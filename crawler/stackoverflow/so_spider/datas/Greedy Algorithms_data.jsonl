{"Question": "Usage examples of greedy algorithms?\r\n                \r\nWhat is the use of greedy algorithms? An real example?\n    ", "Answer": "\r\nMinimum Spanning Tree - Prim's algorithm and Kruskal's algorithm\n\nShortest Path Calculation - Dijkstra's algorithm\n\nMore:\n(Fractional Knapsack Problem, Huffman Coding, Optimal Merging, Topological Sort).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithms and optimal substructure\r\n                \r\nOn Wikipedia page it is said that greedy algorithms are ideal only for problems which have optimal substructure.\n\nQuestions:\n\n\nWhat is optimal/non-optimal substructure?\nWhat is local and global optimum?\nHow to prove that Greedy algorithm yields global optimum?\n\n    ", "Answer": "\r\nI have found the answers and glad to share:\n\n\nWhat is optimal/non-optimal substructure? A problem is said to have optimal substructure if an optimal solution can be constructed efficiently from optimal solutions of its subproblems. This property is used to determine the usefulness of dynamic programming and greedy algorithms for a problem\nWhat is local and global optimum? Local optimum of an optimization problem is a solution that is optimal (either maximal or minimal) within a neighboring set of candidate solutions.\nGlobal optimum - is the optimal solution among all possible solutions, not just those in a particular neighborhood of values.\nHow to prove that Greedy algorithm yields global optimum?\nUsually, global optimum can be proven by induction. Typically, a greedy algorithm is used to solve a problem with optimal substructure if it can be proved by induction that this is optimal at each step. Otherwise, providing the problem exhibits overlapping subproblems as well, dynamic programming is used.\n\n\nTo prove that an optimization problem can be solved using a greedy algorithm, we need to prove that the problem has the following:\n\nOptimal substructure property: an optimal global solution contains the optimal solutions of all its subproblems.\n\nGreedy choice property: a global optimal solution can be obtained by greedily selecting a locally optimal choise.\n\nMatroids can be used as well in some case used to mechanically prove that a particular problem can be solved with a greedy approach.\n\nAnd finally, some good examples of greedy algorithms.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to spot a \"greedy\" algorithm?\r\n                \r\nI am reading a tutorial about \"greedy\" algorithms but I have a hard time spotting them solving real \"Top Coder\" problems.\n\nIf I know that a given problem can be solved with a \"greedy\" algorithm it is pretty easy to code the solution. However if I am not told that this problem is \"greedy\" I can not spot it.\n\nWhat are the common properties and patterns of the problems solved with \"greedy\" algorithms? Can I reduce them to one of the known \"greedy\" problems (e.g. MST)? \n    ", "Answer": "\r\nFormally, you'd have to prove the matroid property of course. However, I assume that in terms of topcoder you rather want to find out quickly if a problem can be approached greedily or not.\n\nIn that case, the most important point is the optimal sub-structure property. For this, you have to be able to spot that the problem can be decomposed into sub-problems and that their optimal solution is part of the optimal solution of the whole problem.\n\nOf course, greedy problems come in such a wide variety that it's next to impossible to offer a general correct answer to your question. My best advice would hence be to think somewhere along these lines:\n\n\nDo I have a choice between different alternatives at some point?\nDoes this choice result in sub-problems that can be solved individually?\nWill I be able to use the solution of the sub-problem to derive a solution for the overall problem?\n\n\nTogether with loads and loads of experience (just had to say that, too) this should help you to quickly spot greedy problems. Of course, you may eventually classify a problem as greedy, which is not. In that case, you can only hope to realize it before working on the code for too long. \n\n(Again, for reference, I assume a topcoder context.. for anything more realistic and of practical consequence I strongly advise to actually verify the matroid structure before selecting a greedy algorithm.)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy algorithms\r\n                \r\nI am new to algorithms and am currently studying using you-tube video tutorials/lectures and a book, I firstly watch the video and then read the book and finally try a question from the book to make sure I have learned the topic correctly. I am currently up to greedy algorithms and it is very confusing.\n\nInside the book there are various problems but I am having trouble understanding and answering a particular one.\n\nFirstly it gives the problem which is (I've just copied the text).\n\nthere is a set of n objects of sizes {x1; x2;..... xn} and a bin with\ncapacity B. All these are positive integers. Try to find a subset of these objects\nso that their total size is smaller than or equal to B, but as close to B as possible.\n\nAll objects are 1-dimensional. For example, if the objects have sizes 4, 7, 10, 12, 15, and\nB = 20, then we should choose 4 and 15 with total size 19 (or equivalently, 7 and 12).\nFor each of the following greedy algorithms, show that they are not optimal by creating\na counter-example. try to make your examples as bad as you can, where \"badness\"\nis measured by the ratio between the optimal and greedy solutions. Thus if the best\nsolution has value 10 and the greedy solution has value 5, then the ratio is 2.\n\nhow do I do this for the following?\n\n1) Always choose the object with the largest size so that the total size of this and all\nother objects already chosen does not exceed B. Repeat this for the remaining objects.\n    ", "Answer": "\r\nAssume the following instance of the problem:\n\nYou have a box of size ```\n2n```\n, one element of size ```\nn+1```\n and the rest are of size ```\nn```\n.\n\nIt is easy to see that the optimal is 2 elements of size ```\nn```\n, while the greedy will get you one element of size ```\nn+1```\n.\n\nSince it is true for each ```\nn```\n, it actually gives you a desired ratio of at least using this greedy approach ```\n2```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is the distinction between local and greedy algorithms?\r\n                \r\nI'm creating a simple LPT heuristic algorithm in python in order to solve a timetabling problem.\n\nThe LPT algorithm I'm employing is greedy. I'm struggling to understand the distinction between greedy algorithms and local algorithms though. From my understanding a greedy algorithm is an example of a local one. Could anyone elaborate on how local and greedy algorithms sit?\n    ", "Answer": "\r\nYou should be able to find a reasonably precise definition of Greedy algorithms, because there is a mathematical theory connecting them with Matroids. For instance, https://people.cs.umass.edu/~barring/cs611/lecture/4.pdf first paragraph says \"A greedy algorithm tries to solve an optimization problem by always choosing a next step that is locally optimal.\" and P 10 describes a generic greedy algorithm which produces an optimal set X by sorting candidates and examining candidates in non-increasing order, adding candidates to X when this does not violate the constraints. If there is a Matroid lurking around behind the scenes, the greedy algorithm will return a globally optimal answer.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is the difference between \"hill climbing\" and \"greedy\" algorithms?\r\n                \r\nPlease explain the difference between \"hill climbing\" and \"greedy\" algorithms. \n\nIt seems both are similiar, and I have a doubts that \"hill climbing\" is an algorithm; it seems to be an optimization. Is this correct?\n    ", "Answer": "\r\nHill-climbing and greedy algorithms are both heuristics that can be used for optimization problems. In an optimization problem, we generally seek some optimum combination or ordering of problem elements. A given combination or ordering is a solution. In either case, a solution can evaluated to compare it against other solutions.\n\nIn a hill-climbing heuristic, you start with an initial solution. Generate one or more neighboring solutions. Pick the best and continue until there are no better neighboring solutions. This will generally yield one solution. In hill-climbing, we need to know how to evaluate a solution, and how to generate a \"neighbor.\"\n\nIn a greedy heuristic, we need to know something special about the problem at hand. A greedy algorithm uses information to produce a single solution.\n\nA good example of an optimization problem is a 0-1 knapsack. In this problem, there is a knapsack with a certain weight limit, and a bunch of items to put in the knapsack. Each item has a weight and a value. The object is to maximize the value of the objects in the knapsack while keeping the weight under the limit.\n\nA greedy algorithm would pick objects of highest density and put them in until the knapsack is full. For example, compared to a brick, a diamond has a high value and a small weight, so we would put the diamond in first. \n\nHere is an example of where a greedy algorithm would fail: say you have a knapsack with capacity 100. You have the following items:\n\n\nDiamond, value 1000, weight 90 (density = 11.1)\n5 gold coins, value 210, weight 20 (density each = 10.5)\n\n\nThe greedy algorithm would put in the diamond and then be done, giving a value of 1000. But the optimal solution would be to include the 5 gold coins, giving value 1050.\n\nThe hill-climbing algorithm would generate an initial solution--just randomly choose some items (ensure they are under the weight limit). Then evaluate the solution--that is, determine the value. Generate a neighboring solution. For example, try exchanging one item for another (ensure you are still under the weight limit). If this has a higher value, use this selection and start over.\n\nHill climbing is not a greedy algorithm.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "The greedy algorithm and implementation\r\n                \r\nHello I've just started learning greedy algorithm and I've first looked at the classic coin changing problem. I could understand the greediness (i.e., choosing locally optimal solution towards a global optimum.) in the algorithm as I am choosing the  highest value of coin such that the\n sum+{value of chosen coin}<=total value . Then I started to solve some greedy algorithm problem in some sites. I could solve most of the problems but couldn't figure out exactly where the greediness is applied in the problem. I coded the only solution i could think of, for the problems and got it accepted. The editorials also show the same way of solving problem but i could not understand the application of greedy paradigm in the algorithm.\n\nAre greedy algorithms the only way of solving a particular range of problems? Or they are one way of solving problems which could be more efficient?\n\nCould you give me  pseudo codes of a same problem with and without the application of greedy paradigm?\n    ", "Answer": "\r\nThere are lots of real life examples of greedy algorithms. One of the obvious is the coin changing problem, to make change in a certain currency, we repeatedly dispense the largest denomination, thus , to give out seventeen dollars and sixty one cents in change, we give out a ten-dollar bill, a five-dollar bill, two one-dollar bills, two quarters , one dime, and one penny. By doing this, we are guaranteed to minimize the number of bills and coins. This algorithm does not work in all monetary systems...more here\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm and coin algorithm?\r\n                \r\nI've been working on some problems/exercises on Project Euler hoping to practice/learn some optimal algorithms and programming idioms with python.\n\nI came across a problem which asked to find all the unique combinations using at least two values to sum to 100.  In researching this problem I came across people referring to the coin problem and the greedy algorithm which is what this question is about.  \n\nI had heard of the greedy algorithm before but, never understood or used it.  I thought I would give it a try.  I still am unsure of whether this is the proper way of doing it. \n\n```\ndef greedy(amount):\n    combos = {}\n    ways = {}\n    denominations = [1,5,10,25]\n    ## work backwards? ##\n    denominations.reverse()\n    for i in denominations:\n    ## check to see current denominations maximum use ##\n        v = amount / i\n        k = amount % i\n    ## grab the remainder in a variable and use this in a while loop ##\n        ways.update({i:v})\n    ## update dictionarys ##\n        combos.update({i:ways})\n        while k != 0:\n            for j in denominations:\n                if j <= k:\n                    n = k/j\n                    k = k % j\n                    ways.update({j:n})\n                    combos.update({i:ways})\n        ways = {}\n    return combos\n```\n\n\nI know this isn't the way to go about solving the Euler question but, I wanted to understand and learn an optimal way to use this algorithm.  My question is, would this be considered a proper greedy-algorithm?  If not what am I doing wrong.   If correct could I improve optimize?\n    ", "Answer": "\r\nThe greedy coin algorithm computes the optimal way to make change for a given amount due.  It works with our denominations of coins but could fail with made up denominations of coins (eg. a 7 cent coin and a 12 cent coin)\n\nhere is a recursive implementation of it\n\n```\n>>> def pickBest(coins,due):\n...     if due == 0: return []\n...     for c in coins:\n...        if c<= due: return [c] + pickBest(coins,due-c)\n...\n>>> coins = [1,5,10,25]\n>>> coins = sorted(coins,reverse=True)\n>>> coins\n[25, 10, 5, 1]\n>>> print pickBest(coins,88)\n[25, 25, 25, 10, 1, 1, 1]\n```\n\n\nhowever I dont think this will help you much with the problem as you stated it\n\nyou would likely want to think of it as a recursive problem\n\n```\n100 = 99 + 1\n100 = 98 + 2  (2 = 1 + 1)\n100 = 98 + (1 + 1)\n100 = 97 + 3 (3 = 1 + 2)\n100 = 97 + 2+1 (recall 2 = 1+1)\n100 = 97 + 1+1 + 1\n...\n```\n\n\nat least thats what I think, I might be wrong..(in fact i think I am wrong)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why does the greedy coin change algorithm not work for some coin sets?\r\n                \r\nI understand how the greedy algorithm for the coin change problem (pay a specific amount with the minimal possible number of coins) works - it always selects the coin with the largest denomination not exceeding the remaining sum - and that it always finds the correct solution for specific coin sets.\n\nBut for some coin sets, there are sums for which the greedy algorithm fails. For example, for the set ```\n{1, 15, 25}```\n and the sum 30, the greedy algorithm first chooses 25, leaving a remainder of 5, and then five 1s for a total of six coins. But the solution with the minimal number of coins is to choose 15 twice.\n\nWhat conditions must a set of coins fulfil so that the greedy algorithm finds the minimal solution for all sums?\n    ", "Answer": "\r\nA set which forms a matroid (https://en.wikipedia.org/wiki/Matroid) can be used to solve the coin changing problem by using greedy approach. In brief, a matroid is an ordered pair \nM = (S,l) satisfying the following conditions:\n\n\nS is a finite nonempty set\nl is a nonempty family of subsets of S, called the independent subsets,such that if B->l\nand A is a subset of B, then A -> l\nIf A-> l, B-> l and |A| < |B|, then there is some element x-> B-A such that A U {x} ->l\n\n\nIn our question of coin changing, S is a set of all the coins in decreasing order value \nWe need to achieve a value of V by minimum number of coins in S\n\nIn our case, l is an independent set containing all the subsets such that the following holds for each subset: the summation of the values in them is <=V\n\nIf our set is a matroid, then our answer is the maximal set A in l, in which no x can be further added\n\nTo check, we see if the properties of matroid hold in the set S = {25,15,1} where V = 30\nNow, there are two subsets in l:\nA = {25} and B= {15,15}\nSince |A| < |B|, then there is some element x-> B-A such that A U {x} ->l (According 3)\nSo, {25,15} should belong to l, but its a contradiction since 25+15>30\n\nSo, S is not a matroid and hence greedy approach won't work on it.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm Nodes\r\n                \r\nI was asked this question on an interview. Can someone give me some insight on how to do this? I was stumped\n\nOften, greedy algorithms they are used as heuristics. An independent set in an\nundirected graph G is a set of nodes I so that no edge has both endpoints\nin I. In other words, if {u,v} included in set E, then either u not included in set I or v not included in set I. The maximum independent set problem is , given G, nd an independent set\nof the largest possible size.\n\nImplement a greedy algorithm for maximum independent set based on\nincluding nodes of smallest degree.\n    ", "Answer": "\r\nYour greedy strategy based on nodes degree can be the following:\n\n```\nI := resulting set\nV := set of unused vertices, initially all vertices\n\nwhile V not empty:\n   v := vertex in V with smallest degree\n   I.add(v)\n   for each u adjacent to v:\n      V.remove(u)\n\nreturn I\n```\n\n\nThe strategy is greedy, because a single decision depends only on the local situation.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Divide and conquer, dynamic programming and greedy algorithms!\r\n                \r\nWhen I have a problem with optimal substructur and no subproblem shares subsubproblems then I can use a divide and conquer algorithm to solve it?\n\nBut when the subproblem shares subsubproblems (overlapping subproblems) then I can use dynamic programming to solve the problem?\n\nIs this correct? \n\nAnd how is greedy algorithms similar to dynamic programming? \n    ", "Answer": "\r\n\n  When I have a problem with optimal\n  substructur and no subproblem shares\n  subsubproblems then I can use a divide\n  and conquer algorithm to solve it?\n\n\nYes, as long as you can find an optimal algorithm for each kind of subproblem.\n\n\n  But when the subproblem shares\n  subsubproblems (overlapping\n  subproblems) then I can use dynamic\n  programming to solve the problem?\n  \n  Is this correct?\n\n\nYes. Dynamic programming is basically a special case of the family of Divide & Conquer algorithms, where all subproblems are the same.\n\n\n  And how is greedy algorithms similar\n  to dynamic programming?\n\n\nThey're different.\nDynamic programming gives you the optimal solution.\nA Greedy algorithm usually give a good/fair solution in a small amount of time but it doesn't assure to reach the optimum.  \n\nIt is, let's say, similar because it usually divides the solution construction in several stages in which it takes choices that are locally optimal. But if stages are not optimal substructures of the original problem, then normally it doesn't lead to the best solution.\n\nEDIT:\n\nAs pointed out by @rrenaud, there are some greedy algorithms that have been proven to be optimal (e.g. Dijkstra, Kruskal, Prim etc.).\nSo, to be more correct, the main difference between greedy and dynamic programming is that the former is not exhaustive on the space of solutions while the latter is.\nIn fact greedy algorithms are short-sighted on that space, and each choice made during solution construction is never reconsidered.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why is this a greedy algorithm?\r\n                \r\nI have this question in my text book:\n\n\" Suppose that we have a set of activities to schedule among a large\nnumber of lecture halls, where any activity can take place in any lecture hall. We wish to schedule all the activities using as few lecture halls as possible. Give an efficient greedy algorithm to determine which activity should use which lecture hall. \"\n\nAnd the answer is given here: \nhttp://mitpress.mit.edu/algorithms/solutions/chap16-solutions.pdf \n\n(the firs solution)\n\nAnd my answer is, why is the algorithm a greedy algorithm?\n\nI think that it is because it makes the (greedy?) choice that you always take an activity and put it into a lecture hall, where there already is one or more activities (if possible), instead of putting the activity into a new empty lecture hall. But I am not sure. :)\n    ", "Answer": "\r\nGreedy means that you don't reconsider your choices. that makes it very hard to come up with an optimal solution, and it describes the algorithm there.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Epsilon-greedy algorithm\r\n                \r\nI understand epsilon-greedy algorithm, but there is one point of confusion. \n\n\nIs it average reward or value that it keeps track of? Most of the time, it is explained in the context of multi-armed bandit. However, there is no distinction of reward / value in the problem of multi-armed bandit.\nis epsilon-greedy algorithm a subset of Q-learning? The vague definition of Q-learning seems to be: approximating the optimal Q-function by utilizing past experiences.\n\n    ", "Answer": "\r\nEpsilon-greedy is a policy, not an algorithm. It is exclusive of discrete action problems: you select the action according to\n\n```\nargmax Q(s,a) with probability 1-epsilon\nrandom otherwise\n```\n\n\nYou can use with Q-learning, SARSA, DDPG, policy gradient, ...\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How is dynamic programming different from greedy algorithms?\r\n                \r\nIn the book I am using Introduction to the Design & Analysis of Algorithms, dynamic programming is said to focus on the Principle of Optimality, \"An optimal solution to any instance of an optimization problem is composed of optimal solutions to its subinstances\".\n\nWhereas, the greedy technique focuses on expanding partially constructed solutions until you arrive at a solution for a complete problem. It is then said, it must be \"the best local choice among all feasible choices available on that step\".\n\nSince both involve local optimality, isn't one a subset of the other?\n    ", "Answer": "\r\nDynamic programming is applicable to problems exhibiting the properties of:\n\n\noverlapping subproblems, and\noptimal substructure.\n\n\nOptimal substructure means that you can greedily solve subproblems and combine the solutions to solve the larger problem.  The difference between dynamic programming and greedy algorithms is that with dynamic programming, there are overlapping subproblems, and those subproblems are solved using memoization.  \"Memoization\" is the technique whereby solutions to subproblems are used to solve other subproblems more quickly.\n\nThis answer has gotten some attention, so I'll give some examples.\n\nConsider the problem \"Making change with dollars, nickels, and pennies.\"  This is a greedy problem.  It exhibits optimal substructure because you can solve for the number of dollars.  Then, solve for the number of nickels.  Then the number of pennies.  You can then combine the solutions to these subproblems efficiently.   It does not really exhibit overlapping subproblems since solving each subproblem doesn't help much with the others (maybe a little bit).\n\nConsider the problem \"Fibonnaci numbers.\"  It exhibits optimal substructure because you can solve F(10) from F(9) and F(8) efficiently (by addition).  These subproblems overlap because they both share F(7). If you memoize the result of F(7) when you're solving F(8), you can solve F(9) more quickly.\n\nIn response to the comment about dynamic programming having to do with \"reconsidering decisions\":  This is obviously not true for any linear dynamic programming algorithm like the maximum subarray problem or the Fibonacci problem above.\n\nEssentially, imagine a problem having optimal substructure as a directed acyclic graph whose nodes represent subproblems (wherein the whole problem is represented by a node whose indegree is zero), and whose directed edges represent dependencies between subproblems.  Then, a greedy problem is a tree (all nodes except the root have unit indegree).  A dynamic programming problem has some nodes with indegree greater than one.  This illustrates the overlapping subproblems.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Local maximum vs global maximum in greedy algorithms\r\n                \r\nIn our algorithms class, the professor said that if while implementing a greedy algorithm we stuck in local maximum and thus assume that no more improvement is possible, then it might result in unsuccessful implementation. Can somebody give an example of when this can happen?\n    ", "Answer": "\r\nimagine you need to find maximum number in an array, that has cohesive values(something like landscape, difference between near fields can't be higher than 1). You don't want to check all values for performance reasons you could try a simple greedy algorithm like: check a near-values, if its higher, go in this direction, if its lower go to another direction:\n\n```\npublic static void findHighestValue(int[] landscape){\n    boolean leftChecked = false;\n    boolean rightChecked = false;\n    // we start in the middle of that array\n    int currentIndex = landscape.length / 2;\n    // do work until both directions are checked\n    while(!leftChecked || !rightChecked){\n        //check left boundary\n        if(currentIndex == 0)\n            leftChecked = true;\n        //check right bound\n        if(currentIndex == landscape.length - 1)\n            rightChecked = true;\n        //first check if left value is equal or higher then current value\n        if(!leftChecked){\n            if(landscape[currentIndex - 1] >= landscape[currentIndex]){\n                currentIndex--;\n            } else {\n                leftChecked = true;\n            }\n        } else if(!rightChecked) {\n            //same for right side\n            if(landscape[currentIndex + 1] >= landscape[currentIndex]){\n                currentIndex++;\n            } else {\n                leftChecked = true;\n            }\n        }\n    }\n    //print the result\n    System.out.println(\"local maximum at index: \" + currentIndex);\n}\n```\n\n\nnow try to call that mehtod with values like: {1,1,2,3,4,5,4,4,3,2,3,4,5,6,7,6,5}. Depending on the start-point of the algorithm, it will find 5 as local-maximum or 7 as global maximum \n\nas you can see this algorithm will go to a local maxmum and won't be able to leave it\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy algorithms and arrays\r\n                \r\nThe problem of scheduling n jobs of known durations t1,t2,...tn for execution on a single processor. The jobs can be executed in any order, one job at a time. \nwe want to find a schedule that minimizes the total time spend by all the jobs in this system. The time spent by one job is the sum of the time spent on waiting plus the time spent on its execution. Design a greedy algorithm for this problem.\n\n....so far i am thinking i have to get the shortest jobs first and to get that i would have to sort the array , but is it a single array ? \n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm set cover\r\n                \r\nIn the below instance of set cover. How many sets the greedy algorithm will pick?. All sets have cost 1.\n\nCan anyone explain me. What is the solution for this question.\n\nSo how will be greedy algorithm works for the 2nd instance.\n\n\n\nhow many sets it picks in the instance.\n    ", "Answer": "\r\nConsidering that greedy algorithm selects the best set each time if it this is determined by the number of points in each set it would first take the largest.\n\nAfter it takes one it will remove the points which overlap from the remaining sets and again select the largest. So the remaining set would look like:\n\n\nTherefore it should be 3 sets in the folding order:\n\n\n\nThis is a good problem which illustrates how it doesn't perform optimally because there is a possibility to solve the problem by taking only 2 sets. You can read a bit more here:\nhttp://pages.cs.wisc.edu/~shuchi/courses/787-F07/scribe-notes/lecture02.pdf \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithms: \"expression result unused\"\r\n                \r\nI am trying to do a greedy algorithm for CS50, but for some reason I keep getting errors saying \"expression result unused\" when trying to divide the total sum of cents by 25, 10, 5, etc. Would someone be able to pinpoint where I am going wrong? Thank you so much in advance. \n\n```\n#include <cs50.h>\n#include <stdio.h>\n#include <math.h>\n\nint main(void)\n{\nfloat Change;\nint quarters = 25;\nint dimes = 10;\nint nickels = 5;\nint pennies = 1;\nint count = 0;\n\ndo\n{\n    Change = get_float(\"Change: \");\n}\nwhile (Change < 0);\n\nint cents = round(Change * 100);\n\nwhile (cents % 25 >= 25)\n { \n    cents/25;\n    count = count + 1;\n }\n\n\n while (cents % 10 >= 10)\n {\n     cents/10;\n     count = count + 1;\n }\n\n\nwhile (cents % 5 >= 5)\n{\n    cents/5;\n    count = count + 1;\n}\n\n\nwhile (cents % 1 >= 1)\n{\n    cents/1;\n    count = count + 1;\n}\n\n\nprintf(\"%d coins\", count);\n\n}\n```\n\n    ", "Answer": "\r\nWrong compare\n\nThe following is never true.  ```\ncents % 25```\n, the remainder after division, is always less than 25.\n\n```\nwhile (cents % 25 >= 25)\n```\n\n\nUseless code\n\nThe below divides by 25 then discards the quotient. @Some programmer dude\n\n```\ncents/25;\n```\n\n\n\n\nInstead in the 25, 10, 5, 1 places\n\n```\n// while (cents % 25 >= 25)\nwhile (cents >= 25)\n\n// cents/25;\ncents -= 25;\n```\n\n\n\n\nMore efficient code possible.  Hint: ```\nwhile```\n loops not needed.\n\n\n\nGood to convert input to integers.\n\nDeeper:\n\n```\nint cents = round(Change * 100);```\n produces a ```\nfloat```\n product from ```\nChange * 100```\n, then converts to ```\ndouble```\n in calling ```\nround(double)```\n.  Lastly it converts the results to ```\nint```\n as part of the assignment.\n\nCould have used ```\nroundf(float)```\n and skip the ```\ndouble```\n conversion.\n\nFor learner code this is a good start.  Note that ```\nChange * 100```\n can causes a rounding error which would show itself in select cases near a half cent.  Suggest ```\nround(Change * 100.0)```\n\n\nPerhaps use ```\nlong lround(double x)```\n to expiate the final conversion from ```\ndouble```\n to an integer.\n\nNote that excessively large input causes overflow and undefined behavior.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Iterative Greedy Algorithm Explaination [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nCould anyone explain the Iterative Greedy Algorithm with example, and kindly briefly explain the Construction and Destruction process... \n    ", "Answer": "\r\nGreedy is not an algorithm, but a term, used for many different algorithms. It means that looking for a sequence of elements that fulfill some condition, we take a longer possible sequence. The antonym, lazy, means choosing the first found sequence. \n\nBoth terms are not mathematically strict, they only help to better understand what we are talking about. They have an exact sense only in some context.\n\nLook for greedy term in regex explanation, for example. \n\n\n  A greedy algorithm is any algorithm that follows the problem-solving\n  heuristic of making the locally optimal choice at each stage with\n  the intent of finding a global optimum.\n\n\n(https://en.wikipedia.org/wiki/Greedy_algorithm)\n\nMore easily, greedy means taking some branch and NOT checking it for throwing it off. \n\nAgain, being greedy does not mean anything exact, it only about the classification of similar algorithms. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm in JAVA. Implementation issues\r\n                \r\nI have to develop a project in which I have to use greedy algorithm. The purpose of using greedy to select the best node. \n\nMy project detail. I have a server in GUI in which I have to send some data to 8 clients. So using greedy I have to send to the best 2 nodes. This best 2 nodes are selected on the connectivity with other nodes and its path weight.I know what are greedy algorithms but not having idea how to implement it in java according to my project. How to select the best nodes. My idea is storing the nodes information like connectivity,total number of bytes sent in the data base and using greedy to select the best. Can you guide me which is best greedy Algo to do this?\n\nThanks Ameer\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is the Best Complexity of a Greedy Algorithm?\r\n                \r\nIt seems like the best complexity would be linear O(n). \n\nDoesn't matter the case really, I'm speaking of greedy algorithms in general.\n\nSometimes it pays off to be greedy?\n\nIn the specific case that I am interested would be computing change.\n\nSay you need to give 35 cents in change. You have coins of 1, 5, 10, 25. The greedy algorithm, coded simply, would solve this problem quickly and easily. First grabbing 25 cents the highest value going in 35 and then next 10 cents to complete the total. This would be best case. Of course there are bad cases and cases where this greedy algorithm would have issues. I'm talking best case complexity for determining this type of problem.\n    ", "Answer": "\r\nAny algorithm that has an output of ```\nn```\n items that must be taken individually has at best ```\nO(n)```\n time complexity; greedy algorithms are no exception.  A more natural greedy version of e.g. a knapsack problem converts something that is NP-complete into something that is ```\nO(n^2)```\n--you try all items, pick the one that leaves the least free space remaining; then try all the remaining ones, pick the best again; and so on.  Each step is ```\nO(n)```\n.  But the complexity can be anything--it depends on how hard it is to be greedy.  (For example, a greedy clustering algorithm like hierarchical agglomerative clustering has individual steps that are ```\nO(n^2)```\n to evaluate (at least naively) and requires ```\nO(n)```\n of these steps.)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm in \"C\"\r\n                \r\nI'm just start learning ```\nC language```\n. I wrote this C code to implement Greedy algorithm\nI don't know what mistake I've made with this code, that code seems fine but its not working as I expected. Can anybody help me to fix this code?\n\n```\nint main(void) {\n    float amount = 0;\n    int cents = 0;\n    int count = 0;\n    int amount_left = 0;\n\n    amount = .30;\n\n    cents = (int)round(amount * 100);\n\n    printf(\"%d\", cents);\n\n    amount_left = cents;\n\n    while (cents - 25 >= 0) {\n        count = count + 1;\n        amount_left = cents - 25;\n    }\n    while (amount_left - 10 >= 0) {\n        count = count + 1;\n        amount_left = amount_left - 10;\n    }\n    while (amount_left - 5 >= 0) {\n        count = count + 1;\n        amount_left = amount_left - 5;\n    }\n    while (amount_left - 1 >= 0) {\n        count = count + 1;\n        amount_left = amount_left - 1;\n    }\n    printf(\"You get %d coins\\n\", count);\n}\n```\n\n    ", "Answer": "\r\nNotes about the problems in the code:\n\n\nYou are using in the first loop ```\ncents```\n when there would be ```\namount_left```\n, in the case of the first loop if it require more that one iteration, the result would be incorrect.\nAs recommended is better to change ```\namount_left - 10 >= 0```\n by ```\namount_left >= 10```\n.\nThe final ```\nprintf```\n statement most probably (by the text) is for printing the count of coin gained by the amount provided.\n\n\nCode:\n\n```\n#include <stdio.h>\n#include <math.h>\n\nint main(void) {\n    float amount = 0;\n    int cents = 0;\n    int count = 0;\n    int amount_left = 0;\n\n    amount = .30;\n\n    cents = (int)round(amount * 100);\n\n    printf(\"%d\\n\", cents);\n\n    amount_left = cents;\n\n    while (amount_left >= 25) {\n        count++;\n        amount_left -= 25;\n    }\n    while (amount_left >= 10) {\n        count++;\n        amount_left -= 10;\n    }\n    while (amount_left >= 5) {\n        count++;\n        amount_left -= 5;\n    }\n    while (amount_left >= 1) {\n        count = count + 1;\n        amount_left -= 1;\n    }\n    printf(\"You get %d coins\\n\", count);\n}\n```\n\n\nUsing the formula: ```\ninitial_amount```\n = ```\ncoin value```\n * ```\ncoin used```\n + ```\namount_left```\n\n\nThis could be write in C as:\n\n\n```\ninitial_amount```\n / ```\ncoin value```\n = ```\ncoin used```\n\n```\ninitial_amount```\n % ```\ncoin value```\n = ```\namount_left```\n\n\n\nMore optimized solution:\n\n```\n#include <stdio.h>\n#include <math.h>\n\nint main(void) {\n    float amount = 0;\n    int cents = 0;\n    int count = 0;\n    int amount_left = 0;\n\n    amount = .30;\n\n    cents = (int)round(amount * 100);\n\n    printf(\"%d\\n\", cents);\n\n    amount_left = cents;          // beginning with 30 cents\n\n    count += amount_left / 25;    // 30 / 25 = 1,      one 25 cent coin\n    amount_left %= 25;            // 30 % 25 = 5,      left with 5 cents\n\n    count += amount_left / 10;    // 5 / 10 = 0        no coin used\n    amount_left %= 10;            // 5 % 10 = 5        left the same 5 cents\n\n    count += amount_left / 5;     // 5 / 5 = 1         one 5 cent coin\n    amount_left %= 5;             // 5 % 5 = 0         left with 0 cents\n\n    count += amount_left;        // not needed 1 cent coins.\n\n    printf(\"You get %d coins\\n\", count);\n}\n```\n\n\nNotes:\n\n\nThere is no need to ```\nwhile loop```\n operation ```\n17 / 5 = 3```\n in integers arithmetic in ```\nC```\n and ```\n17 % 5 = 2```\n.\nUsing this you use for a coin of value ```\nN```\n, ```\namount / N```\n coins count (could be 0, eg: ```\namount = 9```\n and ```\nN = 10```\n, ```\n9/10 = 0```\n in integer division) and the amount left is ```\namount % N```\n.\nThe last case (for coin of 1) always left ```\namount = 0```\n.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for the following\r\n                \r\nI am trying to solve the following problem using Greedy Algorithm,\n\nWe have ```\nn```\n friends and we want to give a present to each one of them. But we don't want to give the same present to two person who know each other. (if x knows y, then y knows x). People who do not know each other may take the same gift, it is okay. We want to minimize the number of distinct gifts given.\n\nHere is what I thought, We try to make pairs of people who do not know each other, and give them all the same gift. But I am not sure whether this is a greedy algorithm. Also, we may want to find maximum group of people in which no one knows any other, so we can give hem the same gift. But can we do this? Can we find the maximum group of people who do not know each other?\n\nCan anyone propose a greedy algorithm for the problem?\n    ", "Answer": "\r\nThe problem you have mentioned is a restatement of ```\nGraph Coloring```\n problem. You have to label the graph’s vertices with colors such that no two vertices sharing the same edge have the same color.  The link given below is to the ```\nGreedy Coloring Algorithm```\n.  \n\nhttp://en.wikipedia.org/wiki/Greedy_coloring\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm in C\r\n                \r\nSo I started learning C for 2 days in the course of CS50. In week #2 problem set there was a challenge of coding for the Greedy Algorithms which basically giving back to the customer their change at a minimum amount of coins. \nHere is my solution for it writen in CS50 sandbox. \n\n```\n#include <stdio.h>\n#include <cs50.h>\n#include <math.h>\n\nint main(void)\n{\n    //Assign value\n    int q = 0; int d = 0; int n = 0; int p =0;\n    int left;\n    int count = 0;\n    float change;\n\n    // Promting user for change.\n    do\n    {\n       change = get_float(\"Change:\");\n    }\n    while(change < 0);\n\n    // Convert cent to dollar.\n    int cent = round(change * 100);\n    printf(\"Dollar %i\\n\", cent);\n\n    //Counting coin\n    while(cent >=25)\n    {\n        q++;\n        left = cent - 25;\n    }\n    while(left >=10)\n    {\n        d++;\n        left = left -10;\n    }\n    while(left >=5)\n    {\n        n++;\n        left = left -5;\n    }\n    while(left >=1)\n    {\n        p++;\n        left=left-1;\n    }\n    count = q + d + n + p;  \n    printf(\"Total coin: %i\\n\", count);\n}\n```\n\n\nI run the code by the CS50 Terminal in the CS50 sandbox and get this error:\n\n```\ncash.c:27:10: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'\n```\n\n\nI understand that my loop goes over the limitation of storing data in int. But I cannot find a way to fix it.\n    ", "Answer": "\r\nYou have this:\n\n```\nwhile(cent >=25) \n    q++;\n    left = cent - 25;\n}\n```\n\n\nIf ```\ncent```\n is originally 25 of greater, will this loop ever end? ```\ncent```\n never changes, so no. The other loops are fine, so all you have to do is use the same pattern you used for the other loops for this one too.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm or dynamic programming?\r\n                \r\nThere is list l = [x_1, ..., x_n] given. Every element of the list is the length of some piece of wood. To glue two pieces of wood, of lengths a and b you need max(a,b) of glue. After glueing, you got one piece of wood of length a+b. Compute minimum amount of glue to glue all the pieces.\n\nDo you think greedy algorithm works here? I can't think of any example. Saying greedy algorithm I mean: take two pieces of minimal length, glue them and do that until all pieces are glued. Using some priority queue, this can be done in O(n log n) complexity.\n\nDoes that work? If not, give me please some example of list l, which can be glued in smaller amount of glue than greedy algorithm would say.\n    ", "Answer": "\r\nThe greedy algorithm won't always be optimal.  A counter example is [1, 2, 2, 3], for which the greedy algorithm will use 10 units of glue and the optimal will use 9 units.  \n\nGreedy Algorithm:\n\n```\n1-2 = 2 glue\n2-3 = 3 glue\n3-5 = 5 glue\n---------------\ntotal = 10 glue\n```\n\n\nOptimal:\n\n```\n2-2 = 2 glue\n1-3 = 3 glue\n4-4 = 4 glue\n--------------\ntotal = 9 glue\n```\n\n\nDynamic programming it is.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "CS50 greedy algorithm\r\n                \r\nI just started C programming with cs50. \n\nI tried to do the problem set about the greedy algorithm but can't seem to find the bug. My code is below.\n\n```\n#include <cs50.h>\n#include <stdio.h>\n#include <math.h>\n\n\nint main (void)\n{\n\nint count = 0;\n\nprintf(\"how much is the change?: \");\n\nfloat change = get_float();\n\nwhile(change < 0)\n{\n   printf(\"change is to be more than 0\");\n   change = get_float();\n }\n\nint amount = lroundf(change*100);\n\nwhile(amount > 0)\n{\n  if ((amount-25) >= 25)\n  {\n      amount  =  amount - 25;\n      count++;\n  }\n\n  else if ((amount-10) >= 10)\n  {\n      amount =  amount - 10;\n      count++;\n  }\n\n  else if ((amount-5) >= 5)\n  {\n      amount = amount -5;\n      count++;\n  }\n\n  else if((amount-1) >= 1)\n  {\n      amount = amount -1;\n      count ++;\n      break;\n  }\n\n  else\n  {\n   printf(\"you have no change \\n\");   \n  }\n  }\n  printf(\"your number of coins is %i\\n\", count);\n\n  }\n```\n\n\nWhen I input my change as 1, I am given back 8 coins. Can't seem to find where the bug is. Can anyone help me?\n    ", "Answer": "\r\nFirstly, you could try running your program with values for ```\nchange```\n that return simple answers, like 1 coin, using, for example, ```\nchange = 0.25```\n. If that works, then you should start trying with some few coins, repeating one type, like you did with ```\n1.00```\n, or joining a few types, like ```\n0.06```\n . And after that, try big numbers and values with higher floating inaccuracy, like ```\n4.10```\n. Following this should lead you to your answers.\n\nIf, after trying that, you still can't find the problem, then here is the answer: the problem is with the ```\nif```\n/```\nelse if```\n expressions. When you are trying to count the quarters, for example, the ```\n(amount-25) >= 25```\n doesn't work properly. You're trying to take away a quarter while ```\namount```\n is bigger or equal to 25, but your code just do that until it gets to less than 50. Developing your expression may help you see it: ```\n(amount-25) >= 25```\n -> ```\n(amount-25) + 25 >= 25 + 25```\n -> ```\namount >= 50```\n.\n\nAnother problem you may find is with that ```\nbreak```\n statement. It might get out from the loop earlier than expected. If you try running numbers like ```\n0.04```\n and ```\n0.03```\n you'll see the count stuck at ```\n1```\n. After removing the first penny, the code breaks out of the loop leaving ```\namount```\n still bigger than 0. ```\nbreak```\ns make it harder to see when the code is getting out of the loop and that's why many programmers recommend avoiding it whenever possible.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Solving Heuristically Using Greedy Algorithm\r\n                \r\nI have a question on a test review thats asks \"Which of the following is solved heuristically by a greedy method?\"\n\nA. Unweighted interval scheduling\n\nB. 0/1 knapsack\n\nC. Fractional knapsack\n\nD. Huffman code\n\nI'm was able to narrow it down to A,C, or D because I know 0/1 knapsack use Dynamic programing. My best guess would be C because I THINK A and D can be solved optimally using greedy algorithms. \n\nIs this correct?\n    ", "Answer": "\r\nYes it's correct.\n\nThe Fractional knapsack problem can be solved by choosing greedily.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy algorithm, scheduling\r\n                \r\nI am trying to understand how Greedy Algorithm scheduling problem works.\n\nSo I've been reading and googling for a while since I could not understand Greedy algorithm scheduling problem.\n\nWe have n jobs to schedule on a single resource. The job (i) has a requested start time s(i) and finish time f(i).\n\nThere are some greedy ideas which we select...\n\n\nAccept in increasing order of s (\"earliest start time\")\nAccept in increasing order of f - s (\"shortest job time\")\nAccept in increasing order of number of conflicts (\"fewest conflicts\")\nAccept in increasing order of f (\"earliest finish time\")\n\n\nAnd the book says the last one, accept in increasing order of f will always gives an optimal solution.\n\nHowever it did not mention why it always gives optimal solution and why other 3 will not give optimal solution.\n\nThey provided the figure that says why other three will not provide optimal solution but I could not understand what it means.\n\nSince I have low reputation, I can not post any image so I will try to draw it.\n\n　|---| |---| |---|\n|-------------------------|\n     increasing order of s\nunderestimated solution\n\n|-----------| |-----------|\n          　　　|-----|\n      increasing order of f-s\nunderestimated solution\n\n|----|　 |----|　|----| 　|----|\n\n　|-----|　|-----|　|-----| \n\n　|-----|　　　　|-----|\n\n　|-----|　　　　|-----|\n\nincreasing order of number of conflicts.\nunderestimated solution\n\nThis is what it looks like and I don't see why this is a counterexample of each scenario.\n\nIf anyone can explain why each greedy idea does/ does not work, it will be very helpful.\n\nThank you.\n    ", "Answer": "\r\nI think I can explain this.\nLets say, we have ```\nn```\n jobs, start times as ```\ns[1..n]```\n and finish times as ```\nf[1..n]```\n. So if we sort it according to finish times, then, we will always be able to complete most number of tasks. Lets see, how.\n\nIf a job is finishing earlier (even if it started later in the series, a short job), then, we always have more time for later jobs. Lets assume, we have other jobs that we could start/complete in this interval so that our number of tasks could increase. Now, this is not actually possible as if any task completed before this, then that would be the one with earliest finish time so we would be working on that one. And, if any task has not been completed till now (but has started), then if we selected that, we would not have completed any task but now we actually have done one at least. So, in any case, this is the most optimal choice. \nThere are many possible solutions with maximum number of tasks that can be done in an interval, EFT gives one such solution. But it is always the max  number possible.\n\nI hope I could explain it well.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithms: cost minimisation\r\n                \r\nI'm struggling with the following greedy algorithm I wrote; I know my algorithm is not complete, but I really don't know to improve it.:\n\n```\nAlgorithme minCost()\n\nwhile j<n (while all the licences have not been yet bought)\nj=next licence bought\nIf the licence of the current month is available then\nbuy\nEndIf\nEndWhile\n```\n\n\nThis the formulation of the problem:\nTo market its various products, a company needs \"n\" licenses. Because of certain laws, it can not get more than one permit per month. In addition, the cost of permits increase\neach month. Indeed, although the cost of each permit is $100.00 currently, the cost of the permit j, (1 ≤ j ≤ n) increases by a factor rj> 1 each month (the rj are parameters).\nIn other words, buy the license in the first four months costs 100r4 while its acquisition during the fith month, for example, would cost $ 100(r3)^5. Finally, we assume that ri is different of rj for i different of j.\nThe question then is, for a given set of rj (1 ≤ j ≤ n), in what order to buy the \"n\" permits to minimize the total cost of ownership.\n1. Develop a polynomial algorithm using greedy approach, for solving this problem. Analyze your algorithm in worst case.\n2. Prove that your algorithm returns the optimal solution well.\n3. Illustrate your algorithm on the following instance: n = 3, r1 = 3, r2 = 4, r3 = 2.\n\nThanks\n    ", "Answer": "\r\n```\nAlgorithme minCout(A[1, ..., n], B[])\n//A[1, ..., n]: table storing the rj values of the licenses cost\n//B[]: empty table to store selected licences cost for buy\nQuickSort(A[1, ..., n])\n//A[1, ..., n] is now sorted in decreasing order\n\n while j < n (while all the licences have not been yet bought) do\n    for i ← 1 to n (Check all the available licences cost) do\n    if ri < ri+1 (choose the highest license cost) then\n    A[i ] = i + 1 (buy now the highest cost licence)\n    end\n    j = j + 1 (check the next licence to buy)\n    end\n    end\nReturn A[i]\n```\n\n\nNormally the number of licences must decrease as longer as I'm selecting the licences of the highest cost and store them into table B. In addition, as I'm reviewing the cost of the licences, I must not review again the full part of table A. Then, how can I write then a recursive version of this algorithm that can allow me to consider what I'm just mentionned? Thank you.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm in JavaScript\r\n                \r\nHere is the question that I need to consult for help:\n\n\n  Write a greedy algorithm to make change with the fewest coins possible\n  using the Greedy Algorithm. You are given an array of coin values and\n  an amount: ```\ncomputeChange(coins, amount)```\n. Return an array with the\n  counts of each coin.\n  \n  For example:   ```\ncomputeChange([50, 25, 10, 5, 1], 137)```\n should return\n  the array ```\n[2, 1, 1, 0, 2]```\n which indicates how many of each coin: 2\n  50-cent pieces, 1 quarter (25 cents), 1 dime (10 cents), no nickels (5\n  cents), and 2 pennies (1 cent), which add up to 137 cents.\n  \n  The array you return from computeChange should be the same length as\n  the first argument (coins). Assume that coins contains the values of\n  different coin types in decreasing order.\n  \n  The greedy algorithm says that you repeatedly look for the largest\n  coin less than or equal to the remaining amount of money, then\n  subtract that coin from the remaining amount. When the remaining\n  amount reaches zero (or less), return the counts of coins used. (This\n  algorithm is not always optimal.)\n  \n  You can change the variables ```\nCOINS```\n, which gives the values of the\n  different coins you can use to make change, and ```\nAMOUNT```\n, which is the\n  total value of the change to make. Changing these values might be\n  useful for debugging your program.\n\n\nHere is my code which I did but it did not display the standard change for 36 cents. Can anyone help me? Thank you.\n\n```\n<html>\n<head>\n    <title>The Greedy Algorithm</title>\n\n    <script>\n\n// ======== Here is the problem to be solved:   ========\nCOINS = [50, 25, 10, 5, 1];\nAMOUNT = 137\ncoincount = [0,0,0,0,0];\n\n// ======== Here is where your solution begins: ========\n\n// define the function named computeChange here:\nfunction computeChange(coins, amount) {\n  var i = 0; var creminder = AMOUNT; var ccoin; \n\n    while( i < COINS.length )\n    {\n      while ( COINS[i] <= creminder )\n      {\n        creminder = creminder - COINS[i];\n        ccoin = coincount [i] ;\n        ccoin += 1;\n        coincount [i] = ccoin ;\n\n      }\n\n      i++;\n    }\n\n    return coincount;\n}\n\n// ===================================================================\n// ======== Everything below here simply displays your output ========\n// ======== Do NOT change anything below this line ===================\n// ===================================================================\n\n\nfunction rightJustify(s, w) {\n    // return a string of width w with s in the rightmost characters and\n    // at least one space on the left. For simplicity, assume w < 20.\n    var slen = s.length;\n    var blanks = \"                    \"\n    return blanks.substr(0, Math.min(20, Math.max(1, w - slen))) + s;\n}\n\n\nfunction makeChange() {\n    // compute change as an array: each element of change tells\n    // how many of the corresponding value in COINS to give. The\n    // total value should equal AMOUNT.\n    var change = computeChange(COINS, AMOUNT);\n    // now format the results. Output should look like:\n    // NUMBER   VALUE\n    //    1       50\n    //    0       25\n    //    1       10\n    //    1        5\n    //    3        1\n    // TOTAL AMOUNT: 68 (total is correct)\n    //\n    // First, we'll do some type checking in case change is not of the\n    // expected type.\n    change = [].concat(change); // force whatever it is to be an array\n    // it should be an array of numbers, so let's check\n    for (i = 0; i < change.length; i++) {\n        if (typeof(change[i]) != 'number') {\n            return \"Error: the function computeChange did not return \" +\n                   \"an array of numbers.\";\n        }\n    }\n    if (change.length > COINS.length) {\n        return \"Error: the function computeChange returned an array \" +\n               \"longer than the length (\" + COINS.length + \") of COINS.\";\n    }\n    if (change.length < COINS.length) {\n        return \"Error: the function computeChange returned an array \" +\n               \"shorter than the length (\" + COINS.length + \") of COINS.\";\n    }\n    var output = \"<pre>NUMBER   VALUE\\n\"\n    var sum = 0;\n    for (i = 0; i < change.length; i++) {\n        sum += change[i] * COINS[i];\n        var n = change[i].toString();\n        var a = COINS[i].toString();\n        output += rightJustify(n, 4) + rightJustify(a, 9) + \"\\n\";\n    }\n    output += \"TOTAL AMOUNT: \" + sum + \" (total is \";\n    output += (sum == AMOUNT ? \"correct\" :\n                               \"incorrect, should be \" + AMOUNT) + \")\\n\";\n    return output;\n}\n\n\nfunction runSolution()\n{\n    parent.console.log('loaded, calling runSolution()\\n');\n    parent.console.log('answer: ' + document.getElementById('answer').toString());\n    document.getElementById('answer').innerHTML = makeChange();\n}\n\n    </script>\n</head>\n<body>\n    <!-- the output is displayed using HTML     -->\n    <!-- the ? will be replaced with the answer -->\n    <div id = \"answer\">?</div></p>\n    <br>\n    <script>runSolution();</script>\n</body>\n</html>\n```\n\n    ", "Answer": "\r\nThoughts:\nAfter reading the replys, first at thought is that this may be used to other codes that we didn't see here, so we need to make the function sufficient to solve the question by input, not using the ```\nGLOBAL VALUES```\n like ```\nAMOUNT```\n, ```\nCOINS```\n and ```\ncoincount```\n, instead, use params given like ```\ncoins```\n and ```\namount```\n, and return a self created ```\ncoincount```\n.\n\nI'll explain this directly use comments in the codes\n\n```\nfunction computeChange(coins, amount) {\n    // Create a array that is used to return the final result, instead of the global one.\n    var coincount = [];\n\n    // use the given `amount` to set `creminder ` rather than `AMOUNT` which may not be accessible if your code is called otherplace rather than here.\n    var i = 0; var creminder = amount; var ccoin;\n\n\n    while( i < coins.length )\n    { \n      // Lazily init the used coin for coin type i to 0.\n      coincount[i] = 0;\n      while ( coins[i] <= creminder )\n      {\n        creminder = creminder - coins[i];\n        ccoin = coincount[i];\n        ccoin += 1;\n        coincount[i] = ccoin;\n      }\n\n      i++;\n    }\n\n    return coincount;\n}\n```\n\n\nYour origin version's ```\ncreminder```\n is determined by ```\nAMOUNT```\n, so no matter I call ```\ncomputeChanges(COINS, AMOUNT)```\n or ```\ncomputeChanges(COINS, 37)```\n, the result will be the same, because the ```\n37```\n in the second example is not used, ignored and ```\ncreminder```\n is still set to ```\nAMOUNT```\n. Both Nina Scholz and I do is to make that given ```\namount```\n account, so it matters when your function generates a result set.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How does this code involved in this algorithm(Greedy Algorithms/MST)\r\n                \r\nI was trying to learn this algorithm , \nI could follow how it works and I understood most of lines since it depends on previous tutorials , here is a link explaining the algorithm\nhttps://www.cdn.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\n\nand here is the algorithm \n\n```\n  class Graph\n {\n    // A class to represent a graph edge\nclass Edge implements Comparable<Edge>\n{\n    int src, dest, weight;\n\n    // Comparator function used for sorting edges \n    // based on their weight\n    public int compareTo(Edge compareEdge)\n    {\n        return this.weight-compareEdge.weight;\n    }\n};\n\n// A class to represent a subset for union-find\nclass subset\n{\n    int parent, rank;\n};\n\nint V, E;    // V-> no. of vertices & E->no.of edges\nEdge edge[]; // collection of all edges\n\n// Creates a graph with V vertices and E edges\nGraph(int v, int e)\n{\n    V = v;\n    E = e;\n    edge = new Edge[E];\n    for (int i=0; i<e; ++i)\n        edge[i] = new Edge();\n}\n\n// A utility function to find set of an element i\n// (uses path compression technique)\nint find(subset subsets[], int i)\n{\n    // find root and make root as parent of i (path compression)\n    if (subsets[i].parent != i)\n        subsets[i].parent = find(subsets, subsets[i].parent);\n\n    return subsets[i].parent;\n}\n\n// A function that does union of two sets of x and y\n// (uses union by rank)\nvoid Union(subset subsets[], int x, int y)\n{\n    int xroot = find(subsets, x);\n    int yroot = find(subsets, y);\n\n    // Attach smaller rank tree under root of high rank tree\n    // (Union by Rank)\n    if (subsets[xroot].rank < subsets[yroot].rank)\n        subsets[xroot].parent = yroot;\n    else if (subsets[xroot].rank > subsets[yroot].rank)\n        subsets[yroot].parent = xroot;\n\n    // If ranks are same, then make one as root and increment\n    // its rank by one\n    else\n    {\n        subsets[yroot].parent = xroot;\n        subsets[xroot].rank++;\n    }\n}\n\n// The main function to construct MST using Kruskal's algorithm\nvoid KruskalMST()\n{\n    Edge result[] = new Edge[V];  // Tnis will store the resultant MST\n    int e = 0;  // An index variable, used for result[]\n    int i = 0;  // An index variable, used for sorted edges\n    for (i=0; i<V; ++i)\n        result[i] = new Edge();\n\n    // Step 1:  Sort all the edges in non-decreasing order of their\n    // weight.  If we are not allowed to change the given graph, we\n    // can create a copy of array of edges\n    Arrays.sort(edge);\n\n    // Allocate memory for creating V ssubsets\n    subset subsets[] = new subset[V];\n    for(i=0; i<V; ++i)\n        subsets[i]=new subset();\n\n    // Create V subsets with single elements\n    for (int v = 0; v < V; ++v)\n    {\n        subsets[v].parent = v;\n        subsets[v].rank = 0;\n    }\n\n    i = 0;  // Index used to pick next edge\n\n    // Number of edges to be taken is equal to V-1\n    while (e < V - 1)\n    {\n        // Step 2: Pick the smallest edge. And increment \n        // the index for next iteration\n        Edge next_edge = new Edge();\n        next_edge = edge[i++];\n\n        int x = find(subsets, next_edge.src);\n        int y = find(subsets, next_edge.dest);\n\n        // If including this edge does't cause cycle,\n        // include it in result and increment the index \n        // of result for next edge\n        if (x != y)\n        {\n            result[e++] = next_edge;\n            Union(subsets, x, y);\n        }\n        // Else discard the next_edge\n    }\n\n    // print the contents of result[] to display\n    // the built MST\n    System.out.println(\"Following are the edges in \" + \n                                 \"the constructed MST\");\n    for (i = 0; i < e; ++i)\n        System.out.println(result[i].src+\" -- \" + \n               result[i].dest+\" == \" + result[i].weight);\n}\n\n// Driver Program\npublic static void main (String[] args)\n{\n\n    /* Let us create following weighted graph\n             10\n        0--------1\n        |  \\     |\n       6|   5\\   |15\n        |      \\ |\n        2--------3\n            4       */\n    int V = 4;  // Number of vertices in graph\n    int E = 5;  // Number of edges in graph\n    Graph graph = new Graph(V, E);\n\n    // add edge 0-1\n    graph.edge[0].src = 0;\n    graph.edge[0].dest = 1;\n    graph.edge[0].weight = 10;\n\n    // add edge 0-2\n    graph.edge[1].src = 0;\n    graph.edge[1].dest = 2;\n    graph.edge[1].weight = 6;\n\n    // add edge 0-3\n    graph.edge[2].src = 0;\n    graph.edge[2].dest = 3;\n    graph.edge[2].weight = 5;\n\n    // add edge 1-3\n    graph.edge[3].src = 1;\n    graph.edge[3].dest = 3;\n    graph.edge[3].weight = 15;\n\n    // add edge 2-3\n    graph.edge[4].src = 2;\n    graph.edge[4].dest = 3;\n    graph.edge[4].weight = 4;\n\n    graph.KruskalMST();\n}\n```\n\n\n}\n\nI couldn't understand how this piece of code involved in the algorithm\n\n```\n    public int compareTo(Edge compareEdge)\n    {\n        return this.weight-compareEdge.weight;\n    }\n```\n\n\nI mean when the program execute this part ? in witch line ?\n    ", "Answer": "\r\nIt's used in this line implicitly while sorting the array of Edges:\n```\n    Arrays.sort(edge);\n```\n\nThe Edge class implements Comparable interface. It has a compareTo method which allows to compare an instance of the related class with another instance of the same class (here it's Edge) for sorting purposes. Check out https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "When locally optimal solutions equal global optimal? Thinking about greedy algorithm\r\n                \r\nRecently I've been looking at some greedy algorithm problems. I am confused about locally optimal. As you know, greedy algorithms are composed of locally optimal choices. But combining of locally optimal decisions doesn't necessarily mean globally optimal, right?\n\nTake making change as an example: using the least number of coins to make 15¢, if we have \n10¢, 5¢, and 1¢ coins then you can achieve this with one 10¢ and one 5¢. But if we add in a 12¢ coin the greedy algorithm fails as (1×12¢ + 3×1¢) uses more coins than (1×10¢ + 1×5¢).\n\nConsider some classic greedy algorithms, e.g. Huffman, Dijkstra. In my opinion, these algorithms are successful as they have no degenerate cases which means a combination of locally optimal steps always equals global optimal. Do I understand right?\n\nIf my understanding is correct, is there a general method for checking if a greedy algorithm is optimal?\n\nI found some discussion of greedy algorithms elsewhere on the site.\nHowever, the problem doesn't go into too much detail.\n    ", "Answer": "\r\nGenerally speaking, a locally optimal solution is always a global optimum whenever the problem is convex. This includes linear programming; quadratic programming with a positive definite objective; and non-linear programming with a convex objective function. (However, NLP problems tend to have a non-convex objective function.)\n\nHeuristic search will give you a global optimum with locally optimum decisions if the heuristic function has certain properties. Consult an AI book for details on this.\n\nIn general, though, if the problem is not convex, I don't know of any methods for proving global optimality of a locally optimal solution.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Choosing greedy algorithm to find lowest cost path\r\n                \r\nI have a pyramid of numbers. Each number represents the number of points associated. I need to use a greedy algorithm to find the path with the lowest cost to get from the top of the pyramid to the bottom. I've read about uninformed & informed search algorithms, but still I don't know what to choose. What do you thing is best suited for this type of problem? Greedy best-first search / A* search or other? It's such a simple issue, but I'm not used with all these algorithms to know what's the best option. And as I said, it has to be a greedy algorithm.\n    ", "Answer": "\r\nIf I am understanding you correctly, in your pyramid you always have the option of descending to the left or to the right, and the cost of getting to the bottom is the sum of all the nodes you pass through.\n\nIn this case, simply work your way up from the bottom. Start at the 2nd row from the bottom. For each node in the row, look at its left and right children in the row below. Add the cost of the cheaper child node to the node you are on. Move up a row and repeat, until you are at the root/peak. Each node will now contain the cost of the cheapest path from there to the bottom. Just greedily descend by choosing the child node with the cheaper cost.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm: The Robot\r\n                \r\nAny ideas? I've tried drawing it out and I've narrowed down the minimum number of robots you'd need but I just don't know how to express it in a greedy algorithm or how to prove it. It's a bonus question from one of our lectures so we don't have to know how to do it but I feel like its a good exercise. Thanks in advance! \n\n\n    ", "Answer": "\r\n```\nuntil robot is at the bottom row:\n    while there's a coin to the right on the same row:\n        go right\n    go down one step\ngo to the right corner\n```\n\n\nor perhaps more succinctly:\n\n```\nIf there are coins to the right: go right\nOtherwise: go down\n```\n\n\nEdit: \nTo see that the algorithm is optimal in the sense that it requires the fewest total number of robots to clear the board, observe that no robot ever makes a move that is worse than an optimal robot: \"greedy stays ahead\". Here's an attempt to make this argument more formal:\n\nLet G be the greedy algorithm and R be any optimal algorithm. \n\nFrom the perspective of a single robot, there is some set S of coins within reach. From the starting position, for example, all coins are within reach (though some coins may be mutually exclusive, of course). when a robot r makes a move, a subset V of S becomes unreachable for r. It is clear that for any single move, only one additional robot is needed to take all coins in V. Thus in some sense, the worst possible individual move will be such that V is not empty, and there is no way that a single move would cause the algorithm to require two or more additional robots.\n\nFor a robot in G, unless S is empty, V is always a true subset of S. In other words, G doesn't make any \"obviously stupid\" moves. Combined with the fact that G and R collect all coins, we see that the only interesting places where the robots differ are where they make different choices (down or right) after having taken the same coin. \n\nConsider the robots r in R and g in G at a point where they differ. There are two possibilities:\n\n\ng goes right and r goes down.\ng goes down and r goes right.\n\n\nIn the first case, there is a coin to the right, and r goes down. Thus V is not empty for r at that step, and by the previous argument, g's decision can't be worse. \n\nIn the second case, there is no coin to the right, and g goes down. It is clear that V is empty for g, and r's decision can't be better than that.\n\nWe see that in any case where R and G differ, G is at least as good as R, which is optimal, so G must also be optimal. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Breadth First Search vs Greedy Algorithm\r\n                \r\nIn a reputable Algorithmic book , it was mentioned that breadth first search is a greedy algorithm. But I searched for it but I found many links that doesn't say so.\nMy question:\nIs breadth first search a Greedy Algorithm and why ?\nCan you give me a notable reference for your answer ?!\n    ", "Answer": "\r\nThe term \"greedy algorithm\" refers to algorithms that solve optimization problems.\nBFS is not specifically for solving optimization problems, so it doesn't make sense (i.e., it's not even wrong) to say that BFS is a greedy algorithm unless you are applying it to an optimization problem.  In that case, the statement is true or not depending on how it is applied.\nThe \"reputable algorithm book\" probably refers to BFS in the context of a specific optimization problem, and is probably correct to say that it is a greedy algorithm in that context... which you have omitted in your question.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Correctness of greedy algorithm\r\n                \r\n\n  In non-decreasing sequence of (positive) integers two elements can be removed when . How many pairs can be removed at most from this sequence?\n\n\nSo I have thought of the following solution:\n\n\nI take given sequence and divide into two parts (first and second).\nAssign to each of them iterator -  it_first := 0 and it_second := 0, respectively. count := 0\nwhen it_second != second.length\n\n\nif 2 * first[it_first] <= second[it_second]\n\n\ncount++, it_first++, it_second++\n\nelse\n\n\nit_second++\n\n\ncount is the answer\n\n\nExample:\n\ncount := 0\n\n[1,5,8,10,12,13,15,24] --> first := [1,5,8,10], second := [12,13,15,24]\n\n\n2 * 1 ?< 12 --> true, count++, it_first++ and it_second++\n2 * 5 ?< 13 --> true, count++, it_first++ and it_second++\n2 * 8 ?< 15 --> false, it_second++\n8 ?<24  --> true, count ++it_second reach the last element - END.\ncount == 3\n\n\nLinear complexity (the worst case when there are no such elements to be removed. n/2 elements compare with n/2 elements).\nSo my missing part is 'correctness' of algorithm - I've read about greedy algorithms proof - but mostly with trees and I cannot find analogy. Any help would be appreciated. Thanks!\n\nEDIT:\nBy correctness I mean:\n * It works\n * It cannot be done faster(in logn or constant)\n\nI would like to put some graphics but due to reputation points < 10 - I can't.\n(I've meant one latex at the beginning ;)) \n    ", "Answer": "\r\n\nCorrectness:\n\n\nLet's assume that the maximum number of pairs that can be removed is ```\nk```\n. Claim: there is an optimal solution where the first elements of all pairs are ```\nk```\n smallest elements of the array. \nProof: I will show that it is possible to transform any solution into the one that contains the first ```\nk```\n elements as the first elements of all pairs. \n\n\nLet's assume that we have two pairs ```\n(a, b)```\n, ```\n(c, d)```\n such that ```\na <= b <= c <= d```\n, ```\n2 * a <= b```\n and ```\n2 * c <= d```\n. In this case, pairs ```\n(a, c)```\n and ```\n(b, d)```\n are valid, too. And now we have ```\na <= c <= b <= d```\n. Thus, we can always transform out pairs in such a way that the first element from any pair is not greater than the second element of any pair.\nWhen we have this property, we can simply substitute the smallest element among all first all elements of all pairs with the smallest element in the array, the second smallest among all first elements - with the second smallest element in the array and so on without invalidating any pair.\n\nNow we know that there is an optimal solution that contains ```\nk```\n smallest elements. It is clear that we cannot make the answer worse by taking the smallest unused element(making it bigger can only reduce the answer for the next elements) which fits each of them. Thus, this solution is correct.\nA note about the case when the length of the array is odd: it doesn't matter where the middle element goes: to the first or to the second half. In the first half it is useless(there are not enough elements in the second half). If we put it to the second half, it is useless two(let's assume that we took it. It means that there is \"free space\" somewhere in the second half. Thus, we can shift some elements by one and get rid of it).   \n\nOptimality in terms of time complexity: the time complexity of this solution is ```\nO(n)```\n. We cannot find the answer without reading the entire input in the worst case and reading is already ```\nO(n)```\n time. Thus, this algorithm is optimal.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithms in two pointer techniques(fast and slow runnner)\r\n                \r\nI am learning the Two-Pointer Technique in Two-pointer Technique - Scenario II\n\nIt introduced fast-runner pointer and slow-runner pointer to move elements and return the new length\n\n```\npublic int removeElement(int[] nums, int val) {\n    int k = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        if (nums[i] != val) {\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    return k;\n}\n```\n\n\nA summary follows:\n\nThis is a very common scenario of using the two-pointer technique when you need:\n\n\n  One slow-runner and one fast-runner at the same time.\n\n\nThe key to solving this kind of problems is to\n\n\n  Determine the movement strategy for both pointers.\n\n\nSimilar to the previous scenario, you might sometimes need to ```\nsort```\n the array before using the two-pointer technique. And you might need a ```\ngreedy```\n thought to determine your movement strategy.\n\nReference to \n\n\n  And you might need a ```\ngreedy```\n thought to determine your movement strategy.\n\n\nThe ```\ngreedy```\nhere is confusing since we take ```\ngreedy```\n as the fundamental greedy algorithms for granted.\n\nWhat kinds of greedy algorithms thought can be employed in two pointer? \n\nCould you please help an example?  \n\n\n    ", "Answer": "\r\n\n  What kinds of greedy algorithms thought can be employed in two\n  pointer?\n\n\nConsider this problem 3sum in LeetCode.\n\nThis problem requires sorting the input array prior to applying two-pointers method. When you're sorting the input array in some order, this is pretty greedy way to attack a problem.\n\nConsider another problem Container With Most Water in LeetCode.\n\nI don't want to give you spoiler solution for this problem incase you didn't solve it yet. But to give you some idea how it relates to greedy approach, you need to advance left and right pointer based on some comparison between numbers which is actually kind of \"Greedy\".\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Complexity of the greedy algorithm\r\n                \r\nI made a greedy algorithm that solves minimum-weighted-Hamiltonian-circuit problem.The algorithm always picks the cheapest edge,if there is no way to find the circuit from the current edges set then the algorithm drops the last edge and picks the next cheapest.I'm not sure about the complexity of this algorithm,can someone explain it to me\nHere is the pseudocode\n\n```\n    HC(currentVertex,expandedVertices,path,sum,N)\n    if size(expandedVertices)==N then\n        print(path)\n        return sum\n    end if\n    expandedVertices.add(currentVertex)\n    vertices=getAdjacentNodes(expandedVertices)\n    sort(vertices)\n    for i=1 to size(vertices) do\n        path.append(vertices[i])\n        cost=HC(vertices[i],expandedVertices,path,sum+getEdgeCost(currentVertex,\n           vertices[i]),N)\n        if(cost>0) then\n            break\n        end if\n        path.remove(vertices[i])\n    expandedVertices.remove(currentVertex)\n    return cost\n```\n\n    ", "Answer": "\r\nYour algorithm uses brute force to find a path, so the maximum running time is ```\nO(n!)```\n (for a fully connected graph). There might only be one possible route, the last one you check. \n\nIn most real-world cases, this algorithm will be faster. The problem is usually referenced to by its other name: the traveling salesman problem. Wikipedia has a list of good algorithms and heuristics that are faster than yours.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm and coins algorithm\r\n                \r\nFirst, yes it's my HW and I find it hard so I'll really appreciate some guidance.\n\nI need to prove that for denomination of ```\n1,x,x2...xn```\n when ```\nx>=1```\n the greedy algorithm for the coins problem always work .\n\n\nWe will always get the amount of money we need in minimal coins number when we always pick the maximal coin that smaller from the amount.\n\n\nThank you.\n    ", "Answer": "\r\nAs this is your homework I will not provide a complete answer but will rather try to guide you:\n\nFirst as it usually happens for problems of that type try and prove for yourself that the statement is true for the first few natural numbers. Try to summarize what you use to make the proof for them. This usually will give you some guidance of the correct approach.\n\nI would use induction for this one. \n\nAnother option that might help you - represent all the numbers in numerical system with base ```\nx```\n. This should make it clearer why the statement is true.\n\nHope this helps you.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for knapsack in java\r\n                \r\nI am trying to write a very simple greedy algorithm for the knapsack problem. My inputs are two parallel arrays. One array contains the value of the item and the other array contains the weights. \n\nThe greedy algorithm that I’m trying to write would go as follows: check which item has the highest value and put this in the knapsack. Then set the value of this item to zero. Check again which item has the highest value and put it in the knapsack if the knapsack can still hold it. If it can hold it, set the value again to zero (after you’ve put it in) and start looking for the highest value again. If that knapsack cannot hold it anymore then just end the program.\n\nI know that there are a lot of better greedy algorithms out there but this seems to me to be a pretty simple one and I think I could manage this. My problem is that I have to go through the entire values array to find the maximum value. Then when I’ve found it I put it in the knapsack and set the value to zero. But the problem then is that I have to go back in the for loop to find the new highest value item and put this in the knapsack. But I don’t know how I would go about doing this. \n\nI am writing this in Java.\n    ", "Answer": "\r\nFirst of all, you usually solve Knapsack greedily by using the highest ratio value/weight instead of just the value.\n\nSecondly, you do not need to search for the maximum in each step if you sort the list of items once and go through it step by step.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Time complexity of greedy algorithm\r\n                \r\nGood morning,\n\nI'm trying to find a way to calulate time complexity (average and worst) of greedy algorithm. I know that final formula is: O(nlogn + n) which is O(nlogn). I will appreciate any suggestion/hints how I can calculate this.\n\nRegards\n    ", "Answer": "\r\nBecause the greedy algorithms can be conclude as follows:\n\n```\nInitially let R be the set of all requests，and let A be empty\nWhile R is not yet empty\n    Choose a request iR that has the smallest finishing time\n    Add request i to A\n    Delete all requests from R that are not compatible with request i\nEndWhile\nReturn the set A <is the set of accepted requests\n```\n\n\nTherefore, the running time of it is consist of:\n\n\nSorting the n requests in order, which costs O(nlogn).\nConstructing the array containing sorted requests, which costs O(n).\nIterating through the intervals in the array, which costs O(n).\n\n\nActually, the second and the third step can often be merged into one step. Thus, the running time of the algorithm is O(nlogn).\n\n(References: Jon,Kleinberg, and Éva,Tardos. Algorithm Design)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Design a Greedy algorithm for this preblem [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIn the interval covering problem, we are given ```\nn```\n  intervals\n\n```\n[s1,t1), [s2,t2), ···, [sn,tn)\n```\n\n\nsuch that\n\n```\nS i∈[n][si,ti) = [0,T).\n```\n\n\nThe goal of the problem is to return a smallest-size set\n\n```\nS ⊆ [n]\n```\n\n\nsuch that\n\n```\nS i∈S[si,ti) = [0,T).\n```\n\n\nDesign a greedy algorithm for this problem.\n    ", "Answer": "\r\nA greedy algorithm could be devised as follows. As long as there is a point ```\np```\n in ```\n[0,T)```\n which is not contained in one of the already selected intervals, select an interval ```\n[s_i,t_i)```\n , which must exist, since the union of all ```\n[s_i,t_i)```\n is ```\n[0,T)```\n as stated in the requirements. As the set of intervals ```\n[s_i,t_i)```\n is finite, this procedure must terminate.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "can sampling remove the limitations in greedy algorithm\r\n                \r\nknowing this is a vague question, but i just want to know that, given the limitations of greedy (i.e., not always finding the optimal solution), does sampling the data space in a randomized manner or some structured manner reduce or remove the limitations of greedy algorithm.\n\ni understand the answer to this is problem specific, but given a problem that shows the limitation of greedy algorithm can sampling be used in any way in order to guide the greedy algorithm to generate an optimal solution?\n\nmany thanks in advance.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm odd behavior\r\n                \r\nI've implemented the Greedy algorithm to solve Egyptian fractions, however I'm getting some unexpected results. Here's my code\n\n```\nfrom math import ceil\nfrom fractions import Fraction\n\ndef go(frac):\n    ret = []\n    while frac > 0:\n        if frac.numerator == 1:\n            ret.append(frac)\n            break\n        x = Fraction(1, ceil(frac.denominator / frac.numerator))\n        frac -= x\n        ret.append(x)\n    return ret\n\ninput1 = int(raw_input('numerator: '))\ninput2 = int(raw_input('denominator: '))\n\nprint go(Fraction(input1, input2))\n```\n\n\nI constantly am getting the error \"TypeError: both arguments should be Rational instances\"\n\nI've been logging and it crashes upon the first iteration of the while loop.\n\nEDIT: the error in detail is:\n\n```\nFile \"egypt.py\", line 19, in <module>\nprint go(Fraction(input1, input2))\nFile \"egypt.py\", line 10, in go\nx = Fraction(1,ceil(frac.denominator / frac.numerator))\nFile \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/fractions.py\", line 158, in __new__\nraise TypeError(\"both arguments should be \"\nTypeError: both arguments should be Rational instances\n```\n\n\nWhy is this?\nThank you.\n    ", "Answer": "\r\nYou have 2 problems in your code.\n\n\nyou're dividing ```\nint```\n with ```\nint```\n which always returns an ```\nint```\n; in your case, you're dividing ```\na / b```\n where ```\na < b```\n so it'll always be rounded down to 0.\nThen, you ```\nceil()```\n that, which returns a ```\nfloat```\n (0.0) which is something ```\nFraction```\n doesn't like;it wants ```\nint```\ns.\n\n\nSo try this instead:\n\n```\nFraction(1, int(ceil(float(frac.denominator) / frac.numerator)))\n```\n\n\nThe rest of the code looks good.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for 0-1 Knapsack\r\n                \r\nIs there any greedy algorithm that would give an optimal solution to non-fractional(0-1 Knapsack) Knapsack problem? I know that there is one for the fractional version of Knapsack giving the optimal solution.\n    ", "Answer": "\r\nThere are no greedy algorithms for 0-1 Knapsack even though greedy works for Fractional Knapsack.\n\nThis is because in 0-1 Knapsack you either take ALL of the item or you don't take the item at all, unlike in Fractional Knapsack where you can just take part of an item if your bag overflows. This is crucial.\n\nHere is an example that disproves that Greedy Algorithm works for 0-1 Knapsack. Let's say that you have a bag of size 6 and these items: \n\nItem   Value   Size   Value/Size \nA       5.5       4         1.38 \nB       4          3         1.33 \nC       4          3         1.33 \n\nFor 0-1 Knapsack, if you tried to be greedy you would always take the item that has the highest Value/Size, which is Item A. After taking Item A, you only have room for an item of size 2 or less so you wouldn't be able to pick up anything else. That means that the only thing you have in your bag is Item A which is a total value of 22.\n\nOn the other hand, if you had not been greedy and taken the most valuable item and had instead taken Item B, then you would have enough room to take Item C as well. This would have resulted in a total value of 24 in the bag, which is better than the greedy route.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Not Greedy algorithm for Set Cover\r\n                \r\nDetails about my sets:\neach set have exactly M elements, and each element belongs to exactly N sets.\n\nI need a Non greedy algorithm to compute the size of the minimal set cover.\n\nis there a good algorithm? (for my special case)\n\nthanks.\n    ", "Answer": "\r\nThe hardness results and probably the inapproximability results (perhaps with a worse constant) apply even to your special case. Use a solver for mixed-integer programs such as GLPK.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Python Greedy Algorithm\r\n                \r\nI am writing a greedy algorithm (Python 3.x.x) for a 'jewel heist'. Given a series of jewels and values, the program grabs the most valuable jewel that it can fit in it's bag without going over the bag weight limit. I've got three test cases here, and it works perfectly for two of them.\n\nEach test case is written in the same way: first line is the bag weight limit, all lines following are tuples(weight, value).\n\nSample Case 1 (works):\n\n```\n10\n3 4\n2 3\n1 1\n```\n\n\nSample Case 2 (doesn't work):\n\n```\n575\n125 3000\n50 100\n500 6000\n25 30\n```\n\n\nCode: \n\n```\ndef take_input(infile):\n    f_open = open(infile, 'r')\n    lines = []\n    for line in f_open:\n        lines.append(line.strip())\n    f_open.close()\n    return lines\n\ndef set_weight(weight):\n    bag_weight = weight\n    return bag_weight\n\ndef jewel_list(lines):\n    jewels = []\n    for item in lines:\n        jewels.append(item.split())\n    jewels = sorted(jewels, reverse= True)\n    jewel_dict = {}\n    for item in jewels:\n        jewel_dict[item[1]] = item[0]\n    return jewel_dict\n\ndef greedy_grab(weight_max, jewels):\n    #first, we get a list of values\n    values = []\n    weights = []\n    for keys in jewels:\n        weights.append(jewels[keys])\n    for item in jewels.keys():\n        values.append(item)\n    values = sorted(values, reverse= True)\n    #then, we start working\n    max = int(weight_max)\n    running = 0\n    i = 0\n    grabbed_list = []\n    string = ''\n    total_haul = 0\n    # pick the most valuable item first. Pick as many of them as you can.            \n    # Then, the next, all the way through.\n    while running < max:\n        next_add = int(jewels[values[i]])\n        if (running + next_add) > max:\n            i += 1\n        else:\n            running += next_add\n            grabbed_list.append(values[i])\n    for item in grabbed_list:\n        total_haul += int(item)\n    string = \"The greedy approach would steal $\" + str(total_haul) + \" of  \n             jewels.\"\n    return string\n\ninfile = \"JT_test2.txt\"\nlines = take_input(infile)\n#set the bag weight with the first line from the input\nbag_max = set_weight(lines[0])\n#once we set bag weight, we don't need it anymore\nlines.pop(0)\n\n#generate a list of jewels in a dictionary by weight, value\nvalue_list = jewel_list(lines)\n#run the greedy approach\nprint(greedy_grab(bag_max, value_list))\n```\n\n\nDoes anyone have any clues why it wouldn't work for case 2? Your help is greatly appreciated.\nEDIT: The expected outcome for case 2 is $6130. I seem to get $6090.\n    ", "Answer": "\r\nYour dictionary keys are strings, not integers so they are sorted like string when you try to sort them. So you would get:\n\n```\n['6000', '3000', '30', '100']\n```\n\n\ninstead wanted:\n\n```\n['6000', '3000', '100', '30']\n```\n\n\nChange this function to be like this and to have integer keys:\n\n```\ndef jewel_list(lines):\n    jewels = []\n    for item in lines:\n        jewels.append(item.split())\n    jewels = sorted(jewels, reverse= True)\n    jewel_dict = {}\n    for item in jewels:\n        jewel_dict[int(item[1])] = item[0]  # changed line\n    return jewel_dict\n```\n\n\nWhen you change this it will give you:\n\n```\nThe greedy approach would steal $6130 of jewels.\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm vs Nearest Neighbor Algorithm\r\n                \r\nI'm doing an assignment on Travelling Salesman and I want to know the difference between the Greedy Algorithm and the Nearest Neighbor algorithm. I looked it up and they seemed almost the same to me. And there weren't any good resources tha compared them. What is their difference?\n    ", "Answer": "\r\nActually, I'm having a hard time finding the similarity :) You talk about two very different algorithms here, for different kinds of problems.\nGreedy algorithm is being used mainly for graphs, as it's supposed to solve staged-problems, when each stage requires us to make a decision. For example, when trying to find the shortest way from one point to another, it would choose each time the closest point to the current point it stands at.\nK-NN is a lazy classification algorithm, being used a lot in machine learning problems. It calculates the class for a value depending on its distance from the k closest points in the set.\nThinking about it, you can actually say that each stage of the greedy algorithm uses a 1-Nearest-Neighbours algorithm to find the closest point, but it's pretty ridiculous... :)\nHope it's understandable!\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Confused about the for loop in the Set Covering Problem (Greedy Algorithms)\r\n                \r\nThis is my first time learning data structure and algorithms. I am stuck in the Grokking Algorithm Chapter 8 Greedy Algorithms, where there is a simple Set Covering Problem given to the readers.\nIs there a simpler example of source code which I can refer to understand the concept behind this example?\nCan somebody explain how set intersection helps to get the ultimate result of {'k4', 'k5'} in plain English? How is the array of states_needed passed in to a hash and gets converted to a set?\n```\nstates_needed = set([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"])\n\nstations = {}\n\nstations[\"k1\"] = set([\"a\", \"b\", \"c\"])\nstations[\"k2\"] = set([\"c\", \"d\", \"e\"])\nstations[\"k3\"] = set([\"f\", \"g\", \"h\"])\nstations[\"k4\"] = set([\"a\", \"b\", \"c\", \"d\"])\nstations[\"k5\"] = set([\"e\", \"f\", \"g\", \"h\"])\n\nfinal_stations = set()\n\nwhile states_needed:\n  best_station = None\n  states_not_covered = set()\n  \n  for station, states_for_station in stations.items():\n    covered = states_needed & states_for_station\n    if len(covered) > len(states_not_covered):\n      best_station = station\n      states_not_covered = covered\n\n  states_needed -= states_not_covered\n  final_stations.add(best_station)\n\nprint(final_stations)\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Improvement of the Greedy Algorithm\r\n                \r\nI've been working on an abstract chess algorithm using Haskell (trying to expand my understanding of different paradigms), and I've hit a challenge that I've been pondering about for weeks.\n\nHere's the problem:\n\n\n  Given a board (represented by a list of lists of integers; each\n  integer represents a subsequent point value), with dimensions n x n,\n  determine the path that provides the most points. If there is a tie\n  for best path, return either of them.\n\n\nHere are the specifics:\n\n```\nA = [[5,4,3,1],[10,2,1,0],[0,1,2,0],[2,3,4,20]] \n```\n\n\nwhich renders as: \n\n```\nR1: 5  4  3  1, R2: 10 2 1 0, R3: 0 1 2 0, R4: 2 3 4 20.\n```\n\n\nThe rules are: \n\n\nYou may start anywhere on the top row \nYou may move one square at a time, either straight down, down-left (diagonal) , or down-right (diagonal). \nThe output must be a tuple of integers. \n\n\nFirst element is a list representing the columns vs. row, and the second element is the total number of points. Eg. for the above board, the best solution is to travel from top-left (5) and go diagonally for the remaining steps (until the 20 point square). This would result in the tuple ```\n([1,2,3,4], 29)```\n. \n\nRemember, this is all in Haskell so it is a functional-paradigm recursive problem. At first, I was thinking about using the greedy algorithm, that is, choosing the highest value in r1, and recursing through comparing the next 3 possibilities; choosing the highest of the 3. However, the downfall is that the greedy algorithm doesn't have the ability to see potential ahead of the next row. \n\nHow would I go about this? I'm not looking for code per se, since I enjoy solving things on my own. However, pseudocode or some algorithmic guidance would be much appreciated!\n    ", "Answer": "\r\nI saw your previous question on the same topic, and I start to work on it.\nAs you doesn't want the direct solution, I can provide you my reflexion about your problem, I guess it could help you.  \n\nSome basic property :\n1. The number of movement is alway egal to the length of the list m = length A\n2. The number of starting point is egal to the length of the head of the list n = length   (head A)\n3. The current position could never be negative, then :\n- if the current position is egal to 0 you can either go down or right\n- else you can go to left, down or right  \n\nWhich lead us to this pseudo code  \n\n```\ngenerate_path :: [[Int]] -> [[Int]]\ngenerate_path [] = [[]] \ngenerate_path A =  ... -- You have to put something here\n        where \n              m = length A\n              n = length (head A)\n```\n\n\nThis things should look like something as this  \n\n```\nmove pos0 count0\n    | count0 == 0 =   \n        | pos0 == 0 = move (down count) ++ move (right count)  \n        | otherwise = move (left count) ++ move (down count) ++ move (right count)  \n            where \n                count = count0 - 1\n                down  = position0 \n                left  = position0 - 1\n                right = position0 + 1\n```\n\n\nIn fact keeping all of this in mind and adding the (!!) operator, we shouldn't be so far of the solution. To convince you play with A + list comprehension + !!, as   \n\n```\n[A !! x !! y | x <- [1..2], y <- [0..2]] -- I take random range \n```\n\n\nOr play with another version :   \n\n```\n[[A !! x !! y | x <- [1..2]] | y <- [0..2]]] -- I take random range \n```\n\n\nIn fact you have two recursion the main one working on the parameter n = length (head A), you repeat the same action from 0 to (n-1) at (n-1) retrieve the result, this recursion embedded another one which work on m, repeat the same action from 0 to (m-1).   \n\nHope it help.\nGood luck.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Scheduling, Greedy algorithm\r\n                \r\nThis is a variation of the popular El Goog problem.\n\n\n\nConsider the following scheduling problem: There are n jobs, i = 1..n. There is 1 super computer and unlimited PCs. Each job needs to be pre-processed by the super computer first and then processed on a PC. The time required for job i on the super computer is si, i = 1..n. For PCs, it's pi, i = 1..n. The PCs can work in parallel, but the super computer can only work on 1 job at a time. A schedule S is created according to which the super computer will process the jobs. The completion time Ti(S) in schedule S is given by the clock time at which the job finishes on the PC. We want to find a schedule that minimizes Maxi[Ti(s)] (to be read as: we need to find a schedule that minimizes the highest finish time). The following greedy algorithm is proposed: Arrange the jobs in the decreasing order of processing times on the PCs. The complexity of this algorithm is O(nlogn). Either prove that this algorithm produces an optimal solution or provide a counter-example to show that it does not.\n\n\n\nMy solution (not sure if this is correct): I don't think it matters how we order the jobs. The highest finish time will still be the same. Consider this example of the processing times on the PCs for a list of jobs: <5, 7, 17, 8, 10>. This will yield finish times as <5, 12, 29, 37, 47>. As per the algorithm, we will sort the list as <17, 10, 8, 7, 5> and will yield finish times of <17, 27, 35, 42, 47>. So while technically, the greedy algorithm does give an optimal ordering, it takes nlogn time to do that, while simply iterating through the list of jobs gives us the same result.\n\nIf anyone thinks that the greedy algorithm will work better or that my approach is flawed, I'd appreciate your thoughts.\nThanks!\n\n\n\nUpdate: I think I may have the answer. The time taken by the super computer doesn't matter. The key here is that the PCs run in parallel. From the initial example of pi = <5, 7, 17, 8, 10>, let's add si = <8, 5, 1, 12, 9>. Now, in the default, unsorted order, we'd have processing times of <13, 20, (8 + 5 + 1 + 17 = )31, 34, 45>. So 45 is the time of completion. Assume a sorted order in which pi's are decreasing. The output is: <18, 20, 30, 34, 40>. [Sorted input: pi = <17, 10, 8, 7, 5>, si = <1, 9, 12, 5, 8>].\n\nHere's an example that probably clears the whole thing up:\nsi = <17, 10>, pi = <10, 17>. The output in the unsorted case (which also happens to be sorted in descending order of si) will be <27, 44>. Sorting based on pi, the input is: si = <10, 17>, pi = <17, 10>. Output is <27, 37>. Since the PCs run in parallel, you want to send the shortest job last.\n    ", "Answer": "\r\nFor Limited number of PCs:\n\nw.l.o.g Assume there is no super computer, your problem will be converted to Minmum Makespan Scheduling problem (or ppt), which is NP-Hard. So your current algorithm doesn't works or P = NP.\n\nBut greedy algorithms are useful for approximations, Also you can convert Bin Packing to this problem and by fixed amount of error for approximation find good results, but runtime will be not good polynomial (e.g like n^10).\n\nP.S: You can simply assume there is no super computer, for this assume the instance such that Max(si) < Min(Pi).\n\nP.S2: I didn't see unlimited number of PCs at first, so I wrote this, I'll think about unlimited number of PCs.\n\nUnLimited case:\n\nYour current algorithm is wrong, assume this conditions:\n\n```\nFor PCs: <5, 7, 17, 8, 10>\nFor super computer: <1000,800,500,600,700).\n```\n\n\nYour current solution will fails.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to vectorize greedy algorithm in R?\r\n                \r\nI'm writing an R script that implements a greedy algorithm to optimize a function. As a simple example, suppose I have a vector of positive numbers to be distributed among 3 clusters. I want to minimize the total within-cluster distance in each cluster. I use the greedy algorithm of distributing the numbers one at a time and placing each number in the cluster that has the smallest sum of distances between that number and the numbers already in the cluster. Here's an R script to implement that algorithm:\n\n```\nn <- 100\nset.seed(0)\nx <- rnorm(n)\ncluster <- integer(n)\n\ntotal_distance <- function(c, x, cluster){\n  if(!any(cluster == c)){\n    total_dist <- 0\n  } else{\n    total_dist <- sum(abs(x[cluster == c] - x[which.min(cluster > 0)]))\n  }\n  return(total_dist)\n}\n\nfor(i in 1:n){\n  within_cluster_distances <- mapply(total_distance, 1:3,\n                                     MoreArgs = list(x = x, cluster = cluster))\n  cluster[i] <- which.min(within_cluster_distances)\n}\n\n> cluster\n  [1] 1 2 3 1 2 3 2 2 2 1 1 3 3 2 2 2 2 3 1 3 2 1 2 1 2 1 1 3 3 2 2 3 2 3 1 1 1 2 1 2 1 1 2 3 3 3 3 1 1 2 2 2 1 3 2 2 1 2 3 3 2 2 3 2 3 2 3\n [68] 1 2 2 2 2 3 2 1 1 2 2 3 3 3 1 1 2 2 2 1 2 1 1 1 3 2 3 1 2 2 1 2 1\n```\n\n\nIs it possible (or even desirable) to vectorize the loop to obtain the ```\ncluster```\n vector? I don't know how to vectorize when the values in the output vector depend on other values in that vector.\n\nEDIT: I realize that the greedy algorithm outlined above is not an effective clustering method. The problem described above is not the problem that I am actually trying to solve. My question is about whether it is possible and beneficial to vectorize the loop in my code example.\n    ", "Answer": "\r\nAnother option is to use ```\nstats::kmeans```\n:\n\n```\nkmeans(x, 3)$cluster\n```\n\n\nCheck which is more closely packed:\n\n```\ncldist <- function(v) sum(abs(outer(v, v, `-`)))\n\ntapply(x, cluster, FUN=cldist)\n#       1        2        3 \n#1086.007 1132.614 1019.575 \n\ntapply(x, kmeans(x, 3)$cluster, FUN=cldist)\n#       1        2        3 \n#234.8734 722.5750 374.7199 \n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why horn formulas algorithm is greedy?\r\n                \r\nI understand horn formula and it is as follow:\n\n\n\nBut I cant understand why it taught usually in the section related to greedy algorithms,\nI can not see the greedy part of horn formula. Can anyone help?\n    ", "Answer": "\r\nThe algorithm is greedy in that it tries to build up a satisfying assignment from an unsatisfying assignment by incrementally flipping variables to be true. This can be viewed as \"greedy\" because the algorithm only makes local decisions (make something true in order to satisfying a specific clause without any regards to what happens later) rather than global decisions, and never backtracks from its decisions (unlike many other SAT solving algorithms).\n\nHope this helps!\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Solve graph coloring prob with a greedy algorithm in exponential time\r\n                \r\nI'm currently teaching myself about algorithms and about different problems that are interesting in CS. For an example if I wanted to solve the graph coloring problem with a greedy algorithm (e.g. choose what's best at the moment) and ensure that I have the correct solution, then I'd basically have to go through the graph more than one time, if I'm correct? Because choosing what's best at the moment is generally not optimal and might give wrong results.\n\nTo be more specific, I'd actually want to answer the decision problem: Is the graph G colorable with N colors? with a greedy algorithm, and the answer certainly needs to be correct.\n\nSo are there any example algorithms in pseudo code out there - or can I get a clue how I can make sure that I give the correct answer with this greedy algorithm?\n\nThanks in advance! I appreciate any reply\n    ", "Answer": "\r\nFrom my understanding, for problems like this, greedy might not always give a correct solution since a graph may contain cycles and you might not be aware of certain edges to nodes until you reduce your space to a few nodes and you're left with incompatible colors.\nA basic solution to this would be a backtracking algorithm. It might be possible to use greedy in this case if you can reduce this problem to another NP problem that has a greedy solution but to the extent of my knowledge, I am not aware of one. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "need brute force, divide and conquer, dynamic programming and greedy algorithms for matrix inversion?\r\n                \r\nI need different algorithms that use different approaches like brute force, divide and conquer, dynamic programming and greedy algorithms for matrix inversion. It would be very helpful if I get one algorithm per approach.Because I need to compare all four algorithms and find which one is efficient in terms of time complexity and space complexity.\nI tried finding them online but found algorithms that use different methods like Gauss Jordan method, adjoint method to find inverse of a matrix. But I couldn't categorize them into approaches like dp or greedy.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Are there flaws in my Greedy algorithm?\r\n                \r\nI was just wondering if you could see any flaws or problems with my Greedy algorithm I've come up with to solve this problem. The problem is:\n\n\nThey're a set of employees\nEach employee has one work shift that is a single interval of time during the week. Shifts of employee's have the possibility of overlapping.\nA subset of the employees forms a Supervision group.\nThe Supervision Group has a property that for every moment of every employee’s shift, there's a supervisor working as well.\n\n\nGoal is to produce a Supervision Group whose size is as small as possible.\n\nNow, my Greedy algorithm to solve this. \nAssume there's a list of employees:\n\n```\n  While(there are employee's who aren't supervisors and are not removed )\n      Choose first employee working with longest work shift to be supervisor. \n      Remove any employee whos finish time is less than the current supervisor finish time.\n\n      If(supervisor shift is ending)\n         Turn employee whos shift interests with supervisor shift,\n         with longest work time remaining into a supervisor as well.\n      end if\n  End while\n\n      return list of supervisors\n```\n\n\nWill this work? And will this actually return the smallest group of supervisors possible? I'm not sure if this is the best way to be doing this.\n\nThanks\n    ", "Answer": "\r\nWith each employee working exactly one shift, it is easy to prove that the greedy strategy produces an optimal solution.\n\nLet's pretend that your algorithm does not produce an optimal solution. This means that there exists an employee ```\nE0```\n who could replace at least two employees ```\nE1```\n and ```\nE2```\n who were assigned supervisors for two back-to-back intervals. This means that ```\nE0```\n's shift started at least as early as ```\nE1```\ns, and ended as late or later that```\nE2```\n's. If that were true, however, your greedy algorithm would have picked ```\nE0```\n over ```\nE1```\n to be the supervisor, which is a contradiction. This means that your algorithm finds an optimal solution to the problem.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm Python. Get all sequences\r\n                \r\nTrying to get through DP and Greedy algorithms. Please help!\n\nInput has time, range and price. For eg. - (start, end, price) ```\n[(0,1,9), (0,3,8),(2,6,5),....(6,11,10)]```\n. If ```\ndays_for_trading=2```\n, program should give the highest profit, which are ```\n(0,1,9),(6,11,10)```\n. But it stops on the first satisfied condition with days range ```\n(0,1,9), (2,6,5)```\n. \n\nDon't know really how to make this iterating further. Thanks!\n\nUpdates: Thanks for all participants. It's solved. But the current algorithm doesn't fit the limit of memory usage. I kept the link to the task in comments below if someone needs it\n\n```\ndef get_max(tmp, days_for_trading):\n    global best_profit\n    for day_start, day_end, price in tmp:\n        traiding_sequence=[]\n        cur_profit=0\n        count=0\n        deal=(day_start, day_end, price)\n        traiding_sequence.append(deal)\n        cur_profit+=price\n        for next_day_start, next_day_end, next_price in tmp:    \n            if days_for_trading==len(traiding_sequence):\n                break\n            else:\n                if next_day_start>traiding_sequence[count][1]:\n                    next_deal=(next_day_start, next_day_end, next_price)\n                    traiding_sequence.append(next_deal)\n                    cur_profit+=next_price\n                    count+=1        \n        best_profit=cur_profit if cur_profit>best_profit else best_profit\n```\n\n    ", "Answer": "\r\nI assume it is this line as you are excluding the last trading sequence with it (and there there is a typo in your variable)\n\n```\nif days_for_trading==len(traiding_sequence):\n    break\n```\n\n\ntry it with \n\n```\nif days_for_trading > len(traiding_sequence):\n    break\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Minimization using a Greedy Algorithm\r\n                \r\nTheres a problem such that there are n houses a1,...an on a straight line. You want to build facilities such that each house is at most distance X from a facility. There are p locations b1,...bp that the facilities can be built. \nI am trying to figure a greedy algorithm to figure out what is the minimum number of facilities that can be built. \n\nHow would I go about solving this? \n    ", "Answer": "\r\nFor each location (B1,...,Bp), create a list that contains the houses that are within X distance from that location. \n\nCreate a list of houses (lets call this list \"NeedToCover\") that initially contains all of the houses.\n\nNow go through each location's list and determine which location's list covers the most houses in the \"NeedToCover\" list. This will be the the location where you will build your facility.\n\nAfter building the facility, remove all the houses in \"NeedToCover\" that was covered by that location that you had just picked.\n\nRepeat the above steps with the remaining houses in \"NeedToCover\" and the remaining locations until \"NeedToCover\" is empty, in which that means all houses are within X distance from a facility.\n\n(This algorithm is greedy because each time you are picking the location that covers the most houses out of the remaining houses \"without regard for the future.\")\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is floating point math broken?\r\n                \r\nConsider the following code:\n```\n0.1 + 0.2 == 0.3  ->  false\n```\n\n```\n0.1 + 0.2         ->  0.30000000000000004\n```\n\nWhy do these inaccuracies happen?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Back Tracking Vs. Greedy Algorithm Maximum Independent Set\r\n                \r\nI implemented a back tracing algorithm using both a greedy algorithm and a back tracking algorithm.\nThe back tracking algorithm is as follows:\n\n```\nMIS(G= (V,E): a graph): largest set of independent vertices\n1:if|V|= 0\nthen return .\n3:end if\nif | V|= 1 \nthen return V\nend if\npick u ∈ V\nGout←G−{u}{remove u from V and E }\nGn ← G−{ u}−N(u){N(u) are the neighbors of u}\nSout ←MIS(Gout)\nSin←MIS(Gin)∪{u}\nreturn maxsize(Sout,Sin){return Sin if there’s a tie — there’s a reason for this.\n }\n```\n\n\nThe greedy algorithm is to iteratively pick the node with the smallest degree, place it in the MIS and then remove it and its neighbors from G.\n\nAfter running the algorithm on varying graph sizes where the probability of an edge existing is 0.5, I have empirically found that the back tracking algorithm always found a smaller a smaller maximum independent set than the greedy algorithm. Is this expected?\n    ", "Answer": "\r\nYour solution is strange. Backtracking is usually used to yes/no problems, not optimization. The algorithm you wrote depends heavily on how you pick ```\nu```\n. And it definitely is not backtracking because you never backtrack.\n\nSuch problem can be solved in a number of ways, e.g.:\n\n\ngenetic programming,\nexhaustive searching,\nsolving the problem on dual graph (maximum clique problem).\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to know if I created a greedy algorithm or not?\r\n                \r\nI've read that a greedy algorithm only take cares for the optimal solution that is trying to reach at that moment, but is this the only criteria I should consider if I want to create a greedy algorithm? Aslo, how can I know if I have created a greedy algorithm or not? I mean, I created the following code for the problem of the change in ```\nC++```\n:\n\n```\n#include <iostream>\n\nusing namespace std;\n\nint greedyChange(int coinSet[], int lenCoinSet,  int money){\n    int change = 0;\n    static int i = 0;\n\n    if(i >= lenCoinSet){\n        return 0;\n    }\n    while(money - coinSet[i] >= 0){\n        change++;\n        money -= coinSet[i];\n    }\n    i++;\n    return change + greedyChange(coinSet, lenCoinSet, money);\n}\n\nint main(int argc, char const *argv[]){\n\n    int coinSet[]={20, 15, 10, 5, 1};\n    int lenCoinSet = sizeof(coinSet)/sizeof(coinSet[0]);\n    int money = 30;\n\n    cout << \"The minimun number of coins to get your change is: \" \n            << greedyChange(coinSet, lenCoinSet, money)<<endl;\n    return 0;\n}\n\n```\n\n\nAnd I think it is greedy, but I'm not sure. I would apreciate if you could explain me if the code I wrote is greedy or not. Besides, if it isn't, do you have another possible solution you could share or maybe some advices to improve this code? Finally, if there is documentation you could recommend me, I'll be very thankful.\n    ", "Answer": "\r\nYes, it's greedy.\n\nThere are 2 problems, though.\n\nFirstly, instead of loop, you should have used a simple division:\n\n```\nwhile(money - coinSet[i] >= 0){\n    change++;\n    money -= coinSet[i];\n}\n```\n\n\ncan be easily replaced with:\n\n```\ncoins = money / coinSet[i]\nchange += coins\nmoney -= coins * coinSet[i]\n```\n\n\nSecondly, your program uses recursion with a static variable -- this is usually frowned upon. You should replace this with a simple loop over ```\ni```\n instead of calling recursively.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm - Roman Numerals [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm trying to implement a C program which converts an integer ```\nn```\n (between 0 and 1024)  into a Roman numeral by way of a greedy algorithm. I have tried to do this in the following manner:\n\n```\n#include <stdio.h>\n#include <string.h>\nvoid convert(int);\nint max(int[], int, int);\n\nint main(){\n\n    //User Input\n    int n;\n    printf(\"Enter a digit between 0 and 1024: \");\n    scanf(\"%d\", &n);\n\n    //Validation\n    while((n < 0)||(n > 1024)){\n        printf(\"That number is not between 0 and 1024. Please try again: \");\n        scanf(\"%d\", &n);\n    }\n\n    //Output\n    printf(\"\\nAs a Roman numeral, this was written: \");\n    if (n == 0) printf(\"nulla\");    //Romans wrote 'nulla' for zero\n    else convert(n);\n\n    return 0;\n}\n\nvoid convert(int n){\n    //Case n = 0\n    if (n == 0)  return;\n\n    else{\n        //Case n > 0\n        char* romanNums[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\n        int arabicNums[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n        int biggestNo = max(arabicNums, 12, n); //Biggest number in arabicNums[] smaller than n\n\n        printf(\"%s\", romanNums[biggestNo]); //Print the biggest number as a Roman numeral\n        convert(n - biggestNo);             //Convert the remaining\n\n    }\n}\n\n//This function determines the maximum number in arr[] smaller than n\nint max(int arr[], int size, int n){\n    int i, max;\n    for(i = 0; i < size; i++){\n        if (n < arr[i]) max = i;\n    }\n    return max;\n}\n```\n\n\nI have tried debugging and modifying aspects of the code, but it's not working. I'd appreciate any feedback.\n\n\n\nUPDATE I've managed to amend my program so that it outputs the values 1, 4, 5 etc. correctly, but composite values (i.e. those which require another iteration of ```\nconvert()```\n) keeps resulting in \"Romans.exe not responding\". Here is the new code:\n\n```\n#include <stdio.h>\n#include <string.h>\nvoid convert(int);\nint max(int[], int, int);\n\nint main(){\n\n    //User Input\n    int n;\n    printf(\"Enter a digit between 0 and 1024: \");\n    scanf(\"%d\", &n);\n\n    //Validation\n    while((n < 0)||(n > 1024)){\n        printf(\"That number is not between 0 and 1024. Please try again: \");\n        scanf(\"%d\", &n);\n    }\n\n    //Output\n    printf(\"\\nAs a Roman numeral, this was written: \");\n    if (n == 0) printf(\"nulla\");    //Romans wrote 'nulla' for zero\n    else convert(n);\n\n    return 0;\n}\n\nvoid convert(int n){\n    //Case n = 0\n    if (n == 0)  return;\n\n    else{\n        //Case n > 0\n        char* romanNums[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\n        int arabicNums[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n        int biggestNo = max(arabicNums, 13, n); //Biggest number in arabicNums[] smaller than n\n\n        printf(\"%s\", romanNums[biggestNo]); //Print the biggest number as a Roman numeral\n        convert(n - arabicNums[biggestNo]); //Convert the remaining\n\n    }\n}\n\n//This function determines the maximum number in arr[] smaller than n\nint max(int arr[], int size, int n){\n    int i, max;\n    for(i = size; i > 0; i--){\n        if (n <= arr[i]) max = i;\n    }\n    return max;\n}\n```\n\n    ", "Answer": "\r\nYou have 2 missing point on your code:\n\nOn function max:\n\n```\nfor(i = 0; i < size; i++){\n    if (n < arr[i]) max = i;\n}\n```\n\n\nmust be:\n\n```\nfor(i = 0; i <= size; i++){\n    if (n >= arr[i]) max = i;   // Equal is require. Isn't it?\n}\n```\n\n\nOn your main function: function convert:\n\n```\nconvert(n - biggestNo);             //Convert the remaining\n```\n\n\nmust be:\n\n```\nconvert(n - arabicNums[biggestNo]);\n```\n\n\nbiggestNo is seq number, not is value for div\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Simple greedy algorithm. Infinite loop\r\n                \r\nI wrote a simple greedy algorithm, but somehow it doesn't work. \n\n```\n#include <stdio.h>\n#include <iostream>\n#include <conio.h>\n\nint main(void)\n{\n    float change;\n    std::cout << \"Change: \";\n    std::cin >> change;\n    int quantity = 0;\n    while(change > 0.0){\n        if(change >= 0.5){\n            change -= 0.5;\n        }\n        else if(change >= 0.25){\n            change -= 0.25;\n        }\n        else if(change >= 0.1){\n            change -= 0.1;\n        }\n        else if(change >= 0.05){\n            change -= 0.05;\n        }\n        else if(change >= 0.01){\n            change -= 0.01;\n        }\n        quantity++;\n        std::cout << change << std::endl;\n    }\n    std::cout << quantity << std::endl;\n    _getch();\n    return 0;\n}\n```\n\n\nWhile it works for 0.5 and 0.25 it doesn't for 0.01 or 0.1 for example. (it looks like it returns some really small number)\nI can't see where the problem is.\n\n//EDIT\nConverted everything to int values to avoid problem mentioned below Zeno\n    ", "Answer": "\r\nThe problem is elementary: While 0.5, 0.25, 0.125, ... are 'exact' floating point numbers 0.1, 0.01 are not: You compare/subtract is wrong.\nIn the set 0.1 ... 0.9 the only 'exact' floating point is 0.5.\n\n(All of that assumes binary floating points)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Make Greedy Algorithm Fail on Subset of Euro Coins\r\n                \r\nA greedy change-making algorithm is one that makes change by choosing the highest denomination of coin available until it reaches the amount of change it is trying to make. Surprisingly, this algorithm actually works for making change in the most efficient manner for US and Euro coin denominations!\n\nHowever, the greedy algorithm can sometimes fail for making change. Suppose we have the denominations [25,15,1] and are trying to make 31 cents. The greedy algorithm would pick 25,1,1,1,1,1,1 (7 coins) while 31 cents can actually be made as 15,15,1 (3 coins).\n\nWhat I'm wondering is if there's a way to make the greedy algorithm fail for a SUBSET of Euro coins (the list of Euro coins is 1,2,5,10,20,50,100,200) that includes the denomination 1.  While I can make the greedy algorithm fail subsets with other values, I can't seem to make it fail for a subset of the Euro coins.\n\nSome resources say that the greedy algorithm will fail whenever the highest element plus the lowest element is less than twice the second highest element (so in the example from above, 25 + 1 < 15 + 15), but there is no way to make this possible with a subset of Euro coins.\n    ", "Answer": "\r\nTry to make 60 with 1, 20, 50.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "A way to prove that there's no greedy algorithm that obtains optimal solution?\r\n                \r\nThe question is pretty simple. I need to prove that there's no greedy algorithm that can obtain the optimal solution for a given problem. \n\nIt is unclear to me if there is any condition that a problem must meet so that exists a certain greedy algorithm to obtain the optimal solution. Or if there is any sufficient condition for the problem not to be solvable by a greedy algorithm. \n\nI am precisely talking about the greedy coloring:\n\n\n  http://en.wikipedia.org/wiki/Greedy_coloring\n\n    ", "Answer": "\r\n\n  I need to prove that there's no greedy algorithm that can obtain the\n  optimal solution for a given problem.\n\n\nWell, that's going to depend on the definition of the property you chose.\n\nHave a look for example on the graph coloring problem, and assume you have an oracle ```\nM```\n that given a partially colored graph, returns true if and only if there is a graph coloring for it.\n\nNow, using this oracle, a greedy algorithm can be as follows:\n\n```\nfor each vertex v:\n   for each color c:\n        temporarly color v with c\n        run M on partially colored graph\n        if M yields true, make c constant to v, and abort the inner loop\n```\n\n\nThe above algorithm is coloring the graph in a greedy manner, chosing one vertex at a time, according to the answer of the oracle ```\nM```\n. (Choosing the best answer of ```\nM```\n and assigning it to each vertex and color, where set of answers is false or true)\n\nDoes it feel like cheating? Probably, because there is no known such ```\nM```\n that runs in polynomial time, but if you run an exponential algorithm that creates ```\nM```\n, there is definetly a greedy algorithm for it.\n\nYou can however prove that there is no KNOWN algorithm that greedily chooses in polynomial time (or any other polynomial algorithm for that matter) that yields an optimal answer for graph coloring, since graph coloring is NP-Complete, and we don't know any algorithm that solves NPC problems efficiently (and most believe such does not exist).\n\nHowever, if at some point we will prove P=NP, we can efficiently calculate ```\nM```\n, and we will get an efficient greedy algorithm that solves graph coloring.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "A Greedy algorithm for k-limited resources\r\n                \r\nI am studying greedy algorithms and I am wondering the solution for a different case.\n\nFor interval selection problem we want to pick the maximum number of activities that do not clash with each other, so selecting the job with the earliest finishing time works.\n\nAnother example; we have n jobs given and we want to buy as smallest number of resources as possible. Here, we can sort all the jobs from left to right, and when we encounter a new startpoint, we increment a counter and when we encounter an endpoint, we decrement the counter. So the largest value we get from this counter will be number of resources we need to buy.\n\nBut for example, what if we have n tasks but k resources? What if we cannot afford more then k resource? How should be a greedy solution to remove as few tasks as possible to satisfy this?\n\nAlso if there is a specific name for the last problem I wrote, I would be happy to hear that.\n    ", "Answer": "\r\nThis looks like a general case of the version where we have only one resource.\n\nIntuitively, it makes sense to still sort the jobs by end time and take them one by one in that order. Now, instead of the ending time of the last job, we keep track of the ending times of the last k jobs accepted into our resources. For each job, we check if the current jobs starting time is greater that the last job in any one of our resources. If no such resource is found, we skip that job and move ahead. If one resource is found, we assign that job to that resource and update ending time. If there are more than one resource able to take on that job,  it makes sense to assign it to the resource with the latest end time.\n\nI don't really have a proof of this greedy strategy, so it may well be wrong.  But I cannot think of a case where changing the choice might enable us to fit more jobs.   \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Ways of implementing a greedy algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nSo, I have an assignment that I have to represent both adjacent and incidence matrixes statically and then, use a greedy algorithm to find the shortest path (I guess that it can be lowest cost as well, not sure) that goes through all vertices having 1 as origin.\n\nHere's an image of the graph:\n\n\n\nI'm kinda lost on how to do it, could somebody please give me some tips? \n    ", "Answer": "\r\nGreedy Algorithm:\n\n```\nWhile (Not at node 1)\n{\n  if already visited current node, fail.\n  look at all current node's exit costs and choose the lowest as next destination.\n  go to next location.\n}\nsuccess.\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Faulty server and greedy algorithm\r\n                \r\nThe topic I am currently working on is called Greedy Algorithms. There is such a task\n\nThere is a faulty server that can work without restarting no longer\nthan t minutes. Restarting a server takes exactly one minute.\nYou are given a list of times when there will be no requests to the server\nfor a minute in the form of integers representing difference between\nno-request start time and current time, sorted increasingly. So that is the\nonly possible time slots (each one is 1 minute time long) when the server\ncan be restarted.\nYou should output the minimum time of restarts needed for server to work for\nm minutes starting from now. If the server would have to restart when there\nare requests sent to it (i.e. it is impossible to fit all the restarts into\nthe given time slots), output -1 insteed.\n\nMy naive solution looks so\n```\ndef minRestarts(m, t, no_request_times):\n    min_restarts = 0\n    rest_times = []\n    rt=t\n    while t <= m:\n        rest_times.append(t)\n        t += rt+1\n    for i in rest_times:\n        if i in no_request_times:\n            min_restarts += 1\n        else:\n            return -1\n    return min_restarts\n```\n\nI'm not sure if there is anything greedy here but it seems to work on such test for example\n```\nm=100\nt=20\nno_request_times = [50] \n```\n\nIt outputs -1. But on the other test\n```\nm=100\nt=20\nno_request_times = [20,41,62,83]\n```\n\nI have 4 as the output. But it must be -1? Or my answer is correct? May be I don't understand the task. Could you please tell me if it is correct.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm broken implementation\r\n                \r\nI'm trying to implement a greedy algorithm below, So I'm trying to follow the gist of the algorithm details, but I'm getting an error at my IF statement:  java.lang.IndexOutOfBoundsException: Index: 4, Size: 4 \nDoes anyone know if the below method is how I should be approaching this?\n\n\n  \n  Color first vertex with first color.\n  Do following for remaining V-1 vertices.\n  \n  a) Consider the currently picked vertex and color it with the \n               lowest numbered color that has not been used on any previously\n               colored vertices adjacent to it. If all previously used colors \n               appear on vertices adjacent to v, assign a new color to it. */\n  \n\n\n```\npublic void greedy(LinkedHashMap<String, Node> nodes) {         \n    ArrayList<Integer> colors = new ArrayList<Integer>();\n    ArrayList<Integer> colorsUsed = new ArrayList<Integer>();\n\n    nodes.entrySet().iterator().next().getValue().currentColor = 1; \n    colorsUsed.add(1);\n    for (Map.Entry<String,Node> entry : nodes.entrySet()) {\n        for (int i = 0; i < nodes.entrySet().size(); i++) {\n            if(entry.getValue().edges.get(i).currentColor == 0) {\n                //assign a color\n                System.out.println(colors.get(i));\n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nYour nested loop doesn't make much sense and it's the cause of the exception (you stop ```\ni```\n at the number of nodes instead of the number of edges per node, hence the index ```\ni```\n is out of the bounds of the collection ```\nentry.getValue().edges```\n).\n\nYou should probably replace\n\n```\nfor (int i = 0; i < nodes.entrySet().size(); i++) {\n                    ^^^^^^^^^^^^^^^^^^^^^^^\n    if(entry.getValue().edges.get(i).currentColor == 0) {\n```\n\n\nWith something like\n\n```\nfor (int i = 0; i < entry.getValue().edges.size(); i++) {\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    if(entry.getValue().edges.get(i).currentColor == 0) {\n```\n\n\n(Supposing ```\nNode#edged```\n implements java.util.List)\n\nAlso, ```\ncolors.get(i)```\n doesn't make much sense either...\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is the difference between greedy and best-first search algorithms?\r\n                \r\n\nBest-first search - a search that has an evaluation function f(n) that determines the cost of expanding node n and chooses the lowest cost available node\nUninformed search - has no knowledge of h(n)\nInformed search - has knowledge of h(n)\nGreedy search - is best-first, can be informed or uninformed, f(n) does not contain g(n)\nUniform cost search - is best-first, is not greedy, is uninformed, f(n) = g(n)\nA* search - is best-first, is not greedy, is informed, f(n) = g(n) + h(n)\nGreedy best-first search - is best-first, is greedy, is informed, f(n) = h(n)\n\n\nIs this correct? Can someone give concrete and all-encompassing definitions for these terms? It seems that \"greedy\" and \"best-first\" are often used interchangeably. \n\nEven Wikipedia has conflicting definitions...\n\nGreedy algorithm - Wikipedia:\n\n\n  Dijkstra's algorithm and the related A* search algorithm are verifiably optimal greedy algorithms\n\n\nBest-first search - Wikipedia:\n\n\n  The A* search algorithm is an example of a best-first search algorithm, as is B*. Best-first algorithms are often used for path finding in combinatorial search. Neither A* nor B* is a greedy best-first search, as they incorporate the distance from the start in addition to estimated distances to the goal.\n\n\nIs it that A* is greedy, A* is best-first, but A* is not greedy best-first? \n\nSomeone please sort all these terms out...\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Python Traveling Salesman Greedy Algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nSo I have created a sort for my traveling salesman problem and I con sort by the x-coordinates and the y-coordinates.\n\nI am trying to implement a greedy search, but am unable to.\n\nAlso, each point is instantiated in the matrix city such as [0,3,4] where 0 is the header, 3 is the x coordinate, and 4 is the y coordinate.\n\nHere is my program which you should be able to run. The main problem is that my algorithm isn't working and I need help fixing it to a working greedy algorithm. You can find the algorithm near the end of the code.\n\nhttp://pastebin.com/ABQ3x0PG\n\nThis is the text file you will need which it takes the input from.\n\nhttp://pastebin.com/c1UQzqEB\n    ", "Answer": "\r\nThe Traveling Salesman Problem (TSP) is a combinatorial optimization\nproblem, where given a map (a set of cities and their positions), one\nwants to find an order for visiting all the cities in such a way that\nthe travel distance is minimal.\n\nI would suggest solving the tsp and then solve the visual stuff.\n\nFollowing code contains a set of functions to illustrate:\n  - construction heuristics for the TSP\n  - improvement heuristics for a previously constructed solution\n  - local search, and random-start local search.\n\n```\nimport math\nimport random\n\n\ndef distL2((x1,y1), (x2,y2)):\n    \"\"\"Compute the L2-norm (Euclidean) distance between two points.\n\n    The distance is rounded to the closest integer, for compatibility\n    with the TSPLIB convention.\n\n    The two points are located on coordinates (x1,y1) and (x2,y2),\n    sent as parameters\"\"\"\n    xdiff = x2 - x1\n    ydiff = y2 - y1\n    return int(math.sqrt(xdiff*xdiff + ydiff*ydiff) + .5)\n\n\ndef distL1((x1,y1), (x2,y2)):\n    \"\"\"Compute the L1-norm (Manhattan) distance between two points.\n\n    The distance is rounded to the closest integer, for compatibility\n    with the TSPLIB convention.\n\n    The two points are located on coordinates (x1,y1) and (x2,y2),\n    sent as parameters\"\"\"\n    return int(abs(x2-x1) + abs(y2-y1)+.5)\n\n\ndef mk_matrix(coord, dist):\n    \"\"\"Compute a distance matrix for a set of points.\n\n    Uses function 'dist' to calculate distance between\n    any two points.  Parameters:\n    -coord -- list of tuples with coordinates of all points, [(x1,y1),...,(xn,yn)]\n    -dist -- distance function\n    \"\"\"\n    n = len(coord)\n    D = {}      # dictionary to hold n times n matrix\n    for i in range(n-1):\n        for j in range(i+1,n):\n            (x1,y1) = coord[i]\n            (x2,y2) = coord[j]\n            D[i,j] = dist((x1,y1), (x2,y2))\n            D[j,i] = D[i,j]\n    return n,D\n\ndef read_tsplib(filename):\n    \"basic function for reading a TSP problem on the TSPLIB format\"\n    \"NOTE: only works for 2D euclidean or manhattan distances\"\n    f = open(filename, 'r');\n\n    line = f.readline()\n    while line.find(\"EDGE_WEIGHT_TYPE\") == -1:\n        line = f.readline()\n\n    if line.find(\"EUC_2D\") != -1:\n        dist = distL2\n    elif line.find(\"MAN_2D\") != -1:\n        dist = distL1\n    else:\n        print \"cannot deal with non-euclidean or non-manhattan distances\"\n        raise Exception\n\n    while line.find(\"NODE_COORD_SECTION\") == -1:\n        line = f.readline()\n\n    xy_positions = []\n    while 1:\n        line = f.readline()\n        if line.find(\"EOF\") != -1: break\n        (i,x,y) = line.split()\n        x = float(x)\n        y = float(y)\n        xy_positions.append((x,y))\n\n    n,D = mk_matrix(xy_positions, dist)\n    return n, xy_positions, D\n\n\ndef mk_closest(D, n):\n    \"\"\"Compute a sorted list of the distances for each of the nodes.\n\n    For each node, the entry is in the form [(d1,i1), (d2,i2), ...]\n    where each tuple is a pair (distance,node).\n    \"\"\"\n    C = []\n    for i in range(n):\n        dlist = [(D[i,j], j) for j in range(n) if j != i]\n        dlist.sort()\n        C.append(dlist)\n    return C\n\n\ndef length(tour, D):\n    \"\"\"Calculate the length of a tour according to distance matrix 'D'.\"\"\"\n    z = D[tour[-1], tour[0]]    # edge from last to first city of the tour\n    for i in range(1,len(tour)):\n        z += D[tour[i], tour[i-1]]      # add length of edge from city i-1 to i\n    return z\n\n\ndef randtour(n):\n    \"\"\"Construct a random tour of size 'n'.\"\"\"\n    sol = range(n)      # set solution equal to [0,1,...,n-1]\n    random.shuffle(sol) # place it in a random order\n    return sol\n\n\ndef nearest(last, unvisited, D):\n    \"\"\"Return the index of the node which is closest to 'last'.\"\"\"\n    near = unvisited[0]\n    min_dist = D[last, near]\n    for i in unvisited[1:]:\n        if D[last,i] < min_dist:\n            near = i\n            min_dist = D[last, near]\n    return near\n\n\ndef nearest_neighbor(n, i, D):\n    \"\"\"Return tour starting from city 'i', using the Nearest Neighbor.\n\n    Uses the Nearest Neighbor heuristic to construct a solution:\n    - start visiting city i\n    - while there are unvisited cities, follow to the closest one\n    - return to city i\n    \"\"\"\n    unvisited = range(n)\n    unvisited.remove(i)\n    last = i\n    tour = [i]\n    while unvisited != []:\n        next = nearest(last, unvisited, D)\n        tour.append(next)\n        unvisited.remove(next)\n        last = next\n    return tour\n\n\n\ndef exchange_cost(tour, i, j, D):\n    \"\"\"Calculate the cost of exchanging two arcs in a tour.\n\n    Determine the variation in the tour length if\n    arcs (i,i+1) and (j,j+1) are removed,\n    and replaced by (i,j) and (i+1,j+1)\n    (note the exception for the last arc).\n\n    Parameters:\n    -t -- a tour\n    -i -- position of the first arc\n    -j>i -- position of the second arc\n    \"\"\"\n    n = len(tour)\n    a,b = tour[i],tour[(i+1)%n]\n    c,d = tour[j],tour[(j+1)%n]\n    return (D[a,c] + D[b,d]) - (D[a,b] + D[c,d])\n\n\ndef exchange(tour, tinv, i, j):\n    \"\"\"Exchange arcs (i,i+1) and (j,j+1) with (i,j) and (i+1,j+1).\n\n    For the given tour 't', remove the arcs (i,i+1) and (j,j+1) and\n    insert (i,j) and (i+1,j+1).\n\n    This is done by inverting the sublist of cities between i and j.\n    \"\"\"\n    n = len(tour)\n    if i>j:\n        i,j = j,i\n    assert i>=0 and i<j-1 and j<n\n    path = tour[i+1:j+1]\n    path.reverse()\n    tour[i+1:j+1] = path\n    for k in range(i+1,j+1):\n        tinv[tour[k]] = k\n\n\ndef improve(tour, z, D, C):\n    \"\"\"Try to improve tour 't' by exchanging arcs; return improved tour length.\n\n    If possible, make a series of local improvements on the solution 'tour',\n    using a breadth first strategy, until reaching a local optimum.\n    \"\"\"\n    n = len(tour)\n    tinv = [0 for i in tour]\n    for k in range(n):\n        tinv[tour[k]] = k  # position of each city in 't'\n    for i in range(n):\n        a,b = tour[i],tour[(i+1)%n]\n        dist_ab = D[a,b]\n        improved = False\n        for dist_ac,c in C[a]:\n            if dist_ac >= dist_ab:\n                break\n            j = tinv[c]\n            d = tour[(j+1)%n]\n            dist_cd = D[c,d]\n            dist_bd = D[b,d]\n            delta = (dist_ac + dist_bd) - (dist_ab + dist_cd)\n            if delta < 0:       # exchange decreases length\n                exchange(tour, tinv, i, j);\n                z += delta\n                improved = True\n                break\n        if improved:\n            continue\n        for dist_bd,d in C[b]:\n            if dist_bd >= dist_ab:\n                break\n            j = tinv[d]-1\n            if j==-1:\n                j=n-1\n            c = tour[j]\n            dist_cd = D[c,d]\n            dist_ac = D[a,c]\n            delta = (dist_ac + dist_bd) - (dist_ab + dist_cd)\n            if delta < 0:       # exchange decreases length\n                exchange(tour, tinv, i, j);\n                z += delta\n                break\n    return z\n\n\ndef localsearch(tour, z, D, C=None):\n    \"\"\"Obtain a local optimum starting from solution t; return solution length.\n\n    Parameters:\n      tour -- initial tour\n      z -- length of the initial tour\n      D -- distance matrix\n    \"\"\"\n    n = len(tour)\n    if C == None:\n        C = mk_closest(D, n)     # create a sorted list of distances to each node\n    while 1:\n        newz = improve(tour, z, D, C)\n        if newz < z:\n            z = newz\n        else:\n            break\n    return z\n\n\ndef multistart_localsearch(k, n, D, report=None):\n    \"\"\"Do k iterations of local search, starting from random solutions.\n\n    Parameters:\n    -k -- number of iterations\n    -D -- distance matrix\n    -report -- if not None, call it to print verbose output\n\n    Returns best solution and its cost.\n    \"\"\"\n    C = mk_closest(D, n) # create a sorted list of distances to each node\n    bestt=None\n    bestz=None\n    for i in range(0,k):\n        tour = randtour(n)\n        z = length(tour, D)\n        z = localsearch(tour, z, D, C)\n        if z < bestz or bestz == None:\n            bestz = z\n            bestt = list(tour)\n            if report:\n                report(z, tour)\n\n    return bestt, bestz\n\n\nif __name__ == \"__main__\":\n    \"\"\"Local search for the Travelling Saleman Problem: sample usage.\"\"\"\n\n    #\n    # test the functions:\n    #\n\n    # random.seed(1)    # uncomment for having always the same behavior\n    import sys\n    if len(sys.argv) == 1:\n        # create a graph with several cities' coordinates\n        coord = [(4,0),(5,6),(8,3),(4,4),(4,1),(4,10),(4,7),(6,8),(8,1)]\n        n, D = mk_matrix(coord, distL2) # create the distance matrix\n        instance = \"toy problem\"\n    else:\n        instance = sys.argv[1]\n        n, coord, D = read_tsplib(instance)     # create the distance matrix\n        # n, coord, D = read_tsplib('INSTANCES/TSP/eil51.tsp')  # create the distance matrix\n\n    # function for printing best found solution when it is found\n    from time import clock\n    init = clock()\n    def report_sol(obj, s=\"\"):\n        print \"cpu:%g\\tobj:%g\\ttour:%s\" % \\\n              (clock(), obj, s)\n\n\n    print \"*** travelling salesman problem ***\"\n    print\n\n    # random construction\n    print \"random construction + local search:\"\n    tour = randtour(n)     # create a random tour\n    z = length(tour, D)     # calculate its length\n    print \"random:\", tour, z, '  -->  ',   \n    z = localsearch(tour, z, D)      # local search starting from the random tour\n    print tour, z\n    print\n\n    # greedy construction\n    print \"greedy construction with nearest neighbor + local search:\"\n    for i in range(n):\n        tour = nearest_neighbor(n, i, D)     # create a greedy tour, visiting city 'i' first\n        z = length(tour, D)\n        print \"nneigh:\", tour, z, '  -->  ',\n        z = localsearch(tour, z, D)\n        print tour, z\n    print\n\n    # multi-start local search\n    print \"random start local search:\"\n    niter = 100\n    tour,z = multistart_localsearch(niter, n, D, report_sol)\n    assert z == length(tour, D)\n    print \"best found solution (%d iterations): z = %g\" % (niter, z)\n    print tour\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Graph Coloring with greedy algorithm\r\n                \r\nI'm trying to color a graph on Java.\n\nFor example, I have a graph like this:\n\n\n\nNow I want to fill the verticles with color 0 (red), 1 (blue), or 2 (green). One of possible result would be:\n\n```\nVertex 1 ---> Color 1 \nVertex 2 ---> Color 1 \nVertex 3 ---> Color 2\nVertex 4 ---> Color 0\nVertex 5 ---> Color 0\nVertex 6 ---> Color 2\n```\n\n\nHere's my code with a method I found that uses greedy algorithm to color the vertex\n\n```\npublic class Graph {\n            int V;\n            int[] verticleColor;\n            boolean[] colorAvailable;\n            ArrayList<ArrayList<Integer> > adjList;\n\n            Graph(int v) { \n                V = v; \n                adjList = new ArrayList<ArrayList<Integer> >(V); \n                for (int i = 0; i < V+1; i++) {\n                    adjList.add(new ArrayList<Integer>()); \n                }\n            } \n\n            public void add(int x, int y) { \n                adjList.get(x).add(y); \n                adjList.get(y).add(x); \n            }\n\n            public void colorTheVerticle() {\n                 verticleColor = new int[V]; \n\n                for (int a = 0; a < verticleColor.length; a++) {\n                    if (a == 0) {\n                        verticleColor[a] = 0;\n                    } else {\n                        verticleColor[a] = -1;\n                    }\n                }\n\n                colorAvailable = new boolean[V]; \n                for (int b = 0; b < colorAvailable.length; b++) {\n                    colorAvailable[b] = true;\n                }\n\n\n\n                for (int c = 1; c < V; c++) {\n                    Iterator<Integer> it = adjList.get(c).iterator() ; \n                    while (it.hasNext()) { \n                        int i = it.next();\n                        if (verticleColor[i-1] != -1)  {\n                            colorAvailable[verticleColor[i]] = false; \n                        }\n                    } \n\n\n                    int color; \n                    for (color = 0; color < V; color++){ \n                        if (colorAvailable[color]) {\n                            break; \n                        }\n                    } \n\n                    verticleColor[c] = color; \n\n                    for (int d = 0; d <  colorAvailable.length; d++) {\n                        colorAvailable[d] = true;\n                    } \n                } \n\n                for (int u = 1; u < V+1; u++) {\n                    System.out.println(\"Vertex \" + u + \" ---> Color \" + verticleColor[u-1]);\n                }\n}\n```\n\n\nThe problem is, I get different result than I hoped for, which is:\n\n```\nVertex 1 ---> Color 0\nVertex 2 ---> Color 0\nVertex 3 ---> Color 0\nVertex 4 ---> Color 1\nVertex 5 ---> Color 0\nVertex 6 ---> Color 2\n```\n\n\nAlso, changing a bit of the method would get me ArrayIndexOutOfBoundsException error.\n\nA little explanation would be helpful.\n    ", "Answer": "\r\nNot working with Java at the moment but I can understand the code.\n\nThe code depends on 2 facts:\n\n\nFor a graph of n vertices at most n colors will have to be used.\nLoop through each vertex and assign an available color based on available colors list not used on colors of adjacent vertices.\n\n\nThe above facts suggest the greedy algorithm used which at most will use n colors but often less than n colors (unless every vertex is connected to each other) although not optimal in general.\n\nAnalysing the method that computes the coloring we have:\n\ninitialisation steps\n\n```\nverticleColor = new int[V]; // initialise the colors assigned to each vertex to a list\n\nfor (int a = 0; a < verticleColor.length; a++) {\n   if (a == 0) {\n      verticleColor[a] = 0; // we can assign the first color to first vertex, no problem\n   } else {\n      verticleColor[a] = -1; // else for rest vertices, no assigned color yet\n   }\n}\n\n\ncolorAvailable = new boolean[V]; // initialise a list of available colors to assign to vertices, at most n\nfor (int b = 0; b < colorAvailable.length; b++) {\n   colorAvailable[b] = true; // initially all colors are available for assignment\n}\n```\n\n\nmain computation loop\n\n```\n            for (int c = 1; c < V; c++) { // for all vertices, except first\n                Iterator<Integer> it = adjList.get(c).iterator() ; // get iterator that loops through current vertex's adjacent vertices\n                while (it.hasNext()) { \n                    int i = it.next(); // adjacent vertex\n                    if (verticleColor[i-1] != -1)  { // if assigned color\n                        colorAvailable[verticleColor[i]] = false; // this color is not available anymore\n                    }\n                } \n\n\n                int color; \n                for (color = 0; color < V; color++){ // loop through all colors\n                    if (colorAvailable[color]) {\n                        break; // find first available color, we can always find an available color since we have at most n possible colors\n                    }\n                } \n                /* effectively availableColors list holds the available and\n                 used colors for each vertex and its adjacent/connected \n                 vertices, but we do not need to store multiple \n                 availableColors for each vertex, we can re-use same, no problem\n                */\n                verticleColor[c] = color; // color the vertex with this color\n\n                // for next round, all colors are again available\n                for (int d = 0; d <  colorAvailable.length; d++) {\n                    colorAvailable[d] = true; // available color\n                } \n            } \n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm, error : expected identifer\r\n                \r\nSo I'm writing code for a class, and the job is to create a greedy algorithm. I wrote code that should work, but I'm getting an error code. Did I forget a {} somewhere or what's wrong here? The exact error is :\npractice.c:14:9: error: expected identifier or '('\ndo\n^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\n2 errors generated\nmake: *** [: practice] Error 1\nSo that's my code\n```\n#include <cs50.h>\n#include <stdio.h>\nint calculate_quarters(int cents);\nint calculate_dimes(int cents);\nint calculate_nickels(int cents);\nint calculate_pennies(int cents);\nint answer(void);\nint quarters(void);\nint dimes(void);\nint nickels(void);\nint pennies(void);\nint main(void);\n    do\n    {\n        int cents = get_int(\"How much change? \\n\");\n\n        return cents;\n    }\n    while (cents <= 0)\n\n    int quarters = 0;\n    do\n    {\n        cents = cents - 25;\n        quarters++;\n    }\n    while (cents >=25)\n    return quarters;\n    return cents;\n    int dimes = 0;\n    do\n       {\n        cents = cents - 10;\n        dimes++;\n        }\n    while (cents >= 10)\n\n    return dimes;\n    return cents;\n    int nickels = 0;\n    do\n\n    {\n        cents = cents -5;\n        nickels++;\n    }\n    while (cents >= 5)\n    return nickels;\n    return cents;\n    int pennies = 0;\n    do\n    {\n        cents = cents - 1;\n        pennies++;\n    }\n     while (cents > 0)\n\n    return pennies;\n    return cents;\n    do\n    {\n        printf(\"Quarters amount: &i\\n\" quarters);\n        printf(\"\\n\");\n        printf(\"Dimes amount: &i\\n\" dimes);\n        printf(\"\\n\");\n        printf(\"Nickels amount: &i\\n\" nickels);\n        printf(\"\\n\");\n        printf(\"Pennies amount: &i\\n\" pennies);\n        printf(\"\\n\");\n    }\n    while (cents = 0)\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm for solving Horn formulas\r\n                \r\nThis is my assignment question I've been trying to understand for a couple of days and ultimately solve it. So far, I have got no success. So any guidance, help in understanding or solving the problem is appreciated.\n\nYou are given a set of ```\nm```\n constraints over ```\nn```\n Boolean variables\n{x1, x2, ..., xn}.\nThe constraints are of two types:\nequality constraints: xi = xj, for some ```\ni != j```\n\ninequality constraints: xi != xj, for some ```\ni != j```\n\nDesign an efficient greedy algorithm that given the\nset of equality and inequality constraints determines if it is\npossible or not to satisfy all the constraints simultaneously.\nIf it\nis possible to satisfy all the constraints, your algorithm should\noutput an assignment to the variables that satisfyes all the\nconstraints.\n\nChoose a representation for the input to this problem\nand state the problem formally using the notation Input: ..., Output:\n....\n\nDescribe your greedy algorithm in plain English. In what\nsense is your algorithm \"greedy\"?\n\nDescribe your greedy algorithm\nin pseudocode.\n\nBriefly justify the correctness of your algorithm.\n\nState and justify the running time of your algorithm. The more\nefficient algorithm the better.\n\n\n\nWhat I've figured out so far is that this problem is related to the Boolean satisfiability (SAT) problem. I've tried setting all the variables to ```\nfalse```\n first and then, by counter examples, prove that it cannot satisfy all the constraints at once.\nI am getting confused between constraint satisfaction problems (CSP) and Horn SAT. I read certain articles on these to get a solution and this led me to confusion. My logic was to create a tree and apply DFS to check if constraints are satisfied, whereas Horn SAT solutions are leading me to mathematical proofs.\nAny help is appreciated as this is my learning stage and I cannot master it all at once. :)\n    ", "Answer": "\r\n\n(informal) Classification:\nSo firstly, it's not the boolean SAT problem, because that's NP-complete. Your teacher has implied that this isn't NP-complete by asking for an efficient (ie. at most polynomial-time) way to always solve the problem.\nModelling (thinking about) the problem:\nOne way to think of this problem is as a graph, where inequalities represent one type of edge, while equalities represent another:\n\nThinking of this problem graphically helped me realise that it's a bit like a graph-colouring problem: we could set all nodes to ```\n?```\n (unset), then choose any node to set to ```\ntrue```\n, then do a breadth-first search from that node to set all connecting nodes (setting them to either ```\ntrue```\n or ```\nfalse```\n), checking for any contradiction. If we complete this for a connected component of the graph, without finding contradictions, then we can ignore all nodes in that part and randomly set the value of another node, etc. If we do this until no connected components are left, and we still have no contradictions, then we've set the graph in a way that represents a legitimate solution.\nSolution:\nBecause there's exactly ```\nn```\n elements, we can make an associated \"bucket\" array of the ```\nequalities```\n and another for the ```\ninequalities```\n (each \"bucket\" could contain an array of what it equates to, but we could get even more efficient than this if we wanted [the complexity would remain the same]).\nYour array of arrays for ```\nequalities```\n could be imagined like this:\n\nwhich would represent that:\n```\n0 == 1\n1 == 2\n3 == 4\n```\n\nNote that this is an irregular matrix, and requires ```\n2*m```\n space. We do the same thing for the an ```\ninequality```\n matrix. Moreover, setting up both of these arrays (of arrays) uses ```\nO(m + n)```\n space and time complexity.\nNow, if there exists a solution, {x0, x1, x2, x3}, then {!x0, !x1, !x2, !x3} is also a solution. Proof:\n(xi == xj) iff (!xi == !xj)\nSo it won't effect our solution if we set one of the elements randomly. Let's set xi to ```\ntrue```\n, and set the others to ```\n?```\n [numerically we'll be dealing with three values: ```\n0```\n (false), ```\n1```\n (true), and ```\n2```\n (unset)].\nWe'll call this array ```\nsolution```\n (even though it's not finished yet).\nNow we can use recursion to consider all the consequences of setting our value:\n(The below code is psuedo-code, as the questioner didn't specify a language. I've made it somewhat ```\nc++```\n-style, but just to keep it generic and to use the pretty formatting colours.)\n```\nbool Set (int i, bool val) // i is the index\n{\n    if (solution[i] != '?')\n        return (solution[i] == val);\n\n    solution[i] == val;\n\n    for (int j = 0; j < equalities[i].size(); j += 1)\n    {\n        bool success = Set(equalities[i][j], val);\n        \n        if (!success)\n            return false; // Contradiction found\n    }\n    \n    for (int j = 0; j < inequalities[i].size(); j += 1)\n    {\n        bool success = Set(inequalities[i][j], !val);\n        \n        if (!success)\n            return false; // Contradiction found\n    }\n\n    return true; // No contradiction found\n}\n\n\nvoid Solve ()\n{\n    for (int i = 0; i < solution.size(); i += 1)\n        solution[i] == '?';\n\n    for (int i = 0; i < solution.size(); i += 1)\n    {\n        if (solution[i] != '?')\n            continue; // value has already been set/checked\n        \n        bool success = Set(i, true);\n        \n        if (!success)\n        {\n            print \"No solution\";\n            return;\n        }\n    ]\n    \n    print \"At least one solution exists. Here is a solution:\";\n    print solution;\n}\n```\n\nBecause of the first ```\nif```\n condition in the ```\nSet```\n function, the function can only be executed (beyond the if statement) ```\nn```\n times. The ```\nSet```\n function can call itself only when passing the first ```\nif```\n statement, which it does ```\nn```\n times, 1 for each node value. Each time the ```\nSet```\n function passes into the body of the function (beyond the ```\nif```\n statement), the work it does is proportional to the number of edges associated with the corresponding node. The ```\nSolve```\n function can call the ```\nSet```\n function at most ```\nn```\n times. Hence the number of times that the function can be called is ```\nO(m+n)```\n, which corresponds to the amount of work done during the solving process.\nA trick here is to recognise that the ```\nSolve```\n function will need to call the ```\nSet```\n function ```\nC```\n times, where ```\nC```\n is the number of connected components of the graph. Note that each connected component is independent of each other, so the same rule applies: we can legitimately choose a value of one of its elements then consider the consequences.\nThe fastest solution would still need to read all of the constraints, ```\nO(m)```\n and would need to output a solution when it's possible, ```\nO(n)```\n; therefore it's not possible to get a solution with better time complexity than ```\nO(m+n)```\n. The above is a greedy algorithm with ```\nO(m+n)```\n time and space complexity.\nIt's probably possible to get better space complexity (while maintaining the ```\nO(m+n)```\n time complexity), maybe even ```\nO(1)```\n, but I'm not sure.\nAs for Horn formulas, I'm embarrassed to admit that I know nothing about them, but this answer directly responds to everything that was asked of you in the assignment.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for active contours - shrinking\r\n                \r\nI am studying and implementing the Greedy algorithm for active contours as described in paper by Donna Williams - A Fast Algorithm For Active Contours And Curvature Estimation.\n\nOne of the advantages over another implementation (by Kass et al.) should be uniform distribution of points along the contour curve. In every iteration each point tries to move itself so the distance to the previous point is as close to the average as possible.\n\nThe contour is expected to be drawn around an object in image and then to shrink around it until it is \"attached\" to the object edges.\n\nBut the problem is that the contour won't shrink. It evolves so that the points are equally spaced to each other along the contour, but the contour cannot shrink around the image object because distances between points would go below average and the algorithm would move them back.\n\nDo you have any thoughts on this? What am I missing? Other implementations of active contours do shrink, but have another drawbacks and the Greedy algorithm is supposed to be better and more stable.\n    ", "Answer": "\r\nThe researchers hardly emphasize the disadvantages of their new solution.\nDont trust the paper, too much, If you don't have heard from other sources, that\nthis algorithm works.\nI would implement only an algorithm if it is well accepted in literature (or if I have invented it ;-) ).\nCompanies need a robust solution that works, a researcher must publish something new,\nwhich may be less useable in practise, and sometimes only works well on specific test sets. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is there any idea to optimize the greedy algorithm?\r\n                \r\nI recently wrote a program to solve the backpack problem using python. It works great and generally follows the greedy algorithm (i.e. find out the best solution for every step until it's end)\n\nBut I need to optimise it based on the greedy algorithm\n(That is a part of my homework)\n\nSo could you please provide me some fundamental idea(s) to improve it?\n\n```\n    Item Name             Weight          Profit\n    Ammunition             3.00            95.00\n    Bread                  3.60            90.00\n    Firewood               2.50            56.00\n    Olive Oil              2.40            45.00\n    Water                  3.70            67.00\n    Weapon                 4.80            79.73\n```\n\n\nThis is the output of my current project. The bag capacity has been limited to 20kg, the data cannot be changed, but I need a better idea to improve it. Thank you!\n\nI am not sure about the code or the solution, but I think it is all related to \"efficiency\"\n    ", "Answer": "\r\nHere I will use the terms \"space\" and \"weight\" synonymously.\n\nOnce thing you can do is calculate the ratio ```\nprofit/weight```\n for each item. The difference in ratios times some space is the best possible improvement for that space. For example if you had empty space and might be able to squeeze some other item Z in if you rearranged, the maximum profit you could achieve from that space would be (Zratio-0ratio)*weight. You can thus generate a candidate solution based on the greedy algorithm, then use this to bound possible improvements. In general though you will want to approach this from a dynamic programming standpoint.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy algorithm for turned based game\r\n                \r\nI need to know how to implement a greedy algorithm in a card game\nusing C#.  The game is a turn based game.  When the AI should issue\nsome cards, it must be based on the latest state of other cards that\nalready are on the table.  Does anyone have a solution for this, or\nmaybe a reference for me to get started?  Thanks in advance!\n\nFor now I only finished the code to shuffle the cards:\n\n```\nList<int> cards = new List<int>();\n\nfor (int j = 1; j <= 2; j++)\n{\n    for (int i = 1; i <= 54; i++)\n    {\n        cards.Add(i);\n    }\n}\n\nList<int> ShuffledCards = new List<int>();\nRandom random = new Random();\n\nint iterations = cards.Count;\nint index = 0;\nfor (int j = 1; j <= 2; j++)\n{\n    for (int i = 0; i < iterations; i++)\n    {\n        index = random.Next(0, iterations - i);\n        ShuffledCards.Add(cards[index]);\n        cards.RemoveAt(index);\n    }\n    iterations = cards.Count;\n    index = 0;\n}\n\nShuffledCards.Reverse(0, ShuffledCards.Count);\nShuffledCards.RemoveRange(0, 8);\nShuffledCards.Reverse(0, ShuffledCards.Count);\n```\n\n    ", "Answer": "\r\nThis book is like a bible about AI. You can start with reading first 3 parts of this book.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "making greedy algorithm work for every input\r\n                \r\nI wrote a code for greedy algorithm of cs50. It works for inputs between 0 and 1. How can I make it work to inputs like 4.2 , 6.5 , 8 etc?. I have listed my code below. What should I modify in the program?\n\n```\n#include<stdio.h>\n#include<cs50.h>\n#include<math.h>\n\nint main()\n{\n    int count , change;\n    float cents;\n    printf(\"Enter the change amount : \");\n    cents = GetFloat();\n    cents = cents * 100;\n    change = round(cents);\n    count = 0;\n\n    while(cents < 0 )\n    {\n        printf(\"Enter a positive number : \");\n        cents = GetFloat();\n    }\n\n    while (change >= 25)\n    {\n        change = change - 25;\n        count++;\n    }\n\n    while (change < 25 & change >= 10)\n    {\n        change = change - 10;\n        count++;\n    }\n    while (change < 10 & change >= 5)\n    {\n        change = change - 5;\n        count++;\n    }\n    while (change < 5 & change >= 1)\n    {\n        change = change - 1;\n        count++;\n    }\n\n    printf(\"Total number of coins used : \" );\n    printf (\" %d \" ,  count );\n    printf(\"\\n\");\n\n}\n```\n\n    ", "Answer": "\r\nI believe that your problem is that you are using bitwise logical operators. You should use ```\n&&```\n in your comparisons to compare the values of two expressions. There are other little issues: The loop that guarantees positive input should multiply ```\ncents```\n by 100 and ```\nround()```\n, before assigning this new value to change. But you don't actually need both ```\nchange```\n and ```\ncents```\n. And you don't need as many comparisons as you have written, and without the extra comparisons, you don't need the logical operators that were causing you trouble in the first place!\nEdit\nI noticed that a number like ```\n4.20```\n was being rounded first, then multiplied by 100! Of course this is wrong, giving the same results for ```\n4.20```\n, ```\n4.75```\n, and ```\n4```\n. I changed the code below accordingly, but your original code was doing this part correctly (except in the input validation loop, as mentioned earlier). Now the program correctly handle such inputs.\nHere is a cleaned-up version (I don't have the ```\ncs50.h```\n library, so there are some small differences):\n```\n#include <stdio.h>\n#include <math.h>\n\nint main(void)\n{\n    int count;\n    float cents;\n\n    printf(\"Enter the change amount: \");\n    scanf(\"%f\", &cents);\n    cents = (float)round(cents * 100);\n    count = 0;\n\n    while (cents < 0) {\n        printf(\"Enter a positive number: \");\n        cents = (float)round(cents * 100);\n    }\n\n    while (cents >= 25) {\n        cents -= 25;\n        count++;\n    }\n    while (cents >= 10) {\n        cents -= 10;\n        count++;\n    }\n    while (cents >= 5) {\n        cents -= 5;\n        count++;\n    }\n    while (cents >= 1) {\n        cents -= 1;\n        count++;\n    }\n\n    printf(\"Total number of coins used: %d\\n\", count);\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy algorithm (with coins) in C\r\n                \r\nIn my code I usede the greedy algorithm in order to use the minimum amaount of coins. For example: I must return $0.41, the minimum amount of coins I can use is 4:\n\n```\n1 - 0,25;\n1 - 0.10;\n1 - 0.05;\n1 - 0.01;\n```\n\n\nThere are 4 types of coins: 0.25,0.10,0.05,0.01.\n\nHere is my code:\n\n```\n#include <stdio.h>\n#include <cs50.h>\n\nint main(void)\n{\n    printf(\"Enter the sum, that you want to return you:\");\n    float sum = GetFloat();\n    float quaters = 0.25;\n    float dime = 0.10;\n    float nickel = 0.05;\n    float penny = 0.01;\n    int count_q = 0,count_d = 0,count_n = 0,count_p = 0;\n\n\n    while(sum<0){\n        printf(\"Incorrect, enter the positive float number\");\n        sum = GetFloat();\n    }\n\n    while(sum > 0){\n        if(sum - quaters >=0){\n            sum -=quaters;\n            count_q +=1;\n        }\n        else if((sum -quaters <0) && (sum -dime>=0)){\n            sum -= dime;\n            count_d +=1;\n        }\n        else if((sum - dime <0) &&(sum - nickel>=0) ){\n            sum -= nickel;\n            count_n +=1;\n        }\n        else if(sum - nickel <0){\n            sum -= penny;\n            count_p +=1;\n        }\n    }\n    printf(\"The number of quaters: %i\\n\",count_q);\n    printf(\"The number of dimes: %i\\n\",count_d);\n    printf(\"The number of nickels: %i\\n\",count_n);\n    printf(\"The number of pennies: %i\\n\",count_p);\n}\n```\n\n\nThis code calculates how many coins of each type of was used to return the sum. In most cases it works fine.\n\nBut sometimes, for example, when i enter the number 1.12 it gives me wrong result:\n\n```\nEnter the sum, that you want to return you:1.12\nThe number of quaters: 4\nThe number of dimes: 1\nThe number of nickels: 0\nThe number of pennies: 3\n```\n\n\nI think, that the problem is in last else if statement. But i don't know how can I correct it.\n    ", "Answer": "\r\nTo my understanding, there is no bug in your code in the strictest sense, as the reasoning on which the implementation is based (a greedy algorithm) is correct. You are most likely experiencing rounding errors due to repeated subtraction, as you use ```\nfloat```\n, the single-precision floating type to represent your values. Perhaps, if you change ```\nfloat```\n to ```\ndouble```\n in your code, the output will be as expected for your example input.\n\nHowever, this only pushes the boundaries of the limitation. Perhaps it would be better to internally represent the amount of money in pennies as ```\nint```\n.\n\nNote that, when first confronted with the fact that floating point representations are inaccurate, I believed that the impossibility to represent some values and accumulation of rounding errors would be an issue only when you absolutely do some rocket science calculations, but would never be relevant for what I considered to be layman's calculations. However, this is not the case.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Dynamic vs Greedy Algorithms : The debate regarding Neil G's answer on the same topic\r\n                \r\nI was trying to understand the differences between Dynamic and Greedy algorithms, and This answer by Neil G was quite helpful, but, there was this one statement that he made which caused a debate in the comments section.\n\n\n  The difference between dynamic programming and greedy algorithms is that with dynamic programming, the subproblems overlap. That means that by \"memoizing\" solutions to some subproblems, you can solve other subproblems more quickly.\n\n\nComments aren't the best place to solve a doubt, so i'm creating this post. My questions are :\n\n Minimum spanning trees have Optimal substructure as well as Overlapping Sub-problems. Also, in an MST, a locally optimal choice is globally optimal. Thus both Dynamic and Greedy properties hold right? How does the above quoted part hold up to this?\n\n How is the property of optimal substructure different to the property \"locally optimal then also globally optimal\" ? My head is going : If something has an optimal substructure, then all locally optimal choices must also be globally optimal right ? Can someone explain where i'm going wrong here ?\n\nEnglish is not my native language, so please feel free to correct any mistakes with the language.\n    ", "Answer": "\r\nI think the explanation of the difference between a greedy and dynamic solutions is not good. A greedy solution makes choices only using local information i.e. what looks best as of the current position. As a result greedy solutions may \"get stuck\" at a local optimum instead of the global one. Dynamic programming is a technique in which you break a single more complex problem to simpler subproblems and then you combine the results from the subproblems to obtain the result for the initial problem. A solution can be both greedy and dynamic. Take a look at my answer to the original thread.\n\nHowever this statement of yours:\n\n```\nIf something has an optimal substructure, then all locally optimal\nchoices must also be globally optimal right?\n```\n\n\nIs wrong. Take for example the 0,1 knapsack example: you are a thief, breaking into some shop a night. You have a knapsack and it has a fixed weight capacity. The shop has some products each with associated price and weight. Steal the greatest price possible. \n\nNow take the example where you have knapsack of capacity 50 and products of price and weight respectively (21, 20), (30, 22), (22, 21), and (9, 9). If you make choices that are locally optimal(i.e. each time you select the item with greatest price/weight ratio) you will select the products (30, 22) and (21, 20) while this solution is not optimal. The optimal solution would be to take (21, 20), (22, 21) and (9,9) resulting in profit that is bigger by 2.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Complexity of greedy algorithm for TSP\r\n                \r\nI have a complete graph G = (V, E), with n vertices. I want to create a path that starts from a vertices, passes through all other vertices exactly once and returns to the start (a.k.a. a Hamiltonian path) of minimum length.\nEdit: This is the Traveling Salesman Problem (TSP), which is NP-Hard. I want to find a demonstration for this approximation algorithm:\nGreedy algorithm:\n\nSort list L of all edges\nCreate empty list I\nfor e in L:\n3.1 if I+e does not form a cycle, add e to I\nreturn I\n\nI used \"+\" to show the union between a list and a element\nThe time complexity for the standard greedy algorithm is O(n*log(n)), if step 3 does not take longer.\nIn this case, the internet says that the time complexity is O(n^2*log(n)), because the algorithm has to check if there is a cycle before adding any edge to the list and I don't know how to demonstrate this complexity.\nIn my implementation, I used a breath first search to determine the absence of cycles, but I  am not sure if there is a faster method that would give the complexity I am looking for.\nEdit: the solution does not need to use BFS, I can alter my implementation at any time.\nTo be clear, I know that the complexity is O(n^2*log(n)), I just need to demonstrate it.\n    ", "Answer": "\r\nThe algorithm you describe does not produce a TSP solution, but a minimum spanning tree; in fact it is Kruskal's algorithm. The actual time complexity (assuming an efficient implementation) is ```\nO(n log n)```\n. Checking for a cycle can be done simply by maintaining a disjoint set structure and checking whether the vertices of an edge are in the same connected component.\nIf, rather than just avoiding cycles, you also avoided adding any edge which would result in a vertex with degree > 2, you would end up with a Hamiltonian path (the one from the minimum spanning tree). The time complexity (again, assuming an efficient implementation) would be the same, dominated by the edge sort.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why greedy algorithm is heuristic, not meta-heuristic?\r\n                \r\nAFAIK, heuristic algorithm is problem-dependent and meta-heuristic are problem-independent, according to this answer.1\n\nBut greedy algorithm can apply to many problems, such as minimum spanning tree and shortest path problem. My question is that why is it problem-dependent, not problem-independent? \n    ", "Answer": "\r\nThere are a lot of greedy algorithms for different problems, greedy algorithm is not the one particular algorithm, it's a class of algorithms that use the same approach to the problem. Dijkstra's algorithm, Prim's algorithm, Kruskal's algorithm, etc. are completely different, but they are all greedy.\n\nIn Dijkstra's algorithm you take an untouched node with minimal distance to it.\nIn Prim's algorithm you take an edge, that connects tree node with not-tree node, with minimal weight.\nIn Kruskal's algorithm you take an edge, that connects two different trees, with minimal weight.\nAnd there are many greedy algorithms that don't even work with graphs.\n\nAll these heuristics are different and problem-specific, because these algorithms solve completely different problems.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy algorithm pseudo code [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking for code must demonstrate a minimal understanding of the problem being solved. Include attempted solutions, why they didn't work, and the expected results. See also: Stack Overflow question checklist\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nSuppose you have to drive from Islamabad to Lahore. At the start, your gas tank is full. Your gas tank, when full, holds enough gas to travel ```\nm```\n miles, and you have a map that gives distances between gas stations along the route. Let ```\nd1 < d2 < … < dn```\n be the locations of all the gas stations along the route, where ```\ndi```\n is the distance from Islamabad to the gas station. The distance between neighboring gas stations is at most ```\nm```\n miles. Also, the distance between the last gas station and Lahore is at most ```\nm```\n miles.\n\nYour goal is to make as few gas stops as possible along the way. Give a greedy algorithm (in pseudo-code form) to determine at which gas stations you should stop. \n\nIs your solution optimal? What is the time complexity of your solution?\n    ", "Answer": "\r\nThis algorithm begins at Islamabad, and repeatedly tries to drive as far as possible without running out of gas.\n\n```\ncurrent_distance = 0\ncurrent_stop = 0\nstops = []\nwhile current != lahore:\n  next_stop = 0\n  while distance(next_stop) - current_distance <= m:\n    next_stop = next_stop + 1\n  next_stop = next_stop - 1\n\n  current_stop = next_stop\n  current_distance = distance(current_stop)\n  add next_stop to stops\nreturn stops\n```\n\n\nThis is an optimal solution. To see this, we note that any sequence of stops that took less stops then the greedy algorithm would have to 'pass' the greedy algorithm at some point along the route.\n\nUsing induction, we can see that if the greedy algorithm is the farthest it can be after the first stop, and after the nth stop it is the farthest it could be given stop n - 1, then the greedy algorithm must be the farthest it can be for all stops along the route.\n\nAlthough this algorithm has complexity O(n) and returns an optimal solution computationally, the route it returns may not be a very 'even' or 'smooth' route. In order to produce routes for actual use by people, more routes that space their stops more evenly would want to be considered.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to prove greedy algorithm for number partitioning?\r\n                \r\n\n  the partition problem (or number partitioning1) is the task of\n  deciding whether a given multiset S of positive integers can be\n  partitioned into two subsets S1 and S2 such that the sum of the\n  numbers in S1 equals the sum of the numbers in S2.\n\n\nThere is a greedy algorithm for this problem:\n\n\n  One approach to the problem, imitating the way children choose teams\n  for a game, is the greedy algorithm, which iterates through the\n  numbers in descending order, assigning each of them to whichever\n  subset has the smaller sum. This approach has a running time of O(n\n  log n). This heuristic works well in practice when the numbers in the\n  set are of about the same size as its cardinality or less, but it is\n  not guaranteed to produce the best possible partition. For example,\n  given the set S = {4, 5, 6, 7, 8} as input, this greedy algorithm\n  would partition S into subsets {4, 5, 8} and {6, 7}; however, S has an\n  exactly balanced partition into subsets {7, 8} and {4, 5, 6}.\n\n\nBut, I don't know how to prove ```\nThis heuristic works well in practice when the numbers in the set are of about the same size as its cardinality or less```\n. Can anyone help?\n    ", "Answer": "\r\nThe claim is not a precise one; it's just saying that if the elements of the multiset aren't much bigger than its cardinality, then the heuristic will usually give the right answer, unless you make a point of seeking out cases where it doesn't. So the claim can't really be \"proven\" as-is.\n\nFurthermore, there are many different ways that the claim could be made precise; and not all of those ways necessarily result in a true claim. So you can't just make the claim precise and then prove that.\n\n\n\nHowever, if you read the paragraph after the one you cite, it offers a related claim that is precise, and that is (according to the article) correct, namely that if the multiset S can be partitioned into two multisets whose sums are both ≤ OPT, then this greedy algorithm will partition it into two multisets whose sums are both ≤ ⁷/₆ OPT. However, this claim is not the same as the original claim; it sets an upper bound on how wrong the heuristic can be, but it doesn't guarantee that it's ever exactly right, and it doesn't make any reference to the values of the elements.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to tell if greedy algorithm suffices for finding minimum coin change?\r\n                \r\nThe minimum coin change problem is an NP-complete problem but for certain sets of coins the greedy algorithm (choose largest denominations first) works. Given a set of integers denoting coin-values, what's the fastest algorithm to determine if the greedy algorithm suffices or not? One obvious way is to build up your dynamic programming solution till the largest denomination and see for each if it yields a better solution than the greedy way. But is there a faster \"math-way\" of detecting it?\n    ", "Answer": "\r\nI recently came up with 1 solution that seemed to show if the given 2 conditions are satisfied, the greedy algorithm would yield the optimal solution. \n\na) The G.C.D (All the denominations except 1) = 2nd Smallest denomination. \n\nb) The sum of any 2 consecutive denominations must be lesser than the 3rd consecutive denomination. \n\nFor eg. c2 + c3 < c4. \n\n(Where c1 = 1; c2, c3, c4 are coin denominations in ascending order). \n\nI understand this is not a complete solution. However, I believe that if these 2 conditions are met, the greedy algorithm will yield the optimal solution.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Can Binary Search be / Is Binary Search a greedy algorithm?\r\n                \r\nI'm reading different materials about Binary search, and it's not clear to me is it a greedy binary (which looks to me like it's not) or, CAN it be a greedy algorithm with some specific implementation? \n\nAnd if it can be greedy, how it make sense? If the global optimum is obtained by selecting the local optimum, without reconsidering previous choices, it can't guarantee correct results for the binary search.\n    ", "Answer": "\r\nI guess if you squint at it sideways, binary search is greedy in the sense that you're trying to cut down your search space by as much as you can in each step.  It just happens to be a greedy algorithm in a search space with structure making that both efficient, and always likely to find the right answer.\n\nI don't tend to so squint.\n\nThat said binary search can be used inside of a traditional greedy algorithm.  As an example, a greedy algorithm for a packing problem could ask you to next choose \"the largest available item that can still fit\".  A binary search could be used to find that.\n\nConversely a greedy algorithm can be used to create a data structure that is well-suited to binary search.  See for example https://en.wikipedia.org/wiki/Geometry_of_binary_search_trees#Greedy_algorithm\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Proving greedy algorithm with exchange argument [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nSo I have to write a greedy algorithm that given a linked list or array of pairs (t_i, w_i), I have to produce a schedule that generates the maximum amount of money within time T. t_i would be the maximum number of hours that can worked for that job, w_i would be the wage in dollars per hour and T would be the maximum number of hours that person is willing to work per week. Jobs don't need to be worked until t_i, as the worker can choose to switch jobs early and get paid for each hour they worked.\n\nSo I wrote a greedy algorithm where you just get the job with the highest wage per hour and work that job for as long as you can, then get the job with the second wage per hour and work that job for as long as you can and so on till you work T hours.\n\nI am now being asked to use an exchange argument to prove that my pseudocode produces an optimal schedule. In my opinion, my pseudocode solution is already the optimal schedule, so what what I compare it to then?\n    ", "Answer": "\r\nI'll give you the idea of the demonstration without writting it entirely. \n\nYou need to take an optimal solution S. You can tell that this solution can grant x $, where x is the maximum money you can make.\n\nThen you take your solution G witch is greedy. \n\nNow you say the first job you chose in G, this job is j1 and the time spent is t1. There is two possibility, either j1 is in S or it's not. If it's not by replacing one job in S by j1 you get a better solution (or at least as good) BUT S is optimal so you can conclude that j1 is in S. You can do the same kind of reasoning to prove that the time associed with j1 in S is t1.\n\nThen you do that for every element. And you'll conclude that the amount of money x earned is the same in G and in S. So G is optimal \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to trace Knapsack problem using greedy algorithm?\r\n                \r\nThe question is how to trace a Knapsack problem with greedy algorithm using the following information?\n\n```\nP=[10,7,12,13,6,20]\nW=[3,2,4,3,13,8]\nM=15\nn=6\n```\n\n\nI'd appreciate it if some one could help me understand this or point me to the right direction.\n    ", "Answer": "\r\nWell, if it's 'fractional knapsack' (i.e. you can take fractions of the items) then it's easy:\n\nThe items are (as price, weight pairs) [(10, 3), (7, 2), (12, 4), (13, 3), (6, 13), (20, 8)]\n\nIntuitively, you'll want to get an item first which will provide more price with less weight. So, let's sort the items by their price to weight ratio:\n\n[(13, 3), (7, 2), (10, 3), (12, 4), (20, 8), (6, 13)]\n\nNow, until you run out of capacity or an item, take the most valuable item as much as you can.\n\n```\n0. cap = 15, price = 0\n1. Take (13, 3): cap = 12, price = 13\n2. Take (7, 2): cap = 10, price = 20\n3. Take (10, 3): cap = 7, price = 30\n4. Take (12, 4): cap = 3, price = 42\n5. Take (20, 8): cap = 0, price = 49.5\n   [in this step, you have capacity to take 3 units, so take 3 units of the 5th item, the price of which is 3*20/8]\n```\n\n\nIf you cannot take fractional items, then such a greedy approach may not give you the optimal solution.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to prove greedy algorithm optimality\r\n                \r\n\n  Let ```\nS```\n be a set of intervals (containing n number of intervals) of the natural numbers that might overlap and N be a list of numbers (containing n number of numbers).\n\n\nI want to find the smallest subset (let's call P) of S such that for each number\nin our list N, there exists at least one interval in P that contains it. The intervals in P are allowed to overlap.\n\nTrivial example:\n\n```\nS = {[1..4], [2..7], [3..5], [8..15], [9..13]}\nN = [1, 4, 5]\n// so P = {[1..4], [2..7]}\n```\n\n\n\n\nI found a solution to this problem shown below\n\n```\nN = MergeSort (N)\nupper, lower = infinity, -1\nP = empty set\nfor each q in N do\n     if (q>=lower and q<=upper)=False\n          max_interval = [-infinity, infinity]\n          for each r in S do\n              if q in r then\n                 if r.rightEndPoint > max_interval.rightEndPoint\n                     max_interval = r\n          P.append(max_interval)\n          lower = max_interval.leftEndPoint\n          upper = max_interval.rightEndPoint\n          S.remove(max_interval)\n```\n\n\nI have found this solution, but I am not entirely sure how to prove the optimality of a greedy algorithm (that is prove, that is will always give the best result).\n\nMy question: How can I prove the optimality of this greedy solution?\n\nThanks in advance.\n    ", "Answer": "\r\nYes, your algorithm reaches optimal solution. I am not good with formal proofs but hopefully the following arguments should be convincing.\n\n\nThe array N is sorted in ascending order and you are accessing elements accordingly in non-decreasing order. In other words, the current element is always >= previous element.    \nFor each element, we first check whether it can be accommodated in the previously chosen interval and if not, only then we proceed to step 3, otherwise we skip to the next element.  \nFor the current element, we are choosing the (so far un-chosen) interval in S such that its 'end' point is as large as possible. This makes sense because that way we can accommodate most number of elements that follow our current element. For example, if the current element is 10, and we have two candidate intervals [8, 12] and [9, 15], under no circumstances shall we choose the former because we know that all the following elements have to be greater than 10.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "With restrictions, can the knapsack puzzle be solved with a greedy algorithm?\r\n                \r\nI know that with the knapsack problem in general, there is no known greedy algorithm to solve it. But, say we add the following constraints: \n\n• All items have values equal to their weights (for all i, w(i) = v(i))\n\n• The weights are all powers of 2 (for all w(i) there exists n ∈ N such that w(i) = 2^n).\n\nNow, a knapsack problem with the following constraints can have a greedy algorithm that selects the heaviest item which can currently fit in the knapsack until no item remaining can fit.\n\n\n\nWill this work or is there really no way the constrained knapsack problem can be solved with a greedy algorithm?\n    ", "Answer": "\r\nIn general, there are two types of knapsack problems, one where you can take part of an item (50% of a bag of sand, for instance) and one where you have to take the whole item. The latter is referred to as the 0/1 knapsack (all or nothing), which is what I believe you are referring to.\n\nThe first can be solved greedily taking all of the maximum valued items by unit ($x per pound, for example) until your capacity is about full, then filling the rest with a percentage of the remaining highest valued item by unit. The second, without your constraints, cannot be solved greedily, in general.\n\nNow looking at your constraints. In answering this, I'm assuming that values are by unit not by total because this would change the algorithm. Think $2 item weighs 2 pounds and $8 item weighs 8 pounds versus a 2-pound item is $2 per pound ($4 total) and an 8-pound item is $8 per pound ($64 total), which makes there incentive to take the heavier item first. This can be solved greedily by taking the heaviest item possible first, then second heaviest, and so on until no more items will fit in the bag, which is the algorithm you described.\n\nThe reason why this works is the sum of all the values below the maximum available to put in the knapsack is still less that of the maximum available due to having powers of two and the value per pound assumption. Think by putting an 8-pound item (total value = $64), I would be losing the opportunity to put a number of 2 & 4-pound items (total value = $4 and $16, respectively). No matter the weight of the knapsack (equal to or larger than 8), there is no combination of only 2's and 4's that could outvalue the contribution of the 8 (if you're thinking five 4-pound items would at $80 then think that at the same weight one 8-pound item and three 4-pound items is better at $112). Since the heaviest item cannot be outvalued by items below it, it's optimal to take that heaviest item, which gives you a greedy solution.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "using greedy algorithm search in lists\r\n                \r\nGiven a list of positive integer Items whose elements are guaranteed to be in sorted ascending order, and a positive integer Goal, and Output  is a list of three elements [A,B,C] taken from items that together add up to goal. The Output must occur inside the items list in that order (ascending order).\nex:\n```\n?- threeSum([3,8,9,10,12,14],27,Output).\nOutput=[8,9,10];\nOutput=[3,10,14].\n```\n\nsomeone helped me to reach this to this code\nbut it gives me singleton variables:[Input,Items] ,it didnt work\nalthough iam not quite sure if this is a greedy algorithm search or not ?\n```\n threeSum(Input,Goal,[A,B,C]):-\n  permutation(Items, [A,B,C|Rest]),\n  msort([A,B,C],[A,B,C]),\n  msort(Rest,Rest),\n  sum_list([A,B,C],Goal).\n```\n\n    ", "Answer": "\r\nA clpfd approach:\n```\n:- use_module(library(clpfd)).\n\nthreeSum(Input, Goal, [A,B,C]) :-\n    Input = [First|Rest],\n    foldl([N,M,T]>>(T = N\\/M), Rest, First, Domain),\n\n    [A,B,C] ins Domain,\n    all_different([A,B,C]),\n    chain([A,B,C], #>=),\n\n    Goal #= A + B + C,\n\n    labeling([max(A), max(B), max(C)], [A,B,C]).\n```\n\nWhich has a bit of wrangling to turn the list of numbers into a domain, then says [A,B,C] must be in the list of numbers, must be different numbers, must be in descending order, must sum to the goal, and the clpfd solver should strive to maximise the values of A then B then C. (This probably won't work if the list can contain multiple of the same value like [5,5,5,3,2]).\ne.g.\n```\n?- threeSum([3,8,9,10,12,14], 27, Output).\nOutput = [14, 10, 3] ;\nOutput = [10, 9, 8]\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm to minimize the sum of a permutation\r\n                \r\nI have an array ```\n{a1,a2,....,an}```\n (of natural numbers), i need to build an greedy algorithm that finds a permutation (i1,...in) of 1....n that minimizes the sum: ```\n1.ai1 + 2.ai2 + .... + (n − 1)ain−1 + n.ain```\n.\nDefinitely I can just try all of them and select the one which gives the smallest sum (this will give correct result in O(n!)).\nThe greedy choice that i though is to choose the numbers in decreasing order, but i don't know how to prove that this works.\nP.S: this is just for study and training, I'm not being able to think \"greedly\"\n    ", "Answer": "\r\nChoosing the numbers in decreasing order is optimal.\nProof is by induction on n: suppose there's a permutation that is optimal and that the smallest number is not in the last place. Then, swapping the element that is in the last place and the smallest element decreases the total sum. That contradicts the assumption of optimality, so we must have that the smallest element is in the last place. By the induction hypothesis, the other elements are in decreasing order in the first (n-1) places.\nThe base case of n=1 is trivial.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm exercise not working properly\r\n                \r\nI'm in high school and having a test soon, one of the topics being the Greedy algorithm. I'm having an unknown issue with this exercise: \"It is given an array of N integers. Using the Greedy algorithm, determine the largest number that can be written as a multiplication of two of the array elements\" (Sorry if it's a bit unclear, I'm not a native English speaker).\n\nNow, what I had in mind to solve this exercise is this: Find the largest two numbers and the lowest two numbers (in case they are both negative) and display either the multiplication of the two largest or of the two lowest, depending on which number is larger.\n\nThis is what I wrote:\n\n```\n#include <iostream>\nusing namespace std;\n\nint a[100001],n;\n\nint main()\n{\n\nint max1=-1000001,max2=-1000001,min1=1000001,min2=1000001,x;\ncin>>n;\n\nfor (int i=1; i<=n; i++)\n{\n    cin>>a[i];\n\n    if (a[i]>=max2)\n    {\n        if (a[i]>=max1)\n        {\n            x=max1;\n            max1=a[i];\n            max2=x;\n        }\n        else max2=a[i];\n    }\n\n    if (a[i]<=min2)\n    {\n        if (a[i]<=min1)\n        {\n            x=min1;\n            min1=a[i];\n            min2=x;\n        }\n        else min2=a[i];\n    }\n}\n\nif (n==1)\n    cout<<n;\nelse if (max1*max2>=min1*min2)\n    cout<<max1*max2;\nelse cout<<min1*min2;\n\nreturn 0;\n}\n```\n\n\nYes, I know the way I wrote it is untidy/ugly. The code, however, should function properly and I tested it with both the example provided by the exercise and lots of different situations. They all gave the right result. The problem is that the programming exercises website gives my code a 80/100 score, not because of the time but because of the wrong answers.\n\nI've already spent more than 2 hours looking at this code and I just can't figure out what's wrong with it. Can anyone point out the flaw? Thanks <3\n    ", "Answer": "\r\nThe problem most likely comes from the fact that multiplying 2 int's will give you an int. An int usually has a range of ```\n-2,147,483,648 to 2,147,483,647```\n.\n\nIf you then multiply ```\n2,147,483,647 * 2```\n for example you get ```\n-2```\n. Similarly taking ```\n2,147,483,647 + 1```\n will give you ```\n-2147483648```\n. When the value reaches it's max it deals with that by going to the lowest possible value.\n\nTo partially solve the problem you just need to cast 1 of the variables you multiply to a 64-bit integer. For modern C++ that would be ```\nint64_t```\n.\n\n```\nif (n==1)\n    cout<<n;\nelse if (static_cast<int64_t>(max1)*max2>=static_cast<int64_t>(min1)*min2)\n    cout<<static_cast<int64_t>(max1)*max2;\nelse cout<<static_cast<int64_t>(min1)*min2;\n```\n\n\nBut you will still be able to get too big number if both the values are big enough. So you need the full range of a ```\nuint64_t```\n, the unsigned version.\n\nSo we need to cast to a ```\nuint64_t```\n instead, but then you run into another issue with the numbers below 0. So first you should convert you min1 and min2 to the equivalent positive numbers, then cast to ```\nuint64_t```\n.\n\n```\nuint64_t positive_min1, positive_min2;\nif (min1 < 0 && min2 < 0) {\n    positive_min1 = min1*-1;\n    positive_min2 = min2*-1;\n}\nelse {\n    positive_min1 = 0;\n    positive_min2 = 0;\n}\n```\n\n\nNow you can go ahead and do\n\n```\nif (n==1)\n    cout<<n;\nelse if (static_cast<uint64_t>(max1)*max2>=positive_min1*positive_min2)\n    cout<<static_cast<int64_t>(max1)*max2;\nelse cout<<positive_min1*positive_min2;\n```\n\n\nNo need to cast positive_min1 & 2 since it was already converted to ```\nuint64_t```\n.\n\nSince you are casting ```\nmax1```\n to unsigned, you should probably check that it's not below 0 first.\n\nIf signed and unsigned is not familiar concepts you can read about that and the different data types here.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Optimization with a greedy algorithm\r\n                \r\nIf an optimization problem can be solved using the greedy method, is it true that all its optimal solutions must always contain the first choice (i.e. the greedy choice)?\n    ", "Answer": "\r\nI am interpreting your question as \"the set of all optimal solutions must always contain the first choice\" otherwise it does not make sense for a solution to contain another solution.\n\nNaturally, the answer is trivially yes. If a greedy algorithm solves the problem, it produces an optimal solution, which by definition is in the set of optimal solutions.\n\nPerhaps you meant \"if a greedy algorithm sometimes produces an optimal solution, ...\" in that case again the answer is trivial.\n\nIf you meant that \"if a greedy algorithm sometimes produces an optimal solution, is it true that all guaranteed optimal algorithms will produce that solution too?\" the answer depends upon whether the problem has a unique optimal solution or multiple ones.\n\nIf a problem has multiple optimal solutions, the answer is clearly no.\n\nA good example to think about is to sort a list of numbers such that all single digit numbers come ahead of two digit numbers, two digit numbers come ahead of three digit numbers, and so forth. I. e. you don't care whether 99 comes before 11 or vice versa, you just want 9 to come before 25, and 33 before 872, and 555 before 1234.\n\nThis example problem has multiple optimal solutions. A lazy but not greedy algorithm would not ensure that 11 comes before 99. An overenthusiastic algorithm would do so. Both would produce optimal solutions different from each other.\n\nIf this doesn't help, nothing will ;-)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm Approach\r\n                \r\nSo i have this problem where a food place with only 1 delivery man has to deliver food to customers. It has all the orders in the morning and at noon he will start delivering. Each customer i has ti(time for food preparation and delivery) and vi(value of importance to the food place). So if customer j is the first customer his order will be delivered in time Xj = tj. If customer's f food get prepared and delivered after customer j, his food will be delivered in time Xf = Xj + tf. About the importance factor, the aim of the delivery man is to have the least sum of lateness where lateness is: sum from i=1 to n (where n number of customers) of vi * Xi.\nFor example:\nI have this list of customers\n```\nCUSTOMER        DISTANCE        IMPORTANCE\n 1              10              8\n 2              1               8\n 3              5               7\n 4              5               3\n 5              3               7\n```\n\nIf i sort them by delivering each time to the nearest customer without taking into consideration his importance i will get the sum of:\n(if 2 have the same distance then choose one with most importance)\n```\nThe sum by distance is :333\n(8*1+7*4+7*9+3*14+8*24 = 333)\n```\n\nAnd this will be the order of the delivery\n```\n CUSTOMER       DISTANCE        IMPORTANCE\n 2              1               8\n 5              3               7\n 3              5               7\n 4              5               3\n 1              10              8\n```\n\nI also tried selecting each time the most important customer with the sum being:\n(if 2 have the same importance then choose one with least distance)\n```\nThe sum by importance is :399\n(8*1+8*11+7*14+7*19+3*24 = 399)\n\n```\n\nAnd the order of the deliveries:\n```\n CUSTOMER       DISTANCE        IMPORTANCE\n 2              1               8\n 1              10              8\n 5              3               7\n 3              5               7\n 4              5               3\n```\n\nSo in this scenario selecting always the closest one did calculate a smaller sum than the selecting always the most important one, but this doesn't work every time. I have to come up with something that will give me the optimal sum in every given list. I know that both distance and importance have to be taken into consideration but i cannot figure out the formula that i will have to apply to always get the least sum. If someone knows any greedy algorithm technique that will be in use in this scenario i would appreciate it. Thanks.\n    ", "Answer": "\r\nNote: neither of the greedy approaches that you mentioned results in an optimal solution. Behold this order:\n```\n CUSTOMER       DISTANCE        IMPORTANCE\n 2              1               8\n 5              3               7\n 3              5               7\n 1              10              8\n 4              5               3\n```\n\nWith the resulting sum of 323. This happens because ```\n10 * 3 = 30 < 40 = 5 * 8```\n.\nThe question becomes: Can we build on top of this observation?\nStarting from the simple:\nLets look at the case of only two customers:\n```\nc1    d1    i1\nc2    d2    i2\n```\n\nIf we take c1 first, its cost will be ```\nd1 * i1```\n. At the same time, he will increase the cost of every subsequent customer cx by  ```\ncx * d1```\n. The same works the other way around for the customer c2. Which one do we pick first then? \nc1 first: ```\nc1_sum = d1 * i1 + (d1 + d2) * i2 = d1 * i1 + d1 * i2 + d2 * i2```\n \nc2 first: ```\nc2_sum = d2 * i2 + (d1 + d2) * i1 = d2 * i2 + d1 * i1 + d2 * i1```\n \n```\nd1 * i1```\n appears in both sums. Same for ```\nd2 * i2```\n. The only difference is the ```\nd1 * i2```\n vs ```\nd2 * i1```\n. This means that c1_sum < c2_sum <=> d1 * i2 < d2 * i1.\nMoving towards the solution:\nNow let us consider the original task with multiple customers c1, ... cn. The customer ck should have priority if for every other customer cl (l=0..n, l != k) this is true: dk * il < dl * ik.\nWhy is that?\nFor a customer, the only thing that matters is the sum of times of the preceding customers since his own time * importance score is fixed. So we will want to compare how much we will hold up the other customers as opposed to holding this single customer.\nDo we have to recompute everything at every step?\nIf at every step, we have to compute this comparison for every pair of elements, we would be in the not-so-nice territory of O(n3). Polynomial complexity is manageable, however 3 in the exponent is rather annoying and it would be for the best if we could prevent it. For example by ordering the nodes.1 Can we do that?\n\nReflexivity: Holds.\nAntisymmetry: If dk * il = dl * ik it means that dk * il < dl * ik which is equivalent to (dk / ik) < (dl / il)\nTransitivity similarly to the previous step.\n\nNote: kudos to @รยקคгรђשค, I forgot that the division existed and got wee bit tangled in the indices.\nSo since the relation is an order, we can sort by it. Sort is O(n log(n)) and then we can just grab the pieces greedily in order.\n\n1 By the distance / importance ratio.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Determine if the solution can be optimally given using greedy algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nMost of the times the confusing fact is whether to go for an exhaustive search (dynamic programming or back tracking or brute force) to solve the problem or to go for the greedy approach. \n\nI am not talking about using greedy to determine the best possible solution, I am talking about using greedy algorithm to find \"the solution\". I am trying to get some standard ways in which I can validate if the problem can be solved with greedy approach. Like Optimal substructure, memorization for dynamic programming. And not related any specific problem. \n\nAre there any proof of induction I can do to decide if greedy approach will always produce the best solution?\n    ", "Answer": "\r\nIn general\nTo prove that an optimization problem can be solved using a greedy algorithm, we need to prove that the problem has the following:\n\nOptimal substructure property: an optimal global solution contains the optimal solutions of all its subproblems.\n\nGreedy choice property: a global optimal solution can be obtained by greedily selecting a locally optimal choice.\n\n\n\nExample\n\nLet us consider the classical activity selection problem. We have a set S of n activities, each one with a start time ```\ns[i]```\n and an end time ```\ne[i]```\n. We want to choose a subset of S, such that the selection maximizes the number of non overlapping events.\n\nThis problem can be solved using a greedy algorithm, but how can we prove that?\nWe need to show it exhibits:\n\nOptimal substructure\n\nConsider a general activity a contained in a global optimal solution ```\nS = {A', a, A''}```\n, where ```\nS```\n is the global optimal solution, a is our little activity, and ```\nA'```\n and ```\nA''```\n are two subproblems of finding the activities before a and after a.\nIf the problem has the optimal substructure property, the optimal solution for the subproblems ```\nA'```\n and ```\nA''```\n must be contained in the global optimal solution ```\nS```\n.\nThis is true, but why?\nSuppose that the optimal solution for the subproblem ```\nA'```\n is not in ```\nS```\n. Then we could substitute the optimal for ```\nA'```\n, say ```\nS'```\n, in ```\nA```\n, to obtain a new global optimal solution that is better than ```\nS```\n. But ```\nS```\n was the global optimal solution! Contradiction.\n\nGreedy choice:\n\nWe need to prove that our greedy choice (to select the activity that ends first) is correct.\nLet ```\nB```\n be a subproblem. Let b be the activity of the subproblem ```\nB```\n that ends first, thus b is our (first) greedy choice. We need to prove that b is included in some optimal solution for ```\nB```\n.\nLet ```\nX```\n be an optimal solution for the subproblem ```\nB```\n. Let x be the activity in ```\nX```\n that ends first.\n\nIf b = x, then b is in ```\nX```\n, the optimal solution for ```\nB```\n, and we have shown that the greedy choice is included in the optimal solution.\n\nIf b != x, surely we have that ```\nend_time[b] < end_time[x]```\n.\nSince b was our greedy choice (i.e. the activity that ends first of all in the subproblem ```\nB```\n), then we can substitute ```\nx```\n with b in ```\nX```\n to obtain another optimal solution: ```\nX' = (X \\ {x}) U {b}```\n. ```\nX'```\n is optimal because it has the same number of activities of ```\nX```\n, and ```\nX```\n was optimal, and in this case, b is in ```\nX'```\n, the optimal solution for ```\nB```\n.\n\n\nSo our greedy choice ```\nb```\n is included in some optimal solution for ```\nB```\n in one case or the other.\n\nMatroids\nFurthermore, there's a powerful mathematical theory that can be in some case used to mechanically prove that a particular problem can be solved with a greedy approach.\nBriefly:\n\nOne can define a particular combinatoric structure named matroid.\n\nSome smart man proved in the past that these matroids have the Optimal substructure property and the Greedy choice property.\n\nThis means that you can run a greedy algorithm on your optimization problem, and it will find the optimal solution. You only need to verify that your problem is defined on a matroid-like structure.\n\n\nFurther information about this can be found here.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm for activity selection with activity value (CLRS 16.1-5)\r\n                \r\nIs there a greedy algorithm possible for this problem.\nI have worked out a DP algorithm for it but am not sure of a Greedy Algorithm for it.\nPlease Explain if a greedy algorithm exists for it.\n\nFor those who are not familiar with the problem:\n\n\n  There are 'n' activities from a1 to an . Each activity ai has an associated start time si and a finish time fi i.e [si,fi). Each activity ai also has a value vi associated with it. No two activities can occur simultaneously. Task is to select mutually compatible activities so as to maximize the total value i.e summation of all activities scheduled. \n  Mutally compatible means that their running times don't overlap.\n\n    ", "Answer": "\r\nTo find a greedy solution for a problem, we have to find a the intuition behind it. This problem looks similar to the problem of activity-selection problem in the text of CLRS (```\nsection 16.1```\n). In that problem, we are to find a set with the maximum size in which every activities are mutually compatible. But this problem has another goal which wants us to find a set maximizing the coverage or resource usage.\n\nThe solution to this problem, in my opinion, is to first sort all activities based on their starting time. The intuition behind it is that we want to use the time/value/resources as fast as possible and not waste anything. Then, we start picking the longest activities and check if it is compatible with other activities that have been selected so far. And you continue picking up to the end. If you apply this to the example in the book, it gives you a set with activities ```\n{3, 7, 11}```\n. \n\nIt might not be correct for all sets of activities. For example, a set of two activities: ```\nactivity(1) = <0, 2>```\n and ```\nactivity(2) = <1, 5>```\n. \n\nAs you can see, the idea doesn't work in this case. So you have to apply it again but from right to left. (Sort them based on their finishing times and pick those first which are finished first and lasted longer!) At the end you will pick the set with the most coverage! \n\nI might not yet yield the best results. If we add another activity ```\nactivity(3)=<4, 6>```\n, those approaches are not the answers. So sorting activities based on their length in a descending order might be the answer.\n\nAt the end, one of these three approaches should give the answer.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Implementation of Greedy algorithm\r\n                \r\nI'm trying to implement my own version of Greedy algorithm for the knapsack problem(the one in which you are allowed to add fractions of an object not neccesarly objects as wholes). \n\nI have written the below code following this logic:\n- created an array named 'profitPerWeight' in which I stored the values of profit/weight for all the objects\n- in a 'knapSack()' function I check which item has the most profitable value, and check with another function called 'getFraction()' what fraction of the object fits in the bag(the bag capacity is 15 in my case).\n- in the 'getFraction()' function I return 1 if the item fits as a whole or which fraction of it fits(e.g: if bag weight is currently is 7 and item is 2 I return 1 because the item can fit in the bag without going over capacity: 15. If say weight is 7 and item is 9 I return 9%7 because only a part(2) of the item(9) could go in the bag without going over the allowed capacity.\n- then I add the fraction of the item in the bag and I have another array 'bagContent[]' which stores for each object the fraction of it that was included in the bag.\n\nE.g: if bagContent would be = {1,1,0,0,2/3} means I stored in the bag: obj0, obj1, and 2/3*obj4.\n\nThe output of this problem is supposed to be:\n1*first 2/3*second 1*third 0*fourth 1*fifth 1*sixth 1*seventh\n\nHowever I get a different one when I run my solution:\n1*first 1*second 1*third 0*fourth 1*fifth 1*sixth 1*seventh.\n\nAs you can see the second one is '1' instead of '2/3' :(. And I have no ideea why I'm guessing it's something with decimals that I need to fix. I tried few things but they did not work. Or perhaps there is something wrong with my logic. I'm not very experienced with algorithms :( .Please tell me what am I doing wrong and how can I correct this. Thank you. The code is below:\n\n```\n// Knapsack problem: Greedy method\n\n// Objects: 1,  2,   3,   4,  5,  6,  7\n// Profits: 10, 5,   15,  7,  6,  18, 3\n// Weights: 2,  3,   5,   7,  1,  4,  1\n\n// Fill a 15kg knapsack with the objects(they can be divisible) so that the profit is maximum\n\n// Output should be:\n// 1*first 2/3*second 1*third 0*fourth 1*fifth 1*sixth 1*seventh\n\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nchar *objects[] = {\"First\", \"Second\", \"Third\", \"Fourth\", \"Fifth\", \"Sixth\", \"Seventh\"};\nint profits[] = {10, 5, 15, 7, 6, 18, 3};\nint weights[] = {2, 3, 5, 7, 1, 4, 1};\ndouble profitPerWeight[7] = {5, 1.3, 3, 1, 6, 4.5, 3};\nint bagWeight = 0;\nint bagCapacity = 15;\nint fraction;\nint bagContent[7] = {0,0,0,0,0,0,0};\nint itemToAddIndex = 0;\n\n// function that returns the index of most profitable item in 'profitPerWeight[]'\nint MaxProfitItem()\n{\n int index = 0;\n int mostPr = profitPerWeight[0];\n for(int i=1; i<7; i++)\n {\n  if(profitPerWeight[i] > mostPr)\n  {\n   mostPr = profitPerWeight[i];\n   index = i;\n  }\n }\n return index;\n}\n\n// function that returns true if the current fraction of an\n// item can fit in the bag or false if the\n// current fraction of an item cannot fit in the bag\nbool itemFits(int index)\n{\n if(bagWeight + weights[index] <= 15)\n  return true;\n\n return false;\n}\n\n// function that divides an item with a specified fraction\nvoid divideItem(int index, double fraction)\n{\n weights[index] = weights[index] / fraction;\n}\n\n// function that returns which fraction of an item can fit in the bag\ndouble getFraction(int index)\n{\n double fraction;  // the fraction is initially 1\n if(itemFits(index))\n {\n  fraction = 1;\n }\n\n else\n {\n  fraction = weights[index] % bagCapacity;\n }\n\n return fraction;\n\n\n}\n\n// puts fraction of item in bag and updates capacity&weight of bag\nvoid putInBag(int itemToAddIndex, double fraction)\n{\n profitPerWeight[itemToAddIndex] = 0; // disegard this so it won't be seen as max next time we look for most valuable item\n bagCapacity = bagCapacity - fraction * weights[itemToAddIndex];\n bagWeight = bagWeight + fraction * weights[itemToAddIndex];\n bagContent[itemToAddIndex] = fraction;\n}\n\n// function that solves the problem using greedy approach\nvoid knapSack()\n{\n  while(bagWeight<=15)\n  {\n   itemToAddIndex = MaxProfitItem();       // select the most profit/weight valuable item\n   fraction = getFraction(itemToAddIndex); // see which fraction of it fits in the bag\n   putInBag(itemToAddIndex, fraction);     // put the fraction of item which fits in bag\n  }\n\n  for(int i=0; i<7; i++)\n  {\n   cout << *(objects+i) << \"*\" << bagContent[i] << \" \";\n  }\n}\n\nint main()\n{\n knapSack();\n\n}\n```\n\n    ", "Answer": "\r\nYour function ```\ndouble getFraction(int index)```\n has some flaws. It shouldn't be comparing the weight of the item to the bagCapacity (the MAX), it should be comparing the weight to the current remaining capacity.. ie the bagCapacity - bagWeight.  But also, I'm not sure why you are doing a % (modulus), when you should be dividing to get the fraction.  ALSO, you're dividing two ints into a double, and you need to do a cast for that.  Try changing the function to the following:\n\n```\ndouble getFraction(int index)\n{\n double fraction;  // the fraction is initially 1\n if(itemFits(index))\n {\n  fraction = 1;\n }\n\n else\n {\n  fraction = (double)(bagCapacity - bagWeight) / (double)weights[index]; \n }\n\n return fraction;\n\n\n}\n```\n\n\nEdit: And also, your array only holds ints, when you want fractions (or actually decimal points).  Change ```\nint bagContent[7] = {0,0,0,0,0,0,0};```\n to ```\ndouble bagContent[7] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0};```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm- Knapsack Puzzle\r\n                \r\nI am attempting to solve the Knapsack problem with a greedy algorithm in Python 3.x. Below is my code, and the sample cases I'm using to test it. Each sample case is in the form line[0] = max weight, line[1:] in form (weight, value.)\n\nSample case 1 successful:\n\n```\n575\n125 3000\n50 100\n500 6000\n25 30\n```\n\n\nExpected $6130, got $6130.\n\nSample case 2 not successful:\n\n```\n1500\n151 150\n150 150\n```\n\n\nExpected $1500, got $1350.\n\nCode:\n\n```\ndef take_input(infile):\n    f_open = open(infile, 'r')\n    lines = []\n    for line in f_open:\n        lines.append(line.strip())\n    f_open.close()\n    return lines\n\ndef create_list(jewel_lines):\n    #turns the jewels into a list of lists\n    jewels_list = []\n    for x in jewel_lines:\n        weight = x.split()[0]\n        value = x.split()[1]\n        jewels_list.append((int(value), int(weight)))\n    jewels_list = sorted(jewels_list, reverse=True)\n    return jewels_list\n\ndef greedy_grab(jewels_list, max_weight):\n    running = 0\n    i = 0\n    grabbed_list = []\n    string = ''\n    total_haul = 0\n    #sort jewels list by value, since this is greedy\n\n    while running <= max_weight and i <= (len(jewels_list)-1):\n        #pick the most valuable item\n        to_add = int(jewels_list[i][1])\n        if (running + to_add) > max_weight:\n            i += 1\n        else:\n            running += to_add\n            grabbed_list.append(jewels_list[i][0])\n    for item in grabbed_list:\n        total_haul += int(item)\n    string = \"The greedy approach would steal $\" + str(total_haul) + \" of jewels.\" +\"It would use value \" + str(grabbed_list)\n    return string\n\n#required setup of variables    \ninfile = \"JT_test3.txt\"\ngiven_input = take_input(infile)\nmax_weight = int(given_input[0])\ngiven_input.pop(0)\njewels_list = create_list(given_input)\n\n#test lines\nprint(jewels_list)\nprint(greedy_grab(jewels_list, max_weight))\n```\n\n\nThe last time I had an error like this, before I rewrote the program, it was a struggle with int types. This time it seems to be in breaking ties, but I'm not sure what the way to fix it is. Any help is greatly appreciated. I just know this'll be a simple fix when I see it...\n\nEDIT: this has to be something to do with how my lists are sorted. I have a list of lists, sorted in reverse. In case of a tie between item[0] and item2[0], though, I need to sort by item[1]. I don't know how though.\n    ", "Answer": "\r\nIn second case, ```\nsorted(jewels_list, reverse=True)```\n returns [(150, 151), (150, 150)], so your algoritm choses the heaviest jewel amongst equaly weghted ones. You should sort by value descending and by weight ascending to get what you expect.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy algorithm matrix of 0\\1\r\n                \r\nI'm studying for an algorithm exam and I cant find a way to solve the next problem:\n\nINPUT: Positive integers r1,r2....rn   and   c1,c2....cn\n\nOUTPUT: An n by n matrix A with 0/1 entries such that for all i the sum of the i-th row in\nA is ri and the sum of the i-th column in A is ci, if such a matrix exists.\nConsider the following greedy algorithm that constructs A row by row. Assume that the first\ni-1 rows have been constructed. Let aj be the number of 1's in the j-th column in the first i-1 rows. The ri columns with maximum cj-aj are assigned 1's in row , and the rest\nof the columns are assigned 0's. That is, the columns that still needs the most 1's are given 1's. Formally prove that this algorithm is correct using an exchange argument.\n\nSo what I tried to do as with most greedy problems I encountered is to wrap it up in an induction,\nassume that the rows up to the i-th row in the greedy solution and the optimal solution are the same and then try to change the i+1-th row so it will match the greedy and prove that it wont create a less optimal solution to the optimal given. then keep it up for k-i iterations till the entire solution is similar. \n\nAfter trying that unsuccessfully I tried the same idea only per coordinate assume the ij coordinate is the first one that does not match and again failed.\n\nThen I tried a different approach assuming that I have a set of steps in the greedy and swap a whole step of the algorithm (which is basically the same idea as the first one) and still I did not manage to find a way in which it is guaranteed that I did not create a less optimal solution.\n\nthanks in advance for any assistance. \n    ", "Answer": "\r\nConsider some inputs ```\nr```\n and ```\nc```\n and a matrix ```\nS```\n that satisfies them.\nThrow away the contents of the last row in ```\nS```\n to get a new matrix ```\nS(n-1)```\n. If we fed ```\nS(n-1)```\n to the greedy algorithm and asked it to fill in this last row, it'd obviously recover a satisfying solution.\nWell, now throw away the contents of the last two rows in ```\nS```\n to get ```\nS(n-2)```\n. Since we know a satisfying solution exists, we know that there are no ```\nj```\n such that ```\nc(j) - a(j) > 2```\n, and the number of ```\nj```\n such that ```\nc(j)-a(j) == 2```\n is smaller or equal to ```\nr(n-1)```\n. It follows that the greedy algorithm will set ```\nA[n-1, j] = 1```\n for the latter set of ```\nj```\n, along with some other ```\nj```\n for which ```\nc(j)-a(j) = 1```\n. But because we know there's a satisfying solution, it must be that the number of ```\nj```\n with ```\nc(j) - a(j) == 1```\n after the ```\nn-1```\nth row is filled is exactly ```\nr(n)```\n, and is hence satisfiable.\nAnyway, we can extend this downwards: in ```\nS(n-k-1)```\n it must be the case that:\n\nthere aren't any ```\nj```\n such that ```\nc(j) - a(j) > k+1```\n\nthere can be at most ```\nr(n-k)```\n many ```\nj```\n such that ```\nc(j) - a(j) = k+1```\n,\nand ```\nSum(c(j) - a(j)) == Sum(r(i), i >= n-k)```\n\n\nSo after the greedy algorithm has processed the ```\nn-k```\nth row, it must be the case that\n\nthere aren't any ```\nj```\n such that ```\nc(j) - a(j) > k```\n\nthere can be at most ```\nr(n-k+1)```\n many ```\nj```\n such that ```\nc(j) - a(j) = k```\n,\nand ```\nSum(c(j) - a(j)) == Sum(r(i), i >= n-k+1)```\n\n\nHence when ```\nk = 0```\n, there aren't any ```\nj```\n such that ```\nc(j) - a(j) > 0```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is it possible that a greedy algorithm is also a dynamic programming algorithm?\r\n                \r\nIs it possible that a ```\ngreedy```\n algorithm is also a ```\ndynamic programming```\n algorithm?\n\nI took an ```\nAnalysis of Algorithms```\n class but still, I am not sure with the two concepts.\n\nI understand that the greedy approach uses the current optimal solution to find the global optimal solution and DP algorithm reuse the overlapping sub-results.\n\nI believe the answer is \"YES\" but I couldn't find a good example which is both greedy and DP algorithm.\n\nCould someone give me an example?\n\nIf the answer to the above question is \"NO\" then could someone explain to me why? \n    ", "Answer": "\r\nFrom looking at the Bellman equation:\n\nIf in the minimization we can separate the f part (current period) from the J part (optimal from previous periods) then this corresponds precisely to the greedy approach. An easy example of this is when the optimization function is the sum of the costs at each period,\n```\nJ(u1,u2,...)= sum(f_i(u_i))```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is the bad case in greedy algorithm for coin changing algorithm?\r\n                \r\nThe Coin changing problem is making change for n cents using the fewest number of coins.\n\nCan you give a set of coin denominations for which the greedy algorithm does not yield an optimal solution. The set should include a penny so that there is a solution for every n.\n    ", "Answer": "\r\nWell, given ```\n10, 7, 1```\n coins change ```\n15```\n:\n```\n15 = 10 + 1 + 1 + 1 + 1 + 1 // greedy  (6 coins)\n15 =  7 + 7 + 1             // optimal (3 coins)\n```\n\nYou can easily generate a greedy solution as much inefficient as you want:\njust let available coins be ```\n1```\n, ```\nN-1```\n, ```\nN```\n and try to change ```\n2 * N - 2```\n:\n```\n N, 1, 1, ..., 1 // greedy  (N - 1 coins)\n N-1, N-1        // optimal (2 coins)\n```\n\nNow, make ```\nN```\n being large\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why is greedy algorithm not finding maximum independent set of a graph?\r\n                \r\nGiven a graph G, why is following greedy algorithm not guaranteed to find maximum independent set of G:\n\n```\nGreedy(G):\nS = {}\nWhile G is not empty:\n    Let v be a node with minimum degree in G\n    S = union(S, {v})\n    remove v and its neighbors from G\nreturn S\n```\n\n\nI am wondering can someone show me a simple example of a graph where this algorithm fails?\n    ", "Answer": "\r\nI'm not sure this is the simplest example, but here is one that fails: https://i.stack.imgur.com/ZPuHR.jpg\n\nFor the first step, you can choose B, C, D, or F since they all have degree 2. Suppose we remove B and its neighbors. That leaves F and D with degree 1 and E with degree 2. During the next two steps, we remove F and D and end up with a set size of 3, which is the maximum.\n\nInstead suppose on the first step we removed C and its neighbors. This leaves us with F, A and E, each with a degree size of 2. We take either one of these next, and the graph is empty and our solution only contains 2 nodes, which as we have seen, isn't the maximum.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Prove or give a counter example for this greedy algorithm\r\n                \r\nI'm having trouble with this homework question. I think the main confusion comes from not identifying a basis for a counter example.\n\n\n  Let ```\nP1```\n, . . . , ```\nPn```\n be programs stored on a disk. Program ```\nPi```\n requires\n  ```\nSi```\n megabytes of storage, and the capacity of the disk is ```\nD```\n\n  megabytes. Where ```\nD```\n is less than the sum of megabytes of storage\n  \n  \n  (a) maximize the number of programs held on the disk. Prove or give a counter-example: greedy algorithm that selects programs in order of\n  increasing ```\nSi```\n\n  (b) use as much of the capacity of the disk as possible. Prove or give a counter-example: greedy algorithm that selects programs in\n  order of decreasing ```\nSi```\n\n  \n\n\nEdit:\nSorry for not clarifying.\n\nFor part (a) my initial try was assuming that it does not select programs in order of increasing  ```\nSi```\n. Choosing ```\nPa```\n, ```\nPb```\n and ```\nPc```\n where ```\nSa<=Sb<=Sc```\n, after this I didn't really understand how to go further and part (b) asks the same question but decreasing ```\nSi```\n.\n    ", "Answer": "\r\na) Theorem: taking programs in increasing order of disk space required ensures that as many programs run as is possible. Proof: the proof is by contradiction. Suppose there is some other method of choosing programs that allows more to run. Then this method must select a different set of programs in at least one case; that is, it must select at least one program that requires more space than one not selected. However, the method might as well have selected the program requiring less space rather than this other one that differentiates it from the selection made by the greedy algorithm. This contradicts the assumption that this method is better than the greedy method. Therefore, no method is better than the greedy method: it is optimal.\n\nb) Theorem: taking programs in decreasing order of disk space required does not ensure that as much disk space is used as is possible. Proof: the proof is by example. Consider the case of a disk of size 10 and programs requiring disk space 6, 5 and 5. Taking the programs in decreasing order of disk space required allows us to use only 6 of the 10 available storage units, whereas we might have taken two programs requiring 5 units each for 10 total units. Therefore, the greedy approach does not give an optimal result in all cases.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What are the differences between Nearest Neighbor Algorithm and Greedy Algorithm?\r\n                \r\nI'm trying to develop 2 different algorithms for Travelling Salesman Algorithm (TSP) which are Nearest Neighbor and Greedy. I can't figure out the differences between them while thinking about cities. \n\nI think they will follow the same way because shortest path between two cities is greedy and the nearest at the same time. which part am i wrong? Can you explain with a few cities example thank you!\n    ", "Answer": "\r\nCheck out this link here:\nhttps://en.wikipedia.org/wiki/Travelling_salesman_problem\nIt gives an in depth description of the problem. There are many different solutions to the TSP, the Nearest Neighbour solution is a Greedy Solution, so these are indeed the same.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm in C not returning any values?\r\n                \r\nI'm attempting to write a greedy algorithm with input that should return the smallest number of coins to be used in the change, but it's not returning any values. I am not sure why. It just asks for input, then displays nothing.\n\nI made a previous thread where a bug was determined that resulted in an infinite loop, which was squashed, but now there seems to be another underlying bug in my logic. \n\n```\n#include <stdio.h>\n#include <cs50.h>\n#include <math.h>\n\n// declare variable change_owed, num_coins, and input globally\nfloat change_owed = 0;\nfloat input;\nint num_coins;\n\nint main(void)\n{\n    // makes sure the input is non-negative\n    do\n    {\n        input = get_float(\"Amount paid\\n\");\n    }\n    while(input <=0);\n\n    // begin checking \n    while(input > 0)\n    {\n        if(input - .25 >= 0) // quarters\n        {\n            num_coins++; // number of coins used, to be printed later, is incremented\n            input = input - .25; // coin is subtracted from total\n        }\n        if (input - .10 >= 0) // dimes\n        {\n            num_coins++;\n            input = input - .10;\n        }   \n        if (input - .05 >= 0) // nickels\n        {\n            num_coins++;\n            input = input - .05;\n        } \n        if (input - .01 >= 0) // pennies\n        {\n            num_coins++;\n            input = input - .01;\n        } \n    }\n    printf(\"%i\", num_coins);\n}\n```\n\n    ", "Answer": "\r\nIn the commonly used format for ```\ndouble```\n, ```\n.10```\n is not .10 but is 0.100000001490116119384765625. Also, you are using ```\nfloat```\n variables (```\nfloat input```\n) with ```\ndouble```\n constants (```\n.10```\n, ```\n.05```\n, ```\n.01```\n). At some point, your program has a remaining amount of money such as .00999…5 that is less than a penny, so it has no coin to subtract from it, so the code loops forever without subtracting anything. To fix that, as soon as you get the ```\ninput```\n, multiply it by 100, round it to the nearest integer (as with ```\nint cents = roundf(input * 100);```\n), and use integer arithmetic for the rest of the calculations.\n\nOnce you have done that, your program will start producing results, and you will need to rethink the ```\nwhile```\n and ```\nif```\n structures you have, as mentioned in some of the comments.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm Java / firstFit method\r\n                \r\nI am taking a data structures and algorithms with Java class at my local community college, and I am completely stuck on my current homework assignment. The problem is as follows...\n\nWrite a program that packs the objects of various weights into containers. Each container can hold a max of 10 pounds. \n\nThe program uses a greedy algorithm that places an object into the first bin in which it will fit. \n\nI am not asking for my homework to be done for me, I am just really hoping to be pointed in the right direction. I have the program really close to working but I just can't get it to function 100% properly. I am able to get the first container to hold the right amount of weight, but then after that the rest of my containers only hold one weight value per container. Here is what I have so far....\n\n```\nimport java.util.ArrayList;\n\n\npublic class Lab20 {\n    public static void main(String[] args) {\n        final java.util.Scanner input = new java.util.Scanner(System.in);\n\n    System.out.print(\"Enter the number of objects: \");\n    double[] items = new double[input.nextInt()];\n    System.out.print(\"Enter the weight of the objects: \");\n    for (int i = 0; i < items.length; i++) {\n        items[i] = input.nextDouble();\n    }\n\n    ArrayList<Bin> containers = firstFit(items);\n\n    //Display results\n    for (int i = 0; i < containers.size(); i++) {\n        System.out.println(\"Container \" + (i + 1)\n                + \" contains objects with weight \" + containers.get(i));\n    }\n    input.close();\n}\n\n//Greedy Algorithm??\npublic static ArrayList<Bin> firstFit(double[] items) {\n    ArrayList<Bin> list = new ArrayList<>();\n    Bin bin = new Bin();\n\n    list.add(bin);\n\n    for (int i = 0; i < items.length; i++) {\n        if (!bin.addItem(items[i])) {\n            Bin bin2 = new Bin();\n            list.add(bin2);\n            bin2.addItem(items[i]);\n            }\n        }\n        return list;\n    }\n}\n\n//Bin Class\nclass Bin {\n    private ArrayList<Double> objects = new ArrayList<>();\n    private double maxWeight = 10;\n    private double totalWeight = 0;\n\n    public Bin() {\n    }\n\n    public Bin(double maxWeight) {\n        this.maxWeight = maxWeight;\n    }\n\n    //Or is this supposed to be the Greedy algorithm??\n    public boolean addItem(double weight) {\n        if ((totalWeight+weight) <= maxWeight) {\n            objects.add(weight);\n            totalWeight += weight;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    public int getNumberOfObjects() {\n        return objects.size();\n    }\n\n    @Override\n    public String toString() {\n        return objects.toString();\n    }\n}\n```\n\n\nAnd here is the output that I am getting...\n\nEnter the number of objects: 6\n\nEnter the weight of the objects: 7 5 2 3 5 8\n\nContainer 1 contains objects with weight [7.0, 2.0]\n\nContainer 2 contains objects with weight [5.0]\n\nContainer 3 contains objects with weight [3.0]\n\nContainer 4 contains objects with weight [5.0]\n\nContainer 5 contains objects with weight [8.0]\n\n\n\nAnd this is what the output should be...\n\nEnter the number of objects: 6\n\nEnter the weight of the objects: 7 5 2 3 5 8\n\nContainer 1 contains objects with weight [7.0, 2.0]\n\nContainer 2 contains objects with weight [5.0, 3.0]\n\nContainer 3 contains objects with weight [5.0]\n\nContainer 4 contains objects with weight [8.0]\n    ", "Answer": "\r\nThere's a problem in your firstFit method. \n\nWhat you do is, you only try to add an element to the first bin in the BinList. In order to achieve what you expect, you have to try to add the item to all the bins in the list. Then you should check whether you could add or not. If not, you have to use a new bin and add to the list as follows.\n\n```\nfor (int i = 0; i < items.length; i++) {\n    boolean added=false;    \n    for(Bin bin: list){ \n        if(bin.addItem(items[i])){\n            added=true;         \n            break;\n        }\n    }\n    if(!added){\n        Bin bin=new Bin();\n        bin.addItem(items[i]);\n        list.add(bin);\n    }\n}\nreturn list;\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for a given unsorted input with time complexity \"nlogn\"\r\n                \r\nMulti-Constrained Knapsack Problem \n\ni have such a given example ,i m just trying to understand, whats the difference between greedy algorithm with O(n*logn) and greedy algorithm for O(n2)? I really do not know how to start please help! Should i sort it or something different :( ?\n(profit and weight ratio is not in a decreasing or increasing order,totally random)\np = (p1; : : : ; pn) = (24; 17; 95; 103; 41; 39; 22; 1)\nw = (w1; : : : ;wn) = (20; 15; 39; 41; 27; 23; 18; 2)\n    ", "Answer": "\r\nYup, the O(n log n) algorithm is to sort by (profit / weight) in decreasing order, and then grab as many objects as possible up to the weight limit. Of course the sorting algorithm has to be O(n log n). \n\nThe naive (O(n^2)) algorithm would be to repeatedly search the list for the item with the highest (profit / weight) ratio and grab that. Note that this is, in effect, the same as doing a selection sort.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm to get highest score obtainable\r\n                \r\nI have an exam where the max pts is 55 and time limit is 50 mins. I need to devise a greedy algorithm in R to maximize the number of points obtainable in the allocated time. \n\nassumptions:\n-100% correct for questions attempted \n-once question started, it must be completed\n\nI don't really know how to go about this one. \n\n```\n> table[order(table$Points_per_min, decreasing = T),]\n  Question Total_Points Time_needed Points_per_min\n6       Q6            5           3      1.6666667\n5       Q5            5           4      1.2500000\n4       Q4           14          12      1.1666667\n7       Q7           10          10      1.0000000\n8       Q8            5           5      1.0000000\n1       Q1           21          24      0.8750000\n9       Q9            5           6      0.8333333\n2       Q2            5           7      0.7142857\n3       Q3           10          15      0.6666667\n```\n\n\nI think based on calculations by hand, I should get 49 max points and 47 minutes used. I could be wrong. Thank you! \n    ", "Answer": "\r\nYou can set this up as a linear optimization problem. You are trying to maximize the number of points, subject to the time constraint. Further, each decision variable should be binary as you can't answer the same question twice.\n\n```\nlpSolveAPI```\n is an R package to set these problems up. To be honest, I find the syntax a bit dense, but very powerful. I was able to find a 50 point solution that takes all 50 minutes. FWIW, I found the same solution in Excel's ```\nSolver()```\n, which is a bit more intuitive in my opinion.\n\nThe full solution is below, but here's the representation of the model we've set up (this is the output from ```\nwrite.lp()```\n after setting the model up:\n\n```\n/* Objective function */\nmax: +21 Q1 +5 Q2 +10 Q3 +14 Q4 +5 Q5 +5 Q6 +10 Q7 +5 Q8 +5 Q9;\n\n/* Constraints */\nTime_Constraint: +24 Q1 +7 Q2 +15 Q3 +12 Q4 +4 Q5 +3 Q6 +10 Q7 +5 Q8 +6 Q9 <= 50;\n\n/* Variable bounds */\nQ1 <= 1;\nQ2 <= 1;\nQ3 <= 1;\nQ4 <= 1;\nQ5 <= 1;\nQ6 <= 1;\nQ7 <= 1;\nQ8 <= 1;\nQ9 <= 1;\n\n/* Integer definitions */\nint Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q8,Q9;\n```\n\n\n\n\n```\nlibrary(lpSolveAPI)\nlibrary(data.table)\n\n#Define questions, points, and time requirements\ndt <- data.table(questions = paste0(\"Q\", 1:9), points = c(21,5,10,14,5,5,10,5,5), time = c(24,7,15,12,4,3,10,5,6))\n\n#make lp object with one contrasint and 9 decision variables\nlprec <- make.lp(1,9)\n#make sure we're maximizing, not minimizing\nlp.control(lprec,sense='max')\n#Set the names\ndimnames(lprec) <- list(\"Time_Constraint\", dt$questions)\n#Set the objective function values, i.e. how many points we get\nset.objfn(lprec, dt$points)\n#assign the time taken to earn the points\nset.row(lprec, 1, dt$time)\n#what is the right hand side variable to 50\nset.rhs(lprec, 50)\n#make the variables binary\nset.type(lprec, columns = 1:9, \"binary\")\n#write this model out to see what it is\nwrite.lp(lprec, filename = \"model.lp\", type = \"lp\")\n#solve the model\nsolve(lprec)\n#> [1] 0\n#get the answers, i.e. which should be answered\nanswers <- get.variables(lprec)\n#let's subset just the questions we should answer\ndt[as.logical(answers), ]\n#>    questions points time\n#> 1:        Q1     21   24\n#> 2:        Q4     14   12\n#> 3:        Q5      5    4\n#> 4:        Q7     10   10\n#and confirm that we don't go over 50 minutes\ndt[as.logical(answers), .(points = sum(points), time_taken = sum(time))]\n#>    points time_taken\n#> 1:     50         50\n```\n\n\nCreated on 2019-02-10 by the reprex package (v0.2.1)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Having problem in compiling this Greedy Algorithm's python question [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        TypeError: list indices must be integers or slices, not float\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 3 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI was trying this question which is a greedy algorithm question. The celebration party problem.\nWhen i run it , as you can see below, it says list indices must be integer..\nCan you help me with this, I am new to algorithm coding. \nI am also open to better and effective solutions.\n\nProblem:\n\n```\na=[1,5.4,2.1,3.4,3.1,2.0,1.8,8.9,10,23,4,5,5,2,1.6,1.9]\na.sort()\nq=0\nz={}\nfor i in range(len(a)):\n    if (a[q]+1.0)>=a[i]:\n        if q not in z.keys():\n            z[q]=[]\n        z[q].append(a[i])\n    else:\n        q=a[i]\n        if q not in z.keys():\n            z[q]=[]\n        z[q].append(a[i])\n```\n\n\n\r\n\r\n```\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-32-60bee6e37157> in <module>\r\n      4 z={}\r\n      5 for i in range(len(a)):\r\n----> 6     if (a[q]+1.0)>=a[i]:\r\n      7         if q not in z.keys():\r\n      8             z[q]=[]\r\n\r\nTypeError: list indices must be integers or slices, not float```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nThe problem is with using q after you have assigned it to the values in a\n\n```\na=[1,5.4,2.1,3.4,3.1,2.0,1.8,8.9,10,23,4,5,5,2,1.6,1.9]\na.sort()\nq=0\nz={}\nfor i in range(len(a)):\n    if (a[q]+1.0)>=a[i]: # this is the problem that you have an error\n        if q not in z.keys():\n            z[q]=[]\n        z[q].append(a[i])\n    else:\n        q=a[i] #here you are assigned the value to q, which can be a float\n        if q not in z.keys():\n            z[q]=[]\n        z[q].append(a[i])\n```\n\n\nWhen you check ```\nif (a[q]+1.0)>=a[i]```\n, it is taking the list ```\na```\n and checking the index using the value ```\nq```\n.  Since that value can be a float, you can have the error, since index must be an int. \n\nYou can change the loop to track the index instead:\n\n```\na=[1,5.4,2.1,3.4,3.1,2.0,1.8,8.9,10,23,4,5,5,2,1.6,1.9]\na.sort()\nq=0\nqidx=0\nz={}\nfor i in range(len(a)):\n    if (a[qidx]+1.0)>=a[i]:\n        if q not in z.keys():\n            z[q]=[]\n        z[q].append(a[i])\n    else:\n        q=a[i]\n        qidx = i\n        if q not in z.keys():\n            z[q]=[]\n        z[q].append(a[i])\n```\n\n\nWhich will output\n\n```\n{0: [1, 1.6, 1.8, 1.9, 2.0, 2], 2.1: [2.1, 3.1], 3.4: [3.4, 4], 5: [5, 5, 5.4], 8.9: [8.9], 10: [10], 23: [23]}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Trying to gain intuition for work scheduling greedy algorithm\r\n                \r\nI have the following scenario: (since I don't know of a way to show LaTeX, here's a screenshot)\n\n\n\nI'm having some trouble conceptualizing what's going on here. If I were to program this, I would probably attempt to structure this as some kind of heap where each node represents a worker, from earliest-to-latest, then run Prim's/Kruskal's algorithm on it. I don't know if I'm on the right track with that idea, but I need to flesh out my understanding of this problem so I can do the following:\n\n\nDescribe in detail the greedy choice\nShow that if there's an optimal solution for which the greedy choice was not made, then an  exchange can be made to conform with the greedy choice\nKnow how to implement a greedy algorithm solution, and its running time\n\n\nSo where should I be going with this idea?\n    ", "Answer": "\r\nThis problem is very similar in nature to \"Roster Scheduling problems.\" Think of the committee as say a set of 'supervisors' and you want to have a supervisor present, whenever a worker is present. In this case, the supervisor comes from the same set as the workers.\nHere are some modeling ideas, and an Integer Programming formulation.\nTime Slicing Idea\nThis sounds like a bad idea initially, but works really well in practice. We are going to create a lot of \"time instants\" T i from the start time of the first shift, to the end time of the very last shift. It sometimes helps to think of\n```\nT1, T2, T3....TN```\n as being time instants (say) five minutes apart. For every ```\nTi```\n at least one worker is working on a shift. Therefore, that time instant has be be covered (Coverage means there has to be at least one member of the committee also working at time ```\nTi```\n.)\nWe really need to only worry about ```\n2n```\n Time instants: The start and finish times of each of the ```\nn```\n workers.\nCoverage Property Requirement\nFor every time instant ```\nTi```\n, we want a worker from the Committee present.\nLet ```\nw1, w2...wn```\n be the workers, sorted by their start times ```\ns_i```\n. (Worker ```\nw1```\n starts the earliest shift, and worker ```\nwn```\n starts the very last shift.)\nIntroduce a new Indicator variable (boolean):\n```\nY_i = 1 if worker i is part of the committeee\nY_i = 0 otherwise.\n```\n\nVisualization\nNow think of a 0-1 matrix, where the rows are the SORTED workers, and the columns are the time instants...\nConstruct a Time-Worker Matrix (0/1)\n```\n    t1 t2 t3 t4 t5 t6 ...          tN\n------------------------------------------- \nw1   1  1\nw2   1  1\nw3      1  1  1\nw4         1  1  1  \n...\n...\nwn                               1 1 1 1\n------------------------------------------- \nTotal 2 4 3 ...              ... 1 2 4 5\n```\n\nSo the problem is to make sure that for each column, at least 1 worker is Selected to be part of the committee. The Total shows the number of candidates for the committee at each Time instant.\nAn Integer Programming based formulation\n```\nObjective: Minimize Sum(Y_i)\n\nSubject to:\n\nY1 + Y2       >= 1 # coverage for time t1\nY1 + Y2 + Y3  >= 1 # coverage for time t2\n...\n```\n\nMore generally, the constraints are:\n```\n# Set Covering constraint for time T_i\nSum over all worker i's that are working at time t_i (Y_i) >= 1 \n\nY_i Binary for all i's\n```\n\nPreprocessing\nThis Integer program, if attempted without preprocessing can be very difficult, and end up choking the solvers. But in practice there are quite a number of preprocessing ideas that can help immensely.\n\nMake any forced assignments. (If ever there is a time instant with only one\nworker working, that worker has to be in the committee ```\n∈ C```\n)\nSeparate into nice subproblems. Look at the time-worker Matrix. If there are nice 'rectangles' in it that can be cut out without\nimpacting any other time instant, then that is a wholly separate\nsub-problem to solve. Makes the solver go much, much faster.\nIdentical shifts - If lots of workers have the exact same start and end times, then you can simply choose ANY one of them (say, the\nlexicographically first worker, WLOG) and remove all the other workers from\nconsideration. (Makes a ton of difference in real life situations.)\nDominating shifts: If one worker starts before and stays later than any other worker, the 'dominating' worker can stay, all the\n'dominated' workers can be removed from consideration for ```\nC```\n.\nAll the identical rows (and columns) in the time-worker Matrix can be fused. You need to only keep one of them. (De-duping)\n\nYou could throw this into an IP solver (CPLEX, Excel, lp_solve etc.) and you will get a solution, if the problem size is not an issue.\nHope some of these ideas help.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for finding minimum numbers of stops\r\n                \r\nMr X is traveling by car on an expressway. Suppose there are several gas (petrol) stations\non the way: at distances 0 = d0 < d1 < d2 < ... < dn from the starting point d0. \n\nMr X’scar, when full, can travel a distance D >= max{di+1 - di} . \nMr X wants to minimize the number of stops he makes to fill gas.\n\nDevise an greedy algorithm that return min numbers of stops needed. \n    ", "Answer": "\r\nThis is the sort of thing it is asking for.\n\nGCC 4.8.3: ```\ng++ -Wall -Wextra -std=c++0x -g main.cpp```\n\n\n```\n#include <algorithm>\n#include <iostream>\n#include <stdexcept>\n#include <vector>\n\nint count_stops(int D, const std::vector<int>& d) {\n  if (d.size() < 2) { throw std::logic_error(\"Vector too small.\"); }\n\n  auto p = std::begin(d);\n  auto count = 0;\n\n  while (p != --std::end(d)) {\n    // Greedy: go as far as I can on this tank of gas.\n    auto n = --std::find_if(p, std::end(d), [=](int x) {\n      return *p + D < x; });\n    // The specification says we do not need to worry about this...\n    if (p == n) { throw std::logic_error(\"D too small.\"); }\n    p = n;\n    ++count; }\n\n  return count; }\n\n\nint main(int, char* []) {\n  auto D = 16;\n  auto d = std::vector<int> { 0, 5, 15, 30, 32, 33, 37, 49, 53, 59, 61 };\n\n  std::cout << \"stops: \" << count_stops(D, d) << \"\\n\";\n  return 0; }\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm java in map\r\n                \r\nI'm working on emulator of ATM in java. The overall pattern in project is Command. \nSo I have 4 commands - getInfo, deposit,withdraw and exit.\n\nI'm facing problems with an implementation of greedy algorithm in withdrawal method. It should return Map were first Integer is \"denomination\" and second Integer is \"amount\" left in ATM after we withdrew.\n\n```\npublic Map<Integer, Integer> withdrawAmount(int expectedAmount) \n```\n\n\nSo it takes expected amount as an argument and has to subtract it from ATM with the least possible amount of bills.\n\n```\n   public class CurrencyManipulator\n    {\n// denominations is a map where each denomination and it's quantity stored\n        private String currencyCode;\n        private Map<Integer, Integer> denominations = new HashMap<>();\n\n        public String getCurrencyCode()\n        {\n            return currencyCode;\n        }\n\n    public CurrencyManipulator(String currencyCode)\n    {\n        this.currencyCode = currencyCode;\n    }\n\n    public void addAmount(int denomination, int count)\n    {\n        if (denominations.containsKey(denomination))\n        {\n            denominations.put(denomination, denominations.get(count) + count);\n        } else\n        {\n            denominations.put(denomination, count);\n        }\n    }\n\n    public int getTotalAmount()\n    {\n        int sum = 0;\n        for (Map.Entry<Integer, Integer> pair : denominations.entrySet())\n        {\n            sum = pair.getKey() * pair.getValue();\n        }\n        return sum;\n    }\n\n    public boolean hasMoney()\n    {\n        return denominations.size() != 0;\n    }\n\n    public boolean isAmountAvailable(int expectedAmount)\n    {\n        return expectedAmount <= getTotalAmount();\n    }\n\n     public Map<Integer, Integer> withdrawAmount(int expectedAmount) throws NotEnoughMoneyException\n    {\n\n\n    }\n} \n```\n\n\nSo I need this method to return a map or throw exception if amount asked \"expectedAmount\" is higher then money available in ATM.\n\nIf we take $600 it could be - three bills: $500 + $50 + $50 OR $200 + $200 + $200, the preferred option is $500 + $50 + $50\nExample, you have to give $600\nThe ATM has the following bill-count:\n\n500 - 2\n\n200 - 3\n\n100 - 1\n\n50 - 12\n\nThe result should be:\n\n500 - 1\n\n100 - 1\n\nThis what I came up with:\n\n```\npublic Map<Integer, Integer> withdrawAmount(int expectedAmount) throws NotEnoughMoneyException\n    {\n\n        denominations.put(50,1);\n        denominations.put(500,1);\n        denominations.put(200,3);\n        HashMap<Integer, Integer> map = new HashMap<>();\n        TreeMap<Integer, Integer> sortedMap = new TreeMap<>(Collections.reverseOrder());\n        sortedMap.putAll(denominations);\n        ArrayList<Integer> bills = new ArrayList<>();\n        bills.addAll(sortedMap.keySet());\n\n\n        int num;\n\n        for (int i = 0; i < bills.size(); i++)\n        {\n            if (bills.get(i) <= expectedAmount)\n            {\n                num = expectedAmount / bills.get(i);\n                map.put(bills.get(i), num);\n                expectedAmount -= num * bills.get(i);\n            }\n        }\n        System.out.println(map);\n        return map;\n    }\n```\n\n\nIt returns the map of needed bills and their quantity. \n\nNow my question is..how do i compare it with the \"denominations\" map i have and subtract new map from it? \n    ", "Answer": "\r\nseems to be working code if someone ever needs it    \n\n```\npublic Map<Integer, Integer> withdrawAmount(int expectedAmount) throws NotEnoughMoneyException\n    {\n\n\n        denominations.put(50,2);\n        denominations.put(500,1);\n        denominations.put(100,1);\n        HashMap<Integer, Integer> map = new HashMap<>();\n\n        TreeMap<Integer, Integer> sortedDenominations = new TreeMap<>(Collections.reverseOrder());\n        sortedDenominations.putAll(denominations);\n        ArrayList<Integer> bills = new ArrayList<>();\n        bills.addAll(sortedDenominations.keySet());\n\n\n        int num;\n\n        for (int i = 0; i < bills.size(); i++)\n        {\n            if (bills.get(i) <= expectedAmount)\n            {\n                num = expectedAmount / bills.get(i);\n                map.put(bills.get(i), num);\n                expectedAmount -= num * bills.get(i);\n            }\n        }\n        System.out.println(map);\n\n        for (Map.Entry<Integer,Integer> denominPresent:sortedDenominations.entrySet()){\n            int value;\n            for (Map.Entry<Integer,Integer> deominNeeded:map.entrySet()){\n\n                if(denominPresent.getKey().equals(deominNeeded.getKey())){\n                    value = denominPresent.getValue()-deominNeeded.getValue();\n                    if (value>=0) sortedDenominations.put(denominPresent.getKey(),value);\n                    else throw new NotEnoughMoneyException();\n                }\n\n            }\n\n        }\n\n        System.out.println(sortedDenominations);\n        return sortedDenominations;\n    }\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How do I answer this greedy algorithm question?\r\n                \r\nI am learning greedy algorithm and it's applications. The question below is the first one of the many provided in the book to learn greedy algorithm.\n\nQ) There is n number of children and you have m > n number of chocolate to distribute. You must give\neach child exactly one chocolate (of course, you cannot give the same chocolate to two different\nchildren). Each child has an appetite factor ai, 1 ≤ i ≤ n which is the minimum size of a chocolate that the\nchild will be happy with; and each chocolate has a size sj , 1 ≤ j ≤ m. Your goal is to maximize the\nnumber of happy children, i.e., children i assigned a chocolate j with gi ≤ sj..\n\nI would really appreciate it if anyone could help me the solution to this question. There are a few more like this but I think I will be able to do them if i can do this one.\n\nThanks!\n    ", "Answer": "\r\nYou've correctly identified the algorithm in the comments:\n\n\n  we have to assign the cookies in ascending order and whenever possible\n  assign it the least greediest child\n\n\nYou can break the algorithm down into simple steps, like this\n\n```\nSort the cookies ascending by size\nFor each cookie in the sorted list\n    if the least greedy child remaining will be happy with that cookie\n        give the cookie to the least greedy child\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Pseudo code for a greedy algorithm for the influence maximization under the independent cascade mode\r\n                \r\nI understand the concept behind a greedy algorithm but am still confused about the influence maximization under the independent cascade model and how I would implement the greedy algorithm.\n\n\nread in the data in a loop\nstick it into a data structure (i.e. arrays for nodes & edges, variables for the node count, edge count, probability, etc), \nloop through the nodes and edges using the algorithm storing the output values into another array, and finally \nloop to print out the results of your output array.\n\n\nI am looking for pseudo code to understand the overall approach to creating this program. \n\nI had found pseudo code for a greedy algorithm but I'm not sure I'm hoping to be able to create a working project once I am pushed in the right direction.\n\nLink to prompt\n\nLink to Greedy Algorithm Pseudo code\n\nI have this as far as the greedy algorithm goes:\n\n{\n\nOpen file (graph.txt)\n\nReadln (n, m, k)\n\ni = 1\n\nwhile (i <= n)\n\n   \n     Readln(nodes[i], vert[i], probability[i])\n\nend\n\n}\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is the difference between greedy and steepest algorithms?\r\n                \r\nI have slides where 2 versions of local search algorithms are compared: greedy and steepest.\n\nGreedy:\n    generate solution x;\n    repeat\n    {\n        for each y in N(x) in random order\n        {\n            if f(y) > f(x) then\n                x = y;\n        }\n    }\n    until no better solution was found\n\nSteepest:\n    generate solution x;\n    repeat\n    {\n        find the best solution y in N(x);\n        if f(y) > f(x) then\n            x = y;\n    }\n    until no better solution was found\n\nBut everywhere on the Internet I read that greedy method searches for the best (not first better found) solution. So - what is the difference? And: which version is true?\n    ", "Answer": "\r\nI agree that greedy would also mean steepest as it attempts to make the locally optimal choice. To me the difference is that the notion of steepest descent / gradient descent is closely related with function optimization, while greedy is often heard in the context of combinatorial optimization. Both however describe the same \"strategy\".\n\nIn my opinion these notions are not very well suited to describe the behavior that you want to describe. I prefer the terms best improvement and first improvement local search. Both a greedy local search and the steepest descent method would be best improvement local search methods.\n\nWith regular expressions, greedy has a similar meaning: That of considering the largest possible match to a wildcard expression. It would be also wrong to state greedy matching would match on the first possibility.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Visiting all nodes in a DAG using a greedy algorithm\r\n                \r\nI'm trying to visit all the nodes within a directed acyclic graph using a greedy algorithm. I was thinking that something like depth first search would work but I'm not sure how this would work with a DAG as I cannot trace myself back through the graph.\n\nThanks.\n    ", "Answer": "\r\nYes, you can use either depth-first search (DFS) or breadth-first search (BFS), check any good texbook, for instance, \"Introduction to Algorithms\" by Thomas H. Cormen.\n\nYou do not need to use edges to \"trace yourself back\", use either a stack (or recursion) or a queue.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is it possible to solve a fractional knapsack including negative values using greedy algorithm?\r\n                \r\nI have a problem which I think can be converted to a variant of \nfractional knapsack problem.\n\nThe objective function is in the form of:\n\n$\\sum_{i} x_iv_i$\n\nHowever, my problem differs in that it allows $v_i$ s and $x_i$ to be negative.\n\nI want to prove that this problem can be solved using the greedy algorithm (explained in the link).\n\nI have tested this for many test cases and greedy algorithm seems to solve it, but I want a definite \nproof that greedy algorithm is still applicable given the extra constraint.\n    ", "Answer": "\r\nIn the fractional knapsack problem, you find the Value/Weight of every item that you may put in the knapsack, and sort these items from the best V/W ratio to the worst. You then start with the best ratio, and fill the knapsack is either full or you run out. If you run out, you then head to the next item in the list and fill the knapsack with it. This pattern continues until the knapsack is full. It is greedy, because once we sort this list we know that we can confidently add the items fractionally in this order and that we will end with the greatest potential value in the bag.\n\nBy allowing the values and \"weights\" to be negative, as in this problem, however, the algorithm is no longer greedy. It is ruined by the fact that an item could have a negative \"weight\" and negative value, resulting in a positive V/W ratio. For example, take the following list of items:\n\n\nV=-1, W=-1  -> V/W = 1.0\nV=.9, W=1  -> V/W = 0.9\nV=.8, W=1  -> V/W = 0.8\n\n\nFollowing the greedy algorithm, we would want to add as much of item 1 as exists, because it has the best V/W ratio. However, adding item 1 really hurts us in the long run, because we are losing more value per weight then we can add later on. For example, let's assume the |W|=10 for each, and the max weight of the knapsack is 10. By adding all of 1, we will have a weight of -10 and a value of -10. Then we add all of 2, which results in a weight of 0 and a value of -1. Then we add all of 3, which results in a weight of 10 and a value of 7.\n\nIf instead of this, we just added all of item 2 from the start, we would have a weight of 10 and a value of 9. Therefore by contradiction, if weight and value can be negative, the algorithm is NOT a greedy algorithm.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Trying to construct a greedy algorithm with python\r\n                \r\nSo i'm trying to create a greedy algorithm for a knapsack problem. The txt file below is the knap20.txt file.  The first line gives the number of items, in this case 20. The last line gives the capacity of the knapsack, in this case 524. The remaining lines give the index, value and weight of each item.\n\nMy function is to ideally return the solution in a list and the value of the weights\n\nFrom what I can tell by my results, my program is working correctly. Is it working as you would expect, and how can i improve it?\n\ntxt file\n\n```\n20\n    1    91    29\n    2    60    65\n    3    61    71\n    4     9    60\n    5    79    45\n    6    46    71\n    7    19    22\n    8    57    97\n    9     8     6\n   10    84    91\n   11    20    57\n   12    72    60\n   13    32    49\n   14    31    89\n   15    28     2\n   16    81    30\n   17    55    90\n   18    43    25\n   19   100    82\n   20    27    19\n524\n```\n\n\npython file\n\n```\nimport os\nimport matplotlib.pyplot as plt\n\ndef get_optimal_value(capacity, weights, values):\n    value = 0.\n    numItems = len(values)\n    valuePerWeight = sorted([[values[i] / weights[i], weights[i]] for i in range(numItems)], reverse=True)\n    while capacity > 0 and numItems > 0:\n        maxi = 0\n        idx = None\n        for i in range(numItems):\n            if valuePerWeight[i][1] > 0 and maxi < valuePerWeight[i][0]:\n                maxi = valuePerWeight[i][0]\n                idx = i\n\n        if idx is None:\n            return 0.\n        if valuePerWeight[idx][1] <= capacity:\n            value += valuePerWeight[idx][0]*valuePerWeight[idx][1]\n            capacity -= valuePerWeight[idx][1]\n        else:\n            if valuePerWeight[idx][1] > 0:\n                value += (capacity / valuePerWeight[idx][1]) * valuePerWeight[idx][1] * valuePerWeight[idx][0]\n                return values, value\n        valuePerWeight.pop(idx)\n        numItems -= 1\n    return value\n\n\ndef read_kfile(fname):\n    print('file started')\n    with open(fname) as kfile:\n        print('fname found', fname)\n        lines = kfile.readlines()     # reads the whole file\n    n = int(lines[0])\n    c = int(lines[n+1])\n    vs = []\n    ws = []\n    lines = lines[1:n+1]   # Removes the first and last line\n    for l in lines:\n        numbers = l.split()   # Converts the string into a list\n        vs.append(int(numbers[1]))  # Appends value, need to convert to int\n        ws.append(int(numbers[2]))  # Appends weigth, need to convert to int\n    return n, c, vs, ws\n\ndir_path = os.path.dirname(os.path.realpath(__file__))  # Get the directory where the file is located\nos.chdir(dir_path)  # Change the working directory so we can read the file\n\n\nknapfile = 'knap20.txt'\nnitems, capacity, values, weights = read_kfile(knapfile)\nval1,val2 = get_optimal_value(capacity, weights, values)\nprint ('values',val1)\nprint('value',val2)\n```\n\n\nresult\n\n```\nvalues [91, 60, 61, 9, 79, 46, 19, 57, 8, 84, 20, 72, 32, 31, 28, 81, 55, 43, 100, 27]\nvalue 733.2394366197183\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm Python - code hitting infinite loop\r\n                \r\nI am trying to write a greedy algorithm in ```\npython 3```\n. \n\nThe premise is to take change, owed by user, as input and them give them as few coins as possible.\n\nAvailable coins are: Quarters (0.25); Dimes(0.1); Nickels (0.05); and Pennies (0.01).\n\nMy code currently ends up in an infinite loop and i don't know what i am doing wrong.\n\nCan anyone see where i am going wrong with the following code?\n\nCode:\n\n```\nvalidacion = False\npennies = 0.01\nnickels = 0.05\ndimes = 0.1\nquarters = 0.25\ncoinCounter = 0\npenniesCounter = 0\nnickelsCounter = 0\ndimesCounters = 0\nquartersCounter = 0 \ncambio = False\n\nwhile validacion is False:\n    changeOwed = float(input(\"Change owed: \"))\n    if changeOwed > 0:\n        validacion = True\n    else:\n        validacion = False\nwhile cambio is False:\n    if changeOwed > dimes and changeOwed <= quarters:\n        coinCounter += 1\n        quartersCounter += 1\n        changeOwed -= quarters\n        if changeOwed == 0.0:\n            cambio = True\n    elif changeOwed > nickels and changeOwed <= dimes:\n        coinCounter += 1\n        nickelsCounter += 1\n        changeOwed -= nickels\n        if changeOwed == 0.0:\n            cambio = True\n    elif changeOwed > pennies and changeOwed <= nickels:\n        coinCounter += 1\n        dimesCounters += 1\n        changeOwed -= dimes\n        if changeOwed == 0.0:\n            cambio = True\n    else:\n        coinCounter += 1\n        penniesCounter += 1\n        changeOwed -= pennies\n        if changeOwed == 0.0:\n            cambio = True\n\nprint(coinCounter)\n```\n\n    ", "Answer": "\r\nFollowing squeamish ossifrage's advice, rephrase your assignments as:\n\n```\n    pennies = 1\n    nickels = 5\n```\n\n\nand so on. Then test your code using integer cents, rather than IEEE-754 binary FP dollars.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Maximum contiguous subsequence -- dynamic programming or greedy algorithm?\r\n                \r\nGiven an array ```\nvector<int> arr```\n with positive and negative entries, the maximum contiguous subsequence problem requires to find a (contiguous) segment of the array ```\narr```\n with maximum sum. Sum of empty segment is zero. The C++ code of the algorithm I'm using is as follows:\n\n```\n  int MaxContSum(const vector<int>& arr){\n    int i,sum=0,max=0;\n    for(i=0;i<arr.size();i++){\n      if(arr[i]>=0) {if(sum<0) sum=0;}\n      else {if(sum>max) max=sum;}\n      sum+=arr[i];\n    }\n    if(sum>max) max=sum; return max;\n  }\n```\n\n\nIs this algorithm a greedy algorithm or dynamic programming? It looks like it's just scanning the entries one by one and applying different strategies based on whether ```\narr[i]```\n is potive or negative, a locally checkable condition. Why does this problem appear in the dynamic programming chapter, then?\n    ", "Answer": "\r\nThis is Kadane's algorithm for the maximum subarray problem. It scans through the sequence and keeps track of the maximum subarray sum found up to this iteration in general, and the maximum subarray sum ending exactly at this point. How does it know the starting position of the subarray leading to the best sum up to exactly this point? Whenever 1) the previous sum is negative, and 2) a positive element is encountered, it pays to start at the positive element and continue from there. The proof that it works is by simple induction.\n\nThis algorithm is not greedy, but it can be viewed as dynamic programming.\n\nA greedy algorithm makes a locally-optimum guess, and sticks with it (just continuing it further and further). Here, conversely, the algorithm can guess to check a subsequence starting at some point (where the sum ending at a positive element is negative), and later discard it and try a subsequence starting at some other point (again, because the sum becomes negative and the element is positive).\n\nConversely, it can be viewed as a dynamic programming problem. As the Wikipedia entry puts it:\n\n\n  Because of the way this algorithm uses optimal substructures (the maximum subarray ending at each position is calculated in a simple way from a related but smaller and overlapping subproblem: the maximum subarray ending at the previous position) this algorithm can be viewed as a simple example of dynamic programming.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm for Convolutional neural network (CNN)\r\n                \r\nI had a specific question about Andrew Howard's \"Some Improvements on Deep Convolutional Neural Network Based Image Classification.\" In the paper under section 3.3, he describes using a simple greedy algorithm to reduce the number of predictions from 90 to 10, starting with the best prediction. How can you decide which image crop will produce the best prediction? My guess is we decide on the 10 best crops outputting the 10 best predictions during the validation set, and just use those 10 crop during subsequent prediction? Or is it just any 10 random crops that occur during prediction?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Find a ZIG-ZAG sequence with a greedy algorithm\r\n                \r\nAn integer sequence X=x1,x2...,xn is defined ZIG-ZAG  if :\n\nxi < xi+1 if xi is an odd number\nxi > xi+1 if xi is an even number\n\nI need a greedy algorithm to find the dimension of the maximum ZIG-ZAG subsequence inside a given sequence\n\nEDIT: \nThere's an example:\nY = (3, 4, 8, 5, 6, 2)\nOutput should be 5 for 3, 8, 5, 6, 2 or 4, 8, 5, 6, 2\n    ", "Answer": "\r\njust run through the sequence and check for each element if the condition is sattisfied.\n\ncould you try to explain what greedy algorithms have to do with this?\n\nedit: ok, now it makes more sense then in the original.\nunfortunately i can't think of a good solution atm.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for bipartite matching\r\n                \r\nSo I came across a problem in which there were 'n' pilots and 'm' airplanes. Each pilot had a list of airplanes which he could fly. And one pilot can fly only one airplane at a time. You had to determine the maximum number of planes that can fly at the same time. Standard bipartite matching problem(which I found out later). \n\nIn the contest, I came up with a greedy algorithm as follows :\n\n\n  While there are planes in the graph :  \n  \n  \n    1)Select a plane which can be flown by minimum number of pilots\n    \n    2)Greedily allocate a pilot to that plane (from the ones who can fly it)\n    \n    3)Remove both the plane and the allocated pilot from the graph\n  \n\n\nIn general, for a bipartite matching problem, I propose the following algorithm :\n\n\n  While there are nodes in the right set of the bipartite graph :\n  \n  \n    1)Select a node from the right set with minimum incoming degree\n    \n    2)Greedily match it with ANY node from the left set (which has an edge to it)\n    \n    3)Remove both these nodes from the graph( this would also involve decreasing the incoming degree of all nodes on the right to which this node has an edge to)\n  \n\n\nI am not mathematically proficient to prove the correctness of this algorithm and after a lot of thinking I have not been able to come up with a counter example. \nSo my specific question is, is this a standard or known algorithm or am I making some blatant mistake which I cannot see?\n\nPlease feel free to edit my question to make it clearer if you feel so. Thank you.\n    ", "Answer": "\r\ncounter-example:\n\n```\n   a1  a2  a3  a4  a5\np1  x   x\np2  x   x   x   x         \np3  x   x   x   x   \np4                  x\np5          x   x   x\n```\n\n\na5 is selected first. Randomly select pilot which MAY be p5. If it is, p4 doesn't have a plane.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Cases where the greedy algorithm fails the 0-1 knapsack p‌r‌o‌b‌l‌e‌m\r\n                \r\nI'm looking for a case where the greedy algorithm of picking items of the highest value/weight ratio that has weight < max weight and putting it in the knapsack first won't work. Does anyone have examples? Because otherwise, the worst case for greedy would be O(nlogn) (nlogn to sort in descending value/weight and n to go through it) while the dynamic programming way's worst case would be O(nW), making greedy faster when logn < W.\n    ", "Answer": "\r\nConsider a backpack with capacity 4, and items with the following weights and values:\n\n\nItem  Weight  Value  value/Weight\n A      3      1.65     0.55\n B      2      1        0.5\n C      2      1        0.5\n\n\nA greedy algorithm based on value per weight would first choose item A and then quit, there being insufficient capacity left for any other item -- total value 1.65.  The optimal solution, however, is to choose items B and C, which together exactly take up the full capacity and have a combined value of 2.\n\nMore generally, the greedy algorithm can fail when it chooses a set of items that don't take up the whole available capacity.  A different set of items that fills more of the available capacity will sometimes be a better choice.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for scheduling?\r\n                \r\nwhat is Greedy solution for scheduling problem when  running time (like 5 minutes, 10 minutes,  not starting and ending time ) of problem is given and you have m process to run them then what is minimum of maximum time ?\nAssume i have nine jobs ( 3,5,6,10,11,14,15,18,20 minutes) and three process then solution is \n\n1st process handle --> 20 + 14\n\n2nd process handle --> 18 + 11 +5\n\n3rd process handle --> 15 + 10 + 6 + 3\n\nminmimum time is 34 minutes \n    ", "Answer": "\r\nGiven that the problem is NP-hard (see for example here), it is unlikely that a polynomial time algorithm exists that gives an exact solution in all cases.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm - Criteria for a coin system to be canonical\r\n                \r\nGiven a coin system, what are the conditions that can be used to figure out whether the coin system is canonical. I did read a few papers but nothing solid came off from them.\nI know that greedy algorithm works only for canonical coin systems. I am trying to figure out if the coins ={1, 2, 3, 6} is a canonical coin system. Can I know what is the criteria used to decide this?\n    ", "Answer": "\r\nSee https://graal.ens-lyon.fr/~abenoit/algo09/coins2.pdf for a ```\nO(n^3)```\n algorithm for answering whether a given set of coins is canonical.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why doesn't greedy algorithm work for some currencies that are unlike US currency?\r\n                \r\nTo make $6.39, you can choose:\n\n\n$5 bill \n$1 bill to make $6. \n25¢ coin, to make $6.25 \n10¢ coin, to make $6.35 \nFour 1¢ coins, to make $6.39.\n\n\nHowever it doesn't work if the currency has coins with weights of 1,7, and 10. My question is, why does the greedy algorithm work [efficiently] only for a few weights? What are the conditions to be satisfied for the given set of weights to satisfy the greedy algorithm and be optimal at the same time?\n    ", "Answer": "\r\nThis exact problem is examined in 'A polynomial-time algorithm for the change-making problem' by David Pearson.\n\nUnfortunately, it doesn't provide an elegant mathematical property that answers the question. It is based on the fact that if the greedy algorithm doesn't work, a counterexample will be among a finite number of values and these values have properties which make it cheap to check each one.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for finding a negafibonacci representation of a number?\r\n                \r\nAccording to Zeckendorf's theorem, every positive integer can be written in a unique way as the sum of non-consecutive distinct Fibonacci numbers. Such a decomposition can be found easily with a greedy algorithm consisting essentially in subtracting the largest Fibonacci number that fits and iterating, for example:\n\n```\n20 = 13 + 7 = 13 + 5 + 2```\n\n\nHowever, the theorem also implies that any integer (also <= 0) has a unique decomposition as a sum of distinct, non-consecutive negaFibonacci numbers, that is the sequence\n\n0, 1, -1, 2, -3, 5, -8, ...\n\nor F_(-n) = (-1)^(n+1) F_n. Some examples:\n\n```\n-4 = - 3 - 1```\n\n\n```\n4 = 5 + 1```\n\n\n```\n11 = 13 - 3 + 1```\n\n\nIs there a known easy algorithm for decomposing a given integer in this way?\n    ", "Answer": "\r\nThere is a nice greedy algorithm you can use to represent numbers in negafibonacci. \n\nThe idea behind this algorithm is to split the integers into ranges delimited by pairs of even Fibonacci numbers (in the positive case) and odd Fibonacci numbers (in the negative case). Specifically, we'll split the positive numbers into the ranges\n\n\nF0 + 1 to F2, inclusive,\nF2 + 1 to F4, inclusive,\nF4 + 1 to F6, inclusive,\nF6 + 1 to F8, inclusive,\nF8 + 1 to F10, inclusive,\n...\nF2k + 1 to F2k+2, inclusive,\n...\n\n\nWe'll similarly split the n numbers into these ranges demarcated by negative Fibonacci numbers:\n\n\n-F1 to -F3 + 1, inclusive,\n-F3 to -F5 + 1, inclusive,\n-F5 to -F7 + 1, inclusive,\n-F7 to -F9 + 1, inclusive,\n...\n-F2k-1 to -F2k+1 + 1, inclusive,\n...\n\n\nThe greedy algorithm then proceeds as follows:\n\n\nIf the number is positive, find the range [F2k + 1, F2k+2] containing n, add F2k+1 to the representation, and subtract F2k+1 from n.\nIf the number is negative, find the range [-F2k-1, -F2k+1 + 1] containing n, add -F2k to the representation, and add F2k to the total.\nIf the number is zero, you're done.\n\n\nLet's do an example. Suppose I want to convert 27 into negafibonacci. I find that 21 + 1 ≤ 27 ≤ 55. This sandwiches the (odd-index) Fibonacci number 34, so I add 34 to the total and then try to convert 27 - 34 = -7 into negafibonacci.\n\nNext, we notice that 5 + 1 ≤ 7 ≤ 13, so 7 is sandwiched in a range containing the (even-indexed) Fibonacci number 8. We therefore add -8 into the total and try to convert 1 to negafibonacci.\n\nNow, we notice that 0 + 1 ≤ 1 ≤ 1, so 1 is sandwiched in a range containing the (odd-indexed) Fibonacci number 1. We therefore add 1 into the total and try to convert 0 to negafibonacci.\n\nThis leaves a total of 0, so we're done! And hey! 34 - 8 + 1 = 27.\n\nLet's first argue correctness. First, notice that if we add in a positive Fibonacci number, it must be an odd-numbered Fibonacci number (since we pick something of the form F2k+1), and if we add in a negative Fibonacci number, it must be a negative even-numbered Fibonacci number (since we pick something of the form -F2k). So each number added in will have the proper sign.\n\nNext, we'll prove termination. Look at the positive case first. If we find that we have a number in the range [F2k + 1, F2k+2], then we subtract out F2k+1. The upper bound on the number is then F2k+2 - F2k+1 = F2k, so the largest interval containing the remainder will fall in the range [F2k-2 + 1, F2k] and the highest Fibonacci number we could pull out would be F2k-1. Therefore, we can't repeat the Fibonacci number we previously removed, and there will be a gap between the positive numbers pulled out.\n\nThe lower bound on the number is F2k + 1 - F2k+1 = -F2k-1 + 1. That means that if the number is negative, the \"highest\" negative interval containing it would be [F2k-1 + 1, F2k-3], so the highest negative Fibonacci number we could pull out is F2k-2. Therefore, we will pull out a lower-order Fibonacci number.\n\nWe can do similar math to show that pulling out a negative Fibonacci number shifts our window down one step.\n\nTo implement this efficiently, we can keep track of three consecutive Fibonacci numbers (Fk-1, Fk, Fk+1) and keep shifting it upward (or downward) until we find a range containing the number n. We can then pull out our (possibly negative) Fibonacci number and then shift the window back toward 0 until we're done. Overall, this will run in time O(log n).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm minimum search in C++?\r\n                \r\nI have a C++ assignment which I've been working on in the last 2 weeks. My knowledge is very limited, as I just started learning C++ and algorithms in February.\n\nThe assignment is:\nN number of guests were invited to a party. We know all guests arrival and leave time. We want to know which guest met the LEAST amount of other guests. Two guests meet when guest1_arrivaltime <= guest2_leavetime and guest2_arrivaltime <= guest1_leavetime. If there are multiple guests who met the same amount of other guests, only one needs to be printed out.\n\nUse: standard input (cin, cout) and greedy algorithm.\n\nN (number of guests) can range from 1 to 1 000 000, the arrival and leave time values can be between 1 and 100 000\n\nRun time limitation: 0.1 second\n\nMemory limitation: 32 MB\n\nI have a working code which seems to be okay to me, but when I upload it to the school's server I only get 27 marks out of 100. I need 50 marks to pass.\n\n```\n#include <iostream>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct guestData\n{\n    int guestIndex;\n    int time;\n\n    guestData(int guestIndex, int time)\n    {\n        this->guestIndex = guestIndex;\n        this->time = time;\n    }\n\n    guestData()\n    {\n        guestIndex = 0;\n        time = 0;\n    }\n};\n\nint n;\nguestData * arrive;\nguestData * leave;\nset<int> guestsIn;\nset<int> * metSet;\nint minGuests;\nint minIndex = 1;\n\nbool operator<(const guestData & l, const guestData & r)\n{\n    return l.time < r.time;\n}\n\nvoid read(int n)\n{\n    arrive = new guestData[n];\n    leave = new guestData[n];\n    metSet = new set<int>[n];\n    minGuests = n;\n    for (int i = 0; i < n; ++i){\n        int arriveTime;\n        int leaveTime;\n        cin >> arriveTime >> leaveTime;\n        arrive[i] = guestData(i, arriveTime);\n        leave[i] = guestData(i, leaveTime);\n\n    }\n}\n\nvoid process()\n{\n   sort(arrive, arrive+n);\n   sort(leave, leave+n);\n\n   int i = 0, j = 0;\n\n   while (i < n && j < n)\n   {\n      if (arrive[i].time <= leave[j].time)\n      {\n            int currentTime = arrive[i].time;\n            int in = arrive[i].guestIndex;\n            for (auto it = guestsIn.begin(); it != guestsIn.end(); ++it)\n            {\n                metSet[in].insert(*it);\n                metSet[*it].insert(in);\n            }\n            guestsIn.insert(in);\n          i++;\n      }\n      else\n      {\n          int currentTime = leave[j].time;\n            int out = leave[j].guestIndex;\n           guestsIn.erase(out);\n          j++;\n      }\n   }\n}\n\nvoid findMin(){\n    for (int i = 0; i < n; ++i)\n    {\n        if (metSet[i].size() < minGuests)\n        {\n            minGuests = metSet[i].size();\n            minIndex = i+1;\n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    read(n);\n    process();\n    findMin();\n    cout << minIndex << \" \" << minGuests;\n    return 0;\n}\n```\n\n\nThe problem: it works great on the example input, which is:\n\n8\n\n1 3\n\n4 8\n\n9 12\n\n2 5\n\n3 9\n\n7 10\n\n2 3\n\n1 3\n\nwhere 8 is the n (number of guests) and then 8 x the arrival(left row) and leave time(right row) for the guests.\n\nThe output for this example input is: 3 2 which is correct, because the 3rd guests met the least amount of other guests (2)\n\nHowever, I get this error on my school's website when I upload my code: ERROR CODE 11 ILLEGAL MEMORY REFERENCE\n    ", "Answer": "\r\nYou should free the memory at the end of the program. The grading system probably detects you are not doing that.\n\n```\ndelete[] arrive;\ndelete[] leave;\ndelete[] metSet;\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why is greedy algorithm not finding maximum independent set of a bipartite graph?\r\n                \r\nI was trying to solve the maximum independent set problem on bipartite graphs using the greedy method. So came across this post which does exactly what i was trying to do. But am concentrating only on the bipartite graphs. The counter case in the answer is not a bipartite graph. Are there any bipartite graphs that this one wont work?\n\n```\nGreedy(G):\n S = {}\n While G is not empty:\n Let v be a node with minimum degree in G\n S = union(S, {v})\n remove v and its neighbors from G\nreturn S\n```\n\n\nWhy is greedy algorithm not finding maximum independent set of a graph?\n    ", "Answer": "\r\nThe same approach as in the original question answer applies here as well, with a slightly modified graph:\n\n\n\nStart by removing #5, What's left is a paw graph (nodes (1,3,4,7)). Remove its leaves in any order. You discover a four-node independent set: (1,3,5,7)\n\nStart by removing #6. What's left is a 4-cycle. Removing any node forces either of these sets:\n\n\n(1,3,6)\n(2,4,6)\n\n\nboth are three-element maximal (as in, cannot be expanded) independent sets, and thus not maximum (as in, the largest possible).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "TSP greedy algorithm implementation to certain graph example\r\n                \r\nI am trying to figure out an greedy algorithm for this kind of graph structure?. How should i approach?\n\n1.Start from random node\n\n2.Find nearest route to neighbor that has not been visited (Ei vierailtu=not visited)\n\n3.Make neighbor active\n\n4.Mark active node as visited (vierailtu=visited)\n\n5.Save visited node to path\n\n6.If all visited ->end\n\n7.If not go to 2.\n\nThis is the algorithm i am trying to implement here but i am kind of lost. Any help would be appriciated..\n\n```\nclass MainClass\n{\n    const int ALUSTAMATON_KAARI = 0;\n    const int EI_KAARTA = -1;\n    const int EI_KAARTA_ITSEEN = -2;\n\n    const int VIERAILTU_SOLMU = -3;\n    const int TUTKITTU_KAARI = -3;\n    const int PALUUKAARI = -4;\n\n\n\n    static int maxNodes = 11;\n\n\n    public class Graph\n    {\n\n        private int[,]data;\n        public int[,] Data\n        {\n            get\n            {\n                return data;\n            }\n            set\n            {\n                data = value;\n            }\n        }\n\n\n        private int noNodes;\n        public int NoNodes\n        {\n            get\n            {\n                return noNodes;\n            }\n            set\n            {\n                noNodes = value;\n            }\n        }\n\n\n        public Graph()\n        {\n            data = new int[maxNodes,maxNodes];\n\n            for (int i = 0; i < maxNodes; i++)\n                for (int j = 0; j < maxNodes; j++)\n                    if (i == j)\n                        data[i,j] = EI_KAARTA_ITSEEN;\n                    else\n                        data[i,j] = EI_KAARTA;\n\n\n            noNodes = 1;\n        }\n    }\n\n\n\n    public static bool ADD_VERTEX(int v, Graph G)\n    {\n        if (G.NoNodes < maxNodes)\n        {\n            G.Data[G.NoNodes,0] = v;\n            G.Data[0,G.NoNodes] = v;\n            G.NoNodes++;\n            return true;\n        }\n        else return false;\n    }\n\n    public static bool SET_VERTEX_VALUE(int v, int x, Graph G)\n    {\n        int i = 0;\n        while (G.Data[i,0] != v && i < G.NoNodes)\n            i++;\n\n        if (i < G.NoNodes)\n        {\n            G.Data[i, 0] = x;\n            G.Data[0, i] = x;\n            return true;\n        }\n        else return false;\n    }\n\n    public static bool SET_EDGE_VALUE(int v1, int v2, int x, Graph G)\n    {\n        int i = 0;\n        while (G.Data[i,0] != v1 && i < G.NoNodes)\n            i++;\n\n        int j = 0;\n        if (i < G.NoNodes)\n        {\n            while (G.Data[j,0] != v2 && j < G.NoNodes)\n                j++;\n        }\n\n        if (i < G.NoNodes && j < G.NoNodes)\n        {\n            if (G.Data[i, j] != EI_KAARTA && G.Data[j, i] != EI_KAARTA)\n            {\n                G.Data[i, j] = x;\n                G.Data[j, i] = x;\n                return true;\n            }\n            else return false;\n        }\n        else return false;\n    }\n\n    public static int GET_EDGE_VALUE(int v1, int v2, Graph G)\n    {\n        int i = 0;\n        while (G.Data[i,0] != v1 && i < G.NoNodes)\n            i++;\n\n        int j = 0;\n        if (i < G.NoNodes)\n        {\n            while (G.Data[j,0] != v2 && j < G.NoNodes)\n                j++;\n        }\n\n        if (i < G.NoNodes && j < G.NoNodes)\n        {\n            if (G.Data[i, j] != EI_KAARTA && G.Data[j, i] != EI_KAARTA)\n            {\n                return G.Data[i, j];\n            }\n            else return -1;\n        }\n        else return -1;\n    }\n\n    public static bool ADD_EDGE(int v1, int v2, Graph G)\n    {\n        int i = 0;\n        while (G.Data[i,0] != v1 && i < G.NoNodes)\n            i++;\n\n        int j = 0;\n        if (i < G.NoNodes)\n        {\n            while (G.Data[j,0] != v2 && j < G.NoNodes)\n                j++;\n        }\n\n        if (i < G.NoNodes && j < G.NoNodes)\n        {\n            G.Data[i,j] = ALUSTAMATON_KAARI;\n            G.Data[j,i] = ALUSTAMATON_KAARI;\n            return true;\n        }\n        else\n            return false;\n    }\n\n    public static int[] NEIGHBORS(int v, Graph G)\n    {\n        int i = 0;\n        int [] neighbors; \n        neighbors = new int[maxNodes];\n        neighbors[0] = -2;\n\n        while (G.Data[i,0] != v && i < G.NoNodes)\n            i++;\n\n        if (i < G.NoNodes)\n        {\n            for (int j = 1; j < maxNodes; j++)\n                if(G.Data[i,j] >= 0)\n                    neighbors[j] = 0;\n                else\n                neighbors[j] = EI_KAARTA;\n        }\n        return neighbors;\n    }\n\n\n    public static void PRINT_GRAPH(Graph G)\n    {\n        for (int i = 0; i < maxNodes; i++)\n        {\n            for (int j = 0; j < maxNodes; j++)\n                Console.Write (G.Data[i,j] + \" \");\n            Console.WriteLine();\n        }\n        Console.WriteLine();\n    }\n\n\n    public static void MarkVisited(int v, Graph G)\n    {\n        int i = 0;\n        while (G.Data[i,0] != v && i < G.NoNodes)\n            i++;\n\n        if (i < G.NoNodes)\n        {\n            G.Data[i,i] = VIERAILTU_SOLMU;\n        }\n    }\n\n\n    public static bool isVisited(int v, Graph G)\n    {\n        int i = 0;\n        while (G.Data[i,0] != v && i < G.NoNodes)\n            i++;\n\n        if (i < G.NoNodes)\n        {\n            if (G.Data[i,i] == VIERAILTU_SOLMU)\n                return true;\n            else\n                return false;\n        }\n\n        return false;\n    }\n\n\n    public static void INIT_DFS_PRINT(int v, Graph G)\n    {\n        Graph tmpG = new Graph();\n\n        Array.Copy(G.Data, tmpG.Data, G.Data.Length);\n\n        tmpG.NoNodes = G.NoNodes;\n\n        DFS_PRINT(v, tmpG);\n\n    }\n\n\n    public static void DFS_PRINT(int v, Graph G)\n    {\n        int w;\n\n\n        MarkVisited(v, G);\n        Console.WriteLine(\"Vierailtu solmu: \" + v);\n\n\n        int[] tmp = new int[maxNodes];\n        tmp = NEIGHBORS(v, G);\n\n        for (int i = 0; i < maxNodes; i++)\n        {\n            //Console.WriteLine(tmp[i]);\n\n            if (tmp[i] == 0)\n            {\n\n                int tmpValue = GET_EDGE_VALUE(v, G.Data[i, 0], G);\n\n                if ( tmpValue >= 0 )\n                {\n\n                    w = G.Data[i, 0];\n\n                    if (!isVisited(w, G))\n                    {\n\n                        SET_EDGE_VALUE(v, G.Data[i, 0], TUTKITTU_KAARI, G);\n\n\n                        DFS_PRINT(w, G);\n                    }\n                    else\n\n                        SET_EDGE_VALUE(v, G.Data[i, 0], PALUUKAARI, G);\n                }\n            }\n        }\n    }\n\n    // Pääohjelma verkko-tietotyypin toteutuksen testaamista varten.\n    public static void Main (string[] args)\n    {\n\n        Graph G = new Graph();\n\n        PRINT_GRAPH(G);\n\n        /\n        ADD_VERTEX(5, G);\n        ADD_VERTEX(9, G);\n        ADD_VERTEX(12, G);\n        ADD_VERTEX(3, G);\n\n\n        ADD_EDGE(5, 9, G);\n        ADD_EDGE(5, 3, G);\n        ADD_EDGE(9, 12, G);\n\n        PRINT_GRAPH(G);\n\n\n        SET_VERTEX_VALUE(9, 11, G);\n        SET_EDGE_VALUE(5,  3, 55, G);\n\n        PRINT_GRAPH(G);\n\n\n        int[] tmp = new int[maxNodes];\n        tmp = NEIGHBORS(5, G);\n\n        for (int i = 0; i < maxNodes; i++)\n            Console.Write(tmp[i] + \" \");\n        Console.WriteLine();\n        Console.WriteLine();\n\n\n        INIT_DFS_PRINT(5, G);\n\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "PseudoCode for a Activity Selection Problem based on Greedy Algorithm\r\n                \r\n\nSuppose that instead of always selecting the first activity to finish, we select the last activity\nto start that is compatible with all previously selected activities. Describe how this\napproach is a greedy algorithm and prove (see theorem 16.1) that it yields an optimal\nsolution.\nWrite pseudocode (both recursive as well as iterative) to solve the activity selection\nproblem using the above-mentioned greedy approach.\n\nThis is a practice problem. However, I am unable to do it.\nI tried solving it by modifying the original code but unable to do so.\nOriginal code based on first activity to finish\nRecursive\n\niterative\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for fitting subintervals on a wire\r\n                \r\nIm currently playing around with some greedy algorithms.\nI have this problem description:\n```\nThere is a long electrical wire of length ℓ\ncentimetres between two poles where birds like to sit. After a long day at work you like to watch \nthe birds on the wire from your balcony. \nSome time ago you noticed that they don’t like to sit closer than d centimetres from each other. In \naddition, they cannot sit closer than 6 centimetres to any of the poles, since there are spikes\nattached to the pole to keep it clean from faeces that would otherwise damage and weaken it. \nYou start wondering how many more birds can possibly sit on the wire\n\nGiven numbers ℓ and d, how many additional birds can sit on the wire given the positions of the  \nbirds already on the wire? For the purposes of this problem we assume that the birds have zero width.\n\nThe first line contains three space separated integers: the length of the wire ℓ, distance d and \nnumber of birds n already sitting on the wire. \nThe next n lines contain the positions of the birds in any order. \nAll number are integers, 1≤ℓ,d≤1000000000 and 0≤n≤20000. \n(If you have objections to the physical plausibility of fitting that many birds on a line hanging \nbetween two poles, you may either imagine that the height of the line is 0 cm above ground level, or \nthat the birds are ants instead.) \nYou can assume that the birds already sitting on the wire are at least 6 cm from the poles and at least d centimetres apart from each other.\n```\n\nAnd I must output a Integer, which is the max amount of additional birds that there is room for on the wire.\nsample input and output\nin         out\n22 2 2     3\n11\n9\nand\nin         out\n47 5 0     8\nattempt\nMy initial thought was that do some calculation on how much free space was on the wire. In the case of my first sample input here The array would look something like this:\n\n(here red squares are places on the wire too close to the poles, and blue ones are already occupied)\nNow i would just iterate over this array, and as soon as i hit a \"free\" item, then place a new bird there, and mark its d-1 neighbors as occupied if they are not already.\nI will now go through a hand execution of this idea, where I will iterate with i through the list, and colour the newly occupied places yellow:\n\nNext we land at i = 15, and hit another empty spot\n\nThis however gives me a different result than my testcases, I must be doing something wrong?\nAlso I would very much like some comments on the general methodology, is there any way I could be doing this smarter?\nI iterate on and next time I hit a empty spot:\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm Giving Dubious Results\r\n                \r\nI am implementing a simple greedy algorithm:\n\nAim: To pay-back the user's change using as few coins as possible out of the following coin types; Quarter (0.25), Dime (0.10), Nickel (0.05) & Penny (0.01).\n\nInput: The amount of change the user is owed.\n\nOutput: The total number of coins used in paying-back the user.\n\nA snippet of my code can be seen below:\n\n```\nfinal double quarter = 0.25d;\nfinal double dime = 0.10d;\nfinal double nickel = 0.05d;\nfinal double penny = 0.01d;\ndouble changeOwed;\nint coinsUsed = 0;\n\n/*\nCode to get the user's input\n*/\n\n    while (changeOwed > 0 && changeOwed % quarter != changeOwed) {\n        coinsUsed++;\n        changeOwed -= quarter;\n    }\n\n    while (changeOwed > 0 && changeOwed % dime != changeOwed) {\n        coinsUsed++;\n        changeOwed -= dime;\n    }\n\n    while (changeOwed > 0 && changeOwed % nickel != changeOwed) {\n        coinsUsed++;\n        changeOwed -= nickel;\n    }\n\n    while (changeOwed > 0 && changeOwed % penny != changeOwed) {\n        coinsUsed++;\n        changeOwed -= penny;\n    }\n\n    System.out.println(\"Change remaining: \"+ changeOwed);\n    System.out.println(\"Total coins used: \"+coinsUsed);\n```\n\n\n\n\nResults:\n\n```\nEnter change owed: 32\nChange remaining: 0.0\nTotal coins used: 128\n```\n\n\n\n\n```\nEnter change owed: 3.25\nChange remaining: 0.0\nTotal coins used: 13\n```\n\n\n\n\n```\nEnter change owed: 0.32\nChange remaining: 3.469446951953614E-18\nTotal coins used: 4\n```\n\n\n\n\nI decided to do this using while loops, and the modulo operator. If ```\nchangeOwed```\n were equal to 0, then there would be no need to execute the while loop, because all of the change would've been paid-back. To add to this, if ```\nchangeOwed % COINTYPE```\n (\"COINTYPE\" being an arbitrary placeholder) were equal to changeOwed, this would indicate that COINTYPE is greater than ```\nchangeOwed```\n (the amount of remaining change). In such an event, the program proceeds to he next while-loop sporting a smaller COINTYPE. \n\nAs can be seen above, the algorithm seems to produce the correct output as regards the amount of coins used. However, as in the last example, the amount of change remaining seems to be way off. I understand that computers cannot do perfect arithmetic due to a finite number of bits. However, why is it that the amount of change remaining has increased drastically from 0.32 to 3+? \n    ", "Answer": "\r\nIt's not 3. Its 3E-18 which is a very small number (0. 18-zeros 3).\n\nThis is probably caused by using ```\ndoubles```\n. It's a floating point error.\n\nIf you want to avoid this use ```\nBigDecimal```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Multi-way KK differencing algorithm vs. Greedy algorithm?\r\n                \r\nIt's proven that, the Karmarkar-Karp's differencing algorithm always performs better than greedy for 2-way partitioning problems, i.e. partitioning set of n integers to 2 subsets with equal sums. Can this be extended to k-way partitioning as well? If not, is there any example where greedy performs better than KK in k-way partitioning?\n    ", "Answer": "\r\nKK's superiority cannot be generalized for the k-way partitioning. In fact, it's easier to give a counter-example where the Greedy algorithm is performing better. \nLet the performance measure be the maximum subset sum of the final partition.\nNow, take this set of integers:\n\nS = [10 7 5 5 6 4 10 11 12 9 10 4 3 4 5] and k=4 (partitioning into 4 equal subsets)\n\nFast forward, KK algorithm gives the result of [28, 26, 26, 26] whereas the greedy gives the final partition of [27, 27, 27, 24]. Since 28 > 27, greedy performed better for this example.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Present a greedy algorithm to find a longest cycle in an unweighted graph\r\n                \r\nI could only think of a trivial solution to find all cycles in the graph and then find the number of edges in each cycle and then return the one with maximum edges.\n\nHow do I find a longest cycle using a greedy algorithm?\n    ", "Answer": "\r\n\"The longest simple cycle problem is the problem of\nfinding a cycle of maximum length in a graph. As a\ngeneralization of the Hamiltonian cycle problem, it is NPcomplete on general graphs and, in fact, on every class of graphs\nthat the Hamiltonian cycle problem is NP-complete. The longest\nsimple cycle problem may be solved in polynomial time on\nthe complements of comparability graphs. It may also be solved\nin polynomial time on any class of graphs with bounded tree\nwidth or bounded clique-width, such as the distance-hereditary\ngraphs. However, it is NP-hard even when restricted to split\ngraphs, circle graphs, or planar graphs. In this paper a heuristic\nalgorithm is proposed which can solve the problem in polynomial\ntime. To solve the longest simple cycle problem using adjacency\nmatrix and adjacency list by making a tree of given problem to\nfind the longest simple cycle as the deepest path in tree following\nreconnect the leaf node of deepest path with root node. The result\nresolves the open question for the complexity of the problem on\nsimple unweighted graphs. The algorithm is implemented on a\nsimple labeled graph without parallel edges and without selfloop. The worst case time complexity for the proposed algorithm\nis O(V+E).\n\nThe Longest Simple Cycle Algorithm\nIn the Proposed Algorithm, the input graph considered to be a\nsimple graph (i.e. without self-loop and without parallel\nedges), the algorithm for Longest Simple Cycle in simple\ngraph is summarized below:\n\n\nEnumerate all the nodes to calculate degree of each node to\nfind the node with highest degree.\nAssign the node with highest degree as the root for tree.\nConstruct a tree T of the given graph G considering the\nadjacent nodes as successor and predecessors accordingly\nfor each vertex using adjacency matrix.\nDo apply the proposed LSC algorithm to find the longest\npath.\nJoin the leaf node of the longest path with root and retrieve\nthe path considering it as the longest cycle in graph.\"\n\n\nA Heuristic Algorithm for Longest Simple Cycle Problem\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm to pair numbers that minimizes the maximum sum\r\n                \r\nThe input is a sequence of real numbers x1, x2, ..., x2n. We want to pair these numbers into n pairs. For the ith pair, (i = 1, 2, ..., n), let Si denote the sum of numbers in that pair. (For example if you pair x(2i−1) and x2i as the ith pair, Si = x(2i−1) + x2i). We want to pair these numbers so that Maxi[Si] is minimized. Design a greedy algorithm to solve this\nproblem.\n\n\n\nThat's the question; my solution is to simply sort the numbers and pair the first-last elements and add-one/subtract-one index and repeat. The algorithm tries to optimize for each pair, so that makes it greedy. I'm just wondering if there's a linear time algorithm that will do this?\n\nPS: This is not homework, but I understand this looks very much like it.\n    ", "Answer": "\r\nNo. There can't be a linear time algo to get this done for you. The input numbers can be in any order so you cant get the pairing done right away with min Maxi[Si]. Your current solution is simple and good.\n\nSuggestions to improve on the running time:\n\nYou can create a Binary tree out of the input numbers (this takes O(nlog(n)) time). Do inorder traversal of the tree and create pairs from the (first+i, last-i) elements (i from 0 to n/2)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy knapsack algorithm\r\n                \r\nThe task is classic knapsack problem. Greedy algorithm should be used in solvation. I managed to create code below, but it works too slow. Could you give me an idea how to speed it up? Thank you.\n\n```\ndef backpack(c, array):\n    array.sort(key=lambda x: x[1])\n    array.sort(key=lambda x: x[0], reverse=True)\n    backpack = []\n\n    for item in array:\n        if item[1] <= c:\n            backpack.append(item)\n            c -= item[1]\n\n    result = []\n    for item in backpack:\n        result.append(item[2])\n    result.sort()\n\n    return print(*result)\n\n\nc = int(input())\nn = int(input())\narray = list()\nfor i in range(n):\n    item = [int(x) for x in input().split()]\n    array.append(item)\n    array[i].append(i)\n\nbackpack(c, array)\n```\n\n\nc is weight limit for backpack. n represents the amount of price-weight pairs (both numbers have int type, not float). Restrictions are following: 1) should you choose between elements with the same weight, the one with the highest price should be taken 2) should you choose between elements with the same price and same weight, the one which was inputed first should be taken.\n    ", "Answer": "\r\nWe can use:\n\n```\ndef backpack(weight, arr):\n    # Associate the index with each pair of the given array.\n    arr = [(idx, pair) for idx, pair in enumerate(arr)]\n\n    # sort the arr in descending order with highest price taking precedence\n    arr = sorted(arr, reverse=True, key=lambda x: x[1][0]) \n\n    result, totalWeight = [], 0\n    for item in arr:\n        if item[1][1] + totalWeight <= weight:\n            totalWeight += item[1][1] # increase the cummalative weight of backpack\n\n            result.append(item[0]) # Append the index of added pair to result\n    return result\n```\n\n\n\n\nExample:\n\n```\n# arr contains the pairs of <price, weight>\narr = [[1, 2], [2, 3], [1, 1], [2, 4], [2, 3], [5, 1], [1, 5], [3, 3], [2, 2]]\nweight = 7\nprint(backpack(weight, arr))\n```\n\n\nResult:\n\n```\n[5, 7, 1] # indices of pairs in arr which are taken from array and added to backpack\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Does `tree_method = 'exact'` in `xgboost` really mean exact greedy algorithm?\r\n                \r\nDoes ```\ntree_method = 'exact'```\n in ```\nxgboost```\n really mean using the exact greedy algorithm for split finding? \n\nI'm asking this question because ```\nxgboost```\n runs unreasonably fast. Here is the script that I used for running test\n\n```\nfrom xgboost import XGBRegressor as rr\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nimport pickle \nimport sys\nfrom time import time\n\nt1 = time()\ndata = sys.argv[1]\nwith open(data, 'rb') as source:\n    data = pickle.load(source)\nnp.random.shuffle(data)\nx = [item[0] for item in data]\ny = [item[1] for item in data]\nx_train, x_val, y_train, y_val = train_test_split(x, y, test_size = 0.2, random_state = 100)\neval_set = [(x_train, y_train), (x_val, y_val)]\n\n# Exact model\nmodel_exact = rr(max_depth = 5, \n                 n_estimators = 1,\n                 slient = False, \n                 min_child_weight = 0, \n                 tree_method = 'exact')\nmodel_exact.fit(x_train, \n                y_train, \n                eval_set=eval_set,\n                eval_metric=\"mae\",\n                early_stopping_rounds=30)\nt2 = time()\nprint(f\"Time used: {t2 - t1}\")\n```\n\n\nThe pickled data used for testing has been uploaded here.\n\nThere are ```\n96```\n features in each instance, and there are in total ```\n11450```\n instances. \n\n```\nxgboost```\n finds the first split in ```\n0.9804270267486572s```\n by running on a single core (```\n1.3 GHz Intel Core i5```\n). If ```\nxgboost```\n actually performs a greedy search of all the possible splits, it means ```\nxgboost```\n evaluates ```\n11450 x 96 = 1099200```\n splits in just ```\n0.9804270267486572s```\n!\n\nIs ```\nxgboost```\n really such powerful? Or, do I misunderstand ```\ntree_method = exact```\n? \n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm\r\n                \r\nI am writing a piece of code, when a user enters the amount of change owed, returns the minimum amount of coins to equal that change. For instance, assuming only quarters, dimes, nickels and pennies are used. You enter $1.00. The number my code will render on the screen is 4 (4 quarters equaling a dollar). However, I am experiencing a small bug. If you type in $0.41 for example, you'd expect the code to render 4 again (1 quarter + 1 dime + 1 nickel + 1 penny is the minimum amount of permutations to equal 41 cents), but it doesn't, it renders 5.44. Please help! Thank you in advance.\n\n\r\n\r\n```\ndocument.write(\"Hi,how much change is due? \");\r\n\r\nfunction greed () {\r\n\t\r\n\tvar n = document.getElementById('change').value;\r\n\t\r\n\tif (n >=0)\r\n\t{ \r\n\t\t\r\n\t\r\n\t\tfunction amount (amt){\r\n\t\t\t\r\n\t\t\t\treturn amt/25 + (amt%25)/10 + ((amt%25)%10)/5 + ((amt%25)%10)%5;\r\n\t\t\t\t\r\n\t\t\t }\r\n\t\tdocument.write(amount(Math.round(n*100)));\r\n\t}\r\n\telse {alert(\"Invalid Amount!\")};\r\n}```\n\r\n```\n<!DOCTYPE html>\r\n\r\n<html lang=\"en-US\">\r\n\r\n\t<head>\r\n\r\n\t\t<title>Greedy! </title>\r\n\t\t<script type=\"text/javascript\" src=\"greedy.js\" ></script>\r\n\t</head>\r\n\r\n\t<body>\r\n\t\t<form>\r\n\t\t\t<fieldset>\r\n\t\t\t\t<input type=\"number\" id=\"change\" name=\"change\" value=\"0\"/>\r\n\t\t\t\t<input type=\"submit\" id=\"submit\" name=\"submit\" value=\"submit\" onclick=\"greed();\"/>\r\n\t\t\r\n\t\t\t</fieldset>\r\n\t\t</form>\r\n\t</body>\r\n\r\n</html>```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nThe main problem here is that you're not treating the numbers as integers, so you get decimal numbers everywhere. Let's use your example (0.41):\n\n```\namt = n*100 = 41```\n, so let's go to the return:\n\n```\nreturn amt/25 + (amt%25)/10 + ((amt%25)%10)/5 + ((amt%25)%10)%5\n```\n\n\nwhich is the same as\n\n```\nreturn 41/25 + (41%25)/10 + ((41%25)%10)/5 + ((41%25)%10)%5\n```\n\n\nas you know, ```\n41/25 =/= 1```\n, same with ```\n(41%25)/10 = 16/10 =/= 1```\n and ```\n((41%25)%10)/5 = (16%10)/5 = 6/5 =/= 1```\n, but you don't care about that in the code so you end up adding those decimal numbers till the end, and get weird values.\n\nYou must use ```\nparseInt()```\n to get Integer values, so it should look like this:\n\n```\nreturn parseInt(amt/25) + parseInt((amt%25)/10) + parseInt(((amt%25)%10)/5) + ((amt%25)%10)%5\n```\n\n\nTo show it works:\n\n\r\n\r\n```\ndocument.write(\"Hi,how much change is due? \");\r\n\r\nfunction greed () {\r\n\t\r\n\tvar n = document.getElementById('change').value;\r\n\t\r\n\tif (n >=0)\r\n\t{ \r\n\t\t\r\n\t\r\n\t\tfunction amount (amt){\r\n\t\t\t\r\n\t\t\t\treturn parseInt(amt/25) + parseInt((amt%25)/10) + parseInt(((amt%25)%10)/5) + ((amt%25)%10)%5;\r\n\t\t\t\t\r\n\t\t\t }\r\n\t\tdocument.write(amount(Math.round(n*100)));\r\n\t}\r\n\telse {alert(\"Invalid Amount!\")};\r\n}```\n\r\n```\n<!DOCTYPE html>\r\n\r\n<html lang=\"en-US\">\r\n\r\n\t<head>\r\n\r\n\t\t<title>Greedy! </title>\r\n\t\t<script type=\"text/javascript\" src=\"greedy.js\" ></script>\r\n\t</head>\r\n\r\n\t<body>\r\n\t\t<form>\r\n\t\t\t<fieldset>\r\n\t\t\t\t<input type=\"number\" id=\"change\" name=\"change\" value=\"0\"/>\r\n\t\t\t\t<input type=\"submit\" id=\"submit\" name=\"submit\" value=\"submit\" onclick=\"greed();\"/>\r\n\t\t\r\n\t\t\t</fieldset>\r\n\t\t</form>\r\n\t</body>\r\n\r\n</html>```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for largest value in dictionaries in Python\r\n                \r\nI've been working on the greedy algorithm in this problem set from OCW.\n\nSo far I have this:\n\n```\ndef greedyAdvisor(subjects, maxWork, comparator):\n    \"\"\"\n    Returns a dictionary mapping subject name to (value, work) which includes\n    subjects selected by the algorithm, such that the total work of subjects in\n    the dictionary is not greater than maxWork.  The subjects are chosen using\n    a greedy algorithm.  The subjects dictionary should not be mutated.\n\n    subjects: dictionary mapping subject name to (value, work)\n    maxWork: int >= 0\n    comparator: function taking two tuples and returning a bool\n    returns: dictionary mapping subject name to (value, work)\n    \"\"\"\n    greedySchedule = {}\n    currentWork = 0 \n    nameList = []\n    workValueList = []\n    for name, workValue in subjects.items():\n        nameList.append(name)\n        workValueList.append(workValue)\n    while currentWork <= maxWork:\n        for i in range(len(workValueList) - 2): \n            for j in range(i, len(workValueList) - 1): \n                if comparator(workValueList[i], workValueList[j]):\n                    bestKey = nameList[i]\n                    bestTuple = workValueList[i]\n                    currentWork += workValueList[i][WORK]\n                    jWasPicked = False\n                else:\n                    bestKey = nameList[j]\n                    bestTuple = workValueList[j]\n                    currentWork += workValueList[j][WORK]\n                    jWasPicked = True\n                if currentWork > maxWork:\n                    break\n                if jWasPicked:\n                    break\n            if currentWork > maxWork:\n                break\n            greedySchedule[bestKey] = bestTuple\n    return greedySchedule\n```\n\n\nThe comparators are:\n\n```\nVALUE = 0\nWORK = 1\n\ndef cmpValue(subInfo1, subInfo2):\n    \"\"\"\n    Returns True if value in (value, work) tuple subInfo1 is GREATER than\n    value in (value, work) tuple in subInfo2\n    \"\"\"\n    val1 = subInfo1[VALUE]\n    val2 = subInfo2[VALUE]\n    return  val1 > val2\n\ndef cmpWork(subInfo1, subInfo2):\n    \"\"\"\n    Returns True if work in (value, work) tuple subInfo1 is LESS than than work\n    in (value, work) tuple in subInfo2\n    \"\"\"\n    work1 = subInfo1[WORK]\n    work2 = subInfo2[WORK]\n    return  work1 < work2\n\ndef cmpRatio(subInfo1, subInfo2):\n    \"\"\"\n    Returns True if value/work in (value, work) tuple subInfo1 is \n    GREATER than value/work in (value, work) tuple in subInfo2\n    \"\"\"\n    val1 = subInfo1[VALUE]\n    val2 = subInfo2[VALUE]\n    work1 = subInfo1[WORK]\n    work2 = subInfo2[WORK]\n    return float(val1) / work1 > float(val2) / work2\n```\n\n\nWhenever I run this it only gives me the subjects in the order they come in on the list. The dictionary I'm using is:\n\n```\nsmall_catalog = {'6.00': (16, 8), '1.00': (7, 7), '6.01': (5, 3), '15.01': (9, 6)} \n```\n\n\nIt always returns ```\n{'1.00': (7,7), '15.01': (9, 6)}```\n when ```\nmaxWork```\n is ```\n15```\n\nI'm using a specific ```\nprintSubjects```\n function that returns subjects in order based on the numerical order of the names. For instance when I use it for the ```\nsmall_catalog```\n, it prints\n\n```\n{'1.00': (7, 7), '15.01': (9, 6), '6.00': (16, 8), '6.01': (5,3)}\n```\n\n\nObviously this is a little flawed because ```\n15.01```\n should be last but that isn't the point. The point is that it always prints in the order of this dictionary while limiting the workload to ```\nmaxWork```\n which is ```\n15```\n. \n    ", "Answer": "\r\nSince this is a homework assignment, we shouldn't just give away the answer.  So here are some hints:   \n\n\nLook at the sorted() to rank order \"best\" candidates in order.\nUse a \"key function\" or \"cmp function\" to pass in the metric of merit.\nLoop through the result list accumulating results until you hit \"max\".\n\n\nHere's a resource to get your started:\n\n\nhttps://docs.python.org/2.7/howto/sorting.html\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is Rod cutting Algorithm a Semi-Greedy Algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nIn My example 7 Inch Long Rod can be divided into 6 + 1 or in 2 + 2 + 3 manner.\nNow assume if my algorithm chooses First partition.\n\n```\n6 + 1\n```\n\n\ninstead of\n\n```\n2 + 2 + 3\n```\n\n\nShould i say it is a Semi-Greedy Approach, As i know Rod Cutting Problem is a Dynamic Programming Problem\n    ", "Answer": "\r\nThere is no such term like semi greedy algorithm, okay.\n It chooses first choice because it search for  more price and if it terminates, it doesn't go for another option, it is all because of ```\n<=```\n expression; which compares optimality of rod cutting combination, not because it is a semi greedy algorithm.\nI beleive it is now clear to you\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why is the greedy algorithm optimal?\r\n                \r\nCodility, lesson 14, task TieRopes (https://codility.com/demo/take-sample-test/tie_ropes). Stated briefly, the problem is to partition a list ```\nA```\n of positive integers into the maximum number of (contiguous) sublists having sum at least ```\nK```\n.\n\nI've only come up with a greedy solution because that's the name of the lesson. It passes all the tests but I don't know why it is an optimal solution (if it is optimal at all).\n\n```\nint solution(int K, vector<int> &A) {\n    int sum = 0, count = 0;\n    for (int a : A)\n    {\n        sum += a;\n        if (sum >= K)\n        {\n            ++count;\n            sum = 0;\n        }\n    }\n    return count;\n}\n```\n\n\nCan somebody tell me if and why this solution is optimal?\n    ", "Answer": "\r\nMaybe I'm being naive or making some mistake here, but I think that is not too hard (although not obvious) to see that the algorithm is indeed optimal.\n\nSuppose that you have an optimal partition of the list that with the maximum number of sublists. You may or may not have all of the elements of the list, but since adding an element to a valid list produces an also valid lists, lets suppose that any possible \"remaining\" element that was initially not assigned to any sublist was assigned arbitrarily to one of its adjacent sublists; so we have a proper optimal partition of the list, which we will call P1.\n\nNow lets think about the partition that the greedy algorithm would produce, say P2. There are two things that can happen for the first sublist in P2:\n\n\nIt can be the same as the first sublist in P1.\nIt can be shorter than the first sublist in P1.\n\n\nIn 1. you would repeat the reasoning starting in the next element after the first sublist. If every subsequent sublist produced by the algorithm is equal to that in P1, then P1 and P2 will be equal.\n\nIn 2. you would also repeat the reasoning, but now you have at least one \"extra\" item available. So, again, the next sublist may:\n\n2.1. Get as far as the next sublist in P1.\n2.2. End before the next sublist in P1.\n\nAnd repeat. So, in every case, you will have at least as many sublists as P1. Which means, that P2 is at least as good as any possible partition of the list, and, in particular, any optimal partition.\n\nIt's not a very formal demonstration, but I think it's valid. Please point out anything you think may be wrong.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm to finish a task with time constraint\r\n                \r\nThis is a question from my midterm today and I wonder how to solve this. All i know is to prove the greedy algorithm using induction.\n\nQuestion:\n\nYou are working on a programming project. There are n Java classes C1, C2, ..., Cn (the bossy architect says so). The architect also says that these classes have to be implemented in order (you are not allowed to implement C2 before you have completed C1 and so on).\n\nEach of the Java classes takes at most 8 hours to implement. You work exactly 8 hours a day, and you should not leave a Java class unfinished at the end of the day.\n\nTo complete the project as soon as possible, a strategy is to implement as many classes as you can everyday. Prove that this greedy strategy is indeed the optimal one. \n(Hint: let ti be the total number of classes completed in the first i days using the above strategy. The strategy always stays ahead if ti is no less than the total number of classes completed in the first i days using any other strategy)\n    ", "Answer": "\r\nThis problem is similar to the classic task scheduling case where the waiting time in the system must be minimized.\n\nLet C1, C2, ..., Cn your projected classes and c[1], c[2], ..., c[n] their required implementation time. Let's suppose you implement C1, C2, ... Cn in this order. Therefore, the total time (waiting + implementation) for each class Ck will be:\n\nc[1] + c[2] + ... + c[k]\n\nTherefore, we have the total time:\n\nT = n·c[1] + (n – 1)·c[2] + ... + 2*c*[n – 1] + c[n] = sum(k = 1 to n) of (n – k + 1)·c[k]\n\n(Sorry about the presentation — superscripts, subscripts, and math equations aren't supported...)\n\nLet's suppose the implementation times in our permutation are not sorted by ascending order. We can therefore find two integers a and b such that a < b with c[a] > c[b]. If we switch them in the computation of T, we have:\n\nT' = (n – a + 1)·c[b] + (n – b + 1)·c[a] + sum(k = 1 to n except a, b) of (n – k + 1)·c[k]\n\nWe finally compute T – T':\n\nT – T' = (n – a + 1)(c[a] – c[b]) + (n – b + 1)(c[b] – c[a]) = (b – a)(c[a] – c[b])\n\nFollowing our initial hypothesis (a < b and c[a] > c[b]), we have b – a > 0 and c[a] – c[b] > 0 as well, hence T – T' > 0.\n\nThis proves that we decrease the total waiting time by switching any pair of tasks so that the shorter one is done first.\n\nYour problem statement is the same, except that before starting implementing a new class, you have to check whether you should start it now (if there is enough time left on the present day) or tomorrow. But the principle proven here holds when it comes to minimizing the total \"waiting\" time.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Time complexity of greedy algorithm to find a maximal independent set of a graph\r\n                \r\nA simple greedy algorithm to find a maximal independent set, I think it will take O(n) time since no vertex will be visited more than twice. Why wiki said it would take O(m) time?\n```\nGreedy(G)\nwhile G is not empty (visited V in an arbitrary order)\n    mark v as IS and v's neighbors as Non-IS\nreturn all IS vertices\n```\n\n    ", "Answer": "\r\nIf you run it on Kn/2,n/2, the neighbors on the side not chosen each get marked as non-IS n/2 times.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is the name of this greedy algorithm to solve NP-Hard Vertex Cover\r\n                \r\nI found this pseudocode in a textbook but I do not properly understand it, and it was poorly explained.\n\n```\nAlgorithm 8: Greedy Vertex Cover Algorithm Example(G=(V,E))\n1) C := ;.\n2) while (E 6= ;)\n• Select a node v of maximal degree in G.\n• C := C [{v}.\n• Remove all edges e from E that are covered by v,\ni.e. for which e\\v 6= ; holds.\n3) Return C.\n```\n\n\nThe algorithm is a greedy algorithm to solve the Vertex Cover problem. Does anyone recognize it and know it's name? I would like to learn more about it.\n    ", "Answer": "\r\nI think you can find this particular algorithm on page 8 of this Vertex Cover Problem presentation provided by Gajanand Sharma.\nIt seems to be called Approx-Vertex-Cover also known as Vertex Cover Approximation Algorithm.\nIn the subsequent pages there is an example about the algorithm and how it works.\nAlso in Approximation Algorithms: Vertex Cover document at page 2 you can find another good explanation:\n\nAlgorithm 1: Approx-Vertex-Cover(G)\n1 ```\nC←∅```\n\n2 ```\nwhile E 6= ∅```\n\n```\n  pick any {u, v} ∈ E\n  C ← C ∪ {u, v}\n  delete all edges incident to either u or v \n```\n\n```\nreturn C```\n\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Coins Change with Greedy algorithm\r\n                \r\nHy guys, for some reason my greedy coins change program does not work. The function should return with the minimum amount of coins you can change a value and there is an array as well which includes the coins you can use for this. My program does not show anything an I dont know why.\n\n```\npublic class Main {\n\npublic static int coinChangeGreedy(int[] coins, int n) {\n\n        int result = 0;\n\n        while (n != 0)\n        {\n\n            for (int i=coins.length - 1 ; i>=0 ; i--)\n            {\n                if (coins[i] <= n)\n                {\n                    n = n - coins[i];\n                    result++;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args)\n    {\n        int[] coins = {1, 2, 5};\n        int n = 11;\n\n        coinChangeGreedy(coins, n);\n\n    }\n\n}\n```\n\n    ", "Answer": "\r\nWell, at first - you are not printing anything - you just run the function. \nSecond - you have a bit of a flaw in your code. You see - if you find a coin that works, you shouldn't go to the next coin, but see if that one \"fits\" again. \nIn your example with ```\nn=11```\n. You have 5 as the first one and then move to 2. But you should actually try the 5 again (prevent the ```\nfor```\n loop from going to the next element). See the example: \n\n```\npublic static int coinChangeGreedy(int[] coins, int n) {\n\n        int result = 0;\n\n        while (n != 0) {\n\n            for (int i=coins.length - 1 ; i>=0 ; i--) {\n                if (coins[i] <= n) {\n                    n = n - coins[i];\n                  System.out.println(\"Adding \" +coins[i]);\n                  i++; //neutralizing i-- with i++.\n\n                    result++;\n                }\n            }\n        }\n        return result;\n    }\n```\n\n\nNot you'll see that 5 is taken twice.  \nP.s. - if you are assuming that the coin array will be ascending.\nAnd to print it, you just go: \n\n```\nSystem.out.println(\"Total coins needed: \" +coinChangeGreedy(coins, n));\n```\n\n\nAdditionally - if you want to keep track of coins used, you can store them in an ```\nArrayList```\n every time it is chosen. list.add(coins[i])```\n. And of course you declare and initialize that```\nlist` at the beggining.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Makespan algorithm\r\n                \r\nI am needing to implement this greedy algorithm in python, but am having trouble understanding how to find the 'processor' for which M[j] is the least. Algorithm provided below...\n```\ngreedy_min_make_span(T, m):\n  # T is an array of n numbers, m >= 2\n  A = [Nil, ... , Nil] # Initialize the assignments to nil (array size n)\n  M = [ 0, 0, ...., 0] # initialize the current load of each processor to 0 (array size m)\n  for i = 1 to n\n    find processor j for which M[j] is the least.\n    A[i] = j\n    M[j] = M[j] + T[i]\n # Assignment achieves a makespan of max(M[1], .. M[m])\n return A\n\n\ndef greedy_makespan_min(times, m):\n    # times is a list of n jobs.\n    assert len(times) >= 1\n    assert all(elt >= 0 for elt in times)\n    assert m >= 2\n    n = len(times)\n    # please do not reorder the jobs in times or else tests will fail.\n    # Return a tuple of two things: \n    #    - Assignment list of n numbers from 0 to m-1\n    #    - The makespan of your assignment\n    A = n*[0]\n    M = m*[0]\n    \n    i = 1\n    for i in range(i, n):\n        j = M.index(min(M))\n        A[i] = j\n        M[j] = M[j] + times[i]\n    return (A, M)\n```\n\nFIXED: The error i'm getting right now is \"list assignment index out of range\" when I am trying to assign A[i] to j.\nUtility function:\n```\ndef compute_makespan(times, m, assign):\n    times_2 = m*[0]\n    \n    for i in range(len(times)):\n        proc = assign[i]\n        time = times[i]\n        times_2[proc] = times_2[proc] + time\n    return max(times_2)\n```\n\nTest cases that I have...\n```\ndef do_test(times, m, expected):\n    (a, makespan) = greedy_makespan_min(times,m )\n    print('\\t Assignment returned: ', a)\n    print('\\t Claimed makespan: ', makespan)\n    assert compute_makespan(times, m, a) == makespan, 'Assignment returned is not consistent with the reported makespan'\n    assert makespan == expected, f'Expected makespan should be {expected}, your core returned {makespan}'\n    print('Passed')\nprint('Test 1:')\ntimes = [2, 2, 2, 2, 2, 2, 2, 2, 3] \nm = 3\nexpected = 7\ndo_test(times, m, expected)\n\nprint('Test 2:')\ntimes = [1]*20 + [5]\nm = 5\nexpected =9\ndo_test(times, m, expected)\n```\n\nRight now I am failing the test cases. My assignment returned is not consistent with the reported makespan. My assignment returned is: [0, 0, 1, 2, 0, 1, 2, 0, 1] and my claimed makespan is: [6, 7, 4]. My compute makespan is returning 8 when it is expecting 7. Any ideas where I'm implementing this algorithm wrong?\n    ", "Answer": "\r\nChange ```\nA = n*[]```\n to ```\nA = n*[0]```\n.\nInstead of creating a list with length ```\nn```\n, ```\nA = n*[]```\n would create an empty list. Since you're assigning ```\nA[i] = j```\n in each iteration, the change would functionally make no difference to the output.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is Kadane's Algorithm Greedy or Optimised DP?\r\n                \r\nI feel like Kadane's algorithm is a modified version of the true dynamic programming solution of maximum subarray problem.Why do I feel so?\nI feel because the way to calculate the maximum subarray can be taken by:\n\n```\nfor(i=0;i<N;i++)\n    {\n        DP[i][A[i]]=true;\n        for(j= -ve maximum ;j<= +ve maximum ;j++)\n        if(DP[i-1][j])\n            DP[i][j+A[i]]=true;\n    }\n```\n\n\nThe recurrence being if it is possible to form j with a subarray ending at i-1 elements i can form j+A[i] using the i th element and also form A[i] alone by starting a subarray at i th position\nAnd at last we can search this DP array for maximum j that is marked true!\n\nNote : ```\nDP[i][j]```\n represents if it is possible to make j using a sub array ending at i! Here I assume j can be negative too.! Now one can easily derive that sum+ a negative number < sum . That implies adding any negative indices wont help getting a better sum thats why we can drop them! Morover we care about the maximum j till ```\ni-1```\n th position and connect it with ```\ni th```\n  element which makes me feel it is kind of making a greedy choice ( Just because maximum + element gives me a maximum).\n\nNOTE: I haven't studied Greedy algorithms by now but I have an idea what a greedy choice is!\n\nEDIT: SOmeone said my algorithm doesn't makes any sense so I am trying to post my code to make myself clear. I haven't taken j as -ve as they aren't fruitful.\nI repeat my state is defined as is it possible to make j using a subarray ending at i.\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\nint DP[101][101];\nint main()\n{\n    int i,j,ans=INT_MIN;\n    int A[]={3,-1,2,-1,5,-3};\n    int N=sizeof(A)/sizeof(int);\n    for(i=1;i<=N;i++)\n    {\n        if(A[i-1]>=0)\n            DP[i][A[i-1]]++;\n        for(j=0;j<=100;j++)\n        {\n            if(DP[i-1][j])\n            {\n                if(j+A[i-1]>=0)\n                    DP[i][j+A[i-1]]++;\n            }\n            if(DP[i][j])\n                ans=max(ans,j);\n        }\n    }\n    cout<<ans<<\"\\n\";\n    return 0;\n}\n```\n\n\nOutput 8\n    ", "Answer": "\r\nKadane's is an iterative dynamic programming algorithm.\nIt is very common to optimize iterative DP algorithms to remove one dimension of the DP matrix along the major axis of the algorithm's progression.\nThe usual 'longest common subsequence' algorithm, for example, is usually described with a 2D matrix, but if the algorithm progresses from left to right, then you really only need space for 2 columns.\nKadane's algorithm is a similar optimization applied to a 1D problem, so the whole DP array disappears.  The DP code in your question has a 2D matrix for some reason.  I don't know why -- it doesn't really make sense.\nThis site does a pretty good job of explaining the derivation: https://hackernoon.com/kadanes-algorithm-explained-50316f4fd8a6\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Creating the greedy algorithm using recursion\r\n                \r\nFor an assignement I have to write a Greedy Algorithm using a recursive function, but I can't seem to figure out how to do this.\nThe assignement is to make a route to go from one city to another, each time going to the city with the lowest distance between them, but no visit cities multiple times.\nFor now I have the following code, which is of course far from done as it doesnt even have any recursion and simply doesn't give the right result. I wouldn't be surprised if this code is not even slightly right. The result I get is [1,2,1,1], meaning the route would be from city 0 to 1, to 2, to 1, to 1. The answer should be [1, 2, 3].\nI've been trying this code for way too long now and I just can't seem to figure it out. I get the idea of what I have to do: take the index of the lowest distance, check if that index is already in list v, if it is, take the second lowest distance and check again. But I can't figure out how to put this into code and include recursion.\nIs anyone able to give me any tips to help me along or link me an example code?\nPS I am not allowed to use any import functions, this assignement is for a relatively simple (though not simple for me) programming course at my university\n```\nv = []\ndef append_list_with_nearest_unvisited(visited, distances):                  \n    city = 0\n    for n in range(len(distances)):\n        if city in v:\n            i = min(j for j in distances[n] if j > 0) #take lowest distance\n            h = min(k for k in distances[n] if k > i) #take second lowest distance because the true lowest distance is a visited city\n            city = distances[n].index(h) #city visited is the index of the lowest distance\n            v.append(city)\n        \n        else:\n            i = min(j for j in distances[n] if j > 0) #take lowest distance\n            city = distances[n].index(i)\n            v.append(city)\n    print(v)\n\nappend_list_with_nearest_unvisited(v, [[0,2,3,4],[2,0,4,5],[3,4,0,6],[4,5,6,0]])\n```\n\n    ", "Answer": "\r\nI think what you are asking is something like this\n```\nnodes = [0,1,2,3]\n\ndistanceMat = [\n    [0,2,3,4],\n    [2,0,4,5],\n    [3,4,0,6],\n    [4,5,6,0]\n    ]\n\nroute = []\ndistance = []\nstartNode_ = 0\ndestinationNode_ = 3\n\n\n\ndef findRoute(currentNode, destinationNode):\n    if currentNode not in route:\n        route.append(currentNode)\n    if currentNode == destinationNode:\n        return\n    else:\n        shortestDistance = min(j for j in distanceMat[currentNode] if j > 0)\n        nextNode = distanceMat[currentNode].index(shortestDistance)\n        while nextNode in route:\n            shortestDistance = min(k for k in distanceMat[currentNode] if k > shortestDistance)\n            nextNode = distanceMat[currentNode].index(shortestDistance)\n        route.append(nextNode)\n        distance.append(shortestDistance)\n        findRoute(nextNode, destinationNode)\n        \nfindRoute(startNode_, destinationNode_)\n\nprint('Route: ', route, '\\nDistance: ', distance)\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm on a number choice game\r\n                \r\nThe problem is given as follows:\n\nThere is a game with a sequence of n numbers(a1, a2, a3,..,an) and two players. Players take numbers from the sequence; on each turn the player can choose either the first or last number in the sequence.  When the sequence is emptied, the player with the larger total wins; if equal, the game is a draw.\n\nThe goal is to write an algorithm, that returns a sequence of choices to guarantee the best result (win or draw) for the first player, assuming that the second player will play optimally.\n\nI came up with a recursive formula, which can be translated to dynamic programming solution:\n\n\nFor the sequence Ai, Ai+1,..., Aj:\nIf there is one number in the sequence - take it. \nOtherwise, check both of possible choices, picking the one that gives the lower result for the second player through the end of the game.\n\n\nThus, the optimal sum for the first player is a sum of all numbers in the sequence minus this minimal sum that the second player will get. The formula looks as follows:\n\np(i,j) = Ai (if i=j)\n\np(i,j) = Ai + Ai+1 +...+ Aj - min{p(i+1,j), p(i,j-1)} (if j>i)\n\nWe use the same formula for computing the sum of the second player and the sum of the first player, because the second player also wants to get the maximum possible value.\n\nThe correctness can be easily proved inductively. Also, we can get the dynamic programming solution from it:  First calculate values of p(i,j) for each pair (i,j) and save it in the table nxn. The solution takes O(n^3). Also, there is a way to perform pre-processing of sum A1 + Ai+1 +Ai+2 +...+ Aj: we can compute sums A1 +...+ Aj for each j and every time applying the formula p(i,j) can use sum(1,j) - sum(1,i) so that the solution will take O(n^2).\n\nIs there a faster algorithm? In my solution I get the sequence of choices that gives the maximal sum for the first player, but it is too \"strong\": I  was asked to get a sequence of chooses that bring to him a win, regardless of maximizing the final sum. So, undoubtedly, I performed some unnecessary steps.\n\nThe better solution seems to be a greedy algorithm, because I have seen the same problem, but with an even number of numbers in the sequence(here https://cs.stackexchange.com/questions/82351/optimizing-greedy-solution-for-choice-game/82450). \n\nCan anybody give me some ideas or clues on how a greedy solution should look? Thank you in advance!\n    ", "Answer": "\r\n\"Greedy\" is a simple concept: instead of looking through the entire game tree, consider only maximizing the short-term result for the present level.  In this case, it means taking the larger of the two elements available, and not using recursion at all.\n\nYour complete solution, maximizing the sum received, works; it's just a little overkill for the general situation.\n\nA balance between the two might be useful, a heuristic that looks ahead a certain number of moves.  For instance, play out the game only four moves ahead (two for each player), and pick the one that maximizes your difference.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is Greedy Algorithm always best for choosing proper indexes for database table?\r\n                \r\nIn \"Database Systems: The Complete Book\" written by Garcia-Molina, Ullman, Widom, in chapter dedicated to indexes, it is written that the greedy algorithm for choosing best indexes for given database is effective. By greedy they mean choosing the best index based on some analysis, then repeat analysis for remaining indexes (including info about newly added index in previous step), choosing the best one again, etc.\n\nWe must have in mind, according to authors, that using one index or another can also affect other indexes' performance. \n\nI am just curious, is the \"greedy way\" only effective or maybe also guaranteed to be optimal? \nWhy is it effective/optimal?\n    ", "Answer": "\r\nFor MySQL, the \"greedy\" method is not used at all (as far as I can tell).  Instead, it uses statistics, plus probes into the BTrees to decide what it is likely to \"cost\" for each index.  Then it takes the cheapest.\n\nIt is impractical to simulate the \"cost\" model in your head; instead, see the following, which provides some general rules that almost always work:\nhttp://mysql.rjweb.org/doc.php/index_cookbook_mysql\n\nNo method is \"guaranteed to be optimal\".  Many methods (greedy/cost/cookbook/etc) are usually optimal.\n\nIf an algorithm spends too much time deciding what is optimal, well that takes away from the time to actually perform the query!  It's sort of the \"heisenberg uncertainty principle\" of optimizing queries.\n\nSometimes the \"optimal\" is to ignore all the indexes and simply scan the table.  This is because bouncing back and forth between the index and the data may make using an index slower.  This forum is littered with people who don't understand that and ask \"Why didn't MySQL use my index?\"\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm Implementation\r\n                \r\nYou know who knows who among n people that you would like to have come to a party. Assume \"knows\" is symmetric: If I know you, you know me. You make further requirements that you want each person to have at least 5 new people to meet at the party, and also, so nobody feels too isolated, each person should already know at least 5 people at the party. Your original list may not satisfy these extra two conditions, so you may need to eliminate some people from the invitation list (or maybe you cannot have a party at all with these restrictions). Find a largest possible subset of the n people that you could invite and satisfy the the other two requirements. For the basic problem, find an O(n^3) algorithm and explain its order and its logic.\n\nI ask not for the answer, but for guidance on where to start.\n    ", "Answer": "\r\nSounds like a good place to apply a graph algorithm.\n\nForm a graph of people, ```\nG```\n. For ```\nn```\n people there will be ```\nn```\n nodes in the graph. Link nodes ```\ni```\n and ```\nj```\n if person ```\ni```\n knows person ```\nj```\n.\n\nLet the first iteration of ```\nG```\n be called ```\nG_0```\n. Obtain ```\nG_1```\n by making a pass through ```\nG```\n and eliminate any person who knows too many or too few people. (That is, eliminate person ```\ni```\n if the number of links to ```\ni```\n is ```\n< 5```\n or ```\n> n-5```\n.)\n\nRepeat the process, obtaining ```\nG_2```\n, ```\nG_3```\n up to a maximum of ```\nn```\n (or so) iterations, obtaining ```\nG_n```\n. The people remaining in this graph are the people you should invite.\n\nEach of the ```\nn```\n passes requires a check of ```\nn```\n people against ```\nn```\n other people, so the algorithm is ```\nO(n^3)```\n.\n\n\n\nMATLAB code to accomplish this (you didn't ask for it, but I thought it was interesting and wrote it anyway):\n\n```\n% number of people on original list\nN = 10\n\n% number of connections to (attempt) to generate\n% may include self-links (i,i) or duplicates\nM = 40\n\n% threshold for \"too few\" friends\np = 3\n\n% threshold for \"too many\" friends\nq = 3\n\n% Generate connections at random\nG = zeros(N);\nfor k = 1:M\n    i = randi(N);\n    j = randi(N);\n    G(i,j) = 1;\n    G(j,i) = 1;\nend\n\n% define people to not be their own friends\nfor i = 1:N\n    G(i,i) = 0;\nend\n\n% make a copy for future comparison to final G\nG_orig = G\n\n% '1' means invited, '0' means not invited\ninvited = ones(1,N);\n\n% make N passes over graph\nfor k = 1:N\n    % number of people still on the candidate list\n    n = sum(invited); \n    % inspect the i'th person\n    for i = 1:N \n        people_known = sum(G(i,:));\n        if invited(i) == 1 && ((people_known < p) || (people_known > n-q))\n            fprintf('Person %i was eliminated. (He knew %i of the %i invitees.)\\n',i,people_known,n);\n            invited(i) = 0;\n            G(i,:) = zeros(1,N);\n            G(:,i) = zeros(1,N);\n        end\n    end\nend\n\nfprintf('\\n\\nFinal connection graph')\nG\n\ndisp 'People to invite:'\ninvited\n\ndisp 'Total invitees:'\nn\n```\n\n\nSample output (10 people, 40 connections,  must know at least 3 people, must not know at least 3 people)\n\n```\nG_orig =\n\n     0     0     1     1     0     0     0     0     1     0\n     0     0     0     0     0     1     0     0     0     1\n     1     0     0     1     1     1     0     0     0     1\n     1     0     1     0     0     1     0     1     1     0\n     0     0     1     0     0     0     1     0     1     1\n     0     1     1     1     0     0     0     1     0     1\n     0     0     0     0     1     0     0     0     1     0\n     0     0     0     1     0     1     0     0     0     1\n     1     0     0     1     1     0     1     0     0     1\n     0     1     1     0     1     1     0     1     1     0\n\nPerson 2 was eliminated. (He knew 2 of the 10 invitees.)\nPerson 7 was eliminated. (He knew 2 of the 10 invitees.)\n\n\nFinal connection graph\nG =\n\n     0     0     1     1     0     0     0     0     1     0\n     0     0     0     0     0     0     0     0     0     0\n     1     0     0     1     1     1     0     0     0     1\n     1     0     1     0     0     1     0     1     1     0\n     0     0     1     0     0     0     0     0     1     1\n     0     0     1     1     0     0     0     1     0     1\n     0     0     0     0     0     0     0     0     0     0\n     0     0     0     1     0     1     0     0     0     1\n     1     0     0     1     1     0     0     0     0     1\n     0     0     1     0     1     1     0     1     1     0\n\nPeople to invite:\n\ninvited =\n\n     1     0     1     1     1     1     0     1     1     1\n\nTotal invitees:\n\nn =\n\n     8\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Can this greedy algorithm be more efficient?\r\n                \r\nI'm studying for my exam coming up and I am practicing a problem that wants me to implement a greedy algorithm.\n\nI am given an unsorted array of different weights where 0 < weight_i for all i. I have to place all of them such that I use the least number of piles. I can not place two weights in a pile where the one on top is greater than the one below. I also have to respect the ordering of the weights, so they must be placed in order. There is no height limit for the pile.\n\nAn example: If I have the weights {53, 21, 40, 10, 18} I cannot place 40 above 21 because the pile must be in descending order, and I cannot place 21 above 40 because that does not respect the order. An optimal solution would have pile 1: 53, 21, 10 and pile 2: 40 18\n\nMy general solution is iterate through the array and always pick the first pile the weight is allowed to go. I believe this would give me an optimal solution (although I haven't proved it yet). I could not find a counter example to this. But this would be O(n^2) because worst case I have to iterate through every element and every pile (I think)\n\nMy question is, is there a way to get this down to O(n) or O(nlogn)? If there is I'm just not seeing it and need some help.\n    ", "Answer": "\r\nYour algorithm will give a correct result. \n\nNow note the following: when visiting the piles in order and stopping at the first one where the next value can be stacked, you will always have a situation where the stacks are ordered by their current top (last) value, in ascending order.\n\nYou can use this property to avoid an iteration of the piles from \"left to right\". Instead use a binary search, among the piles, to find that first pile that can take the next value.\n\nThis will give you a O(nlogn) time complexity.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Into which technique would this algorithm fall into? Brute Force or Greedy?\r\n                \r\nI have an algorithm that I am not sure whether to classify as a greedy algorithm or a brute force algorithm.\n```\nwhile(true) {\n            int n = 0;\n            int d = 0;\n              int r = 0;\n              int outcome = 0;\n            \n            n = scan.nextInt();\n            d = scan.nextInt();\n            r = scan.nextInt();\n\n            if ( n + d + r == 0) break;\n\n            int[] morning = new int[n];\n            int[] afternoon = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                morning[i] = scan.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                afternoon[i] = -scan.nextInt();\n            }\n\n            for (int i = 0; i < n; i++) {\n                int sum = morning[i] + (-afternoon[i]) - d;\n                if (sum > 0) outcome += sum * r;\n            }\n            System.out.printf(\"%d\\n\", outcome);\n        }\n```\n\nI feel like it is most likely greedy, not completely certain.\n    ", "Answer": "\r\nSo at first glance, and without further information, it does not seem to me that this algorithm uses greedy or brute force techniques.\nBy definition a greedy algorithm makes decisions at each step by choosing the locally optimal choice, with the hope of finding a global optimum, and a brute force algorithm tries every possible solution to a problem, in order to find the correct solution.\nIt doesn't appear that that piece of code does either of those things.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Showing that Greedy algorithm exhibits optimal substructure and greedy choice\r\n                \r\nI am in need of help proving that an algorithm has greedy choice property and optimal substructure.\nContext of the problem:\nConsider a problem where a company owns ```\nn```\n gas stations that  are connected by a highway.\nEach gas station has a limited supply ```\ng_i```\n of gas-cans. Since the company don't know which gas station is most visited they want all of them to have the same amount of gas.\nSo they hire a fueling-truck to haul gas between the stations in their truck. However, truck also consumes 1 gas-can per kilometer driven.\nYour task will be to help the chain calculate the largest amount of gas-cans ```\ng_bar```\n\nthey can have at all Stations.\nConsider the example: Here we have g = (20, 40, 80, 10, 20) and\np = (0, 5, 13, 33, 36) (in kilometers). In order to send one gas-can from station 3 to\nstation 4 we need to put 41 gas-cans in the truck, as the fueling-truck will consume 40 before reaching their destination (to send two gas-cans we need to put 42 in the truck).\nThe optimal ```\ng_bar```\n for the example is 21 and can be achieved as follows:\n\nStation 2 sends 11 gas-cans towards Station 1. One gas-can arrives while ten are consumed on the way.\n\nStation 3 sends 59 gas-cans towards Station 4. 19 arrive while 40 are consumed on the way.\n\nStation 4 now has 29 gas-cans and send eight towards Station 5. Two of these arrive\nand six are consumed on the way.\n\nThe final distribution of gas-cans is: (21, 29, 21, 21, 22).\n\n\nGiven an integer  ```\ng_bar```\n. Determine whether it is possible to get at least  ```\ng_bar```\n gas-cans in every Gas Station.\nin order for the greedy choice property and optimal substructure to make sense for a decision problem, you can define an optimal solution to be a solution with at least ```\ng_bar```\n gas-cans in every gas station if such a solution exists; otherwise, any solution is an optimal solution.\nInput: The position ```\np_i```\n and gas-can supply ```\ng_i of```\n each bar. Here ```\ng_i```\n is the supply for the bar at position ```\np_i```\n. You may assume that the positions are in sorted order – i.e. ```\np_1 < p_2 < . . . < p_n```\n.\nOutput: The largest amount ```\ng_bar```\n, such that each gas-station can have a gas-can supply of at least ```\ng_bar```\n after the truck have transferred gas-cans between the stations.\nHow can i prove Greedy Choice and Optimal Substructure for this?\n    ", "Answer": "\r\nLet's define an optimal solution: Each station has at least ```\nX```\n gas cans in each station (```\nX```\n = ```\ng_bar```\n).\nProving greedy property\nLet us assume our solution is sub-optimal. There must exist a station ```\ni```\n such that ```\ngas[i]```\n < ```\nX```\n. Based on our algorithm, we borrow ```\nX - gas[i]```\n from station ```\ni+1```\n (which is a valid move, since we had already found a solution). Now station ```\ni```\n has ```\ngas = X```\n. This contradicts the original assumption that there must exist a station ```\ni```\n such that ```\ngas[i]```\n < ```\nX```\n, which means our solution isn't suboptimal. Hence, we prove the optimality.\nProving optimal substructure\nAssume we have a subset of the stations of size ```\nN'```\n, and our solution is suboptimal. Again, if the solution is suboptimal, there must exist a station ```\ni```\n such that ```\ngas[i]```\n < ```\nX```\n. You can use the greedy proof again to prove that our solution isn't suboptimal. Since we have optimal solution for each arbitrary subset, we prove that we have optimal substructure.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Optimal algorithm for the Greedy Algorithm: Interval Scheduling - Scheduling All Intervals\r\n                \r\nI recently read about the Interval Scheduling algorithm in chapter 4 of Algorithm Design by Tardos and Kleinberg. The solution provided to the Interval Scheduling Problem was this:\n\n```\nSort the n intervals based on their finishing time and store in array F\nA = [] #list of intervals\nS = array with property that S[i] contains the finishing time of the ith interval\ni = 0\nFor j = 0 to n-1\n    if S[j] >= F[i] #this interval does not overlap with the ith interval\n        i = j\n        A.add(j)\n```\n\n\nThis algorithm in C++/Java/Python can be found here: http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/\n\nAn extension of the problem, also known as the Interval Coloring Problem, can be explained as follows.\n\n\n  We are given a set of intervals, and we want to colour all intervals\n  so that intervals given the same  colour do not intersect and the goal\n  is to try to minimize the number of colours used.\n\n\nThe algorithm proposed in the book was this:\n\n```\nSort the intervals by their start times in a list I\nn = len(I)\nFor j = 1 to n:\n   For each interval I[i] that precedes I[j] and overlaps it:\n       Exclude the label of I[i] from consideration for I[j]\nThe jth interval is assigned a nonexcluded label\n```\n\n\nHowever isn't this algorithm's running time O(n^2)? I thought of a better one, but I'm not sure if it is correct. Basically, we modify the algorithm for Interval Scheduling. \n\n```\nSort the n intervals based on their finishing time and store in array F\nA = []\nx = 1\nS = array with property that S[i] contains the finishing time of the ith interval\ni = 0\nwhile F is not empty:\n    new = []\n    For j = 0 to n-1\n        if S[j] >= F[i] #this interval does not overlap with the ith interval\n            i = j\n            A.add(F[j])\n        else:\n            new.add(F[j])\n    F = new\n    Recompute S\n    print x, A\n    A = []\n    x++\n```\n\n\nI might have a silly bug in the pseudocode but I hope you understand what my algorithm is trying to do. Basically I'm peeling off all possible colourings by repeatedly running the standard interval scheduling algorithm.\n\nSo, shouldn't my algorithm print all the various colourings of the intervals? Is this more efficient than the previous algorithm, if it is a correct algorithm? If it is not, could you please provide a counter-example? \nThanks!\n(More about interval scheduling here: https://en.wikipedia.org/wiki/Interval_scheduling)\n    ", "Answer": "\r\nYour algorithm can produce a suboptimal solution.  Here's an example of what your algorithm will produce:\n\n```\n---      -----\n  ----\n    ------------\n```\n\n\nClearly the following 2-colour solution (which will be produced by the proven-optimal algorithm) is possible for the same input:\n\n```\n--- ------------\n  ----   -----\n```\n\n\nFinally, although the pseudocode description of the book's proposed algorithm does indeed look like it needs O(n^2) time, it can be sped up using other data structures.  Here's an O(n log n) algorithm: Instead of looping through all n intervals, loop through all 2n interval endpoints in increasing order. Maintain a heap (priority queue) of available colours ordered by colour, which initially contains n colours; every time we see an interval start point, extract the smallest colour from the heap and assign it to this interval; every time we see an interval end point, reinsert its assigned colour into the heap. Each endpoint (start or end) processed is O(log n) time, and there are 2n of them.  This matches the time complexity for sorting the intervals, so the overall time complexity is also O(n log n).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Graph coloring algorithm (Greedy coloring)\r\n                \r\nI'm working on a graph-coloring project using Java. I need to implement four different graph coloring algorithms using four-color theorem. I have a problem with one of the algorithms named few neighbors greedy algorithm. \n\nI have a map which contains bunch of polygon objects (stored in an arraylist) in it. Also, I have a 2D boolean array that represents the adjacencies of different polygons.\n\nI know the algorithm theoretically: I have a priorityqueue that stores my uncolored polygons. The order of the queue based on adjacency counts. If a polygon has few neighbors, it is considered better than a polygon which has a lot of neighbots. Anyway, the algorithm should repeatedly draw a polygon from the priorityqueue and attemp to color it based on its adjacencies. \n\nUnfortunately, I have problems with the implementation part. I got the priorityqueue based on thie adjacency counts, but I have problems while assigning colors to those polygons. If is there anyone who worked on that kind of algorithms, or anyone with an idea, please share with me. I need some ideas to speed up the implementation part. \n\nThanks in advance. \n    ", "Answer": "\r\nYou should state exactly what kind of help you need with the implementation part. \"I have problems when assigning colors\" how? \n\nA map which contains Polygon objects stored in an array list with a separate 2D boolean array for adjacencies is the input? I assume your polygons are Nodes in the graph. \n\nYou should probably build a Graph data structure and navigate it. The classical, C-style approach is using arrays for nodes and edges and making it look complex. \n\nSince OOP using Composition naturally generates a graph of objects that's a good approach to use here.\n\nGraphs are essentially composed of 2 elements: Nodes and Edges.\n\nStart with a Node class. It has a color, an id, and an ArrayList of Edges.\nEdges form a relationship between 2 nodes, and may have a weight and a direction.\n\nMake your nodes and edges from the inputs (remember, if a new node doesn't exist, then make it). Then run the nearest neighbor algorithm by picking an unmarked node (a static method may work well for this, or you can really practice for real life and implement the Strategy Pattern). \n\nLook out for cycles, though!\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Find a greedy algorithm for beach and umbrella question\r\n                \r\nA day at the beach. A group of n people are lying on the beach. The beach is represented by the real line R and the location of the i-th person is some integer xi ∈ Z. Your task is to prevent people from getting sunburned by covering them with umbrellas. Each umbrella corresponds to a closed interval I = [a, a + L] of length L ∈ N, and the i-th person is covered by that umbrella if xi ∈ I. Design a greedy algorithm for covering all people with the minimum number of umbrellas. The input consists of the integers x1,...,xn, and L. The output of your algorithm should be the positions of umbrellas.\nForexample,iftheinputisx1 =1,x2 =3,x3 =5,andL=2,thenanoptimumsolutionisthe set of two umbrellas placed at positions 2 and 5, covering intervals [1, 3] and [4, 6]. The running time should be polynomial in n \n    ", "Answer": "\r\nThe main idea is that when we see someone that is not covered yet, we will place the umbrella at position ( uncoveredPersonPosition + L/2 ), and the umbrella reach will be covering the range (uncoveredPersonPosition, uncoveredPersonPosition + L) .\n\nHere is the code for this idea.\n\n```\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nint solve(std::vector<double>&  people, int umbrellaCoverage) {\n\n    std::sort(people.begin(), people.end() );\n\n    int answer = 0;\n    double umbrellaReach;\n\n    for(const auto& p : people) {\n        if(answer == 0) {\n            answer += 1;\n            umbrellaReach = p + umbrellaCoverage;\n        }\n        else {\n            if(p < umbrellaReach) continue;\n            else {\n                answer++;\n                umbrellaReach = p + umbrellaCoverage;\n            }\n        }\n    }\n    return answer;\n}\n\nint main() {\n\n    std::vector<double> v(10);\n    for(int i = 0; i < 10; ++i) v[i] = (double) i;\n    std::cout << solve(v, 3) << std::endl;\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy search algorithm\r\n                \r\nCurrently, I am a new to the Artificial Intelligence. I have a problem with the greedy search algorithm. I saw one question in a tutorial but can't understand how to answer it. Please help me. Any help much appreciated.\n\nConsider the given figure 1. The values in each node represent the\nheuristic cost from that node to goal node (G) and the values within\nthe arcs represent the path cost between two nodes.\n\nIf B is the starting node and G is the goal node,\n\n\nFind the traversal using Greedy Search Algorithm.\nFind the traversal using A* Search Algorithm\n\n\nUsing the result of part (1) show that greedy search is not optimal.\n\n\n\n\n\n    ", "Answer": "\r\nI assume that the greedy search algorithm that you refer to is having the greedy selection strategy as follows: Select the next node which is adjacent to the current node and has the least cost/distance from the current node. Note that the greedy solution don't use heuristic costs at all.\n\nConsider the following figure well crafted such that it proves that greedy solution is not optimal.\n\n\nThe path highlighted with red shows the path taken by Greedy Algorithm and the path highlighted with green shows the path taken by Heuristic A* algorithm.\n\nExplanation:\n\nGreedy algorithm\n\n\nStarting from Node B, the greedy algorithm sees the path costs (for A it's 6, for C it's 6 and for E it's 5)\nWe greedily move to node E because it is having least path value.\nFrom E we have only one option to move to F\nFrom F we again have only one option to move to H and from H we move to G (Goal state/node)\n\n\nCost for the path by Greedy Algorithm (highlighted in red): ```\nB -> E -> F -> H -> G```\n = ```\n5+6+6+3```\n = ```\n20```\n\n\nA* algorithm (before going forward have a look at the wiki page for A* algorithm and understand what ```\ng(n)```\n and ```\nh(n)```\n are if you haven't already understood this concept):\n\n\nStarting from node B, we have three options A, C and E. For each node we calculate ```\nf(n) = g(n) + h(n)```\n. Here g(n) is the immediate cost on the arc and ```\nh(n)```\n is the heuristic value on the node\n\n\nFor node A, f(n) = 6 + 12 = 18\nFor node B, f(n) = 6 + 10 = 16\nFor node C, f(n) = 5 + 14 = 19\n\nWe choose to proceed with the node that has least ```\nf(n)```\n. So we move to node B.\nWe proceed in the similar fashion and find the path highlighted in green.\nThe path by A* algorithm is ```\nB -> C -> D -> H -> G```\n and it's cost is ```\n6+6+4+3```\n = ```\n19```\n\n\n\nBy the above example we can see that the cost of heuristic path is less than greedy algorithm. Hence greedy algorithm is not always optimal.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm for Finding Min Set of Intervals that Overlap All Other Intervals\r\n                \r\nI'm learning greedy algorithms and came across a problem that I'm not sure how to tackle. Given a set of intervals (a,b) with start time a and end time b, give a greedy algorithm that returns the minimum amount of intervals that overlap every other interval in the set. So for example if I had:\n\n(1,4) (2,3) (5,8) (6,9) (7,10)\n\nI would return (2,3) and (7,8) since these two intervals cover every interval in the set. What I have right now is this:\n\n\nSort the intervals by increasing end time\nPush the interval with the smallest end time onto a stack\nIf an interval (a,b) overlaps the interval on the top of the stack (c,d) (so a is less than d) then if a<=c keep (c,d). Else update the interval on the top of the stack to (a,d)\nIf an interval (a,b) does not overlap the interval on the top of the stack (c,d) then push (a,b) onto the stack\nAt the end the stack contains the desired intervals and this should run in O(n) time\n\n\nMy question is: how is this algorithm greedy? I'm struggling with the concepts. So maybe I have this right and maybe I don't, but if I do, I can't figure out what the greedy rule is/should be.\n\nEDIT: A valid point was made below, about which I should have been clearer about. (7,8) works instead of (1,10) (which covers everything) because every time in (7,8) is in (5,8) (6,9) and (7,10). Same with (2,3), every time in there is in (1,4) and (2,3). The goal is to get a set of intervals such that if you looked at all possible times in that set of intervals, each time would be in at least one of the original intervals.\n    ", "Answer": "\r\nA greedy algorithm is one that repeatedly chooses the best incremental improvement, even though it might turn out to be sub-optimal in the long run.\n\nYour algorithm doesn't seem greedy to me.  A greedy algorithm for this problem would be:\n\n\nFind the interval that is contained in the largest number of intervals from the input set.\nRemove the intervals from the input set that contain it.\nRepeat until the input set is empty.\n\n\nFor this example, it would first produce (7,8), because it is contained in 3 input intervals, then reduce the input set to (1,4)(2,3), then produce (2,3)\n\nNote that this algorithm doesn't produce the optimal output for input set:\n(0,4)(1,2)(1,4)(3,6)(3,7)(5,6)\n\nIt produces (3,4) first, since it is covered by 4 input intervals, but the best answer is (1,2)(5,6), which are covered by 3 intervals each\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "When does the Greedy Algorithm for the Coin change making problem always fail/always optimal?\r\n                \r\nI understand how the greedy algorithm for the coin change problem works. I am just a bit confused on when the output is always optimal (when using the Greedy) and when the greedy will always fail.\nFor example the US coin denominations are canonical meaning that it is always optimal, what are coin denominations that will always fail or always be optimal?\n    ", "Answer": "\r\nThere is an O(n^3) algorithm derived by Pearson (1994, 2004) for determining whether a given system of n coins is canonical. I believe this is still the best general case algorithm. It works by isolating O(n^2) possible values into which the smallest counterexample to the greedy algorithm must fall (if a counterexample exists). The paper gives a rule for generating a potential counterexample and a minimum coin representation for it in O(n) time. You then check whether the greedy algorithm produces a representation with more coins than the derived minimal one (also in O(n) time), and do this for all O(n^2) potential counterexamples. If the greedy matches the minimal in terms of number of coins for all potential counterexamples, then no counterexample exists and greedy algorithm is optimal for all values (otherwise, it is of course not optimal, as you've found a counterexample).\nHere is an implementation of the test:\n\r\n\r\n```\n/**\n * Check if coins can be used greedily to optimally solve\n * the  change-making problem\n *  check all potential minimal counter-examples w_{ij}, 1 < i <= j <= n: \n *  An optimal coinVector for w_{ij} equals the greedy coinVector \n *  for c_{i-1}-1 with the coint of c_j incremented by one and all \n *   following counts set equal to zero\n * coins: [c1, c2, c3...] : sorted descending with cn = 1\n * return: [optimal?, minimalCounterExample | null, greedySubOptimal | null] */\nfunction greedyIsOptimal(coins) {\n  for (let i = 1; i < coins.length; i++) {\n    greedyVector = makeChangeGreedy(coins, coins[i - 1] - 1)\n    for (let j = i; j < coins.length; j++) {\n      let [minimalCoins, w_ij] = getMinimalCoins(coins, j, greedyVector)\n      let greedyCoins = makeChangeGreedy(coins, w_ij)\n      if (coinCount(minimalCoins) < coinCount(greedyCoins))\n        return [false, minimalCoins, greedyCoins]\n    }\n  }\n  return [true, null, null]\n}\n\n// coins [c1, c2, c3...] => greedy coinVector for amount\nfunction makeChangeGreedy(coins, amount) {\n  return coins.map(c => {\n    let numCoins = Math.floor(amount / c);\n    amount %= c\n    return numCoins;\n  })\n}\n// generate a potential counter-example in terms of its coinVector \n// and total amount of change\nfunction getMinimalCoins(coins, j, greedyVector) {\n  minimalCoins = greedyVector.slice();\n  minimalCoins[j - 1] += 1\n  for (let k = j; k < coins.length; k++) minimalCoins[k] = 0\n  return [minimalCoins, evaluateCoinVector(coins, minimalCoins)]\n}\n// return the total amount of change for coinVector\nconst evaluateCoinVector = (coins, coinVector) =>\n  coins.reduce((change, c, i) => change + c * coinVector[i], 0)\n\n// return number of coins in coinVector\nconst coinCount = (coinVector) =>\n  coinVector.reduce((count, a) => count + a, 0)\n\n/* Testing */\nlet someFailed = false;\nfunction test(coins, expect) {\n  console.log(`testing ${coins}`)\n  let [optimal, minimal, greedy] = greedyIsOptimal(coins)\n  if (optimal != expect) (someFailed = true) && console.error(`expected optimal=${expect}\n  optimal: ${optimal}, amt:${evaluateCoinVector(coins, minimal)}, min: ${minimal}, greedy: ${greedy}`)\n}\n// canonical examples\ntest([25, 10, 5, 1], true) // USA\ntest([240, 60, 24, 12, 6, 3, 1], true) // Pound Sterling - 30\ntest([240, 60, 30, 12, 6, 3, 1], true) // Pound Sterling - 24\ntest([16, 8, 4, 2, 1], true) // Powers of 2\ntest([5, 3, 1], true) // Simple case\n\n// non-canonical examples\ntest([240, 60, 30, 24, 12, 6, 3, 1], false) // Pound Sterling\ntest([25, 12, 10, 5, 1], false) // USA + 12c\ntest([25, 10, 1], false) // USA - nickel\ntest([4, 3, 1], false) // Simple cases\ntest([6, 5, 1], false)\n\nconsole.log(someFailed ? \"test(s) failed\" : \"All tests passed.\")```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Set Coverage algorithm built by *removing* sets\r\n                \r\nI am trying to implement a solution for a set coverage problem using a greedy algorithm.\n\nThe classic greedy approximation algorithm for it is \n\n```\ninput: collection C  of sets over universe U  , costs: C→R ≥0    \noutput: set cover S   \n1. Let S←∅.  \n2. Repeat until S covers all elements:  \n3.   Add a set s to S, where s∈C maximizes the number of elements in s not yet covered by set s in S, divided by the cost c(s). \n4. Return S.  \n```\n\n\nI have a question in 2 parts:\n\na. Will doing the algorithm in reverse be a valid algorithm i.e.\n\n```\ninput: collection C  of sets over universe U  , costs: C→R ≥0    \noutput: set cover S   \n1. Let S←C  .  \n2. Repeat until there are no s∈S such that S-s=S (i.e. all elements in s are redundant):  \n3.   Remove a set s from S, where s∈S minimises the number of elements in s, divided by the cost c(s). \n4. Return S.  \n```\n\n\nb. The nature of the problem is such that it easy to get C and there will be a limited number (<5) of redundant sets - in this case will this removal algorithmm would perform better?\n    ", "Answer": "\r\nThe algorithm will surely return a valid set cover as at every step it checks if all elements of s are redundant. \nIntuitively I feel that part b is true though I am unable to write a formal proof for it. Read chapter 2 of Vijay Vazirani as it might help do the analysis part.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm implementation\r\n                \r\nSo I have some questions concerning the solution to the problem of scheduling n activities that may overlap using the least amount of classrooms possible. The solution is below:\n\n\n  Find the smallest number of classrooms to schedule a set of activities S in. To do this efefficiently\n  move through the activities according to starting and finishing times. Maintain two lists of classrooms: Rooms that are busy at time t and rooms that are free at time t. When t is the starting time\n  for some activity schedule this activity to a free room and move the room to the busy list.\n  Similarly, move the room to the free list when the activity stops. Initially start with zero rooms. If\n  there are no rooms in the free list create a new room.\n  \n  The algorithm can be implemented by sorting the activities. At each start or finish time we can\n  schedule the activities and move the rooms between the lists in constant time. The total time is thus\n  dominated by sorting and is therefore O(n lg n).\n\n\nMy questions are \n\n1) First, how do you move through the activities by both starting and finishing time at the same time? \n\n2) I don't quite understand how it's possible to move the rooms between lists in constant time. If you want to move rooms from the busy list to the free list, don't you have to iterate over all the rooms in the busy list and see which ones have end times that have already passed? \n\n3) Are there any 'state' variables that we need to keep track of while doing this to make it work?\n    ", "Answer": "\r\n\nThe way the algorithm works, you need to create a list containing an element for each start time and an element for each end time (so 2n elements in total if there are n activities).  Sort this list.  When an end time and a start time are equal, sort the end time first -- this will cause back-to-back bookings for halls to work.\nIf you use linked lists for holding the free and booked halls, you can have the elements you created in step 1 hold pointers back to an activity structure, and this structure can hold a pointer to the list element containing the hall that this activity is assigned to.  This will be NULL initially, and will take on a value when that hall is used for that activity.  Then when that activity ends, its hall can be looked up in constant time by following two pointers from the activity-end element (first to the activity object, and from there to the hall element).\nThat should be clear from the above description, hopefully.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm: highest value first vs earliest deadline first\r\n                \r\nAssume we have a set of ```\nn```\n jobs to execute, each of which takes unit time. At any time we can serve exactly one job. Job ```\ni```\n, ```\n1<=i<=n```\n earns us a profit if and only if it is executed no later than its deadline.\n\nWe can a set of jobs feasible if there exists at least one sequence that allows each job in the set to be performed no later than their deadline. \"Earliest deadline first\" is feasible.\n\nShow that the greedy algorithm is optimal: Add in every step the job with the highest value of profit among those not yet considered, provided that the chosen set of jobs remains feasible.\n\nMUST DO THIS FIRST: show first that is always possible to re-schedule two feasible sequences (one computed by Greedy) in a way that every job common to both sequences is scheduled at the same time. This new sequence might contain gaps.\n\nUPDATE\n\nI created an example that seems to disprove the algorithm:\n\nAssume 4 jobs:\n\n\nJob A has profit 1, time duration 2, deadline before day 3;\nJob B has profit 4, time duration 1, deadline before day 4;\nJob C has profit 3, time duration 1, deadline before day 3;\nJob D has profit 2, time duration 1, deadline before day 2.\n\n\nIf we use greedy algorithm with the highest profit first, then we only get job B & C. However, if we do deadline first, then we can get all jobs and the order is CDB\n\nNot sure if I am approaching this question in the right way, since I created an example to disprove what the question wants\n    ", "Answer": "\r\nThis problem looks like Job Shop Scheduling, which is NP-complete (which means there's no optimal greedy algorithm - despite that experts are trying to find one since the 70's). Here's a video on a more advanced form of that use case that is being solved with a Greedy algorithm followed by Local Search.\n\nIf we presume your use case can indeed be relaxed to Job Shop Scheduling, than there are many optimization algorithms that can help, such as Metaheuristics (including Local Search such as Tabu Search and Simulated Annealing), (M)IP, Dynamic Programming, Constraint Programming, ... The reason there are so many choices, is because none are perfect. I prefer Metaheuristics, as they out-scale the others in all the research challenges I've seen.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm visualization\r\n                \r\nI have a problem which goes as follows.\nThere are ```\nn```\n items. Each item ```\ni```\n takes ```\nm_i```\n time to manufacture and ```\nt_i```\n time to test. Obviously, an item must be manufactured before being tested. At any point of time, manufacturing queue and testing queue can have only one item in each of them. Now, the objective is to schedule the items to minimize the total production time.\nI have written the code for this:\n```\n# data is a list of lists which will be in the form of [[id, m_i, t_i]]\ndata.sort(key=lambda x: x[1])  # Sort by manufacturing time\nprint(f\"Items will be produced in the order: {', '.join(str(x[0]) for x in data)}\")\nidle = 0\nlast =  0\n# Idle time is the total time when the testing unit will have no work\nschedule = 0\nfor item in data:\n    if last and last <= item[1]:\n        idle = item[1] - last + 1\n    schedule += item[2]\n    last = schedule + idle\nprint(f\"The total production time is {schedule+idle}\")\n```\n\nNow, for the following input,\n```\n1 / 5 / 7\n2 / 1 / 2\n3 / 8 / 2\n4 / 5 / 4\n5 / 3 / 7\n6 / 4 / 4\n```\n\nI want to visualize it this way\n\nAs you can see above, an item is moved to testing queue as soon as it is manufactured and the next item is pulled into the manufacturing queue. If the manufacturing queue still has time left, the testing queue will be idle as there are no drones to be tested. Now, I want to visualize the above code this way.\nHow to achieve this? I am stuck with this. Could someone please help me?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How is Kruskal's Algorithm Greedy?\r\n                \r\nIt is said that Kruskal's algorithm for MST construction is greedy, but the algorithm chooses global minimum and instead of local minimum unlike Prim's algorithm. Can someone explain how Kruskal's algorithm is considered a greedy approach ?\n    ", "Answer": "\r\nWhat we do in Kruskal ? Firstly sort the edges according to their weight. Then we choose that edge which has minimal weight. We add that edge if it makes no cycle. Thus we go forward greedily. So it is greedy approach. :) \n\nThe greedy approach is called greedy because, it takes optimal choice in each stage expecting, that will give a total optimal solution. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is an efficient way to go beyond a greedy algorithm\r\n                \r\nThe domain of this question is scheduling operations on constrained hardware. The resolution of the result is the number of clock cycles the schedule fits within. The search space grows very rapidly where early decisions constrain future decisions and the total number of possible schedules grows rapidly and exponentially. A lot of the possible schedules are equivalent because just swapping the order of two instructions usually result in the same timing constraint.\n\nBasically the question is what is a good strategy for exploring the vast search space without spending too much time. I expect to search only a small fraction but would like to explore different parts of the search space while doing so.\n\nThe current greedy algorithm tend to make stupid decisions early on sometimes and the attempt at branch and bound was beyond slow.\n\nEdit:\nWant to point out that the result is very binary with perhaps the greedy algorithm ending up using 8 cycles while there exists a solution using only 7 cycles using branch and bound.\n\nSecond point is that there are significant restrictions in data routing between instructions and dependencies between instructions that limits the amount of commonality between solutions. Look at it as a knapsack problem with a lot of ordering constraints as well as some solutions completely failing because of routing congestion.\n\nClarification:\nIn each cycle there is a limit to how many operations of each type and some operations have two possible types. There are a set of routing constraints which can be varied to be either fairly tight or pretty forgiving and the limit depends on routing congestion.\n    ", "Answer": "\r\nInteger linear optimization for NP-hard problems\n\nDepending on your side constraints, you may be able to use the critical path method or \n(as suggested in a previous answer) dynamic programming.  But many scheduling problems are NP-hard just like the classical traveling sales man --- a precise solution has a worst case of exponential search time, just as you describe in your problem.\n\nIt's important to know that while NP-hard problems still have a very bad worst case solution time there is an approach that very often produces exact answers with very short computations (the average case is acceptable and you often don't see the worst case).\n\nThis approach is to convert your problem to a linear optimization problem with integer variables.  There are free-software packages (such as lp-solve) that can solve such problems efficiently.\n\nThe advantage of this approach is that it may give you exact answers to NP-hard problems in acceptable time.  I used this approach in a few projects.\n\nAs your problem statement does not include more details about the side constraints, I cannot go into more detail how to apply the method.\n\nEdit/addition: Sample implementation\n\nHere are some details about how to implement this method in your case (of course, I make some assumptions that may not apply to your actual problem --- I only know the details form your question):\n\nLet's assume that you have 50 instructions cmd(i) (i=1..50) to be scheduled in 10 or less cycles cycle(t) (t=1..10).  We introduce 500 binary variables v(i,t) (i=1..50; t=1..10) which indicate whether instruction cmd(i) is executed at cycle(t) or not. This basic setup gives the following linear constraints:\n\n```\nv_it integer variables\n0<=v_it; v_it<=1;       # 1000 constraints: i=1..50; t=1..10\nsum(v_it: t=1..10)==1   # 50 constraints:   i=1..50\n```\n\n\nNow, we have to specify your side conditions.  Let's assume that operations cmd(1)...cmd(5) are multiplication operations and that you have exactly two multipliers --- in any cycle, you may perform at most two of these operations in parallel:\n\n```\nsum(v_it: i=1..5)<=2    # 10 constraints: t=1..10\n```\n\n\nFor each of your resources, you need to add the corresponding constraints.\n\nAlso, let's assume that operation cmd(7) depends on operation cmd(2) and needs to be executed after it.  To make the equation a little bit more interesting, lets also require a two cycle gap between them:\n\n```\nsum(t*v(2,t): t=1..10) + 3 <= sum(t*v(7,t): t=1..10)   # one constraint\n```\n\n\nNote: sum(t*v(2,t): t=1..10) is the cycle t where v(2,t) is equal to one.\n\nFinally, we want to minimize the number of cycles.  This is somewhat tricky because you get quite big numbers in the way that I propose:  We give assign each v(i,t) a price that grows exponentially with time: pushing off operations into the future is much more expensive than performing them early:\n\nsum(6^t * v(i,t): i=1..50; t=1..10) --> minimum.   # one target function \n\nI choose 6 to be bigger than 5 to ensure that adding one cycle to the system makes it more expensive than squeezing everything into less cycles.  A side-effect is that the program will go out of it's way to schedule operations as early as possible.  You may avoid this by performing a two-step optimization: First, use this target function to find the minimal number of necessary cycles.  Then, ask the same problem again with a different target function --- limiting the number of available cycles at the outset and imposing a more moderate price penalty for later operations.  You have to play with this, I hope you got the idea.\n\nHopefully, you can express all your requirements as such linear constraints in your binary variables.  Of course, there may be many opportunities to exploit your insight into your specific problem to do with less constraints or less variables.\n\nThen, hand your problem off to lp-solve or cplex and let them find the best solution!\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm Optimization\r\n                \r\nI have the following problem:\n\n\nLet there be n projects.\nLet Fi(x) equal to the number of points you will obtain if you spent\nx units of time working on project i.\nYou have T units of time to use and work on any project you would\nlike.\n\n\nThe goal is to maximize the number of points you will earn and the F functions are non-decreasing.\n\nThe F functions have diminishing marginal return, in other words spending x+1 unit of time working on a particular project will yield less of an increase in total points earned from that project than spending x unit of time on the project did. \n\nI have come up with the following O(nlogn + Tlogn) algorithm but I am supposed to find an algorithm running in O(n + Tlogn):\n\n```\nsum = 0\nschedule[]\ngain[] = sort(fi(1))\n\nfor sum < T\n    getMax(gain) // assume that the max gain corresponds to project \"P\"\n    schedule[P]++\n    sum++\n    gain.sortedInsert(Fp(schedule[P] + 1) - gain[P])\n    gain[P].sortedDelete()\n\nreturn schedule\n```\n\n\nThat is, it takes O(nlogn) to sort the initial gain array and O(Tlogn) to run through the loop. I have thought through this problem more than I care to admit and cannot come up with an algorithm that would run in O(n + Tlogn).\n    ", "Answer": "\r\nFor the first case, use a Heap, constructing the heap will take O(n) time, and each ExtractMin & DecreaseKey function call will take O(logN) time.\n\nFor the second case construct a nXT table where ith column denotes the solution for the case T=i. i+1 th column should only depend on the values on the ith column and the function F, hence calculatable in O(nT) time. I did not think all the cases thoroughly but this should give you a good start.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm error using c++ sets\r\n                \r\nI've created  a greedy algorithm to solve a problem (homework assignment) and since I'm learning ```\nc++```\n I would like to achieve the same thing but using ```\nsets```\n.\n\nBasically we submit the homework to an online platform, this platform as some test cases that we don't know of, and we get a score based on that. If we pass all test cases we have 100%;\n\nThe problem is like this.\n\nWe have an actor that wants to schedule appointments with the fans that answered an online questionnaire about him. Now he wants to choose the fan's that maximizes the sum of points in the questionnaire and respecting the fan's availability. He can see only one fan a day.\n\nWe have an input like this:\n\n```\n6\n1 1 5  \n2 2 4\n3 1 2\n4 3 1\n5 1 6\n6 2 2\n```\n\n\nWhere the first line is the number of fans and following, in each line, we have the fan id, the fan available days and the fan points achieved in the online questionnaire. I must print the ids of the fans that the actor will see and the sum of combined points of the fans. So for the above input I have the following output:\n\n```\n2\n4\n5\n11\n```\n\n\nNote that if two fans have the same points, the fan prefered should be the one with the lower ID.\n\nI've started by sorting the fans by the points of the questionnaire (decreasing order) and then by the lower id.\nWhen reading the input, I'm adding the number of days to a ```\nset```\n.\nMy idea was like this:\n\nWhen iterating over the data, I check if the fan in study days available is in the ```\nset```\n. If it is, add this fan and remove the days from the set. If the fan days is not in the set, then get the ```\nupper_bound```\n and decrease the iterator to set the fan on the first day lower that the initial day. The algorithm stops wen the set is empty or I iterate all over the fans.\n\nHere is my greedy function:\n\n```\nvoid greedy() {\n    fan_id.insert(questionnaire_result[0][0]);\n    days_available.erase(questionnaire_result[0][1]);\n    total_questionaire_sum += questionnaire_result[0][2];\n\n    int i;\n    for (i = 1; i < number_of_fans; i++) {\n        if (days_available.empty()) {\n            break;\n        } else if (days_available.count(questionnaire_result[i][1])) {\n            fan_id.insert(questionnaire_result[i][0]);\n            days_available.erase(questionnaire_result[i][1]);\n            total_questionaire_sum += questionnaire_result[i][2];\n        } else {\n            it = days_available.upper_bound(questionnaire_result[i][1]);\n            if (it == days_available.begin()) {\n                if (*it < questionnaire_result[i][1]) {\n                    fan_id.insert(questionnaire_result[i][0]);\n                    days_available.erase(*it);\n                    total_questionaire_sum += questionnaire_result[i][2];\n                }\n            } else if (it == days_available.end()) {\n                it--;\n                if (*it < questionnaire_result[i][1]) {\n                    fan_id.insert(questionnaire_result[i][0]);\n                    days_available.erase(*it);\n                    total_questionaire_sum += questionnaire_result[i][2];\n                }\n\n            } else {\n                it--;\n                if (*it < questionnaire_result[i][1]) {\n                    fan_id.insert(questionnaire_result[i][0]);\n                    days_available.erase(*it);\n                    total_questionaire_sum += questionnaire_result[i][2];\n                }\n            }\n        }\n    }\n}\n```\n\n\nI believe my problem is in this line:\n\n```\nit = days_available.upper_bound(questionnaire_result[i][1]);\n```\n\n\nI've tested many possibilities and this is working in all my test cases. Unfortunately, we don't have the test cases of the platform.\n\nDoes someone see an situation that my code fails? With this I'm getting 90% of the score.\n\nEDIT:\n\nAs Edward pointed me out, I've managed to solve the problem like this:\n\nWhen reading the input added this line of code:\n\n```\nmax_days = max_days | questionnaire_result[i][1];\n```\n\n\nAnd then did this:\n\n```\nfor (int j = 1; j < max_days + 1; j++) {\n            days_available.insert(j);\n        }\n```\n\n\nProblem solved\n    ", "Answer": "\r\nThis input file will cause the program to generate an incorrect result:\n\n```\n2\n1 2 6\n2 2 5\n```\n\n\nBoth fans are available either day, so it's clear that both fans could be visited and the total output score should be 11.  Your algorithm, however, only chooses the first one and outputs a score of 6.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Online Bin Packing Algorithm\r\n                \r\nI'm trying to find a greedy solution to the online bin packing problem. There are some changes to this problem compared to the original bin packing problem. First, each bin has capacity C > 0. Also, each item i has weight w_i <= C. Since this is an online bin packing problem, each item must be placed in a bin (and never moved again) before the next item can be processed. Also, if we create a new bin, then we can't return back to the old bin and place more items in it later.\n\nMy greedy algorithm is the next fit solution (fit as many items as possible into one bin while the total weight is less than C). When we can't fit the next item, we create a new bin.\n\nBut I am having difficulty proving the optimality for this solution. I tried using a greedy ahead argument, but got stuck.\n\nAny hints or guideline would be great!\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Minimum absolute difference between vector pairs (greedy algorithm)\r\n                \r\nGiven a numeric vector, I'd like to find the smallest absolute difference in combinations of size 2. However, the point of friction comes with the use of ```\ncombn```\n to create the matrix holding the pairs. How would one handle issues when a matrix/vector is too large?\nWhen the number of resulting pairs (number of columns) using ```\ncombn```\n is too large, I get the following error:\n\nError in matrix(r, nrow = len.r, ncol = count) :\ninvalid 'ncol' value (too large or NA)\n\nThis post states that the size limit of a matrix is roughly one billion rows and two columns.\nHere is the code I've used. Apologies for the use of ```\ncat```\n in my function output -- I'm solving the Minimum Absolute Difference in an Array Greedy Algorithm problem in HackerRank and R outputs are only counted as correct if they're given using ```\ncat```\n:\n```\nminimumAbsoluteDifference <- function(arr) {\n  combos <- combn(arr, 2)\n  \n  cat(min(abs(combos[1,] - combos[2,])))\n}\n\n# This works fine\ninput0 <- c(3, -7, 0)\n\nminimumAbsoluteDifference(input0) #returns 3\n\n# This fails\ninputFail <- rpois(10e4, 1)\n\nminimumAbsoluteDifference(inputFail) \n  #Error in matrix(r, nrow = len.r, ncol = count) : \n  # invalid 'ncol' value (too large or NA)\n```\n\n    ", "Answer": "\r\nTL;DR\nNo need for ```\ncombn```\n or the like, simply:\n```\nmin(abs(diff(sort(v))))\n```\n\nThe Nitty Gritty\nFinding the difference between every possible combinations is ```\nO(n^2)```\n. So when we get to vectors of length ```\n1e5```\n, the task is burdensome both computationally and memory-wise.\nWe need a different approach.\n\nHow about sorting and taking the difference only with its neighbor?\n\nBy first sorting, for any element vj, the difference min |vj -  vj -/+ 1| will be the smallest such difference involving vj. For example, given the sorted vector ```\nv```\n:\n```\nv = -9 -8 -6 -4 -2  3  8\n```\n\nThe smallest distance from ```\n-2```\n is given by:\n```\n|-2 - 3| = 5\n|-4 - -2| = 2\n```\n\nThere is no need in checking any other elements.\nThis is easily implemented in base ```\nR```\n as follows:\n```\ngetAbsMin <- function(v) min(abs(diff(sort(v))))\n```\n\nI'm not going to use ```\nrpois```\n as with any reasonably sized vector, duplicates will be produces, which will trivially give ```\n0```\n as an answer. A more sensible test would be with ```\nrunif```\n or ```\nsample```\n (```\nminimumAbsoluteDifference2```\n is from the answer provided by @RuiBarradas):\n```\nset.seed(1729)\nrandUnif100 <- lapply(1:100, function(x) {\n    runif(1e3, -100, 100)\n})\n\nrandInts100 <- lapply(1:100, function(x) {\n    sample(-(1e9):(1e9), 1e3)\n})\n\nhead(sapply(randInts100, getAbsMin))\n[1]  586 3860 2243 2511 5186 3047\n\nidentical(sapply(randInts100, minimumAbsoluteDifference2),\n          sapply(randInts100, getAbsMin))\n[1] TRUE\n\noptions(scipen = 99)\nhead(sapply(randUnif100, getAbsMin))\n[1] 0.00018277206 0.00020549633 0.00009834766 0.00008395873 0.00005299225 0.00009313226\n\nidentical(sapply(randUnif100, minimumAbsoluteDifference2),\n          sapply(randUnif100, getAbsMin))\n[1] TRUE\n```\n\nIt's very fast as well:\n```\nlibrary(microbenchmark)\nmicrobenchmark(a = getAbsMin(randInts100[[50]]),\n               b = minimumAbsoluteDifference2(randInts100[[50]]),\n               times = 25, unit = \"relative\")\nUnit: relative\nexpr      min       lq     mean   median       uq      max neval\n   a   1.0000   1.0000   1.0000   1.0000  1.00000  1.00000    25\n   b 117.9799 113.2221 105.5144 107.6901 98.55391 81.05468    25\n```\n\nEven for very large vectors, the result is instantaneous;\n```\nset.seed(321)\nlargeTest <- sample(-(1e12):(1e12), 1e6)\n\nsystem.time(print(getAbsMin(largeTest)))\n[1] 3\n user  system elapsed \n0.083   0.003   0.087\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why is 0/1 Knapsack not part of Greedy Algorithm but Fractional Knapsack is? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Cases where the greedy algorithm fails the 0-1 knapsack p‌r‌o‌b‌l‌e‌m\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 2 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI don't get it. I really don't. Greedy Algorithm for me, only cares about :\n\nDividing a problem into stages[sub problems]\nMaximizing/Minimizing or Optimizing output in each stage irrespective of later stages or anything else.\n\nEven the 0/1 Knapsack Problem is solved using the same theory.\n\nStages become various items to fill\nOptimizing output in each stage becomes picking the item providing most profit first and then picking the next item providing most profit and so on.\n\nIt's the same approach that we are following on both Knapsack problems. The only difference is :\n\nIn Fractional Knapsack : we maximize profit by picking the item providing most PROFIT/WEIGHT. Why? Because items can be divided\nIn 0/1 Knapsack : we maximize profit by simply picking the item providing most profit. Since items cannot be divided, we don't think about calculating profit/weight as it makes no difference.\n\nThey both should fall under Greedy Algorithm.\nI'm just not able to understand where does concept of Dynamic Programming arrive.\n    ", "Answer": "\r\nGreedy algorithms are not about dividing the problem and solving it in parts.\nIt is in fact DP or backtracking. In Greedy we choose the best possible option that we have at the moment and pick that and compute for the rest. Best example for this is Dijkstra.\nIn 0/1 we don't know which item will give us the maximum weight, so we have to try all the items. In order to avoid computing the same input space again and again, we store the intermediate result and that's why it falls under DP.\nIn partial knapsack, we basically take the item which will give us the best weight at the moment, pick that and compute for the remaining of the weight.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How do I change this greedy algorithm to predict the most overall score?\r\n                \r\nHello, everyone, this is my first post here.\nSo today during my university class, our professor gave us a task to write an algorithm:\nWrite a function that returns the count for the amount of steps you need to make in order to get the most score in a board game:\nRules of the game:\n\nyou throw a dice and move accordingly (1-6 steps).\nthe amount of tiles on the board can range anywhere between 2 - 99 999.\nwhen you step on a tile you receive or lose points (the points on each tile vary from -99 999, to 99 999).\nif you are at the end of the board and your dice throw gets you out of it's boundaries, you don't move.\n\nMy approach\nIt's sort of a greedy algorithm:\n\ncount for each step if it's above or equal to 0,\nif it's negative, check for the next 6 tiles and move to the one with the highest score, to lose the least amount of points.\n\nI realized that my approach is wrong, after I imagined this example:\n\nSo imagine an array of {1, -40, -40, -40, -40, -1, -38, -40, -40, -40, -40, -40, 1}\nMy greedy algorithm starts at 1 and sees four -40's, one -38 and one -1. It chooses -1 because it's the best option, but now we will end up with a result of: 1 + (-1) + (-38) + 1 = -37, however if we choose -38 instead of -1, we would end up with: 1 + (-38) + 1 = -36.\nThis is just a simple example of what the problems could be, I imagine I'd have to check for every path possible, because greedy algorithms don't check for the best path out there, only the best applicable for some particular moment.\nI was wondering if a graph with all the possibilities could be an option here, but if we had an array of only negative numbers, then we would end up with a graph with maximum size of something around (99999^6?), which would result in taking up too much memory.\nI'm a newbie and I've ran out of ideas. Could anyone point me towards the right direction?\n    ", "Answer": "\r\nOh, wait! Greedy is possible here using a maximum heap.\nIdea:\nMax heap is a data structure which maintains the maximum element at the top of the structure. If we keep 6 values that could come up after the dice roll in maximum heap, we can get the maximum possible value that dice can roll.\nLet us consider your example array {1, -40, -40, -40, -40, -1, -38, -40, -40, -40, -40, -40, 1}.\nPush first six values that dice can roll in the max heap. So, max heap contains the elements {<1, 0>, <-40, 1>, <-40, 2>, <-40, 3>, <-40, 4>, <-1, 5>} (not in max heap order).\nHere ```\n<top of the max heap>.value```\n = 1 and ```\n<top of the max heap>.index```\n = 0.\nNow, max_score = 1.\nAfter popping the max heap and adding the next element from the array, max heap would contain following elements {<-40, 1>, <-40, 2>, <-40, 3>, <-40, 4>, <-1, 5>, <-38, 6>} (not in max heap order).\nSimilarly, you can work out for remaining elements in the input array using the below algorithm.\nAlgorithm:\n```\nmax_score, curr_index, steps = 0\nPush input_array[0..max(5, size_of_input_array - 1)] values in a max heap in the form <value, index in the array>\ni = 6\n\nwhile(max heap is not empty):\n    while(max heap is not empty and <top of the max heap>.index < curr_index):\n        pop the max heap\n    if(max heap is not empty):\n        max_score += <top of the max heap>.value\n        curr_index = <top of the max heap>.index\n        steps++\n        pop the max heap\n    if(i < size_of_input_array):\n        push the <input_array[i], i> into the max heap\n        i++\nreturn max_score, steps\n\nTime complexity: O(size_of_input_array * log(6)) => O(size_of_input_array)\nSpace complexity: O(6) => Constant\n```\n\nNot giving out the full working code as it is your assignment but the above algorithm is not less than code.\nYou can try with Depth First Search, Dynamic Programming as well. But the above greedy solution is asymptotically the most efficient approach.\nHope that helped you. I loved solving it. Thanks!\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "n-queen greedy algorithm python\r\n                \r\nHere is the code for a greedy queens on a chess table and I don't understand how it works:\n\n//here create the table\n\n```\ndef create_table(m,n):\nt=[]\none_line=[]\nfor i in range(0,m):\n    one_line.append(0)\nfor i in range(0,n):\n    t.append(one_line)\nreturn t\n```\n\n\n//here I ve lost in this loops. What's the purpose of cost and how to understand easily what's in here?\n\n```\ndef getPositionCost(t,pi,pj):\n\nn=len(t)\nm=len(t[0])\ncost=0\nfor i in range(0,len(t)):\n    for j in range(0,len(t[i])): \n        if pi==i and t[i][j]==0:\n            cost=cost+1\n        if pj==j and t[i][j]==0:\n            cost=cost+1\ni=pi\nj=pj\nwhile i>0 and j>0:\n    i=i-1\n    j=j-1\n    if t[i][j]==0:\n        cost=cost+1\ni=pi\nj=pj\nwhile i<n-1 and j<m-1:\n    i=i+1\n    j=j+1\n    if t[i][j]==0:\n        cost=cost+1\ni=pi\nj=pj\nwhile i>0 and j<m-1:\n    i=i-1\n    j=j+1\n    if t[i][j]==0:\n        cost=cost+1\ni=pi\nj=pj\nwhile i<n-1 and j>0:\n    i=i+1\n    j=j-1\n    if t[i][j]==0:\n        cost=cost+1\nreturn cost-1\n```\n\n\n//here puts the queens in table. But on which criteria?\n\n```\ndef putOnPosition(t,pi,pj):\nn=len(t)\nm=len(t[0])\nfor i in range(0,len(t)):\n    for j in range(0,len(t[i])): \n        if pi==i and t[i][j]==0:\n            t[i][j]=1\n        if pj==j and t[i][j]==0:\n            t[i][j]=1\ni=pi\nj=pj\nwhile i>0 and j>0:\n    i=i-1\n    j=j-1\n    if t[i][j]==0:\n        t[i][j]=1\ni=pi\nj=pj\nwhile i<n-1 and j<m-1:\n    i=i+1\n    j=j+1\n    if t[i][j]==0:\n        t[i][j]=1\ni=pi\nj=pj\nwhile i>0 and j<m-1:\n    i=i-1\n    j=j+1\n    if t[i][j]==0:\n        t[i][j]=1\ni=pi\nj=pj\nwhile i<n-1 and j>0:\n    i=i+1\n    j=j-1\n    if t[i][j]==0:\n        t[i][j]=1\nt[pi][pj]=\"X\"\nreturn\n\n\ndef getMinCostPosition(t):\nmin=-1\npi=-1\npj=-1\nfor i in range (0,len(t)):\n    for j in range(0,len(t[i])):\n        if t[i][j]==0:\n            cost=getPositionCost(t, i, j)\n            if min==-1:\n                min=cost\n                pi=i\n                pj=j\n            elif cost<min:\n                min=cost\n                pi=i\n                pj=j\nreturn pi,pj,min\n\n\ndef gbfs(m,n):\nqueens=0\ntable = [[0 for x in range(n)] for x in range(m)] \n#table=create_table(4,5)\nfor line in table:\n    print(line)\n\ni,j,mi=getMinCostPosition(table)\nwhile i!=-1:\n    i,j,mi=getMinCostPosition(table) \n    putOnPosition(table, i, j)\n    i,j,mi=getMinCostPosition(table) \nfor line in table:\n    print(line)\nfor i in range(0,len(table)):\n    if \"X\" in table[i]:\n        queens=queens+1\nprint(\"Maximum number of queens :\"+ str(queens))\nreturn queens\n```\n\n\nI want to understand the logic behind the code, I tried to take every step on paper but I've lost it. i don't understand what is the criteria such a queen is put on the table? And what cost means?\nIf I give a 3x3 table the output is:\n\n```\n ['X', 1, 1]\n [1, 1, 'X']\n [1, 1, 1]\n```\n\n\nAnd it's ok, but if I give 4x4:\n\n```\n['X', 1, 1, 1]\n[1, 1, 1, 'X']  \n[1, 'X', 1, 1]\n[1, 1, 1, 1]\n```\n\n\nWhy the queen wasn't put in the 2nd line, 3rd column? \n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm Optimization\r\n                \r\nConsider a DVR recorder that has the duty to record television programs. \nEach program has a starting time and ending time. \nThe DVR has the following restrictions:\n\n\nIt may only record up to two items at once.\nIf it chooses to record an item, it must record it from start to end.\n\n\nGiven the the number of television programs and their starting/ending times, what is the maximum number of programs the DVR can record?\n\nFor example: Consider 6 programs:\nThey are written in the form: \n\na  b  c. a is the program number, b is starting time, and c is ending time\n\n1 0 3\n\n2 6 7\n\n3 3 10\n\n4 1 5\n\n5 2 8\n\n6 1 9\n\nThe optimal way to record is have programs 1 and 3 recorded back to back, and programs 2 and 4 recorded back to back. 2 and 4 will be recording alongside 1 and 3.\nThis means the max number of programs is 4.\n\nWhat is an efficient algorithm to find the max number of programs that can be recorded?\n    ", "Answer": "\r\nThis is a classic example for a greedy algorithm.\n\nYou create an array with tuples  for each program in the input.\nNow you sort this array by the end times and start going from the left to the right. If you can take the very next program (you are recording at most one program already), you increment the result counter and remember the end-time. For another program again fill the available slot if possible, if not, you can't record it and can discard it.\n\nThis way you will get the maximum number of programs that can be recorded in O(nlogn) time.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm is returning quanities too large for small values, but not larger values\r\n                \r\nI'm writing a greedy algorithm (that has already caused me many headaches) that outputs the smallest number of coins that can be used for some monetary value, and I finally got code I was happy with, or so I thought. When inputting the value ```\n.41```\n, I'm returned ```\n4 coins```\n which is correct - however, the input ```\n.01```\n returns ```\n2 coins```\n and I have no idea why.\n\n```\n// declare variable change_owed, num_coins, and input globally\nfloat change_owed = 0;\nfloat dollars;\nint cents;\nint num_coins;\n\nint main(void)\n{\n    // makes sure the input is non-negative\n    do\n    {\n        dollars = get_float(\"Change owed:\\n\");\n        cents = round(dollars * 100);\n    }\n    while(cents <= 0);\n\n    // begin checking \n\n\n        while(cents - 25 >= 0) // quarters\n        {\n            num_coins++; // number of coins used, to be printed later, is incremented\n            cents = cents - 25; // coin is subtracted from total\n        }\n        while(cents - 10 >= 0) // dimes\n        {\n            num_coins++;\n            cents = cents >= 10;\n        }   \n        while(cents - 5 >= 0) // nickels\n        {\n            num_coins++;\n            cents = cents - 5;\n        } \n        while(cents >= 0) // pennies\n        {\n            num_coins++;\n            cents = cents - 1;\n        } \n\n    printf(\"%i coins\\n\", num_coins);\n}\n\n```\n\n    ", "Answer": "\r\nMain problem (off by one coin):\n\n```\nwhile(cents >= 0) // pennies\n```\n\n\nshould be\n\n```\nwhile (cents - 1 >= 0) // or even better: while (cents >= 1)\n```\n\n\n\n\nAlso, there is a typo:\n\n```\ncents = cents >= 10;\n```\n\n\nshould be\n\n```\ncents = cents - 10; // or even better: cents -= 10;\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm correctness\r\n                \r\nI'm trying to solve the following problem:\n\n\n  CEO is checking on it's employees at a constant times every day (for\n  an example the number of minutes after a shift started> {5, 35,\n  120..}). Calculate when should employees work, so that every time the CEO checks on them they are working. Their work takes 3 minutes to\n  complete and it increases by another 3 minutes every time they start\n  working again (First time it takes 3 minutes, second time it takes 6\n  minutes, third time it takes 9 minutes..).\n\n\nThis is my algorithm in pseudocode:\n\n```\nint time = 2\nfor: every CEOcheckTime in 0 to CEOcheckTime.length\n    add (CEOcheckTimes-time) to results\n    time = time + 2\n```\n\n\nIgnoring the edge case, where the CEO checks on employees sooner that they can finish the work, is my algorithm correct? Thanks!\n    ", "Answer": "\r\nIgnoring the 'edge case' this seems fine except your time is being incremented by 2 rather than 3 as per the spec.\n\n```\n int time = 3\n for: every CEOcheckTime in CEOcheckTimes\n     add (CEOcheckTimes-time) to results\n     time = time + 3\n```\n\n\na similar just in time approach could be used here that would account for your edge case too.\n\n```\nfor: every CEOcheckTime in CEOcheckTimes\n    if exists(time):\n        if last(results) + time < CEOcheckTime:\n            add (CEOcheckTimes) to results\n            time = time + 3\n    else:\n         add (CEOcheckTimes) to results\n         time = 3\n```\n\n\nedit: i have assumed that if work starts / ends at the same time as a check that this counts as working.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to prove this greedy algorithm as optimal?\r\n                \r\nThe problem sounds like this: we get n-cubes. Each cube has a length (the edge's length) and a colour. The edges' lengths are distinct, but the culours are not, for instance: any two cubes can never have the same length, but it is possible to have the same colour. The colours are from 1 to p (p is given).\n\nWe have to build a cube-tower that has a maximum height, following these rules:\n\n1) a cube cannot be placed upon a cube if they have the same colour;\n\n2) a cube cannot pe placed upon a cube whose edge's length is smaller.\n\ne.g: cube c1 has a length of 3, cube c2 has a length of 5. cube c1 can be placed on the top of c2, but cube c2 cannot be placed on the top of c1.\n\nAlright, so the algorithm I came up with in order to solve this problem is this: \n\n\nwe sort the cubes by edge length, in descending order and we put them in an array;\nwe add the first cube in the array to the Tower;\nwe save the length of the last inserted cube( in this case, the first cube's length ) in variable l;\nwe save the colour of the last inserted cube( in this case, the first cube's colour ) in variable c;\nwe go through the rest of the array, inserting the first cube whose length is smaller than l and colour different than c and then we repeat 3-4-5;\n\n\nNow what I'm having difficulties with is, how do I prove this greedy algorithm to be the optimal one? I guess that the proof has to somehow look like the ones here: http://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/04GreedyAlgorithmsI-2x2.pdf\n    ", "Answer": "\r\nThe question is:\n\n\nIs there a case where picking the max-length cube is not optimal?\n\n\nAt each decision-node we have to decide if we pick a or b, given a>b:\n\nAssume picking b is strictly optimal (implies max-height):\n\n\nCase 1: ```\ncol(a) == col(b)```\n\n```\nb optimal => final tower: b, x0, x1, ...```\n\nbut also valid by construction with equal height: ```\na, x0, x1, ...```\n\nvalid because: ```\ncol(a) == col(b)```\n, ```\n(a > b) & (b > x0) => (a > x0)```\n (transitivity)\ncontradiction!\nCase 2 ```\ncol(a) != col(b)```\n\n```\nb optimal -> final tower: b, x0, x1, ...```\n\nbut also valid construction with more height: ```\na, b, x0, x1, ...```\n\nvalid because: ```\n(a > b) & (col(a) != col(b)) => a before b```\n\ncontradiction!\n\n\nWe assumed picking b is strictly optimal and showed contradictions. Picking b can only be equally good or worse than picking a (the max-length cube of the remaining ones).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Coin Change Greedy Algorithm Not Passing Test Case\r\n                \r\nI'm trying to solve the coin change problem where you use the fewest amounts of coins possible to make an amount. I'm trying to use the Greedy Approach - my algorithm sorts the coins array, starts with the biggest coin and uses it as many times as possible before moving on the next coin that will divide the remainder.\nThis worked for the initial test case:\ncoins = [1,2,5], amount = 11\nBut failed for this one:\ncoins = [186,419,83,408], amount = 6249\nI'm not sure why it's failing, I'm still trying to grasp the greedy approach. Would really appreciate any feedback!\n```\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        int count = 0;\n        \n        if(coins.length == 1 && amount % coins[0] != 0) {\n            return -1;\n        }\n\n        Arrays.sort(coins);\n        \n        int i = coins.length - 1;\n        while(amount >= 0 && i >= 0) {\n             if(coins[i] <= amount) {\n                int remainder = amount / coins[i];\n                    count = count + remainder;\n                    amount -= (remainder * coins[i]);\n            }\n            i--;\n        }\n    \n        return count;\n    }\n}\n```\n\n    ", "Answer": "\r\nGreedy approach to coin change problem doesn't work on the general case (arbitrary coin values).\nExample:\n```\nCoins = [2, 3, 6, 7]```\n and ```\nAmount = 12```\n,\nGreedy takes ```\n[2, 3, 7]```\n and the optimal choice is ```\n[6, 6]```\n.\nYou need to use the dynamic programming approach to have the optimal value.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to solve 0/1 knapsack by greedy algorithm and only focus on benefit?\r\n                \r\nI need to write C++ to solve 0/1 knapsack problem by greedy algorithm. Because it is a NP complete problem so we can only find the nearest solution.I have already finished it by ratio(value/weight), but dont know how to turn Benefit focus only(choose one by one only by value) to code.\n\n    ", "Answer": "\r\nGreedy method for Benefit only denotes that you get items with the largest value until weight sum reaches knapsack capacity.\n\nSo just sort items by value and sum both values and weights in parallel.\n\nNote that this problem is simpler than one with B/W ratio\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithms. How to solve this problem?\r\n                \r\nSuppose you are given two sets A and B, each containing n positive integers. You can choose to reorder each set however you like. After reordering let ai be the i-th element of set A, and let bi be the i-th element of set B. You then receive a payoff of (a1 ^ b1) × (a2 ^ b2) × ... × (an ^  bn). Give a polynomial algorithm that will maximize the payoff.\n\nAnswer:\nI think if we sort both sets increasingly, the problem will solve. It needs o(nlog(n)) time. \nDoes anyone have a counterexample?\n    ", "Answer": "\r\nIt's straightforward to prove that the greedy algorithm - i.e. pair the largest number with the largest exponent, then the next-largest number with the next-largest exponent, and so on - is optimal.\n\nSuppose the product includes two terms ```\na[i] ** b[i]```\n and ```\na[j] ** b[j]```\n, where ```\na[i] < a[j]```\n and ```\nb[i] > b[j]```\n. It follows that ```\n(a[i] ** b[j]) * (a[j] ** b[i])```\n is greater than ```\n(a[i] ** b[i]) * (a[j] ** b[j])```\n because they differ by a factor of ```\n(a[j] / a[i]) ** (b[i] - b[j])```\n, which by assumption is a number greater than 1 to the power of a number greater than 0, so this factor is greater than 1. Therefore, we can improve the payoff by swapping ```\nb[i]```\n with ```\nb[j]```\n, and hence the original payout was not optimal because it could be improved upon by making the swap.\n\nIt follows that your greedy algorithm is correct in the sense that it does indeed maximise the payoff.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Complexity of a greedy assignment algorithm\r\n                \r\nThe assignment problem asks to find a set of ```\nn```\n elements with maximal possible sum in distinct rows and columns of a given n-by-n matrix. It can be solved optimally by the Hungarian algorithm in O(n^3). However, let us consider the following suboptimal greedy algorithm:\n\n\nChoose the maximal element in the remaining matrix\nAdd this element to the resulting set, i.e. match the row of this element to its column, and remove these row and column from the matrix\nRepeat from the step 1.\n\n\nWhat would be an efficient data structure to implement such an algorithm? Can its time complexity be O(n^2), if it requires O(n^2 log(n)) only to sort all the elements?\n    ", "Answer": "\r\nA complexity of O(n2logn) may be achieved using something as follows.\n\nYou initially store a sorted version of each of n rows and columns.(the exact structure this stored rows and columns will use is clarified later in this answer) Note that, even though you will sort these according to the values of the cells, the values of the cells should be stored alongside their initial indices. The initial indices will help when deleting rows and columns. (step 2 of your algorithm)\n\nAfter the preprocessing mentioned above, have a loop that iterates n times. Inside this loop will be the steps of your algorithm. At each iteration;\n\nStep 1: Check the largest elements in each sorted row and column, updating the value and address for the globally maximal element.\n\nStep 2.1: Add element to the resulting array/list/etc, and remove it from the sorted row and column structure of the corresponding row and column.\n\nStep 2.2: Traverse each sorted row structure. For each row, we need to delete a column. Since we have the matrix and the address of the maximal element, we can also access the exact value and address of the column we are deleting for each row. Utilizing this, in each sorted row structure, given it is sorted, conduct a binary search to find that element, and remove it.\n\nHere is the thing! If you store this sorted row structure as a straightforward array, removing this element will take O(n) time, as you have to carry the remaining part of the array to the left by 1. A solution I can think of is to use a structure akin to STL's set. It can, in fact, find in O(logn) just like binary search, and provides O(logn) time insertion and deletion.\n\nStep 2.3: Identical to Step 2.2, this time each column structure is traversed. As we are deleting a row, we are removing an element from each column. However, thanks to having found the address(i.e. row&column) and the value of the globally maximal element, we know which row we are removing and the value and address of the element we remove from each column. So, for each column structure we find and remove that element from the STL's set-like data structure storing the sorted version of that column.\n\nPerformance\n\nPreprocessing: Now that we know what kind of a data structure stores sorted rows and columns, we can say that it takes O(n2logn) as there are 2n of those structures, and we insert n elements to each one of them in O(logn) time.\n\nStep 1: There are 2n sorted structures, which means accessing their largest element in O(logn) time will have a combined O(nlogn) time complexity.\n\nStep 2.1: Though it depends on the data structure the resulting data is kept in, assuming it is an array, it takes O(1) time to add an element to it. However this step has an overall complexity of O(logn) as we need to remove the maximal element from the sorted row and column structures it belongs to.\n\nStep 2.2: There are n sorted row structures for which we do a find and remove operation, causing an O(nlogn) burden.\n\nStep 2.3: Has O(nlogn) cost, same as Step 2.2.\n\nConsidering steps 2.1, 2.2, and 2.3 are done n times, the overall complexity of the algorithm is O(n2logn).\n\nImplementation\n\nBelow you may find a complete implementation of the algorithm I mentioned above, which seems to be working. The gist of the algorithm is the same, with minor changes due to implementation like defining a negative infinity or using an extra bool vector to store whether a row or column is completely deleted.(i.e. we won't bother to look at its sorted structure when looking for the maximal element in remaining matrix)\n\n```\n#include <set>\n#include <vector>\n#include <iostream>\n#define NEGATIVE_INFINITY -1\n\nusing namespace std;\n\nvector< set< pair<int, int> > > sortedRows;\nvector< set< pair<int, int> > > sortedCols;\nvector< int > result;\nvoid solve(const vector< vector< int > > &matrix)\n{\n    int n = matrix.size();\n    vector<bool> rowNotDeleted(n, true), colNotDeleted(n, true);\n\n    // Preprocessing\n    for(int i=0; i < n; ++i)\n    {\n        sortedRows.resize(n);\n        sortedCols.resize(n);\n        for(int j=0; j < n; ++j)\n        {\n            sortedRows[i].insert( make_pair(matrix[i][j], j) );\n            sortedCols[j].insert( make_pair(matrix[i][j], i) );\n        }\n    }\n\n    for(int k=0; k < n; ++k)\n    {\n        set< pair<int, int> >::reverse_iterator it;\n\n        // STEP 1: Find max. element\n        int maxVal = NEGATIVE_INFINITY, maxRow = -1, maxCol = -1;\n        for(int i=0; i < n; ++i)\n        {\n            if(rowNotDeleted[i])\n            {\n                it = sortedRows[i].rbegin();\n                if(it->first > maxVal)\n                {\n                    maxVal = it->first;\n                    maxRow = i;\n                    maxCol = it->second;\n                }\n            }\n        }\n\n        for(int i=0; i < n; ++i)\n        {\n            if(colNotDeleted[i])\n            {\n                it = sortedCols[i].rbegin();\n                if(it->first > maxVal)\n                {\n                    maxVal = it->first;\n                    maxRow = it->second;\n                    maxCol = i;\n                }\n            }\n        }\n\n        // STEP 2.1: Add max. element to result.\n        result.push_back(maxVal);\n        /*\n         * Due to my implementation, removing it from\n         * relevant sorted data structures can be done\n         * in steps 2.2 and 2.3.\n         */\n//        sortedRows[maxRow].erase( make_pair(maxVal, maxCol) );\n//        sortedCols[maxCol].erase( make_pair(maxVal, maxRow) );\n        rowNotDeleted[maxRow] = false;\n        colNotDeleted[maxCol] = false;\n\n        // STEP 2.2: Remove cells of deleted col from sorted row structures\n        for(int i=0; i < n; ++i)\n        {\n            sortedRows[i].erase( make_pair(matrix[i][maxCol], maxCol) );\n        }\n\n        // STEP 2.3: Remove cells of deleted row from sorted col structures\n        for(int i=0; i < n; ++i)\n        {\n            sortedCols[i].erase( make_pair(matrix[maxRow][i], maxRow) );\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    // Read matrix\n    vector< vector< int > > matrix(n);\n    for(int i=0; i < n; ++i)\n    {\n        matrix[i].resize(n);\n        for(int j=0; j < n; ++j)\n        {\n            cin >> matrix[i][j];\n        }\n    }\n\n    solve(matrix);\n\n    // Output results\n    cout << result[0];\n    for(int i=1; i < n; ++i)\n    {\n        cout << \" \" << result[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Not able to understand one Top Coder entry on Greedy Algorithms\r\n                \r\nI am actually practicing Greedy Algorithms and There is a problem on topcoder.. So need some help....\nThe problem is about Robust Computer System.. http://www.topcoder.com/stat?c=problem_statement&pm=2235&rd=5070\nI don't understand what is MFC. (Maximum Failure Count)?\nIf somebody can put light on the explanation of MFC with simple example then that would be help!!\nThanks..\nIn case you don't have an account, and can't follow the link, here's the question:\n\nIn a robust computer system, one of the most important pieces is the cooling. Without proper cooling, processors can heat up to over 400 degrees C. The reliability of a system can be measured by determining how many fans can fail without risking the system processor. Each fan can be assigned a value indicating how much capacity it has to cool the system, and we can define a minimum cooling capacity, which the sum of the fan capacities must exceed to properly cool the system. We define a Failure Set as a set of fans which are not necessary to cool the system. In other words, if the fans in a Failure Set break, the system can still be properly cooled by the remaining fans. The count of a Failure Set is the number of fans in the set.\nTo measure the reliability, we will define two values, the Maximum Failure Set (MFS) and the Maximum Failure Count (MFC). A MFS is a Failure Set of fans with the largest count possible. A set of fans may have more than one MFS (see below). A Failure Set is an MFS if and only if there are no Failure Sets with a higher count. The MFC is the largest value such that all fan sets with count <= MFC are Failure Sets. In other words, any set of fans of size MFC or less can fail, and the system will still be properly cooled by the remaining fans.\nConsider the fan set with capacities 1, 2, 3, and a cooling requirement of 2. Two MFSs with a count of 2 exist: fans 1 and 3, or fans 1 and 2. However, the MFC is not 2 because fans 2 and 3 is not a Failure set (fan 1 could not cool the system properly by itself). Thus, the MFC is 1, because if any single fan fails, the system can still be cooled.\nYou will be given a int[] capacities, which designates how many units of cooling each fan provides, and an int minCooling, which designates the minimum units of cooling required to cool the system. Your method should return a int[], where the first value should be the number of fans in the Maximum Failure Set (MFS), and the second value should be the Maximum Failure Count (MFC).\n\n    ", "Answer": "\r\n\nWe define a Failure Set as a set of fans which are not necessary to cool the system. In other words, if the fans in a Failure Set break, the system can still be properly cooled by the remaining fans. The count of a Failure Set is the number of fans in the set.\nA Failure Set is an MFS if and only if there are no Failure Sets with a higher count.\n\nIt's all in the problem statement. What's not clear?\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Infinite loop in Basic Greedy Algorithm for TSP\r\n                \r\nI am trying to implement basic greedy algorithm for Travelling Salesman Problem in Python 2.7.\n\nI have a dictionary called d_dict = {(city1,city2):distance} that stores distances between cities. Here, all cities are connected to one another. I simply need to get to the closest neighbour till all cities are covered and then head back to the start city. Here, for convenience, the start city is 1, i.e. st = 1. There are two lists, rem, that stores uncovered cities and cov, that stores cities in the order they are covered. \n\nI have defined a function called basic_greedy(x) that takes city x as start city, computes its distance to all uncovered cities (since every city is connected to every city in this case) in list rem, and then the nearest neighbour is removed from rem, appended to cov and made the next start city. This function is called iteratively till rem becomes an empty list (i.e. all cities are covered). The start city (or root) is simply appended at last to cov. Here is my code:\n\n```\n#create two lists - 'covered' or 'cov': to store cities as they are covered in order.\n#'remaining' or 'rem': list of uncovered cities.\n\ncov = []\nrem = [ x for x in range(1,size+1)]\n\nglobal st\nst = 1 #start city, initialized as 1\nroot =  st     #root of the graph - start of the tour\n\n\n#######################################\n#basic greedy search\n\n#function definition - basic greedy search algorithm for the travelling salesman problem\n\ndef basic_greedy(x):\n\n    #rem.remove(x)\n\n    try:\n        r = rem.index(x)\n        del rem[r]\n    except:\n        pass\n\n    cov.append(x)\n    print (cov,rem)\n\n    m=1\n    chg = 0  #a temporary variable, counts number of changes in value of st\n    if x < size:\n        m = d_dict[(x,x+1)] #variable m shall keep track of the smallest distance\n    elif x == size:\n        m = d_dict[(x,x-1)]\n\n    for k in rem:\n        if d_dict[(x,k)] < m:\n            m = d_dict[(x,k)]\n            st = k\n\n\n########################################\n\nwhile len(rem)!= 0:\n    basic_greedy(st)\n\ncov.append(root)\nprint \"Basic Greedy Search Tour: \",cov  #THE FINAL SEQUENCE\n```\n\n\nHowever, when I run this, I get an infinite loop, that is just 1's appended infinitely. What is the error in the code? \n\n(P.S. I have tried multiple ways yet have been unable to spot the error for days)\n\nedit: Here is the dictionary for 12 cities:\n\n```\n(1, 1) : 0 ,\n(1, 2) : 32 ,\n(1, 3) : 7 ,\n(1, 4) : 13 ,\n(1, 5) : 15 ,\n(1, 6) : 21 ,\n(1, 7) : 5 ,\n(1, 8) : 30 ,\n(1, 9) : 40 ,\n(1, 10) : 31 ,\n(1, 11) : 9 ,\n(1, 12) : 14 ,\n(2, 1) : 32 ,\n(2, 2) : 0 ,\n(2, 3) : 40 ,\n(2, 4) : 21 ,\n(2, 5) : 3 ,\n(2, 6) : 8 ,\n(2, 7) : 32 ,\n(2, 8) : 25 ,\n(2, 9) : 3 ,\n(2, 10) : 5 ,\n(2, 11) : 16 ,\n(2, 12) : 10 ,\n(3, 1) : 7 ,\n(3, 2) : 40 ,\n(3, 3) : 0 ,\n(3, 4) : 5 ,\n(3, 5) : 9 ,\n(3, 6) : 12 ,\n(3, 7) : 12 ,\n(3, 8) : 20 ,\n(3, 9) : 30 ,\n(3, 10) : 50 ,\n(3, 11) : 21 ,\n(3, 12) : 31 ,\n(4, 1) : 13 ,\n(4, 2) : 21 ,\n(4, 3) : 5 ,\n(4, 4) : 0 ,\n(4, 5) : 9 ,\n(4, 6) : 11 ,\n(4, 7) : 20 ,\n(4, 8) : 6 ,\n(4, 9) : 29 ,\n(4, 10) : 27 ,\n(4, 11) : 25 ,\n(4, 12) : 35 ,\n(5, 1) : 15 ,\n(5, 2) : 3 ,\n(5, 3) : 9 ,\n(5, 4) : 9 ,\n(5, 5) : 0 ,\n(5, 6) : 4 ,\n(5, 7) : 30 ,\n(5, 8) : 10 ,\n(5, 9) : 6 ,\n(5, 10) : 8 ,\n(5, 11) : 15 ,\n(5, 12) : 9 ,\n(6, 1) : 21 ,\n(6, 2) : 8 ,\n(6, 3) : 12 ,\n(6, 4) : 11 ,\n(6, 5) : 4 ,\n(6, 6) : 0 ,\n(6, 7) : 35 ,\n(6, 8) : 7 ,\n(6, 9) : 8 ,\n(6, 10) : 17 ,\n(6, 11) : 14 ,\n(6, 12) : 13 ,\n(7, 1) : 5 ,\n(7, 2) : 32 ,\n(7, 3) : 12 ,\n(7, 4) : 20 ,\n(7, 5) : 30 ,\n(7, 6) : 35 ,\n(7, 7) : 0 ,\n(7, 8) : 50 ,\n(7, 9) : 53 ,\n(7, 10) : 30 ,\n(7, 11) : 6 ,\n(7, 12) : 10 ,\n(8, 1) : 30 ,\n(8, 2) : 25 ,\n(8, 3) : 20 ,\n(8, 4) : 6 ,\n(8, 5) : 10 ,\n(8, 6) : 7 ,\n(8, 7) : 50 ,\n(8, 8) : 0 ,\n(8, 9) : 20 ,\n(8, 10) : 40 ,\n(8, 11) : 32 ,\n(8, 12) : 34 ,\n(9, 1) : 40 ,\n(9, 2) : 3 ,\n(9, 3) : 30 ,\n(9, 4) : 29 ,\n(9, 5) : 6 ,\n(9, 6) : 8 ,\n(9, 7) : 53 ,\n(9, 8) : 20 ,\n(9, 9) : 0 ,\n(9, 10) : 2 ,\n(9, 11) : 15 ,\n(9, 12) : 7 ,\n(10, 1) : 31 ,\n(10, 2) : 5 ,\n(10, 3) : 50 ,\n(10, 4) : 27 ,\n(10, 5) : 8 ,\n(10, 6) : 17 ,\n(10, 7) : 30 ,\n(10, 8) : 40 ,\n(10, 9) : 2 ,\n(10, 10) : 0 ,\n(10, 11) : 15 ,\n(10, 12) : 4 ,\n(11, 1) : 9 ,\n(11, 2) : 16 ,\n(11, 3) : 21 ,\n(11, 4) : 25 ,\n(11, 5) : 15 ,\n(11, 6) : 14 ,\n(11, 7) : 6 ,\n(11, 8) : 32 ,\n(11, 9) : 15 ,\n(11, 10) : 15 ,\n(11, 11) : 0 ,\n(11, 12) : 4 ,\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Find a greedy algorithm to balance success rate and cost\r\n                \r\n\n\nHi! I'm trying to solve a problem like this. A task contains more than one alternative nodes. They will be executed in parallel. Every node has a success rate and a cost. The success rate can be increase by executing this task on multiply devices (The success rate that at least one device gets the result will increase by 1-(1-S)^N).\n\nThe goal of the task is to get result from any of these nodes. Once one node is successfully executed, others will stop. The problem is, how to define an algorithm that satisfy the overall success rate threshold that at least one node succeed and has the lowest cost.\n\nI think this should be a greedy algorithm with 3 variables: number of devices, success rate and cost. I don't know how to compare the ratio of success rate and the cost. Can anyone help me please? We can assume the threshold of overall success rate is 90%.\n    ", "Answer": "\r\nYou want to use an algorithm similar to fractional knapsack, but with a twist:\n\nFirst, temporarily set any success rates of nodes with a success rate higher than the boundary to the value of the boundary.\nFor example, if the boundary was 90% and Node C was (100%, $5), Node C would become (90% success rate, $5).\n\nThis is because you are looking for the minimum cost to meet a boundary. So for example if your boundary is 50%, you would still want to choose the node with (50% success rate, $5) over a node with (100% success rate, $6). So your node with 100% success rate might as well be 50% success rate\n\nThen, sort the nodes by ascending success rate / cost. \n\nEach step of the algorithm would be to add the node with the lowest success rate / cost to your solution list of nodes until the total success rate of the nodes reaches the boundary. However, an added step would be if the added node creates a total success rate greater than the boundary, you would have to go through your solution list of nodes from the greatest success rate / cost to the lowest and see if removing that node will still maintain reaching the percent boundary. You would continue removing possible nodes until no nodes can be removed and the boundary is still satisfied. \n\nFor example: if your list had nodes as added in order:\n\n(20%, $2), (30%, $1), (40%, .5$) and the boundary was 70%,\n\nthe total percent is 90% at the moment which is greater than 70%. \nSince node (40%, .5$) was just added, you look at node (30%, $1) only to find it cannot be removed because then the boundary would be 60% which is less than the boundary.\nThen you look at the next node (20%, $2) which can be removed since the remaining total percent would be 70% which meets the required boundary. You would keep going down the line, but in this example, the newly altered (30%, $1), (40%, .5$) would be valid as the solution. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Should I expect to have exactly same match everytime I run the match with greedy algorithm?\r\n                \r\nI'm using greedy algorithm or local algorithm to match propensity score in two groups. I will end up with same number of matches every time but sometimes it doesn't match exactly same with last time. Is this normal?\n    ", "Answer": "\r\n\"Greedy\" doesn't necessarily mean \"deterministic,\" in particular if you have two choices with equal weight/value then it may be possible to first select one choice during one algorithm execution and to first select the other choice on another algorithm execution.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm in Python\r\n                \r\nI want c in plunder(aList, c) to equal 0. \n\n```\nList = [('Gold', 10, 500), ('Silver', 5, 200), ('Diamond', 2, 2000), ('Platinum', 20, 1000)]\naList = sorted(List, key =  lambda x : x[2]) # sort the list above\n```\n\n\nGives me the sorted list based on the 3rd value of each tuple. So I get:\n\n```\n[('Silver', 5, 200), ('Gold', 10, 500), ('Platinum', 20, 1000), ('Diamond', 2, 2000)]\n```\n\n\nI am trying to get the plunder(aList, c) to keep subtracting the middle values of each tuple (2, 20, 10, 5) from c until c = 0. \n\nHere is my code: \n\n```\nList = [('Gold', 10, 500), ('Silver', 5, 200), ('Diamond', 2, 2000), ('Platinum', 20, 1000)]\naList = sorted(List, key =  lambda x : x[2]) # sort the list above\n\ndef plunder(aList, c):\n    aList[-1] = list(aList[-1])\n    i = aList[-1]\n    r = 0\n    if c > 0 and i[1] != 0:\n        c -= 1\n        i[1] -=1\n        r += 1\n        return plunder(aList, c-r)\n    elif c == 0:\n        pass\n        print('Done')\n    else:\n        return plunder(aList[:-1], c-r)\n\nplunder(aList, 10)\n```\n\n\nBut when I run it, it prints done and the new list is:\n\n```\n[('Silver', 5, 200), ('Gold', 10, 500), ('Platinum', 20, 1000), ['Diamond', 0, 2000]]\n```\n\n\nand also when I type c in the python shell, it tells me that c is not defined. How could I fix these issues?\n\nSo if the c value is 10. My expected output would be:\n\n```\n[('Silver', 5, 200), ('Gold', 10, 500), ['Platinum', 12, 1000], ['Diamond', 0, 2000]]\n```\n\n\nI subtracted as many diamonds as I could from the 10 (10 - 2 = 8) so 0 diamonds were left. Then I subtracted 8 from 20 platinums and the weight of the platinums changed to 12 (since I took 8 platinums. And now my c ('capacity') is 0. 2 diamonds + 8 platinums = 10 (which was my c).\n    ", "Answer": "\r\nThe main problem is that you are relying on Python's pass by reference for lists to modify the list in place. \nThat works fine initially, but when you reach \n\n```\nplunder(aList[:-1], c-r)\n```\n\n\nPython creates a copy of the list and proceeds to modify that copy. Thus your original list remains unchanged after Diamonds are exhausted (you hit the ```\nelse```\n part).\n\nNote that you can see this behaviour in your printed ```\naList```\n as only last entry is a ```\nlist```\n and all other are tuples. \n\n```\n[\n ('Silver', 5, 200), \n ('Gold', 10, 500), \n ('Platinum', 20, 1000), \n ['Diamond', 0, 2000]   #Only list\n]\n```\n\n\nIf you add a ```\nprint alist[-1]```\n statement to the function, you can see it even more clearly.\n\n```\n['Diamond', 2, 2000]\n['Diamond', 1, 2000]\n['Diamond', 0, 2000]\n['Platinum', 20, 1000]\n['Platinum', 19, 1000]\n['Platinum', 18, 1000]\n['Platinum', 17, 1000]\n['Platinum', 16, 1000]\n['Platinum', 15, 1000]\n['Platinum', 14, 1000]\n['Platinum', 13, 1000]\n['Platinum', 12, 1000]\n```\n\n\nSo your algorithm does work but as you have no way of keeping the result, it does not (fully) affect your original list.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm: Interval coloring\r\n                \r\nIn interval scheduling, the algorithm is to pick the earliest finish time. But in interval colouring the former does not work. Is there an example or explanation on why picking earliest finish time won't work for interval colouring? \n\nThe interval colouring problem is:  given  a  set  of  intervals,  we  want  to  colour\nall  intervals  so  that  intervals  given  the  same  colour  do  not  intersect  and  the goal  is  to  try  to  minimize  the  number  of  colours  used. This can be thought of as the interval partitioning problem (if it makes more sense)\n\nThe interval scheduling problem that i'm referring to is: If you go to a theme park and there are many shows, the start and finish time of each show is an interval, and you are the resource. You want to attend as many shows as possible.\n    ", "Answer": "\r\nThis is just a case of playing around with pictures until you find an example.  The first picture I drew that showed the problem had the following partitioning:\n\n```\nA: (0, 2) (3, 7)\nB: (1, 4) (5, 6)\n```\n\n\nAs a picture that looks like this:\n\n```\n-- ----\n --- -\n```\n\n\nBut looking for the earliest stop time rule produces the following coloring:\n\n```\nA: (0, 2) (5, 6)\nB: (1, 4)\nC: (3, 7)\n```\n\n\nWhich is this partitioning:\n\n```\n--   -\n ---\n   ----\n```\n\n\nSo this greedy rule fails to be optimal on this example.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to Implement Max Heaps and Item Class To Create Greedy Algorithm?\r\n                \r\n```\npublic class MaxHeap {\n\n    class Item{\nprivate double weight;\nprivate int value;\nprivate int ID;\nprivate double factor;\n\npublic Item(double weight, int value, int id, double factor){\nthis.weight = weight;\nthis.value = value;\nthis.ID = id;\nthis.factor = factor;\n}\n\npublic double getWeight() {\nreturn weight;\n}\n\npublic void setWeight(double weight) {\nthis.weight = weight;\n}\n\npublic int getValue() {\nreturn value;\n}\n\npublic void setValue(int value) {\nthis.value = value;\n}\n\npublic int getID() {\nreturn ID;\n}\n\npublic void setID(int ID) {\nthis.ID = ID;\n}\n\npublic double getFactor() {\nreturn factor;\n}\n\npublic void setFactor(double factor) {\nthis.factor = factor;\n}\n}\n \n\n  private int[] Heap;\n    private int size;\n    private int maxsize;\n \n    // Constructor to initialize an\n    // empty max heap with given maximum\n    // capacity\n    public MaxHeap(int maxsize)\n    {\n        // This keyword refers to current instance itself\n        this.maxsize = maxsize;\n        this.size = 0;\n        Heap = new int[this.maxsize];\n    }\n \n    // Method 1\n    // Returning position of parent\n    private int parent(int pos) { return (pos - 1) / 2; }\n \n    // Method 2\n    // Returning left children\n    private int leftChild(int pos) { return (2 * pos) + 1; }\n \n    // Method 3\n    // Returning right children\n    private int rightChild(int pos){ return (2 * pos) + 2; }\n \n    // Method 4\n    // Returning true of given node is leaf\n    private boolean isLeaf(int pos)\n    {\n        if (pos > (size / 2) && pos <= size) {\n            return true;\n        }\n        return false;\n    }\n \n    // Method 5\n    // Swapping nodes\n    private void swap(int fpos, int spos)\n    {\n        int tmp;\n        tmp = Heap[fpos];\n        Heap[fpos] = Heap[spos];\n        Heap[spos] = tmp;\n    }\n \n    // Method 6\n    // Recursive function to max heapify given subtree\n    private void maxHeapify(int pos)\n    {\n        if (isLeaf(pos))\n            return;\n \n        if (Heap[pos] < Heap[leftChild(pos)]\n            || Heap[pos] < Heap[rightChild(pos)]) {\n \n            if (Heap[leftChild(pos)]\n                > Heap[rightChild(pos)]) {\n                swap(pos, leftChild(pos));\n                maxHeapify(leftChild(pos));\n            }\n            else {\n                swap(pos, rightChild(pos));\n                maxHeapify(rightChild(pos));\n            }\n        }\n    }\n \n    // Method 7\n    // Inserts a new element to max heap\n    public void insert(double weight, int value, int id)\n    {\n        Heap[size] = value;\n \n        // Traverse up and fix violated property\n        int current = size;\n        while (Heap[current] > Heap[parent(current)]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n \n    // Method 8\n    // To display heap\n   \n \n\n    public int extractMax()\n    {\n        int popped = Heap[0];\n        Heap[0] = Heap[size--];\n        maxHeapify(0);\n        return popped;\n    }\n    \n \n\n    public static void main(String[] arg)\n    {\n\n \n        MaxHeap maxHeap = new MaxHeap(67);\n \n        // Inserting nodes\n        // Custom inputs\n        maxHeap.insert(23,505,0);\n        maxHeap.insert(26,352,1);\n        maxHeap.insert(20,458,2);\n        maxHeap.insert(18,220,3);\n        maxHeap.insert(32,354,4);\n        maxHeap.insert(27,414,5);\n        maxHeap.insert(29,498,6);\n        maxHeap.insert(26,545,7);\n        maxHeap.insert(30,473,8);\n        maxHeap.insert(27,543,9);\n       \n        maxHeap.print();\n \n        \n        System.out.println(\"The max val is \"\n                           + maxHeap.extractMax());\n    }\n}\n\n\n\n\n    public static void main(String[] args) {\n        // TODO code application logic here\n    }\n    \n}\n```\n\nI was tasked with trying to create a max heap and and item class and implement the two in solving a basic knapsack problem. I have been playing around with it and I cannot figure out how I can use my max heap class and item class in order to create a greedy algorithm. Any help is appreciated. I am also not sure how necessary the \"knapsack\" class is as I had just taken that from geeksforgeeks and was trying to take bits and pieces and implement it into mine. Apologies if this is too much code.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How can I create a greedy algorithm for this \"balls and boxes\" knapsack-like problem?\r\n                \r\nSay that there are n balls, each with weight at most 1. We can assume that the weights of these balls are put in an array W[1..n] with 0 <= W[i] <= 1 for all i. The problem is to put these balls in a minimum number of boxes so that each box contains no more than two balls, and the total weight of the balls placed in each box is <= 1.\nI am to design an efficient greedy algorithm for this. I presume that one obvious choice (pick the largest first and the smallest second) is not correct. But what if I picked the largest available ball first, and then the largest remaining that fits second? I think this is right, but I'm not sure how to prove this. Doing this would produce a trivial O(n^2) algorithm.\nThis also seems like some kind of variant on the knapsack problem, but there the greedy algorithm is not optimal.\n    ", "Answer": "\r\nThe usual proof template for greedy algorithms is to show that the algorithm's first k choices can be extended to an optimal solution, for all k ≥ 0 by induction on k. As it turns out, both of your ideas are correct, as is every greedy algorithm that repeatedly puts the largest remaining ball in a box together with (if possible) any ball that will go with it.\nThe base case of the induction, k = 0, is trivial. For the step, consider an optimal solution that agrees with the greedy solution for the first k−1 boxes. Let B be the heaviest ball not in the first k−1 boxes. Greedy packs B in box #k. Consider the possibilities.\n\nIf box #k appears in the optimal solution, then the latter fulfills the condition required for induction.\n\nIf the greedy solution has B in a box by itself, then B does not fit with any remaining ball, so the optimal solution also has B by itself, and the first k decisions agree.\n\nIf greedy has B with another ball but optimal has B alone, then we can modify the optimal solution by moving the other ball to B's box. This new solution is also optimal and fulfills the condition required for induction.\n\nIf greedy and optimal have B with different balls, then we can swap those balls in the optimal solution to align it with the greedy solution. We know that this is possible because the balls in the other box cannot be bigger than B, since the k−1 that may be larger than B are packed the same way in both solutions.\n\n\nYour second solution can be implemented in O(n log n) time using a balanced binary search tree.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Can an activity problem with unknown start time be solved with a greedy algorithm?\r\n                \r\nGiven the classic activity problem of maximizing the number of activities in a given interval where t has to be smaller than k. However, in this case, the interval does not start before we select the first activity and the activity is constant, ie there is no start time.\nCan this problem be solved with a greedy algorithm? If not is there another type of algorithm that can solve this problem in an optimal way?\nMy first thought was that we need to find the interval with the highest density of activities.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What's the difference between greedy and heuristic algorithm?\r\n                \r\nWhat's the difference between greedy and heuristic algorithm? \n\nI have read some articles about the argument and it seems to me that they are more or less the same type of algorithm since their main characteristic is to choose the best (local) option at each iteration to solve a problem. \n    ", "Answer": "\r\nThe way that Heuristics have been described to me is that they are \"rules of thumb\". Their ability to produce a globally optimal solution may not be directly provable but typically, they do a good job. They're often used when the cost of determining an optimal solution is too high. Furthermore, Heuristics often encode a degree of experience on how the problem was solved in the past. A better way to describe a Heuristic is a \"Solving Strategy\".\n\nA Greedy algorithm is one that makes choices based on what looks best at the moment. In other words, choices are locally optimum but not necessarily globally optimum (it might be if lucky but you can't prove it). Furthermore, a Greedy algorithm doesn't typically refine its solution based on new information. This is but one solving strategy (a.k.a a heuristic).\n\nTo provide an example of how a greedy algorithm might work, if you were to use one to help you plan a route to drive from one side of the country to the other in the shortest distance, it would likely choose the short slow roads. It wouldn't necessarily understand that a motorway, although longer and perhaps more direct, would be the better option.\n\nAn alternative strategy (heuristic) might seek to cover as much of the journey using motorways (because for most destinations, they tend to be more direct), and then resort to use normal roads to transition between. In some circumstances, it would probably perform quite lousy but in most, it would do quite well, and to be honest, it's probably a similar heuristic we all use when commuting (if not using a satnav).\n\nWrapping up...\n\n\nAre all Heuristics, Greedy Algorithms - No\nAre all Greedy Algorithms, Heuristics - In general, yes.\n\n\nTo help provide some background, one of the first problems I was taught in my algorithms class at university was the Traveling Salesman Problem. It belongs to the NP-complete class of problems meaning that there exists no efficient means of solving. That is to say as the size of the problem grows, the time taken to find a solution grows substantially. There exists a number of proveable algorithms but their performance isn't great and in real world applications, we tend to favour heuristics (which include Greedy Algorithms - see link).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm to Determine 3 Best Quantile Points for Quantile Regression\r\n                \r\nI ran a Quantile Regression algorithm on a multimodal data point and have successfully generated a reasonable model with sufficient accuracy. However, the challenge I have is I had to hand pick the quantile points. I have to replicate this experience against multiple products.\nThe first image shows the quantiles I hand-picked. However, I'd like to automate the process so the machine can return to me the three best points. The source from which I picked my quantiles is from the table below which shows the average Mean Absolute Error (MAE) of the quantile columns at each 0.05 quantile/percentile. I basically started from the left most column, and gradually select the quantile points that yield the smallest average MAE.\nI'm familiar with the Greedy Algorithms that looks through one list and yields a maximum/minimum solution by slicing a list/array and highlighting the first and last index. However, in multi-dimensional space like the table below, how can such algorithm be utilized?\nIn summary, the goal is to find three quantile points with the minimum average MAE to represent the observation. What approach can be used to solve this problem?\nHigh-level overview of how I created the table below:\n```\n# Setup Flow\nquantiles = np.arange(0.05,1.0,0.05)\npredictions = {}\n\n# Run Regression\nfrom statsmodels.regression.quantile_regression import QuantReg\n\nX_ = general_linear_model_preprocessor.fit(df_btb)\nX_columns = X_.get_feature_names_out()\nX = pd.DataFrame(X_.transform(df_set['product_train']), columns=X_columns, index=df_set['product_train'].index)\nmod = QuantReg(df_set['product_train']['btb_total'],X)\n\n# Go through each quantile and generate a regression model\nfor quantile in quantiles:\n    res = mod.fit(q=quantile, kernel='epa')\n    X_test = pd.DataFrame(X_.transform(df_set['product_test']), columns=X_columns, index=df_set['product_test'].index)\n    predictions[\"{:.2f}\".format(quantile)] = res.predict(X_test)\n\n\n# Record the actual data into a new DataFrame \n# and concatenate with quantile results\n\ndf_y = df_set['product_test']['btb_total'].copy()\n\nfor quantile in quantiles:\n    df_y_hat = pd.DataFrame(predictions[\"{:.2f}\".format(quantile)], columns=[\"{:.2f}\".format(quantile)], index=df_y.index)\n    df_y = pd.concat([df_y,df_y_hat], axis=1)\n\n# Sort\ndf_y_sort = df_y.sort_values(by=[y_variable])\n\n# Generate table to measure MAE\ndf_mae = np.abs(df_y_sort.drop(columns=['btb_total']).sub(df_y_sort['btb_total'], axis=0))\n\n# Split into 0.05 quantiles\ndf_mae_split = np.array_split(df_mae, len(quantiles)+1)\n\n# Aggregator\nmae_aggregator = list()\n\n# Loop and measure MAE\nfor df_sub in df_mae_split:\n    mae_aggregator.append(df_sub.mean(axis=0).values.ravel())\n\npd.DataFrame(mae_aggregator, columns=df_mae.columns)\n```\n\n\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm approach to a modified Nearby School/Postoffice example\r\n                \r\nI have been trying to solve a practice problem from my professors note but could not find a optimal solution.The following is the problem.\n\nAlong a west-east street there are m public schools that respectively have distances, S[1] < S[2] < … < S[m], to the west end of the street. In addition to the m schools, there are n houses which have distances H[1] < H[2] < … < H[n] to the west end of the street, respectively. Currently, a student from any house can find a school that is within 200 meter walking distance. Now, because the budget is short, we wish to close some schools. Please design an O(n+m) greedy algorithm to select a minimum number of schools to be open such that any home still can find one of these selected schools that is within 200 meter walking distance. You need to show a pseudo code and prove the correctness of your algorithm.\n    ", "Answer": "\r\nHigh Level Thoughts\n\nFirst, we know solution always exist, by not removing any schools.\n\nFor choosing minimum schools, let's think in another way:\n\n\n  For each house at h[i], think as a range ```\n[h[i]-200, h[i]+200]```\n inclusively\n\n\nSo, for every such range, we want to find some school  at ```\ns[j]```\n where  ```\nh[i]-200 <= s[j] <= h[i]+200```\n\n\nAs both ```\nh[]```\n & ```\ns[]```\n is sorted, let's see from the leftmost house ```\n[h[0]-200, h[0]+200]```\n, we MUST choose one school for this house, intuitively, we want to choose the rightmost school possible, as this school has a higher chance to share with next house\n\nThis idea is true in general case:\n\n\n  For range h[i], we always want to choose school which is already chosen school by h[i-?], or the rightmost non chosen school\n\n\nCorrectness\n\nLet a solution is an ordered set of schools ```\nS```\n, which is not found by the method described\n\nLet the solution found by our greedy method be an ordered set of schools ```\nG```\n\n\nConside ```\nS[0]```\n and ```\nG[0]```\n, ```\nS[0] <= G[0]```\n as we choose the rightmost possible school for the first house. Then either\n\n\n```\nS[0] <= G[0] <= S[1]```\n, we can replace ```\nS[0]```\n by ```\nG[0]```\n which provides same set size\n```\nS[0] < S[1] < ... < S[X] <= G[0] <= S[X+1]```\n, we can replace all ```\nS[X]```\n <= ```\nG[0]```\nby ```\nG[0]```\n, which provides a smaller / more optimal size\n\n\n(Yes indeed case 1 is a sub-case of case 2)\n\nFor both cases, remove ```\nG[0]```\n and any ```\nS[X] <= G[0]```\n, the scenario is the same with two reduced set, we can use similar arguments, recursively, to say that our greedy method would not do worse than any possible solutions, which is optimal\n\nPseudo Code\n\n\r\n\r\n```\nPointer house_pointer = first house, school_pointer = first school;\r\n\r\nfor( each house ){\r\n   if( NOT ( current school is chosen and within current house's range ) ){\r\n       while(current school is NOT the rightmost school within range){\r\n            school_pointer = current school = next school\r\n       }\r\n       mark current school chosen\r\n   }\r\n   house_pointer = next house\r\n}```\n\r\n\r\n\r\n\n\nIt seems like there is two loops in the algorithm, which is ```\nO(nm)```\n, but it is not true.  For these type of structure (for eg ```\nKMP algorithm```\n) which uses two-pointers to iterate through an array, very often you can observe the maximum # of times each elements would be accessed.\n\nFor the houses, as each iteration would move to next house, each house is at most be accessed 1 time.\n\nFor the schools, as the pointer only move forward but not backward, each school is at most accessed 1 time as well, though not evenly distributed for each house iteration (depends on implementation, some schools maybe accessed 2 times but that's not important)\n\nTherefore, combine both, the complexity is still ```\nO(n+m)```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Maximizing # of carriage returns algorithm (greedy?)\r\n                \r\nI recently had an interview question as follows:\nWe are given a list of words, and we want to format them to maximize the # of carriage returns while keeping the # of letters per line within a range.\n\nFor example, we want a range of 5 - 10 (inclusive) letters per line, one solution is this:\n\n\nhello (5)\ncat (3)\n\n\nAnother is this:\n\n\nhello cat (9) <- 1 for a space\n\n\nSo the first solution is better because we have 1 carriage return versus 0 in the second.\n\nIf a word does not fit, it must be placed on a new line. For example:\n\n\nhello (5)\npeople (6)\n\n\nIntuitively to me this seems like a greedy algorithm problem where we return as soon as we meet the minimum letter per line constraint. However, this seems too simple and I'm now starting to doubt myself, but I can't come up with a counter example where greedy is not the best.\n    ", "Answer": "\r\nIf the words are to be placed in the same order as they appear then a simple greedy approach shall be optimal because there is no reason why you wouldn't place the carriage returns as early as possible in the sequence.\n\nIf you are allowed to change the order of the words, then it is a more difficult problem and then following approach can be applied.\n\nSort the words in descending order of the number of letters.\n\nAssign one line each to words of length >= 5.\n\nFor words of length < 5, it is a reverse multiple bins bin backing problem wherein:\nThe bins have minimum capacity 5 and maximum capacity 10.\nYou have to place the words in the bins such that the number of bins is maximized.  \n\nIt is at least an NP complete problem but \"I think\" (more so because it was asked in an interview) a dynamic programming formulation can be thought of that solves it in pseudo-polynomial time (like a knapsack problem).\n\nEDIT:\nIMO the greedy algorithm shall work in the case when the maximum capacity is at least equal to twice the minimum capacity, like in this case.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Solving knapsack problem using a greedy python algorithm\r\n                \r\nI'm trying to solve the knapsack problem using Python, implementing a greedy algorithm. The result I'm getting back makes no sense to me. \n\nKnapsack:\n\nThe first line gives the number of items, in this case 20. The last line gives the capacity of the knapsack, in this case 524. The remaining lines give the index, value and weight of each item.\n\n```\n20\n    1    91    29\n    2    60    65\n    3    61    71\n    4     9    60\n    5    79    45\n    6    46    71\n    7    19    22\n    8    57    97\n    9     8     6\n   10    84    91\n   11    20    57\n   12    72    60\n   13    32    49\n   14    31    89\n   15    28     2\n   16    81    30\n   17    55    90\n   18    43    25\n   19   100    82\n   20    27    19\n524\n```\n\n\nPython code:\n\n```\nimport os \n\ndef constructive():     \n    knapsack = []\n    Weight = 0\n    while(Weight <= cap):\n        best = max(values)\n        i = values.index(best)\n        knapsack.append(i)\n        Weight = Weight + weights[i]\n        del values[i]\n        del weights[i]\n    return knapsack, Weight\n\n\ndef read_kfile(fname):\n    with open(fname, 'rU') as kfile:\n        lines = kfile.readlines()     # reads the whole file\n    n = int(lines[0])\n    c = int(lines[n+1])\n    vs = []\n    ws = []\n    lines = lines[1:n+1]   # Removes the first and last line\n    for l in lines:\n        numbers = l.split()   # Converts the string into a list\n        vs.append(int(numbers[1]))  # Appends value, need to convert to int\n        ws.append(int(numbers[2]))  # Appends weigth, need to convert to int\n    return n, c, vs, ws\n\ndir_path = os.path.dirname(os.path.realpath(__file__))  # Get the directory where the file is located\nos.chdir(dir_path)  # Change the working directory so we can read the file\n\nknapfile = 'knap20.txt'\nnitems, cap, values, weights = read_kfile(knapfile)\nval1,val2 =constructive()\nprint ('knapsack',val1)\nprint('weight', val2)\nprint('cap', cap)\n```\n\n\nResult:\n\n```\nknapsack [18, 0, 8, 13, 3, 8, 1, 0, 3]\nweight 570\ncap 524\n```\n\n    ", "Answer": "\r\nWelcome. the reason why your program is giving a weights over the cap limit is because on the final item you are putting in the knapsack, you aren't checking if it can fit in it. To do this just add an if statement, Also you should check if the list of values is empty. Do note that I have append (i+1) since your text file's index is starting at 1 but Python starts it's list index at 0:\n\n```\ndef constructive():\n    knapsack = []\n    Weight = 0\n\n    while(Weight <= cap and values):\n        best = max(values)\n        i = values.index(best)\n        if weights[i] <= cap-Weight:\n            knapsack.append(i+1)\n            Weight = Weight + weights[i]\n        del values[i]\n        del weights[i]\n\n    return knapsack, Weight\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Proof of a greedy algorithm concerning \"Buy and Resell Problem\" [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\n\"Buy and Resell Problem\" is a classical optimization problem. It can be described in the following way:\nThere are $n$ cities. For each city, the price of products in this city is given (a positive number). Now a person will travel from city 1 to city $n$, one by one. When reaching a city, he can buy exactly one product with the price in this city, or sell exactly one product if he currectly has at least one product. He can also do nothing and then go on to the next city. The problem is how to plan a strategy so that he can earn maximal money.\nThere is a correct greedy algorithm to this problem. When reaching city $i$, consider all $j$ in $1 ... i-1$, and find a $j$ with lowest price such that he doesn't buy a product in city $j$ (he could have sold a product in city $j$). Then he buys a product in city $j$ and sells it in city $i$. The algorithm runs all $i$ in increasing order, and finally gives the best strategy.\nThe solution is quite sumple, but how to prove its correctness? \n    ", "Answer": "\r\nOk, so the proof won't be very formal, but I hope it will be enough.\n\nLet's consider city i, where you can buy/sell a product for a price x. You want to sell there a product that was bought cheaper than x in order to earn money. So you want to find the cheapest product in the previous cities that costs less than x and you haven't bought it yet. Let's say its cost is y. If we sell it here, we earn (x - y). \n\nNow we go to the next city, j. What if you can sell that product here for more than x, let's say z? Then you would earn (z - y), which is more than (x - y)... So have you made a wrong decision?\n\nLet's say he can both buy AND sell a product in one city. Then, your decision actually does not matter. If you sell a product in city i, that is for x, you immidiately earn (x - y). Then, you can also buy a product in city i, which will cost you x money. Now, when you get to city j, you can sell it for price (z - x). How much would you earn in total by doing so? Exactly:\n\n```\nx - y + z - x = z - y\n```\n\n\nThat is equal to buying a product for y, then selling it in city j for z.\n\nWe can easily see that selling and buying a product in one city gives us exactly the same result that not selling a product in that city at all. So does it matter if you can buy and sell at the same time or not? No, not really. It's just like not selling there at all. We can deny selling a product in city i by just buying another one in i.\n\nWhat if z is actually smaller than x? If so, you have made a great decision, selling product for z instead of x gives you less.\n\nNo matter what the price in j is, you have made a good decision with selling a product in city i. So your algorithm is always making the best choice, that's why it works.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Proof for the greedy algorithm\r\n                \r\nI recently tried solving a problem on Codeforces I did get the solution right but am now trying to prove it. The algorithm is something like this:\n\nTake the smallest discount and apply it on the most expensive ones and take the two consecutive less expensive ones for free. Then do it continuously till no items are left.\n\nI am kind of stuck on the proof. It would be great if someone can give me a formal proof by contradiction.\n\nProblem!\n    ", "Answer": "\r\nIt goes in two parts:\n\nWhich discount to pick? \n\nSuppose we choose to take any other discount (2 free for ```\nm```\n items) than the smallest one (```\nn```\n items, ```\nn<m```\n): Buying articles ```\na(1)```\n to ```\na(m)```\n we get articles ```\nb```\n and ```\nc```\n for free. We could just take the smallest discount, buying articles ```\na(1)```\n to ```\na(n)```\n to get ```\nb```\n and ```\nc```\n for free, and the buy the items ```\na(n+1)```\n to ```\na(m)```\n for the full price to end up in the same situation. Therefore picking the smallest discount is at worst on par with other choices.\n\nWhich free articles to pick?\n\nNow suppose we apply the discount to items ```\na1```\n and ```\na2```\n instead of the most expensive ones ```\nb1```\n an ```\nb2```\n (```\ncost(a1)<cost(b1)```\n or ```\ncost(a2)<cost(b2)```\n). Let's assume that ```\ncost(a1)<cost(a2)```\n since the cases are symmetrical. Three cases arise:\n\n\nSomehow we still manage to get ```\na2```\n for free as part of a promotion: then we could also have gotten ```\na1```\n if we hadn't picked it already.\nWe have to pay for it, as part of a discount. The discount allows us to buy items costing  up to ```\nc```\n. One of the following arises:\n\n```\nc<=cost(a1)```\n: we may swap ```\na1```\n and ```\na2```\n, which leads to a lower cost for this basket, without changing anything else.\n```\ncost(a2)<=c<cost(a1)```\n: let's call ```\nd```\n and ```\ne```\n the items we get out of this second discount, ```\nd```\n being the most expensive one. We could have picked ```\na2```\n as a free item in the first discount, replacing it by ```\nd```\n in the second and picking ```\na1```\n as a free item in the second discount, resulting in a lower or equal cost.\n\nWe buy it out of a discount: we could have picked ```\na2```\n and paid ```\na1```\n for a lower cost without changing anything else, hence picking ```\na1```\n was suboptimal.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is the greedy best-first search algorithm different from the best-first search algorithm?\r\n                \r\nIs the greedy best-first search algorithm different from the best-first search algorithm?\n\nThe wiki page has a separate paragraph about Greedy BFS but it's a little unclear.\n\nMy understanding is that Greedy BFS is just BFS where the \"best node from OPEN\" in wikipedia's algorithm is a heuristic function one calculates for a node. So implementing this:\n\n```\nOPEN = [initial state]\nCLOSED = []\nwhile OPEN is not empty\ndo\n 1. Remove the best node from OPEN, call it n, add it to CLOSED.\n 2. If n is the goal state, backtrace path to n (through recorded parents) and return path.\n 3. Create n's successors.\n 4. For each successor do:\n   a. If it is not in CLOSED: evaluate it, add it to OPEN, and record its parent.\n   b. Otherwise: change recorded parent if this new path is better than previous one.\ndone\n```\n\n\nwith \"best node from OPEN\" being a heuristic function estimating how close the node is to the goal, is actually Greedy BFS. Am I right?\n\nEDIT: Comment on Anonymouse's answer:\n\nSo essentially a greedy BFS doesn't need an \"OPEN list\" and should base its decisions only on the current node? Is this algorithm GBFS:\n\n```\n1. Set START as CURRENT node\n2. Add CURRENT to Path [and optinally, to CLOSED?]\n3. If CURRENT is GOAL, exit\n4. Evaluate CURRENT's successors\n5. Set BEST successor as CURRENT and go to 2.\n```\n\n    ", "Answer": "\r\n\"Best first\" could allow revising the decision, whereas, in a greedy algorithm, the decisions should be final, and not revised.\n\nFor example, A*-search is a best-first-search, but it is not greedy.\n\nHowever, note that these terms are not always used with the same definitions. \"Greedy\" usually means that the decision is never revised, eventually accepting suboptimal solutions at the benefit of improvements in running time. However, I bet you will find situations where \"greedy\" is used for the combination of \"best first + depth first\" as in \"try to expand the best next step until we hit a dead end, then return to the previous step and continue with the next best there\" (which I would call a \"prioritized depth first\").\n\nAlso, it depends on which level of abstraction you are talking about. A* is not greedy in \"building a path\". It's fine with keeping a large set of open paths around. It is however greedy in \"expanding the search space\" towards the true shortest path.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm Exchange Proof (Algorithm Design, Chapter 4, 6E)\r\n                \r\nWorking through book, and came across this problem :\n```\n6. Your friend is working as a camp counselor, and he is in charge of \norganizing activities for a set of junior-high-school-age campers. One of \nhis plans is the following mini-triathalon exercise: each contestant must \nswim 20 laps of a pool, then bike 10 miles, then run 3 miles. The plan is \nto send the contestants out in a staggered fashion, via the following rule: \nthe contestants must use the pool one at a time. In other words, first one \ncontestant swims the 20 laps, gets out, and starts biking. As soon as this \nfirst person is out of the pool, a second contestant begins swimming the \n20 laps; as soon as he or she is out and starts biking, a third contestant \nbegins swimming . . . and so on.) \n\nEach contestant has a projected swimming time (the expected time it \nwill take him or her to complete the 20 laps), a projected biking time (the \nexpected time it will take him or her to complete the 10 miles of bicycling), \nand a projected running time (the time it will take him or her to complete \nthe 3 miles of running). Your friend wants to decide on a schedule for the \ntriathalon: an order in which to sequence the starts of the contestants. \nLet’s say that the completion time of a schedule is the earliest time at \nwhich all contestants will be finished with all three legs of the triathalon, \nassuming they each spend exactly their projected swimming, biking, and \nrunning times on the three parts. (Again, note that participants can bike \nand run simultaneously, but at most one person can be in the pool at \nany time.) What’s the best order for sending people out, if one wants the \nwhole competition to be over as early as possible? More precisely, give \nan efficient algorithm that produces a schedule whose completion time \nis as small as possible. \n```\n\nJust fiddling with numbers it becomes pretty obvious the answer is a greedy algorithm to sort in descending order of biking time + running time.\nWhat I am struggling with is my teacher mentioned this as good practice for using the exchange argument/proof, but I can't see how to use it (or anything else) to prove this answer correct.\nThis problem is answered elsewhere online (I see this variant several places), but as far as I can tell the answer is wrong\nnote : bi/ri stands for bike/ride time of contestant i\nWe prove this by an exchange argument. Consider any optimal solution, and suppose it does not use this\norder. Then the optimal solution must contain two contestants i and j so that j is sent out directly\nafter i , but bi + ri < bj + rj . We will call such a pair (i,j) an inversion . Consider the solution obtained by swapping the orders of i and j . In this swapped schedule, j completes earlier than he/she used to. Also, in the swapped schedule, i gets out of the pool when j previously got out of the pool; but since bi + ri < bj + rj , i ﬁnishes sooner in the swapped schedule than j ﬁnished in the previous schedule.\nMy issue with this is bolded, there is no reason to assume that i and j have the same swim time, therefore i will not get out the pool when j got out of the poo;\nAm I wrong and this answer is somehow right? If so why? If not what would a correct proof/argument look like?\n    ", "Answer": "\r\nI agree with you that this answer overassumes what you mentioned in bold. I was only able to find this text posted at https://www.coursehero.com/file/9692310/HW4S12sol1/ and mirrors thereof. Fortunately, we don't need this assumption to prove the greedy algorithm is optimal with the exchange argument.\nTo prove it, we will calculate the time each contestant takes in each case and show that the swapping will only reduce the time the last of i or j complete.\nWe can assume WLOG that the first of i or j starts at time 0.\nIn the optimal schedule with the inversion (i goes first):\n\n\n\n\nContestant\nTime Finished\n\n\n\n\ni\ntoi  = si + bi + ri\n\n\nj\ntoj = si + sj + bj + rj\n\n\n\n\nSince bi + ri < bj + rj, it is clear that toi < toj which means j finishes last in this case.\nIn the swapped schedule (j goes first):\n\n\n\n\nContestant\nTime Finished\n\n\n\n\ni\ntsi = si + sj + bi + ri\n\n\nj\ntsj = sj + bj + rj\n\n\n\n\nWe don't know which of the two finishes last, but we can show that tsi < toj and tsj < toj which means that either way, the time the last contestant finished has reduced.\nThus, swapping this inversion will only improve the finish time of the last contestant of i or j, and continued swapping of the optimal solution to the greedy solution will not result in a sub-optimal solution. Therefore the greedy solution is optimal.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Using greedy algorithm within two lists in Python\r\n                \r\nWe observe a particular data sample explained by an int value ```\nn```\n and two lists ```\nA```\n and ```\nB```\n, where the two lists contain integer element or elements ranging from ```\n1```\n to ```\nn```\n, and the elements in each list aren't repeated. (There could be the same element in both lists, however.)\n\n```\nn```\n represents the size of the observed sample.\nElements in ```\nA```\n represent the numbers that are 'taken out' from the sample. Hence, if ```\nn=5```\n and ```\nA=[2,3]```\n, the size of our resulting sample would be ```\n3```\n.\nElements in ```\nB```\n represent the numbers that are 'put back into' the sample. The maximum size of the resulting sample cannot exceed ```\nn```\n.\nHowever, the elements in ```\nB```\n can only be put back in if and only if there is an element in ```\nA```\n that is either equal to the element in ```\nB```\n, or one less or greater than the element in ```\nB```\n. For example, if ```\nn=5, A=[2,3], B=[4]```\n, the size of our sample would be ```\n4```\n, as there exists an element in ```\nA```\n that is one less than the element in ```\nB```\n.\nFinally, the elements in ```\nB```\n are only considered once if they are 'put back in'. If ```\nn=5, A=[2,3,5], B=[3,4]```\n, even though the elements in ```\nB```\n satisfy the condition twice each, the size of the resulting sample would still be ```\n4```\n.\n\nSome of the test cases are given:\n```\nn   A       B           return\n5   [2, 4]  [1, 3, 5]   5\n5   [2, 4]  [3]         4\n3   [3]     [1]         2\n```\n\nI'm aware that this is a type of a greedy algorithm (which I am not super familiar with), but I also tried the following:\n```\ndef solution(n, A, B):\n    count = n - len(A)\n    for i in range(len(B)):\n        if B[i]-1 in A:\n            count += 1\n        elif B[i]+1 in A:\n            count += 1\n        elif B[i] in A:\n            count += 1\n        else:\n            count += 0\n    if n > count:\n        answer = count\n    else:\n        answer = n\n    return answer\n```\n\nWhile this seemingly works, it doesn't take into account that the elements in ```\nB```\n cannot be considered once they are put back in already. Is there any edit I can make to my code, and how would this problem be optimally solved?\n    ", "Answer": "\r\nI guess the key was to use ```\nset()```\nin order to retrieve the set without any overlapping elements first, and then start removing the elements that are gone over (which is done similarly to my initial code).\n```\ndef solution(n, A, B):\n  B_uniq = set(B)-set(A)\n  A_uniq = set(A)-set(B)\n  for i in B_uniq:\n    if i-1 in A_uniq:\n      A_uniq.remove(i-1)\n    elif i+1 in A_uniq:\n      A_uniq.remove(i+1)\n  return n-len(A_uniq)\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Schedule Algorithm\r\n                \r\nThere is a proof that states that sorting a list of Tasks by their start times will make use of the least amount of machines needed to perform the tasks. I found a case where sorting by their total time makes use of less machines.\n\nScheduling method: This algorithm makes use of this post to see if times overlap. If they do overlap we make a new machine. If not then we reassign the machine\n\n```\nprivate static void schedule(ArrayList<Task> tasks, ArrayList<Machine> machines) {\n    for (Task t : tasks){\n        boolean canProcess = false;\n        for(Machine m : machines){\n            if(t.startTime < m.task.endTime && t.endTime > m.task.startTime) \n                continue;//this machine is running during this time; look at next machine\n            canProcess = true;\n            m.task = t;\n            break; //go on to the next task\n        }\n        if(canProcess == false){\n            //create a new machine\n            Machine m = new Machine();\n            m.task = t;\n            machines.add(m);\n        }\n    }\n}\n```\n\n\nHere is an example of sorting by start time\n\n```\nStart Time: 4 End Time: 7 Total Time: 3\nStart Time: 5 End Time: 9 Total Time: 4\nStart Time: 6 End Time: 20 Total Time: 14\nStart Time: 12 End Time: 21 Total Time: 9\nStart Time: 19 End Time: 22 Total Time: 3\nSorting by start time: 3 machines\n```\n\n\nAnd here is sorting by Total Time:\n\n```\nStart Time: 4 End Time: 7 Total Time: 3\nStart Time: 19 End Time: 22 Total Time: 3\nStart Time: 5 End Time: 9 Total Time: 4\nStart Time: 12 End Time: 21 Total Time: 9\nStart Time: 6 End Time: 20 Total Time: 14\nSorting by total time: 2 machines\n```\n\n\nIs the theorem broken then or am I not implementing Greedy Scheduling correctly?\n    ", "Answer": "\r\nIf I understand your code correctly, you assign the task from 4-7 to machine 1; then you assign the task from 19-22 to machine 1, since that interval doesn't overlap with the previous interval (4-7); then you assign the task from 5-9 to machine 1, since that interval doesn't overlap with the previous interval (19-22).  And already you've got a problem.  You're telling machine 1 to perform a task from time 4-7 and a task from time 5-9, and it can't do that.  So your \"2 machines\" result is bogus.\n\nIf you want to get the number of machines without sorting by start time first, then you'll need to keep a list of all intervals of the tasks that you've assigned to each machine.  Thus, after the second task, your data will say that machine 1 is scheduled for 4-7 and 19-22.  Then, when you look at the third task, at interval 5-9, you have to check it against both intervals assigned to machine 1.  You'll find that it overlaps with 4-7 and that you can't schedule it, so you assign it to machine 2.  I think that if you sort by start time first, then you don't have to keep a list of tasks for each machine.  Maybe that's what the theorem is really saying?  I don't know; I'd have to see the theorem (if you can provide a reference to it, that would be good).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm - Depreciating Cost\r\n                \r\nThis is a problem I found as an extra note in Algorithm Design by Kleinberg and Tardos.\n\nSuppose we are trying to sell off equipment whose cost is depreciating at a factor of ri < 1 per month, starting from $100, so if you sell it t months from now you will receive 100.rit.\n\nIf you can sell only one item per month what is the optimal order in which to sell them?\n\nInput (3/4; 1/2; 1/100)\n\nOptimal order would be [100x{1/2+(3/4)2+(1/100)3}].\n\nI am not sure how to go about this problem.\n    ", "Answer": "\r\nSuppose there are N items with individual Ri.\n\n\nCompute the N x N matrix where Cij = Power(Ri,j).\nThe problem now boils down to Assignment problem with N objects to be placed in N positions and each having corresponding profits associated.\nMaximize the total profit using any algorithm like the Hungarian Algorithm.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Improving my greedy Algorithm\r\n                \r\n**This is my code that look a way to find a sum in an array **\n\n```\n     public class Piecedemonei {\n        public static void recherche(int[] tab) {\n                int num;\n                int quo;\n\n                for (int i = 0; i <= tab.length - 1; i++) {\n\n\n int somme = 18;\n                    System.out.println(\"Solution  \" + i);\n\n                    for (int j = i; j < tab.length; j++){\n\n\n                        if (tab[j] <= somme) {\n\n                            num = somme / tab[j];\n                            System.out.print(num+\"*\" + \" \" + tab[j]);\n                            System.out.println(\" \");\n\n                            somme -= num * tab[j];\n        j=0;\n                        }\n\n\n\n                }\n            }\n            }\n\n\n\n\n            public static void main(String[] args) {\n                int aba[] = { 7, 6, 4, 5 };\n                recherche(aba);\n                System.out.println();\n\n            }\n\n        }\n```\n\n\nOutput\n\n```\nSolution  0\n2 7 + 1 4\nSolution  1\nSolution  2\nSolution  3\n```\n\n\n**I am looking a way to improve my code so that the output looks like this : **\n\n```\n Solution  0\n2*7 + 1*4\nSolution  1\n3*6\nSolution  2\n4*4 + 1*4\nSolution  3\n```\n\n\n**Why cant I reset my loop so that it does the same thing again and again ? **\n    ", "Answer": "\r\nChange \n\n```\nint somme = 18;\nfor (int i = 0; i <= tab.length - 1; i++) {\n    System.out.println(\"Solution  \" + i);\n\n    for (int j = 0; j < tab.length; j++){\n    ...\n```\n\n\nto\n\n```\nfor (int i = 0; i <= tab.length - 1; i++) {\n    int somme = 18;\n    System.out.println(\"Solution  \" + i);\n\n    for (int j = i; j < tab.length; j++) {\n    ...\n```\n\n\nNotice the ```\nint j = i```\n in the inner loop.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "JavaScript: How to optimize team balancing program that runs based on Greedy Algorithm?\r\n                \r\nI've written a simple JavaScript program using jQuery that takes in a group of players and breaks them into teams of similar skill level. I spent a lot of time looking at the best way to sort the teams and settled on using a Greedy Algorithm. This works when splitting the group of players into 2 teams. However, when breaking players into more than 2 teams the subsets are close but not always optimal.\nExample: Splitting 20 players whose skill levels can be represented as (11,10,8,8,7,7,7,7,7,6,5,5,5,4,4,3,3,2,1,1) with an average skill value of 5.55 into 4 teams.\nThe greedy algorithm breaks them into the following 4 subsets\n\nTeam 1: (11,7,5,3,3) Sum: 29 Average: 5.8\nTeam 2: (10,7,5,4,2) Sum: 28 Average: 5.6\nTeam 3: (8,7,7,4,1) Sum: 27 Average: 5.4\nTeam 4: (8,7,6,5,1) Sum: 27 Average: 5.4\n\nBut the optimal teams, in this case, are actually\n\nTeam 1: (11,7,4,3,3) Sum: 28 Average: 5.6\nTeam 2: (10,7,5,4,2) Sum: 28 Average: 5.6\nTeam 3: (8,7,7,5,1) Sum: 28 Average: 5.6\nTeam 4: (8,7,6,5,1) Sum: 27 Average: 5.4\n\nI'm wondering if anyone has any insights into what I can add to help make sure the program finds the optimal teams when splitting a group into more than 2 teams. (Also this is my first question on here so please let me know if there's any information I can add or clarify to make this better.)\n    ", "Answer": "\r\nThe following might not work for all cases, but it should be a slight improvement over the simple \"greedy\" algorithm:\n\r\n\r\n```\nvar sk=[11,10,8,8,7,7,7,7,7,6,5,5,5,4,4,3,3,2,1,1],n=4;\nfunction greedy(arr,n){\n  const asm=arr=>arr.reduce((a,c)=>a+c,0);\n  let lim=Math.ceil(asm(arr)/n),\n      loopend=sk.length*n;\n      srt=arr.slice(0).sort((a,b)=>b-a),\n      dist=[...Array(n)].map(()=>[]);\n  for (let i=0; srt.length && i<loopend ; i++) {\n    if (asm(dist[i%n])+srt[0]<=lim) dist[i%n].push(srt.shift());\n  }\n  console.log(\"lim:\",lim);\n  if (srt.length) console.log(lim,\"Not all elements were distributed!\")\n  return dist\n}\n\nvar res=greedy(sk,n);\n\nconsole.log(res);\nconsole.log(\"sums:\",res.map(a=>a.reduce((s,c)=>s+c)));```\n\r\n\r\n\r\n\nBasically I follow the rules of the greedy algorithm, but before I ```\n.push()```\n an element into one of the target arrays I check, whether the resulting sum would be more than the limit ```\nlim```\n (a value calculated before on the basis of the total sum divided by the number of divisions).\nIn my function I calculate the sums for each sub-array freshly within each iteration (using ```\nasm()```\n). This can of course be optimised by providing accumulating variables and only checking against the those and the new additional value.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How do I prove the correctness of my greedy algorithm for vertex cover on a tree?\r\n                \r\nThe vertex cover problem on trees is as follows.\n\nInput: an acyclic simple undirected graph G Output: a set of vertices W such that, for every edge uv, u &in; W or v &in; W. We want to minimize the size of W.\n\nMy greedy algorithm is to initialize W = &emptyset;, then, while G is not empty, repeat the following steps. Let L be the leaf vertices of G. Let N(L) be the set of vertices adjacent to some vertex in L. Update W = W ∪ N(L). Delete the vertices L ∪ N(L) and their incident edges from G.\n\nThis algorithm works in all of the cases that I have tried so far. How do I go about proving it correct? Here's what I have so far.\n\nAssume that there is another set S that is an optimal solution. By contradiction, I want to establish either that S does not cover all of the edges or that S is the same set as the one produced by my greedy algorithm.\n    ", "Answer": "\r\nThat's a reasonable start, but I see two issues.  First, the optimal solution may not be unique.  Consider the four-vertex path ```\na-b-c-d```\n, which has three optimal solutions: ```\n{a,c}, {b,c}, {b,d}```\n.  Second (and you're probably doing this already, but you didn't say so), it's necessary to consider the tree to be rooted.  Otherwise, on the graph ```\na-b```\n for example, we have ```\nL = {a,b}```\n and ```\nN(L) = {b,a}```\n, and the vertex cover produced is ```\nW = {b,a}```\n, which is not optimal.  By designating ```\na```\n as a root, it is by definition excluded from the set of leaves.\n\nTo prove formally the correctness of a program involving a loop, it is often a good idea to use induction to establish a loop invariant.  Allow me to suggest two.\n\n\nFor all times t (where time = number of loop iterations), let G(t) be what's left of G at time t and let W(t) be the value of W at time t.  For every vertex cover X of G(t), the set W(t) ∪ X is a vertex cover of G(0), where 0 is the starting time.\nFor all times t, there exists an optimal solution that contains W(t) as a subset.\n\n\nLet T be the ending time.  Since G(T) is the empty graph, X = &emptyset; is a valid vertex cover of G(T), so Invariant #1 establishes that W(T) is a vertex cover of G(0).  Invariant #2 establishes that W(T) is contained in some optimal solution.  Since W(T) itself is a vertex cover, W(T) itself must be that optimal solution.\n\nThe inductive step in proving Invariant #2 is, given an optimal solution that contains W(t-1) but not W(t), to massage it into another optimal solution that contains W(t).  This involves formalizing your intuition that it's always at least as productive to take a leaf's neighbor over the leaf.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "2D Greedy Ascent Search Algorithm Clarification\r\n                \r\nI am doing some remedial work on algorithms as I am taking a graduate course on them in the Fall and was a physics undergrad. Watching this video and at the 38:00 mark he goes over the greedy ascent algorithm for a 2D array. I am confused as he defines the peak as \na <= b,c,d,e (with b,c,d and e being the elements to the left,right,top,bottom of the current element 'a'). And then he goes on to say that to find the peak you follow the greatest element bordering on 'a' but what if you have the 2D array:\n\n20 15 13\n12  10 10\n40 40 40\n\nand started at 13, wouldn't the greedy ascent algorithm incorrectly identify 20 as the peak? How can you search an unsorted array without having to look at every element?\n\nI thank you for your help apologize in advance if this is a silly question.\n    ", "Answer": "\r\nPay close attention to the definitions, as they are not the same as what you would expect intuitively.\n\n\n  he defines the peak as a <= b,c,d,e (with b,c,d and e being the elements to the left,right,top,bottom of the current element 'a')\n\n\nSo there you have it -- a peak is defined as a local maximum (an element larger than all of its immediate neighbors), rather than a global maximum (an element larger than all other elements). By this definition, it's clear that while 20 is not the largest element it is a peak.\n\n(As noted in comments, the definition should probably be a >= b,c,d,e that's probably just a typo in the original post)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Schedule as many jobs as possible with two processors? Greedy Algorithm\r\n                \r\nI know the algorithm to schedule as many jobs as possible in the case where we have only one resource/processor:\n\nSimply, sort the jobs in ascending order of their finish times. The greedy approach. But this was for one processor/resource.\n\nNow we have two processors available. What would be the greedy approach for this problem?\n\nThe input is ( (s1,f1) , (s2,f2) ,.....(sn,fn)) where Sn represents start time of nth job and fn represents finish time of nth job.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How can i use greedy algorithm to allocate products to stores\r\n                \r\nI got assigned to solve this problem: Given number of products sold in specific stores, is there a way to find from which stores to buy all products with the condition of buying only one product from each store.\nFor example if you have stores A,B,C and products a,b,c with each shop selling:\nA: a,c\nB: a,b,c\nC: c\nAnswer: You will be buying products a from store A product b from store B and product c from store C.\nFrom this am assuming you cant have more products than stores since you are buying just 1 product from each store and you want to buy all of them.\nMy thought was using a greedy algorithm where you first buy products exclusively sold in one store and solving this hierarchically but it doesn't always work\n    ", "Answer": "\r\nYou could solve it by finding the max-flow on a maximum cardinality matching in a bipartite graph. Construct a source ```\ns```\n going to all the stores, ```\n{A, B, C}```\n, and draw a directed edge to each product that store has, ```\n{a, b, c}```\n. Then the products to the sink, ```\nt```\n. Label all edges with 0/1.\n\nThen apply the greedy Ford–Fulkerson method. If the max-flow reaches the number of stores and the number of products, then one has a viable solution. This will complete in at most ```\nO((number of stores, products)✖️(number of edges))```\n, since the maximum capacity is the number of stores and products, and each iteration increases the capacity.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm minimum basestation\r\n                \r\nSuppose we have a set of houses on one side of a long street to be served by electric\ndistribution boxes that can connect houses up to distance d. We need to use the\nminimum number of boxes. Show how to position the electric distribution boxes.\n    ", "Answer": "\r\nIn order to prove the correctness of a greedy algorithm, we must show that it produces a valid answer, has the greedy choice property, and that the problem has optimal substructure. The greedy choice property states that the first decision made by the algorithm can ALWAYS be a choice in an optimal solution. Optimal substructure means that the optimal solution to a given problem contains optimal solutions each sub problem.\n\nFor this answer, I am going to assume that you can only place an electrical distribution box at a house, rather than between them. I will also assume that each house at most d away from the houses adjacent to it.\n\nLet current_distance be the distance from the previous box (or from the first house on the street at the beginning of the algorithm)\n\nWhile there are houses without electricity\n    While (current_distance <= d)\n         If we can move to the next house before we are more than d away from last box \n           (i.e. current_distance + distance_to_next_house <= d) then move to the next \n            house\n         else place a box at the current house\n\nEssentially what this algorithm does is move as far as possible from the previous box, then places a new box. Then it goes as far as it can from the last box, and repeats until all houses are within d of an electrical distribution box.\n\nFirst let's make sure that our solution is valid and provides each house with electricity. Assume that it is not valid, and there is at least one house hi that is x away from an electrical distribution box placed at hk, where x > d. \nBecause the distance between hi and hk is greater than d, we know that there must be at least one house hj between them such that the distance between hi and hj <= d. Because our algorithm will only place a box at a house that is <= d away from the previous box, we know that this is not possible and our algorithm will always produce a valid solution.\n\nNext let's prove the greedy choice property. Assume O is the optimal solution set of houses to place boxes at, such that size(O) is minimum. Suppose the first box in O, o1, is not at the same house that our algorithm would choose, h1. We know that h1 is further down the street than o1, because our algorithm always chooses the furthest house to place a box at. We also know that the distance from o1 to o2 is less than or equal to d, and let's call this distance d0. Because h1 is further down the street than o1, we know that the distance between h1 and o2 (call this dh) is less than du. This means that dh < du <= d. Therefore, we can replace o1 with h1, which means that the first choice of our algorithm could always be a choice in an optimal solution. We have proven the greedy choice property.\n\nFinally let's prove that this problem has optimal substructures. We can do this by proving that for any box placed, our algorithm will be further down, or at the same place, on the street as any optimal solution. After we prove this, we must show that the size of our algorithms solution is the same size as the optimal solution. Let the optimal solution be called O (where each house chosen for a box is 01, o2, ..., on), and let the solution created by our algorithm be called H (where each house is h1,h2, ..., hn).\n\nWe know our first choice can always be a part of the optimal solution, so h1 must always be further along than, or at the same house as o1.\nAssume that hk is further along than, or at the same house as ok. \nNow let's prove that hk+1 must be further or at the same point on the street as ok+1.\nAssume that this is not true, and that ok+1 is further along than hk+1. Let dx represent the distance between ok and ok+1, dy represent the distance between hk and hk+1, and dz represent the distance between hk+1 and ok+1. We know that dx <= d. We also know that dy +dz <= dx, therefore dy + dz <= d, so our algorithm would not have stopped at hk+1, and would have continued to at least ok+1. Therefore hk+1 must be at the same point, or further than, ok+1.\n\nWe know that size(H) can't be less than the size(O), because O is the optimal solution. To prove size(O) = size(H), first assume that size(O) < size(H). We know that for any k, hk is as far as, or further than, ok. However, the size of our set is larger than the size of O, so we must have extra boxes placed after hk. Now let k=size(O), so ok is the last house with a box in O. We know that the distance between ok and the last house on the street (call this dz) is less than or equal to d. But since our algorithm is always ahead of or equal to the optimal solution, we know that the distance between hk and the last house on the street (dh), must be less than or equal to dz. Therefore dh <= dz <= d. This means that our algorithm would not place a box between hk and the final house, and the size of H is equal to the size of O, and is then a minimum size. \n\nHere we have proven that our algorithm produces a valid answer, has the greedy choice property, and has optimal substructures. Therefore, we have produced a correct algorithm for this problem.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Car Fueling Problem by Greedy Algorithm (getting list index out of range)\r\n                \r\nI have a small problem solving the Car fueling problem using the Greedy Algorithm.\nProblem Introduction\n\nYou are going to travel to another city that is located 𝑑 miles away from your home city. Your car can travel\nat most 𝑚 miles on a full tank and you start with a full tank. Along your way, there are gas stations at distances stop1, stop2, ... , stopN from your home city. What is the minimum number of refills needed?\n\nInput:\n```\n950\n400\n4\n200 375 550 750\n```\n\nOutput:\n```\n2\n```\n\nWhat I've tried as of now\n```\ndef car_fueling(dist,miles,n,gas_stations):\n  num_refill, curr_refill, last_refill = 0,0,0\n  while curr_refill <= n:\n    last_refill = curr_refill\n    while (curr_refill <= n-1) & (gas_stations[curr_refill + 1] - gas_stations[last_refill] <= miles):\n        curr_refill += 1\n    if curr_refill == last_refill:  \n      return -1\n    if curr_refill <= n:\n      num_refill += 1\n  return num_refill\n```\n\nWhat is the problem I'm facing\nIn the statement\n```\nwhile (curr_refill <= n-1) & (gas_stations[curr_refill + 1] - gas_stations[last_refill] <= miles)\n```\n\nI am getting the error ```\nIndexError: list index out of range```\n. It is because of ```\ngas_stations[curr_refill + 1]```\n. So when I try to separate it as a ```\nwhile```\n loop and an ```\nif```\n statement as in\n```\nwhile (curr_refill <= n-1):\n    if (gas_stations[curr_refill + 1] - gas_stations[last_refill] <= miles):\n        curr_refill += 1\n    else:\n        break\n```\n\nIt is entering an infinite loop.\nCan you kindly point out the mistake I'm facing?\n    ", "Answer": "\r\nA few issues:\n\n\n```\n&```\n is not the boolean and-operator. Use ```\nand```\n\n```\ncurr_refill + 1```\n can be ```\nn```\n, and hence produce the error you got. Note that the distance after the last gas station can be determined using ```\ndist```\n\nThe value of ```\nlast_refill```\n is wrong from the start: you did not refill (yet) at station 0, so it should not be initialised as 0. Instead use another variable that represents how far you can currently drive.\n\n\nCorrected code:\n\n```\ndef car_fueling(dist,miles,n,gas_stations):\n    num_refill, curr_refill, limit = 0,0,miles\n    while limit < dist:  # While the destination cannot be reached with current fuel\n        if curr_refill >= n or gas_stations[curr_refill] > limit:\n            # Cannot reach the destination nor the next gas station\n            return -1\n        # Find the furthest gas station we can reach\n        while curr_refill < n-1 and gas_stations[curr_refill+1] <= limit:\n            curr_refill += 1\n        num_refill += 1  # Stop to tank\n        limit = gas_stations[curr_refill] + miles  # Fill up the tank \n        curr_refill += 1\n    return num_refill\n\n# Test cases\nprint(car_fueling(950, 400, 4, [200, 375, 550, 750]))  # 2\nprint(car_fueling(10, 3, 4, [1, 2, 5, 9]))  # -1\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm to find minimum number of lines that can intersect all circles in the plane\r\n                \r\nI have a problem from homework where I need to find an ```\nO(n.log(n))```\n\ngreedy algorithm for the minimum number of lines required to intersect all circles in the plane, as shown with the example below.\n\n\n\nThe starting point of all the lines is ```\n(0,0)```\n which is the origin point. The set ```\nC```\n contains ```\nn```\n circles, where each circle ```\nc_i```\n has information about its radius ```\nr_i```\n and its centre coordinate ```\n(x_i, y_i)```\n.\n\nI have tried making greedy rules:\n\n\niterate over each circle in the set ```\nC```\n and pick ```\nc_i```\n\nconstruct 3 lines from ```\norigin```\n to ```\nc_i```\n, where 2 lines are tangent lines that only intersect 1 point in the circle, and 1 line is secant line that goes through the circle via its center.\niterate over other remaining circles ```\nc_j (j != i)```\n and look how many circles intersect with these lines\nchoose the line ```\nL_i```\n and remove the circles that intersect with it from the plane.\ncontinue until the plane is empty.\n\n\nBut I don't think that this greedy rule will achieve the optimum solution and its complexity won't be ```\nO(n.log(n))```\n. \n\nAny hints or full solution is OK. It is also mentioned in the problem sheet that greedy rules that give ```\nminimum + 1```\n lines is fine.\n    ", "Answer": "\r\nSince you can use one line more than the minimum, you may start with an arbitrary line. Continue line by line clockwise until all circles are intersected. Each new line should have the greatest possible angle to the last as long as no circle lies between them. The 2 tangent lines you found is useful to find how far you can go in each step, but it will be time consuming to check every circle for each step. See if you can figure out how to speed it up.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm implementation, Haskell [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI need to implement a Haskell function who receives one Int (truck load capacity), and a list of Ints (boxes models that can be loaded on the truck).\n\nTo define which box models must be placed preferably in\ntruck, it's requested that the boxes with greater capacity in\nrelation to the available space, always be placed first.\n\nThe algorithm should return the list of models of boxes to be placed on truck. I have no idea how to program this a functional paradigm :/\n\n```\nmaximizeLoad 103 [15, 20, 5, 45, 34]\n[45, 45, 5, 5]\n```\n\n\nThanks!\n    ", "Answer": "\r\nBruce force approach with smart filtering\n\n```\nmaximumLoad n = head \n              . head \n              . group length \n              . last \n              . group sum \n              . filter ((<= n) . sum)\n              . map concat \n              . sequence \n              . map (rep n)\n              . reverse \n              . sort\n        where rep n x = take ((div n x)+1) $ iterate (x:) []\n              group f = groupBy ((==) `on` f) . sortBy (comparing f) \n\n> maximumLoad 103 [15, 20, 5, 45, 34]\n[34,34,20,15]\n```\n\n\nUPDATE For the greedy algorithm, it will be much simpler.  I think the code is easy to read to describe the algorithm.  Expects reverse sorted input list.\n\n```\nmaxLoad _ [] = []\nmaxLoad n (x:xs) | n==0 = []\n                 | x <= n = x: maxLoad (n-x) (x:xs)\n                 | otherwise = maxLoad n xs\n\n> maxLoad 103 $ reverse $ sort [15, 20, 5, 45, 34]\n[45,45,5,5]\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to get solution path from greedy algorithm?\r\n                \r\nI have greedy algoithm with job scheduling problem, but I want to return which one projects were chosen to get this max value, how can I do that?\n```\nfrom dataclasses import dataclass\nfrom datetime import date\n\n\n@dataclass\nclass InvestmentProject:\n    profit: int\n    begin_date: date\n    end_date: date\n\n\ndef get_max_sequence(arr, i=0):\n    if i == len(arr):\n        return 0\n    j = i + 1\n    while j < len(arr) and arr[i].end_date > arr[j].begin_date:\n        j += 1\n    one = arr[i].profit + get_max_sequence(arr, j)\n    two = get_max_sequence(arr, i+1)\n    return max(one, two)\n\n\ndef main():\n    arr = [\n        InvestmentProject(30, date(2022, 10, 10), date(2022, 10, 14)),\n        InvestmentProject(15, date(2022, 10, 15), date(2022, 10, 16)),\n        InvestmentProject(25, date(2022, 10, 12), date(2022, 10, 15)),\n        InvestmentProject(10, date(2022, 10, 20), date(2022, 10, 26)),\n    ]\n    print(get_max_sequence(sorted(arr, key=lambda x: x.begin_date)))\n\n```\n\n    ", "Answer": "\r\nYou could always return value and list of indexes.\nFirst\n```\nif i == len(arr):\n   return 0, []\n```\n\nNext you would have to always get value and list before calculations\n```\n    val, indexes = get_max_sequence(arr, j)\n\n    one = arr[i].profit + val\n    \n    two, other_indexes = get_max_sequence(arr, i+1)\n```\n\nAnd you would have to manually check ```\nmax()```\n\n```\n    if one > two:\n        return one, indexes + [i]\n    else:\n        return two, other_indexes\n```\n\n\nMinimal working code:\n```\nfrom dataclasses import dataclass\nfrom datetime import date\n\n\n@dataclass\nclass InvestmentProject:\n    profit: int\n    begin_date: date\n    end_date: date\n\n\ndef get_max_sequence(arr, i=0):\n    if i == len(arr):\n        return 0, []\n    \n    j = i + 1\n    while j < len(arr) and arr[i].end_date > arr[j].begin_date:\n        j += 1\n        \n    val, indexes = get_max_sequence(arr, j)\n    one = arr[i].profit + val\n    \n    two, other_indexes = get_max_sequence(arr, i+1)\n    \n    if one > two:\n        print('one:', indexes+[i])\n        return one, indexes + [i]\n    else:\n        print('two:', other_indexes)\n        return two, other_indexes\n\n\ndef main():\n    arr = [\n        InvestmentProject(30, date(2022, 10, 10), date(2022, 10, 14)),\n        InvestmentProject(15, date(2022, 10, 15), date(2022, 10, 16)),\n        InvestmentProject(25, date(2022, 10, 12), date(2022, 10, 15)),\n        InvestmentProject(10, date(2022, 10, 20), date(2022, 10, 26)),\n    ]\n    \n    arr = list(sorted(arr, key=lambda x: x.begin_date))\n    for item in arr:\n        print(item)\n    print(get_max_sequence(arr))\n    \nmain()    \n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm: building the tallest tower stealing the less bricks\r\n                \r\nA group of m children try to build the tallest possible tower. Every kid has the bricks of different size. The first child has w1,1 , ... , w1,n1, the second w2,1, ... w2,n2 etc. The kids went to eat dinner, but one clever child stayed. Now he has the only change to pick up some bricks from other children so that he has the highest tower. Show the quickest algorithm to solve this problem, which takes the little number of bricks (note that the number wi,j can be very large). Towels treat as a sets, not stack (we can take any bricks that we want from the particular tower).\nI was thinking all day for solving this problem, but for all solution I created, I also see a situation, when they do not work.\nI tried use Greedy Algorithm. The best idea, which I have is take the bricks from towers, which are bigger that the clever child. If the size of taken bricks + tower of clever child is still less, take the biggest bricks from all towers.\nUnfortunately, problem is when we have sets like this:\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], [2,2,2,2,2,2,2], [7,4,1], [9, 2]\nand tower of clever child has size 13\nHave anyone idea or hints how to solve this task?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Python. Greedy algorithm, 2 for loops iterating over lists\r\n                \r\nI am trying to write a greedy algorithm where I have a constraint on how many items I can fit into a box and I have to fit as many items in a box as possible before moving on to the next one (ie maximizing the weight of each box).\n\nI've been trying to solve this by creating two identical lists, let's say ```\na_list```\n and ```\nb_list```\n. \n\n```\na_list = [9, 8, 6, 4, 3, 2, 2, 2]\nb_list = [9, 8, 6, 4, 3, 2, 2, 2]\n```\n\n\nThe constraint on each box is 10 here, so for example I can only fit the first item (9) into one before moving onto the next box. The following box should contain 8 + 2.\n\nEach box is a list within the main list ie \n\n```\nlist_ = [[9], [8,2],[6,4].....]\n```\n\n\nI can only move on to next box once the current one cannot have further items fitted into it.\n\nWhen I am trying iterate through the two lists I don't know how to delete items to avoid them appearing multiple times in ```\nlist_```\n.\n\nI'm close but I have a couple of items coming up twice while one doesn't come up at all.\n\nIt is also the case that despite my sorting the lists in descending order, not all my boxes are optimal, one of them only has one item with value '2' in it. I know it's to do with the loop but I don't understand why it's not going through the items in descending order.\n\n```\nlimit = 10\nlist_ = [[]]\n\nfor i in a_list:\n   for j in b_list:            \n\n       if sum(l[-1]) + i + j <= limit:\n\n           l[-1].append(i)\n           l[-1].append(j)\n           b_list.remove(j)\n\n       elif sum(l[-1]) + j <= limit:\n           l[-1].append(j)\n           b_list.remove(j)\n\n       else:\n           l.append([])\n```\n\n    ", "Answer": "\r\nThe only reason I think that you're using an ```\na_list```\n and a ```\nb_list```\n is that you assume you need to pick two items per box, which need not be the case. \n\nI think you should use a single list, and use a list index based approach to track which items are added.\n\nYou also will have issues with deletes, so try setting items that are added to -1 and filter them out after each pass, to avoid confusions with deletes while looping.\n\nI'm resisting sharing the solution code here, but ping me if you need it.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Mailman uses greedy algorithm to deliver as many letters as possible [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed last year.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nSo my professor asked this on the test the other day and I am not sure I got it right.\nA mailman has only one hour to deliver as many letters as possible(one by one). In order to deliver a letter in distance n it takes 5 + 0 .5logn minutes (log with base 3). He decides which letters he will deliver using a greedy algorithm. If the distances of each letter is given in the matrix how many letters will he deliver?\nA = 3, 3, 3, 9, 9, 3, 3, 27, 27, 27, 81, 9, 81, 81\nI thought that he will choose to deliver the letters with the minimum distance first because these take less time (so the ones with distance 3, then those with a distance of 9 etc...).\nSo my answer was 5 letters with distance 3 (time = 27.5), then 3 letters with distance 9 (18 additional minutes, so the total is 45.5) and then 2 of distance 27 so the total time is 58.5 .\nAm I thinking this right???\n    ", "Answer": "\r\nIf A represents the distances between postoffice and mailbox for the letter and mailman can only deliver one letter per run, then yes. Actually this problem is called \"Knapsack problem\". You can find further information on the internet.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm not functioning properly\r\n                \r\nThis code is supposed to give me the least amount of coins (quarters, dimes, nickels, and pennies) that add up to the amount owed.\nwhen I enter values that are multiples of 0.25, it works seamlessly. But when I enter other values in the terminal, it just inserts a new line without doing anything. how did I mess up?\n\n```\nowed = float(input(\"how much change is owed?\"))\ncoins = 0\n\nif owed % 0.25 == 0:\n    coins = owed / 0.25\n    print(int(coins))\n    exit()\nelif owed % 0.25 != 0:\n    while owed > 0:\n        if (owed - 0.25) >= 0:\n            coins += 1\n            owed -= 0.25\n        elif (owed - 0.10) >= 0:\n            coins += 1\n            owed -= 0.10\n        elif (owed - 0.05) >= 0:\n            coins += 1\n            owed -= 0.05\n        elif (owed - 0.01) >= 0:\n            coins += 1\n            owed -= 0.01\n    print(int(coins))\n    exit()\n```\n\n    ", "Answer": "\r\nYour program is running infinite ```\nwhile```\n loop due to some roundoff errors related to Float values caused by the internal representation of floating point numbers. So to fix these errors, we can use ```\nround()```\n function to roundoff the value ```\nowed```\n at the end of each ```\nwhile```\n loop iteration:\n\n```\nelif owed % 0.25 != 0:\n    while owed > 0:\n        if (owed - 0.25) >= 0:\n            coins += 1\n            owed -= 0.25\n        elif (owed - 0.10) >= 0:\n            coins += 1\n            owed -= 0.10\n        elif (owed - 0.05) >= 0:\n            coins += 1\n            owed -= 0.05\n        elif (owed - 0.01) >= 0:\n            coins += 1\n            owed -= 0.01\n        owed = round(owed, 3) # In this line, we roundoff the value of owed\n    print(int(coins))\n    exit()\n```\n\n\nand this works fine.\n\nHope this helps :)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Finding maximum element in an array - is it that you will call greedy algorithm or brute force algorithm or both?\r\n                \r\nSuppose an array of integers is given:\n\n```\n{1,3,2,4,6,5,2} \n- MAX: 6\n```\n\n\nUsing Brute force, finding maximum element in this is to observe every element (each element is a candidate for the solution), thus searching entire search space.\n\nConsidering Greedy approach, we will modify the maximum element at each element of the array if necessary. Thus a local optimal choice will eventually lead to global optimal choice.\n\nAre brute force and greedy approach similar here? So what exacty the difference between two algos in general?\n\nApproach:\n\nBrute force - Starting from first element - 1 taking it as max. Now considering each and every next element in array - entire search space. Choosing maximum at each step if necessary. This is brute force.\n\nGreedy Algorithm - starting from nothing, taking first element - taking it max as 1. Then considering second element - 3, making local optimal choice between 1 and 3- taking 3 as maximum. And so on for other elements. At last, we will have 6 as maximum element- the global optimal choice.\n\nHow will you exactly tell the difference between the two algos in general?\n    ", "Answer": "\r\nFinding the maximum element in an unsorted array will require the brute-force approach. \n\nThere are ways of minimizing the complexity of this operation by using data-structures such as heaps, which sort the data as it is being added to the structure.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm to maximize score\r\n                \r\nI am trying to implement a method in java which takes as input an ArrayList of objects that have a deadline, a score, and object number. Each is accessible as:\n```\ngame.get(i).number\ngame.get(i).score\ngame.get(i).deadline\n```\n\nWhere ```\ngame```\n is the ArrayList and ```\ni```\n is the index.\nI want to maximize the score I can achieve while considering the deadline for each game. Each game has to be completed before the deadline. e.g. if deadline is 5, it has to be completed at 4 or earlier.\nFor example, here is a sample ArrayList with it's corresponding data organized in descending order of the score worth:\n```\nIndex     Game number     Score     Deadline\n0         3               76        3\n1         4               66        2\n2         1               52        2\n3         6               51        4\n4         5               47        2\n5         2               23        1\n\n```\n\nThen the following ArrayList could be the result:\n```\nmaximizedScore = [4,1,3,6] ```\n -> here each index represents the hour. Even though game 3 has a higher score than game 4 and game 1, we put game 4 in index 0 and game 1 in index 1 as they both have a deadline of 2 so they must be completed before then. However, game 3 has a deadline of 3 so we can do it at hour 2 in order to maximize the total score. Note that game 5 also has the same deadline as game 4 and 1, but it has less points than both so we sacrifice it.\nEdit: Each index (0,1,2,3,4,..) represents the hour while the value at the index represents the game number being completed at that hour.\nEdit 2: We can only do one game per hour. So if the latest deadline in the data is x, then we can do a max of x games. I.e. 4 in this example.\nThis provides a maximum score of 245.\nThe order of games does not matter as long as they are before the deadlines. For example: ```\n[1,4,3,6]```\n would also be acceptable as both game 4 and game 1 are being completed before the deadline.\nUnfortunately, I have no idea how to go about implementing this. Hopefully I provided a clear idea of what I need.\nAny help is appreciated!\n    ", "Answer": "\r\nI will try to give a general approach without writing any code yet.\nI will call the result you are looking for the \"schedule\". As you explained in your question, the maximum number of games you can place in your schedule is indicated by the maximum value in the \"Deadline\" column of your input data. I will call this the \"time limit\".\nYou are asking for a greedy algorithm. Such an algorithm will generate and check all game schedules to find the one that maximizes your score.\nBasic approach\nThe most basic approach you can take is to generate all permutations of games of length \"time limit\" or less. For each one of them, you would then check:\n\nis it indeed a valid schedule (is each game in the tentative schedule payable at the time it is placed?),\ndoes this tentative schedule yield a total score greater than the best score obtained so far ? If so, you \"keep\"  this solution and continue trying other schedules\n\nThe main difficulty in this first approach is to correctly generate all the possible schedules. I.E:\n\n0\n0 1\n0 1 2\n0 1 2 3\n0 1 2 3 4\n0 1 2 4\n0 1 2 4 3\n0 1 3\n....\n1\n1 0\n1 0 2\n....\n\nOptimizations\nNow, the basic approach above has some ineficiencies. For instance, when you are building the possible schedule and you build one that is impossible due to the deadline criteria. For example:\n\n3 5\n\nis an impossible schedule because game \"5\" has a deadline of 1 (meaning it can only be played as the first game or not a all). If you can recognize this, then you realize that any schedule that starts with ```\n3 5```\n (```\n3 5 0 ...```\n, ```\n3 5 1 ...```\n) is also impossible.\nYou can exploit this fact if you generate the schedule in a clever order and skip the generation of the schedules that you know are not going to be possible.\nTips for algorithm\nI would suggest generating the schedules in a recursive manner. You have all your game ids (0, 1, etc) in a collection. You start with the lowest index: 0 , remove it from the collection of games and place it in your tentative schedule:\nSchedule: ```\n0      ```\n\nYou check if it is a valid schedule (i.e. if the game you just placed in your schedule can be played at that time). Let's assume that it is the case (in this specific case as it is the first game on the schedule, it should always be possible). You also check if this tentative schedule yields a better score than anything you found so far.\nThen you try to add the lowest game left in your collection of games left to play. In this case, ```\n1```\n. Same thing you remove ```\n1```\n from the collection of games and place it on your schedule:\nSchedule: ```\n0 1    ```\n\nSame thing, you check if this is a valid schedule. You already know that game ```\n0```\n can be played first, you check if game ```\n1```\n can be played in second position. Bad luck, the time limit of game ```\n1```\n prevents you from doing it. It is not worth exploring the schedules that start with ```\n0 1```\n anymore. You remove ```\n1```\n from your schedule, but you do not replace it in the games collection: as it is impossible to play in second position, it is not worth checking it further. Instead, I would place it in a collection of games that were \"excluded\" at the current exploration level.\nYou then move on to the next game remaining in the game collection, ```\n2```\n and follow the same routine. If you are able to place a game on your schedule that is compatible with the time limit, you can continue adding games on you schedule with the ones that remain in the games collection. Be careful to recognize that there may be cases where you completely fill your schedule but there are still games left (or vice versa, you still have holes in your schedule but there are no games that can be played left).\nWhen you have run out of options, it is time to remove games from the schedule. Remove the last game you placed on your schedule and place it back in the games collection. Also place the games that you have excluded at the current level back into the games collections. You can continue the schedule generation. Be careful not to take the game you just removed at this level again though.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Algorithm: maximizing the output of a pastry shop. How to without the greedy algorithm? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nHere the problem:\n\nyou got a list of ingredients (assuming their value unitary) with\ntheir respective quantities, and a list of products.  Each product got\na price and the recipe which contain the needed ingredients an their\nquantities.\nYou need is to maximize the total proceeds from those products with\nthe given ingredients.\n\nThe first thing blowing up in my mind is to create a price/(n° needed items) ratio and start creating the products with the highest ratio. I know that this is some kind of greedy algorithm (if I'm not wrong) and not always lead to the best solution but I had no other implementable ideas.\nAnother way may be to brute-force all the possibilities, but I'm not able to realize how I can implement it; I'm not so familiar with the brute-forcing. My first brute-force algorithm was this one, but it was easy because it was with numbers and, furthermore, the element that comes after is not precluded by the previous elements.\nHere the things are different, because the next element is a function of the available ingredients, whom are influenced from the previous products, and so on.\nHave you any hint? This is some kind of homework, so I prefer not a direct solution, but something to start from!\n\nThe language I have to use is C\nMany thanks in advance :)\n    ", "Answer": "\r\nI would first try looking at this as a linear programming problem; there are algorithms available to solve them efficiently.\n\nIf your problem can't accept a fractional number of items, then it is actually an integer programming problem.  There are algorithms available to solve these as well, but in general it can be difficult (as in time-consuming) to solve large integer programming problems exactly.\n\nNote that a linear programming solution may be a good first approximation to an integer programming solution, e.g. if your production quantities are large.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm in C _cashier\r\n                \r\nI am currently taking Harvard's CS50 - Introduction to cs and I have no previous coding experiences. So ı am kind of having a hard time with the assignments.\nThe main purpose of my code is to calculate the minimum number of coins( 25, 10, 5, and 1) used for a given amount of cash. Besides, I have to convert dollars to cents. Here is my code:\n```\n#include <cs50.h>\n#include <stdio.h>\n#include <math.h>\n\nint main (void)\n{\n\nint change = 0;\n\n float dollars = get_float(\"Change: \");\n int cents = round( dollars * 100);  \n\nwhile ( 0 > dollars ) \n; \n   \n{\n    if ( cents >= 25)\n    {\n        cents = cents - 25;\n        change++;\n    }\n    else if ( cents >= 10)\n    {\n        cents = cents - 10;\n        change ++;\n    }\n    else if ( cents >= 5)\n    {\n        cents = cents - 5;\n        change++;\n    }\n    else if ( cents >= 1)\n    {\n        cents = cents - 1;\n        change++;\n    }\n    printf(\"%i\\n\" , change);\n}\n}\n```\n\nunfortunately, ı cannot find where the bug is. When I type \"5\" it gives me the number \"1\" However, when ı type 0.25 it also gives me the result \"1\". Can anyone help?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "prove the greedy algorithm for Gas Station is valid\r\n                \r\nI'm trying to prove the solution for the problem Gas Station (LeetCode 134)\nLet's define ```\nd_i```\n to be the difference ```\ng_i - c_i```\n.\nBasically it's a greedy solution where you look for the first ```\nk```\n s.t.\n```\n\\sum_{i=k}^n d_i >= 0```\n\nLet's denote the following:\n```\nA = \\sum_{i=1}^k d_i```\n\n```\nB = \\sum_{i=k+1}^n d_i```\n\nNotice that by definition of ```\nk```\n, ```\nA<0```\n and ```\nB >= 0```\n.\nSince we know that there's a unique solution:\n```\nA+B >= 0 --> B >= -A```\n\nWe want to show that ```\nB-A >= 0```\n. This will show that we have enough gas for ```\nA```\n after finishing the ```\nB```\n part.\nSo ```\nB-A >= B+B >= 0```\n\nIs my proof correct?\nThanks\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Proving optimality of greedy algorithm\r\n                \r\nProblem I came across is as follows:\n\nWe have n tasks with ```\nl_i```\n and ```\nw_i```\n being completion time and weight of task ```\ni```\n. Come up with an algorithm that minimizes ```\nsum for all i of f_i * w_i```\n where ```\nf_i```\n is time when task ```\ni```\n was finished. If for example some task i is scheduled first then ```\nf_i = t_i```\n and if second then ```\nf_i = t_i + t_(first task)```\n.\n\nI spent some time on this, I first thought that simply making the list of tasks by selecting tasks from highest weight to lowest weight will be good enough, but realized it's wrong, for example if we have 2 tasks:\n\n1 task : ```\nw_i = 10, l_i = 100```\n\n\n2 task : ```\nw_i = 9, l_i = 1```\n\n\nif we selected the one with w_i 10 first then we would get 10*100 + 9*101 = 1909 but if we selected it second we would get 9*1 + 10*101 = 1019.\n\nNow I think the optimal algo is the one that schedules tasks from highest ratio of w_i/l_i to the lowest, but I am not sure how to prove it. Could anyone help with it?\n    ", "Answer": "\r\nYou should be able to show that if the tasks are not arranged as you suggest you can improve the schedule by swapping two adjacent tasks that are in the wrong order. If you subtract total weighted completion times for these two cases you should end up looking at an expression for the difference in the weighted completion times of something like\n\nL1W1 + (L1 + L2)W2 - [L2W2 + (L2 + L1)W1] and finding that you gain by reversing the order if L1/W1 and L2/W2 compare in the wrong direction.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "finding the min number of moves by greedy algorithm\r\n                \r\nThere is a 2-d grid which contains chocolates in random cells.In one move ,i can take all the chocolates contained in one row or in one column.What will be the minimum number of moves required to take all the chocolates?\n\nExample:cells containing chocolates are:\n\n```\n0 0\n1 1\n2 2\n```\n\n\nmin. no of moves =3\n\n```\n0 0\n1 0\n0 1\n```\n\n\nmin no of moves=2\n\nI guess there is a greedy algo solution to this problem.But how to approach this problem?\n    ", "Answer": "\r\nI think this is a variance of classic Set Cover problem which is proved to be NP-hard.\n\nTherefore, a greedy algorithm could only get an approximation but not the optimal solution.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm - Out of idea\r\n                \r\nI'm making a \"Ribbon Packing\" personal project, and I am stuck. \n\nI have ```\nN```\n random size blocks. I need to put all of the N blocks inside the ribbon, to have the smallest height as possible.\n\nThis is the visual result I currently get (without the part of the ```\nelse```\n).\n\nEverything is working for the first line into the ribbon, the problem is when it need to print other blocks on top of the blocks already in the ribbon. I tried several things but still nothing (i'll put the last \"version\" below).\n\n```\npublic void algoGlouton(Graphics g) {\n\n    ArrayList<Bloc> listBlocRemaining = (ArrayList<Bloc>) blocksList.clone(); \n\n    int offsetX = 13;\n    int offsetY = 600;\n    int widthAvailable= 0;\n    int smallestHeight= 300;\n\n    for (Bloc b : blocksList.clone) {\n        if(widthRemaining + b.getWidth () < ribbon.getWidth ()) {\n            widthAvailable += b.getWidth();\n\n            g.setColor(b.getColor());\n            g.fillRect(offsetX, offsetY - b.getHeight(), b.getWidth(), b.getHeight());\n            listBlocksIntoRibbon.add(b);\n\n            b.setX(offsetX);\n            b.setY(offsetY - b.getHauteur());\n            offsetX += b.getLargeur();\n\n        } else { //Below is the mess\n            // We search the smallest height\n            for (Bloc b1 : listBlocksIntoRibbon) {\n                if (b1.getHauteur() < smallestHeight) {\n                    //when we have the smallest, we go through the blocks remaining\n                    for (Bloc b2 : listBlocRemaining) {\n                        // PlaceRemaining is an int into the block class and its equal to his width\n                        // we see if the block can fit above the smallest height\n                        if (b1.getPlaceRemaining() > b2.getWidth()){\n                            b2.setX(b1.getX());\n                            b2.setY(b1.getHeight() - b2.getHeight());\n\n                            g.setColor(b.getColor());\n                            g.fillRect(b1.getX(), b1.getHeight() - b2.getHeight(), b2.getWidth(), b2.getHeight());              \n                        }\n                    }\n                }\n            }\n        }\n    }\n```\n\n\nI'm really lost right now, I did my best to resolve this, but I need some help to go further.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for rod cutting\r\n                \r\nThis is problem from civil engineering someone looks for a good solution for it\n\nAssume you have a dict of bars you need to cut where the keys are the name of the bar and the values are list of quantity and length required of this kind of bar and the standard length of the bar is 12 m\n\nHow to make the most economical solution with the minimum wastage\n\ndict{b1:(3,5),b2:(3,4),b3:(5,2.5)}\n\nnotice\n\n1- some times it's more economical to cut 3 pieces of 4 meters which makes a whole bar and this is considered as optimal solution\n\n2-the target is not to make 0 loss but trying to decrease it as much as possible\n    ", "Answer": "\r\nSo, if I read your question correctly, you have an infinite supply of 12m rods, and you are given a request for various quantities of bars, of varying sizes, and you want to figure out how to cut those bars from the supply bars while minimizing the amount of 'wastage' (where wastage is the total length of all the leftover pieces of 12m rods that you had to cut, but were not asked for.) \n\nI don't have a complete solution, but it seems to me the first step would be to make all the bars that are > 6m in length, since each of those bars will necessarily require pulling a new 12m rod from your supply. Then your problem space is reduced: you have a finite inventory of bars < 6m long that you don't want to waste if you can avoid it, and an infinite supply of 12m bars, and you need to make all the remaining requested bars that are <= 6m long.\n\nHope this helps get you started...\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Where does this greedy scheduling algorithm become sub-optimal?\r\n                \r\nThis question is inspired by another question on process allocation. This is a twist on, and enhancement of, the problem discussed there.\nWe have n processes, and we need to allocate them to the fewest possible processors. Each process has a scheduled start and finish time, which we will define in terms of time units, indexed from 1; a process will run for some contiguous sequence of time units. A processor can then be scheduled to run any number of non-overlapping processes.\nThe obvious greedy algorithm is:\n\nAt each step, schedule a maximal non-overlapping set of the remaining processes onto the next processor.\n\nHow is a maximal non-overlapping set to be chosen? We will leave the algorithm as non-deterministic, since that makes it easier to analyse and split into two sub-questions.\nEssentially, the previous question concerned behaviour if the algorithm is unlucky: what's the smallest n for which this algorithm might produce a sub-optimal allocation (i.e., require more processors than necessary)? It turns out that the answer is n=4. There are cases where two processors are sufficient, but the greedy algorithm might require three processors (though if it's lucky, it will do it in two steps).\nThis question concerns what happens if the non-determinism is always lucky:\n\nWhat's the smallest n for which this algorithm is guaranteed to be sub-optimal? That is, what's the smallest n for which we can find a set of processes where the greedy algorithm must use more processes than necessary?\n\nSince Stack Overflow actively encourages asking and answering your own question, I will do so here, and you can tell me whether my partial answer can be improved upon!\n    ", "Answer": "\r\nI think that the answer is n=7. I will try to demonstrate that things go wrong with n=7; but this only gives an upper bound. Can things go wrong with n=6? I don't think so, but I'm not sure.\n\nUpper bound\n\nSuppose that we have the following processes to schedule:\n\n\n```\n[1]```\n (i.e., the process runs during time unit 1)\n```\n[2]```\n\n```\n[4]```\n\n```\n[5]```\n\n```\n[1,2,3]```\n (i.e., the process runs during time units 1 to 3)\n```\n[2,3,4]```\n\n```\n[3,4,5]```\n\n\n\nThe optimal allocation looks to require three processors:\n\n\n```\n[1]```\n, ```\n[2,3,4]```\n\n```\n[2]```\n, ```\n[3,4,5]```\n\n```\n[1,2,3]```\n, ```\n[4]```\n, ```\n[5]```\n\n\n\nBut the greedy algorithm will produce the following:\n\n\n```\n[1]```\n, ```\n[2]```\n, ```\n[4]```\n, ```\n[5]```\n\n```\n[1,2,3]```\n\n```\n[2,3,4]```\n\n```\n[3,4,5]```\n\n\n\nThe key point here is that it'll schedule four on the first step (because it's greedy), and then after that we're left with three pairwise overlapping processes.\n\nLower bound\n\nCan things go wrong with n=6? I don't think so, but I am not certain. It looks to me as though the relevant case will be where the optimal solution requires three processors, each running two processes. Can we find a case where the greedy algorithm schedules three on the first processor, and is then left with three overlapping processes, thus requiring four processors in total?\n\nWe'll need three pairs, for the optimal solution; but we'll need these processes to be constructed in such a way that if you schedule three of them on the first step, you can't then complete in two steps. Clearly these three processes can't include one of the pairs, or else the solution can continue as it would have done with the pairs, but leaving one of them as a singleton. So it must take one from each of the pairs.\n\nIf a process could require non-contiguous time blocks, we could do it like this:\n\n\n```\n[1]```\n\n```\n[2]```\n\n```\n[3]```\n\n```\n[1,2]```\n\n```\n[2,3]```\n\n```\n[1,3]```\n (this isn't allowed, because it stops and starts again!)\n\n\nThe optimal solution would pair each singleton with its complement; the greedy algorithm would take all the singletons together on the first step, and then the pairwise overlapping processes we're left with would require three more processors. But we've cheated, because the last process listed above doesn't run for a contiguous time block.\n\nWe can't change the last one to ```\n[3,4]```\n, because then it can be run on the same processor as ```\n[1,2]```\n. In fact, we can't have three pairwise overlapping contiguous blocks unless their intersection is non-empty. So we'd end up with something like ```\n[1,2,3]```\n, ```\n[2,3,4]```\n, ```\n[3,4,5]```\n, as we had with the seven process case. The problem is that it then seems to be impossible to add three more processes that can be scheduled together, and still allow a three-processor optimal solution, without allowing for the possibility of scheduling two of the singletons with one of the triples. If we try\n\n\n```\n[1]```\n\n```\n[2]```\n\n```\n[4]```\n\n```\n[1,2,3]```\n\n```\n[2,3,4]```\n\n```\n[3,4,5]```\n\n\n\nthen the greedy algorithm might schedule ```\n[1]```\n, ```\n[2]```\n, ```\n[3,4,5]```\n on the first step, which will lead to an optimal solution (and we're looking for a case where the non-determinism is guaranteed to lead to a sub-optimal solution).\n\nIf we try\n\n\n```\n[2]```\n\n```\n[3]```\n\n```\n[4]```\n\n```\n[1,2,3]```\n\n```\n[2,3,4]```\n\n```\n[3,4,5]```\n\n\n\nthen we don't have an optimal solution on three processors, because four of the processes require time unit 3.\n\nAll of this musing suggests to me that the greedy algorithm will be optimal in the case of n=6, and that the upper bound of n=7 is therefore strict; but it falls rather short of a proof. How can we prove that it's always optimal for n=6?\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy TV Watching Algorithm\r\n                \r\nI am trying to implement the following greedy algorithm in C:\n\nAlex is a great fan of television. He wrote down all the TV programs he is interested in for\ntoday. His list contains n shows, i-th of them starts at moment li and ends at moment ri.\nAlex owns two TVs. He can watch two different shows simultaneously with two TVs but he can only\nwatch one show at any given moment on a single TV. If one show ends at the same moment some\nother show starts then you can't watch them on a single TV.\nAlex wants to check out all n shows. Are two TVs enough to do so? Write a program to help Alex\nfigure out the answer.\nInput\nThe first line contains one integer which indicate the number of shows.\nEach of the next n lines contains two integers starting and ending time of i-th show.\nOutput\nIf Alex is able to check out all the shows using only two TVs then print \"YES\" (without quotes).\nOtherwise, print \"NO\" (without quotes).\n\n\nExample input\n3\n1, 2\n2, 3\n4, 5\noutput\nYES\n\nHowever, whenever I run my implementation, I recieve a segmentation fault error. I'm sure it is something I am not seeing but I cannot seem to narrow down the issues. Below is my code:\n\n```\n#include <stdio.h>\n\nint main(){\n\n    const int num;\n\n    int A[num][2]; //should be declared after fscanf\n\nFILE* filePtr = fopen(\"input2.txt\",\"r\");\n\nfscanf(filePtr, \"%d\\n\", &num);\n\n    for(int i = 0; i < num; i++){\n        fscanf(filePtr, \"%d, %d\\n\", &A[i][0], &A[i][1]);\n    }\n\n    fclose(filePtr);\n\n    int temp[2];\n\n    for(int i = 0; i < num; i++){\n        for(int j = 0; j < (num - i) - 1; j++){\n            if(A[j][0] > A[j+1][0]){\n                temp[0] = A[j][0];\n                temp[1] = A[j][1];\n                A[j][0] = A[j+1][0];\n                A[j][1] = A[j+1][1];\n                A[j+1][0] = A[j+1][0];\n                A[j+1][1] = A[j+1][1];\n            }\n        }\n\n    }\n\n    int TV1 = 0, TV2 = 0;\n    int currentShow = 0;\n\n    for(int i = A[0][0]; i <= A[num-1][0] && currentShow < num; i++){\n        if(i == A[currentShow][0]){\n            if(TV1 == 0) TV1 = A[currentShow][1] - A[currentShow][0];\n            else if(TV2 == 0) TV2 = A[currentShow][1] - A[currentShow][0];\n            else{\n                printf(\"No.\\n\");\n                break;\n            }\n            currentShow++;\n        }\n\n        if(TV1 > 0) TV1--;\n        if(TV2 > 0) TV2--;\n    }\n\n    if(currentShow == num) printf(\"Yes.\\n\");\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\n```\nconst int num;\nint A[num][2];\n```\n\n\nThis is a rather serious problem, ```\nnum```\n hasn't been set to anything when you create ```\nA```\n. That's unlikely to end well.\n\nIf you want to use ```\nnum```\n as a dimension specifier, you should wait until you know what it is (after the first ```\nfscanf```\n). Compilers are good but I'm pretty certain they're subject to the same temporal rules as we are :-)\n\nThere's also a host of other things jumping out at me, such as:\n\n\nnot checking the return values of ```\nfopen```\n or ```\nfscanf```\n;\ntrying to modify ```\nnum```\n even though it's marked ```\nconst```\n.\n\n\nFixing those would also go a long way toward solving your problems. You should generally check any call that could have a downstream effect later on, such as with:\n\n```\nFILE* filePtr = fopen(\"input2.txt\", \"r\");\nif (filePtr == NULL) {\n    fprintf(stderr, \"Could not open input file\\n\");\n    return 1;\n}\n```\n\n\nand:\n\n```\nif (fscanf(filePtr, \"%d, %d\\n\", &A[i][0], &A[i][1]) != 2) {\n    fprintf(stderr, \"Could not get two integers from file\\n\");\n    fclose(filePtr);\n    return 1;\n}\n```\n\n\n\n\nAnd, as an aside, I'm not entirely certain I understand how your algorithm works. It may be worthwhile breaking it down into separate modules so that it's easier to understand and debug.\n\nThe approach I would take would be to work out all the timepoints you're interested in which, in your case, is everything from the minimum ```\n1```\n through the ```\nmaximum```\n5`.\n\nThen, for all of those, count the number of durations in which it appears. If that's more than two then obviously two TVs are not going to do the job. \n\nFrom a conceptual point of view, your test data would be:\n\n```\nTimepoint  Appears-in:  1-2  2-3  4-5  count\n---------  --------------------------  -----\n    1                   yes  no   no     1\n    2                   yes  yes  no     2\n    3                   no   yes  no     1\n    4                   no   no   yes    1\n    5                   no   no   yes    1\n```\n\n\nSo that one's okay.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is a greedy algorithm for this problem that is minimally optimal + proof?\r\n                \r\nThe details are a bit cringe, fair warning lol:\nI want to set up meters on the floor of my building to catch someone; assume my floor is a number line from 0 to length L. The specific type of meter I am designing has a radius of detection that is 4.7 meters in the -x and +x direction (diameter of 9.4 meters of detection). I want to set them up in such a way that if the person I am trying to find steps foot anywhere in the floor, I will know. However, I can't just setup a meter anywhere (it may annoy other residents); therefore, there are only n valid locations that I can setup a meter. Additionally, these meters are expensive and time consuming to make, so I would like to use as few as possible.\nFor simplicity, you can assume the meter has 0 width, and that each valid location is just a point on the number line aformentioned. What is a greedy algorithm that places as few meters as possible, while being able to detect the entire hallway of length L like I want it to, or, if detecting the entire hallway is not possible, will output false for the set of n locations I have (and, if it isn't able to detect the whole hallway, still uses as few meters as possible while attempting to do so)?\nEdit: some clarification on being able to detect the entire hallway or not\n    ", "Answer": "\r\nGiven:\n\n```\nL```\n (hallway length)\na list of N valid positions to place a meter (```\np_0```\n ... ```\np_N-1```\n) of radius 4.7\n\nYou can determine in O(N) either a valid and minimal (\"good\") covering of the whole hallway or a proof that no such covering exists given the constraints as follows (pseudo-code):\n```\n// total = total length; \n// start = current starting position, initially 0\n// possible = list of possible meter positions\n// placed = list of (optimal) meter placements, initially empty\nboolean solve(float total, float start, List<Float> possible, List<Float> placed):\n\n   if (total-start <= 0): \n        return true; // problem solved with no additional meters - woo!\n   else:\n        Float next = extractFurthestWithinRange(start, possible, 4.7);\n        if (next == null):\n             return false; // no way to cover end of hall: report failure\n        else:\n             placed.add(next); // placement decided\n             return solve(total, next + 4.7, possible, placed); \n```\n\nWhere ```\nextractFurthestWithinRange(float start, List<Float> candidates, float range)```\n returns ```\nnull```\n if there are no ```\ncandidates```\n within ```\nrange```\n of ```\nstart```\n, or returns the last position ```\np```\n in ```\ncandidates```\n such that ```\np <= start + range```\n -- and also removes ```\np```\n, and all candidates ```\nc```\n such that ```\np >= c```\n.\nThe key here is that, by always choosing to place a meter in the next position that a) leaves no gaps and b) is furthest from the previously-placed position we are simultaneously creating a valid covering (= no gaps) and an optimal covering (= no possible valid covering could have used less meters - because our gaps are already as wide as possible). At each iteration, we either completely solve the problem, or take a greedy bite to reduce it to a (guaranteed) smaller problem.\nNote that there can be other optimal coverings with different meter positions, but they will use the exact same number of meters as those returned from this pseudo-code. For example, if you adapt the code to start from the end of the hallway instead of from the start, the covering would still be good, but the gaps could be rearranged. Indeed, if you need the lexicographically minimal optimal covering, you should use the adapted algorithm that places meters starting from the end:\n```\n// remaining = length (starts at hallway length)\n// possible = positions to place meters at, starting by closest to end of hallway\n// placed = positions where meters have been placed\nboolean solve(float remaining, List<Float> possible, Queue<Float> placed):\n\n   if (remaining <= 0): \n        return true; // problem solved with no additional meters - woo!\n   else:\n        // extracts points p up to and including p such that p >= remaining - range\n        Float next = extractFurthestWithinRange2(remaining, possible, 4.7);\n        if (next == null):\n             return false; // no way to cover start of hall: report failure\n        else:\n             placed.add(next); // placement decided\n             return solve(next - 4.7, possible, placed); \n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Time complexity for a greedy recursive algorithm\r\n                \r\nI have coded a greedy recursive algorithm to Find minimum number of coins that make a given change. Now I need to estimate its time complexity. As the algorithm has nested \"ifs\" depending on the same i (n * n), with the inner block halving the recursive call (log(2)n), I believe the correct answer could be O(n*log(n)), resulting from the following calculation: \n\n\n  n * log2(n) * O(1)\n\n\nPlease, give me your thoughts on whether my analysis is correct and feel free to also suggest improvements on my greedy recursive algorithm.\n\nThis is my recursive algorithm:\n\n```\ncoins = [1, 5, 10, 21, 25]\ncoinsArraySize = len(coins)\nchange = 63\npickedCoins = []\n\ndef findMin(change, i, pickedCoins):              \n    if (i>=0):\n        if (change >= coins[i]):               \n           pickedCoins.append(coins[i])\n           findMin(change - coins[i], i, pickedCoins)\n        else:           \n           findMin(change, i-1, pickedCoins)\nfindMin(change, coinsArraySize-1, pickedCoins)\n```\n\n    ", "Answer": "\r\nEach recursive call decreases change by at least 1, and there is no branching (that is, your recursion tree is actually a straight line, so no recursion is actually necessary). Your running time is ```\nO(n)```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Removing a Tuple from a list of tuples while iterating a greedy algorithm - python\r\n                \r\nI'm trying to write a greedy algorithm and I have a list of tuples: \n\ncow_list = [('Betsy', 9), ('Henrietta', 9), ('Herman', 7), ('Oreo', 6), ('Millie', 5), ('Maggie', 3), ('Moo Moo', 3), ('Milkshake', 2), ('Lola', 2), ('Florence', 2)]\n\nI'm trying to iterate through the list:\n\n```\ndef greedy_cow_transport(cow_list, maxWeight):\ntransport_name = []\ntaken_transport = []\nnot_taken = []\ntransport_weight = []\nfor i in range(len(cow_list)):\n    total_weight = sum(transport_weight)\n    if (total_weight+cow_list[i][1]) <= maxWeight:\n        transport_name.append(cow_list[i][0])\n        transport_weight.append(cow_list[i][1])\n        total_weight += cow_list[i][1]\n    elif (total_weight+cow_list[i][1]) > maxWeight:\n        taken_transport.append(cow_list[i][0])            \n```\n\n\nAnd what I'm trying to do is delete the first tuple in the list if > maxWeight so the for loop can start the process over again without using that first tuple.\n\nSo I want the final result to be:\n\ntransport_name = [['Betsy'], ['Henrietta'], ['Herman', 'Maggie'], ['Herman', 'Moo Moo'], ['Herman', 'Milkshake'], etc. with all combinations where the sum of the values is <10.\n\nPlease let me know if my question doesn't make sense.\n    ", "Answer": "\r\nA very ad-hoc approach,\n\n```\ndef greedy_cow_transport(cow_list, maxWeight):\n    transport_name = []\n    taken_transport = []\n    not_taken = []\n    transport_weight = []\n    for i in range(len(cow_list)):\n        # Store an initial element\n        temp_name.append(cow_list[i][0])\n        temp_weight.append(cow_list[i][1])\n        total_weight = sum(temp_weight)\n\n        # Iterate on all the elements to the right\n        for j in range(i, len(cow_list)):\n            if (total_weight + cow_list[j][1])<= maxWeight:\n                temp_name.append(cow_list[j][0])\n                temp_weight.append(cow_list[j][1])\n                total_weight = sum(temp_weight)\n            else:\n                taken_temp_transport.append(cow_list[j][0])\n\n        transport_name.append(temp_name)\n        transport_weight.append(temp_weight)\n        taken_transport.append(taken_temp_transport)\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm by selecting vertices with least number of edges for maximum matching?\r\n                \r\nI'm learning Blossom Algorithm, but I am confused why you can't simply do this greedy approach that I thought of. Does anyone have a counterexample?\n```\nWhile no more vertices:\n    Choose the vertex (V) with the least number of edges\n    Considering vertices connected to that vertex V, choose one with the least number of edges.\n    Create this edge and don't consider these two vertices anymore. \n    Reduce the count of edges on each vertex accordingly. Repeat\n```\n\n    ", "Answer": "\r\n```\nE         G\n|\\       /|\n| A-B-C-D |\n|/       \\|\nF         H\n```\n\nIf at the first step you choose BC, you lose, because you are left with 2 odd cycles and you cannot cover all the vertices. The optimal matching is AB CD EF GH.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Can we solve the \"printing neatly\" problem using a greedy algorithm rather than dynamic programming?\r\n                \r\nThe \"printing neatly\" problem in the \"introductions to algorithms\" book is solved via dynamic programming. It's Problem 5.3 and the solution is found here\n\nI think this problem could be simply solved by a greedy algorithm. Just put as many words per line as possible intil you can't fit the next word and so move to a new line.\n\nCan someone help me understand if this solution is enough ? (the greedy algo)\n\nHere's the problem: Printing neatly\n\nConsider the problem of neatly printing a paragraph on a printer. The input text is a sequence of n words of lengths l1,l2,...,ln, measured in characters. We want to print this paragraph neatly on a number of lines that hold a maximum of M characters each. Our criterion of \"neatness\" is as follows. If a given line contains words i through j and we leave exactly one space between words, the number of extra space characters at the end of the line is the difference between M and the total number of characters in the words plus the spaces between them  .We wish to minimize the sum, over all lines except the last, of the cubes of the numbers of extra space characters at the ends of lines. Give a dynamic-programming algorithm to print a paragraph of n words neatly on a printer. Analyze the running time and space requirements of your algorithm.\n    ", "Answer": "\r\nNo, because as is often the case with greedy algorithms, short sighted decisions now (deciding how many words for the current line) end up forcing higher cost later. For example, suppose we can have 10 chars per line.\n\nGreedy solution\n\n```\nxx xxx xx    cost = 1\nxxxxx        cost = 125\nxxxxx        cost = 0 (last line)\n```\n\n\nBetter solution\n\n```\nxx xxx       cost = 64\nxx xxxxx     cost = 8\nxxxxx        cost = 0 (last line)\n```\n\n\nThe greedy solution packs more words onto the first line, but that actually produces a higher total solution cost.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm compiles with no errors but never gets past first action when run\r\n                \r\nSo I am taking cs50 and I am doing the greedy algorithm \"cash\" problem, and the code I've written compiles fine, but when I run it, it asks for \"Change amount in USD:\" and then never accepts a valid response and I'm stuck entering inputs forever and nothing happens.\n\nA friend said that I was missing an input and that's why it wasn't working, but I'm trying to use the user's input, so... Your help would be greatly appreciated, because I think I'm really close, I just have not idea how to fix it, and help50 says that technically nothing's wrong, so I'm just at a stand still.\n\nThank you!\n\n```\n#include <cs50.h>\n#include <stdio.h>\n#include <math.h>\n\nint main(void)\n{\n    // identifying variables\nfloat amount;\nint cents;\nint count = 0;\n\n// prompting user for input\ndo\n{\n    amount = get_float(\"Change amount in USD: \");\n}\n// ensuring a positive number\nwhile (amount < 0);\n\n//changing float to an int\n    cents = round(amount*100);\n\n// using highest denomination first (quarters)\nwhile (cents % 25 >= 0)\n{\n    count++;\n    cents = cents % 25;\n}\n\n// using next highest denomination second (dimes)\nwhile (cents % 10 >= 0)\n{\n    count++;\n    cents = cents % 10;\n}\n\n// using next highest denomination third (nickels)\nwhile (cents % 5 >= 0)\n{\n    count++;\n    cents = cents % 5;\n}\n\n// using last denomination amount (pennies)\nwhile (cents % 1 >= 0)\n{\n    count++;\n    cents = cents % 1;\n}\n\n// displays number of coins used\nprintf(\"%i\\n\", count);\n```\n\n\n}\n    ", "Answer": "\r\n```\nwhile (cents % 25 >= 0)\n{\n    count++;\n    cents = cents % 25;\n}\n```\n\n\nThe division willl always be ```\n>= 0```\n, thus you have an infinite loop, switch to \n\n```\nwhile (cents % 25 > 0)\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy and recursive algorithm for finding shortest path for all nodes in a complete binary tree with node and edge weights\r\n                \r\nI have a setup like this\nThe first part of the question is to implement a function that generates a complete binary tree (i.e. two arrays) with a given size as input where the node and edge weights are set randomly between 1 and 20 inclusive.\nI wrote the code below for the first part and I need to develop a greedy algorithm and a recursive algorithm for finding the shortest path for all nodes in the tree.\nHow can I develop greedy and recursive algorithms guys?\n```\npublic static void main(String[] args) {\n\n    System.out.println(Arrays.toString(randWN(9)));\n    int[][] qq=randWE(9);\n\n    for (int[] row : qq)\n        System.out.println(Arrays.toString(row));\n}\n\npublic static int[] randWN(int size)\n{\n    int[] WN=new int[size];\n    for (int i = 0; i < WN.length; i++) {\n        WN[i]=getRandomNumber(1,20);\n    }\n    return WN;\n}\npublic static int[][] randWE(int size)\n{\n    int counter=0;\n    int iterator=0;\n    int[][] WE=new int[size][size];\n    for (int i = 0; i < WE.length; i++) {\n        for (int j = 0; j < WE[size-1].length; j++) {\n            if(j>iterator && counter<2)\n            {\n                WE[i][j]=getRandomNumber(1,20);\n                counter++;\n                iterator++;\n            }\n        }\n        counter=0;\n    }\n    return WE;\n\n}\npublic static int getRandomNumber(int min, int max) {\n    return (int) ((Math.random() * (max - min)) + min);\n}\n```\n\noutput of the first part is here\n    ", "Answer": "\r\nCorrect me if am mistaken, but your code does not produce a binary tree, but rather a square matrix. How does this represent a complete binary tree?\nI think an implementation using a class node with parent and child attributes which in turn are nodes as well, makes more sense?\nAnd then you just follow a greed algorithm to find the shortest path. E.g. recursively traverse the tree, always choosing to cheapest path to the next node, and backtrack once you are at a leaf. Maybe looking up binary trees on wikipedia might help.\nOr I missinterpreted something and am completely wrong.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Not getting desired output for Knapsack problem using greedy algorithm\r\n                \r\nI'm trying to implement a greedy approach for the fractional knapsack problem.\nThe input format is: The first line of the input contains the number 𝑛 of items and the capacity 𝑊 of a knapsack.\nThe next 𝑛 lines define the values and weights of the items. The 𝑖-th line contains integers 𝑣𝑖 and 𝑤𝑖—the\nvalue and the weight of 𝑖-th item, respectively.\nThe output will be the maximum value.\nI've implemented this algorithm in C++\n```\n#include <iostream>\n#include <vector>\n\nusing std::vector;\n\ndouble get_optimal_value(int capacity, vector<int> weights, vector<int> values, int n) {\n  double value = 0.0;\n  double A[] {};\n  int amt = 0;\n  for (int i = 0; i < n; i++) {\n    if (capacity = 0){\n      break;\n    }\n    else {\n      amt = std::min(weights[i], capacity);\n      weights[i] -= amt;\n      A[i] = A[i] + amt;\n      value = value + amt*(values[i]/weights[i]);\n      capacity -= amt;\n    }\n  }\n  return value;\n}\n\nint main() {\n  int n;\n  int capacity;\n  std::cin >> n >> capacity;\n  vector<int> values(n);\n  vector<int> weights(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> values[i] >> weights[i];\n  }\n\n  double optimal_value = get_optimal_value(capacity, weights, values, n);\n\n  std::cout.precision(10);\n  std::cout << optimal_value << std::endl;\n  return 0;\n}\n```\n\nWhen I'm inputting some values I'm getting output as 0\n```\n3 50\n60 20\n100 50\n120 30\n0\n```\n\nAny guidance on this will be very helpful. Thanking you in advance\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Expression Result Unused Greedy Algorithm\r\n                \r\nI have run this program and get the error expression result unused. I may be doing something simple wrong, but I have spent the day trying to figure it out to no avail. Any help you can provide is greatly appreciated.\n\n```\n#include <stdio.h>\n#include <cs50.h>\n\nint main()\n{\n    int x, y = 0;\n    printf(\"Enter the amount of change \");\n    x = GetFloat() * 100;\n    while (x != 0)\n    {\n        if (x >= 25)\n        {\n            x - 25;\n            y = y + 1;\n        }\n        if (x >= 10 && x < 25)\n        {\n            x - 10;\n        }   y = y + 1;\n        if (x >= 5 && x < 10)\n        {\n            x - 5;\n        }   y = y + 1;\n        if (x >= 1 && x < 5)\n        {   x - 1;\n            y= y + 1;\n        }\n    }\n    printf(\"The number of coins neccessary is %d\", y);\n}\n```\n\n    ", "Answer": "\r\n```\n    if (x >= 25)\n    {\n        x - 25;               // This accomplishes nothing\n        y = y + 1;\n    }\n    if (x >= 10 && x < 25)\n    {\n        x - 10;               // This accomplishes nothing\n    }   y = y + 1;\n    if (x >= 5 && x < 10)\n    {\n        x - 5;                // This accomplishes  nothing\n    }   y = y + 1;\n    if (x >= 1 && x < 5)\n    {\n        x - 1;                // This accomplishes nothing\n        y= y + 1;\n    }\n```\n\n\nIn each of those lines you're subtracting a number from ```\nx```\n, but you're doing nothing with the result.  If you're trying to update ```\nx```\n with the result, you need to do just like you're doing with ```\ny```\n, and put ```\nx =```\n in front of the expression.\n\nSo if you want ```\nx```\n to go down by ```\n25```\n, you should write:\n\n```\nx = x - 25; \n```\n\n\nAlternatively, you can write the shorthand:\n\n```\nx -= 25;     // Note the equal sign \n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm, numpy, matrix, explantation\r\n                \r\nDistance \n\nfrom 0 to 1 is 1.0\n\nfrom 1 to 2 is 3.0\n\nfrom 0 to 2 is 2.0\n\n```\nD = [\n\n     [ 0, 1.0, 2.0],\n     [ 1.0, 0, 3.0],\n     [ 2.0, 3.0, 0]\n]\n```\n\n\nSo I've got a matrix which looks like one above.\n\nBut I can't quite see why those measures are like the ones given at the top of my post?\n\nHow is distance from 0 to 1 is 1.0?\n    ", "Answer": "\r\nAh... this is a pre-loaded distance array.\n\nSay for instance that point 0 is (5,0), point 1 is (4,0), and point 2 is (7,0). Then D is preloaded with inter-point distances, ie ```\nD[from_point][to_point] = distance(from_point, to_point)```\n.\n\nThen you can refer to the matrix rather than having to recalculate distances.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "how to prove this greedy algorithm as optimal: rod connection\r\n                \r\nHere is the problem:\n\nGiven an array represents the lengths of rods on the table. Every time pick two rods and connect them and get a new rod. Do this until there is only one rod on the table.\nThe cost of a connection is the sum of two rods' lengths, for example, connect 2 with 3 will get a 5 rod and cost 5.\nWhat is the minimum cost connection strategy?\n\nGreedy: every time pick the shortest two and put the connected new rod back to the table.\n\nExample:\n\n[1,2,3,4,5] , pick 1 and 2 cost 3 [3,3,4,5], pick 3 and 3 cost 6 [4,5,6], pick 4 and 5 cost 9 [6,9], pick 6 and 9 cost 15. So that the total cost is 33.\n\nWe can't simply say that, total times of connection is the same n-1 so that every time picking smallest two will give a final minimum cost. Because every picking will change the future, like picking 1+2 and picking 2+4 will result in two different sets of rods for the next step.\n\nHow can I prove this greedy will get minimum cost?\n    ", "Answer": "\r\nThe proof is similar to a proof that Huffman'c code is optimal.\n\nThere's a binary tree corresponding to each strategy. It contains all initial rods in its leaves and inner vertices correspond to connection operations.\n\nOne can see that the cost of connecting the rods for a fixed tree is the sum of ```\na[v] * depth[v]```\n over all leaves ```\nv```\n, where ```\na[v]```\n is the length of the initial rod and ```\ndepth[v]```\n is the depth of the leave. It's the case because each rod takes part in a connection exactly ```\ndepth[v]```\n times.\n\nWe need to show that there exists an optimal strategy such that its tree has two shortest rods as siblings. \n\nLet assume that ```\nT```\n is an optimal tree. Let's sort it's leaves by their depths (in non-strictly decreasing order). If the two shortest rods are the first two leaves, we're done. Otherwise, let's keep swapping them with their left sibling (which is at least as long as them) until they get into the first two positions. When we swap 2 leaves ```\nu```\n and ```\nv```\n, the cost change is ```\n-depth[u] * a[u] - depth[v] * a[v] + depth[u] * a[v] + depth[v] * a[u]```\n = ```\n(depth[v] - depth[u]) * (a[u] - a[v])```\n. The first term is non-positive (as the leaves were sorted by their height) and the second term is non-negative (as ```\na[u] >= a[v]```\n). Thus, the cost change is negative or zero.\n\nHence, there exists an optimal tree where two shortest rods are siblings. It means that there's an optimal strategy where we connect these two rods before we do anything else.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "min change greedy algorithm in java\r\n                \r\nOk so i need to make a program to ask me for an amount of money, then I need it to tell me the least amount of coins to make it.  The coins I can use are: dollars, quarters, dimes, nickels, and pennies. For example, When I run the program it's supposed to look like this:\n\n```\n> run Coins\nEnter the amount of given money:\n [1.73]\nGive the seller 8 coins:\n1 dollars,\n2 quarters,\n2 dime,\n0 nickels,\n3 pennies.\n```\n\n\nThis is What I have so far:\n\n```\nimport java.util.Scanner;\n\nclass Coins {\n  public static void main (String args[]) {\n     Scanner input = new Scanner(System.in);\n     double  money;\n     System.out.println(\"Enter the amount of money \");\n     money = input.nextDouble();\n\n\n\n\n     while (money > 0.0 ){\n       if (money >= 1) {\n          System.out.println(money/1+\"dollars\");\n          money -= 1;\n\n     }\n       else if (money>=.25) {\n         System.out.println(money/.25+\"quarters\");\n         money-=.25;\n\n       }\n       else if (money>=.10) {\n         System.out.println(money/.10+\"Dimes\");\n         money-=.10;\n       }\n       else if (money>=.05) {\n         System.out.println(money/.05+\"Nickels\");\n         money-=.05;\n       }\n       else if (money>=.01) {\n         System.out.println(money/.01+\"Penny\");\n         money-=.01;\n       }\n     }        \n  }\n}  \n```\n\n\nThe part I need help with is this: If I run the program and enter the amount 1.73, the way I have the code written, it takes the number 1.73, divides it by 1, and prints \"1.73 dollars\". I need a way to get rid of the decimal part so instead of printing \"1.73 dollars\", it prints \"1 dollar\". But I'm not sure how to do this. I tried converting it to an int but it messes up the flow of the other statements. Please help me.\n    ", "Answer": "\r\nYou should use the combination of ```\nfloor```\n with casting to ```\ndouble```\n, the following code works:\n\n```\nclass Coins {\n    public static void main (String args[]) {\n        double  money = 1.73;\n\n        while (money > 0.0 ){\n            if (money >= 1) {\n                System.out.println(Math.floor(money/1)+\" dollars\");\n                money -= Math.floor(money/1)*(double)1;\n\n            }\n            else if (money>=.25) {\n                System.out.println(Math.floor(money/.25)+\" quarters\");\n                money-=Math.floor(money/.25)*(double).25;\n\n            }\n            else if (money>=.10) {\n                System.out.println(Math.floor(money/.10)+\" Dimes\");\n                money-=Math.floor(money/.10)*(double).10;\n            }\n            else if (money>=.05) {\n                System.out.println(Math.floor(money/.05)+\" Nickels\");\n                money-=Math.floor(money/.05)*(double).05;\n            }\n            else if (money>=.01) {\n                System.out.println(Math.round(money/.01)+\" Penny\");\n                money-=Math.round(money/.01)*(double).01;\n            }\n        }\n    }\n}\n```\n\n\nAnother bug you had:\nYou should subtract ```\nMath.floor(money/XXX)*(double)XXX```\n not ```\n(double)XXX```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Javascript Greedy Algorithm Making Change\r\n                \r\nI'm working on the classic \"making change\" problem, which is highly documented in plenty of other languages, but there's not much out there for it in Javascript. So far, I have this:     \n\n```\n    var total = $('#total').val();\n    var coins = [];\n\n    function makeChange(total, coins) {     \n        var remainder = 0;\n\n        if (total % 0.25 < total) {\n            coins[3] = parseInt(total / 0.25);\n            remainder = total % 0.25;\n            total = remainder;\n        }\n\n        if (total % 0.10 < total) {\n            coins[2] = parseInt(total / 0.10);\n            remainder = total % 0.10;\n            total = remainder;\n        }\n\n        if (total % 0.05 < total) {\n            coins[1] = parseInt(total / 0.05);\n            remainder = total % 0.05;\n            total = remainder;\n        }\n\n        coins[0] = parseInt(total / 0.01);\n    }\n\n    function showChange(coins) {\n        if (coins[3] > 0) {\n            $('.quarter').html(coins[3] + \" quarter(s).\");\n        }\n\n        if (coins[2] > 0) {\n            $('.dime').html(coins[2] + \" dime(s).\");\n        }\n\n        if (coins[1] > 0) {\n            $('.nickel').html(coins[1] + \" nickel(s).\");\n        }\n\n        if (coins[0] > 0) {\n            $('.penny').html(coins[0] + \" pennies.\");\n        }\n    }\n\n    makeChange(total, coins);\n    showChange(coins);\n```\n\n\nHowever, this seems awfully repetitive and I'm finding that with certain values, it's a penny off. How can I make it more accurate and concise? \n    ", "Answer": "\r\n\n  I'm finding that with certain values, it's a penny off.\n\n\nProbably due to floating-point issues. And you shouldn't use ```\nparseInt```\n to convert a number - it's meant for strings.\n\n\n  this seems awfully repetitive\n\n\nA loop, with a data structure that represent the different coins will help. You already did something like that for your result: ```\ncoins```\n is an array, not 4 different variables.\n\n```\nfunction makeChange(total, values) { \n    var coins = [],\n        epsilon = 1e-5; // this is wrong in general!\n    // assume values are ascending, so we loop backwards\n    for (var i=values.length; i--; ) {\n        coins[i] = Math.floor(total / values[i].val + epsilon);\n        total %= values[i].val;\n    }\n    return coins;\n}\n\nfunction showChange(coins, values) {\n    for (var i=values.length; i--; ) {\n        var el = $(values[i].sel);\n        if (coins[i] > 0) {\n            el.html(coins[i] + \" \"+values[i].name+\".\");\n        } else {\n            el.empty();\n        }\n    }\n}\n\nvar values = [\n    {val:0.01, sel:'.penny', name:\"pennies\"},\n    {val:0.05, sel:'.nickel', name:\"nickel(s)\"},\n    {val:0.10, sel:'.dime', name:\"dime(s)\"},\n    {val:0.25, sel:'.quarter', name:\"quarter(s)\"}\n];\nshowChange(makeChange(parseFloat($('#total').val()), values), values);\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "SPOJ: DCOWS Why a Greedy algorithm does not work?\r\n                \r\nQuestion Link: https://www.spoj.com/problems/DCOWS/\n\nI am trying to figure out why my greedy approach to solve the above problem does not work.\n\nGiven two lists ```\nB```\n & ```\nC```\n with corresponding sizes of ```\nN```\n & ```\nM```\n with ```\n(M > N)```\n, consisting of heights of bulls and cows respectively as inputs to this question, my approach to solve this problem is as follows:\n\n\nSort both lists ```\nB```\n & ```\nC```\n in non-decreasing order\nSet ```\nk = 0```\n\nFor each item Bi in ```\nlist B```\n\n\n\nUsing modified binary search on ```\nC[k..M-N+i]```\n find an element Cj at position j, ```\n0<=j<=M-N```\n in ```\nlist C```\n which has the minimum absolute difference with Bi\nAdd abs(Bi - Cj) to the result\nUpdate ```\nk = j + 1```\n for next iteration of the loop\n\n\n\nHere is the code:\n\n```\n#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint my_bsearch(long *arr, int lo, int hi, long x)\n{\n    int mid = lo + (hi - lo)/2;\n    if (lo == mid)\n    {\n        if (abs(x - arr[lo]) <= abs(x - arr[hi])) return lo;\n        else                  return hi;\n    }\n\n    if ((mid-1 >= 0) && (abs(x - arr[mid-1]) <= abs(x - arr[mid])))\n        return my_bsearch(arr, lo, mid, x);\n    else\n        return my_bsearch(arr, mid, hi, x);\n}\n\nint main() {\n    int M, N;\n    cin >> N >> M;\n\n    long bulls[N], cows[M];\n    for (int i=0; i<N; i++) cin >> bulls[i];\n    for (int i=0; i<M; i++) cin >> cows[i];\n\n    sort(bulls, bulls + N);\n    sort(cows, cows + M);\n\n    long long min_val = 0, lo = 0, hi = M-N;\n    for (int i=0; i<N; i++) {\n        lo = my_bsearch(cows, lo, hi, bulls[i]);\n        min_val += abs(bulls[i] - cows[lo]);\n        lo++, hi++;\n    }\n    cout<< min_val << endl;\n\n    return 0;\n} \n```\n\n    ", "Answer": "\r\nAs described in this similar question Can we solve the “printing neatly” problem using a greedy algorithm, a greedy solution is often led astray. Consider this data:\n\nBulls: 5, 5\n\nCows: 1, 6, 15\n\nYour algorithm outputs minimum distance of 11 (pairs 5 to 6, and then 5 to 15). But the optimal solution is clearly 5 (pairing 5 to 1, and 5 to 6).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Find an algorithm that minimize the maximum distance of two sets, better than Greedy algorithm\r\n                \r\nHere is the interesting but complicated problem:\n\nSuppose we have two sets of points. One set A includes points in some space grid, like regular 1D or 3D grid. The other set B includes points that are randomly spaced and are of the same size as the space grid. Mathematically, we could order the two sets and construct a corresponding matrix with respect to the distance between A and B. For example, A(i, j) may refer to the distance between i of A and j of B.\n\nGiven some ordering, we have a matrix. Then, the diagonal element (i,i) in the matrix is the distance between point i of A and point i of B. The problem is how to find a good reordering/indexing such that the maximum distance is as small as possible? In matrix form, how to find a good reordering/indexing such that the largest diagonal element as small as possible?\n\nNotes from myself:\n\n\nSuppose set A is corresponding to rows of the matrix, and set B is to columns of the matrix. Then reordering the matrix means we are doing row/column permutation. Therefore, our problem is equivalent to find a good permutation to minimize the largest diagonal element.\nGreedy algorithm may be a choice. But I am trying to find an ideally perfect reordering that minimize the largest diagonal element.\n\n    ", "Answer": "\r\nThe reordering you are referring to is essentially a correspondence problem i.e. you are trying to find the closest match for each point in the other set. The greedy algorithm will work fine. The distance you are looking for is commonly referred to as the Hausdorff distance.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy algorithm for set cover c++\r\n                \r\nMinimum Set Cover is a question where you must find the minimum number of sets needed to cover every element. \nFor example, imagine that we have a set of ```\nX=array(1,2,3,4,5,6)```\n and 5 another set S, where  \n\n```\nS[1] = array(1, 4)   \nS[2] = array(2, 5)   \nS[3] = array(3, 6)  \nS[4] = array(1, 2, 3)   \nS[5] = array(4, 5, 6) \n```\n\n\nThe problem is to find minimum number of sets of S which cover every element of X. So obviously the minimum set cover in our case will be ```\nS[4]```\n and ```\nS[5]```\n because they cover all the elements.\nDoes anybody have an idea how to implement this code in C++. Note, that this is NP-complete so there is no fast algorithm to solve it. Any solution in C++ will be welcomed.\nAnd by the way it is not a homework, I need to use this algorithm in Quine–McCluskey project in order to generate the last part of solution.\nThanks in advance.\n    ", "Answer": "\r\nSo, you are in a state, where you identified all prime implicancts with the Quine & McCluskey method. Then you have created the prime implicant table and extracted the essential prime implicants. You checked row and columns dominance end eliminated redundant rows and columns. But then you came to an end and have a cyclic core left.\n\n```\n     Ac Bc Ab bC aB aC \n  3   X  X\n  5         X  X\n  7   X     X\n  9               X  X\n 11      X        X\n 13            X     X\n```\n\n\nAnd now you want to employ the set cover problem to find out all minimum necessary prime implicants.\n\nFor this you can use Petrick's method. It is an exact method and will give you a set of minimum results. The implementation is rather simple. 10 lines of code:\n\n```\nusing MintermSet = std::set<MinTermNumber>;\nusing Minterm = std::set< BooleanVariable>;\nusing MintermVector = std::vector<MinTermNumber>;\n\nusing MaxtermSet = std::set<MaxTermNumber>;\nusing ConjunctiveNormalForm = std::set<MaxtermSet>;\n\nusing ProductTerm = std::set<BooleanVariable>;\nusing ProductTermVector = std::vector<ProductTerm>;\n\n// Disjunctive Normal Form\nusing DNF = std::set<ProductTerm>;\n// Conjunctive Normal Form\nusing CNF = std::vector<DNF>;\n\n\nclass PetricksMethod\n{\npublic:\n    // Functors operator\n    ProductTermVector operator()(const CNF& cnf);\nprotected:\n};\n\n\n#include \"petrick.hpp\"\n\n#include <algorithm>\n\n// Functor operator for applying Petricks methhod\n\nProductTermVector PetricksMethod::operator ()(const CNF& cnf)\n{\n    // We select an iterative approach. Start with the first Element of the CNF (which is a DNF)\n    // And we sorte the result of each iterative operation again in this element\n    DNF resultingDNF{ cnf[0] };\n    // We will always start with the element 1 (not element 0) becuase in 0 is the initial value\n    // or respectively the intermediate result\n    for (CNF::size_type dnfInCnfIndex = 1; dnfInCnfIndex < cnf.size(); ++dnfInCnfIndex)\n    {\n        // Result of multipliyong out od the intermediate (initial) value with the current CNF Product term\n        DNF intermediateCalculatedDNF;\n        // Now go through all elements of the intermediate (initial) product term/DNF\n        // For (1+2)(3+4)  this would be the (1+2) part\n        for (const ProductTerm& productTermLeftSide : resultingDNF)\n        {\n            // Next we will iterate over all Minterms in the next DNF\n            // For (1+2)(3+4)  this would be the (3+4) part\n            for (const ProductTerm& productTermRightSide : cnf[dnfInCnfIndex])\n            {\n                ProductTerm productTerm{ productTermLeftSide }; // Resulting Product term is now 1\n                // Add all elements from the right side\n                productTerm.insert(productTermRightSide.begin(), productTermRightSide.end());   // Resulting Product term is now 1,2\n                intermediateCalculatedDNF.insert(std::move(productTerm));  // Store this one\n                // And continue to add more product terms. The stl::set will ensure the idempotence law and prevent memory waste\n            }\n        }\n        // And now add all found terms to the result and continue with the next element of the right hand side\n        // Please note: also here the set will prevent double terms\n        resultingDNF = std::move(intermediateCalculatedDNF);\n    }\n\n    // Now we have the result (with 10 lines of code). The result contains all product terms in DNF\n    // But for our prupose we are only interested in the minimum size terms\n    // so, lets find the element with the minimu size (can be more than one)\n    uint minLength{ narrow_cast<uint>(std::min_element(resultingDNF.begin(), resultingDNF.end(), [](const ProductTerm & left, const ProductTerm & right) noexcept {return left.size() < right.size(); })->size()) };\n    // And from the big list of the DNF with all product terms, we copy all elements having the minimu size to the result. These are our best coverage sets\n    ProductTermVector cheapestVector;\n    // Copy result and return it to caller\n    std::copy_if(resultingDNF.begin(), resultingDNF.end(), std::back_inserter(cheapestVector), [&minLength](const ProductTerm& pt) noexcept {return pt.size() == minLength; });\n    return cheapestVector;\n}\n```\n\n\nAll this is part of a software that you can find on GitHub. You can see also a fully implemented Quine & McCluskey algorithm.\n\nHope this helps . . .\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is a Greedy problem a recursive algorithm without overlapping sub-problems?\r\n                \r\nI am new to Data Structures and Algorithms and was wondering about Greedy approach and Dynamic Programming(DP) approach. After a long struggle I seem to sort of grasp the step by step approach to solving a DP problem. However I seem to mis-understand problems which require a greedy approach to DP problems. By definition Greedy approach means we choose the best solution at every step and DP has overlapping sub problems.\nThe root of my confusion is that I solve a DP problem recursively first then look for overlapping sub-problems and use memoisation to improve the solution.\nMy question is that can I call recursive solution for a DP problem without memoisation a Greedy Solution. For example while solving the popular Knapsack problem we either choose to add an item to the Knapsack or not. We then choose the best possible outcome at every step. Now the Knapsack problem has overlapping sub problems and is a DP Problem. But my question is what if it didn't had overlapping sub problems. Can we call the recursive approach without memoisation a greedy approach for Knapsack problem?\nPlease help me out as I am a complete beginner and this has been bugging me for a while.\nThanks!\n    ", "Answer": "\r\nFrom Your question, I understood that you are having confusion between DP and the Greedy approach.\nDP--Taking intuition about Dp, actually Dp is the approach in which we check for all possible solutions which can be a contestant for the actual solution, we select anyone from it. But the thing that makes Dp different is the overlapping subproblem. Now, what is the overlapping subproblem - suppose we have to calculate the sum of all numbers from 1 to 7, we find the answer by doing 1+2+3+4+5+6+7 and store that answer, Now we have to calculate sum from 1 to 10, now what we will do 10+9+8+ans(7) this means we have reduced our efforts of doing the same thing which we have done before. This has drastically reduced our time. So actually this is DP. Whether we apply recursion or iterative we have to store past results. So actually saying about DP, it is recursion + remembering the past answers.\nNow telling about Greedy - In greedy, we don't check for every possibility, we find the answer on the basis of the previously found optimal solution, but don't check about every possibility.\nThis concept will get more and more clear once you will solve a sufficient amount of questions on both topics.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Maximum and Minimum difference (greedy algorithm)\r\n                \r\n\nProblem:\nYou are given an array A ,of n elements.You have to remove exactly n/2 elements from an array and add it to another array B\n(intially empty).Find the maximum and minimum values of difference\nbetween these two arrays.The difference between those two arrays is\nsum(abs(A[i]-B[i]).\n\nThe code only works if the size of the array(N) is even.\nCan someone provide a solution which works when the size of array is odd as well.\n```\n#include <bits/stdc++.h>\n\nusing namespace std;     \n//This code only works for even number of elements        \n\nint main(){      \n    int n;  \n    cin>>n;   \n    vector<int> a(n);    \n    for(int i=0;i<n;i++){      \n        cin>>a[i];        \n    }       \n    sort(a.begin(), a.end());       \n    long long mn = 0,mx = 0;               \n    for(int i=0;i<n/2;i++){    \n        mx+=a[i+n/2]-a[i];         \n        mn+=a[2*i+1]-a[2*i];        \n    }\n\n    cout<<abs(mn)<<\" \"<<abs(mx)<<\" \";\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nFor me, I like to split up the work to easily visualize where efficiencies can be made in the algorithm. The following is very similar to your solution, but works fine for both even and odd length vectors. The average runtime is O(nlogn) for sort with space complexity as O(n) for the vectors.\n```\n// Given two arrays of equal length, returns their \"Difference\", O(n) runtime\nint ArrayDiff(vector<int> A, vector<int> B)\n{\n    if (A.size() != B.size() || A.size() == 0) return -1;\n\n    int sum = 0;\n    for (int i = 0; i < A.size(); i++)\n    {\n        sum += abs(A[i] - B[i]);\n    }\n    return sum;\n}\n\n// Given a vector arr, find the max and min \"Difference\"\nvoid PrintMaxAndMin(vector<int> arr)\n{\n    int n = arr.size();\n    if (n <= 0) return;\n    vector<int> Amax, Amin, Bmax, Bmin {};\n\n    // for each iteration of removing n/2 elements, we find the max and min of the arrays\n    sort(arr.begin(), arr.end());\n\n    for (int i = 0; i < n/2; i++)\n    {\n        Amax.push_back(arr[i]);\n        Bmax.push_back(arr[n-i-1]);\n\n        Amin.push_back(arr[n-i-1]);\n        Bmin.push_back(arr[n-i-2]);\n    }\n\n    cout << ArrayDiff(Amax, Bmax) << \" \" << ArrayDiff(Amin, Bmin) << endl;\n}\n\n// Run the above functions on a vector of odd and even sizes\nint main(){      \n    vector<int> arr_even = { 4,3,2,1 };\n    cout << \"Even Length Vector: \";\n    PrintMaxAndMin(arr_even);\n\n    vector<int> arr_odd = { 5,4,3,2,1 };\n    cout << \"Odd Length Vector: \";\n    PrintMaxAndMin(arr_odd);\n\n    return 0;\n}\n```\n\nHere's the working example: live example. Hope this helped.\nProgram output:\n```\nProgram stdout\nEven Length Vector: 4 2\nOdd Length Vector: 6 2\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm for coin change c++\r\n                \r\nSo, I'm creating a coin change algorithm that take a Value N and any number of denomination and if it doesn't have a 1, i have to include 1 automatically. I already did this, but there is a flaw now i have 2 matrix and i need to use 1 of them. Is it possible to rewrite S[i] matrix and still increase the size of array.... Also how can i find the max denomination and the second highest and sooo on till the smallest? Should i just sort it out in an highest to lowest to make it easier or is there a simpler way to look for them one after another? \n\n```\nint main()\n{\n    int N,coin;\n    bool hasOne;\n    cout << \"Enter the value N to produce: \" << endl;\n    cin >> N;\n    cout << \"Enter number of different coins: \" << endl;\n    cin >> coin;\n\n    int *S = new int[coin];\n\n    cout << \"Enter the denominations to use with a space after it\" << endl;\n    cout << \"(1 will be added if necessary): \" << endl;\n    for(int i = 0; i < coin; i++)\n    {\n        cin >> S[i];\n        if(S[i] == 1)\n        {\n            hasOne = true;\n        }\n        cout << S[i] << \" \";\n    }\n    cout << endl;\n    if(!hasOne)\n    {\n        int *newS = new int[coin];\n        for(int i = 0; i < coin; i++)\n        {\n            newS[i] = S[i];\n            newS[coin-1] = 1;\n            cout << newS[i] << \"  \";\n        }\n        cout << endl;\n        cout << \"1 has been included\" << endl;\n    }\n\n    //system(\"PAUSE\");\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nYou could implement it with std::vector, then you only need to use ```\npush_back```\n.\n\n```\nstd::sort```\n can be used to sort the denominations into descending order, then it's just a matter of checking whether the last is ```\n1```\n and adding it if it was missing. (There is a lot of error checking missing in this code, for instance, you should probably check that no denomination is >= 0, since you are using signed integers).\n\n```\n#include <iostream>   // for std::cout/std::cin\n#include <vector>     // for std::vector\n#include <algorithm>  // for std::sort\n\nint main()\n{\n    std::cout << \"Enter the value N to produce:\\n\";\n    int N;\n    std::cin >> N;\n\n    std::cout << \"Enter the number of different denominations:\\n\";\n    size_t denomCount;\n    std::cin >> denomCount;\n\n    std::vector<int> denominations(denomCount);\n    for (size_t i = 0; i < denomCount; ++i) {\n        std::cout << \"Enter denomination #\" << (i + 1) << \":\\n\";\n        std::cin >> denominations[i];\n    }\n\n    // sort into descending order.\n    std::sort(denominations.begin(), denominations.end(),\n        [](int lhs, int rhs) { return lhs > rhs; });\n\n    // if the lowest denom isn't 1... add 1.\n    if (denominations.back() != 1)\n        denominations.push_back(1);\n\n    for (int coin: denominations) {\n        int numCoins = N / coin;\n        N %= coin;\n        if (numCoins > 0)\n            std::cout << numCoins << \" x \" << coin << '\\n';\n    }\n\n    return 0;\n}\n```\n\n\nLive demo: http://ideone.com/h2SIHs\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm with Maximum Salary Problem?\r\n                \r\nI am trying to solve the below problem. I think my solution is working well. But, the system in which I am trying to upload the solutions, is not accepting my solution. Probably some tests are failing. May I know what am I missing?\nThe problem is:\nAs the last question of a successful interview, your boss gives you a few pieces of paper with numbers on it and asks you to compose a largest number from these numbers. The resulting number is going to be your salary, so you are very much interested in maximizing this number. How can you do this?\n\nSample 1\nInput:\n2\n21 2\nOutput: 221\n\n\nSample 2\nInput:\n3\n23 39 92\nOutput: 923923\n\nMy solution is:\n\r\n\r\n```\nfunction MaxSallary(nums) {\n  let maxSize = Math.max(...nums).toString().length;\n  let newArr = [];\n\n  nums.map((num) => {\n    while (num.toString().length < maxSize) {\n      num = num.toString().concat(num.toString().split(\"\").slice(-1)[0]);\n    }\n\n    newArr.push(Number(num));\n  });\n\n  finalArr = [];\n  while (newArr.length > 0) {\n    let minIndex = newArr.indexOf(Math.max(...newArr));\n    newArr.splice(minIndex, 1);\n    finalArr.push(...nums.splice(minIndex, 1));\n  }\n  return finalArr.join(\"\");\n}\n\nconsole.log(MaxSallary([2, 12, 34, 11, 43, 21, 5]));```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nYou want to know in which order the numbers should be concatenated, so that, once parsed back to a number, the result is the highest possible. Reworded this way, it looks like we should sort the array first.\nWhen comparing two numbers ```\na```\n and ```\nb```\n, to know which one should come first, we need to know which one is higher between ```\n${a}${b}```\n and ```\n${b}${a}```\n:\n```\n.sort((a, b) => parseInt(`${b}${a}`, 10) - parseInt(`${a}${b}`, 10)))\n```\n\n```\n.sort```\n mutates the array (and returns it), so I'm cloning it first.\n\r\n\r\n```\nfunction MaxSallary(nums) {\n  const salary = [...nums]\n    .sort((a, b) => parseInt(`${b}${a}`, 10) - parseInt(`${a}${b}`, 10))\n    .join(\"\");\n  return salary;\n}\n\nconsole.log(MaxSallary([21, 2]));\nconsole.log(MaxSallary([23, 39, 92]));\nconsole.log(MaxSallary([2, 12, 34, 11, 43, 21, 5]));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is there a problem with my Greedy Algorithm [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Looking for help regarding a greedy algorithm in C for the cs50 \"cash\" problem set [closed]\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 2 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nwhen I try to run my code, the result is:\n```\n $ ./prueba\n    Your change is...0.41\n    your cents is 41\n    prueba.c:20:19: runtime error: signed integer overflow: -2147483634 - 25 cannot be represented in type 'int'\n```\n\nI don't understand that error with the integer and how to solve it, I need to put a money as a float and calculate how many cents I'll need to pay it, so I multiply the float x100, and try to round it, but no idea why it doesn't work, my code is:\n```\n#include <cs50.h>\n#include <stdio.h>\n#include  <math.h>\nint main(void)\n{   \n    float cash;\n    do\n    {\n        cash = get_float(\"Your change is...\");\n    }\n    while (cash <= -1);\n    cash = cash * (100);\n    int cents = roundf(cash); \n    int coins = 0;\n    printf(\"your cents is %i\\n\",cents);\n    do{\n    cents = cents - 25;\n    coins++;\n    }   \n    while(cents < 24);\n    do{\n    cents = cents - 10;\n     coins++;\n    }\n    while( 25 > cents && cents < 9);\n    do{\n    cents = cents - 5;\n     coins++;\n    }\n    while ( 5 > cents &&  cents < 2);\n    do{\n        cents = cents - 1;\n         coins++;\n    }\n    while ( 4 >= cents && cents <=1);\n    printf(\"Your change is %i coins\\n\",coins);\n}\n```\n\nBtw, this is the \"easy\" project of CS50 week 1, Cash, thanks if you could help me\n    ", "Answer": "\r\nThis is wrong:\n```\ndo{\n    cents = cents - 25;\n    coins++;\n}   \nwhile(cents < 24);\n```\n\nThis is what's called a bottom-tested loop, which means a the condition is only checked after the loop body has been evaluated at least once. (The test is at the bottom or end of the loop.)\nWhat this means for you is that you unconditionally evaluate ```\ncents = cents - 25```\n even if the amount is less than 25 cents. This is incorrect, as it would make ```\ncents```\n negative! You need a top-tested loop, one which checks if the loop is entered at all. Simply put, the do-while loop needs to be replaced with a while loop.\nBut that's not the only problem. The condition under which the loop is entered is incorrect. The loop should be entered as long as the amount is greater than or equal to 25. Entering the loop as long as the amount is less than 24 is completely wrong.\nFinally, you might want separate counts for each type of coin.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm with Maximum Salary Problem?\r\n                \r\nI am trying to solve the below problem. I think my solution is working well. But, the system in which I am trying to upload the solutions, is not accepting my solution. Probably some tests are failing. May I know what am I missing?\nThe problem is:\nAs the last question of a successful interview, your boss gives you a few pieces of paper with numbers on it and asks you to compose a largest number from these numbers. The resulting number is going to be your salary, so you are very much interested in maximizing this number. How can you do this?\n\nSample 1\nInput:\n2\n21 2\nOutput: 221\n\n\nSample 2\nInput:\n3\n23 39 92\nOutput: 923923\n\nMy solution is:\n\r\n\r\n```\nfunction MaxSallary(nums) {\n  let maxSize = Math.max(...nums).toString().length;\n  let newArr = [];\n\n  nums.map((num) => {\n    while (num.toString().length < maxSize) {\n      num = num.toString().concat(num.toString().split(\"\").slice(-1)[0]);\n    }\n\n    newArr.push(Number(num));\n  });\n\n  finalArr = [];\n  while (newArr.length > 0) {\n    let minIndex = newArr.indexOf(Math.max(...newArr));\n    newArr.splice(minIndex, 1);\n    finalArr.push(...nums.splice(minIndex, 1));\n  }\n  return finalArr.join(\"\");\n}\n\nconsole.log(MaxSallary([2, 12, 34, 11, 43, 21, 5]));```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nYou want to know in which order the numbers should be concatenated, so that, once parsed back to a number, the result is the highest possible. Reworded this way, it looks like we should sort the array first.\nWhen comparing two numbers ```\na```\n and ```\nb```\n, to know which one should come first, we need to know which one is higher between ```\n${a}${b}```\n and ```\n${b}${a}```\n:\n```\n.sort((a, b) => parseInt(`${b}${a}`, 10) - parseInt(`${a}${b}`, 10)))\n```\n\n```\n.sort```\n mutates the array (and returns it), so I'm cloning it first.\n\r\n\r\n```\nfunction MaxSallary(nums) {\n  const salary = [...nums]\n    .sort((a, b) => parseInt(`${b}${a}`, 10) - parseInt(`${a}${b}`, 10))\n    .join(\"\");\n  return salary;\n}\n\nconsole.log(MaxSallary([21, 2]));\nconsole.log(MaxSallary([23, 39, 92]));\nconsole.log(MaxSallary([2, 12, 34, 11, 43, 21, 5]));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "3d \"Greedy\" Bresenham's Line Algorithm\r\n                \r\nIs there a fast (i.e. not incremental step) algorithm to find all voxels that a line intersects in 3d space?\nI compare to Bresenham's line algorithm, but I want it to be \"greedy\" such that it doesn't just form a line, but provides every single intersection. It also must be applicable to 3d space.\nThe purpose is for ray tracing, but I was hoping for a 3d grid I wouldn't have to do a method where I step a tiny bit, look at the cube the point is on, then step forward another tiny bit, until I reach the other end of the line.\n    ", "Answer": "\r\nYes, there is Amanatides and Woo article \"A Fast Voxel Traversal Algorithm for Ray Tracing\" for 2D and 3D cases.\nIn general it is like your idea ```\nFind the point the line exits the cube via line-intersecting-plane math```\n\nExample of implementation\n2D case example:\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy set cover algorithm\r\n                \r\nSo, I picked up this code from \n\nHow do I make my implementation of greedy set cover faster?\n\nI am trying to understand sets and set cover so, I modify this a bit. \n\n```\nU = set([1,2,3,4])\nR = U\nS = [set([1,2]), \n     set([1]), \n     set([1,2,3]), \n     set([1]), \n     set([3]), \n     set([1,2]), \n     set([3]), \n     set([1,2,3])]\nw = [1, 1, 1, 1, 1, 1, 1, 1]\n\nC = []\ncosts = []\n\ndef findMin(S, R):\n    minCost = 99999.0\n    minElement = -1\n    for i, s in enumerate(S):\n        try:\n            cost = w[i]/(len(s.intersection(R)))\n            if cost < minCost:\n                minCost = cost\n                minElement = i\n        except:\n            # Division by zero, ignore\n            pass\n    return S[minElement], w[minElement]\n\nwhile len(R) != 0:\n    S_i, cost = findMin(S, R)\n    C.append(S_i)\n    R = R.difference(S_i)\n    costs.append(cost)\n\nprint \"Cover: \", C\n#print \"Total Cost: \", sum(costs), costs\n```\n\n\nAs can be seen U has values 1,2,3,4. None of the sets have 4 in them.\nI don't understands weights, so have put them as 1.\n\nExpected output: ```\nset([1,2])```\n, ```\nset([3])```\n, ```\nset([1,2,3])```\n, or Something which covers the maximum available.\n    ", "Answer": "\r\nThe problem with your code is that there is no cover, because there's an extra 4. My understanding is that by definition, the set cover problem specifies that the union of all sets in ```\nS```\n must be equal to ```\nU```\n. So that extra 4 shouldn't be there.\n\nSince your program doesn't halt until it finds a perfect cover (i.e. as long as ```\nlen(R) != 0```\n) it will never halt on this input. You're passing invalid input to the algorithm. \n\nOn a side note, I would strongly recommend against a blanket ```\nexcept```\n clause to test for zero division. That's not a good use of ```\ntry/except```\n; I think this is a case where you should look before you leap. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why does this greedy algorithm work?\r\n                \r\nHere's the problem:\n\nGiven a sequence s of + and - characters which represent +1 and -1 operations respectively on a variable x with initial value 0, find the maximum range of values x can achieve with any subsequence of s.\n\nExample:\n\ns = +--+--+, x = 0\nSubsequence that would lead to the maximum range of 4 is +----+. x would have max value 1 and min value -3.\n\nThe solution for this algorithm in pseudo-code is as follows:\n```\ncount_minus = #occurrences of - character\ncount_plus = #occurences of + character\nreturn max(count_minus, count_plus)\n```\n\nWhy does this work?\n    ", "Answer": "\r\nIf you remove all the positives then you have ```\nmax=0```\n and ```\nmin=-#negatives```\n for ```\nrange=#negatives```\n. Similarly for removing the negatives. Can't really get any better.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Difference between greedy and Dynamic and divide and conquer algorithms [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about a specific programming problem, a software algorithm, or software tools primarily used by programmers. If you believe the question would be on-topic on another Stack Exchange site, you can leave a comment to explain where the question may be able to be answered.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI want to know the difference between these three i know that in Divide and conquer and Dynamic algos the difference between these two is that both divides the broblem in small part but in D&Q the the small parts of the problem are  dependent on each other whereas not the case with dynamic. but what about greedy ?\n    ", "Answer": "\r\na simplified view outlining the gist of both schemes:\n\n\ngreedy algorithms neither postpone nor revise their decisions (ie. no backtracking).\nd&q algorithms merge the results of the very same algo applied to subsets of the data\n\n\nexamples:\n\n\ngreedy: kruskal's minimal spanning tree\nselect an edge from a sorted list, check, decide, never visit it again.\nd&q: merge sort\nsplit the data set into 2 halves,\nmerge sort them,\ncombine the results by skimming through both partial results in parallel, stopping, choosing or advancing as appropriate.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is there a way to print the contents added to a knapsack for this 0/1 Greedy algorithm?\r\n                \r\nMy most recent lab assignment has me trying to implement a Greedy algorithm for the 0/1 Knapsack problem, and print out the contents of the knapsack along with the total value of the knapsack. So far, I was able to get it to output the total value of the knapsack without issue, but I'm having trouble with outputting what items went into the knapsack.\n```\n#class definitions for the greedy approach\nclass Item: \n    def __init__(self,weight,value):\n        self.weight = weight\n        self.value = value\n        self.price_kg = value / weight\n    def __repr__(self):\n        return f\"Item(weight={self.weight}, value={self.value},v/w={self.price_kg})\\n\"\n\nclass Knapsack: \n    def __init__(self,max_weight,items):\n        self.max_weight = max_weight\n        self.items = items\n        self.contents = list()\n\n    def fillGreedy(self):\n        self.items.sort(key=lambda x: x.price_kg, reverse=True)#sorts the items by weight/value\n        for i in self.items:\n            self.contents.append(i)#Tries putting the item in the bag\n            if sum(i.weight for i in self.contents) > self.max_weight:\n                self.contents.remove(i)#Removes the item it is too heavy for the bag\n            elif sum(i.weight for i in self.contents) == self.max_weight:#finds an optimal configuration for the bag\n                return sum(i.value for i in self.contents)\n            \n        return sum(i.value for i in self.contents)\n\n#main method\nmax_weights = [10, 13, 15, 30, 30]\nweights = [\n    [4, 5, 7],\n    [6, 5, 7, 3, 1],\n    [2, 3, 5, 5, 3, 7],\n    [10, 13, 17, 15],\n    [5, 4, 7, 6, 3, 4, 2, 1, 7, 6]\n]\nvalues = [\n    [2, 3, 4],\n    [7, 3, 4, 4, 3],\n    [3, 4, 10, 9, 6, 13],\n    [21, 17, 30, 23],\n    [3, 1, 3, 2, 1, 3, 2, 3, 1, 4]\n]\n\nfor i in range(len(max_weights)):\n    items = list()\n    for j in range(len(weights[i])):\n        items.append(Item(weights[i][j], values[i][j])) #adds the contents of the arrays to the Items list\n i\n    ks = Knapsack(max_weights[i], items)\n    v1 = ks.fillGreedy()\n    print(f\"Total value = {v1}\")\n    #print(items)\n\n```\n\nSo far, I tried printing out the contents of the ks and v1 objects, but that only gives the memory addresses of the objects. I tried printing out the 'items' list itself after iterating through the fillGreedy method, but it prints out all the contents of the list and not the ones in the knapsack itself. I also tried doing something in the fillGreedy method that would print the item that was just added, but it ended up causing conflicts. I'm unsure where to continue from here. Is there a way to print out the items of the knapsack using this approach?\n    ", "Answer": "\r\nWelcome to the site.\nYou already have a collection of the selected items inside the Knapsack object, so you could iterate over ks.contents and print out the contents or whatever is needed from there...\n```\nfor item in ks.contents:\n    print(item)\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm to split a list of lists of numbers into two partitions with same amount of each number in Python\r\n                \r\nI have a list of sublists of random positive integers. This list is controlled by 3 parameters:\n\n```\nmax_num```\n: the maximum integer allowed in each sublist, e.g. if ```\nmax_num = 3```\n, the list will look like ```\n[[1,3], [3], [1,2,3], [1], ...]```\n;\n```\nmax_length```\n: the maximum number of intergers in each sublist;\n```\nn_gen```\n: the number of sublists generated, i.e., the length of the list.\n\nYou can generate such list using the following code\n```\nimport random\n\nrandom.seed(10)\ndef random_numbers(length, max_num):\n    return [random.randint(1, max_num) for _ in range(length)]\n\nmax_num = 3\nmax_length = 3 # I want max_length=10\nn_gen = 10 # I want n_gen=200\n\nlst = [random_numbers(random.randint(1, max_length), max_num) for _ in range(n_gen)]\n```\n\nNow I want to split the list into two partitions, each partition has the same amount of each number. For example, if ```\nlst = [[1,2,3], [2,3], [1,3], [3]]```\n, one of the solution would be ```\nbipartition = [[[1,2,3], [3]], [[2,3], [1,3]]]```\n.\nI managed to write the following brute-force enumeration for all possible bipartitions, which works fine for small parameters.\n```\nfrom itertools import product\n\nlst1 = []\nlst2 = []\nfor pattern in product([True, False], repeat=len(lst)):\n    lst1.append([x[1] for x in zip(pattern, lst) if x[0]])\n    lst2.append([x[1] for x in zip(pattern, lst) if not x[0]])\n\nbipartitions = []\nfor l1, l2 in zip(lst1, lst2):\n    flat1 = [i for l in l1 for i in l]\n    flat2 = [i for l in l2 for i in l]\n    if sorted(flat1) == sorted(flat2):\n        bipartitions.append([l1, l2])\n\nfor bipartition in bipartitions:\n    print(bipartition)\n```\n\nOutput:\n```\n[[[1, 2, 2], [1, 1, 2], [2, 3], [3, 2]], [[1], [2, 2, 1], [3], [1, 2], [3], [2, 2]]]\n[[[1, 2, 2], [1, 1, 2], [3], [3], [2, 2]], [[2, 3], [1], [2, 2, 1], [1, 2], [3, 2]]]\n[[[1, 2, 2], [2, 3], [1], [2, 2, 1], [3]], [[1, 1, 2], [1, 2], [3], [2, 2], [3, 2]]]\n[[[1, 2, 2], [2, 3], [1], [2, 2, 1], [3]], [[1, 1, 2], [3], [1, 2], [2, 2], [3, 2]]]\n[[[1, 2, 2], [2, 3], [1], [1, 2], [3, 2]], [[1, 1, 2], [2, 2, 1], [3], [3], [2, 2]]]\n[[[1, 2, 2], [1], [2, 2, 1], [3], [3, 2]], [[1, 1, 2], [2, 3], [1, 2], [3], [2, 2]]]\n[[[1, 2, 2], [1], [2, 2, 1], [3], [3, 2]], [[1, 1, 2], [2, 3], [3], [1, 2], [2, 2]]]\n[[[1, 2, 2], [1], [3], [1, 2], [3], [2, 2]], [[1, 1, 2], [2, 3], [2, 2, 1], [3, 2]]]\n[[[1, 2, 2], [2, 2, 1], [3], [1, 2], [3]], [[1, 1, 2], [2, 3], [1], [2, 2], [3, 2]]]\n[[[1, 1, 2], [2, 3], [1], [2, 2], [3, 2]], [[1, 2, 2], [2, 2, 1], [3], [1, 2], [3]]]\n[[[1, 1, 2], [2, 3], [2, 2, 1], [3, 2]], [[1, 2, 2], [1], [3], [1, 2], [3], [2, 2]]]\n[[[1, 1, 2], [2, 3], [3], [1, 2], [2, 2]], [[1, 2, 2], [1], [2, 2, 1], [3], [3, 2]]]\n[[[1, 1, 2], [2, 3], [1, 2], [3], [2, 2]], [[1, 2, 2], [1], [2, 2, 1], [3], [3, 2]]]\n[[[1, 1, 2], [2, 2, 1], [3], [3], [2, 2]], [[1, 2, 2], [2, 3], [1], [1, 2], [3, 2]]]\n[[[1, 1, 2], [3], [1, 2], [2, 2], [3, 2]], [[1, 2, 2], [2, 3], [1], [2, 2, 1], [3]]]\n[[[1, 1, 2], [1, 2], [3], [2, 2], [3, 2]], [[1, 2, 2], [2, 3], [1], [2, 2, 1], [3]]]\n[[[2, 3], [1], [2, 2, 1], [1, 2], [3, 2]], [[1, 2, 2], [1, 1, 2], [3], [3], [2, 2]]]\n[[[1], [2, 2, 1], [3], [1, 2], [3], [2, 2]], [[1, 2, 2], [1, 1, 2], [2, 3], [3, 2]]]\n```\n\nHowever, when the parameters becomes larger, this becomes infeasible. Now I would like to generate random bipartitions that has same amount of each number, I guess a greedy algorithm will do. For my current task, I need to use\n```\nmax_num = 3\nmax_length = 10\nn_gen = 200\n```\n\nAny suggestions?\nEdit: I am aware that there will be cases where such bipartition is not possible at all. My thought is when the bipartition suggested by the greedy algorithm after a maximum number of suggestions (e.g. 1000 if fast enough), we should believe there is no such bipartitions. When the parameters are large, even a check of whether such bipartition exist will be infeasible.\n    ", "Answer": "\r\nHoly heck this one was a doozy. First off, let me state the obvious. A greedy algorithm is deterministic, since it will always choose the optimal path. Second, the odds of actually being able to bipartition something is very, very unlikely. I also suggest that if you want to generate bipartitions, trying to find them from random sets like this is not a good idea.\nAnyhow, on to the code. First, let me say that the code is not pretty, nor is it completely optimized. Towards the end there I wasn't even being Pythonic in some areas, but they are all easily fixable. I've been at this for hours, but it was a fun project. The copying of the list stands out as the prime suspect. You can re-write it and optimize it in your own time. I also can't guarantee that it's bug-free, but I'm pretty sure it is. Only exception being that you need to make sure that it at least does one \"careful\" search if you want any results. That brings me to the next point, the algorithm itself.\nWe start off by doing a pretty standard greedy algorithm. We pick an index from our partitionee and, WLOG, assign it to the left bipartition. Next we look at all possible ways of inserting all remaining lists. We choose the one that brings us closest to 0. We repeat until we hit some breakpoint, after which we switch to your exhaustive algorithm.\nNow, odds are we don't find a partition for high values of your constants. I believe this is just a statistical thing, and not a problem with the algorithm, but I could be wrong.\nI also implemented a rough feasibility test, and you'll see quite quickly that ~90% of all randomly generated nested lists can immediately be discarded as impossible to bipartition.\nHowever, the addition of the greedy algorithm now allows me, on my machine, to go from testing ~15 length partitions to ~30 length ones, with good success of finding one. It also runs in less than a 10th of second with e.g. 3, 3, 40, 12 as its constants.\nFinally, here is the code Note that I only made it generate one partition to test, so you might need to run it a few times before you even get a feasible one:\n```\nfrom itertools import product\nimport random\nimport datetime\nimport time\nimport sys\n\nMAX_NUM = 3\nMAX_LEN = 3\nNUM_GEN = 200\nNSWITCH = 12\n\nrandom.seed(time.time())\n\ndef feasible(partitionee):\n    '''Does a rough test to see if it is feasible to find a partition'''\n    counts = [0 for _ in range(MAX_NUM)]\n    flat = [x for sublist in partitionee for x in sublist]\n    for n in flat:\n        counts[n-1] += 1\n    for n in counts:\n        if n % 2 != 0:\n            return False\n    return True \n\ndef random_numbers(length, max_num, n_lists):\n    '''Create a random list of lists of numbers.'''\n\n    lst = []\n    for i in range(n_lists):\n        sublist_length = random.randint(1, length)\n        lst.append([random.randint(1, max_num) for _ in range(sublist_length)])\n    return lst\n\n\ndef diff(lcounts, rcounts):\n    '''Calculate the difference between the counts in our dictionaries.'''\n\n    difference = 0\n    for i in range(MAX_NUM):\n        difference += abs(lcounts[i] - rcounts[i])\n\n    return difference\n\n\ndef assign(partition, d, sublist):\n    '''Assign a sublist to a partition, and update its dictionary.'''\n\n    partition.append(sublist)\n    for n in sublist:\n        d[n-1] += 1\n\n\ndef assign_value(d1, d2, sublist):\n    '''Calculates the loss of assigning sublist.'''\n\n    for n in sublist:\n        d1[n-1] += 1\n    left_score = diff(d1, d2)\n    for n in sublist:\n        d1[n-1] -= 1\n        d2[n-1] += 1\n    right_score = diff(d1, d2)\n    for n in sublist:\n        d2[n-1] -= 1\n\n    return (left_score, right_score)\n\n\ndef greedy_partition(left, right, lcounts, rcounts, i, partitionee):\n    # Assign the i:th sublist to the left partition.\n    assign(left, lcounts, partitionee[i])\n    del partitionee[i]\n\n    for _ in range(NUM_GEN - NSWITCH):\n        # Go through all unassigned sublists and get their loss.\n        value_for_index = {}\n        for i, sublist in enumerate(partitionee):\n            value = assign_value(lcounts, rcounts, sublist)\n            value_for_index[i]  = value\n\n        # Find which choice would be closest to 0 difference.\n        min_value    = 100000000000 # BIG NUMBER\n        best_index  = -1\n        choose_left = True\n        for key, value in value_for_index.items():\n            if min(value) < min_value:\n                min_value    = min(value)\n                choose_left = value[0] < value[1]\n                best_index  = key\n\n        # Assign it to the proper list.\n        if choose_left:\n            assign(left, lcounts, partitionee[best_index])\n        else:\n            assign(right, rcounts, partitionee[best_index])\n        del partitionee[best_index]\n\n    return diff(lcounts, rcounts)\n\n\n\n# Create our list to partition.\npartition_me = random_numbers(MAX_LEN, MAX_NUM, NUM_GEN)\n\nstart_time = datetime.datetime.now()\n\n# Start by seeing if it's even feasible to partition.\nif not feasible(partition_me):\n    print('No bipartition possible!')\n    sys.exit()\n\n\n# Go through all possible starting arrangements.\nmin_score_seen = 100000000000 # BIG NUMBER\nbest_bipartition = []\nfor i in range(NUM_GEN):\n    # Create left and right partitions, as well as maps to count how many of each\n    # number each partition has accumulated.\n    left  = []\n    right = []\n    lcounts  = [0 for i in range(MAX_NUM)]\n    rcounts  = [0 for i in range(MAX_NUM)]\n\n    # Copy partitionee since it will be consumed.\n    partition = partition_me.copy()\n\n    # Do greedy partition.\n    score = greedy_partition(left, right, lcounts, rcounts, i, partition)\n    if score < min_score_seen:\n        min_score_seen = score\n        best_bipartition = [left] + [right]\n\n# Now that we've been greedy and fast, we will be careful and slow.\n# Consider all possible remaining arrangements.\nprint('Done with greedy search, starting careful search.')\nleft = best_bipartition[0]\nright = best_bipartition[1]\n\nfor pattern in product([True, False], repeat=len(partition)):\n    lst1 = left  + ([x[1] for x in zip(pattern, partition) if x[0]])\n    lst2 = right +([x[1] for x in zip(pattern, partition) if not x[0]])\n    left_flat  = [x for sublist in lst1 for x in sublist]\n    right_flat  = [x for sublist in lst2 for x in sublist]\n    if sorted(left_flat) == sorted(right_flat):\n        print('Found bipartition by careful search:')\n        print([lst1] + [lst2])\n        break\n\nend_time = datetime.datetime.now()\nprint('Time taken: ', end='')\nprint(end_time - start_time)\n\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy approach VS Dynamic programming In travelling salesman\r\n                \r\nIf a travelling salesman problem is solved by using dynamic programming approach, will it provide feasible solution better than greedy approach?\n\nI know that in terms of optimal solution, greedy algorithms are used for solving TSPs, but it becomes more complex and takes exponential time when numbers of vertices (i.e. cities) are very large.\n\nSo, in the end, which approach will be better?\n    ", "Answer": "\r\nThere is an important distinction between exact algorithms and heuristics. An exact algorithm is guaranteed to find the exact optimal solution. A heuristic is not, but it is designed to run quickly.\n\nDP is an exact algorithm, at least as it is usually used. There are DP algorithms for TSP. Thus, these algorithms will solve the problem exactly.\n\nThe TSP cannot be solved exactly using greedy methods, hence any greedy method is a heuristic. By definition, therefore, DP will always find a better (or, no worse) feasible solution than a greedy heuristic will, for any instance of the TSP. \n\nNote, however, that DP is not the dominant approach for solving TSP. Many other algorithms exist that are much more efficient. Some of the original papers on TSP used DP, and it is often formulated as an illustrative example, but it is not the way TSPs are usually solved in practice.\n\nTo correct something in the OP: \n\n\n  I know that in terms of optimal solution, greedy algorithms are used for solving TSPs, but it becomes more complex and takes exponential time when numbers of vertices (i.e. cities) are very large.\n\n\nGreedy heuristics are sometimes used for solving TSPs. (These have names like nearest neighbor, cheapest insertion, etc.) As the number of vertices grows, the run time of those heuristics grows too, but it does not grow exponentially. Most of these heuristics have run times with low-order polynomial complexity, such as O(n^2).\n\nOn the other hand, because TSP is NP-hard, all known exact algorithms will have worst-case complexity that is exponential in the number of vertices. (Note that I say worst-case complexity -- actual run times may be quite reasonable for many instances, but only exponential in the worst case.)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "reason for the failure of greedy algorithm in following case\r\n                \r\nI tried solving one problem which was claimed to be solvable using Dynamic programming only. Following is the problem.\nA man has total energy as H and he needs to cover distance D. He wants to cover this distance using maximum energy upto H in minimum time. He can run in 5 modes. Total distance is covered by running each km according to one of the 5 modes. \nThese five modes are described using two arrays which are sorted\n\nTime:-'5m 10sec', '6 m 11sec','7 m 7sec','8 m 11sec','9 m 11sec'\n\nEnergy required:-11,9,8,7,6 \n\nSo my greedy solution strategy is\n\n\nCompute x=floor of H/D\nRun next km using mode which takes lowest time and requires energy<=x\n\n& set H=H-energy required by mode\n\nset D=D-1\nGoto step 1 till remaining distance becomes 0.\nAnswer will be some of all times for each km.\n\n\nI think this solution will work but it fails in reality. I know how to solve it using DP, but I wanted to know where it fails. I have tried many examples but not getting the feeling. I do not recall above two arrays elements exactly but they are necessarily in sorted order.\n    ", "Answer": "\r\nThe reason is simple; You haven't proven your algorithm, so you can't claim it is correct. Simple as that. Do you have any idea how many heuristic algorithms in research literature \"look\" correct, yet they have no proofs of correctness. Hence why they're only heuristics. \n\nYour solution is a heuristic. For a counter example. Take ```\nH=100, D=3```\n. Also take the modes to be with time ```\n[1,2,3,4,5]```\n and the corresponding energies as ```\n[35,34,32,32,32]```\n. \n\nYour initial ```\nx```\n is ```\nfloor(100/3)=33```\n. The lowest time with energy ```\n<=33```\n is ```\n3```\n. Choose it. Update H and D such that ```\nH=67, D=2```\n. We have ```\nfloor(67/2)=33```\n. Again, choose time ```\n3```\n. Update H and D such that ```\nH=34, D=1```\n. Finally ```\nx=floor(34/1)=34```\n Choose time ```\n2```\n. So your list of times to cover the distances is ```\n[3,3,2]```\n with total energy ```\n32+32+34=98```\n and total time ```\n8```\n. \n\nHowever, I can come up with a better solution than your greedy solution. Namely the times ```\n[1,3,4]```\n that take ```\n8```\n units of time but have ```\n35+32+32=99```\n total energy. Beating your greedy solution.\n\nMoral of the story? If you can't prove your algorithm, assume its wrong, or simply a heuristic.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy clustering algorithm speed improvement\r\n                \r\nI am trying to implement a very simple greedy clustering algorithm in python, but am hard-pressed to optimize it for speed.  The algorithm will take a distance matrix, find the column with the most components less than a predetermined distance cutoff, and store the row indices (with components less than the cutoff) as the members of the cluster.  The centroid of the cluster is the column index.  The columns and rows of each member index are then removed from the distance matrix (resulting in a smaller --but still square-- matrix), and the algorithm iterates through successively smaller distance matrices until all clusters are found.  Because each iteration depends on the last (a new distance matrix is formed so that there are no overlapping members between clusters), I think I can not avoid a slow for loop in python.  I've tried numba (jit) to speed it up but I think it is reverting to python mode and so does not result in any speed gains.  Here are two implementations of the algorithm.  The first is slower than the latter.  Any suggestions for speedups are most welcome.  I am aware of other clustering algorithms as implemented in scipy or sklearn (such as DBSCAN, kmeans/medoids, etc), but am very keen to use the current one for my application. Thanks in advance for any suggestions.\n\nMethod 1 (slower):\n\n```\ndef cluster(distance_matrix, cutoff=1):\n    indices = np.arange(0, len(distance_matrix))\n    boolean_distance_matrix = distance_matrix <= cutoff\n    centroids = []\n    members = []\n    while boolean_distance_matrix.any():\n        centroid = np.argmax(np.sum(boolean_distance_matrix, axis=0))\n        mem_indices = boolean_distance_matrix[:, centroid]\n        mems = indices[mem_indices]\n        boolean_distance_matrix[mems, :] = False\n        boolean_distance_matrix[:, mems] = False\n        centroids.append(centroid)\n        members.append(mems)\n    return members, centroids\n```\n\n\nMethod 2 (faster, but still slow for large matrices):\n\nIt takes as input an adjacency (sparse) matrix formed from sklearn's nearest neighbors implementation.  This is the simplest and fastest way I could think to get the relevant distance matrix for clustering.  I believe working with the sparse matrix also speeds up the clustering algorithm.\n\n```\nnbrs = NearestNeighbors(metric='euclidean', radius=1.5, \nalgorithm='kd_tree')            \nnbrs.fit(data)    \nadjacency_matrix = nbrs.radius_neighbors_graph(data)   \n\ndef cluster(adjacency_matrix, gt=1):\n    rows = adjacency_matrix.nonzero()[0]\n    cols = adjacency_matrix.nonzero()[1]\n    members = []\n    member = np.ones(len(range(gt+1)))\n    centroids = []\n    appendc = centroids.append\n    appendm = members.append\n    while len(member) > gt:\n        un, coun = np.unique(cols, return_counts=True)\n        centroid = un[np.argmax(coun)]\n        appendc(centroid)\n        member = rows[cols == centroid]\n        appendm(member)\n        cols = cols[np.in1d(rows, member, invert=True)]\n        rows = rows[np.in1d(rows, member, invert=True)]\n    return members, centroids  \n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm - Invite guests to a party\r\n                \r\nGiving the problem in the link below,\n\nQuestion\n\nIs it possible to find an algorithm using graphs with less than O(n^3)?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Line Wrapping Algorithm: The greedy approach\r\n                \r\nI needed a simple line wrapping algorithm, so I turned to Wikipedia:\n\nhttp://en.wikipedia.org/wiki/Line_wrap_and_word_wrap#Minimum_number_of_lines\n\nThe greedy algorithm:\n\n\n1. |  SpaceLeft := LineWidth\n2. |  for each Word in Text\n3. |      if (Width(Word) + SpaceWidth) > SpaceLeft\n4. |         insert line break before Word in Text\n5. |         SpaceLeft := LineWidth - Width(Word)\n6. |      else\n7. |         SpaceLeft := SpaceLeft - (Width(Word) + SpaceWidth)\n\n\nOn line #5, when we start a new line and subtract the word width from the available width, shouldn't we also subtract the space width?\n\n\n5. |         SpaceLeft := LineWidth - (Width(Word) + SpaceWidth)\n\n\nWhy is the space width not accounted for on line #5?\n\n-- UPDATE --\n\nSome simple testing.\n\nIn each of the images, the first paragraph is created by JavaScript using the above wrapping algorithm (orange outline), and the second paragraph is native-rendered by the browser (blue outline).\n\nInterestingly, this extremely bare-bones algorithm, indeed produces the exact same results as the browser rendering, for text with NO edge cases.\n\nThis first image shows that when we use\n\n```\nSpaceLeft := LineWidth - Width(Word)\n```\n\n\nJS rendering and browser rendering are exactly same.\n\n\n\nBut the following images (different line widths) show the subtle differences between JS and browser renderings when we use:\n\n```\nSpaceLeft := LineWidth - (Width(Word) + SpaceWidth)\n```\n\n\n\n\n\nThe Code\n\n\n\n// function getWidth() uses canvas to calculate the widths\n// http://stackoverflow.com/questions/118241/calculate-text-width-with-javascript\n\nvar wrap = function(container, text, lineWidth) {\n        var words = text.split(' ');\n        var w, x, i, l;\n        var spaceWidth = getWidth(' ');\n        var spaceLeft = lineWidth;\n\n        var arr = [], line = [];\n        arr.push(line);\n\n        for ( i = 0, l = words.length; i < l; i++ ) {\n            w = words[i];\n            x = getWidth(w) + spaceWidth;\n\n            if ( x > spaceLeft ) {\n                line = [];\n                arr.push(line);\n                line.push(w);\n\n                // this is the case for Wikipedia algorithm\n                // spaceLeft = lineWidth - getWidth(w);\n\n                spaceLeft = lineWidth - x;\n            }\n            else {\n                spaceLeft = spaceLeft - x;\n                line.push(w);\n            }\n        }\n\n        for ( i = 0, l = arr.length; i < l; i++ ) {\n\n            container.append(\n                $('<span>').text(arr[i].join(' '))\n            );\n        }\n    };\n\n    ", "Answer": "\r\nThe algorithm would probably be \"more\" correct if line 5 was \n\n```\n5. |         SpaceLeft := LineWidth - (Width(Word) + SpaceWidth)\n```\n\n\nas you suggest.\n\nIn any case, the question is a bit philosophical, as the algorithm is far too simplified for any concrete implementation, considering a real implementation would need to take care of the fact that the text may already contain new lines, that words are not necessarily delimited by spaces (e.g hyphens) and or multiple spaces.\n\nUsing an existing implementation is probably the best solution, e.g. for Java: Wrap the string after a number of characters word-wise in Java\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Activity Selection Algorithm\r\n                \r\nI am trying to solve this problem: https://open.kattis.com/problems/classrooms\n\n\n  There are 𝑘 classrooms on campus and 𝑛 proposed activities that need\n  to be assigned a venue. Every proposed activity has specfic starting\n  time 𝑠𝑖 and ending time 𝑓𝑖. Any such an activity should take place\n  at one of the classrooms. Any of the 𝑘 classrooms is big enough to\n  hold any of the proposed activities, and each classroom can hold at\n  most one activity at any time. No two proposed activities can take\n  place at the same classroom at the same time. Even if two proposed\n  activities overlap momentarily (the ending time of one activity equals\n  the starting time another activity), they cannot be assigned to the\n  same classroom.\n  \n  There are so many proposed activities that there may not be enough\n  classrooms to hold all the activities. It is desirable to have as many\n  activities as possible. At most how many proposed activities can be\n  assigned to the classrooms?\n  \n  Input The first line contains two positive integers 𝑛 and 𝑘\n  (1≤𝑘≤𝑛≤200000), representing the number of proposed activities and\n  number of classrooms, respectively.\n  \n  The following 𝑛 lines each contains two positive integers: the 𝑖th\n  line among these 𝑛 lines contains 𝑠𝑖 and 𝑓𝑖 (1≤𝑠𝑖≤𝑓𝑖≤109),\n  indicating the starting time and ending time of proposed activity\n\n\nI have come up with a greedy solution where I sort the classes by end time, then check if it's possible to allocate a class to an activity based on greedy conditions\n\n```\n'''\nhttps://open.kattis.com/problems/classrooms\n'''\n\nfrom collections import deque\n\nn, k = map(int, input().split())\nclasses = []\nfor _ in range(n):\n    (start, end) = map(int, input().split())\n    classes.append((start, end))\n\nclasses.sort(key=lambda x: x[1])\nqueue = deque()\ncount = 0\nfor (start, end) in classes:\n    if queue and queue[0] < start:\n        queue.popleft()\n        queue.append(end)\n        count += 1\n    elif len(queue) < k:\n        count += 1\n        queue.append(end)\nprint(count)\n\n```\n\n\nHowever, this fails on a few (hidden) test cases. \n\nCould someone point me in the right direction? What's the right approach to solve this problem?\n    ", "Answer": "\r\nHere's one example of how the current procedure could fail.\n\n8 activities, 2 classrooms:\n\n```\n  a   b   c\n --- --- ------\n d     e\n--- -------\n  --- ---- ---\n   f   g   h\n\nqueue   count\n d       1\n d a     2\n f (no)\n a b     3\n b g     4\n e (no)\n g h     5\n c (no)\n```\n\n\nWe can clearly see that the result could be 6, using the top and bottom tracks.\n\nHere's the corresponding input:\n\n```\n8 2\n2 4\n6 8\n10 15\n1 3\n5 11\n3 5\n7 10\n12 14\n```\n\n\nI think a good avenue for exploration is along the lines you proposed except have k buckets (rather than just one) into which we'd like to keep choosing to create the next least end-time.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy algorithm for a simple Oympiad problem\r\n                \r\nI am a beginner in programming and trying to solve problems from the Australian Informatics Olympiad.\nI am stuck on this problem even though to me it seems very simple and straight-forward.\nHere's the link to the problem:\nAIO 2020 - Baubles\nBelow is the snippet of my code that only scored 15%:\n```\nvoid solve(){\nll r,b,s,nr,nb;\ncin >> r >> b >> s >> nr >> nb;\nll ans = 0;\nif (s + r < nr || s + b < nb) ans = 0;\nelse {\n    ll diff_b, diff_r;\n    vector<ll>sum;\n    \n    diff_r = nr - r -1;\n    sum.push_back(s - diff_r);\n    diff_b = nb - b - 1;\n    sum.push_back(s - diff_b);\n    sum.push_back(s - diff_b - diff_r - 1);\n    ll min = INFINITY;\n    for (int i = 0 ; i < sum.size(); i++) if (sum[i] < min) min = sum[i];\n    ans = min;\n}\ncout << ans;}\n```\n\nHere I'm looking at reducing ```\nspare```\n and the initial red/blue if they are greater than the required red/blue, respectively, such that the red/blue + ```\nspare```\n after reducing will be equal to the required red/blue - 1.\nPlease help me understand what I'm doing wrong and understand a good way to approach this problem!\n    ", "Answer": "\r\nYou need to add one more condition in the if statement:\n```\nif (s + r < nr || s + b < nb || s + r + b < nr + np) ans = 0;\n```\n\nThis is also affecting your 3rd push (s - diff_b - diff_r - 1) in sum, cause then it might become negative.\nRest seems fine to me.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "For loop in a greedy algorithm isn't breaking, is asking for input infinitely\r\n                \r\nI'm creating a greedy loop that finds the smallest amount of coins to be used to give back a value for CS50's pset1, and I can't decipher why my while loop is running infinitely.\n\nI've tinkered with it and can't get it to escape.\n\n```\n#include <stdio.h>\n#include <cs50.h>\n#include <math.h>\n\n// declare variable change_owed, num_coins, and input globally\nfloat change_owed;\nfloat input;\nint num_coins;\n\nint main(void)\n{\n    // makes sure the input is non-negative\n    do\n    {\n        input = get_float(\"Amount paid\\n\");\n    }\n    while(change_owed <=0);\n    input = round(input);\n\n    // begin checking \n    while(input > 0)\n    {\n        if(input - .25 > 0) // quarters\n        {\n            num_coins++; // number of coins used, to be printed later, is incremented\n            input = input - .25; // coin is subtracted from total\n        }\n        else if (input - .10 > 0) // dimes\n        {\n            num_coins++;\n            input = input - .10;\n        }   \n        else if (input - .05 > 0) // nickels\n        {\n            num_coins++;\n            input = input - .05;\n        } \n        else if (input - .01 > 0) // pennies\n        {\n            num_coins++;\n            input = input - .01;\n        } \n    }\n    printf(\"%i\", num_coins);\n}\n```\n\n    ", "Answer": "\r\nThe condition for your first ```\ndo/while```\n loop is ```\nchange_owed <= 0```\n, but there is nothing within the loop body that would change that value.  Since it is a global that is initialized to 0, and is not changed before the loop enters, it will always have a value of 0 when the ```\nwhile```\n condition is checked.  This causes the loop to never terminate.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why does Kruskal's algorithm find the minimum spanning tree if it's greedy?\r\n                \r\nWhy does Kruskal's algorithm find the minimum spanning tree if it's greedy? Isn't a minimum spanning tree a global optimization problem? Isn't the point of being greedy is that there is a chance you won't find the most optimal solution? So how can Kruskal be able to find the minimum spanning tree while also being greedy?\n    ", "Answer": "\r\nOkay, let's assume that you're right, so Kruskal's algorithm doesn't find the optimal solution. Let the solution found by Kruskal's algorithm ```\nS```\n, and the optimal solution ```\nT```\n.\nThere must be an edge ```\ne = (u, v)```\n that appears on ```\nS```\n but not on ```\nT```\n. As ```\nT```\n is a spanning tree, there must be a path between node ```\nu```\n and node ```\nv```\n.\nNow, we should notice that at least one edge on the path ```\nu-v```\n has a weight not smaller than ```\ne```\n. Otherwise, Kruskal's algorithm would have chosen all the edges on the path ```\nu-v```\n instead of edge ```\ne```\n.\nThat means, if we remove that edge and add ```\ne```\n on the solution ```\nT```\n, the solution doesn't get worse. And as we assumed that ```\nT```\n is optimal, after this change, the tree is still optimal. If we apply this logic repeatedly, we can always make ```\nS```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm problem: how to assign workers with different skillsets to jobs\r\n                \r\nI'm trying to write an algorithm to optimize my performance in the smartphone game Tiny Tower.\nI have \"n\" workers.\nThere are 5 types of stores: store_types=['green', 'blue', 'yellow', 'purple', 'orange'].\ni have \"k[i]\" spaces open in each type of store.\nEach worker has a skillset: a score (0-9) for each type of store, where 9 is most skilled.\nfor example, workers[3] might have a name and skillset ['randy',9,6,7,6,3], each score number corresponding to a type of store.\nI might have k=[11,15,9,20,5] spaces open, each number corresponding to the spaces open for each type of store.\nI want to place my workers in jobs that optimize my overall performance. Like, if a worker has a score 9 in green stores, I want them in a green store. And so on.\nAlso, I might have too many workers or too many open positions, so if that's the case, unemployed workers or open job positions are okay (I don't want algorithm to crash due to it).\nI already have set up a user-input process to obtain:\n\nlist of workers and their info that looks like [['washington', 9, 8, 8, 9, 6], ['lawson', 6, 2, 9, 9, 2],......]\n(i.e. lawson has a score of 6 for green jobs)\n\nlist of number of spaces available in each type of store that looks like [11, 9, 12, 9, 12]\n(i.e. 11 spaces available in green stores)\n\n\nI don't know what to do next to optimize job assignments. I've googled around a lot about Greedy Algorithm stuff but I'm really just not sure how to go about this.\nPseudocode or conceptual steps are enough for me to work with. Thank you!\n(This is for fun, not school or work. I've been coding for 4 years and I'm new to Stack Overflow, please excuse me if I missed any Stack Overflow etiquette.)\n    ", "Answer": "\r\nSurely you have read the Wikipedia page Greedy algorithm and are aware that a greedy algorithm never reconsiders its choices, having the disadvantage that it might not produce an optimal solution and the advantage that it terminates in a reasonable number of steps and is quick to think up.\nSo, here's pseudocode (which happens to be executable Python code) that assigns each worker in order to a still open job where the skill is highest:\n```\nfor worker in workers:\n    name = worker.pop(0)    # extract the first list element\n    # tie the store index to the score:\n    worker = [(score, index) for index, score in enumerate(worker)]\n    while worker:\n        score, store = max(worker)  # high score\n        if k[store]:\n            k[store] -= 1\n            print(name, store_types[store])\n            break\n        else:   # remove store with no open space from worker's skillset:\n            worker.remove((score, store))\n    else:   print(name, 'unemployed')\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to implement Greedy Search algorithm\r\n                \r\nI have a project that is given on my Artificial Intelligence course. I need to implement Greedy Search algorithm for my program. Description of my project is:\nTwo text files called “tree.txt” and “heuristic.txt” are given. “tree.txt” will define the search tree where each line will contain a parent-child relation and a path cost between them. Each data will be seperated with a space.\n\ne.g.    \n\nA B 5\n\nA C 3\n\nB D 6 \n\nThe first character in the first line will be the Start node (A in here) and the goal node will be “G”.\n\n“heuristic.txt” will define the heuristic, h(n), values. Each line will contain the heuristic value of each node. Each data will be seperated with a space.\n\ne.g.\n\nA 20\n\nB 15\n\nC 18\n\nOutput:\nThe program should give the solution path and the path cost from start node to goal.\n\nNow my problem is that i am familiar with Greedy Search theoretically, but never implemented it practically in coding. I really dont know from where to start. We are free to develop our program in any language. Mostly, i have skills in Java and C#. If anybody can give me some ideas, or help me with any similar examples or tutorials. Any kind of help will be greatly appreciated. Sorry for so much writing. Thank you in advance:)))\n    ", "Answer": "\r\nI suggest this solution using python.\nTo implement the graph in your program use a simple python dictionary. Here's the code:\n\n```\nclass Tree:\n\n     def _init_(self,dict,heuristic):\n     self.tree=tree\n     self.heuristic=heuristic\n\n\n\n     def getHeuristicValue(self,state)\n     value=self.heuristic.get(state)\n     return value\n```\n\n\nThe constructor call is something like:  \n\n```\ng = Graph({'A':{'B':5,'C':3},'B':{'D':6}},{'A':20,'B':15,'C':18})\n```\n\n\nThe ```\ngetHeuristic```\n python function pass accepts a state as an argument and returns the value of the heuristic of this state.\n\nTo learn about python's dictionary class I suggest you read the tutorial\n\nTo implement the search algorithm with python you should implement this simple pseudocode:\n\n```\nfunction Tree-Search(initialNode,goalNode) returns a solution,or failure\nfrontier.push(initialNode) with the value of the function heuristic(initialNode.state)+the path cost to reaxh this node\nwhile(frontier)\n  node<-frontier.pop()\n  if node.state==GoalNode.state\n    return node\n  expand node, adding the resulting nodes to the frontier\nreturn None\n```\n\n\nFor the frontier you must use a priority queue because you must pop the node with the lower value of ```\ng(n)+h(n)```\n (where ```\ng(n)```\n is the path cost to reach this node and ```\nh(n)```\n is the value of the heuristic function).\n\nTo implement priority queue you should use a heap  of the standard library heapq\n\nThe node is a data structure that must contain four components:\n\nnode.state:the state in the state space to which the node corresponds.\n\nnode.parent:the node in the search tree that generated this node.\n\nnode.action: the action that was applied to the parent to generated the node.\n\nnode.pathCost: is g(n),the cost of the path from the initial state to the node.\n\nLastly, for expanding the node, you can use this python function:\n\n```\ndef actions(self,state):\n    '''return a tuple that contain the state child of state '''\n    return tuple(self.tree.get(state))\n```\n\n\nI suggest you to look this for your problem.\n\nYou can get the solution simply go back from the ```\nnode.state```\n that returns from the output of the algorithm while ```\nnode.parent```\n is not null that is your solution.\n\nI hope this is useful for your project.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Creating a Non-greedy LZW algorithm\r\n                \r\nBasically, I'm doing an IB Extended Essay for Computer Science, and was thinking of using a non-greedy implementation of the LZW algorithm. I found the following links:\n\n\nhttps://pdfs.semanticscholar.org/4e86/59917a0cbc2ac033aced4a48948943c42246.pdf\nhttp://theory.stanford.edu/~matias/papers/wae98.pdf\n\n\nAnd have been operating under the assumption that the algorithm described in paper 1 and the LZW-FP in paper 2 are essentially the same. Either way, tracing the pseudocode in paper 1 has been a painful experience that has yielded nothing, and in the words of my teacher \"is incredibly difficult to understand.\" If anyone can figure out how to trace it, or happens to have studied the algorithm before and knows how it works, that'd be a great help.\n    ", "Answer": "\r\nNote: I refer to what you call \"paper 1\" as Horspool 1995 and \"paper 2\" as Matias et al 1998. I only looked at the LZW algorithm in Horspool 1995, so if you were referring to the LZSS algorithm this won't help you much.\n\nMy understanding is that Horspool's algorithm is what the authors of Matias et al 1998 call \"LZW-FPA\", which is different from what they call \"LZW-FP\"; the difference has to do with the way the algorithm decides which substrings to add to the dictionary. Since \"LZW-FP\" adds exactly the same substrings to the dictionary as LZW would add, LZW-FP cannot produce a longer compressed sequence for any string. LZW-FPA (and Horspool's algorithm) add the successor string of the greedy match at each output cycle. That's not the same substring (because the greedy match doesn't start at the same point as it would in LZW) and therefore it is theoretically possible that it will produce a longer compressed sequence than LZW.\n\nHorspool's algorithm is actually quite simple, but it suffers from the fact that there are several silly errors in the provided pseudo-code. Implementing the algorithm is a good way of detecting and fixing these errors; I put an annotated version of the pseudocode below.\n\nLZW-like algorithms decompose the input into a sequence of blocks. The compressor maintains a dictionary of available blocks (with associated codewords). Initially, the dictionary contains all single-character strings. It then steps through the input, at each point finding the longest prefix at that point which is in its dictionary. Having found that block, it outputs its codeword, and adds to the dictionary the block with the next input character appended. (Since the block found was the longest prefix in the dictionary, the block plus the next character cannot be in the dictionary.) It then advances over the block, and continues at the next input point (which is just before the last character of the block it just added to the dictionary).\n\nHorspool's modification also finds the longest prefix at each point, and also adds that prefix extended by one character into the dictionary. But it does not immediately output that block. Instead, it considers prefixes of the greedy match, and for each one works out what the next greedy match would be. That gives it a candidate extent of two blocks; it chooses the extent with the best advance. In order to avoid using up too much time in this search, the algorithm is parameterised by the number of prefixes it will test, on the assumption that much shorter prefixes are unlikely to yield longer extents. (And Horspool provides some evidence for this heuristic, although you might want to verify that with your own experimentation.)\n\nIn Horspool's pseudocode, α is what I call the \"candidate match\" -- that is, the greedy match found at the previous step -- and βj is the greedy successor match for the input point after the jth prefix of α. (Counting from the end, so β0 is precisely the greedy successor match of α, with the result that setting K to 0 will yield the LZW algorithm. I think Horspool mentions this fact somewhere.) L is just the length of α. The algorithm will end up using some prefix of α, possibly (usually) all of it.\n\nHere's Horspool's pseudocode from Figure 2 with my annotations:\n\n```\ninitialize dictionary D with all strings of length 1;\nset α = the string in D that matches the first\n        symbol of the input;\nset L = length(α);\nwhile more than L symbols of input remain do\nbegin\n    // The new string α++head(β0) must be added to D here, rather\n    // than where Horspool adds it. Otherwise, it is not available for the\n    // search for a successor match. Of course, head(β0) is not meaningful here\n    // because β0 doesn't exist yet, but it's just the symbol following α in\n    // the input.\n    for j := 0 to max(L-1,K) do\n        // The above should be min(L - 1, K), not max.\n        // (Otherwise, K would be almost irrelevant.)\n        find βj, the longest string in D that matches\n            the input starting L-j symbols ahead;\n    add the new string α++head(β0) to D;\n    // See above; the new string must be added before the search\n    set j = value of j in range 0 to max(L-1,K)\n            such that L - j + length(βj) is a maximum;\n    // Again, min rather than max\n    output the index in D of the string prefix(α,j);\n    // Here Horspool forgets that j is the number of characters removed\n    // from the end of α, not the number of characters in the desired prefix.\n    // So j should be replaced with L - j\n    advance j symbols through the input;\n    // Again, the advance should be L - j, not j\n    set α = βj;\n    set L = length(α);\nend;\noutput the index in D of string α;\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Algorithms for interval partitioning with possible delay\r\n                \r\nInterval partitioning is a variant of interval scheduling problems. This problem requires us to schedule all the jobs and find the minimum number of machines for doing the jobs.\n\nOne of the most popular solution is to use greedy algorithm. The greedy algorithm firstly sorts all the jobs by their starting time and we start scheduling jobs one-by-one. \n\nHowever, the disadvantage of this greedy algorithm is that the schedule is very tight and when there is a delay in a job, the next job may face a conflict and require rescheduling.\n\nThe problem is: is there an algorithm that can handle interval partitioning with delay and that rescheduling is expensive and should be avoided?\n\nI have tried searching but I can only find greedy algorithm which cannot deal with delays.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithms and append function - how to create a new array?\r\n                \r\nOkay, so I have an array coin and I want to create a new array which is the same length as array, but with the amount of coins from the array 'coins' needed for input m.\n\n```\ncoin = [200,100,50,20,10,5,2,1]\n```\n\n\nSo far, I have the following. What should be in for loop for me to return what I want?\n\n```\ndef coinSplitGD2(m):\n\n    coin = [200,100,50,20,10,5,2,1]\n\n    if m==0:\n        return 0\n    for i in range(len(coin)):\n        if coin...\n```\n\n\nSo if m is 143, it will return ```\n[0, 1, 0, 2, 0, 0, 1, 1]```\n meaning no 200-coins, one 100-coin, no\n50-coins, two 20-coins, no 10-coins, no 5-coins, one 2-coin and one 1-coin\n    ", "Answer": "\r\n```\ncoin = [200,100,50,20,10,5,2,1]\ndef coinSplitGD2(m):\n    a = []\n    for c in coin:\n        a.append(m // c)\n        m %= c\n    return a\n```\n\n\nso that:\n\n```\ncoinSplitGD2(143)\n```\n\n\nreturns:\n\n```\n[0, 1, 0, 2, 0, 0, 1, 1]\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Optimality of greedy transaction minimisation algorithm\r\n                \r\nrecently I have been reading about the Splitwise problem where one has a group of people with debts between each other, and the goal is to settle these debts with the minimal number of transactions. It can also be modeled as a directed weighted graph which edges are to be reduced.\n\nThe solution I encountered most often was a greedy iterative algorithm that, firstly, calculates the net outcome of every person (money he is owed - money he owes), and then repeats the following:\n\n```\n1. take max. debtor X and max. creditor Y\n2. if X owes more than Y is owed\n     then X pays Y Y's value\n          reduce X's debt by Y's value\n          set Y's value to 0\n     else X pays Y X's value\n          reduce Y's value by X's debt\n          set X's debt to 0\n```\n\n\n...until everyone's value is 0.\n\nMy question(s):\n\n\nIs that algorithm really optimal in the transaction amount it produces? If yes, how can this be proved?\nIf not, what is a counterexample to this algorithm's optimality, i.e., a situation where the debts can be minimised with less transactions than the ones it outputs?\n\n    ", "Answer": "\r\nIt looks like this algorithm isn't optimal. Consider the case [-3, -2, -2, 3, 4], where positive indicates creditor and negative indicates debtor. Using the algorithm described, we require four transaction operations to knock out all the debts:\n\n```\n>> [-3, -2, -2, 3, 4]\n>> [0, -2, -2, 3, 1]    ([0] pays [4])\n>> [0, 0, -2, 1, 1]     ([1] pays [3])\n>> [0, 0, -1, 1, 0]     ([2] pays [4])\n>> [0, 0, 0, 0, 0]      ([2] pays [3])\n```\n\n\nBut you can see that the debts can be cleared via three transactions: the person who owes $3 pays the person credited $3, and then the two who owe $2 each pay the person owed $4.\n\nActually, I believe the goal of the algorithm described is to minimize the total amount of money transacted, rather than the number of transactions, which it does and which can be proven (though I won't attempt that here).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Proof of optimality of greedy algorithm for scheduling\r\n                \r\nUnable to come up with a formal proof of optimality for algorithm A for the given problem. Have convinced myself that it is possible to execute some optimal schedule O in increasing order of the events' deadline. But don't know how to formally prove that extract_max operation converges to an optimal solution.\nProblem\n: Given a list of events with deadline date 'd' and duration 'l' days, provide algorithm to select events such that maximum number of them can be chosen. Of course, each event must be scheduled such that it finishes by deadline date 'd', it must run continuously for its duration 'l' days, and only one event can run at any given time.\n```\n**Greedy Algorithm A:**\n\nCreate max_heap S  //schedule\n\nSort events by their deadline (increasing).\n\nfor(j=0;j<events.size();j++)\n\n{ \n\n  If you can incorporate event j into schedule S, do so. \n\n  Else, if(longest event in S > length of j) swap it with j. \n\n\n}\n\nReturn S; \n\nEND\n```\n\n    ", "Answer": "\r\nWe can prove this by contradiction. Assume that the greedy choice were not part of the optimal solution; that is, if we consider the tasks sorted in ascending order of deadline, the optimal solution wouldn't include the one with the earliest deadline. Now, consider the task with earliest deadline in any hypothetical optimal solution. Either it overlaps with the greedy choice (in which case we might as well have chosen the greedy choice, since it finishes no later than the earliest task in the optimal solution, and cannot overlap with any earlier tasks in the optimal solution, since it was the earliest task); or else it doesn't overlap, in which case the optimal solution wasn't optimal (since we could also freely have included the greedy choice in it). In both cases, we have a contradiction (in the first, that the greedy solution couldn't have been picked; in the second, that the solution without the greedy choice was optimal) and so the assumption that the optimal choice doesn't contain the greedy choice was wrong; the optimal solution does include the greedy choice.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "A greedy or dynamic algorithm to subset selection\r\n                \r\nI have a simple algorithmic question. I would be grateful if you could help me.\n\nWe have some 2 dimensional points. A positive weight is associated to them (a sample problem is attached). We want to select a subset of them which maximizes the weights and neither of two selected points overlap each other (for example, in the attached file, we cannot select both A and C because they are in the same row, and in the same way we cannot select both A and B, because they are in the same column.) If there is any greedy (or dynamic) approach I can use. I'm aware of non-overlapping interval selection algorithm, but I cannot use it here, because my problem is 2 dimensional.\n\nAny reference or note is appreciated.\n\nRegards\n\nAttachment:\nA simple sample of the problem:\n\n   \n   A (30$) --------  B (10$)\n   |\n   |\n   |\n   |\n   C (8$)\n\n\n    ", "Answer": "\r\nIf you are OK with a good solution, and do not demand the best solution - you can use heuristical algorithms to solve this.\n\nLet ```\nS```\n be the set of points, and ```\nw(s)```\n - the weightening function.\n\nCreate a weight function ```\nW:2^S->R```\n (from the subsets of S to real numbers):\n\n```\nW(U) =    - INFINITY                         is the solution is not feasible\n          Sigma(w(u)) for each u in U        otherwise\n```\n\n\nAlso create a function ```\nnext:2^S -> 2^2^S```\n (a function that gets a subset of ```\nS```\n, and returns a set of subsets of ```\nS```\n)\n\n```\nnext(U) = V   you can get V from U by adding/removing one element to/from U\n```\n\n\nNow, given that data - you can invoke any optimization algorithm in the Artificial Intelligence book, such as Genetic Algorithm or Hill Climbing.\n\nFor example, Hill Climbing with random restarts, will be something like that:\n\n```\n1. best<- -INFINITY\n2. while there is more time\n3. choose a random subset s\n4. NEXT <- next(s)\n5. if max{ W(v) | for each v in NEXT} < W(s): //s is a local maximum\n   5.1. if W(s) > best: best <- W(s) //if s is better then the previous result - store it.\n   5.2. go to 2. //restart the hill climbing from a different random point.\n6. else:\n   6.1. s <- max { NEXT }\n   6.2. goto 4.\n7. return best //when out of time, return the best solution found so far.\n```\n\n\nThe above algorithm is anytime - meaning it will produce better results if given more time.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Can I use a greedy method as an heuristic for an A* algorithm?\r\n                \r\nI am trying to find a heuristic to solve a travel salesman problem but with more restrictions.\nUsing the greedy is giving me a total cost of 3.839.\nUsing A* with some estimation as a heuristic is giving me results of 4.0 to 5.35.\nUsing A* while using greedy as a heuristic gives me the best result of 3.5.\nIs this wrong? Using a greedy method as a heuristic for a A* algorithm?\nDoes this fall under the category of non-optimistic? Meaning that It can't be used as a heuristic?\nps: this is a graph with many restrictions, with about 5 metrics, so I can't just calculate a distance to the final point.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Minimum cabs required (Algorithm)\r\n                \r\nI am trying to solve this question:\n\nhttps://www.hackerearth.com/practice/algorithms/greedy/basics-of-greedy-algorithms/practice-problems/algorithm/minimum-cabs-0798cfa5/description/\n\nI see a solution here but I don't quite understand it. \n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1500;\nint A[MAX];\nint main(int argc, char* argv[])\n{\n    if(argc == 2 or argc == 3) freopen(argv[1], \"r\", stdin);\n    if(argc == 3) freopen(argv[2], \"w\", stdout);\n    ios::sync_with_stdio(false);\n    int n, hh1, hh2, mm1, mm2, smins, emins, ans;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> hh1 >> mm1 >> hh2 >> mm2;\n        smins = hh1 * 60 + mm1;\n        emins = hh2 * 60 + mm2;\n        A[smins]++;\n        A[emins+1]--;\n    }\n    ans = A[0];\n    for (int i = 1; i < MAX; i++) {\n        A[i] += A[i-1];\n        ans = max(ans, A[i]);\n    }\n    cout << ans << endl;\n    return 0;\n\n}\n```\n\n\nCould someone explain the algorithm to me?\n    ", "Answer": "\r\nThe given solution works on maximum overlapping intervals.\n\nThe author wants to count the maximum number of intervals or ranges which overlap at any given point in the time.\n\nAssume a time scale, which represents time:\n\nMin time: 00:00 => represents 0 on the time scale\n\nMax time: 23:59 => represents 1439 on the time scale\n\nSo, author used a constant ```\nMAX```\n as 1500, thus making a time scale of [0, 1500], which satisfies our requirement.\n\nNow, for each interval/ range we got from the input, author made use of prefix sum, thus adding 1 to every time unit in the range.\n\nFor eg: Suppose my range is 00:00 to 12:36, then I will add 1 to every index of array ```\nA```\n from 0 to 756.\n\nThe maximum prefix sum denotes the minimum number of cabs required as 1 cab can be only be allocated to 1 person at any particular instance of time.\n\nHope this helps. Feel free to ask any doubts. Kindly mark answer correct if satisfies your doubt.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Activity selection using Greedy Algorithm in Python\r\n                \r\nGiven the problem, I have the following approach however, I am not able to to get all the test cases\nProblem Statement: A club has planned to organize several event. The volunteers are given a list of activities and the starting time and ending time of those activities.\nWrite a python function that accepts the activity list, start_time list and finish_time list. The function should find out and return the list of maximum number of activities that can be performed by a single person.\nAssume that a person can work only on a single activity at a time. If an activity performed by a person ends at x unit time then he/she can take up the next activity which is starting at any time greater than or equal to x+1.\n```\ndef find_maximum_activities(activity_list,start_time_list, finish_time_list):\n    activities = list(zip(activity_list, start_time_list, finish_time_list))\n    activities.sort(key = lambda x: x[2])\n    finish = 0\n    result = []\n    for i in activities:\n        if finish <= i[1]:\n            result.append(i[0])\n            finish = i[2]\n    return result\n    \nactivity_list=[1,2,3,4,5,6,7]\nstart_time_list=[1,4,2,3,6,8,6]\nfinish_time_list=[2,6,4,5,7,10,9]\n\n\nresult=find_maximum_activities(activity_list,start_time_list, finish_time_list)\nprint(\"The maximum set of activities that can be completed:\",result)\n```\n\n    ", "Answer": "\r\nYou are missing to update the finish variable.\n\n```\nactivities.sort(key=lambda x: x[1])\nfinish = -1\nresult = []\n\nfor i in activities:\n    if finish <= i[0]:\n        result.append(d[i])\n        finish = i[1]\n```\n\n\nTry the above snippet.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm that works on two ends of an array in Haskell\r\n                \r\nI'm mostly curious about the general pattern that's best practice to implement algorithms where we we're marching along indices on opposite ends of an array.\nHere's an example problem from leetcode.\nProblem Statement\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample Solution\n```\nclass Solution {\npublic:\n    int trap(int A[], int n) {\n        int left=0; int right=n-1;\n        int res=0;\n        int maxleft=0, maxright=0;\n        while(left<=right){\n            if(A[left]<=A[right]){\n                if(A[left]>=maxleft) maxleft=A[left];\n                else res+=maxleft-A[left];\n                left++;\n            }\n            else{\n                if(A[right]>=maxright) maxright= A[right];\n                else res+=maxright-A[right];\n                right--;\n            }\n        }\n        return res;\n    }\n};\n```\n\nI've really enjoyed Haskell because of how elegant the solutions tend to be but I'm wondering if sometimes it's better to be able to fall back on imperative programming like is an option in OCaml\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What's the proper greedy algorithm approaching \"Job shop scheduling\" problem?\r\n                \r\nhaving N jobs of different size with specific dependencies (of other Jobs) defined, what's a good greedy approach to assign these Jobs to M Machines with various processing power? \n\nfirst, I came up with the idea of defining different levels such that works with no dependency come as the first level and level of the other job's nodes in the graph being the longest path from the level one nodes to those nodes.\nthen assigning the heaviest job in each level to the most powerful machine and following the order, but then I thought maybe how many jobs depend on current jobs is a more important factor.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is the greedy many-to-many alignment algorithm in this paper?\r\n                \r\nI got stuck by this greedy many-to-many alignment algorithm depicted below in this paper:\n\nI wonder how it works? I have googled but found nothing related.\n    ", "Answer": "\r\nI found its video on papertalk, and got to know the mechanism. It's not a classic algorithm but just an alignment method utilized by the author.\nIt's actually very simple.\n\nEach ground truth segment first aligns to the maximally overlapping predicted segment\n\n\n\neach leftover predicted segment then aligns to the maximally overlapping ground truth segment\n\n\nThe goal of these two steps is to find a target for each predicted label. That is, disregarding the directions of the arrows, the connected ground truth segment label and predicted segment label are paired to do pooling and then calculate the loss.\nIn the paper the above mechanism is not used in the beginning, but the teacher forcing is used. In the beginning, the ground truth boundaries are directly utilized to do pooling and then loss.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm: Assigning jobs to minimize cost\r\n                \r\nWhat is the best approach to take if I want to find the minimum total cost if I want to assign n jobs to a person in a sequence which have cost assigned to them? For eg. I have 2 jobs which have costs 4 and 5 respectively. Both jobs take 6 and 10 minutes respectively. So the finish time of the second job will be finish time of first job + time taken by this job. So the total cost will be finish time of each job multiplied by its cost.\n    ", "Answer": "\r\nIf you have to assign n jobs to 1 person (or 1 machine) in scheduling literature terminology, you are looking to minimize weighted flow time. The problem is polynomially solvable.\n\nThe shortest weighted processing time sequence is optimal. \n\nSort and reindex jobs such that p_1/w_1 <= p_2/w_2 <= ... <= p_n/w_n,\n\nwhere, p_i is the processing time of the ith job and w_i is its weight or cost.\n\nThen, assign job 1 first, followed by 2 and so on until n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is it guarantee for greedy algorithm to find a solution? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nLet's say I want to find a Hamiltonian circuit. If my algorithm has no edges to visit, should it return false or go back to the place where it can do something?\n    ", "Answer": "\r\nHamilton circuit finding is an NP-hard problem, so by consequence there is no greedy algorithm to always successfully find one when it is possible. This means indeed that an algorithm that initially takes a greedy approach, and is unsuccessful, will need to backtrack and choose another route to try again.\nSee also How to find Hamiltonian Cycle in a Graph\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Search from point A to point B on a graph\r\n                \r\nA question in my textbook asked me to calculate and find a route from Mehadia to Bucharest via 1) A Greedy Search and 2) A uniform-cost search.\n\n*Now I am able to completely illustrate and solve the route via uniform cost search but my greedy search is looking very similar. Any ideas on how I can calculate the route via a \"greedy\" search? \n\n\n\nUPDATE\nI've applied a messy greedy algotithm and have gotten a different route vs the shortest route from my uniform-cost.\n\nThis is the route outputted by my greedy algorithm. The algorithm just keep checking and choosing the smallest local value. My NEW QUESTION to anyone: Is this route acceptable as an output of my greedy algorithm? I.e. could my solution even be legally considered as greedy?\n\nRoute based on my new algorithm:\n\nMehadia -> Lugoj -> Timisoara -> Arad -> Zerind -> Oradea -> Sibiu -> \nRimnicu Vilcea -> Pitesti -> Bucharest\n    ", "Answer": "\r\nWhen you use Uniform-cost Search you are calculating shortest paths from Mehadia to all nodes, so you can be certain the Mehadia-Bucharest path will be the optimal one (this algorithm is complete and optimal).\nHowever if you use a Greedy Search Algorithm, it will choose the locally best\noption discarding the others for each node. This algorithm is neither complete nor optimal.\nTo answer your question yes, your solution is considered as greedy.\n\nHope this helps.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Largest Possible number from given numbers.(Alternative), Greedy Algorithm\r\n                \r\nFor example, if the input digits are ```\n4 9 3 7```\n(for n=4) answer is ```\n9743```\n\n\n1 ≤ 𝑛 ≤ 100, 1 ≤ 𝑎𝑖 ≤ 10^4 for all 1 ≤ 𝑖 ≤ 𝑛.\n\n```\nn = int(input())\nintegers = list(map(int, input().split()))\n# integers.sort()\n\nanswer = ''\n\ndef is_greater_or_equal(max_int, integer):\n\n  len_diff = len(str(max_int)) - len(str(integer))\n\n  if len_diff > 0:\n    integer = int(str(integer) + str(integer%10)*len_diff)\n\n    return integer >= max_int\n\n  else:\n    len_diff = abs(len_diff)\n    max_int = int(str(max_int) + str(max_int%10)*len_diff)\n\n    return integer >= max_int\n\n\nwhile len(integers) != 0:\n  max_int = 0\n\n  for integer in integers:\n\n    if is_greater_or_equal(max_int, integer) :\n      max_int = integer\n\n  answer += str(max_int)\n  integers.remove(max_int)\n\nprint(int(answer))\n```\n\n\nGreedy Approach: Find the custom_maximum(e.g 56>(5=55)>54 which is done by function is_greater_or_equal() but comparing two numbers at a time) number and append it to ```\nanswer```\n string and remove from the input list\n\nSub problem: Find custom_max from the list with reduced size at each iteration\n\n```\nis_greater_or_equal()```\n gives a correct output when used as standalone, but the above code as a whole fails\n\nI have the following questions :\n\n\nIn the case of 5 and 55, which one should be prioritized (i think it depends on other numbers in the list but I am not clear how)?\nWhy is looping or sorting failing and how to fix it?\n\n\nConsider input: \n\n```\n4\n10 1000 100 1\n# this works if integers.sort(reverse=True)\n\n4\n100 10 899 89\n# fails for integers.sort(reverse=True)\n\n```\n\n\nIf I sort(no matter ascending or descending) the input array, it still fails in some cases.\n\nNOTE 1)I am aware of comparing two concatenated numbers approach but I want to know if it is possible to solve by the above approach. 2) This is not homework or formal-task.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is a greedy algorithm that choses n pairs such that the max ∆ in the pairs is as small as possible? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have n puppies with a size and n kittens with a size and I want to make puppy-kitten pairs. In particular, I would like a puppy-kitten pair with as small of a size difference as possible.\nWhat would be an efficient, greedy algorithm that chooses n puppy-kitten pairs so that the size difference between the\nmost size-disparate pair is as small as possible?  More precisely, denote by s_i the size of puppy i and s_j denote the size of kitten j. Given a pair <i, j>, let ∆(i, j) = | s_i − s_j |. The algorithm should choose pairings to ensure the largest ∆(i, j) over all of your pairings is as small as possible.\nHere’s an example: there are three puppies of sizes 6, 4, and 9 and three kittens of sizes 8, 7, and 3. If you pair them <6, 8>, <4, 7> , <9, 3> then the maximum ∆ is 6, whereas if you pair them <6, 7> , <4, 3> , <9, 8>, the maximum ∆ is 1, which is clearly optimal (because, for example, the puppy with size 6 can only\nbe matched to a kitten whose size is ≥ 1 away from the puppy’s size).\n    ", "Answer": "\r\nAn optimal greedy algorithm is:\n\nSort puppies from smallest to largest (ties are broken arbitrarily). Denote such list ```\nP```\n.\nSort kittens from smallest to largest (ties are broken arbitrarily). Denote such list ```\nK```\n.\nSelect pairs according to their indexes ```\n(P[0], K[0])```\n, ```\n(P[1], K[1])```\n, ..., ```\n(P[n - 1], K[n - 1])```\n.\n\nSuch choice can be proved optimal using Exchange Argument.\nDefinition: A list has an inversion if there are two pairs ```\n(a, d)```\n and ```\n(b, c)```\n such that ```\na < b```\n and ```\nc < d```\n.\nLemma 1: All arrangements with no inversions have the same ∆. (a task for you :P, compare what happen in case of ```\na = b```\n and ```\nc < d```\n, ```\na < b```\n and ```\nc = d```\n)\nClaim: There is an optimal arrangement that has no inversions.\nProof. There exist at least an optimal arrangement, let's call it ```\nO```\n.\nIf ```\nO```\n has no inversions we are done.\nElse after swapping ```\n(a, d)```\n and ```\n(b, c)```\n for ```\n(a, c)```\n and ```\n(b, d)```\n we get an optimal arrangement with one less inversion. The initial arrangement can have at most Cn2 inversions, and hence after at most Cn2 swaps we get an optimal arrangement with no inversions.\nWe know that ```\na < b```\n and ```\nc < d```\n. Forcing the other inequalities:\n\n```\na <= c```\n and ```\nb <= d```\n:\n```\n|a - d| = max(|a - d|, |b - c|) >= max(|a - c|, |b - d|)```\n\n```\nc <= a```\n and ```\nb <= d```\n:\n```\n|a - d| >= |b - d|```\n and ```\n|b - c| >= |a - c|```\n then ```\nmax(|a - d|, |b - c|) >= max(|a - c|, |b - d|)```\n\n```\na <= c```\n and ```\nd <= b```\n:\n```\n|a - d| >= |a - c|```\n and ```\n|b - c| >= |b - d|```\n then ```\nmax(|a - d|, |b - c|) >= max(|a - c|, |b - d|)```\n\n```\na >= c```\n and ```\nd <= b```\n:\n```\n|b - c| = max(|a - d|, |b - c|) >= max(|a - c|, |b - d|)```\n\n\nIn all cases swapped arrangement does not increase ∆ value and we know that initial arrangement has optimal ∆ value so our claim is true.\nBy lemma 1 and claim the greedy algorithm is optimal.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "C - My greedy algorithm is not working CS50x\r\n                \r\nI am doing cs50x and have run into a spot of trouble with my work. I am supposed to create an algorithm that will output the least amout of coins required to give back change. E.g 0.41 dollars will be 4 coins, a quarter (0.25), two dimes, (0.10) and a cent (0.01).For some reason this algorithm is not working (it is out putting the incorrect number of coins) and I cannot figure out why:\n\n```\n#include <stdio.h>\n#include <cs50.h>\n\nint Coins;\nfloat Owed;\n\nint main(void)\n{\n    printf(\"How much is owed?\\n\");\n    Owed = GetFloat();\n    while (Owed < 0)\n    {\n        printf(\"A positive number please\");\n        Owed = GetFloat();\n    }\n    if (Owed >= 0.25)\n    {\n        while (Owed >=0.25)\n        {\n            Owed = Owed - 0.25;\n            Coins++;\n        }\n    }\n\n     if (Owed >= 0.1)\n    {\n        while (Owed >=0.1)\n        {\n            Owed = Owed - 0.1;\n            Coins++;\n        }\n\n    }\n\n       if (Owed >= 0.05)\n    {\n        while (Owed >=0.05)\n        {\n            Owed = Owed - 0.05;\n            Coins++;\n        }\n\n    }\n\n       if (Owed >= 0.01)\n    {\n        while (Owed >= 0.01)\n        {\n            Owed = Owed - 0.01;\n            Coins++;\n        }\n\n    }\n    printf(\"%d\",Coins);\n}\n```\n\n\nWhen i ran the code and used 0.41 as the amount owed, i got 3 coins when the answer is supposed to be 4:\n\nGreedyNotWorkTerminalPage\n    ", "Answer": "\r\nWhen you use ```\nfloat```\n, you need notice that it's possible to lose accuracy in this kind of operations. Look at this: Floating point inaccuracy examples\n\nI recommend you work with cents, using a ```\nint```\n instead.\n\nColiru example\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Change-Making Algorithm in matlab\r\n                \r\nlet us suppose we have following  array\n\n```\na=[9 15 10 7 8  6];\nn=43;\n```\n\n\nwhat i want is to choose several  numbers with greedy property(  also repeated numbers possible are ) whose sum  gives  us 43, for instance\n\n```\n 15 15 9 7\n```\n\n\nand i have implemented following code\n\n```\n function total=change_making(a,n)\n        % n total number of coints  to make\n        % a array  of coints\n        total=0;\n        while (total+max(a))<=n\n            total=total+max(a);\n               fprintf('% d ',max(a));\n              if (total+max(a))>n\n            while (total+max(a))>n\n           a(find(a==max(a)))=[];% ti remove  maximum array\n            end\n\n\n              end\n\n        end\n\n        end\n```\n\n\nbut when i applied to the given input, i got\n\n```\ntotal=change_making(a,n)\n 15  15  10 \ntotal =\n\n    40\n```\n\n\nof course we dont have  exactly 43, so one of approach will be  to check if  n-total will be less then  all  element of  a, which means\n\n```\nall(a)>(n-total) \n```\n\n\nbut i am not sure if this will work for any case, so what will be best approach? thanks in advance\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Floating point issue in greedy algorithm in C [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nAlthough I'm aware that there are other threads about this, I've created my own because I don't want to see others' solutions. All of the results print fine except for 4.2. I'm aware of floating point imprecision and have tried to solve it, but cannot do so.\n\nCan someone point me in the right direction on this? (No solutions, just a nod in the right direction.)\n\n```\n#include<stdio.h>\n#include<cs50.h>\n#include<math.h>\n\nint main(void)\n{\n    double quarter = 0.250, dimes = 0.100, nickels = 0.050, pennies = 0.010;\n    double $change = 0.00;\n    int coins = 0;\n    double rem = 0.00;\n    double rem2 = 0;\n    double rem3 = 0;\n    double a = 0;\n    int b = 0;\n    double c = 0;\n    double d = 0;\n\n    do\n    {\n        $change = get_float(\"Change owed: \");\n    }\n    while( $change < 0);\n    int cents = round( $change * 100);\n\n    a = $change / quarter;\n    rem = fmod($change, quarter);\n\n    b = rem / dimes;\n    rem2 = fmod(rem, dimes);\n\n    c = rem2 / nickels;\n    rem3 = fmod(rem2, nickels);\n\n    d = rem3 / pennies;\n\n    coins = a + b + c + d;\n\n    printf(\"%i\\n\", coins);\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nDon't use floats/doubles Why not use Double or Float to represent currency?\n\nYou may work with integers with the minimum quantity be 1 penny for example. You may convert everything to penny to do calculations and then you can convert it back to anything to display as, but you should always treat reminders like for example for divisions some part can have an extra penny. Or if you want more generic solution then maybe you may use decimals such as https://github.com/libdfp/libdfp and How to print/convert decimal floating point values in GCC?\n\nyou may search for more https://github.com/search?l=C&q=decimal&type=Repositories\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How can I write a Java code that solves this problem by using a design a greedy algorithm?\r\n                \r\nThe problem: \n\nYou are going on a long trip. You start on the road at mile post 0. Along the way there are n hotels, numbered as 1 ≤ i ≤ n, at mile posts a 1 < a 2 < . . . < a n , where each a i is measured from the starting point. The only places you are allowed to stop are at these hotels, but you can choose which of the hotels you stop at. You must stop at the final hotel (at distance a n ), which is your destination.\nYou would ideally like to travel 200 miles a day, but this may not be possible (depending on the spacing of the hotels). If you travel x miles during a day, the penalty for that day is (200 − x) 2 . You want to plan your trip so as to minimize the total penalty, the sum, over all travel days, of the daily penalties.\n\nDoes anyone know how I can write a Java code that solves this problem by using a greedy algorithm? \n\nWhat I have already is: \n\n```\npublic static void greedy(int[] a) {\n    int[] hotel = a;\n    int[] cost = new int[hotel.length];\n    int[] stop = new int[hotel.length];\n\n    int dist = 0;\n\n    for (int i = 0; i < hotel.length - 1; i++) {\n        dist = a[i + 1] - a[i];\n        cost[i] = (int) (Math.pow((200 - hotel[i]), 2));\n        stop[i] = 0;\n    }\n}\n```\n\n\nBut I don't know where to go from here.. \n    ", "Answer": "\r\nThe total distance that you need to cover is ```\na(n)```\n, as far as I could understand. As we have to stay in the last hotel, then I would like to propose a greedy solution in reverse mode. \n\nIf ```\na(n) - a(n-1)```\n cannot be greater than ```\n200```\n miles. So I would like to pick a hotel ```\na(i)```\n which is in the middle of somewhere between ```\na(n)```\n and ```\na(n) - 200```\n. Now as we are considering a greedy approach, you need to pick that hotel and save this hotel in your visit list. \n\nNow, move forward from there and pick the next hotel where the distance is between ```\na(i)```\n and ```\na(i) - 200```\n and so on until you reach your starting point. \n\nI am not writing any code as I assume this is homework. However, I think you get the idea. Hope that helps! Good luck.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Gas Station-like Algorithm with minimum cost? Greedy or DP?\r\n                \r\nI have an array of ```\nn```\n service stations ```\nD[]```\n on a highway such that ```\nD[i]```\n is the distance of the station ```\ni```\n from the start of the highway.\n\nI also have an array of costs ```\nC[]```\n such that ```\nC[i]```\n is the cost of getting my vehicle serviced at station ```\ni```\n.\n\nI have to get my car serviced at the first station, and my car can travel at most 100 miles between stations. \n\nWhat is the most efficient algorithm to get from the start of the highway to the end with the least cost (I need to know which stations to stop at)? I was able to find a greedy solution for minimizing the number of stops, but for the least cost, I am thinking DP, with the optimal subproblem:\n\n```\nbestcost[j] = min( 0<i<j bestcost[i] + C[j] s.t. D[j]-D[i] <= 100)\n```\n\n\nand have a separate array ```\nlast[j]```\n which contains the last station at which to stop, which would be the best ```\ni```\n from above subproblem.\n\nWould this be the right approach, or is there a better Greedy / DP solution?\n    ", "Answer": "\r\nThe recurrence is better written as\n\n```\nbestcost_serviced_at[j] =\n  min(0<i<j: bestcost_serviced_at[i] + C[j] s.t. D[j]-D[i] <= 100)\n```\n\n\nbecause the recurrence gives the optimal cost assuming that the vehicle actually stops at station ```\nj```\n for service.\n\nThen the solution to the problem is\n\n```\nmin (j: bestcost_serviced_at[j] s.t. highway_end - D[j] <= 100)\n```\n\n\nI don't think a greedy algorithm would work.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "A greedy algorithm for converting a binary matrix to zero matrix by flipping the cells\r\n                \r\nWe have a M*N matrix with some 1 and 0, we want to make all of these cells zero using a 2*2 square. When this square is pushed on 4 cells their contents will be flopped. We want to find if there is any answer to a given matrix to completely convert all cells to zero or not.\n\nIs there any greedy answer to this?\n    ", "Answer": "\r\nCall your larger matrix M and your small one ( the 2x2 ) P\n\nScan your P from left to right, and top to bottom on M. Every time the top left hand of cell of P on M is 1 apply P.\n\nBy the time you get to the bottom right part of M every cell except the right hand column and bottom row of M is guaranteed to be 0.\n\nIf those last columns are not zero then there is no solution.\n\nYou can prove that not every matrix can be cleared by this process. For example if M were a 2x2 non-zero matrix it could never be cleared using this process. \n\nNeither can any matrix M of any size with between 1 and 3 cells set to 1. \n\nI suspect that there is a more general unsolvable case - e.g. it could be that matrices that don't have a multiple of 4 bits set to 1 cannot be solved this way.\n\nThinking about it more - I don't think you can solve any matrix with an odd number of 1's on any row or column.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why does my 2022 CS50 Cash greedy algorithm output a different number of coins then calculating manually?\r\n                \r\nI'm taking a CS50x without prior knowledge of coding and am kind of stuck on the 2nd Week problem set 1. This is a greedy algorithm problem, in which the program calculates the number of coins to be given to pay back the change. The code passes CS50 automatic check, but it has issues on self-check.\nExample:\nIf I input 5 change on prompt, it is supposed to give me 2 coins - one nickel and one penny (5 + 1), but the code instead outputs 4 coins.\nIf I input 160 change on prompt (same as cs50 check tool uses), it is supposed to give me 7 coins - six quarters and one dime ( 6 + 1). Instead, this code gives me 9 coins.\nI'm scratching my head because if I use the calculator and go manually through the do while loops, it makes sense to output what it is supposed to be output, but, apparently, the program works differently.\nAny ideas?\n```\n#include <cs50.h>\n#include <stdio.h>\n\nint get_cents(void);\nint calculate_quarters(int cents);\nint calculate_dimes(int cents);\nint calculate_nickels(int cents);\nint calculate_pennies(int cents);\n\nint main(void)\n{\n    // Ask how many cents the customer is owed\n    int cents = get_cents();\n\n    // Calculate the number of quarters to give the customer\n    int quarters = calculate_quarters(cents);\n    cents = cents - quarters * 25;\n\n    // Calculate the number of dimes to give the customer\n    int dimes = calculate_dimes(cents);\n    cents = cents - dimes * 10;\n\n    // Calculate the number of nickels to give the customer\n    int nickels = calculate_nickels(cents);\n    cents = cents - nickels * 5;\n\n    // Calculate the number of pennies to give the customer\n    int pennies = calculate_pennies(cents);\n    cents = cents - pennies * 1;\n\n    // Sum coins\n    int coins = quarters + dimes + nickels + pennies;\n\n    // Print total number of coins to give the customer\n    printf(\"%i\\n\", coins);\n}\n\nint get_cents(void)\n{\n    //Ask for how much change is owed\n    int cents = 0;\n    do\n    {\n        cents = get_int(\"Change owed: \");\n    }\n    while (cents <= 0);\n    return cents;\n}\n\nint calculate_quarters(int cents)\n{\n    //Continue to check for how many quarters fit into input amout of change\n    int quarters = 0;\n    do\n    {\n        cents = cents - 25;\n        quarters++;\n    }\n    while (cents >= 25);\n    return quarters;\n}\n\nint calculate_dimes(int cents)\n{\n    //Continue to check for how many cents fit into input amout of change after subtracting quarters\n    int dimes = 0;\n    do\n    {\n        cents = cents - 10;\n        dimes++;\n    }\n    while (cents >= 10);\n    return dimes;\n}\n\nint calculate_nickels(int cents)\n{\n    int nickels = 0;\n    do\n    {\n        cents = cents - 5;\n        nickels++;\n    }\n    while (cents >= 5);\n    return nickels;\n}\n\nint calculate_pennies(int cents)\n{\n    int pennies = 0;\n    do\n    {\n        cents = cents - 1;\n        pennies++;\n    }\n    while (cents >= 1);\n    return pennies;\n}\n```\n\n    ", "Answer": "\r\nYou use ```\ndo```\n / ```\nwhile```\n loops to compute the number of coins of each kind, hence you always count at least one coin of each kind, which is incorrect. For example if you have 2 cents to distribute, you will get 1 quarter and ```\ncents```\n will become ```\n-3```\n, then 1 dime and ```\ncents```\n becomes ```\n-13```\n, etc. resulting in 4 coins where 2 are needed.\nThis problem could have been diagnosed using a debugger or simply by adding a ```\nprintf(\"quarters=%d, cents=%d\\n\", quarters, cents);```\n statement before calling ```\ncalculate_dimes(cents)```\n.\nYou should use ```\nwhile```\n loops instead. More generally, you should avoid ```\ndo```\n / ```\nwhile```\n loops. They are rarely the right tool.\nHere is a modified version:\n```\n#include <cs50.h>\n#include <stdio.h>\n\nint get_cents(void);\nint calculate_quarters(int cents);\nint calculate_dimes(int cents);\nint calculate_nickels(int cents);\nint calculate_pennies(int cents);\n\nint main() {\n    // Ask how many cents the customer is owed\n    int cents = get_cents();\n\n    // Calculate the number of quarters to give the customer\n    int quarters = calculate_quarters(cents);\n    cents = cents - quarters * 25;\n\n    // Calculate the number of dimes to give the customer\n    int dimes = calculate_dimes(cents);\n    cents = cents - dimes * 10;\n\n    // Calculate the number of nickels to give the customer\n    int nickels = calculate_nickels(cents);\n    cents = cents - nickels * 5;\n\n    // Calculate the number of pennies to give the customer\n    int pennies = calculate_pennies(cents);\n    cents = cents - pennies * 1;\n\n    // Sum coins\n    int coins = quarters + dimes + nickels + pennies;\n\n    // Print total number of coins to give the customer\n    printf(\"%d\\n\", coins);\n    return 0;\n}\n\nint get_cents(void) {\n    //Ask for how much change is owed\n    for (;;) {\n        int cents = get_int(\"Change owed: \");\n        if (cents > 0)\n            return cents;\n        printf(\"number must be positive\\n\");\n    }\n}\n\nint calculate_quarters(int cents) {\n    //Continue to check for how many quarters fit into input amout of change\n    int quarters = 0;\n    while (cents >= 25) {\n        cents = cents - 25;\n        quarters++;\n    }\n    return quarters;\n}\n\nint calculate_dimes(int cents) {\n    //Continue to check for how many cents fit into input amout of change after subtracting quarters\n    int dimes = 0;\n    while (cents >= 10) {\n        cents = cents - 10;\n        dimes++;\n    }\n    return dimes;\n}\n\nint calculate_nickels(int cents) {\n    int nickels = 0;\n    while (cents >= 5) {\n        cents = cents - 5;\n        nickels++;\n    }\n    return nickels;\n}\n\nint calculate_pennies(int cents) {\n    return cents;\n}\n```\n\nNote however that there is a much simpler method using integer division and remainder:\n```\n#include <cs50.h>\n#include <stdio.h>\n\nint get_cents(void);\n\nint main() {\n    // Ask how many cents the customer is owed\n    int cents = get_cents();\n\n    // Calculate the number of quarters to give the customer\n    int quarters = cents / 25;\n    cents = cents % 25;\n\n    // Calculate the number of dimes to give the customer\n    int dimes = cents / 10;\n    cents = cents % 10;\n\n    // Calculate the number of nickels to give the customer\n    int nickels = cents / 5;\n    cents = cents % 5;\n\n    // Calculate the number of pennies to give the customer\n    int pennies = cents;\n\n    // Sum coins\n    int coins = quarters + dimes + nickels + pennies;\n\n    // Print total number of coins to give the customer\n    printf(\"%d\\n\", coins);\n    return 0;\n}\n\nint get_cents(void) {\n    //Ask for how much change is owed\n    for (;;) {\n        int cents = get_int(\"Change owed: \");\n        if (cents > 0)\n            return cents;\n        printf(\"number must be positive\\n\");\n    }\n}\n```\n\nThe above function is a good compromise... below is an alternative with all the operations combined as a single expression. You can study it for information as an example of smaller being more difficult to understand while producing code very similar to the previous version.\n```\nint main() {\n    // Ask how many cents the customer is owed\n    int cents = get_cents();\n\n    // Compute the number of coins\n    int coins = cents / 25 + cents % 25 / 10 + cents % 25 % 10 / 5 + cents % 5;\n\n    // Print total number of coins to give the customer\n    printf(\"%d\\n\", coins);\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "scheduling events using shortest duration as greedy algorithm\r\n                \r\nThere is a list of events and I want to schedule maximum number of events in a day in a way that they don't conflict with each other and the events are scheduled based on short duration events being considered first. I have my code attached below which shows what I am trying to do, I know I am sorting them correctly based on their duration but further I am not able to schedule them without conflicts. Can someone please help me with this.\n```\ndef shortest_duration(events):\n    events.sort(key= lambda x: x[1]-x[0])\n    print(events)\n    finish =0\n    ans=[]\n    for event in events:\n        if finish <= event[0]:\n            finish= event[1]\n            ans.append(event)\n    return ans\n\nevents = [(420, 480), (420, 510), (450, 550), (480, 570), (510, 540), (540, 570), (540, 630), (570, 630)]\n\nprint(events)\nprint(shortest_duration(events))\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to parallelize Greedy assignment problem\r\n                \r\nI have a large 2D cost matrix: 500K x 500K and I want to solve the assignment problem. Aside from the Hungarian algorithm, I want to use below greedy algorithm to reduce the time:\n```\n# H1,H2 in range(500K)\nfor n1 in H1:\n    best = -1\n    for n2 in H2:\n        if cost[n1,n2] > best and n2 not in matched:\n            aligned[n1]=n2\n            best = cost[n1,n2]\n    matched.append(aligned[n1])\n```\n\nUsing one core it will take forever (for 5Kx5K it takes 40mins on single thread). I guess we cannot parallelize the nested loop, because we need the best variable. right?\nI tried this code to parallelize, but it gives me many repetitive columns.\n```\nfrom joblib import Parallel, delayed\nimport multiprocessing\n\ninputs = range(500000)\ndef processInput(i):\n    row = cost[i, :]\n    # cost[row, col[0][0]] = 10e5 ### not possible as read-only in multiprocessing\n    return i,col\n\n\nnum_cores = multiprocessing.cpu_count()\nrow_col = Parallel(n_jobs=num_cores)(delayed(processInput)(i) for i in inputs)\n```\n\nany suggestion to run the greedy algorithm faster (my parallel solution is not working)?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Travelling Salesperson - Why greedy algos are not guaranteed to give an optimal solution?\r\n                \r\nWhy is there no greedy algorithm that is guaranteed to give an optimal solution for the travelling salesperson problem? Is there an example for that?\n    ", "Answer": "\r\nThe short answer is that the travelling salesman problem does not satisfy the properties necessary to prove the correctness of a greedy algorithm. In order for a greedy algorithm to be correct, it must both satisfy the greedy-choice property (the first choice in your algorithm can always be in an optimal solution), and the optimal substructure property (an optimal solution to a problem contains optimal solutions to each sub problem). \n\nWhile the travelling salesman does satisfy the optimal substructures property, no algorithm for this problem can satisfy the greedy choice property. Greedy algorithms require discarding other potential solutions to each sub-problem, and Traveling Salesman is too complex to do so.\n\nA general algorithm for the Traveling salesman is to choose a starting point, generate all (n-1)! permutations of cities to visit, calculate each one's cost, then return the cheapest permutation. The running time for this algorithm is Θ(n!).\n\nThe decision version of the traveling salesperson problem is an NP-Complete problem (in this version, given a length X, does a given list of cities have a distance less than or equal to X). NP is short for \"non-deterministic polynomial\", and a problem in NP means that, given an answer to the problem, you can verify whether or not the certificate is correct in polynomial time. NP-Complete is the hardest class of problems in NP, and no NP-complete problem can be solved in polynomial time.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "I was trying to write a Greedy Algorithm in C [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nDoes this make any sense? \n\nI got stuck in here with 4 errors and it is because I didn't declared the ints q,d,n,p. But if I do so it'll keep sending me more errors.\n\nThere might be something about having mixed ints and floats.\n\n```\n#include <cs50.h>\n#include <stdio.h>\n\n\nint main(void)\n{\n    {\n        printf(\"O hai! \");\n    }\n    float valueTotal, quarter, valueQuarter, dime, valueDime,nickel, valueNickel, penny, valuePenny; \n    do\n    {\n        printf(\"How much change is owed?\\n\");\n        valueTotal = GetFloat();\n    }\n    while (valueTotal <= 0);\n\n\n    for (float quarter = 0; valueTotal >= 0.25; quarter--)\n    {\n        valueQuarter = valueTotal - ( q * 0.25);\n    }\n    for (float dime = 0; valueQuarter >= 0.10; dime--)\n    {\n        valueDime = valueQuarter - ( d * 0.10);\n    } \n    for (float nickel = 0; valueDime >= 0.05; nickel--)\n    {\n        valueNickel = valueDime - ( n * 0.05);\n    }\n    for (float penny = 0; valueNickel >= 0.01; penny--)\n    {\n        valuePenny = valueNickel - ( p * 0.01);\n    }\n    printf(\"q+d+n+p\\n\");\n}\n```\n\n    ", "Answer": "\r\n\n  I didn't declared the ints q,d,n,p.\n\n\nThis is exactly your problem - at least one of them, anyways. If these variables are undeclared, how in the world is the program/code supposed to evaluate something like ```\nq * 0.25```\n ? If I said \"Hey man, what is  x times 0.25?\" You'd have absolutely no idea, or tell me that the answer depends on x. The same goes with this code.\n\nYou said:\n\n\n  But if I do so it'll keep sending me more errors.\n\n\nI'm assuming you also need to initialize them (or, in layman's terms, set them equal to something ie. q = 0)\n\nAlso, none of your loop conditions are actually changing.... meaning they're infinitely looping. Make sure that the code inside your loop is actually helping you reach the goal of satisfying the loop condition; for example:\n\n```\n for (float quarter = 0; valueTotal >= 0.25; quarter--)\n    {\n        valueQuarter = valueTotal - ( q * 0.25);\n    }\n```\n\n\nvalueTotal is ALWAYS going to be greater than 0.25 (if it is less than 0.25 to begin with) since you are never changing it at all. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "A* pathfinding algorithm is being semi-greedy\r\n                \r\nSo I have been trying to implement the A* pathfinding algorithm for a 2D tilemap in Java from this video: https://www.youtube.com/watch?v=-L-WgKMFuhE. I tried following the pseudocode and not enough details, I felt, were not explained greatly, especially the idea of the G cost. So, I decided to go into the actual code the video creator wrote and used a lot of his ideas and structure as I had spent a lot of time looking at multiple pseudocodes and not getting the desired result.\nI understand the code perfectly and going step by step it makes sense, but for some reason the algorithm sometimes is not producing the shortest path. In fact, it is being greedy and trying to reach the end destination early on. Here are 2 examples (The green dot is the start and the red dot is the end. The gray tiles represent the path and the black tiles represent walls):\n\n\nI have repeatedly looked at the creator's code and my own and I just can't find the problem.\nHere is my pathfinding method:\n```\nNode start, end; //these are initialized through a GUI\n\nList<Node> open = new ArrayList<Node>();\nSet<Node> closed = new HashSet<Node>();\n    \nboolean pathExists = true;\n\npublic void findPath() {\n        open.add(start);\n\n        while(!open.isEmpty()) {\n            Map<Node, Double> costs = new HashMap<Node, Double>();\n            for(Node node: open) {\n                costs.put(node, node.cost());\n            }\n            Node current = Collections.min(costs.entrySet(), Map.Entry.comparingByValue()).getKey();\n            \n            open.remove(current);\n            closed.add(current);\n            \n            if(current.equals(end)) {\n                end = current;\n                return;\n            }\n            \n            for(Node adjacent: current.getAdjacentNodes()) {\n                if(contains(closed, adjacent) || !inBounds(adjacent.getPoint()))\n                    continue;\n                \n                double newG = current.g + adjacent.getDistanceTo(current);\n                if(newG < adjacent.g || !contains(open, adjacent)) {\n                    adjacent.g = newG;\n                    adjacent.h = adjacent.getDistanceTo(end);\n                    adjacent.parent = current;\n                    \n                    if(!contains(open, adjacent))\n                        open.add(adjacent);\n                }\n            }\n        }\n        pathExists = false;\n    }\n```\n\nAnd here is my Node class:\n```\nprivate class Node {\n        public Point point;\n        public Node parent;\n        \n        public double g, h;\n\n        public Node(Point point) {\n            this.point = point;\n        }\n        \n        public Node getParent() {\n            return parent;\n        }\n        \n        public double cost() {\n            return g + h;\n        }\n        \n        public double getDistanceTo(Node node) {\n            int x = Math.abs((point.x - node.point.x)/cellWidth); //cell width and height are the dimensions of each tile\n            int y = Math.abs((point.y - node.point.y)/cellHeight);\n            \n            if(x > y)\n                return 14*y + 10*(x - y);\n            return 14*x + 10*(y - x);\n        }\n        \n        public List<Node> getAdjacentNodes() {\n            return List.of(\n                    new Node(new Point(point.x + cellWidth, point.y + cellHeight)),\n                    new Node(new Point(point.x + cellWidth, point.y)),\n                    new Node(new Point(point.x + cellWidth, point.y - cellHeight)),\n                    new Node(new Point(point.x, point.y - cellHeight)),\n                    new Node(new Point(point.x - cellWidth, point.y - cellHeight)),\n                    new Node(new Point(point.x - cellWidth, point.y)),\n                    new Node(new Point(point.x - cellWidth, point.y + cellHeight)),\n                    new Node(new Point(point.x, point.y + cellHeight))\n                    );\n        }\n        \n        public Point getPoint() {\n            return point;\n        }\n        \n        public boolean equals(Node node) {\n            return point.x == node.point.x && point.y == node.point.y;\n        }\n        \n        public String toString() {\n            return point.toString();\n        }\n    }\n```\n\nI also have a GUI set up using Java swing. The code is pretty messy, but what really matters is the pathfinding method and node class together. If you want to try and tweak these 2 parts and verify your results, I will leave the GUI code here. (Note: choose a start tile with the start radio button and clicking on a tile, same with the end tile. Right-click on a tile to make it a wall. Then click the \"Find path\" button. There is no user error handling.)\n```\nimport javax.swing.*;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.event.MouseListener;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.awt.event.MouseEvent;\nimport java.awt.Point;\n\npublic class Test extends JPanel {\n    \n    private final int width = 600, height = 450;\n    private final int cellWidth = 25, cellHeight = 25;\n    \n    Map<Point, Color> tiles = new HashMap<Point, Color>();\n    \n    Node start, end;\n    \n    public Test() {\n        JFrame frame = new JFrame();\n        frame.setSize(800, 450);\n        frame.setLocationRelativeTo(null);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n        \n        ButtonGroup group = new ButtonGroup();\n        \n        JRadioButton startSelect = new JRadioButton(\"Start\");\n        JRadioButton endSelect = new JRadioButton(\"End\");\n        JRadioButton coord = new JRadioButton(\"Coord\");\n        \n        startSelect.setSelected(true);\n        \n        group.add(startSelect);\n        group.add(endSelect);\n        group.add(coord);\n        \n        JButton find = new JButton(\"Find Path\");\n        find.addActionListener(event -> {\n            findPath();\n            drawPath();\n            repaint();\n        });\n        \n        SpringLayout layout = new SpringLayout();\n        this.setLayout(layout);\n        layout.putConstraint(SpringLayout.EAST, startSelect, -130, SpringLayout.EAST, this);\n        layout.putConstraint(SpringLayout.NORTH, startSelect, 30, SpringLayout.NORTH, this);\n        this.add(startSelect);\n        layout.putConstraint(SpringLayout.WEST, endSelect, 10, SpringLayout.EAST, startSelect);\n        layout.putConstraint(SpringLayout.NORTH, endSelect, 0, SpringLayout.NORTH, startSelect);\n        this.add(endSelect);\n        layout.putConstraint(SpringLayout.WEST, coord, 10, SpringLayout.EAST, endSelect);\n        layout.putConstraint(SpringLayout.NORTH, coord, 0, SpringLayout.NORTH, endSelect);\n        this.add(coord);\n        layout.putConstraint(SpringLayout.EAST, find, -60, SpringLayout.EAST, this);\n        layout.putConstraint(SpringLayout.NORTH, find, 120, SpringLayout.NORTH, this);\n        this.add(find);\n        \n        this.addMouseListener(new MouseListener() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                double x = e.getX();\n                double y = e.getY();\n                \n                Node tile = new Node(new Point(cellWidth*((int) x/cellWidth), cellHeight*((int) y/cellHeight)));\n                \n                switch(e.getButton()) {\n                case MouseEvent.BUTTON1:\n                    if(startSelect.isSelected()) {\n                        start = tile;\n                        tiles.put(tile.getPoint(), Color.GRAY);\n                    }\n                    else if(endSelect.isSelected()) {\n                        end = tile;\n                        tiles.put(tile.getPoint(), Color.GRAY);\n                    }\n                    else if(coord.isSelected()) {\n                        System.out.println(tile.getPoint());\n                    }\n                    break;\n                case MouseEvent.BUTTON3:\n                    tiles.put(tile.getPoint(), Color.BLACK);\n                    closed.add(tile);\n                    break;\n                }\n                repaint();\n            }\n            \n            @Override\n            public void mouseClicked(MouseEvent e) {\n\n            }\n            \n            @Override\n            public void mouseReleased(MouseEvent e) {\n\n            }\n\n            @Override\n            public void mouseEntered(MouseEvent e) {\n                \n            }\n\n            @Override\n            public void mouseExited(MouseEvent e) {\n                \n            }\n        });\n        \n        this.setPreferredSize(frame.getSize());\n        frame.add(this);\n        frame.pack();\n        \n        for(int i=0; i<width; i+=cellWidth) {\n            for(int j=0; j<height; j+=cellHeight) {\n                tiles.put(new Point(i, j), Color.WHITE);\n            }\n        }\n        \n        frame.setVisible(true);\n    }\n    \n    public boolean inBounds(Point point) {\n        return (point.x >= 0 && point.y >= 0) && (point.x <= width && point.y <= height);\n    }\n    \n    public boolean contains(List<Node> list, Node node) {\n        for(Node n: list) {\n            if(n.equals(node))\n                return true;\n        }\n        return false;\n    }\n    \n    public boolean contains(Set<Node> list, Node node) {\n        for(Node n: list) {\n            if(n.equals(node))\n                return true;\n        }\n        return false;\n    }\n    \n    Set<Node> open = new HashSet<Node>();\n    Set<Node> closed = new HashSet<Node>();\n    \n    boolean pathExists = true;\n    \n    /*\n     * \n     * \n     * \n     * PATHFINDING METHOD*/\n    public void findPath() {\n        open.add(start);\n\n        while(!open.isEmpty()) {\n            Map<Node, Double> costs = new HashMap<Node, Double>();\n            for(Node node: open) {\n                costs.put(node, node.cost());\n            }\n            Node current = Collections.min(costs.entrySet(), Map.Entry.comparingByValue()).getKey();\n            \n            open.remove(current);\n            closed.add(current);\n            \n            if(current.equals(end)) {\n                end = current;\n                return;\n            }\n            \n            for(Node adjacent: current.getAdjacentNodes()) {\n                if(contains(closed, adjacent) || !inBounds(adjacent.getPoint()))\n                    continue;\n                \n                double newG = current.g + adjacent.getDistanceTo(current);\n                if(newG < adjacent.g || !contains(open, adjacent)) {\n                    adjacent.g = newG;\n                    adjacent.h = adjacent.getDistanceTo(end);\n                    adjacent.parent = current;\n                    \n                    if(!contains(open, adjacent))\n                        open.add(adjacent);\n                }\n            }\n        }\n        pathExists = false;\n    }\n    \n    public void drawPath() {\n        if(pathExists) {\n            Node current = end;\n            \n            while(!current.equals(start)) {\n                tiles.put(current.getParent().getPoint(), Color.GRAY);\n                current = current.getParent();\n            }\n        }\n    }\n    \n    /*\n     * \n     * \n     * \n     * \n     * NODE CLASS*/\n    private class Node {\n        public Point point;\n        public Node parent;\n        \n        public double g, h;\n\n        public Node(Point point) {\n            this.point = point;\n        }\n        \n        public Node getParent() {\n            return parent;\n        }\n        \n        public double cost() {\n            return g + h;\n        }\n        \n        /*public double getH() {\n            return 10*Math.sqrt(Math.pow((end.getPoint().x - point.x)/cellWidth, 2) + Math.pow((end.getPoint().y - point.y)/cellHeight, 2));\n        }*/\n        \n        public double getDistanceTo(Node node) {\n            int x = Math.abs((point.x - node.point.x)/cellWidth);\n            int y = Math.abs((point.y - node.point.y)/cellHeight);\n            \n            if(x > y)\n                return 14*y + 10*(x - y);\n            return 14*x + 10*(y - x);       \n        }\n        \n        /*public double getPositionTo(Node node) {\n            if((point.y == node.point.y && (point.x > node.point.x || point.x < node.point.x)) ||\n                    (point.x == node.point.x && (point.y < node.point.y || point.y > node.point.y)))\n                return 10;\n            else\n                return 14;\n        }*/\n        \n        public List<Node> getAdjacentNodes() {\n            return List.of(\n                    new Node(new Point(point.x + cellWidth, point.y + cellHeight)),\n                    new Node(new Point(point.x + cellWidth, point.y)),\n                    new Node(new Point(point.x + cellWidth, point.y - cellHeight)),\n                    new Node(new Point(point.x, point.y - cellHeight)),\n                    new Node(new Point(point.x - cellWidth, point.y - cellHeight)),\n                    new Node(new Point(point.x - cellWidth, point.y)),\n                    new Node(new Point(point.x - cellWidth, point.y + cellHeight)),\n                    new Node(new Point(point.x, point.y + cellHeight))\n                    );\n        }\n        \n        public Point getPoint() {\n            return point;\n        }\n        \n        public boolean equals(Node node) {\n            return point.x == node.point.x && point.y == node.point.y;\n        }\n        \n        public String toString() {\n            return point.toString();\n        }\n    }\n    \n    public void paintComponent(Graphics tool) {\n        super.paintComponent(tool);\n        \n        for(Map.Entry<Point, Color> tile: tiles.entrySet()) {\n            tool.setColor(tile.getValue());\n            tool.fillRect(tile.getKey().x, tile.getKey().y, cellWidth, cellHeight);\n        }\n        tool.setColor(Color.BLACK);\n        for(int i=0; i<width; i+=cellWidth) {\n            tool.drawLine(i, 0, i, height);\n        }\n        for(int i=0; i<height; i+=cellHeight) {\n            tool.drawLine(0, i, width, i);\n        }\n        \n        if(start != null) {\n            tool.setColor(Color.GREEN);\n            tool.fillOval(start.point.x + 8, start.point.y + 8, 10, 10);\n        }\n        if(end != null) {\n            tool.setColor(Color.RED);\n            tool.fillOval(end.point.x + 8, end.point.y + 8, 10, 10);\n        }\n    }\n    \n    public static void main(String[] args) {\n        new Test();\n    }\n}\n```\n\nEDIT I wrote my own contains method for the open and closed sets, just to make sure I wasn't messing up something there:\n```\npublic boolean contains(Set<Node> list, Node node) {\n        for(Node n: list) {\n            if(n.equals(node))\n                return true;\n        }\n        return false;\n    }\n```\n\n    ", "Answer": "\r\nThanks for @thatotherguy for the solution\nIf it helps anyone in the future, the problem was that whenever I was getting the adjacent nodes for the current node, I was creating brand new nodes all with g values of 0.\nTo correct this, I first checked if the adjacent nodes existed in the open list. If so, get that node instead of creating a new node. If the node does not exist in the open set, create a new node but with a correct g value.\n```\npublic List<Node> getAdjacentNodes() {\n            List<Node> nodes = new LinkedList<Node>();\n            nodes.add(new Node(new Point(point.x + cellWidth, point.y + cellHeight)));\n            nodes.add(new Node(new Point(point.x + cellWidth, point.y)));\n            nodes.add(new Node(new Point(point.x + cellWidth, point.y - cellHeight)));\n            nodes.add(new Node(new Point(point.x, point.y - cellHeight)));\n            nodes.add(new Node(new Point(point.x - cellWidth, point.y - cellHeight)));\n            nodes.add(new Node(new Point(point.x - cellWidth, point.y)));\n            nodes.add(new Node(new Point(point.x - cellWidth, point.y + cellHeight)));\n            nodes.add(new Node(new Point(point.x, point.y + cellHeight)));\n            \n            List<Node> correctNodes = new ArrayList<Node>();\n            List<Node> remove = new ArrayList<Node>();\n            \n            for(Node node: nodes) {\n                for(Node openNode: open) {\n                    if(node.equals(openNode)) {\n                        correctNodes.add(openNode);\n                        remove.add(node);\n                        break;\n                    }\n                }\n            }\n            \n            nodes.removeAll(remove);\n            for(Node node: nodes) {\n                node.g = this.g + getDistanceTo(node);\n                correctNodes.add(node);\n            }\n            return correctNodes;\n        }\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How do I optimize my code to make my greedy algorithm better?\r\n                \r\nAn Egyptian fraction was written as a sum of unit fractions, meaning the numerator is always 1; further, no two denominators can be the same. As easy way to create an Egyptian fraction is to repeatedly take the largest unit fraction that will fit, subtract to find what remains, and repeat until the remainder is a unit fraction, for example:\n\n\n7 divided by 15 is less than 1/2 but more than 1/3, so the first unit \nfraction is 1/3 and the first remainder is 2/15.\nThen 2/15 is less than 1/7 but more than 1/8, so the second unit fraction \nis 1/8 and the second remainder is 1/120. \nThat’s in unit form, so we are finished: \n7 ÷ 15 = 1/3 + 1/8 + 1/120\n\n\nI'm trying to solve the egyptian fraction problem where I'm using the below greedy method:\n\n```\n   def egyptianFraction(nr, dr): \n\n    print(\"The Egyptian Fraction \" +\n          \"Representation of {0}/{1} is\". \n                format(nr, dr), end=\"\\n\") \n\n    # empty list ef to store \n    # denominator \n    ef = [] \n\n    # while loop runs until  \n    # fraction becomes 0 i.e, \n    # numerator becomes 0 \n    while nr != 0: \n\n        # taking ceiling \n        x = math.ceil(dr / nr) \n\n        # storing value in ef list \n        ef.append(x) \n\n        # updating new nr and dr \n        nr = x * nr - dr \n        dr = dr * x \n\n    # printing the values \n    for i in range(len(ef)): \n        if i != len(ef) - 1: \n            print(\" 1/{0} +\" .  \n                    format(ef[i]), end = \" \") \n        else: \n            print(\" 1/{0}\" . \n                    format(ef[i]), end = \" \") \n\n# calling the function \negyptianFraction(6, 14) \n```\n\n\nI need to build an algorithm that guarantees a maximum number of terms or a minimum largest denominator; for instance, \n\n```\n5 ÷ 121 = 1/25 + 1/757 + 1/763309 + 1/873960180913 + \n1/1527612795642093418846225\n\nbut a simpler rendering of the same number is \n1/33 + 1/121 + 1/363.\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Python translation from C for CS50 greedy algorithm\r\n                \r\nSo, we all know that CS50 is a big class and lots to learn. Here's another issue I'm having with Python now. The syntax took a little while to get right with all the indentation changes but the logic seems to be very similar. The code works up until you put in .99 or even 1.20. BUT, and it's a big but, I can't debug in the cloud9 ide with Python.....? Idk. I just started Python this week so I'm sure it's a language oriented issue and I just need to figure that out. Hope you can help me. Thanks.\n\n```\n#Greedy algorithm converted to python\nimport sys\nimport os\n\nc = float(input(\"How much change is owed? \"))\ni = 0\nwhile (c<0 or c==0):\n    print(\"Please input a positive amount...\")\n\nwhile (c>.24):\n\n    i  += 1\n    c=(c-.25)\n\nwhile (c>.1 or c==.1):\n\n    i += 1\n    c=(c-.1)\n\n\nwhile (c>.05 or c==.05):\n\n    i += 1\n    c=(c-.05)\n\n\nwhile (c>.01 or c==.01):\n\n    i += 1\n    c=(c-.01)\n\nprint(\"%i coin(s) needed to make the change.\" % i)\n```\n\n    ", "Answer": "\r\nYou're likely running into rounding issues with ```\nfloat```\n. After converting it to cents and using integers, it works:\n\n```\n#Greedy algorithm converted to python\nimport sys\nimport os\n\nc = float(input(\"How much change is owed? \"))\ni = 0\nwhile (c<0 or c==0):\n    print(\"Please input a positive amount...\")\nc = round(c * 100)\nwhile (c>=25):\n\n    i  += 1\n    c=(c-25)\n\nwhile (c>=10):\n\n    i += 1\n    c=(c-10)\n\n\nwhile (c>=5):\n\n    i += 1\n    c=(c-5)\n\n\nwhile (c>=1):\n\n    i += 1\n    c=(c-1)\n\nprint(\"%i coin(s) needed to make the change.\" % i)\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm to find potential weighted activities in order?\r\n                \r\nFor example, let's say there's a list of activities {a, b, c, d, e, f, g}\n\n\na & b are worth 9 points each. \nc is worth 8 points. \nd & e are worth 6 points each. \nf is worth 5 points.\ng is worth 4 points.\n\n\nThe list of activities is already sorted by points descending. \n\nI want to find the highest points combination of three activities (let's call this combination X) that fulfills certain requirements (such that F(X) = true).\n\nF(X) accepts only a combination of three activities, and cannot be modified.\n\nHow can I generate X without first having to calculate all possible combinations?\nHow can I iterate through all the possible combinations in decreasing total points?\n\nI want to be able to find the highest point combination, test it. If it fails, generate second-highest point combination, etc.\n\nThe example list is only a few items. However, the actual list can get extremely large that and it would be impractical to generate all combinations. \n\nHow should I do this?\n    ", "Answer": "\r\nThe following idea only solves an easier version of the problem, but maybe it can be extended to a more powerful solution.\n\nLet [a(1)..a(N)] be the input array. \nWhat I suggest here is a way to enumerate the top N^(1/3) triplets, out of the C(N,3)~N^3 ones in the complete enumeration. I know this is modest, but it guarantees O(N) time and space.\n\n\ns = a(1) + a(2) + a(N^(1/3))\nT = All triplets in [a(1),a(2), .. ,a(N^(1/3))] (takes O(N) time and space)\nSort T in descending triplet sum order (Time complexity: O(N^(1/3) * log N) = O(N) )\nIterate over T and return every triplet r while sum(r) >= s\n\n\nExplanation:\n\nIn (1) we compute the highest score possible for a triplet that doesn't involve only items from T = [a(1)..a(N^(1/3))]. In other words, T already contains all triplets of score > s. Therefore we generate all triplets in T, sort them, and return only the ones we are sure about (i.e. the ones with score>=s). How many such triplets will be returned? well, this depends on the array values, but we can guarantee at least N^(1/3) - 2 triplets, since all triplets [a(1)+a(2)+a(i)] for ```\n2<i<=N^(1/3)```\n have a sum >=s. In practice the number of \"good\" triplets may be much higher, but again, this depends on the array numbers distribution. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy conditional algorithm\r\n                \r\nI have a list of k artistes mapped to their respective music videos that they have starred in. This is represented in a multidimensional array:\n\n```\nmusicvid_arr = \n[[\"MUSICVID 1\", 2014, [\"ARTISTE 1\", \"ARTISTE 2\", \"ARTISTE 3\"]], \n[\"MUSICVID 2\", 2014, [\"ARTISTE 4\", \"ARTISTE 1\", \"ARTISTE 9\", \"ARTISTE 10\"]], \n[\"MUSICVID 3\", 1935, [\"ARTISTE 2\", \"ARTISTE 10\", \"ARTISTE 6\"]], \n[\"MUSICVID 4\", 2010, [\"ARTISTE 1\", \"ARTISTE 2\", \"ARTISTE 3\"]], \n[\"MUSICVID 5\", 2009, [\"ARTISTE 4\", \"ARTISTE 1\", \"ARTISTE 9\", \"ARTISTE 2\", \"ARTISTE 6\", \"ARTISTE 5\"]], \n[\"MUSICVID 6\", 2014, [\"ARTISTE 18\", \"ARTISTE 10\", \"ARTISTE 6\", \"ARTISTE 2\"]], \n[\"MUSICVID 7\", 2014, [\"ARTISTE 9\", \"ARTISTE 2\", \"ARTISTE 3\", \"ARTISTE 0\", \"ARTISTE 9\"]], \n[\"MUSICVID 8\", 2000, [\"ARTISTE 8\", \"ARTISTE 3\", \"ARTISTE 9\", \"ARTISTE 11\", \"ARTISTE 2\", \"ARTISTE 1\"]],\n[\"MUSICVID 9\", 2014, [\"ARTISTE 21\", \"ARTISTE 0\", \"ARTISTE 6\"]], \n[\"MUSICVID 10\", 2014, [\"ARTISTE 12\", \"ARTISTE 2\", \"ARTISTE 3\"]], \n[\"MUSICVID 11\", 2013, [\"ARTISTE 14\", \"ARTISTE 1\", \"ARTISTE 9\", \"ARTISTE 12\"]], \n[\"MUSICVID 12\", 2014, [\"ARTISTE 2\"]]]\n```\n\n\nI want to create a method ```\nget_artistes```\n that takes the parameters: ```\nk```\n , ```\nr```\n, and ```\nmusicvid_arr```\n:\n\n```\ndef get_artistes(k, r, musicvid_arr)\n  # the code here\nend\n```\n\n\nwhere\n\n\n```\nk```\n: the number of artistes to return\n```\nr```\n: the least number of artistes found in the return array of ```\nk```\n artistes that must appear in each music video for the music video to be counted/valid\n\n\nThis method should return a list of artistes. If k = 3:\n\n```\n[\"ARTISTE 1\", \"ARTISTE 2\", \"ARTISTE 9\"]\n```\n\n\nThis image gives a better understanding of how ```\nk```\n and ```\nr```\n affect the most number. With reference to the image above,\n\n```\n# for r = 1 , it would have 11 valid music videos.\n# for r = 2 , it would have 6 valid music videos.\n# for r = 3 , it would have 3 valid music videos.\n```\n\n\nNo matter what ```\nr```\n and ```\nk```\n we pass to this method, we want an array of artistes that have the most number of valid music videos.\n\nWhat would be an effective and efficient approach on tackling this problem?\n\nI attempted to do this via the following algorithm. I do not think that it is the most effective. With big datasets, it takes very long to run.\n\n```\ndef get_artistes(k, r, musicvid_arr)\n    musicvid_arr=musicvid_arr.select{|t| t[2].size>=r} \n    artiste_arr = musicvid_arr.map.reduce({}){|a,vs|vs[2].each{|v|(a[v]||= [])<< vs[0]};a}.to_a.sort_by{|x| -x[1].count}\n    output = []\n    for i in 0...k\n        output << artiste_arr[i]\n    end\n    return output\nend\n```\n\n    ", "Answer": "\r\nOften Jr. Programmers doing something new see the problem as complex and feel the solution should have equal complexity. \n\nRegardless of the complexity of any problem when writing code, the solution, should be clear and readable. If you can't speak your code aloud it's too complicated.\n\nYou should create a class ex: ParseArtists with multiple methods that clearly state each step in the process of parsing artists. This class should have the single responsibility of parsing artists with descriptive variable names, and small obvious methods.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is he being greedy?\r\n                \r\nI am solving a question from LeetCode.com:\n\n\n  Given an array of non-negative integers, you are initially positioned at the first index of the array.\n  Each element in the array represents your maximum jump length at that position.\n  Determine if you are able to reach the last index.\n  For example:\n  A = [2,3,1,1,4], return true.\n  A = [3,2,1,0,4], return false.\n\n\nOne of the most voted solutions (here) says that the following is using a greedy approach:\n\n```\nbool canJump(int A[], int n) {\n    int last=n-1,i,j;\n    for(i=n-2;i>=0;i--){\n        if(i+A[i]>=last)last=i;\n    }\n    return last<=0;\n}\n```\n\n\nI have two questions:\n\n\nWhat is the intuition behind using a greedy algorithm for this?\nHow is the above solution a greedy algorithm?\n\n\nI thought this to be solvable by Dynamic Programming.  I understand that questions solvable by DP can be solved by greedy method, but what was the intuition behind this particular one that made it more sense to solve by the greedy approach?  \n\nThis SO question highlights this difference to some extent.  I understand this might be a bit more, but if possible, could some one please answer this question in this context?  I would highly appreciate that.\n\nThank you.\n\nEdit:  I think one of the reasons of my confusion is over the input ```\n[3,3,1,0,4]```\n.  As per the greedy paradigm, when ```\ni=0```\n wouldn't we take a jump of size ```\n3```\n (```\nA[0]```\n) in order to greedily reach the output?  But doing this would in fact be incorrect.\n    ", "Answer": "\r\nAccording to Wikipedia:\n\n\n  A greedy algorithm is an algorithmic paradigm that follows the problem solving heuristic of making the locally optimal choice at each stage with the hope of finding a global optimum.\n\n\nHere, I want to draw your attention to the key phrase, locally optimal choice at each stage which makes the algorithm paradigm greedy.\n\n\n\n```\nQ1. What is the intuition behind using a greedy algorithm for this?\n```\n\n\nSince in this question, we only care about whether it is possible to reach the last index of the array, we can use a greedy algorithm. A greedy algorithm will select the optimal choice (take the maximum jump) at every step and check at the end whether the maximum index can reach the end.\n\nSay, if we need to find out the jump size at each index to reach the end or need to optimize the number of jumps to reach the end, then the direct use of greedy algorithm won't serve our purpose.\n\n```\nQ2. How is the above solution a greedy algorithm?\n```\n\n\nThe ```\nif```\n condition in the above code - ```\nif(i+A[i]>=last)last=i;```\n makes the algorithm greedy because we take the maximum jump if it is possible (```\ni+A[i]>=last```\n).\n\nThe analysis provided here may help you.\n\n\n\nEdit\n\nLet's talk about the input you mentioned - ```\n[3,3,1,0,4]```\n.\n\n\nWhen ```\ni=0```\n, algorithm checks what is the maximum index that we can reach from ```\ni=0```\n. \nThen we will move to the next index and check what is the max index we can reach from ```\ni=1```\n. Since we moved to ```\ni=1```\n, it is guranteed that we can come to index 1 from index 0 (doesn't matter what is the jump size).\n\n\nPlease note, in this problem, we don't care whether we should take a jump of size 3 at ```\ni=0```\n though we know this will not help us to reach the end. What we care about is whether we can reach the end or beyond that end index by taking jumps.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is an efficient way of back-tracking in greedy best search algorithm? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI coded a greedy search algorithm , but it goes to an infinite loop as its not able to back - track , and reach the final state . How can a back-tracking be done in C++ in the most optimal way ! \n\n```\n    while(!f1.eof() )\n        {\n            f1>>temp1>>time;\n\n            A[i].loc_name=temp1;\n            A[i].time_taken=time;\n\n                initial_start=1; // make initial to 1 and final to i\n\n                final_finish=i;\n\n        i=i+1;\n        }\n\n    while(!f2.eof())\n        {\n            f2>>temp1>>temp2>>time;\n            int ci=0;\n            while( ci != i )\n                {\n\n                    if (temp1 == A[ci].loc_name)\n                        {\n                            flag1=ci;\n                            tf1=time;\n\n                        }\n                    if (temp2 == A[ci].loc_name)\n                        {\n                            flag2=ci;\n                            tf2=time;\n                        }\n                    ci=ci+1;\n                }\n\n\n\n            A[flag1].loc.push_back(flag2);\n            A[flag1].time_live.push_back(time);\n\n            A[flag2].loc.push_back(flag1);\n            A[flag2].time_live.push_back(time);         \n\n        }\n\n\n//Greedy Search algorithm   \n                int min,min_time,finish,start,l;\n                vector<int>path;\n                min_time=99999;\n                l=0;\n                finish=1;\n                start=0;\n//Choosing the node with the minimum value \n            while(finish != final_finish)\n                {\n\n                for(int u=0;u<A[start].loc.size();u++)\n                    {\n                        l=A[start].loc[u];\n                        if(A[l].time_taken < min_time)\n                            {   \n                                min_time=A[l].time_taken;\n                                finish = l;\n\n                            }\n\n                    }\n                min=min+min_time;\n                path.push_back(start);\n                    start=finish;   \n//Printing the path found by Greedy search into an output file\n            f3<<A[l].loc_name<<min<<endl;\n                }\n```\n\n    ", "Answer": "\r\n```\nint algo(int value, int stopValue, list<int> & answer)\n{\n    if(value == stopValue)\n    {\n        return 0;\n    }\n    if(value > stopValue)\n    {\n        return 1;\n    }\n\n    if(algo(value+2, stopValue) == 0)\n    {\n        answer.push_back(2);\n        return 0;\n    }\n    if(algo(value+1, stopValue) == 0)\n    {\n        answer.push_back(1);\n        return 0;\n    }\n    return 1;\n}\n```\n\n\nHere's a trivial greedy recursive algorithm that finds the number of 2s and 1s a number is composed of. Greedy algorithms are only good for some problems and produce suboptimal results in most.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm - minimize number of operations to complete task\r\n                \r\nI am trying to solve a programming challenge question. For convenience, I have summarized it below:\n\nGiven an array, A, of positive integers. In one operation, we can choose one of the elements in the array, A[i] and reduce it by a fixed amount X. At the same time, the rest of the elements will be reduced by a fixed amount Y. We need to find the minimum number of operations to reduce all elements to a non-positive number (i.e. 0 and below).\nConstraints:\n1 <= |A| <= 1e5\n1 <= A[i] <= 1e9\n1 <= Y < X <= 1e9\nTime limit: 1 second\nSource\n\nFor example, let X = 10, Y = 4 and A = {20, 20}.\nThe optimal approach for this example is:\nOperation 1: Choose item 0.\nA = {10, 16}\nOperation 2: Choose item 0.\nA = {0, 12}\nOperation 3: Choose item 1.\nA = {-4, 2}\nOperation 4: Choose item 1.\nA = {-8, -8}\nHence, the answer is 4.\n\nMy approach:\nKeep choosing the current maximum element in the array and reduce it by X (and reduce the rest of the elements by Y). Clearly, this approach would exceed the time limit due to the possibly small values of X and Y (i.e. the number of iterations that my algorithm will perform is lower bounded by max(A[i]) / 2 ).\nCould someone please advise me on a better solution?\n    ", "Answer": "\r\nThis problem could be solved by using binary search\n\nFirst, we want to check if within ```\na```\n operations, whether we can make all elements become <= 0; we could check for each element, the minimum number of operations, ```\nb```\n, such that if we subtract ```\nx```\n for ```\nb```\n operations and subtract ```\ny```\n for the remaining ```\na-b```\n operations, then the resultant value of the element will become <= 0. Sum all of those numbers together, and if the ```\nsum <= a```\n, which means we could use ```\na```\n operations. \n\nThen, we could apply binary search to search for a valid ```\na```\n.\n\n```\nint st = 0;\nint ed = max element / y + 1;\nint result = ed;\nwhile(start <= end){\n    int mid = (st + ed)/2;\n    int sum = 0;\n    for(int i : A){\n        sum += minTimesMinusX(i, mid);\n    }\n    if(sum <= mid){\n        result = mid;\n        ed = mid - 1;\n    }else{\n        st = mid + 1;\n    }\n}\nreturn result;\n```\n\n\nTime complexity ```\nO(n log max(A))```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How could i get O(m+n) using greedy?\r\n                \r\nHow could I design an algorithm greedy ```\nO(m+n)```\n for this case\nGiven two arrangements ```\nL1```\n and ```\nL2```\n, where ```\n| L1 | = n```\n and ```\n| L2 | = m```\n.\n```\nL2```\n is said to be a subsequence of ```\nL1```\n if elements can be removed from ```\nL1```\n to get ```\nL2```\n. This means that there are ```\nm```\n indexes ```\nik∈ [0..n]```\n such that ```\nL1 [ik] = L2 [j]```\n for each ```\nj∈ [0..m]```\n. Design a greedy algorithm in ```\nO (n + m)```\n that detects if ```\nL2```\n is a subsequence of ```\nL1```\n and outputs the ```\nik```\n indices in ```\nL1```\n in the case that ```\nL2```\n is a subsequence of ```\nL1```\n.\nExamples:\n```\nInput L1 = [1 2 3 4 5 6 7 8 9 10] L2 = [3 5 7 9] Output ik = [2 4 6 8]\n\nInput L1 = [2 1 4 3 6 5 7 8 9 10] L2 = [1 6 5 10] Output ik = [1 4 5 9]\n\nInput L1 = [1 2 3 4 5 6 7 8 9 10] L2 = [1 5 9 12] Output L2 is not subsequence of L1\n```\n\nI have been doing the classic code for this using this\n```\nbool isSubsequence(string str1, string str2) {\n    int i=0;\n    int j=0;\n\nwhile (j<str1.length() && i<str2.length()){\n    if(str1[j]==str2[i]){\n        cout<<i<<\" \";\n        j++;\n    }\n\n    i++;\n} \n    \nreturn j==str1.length(); \n}\n```\n\nBut i dont know how to get ```\nO(m+n)```\n using greedy.\nThanks\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy optimization in R\r\n                \r\nI am trying to replicate Caruana et al.'s method for Ensemble selection from libraries of models (pdf).  At the core of the method is a greedy algorithm for adding models to the ensemble (models can be added more than once).  I've written an implementation for this greedy optimization algorithm, but it is very slow:\n\n```\nlibrary(compiler)\nset.seed(42)\nX <- matrix(runif(100000*10), ncol=10)\nY <- rnorm(100000)\n\ngreedOpt <- cmpfun(function(X, Y, iter=100){\n  weights <- rep(0, ncol(X))\n\n  while(sum(weights) < iter) {\n\n    errors <- sapply(1:ncol(X), function(y){\n      newweights <- weights\n      newweights[y] <- newweights[y] + 1  \n      pred <- X %*% (newweights)/sum(newweights)\n      error <- Y - pred\n      sqrt(mean(error^2))\n    })\n\n    update <- which.min(errors)\n    weights[update] <- weights[update]+1\n  }\n  return(weights/sum(weights))\n})\n\nsystem.time(a <- greedOpt(X,Y))\n```\n\n\nI know R doesn't do loops well, but I can't think of any way to do this type of stepwise search without a loop.\n\nAny suggestions for improving this function?\n    ", "Answer": "\r\nHere is an R implementation that is 30% faster than yours. Not as fast as your Rcpp version but maybe it will give you ideas that combined with Rcpp will speed things further. The two main improvements are:\n\n\nthe ```\nsapply```\n loop has been replaced by a matrix formulation\nthe matrix multiplication has been replaced by a recursion \n\n\n\n\n```\ngreedOpt <- cmpfun(function(X, Y, iter = 100L){\n\n  N           <- ncol(X)\n  weights     <- rep(0L, N)\n  pred        <- 0 * X\n  sum.weights <- 0L\n\n  while(sum.weights < iter) {\n\n      sum.weights   <- sum.weights + 1L\n      pred          <- (pred + X) * (1L / sum.weights)\n      errors        <- sqrt(colSums((pred - Y) ^ 2L))\n      best          <- which.min(errors)\n      weights[best] <- weights[best] + 1L\n      pred          <- pred[, best] * sum.weights\n  }\n  return(weights / sum.weights)\n})\n```\n\n\nAlso, I maintain you should try upgrading to the atlas library. You might see significant improvements.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy colouring algorithm on graph in adjacency list representation\r\n                \r\nSuppose you have been given a simple undirected graph and the graph has a max degree of d. You are given d + 1 colors, represented by numbers starting from 0 to d and you want to return a valid placement of colors such that no two adjacent vertices share the same color. And as the title suggests, the graph is given in adjacency list representation. The algorithm should run in O(V+E) time.\n\nI think the correct way to approach this is by using a greedy coloring algorithm. However, this may sound stupid but I am stuck on the part where I try to find the first available color that hasn't been used by its neighbors for each vertex. I don't really know how I can do it so that it runs in O(number of neighbors) time for each vertex that helps to fit under time complexity requirements.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy colouring algorithm on graph in adjacency list representation\r\n                \r\nSuppose you have been given a simple undirected graph and the graph has a max degree of d. You are given d + 1 colors, represented by numbers starting from 0 to d and you want to return a valid placement of colors such that no two adjacent vertices share the same color. And as the title suggests, the graph is given in adjacency list representation. The algorithm should run in O(V+E) time.\n\nI think the correct way to approach this is by using a greedy coloring algorithm. However, this may sound stupid but I am stuck on the part where I try to find the first available color that hasn't been used by its neighbors for each vertex. I don't really know how I can do it so that it runs in O(number of neighbors) time for each vertex that helps to fit under time complexity requirements.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Finding the minimum waste using Greedy gives incorrect output\r\n                \r\nI am trying to solve the following problem using Greedy algorithm but I am not getting the correct output. \n\nHere is the problem: \n\n\nHere is a sample input: \n20 7\n10 4 6 7 6 9 4 \n\nHere is the model output: \n217\n\nMy output is: \n343\nMy algorithm with as a snippet of a java code is here: \n\n```\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Elevate {\n\n\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner cin = new Scanner(new FileReader(\"elevate.in\"));\n        int N, M, Weights, waste;\n        M = cin.nextInt();\n        N = cin.nextInt(); \n        ArrayList<Integer> wieghts = new ArrayList<>();\n        ArrayList<Integer> WT = new ArrayList<>();\n        int numCase =1; \n        while(N != 0 && M != 0){\n            Weights = M;\n            waste = 0; \n            for (int i = 0; i < N; i++) {\n                wieghts.add(cin.nextInt());\n            }\n\n\n            for (int i = 0; i < N; ) {\n                if(wieghts.get(i) <= Weights){\n                   Weights -= wieghts.get(i); \n                   i++;\n                }\n                else{\n                    //we cannot fit more people \n                    //Start again \n\n                    WT.add(Weights);\n                    Weights = M;\n                }\n            }\n            for (int i = 0; i < WT.size(); i++) {\n                waste+= (WT.get(i) * WT.get(i) * WT.get(i));\n            }\n\n            System.out.println(numCase +\": \"+waste);\n            M = cin.nextInt();\n            N = cin.nextInt(); \n            wieghts.clear();\n            WT.clear();\n            numCase++;\n        }\n\n    }\n\n}\n```\n\n\nIs Greedy a bad choice? the passengers has to travel in the same order of arrival, so I'm kinda doing a max fit .. \n\nEdit\nGreedy indeed is bad choice, DP should solve the problem. \n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Finding minimum indepedent dominating set using a greedy algorithm\r\n                \r\nI developed an algorithm that finds the minimum independent dominating set of a graph based on a distance constraint. (I used Python and NetworkX to generate graphs and get the pairs)\n\nThe algorithm uses a brute force approach:\n\n\nFind all possible pairs of edges\nCheck which nodes satisfy the distance constraint\nFind all possible independent dominating sets\nCompare the independent dominating sets found and find the minimum dominating set\n\n\nFor small number of nodes it wouldnt make a difference but for large numbers the program is really slow.\n\nIs there any way that I could make it run faster using a different approach?\n\nThanks\n    ", "Answer": "\r\nUnfortunately, the problem of finding the minimum independent dominating set is NP-complete. Hence, any known algorithm which is sound and complete will be inefficient.\n\nA possible approach is to use an incomplete algorithm (aka local search).\nFor example, the following algorithm is known to have a factor (1 + log|V|) approximation:\n 1. Choose a node with the maximal number of neighbors and add it to the dominating set.\n 2. Remove the node and all of it's neighbors from the graph.\n 3. Repeat until there are no more nodes in the graph.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Salesperson greedy algorithm produce strange data in my data\r\n                \r\nI have a problem with the following definition\nI have a course with some lessons\n\nWhat Java Is and How It Works\nHello World Program\nUsing\nVariables\nStrings: Working With Text\nWhile Loops\nFor Loops\n\"If\"\nGetting User Input\nDo ... While\nSwitch\nArrays\nArrays of Strings\nMulti-Dimensional Arrays\nMethods\n15.Method Parameters\nStatic\nFinal\nString Builder and String Formatting\n\nI have build a network with this course with matrix as following :\nNode 1: first lesson\nNode 2: second lesson\nFrom Node 1 to Node 2 the edge will be 1 and to all other nodes will be 0\nFrom Node 2 to Node 3 and from Node 2 to Node 4 the edge will be one and and to all other nodes it will be 0 because student can move from node 2 to 3 or 4\nAnd so on with the same logic.\nI got the following matrix:\n```\nD = [[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n     [0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n     [0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],\n     [0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],\n     [0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],\n     [0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0],\n     [0,0,0,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1],\n     [0,0,1,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1],\n     [0,0,0,0,1,1,1,0,0,0,1,0,0,1,0,0,0,0],\n     [0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0],\n     [0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0],\n     [0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,0,0,0],\n     [0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,0,0,0],\n     [0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,1,0],\n     [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],\n     [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0],\n     [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],\n     [0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0]]  \n```\n\nand run the algorithm of salesperson the result is : [1, 3, 5, 15, 7, 10, 8, 9, 17, 18, 2, 4, 6, 16, 13, 11, 12, 14, 1]\nI have tried to add -1 and to flip 0 with 1 and 1 with 0 and tried different matrix and still the data not near what the student should follow\n    ", "Answer": "\r\nYour matrix only indicate the presence (or absence) of edges.\nThe TSP algorithm is made to work with weigthed edges. In your case all edges have the same wight, so you are not searching a shortest path but just any Hamiltonian path.\nPlus, with 0 on edges that does not exist, it seems your algorithm belive it's free to use them (i.e. no cost to go from chapter 1 to chapter 3 instead of imposible). You don't want 0's and 1's in your matrix, but weigths (and infinite or really large weights for edges that does not exists).\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for cellphone base station problem, Algortihm Manual\r\n                \r\nI have attempted the question:\nLet’s consider a long, quiet country road with houses scattered very\nsparsely along it. (We can picture the road as a long line segment, with\nan eastern endpoint and a western endpoint.) Further, let’s suppose that\ndespite the bucolic setting, the residents of all these houses are avid cell\nphone users. You want to place cell phone base stations at certain points\nalong the road, so that every house is within four miles of one of the base\nstations.\nGive an efficient algorithm that achieves this goal, using as few base\nstations as possible.\nMy solution:\nFor each house on the line create a job interval entry with start S[h] = house distance from east - 4, and finish F[h] = house distance from east + 4\nThen run interval scheduling algorithm (but without preprocessing sort).\nThe number of base towers will be the number of jobs returned by interval scheduling.\nThe idea was that we'll need only 1 tower per non overlapping job (house) as all the other jobs (houses) are covered by the job with which they overlapped with.\nIs this idea right?\nAlso, would the run time of this algorithm be O(n) where n is the number of houses\nBtw if there's anything wrong with my question please tell me :) This is my first post so not sure exactly how to structure it.\nThank you for your help\n    ", "Answer": "\r\nFirst, Sort the houses according to their locations in O(n \\log n).\nNext, select the locations of the base towers according to the locations above.\nAssuming the location of the first house is \"p\" place the first base tower at location \"p + 4\" miles, and remove all the houses with cell phone service (houses 4 miles within that tower) from the list.\nRepeat the procedure till all houses have been covered.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What kind of algorithm paradigm/algorithm design paradigm is A* (A star) pathfinding algorithm?\r\n                \r\nI'm not sure about what kind of design paradigm is A* (A star) pathfinding algorithm. According of the topics of the book \"Introduction to the Design & Analysis of Algorithms\" by Anany Levitin, I think the design paradigm is a greedy technique, because this algorithm is a combination of Dijktra's algorithm and greedy best first which are greedy techniques. But I'm not sure if that is a good reasoning.\n\nEdit: According Emma comment, she gave me a link of Wikipedia where it says \" Dijkstra and A* are special cases of dynamic programming. A* itself is a special case of a generalization of branch and bound.\" link.\nBut in this other Wikipedia link says \"Dijkstra's algorithm and the related A* search algorithm are verifiably optimal greedy algorithms for graph search and shortest path finding.\"\n    ", "Answer": "\r\nYou have a good question!\nGreedy is setteld!!!\nI guess it would depend and I agree with \"that's a bit of apples and oranges.\" in the question's comment.\nThe answer to your specific question might be here or here.\nIt is considered Greedy or Dynamic Programming (DP), according to some wikipedia pages.\nHowever, templatetypedef also has a good point in the comment: \"I would have pegged it as greedy given that it’s making a locally optimal decision at each point.\"\n\nGreedy\n\nDijkstra's algorithm and the related A* search algorithm are\nverifiably optimal greedy algorithms for graph search and shortest\npath finding.\n\n\nDynamic Programming\n\nWhat sets A* apart from a greedy best-first search algorithm is that\nit takes the cost/distance already traveled, g(n), into account.\nSome common variants of Dijkstra's algorithm can be viewed as a\nspecial case of A* where the heuristic h(n) = 0 for all nodes; in\nturn, both Dijkstra and A* are special cases of dynamic programming.\nA* itself is a special case of a generalization of branch and bound.\n\nReference\n\nA* search algorithm\n\nAlgorithmic paradigm\n\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithm - Where I need to put those object?\r\n                \r\nI'm doing a little personal project and I need your help.\nWhat I'm doing is that I've a list of Object (I call it bloc) which has a random size (width and height) and a also a random number. I have it into an ArrayList.\nWhat I'm trying to do now is that I want to put those blocks into a ribbon : left is my ribbon and right are my blocs\nMy window\nWhat I need to do is making the most optimal choice and to place all the bloc in the ribbonso as to minimize the height.\nThe problem is that :\nThe problem\nWhen I want to place the A Bloc, I check 1st if there is some place at the number 1, obviously there is no place, then where should I check ? Number 2 ? Number 3 ?\nCordially\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to trim the returned nodes of Greedy Best First Search and A* Algorithms?\r\n                \r\nI am trying to implement GBFS and A* with a grid (2D array). I think before we go any further...do both of the algorithms remember previous locations and if so, does this therefore mean that it will jump to that location if the heuristics are better i.e. would it jump to a node of a sibling's child if the sibling's children has better heuristics than the current node's children? Better explanation would be for example, if I had a 8x8 grid and I was on coordinates 7,7, and I check the cells next to it but in the PriorityQueue, we have a coordinate 3,5 which has better heuristics than the cells next to 7,7...would we jump to 3,5?\n\nif the answer is yes, then my problem is how would I create the correct path from the returned nodes that have been removed from the PriorityQueue given that we can jump from one location to another? I.e. how do we trim down the nodes to create the actual path?\n    ", "Answer": "\r\n\n  Do both of the algorithms remember previous locations and if so, does this therefore mean that it will jump to that location if the heuristics are better i.e. would it jump to a node of a sibling's child if the sibling's children has better heuristics than the current node's children?\n\n\nYes to both.\n\nWhen you insert nodes into the priority queue you should keep track of their \"parent\" node, the node that preceded them. For example, if you're at 7,7 and then add 8,7 to the queue you should set 8,7's parent to 7,7.\n\nThis way you can backtrack from any node back to the start node by following the chain of parents.\n\n\n  If I had a 8x8 grid and I was on coordinates 7,7, and I check the cells next to it but in the PriorityQueue, we have a coordinate 3,5 which has better heuristics than the cells next to 7,7...would we jump to 3,5?\n\n\nYes. Considering 3,5 after 7,7 doesn't mean the player is \"jumping\" to 3,5. It means he's now considering an alternate path since the path that goes through 3,5 seems more promising than the one through 7,7, at least momentarily.\n\n\n  How would I create the correct path from the returned nodes that have been removed from the PriorityQueue?\n\n\nEventually you will reach the goal node. Let's say the goal node is 6,6 and you got there from 6,5. How do you reconstruct the path that got you there?\n\n\nLook at 6,5's parent.\nLook at 6,5's parent's parent.\nLook at 6,5's parent's parent's parent.\netc.\n\n\nThis will eventually get you back to the start node, and that is your path (in reverse).\n\n\n\nTake this example image based on your previous question. Each arrow represents one of the parent pointers you'd have. I changed colors each time the search \"jumped\" from one path to another. Notice how you can start from any of the nodes visited during the search and follow the arrows back to the start node. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "greedy vs dynamic [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have some general question about algorithms, when You have some problem and You want to write some algorithm, how do You approach the problem, how do You decide which algorithm to use greedy one or dynamic programming? thanks in advance\n    ", "Answer": "\r\nIn general I try to transform the new problem into a well known problem that has a well known solution. Then selecting the right algorithm is trivial. This covers most cases in the wild in my experience.\n\nIf step one fails I try a greedy approach and try to prove that it doesn't work. The proving part can be tricky but basically you have to show that the local best choice in some intermediate step isn't going to yield an overall best result. From there I branch out and usually dynamic is one of the first alternatives I try.\n\nIf all else fails, I start looking at good approximation algorithms which are close enough for the problem at hand. Many problems can be solved \"well enough\" with approximation in a fraction of the time and resources making it the clear winner. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Determine the minimum number of coins required for giving a change using greedy approach\r\n                \r\nAs an assignment for my course on Design and Analysis of Algorithms, I was asked to determine the minimum number of coins required for giving a change, using a greedy approach. I came up with this intuitive approach:\n\n```\n#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n  int hundreds=0,tens=0,ones=0,sum=0;\n\n  printf(\"Enter a sum of money in range 1 to 999\\n\");\n  scanf(\"%d\",&sum);\n  while(sum!=0) {\n    if (sum<10&&sum>=1){\n      ones=sum/1;\n      sum-=ones;\n    }\n    else if(sum>=10&&sum<100){\n      tens=sum/10;\n      sum-=tens*10;\n    }\n    else if(sum>=100&&sum<=999){\n      hundreds=sum/100;\n      sum-=hundreds*100;\n    }\n    else{\n      printf(\"Error\");\n      exit(0);\n    }\n  }\n\n  printf(\"%d $100, %d $10, %d $1\",hundreds,tens,ones);\n  return 0;\n}\n```\n\n\nIs this approach greedy? \nHow do I prove that the program is correct and uses the greedy approach?\n    ", "Answer": "\r\nThis is indeed greedy approach but you need to reverse the order of if-then-else. In general, greedy means to consume at the current moment the biggest quantity that you can consume.\n\nYou need to check first for the biggest coin.  There is no need for while-loop.  \n\n```\nif(sum>=100) {\n  hundreds=sum/100;\n  sum-=hundreds*100;\n}\nif(sum>=10){\n  tens=sum/10;\n  sum-=tens*10;\n} \nones = sum; \n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "A* efficiency vs Greedy Best First\r\n                \r\nGiven the following maze:\n\n```\n|||||||||||||||||||||||||||||||||||||\n|       | | |           |   |     | |\n| ||||||| | ||| | ||| ||| ||||||| | |\n|       |       | |     |     | |   |\n||||| ||||| ||| | | | ||| ||||| | |||\n|   | | | |   | | | |   | |   | |   |\n| ||| | | | ||| ||||| ||| | ||| ||| |\n|       |     |   |   |     | | |   |\n||| ||||||||| ||||||| ||| ||| | | | |\n|             |       | |   |     | |\n| | ||||| | ||| | | ||| | ||| ||| | |\n| | |     | | | | |     |   | | | | |\n| | | ||||||| | ||||||||| ||| | ||| |\n| | | |     |   |     |     |   |   |\n||| ||| | ||||| ||||| ||| ||| ||||| |\n|     | | |     | |     | |   | | | |\n| | | | | ||| ||| ||| ||| | | | | | |\n| | | | |                 | | |     |\n||| ||||||| | | ||||| ||| | ||| |||||\n|       | | | |     |   |     | |   |\n||||| | | ||||||||| ||||||||||| | |||\n|   | |           | |     |   | |   |\n| ||| ||||| ||||||||| ||||| | | ||| |\n| |   |      |        |     |       |\n| | | ||||| ||| | | | | |||||||||||||\n| | |   |     | | | |       |   | | |\n| | ||| ||| | | | ||||||||| ||| | | |\n| |   | |   | | |   | |   | | |     |\n| ||| ||| ||||| ||| | | ||||| | |||||\n|       |   |     | |     |   | |   |\n||| | ||||| ||||| ||| ||| | ||| | |||\n| | | | | | | |     | |   | |   | | |\n| | ||| | | | | ||||||||| | | | | | |\n|   |   |   |                 |     |\n| | | | ||| ||| ||||||| ||| ||| ||| |\n|+| | |       |   |       |   | |  P|\n|||||||||||||||||||||||||||||||||||||\n```\n\n\nI have two results from two different algorithms (of which, I'm hoping are correct implementations of A* and Greedy First):\n\n```\n                                    #nodes searched; hops to goal\nlarge maze - a* -                   expanded: 1120 (cost: 209)\nlarge maze - greedy -               expanded: 916 (cost: 209)\n```\n\n\nIs this normal behavior? Is A* not always optimal and more efficient than other algorithms, given a single path? I know it's dependent on the problem setup, but this was replicated with a much larger test as well:\n\n```\nmega maze - a* -                    expanded: 8964 (837)\nmega maze - greedy (mh heur) -      expanded: 5455 (837)\n```\n\n\nAm I wrong in thinking A* should have outperformed Greedy First here?\nBelow are my heuristics... maybe I'm setting my heuristic values wrong?:\n\n```\n#greedy\nself.heuristic = abs(goalNodeXY[0] - self.xy[0]) + abs(goalNodeXY[1] - self.xy[1])\n\n#A* --- costFromStart == path length from starting point\nself.heuristic = math.hypot(self.xy[1]-goalNodeXY[1],self.xy[0]-goalNodeXY[0]) + costFromStart\n```\n\n    ", "Answer": "\r\n\n  Is A* not always optimal and more efficient than other algorithms, given a single path?\n\n\nNo. A* always finds an optimal path, but it does not always do so faster than other algorithms. It's perfectly normal for the greedy search to sometimes do better.\n\nAlso, your A* heuristic isn't as good as the one you used for the greedy algorithm. You used Manhattan distance in the greedy algorithm and Euclidean distance in the A* search; Manhattan distance is always a better estimate of the remaining path length and never overestimates, so it would have been better to use Manhattan distance in the A* search too.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Dominating Set Greedy Approximation Worst-Case Example\r\n                \r\nTo find a minimum Dominating Set of an undirected Graph G you can use a greedy algorithm like this:\nStart with an empty set D. Until D is a dominating Set, add a vertex v with maximum number of uncovered neighbours.\n\nThe algorithm generally does not find the optimal solution, it is a ln(Delta)-approximation. (If Delta is the maximum degree of a vertex in G)\n\nNow I am looking for a simple example where the greedy algorithm does not find the optimal solution. The only one I found is a related instance of the set cover problem. (http://en.wikipedia.org/wiki/Set_cover_problem#Greedy_algorithm picture on the right)\nTranslating this one to a graph would cause a minimum of 14 vertices and a lot of edges.\n\nDoes anyone know a small example?\n\nThanks in advance\n    ", "Answer": "\r\nConsider the following graph:\n\n\n\nA greedy approach will choose B then D and G. Meanwhile, E and F form a dominating set. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "optimal sequence to be followed for studying topics like dp [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am a novice to algorithms and data structures. I recently started participating on codeforces and spoj etc.for solving questions  i need to study dp,greedy algorithms,graph algorithms,data structures.what should be my strategy for studying or rather sequence and what data structures i need to know for competitive programming?\n    ", "Answer": "\r\nAll in all there shouldnt be an \"optimal\" sequence. Its all about understanding the topic. Since not two people can learn with the same speed, there shouldnt be something like an \"optimal\" sequence. But its good to learn basic approaches of each topic. \n\nThere are alot Tutorials out there, which explains the most fundamental thing in any topic. E.g. Youtube covers most graph problems. Even DP and so can be found there. Especially on Topcoder Tutorials there is alot you can learn.\n\nOn the other hand you will learn nearly nothing, if u dont have to think for yourself. So solving such puzzles is a must. I would recommend this site (especially for dp). Just check the \"problem set\" link on the site and look for dynamic programming.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How is Greedy Technique different from Exhaustive Search?\r\n                \r\nI have some sample problems that I'm writing pseudo code for and I'm noticing alarming patterns between the greedy technique and exhaustive search.\n\n```\n       Job 1, Job 2, Job 3, Job 4, Job 5\nPerson:  1     9     2      7      8\nPerson:  2     6     4      3      7\nPerson:  3     5     8      1      8\nPerson:  4     7     6      9      4 \n```\n\n\nThe above is the table example of an assignment problem. Basically, you have n amount of jobs to do, five here, and you need to complete them in the smallest amount of them were time is shown by the values attached to each person and their job in the table. \n\nIt seems to be that the only difference in the exhaustive search and the greedy technique are the data structures used by both to solve the problems. Greedy uses weighted graphs while exhaustive uses arrays. Does this happen a lot in our algorithms? Do many algorithms mimic each other closely yet simply use more efficient data structures to accomplish our problems?\n    ", "Answer": "\r\nExhaustive search explores all possible solutions and then it is able to pick the one that is the best.\n\nGreedy search starts with some (partial) solution. This solution is then improved/completed in a way that it always gets better. However, this does not necessarily lead to the best solutions of all of them.\n\nExample\n\nImagine a super simple problem: you have this sequence of numbers:\n\n```\nindex:   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\nnumbers: 1  6  5  4  5  6  7  8  9  5  2  1  0  1  5  4  5  6  4  1\n```\n\n\nand you are to find the smallest number. If you do exhaustive search, you go through the whole sequence and just return the smallest number encountered. If you do greedy search, you pick some number, e.g. the one at the index 7, which is 8. You then try to greedily improve the solution: you look right - there is 9 and that is worse. You look left - there is 7, which is better, so move there. Again you look at both sides and there is 8 on the right and 6 on the left, so go left. You do that twice more times and you get to index 3 where is the number 4. And that one is the final solution of this greedy search - you cannot improve it more by going left or right, but clearly not the best possible. But you also got it in far fewer steps than with the exhaustive search.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Please tell me Greedy algorithm Time analysis For a problem\r\n                \r\nAssume you are running a transportation network company. Suppose you have M driver and N\npassengers such that one driver only picks 1 passenger and 1 passenger can only take ride from 1\ndriver at a time. To make the travel comfortable, you don’t allow driver to pick up a passenger\nwith whom he has education difference of more than 2 years. Please devise the algorithm to\nmaximize the number of drivers and passengers matches.\n    ", "Answer": "\r\nThe Algorithm:\n\nOne greedy approach that you could take would be to sort both lists of M drivers and N passengers by increasing # years of education. You could then use two pointers to assign pairs. Starting at the beginning of each list compare the current driver and passenger. If their education level is <= 2 assign the two as a pair and increment both pointers. If their education level is > 2 increment whichever pointer has the lower education level and continue. Once you have reached the end of both lists you are done assigning pairs. This would assign the maximum number of valid driver-passenger pairs. \n\nRuntime Analysis:\n\nSort List of Drivers: O(M log M)\n\nSort List of Passengers: O(N log N)\n\nAssigning Pairs: O(N + M) \n\nRuntime: O(M log M + N log N)\n\nI hope this information is helpful!\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Please tell me Greedy algorithm Time analysis For a problem\r\n                \r\nAssume you are running a transportation network company. Suppose you have M driver and N\npassengers such that one driver only picks 1 passenger and 1 passenger can only take ride from 1\ndriver at a time. To make the travel comfortable, you don’t allow driver to pick up a passenger\nwith whom he has education difference of more than 2 years. Please devise the algorithm to\nmaximize the number of drivers and passengers matches.\n    ", "Answer": "\r\nThe Algorithm:\n\nOne greedy approach that you could take would be to sort both lists of M drivers and N passengers by increasing # years of education. You could then use two pointers to assign pairs. Starting at the beginning of each list compare the current driver and passenger. If their education level is <= 2 assign the two as a pair and increment both pointers. If their education level is > 2 increment whichever pointer has the lower education level and continue. Once you have reached the end of both lists you are done assigning pairs. This would assign the maximum number of valid driver-passenger pairs. \n\nRuntime Analysis:\n\nSort List of Drivers: O(M log M)\n\nSort List of Passengers: O(N log N)\n\nAssigning Pairs: O(N + M) \n\nRuntime: O(M log M + N log N)\n\nI hope this information is helpful!\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Having a casting issue with traveling salesperson using a greedy algorithm\r\n                \r\nI figure I have the general idea down for how to solve the algorithm but the implementation seems to elude me. What I have thus far is this:\n\n```\npublic class GreedySalesman {\n\n\npublic static int[] greedySalesmanSolution(int[][] distances) {\n    List cityList = new ArrayList();\n            for(int[] array: distances) {\n               cityList.add(Arrays.asList(array));\n            }\n    List<Integer> initialResult = new ArrayList();\n    initialResult.add(0);\n    List<Integer> finalResult = findMinDistance(cityList, cityList, initialResult, 0);\n          /*int finalResultArray = new int[finalResult.size()+1];\n    int i = 0;\n    while (!(finalResult.isEmpty)) {\n                finalResultArray[i] = finalResult.poll();\n                i++;\n    }\n\n    return finalResultArray;\n    */\n          return null;\n        }\n\npublic static List<Integer> findMinDistance(List<List<Integer>> initialCityInput, List<List<Integer>> cityInput, List<Integer> distanceResult, int index) {\n        if(cityInput.isEmpty()) {\n            distanceResult.add(0);\n            return distanceResult;\n        }\n        int min = Collections.min(initialCityInput.get(index));\n        List<Integer> city = initialCityInput.get(index);\n        index = city.indexOf(min);\n        distanceResult.add(index);\n        cityInput.remove(city);\n\n        return findMinDistance(initialCityInput,cityInput,distanceResult,index);\n\n}\n}\n```\n\n\nThat is, the algorithm will take an two dimensional array of ints as an input, then make a List cityList referring to distances, then pass it into findMinDistance. The commented out part is where the result from findMinDistance will be converted into an array of ints and returned as finalResultArray but that part is not important yet.\n\nfindMinDistance will take in a two dimensional list of Integers twice, a List of Integers that will become the result and an int representing an index.\nThe function will return the distanceResult when cityInput has been emptied. Otherwise it will start with the first city based on the index, get the minimum distance from that List and its index and add the index to the distanceResult.\nOnce that has been done, the city will be removed from the cityInput and the program will go into recursion until cityInput has been emptied.\n\nThe issue I am getting currently is ```\n\nI cannot be cast to java.lang.Integer```\n\nat   \n\n```\nint min = Collections.min(initialCityInput.get(index));\n```\n\n\nAnd in main upon trying to run the program with some test data.\nAny help will be appreciated.\n\n======\n\nEdit:\n\nI made some changes to my code  \n\n```\npublic class GreedyTSP {\n\n    public int[] greedySalesmanSolution(int[][] distances) {\n                List<List<Integer>> cityList = new ArrayList();\n                List<List<Integer>> initialCityList = new ArrayList();\n                int iLength = distances.length;\n                for (int i = 0; i < iLength; ++i) {\n                    int jLength = distances[0].length;\n                    cityList.add(new ArrayList(jLength));\n                    initialCityList.add(new ArrayList(jLength));\n                    for (int j = 0; j < jLength; ++j) {\n                      cityList.get(i).add(distances[i][j]);\n                      initialCityList.get(i).add(distances[i][j]);\n                    }\n                }\n\n        List<Integer> initialResult = new ArrayList();\n        initialResult.add(0);\n        List<Integer> finalResult = findMinDistance(initialCityList, cityList, initialResult, 0);\n                int[] finalResultArray = new int[finalResult.size()];\n                Iterator<Integer> iterator = finalResult.iterator();\n                for (int i = 0; i < finalResultArray.length; i++){\n                    finalResultArray[i] = iterator.next().intValue();\n                }\n        return finalResultArray;\n\n\n            }\n\n        public List<Integer> findMinDistance(List<List<Integer>> initialCityInput, List<List<Integer>> cityInput, List<Integer> distanceResult, int initialIndex) {\n            if(cityInput.isEmpty()) {\n                distanceResult.add(0);\n                return distanceResult;\n            }  \n            List<Integer> city = initialCityInput.get(initialIndex);\n            Integer min = findMin(city, distanceResult, initialIndex);\n            int resultIndex = city.indexOf(min);\n            distanceResult.add(resultIndex);\n            cityInput.remove(city);\n            return findMinDistance(initialCityInput,cityInput,distanceResult,resultIndex);\n    }\n\n        public Integer findMin(List<Integer> city, List<Integer> distanceResult, int inputIndex) {\n            Integer min = Integer.MAX_VALUE;\n            for(int i = 0; i < city.size();i++) {\n                if (city.get(i) > inputIndex && city.get(i) < min) min = city.get(i);\n            }\n            int resultIndex = city.indexOf(min);\n            if(distanceResult.contains(resultIndex)) {\n                return findMin(city, distanceResult, inputIndex);\n            }\n\n            return min;\n        }   \n}\n```\n\n\nIm not having any cast errors at the moment but it seems that the parts of my program dealing with recursion are causing StackOverflowError-s. I've been messing with this thing for literally 16 hours now and I'm all out of ideas as to why. Any ideas?\n    ", "Answer": "\r\nThe problem with your casting is the following\n\n```\nList<List<Integer>> initialCityInput```\n is a List containing Lists with integers. \n\nTherefore ```\ninitalCityInput.get(index)```\n returns a List not an Int, which cannot be cast to int.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Library for solving knapsack-prblm(integer-programming)\r\n                \r\nI am trying to solve the knapsack-problem, which is also an integer-programming problem. I have looked at several approximate solutions like dynamic-programming, greedy algorithm, branch-and-bound algorithm, genetic algorithms. Can you tell me a library(in any language) that helps implementing any/all of these algorithms?\n\nThanks in advance.\n    ", "Answer": "\r\nHere are a few implementations of the Knapsack Problem (KP):\n\n\nCPLEX If you are familiar with CPLEX (IBM) they have a page for Knapsack (among many other IP formulations) here.\nJava: They also have a Java implementaion of the knapsack problem here. (look specifically at ```\njavaknapsack.mod```\n)\nPython: Here's one example of multiple solution techniques of the Knapsack problem.(by Dave Eppstein)\nCPP: Here's a Genetic Algorithm implementation of the KP.\n\n\nA simple web-search should get you many more examples because the knapsack problem is easy to solve (and to teach) using several of the techniques you mention.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is my code recursive If I use the break command?\r\n                \r\nI'm learning about recursive and Greedy algorithms, this code separate the change needed for a original amount. I tried using a recursive algorithm but the code wasn't working properly until I added the break to avoid further iterations. Is this correct?\n```\npublic class Main {\n\n    public static void main(String[] args) {\n    // write your code here\n        int[] coinSet = {20,10,5,1};\n        int N = 214;\n        GreedyChange greedyChange = new GreedyChange();\n        greedyChange.greedyChange(coinSet,N);\n        greedyChange.printChange();\n    }\n}\n\n\npublic class GreedyChange {\n    private final List<Integer> coins = new ArrayList<>();\n\n    public void greedyChange(int[] coinSet, int change) {\n        if(change<=0){\n            return;\n        }\n        for (int j : coinSet) {\n            if (change - j >= 0) {\n                coins.add(j);\n                change -= j;\n                greedyChange(coinSet, change);\n                break;\n            }\n        }\n    }\n\n    public void printChange() {\n        System.out.println(\"The change is being distributed in \" + coins.size() + \" coins in the following\" +\n                \" way: \");\n        int sum = 0;\n        for (int i = 0; i < coins.size(); i++) {\n            if (i == coins.size() - 1) {\n                System.out.print( \"$\" +coins.get(i));\n            } else {\n                System.out.print(\"$\" + coins.get(i) + \" + \");\n            }\n            sum += coins.get(i);\n        }\n        System.out.print(\" = $\" + sum);\n    }\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Solving fractional knapsack problem with dynamic programming\r\n                \r\nA few days ago, I was reading about greedy algorithms and dynamic programming for the fractional knapsack problem, and I saw that this problem can be solved optimally with the greedy method. Can anyone give an example or a solution to solve this problem with the dynamic programming method?\n\nP.S: I know that the greedy method is the best way to solve this question, but I want to know how dynamic programming works for this issue.\n    ", "Answer": "\r\nYes, you can solve the problem with dynamic programming.\n\nLet ```\nf(i, j)```\n denote the maximum total value that can be obtained using the first ```\ni```\n elements using a knapsack whose capacity is ```\nj```\n.  \n\nIf you are familiar with the 0-1 knapsack problem, then you may remember that we had the exact same function. However, the recurrence for the 0-1 knapsack problem was ```\nf(i, j) = max{f(i - 1, j), V[i] + f(i - 1, j - W[i])}```\n (the first argument considers the case in which we don't take the item at index ```\ni```\n, and the second argument considers the case in which we do take the item at index ```\ni```\n).\n\nIn the fractional knapsack problem, we are allowed to take fractional amounts of some item. Thus, our recurrence would look something like, ```\nf(i, j) = max{f(i - 1, j), delta * V[i] f(i - 1, j - delta * W[i])```\n over all possible values of ```\ndelta```\n, where ```\ndelta```\n represents the amount of the item that we are taking. \n\nNow if you increment ```\ndelta```\n in sufficiently small increments, you should get the correct answer.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Graph Concept\r\n                \r\nHere is my problem:\n\nGiven ```\nT={CTAGC, GAGCG, AGCGG, CGGAG}```\n, using a greedy algorithm, the superstring ```\nS```\n will be ```\nGAGCGGAG```\n.\n\nHere is the pseudocode for my solution:\n\n```\nAlgorithm greedy\nSort edges in decreasing weight order (weight mean the number of overlap between 2 substrings)\nInitialize the Set empty\nFor each edge in this order\n  If the edge does not form a cycle\n    and the edge does not start or end at the same node as another edge in the Set\n    then\n       add the edge to the current Set\nEnd for\nEnd Algorithm\n```\n\n\nFrom ```\nS```\n, the combination of triplets will be given as ```\ns = {GAG, AGC, GCG, CGG, GGA, GAG}```\n.\n\nThe ```\nGAG```\n is repeated.\n\nIf using ```\ns```\n to retrieve the superstring by using Hamiltonian method, would the repeated words will be used or omitted?\n\nIf the repeated word is omitted, then ```\nGAG```\n, ```\nAGC```\n, ```\nGCG```\n, ```\nCGG```\n, ```\nGGA```\n constructed back will become ```\nGAGCGGA```\n.\n\nSo, the greedy method and Hamiltonian method will provide different results in the superstring.\n\nWhy are they different? In my research, all the examples I found showed that there are no repeated words in the combination, so if I reconstruct the superstring using the Hamiltonian method, the result of the greedy and Hamiltonian methods will be the same. But what about the repeated words?\n\nHere is a link to my resource on the subject.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "graph coloring using BFS - greedy coloring?\r\n                \r\nThinking if I can implement graph coloring using BFS, I came up with the approach pseudo coded below.\n\nThough it does appear like a greedy algorithm, I am not sure of it's correctness. Any expert comments? \n\n```\ncolors[MAX_COLORS];\ncolorsUsedSoFar[] = NIL;\nlike BFS, color first node u with colors[0] i.e color[u] = colors[0];\ncolorsUsedSoFar[] += colors[0];\n\nfor each node v adjacent to u{\n  (if v not already colored){\n     color[v] = color from the colorsUsedSoFar[] but NotUsedByItsAdjacents\n     If all the colors in colorsUsedSoFar[] are used by adjacents, assign a new color to v)\n  }\n}\n```\n\n\nBy 'like BFS', I meant using a Queue and processing until Queue exhausts.\n    ", "Answer": "\r\nThis is an example of a greedy coloring algorithm.  \n\nThe breadth first search (BFS) will implicitly choose an ordering for you.\n\nSo the algorithm is correct, but will not always give the optimal coloring (i.e. least number of colours used).\n\nA more common ordering is to order the vertices by their degree, known as the Welsh–Powell algorithm.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Coin Change : Greedy Approach\r\n                \r\nThe Problem is making n cents change with quarters, dimes, nickels, and pennies, and using the least total number of coins. In the particular case where the four denominations are quarters,dimes, nickels, and pennies, we have c1 = 25, c2 = 10, c3 = 5, and c4 = 1. \n\nIf we have only quarters, dimes, and pennies (and no nickels) to use,\nthe greedy algorithm would make change for 30 cents using six coins—a quarter and five pennies—whereas we could have used three coins, namely, three dimes.\n\nGiven a set of denominations, how can we say whether greedy approach creates an optimal solution?\n    ", "Answer": "\r\nWhat you are asking is how to decide whether a given system of coins is canonical for the change-making problem. A system is canonical if the greedy algorithm always gives an optimal solution. You can decide whether a system of coins which includes a 1-cent piece is canonical or not in a finite number of steps. Details, and more efficient algorithms in certain cases, can be found in http://arxiv.org/pdf/0809.0400.pdf.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy - Locate Cottage Boxes within a distance\r\n                \r\nAn agency wants to locate boxes on a road. We have cottages on a road. Each cottage has a their own box. Each cottage's box exist at miles, x_1, x_2, ... , x_n on this road(these values can be assumed to be distinct integers that record the distance in miles from a specified origin). Our goal is to minimize the number of boxes while making sure that no cottage is further then K miles from the closest/nearest box. \n\nIntuition: For this greedy algorithm, I want to look at each cottage one at a time, in some order, and make a greedy choose (some greedy choice) for choosing the locations of the boxes. I figured what I should do first is sort the cottage locations. But I'm struggling with the greedy choice.\n    ", "Answer": "\r\nAssuming the x_i are the distances of the cottages on the road (and not the positions of the boxes, since they aren't given and are supposed to be found). Without loss of generality the x_i are sorted. Then put the first box at distance x_1 + K along the road. This must be optimal, since there has to be a box within distance K from x_1, and wherever you put it, it can't serve more cottages than when it's maximally far away from x_1 (since there's no cottages before x_1).\n\nContinue... let a_1 be the first cottage that's not within distance K from a box, and put the second box at distance x_{a_1} + K along the road. \n\nIn general, if you've placed i boxes, let a_i be the first house that's not within distance K from a box, and put box i+1 at distance x_{a_i} + K along the road.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Finding a greedy optimal solution\r\n                \r\nIs there a greedy algorithm to solve this problem:\nI have n television, each television has a height and a width.\nr buyers come at the same time to my shop. Each one wants a television with a known minimum height and a minimum width.\n\nWhat is the maximum number of commands I can fulfill?\n    ", "Answer": "\r\nThe problem is of maximum graph matching. You create a graph with left side nodes representing customers and right side nodes representing televisions. A edge between left side node and right side node represent that customer can buy television(meaning television passes the minimum height- width requirement of customer). Now you have to find maximum matching in the graph.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "C program Null Parsing\r\n                \r\nI have written a code to calculate the minimum number of coins using Greedy algorithm and Dynamic algorithm, but the Dynamic algorithm part doesn't work properly. There is a Null value going to array, I can't find it. Please HELP me. I need a answer as soon as possible.\n\n```\n#include <stdio.h>\nint n;\nint denom[]={1,2,4,5,20,25};\nint coinCounter(int n);\nint main(){\n\n     printf(\"Please Enter a Number : \");\n     scanf(\"%d\",&n);\n    int coinmin,orin,i;\n    orin=n;\n    i=coinmin=0;\n     for(i=(sizeof(denom)/4)-1;i>=0;i--){\n\n         coinmin =coinmin+n/denom[i];\n          n=n%denom[i];\n      }\n\n    printf(\"Coin Min By Greedy Algorithm : %d\\n\",coinmin);\n    printf(\"Dynamic Algorithm : %d\\n\",coinCounter(orin));\n    return 0;\n}\n\nint coinCounter(int n){\n    int opt[n];\n    int largest[n];\n    int i,j,a;\n    i=j=0;\n    for(j=1;j<=n;j++){\n\n        opt[j]=10000;\n         //printf(\"xxn\");\n        for(i=(sizeof(denom)/4)-1;i>=0;i--){\n\n            if(denom[i]==j){\n\n                opt[j]=1;\n                largest[j]=j;\n            }\n            else if(denom[i]<j){\n                a=opt[j-denom[i]]+1;\n            }\n            if(a<opt[j]){\n                opt[j]=a;\n                largest[j]=denom[i];\n            }\n        }\n\n    }\n     return opt[n];\n\n}\n```\n\n\nI edited the Code as following, but the answer is not coming\n\n```\nint coinCounter(int n){\n    int opt[n];\n    int largest[n];\n    int i,j,a;\n    i=j=0;\n    for(j=1;j<n;j++){\n\n        opt[j]=10000;\n         printf(\"xxn\");\n        for(i=(sizeof(denom)/4)-1;i>=0;i--){\n\n            if(denom[i]==j){\n\n                opt[j]=1;\n                largest[j]=j;\n            }\n            else if(denom[i]<j){\n                a=opt[j-denom[i]]+1;\n            }\n            if(a<opt[j]){\n                opt[j]=a;\n                largest[j]=denom[i];\n            }\n        }\n\n    }\n     return opt[n-1];\n\n}\n```\n\n\nhey these are the results I'm Getting \n\n\nPlease Enter a Number : 8\nCoin Min By Greedy Algorithm : 3\nDynamic Algorithm : 1\n\n\nAnother answer I'm getting I can't figure out what I'm doing wrong\n\n\nPlease Enter a Number : 71\nCoin Min By Greedy Algorithm : 4\nDynamic Algorithm : 3\n\n    ", "Answer": "\r\n1\n```\nint opt[n]; // not the right way to do dynamic allocation. Use malloc/calloc\nint largest[n]; \n```\n\n2\n```\nfor(j=1;j<=n;j++){\n          ^ array is indexed from 0...n-1, index-n is outside array bounds\n```\n\nDon't do this.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Populization of genetic algorithm for multiple traveling salesman\r\n                \r\nI am trying to understand an algorithm proposed by this paper. Unfortunatly behind paywall, but here is the only relevant part:\n\nB. Population initialization \nGenetic algorithm is an operation on evolution of the initial\npopulation. Population initialization is the starting point of the\ncalculation. In order to achieve the global optimum, initial\npopulation should be spread randomly in each area within the\nsearch space. Although random creation can have a diversity of\nthe routes, it also has a low initial adaptability; this may affect\ndirectly the convergence speed. We in this paper use greedy\nstrategy [3] to include as many optimized sub-routes as\npossible in the initial population. This method increased the\nadaptability in the initial population and reduced the blindness\nofthe creation ofthe initial population.\nMethod of creation ofthe initial population is as follows .\n\nStep 1: Select randomly a city labeled as A, if it is not\nselected before, mark it as selected, otherwise repeat the\nselection, then choose city B which is the closest city to A. City\nA and B can form a route AB.\n\n\n\n\nStep 2: Choose separately Cities C and D which are the\nclosest cities to A and B. C and D have to be cities not selected\nbefore . If AC<BD, then choose C to form route C-A-B ,\nOtherwise, choose D to form route A-B-D .\n\n\n\n\nStep 3: Repeat step 2 until all cities are included in\ntraveling routes .\n\n\n\n\nStep 4: If all cities have been selected at least once, choose\nrandomly two cities to form a route and mark them as double\nselection, then go to step 2 until reach the requirement of the\npopulation.\n\n\nI understand Step 1, but would need a more detailed explanation for Step 2 and Step 4. How to select C and D, if B is already the closest city to A and is not marked as selected in Step 1? What does Step 4 suggest?\nAny explanation or pseudocode would be helpful.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Cs50 greedy without using <cs50.h>\r\n                \r\nI am solving the greedy algorithm of from the cs50 course without using the cs50 header file. I have written some code. It works fine with numbers as input but when I give it a string or chars as input, it does not prompt me back. I do not know how to solve this issue.\n\n```\n#include <stdio.h>\n\nint main()\n{\n    float c;\n    int C, nQ, rem1, nD, rem2, nN, rem3;\n\n    do\n    {\n        printf(\"O hai! How much change is owed? \");\n        scanf(\"%f\", &c);\n    }\n    while(c<0);\n\n    C = c * 100;\n\n    nQ = C / 25;\n    rem1 = C % 25;\n\n    nD = rem1 / 10;\n    rem2 = rem1 % 10;\n\n    nN = rem2 / 5;\n    rem3 = rem2 % 5;\n\n    printf(\"%d\\n\", nQ+nD+nN+rem3);\n}\n```\n\n    ", "Answer": "\r\nThis is because a float cannot accept a string. You are expecting ```\nc```\n to hold other data types when it is just a float variable.\nI would suggest you to take input as a string and use ```\natof()```\n to check whether the input is a floating type or not. Something like this:\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main()\n{\n    float c;\n    int C, nQ, rem1, nD, rem2, nN, rem3;\n    char str[10];\n\n    do\n    {\n        printf(\"O hai! How much change is owed? \");\n        scanf(\"%s\", str);\n    }\n    while(atof(str) > 0);\n    c = atof(str);\n    C = c * 100;\n\n    nQ = C / 25;\n    rem1 = C % 25;\n\n    nD = rem1 / 10;\n    rem2 = rem1 % 10;\n\n    nN = rem2 / 5;\n    rem3 = rem2 % 5;\n\n    printf(\"%d\\n\", nQ+nD+nN+rem3);\n}\n```\n\nThis makes sure that you are using a do while loop only for floating point numbers.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Marching cubes and greedy meshing\r\n                \r\nCurrently i am trying to implement the marching cubes algorithm into my voxel engine to get smoother terrain. My voxel engine also uses the greedy meshing algorithm to optimize the engines meshing. My question is do these two algorithms contradict each other (because one minimizes the vertices which the other uses for smoother terrain)? Or are they intercompatible? \n    ", "Answer": "\r\nYou'll have to apply the greedy meshing after the marching cube. Don't forget the marching cube has 512 possibilities (or something like that, forgot the exact number) so you'll have to edit your greedy mesh.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Trying to understand how the math behind for Greedy Modularity Algorithm works\r\n                \r\nI'm using the greedy modularity algorithm from networkx in a project and I need to dissect the paper of this algorithm.\nFrom what I understand, you begin the algorithm putting every vertex into a community of one, calculating the modularity for the network using this separation into communities and then changing the network and incrementing the modularity using the algorithm steps in a way that the new modularity of the graph is the modularity of the new separation.\nBut from reading the paper and doing some calculations it seems that the algorithm doesn't increment enough to give us the modularity of the new separation.\nStarting the algorithm, using equation (7) we will have\n\nAfter the first increment (joining two vertices that are connected), if we calculate Q by the equation (7) we will have, if the vertices are v1 and v2 and the community they are in is called i\n\nAnd if we calculate the new modularity using the first increment of the algorithm, we will only have\n\nWhich is definitely different from the previous one. So how is this difference compensated? Am I calculating this wrong?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "NN vs Greedy Search\r\n                \r\nBoth NN and Greedy Search algorithms have a ```\nGreed```\n nature, and both have tendency towards the lowest cost/distance (my understanding may be incorrect though). But what makes them different in a way that each one can be classified into a distinct algorithm group is somehow unclear to me. \n\nFor instance, if I can solve a particular problem using NN, I can surely solve it with Greedy Search algorithm as well specially if minimization is the case. I came to this conclusion because when I start coding them I come across very similar implementations in code although the general concept behind both might be different. Sometimes I can't even tell if the implementation follows NN or Greedy Search.\n\nI have done my homework well and searched enough on Google, but couldn't find a decent explanation on what distinguishes them from one another. Any such explanation is indeed appreciated.   \n    ", "Answer": "\r\nHmm, at a very high level they both driven by heuristics in order to evaluate a given solution against an ideal solution. But, whilst a greedy search algo outputs a solution for a given input, the NN trains a model that will generate solutions for given inputs. So at a very very high level, you can think that the NN generates a solution finder, whereas the greedy search is a harcoded solution finder.\n\nIn other words, the NN will generate \"code\" (i.e. the model (aka the weights)) that finds solutions to the problem when provided to the same network topology. The greedy search is you actually writing the code that finds the solution to the problem. This is quite wishy washy though, I'm sure there is a much more concise, academically sound way of expressing what I've just said \n\nAll of what I've just said in based on the assumption that by \"Greedy search\" you meant the algorithms to solve problems such as travelling sales man.\n\nAnother way to think of it is:\n\nIn greedy search, you write an algorithm that solves a search problem (find me the graph that best describes the relationship, based on provided heuristic(s), between data point A and data point B).\n\nWhen you write a neural network, you declare a network topology, provide some initially \"random\" weights and some heuristics to measure output errors and then train the networks weights via a plethora of different methods (back prop, GAN etc). These weights can then be used as a solver for novel problems.\n\nFor what it's worth, I don't think an NN would be a good approach to generate a solver for travelling sales man problem. You would be far better off just using a common graph search algorithm..\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "DFS Greedy Chromatic Number\r\n                \r\nIn my school I learned that calculating chromatic number of a arbitrary graph is NP-Complete.\nI understand why the greddy algorithm does not work, but what about DFS/Greedy algorithm? \nThe main idea is do a DFS an for all the vertex not yet colored, take the minimum color index over all the neighbours. \n\nI can't figure out a counter example and this question is blowing my mind. \nThanks for all of your answers.\n\nPseudocode\n\n```\nChromatic(Vertex x){\n    for each neighbour y of vertex x\n        if color(y) = -1\n           color(y) <- minimum color over all the neighbours of y\n           if(y>=numColor) numColors++;\n           Chromatic(y);\n}\nMain(){\n  Set the color of all vertex equal -1\n  Take an arbitrary vertex u and set color(u) = 0\n  numColors = 1;\n  Chromatic(u);\n  print numColors;\n}\n```\n\n    ", "Answer": "\r\nHere's a concrete counterexample: the petersen graph. Your algorithm computes 4, regardless of where you start (I think), but the graph's chromatic index is 3.\n\n\n\nThe petersen graph is a classical counterexample for many greedy attempts at graph problems, and also for conjectures in graph theory.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Using a greedy feature selection algorithm for linear regression in Python\r\n                \r\nThis is a homework problem for a machine learning course I'm taking. I'll be as descriptive as I can regarding the approaches I took, what worked, and what didn't.\n\n\n\nWe are given four types of data sets: ```\ndev_sample.npy```\n, ```\ndev_label.npy```\n, ```\ntest_sample.npy```\n, and ```\ntest_label.npy```\n. We first load the data set as follows:\n\n```\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import ShuffleSplit\nfrom sklearn.metrics import mean_squared_error\nimport matplotlib.pyplot as plt\n\nX_dev = np.load(\"./dev_sample.npy\") # shape (900, 126)\ny_dev = np.load(\"./dev_label.npy\") # shape (900,)\nX_test = np.load(\"/test_sample.npy\") # shape (100, 126)\ny_test = np.load(\"./test_label.npy\") # shape (100,)\n```\n\n\nThe problem we need to solve is to implement a \"greedy feature selection\" algorithm until the best 100 of the 126 features are selected. Basically we train models with one feature, select the best one and store it, train 125 models with each remaining feature paired with the selected, choose the next best one and store it, and continue until we have reached 100.\n\nHere is the code:\n\n```\n# Define linear regression function\n# You may use sklearn.linear_model.LinearRegression\n# Your code here\nlin_reg = LinearRegression()\n# End your code\n\n# Basic settings. DO NOT MODIFY\nselected_feature = []\nsel_num = 100\nvalid_split = 1/5\ncv = ShuffleSplit(n_splits=5, test_size=valid_split, random_state=0)\n\nselected_train_error = []\nselected_valid_error = []\n\n# For greedy selection\nfor sel in range(sel_num) :\n    min_train_error = +1000\n    min_valid_error = +1000\n    min_feature = 0\n\n    for i in range(X_dev.shape[1]) :\n        train_error_ith = []\n        valid_error_ith = []\n\n        # Select feature greedy\n        # Hint : There should be no duplicated feature in selected_feature\n\n        # Your code here\n        X_dev_fs = X_dev[:, i]\n        if (i in selected_feature):\n            continue\n        else:\n            pass\n        # End your code\n\n\n        # For cross validation\n        for train_index, test_index in cv.split(X_dev) : # train_index.shape = 720, test_index.shape = 180, 5 iterations\n            X_train, X_valid = X_dev_fs[train_index], X_dev_fs[test_index]\n            y_train, y_valid = y_dev[train_index], y_dev[test_index]\n\n            # Derive training error, validation error\n            # You may use sklearn.metrics.mean_squared_error, model.fit(), model.predict()\n\n            # Your code here\n            model_train = lin_reg.fit(X_train.reshape(-1, 1), y_train.reshape(-1, 1))\n            predictions_train = model_train.predict(X_valid.reshape(-1, 1))\n            train_error_ith.append(mean_squared_error(y_valid, predictions_train))\n\n            model_valid = lin_reg.fit(X_valid.reshape(-1, 1), y_valid.reshape(-1, 1))\n            predictions_valid = model_valid.predict(X_valid.reshape(-1, 1))\n            valid_error_ith.append(mean_squared_error(y_valid, predictions_valid))\n\n            # End your code\n\n    # Select best performance feature set on each features\n    # You should choose the feature which has minimum mean cross validation error\n\n    # Your code here\n\n    min_train_error = train_error_ith[np.argmin(train_error_ith)]\n    min_valid_error = valid_error_ith[np.argmin(valid_error_ith)]\n    min_feature = np.argmin(valid_error_ith)\n\n    # End your code\n\nprint('='*50)\nprint(\"# of selected feature(s) : {}\".format(sel+1))\nprint(\"min_train_error: {}\".format(min_train_error))\nprint(\"min_valid_error: {}\".format(min_valid_error))\nprint(\"Selected feature of this iteration : {}\".format(min_feature))\nselected_feature.append(min_feature)\nselected_train_error.append(min_train_error)\nselected_valid_error.append(min_valid_error)\n```\n\n\n\n\nThe algorithm that I had in mind when filling in the ```\n#Your code```\n sections is that ```\nX_dev_fs```\n would hold the feature of the current iteration along with the previously selected features. We would then use cross validation to derive training and CV errors.\n\nThe current output that I get after running this program is\n\n```\n==================================================\n# of selected feature(s) : 1\nmin_train_error: 9.756743239446392\nmin_valid_error: 9.689856536723353\nSelected feature of this iteration : 1\n==================================================\n# of selected feature(s) : 2\nmin_train_error: 9.70991346883164\nmin_valid_error: 9.674875050182653\nSelected feature of this iteration : 1\n==================================================\n```\n\n\nand so on, with the ```\n# of selected feature(s)```\n going on until 100.\n\nThe problem is that ```\nSelected feature of this iteration :```\n should not output the same number more than once. I'm also having trouble figuring out how to store the best feature and use it with the subsequent iterations.\n\nThe questions that I have are:\n\n\nWhy is my ```\nselected_feature```\n list containing the same duplicate features, and how do I prevent that?\nHow do I store the best feature in ```\nselected_feature```\n, then use that paired up with each subsequent remaining feature?\n\n\n\n\nAny feedback is appreciated. Thank you.\n\n\n\nEDIT\n\nHere are the links to the files that I am loading into the variables, in case anybody needs them.\n\n```\ndev_sample.npy```\n\n\n```\ndev_label.npy```\n\n\n```\ntest_sample.npy```\n\n\n```\ntest_label.npy```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "algorithmic idea using greedy strategy\r\n                \r\nSo I just finished taking a test and thought that I would ask you guys about a question that stumped me. I was asked to come up with the algorithmic idea using ```\ngreedy strategy```\n on an ascending array of n numbers, where ```\nA[i] + A[j] = T```\n. T is just a number that is given to see if the two numbers add up to it. We are to keep it to ```\nO(n)```\n. I'm wasn't sure on how to do this properly.\n\nThe way that I suggested was to take ```\nA[i] + A[j] > T```\n if it wasn't then ```\nA[i + 1] + A[j + 1]```\n until you found an answer that was greater than T. Once you found that it was greater than T you would go from A[0] to A[j-1] and see if it matches any of the cases. I don't think my idea is O(n) though. Any thoughts?\n    ", "Answer": "\r\nThe idea is that for each big value of A[i] starting at the end of the list, you will search for the smaller value of j such that A[i]+A[j]=T, if such a j exists.  If the array were unordered, this would be an O(n^2) loop nest. \n\nThe greedy part is that you never need to \"go backward\" with the value of j because the values of A are ascending.  I.e. when you decrease the value of i, all the possible correct values of j must be bigger than the current value.\n\nIn code:\n\n```\ni = n - 1;\nj = 0;\nwhile (j <= i)\n  if (A[i] + A[j] < T)\n    j++;\n  else if (A[i] + A[j] > T)\n    i--;\n  else {\n    printf(\"A[%d] + A[%d] = %d\\n\", i, j, T);\n    break;\n  }\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Output of the greedy algorithm in C doesn't give me any output [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is not reproducible or was caused by typos. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question was caused by a typo or a problem that can no longer be reproduced. While similar questions may be on-topic here, this one was resolved in a way less likely to help future readers.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm on week 2 of CS50 and am currently struggling with applying the theory to the actual work. I've been trying to do it in different ways when it gave me errors and I've come to this code.\nHowever, it isn't giving me an error code any more. Instead, there is just no output. I don't understand what I've done wrong as it makes sense in my head. What can I try next?\n```\n#include <cs50.h>\n#include <math.h>\n#include <stdio.h>\n\nint main(void) {\n    int coins_used = 0;\n    float owed_to_customer = 0.0;\n    int q = 25;\n    int d = 20;\n    int n = 5;\n    int p = 1;\n\n    do {\n        owed_to_customer = get_float(\"How much is owed?: \\n\");\n    }\n\n    while (owed_to_customer < 0);\n\n    int cents = round(owed_to_customer * 100);\n\n    while (cents > q)\n\n        coins_used = (cents / q);\n    cents = (cents % q);\n\n    if (cents == 0)\n\n        printf(\"%d\\n\", coins_used);\n\n    while (cents > d)\n\n        coins_used = coins_used + (cents / d);\n    cents = cents + (cents % d);\n\n    if (cents == 0)\n\n        printf(\"%d\\n\", coins_used);\n\n    while (cents > n)\n\n        coins_used = coins_used + (cents / n);\n    cents = cents + (cents % n);\n\n    if (cents == 0)\n        printf(\"%d\\n\", coins_used);\n\n    while (cents > p)\n\n        coins_used = coins_used + (cents / p);\n    cents = cents + (cents % p);\n\n    if (cents == 0)\n        printf(\"%d\\n\", coins_used);\n}\n```\n\n    ", "Answer": "\r\nThe while statement loops over one statement. E.g. in\n```\nwhile (cents > q)\ncoins_used = (cents / q);    <== only this statement is inside the loop\ncents = (cents % q);         <== after the loop\n```\n\ntherefore ```\ncents```\n never gets updated and the while loop runs forever!\nWhen you want to loop over several statements, you must enclose them in braces\n```\nwhile (cents > q) {\n    coins_used = (cents / q);\n    cents = (cents % q);\n}\n```\n\n\n```\nwhile (owed_to_customer < 0);\n```\n\nloops over nothing, since you have added a semicolon denoting an empty statement.\n\nThere is a visually orphaned while here\n```\ndo {\n    owed_to_customer = get_float(\"How much is owed?: \\n\");\n}\n\nwhile (owed_to_customer < 0);\n```\n\nit belongs to the do-loop. Write it like this, to make this visually apparent\n```\ndo {\n    owed_to_customer = get_float(\"How much is owed?: \\n\");\n} while (owed_to_customer < 0);\n```\n\nSee also: Use braces for the body of an if, for, or while statement.\nThe introduction says:\n\nOpening and closing braces for if, for, and while statements should always be used even if the statement's body contains only a single statement.\n[...]\nBraces improve the uniformity and readability of code. More important, when inserting an additional statement into a body containing only a single statement, it is easy to forget to add braces because the indentation gives strong (but misleading) guidance to the structure.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "find the minimum size dominating set for a tree using greedy algorithm\r\n                \r\nDominating Set (DS) := given an undirected graph G = (V;E), a set of\nvertices S  V is a dominating set if for every vertex in V , there is a vertex in\nS that is adjacent to v. Entire vertex set V is a trivial dominating set in\nany graph. \n\nFind minimum size dominating set for a tree.\n    ", "Answer": "\r\nI'll attempt to prove this in a more formal way. \n\nOUTLINE\n\nTo prove your greedy algorithm is correct, you need to prove two things: \n\n\nFirst, that your greedy choice is valid and can always be used in the formation of an optimal solution, and \nsecond, that your problem has an optimal substructure property, that is, you can form an optimal solution from optimal solutions to subproblems of your own problem.\n\n\nGreedy Choice: In your tree T = (V, E), find a vertex v in the tree with the highest number of leaves. Add it to your dominant set.\n\nOptimal Substructure\n\nT' = (V', E') such that: \n\n\nV' = V \\ ({a : a ϵ V, a is adjacent to v, and a's degree ≤ 2} ∪ {v})\nE' = E - any edge involving any of the removed vertices\n\n\nIn other words \n\nLook for a vertex with the highest number of leaves, remove any of its adjacent vertices with degree less than or equal to 2, then remove v itself, and add it to your dominant set. Repeat this until you have no vertices left.\n\n\n\nPROOF\n\nGreedy choice proof\n\nFor any leaf l, it must be that either itself or its parent is in the dominant set. In our case, the vertex v we would have chosen is in this situation. \n\nLet A = {v1 , v2 , ... , vk} be a minimum dominant set of T. If A already has v as member, we are done. If it does not, we see two situations:\n\n\nv has some neighbouring leaf l. Then,  l must be part of the dominant set, otherwise our set is not dominating the entire tree. We can simply thus form A' = {A - {l} + {v}} and still be a dominant set. Since |A'| = |A|, A' is still optimal.\nv does not have any neighbouring leaves l. Then, because v was chosen such that it has the highest number of leaves, then no vertex in T have any leaves. Then T is not a tree. Contradiction.\n\n\nThus, we will always be able to form an optimal solution with our greedy choice.\n\nOptimal Substructure proof\n\nSuppose that A is a minimum dominant set for T = (V, E), but that A' = A \\ {v} is not a minimum dominant set for T' as defined above. \n\nMake a minimum dominant set for T', call it B. As aforementioned, |B| < |A'|. It can be shown that B' = B ∪ {v} is a dominating set for T. Then, since |A'| = |A| - 1, |B'| = |B| + 1, we get |B'| < |A|. This is contradictory, since we assumed that A is an minimum independent set. Thus it must be that A' is also a minimum independent set of T'.\n\nProving B' = B ∪ {v} is a dominating set for T: \n\n\nv may have had adjacent vertices adjacent not in T'. We will show that any vertices that were not considered in T' will be dominated by vertices in B' (This means that we picked our set optimally): Let y be some vertex adjacent to v and not in T'. By definition of T', y can only have degree 1 or 2. Now, y is dominated by v. If y is a leaf, then we are done. However, if y is of degree 2, then y is connected another node which is necessarily in the dominant set of B. This is because, when we removed v to make T', the degree of y became 1, meaning that y or its parent was necessarily added to the dominant set. Hence, B' is a dominant set for T. \n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Complexity of this greedy algorithm to find the maximum independent set of a graph\r\n                \r\nWhat is the complexity for this method which finds the maximum independent set of a graph?\n\nI think it's O(|E|), is that right?\n\n```\nGreedy(G):\nS = {}\nWhile G is not empty:    Let v be a node with minimum degree in G\n    S = union(S, {v})\n    remove v and its neighbors from G\nreturn S\n```\n\n    ", "Answer": "\r\nFor starters, note that this doesn't necessarily find a maximum independent set, though it always finds a maximal independent set.\n\nAs for the time complexity - this depends on how you represent the graph and how you implement each step. Here's one way to implement this algorithm in time O(m + n).\n\nSuppose that you have the graph represented as an adjacency list. Create an array of booleans, one per node, that tracks whether the node can be added to the independent set. Initially, all of these booleans are true. Next, create an array of n buckets, initially empty. Then, iterate across the adjacency list. For each node, count up how many edges its adjacent to (its degree), then put that node into the bucket at that index. This setup takes time O(m + n) because each edge is scanned exactly once and we only need O(n) time to initialize the auxiliary structures.\n\nNow, working from left to right, scan across the buckets. For each node in the bucket, do the following. If that node's auxiliary Boolean is marked false, skip the node. Otherwise, add the node to the set, mark its Boolean false, then iterate across the adjacency list entry for the node and mark all adjacent nodes' booleans false. This simulates deleting the node and its adjacent nodes from the graph.\n\nOverall, this second step takes time O(m + n). To see this, note that it takes time O(n) to iterate across the buckets array, and across all iterations we visit every node and every edge exactly once. Therefore, this can be implemented in overall time O(m + n).\n\nAs you can see, though, it's tough to get this time bound. I'm not sure what your initial intuition was behind why this would take linear time, but I'd be careful to make sure that you didn't just directly jump from the pseudocode to linear time without thinking it through.\n\nHope this helps!\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy machine scheduling in javascript\r\n                \r\nConsider a single machine scheduling problem, where we are given a set, T, of tasks specified by their start times and finish times, as in the task scheduling problem, except now we have only one machine and we wish to maximize the number of tasks that this single machine performs. Design a greedy algorithm for this single machine scheduling problem and show that it is correct. What is the running time of this algorithm?\n\nATTEMPT\n\n```\n var machineScheduling = function(T, finish_time, i, jobs) {\n    var max_jobs = [];\n\n    (function rec(){\n        if (i < 0 || T[i-1][0] === 0) {\n            if (jobs.length > max_jobs.length) max_jobs = jobs;\n            return 0;\n        }\n\n        var new_finish_time = T[i-1][0];\n        var new_jobs = jobs.slice();\n\n        var A = rec(finish_time, i-1, new_jobs);\n        var B = 1+rec(new_finish_time, i-1, new_jobs.push(i));\n\n        return Math.max(A, B);\n    })(T, finish_time, T.length, []);\n };\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Trying to find the optimal subset for the Greedy knapsack problem(python)\r\n                \r\nI think this is the correct algorithm for finding the optimal value, but now i need to find the optimal subsets that got me that value. Help would be greatly appreciated!\n\nThese were my directions:\nImplement a greedy algorithm that arranges the items in the decreasing order of value to weight ratio (vi/wi for i = 1, 2, ..., n), then select the items in this order until the weight of the next item exceeds the remaining capacity (Note: In this greedy version, we stop right after the first item whose inclusion would exceed the knapsack capacity).\n\n```\ndef greedy_knapsack(val, weight, W, n):\n    # index = [0, 1, 2, ..., n - 1] for n items\n    index = list(range(len(val)))\n    # contains ratios of values to weight\n    ratio = [v / w for v, w in zip(val, weight)]\n    QuickSort(ratio, 0, len(ratio) - 1)\n    max_value = 0\n    for i in index:\n        if weight[i] <= W:\n            max_value += val[i]\n            W -= weight[i]\n        else:\n            max_value += val[i] * W // weight[i]\n            break\n    return max_value\n```\n\n    ", "Answer": "\r\nYour greedy approach will fail in many cases.\n\nOne such trivial case:\n\n```\nweight = [10, 10, 10]\nvalue = [5, 4, 3]\nW = 7\n```\n\n\nIn this case, your algorithm will choose (item 1) sum = 5, but the optimal answer should be (items 2 and 3), sum = 7.\n\nYou need a dynamic programming approach to solve this and you can keep a matrix to store your previous states so that you can reconstruct the solution and get the item list.\n\n```\n# Prints the items which are put in a  \n# knapsack of capacity W \ndef printknapSack(W, wt, val, n): \n    K = [[0 for w in range(W + 1)] \n            for i in range(n + 1)] \n\n    # Build table K[][] in bottom \n    # up manner \n    for i in range(n + 1): \n        for w in range(W + 1): \n            if i == 0 or w == 0: \n                K[i][w] = 0\n            elif wt[i - 1] <= w: \n                K[i][w] = max(val[i - 1]  \n                  + K[i - 1][w - wt[i - 1]], \n                               K[i - 1][w]) \n            else: \n                K[i][w] = K[i - 1][w] \n\n    # stores the result of Knapsack \n    res = K[n][W] \n    print(res) \n\n    w = W \n    for i in range(n, 0, -1): \n        if res <= 0: \n            break\n        # either the result comes from the \n        # top (K[i-1][w]) or from (val[i-1] \n        # + K[i-1] [w-wt[i-1]]) as in Knapsack \n        # table. If it comes from the latter \n        # one/ it means the item is included. \n        if res == K[i - 1][w]: \n            continue\n        else: \n\n            # This item is included. \n            print(wt[i - 1]) \n\n            # Since this weight is included \n            # its value is deducted \n            res = res - val[i - 1] \n            w = w - wt[i - 1] \n\n# Driver code \nval = [ 60, 100, 120 ] \nwt = [ 10, 20, 30 ] \nW = 50\nn = len(val) \n\nprintknapSack(W, wt, val, n) \n```\n\n\nref: https://www.geeksforgeeks.org/printing-items-01-knapsack/\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "time complexity of finding 2d peak with greedy ascent algorithm\r\n                \r\n\n\n*there are just one peak\nthe textbook im studying says the time complexity of greedy ascent algorithm is O(nm) and O(n^2) when m=n. So it means in the worst case, I have to visit all elements of the 2d array.\nBut I think that case is only when the row or column is 1, and the elements are sorted, so if I choose the minimum element I have to visit all element to get to peak.\nAt that point, I can't understand that, when n=m, the time complexity is O(n^2).\nIf n=m=1, it would take O(1), but saying that as O(n^2) is kind of meaningless.\nIn the other case where n=m and n>1 , isn't it possible to take O(n^2)?\nIf there are none of those, then isn't O(n^2) not the right complexity?\nI think O(n+m) might be the right complexity becuase the worst case is when the starting point is (0,0) and the peak is at (n,m). So to get to the peak, I have to move verticaly n time, horizentaly m time.\nWhere am I understanding wrong?\n*The point of my question is, I think defining the complexity at the case n=m as O(n^2) based on O(nm) is wrong. And the right complexity is O(n+m)=O(2n)=O(n)\n    ", "Answer": "\r\nYou can easily construct a case where you need to visit at least ```\nn*m/2```\n elements: put the maximum in the bottom-right corner, then follow a zigzagging path, putting an element slightly less than the previous on each traversed space. The path goes all the way to the left, then up two, then all the way to the right, and so on until you reach the top-left or top-right corner. Put a minimum element in all other spaces.\nFor ```\nn=m=4```\n, it looks like this:\n```\n 0  0  0  1\n 5  4  3  2\n 6  0  0  0\n 7  8  9 10\n```\n\nIf you happen to pick the ```\n1```\n, you need to go through ```\n10 > n*m/2```\n elements.\nFor ```\nn=4```\n and ```\nm=5```\n:\n```\n 1  2  3  4\n 0  0  0  5\n 9  8  7  6\n10  0  0  0\n11 12 13 14\n```\n\nHere you need to go through ```\n14 > n*m/2```\n elements.\nSo in the worst case, this is ```\nO(n*m/2) = O(nm)```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Car fueling problem with a greedy algorithmic solution is giving wrong output\r\n                \r\nI am solving a problem called Car Fueling on coursera and I followed the pseudocode that had been given. The problem states:\n\nYou are going to travel to another city that is located ```\nd```\n miles away from your home city. Your car can travel at most ```\nm```\n miles on a full tank and you start with a full tank.\nAlong your way, there are gas stations at distances stop 1, stop 2, . . . , stop ```\nn```\n from your home city. What is the minimum number of refills needed?\nInput Format.\nThe first line contains an integer ```\nd```\n.\nThe second line contains an integer ```\nm```\n.\nThe third line specifies an integer ```\nn```\n.\nFinally, the last line contains integers stop 1, stop 2, . . . , stop ```\nn```\n.\nOutput Format.\nAssuming that the distance between the cities is ```\nd```\n miles, a car can travel at most ```\nm```\n miles  on a full tank, and there are gas stations at distances stop 1, stop 2, . . . , stop ```\nn```\n along the way, output the minimum number of refills needed. Assume that the car starts with a full tank. If it is not possible to reach the destination, output ```\n−1```\n.\n\nHere is the function to solve the problem:\n```\nint compute_min_refills(int dist, int tank, vector<int> & stops) {\n    int curref=0;//current position of the car\n    int numref=0;//number of refills\n    int lastref=0;//last position of the car\n    int n=stops.size();//the amount of stops to refill at\n    while(curref<=n){\n        if(curref>=n){return -1;}\n        lastref=curref;\n        while((curref<=n) && (stops[curref+1]-stops[lastref]<=tank)){curref=curref+1;}\n\n        if(curref==lastref){return -1;}\n\n        if(curref<=n){numref=numref+1;}\n    }       \n    return numref;\n}\n```\n\nWhen I submit, it fails on the first test case, but I don't know what could be causing it to give error.\nThe test case:\n```\nInput:\n500\n200\n4\n100 200 300 400\n\nYour output:\n1\n\nCorrect output:\n2\n```\n\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Seeking maximum capacity utilization for 0-1 Multidimensional Knapsack\r\n                \r\nThe typical objective function of 0-1 Multidimensional Knapsack is to maximize the value of all items in the knapsack. A good algorithm was provided in the Stackexchange link here: 0-1 Multidimensional Knapsack.\n\nHowever, what if my objective function is to pack as many items in the knapsack as possible? All pieces have equal values. The Stackexchange post (Knapsack problem with all profits equal to 1) claims that a one dimensional knapsack with equal values can be solved by Greedy Algorithm. Is that true? I thought the 01 knapsack problem is NP-hard therefore the greedy algorithm may not give the optimum solution.  \n\nSo my questions are two-part?\n1) can optimum solution be given by greedy algorithm in this case? 01 knapsack with equal values\n2) how to implement a multi-dimensional greedy algorithm? the vi/wi is a value divided by a vector...\n    ", "Answer": "\r\n1.) The knapsack problem IS an NP-Hard problem. So in short, no, you cannot solve it optimally using a greedy algorithm. Instead heuristic approaches exist that can get you very close.\n\n2.) In the case of equal profit knapsack, this will likely to degrade to a simple bin packing problem. In this context if all choices are equal in terms of profit, you will likely need to focus on a different aspect of the problem which is probably something like \"size.\" If that is the case you will want to pick the smallest item you can each time - in which case a greedy algorithm is probably sufficient and can be achieved by simply looking through your choices and choosing the smallest element.\n\nIt should be noted that a linear search can add an annoying amount of overhead to your program if its being repeated a great deal of times. Instead you may want to consider using a MIN-Heap as this will make the smallest value available at a lower computational cost.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "what is epsilon/k how did that come in epsilon greedy algorithm\r\n                \r\nAs it was told it would choose the arm having highest emperical mean with probability 1-epsilon how did epsilon/k add to it (and also epsilon/k for random probability selection)in the equation written for probability in the page no:6 of the paperAlgorithms for multi armed bandits.What does that mean epsilon/k writing there in the equation\n    ", "Answer": "\r\nThis answer was taken from here:\n\nSuppose you are standing in front of k = 3 slot machines. Each machine pays out according to a different probability distribution, and these distributions are unknown to you. And suppose you can play a total of 100 times.\n\nYou have two goals. The first goal is to experiment with a few coins to try and determine which machine pays out the best. The second, related, goal is to get as much money as possible. The terms “explore” and “exploit” are used to indicate that you have to use some coins to explore to find the best machine, and you want to use as many coins as possible on the best machine to exploit your knowledge.\n\nEpsilon-greedy is almost too simple. As you play the machines, you keep track of the average payout of each machine. Then, you select the machine with the highest current average payout with probability = (1 – epsilon) + (epsilon / k) where epsilon is a small value like 0.10. And you select machines that don’t have the highest current payout average with probability = epsilon / k.\nIt much easier to understand with a concrete example. Suppose, after your first 12 pulls, you played machine #1 four times and won $1 two times and $0 two times. The average for machine #1 is $2/4 = $0.50.\n\nAnd suppose you’ve played machine #2 five times and won $1 three times and $0 two times. The average payout for machine #2 is $3/5 = $0.60.\n\nAnd suppose you’ve played machine #3 three times and won $1 one time and $0 two times. The average payout for machine #3 is $1/3 = $0.33.\n\nNow you have to select a machine to play on try number 13. You generate a random number p, between 0.0 and 1.0. Suppose you have set epsilon = 0.10. If p > 0.10 (which it will be 90% of the time), you select machine #2 because it has the current highest average payout. But if p < 0.10 (which it will be only 10% of the time), you select a random machine, so each machine has a 1/3 chance of being selected.\n\nNotice that machine #2 might get picked anyway because you select randomly from all machines.\n\nOver time, the best machine will be played more and more often because it will pay out more often. In short, epsilon-greedy means pick the current best option (\"greedy\") most of the time, but pick a random option with a small (epsilon) probability sometimes.\n\nThere are many other algorithms for the multi-armed bandit problem. But epsilon-greedy is incredibly simple, and often works as well as, or even better than, more sophisticated algorithms such as UCB (\"upper confidence bound\") variations.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to let the user control the number of communities generated in fast greedy community algorithm using dendplot\r\n                \r\nI am using fast greedy community algorithm to create communities. However i want an option where the user can limit the number of communities . I there an method for this. I heard this can be done through dendPlot. Need help on details\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Avoiding local optimisations in an agile project [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm very positive towards agile development, and have worked on agile projects on and off for about 13 years. But I have a concern that I've never really been able to address. It doesn't always seem to manifest, but it has bitten me a few times.\n\nAgile seems to be in some sense a 'greedy algorithm'. Start with the highest value story, optimise the system to precisely fulfil that story, and repeat.\n\nActual greedy algorithms are prone to suffering from converging to locally optimal solutions, while missing a globally optimal solution. \n\nHas this been people's experience? \n\nIs it actually a problem?\n\nIf so, what techniques do you use to avoid such local optima and yet remain agile? \n    ", "Answer": "\r\n\n  Actual greedy algorithms are prone to suffering from converging to locally optimal solutions, while missing a globally optimal solution.\n\n\nThis holds true if  EPIC technical User Story and guideline is not established, along with the normal business EPIC user story.\n\n\n  Has this been people's experience?\n\n\nAt times yes, it has been my experience. One instance was when the user stories we worked on were broken down too much, and the solution was to broaden them to get a more global outlook at our designs. And at times it was different enterprise scrum teams in the same projectt, conflicting with different technical framework uses and approaches.\n\n\n  Is it actually a problem?\n\n\nIt is only a problem, if you ignore the technical EPIC user story or guideline.\n\n\n  If so, what techniques do you use to avoid such local optima and yet remain agile?\n\n\nHere is one Agile approach to solving this:\nDuring Agile Release planning, instead of just coming up with a Business EPIC User Story, also come up with a Technical EPIC User Story. The Technical EPIC User story would have the product vision from a technical stand point, in terms of technical architecture, application framework, quality standards, and global design considerations etc. These could be broken down into smaller technical user stories, and have a Scrum Team which works on getting those user stories working. An example of a user story could be: \"As a Technical Project Manager, I want the whole enterprise project using A, B, C framework, and coding as per X,Y,Z coding standards, so that there is uniformity in project development work.\nIf you don't want to form a scrum team separately for this, then just keep them as reminder cards next to backlogs for development teams to use as guidelines.\n\nAs a testing guideline, we used to have successful integration testing as a done criteria for each backlog. A global test was conducted in an integration environment, on all working software deployed from all enterprise teams, to deem it shippable. So right from inception to end of the backlog, the theme is set for global working software and not just local working software.\n\nFinally, Agile development involves keeping a constant eye on quality, and one of the quality issues could be bad design or a too localized design. As and when this is discovered, it should be redesigned within that backlog itself, and followed going forward for other Backlogs. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Avoiding local optimisations in an agile project [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm very positive towards agile development, and have worked on agile projects on and off for about 13 years. But I have a concern that I've never really been able to address. It doesn't always seem to manifest, but it has bitten me a few times.\n\nAgile seems to be in some sense a 'greedy algorithm'. Start with the highest value story, optimise the system to precisely fulfil that story, and repeat.\n\nActual greedy algorithms are prone to suffering from converging to locally optimal solutions, while missing a globally optimal solution. \n\nHas this been people's experience? \n\nIs it actually a problem?\n\nIf so, what techniques do you use to avoid such local optima and yet remain agile? \n    ", "Answer": "\r\n\n  Actual greedy algorithms are prone to suffering from converging to locally optimal solutions, while missing a globally optimal solution.\n\n\nThis holds true if  EPIC technical User Story and guideline is not established, along with the normal business EPIC user story.\n\n\n  Has this been people's experience?\n\n\nAt times yes, it has been my experience. One instance was when the user stories we worked on were broken down too much, and the solution was to broaden them to get a more global outlook at our designs. And at times it was different enterprise scrum teams in the same projectt, conflicting with different technical framework uses and approaches.\n\n\n  Is it actually a problem?\n\n\nIt is only a problem, if you ignore the technical EPIC user story or guideline.\n\n\n  If so, what techniques do you use to avoid such local optima and yet remain agile?\n\n\nHere is one Agile approach to solving this:\nDuring Agile Release planning, instead of just coming up with a Business EPIC User Story, also come up with a Technical EPIC User Story. The Technical EPIC User story would have the product vision from a technical stand point, in terms of technical architecture, application framework, quality standards, and global design considerations etc. These could be broken down into smaller technical user stories, and have a Scrum Team which works on getting those user stories working. An example of a user story could be: \"As a Technical Project Manager, I want the whole enterprise project using A, B, C framework, and coding as per X,Y,Z coding standards, so that there is uniformity in project development work.\nIf you don't want to form a scrum team separately for this, then just keep them as reminder cards next to backlogs for development teams to use as guidelines.\n\nAs a testing guideline, we used to have successful integration testing as a done criteria for each backlog. A global test was conducted in an integration environment, on all working software deployed from all enterprise teams, to deem it shippable. So right from inception to end of the backlog, the theme is set for global working software and not just local working software.\n\nFinally, Agile development involves keeping a constant eye on quality, and one of the quality issues could be bad design or a too localized design. As and when this is discovered, it should be redesigned within that backlog itself, and followed going forward for other Backlogs. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Is this implementation of greedy Nqueens correct?\r\n                \r\nI am using this resource: https://sites.google.com/site/nqueensolver/home/algorithms/3systematic-greedy-algorithm to implement a greedy Nqueens. One thing I didn't understand is when he wrote:\n\"In my version all the queens are placed in the same row / column and if the algorithm fails to find a solution the queens are moved to the next row / column. The queens can also placed randomly but no more than one queen may occupie a line. If there are no remaining rows / columns stop.\"\nIt sounds like he is only initializing N times, once for each column. But that doesn't make sense, since he is also using an outer infinite loop.\nHere is my implementation:\n```\nPublic NQueensSolver {\n    public int[] nqueensgreedy ( int N ) {\n        int[] result = new int[N]\n        \n        while (true) {\n            int[] cols = new boolean[2 * N - 1];\n            int[] diags = new boolean[2*N - 1];\n            int[] revs = new boolean[2 * N - 1];\n\n            for ( int row = 0 ; row < N; row++) {\n                result[row] = Math.random(0,N)\n                int col = result[row]\n                mark(row, col, cols, diags, revs);\n            }\n            \n\n            int iteration = 0;\n            while (iteration++ < 15) {\n                int total_attacks = 0;\n                for (int row = 0; row < N; row++) {\n                    int min_index = 0;\n                    int min_val = 0;\n                    unmark(row, result[row], cols, diags, revs)\n                    for (int col  = 0; col < N; col++) {\n                        int attacks = getAttacks(row, col, cols, diags,                                                 revs)\n                        if ( attacks < min_val ) {\n                            min_val = attacks\n                            min_index = col\n                        }\n                    }\n                    result[row] = min_index\n                    total_attacks += min_value\n                    mark(row, col, cols, diags, revs)\n                }\n                \n                if (total_attacks = 0) return result;\n            }\n        }\n        \n        \n        throw Exception(“No solution”)\n        \n    }\n\n    private int getAttacks ( int row, int col, int[] cols, int[] diags, int[] revs )\n        return cols[col] + diags[row+col] + revs[col-row + N - 1];\n\n    private mark(int row, int col, int[] cols, int[] diags, int[] revs)\n        cols[col] += 1;\n        diags[row + col] += 1\n        revs[col - row + N - 1] += 1\n\n    private unmark(int row, int col, int[] cols, int[] diags, int[] revs)\n        cols[col] -= 1;\n        diags[row + col] -= 1\n        revs[col - row + N - 1] -= 1\n\n}\n```\n\nEdit: I fixed the mistakes noted in the comments (thank you). Please ignore any missing semi-colons or curly braces. I trust that you can understand via indents and newlines. This is more pseudocode even though it is closest syntactically to java.\nI hope that future feedback is more related to the conceptual question referenced in the link rather than comments about syntax.\nThank you.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Best First Search Algorithm, how to compute the length of its traverse?\r\n                \r\nI have this problem that I am working on that has to do with the greedy best first search algorithm. However I am bit stuck on computing the length of the traverse when it comes to points (x, y). For example lets say I have these points:\n(0, 1), (0, 2), (1, 2), (1, 3). So what I did is draw out a diagram on the x, y plane:\n\n\nNow knowing the GBF algorithm, it goes to check the closet node and so in this case the transverse would look like so: (0, 1)->(0, 2)->(1, 2)->(1, 3). So now in order to compute the length of the points connections done by the GBF, do I need to basically add up the path, which in this case would be three? Any clarifications would be helpful.\n    ", "Answer": "\r\nThe first part is to find the best way to store the graph using appropriate data structure. \n\nSay the graph looks like this now. \n\n```\n         (1,3)P4\n           |\nP2(0,2)--(1,2)P3\n  |\n(0,1)P1\n  |\n(0,0)P0 \n```\n\n\nOne way to represent this graph would using Adjacency List. Like this\n\n```\nP0 => P1\nP1 => P2\nP2 => P3\nP3 => P4\n```\n\n\nNow using Breath first Search the distance between two points can be calculated in linear time. The distance between two nodes(points) with the path length being the number edges.\n\nExplanation for BFS can be found here \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Best First Search and Depth First Search\r\n                \r\nIs it possible for Greedy Best First Search to behave like Depth First Search in any case? \n\nI see that worst case of both of these algorithms is similar O(b^m). Does this mean that they behave in same way? \n    ", "Answer": "\r\n\n  Is it possible for Greedy Best First Search to behave like Depth First Search in any case?\n\n\nNo. If it did, it would be Depth First Search.\n\n\n  I see that worst case of both of these algorithms is similar O(b^m). Does this mean that they behave in same way?\n\n\nNo.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Vertex Cover on Bipartite Graphs\r\n                \r\nI have the following problem. All suggestions appreciated.\n\nGiven a set of questions Q and subjects S, select q questions such that all subjects S are covered. A question might cover multiple subjects. \n\nI built a greedy algorithm over SQL Server. I pick the first question associated with the subject s1 and remove all other subjects that are covered by it. I continue and see if there is a solution.\n\nHere's the catch. Now I want to improve my algorithm and create question sets that are still covering the subjects but are not similar to each other more than 50%. \n\nAny advice on the formal name of this problem. Any algorithms. Should this problem be solved for all sets together, or can it be solved one set at a time.  \n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Disjoint set as greedy solution\r\n                \r\nFor scheduling jobs with given deadlines and profits on prompt completion,a greedy algorithm is suggested to maximize profits from all feasible sets of task.\n\nHowever,the programmatic implementation recommended is disjoint set forests. \n\nI have not been able to find any literature which demonstrates this implementation(easy enough for a non computer science/mathematical background). \n\nAny reference to such a programming language agnostic implementation would be appreciated.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "A greedy algorithm about assigning time to tasks to Maximize the total time\r\n                \r\nI'm given a number of tasks, each of them has a start time and an end time. I should arrange my day to do them.\n\nRequirements are:\n\n\nCan't do more than one tasks at any time.\nCan't divide tasks\nMaximize the total working time\n\n\nMy solution to this is:\n\n\nRank all tasks by their number of overlaps with all others from the least to most.\nSelect the tasks from the left to right in the above ranked list to do. Make sure that any tasks to choose don't have overlaps with tasks that have been chosen.\nCalculate the time.\n\n\nIs this correct? I can't prove it. Does anyone have better idea?\n    ", "Answer": "\r\nThe Activity Selection problem maximises the total number of tasks using a greedy algorithm.\n\nHowever, your problem is slightly different as you wish to maximise the total time.\n\nYou can solve this by solving the shortest path problem in a graph where you have a node for each task.\n\nMake edges from task A to task B if A finishes before B, and set the weight on the edge to the amount of time between the end of A and the start of B.\n\nMake an extra start node that connects to all tasks (with weight equal to the start time of the task), and an extra end node that all tasks connect to (with weight equal to the time between the end of the task and the end of the day).\n\nNote that the weight on each edge corresponds to the amount of time you waste not working if you use that edge.\n\nComputing the shortest path on this graph (e.g. with Dijkstra's algorithm) will tell you the tasks to do with minimum wasted time - which is the same as maximising the work time.\n\nExample\n\n\n\nIn this graph the shortest path is Start->A->C->End with weight 3, corresponding to doing job A followed by job C, and only wasting 3 hours not working.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Prove that a greedy algorithm for finding minimum spanning tree will definitely stop\r\n                \r\nThis is an algorithm for finding a minimum spanning tree in a connected \nUN-directed  graph G=(V,E):\n\n\n\n\nInitialization:  B = ∅ - The group of edges that will be built by the algorithm\nwhile |B| < |V| - 1 do:\n\na. choose some cut in the graph (S,V\\S) which there isn't an edge e belongs to B that cross it.\n\nb. find the lightest edge crossing that cut.\n\nc. add it to the group B.\n B = B ∪ {e}.\nreturn T = (V,B)\n\n\n\n\nThe meaning of cut is described in the attached image:\nCut's meaning \nthe vertices s,u are in one group we can call S.\n\nall the other vertices are in the group V\\S.\n\nso this is the meaning of (S,V\\S) as a cut.\nalso - the edge (u,w) is a crossing edge\n(u,v) is the lightest crossing edge in that specific cut. \n(s,u) is not a \"crossing\" edge\n\nI need to prove that the algorithm will stop eventually. That |B| = |V| - 1\nat some point.\n\nI can use the following say in the proof: \n\n'In any point of the algorithm, there exist a minimum spanning tree T=(V,Et)\nof G that contains the group of edges B that were chosen by the algorithm.'\n\nassuming I already proved that, I need to somehow show that there's is always some cut in the graph that none of his crossing edges been added to B yet.\nwhile |B|<|V|-1 .\nbut I'm not sure how to do that\n    ", "Answer": "\r\nLet us assume that there is no such cut and |B| < |V| - 1. As the tree is connected, this means that all the vertices are connected by some edge in B (Because if a vertex is not connected, there will be a cut in which no edge belongs to B separating that vertex and the spanning tree)\n\nAs, |V| vertices need at least |V| - 1 edges to be connected, we infer that |B| >=  |V| - 1, thus contradicting our assumption.\n\nHence Proved.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Hitting Objects Algorithm\r\n                \r\nI'm trying to find a proper algorithm for this problem\nGiven the blow points\n\nThe target is find the least number of lines to be drawn\nExample result\n\nI googled and some algorithms poped up such as Greedy algorithm, approximation algorithm but I'm sure how they're fit to this problem.\nAny suggestions is highly appreciated.\nThank you for your time.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Incompatible operand types String[] to int\r\n                \r\nIncompatible operand types String[] to int. I added divide and conquer algorithm to my project but I don't know is it good entegration? My project related about the finding the shortest way to x-y coordinate for cities and this project can be related about 3 algorithms for instance; divide and conquer strategy \ngreedy algorithm \nnearest neighbor algorithm\n\n```\npackage formalProject;\n\nimport java.io.*;\nimport java.io.FileNotFoundException;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main (String[] args) throws FileNotFoundException{\n\n        String[][] cities = readArray(\"att48_xy.txt\");\n\n        //printing cities 2d array \n        for(int i = 0; i < cities.length ; i++){\n            System.out.println(cities[i][0] + \" \" + cities[i][1]);\n        }\n\n    }\n\n    public static String[][] readArray(String file) throws FileNotFoundException{\n        //we'll count how many elements are there?\n\n        int counter = 0; //counter for calculating text's row length   \n\n         Scanner sc1 = new Scanner(new File(file)); //scanner for calculating text's row length  \n            while(sc1.hasNextLine()){ //checks for if there is any line \n                counter++; \n                sc1.nextLine();//jumps to next line\n            }\n            String[][] cities = new String[counter][2]; //creating our cities array with \n                                                     //rows as \"counter\" and columns as 2(X, Y)     \n\n            Scanner sc2 = new Scanner(new File(file)); //scanner for getting values from text\n\n            int i = 0;\n            while(sc2.hasNext()) {\n\n                    String tempX = sc2.next();//first next will be X coordinate\n                    String tempY = sc2.next();//second next will be Y coordinate\n                    cities[i][0] = tempX;\n                    cities[i][1] = tempY;\n                    i++;\n            }\n            return cities; //returns our 2d array     \n    }\n\n    public static int cities1 (String[][] cities){\n\n        if(cities.length==0 || cities.length==1){\n\n            return 0;\n        }\n            else{\n                return cities(cities,1,cities.length);\n        }\n    }\n\n    public static int cities(String[][] cities,int i,int f){\n\n        int m,result,sx,dx;\n\n        if(i>=f){\n            return 0;\n        }\n\n        else{\n            m=(i+f)/2;\n            sx=cities(cities,i,m);\n            dx=cities(cities,m+1,f);\n            result=sx+dx;\n            if((cities[m]==cities[m+1])&&(cities[m]==0)) //problem is here \n                    result++;\n            return result;\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\ncities[m] is an array.  I think you possibly want cities[m].length here.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "CS50 Pset1 cash code not working properly\r\n                \r\nSo I just started with the cs50 course and I'm doing the 1 problem set with greedy algorithms. When I run the program it will ask the question right, when I answer it doesn't give output. I can't tell what's wrong.\nHere's the code\n```\n#include <stdio.h>\n#include <cs50.h>\n#include <math.h>\n\nint main (void)\n\n{\n\nfloat n;\nint cents;\nint coins = 0;\n\n// Prompt user for amount owed\n     do\n     {\n        n = get_float(\"Change owed?:\");\n     }\n     while (n < 0);\n\n// convert input into cents\n     cents = round(n * 100);\n\n//loop for minimum coins\n    while (cents >= 25)\n{\n    cents = cents - 25;\n    coins++;\n}\n    while (cents >= 10)\n{\n    cents = cents - 10;\n    coins++;\n}\n    while (cents >= 5)\n{\n    cents = cents - 5;\n    coins++;\n}\n    while (cents >= 1)\n{\n    cents = cents - 1;\n    coins++;\n//Print number of coins\nprintf(\"%i\\n\", coins);\n}\n}\n```\n\n    ", "Answer": "\r\nYou have your print method inside a while-loop, which if its condition evaluates to false, won't execute its body.\nWhat happened is that nothing would get printed, unless ```\ncents```\n would be greater or equal to 1 when reaching your last while-loop.\nChange this:\n```\nwhile (cents >= 1)\n{\n    cents = cents - 1;\n    coins++;\n    //Print number of coins\n    printf(\"%i\\n\", coins);\n}\n```\n\nto this:\n```\nwhile (cents >= 1)\n{\n    cents = cents - 1;\n    coins++;\n}\n//Print number of coins\nprintf(\"%i\\n\", coins);\n```\n\nWith this change, the print method will execute, regardless of whether the code flow enters the last while-loop or not.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "cs50 cash not returning desired output\r\n                \r\ncs50 greedy algorithm description\nThis is my code for the cs50 greedy algorithm. However, it doesn't output any answer. When I change float dollars to int dollars it works, but only for integers greater or equal to 1. For numbers like 0.32, it returns 0. How do I get my code to work for floats? Any help is appreciated.\n```\n#include <stdio.h>\n#include <cs50.h>\n#include <math.h>\nint main(void)\n{\n    float dollars;\n    int quarter = 25;\n    int dime = 10;\n    int nickel = 5;\n    int penny = 1;\n    do {\n          dollars = get_float(\"Change owed: \");\n    } while(dollars <= 0);\n\n    //convert dollars to cents\n    int cents = round(dollars * 100);\n    int coins = 0;\n\n    while(cents >= quarter) \n    {\n         cents -= quarter; //cents = cents - 25;\n         coins++;\n    }\n    while(cents >= dime) {\n        cents -= dime;\n        coins++;\n    }\n    while(cents >= nickel) \n    {\n        cents -= nickel;\n        coins++;\n    }\n    while(cents >= penny) \n    {\n        cents -= penny;\n        coins++;\n    }\n    printf(\"%i\\n\", coins);\n}\n```\n\n    ", "Answer": "\r\n```\n#include <stdio.h>\n\n#include <math.h>\n\n#include <cs50.h>\n\nfloat dollars;\nint coins = 0;\n\nint main(void)\n{\n    //Prompt user for Cash owed and keep doing it until a positive number received\n    do\n    {\n        dollars = get_float(\"Cash owed: \");\n    }\n    while (dollars <= 0);\n\n    //Round the cents to the nearest penny\n    int cents = round(dollars * 100);\n\n    //Iterate deducting the values from the bigger to the smaller\n    while (cents > 0)\n    {\n        if (cents >= 25)\n        {\n            cents -= 25;\n        }\n        else if (cents >= 10)\n        {\n            cents -= 10;\n        }\n        else if (cents >= 5)\n        {\n            cents -= 5;\n        }\n        else\n        {\n            cents --;\n        }\n        coins++;\n    }\n    //Print the minimal amount of coins\n    printf(\"%i\\n\", coins);\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Interval Partitioning by Finish Time?\r\n                \r\nGiven ```\nn```\n lectures, each with start time and finish time, the problem is to assign all the lectures to rooms such that no two lectures occur at the same time in the same room. It is easy to design a greedy algorithm that sorts lectures by start time to minimize the number of rooms used. What if we process lectures by their finish time? Does the greedy algorithm still work? I tried a few examples, and did not find a counter example yet. \n\nGreedy algorithm by Start Time\n\n\nSort all the lectures by start time in ascending order\nPlace all the used rooms in a priority queue. The priority of a room is based on the finish time of last lecture scheduled in the room.\nAssign each lecture to the first available room in the queue. A room is available if the finish time of last lecture scheduled in the room is less than the start time of the current lecture (no overlap).\nIf none of rooms in the queue is available, add a new room, and insert the lecture into the new room.\n\n\nThe above greedy algorithm works. What if we change step 1, sort lectures by finish time, and keep other steps the same? Does it still work?\n\nIf we sort lectures by finish time in descending order, that is, we would process the last lecture first, that is a symmetric of the above greedy algorithm, I believe it definitely works.\n\nBut my question is, we sort lectures by finish time in ascending order, apply the greedy algorithm, does it work?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How come this greedy algorithm does not compute the correct amount of coins?\r\n                \r\nFor some inputted values, my function computes the correct amount of coins. But for most, it's completely off. My code seems simple, but I'm still confused on what's causing the multiple errors. Below is the JavaScript code, but this is the jsbin for the entire project (html, css, and javascript).\n```\nfunction calculateCents(){\n    var amount = document.getElementById(\"centsInput\").value;\n\n    var numberOfQuarters = 0\n    while (amount >= 0.25) {\n        numberOfQuarters++;\n        amount = amount - numberOfQuarters * 0.25;\n    } \n\n    var numberOfDimes = 0\n    while (amount >= 0.1) {\n        numberOfDimes++;\n        amount = amount - numberOfDimes * 0.1;\n    } \n\n    var numberOfNickels = 0\n    while (amount >= 0.05) {\n        numberOfNickels++;\n        amount = amount - numberOfNickels * 0.05;\n    } \n\n    var numberOfPennies = 0\n    while (amount >= 0.01) {\n        numberOfPennies++;\n        amount = amount - numberOfPennies * 0.1;\n    } \n\n\n\n    document.write(\n    `It takes ` + numberOfQuarters + ` quarters, ` + numberOfDimes + ` dimes, ` + numberOfNickels + ` nickels, and ` + numberOfPennies + ` pennies.`\n    );\n}\n```\n\n    ", "Answer": "\r\nLets look at the following snippet\n```\n    while (amount >= 0.25) {\n        numberOfQuarters++;\n        amount = amount - numberOfQuarters * 0.25;\n    } \n```\n\nLets say amount is $2. In the first iteration you will increase ```\nnumberOfQuarters```\n by one so numberOfQuarters = 1 and then subtract ```\n1 * 0.25```\n from amount, resulting in amount = 1.75.\nin the next iteration, numberOfQuarters = 2, and then you will subtract ```\n2 * 0.25```\n from amount resulting in amount = 1.25, which is wrong.\nI guess this should be enough to point you in right direction.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How can I build a max heap java class for an object?\r\n                \r\nI am trying to build a max heap java class for item objects, so I can solve the knapsack problem and implement greedy algorithms to do so. Item class includes weight, value, Id(to distinguish items), and most importantly a priority factor:\n```\npublic class Items {\n    double weight;\n    double value;\n    double priorityFactor; \n    int ID; \n    \n    //constructor for items class\n     public Items(int weight, int value, int id, int priorityFactor)  \n        {\n            this.weight=weight;\n            this.value=value;\n            this.ID=id;\n            this.priorityFactor = priorityFactor;\n        } //end constructor \n```\n\nNow the issue that I'm facing is in the max heap class, which is supposed to build me a max heap tree based on the priority factor. Means that I should have an array of item objects: private Items[] array\nWhat I'm finding difficult to implement is how can I insert those items in the array based on the priority factor. If I do this, I think I will be able to implement the greedy algorithms. How to handle this?\n    ", "Answer": "\r\nThis is the basic code for a min/max heap (depending on the ```\nT:compareTo()```\n method).\nThis only handles insertion, but I think it's what you're after.\n```\npackage jc.lib.container.collection.set;\n\nimport jc.lib.lang.string.JcStringBuilder;\n\n\n\npublic class JcHeap<T extends Comparable<T>> {\n    \n    \n    \n    private T[] mItems;\n    private int mItemCount  = 0;\n    \n    \n    \n    @SuppressWarnings(\"unchecked\") public JcHeap(final int pStartCapacity) {\n        mItems = (T[]) new Comparable[pStartCapacity];\n    }\n    \n    \n    \n    private void checkResize() {\n        if (mItems.length <= mItemCount) {\n            final int newSize = (mItems.length) * 2;\n            @SuppressWarnings(\"unchecked\") final T[] tmp = (T[]) new Comparable[newSize];\n            if (mItems != null) System.arraycopy(mItems, 0, tmp, 0, mItemCount);\n            mItems = tmp;\n        }\n    }\n    \n    static private int getParentIndex(final int pCurrentIndex) {\n        return (pCurrentIndex - 1) / 2;\n    }\n    @SuppressWarnings(\"unused\") static private int getLeftChildIndex(final int pCurrentIndex) {\n        return 2 * pCurrentIndex + 1;\n    }\n    @SuppressWarnings(\"unused\") static private int getRightChildIndex(final int pCurrentIndex) {\n        return 2 * pCurrentIndex + 2;\n    }\n    \n    \n    \n    public void addItem(final T pItem) {\n        checkResize();\n        \n        // insert\n        System.out.println(\"\\nInserting \" + pItem);\n        T current = pItem;\n        int currentIndex = mItemCount;\n        mItems[currentIndex] = current;\n        ++mItemCount;\n        \n        // sort\n        while (true) { // swap up\n            if (currentIndex <= 0) break;\n            final int parentIndex = getParentIndex(currentIndex);\n            final T parent = mItems[parentIndex];\n            System.out.print(\"Checking cur:\" + current + \" vs par:\" + parent + \" => \" + current.compareTo(parent) + \"/\");\n            if (current.compareTo(parent) >= 0) {\n                System.out.println(\"break\");\n                break;\n            }\n            System.out.println(\"swap\");\n\n            System.out.println(\"Swapping with parent: \" + parent);\n            final T tmp = mItems[parentIndex];\n            mItems[parentIndex] = mItems[currentIndex];\n            mItems[currentIndex] = tmp;\n            currentIndex = parentIndex;\n            current = mItems[currentIndex];\n        }\n    }\n    \n    //  public boolean contains(final T pItem) {\n    //      final int index = findIndex(pItem);\n    //      return 0 <= index && index < mItemCount;\n    //  }\n    //\n    //  public int findIndex(final T pItem) {\n    //      int index = 0;\n    //      int width = mItemCount;\n    //\n    //      while (true) {\n    //          System.out.println(\"Comparing with index \" + index);\n    //          final int cmp = pItem.compareTo(mItems[index]);\n    //          if (cmp == 0) return index;\n    //          else if (cmp > 0) return -1;\n    //\n    //          index += mItemCount;\n    //          width /= 2;\n    //          if (width == 0) return -1;\n    //      }\n    //  }\n    \n    \n    \n    @Override public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"\\nTree View:\\n\");\n        int height = (int) (Math.log(mItemCount) / Math.log(2));\n        sb.append(\"count=\" + mItemCount + \" height=\" + height);\n        int next = 1;\n        sb.append(\"\\n[\");\n        sb.append(JcStringBuilder.buildFromArray(\", \", (Object[]) mItems));\n        //      for (int c = 0; c < mItemCount; c++) {\n        //          sb.append(\"\\n\" + mItems);\n        //      }\n        sb.append(\"]\");\n\n        for (int c = 0; c < mItemCount; c++) {\n            if (c + 2 > next) {\n                sb.append(\"\\n\");\n                for (int d = 0; d < height; d++) {\n                    sb.append(\"\\t\");\n                }\n                height -= 1;\n                next *= 2;\n                //              System.out.println(\"Next is \" + next);\n            }\n            \n            sb.append(\"<\" + mItems[c] + \">\\t\");\n        }\n        \n        return sb.toString() + \"\\n\";\n    }\n    \n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Algorithm to find fewest number of tags that encompass all items?\r\n                \r\nI'm thinking this might be NP-complete, but I'll ask anyway. Greedy algorithms don't seem to work in my head.\n\nGiven a set of items, each with 1 or more tags, I want to find the smallest set of tags that cover all the items.\n\nEdit: See my \"solution\" here.\n    ", "Answer": "\r\nThis is the Set Cover problem, which is NP-complete.  Each tag defines a subset\nof your list of items, and you want to find the minimum number of subsets (tags) whose union equals the full list of items.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "An example of an input to the set cover problem which does not provide a 2-approximation\r\n                \r\nI need some help with the following question:\n\nShow an example of an input to the set cover problem for which the greedy algorithm shown in class does not provide a 2-approximation.\n\nThe greedy algorithm:\n\nX - a finite set\n\nF - family of subsets of X such that the union gives X\n\nC - the desired set of minimal size which covers X.\n\n\n    ", "Answer": "\r\nThere is a ```\n3/2```\n approximation example in the wikipedia page presenting the greedy algorithm for the set cover problem.\nWe can see two groups of sets composing ```\nF```\n. 2 sets (the 'lines'), forming a partition, each of them with half of the 'points'. And 3 other sets (the 'rectangles'), forming another partition, with resp. 2, 4 and 8 points.\nThe greedy algorithm will choose the 'rectangles' since it starts with the largest set of ```\nF```\n.\nIt is possible to adapt this scheme to make a 'worse' approximation, to 'trick' the greedy algorithm.\nRecipe: draw the same figure, but with a 31 x 2 grid instead of a 7 x 2. Keep the two lines with half the points in each (still forming a partition), and add two 'rectangles' (the two biggest, they will have resp. 16 and 32 'points') on the right side.\nThe greedy algorithm will return the 5 'rectangles', while the optimal solution will consist of the two lines, so an approximation of ```\n5/2 > 2```\n.  \n\nNote that this process can be extended infinitly (with a ```\n(2^n)-1 per 2```\n grid), so you can prove that the greedy algorithm for the set cover is not a ```\nk```\n-approximaation, for any number ```\nk```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Find local shortest path with greedy best first search algorithm\r\n                \r\nRecently I took a test in the theory of algorithms. I had a normal best first search algorithm (code below).\n```\nfrom queue import PriorityQueue\n\n# Filling adjacency matrix with empty arrays\nvertices = 14\ngraph = [[] for i in range(vertices)]\n\n\n# Function for adding edges to graph\ndef add_edge(x, y, cost):\n    graph[x].append((y, cost))\n    graph[y].append((x, cost))\n\n\n# Function For Implementing Best First Search\n# Gives output path having the lowest cost\ndef best_first_search(source, target, vertices):\n    visited = [0] * vertices\n    pq = PriorityQueue()\n    pq.put((0, source))\n    print(\"Path: \")\n    while not pq.empty():\n        u = pq.get()[1]\n        # Displaying the path having the lowest cost\n        print(u, end=\" \")\n        if u == target:\n            break\n\n        for v, c in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                pq.put((c, v))\n    print()\n\n\nif __name__ == '__main__':\n    # The nodes shown in above example(by alphabets) are\n    # implemented using integers add_edge(x,y,cost);\n    add_edge(0, 1, 1)\n    add_edge(0, 2, 8)\n    add_edge(1, 2, 12)\n    add_edge(1, 4, 13)\n    add_edge(2, 3, 6)\n    add_edge(4, 3, 3)\n\n    source = 0\n    target = 2\n    best_first_search(source, target, vertices)\n\n```\n\nHe brings out ```\nPath: 0 1 0 2```\n (path sum — 8), it's correct.\nMy teacher suggested that I remake the code so that it looks for the local minimum path, i.e. ```\nPath: 0 1 2```\n (path sum — 13).\nI need greedily take the shortest edge from the current node to an unvisited node and I don't really understand how to do it right.\n    ", "Answer": "\r\nSince this is homework, I won't spell out the entire code for you.\nFor best-first search, you don't need a priority queue. You just need to track which nodes you have visited, and which node you are currently at. While your current node is not the target node, find the shortest edge that leads to an unvisited node, and set your current node to the node at the other end of that edge.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "error: passing 'float' to parameter of incompatible type 'const char *'\r\n                \r\nI'm working on a greedy algorithm where I am getting an error while converting float to int \n\n```\n#include <cs50.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    float n;\n    //checking if given input is valid or not\n    do\n    {\n        n = get_float();\n    }\n    while(n<0);\n    //converting dollar into cents\n    float coins = n * 100;\n\n     int x = atoi(coins) //getting error here???\n\n....\n}\n```\n\n    ", "Answer": "\r\nThe ```\natoi```\n function is used to convert a string into an integer.  It expects a ```\nchar *```\n as an argument which points to a string.\n\nYou don't need a conversion function here.  You can assign a ```\nfloat```\n value directly to an ```\nint```\n, and any fractional part will be truncated.\n\n```\nint x = coins;\n```\n\n\nNote however that this can invoke undefined behavior if the truncated value of ```\ncoins```\n is outside the range of an ```\nint```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Car Fueling Problem (Greedy Algorithm), Nested while loop with O(n) complexity\r\n                \r\nInput\n\n(1) the maximum distance that a car can travel with a full tank: L km;\n(2) an integer array, [0, x1, x2, …, xn, xn+1], each integer represents the distance between a location and a source point A. The first integer is 0, which is the distance between A and A. The second distance x1, represents the distance between the first gas station and A. There are n gas stations between A and B (the destination). xn is the distance between the last gas station and A, and xn+1 is the distance between B and A.\n(3) n, which is the number of gas stations.\n\nOutput\n\nThe minimum number of refills to get from A to B\n\nCode\n```\nnumRefills = 0\ncurrentPosition = 0\n\nwhile(currentPosition <= n){\n    lastPosition = currentPosition\n\n    while(currentPosition <= n  &&  x[currentPosition + 1] – x[lastPosition] <= L) {\n    currentPosition++;\n    }\n\n    if (currentPosition == lastPosition) return IMPOSSIBLE; \n    if (currentPosition <= n) numRefills ++;\n}\n\nreturn numRefills\n```\n\nMy doubts are:\n\n\nWhy is the time-complexity of the above code is O(n)? shouldn't it be O(n^2) at least because of nested while loops?\nHow to prove that \"Refilling at farthest reachable gas\" is a safe move?\nAre there any alternatives to writing the same code but using for loop?\n\n\n(In short, I understood the logic but I am not able to compute it)\nAny resources/help/hint/guidance is greatly appreciated!\n    ", "Answer": "\r\nDoubt 1:\nTime complexity is calculated according to number of operation executed. Its not matter how many nested loop in there...\nYour first while loop executed until ```\ncurrentPosition <= n```\n and nested while loop executed until ```\ncurrentPosition <= n  &&  x[currentPosition + 1] – x[lastPosition] <= L```\n.. In this loop you increases ```\ncurrentPostion```\n. So there is no possibility your total operation exceed ```\nn```\n times.\nExample:\n```\narray[0, 10, 20, 30]```\n and ```\nL = 50```\n..\nFor this case your first while loop true for 1st step.. You nested loop true for 4 steps. Then at 2nd step your first while loop false... So there executed N step...\nThats why your code complexiy : ```\nO ( N )```\n...\nDoubt 2:\nTo minimize refill , you need to go far as you can with current fuel.If you cross ```\nk```\n station with current fuel then there is no need to fill tank at ```\n1 to k-1```\n stations..At every station u need to check, is it possible to go next station with current fuel. If you can go from current station to next station with current fuel, then refill tank at current station is redundant.\nDoubt 3:\nThere is many ways to solve a problem... Here is another one:\n```\nnumRefills = 0\ncurrentPosition = 0\ncurrentFuel = L\nwhile(currentPosition <= n){\n   if (currentFuel <= x[currentPosition+1] - x[currentPosition]) {\n      currentFuel = L;\n      numRefills++;\n   }\n   currentFuel -= (x[currentPosition+1] - x[currentPostion]);\n   if ( currentFuel < 0 ) \n      return Impossible;\n   currentPosition++;\n}\n\nreturn numRefills\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Comparison between two algorithms solving fractional knapsack\r\n                \r\nI have written the fractional knapsack problem with two algorithms (Greedy and dynamic programming algorithm) and I have to make  a comparison between them ..  I only made a comparison in terms of time and space complexity .. I have no idea about  what additional factors can be used for making comparison between the two algorithms..\nI hope that anyone could help me and provides me with any idea .\n    ", "Answer": "\r\nAlthough the question is a bit broadly asked, different criteria for comparison might include:\n\n\nactual running time vs. instance quality, i.e. relative gap to an optimal solution\nimplementation difficulty\n\n\nAs practical evaluation of algorithms is an involved subject, I suggest reading A Theoretician's Guide to the Experimental Analysis of Algorithms by Johnson to avoid some common pitfalls and misconceptions.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy algorithm for dividing a region of numbers into partitions with the most equal sum?\r\n                \r\nSay we have a number sequence, and we have X sections to divide this into:\n\n1, 4, 7, 9, 3, 11, 10\n\nIf we had 3 sections, the optimal answer would be:\n\n[1, 4, 7][9, 3][11, 10]\nor\n[1, 4, 7, 9][3, 11][10]\n\nSince the largest sum = 21. This is the best case. (I think, I did it by hand).\n\nWe want each section to be as equal as possible. How can this be done? My first attempt at an algorithm was to find the highest X values (9, 11, 10), and base the regions off of that. That does not work in an example like below, since one of the regions will NOT contain one of the highest values in the set:\n\n3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, \n\nAgain with X=3 sections, optimal answer:\n\n[3, 2][2, 1, 1, 1][1, 1, 1, 1, 1]\n\nOf course I could brute force every possible combination, but there is a much more efficient way of doing this. But I'm having trouble finding it.\n    ", "Answer": "\r\nThis is exactly the linear partition problem as @rta3tayt32yaa32y says. \n\nIf you really mean a greedy algorithm as your subject says, which will be an approximation, then just divide the sum of elements by X. Call this D.  Maintain an accumulated sum as you work from beginning to end of the list. Every time the sum reaches D or more, make the previous elements a section, delete them, and restart the sum.  If the sequence is 1, 4, 7, 9, 3, 11, 10, the sum is 45. For X=3, we have D=15.  So the first section is [1, 4, 7] because adding 9 would make the sum 21.  The next is [9, 3] because adding 11 would make the sum 22.  This leaves [11,10] for the last.  \n\nTo find the exact answer, you need a dynamic program.  This has already been extensively discussed here so I won't repeat that.  The question is rather confused, but the answer of @Óscar López is very good.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to go about proving a condition for the greedy change-making algorithm\r\n                \r\nRecently I've been practicing a few change making algorithm questions and came across two conditions where we were tasked with finding out if the algorithms would produce an optimal solution for coins of each of the following denomination types for each condition. Following are the two separate conditions\n\nHow would we go about solving these two questions?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Return keys when solving Set Cover problem with a dictionary and the greedy algorithm\r\n                \r\nI have a set cover problem to solve where I would like to have the names of the sets returned to me. I figure a good way to store the named sets is in a dictionary.\nI found this blog which implements the algorithm but uses a list of sets and I am trying to modify the code to accommodate a dictionary.\n```\ndef set_cover2(universe, subsets):\n    \"\"\"Find a family of subsets that covers the universal set\"\"\"\n    elements = set(e for s in subsets for e in subsets[s])\n    # Check the subsets cover the universe\n    if elements != universe:\n        return None\n    covered = set()\n    cover = []\n    # Greedily add the subsets with the most uncovered points\n    while covered != elements:\n        subset = max(subsets.values(), key=lambda s: len(s - covered))\n        cover.append(subset)\n        covered |= subset\n\n    return cover\n```\n\nThis returns the sets as a list:\n```\nuniverse = set(range(1, 11))\nsubsets = {\"s1\":set([1, 2, 3, 8, 9, 10]),\n           \"s2\":set([1, 2, 3, 4, 5]),\n           \"s3\":set([4, 5, 7]),\n           \"s4\":set([5, 6, 7]),\n           \"s5\":set([6, 7, 8, 9, 10])}\n\n\ncover = set_cover2(universe, subsets)\nprint(cover)\n```\n\ni.e.\n```\n[{1, 2, 3, 8, 9, 10}, {4, 5, 7}, {5, 6, 7}]\n```\n\nbut not the names.\nTo get the names I cannot use the values of the sets to identify the names as in my actual data some subsets may be the same (well i guess in that case either would do just as well). Regardless I would like a solution which returns the names of each set selected.\nI imagine this must be possible by modifying the ```\nsubset = max(subsets.values(), key=lambda s: len(s - covered))```\n line but I am not sure how to get the name of the set selected from this operation while retaining the set for the algorithm. How can I do this?\nDesired output:\n```\n[\"s1\", \"s3\", \"s4\"]\n```\n\n    ", "Answer": "\r\nsee the comments:\n```\ndef set_cover2(universe, subsets):\n    \"\"\"Find a family of subsets that covers the universal set\"\"\"\n    # cosmetic change: same thing, just looks a bit nicer\n    elements = set().union(*subsets.values())\n\n    # ... some code here ...\n  \n    while covered != elements:\n        # Use keys, account for this in the key function\n        subset = max(subsets.keys(), key=lambda s: len(subsets[s] - covered))\n        cover.append(subset)\n        # since subset is a key now, change here as well\n        covered |= subsets[subset]\n\n    return cover\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Huffman Coding Algorithm(Priority queue vs Sorted queue)\r\n                \r\nI am little confuse whether huffman algorithm uses priority queue or sorted queue to build huffman tree?\nFor example:\n https://www.geeksforgeeks.org/greedy-algorithms-set-3-huffman-coding/.\n\nIn the above link they are saying that use minimum heap but as i can see they have just used sorted list to make huffman tree.Please correct me if I am wrong.\n    ", "Answer": "\r\nA minheap is used to create a priority queue which is a form of a sorted queue. And yes, any sorted data structure can be used to help create a huffman code; however, a heap is traditionally used because the huffman tree is basically a specialized construction of a max heap.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Building a greedy task scheduler - Python algorithm\r\n                \r\nWorking on the following Leetcode problem: https://leetcode.com/problems/task-scheduler/\n\n\n  Given a char array representing tasks CPU need to do. It contains\n  capital letters A to Z where different letters represent different\n  tasks.Tasks could be done without original order. Each task could be\n  done in one interval. For each interval, CPU could finish one task or\n  just be idle.\n  \n  However, there is a non-negative cooling interval n that means between\n  two same tasks, there must be at least n intervals that CPU are doing\n  different tasks or just be idle.\n  \n  You need to return the least number of intervals the CPU will take to\n  finish all the given tasks.\n\n\nExample:\n\n```\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\nOutput: 8\nExplanation: A -> B -> idle -> A -> B -> idle -> A -> B.\n```\n\n\nI've written code that passes the majority of the Leetcode tests cases, but is failing on a very large input. Here's my code:\n\n```\nimport heapq\nfrom collections import Counter\n\nclass Solution(object):\n    def leastInterval(self, tasks, n):\n        CLOCK = 0\n        if not tasks:\n            return len(tasks) \n\n        counts = Counter(tasks)\n        unvisited_tasks = counts.most_common()[::-1]\n        starting_task, _ = unvisited_tasks.pop()\n        queue = [[0, starting_task]]\n\n        while queue or unvisited_tasks:\n            while queue and CLOCK >= queue[0][0]:\n                _, task = heapq.heappop(queue)\n                counts[task] -= 1\n                if counts[task] > 0:\n                    heapq.heappush(queue, [CLOCK + 1 + n, task])\n                CLOCK += 1\n\n            if unvisited_tasks:\n                t, _ = unvisited_tasks.pop()\n                heapq.heappush(queue, [0, t])\n            else:\n                # must go idle\n                if queue:\n                    CLOCK += 1\n\n        return CLOCK \n```\n\n\nHere's the (large) input case: \n\n```\ntasks = [\"G\",\"C\",\"A\",\"H\",\"A\",\"G\",\"G\",\"F\",\"G\",\"J\",\"H\",\"C\",\"A\",\"G\",\"E\",\"A\",\"H\",\"E\",\"F\",\"D\",\"B\",\"D\",\"H\",\"H\",\"E\",\"G\",\"F\",\"B\",\"C\",\"G\",\"F\",\"H\",\"J\",\"F\",\"A\",\"C\",\"G\",\"D\",\"I\",\"J\",\"A\",\"G\",\"D\",\"F\",\"B\",\"F\",\"H\",\"I\",\"G\",\"J\",\"G\",\"H\",\"F\",\"E\",\"H\",\"J\",\"C\",\"E\",\"H\",\"F\",\"C\",\"E\",\"F\",\"H\",\"H\",\"I\",\"G\",\"A\",\"G\",\"D\",\"C\",\"B\",\"I\",\"D\",\"B\",\"C\",\"J\",\"I\",\"B\",\"G\",\"C\",\"H\",\"D\",\"I\",\"A\",\"B\",\"A\",\"J\",\"C\",\"E\",\"B\",\"F\",\"B\",\"J\",\"J\",\"D\",\"D\",\"H\",\"I\",\"I\",\"B\",\"A\",\"E\",\"H\",\"J\",\"J\",\"A\",\"J\",\"E\",\"H\",\"G\",\"B\",\"F\",\"C\",\"H\",\"C\",\"B\",\"J\",\"B\",\"A\",\"H\",\"B\",\"D\",\"I\",\"F\",\"A\",\"E\",\"J\",\"H\",\"C\",\"E\",\"G\",\"F\",\"G\",\"B\",\"G\",\"C\",\"G\",\"A\",\"H\",\"E\",\"F\",\"H\",\"F\",\"C\",\"G\",\"B\",\"I\",\"E\",\"B\",\"J\",\"D\",\"B\",\"B\",\"G\",\"C\",\"A\",\"J\",\"B\",\"J\",\"J\",\"F\",\"J\",\"C\",\"A\",\"G\",\"J\",\"E\",\"G\",\"J\",\"C\",\"D\",\"D\",\"A\",\"I\",\"A\",\"J\",\"F\",\"H\",\"J\",\"D\",\"D\",\"D\",\"C\",\"E\",\"D\",\"D\",\"F\",\"B\",\"A\",\"J\",\"D\",\"I\",\"H\",\"B\",\"A\",\"F\",\"E\",\"B\",\"J\",\"A\",\"H\",\"D\",\"E\",\"I\",\"B\",\"H\",\"C\",\"C\",\"C\",\"G\",\"C\",\"B\",\"E\",\"A\",\"G\",\"H\",\"H\",\"A\",\"I\",\"A\",\"B\",\"A\",\"D\",\"A\",\"I\",\"E\",\"C\",\"C\",\"D\",\"A\",\"B\",\"H\",\"D\",\"E\",\"C\",\"A\",\"H\",\"B\",\"I\",\"A\",\"B\",\"E\",\"H\",\"C\",\"B\",\"A\",\"D\",\"H\",\"E\",\"J\",\"B\",\"J\",\"A\",\"B\",\"G\",\"J\",\"J\",\"F\",\"F\",\"H\",\"I\",\"A\",\"H\",\"F\",\"C\",\"H\",\"D\",\"H\",\"C\",\"C\",\"E\",\"I\",\"G\",\"J\",\"H\",\"D\",\"E\",\"I\",\"J\",\"C\",\"C\",\"H\",\"J\",\"C\",\"G\",\"I\",\"E\",\"D\",\"E\",\"H\",\"J\",\"A\",\"H\",\"D\",\"A\",\"B\",\"F\",\"I\",\"F\",\"J\",\"J\",\"H\",\"D\",\"I\",\"C\",\"G\",\"J\",\"C\",\"C\",\"D\",\"B\",\"E\",\"B\",\"E\",\"B\",\"G\",\"B\",\"A\",\"C\",\"F\",\"E\",\"H\",\"B\",\"D\",\"C\",\"H\",\"F\",\"A\",\"I\",\"A\",\"E\",\"J\",\"F\",\"A\",\"E\",\"B\",\"I\",\"G\",\"H\",\"D\",\"B\",\"F\",\"D\",\"B\",\"I\",\"B\",\"E\",\"D\",\"I\",\"D\",\"F\",\"A\",\"E\",\"H\",\"B\",\"I\",\"G\",\"F\",\"D\",\"E\",\"B\",\"E\",\"C\",\"C\",\"C\",\"J\",\"J\",\"C\",\"H\",\"I\",\"B\",\"H\",\"F\",\"H\",\"F\",\"D\",\"J\",\"D\",\"D\",\"H\",\"H\",\"C\",\"D\",\"A\",\"J\",\"D\",\"F\",\"D\",\"G\",\"B\",\"I\",\"F\",\"J\",\"J\",\"C\",\"C\",\"I\",\"F\",\"G\",\"F\",\"C\",\"E\",\"G\",\"E\",\"F\",\"D\",\"A\",\"I\",\"I\",\"H\",\"G\",\"H\",\"H\",\"A\",\"J\",\"D\",\"J\",\"G\",\"F\",\"G\",\"E\",\"E\",\"A\",\"H\",\"B\",\"G\",\"A\",\"J\",\"J\",\"E\",\"I\",\"H\",\"A\",\"G\",\"E\",\"C\",\"D\",\"I\",\"B\",\"E\",\"A\",\"G\",\"A\",\"C\",\"E\",\"B\",\"J\",\"C\",\"B\",\"A\",\"D\",\"J\",\"E\",\"J\",\"I\",\"F\",\"F\",\"C\",\"B\",\"I\",\"H\",\"C\",\"F\",\"B\",\"C\",\"G\",\"D\",\"A\",\"A\",\"B\",\"F\",\"C\",\"D\",\"B\",\"I\",\"I\",\"H\",\"H\",\"J\",\"A\",\"F\",\"J\",\"F\",\"J\",\"F\",\"H\",\"G\",\"F\",\"D\",\"J\",\"G\",\"I\",\"E\",\"B\",\"C\",\"G\",\"I\",\"F\",\"F\",\"J\",\"H\",\"H\",\"G\",\"A\",\"A\",\"J\",\"C\",\"G\",\"F\",\"B\",\"A\",\"A\",\"E\",\"E\",\"A\",\"E\",\"I\",\"G\",\"F\",\"D\",\"B\",\"I\",\"F\",\"A\",\"B\",\"J\",\"F\",\"F\",\"J\",\"B\",\"F\",\"J\",\"F\",\"J\",\"F\",\"I\",\"E\",\"J\",\"H\",\"D\",\"G\",\"G\",\"D\",\"F\",\"G\",\"B\",\"J\",\"F\",\"J\",\"A\",\"J\",\"E\",\"G\",\"H\",\"I\",\"E\",\"G\",\"D\",\"I\",\"B\",\"D\",\"J\",\"A\",\"A\",\"G\",\"A\",\"I\",\"I\",\"A\",\"A\",\"I\",\"I\",\"H\",\"E\",\"C\",\"A\",\"G\",\"I\",\"F\",\"F\",\"C\",\"D\",\"J\",\"J\",\"I\",\"A\",\"A\",\"F\",\"C\",\"J\",\"G\",\"C\",\"C\",\"H\",\"E\",\"A\",\"H\",\"F\",\"B\",\"J\",\"G\",\"I\",\"A\",\"A\",\"H\",\"G\",\"B\",\"E\",\"G\",\"D\",\"I\",\"C\",\"G\",\"J\",\"C\",\"C\",\"I\",\"H\",\"B\",\"D\",\"J\",\"H\",\"B\",\"J\",\"H\",\"B\",\"F\",\"J\",\"E\",\"J\",\"A\",\"G\",\"H\",\"B\",\"E\",\"H\",\"B\",\"F\",\"F\",\"H\",\"E\",\"B\",\"E\",\"G\",\"H\",\"J\",\"G\",\"J\",\"B\",\"H\",\"C\",\"H\",\"A\",\"A\",\"B\",\"E\",\"I\",\"H\",\"B\",\"I\",\"D\",\"J\",\"J\",\"C\",\"D\",\"G\",\"I\",\"J\",\"G\",\"J\",\"D\",\"F\",\"J\",\"E\",\"F\",\"D\",\"E\",\"B\",\"D\",\"B\",\"C\",\"B\",\"B\",\"C\",\"C\",\"I\",\"F\",\"D\",\"E\",\"I\",\"G\",\"G\",\"I\",\"B\",\"H\",\"G\",\"J\",\"A\",\"A\",\"H\",\"I\",\"I\",\"H\",\"A\",\"I\",\"F\",\"C\",\"D\",\"A\",\"C\",\"G\",\"E\",\"G\",\"E\",\"E\",\"H\",\"D\",\"C\",\"G\",\"D\",\"I\",\"A\",\"G\",\"G\",\"D\",\"A\",\"H\",\"H\",\"I\",\"F\",\"E\",\"I\",\"A\",\"D\",\"H\",\"B\",\"B\",\"G\",\"I\",\"C\",\"G\",\"B\",\"I\",\"I\",\"D\",\"F\",\"F\",\"C\",\"C\",\"A\",\"I\",\"E\",\"A\",\"E\",\"J\",\"A\",\"H\",\"C\",\"D\",\"A\",\"C\",\"B\",\"G\",\"H\",\"G\",\"J\",\"G\",\"I\",\"H\",\"B\",\"A\",\"C\",\"H\",\"I\",\"D\",\"D\",\"C\",\"F\",\"G\",\"B\",\"H\",\"E\",\"B\",\"B\",\"H\",\"C\",\"B\",\"G\",\"G\",\"C\",\"F\",\"B\",\"E\",\"J\",\"B\",\"B\",\"I\",\"D\",\"H\",\"D\",\"I\",\"I\",\"A\",\"A\",\"H\",\"G\",\"F\",\"B\",\"J\",\"F\",\"D\",\"E\",\"G\",\"F\",\"A\",\"G\",\"G\",\"D\",\"A\",\"B\",\"B\",\"B\",\"J\",\"A\",\"F\",\"H\",\"H\",\"D\",\"C\",\"J\",\"I\",\"A\",\"H\",\"G\",\"C\",\"J\",\"I\",\"F\",\"J\",\"C\",\"A\",\"E\",\"C\",\"H\",\"J\",\"H\",\"H\",\"F\",\"G\",\"E\",\"A\",\"C\",\"F\",\"J\",\"H\",\"D\",\"G\",\"G\",\"D\",\"D\",\"C\",\"B\",\"H\",\"B\",\"C\",\"E\",\"F\",\"B\",\"D\",\"J\",\"H\",\"J\",\"J\",\"J\",\"A\",\"F\",\"F\",\"D\",\"E\",\"F\",\"C\",\"I\",\"B\",\"H\",\"H\",\"D\",\"E\",\"A\",\"I\",\"A\",\"B\",\"F\",\"G\",\"F\",\"F\",\"I\",\"E\",\"E\",\"G\",\"A\",\"I\",\"D\",\"F\",\"C\",\"H\",\"E\",\"C\",\"G\",\"H\",\"F\",\"F\",\"H\",\"J\",\"H\",\"G\",\"A\",\"E\",\"H\",\"B\",\"G\",\"G\",\"D\",\"D\",\"D\",\"F\",\"I\",\"A\",\"F\",\"F\",\"D\",\"E\",\"H\",\"J\",\"E\",\"D\",\"D\",\"A\",\"J\",\"F\",\"E\",\"E\",\"E\",\"F\",\"I\",\"D\",\"A\",\"F\",\"F\",\"J\",\"E\",\"I\",\"J\",\"D\",\"D\",\"G\",\"A\",\"C\",\"G\",\"G\",\"I\",\"E\",\"G\",\"E\",\"H\",\"E\",\"D\",\"E\",\"J\",\"B\",\"G\",\"I\",\"J\",\"C\",\"H\",\"C\",\"C\",\"A\",\"A\",\"B\",\"C\",\"G\",\"B\",\"D\",\"I\",\"D\",\"E\",\"H\",\"J\",\"J\",\"B\",\"F\",\"E\",\"J\",\"H\",\"H\",\"I\",\"G\",\"B\",\"D\"]\nn = 1\n```\n\n\nMy code is outputting an interval count of 1002, and the correct answer is 1000. Because the input size is so large, I'm having trouble debugging by hand on where this is going wrong.\n\nMy algorithm essentially does the following:\n\n\nBuild a mapping of character to number of occurrences\nStart with the task that occurs the largest number of times.\nWhen you visit a task, enqueue the next task to be CLOCK + interval iterations later, because my premise is that you want to visit a task as soon as you're able to do so.\nIf can't visit an already-visited task, enqueue a new one, and do so without incrementing the clock.\nIf you have elements in the queue, but not enough time has passed, increment the clock.\n\n\nAt the end, the ```\nCLOCK```\n variable describes how long (in other words, how many \"intervals\") passed before you're able to run all tasks. \n\nCan someone spot the bug in my logic?\n\n\n    ", "Answer": "\r\nConsider a case where the delay ```\nn=1```\n, and you have a task distribution like so, for which the least number of cycles is just the length of the list (the tasks could be run like \"ABCABC...D\"):\n\n```\n{\"A\": 100, \"B\": 100, \"C\": 99, \"D\": 1 } # { \"task\": <# of occurrences>, ...```\n\n\nUsing your algorithm, you would process all the cases of \"A\" and \"B\" first, since you want to move onto the next task in the same type as soon as possible, without considering other task types. After processing those two, you're left with:\n\n```\n{\"C\": 99, \"D\": 1}```\n\n\nwhich results in at least 96 idle cycles.\n\nTo fix this, the ideal task configuration would be something like a round robin of sorts.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Pulp Matching algorithm to replace greedy algo\r\n                \r\nI am trying to create a matching algorithm using pulp but the results for the sample data I'm getting are wrong as I think the function is flawed.\nSample data:\n```\nusers = {\n    1: (5.0, 4.0, 1.0, 2, 1, 1),\n    2: (8.0, 6.0, 2.0, 3, 2, 1)\n}\n\ndataset = pd.DataFrame([\n    {'id': 1, 'group': 'A', 'weight': 1},\n    {'id': 2, 'group': 'A', 'weight': 2},\n    {'id': 3, 'group': 'A', 'weight': 3},\n    {'id': 4, 'group': 'A', 'weight': 3},\n    {'id': 5, 'group': 'A', 'weight': 4},\n    {'id': 6, 'group': 'A', 'weight': 6},\n    {'id': 7, 'group': 'A', 'weight': 7},\n    {'id': 8, 'group': 'A', 'weight': 8},\n    {'id': 9, 'group': 'B', 'weight': 2},\n    {'d': 10, 'group': 'B', 'weight': 1}\n])\n```\n\nI would like to match different ids to users (without repetition). For each user I have a total weight, group A weight, group B weight, unique id count, group A unique id count, group B unique id count.\nFor the sample above the correct answer should be:\n```\n{'id': 5, 'group': 'A', 'weight': 4, 'user_id': 1}\n{'id': 10, 'group': 'B', 'weight': 1, 'user_id': 1}\n{'id': 3, 'group': 'A', 'weight': 3, 'user_id': 2}\n{'id': 4, 'group': 'A', 'weight': 3, 'user_id': 2}\n{'id': 9, 'group': 'B', 'weight': 2, 'user_id': 2}\n```\n\nMy first attempt:\n```\nfrom pulp import *\nimport pandas as pd\nfrom itertools import product\n\ndef match_weights(users, dataset):\n    matched_rows = []\n    \n    variables = LpVariable.dicts(\"Item\", range(len(dataset)), lowBound=0, cat='Binary')\n    user_vars = {}\n    \n    for user_id, (total_weight, group_a_weight, group_b_weight, total_unique_users, group_a_unique_users, group_b_unique_users) in users.items():\n        user_vars[user_id] = {}\n        user_vars[user_id]['total_weight'] = LpVariable(\"TotalWeight_{}\".format(user_id), lowBound=0, upBound=total_weight)\n        user_vars[user_id]['group_a_weight'] = LpVariable(\"GroupAWeight_{}\".format(user_id), lowBound=0, upBound=group_a_weight)\n        user_vars[user_id]['group_b_weight'] = LpVariable(\"GroupBWeight_{}\".format(user_id), lowBound=0, upBound=group_b_weight)\n        user_vars[user_id]['total_unique_users'] = LpVariable(\"TotalUniqueUsers_{}\".format(user_id), lowBound=0, upBound=total_unique_users, cat='Integer')\n        user_vars[user_id]['group_a_unique_users'] = LpVariable(\"GroupAUniqueUsers_{}\".format(user_id), lowBound=0, upBound=group_a_unique_users, cat='Integer')\n        user_vars[user_id]['group_b_unique_users'] = LpVariable(\"GroupBUniqueUsers_{}\".format(user_id), lowBound=0, upBound=group_b_unique_users, cat='Integer')\n\n    prob = LpProblem(\"MatchingProblem\", LpMaximize)\n    prob += lpSum(variables[i] for i in range(len(dataset)))\n\n    for user_id, (total_weight, group_a_weight, group_b_weight, total_unique_users, group_a_unique_users, group_b_unique_users) in users.items():\n        group_a_items = dataset[dataset['group'] == 'A'].index.tolist()\n        group_b_items = dataset[dataset['group'] == 'B'].index.tolist()\n\n        # Total weight constraint\n        prob += lpSum(variables[i] * dataset.loc[i, 'weight'] for i in range(len(dataset))) <= user_vars[user_id]['total_weight']\n\n        # Group A weight constraint\n        prob += lpSum(variables[i] * dataset.loc[i, 'weight'] for i in group_a_items) <= user_vars[user_id]['group_a_weight']\n\n        # Group B weight constraint\n        prob += lpSum(variables[i] * dataset.loc[i, 'weight'] for i in group_b_items) <= user_vars[user_id]['group_b_weight']\n\n        # Total unique user constraint\n        unique_users = set()\n        for i in range(len(dataset)):\n            if variables[i].value() == 1:\n                unique_users.add(dataset.loc[i, 'id'])\n        prob += lpSum(1 for u in unique_users) <= user_vars[user_id]['total_unique_users']\n\n        # Group A unique user constraint\n        unique_users_a = set()\n        for i in group_a_items:\n            if variables[i].value() == 1:\n                unique_users_a.add(dataset.loc[i, 'id'])\n        prob += lpSum(1 for u in unique_users_a) <= user_vars[user_id]['group_a_unique_users']\n\n        # Group B unique user constraint\n        unique_users_b = set()\n        for i in group_b_items:\n            if variables[i].value() == 1:\n                unique_users_b.add(dataset.loc[i, 'id'])\n        prob += lpSum(1 for u in unique_users_b) <= user_vars[user_id]['group_b_unique_users']\n\n    prob.solve()\n    for user_id, (total_weight, group_a_weight, group_b_weight, total_unique_users, group_a_unique_users, group_b_unique_users) in users.items():\n        matched_user_rows = []\n        for i in range(len(dataset)):\n            if variables[i].value() == 1:\n                matched_row = dataset.loc[i].copy()\n                matched_row['user_id'] = user_id\n                matched_user_rows.append(matched_row)\n        matched_rows.extend(matched_user_rows)\n\n    return matched_rows\n```\n\nHowever the results are:\n```\n{1: {'group_a': [2], 'group_b': [10]}, 2: {'group_a': [2], 'group_b': [10]}}\n```\n\nLooks like my results might overwrite each other but also look wrong.\nI tried to rewrite it and got similar incorrect results:\n```\ndef match_weights(users, dataset):\n   \n    model = LpProblem(\"MatchingProblem\", LpMaximize)\n    variables = LpVariable.dicts(\"Item\", dataset.index, lowBound=0, cat='Binary')\n    model += lpSum(variables[i] for i in dataset.index)\n\n    # Add constraints for each user\n    for user_id, (total_weight, group_a_weight, group_b_weight, _, _, _) in users.items():\n        # Filter dataset based on user group\n        group_a_indices = dataset[dataset['group'] == 'A'].index\n        group_b_indices = dataset[dataset['group'] == 'B'].index\n\n        # Total weight constraint\n        model += lpSum(variables[i] * dataset.loc[i, 'weight'] for i in dataset.index) <= total_weight\n\n        # Group A weight constraint\n        model += lpSum(variables[i] * dataset.loc[i, 'weight'] for i in group_a_indices) <= group_a_weight\n\n        # Group B weight constraint\n        model += lpSum(variables[i] * dataset.loc[i, 'weight'] for i in group_b_indices) <= group_b_weight\n\n\n    unique_user_set = set(dataset['respondent_id'])\n    for user_id, (total_weight, _, _, total_unique_users, group_a_unique_users, group_b_unique_users) in users.items():\n \n        group_a_indices = dataset[dataset['group'] == 'A'].index\n        group_b_indices = dataset[dataset['group'] == 'B'].index\n\n        # Total unique users constraint\n        model += lpSum(variables[i] for i in dataset.index if dataset.loc[i, 'respondent_id'] in unique_user_set) \\\n                 <= total_unique_users\n\n        # Group A unique users constraint\n        model += lpSum(variables[i] for i in group_a_indices if dataset.loc[i, 'respondent_id'] in unique_user_set) \\\n                 <= group_a_unique_users\n\n        # Group B unique users constraint\n        model += lpSum(variables[i] for i in group_b_indices if dataset.loc[i, 'respondent_id'] in unique_user_set) \\\n                 <= group_b_unique_users\n\n\n    model.solve()\n    results = {}\n    for user_id, (_, _, _, _, _, _) in users.items():\n\n        group_a_indices = dataset[dataset['group'] == 'A'].index\n        group_b_indices = dataset[dataset['group'] == 'B'].index\n        matched_a = [dataset.loc[i, 'respondent_id'] for i in group_a_indices if variables[i].value() == 1]\n        matched_b = [dataset.loc[i, 'respondent_id'] for i in group_b_indices if variables[i].value() == 1]\n\n        results[user_id] = {'group_a': matched_a, 'group_b': matched_b}\n\n    return results\n```\n\nWhere am I going wrong?\n    ", "Answer": "\r\nYou've set an optimisation objective and optimisation sense when I believe there should be no objective (and the sense left as default). In other words, once you're done formulating, ```\nprint(prob)```\n should include\n```\nMINIMIZE\nNone\n```\n\nYou should not have variables for total weight, total unique users etc: instead, only have one decision variable kind, which is a binary assignment of whether an ID has been assigned to a user.\nThe \"total\" constraint is redundant and you can deal with the individual group values without the total.\nSince you're in Pandas, so long as your data are shaped correctly, you do not need to use ```\nlpSum```\n; you can operate on the frames and series directly (```\n.dot()```\n, ```\n.sum()```\n).\n```\ndataset```\n is a frame (good!) that needs ```\nid```\n to move to an index. ```\nusers```\n should be converted from a dictionary to a frame.\n```\nimport pandas as pd\nimport pulp\n\nrequirements = pd.DataFrame(\n    data={\n        1: (5.0, 4.0, 1.0, 2, 1, 1),\n        2: (8.0, 6.0, 2.0, 3, 2, 1),\n    },\n    # row index, soon to turn into column names via .T\n    index=pd.MultiIndex.from_product(\n        iterables=(('weight', 'count'), ('total', 'A', 'B')),\n        names=('requirement', 'group'),\n    ),\n).drop(labels='total', level='group').T  # redundant\nrequirements.index.name = 'user'\nuser_values = requirements.index.to_series()\nrequirements = requirements.stack(level='group')\nprint(requirements, end='\\n\\n')\n\ndataset = pd.DataFrame([\n    {'id': 1, 'group': 'A', 'weight': 1},\n    {'id': 2, 'group': 'A', 'weight': 2},\n    {'id': 3, 'group': 'A', 'weight': 3},\n    {'id': 4, 'group': 'A', 'weight': 3},\n    {'id': 5, 'group': 'A', 'weight': 4},\n    {'id': 6, 'group': 'A', 'weight': 6},\n    {'id': 7, 'group': 'A', 'weight': 7},\n    {'id': 8, 'group': 'A', 'weight': 8},\n    {'id': 9, 'group': 'B', 'weight': 2},\n    {'id': 10, 'group': 'B', 'weight': 1},\n]).set_index('id')\nprint(dataset, end='\\n\\n')\n\ncombos = pd.merge(left=user_values, right=dataset.index.to_series(), how='cross')\nasn_name = 'asn_u' + combos.user.astype(str) + '_i' + combos.id.astype(str)\ncombos['asn'] = asn_name.apply(pulp.LpVariable, cat=pulp.LpBinary)\ncombos = combos.set_index(['user', 'id']).asn.unstack(level='user')\nprint(combos, end='\\n\\n')\n\nprob = pulp.LpProblem(name='user_assignment')\n\n# Every ID can be assigned to at most one user\nfor user, total in combos.sum(axis=1).items():\n    prob.addConstraint(name=f'excl_u{user}', constraint=total <= 1)\n\nfor group, dataset_weights in dataset.groupby('group'):\n    group_assigns = combos.loc[dataset_weights.index]\n    for user, user_assigns in group_assigns.items():\n        requirement = requirements.loc[(user, group), :]\n        prob.addConstraint(\n            name=f'count_u{user}_g{group}',\n            constraint=user_assigns.sum() == requirement['count'],\n        )\n        prob.addConstraint(\n            name=f'weight_u{user}_g{group}',\n            constraint=user_assigns.dot(dataset_weights.weight) == requirement['weight'],\n        )\n\nprint(prob)\nprob.solve()\nassert prob.status == pulp.LpStatusOptimal\n\ncombos = combos.applymap(pulp.LpVariable.value).astype(int)\ncombos = combos[combos.any(axis=1)]\nprint(combos)\n```\n\n```\nrequirement  count  weight\nuser group                \n1    A         1.0     4.0\n     B         1.0     1.0\n2    A         2.0     6.0\n     B         1.0     2.0\n\n   group  weight\nid              \n1      A       1\n2      A       2\n3      A       3\n4      A       3\n5      A       4\n6      A       6\n7      A       7\n8      A       8\n9      B       2\n10     B       1\n\nuser           1           2\nid                          \n1      asn_u1_i1   asn_u2_i1\n2      asn_u1_i2   asn_u2_i2\n3      asn_u1_i3   asn_u2_i3\n4      asn_u1_i4   asn_u2_i4\n5      asn_u1_i5   asn_u2_i5\n6      asn_u1_i6   asn_u2_i6\n7      asn_u1_i7   asn_u2_i7\n8      asn_u1_i8   asn_u2_i8\n9      asn_u1_i9   asn_u2_i9\n10    asn_u1_i10  asn_u2_i10\n\nuser_assignment:\nMINIMIZE\nNone\nSUBJECT TO\nexcl_u1: asn_u1_i1 + asn_u2_i1 <= 1\nexcl_u2: asn_u1_i2 + asn_u2_i2 <= 1\n...\n\ncount_u1_gA: asn_u1_i1 + asn_u1_i2 + asn_u1_i3 + asn_u1_i4 + asn_u1_i5\n + asn_u1_i6 + asn_u1_i7 + asn_u1_i8 = 1\n\nweight_u1_gA: asn_u1_i1 + 2 asn_u1_i2 + 3 asn_u1_i3 + 3 asn_u1_i4\n + 4 asn_u1_i5 + 6 asn_u1_i6 + 7 asn_u1_i7 + 8 asn_u1_i8 = 4\n...\nVARIABLES\n0 <= asn_u1_i1 <= 1 Integer\n0 <= asn_u1_i10 <= 1 Integer\n0 <= asn_u1_i2 <= 1 Integer\n0 <= asn_u1_i3 <= 1 Integer\n0 <= asn_u1_i4 <= 1 Integer\n0 <= asn_u1_i5 <= 1 Integer\n0 <= asn_u1_i6 <= 1 Integer\n0 <= asn_u1_i7 <= 1 Integer\n0 <= asn_u1_i8 <= 1 Integer\n0 <= asn_u1_i9 <= 1 Integer\n0 <= asn_u2_i1 <= 1 Integer\n0 <= asn_u2_i10 <= 1 Integer\n0 <= asn_u2_i2 <= 1 Integer\n0 <= asn_u2_i3 <= 1 Integer\n0 <= asn_u2_i4 <= 1 Integer\n0 <= asn_u2_i5 <= 1 Integer\n0 <= asn_u2_i6 <= 1 Integer\n0 <= asn_u2_i7 <= 1 Integer\n0 <= asn_u2_i8 <= 1 Integer\n0 <= asn_u2_i9 <= 1 Integer\n...\nResult - Optimal solution found\n\nuser  1  2\nid        \n3     0  1\n4     0  1\n5     1  0\n9     0  1\n10    1  0\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "`the shortest path that connects several points` NP-complete algorithms\r\n                \r\nI am reading `Grokking algorithms\" and understand Dijkstran and greedy algorithms,\nbut, when the author compare them with NP-complete problem\n\n\n  But it’s hard to tell if a problem you’re working on is NP-complete. Usually there’s a very small difference between a problem that’s easy to solve and an NP-complete problem. For example, in the previous chapters, I talked a lot about shortest paths. You know how to calculate the shortest way to get from point A to point B.\n  \n  But if you want to find the shortest path that connects several points, that’s the traveling-salesperson problem, which is NP-complete. The short answer: there’s no easy way to tell if the problem you’re working on is NP-complete. Here are some giveaways:\n\n\nThe sentence:\nBut if you want to find the shortest path that connects several points,\n\nWhat are \"the several points\"?\nI cannot figure out any difference with a basic Dijkstan's algorithms problem.\n    ", "Answer": "\r\nHe means a path through a subset of all the nodes of a graph, I think. (Think the worst case of 'several points')\n\nNote, that for any fixed number of points, say k = 3 or k = 3000 on a graph of n nodes, the problem would be of the same complexity as for two points. While some people may think that several is never greater than seven, or may be seven dozens or seven billion, it is neither a matter of fact nor an exact science.\n\nLess likely he meant the usual formulation of the Traveling salesman problem (all the nodes/points on a connected graph), though a possibility. NP complete any way.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Can You help me to find a greedy algorithm for covering a line segment?\r\n                \r\nThe Question is :Given n segments of line (into the X axis) with coordinates [Li , Ri](coordinates could be negative numbers). You are to choose the minimum number of segments that cover the whole segment [0 , M].\n\nAnd Here What I did: Actually I've Sorted the segments by their starting coordinates (Li) in increasing order. Then Selected the segments starting with the smallest Li and then selected the Largest one.\n\nbut my algorithm does not work for some instances. Do You Guys Have any other idea for this problem ? please give me some hints for solving this problem.\n    ", "Answer": "\r\nFirst remove the segments having```\nR < 0```\n. Among the remaining segments, you must select at least one segment such that ```\nL <= 0 <= R```\n. There is no loss in selecting the segment with the largest ```\nR```\n among the segments having ```\nL <= 0```\n.\nRinse and repeat with ```\n[R, M]```\n instead of ```\n[0, M]```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Looking for help regarding a greedy algorithm in C for the cs50 \"cash\" problem set [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThe goal is to make an algorithm that takes an input and gives an output of the number of times the values ( 25, 10, 5, 1) are subtracted from the input. The code needs to do this in the greediest way possible, taking the highest value whenever its possible.\nExpected output for an input of 1 is 4. Actual output just moves the terminal to the next line.\nNo error messages.\nPreviously I didn't have the continue statements and the {} brackets after the if statements, which had a code that was working, however still provided inaccurate results. Input of 1 and 2 gave the same output: 5.\nHeres my current code, I understand that its probably messy and doing division instead of subtraction would be more efficient and 'cleaner'. However since I'm just learning C recently I thought it would be easier to take baby steps.\n```\n#include <cs50.h>\n#include <stdio.h>\n#include <math.h>\n\nint main()\n{\n    float dollars;\n    int cents;\n\n    do\n    {\n        dollars = get_float(\"Change owed: \");\n        cents = round( dollars * 100);\n    }\n    while ( dollars < 0);\n\n    for( int coins = 1; cents > 0; coins++ )\n    {\n        if (cents >= 25)\n        {\n            cents -= 25;\n            continue;\n        }\n        if (cents >= 10)\n        {\n            cents -= 10;\n            continue;\n        }\n        if (cents >= 5)\n        {\n            cents -= 5;\n            continue;\n        }\n        if (cents >= 1)\n        {\n            cents -= 1;\n            continue;\n        }\n        if (cents == 0)\n        {\n        printf(\" %i\", coins);\n        }\n         printf (\"\\n\");\n    }\n   \n}\n```\n\n    ", "Answer": "\r\nHere you have the function which gives you result for any nominals. It is much easier to use integers.\n```\nint nominals[] = {100, 25, 10, 5, 1, 0};\n\nvoid getNominals(double money, int *result)\n{\n    unsigned ncents = money * 100.0;\n    int *nm = nominals;\n    while(*nm && ncents)\n    {\n        *result++ = ncents / *nm;\n        ncents %= *nm++;\n    }\n}\n\nint main(void)\n{\n    int result[sizeof(nominals) / sizeof(nominals[0])] = {0};\n\n    getNominals(4.36, result);\n\n    for(size_t index = 0; nominals[index]; index++)\n    {\n        printf(\"%d = %d\\n\", nominals[index], result[index]);\n    }\n}\n```\n\nhttps://godbolt.org/z/Y5naMf\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How can I find out an induced subgraph of k nodes with at least m*k*(k-1)/n*(n-1) edges\r\n                \r\nI am required to use a greedy algorithm to resolve this problem (here ```\nm```\n is the number of edges and ```\nn```\n is the number of vertices in the original graph). Intuitively， I know it is somehow about density of graph (due to ```\nm/n*(n-1)```\n part), so I try to use greedy algorithm to remove the vertex with minimum degree each iteration until I get a ```\nk```\n nodes graph, but I don't know how can I GARUNTEE the algorithm give me the final graph with at least ```\nm*k*(k-1)/n*(n-1)```\n  edges.\n\nLooking for any hints, Thanks.\n    ", "Answer": "\r\nLet's define the density of a graph ```\np=m/(n*(n-1))```\n (for undirected graph it should be ```\np=2*m/(n*(n-1))```\n. Note that for a graph with density ```\np```\n and ```\nk```\n vertices, it has ```\n(k*(k-1)) * p```\n edges. Also note that when you greedily remove a vertex with the minimum degree, it won't decrease the density of the graph (will proof it below). So when you get the subgraph with ```\nk```\n vertices, its density is equal to or greater than ```\nm/(n*(n-1))```\n, then the subgraph contains at least ```\nk*(k-1)(m*/n*(n-1))```\n edges. \n\nLet G be a graph with ```\nm```\n edges and ```\nn```\n vertices, then ```\np=m/n```\n. Let ```\nd```\n the minimum degree of all vertices. then we have ```\nn * d <= m```\n i.e., ```\nd <= m/n```\n. So when you remove the vertex with the minimum degree, you get a graph with ```\nm-d```\n edges and ```\nn-1```\n vertices, then the density of the new graph will be ```\np'=(m-d)/(n-1) >= (m-m/n)/(n-1) = m/n = p```\n. So we have that the greedy algorithm won't decrease the density of a graph.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Maximum sum of two elements\r\n                \r\nYou are given two arrays each with n integers. Find the maximum sum of two elements. You have to choose one element from the first array, one element from the second array and their indexes have to be different.\nA greedy algorithms doesn't work, it has to be a dynamic one and with a complexity of O(n).\n    ", "Answer": "\r\nConceptually, this is how I would approach this problem:\nFind the biggest and the 2nd biggest element of each array, and keep track of which index they're in.  This should be O(n) each.\nAfter you do that, check all the possible sums you can make out of these four numbers(2 from each array) where the index of each isn't the same.  This will be your biggest sum.  This will take a constant amount of time, and won't affect your time complexity.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Epsilon Greedy Performing better than UCB for small number of arms\r\n                \r\nI am implementing the bandit problem using various algorithms. The issue that I am facing is that epsilon-greedy is performing better than UCB for 5arms and horizon of 2000 for an epsilon value of 0.95.\nI am aware of the fact that epsilon-greedy does indeed perform better when the horizon is comparable with a number of arms.\nBut since my arms are significantly less than the horizon, UCB should perform better. Any idea why this is happening?\nI am enclosing my UCB implementation.\n\n```\nelse if(algorithm.compare(\"UCB\") == 0){\n\nif(pulls == 0){\n  armpullfrequency = new int[numArms];\n  armRewards = new float[numArms];\n  armmean = new double[numArms];\n  UCB = new double[numArms];\n\n  for(int i=0; i<numArms; i++){\n    armpullfrequency[i] = 0;\n    armRewards[i] = 0.0;\n    armmean[i] = (double)0;\n    UCB[i] = (double)0;\n  }\n}\n\nelse{\n\n  armpullfrequency[pulled_arm] = armpullfrequency[pulled_arm] + 1;\n  armRewards[pulled_arm] = armRewards[pulled_arm] + reward;\n}\nint selected_arm = 0;\n//int randint = (rand() % 100);\nif(pulls<=6){\n  for(int i=0;i<numArms;i++){\n    if(armpullfrequency[i]==0){\n      selected_arm = i;\n      return selected_arm;\n    }\n  }\n}\n\nfor(int i=0;i<numArms;i++){\n    int freq = armpullfrequency[i];\n    float prize = armRewards[i];\n    double mean = eval_mean(freq, prize);\n    armmean[i] = mean;\n  }\n\nfor(int i=0; i<numArms;i++){\n  int freq = armpullfrequency[i];\n  double mean = armmean[i];\n  double UCBval = UCBUpdate(mean, freq, pulls);\n  UCB[i] = UCBval;\n}\n\nselected_arm = LargestElementIndex(UCB, numArms);\nreturn(selected_arm);\n```\n\n\nMy UCB and LargestElementIndex function are:-\n\n```\nint LargestElementIndex(double arr[], int size){\n  int max = 0;\n  for(int i=0;i<size; i++){\n    if(arr[i]>max){\n     max = arr[i];\n    }\n  }\n  return max;\n}\n\nint UCBUpdate(double mean, int freq, int pulls){\n  double result = mean + sqrt((double)2.0 *(log(pulls))/(double)freq);\n  return result;\n}\n```\n\n\nThe results in case of UCB is:-\nmaxMean 0.5805 numTotalPulls 2000 cumulativeReward 716.308\nRegret = 444.692\n\nThe results in the case of Epsilon Greedy is:-\nmax means 0.5805 numTotalPulls 2000 cumulativeReward 823.948\nRegret = 337.052\n    ", "Answer": "\r\nI suspect the error is in the following code:\n\n```\nint LargestElementIndex(double arr[], int size){\n  int max = 0;\n  for(int i=0;i<size; i++){\n    if(arr[i]>max){\n     max = arr[i];\n    }\n  }\n  return max;\n}\n```\n\n\nThis does not return the index of the arm with the greatest UCB value (which is probably what you intended). This code simply returns the greatest UCB value in the array itself, after casting it to an ```\nint```\n. This can likely be fixed as follows:\n\n```\nint LargestElementIndex(double arr[], int size){\n  double max_val = -1000.0;\n  int max_idx = -1;\n  for(int i=0;i<size; i++){\n    if(arr[i]>max_val){\n     max_val = arr[i];\n     max_idx = i;\n    }\n  }\n  return max_idx;\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Euler #18 with Python [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am trying to solve project euler problem 18.\nhttp://projecteuler.net/problem=18\nI tried a greedy algorithm with python working from the bottom of the triangle.\nTHen I move up one row and find the biggest route with a greedy algorithm and try to connect the biggest route but it doesn't work. DO you have any hints that would put me on the right track without giving the solution of the problem away.\n\nhere is the function:\n\n```\ndef greedy(i):\n    if i%15==0:\n        a=[(b[i-15],i-15),(b[i-14],i-14)]\n        a=sorted(a)\n        a=a[-1]\n    else:\n        a=[(b[i-15],i-15),(b[i-16],i-16),(b[i-14],i-14)]\n        a=sorted(a)\n        a=a[-1]\n    return a\n```\n\n\nCheers\n    ", "Answer": "\r\nHave you ever heard of Dynamic Programming?\n\nConsider this problem. What makes a route the best? Is there any relation between the last step and the previous ones? Also, look at this triangle where the greedy algorithm doesn't give you the right answer:\n\n```\n      1\n    2   3\n  9   1   2\n1   1   2   4\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "change-making problems with some modifications [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIn change-making problem with following Greedy algorithms, addresses the following question: how can a given amount of money be made with the least number of coins? \n\nAlgorithm: using most valuable coins, if it possible. Suppose we have infinite numbers of each coins set.\n\nmy professor, wrote  the (4) is not produce the optimal solution, anyone could say why? (or why other is not counterexample? )\n\n```\n1- {1,2,5}\n\n2- {1,4,7}\n\n3-{1,5,10}\n\n4-{1,7,10}\n```\n\n    ", "Answer": "\r\nApplying a greedy strategy with coins from set #4 will not produce an optimal result in a situation when you need to represent 14:\n\n\nGreedy strategy will take 10 as soon as it can, finishing off with four pennies, for a total of five coins\nAn optimal strategy would be to take two sevens, for a total of two coins.\n\n\nIt is easy to see that if there exists a coin ```\nC```\n such that the value ```\nk*C```\n can be composed with at least ```\nk+1```\n coins if you take any of the coins of higher denomination, then the greedy algorithm is not going to succeed.\n\nIn your last set ```\nC=7```\n, ```\nk=2```\n, ```\nkC=14```\n. If you take ```\n10```\n to make ```\n14```\n, you need five coins, which is greater than ```\nk```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Neighborhood Structure for Graph Coloring Local Search Heuristic\r\n                \r\nI am attempting to create a local search heuristic for a given greedy algorithm that attempts to 3-color a graph. This greedy algorithm can get stuck (ie, can color no more vertices), at which point my heuristic is used to slightly modify the current graph coloring to attempt to make more progress with the greedy algorithm. I know that I need to define a neighborhood of a given incomplete coloring, and then search through this neighborhood for better coloring candidates. My idea is to define the neighborhood as all colorings reachable by swapping two vertex colors in the graph. However, I'm a little bit confused about how to go about this. What if the coloring is such that no swaps can be made to maintain the coloring's validity? How do I select the vertices to swap?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why the complexity of this algorithm is O(n log(n)))?\r\n                \r\nI have a multi-set S with positive numbers where I want to partition it into K  subsets such that the difference between the sum of partitions is minimized. one simple heuristics approach to the above problem is the greedy algorithm, which iterates through the set of numbers sorted in descending order, assigning each of them to whichever subset has the smaller sum of the numbers. My question is why time complexity of this greedy algorithm is O(nlog(n))?\n    ", "Answer": "\r\nDetermining \"whichever subset has the smaller sum of the numbers\" will take logarithmic time on the current number of subsets. You would need to implement some sort of priority queue or heap for doing this efficiently with such a time complexity. In a worst case your number of sets will be O(𝑛), and so you get the following search time complexities as each input value is processed:\nO(log(1) + log(2) + log(3) + ... + log𝑛)\n= O(log𝑛!)\n= O(𝑛log𝑛)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "a different version of interval scheduling\r\n                \r\nGiven n intervals and a number k,give an algorithm to find the maxmium subsets of intervals such that no points is contained in more than k of them?\nWe know that when k = 1,this problem can be solved by a greedy algorithm.So I have been trying to develop a greedy algorithm for the above problem.\n    ", "Answer": "\r\nThe way I would approach this is to first get a set for all the bounds of all the intervals, and sort that set. This might be the set of at most n*2 point x_i. Then consider the sets S_i = [x_i,x_{i+1}]. Each of your starting intervals either contains the S_i or is disjoint. So for each S_i we can build a list T_i of the indices of all intervals which contain the set. So it intervals 1,2, 5 intersect the set S_1 than T_1 = {1,3,5}.\n\nWe now have a collection of sets T_i, and the problem reduces to finding the minimum set of indicies M so that  T_i union M has at most k elements for each T_i. We can simplify the problem somewhat by throwing away and T_i which starts with fewer than k items. \n\nA recursive algorithm should be able to do a greedy search through the possible sets M.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "how to set the contents of an array equal to the contents from a second array\r\n                \r\nI'm using greedy algorithm to calculate change, I want to save the set of the coins i've used to a new aray, however I : \n\n```\nException in thread \"main\" java.lang.NullPointerException\n    at lacy_lab_7b_2015.Lacy_Lab_7b_2015.main(Lacy_Lab_7b_2015.java:36)\nJava Result: 1\n```\n\n\nfrom the complier.\n\n```\n    public class Lacy_Lab_7b_2015 {\n\npublic static Scanner input = new Scanner(System.in);// scanner object to allow user input\npublic static int amount;// global variable defined by user to be used to have certain value of coins added so that they wll equal this value\npublic static int count = 0;\nfinal public static int[] FACE_VALUES_OF_COINS = {100, 50, 25, 10, 5, 1};\npublic static int[] coinsUsed;\n\n/**\n * @param args the command line arguments\n */\npublic static void main(String[] args) {\n    // TODO code application logic here\n    amount = userAmount();\n   // coinsUsed = coinsUsed(FACE_VALUES_OF_COINS,amount);\n\n    for (int i = 0; i < FACE_VALUES_OF_COINS.length; i++) {\n        int j = 0;\n        if (FACE_VALUES_OF_COINS[i] < amount) {\n            int count = amount / FACE_VALUES_OF_COINS[i];\n           coinsUsed[j] = FACE_VALUES_OF_COINS[i];\n            amount -= count * FACE_VALUES_OF_COINS[i];\n        }//end if\n    }//end for\n    for (int i = 0; i < coinsUsed.length; i++) {\n        System.out.println(coinsUsed[i]);\n    }\n}//end main\n```\n\n    ", "Answer": "\r\nI whould suggest you to write\n\npublic static int[] coinsUsed;\n\nas\n\npublic static int[] coinsUsed = new int[5]; \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "I am unable to solve the fractional knapsack problem using greedy algorithm in python\r\n                \r\nProblem Description : - Maximizing the Value of the Loot Problem Find the maximal value of items that fit into the backpack.\nInput: The capacity of a back- pack W as well as the weights (w 1 , . . . , w n ) and per\npound prices(p 1 , . . . , p n ) of n different compounds.\nOutput: The maximum total priceof items that fit into the backpackof the given capacity:\ni.e.,the maximum value of p 1 · u 1 + · · · + p n · u n such that u 1 + · · · + u n ≤ W\nand 0 ≤ u i ≤ w i for all i.\nInput format -  The first line of the input contains the number n of com-\npounds and the capacity W of a backpack. The next n lines define\nthe prices and weights of the compounds. The i-th line contains the\nprice per pound p i and the weight w i of the i-th compound.\nOutput format - Output the maximum price of compounds that fit into\nthe backpack.\nHere is my Code:-\n```\nb = []                              # list\nn = input().split()                 # number of elements here\ntotal_weight = int(n[1])            # total_weight\ntimes = int(n[0])                   # No of things\nfor i in range(times):\n    item = [int(x) for x in input().split()]          # 10 50   - price weight\n    per  = float(item[0])/float(item[1])              # per = 10/50 \n    item.insert(0,per)\n    b.append(item)                                    # list\nb.sort(reverse = True)                            # sort on the basis of per\nvalue = 0\nfor i in range(times):\n    if b[i][2] >= total_weight:     # b[i] = [2,100,50]  total_weight = 20\n        value = value + (b[i][0] * total_weight) # 2 * 20 = 40\n    if b[i][2] < total_weight:\n        value = value + (b[i][0] * b[i][2])    #b[i] = [5,50,10] total_weight = 20   5*10     \n    if value == total_weight:\n        break\n    total_weight = total_weight - b[i][2]\nprint(round(value,4))\n```\n\nI am unable to get correct answers in some cases .. do review my code if any logical errors are there\n    ", "Answer": "\r\nInput values ```\nprice per pound p i```\n already are sorting keys, so introducing ```\nper```\n variable and corresponding field of ```\nitem / b[]```\n seems wrong.\n\nAlso note that here\n```\nif value == total_weight:\n```\n\nyou compare float value for exact equality - it is not quite correct, because you can get result like ```\n27.000000000001```\n due to limited precision.\nIt is worth to make comparison with some tolerance level using ```\nmath.isclose```\n function. And you can just remove this comparison, adding break in the first if-block\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Integer partition weighted minimum\r\n                \r\nGiven a non-negative integer $n$ and a positive real weight vector $w$ with dimension $m$, partition $n$ into a length-$m$ non-negative integer vector that sums to $n$ (call it $v$) such that $w\\cdot v$ is the smallest. There maybe several partitions, and we only want the value of $w\\cdot v$.\nSeems like this problem can use a greedy algorithm to solve. From a target vector for $n-1$, we add 1 to each entry, and find the minimum among those $m$ vectors. but I don't think it's correct. The intuition is that it might add \"over\" the minimum. That is, there exists another partition not yielded by the add 1 procedure that falls in between the \"minimum\" of $n-1$ produced by this greedy algorithm and that of $n$ produced by this greedy algorithm. Can anyone prove if this is correct or incorrect?\n    ", "Answer": "\r\nWithout loss of generality, assume that the elements of ```\nw```\n are non-decreasing. Let ```\nv```\n be a ```\nm```\n-vector whose values are non-negative integers that sum to ```\nn```\n. Then the smallest inner product of ```\nv```\n and ```\nw```\n is achieved by setting ```\nv[0] = n```\n and ```\nv[i] = 0```\n for ```\ni > 0```\n.\nThis is easy to prove. Suppose ```\nv```\n is any other vector with ```\nv[i] > 0```\n for some ```\ni > 0```\n. Then we can increase ```\nv[0]```\n by ```\nv[i]```\n and reduce ```\nv[i]```\n to zero. The elements of ```\nv```\n will still sum to ```\nn```\n and the inner product of ```\nv```\n and ```\nw```\n will be reduced by ```\nw[i] - w[0] >= 0```\n.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Beginner C: error: control reaches end of non-void function?\r\n                \r\nI'm trying to make a greedy algorithm and I get this error:\n\n```\ngreedy2.c:27:1: error: control reaches end of non-void function\n      [-Werror,-Wreturn-type]\n}\n^\n1 error generated.\n```\n\n\nwith this code:\n\n```\nint man(int argc, char* argv[])\n{\n\n  float amount;\n  do\n    {\n      printf(\"Input dollar amount owed:\\n\");\n      amount = GetFloat();\n    }\n  while (amount <= 0);    \n  int coins = 0;\n  while (amount >= 0.25);\n  {\n    amount = amount - 0.25;\n    coins++;\n  }\n  printf(\"Number of coins to use: %d\\n\", coins);\n\n}\n```\n\n\nWhat is wrong with my curly braces, and how do I fix it?\n    ", "Answer": "\r\nNothing wrong with your curly brackets. Problem is that you declared your main as returning int.. but you are not returning anything\n\nIf you compile with the compiler flag ```\n-Wall```\n .. your compiler will complain when you don't return something from a function that you have defined as returning something..\n\njust add:\n\n```\n  return 0; // before the last bracket\n```\n\n\nAlso its  ```\nint main(int argc, char* argv[]){```\n .. not ```\nint man(int argc, char* argv[]){```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Beginning Dynamic Programming - Greedy coin change help\r\n                \r\nI am currently working through a book on algorithm design and came across a question whereby you must implement a greedy algorithm with dynamic programming to solve the coin change problem.\n\nI was trying to implement this and I just can't figure out out or make sense of the algorithm given in my book. The algorithm is as follows(with my (lack of) understanding in comments) :\n\n```\nChange(p) {\n  C[0] = 0\n    for(i=1 to p) //cycling from 1 to the value of change we want, p\n      min = infinity\n        for(j=1 to k( //cyle from 1 to...?\n          if dj <=i then\n            if(1+C[i-dj] < min) then\n               min = 1+C[i-dj]\n            endif\n          endif\n        endfor\n     C[i] = min\n    endfor\n  return C[p]\n}\n```\n\n\nAnd my attempt at interpreting what's going on :\n\n```\n/**\n     * \n     * @param d\n     *            currency divisions\n     * @param p\n     *            target\n     * @return number of coins\n     */\n    public static int change(int[] d, int p) {\n        int[] tempArray = new int[Integer.MAX_VALUE]; // tempArray to store set\n                                                        // of coins forming\n                                                        // answer\n        for (int i = 1; i <= p; i++) { // cycling up to the wanted value\n            int min = Integer.MAX_VALUE; //assigning current minimum number of coints\n            for (int value : d) {//cycling through possible values\n                if (value < i) {\n                    if (1 + tempArray[i - value] < min) { //if current value is less than min\n                        min = 1 + tempArray[1 - value];//assign it\n                    }\n                }\n            }\n            tempArray[i] = min; //assign min value to array of coins\n        }\n        System.out.println(\"help\"); // :(\n        return tempArray[p];\n    }\n```\n\n\nCan someone please explain to me what I am missing, how to fix this, and how this algorithm is supposed to work? Dynamic Programming seems like such a useful tool, but I cannot get my head around it. I keep thinking recursively.\n    ", "Answer": "\r\nsee this wikipedia link\nan excerpt:\n\nGreedy choice property  We can make whatever choice seems best at the\nmoment and then solve the subproblems that arise later. The choice\nmade by a greedy algorithm may depend on choices made so far but not\non future choices or all the solutions to the subproblem. It\niteratively makes one greedy choice after another, reducing each given\nproblem into a smaller one. In other words, a greedy algorithm never\nreconsiders its choices. This is the main difference from dynamic\nprogramming, which is exhaustive and is guaranteed to find the\nsolution. After every stage, dynamic programming makes decisions based\non all the decisions made in the previous stage, and may reconsider\nthe previous stage's algorithmic path to solution.\n\nYour code iterates through the ```\nint p```\n gets the optimum choice and puts it into the array ```\ntempArray```\n then uses this value to check the optimum choice in the next iteration.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Create minimum no of groups of subsequent elements with max diff between elements being less than k\r\n                \r\nQ:\n```\nCreate minimum no of groups of subsequent elements with max diff between elments being less than k\n```\n\nConstraints:\n```\n0 < A[i] < MAX_INT\nNumber of elements: 1 < N < 10^6\n```\n\nInput\n```\nN = 11\nA = [1,2,4,10,5,4,11,21,15,5,1]\nK = 11\n```\n\nOutput\n```\n[ [1,2,4,10,5,4,11], [21,15], [5,1] ]\n```\n\nExplanation:\n```\nGroup 1: min = 1, max = 11 -> diff = 10, can't include 21 as max diff between this group will become 21-1 = 20, it shouldn't exceed 10 \n\nGroup 2: min = 15, max = 21 -> diff = 6 => 6 < k can't include 5 as max diff will exceed K\n\nGroup 3: min = 1, max = 5 -> diff = 4 => 4 < k \n```\n\nWill greedy algorithm always return correct answer if we start from 1st element and maintain local min,max value and create groups ?\n    ", "Answer": "\r\nThe greedy algorithm is optimal.\nLet F(A) be the minimum number of groups the array A can be divided into.\nAssume A is 1 based indexed and A[k: j] is the sub array from A[k] to A[j] where k <= j\nClearly\n```\nF(A[2:n]) >= F(A[3:n])\nF(A[3:n]) >= F(A[4:n])\nand so on\n```\n\nSo it is optimal for the first group that you select to be as long as possible.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Restricted integer partitions in Python\r\n                \r\nI want to find out how many ways there are to make 500 using only 1, 2, 5, 10, 20, 50, 100, and 200.\nI understand that there exist greedy algorithms etc that can solve this type of question, but I want to be able to do it the following way:\n\nThe number of integer partitions of a given number, n, using only numbers from some set T, can be obtained from the coefficient of the xn term in the product of all (1-xt)-1, where t is in T.\n\nTo do this, note that the Taylor expansion of (1-xt)-1 equals (1+xt+x2t+...).\nHere is the code I've written so far:\n\n```\n#################################\n# First, define a function that returns the product of two \n# polynomials. A list here\n# represents a polynomial with the entry in a list corresponding to \n# the coefficient of the power of x associated to that position, e.g. \n# [1,2,3] = 1 + 2x + 3x^2.\n#################################\n\ndef p(a,v):\n    \"\"\"(list,list) -> list\"\"\"\n    prodav = [0]*(len(a)+len(v)-1)\n\n    for n in range(len(a)):\n        for m in range(len(v)):\n            prodav[n+m] += v[m]*a[n]\n\n    return prodav\n\n#################################\n# Now, let a,b,c,...,h represent the first 501 terms in the Taylor \n# expansion of 1/(1-x^n), where n gives the coin value, i.e \n# 1,2,5,10,20,50,100,200 in pence. See the generating function\n# section in https://en.wikipedia.org/wiki/Partition_(number_theory).\n# Our function, p, multiplies all these polynomials together\n# (when applied iteratively). As per the Wiki entry, the coefficient \n# of x^t is equal to the number of possible ways t can be made,\n# using only the denominations of change available, a so called \n# 'restricted integer partition'. Note that it isn't necessary to \n# consider the entire Taylor expansion since we only need the\n# 500th power.\n#################################\n\na = ( [1]           ) * 501            #   1\nb = ( [1] + [0]     ) * 250 + [1]      #   2\nc = ( [1] + [0]*4   ) * 100 + [1]      #   5\nd = ( [1] + [0]*9   ) *  50 + [1]      #  10\ne = ( [1] + [0]*19  ) *  25 + [1]      #  20\nf = ( [1] + [0]*49  ) *  10 + [1]      #  50\ng = ( [1] + [0]*99  ) *   5 + [1]      # 100\nh = ( [1] + [0]*199 ) *   2 + [0]*101  # 200\n\nx = p(h,p(g,p(f,p(e,p(d,p(c,p(b,a)))))))\n\nprint(x[500])  # = 6290871\n```\n\n\nMy problem is that I'm not confident the answer this gives is correct. I've compared it to two other greedy algorithms whose outputs agree with each other, but not mine. Can anyone see where I might have gone wrong?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Optimal C implementation of the Towers of Hanoi puzzle with k pegs\r\n                \r\nHow do you solve the Towers of Hanoi puzzle when there are k pegs?  Can it be done in an optimal way in C?  Is there a greedy algorithm for it?\n    ", "Answer": "\r\nSee this github page for the code in C: https://github.com/kcolford/hanoi/blob/master/src/hanoi.c\n\nSee this page to know why it's minimal: http://kcolford.com/the-towers-of-hanoi-2/\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Maximizing the number of Tasks so that starting time of the first Task is always the Earliest\r\n                \r\nMy code is inspired by the following article which contains the code-sample which determines the maximum number of activities that can be performed using a greedy algorithm.\nI am treating the problem differently with respect to the greedy idea. I would like to begin at the Earliest Start Time and only then let the greedy algorithm to determine the optimal solution  (i.e. non-overlapping pairs beginning from the Earliest Start Time).\nI'm using ```\nPriorityQueue```\n because I'm treating the input as unsorted.\nI'm curious to know how to choose the activity having the Earliest Start Time and proceed with maximum number of non-overlapping pairs (activities)?\nMy code:\n```\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\n \nclass GFG {\n \n  // Pair class\n  static class Pair {\n \n    int first;\n    int second;\n \n    Pair(int first, int second)\n    {\n      this.first = first;\n      this.second = second;\n    }\n  }\n \n  static void SelectActivities(int s[], int f[])\n  {\n \n    // Vector to store results.\n    ArrayList<Pair> ans = new ArrayList<>();\n \n    // Minimum Priority Queue to sort activities in\n    // ascending order of finishing time (f[i]).\n    PriorityQueue<Pair> p = new PriorityQueue<>(\n      (p1, p2) -> p1.first - p2.first);\n \n    for (int i = 0; i < s.length; i++) {\n      // Pushing elements in priority queue where the\n      // key is f[i]\n      p.add(new Pair(f[i], s[i]));\n    }\n \n    Pair it = p.poll();\n    int start = it.second;\n    int end = it.first;\n    ans.add(new Pair(start, end));\n \n    while (!p.isEmpty()) {\n      Pair itr = p.poll();\n      if (itr.second >= end) {\n        start = itr.second;\n        end = itr.first;\n        ans.add(new Pair(start, end));\n      }\n    }\n    System.out.println(\n      \"Following Activities should be selected. \\n\");\n \n    for (Pair itr : ans) {\n      System.out.println(\n        \"Activity started at: \" + itr.first\n        + \" and ends at  \" + itr.second);\n    }\n  }\n \n  // Driver Code\n  public static void main(String[] args)\n  {\n \n    int s[] = { 1, 3, 0, 5, 8, 5 };\n    int f[] = { 2, 4, 6, 7, 9, 9 };\n \n    // Function call\n    SelectActivities(s, f);\n  }\n}\n```\n\n\nCurrent output:\n```\nFollowing Activities should be selected. \n\nActivity started at: 1 and ends at  2\nActivity started at: 3 and ends at  4\nActivity started at: 5 and ends at  7\nActivity started at: 8 and ends at  9\n```\n\nDesired output:\n```\nFollowing Activities should be selected. \n\nActivity started at: 0 and ends at  6\nActivity started at: 8 and ends at  9\n```\n\n    ", "Answer": "\r\nIn order to always start with the earliest task and then pick the rest tasks in such a way that the number of the fulfilled tasks would be maximal, firstly we need to determine the earliest task and then apply a greedy approach to maximize the total number of tasks.\nThe problem can be addressed in the following steps:\n\nParse the pair of given arrays and create a queue of tasks.\n\nFind the earliest task and remove it from the queue.\n\nApply a greedy algorithm to find the rest tasks.\n\nPrint the list of tasks.\n\n\nFor conciseness to represent a task, I'm using Java 16 record (you can substitute with a class).\nThat's how it can be implemented:\n```\npublic record Task(int start, int finish) {}\n\npublic static void selectActivities(int[] start, int[] finish) {\n    if (start.length == 0 || start.length != finish.length) {\n        return; // throw an exception\n    }\n    \n    Queue<Task> tasks = createTasks(start, finish);\n    Task earliest = pickEarliest(tasks);\n    \n    List<Task> fulfilledTasks = getFulfilledTasks(tasks, earliest);\n    \n    printFulfilledTasks(fulfilledTasks);\n}\n\npublic static Queue<Task> createTasks(int[] start, int[] finish) {\n    Queue<Task> tasks = new PriorityQueue<>(Comparator.comparingInt(Task::finish));\n    for (int i = 0; i < start.length; i++) {\n        tasks.add(new Task(start[i], finish[i]));\n    }\n    return tasks;\n}\n\npublic static Task pickEarliest(Queue<Task> tasks) {\n    Task earliest = null;\n    for (Task task: tasks) {\n        if (earliest == null || task.start() < earliest.start()) {\n            earliest = task;\n        }\n    }\n    tasks.remove(earliest);\n    return earliest;\n}\n\npublic static List<Task> getFulfilledTasks(Queue<Task> tasks, Task earliest) {\n    List<Task> result = new ArrayList<>();\n    result.add(earliest);\n    \n    Task current = earliest;\n    \n    while (!tasks.isEmpty()) {\n        Task next = tasks.remove();\n        if (next.start() >= current.finish()) {\n            result.add(next);\n            current = next;\n        }\n    }\n    return result;\n}\n\npublic static void printFulfilledTasks(List<Task> tasks) {\n    selectActivities(new int[]{ 1, 3, 0, 5, 8, 5 }, new int[]{ 2, 4, 6, 7, 9, 9 });\n}\n```\n\nOutput:\n```\nActivity has started at: 0 and ended at 6\nActivity has started at: 8 and ended at 9\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Integer partition weighted minimum of maximum\r\n                \r\nGiven a non-negative integer ```\nn```\n and a positive real weight vector ```\nw```\n with dimension ```\nm```\n, partition ```\nn```\n into a length-```\nm```\n non-negative integer vector that sums to ```\nn```\n (call it ```\nv```\n) such that ```\nmax w_iv_i```\n is the smallest, that is, we want to find the vector ```\nv```\n such that the maximum of element-wise product between ```\nw```\n and ```\nv```\n is the smallest. There maybe several partitions, and we only want the smallest value of ```\nmax w_iv_i```\n among all possible ```\nv```\n.\nSeems like this problem can use a greedy algorithm to solve. From a target vector ```\nv```\n for ```\nn-1```\n, we add 1 to each entry, and find the minimum among those ```\nm```\n vectors. but I don't think it's correct. The intuition is that it might add \"over\" the minimum. That is, there exists another partition not yielded by the add 1 procedure that falls in between the \"minimum\" of ```\nn-1```\n produced by this greedy algorithm and that of ```\nn```\n produced by this greedy algorithm. Can anyone prove if this is correct or incorrect?\n    ", "Answer": "\r\nIf you already know the maximum element-wise product P, then you can just set vi = floor(P/wi) until you run out of n.\nUse binary search to find the smallest possible value of P.\nThe largest guess you need to try is n * min(w), so that means testing log(n) + log(min(w)) candidates, spending O(m) time for each test, or O(m*(log n + log(min(w))) all together.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to get integers from list where sum of them is less than X?\r\n                \r\nSorry for the mess that was here.\nI wanted a classic greedy algorithm for knapsack problem in haskell for integers.\nBut there was other question - how to refer to list in list comprehension?\n    ", "Answer": "\r\nThere are several approaches to this:\n\nGenerate all lists which are smaller. Take the longest\n\nFor every ```\nn <= X```\n, generate ```\n[1..n]```\n and check whether its sum is lesser ```\nx```\n. Take the longest of those sets:\n\n```\nallLists x = takeWhile ( (<=x) . sum) $ inits [1..]\ntheList    = last . allLists\n```\n\n\nwhere ```\ninits```\n is from ```\nData.List```\n\n\nAlternatively, we remember mathematics\n\nWe know that the sum of ```\n[1..n]```\n is ```\nn*(n+1)/2```\n. We want ```\nx >= n * (n+1)/2```\n. We solve for n and get that ```\nn```\n should be ```\n0.5 * (sqrt (8 * x + 1) - 1)```\n. Since that's not a natural number, we floor it:\n\n```\ntheList x  = [1..n]\n   where n = floor $ 0.5 * (sqrt (8 * (fromIntegral x) + 1) - 1)\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Finding maximum number that can be composed out of a set of integers using greedy algorithm\r\n                \r\nI am trying to compose the largest possible number out of a set of integers. The code only works if the input is single digits otherwise it gives me wrong answer. for example, if the input is 2, 21 it gives me 212 instead of 221. I have tried to edit the code but I got stuck. I had an idea to convert any number the user enters to digits i.e 210 -> 2, 1, 0. but I don't know how to implement it.\n```\nint IsGreaterOrEqual(int n1, int n2)\n{\n    \n}\n\nvoid swap(int* xp, int* yp)\n{\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n\nvoid selectionSort(int arr[], int n)\n{\n    int i, j, min_idx;\n\n    // One by one move boundary of unsorted subarray\n    for (i = 0; i < n - 1; i++) {\n\n        // Find the minimum element in unsorted array\n        min_idx = i;\n        for (j = i + 1; j < n; j++)\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n\n        // Swap the found minimum element\n        // with the first element\n        swap(&arr[min_idx], &arr[i]);\n    }\n}\n\nint main()\n{\n    int n;   //number of elements\n    scanf(\"%d\", &n);\n    int ints[n], sol[n];\n    int size = sizeof(ints)/sizeof(ints[0]); \n\n    for(int i = 0; i < n; i++){   //taking the inputs from the user\n        scanf(\"%d\", &ints[i]);\n    }\n\n    ints[n] = selectionSort(ints, size);   //sort the array in ascending order\n\n\n    for(int i = n-1; i >= 0; i--){   //here is where I am stuck\n        \n    }\n}\n```\n\nI am was going to use IsGreaterOrEqual function to append the 2 numbers forward and backward and return the greatest number. for example, append 2 and 21 -> 221 and 212.\nHow can I edit the code to work for any set of positive integers?\n    ", "Answer": "\r\nAt first you produce undefined behaviour by accessing an array beyond its bounds with ```\nints[n] = ...```\n – not sure why you return a value at all, as you sort in place anyway. What would be the semantics of that return value? Rather change to ```\nvoid```\n and just drop that assignment.\nSame occurs on reading ```\nints[i-1]```\n for ```\ni```\n being 0...\nThen you try sorting sorting the input by their integral value (you scan as ```\nint```\ns). The problem with: Consider the two values ```\n2```\n and ```\n11```\n – obviously the smaller one needs to come first; however if you consider ```\n22```\n and ```\n1```\n now the larger one needs to come first. This just as obviously reveals that you cannot sort that way. Instead you need to sort the numbers lexicographically by their textual representation.\nFor this purpose read the numbers as C strings into appropriate arrays; make sure you prevent undefined behaviour by reading beyond the array bounds, i.e. provide maximum length to ```\nscanf```\n (e.g. ```\nscanf(\"%31s\", array)```\n for a 32 character array) or maybe prefer ```\nfgets```\n or ```\ngetline```\n together with ```\nstrtok```\n over ```\nscanf```\n.\nYou optionally might want to add a check if those strings really only contain digits by iterating over them and checking with ```\nis_digit```\n (to be fully correct convert the input characters to ```\nunsigned char```\n for, covering characters with values > 127 on ```\nchar```\n being signed!).\nNow you can simply compare these strings via ```\nstrcmp```\n – however you need special handling for one string being a prefix of the other one, in worst case recursively (remainder or old prefix again being a new prefix of the other one...).\nThis can lead to code e.g. as follows:\n```\nint less(char const* x, char const*y)\n{\n    size_t nx = strlen(x);\n    size_t ny = strlen(y);\n    size_t min = nx < ny ? nx : ny;\n    int factor = 1;\n    for(;;)\n    {\n        int cmp = strncmp(x, y, min);\n        if(cmp != 0)\n        {\n            return factor * cmp < 0;\n        }\n        if(nx == ny)\n        {\n            return 0; // equal -> not less\n        }\n        if(nx < ny)\n        {\n            // need to change roles!\n            size_t ntmp = nx;\n            nx = ny;\n            ny = ntmp;\n            char const* tmp = x;\n            x = y;\n            y = tmp;\n            factor = -factor;\n        }\n        nx -= ny;\n        x += ny;\n    }\n}\n```\n\nDemonstration on godbolt...\nFor the final main you might scan into a 2D character array and then create an additional array of pointers into the 2D array (you can swap pointers more efficiently) or read in all input at once into a large 1D character array and tokenise with ```\nstrtok```\n, again placing the resulting pointers into another array (I personally prefer the latter approach, actually I'd do the tokenising on my own on checking the digits, if doing so at all). Now sort the pointer array in place in descending order using above comparison and just output the array entries one after another – no need for any second array (```\nsol```\n in your case)...\nFinal recommendation: Try to understand, if need be, ask a new question or leave a comment and then re-implement on your own. This is the way you learn something from. If you instead prefer just to copy 'n' paste the ready to use code – feel free to do so, I don't mind. Nothing learnt then, but not my problem ;)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Minimizing the number of boxes that cover a given set of intervals\r\n                \r\nthis is a question for the algorithms gurus out there :-)\n\nLet ```\nS```\n be a set of intervals of the natural numbers that might overlap and ```\nb```\n a box size. Assume that for each interval, the range is strictly less than ```\nb```\n.\n\nI want to find the minimum set of intervals of size ```\nb```\n (let's call it ```\nM```\n) so all the intervals in ```\nS```\n are contained in the intervals of ```\nM```\n.\n\nTrivial example:\n\n```\nS = {[1..4], [2..7], [3..5], [8..15], [9..13]}\nb = 10\nM = {[1..10], [8..18]}\n// so ([1..4], [2..7], [3..5]) are inside [1..10] and ([8..15], [9..13]) are inside [8..18]\n```\n\n\nI think a greedy algorithm might not work always, so if anybody knows of a solution to this problem (or a similar one that can be converted into), that would be great.\n\nThanks!\n\nUpdate I've been thinking a little bit more about it, and maybe my first intuition was wrong and a greedy algorithm is just the way to solve this, as in the end all the intervals need to be covered and it wouldn't make any difference how the super-intervals are chosen... Should I delete the question or maybe somebody can assert this?\n    ", "Answer": "\r\nThe algorithm might be the following.\n\n\na = 0\ncurr = lowest number in S that is > a. (In our case = 1. in [1..4])\nAdd an interval [curr..b] to M. (In our case M = {[1..10]} )\na = max upper bound in M. (In our case a = 10 )\nGo to 2.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What are the main differences between the Knuth-Morris-Pratt and Boyer-Moore search algorithms?\r\n                \r\nWhat are the main differences between the Knuth-Morris-Pratt search algorithm and the Boyer-Moore search algorithm?\n\nI know KMP searches for Y in X, trying to define a pattern in Y, and saves the pattern in a vector. I also know that BM works better for small words, like DNA (ACTG).\n\nWhat are the main differences in how they work? Which one is faster? Which one is less computer-greedy? In which cases?\n    ", "Answer": "\r\nMoore's UTexas webpage walks through both algorithms in a step-by-step fashion (he also provides various technical sources):\n\n\nKnuth-Morris-Pratt\nBoyer-Moore\n\n\nAccording to the man himself,\n\n\n  The classic Boyer-Moore algorithm suffers from the phenomenon that it\n  tends not to work so efficiently on small alphabets like DNA. The skip\n  distance tends to stop growing with the pattern length because\n  substrings re-occur frequently. By remembering more of what has\n  already been matched, one can get larger skips through the text. One\n  can even arrange ``perfect memory'' and thus look at each character at\n  most once, whereas the Boyer-Moore algorithm, while linear, may\n  inspect a character from the text multiple times. This idea of\n  remembering more has been explored in the literature by others. It\n  suffers from the need for very large tables or state machines.\n\n\nHowever, there have been some modifications of BM that have made small-alphabet searching viable.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "approximation ratio of maximum independent set? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nsuppose we have a weighted grid graph and our problem is to find maximum independent set. There is a greedy algorithm that each time choose the heaviest node and remove it and its neighbors until all nodes of G have been chosen or removed. we want to prove that W(s) >= 1/4 W(T) where S is our greedy result and T is the OPT solution.\n\nlet ```\nS```\n be the result of our greedy algorithm and ```\nT```\n be an arbitrary independent set which can be the OPT. We know that for any ```\nT```\n for any node ```\nv```\n which belongs to ```\nT-S```\n there exist a node ```\nv'```\n in ```\nS```\n which is neighbor of ```\nv```\n and ```\nw(v) <= w(v')```\n.\n\nIs there any idea to how prove that?\n    ", "Answer": "\r\nJust use your last statement, and consider ```\nT```\n as the maximum independent set and you have this two results :\n\n\nfor every node in ```\nT-S```\n like ```\nv```\n there exist a node like ```\nu```\n in ```\nS```\n were ```\nW(v) <= W(u)```\n. \neach node like ```\nu```\n in ```\nS```\n is at most neighbor of 4 nodes in ```\nT```\n.\n\n\nnow use them :)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why I am not getting desired output for my c++ problem\r\n                \r\nI am solving a question which states: to change every '?' with 'a' in a string if doesn't contain if won't form consecutive 'a' else substitute with 'b', eg. a?b will be abb and not aab because here 2 a's are consecutive.\n\nMy problem is for i = 3 my string should be over- written with 'b ' according to my code it is entering into the desired block but the string does n't gets written with b, but in all the other case where it should be witten with 'a' it get's written .Help me out with these.\n\nYou can refer the problem statement from here to for better understanding my problem :https://www.hackerearth.com/practice/algorithms/greedy/basics-of-greedy-algorithms/practice-problems/algorithm/exploring-ruins/\n\n```\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string str;\n    cin >> str;\n    int n = str.size();\n\n    for(int i = 0; i < str.size(); i++) {\n        if(str[i] == '?') {\n            if(i == 0) {\n                if(str[i + 1] == 'a')\n                    str[i] = 'b';\n                else\n                    str[i] = 'a';\n                cout << \"I am in if\" << endl;\n            } else if(i == n - 1) {\n                if(str[i - 1] == 'a')\n                    str[i] == 'b';\n                else\n                    str[i] == 'a';\n                cout << \"I am in if of  else if \" << endl;\n            } else {\n                if(str[i + 1] == 'a' || str[i - 1] == 'a') {\n                    str[i] == 'b';\n                    cout << \"I am in if  of  else \" << endl;\n                } else {\n                    str[i] = 'a';\n                    cout << \"I am in else of else \" << endl;\n                }\n            }\n            cout << str[i] << endl;\n        } else\n            continue;\n    }\n    cout << str << endl;\n\n    return 0;\n}\n```\n\n\nGiven string : ?ba??b\ndesired output : ababab\nmy output : aba?ab\n    ", "Answer": "\r\nIt will be a lot easier for you if you would use functions to solve this problem.\n\n```\nbool check_neighbors_for_a(const string &str, size_t place) {\n    bool result = false;\n    if (place > 0) { // If there is a char before the current char\n        result = str[place - 1] == 'a'; // If the previous char is 'a' result become true\n    }\n    if (place < str.size() - 1) { // If there is a char after the current char\n        result = result || str[place + 1] == 'a'; // If the result has become true before this line, result will stay true. Else, result will be true if the next char is equal to 'a'.\n        // For example: b?a => result = (false || 'a' == 'a')\n        // For example: a?b => result = (true  || 'b' == 'a')\n        // For example: a?a => result = (true  || 'a' == 'a')\n    }\n    return result;\n}\n\nvoid replace_questions_by_a(string &str) {\n    for (size_t i = 0; i < str.size(); i++) {\n        if (str[i] == '?') {\n            if (check_neighbors_for_a(str, i)) { // If one of the neighbors is equal to 'a'\n                str[i] = 'b'; // Place 'b' instead of '?'\n            } else {\n                str[i] = 'a'; // Place 'a' instead of '?'\n            }\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Dynamic Programming:optimal Binary search tree and Huffman\r\n                \r\nIs it possible to construct an optimal Binary search tree (OBST) via a greedy algorithm instead of with Dynamic Programming (DP) (for example Huffman's algorithm)? If so why is DP is preferred in the construction of a OBST?\n    ", "Answer": "\r\nThere are no efficient greedy algorithms to always construct an optimal binary search tree. However there are likely to be heuristics such as greedy algorithms that construct nearly optimal trees, which may be preferable in practice.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Give an efficient greedy algorithm that finds an optimal vertex cover for a tree in linear time\r\n                \r\nI'm trying to work on this problem...\nBelow mentioned is one algorithm..i figured out..\n\nInput a graph\n select a vertex with highest degree of matching with all the other nodes.\n Remove the edges that are incident on this node.\n Add the selected vertex and its edge to a set X.\n Return X\n\nWhere X returns the minimum set of vertices that are required for a vertex cover.Is this way correct...?\nThanks \n    ", "Answer": "\r\nTo select a vertex with highest degree can't guarantee to give the best solution. For example,\nyou have a tree with 7 vertices, edges are listed as follows:\n\n```\n1 2 // (1,2) is connected.\n1 3\n1 4\n2 5\n3 6\n4 7\n```\n\n\nThe minimum vertex cover is {2,3,4}, however, based on you greedy approach, you will choose {1} first, then you will choose at least 3 vertices to covered the left 3 edges.\n\nIndeed, there is a greedy algorithm to solve the vertex cover problem for a tree, that is you find a leaf at each step (since the input is a tree, you can always find such leaf unless there is no edge left), then select the neighbor of the leaf to the vertex cover set X. Return X as the minimum vertex cover when the graph is empty. The complexity is O(E) when E = V-1 so that we can say it is a linear solution.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Integer overflow in greedy coin counting\r\n                \r\n```\n#include <stdio.h>\n#include <cs50.h>\n#include <math.h>\n\nint main (void) { \n\n    printf (\"Enter amount: \");\n    float amount = GetFloat();\n    int coins = 0;\n\n    while (amount != 0) {\n\n        if (fmod(amount, 0.25) == 0) {\n            amount = amount - 0.25;\n            coins += 1;\n        }\n\n        else if (fmod(amount, 0.10) == 0) {\n            amount = amount - 0.10;\n            coins += 1;\n        }\n\n        else if (fmod(amount, 0.05) == 0) {\n            amount = amount - 0.05;\n            coins += 1;\n        }\n\n        else {\n            amount = amount - 0.01;\n            coins += 1;\n        }\n    }\n\n    printf (\"Coins : %d\\n\", coins);\n}\n```\n\n\nI'm trying to implement a small greedy algorithm, in which a user inputs an amount of money ( Ex: 9.25 ) and we output the least amount of coins that it takes for us to exchange it in change( 25 cents, 10 cents, 5 cents and 1 cent only).\n\nThis algorithm works with int amounts like 10 or 20 and with amounts that only requires the program to use the 25 cents coins.\n\nIf I try an amount like 9.10 or 9.01, I get a runtime error, signed integer overflow. I understand what it means, but I don't understand how can the value of coins go so high all of a sudden.\n    ", "Answer": "\r\nAs Danial Tran said it is better to use int when you do logical operations. Please read  Why not use Double or Float to represent currency? Also you can avoid while loop.\n\n```\n#include <stdio.h>\n#include <cs50.h>\n#include <math.h>\n\nint main (void) { \n\n    printf (\"Enter amount: \");\n    //float amount = GetFloat(); //Please refer to chqrlie's comments below.\n    double amount  = 0.0;\n    scanf(\"%lf\",&amount); //I don't know GetFloat() equivalent for double. So using scanf().\n\n    long long int amountInt = (long long int) (amount * 100.0);\n\n    int coins = 0;\n\n    if (25 <= amountInt) {\n        coins += (amountInt/25);\n        amountInt = amountInt % 25;\n    }\n\n    if (10 <= amountInt) {\n        coins += (amountInt/10);\n        amountInt = amountInt % 10;\n    }\n\n    if (5 <= amountInt) {\n        coins += (amountInt/5);\n        amountInt = amountInt % 5;\n    }\n\n    if (1 <= amountInt) {\n        coins += amountInt;\n    }\n\n    printf (\"Coins : %d\\n\", coins);\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "CS50 Problem Set 1(Cash/Greedy algorithm) getting runtime error: signed integer overflow\r\n                \r\n```\n#include <stdio.h>\n#include <cs50.h>\n#include <math.h>\n\nint main(void)\n{\n    int count = 0;\n    float change;\n    // prompt the user for input\n    do\n    {\n        change = get_float(\"Change owed: \");\n    }\n    while (change <= 0);\n    int cents = round(change * 100);\n    while (change >= 25)\n    {\n        cents -= 25;\n        count ++;\n    }\n    while (change >= 10)\n    {\n        cents -= 10;\n        count ++;\n    }\n    while (change >= 5)\n    {\n        cents -= 5;\n        count ++;\n    }\n    while (change >= 1)\n    {\n        cents -= 1;\n        count ++;\n    }\n    printf(\"%i\\n\", count);  \n}\n```\n\n\nIf a delete the \"round\" function and then replace coins with 0.25 0.10 etc. The program works, but it shows the wrong answer on some inputs.\nI can't think of anything. I'm new to programming but I feel like this is really simple it's just my lack of intelligence. \n    ", "Answer": "\r\nOh my gah. Can I swear here?? I'm so dumb!! The solution was simple! The problem was: I created an integer \"cents\" which rounds the \"change\" value. But in every while loop for each cent type I wrote like ```\n(change >= 10)```\n when it should've been ```\n(cents >= 10)```\n so the rounding actually happens. Now it works just as intended! Here's the corrected(and a little bit changed) code if somebody need help on this problem set:\n\n```\n#include <stdio.h>\n#include <cs50.h>\n#include <math.h>\n\nint main(void)\n{\n    float change;\n\n    int count = 0;\n    int total;\n    // prompt the user for input\n    do\n    {\n        change = get_float(\"Change owed: \");\n    }\n    while (change <= 0); // ask the user for only positive numbers\n\n    //rounds the input and stores the value in the variable \"total\"\n    total = round(change * 100);\n\n    //loops for each type of coins\n    while (total >= 25)\n    {\n        total -= 25;\n        count ++;\n    }\n    while (total >= 10)\n    {\n        total -= 10;\n        count ++;\n    }\n    while (total >= 5)\n    {\n        total -= 5;\n        count ++;\n    }\n    while (total >= 1)\n    {\n        total -= 1;\n        count ++;\n    }\n    //prints the converted(to int) and rounded value\n    printf(\"%i\\n\", count);  \n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Optimal epsilon (ϵ-greedy) value\r\n                \r\nϵ-greedy policy\n\nI know the Q-learning algorithm should try to balance between exploration and exploitation. Since I'm a beginner in this field, I wanted to implement a simple version of exploration/exploitation behavior.\n\nOptimal epsilon value\n\nMy implementation uses the ϵ-greedy policy, but I'm at a loss when it comes to deciding the epsilon value. Should the epsilon be bounded by the number of times the algorithm have visited a given (state, action) pair, or should it be bounded by the number of iterations performed?\n\nMy suggestions:\n\n\nLower the epsilon value for each time a given (state, action) pair has been encountered.\nLower the epsilon value after a complete iteration has been performed.\nLower the epsilon value for each time we encounter a state s.\n\n\nMuch appreciated!\n    ", "Answer": "\r\nAlthough in many simple cases the εk is kept as a fixed number in range 0 and 1, you should know that:\nUsually, the exploration diminishes over time, so that the policy used asymptotically becomes greedy and therefore (as Qk → Q∗) optimal. This can be achieved by making εk approach 0 as k grows. For instance, an ε -greedy exploration schedule of the form εk = 1/k diminishes to 0 as k → ∞, while still satisfying the second convergence condition of Q-learning, i.e., while allowing infinitely many visits to all the state-action pairs (Singh et al., 2000).\n\nWhat I do usually is this:\nset the initial alpha = 1/k (consider the initial k = 1 or 2)\nafter you go trial by trial as k increases the alpha will decrease.\nit also keeps the convergence guaranteed.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Repetition-based, pattern-based data compression algorithm\r\n                \r\nSuppose I have the following string:\n\n```\nABCADCADCADABC\n```\n\n\nI want to compress it by finding repeating substrings.\nWhat's an algorithm that gives the optimal compression?\n\nIn the above example it should return\n\n```\nAB*1 CAD*3 ABC*1\n```\n\n\nFor comparison, a greedy algorithm might return\n\n```\nABC*1 ADC*2 AD*1 ABC*1\n```\n\n    ", "Answer": "\r\nDepending on whether you prefer fast and simple or high compression ratio you could take a look into the Lempel-Ziv-Welch (LZW) or Lempel-Ziv-Markov chain (LZMA) algorithms. They both keep dictionaries of recurring strings.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Graph Coloring implementation in traffic routing\r\n                \r\nI want to use greedy algorithm for traffic phase allocation in road junction . But the problem is the greedy algorithm gives me a result that colored vertices(represent routs) those have same origin route(suppose AB route is V1 vertex, AC route is V2 vertex here both have origin A)   some times colored in different color .But in a origin of route , it is not possible to give permission to move some vehicle and not permit to some vehicle at a same time . How can I fix it. Suggest me other algorithm if needed.\nAnd I also want to use fuzzy coloring concept  on traffic phasing. How can I implement it?\nI by modifying the greedy algorithm . Consider the constrain that vertices that from same origin must colored in same color. But the result I find is , if there 4 origin than four color is needed to color the graph .. Which I think nothing worth to use programming.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Scip Branch and bound Pruning via bounds\r\n                \r\nIn using the SCIP library I was wondering how exactly pruning is done with respect to the bounds.\nIf we consider a minimization problem we can instantiate by computing a lower bound via LP-relaxation and upper bound via a greedy algorithm. Then after branching and computing LP-relaxations, we can confidently prune away portions that are worse than the greedy algorithm. But how exactly is this instantiating done in SCIP? Given an arbitrary MIP how does it identify the initial lower-bound.\nI've looked into the documentation but can't really find anything with confidence\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Triangulation of a convex polygon?\r\n                \r\nApply greedy algorithm to the problem of the\nminimum length triangulation of a convex polygon.\n\nHow far can greedy be away from optimum?\nShow the worst case for a pentagon.\n\nI am kind of confused about this question. I know A pentagon has 5 sides and thus 3 triangles. But I am not what is meant by greedy is that choosing a side with least length.\n\nAnd how is this different from the optimal.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Java : running time of big file inputs\r\n                \r\nI'm working on a project where i have ten files and for each file i have to use a greedy algorithm 10 times . However the files have huge inputs of 1000 up to 9000 elements . The code below is about only one file with 1000 elements and I  run it 10 times . I  calculate average running time and 2 other values and it takes 15 minutes for just one file . With what changes can I  make the process faster ? \n(all code runs perfectly nothing wrong with the methods displayed) \n\n```\n    public static void main(String[] args) {\n\n\n    long[] avg1=new long[10]; //stores running time of each try in array \n    long sum=0; //stores average running time \n    int gval=0;\n    int optval=0;\n    for(int i =0;i<10;i++)\n    {   \n        BuyersList b = new BuyersList();\n        BuyersList buyers = new BuyersList();\n        buyers.readFile(\"src/p500x1000.txt\"); //reads file and adds values to list \n        long start = System.currentTimeMillis();\n        b=buyers.greedy(500); //algorithm runs \n        long end = System.currentTimeMillis();    \n        avg1[i]=(end-start); //calculate running time of greedy algorithm\n        sum+=avg1[i];  //add time of one try to sum\n        gval=b.totalValue();\n        optval=buyers.opt;  \n    }\n\n\n    System.out.println(\"m= 500 :\");    // for 500 objects print the values below \n    System.out.println(\" n = 1000 : avgTime = \" + sum/10 + \" greedy value = \" + gval + \" opt value = \" + optval + \" \");\n\n\n\n    }\n```\n\n\ngreedy algorithm : \n\n```\npublic BuyersList greedy( int m  ) {\n\n    if(empty())\n    {\n        return null;\n    }\n    ItemsList lista = new ItemsList(); // create list of items \n    BuyerNode current=this.first;     // node that represents first buyer \n    boolean f = true;   //suppose one subset list exists \n\n    for(int i=0;i<m;i++)  //enter pointers of items \n    {\n        lista.append(i);\n    }\n\n    BuyersList best = new BuyersList(); //create the returning buyers list \n\n\n    while(f==true)    //while one subset list of complete list  exists in the list of buyers \n    {\n            current=this.maximum(this); //call maximum function to set current to maximum fraction \n            boolean flag = lista.contains(current.itemsList);   // if current's list is a subset \n            if(flag==true){\n            best.append(current.id,current.value,current.itemsList); //append current to the best list \n            lista.remove(current.itemsList); //remove current's list  from ItemsList \n            this.deleteNode(current.id); // call private deletenode function to delete current from buyers\n            this.nbNodes--;\n          }\n\n            else {this.deleteNode(current.id);}\n\n\n        BuyerNode bnode = this.first;\n        f = false;  //set f to false to exit loop if it doesn't change below \n        for(bnode=this.first;bnode!=null;bnode=bnode.next)\n        {   \n\n            if(lista.contains(bnode.itemsList))  //check if itemslist contains even one buyer subset list \n            {               \n\n                f = true;   //one subset list exists so loop again \n            }\n        }\n\n    } \n\n\n\n\n    return best;\n}\n```\n\n    ", "Answer": "\r\nWithout looking at your BuyersList.greedy() method, its difficult to suggest any code level optimizations. But assuming your algorithm is already optimized, and assuming you are running your jvm on a multi-core machine( which most of us these days are ), your current code is definitely not using the machine's full capacity. You can try running your file processing in parallel. \nYou can try something like this ( example code ) : \n\n```\nCompletableFuture<ReturnType> runAlgorithm(final String fileName){\n     return CompletableFuture.supplyAsync(()->{\n        BuyersList b = new BuyersList();\n        BuyersList buyers = new BuyersList();\n        buyers.readFile(fileName); \n        b=buyers.greedy(500);\n     }\n}\n\nvoid runAllInParallel(List<String> filenames){\n    List<CompletableFuture<ReturnType>> results = new ArrayList<>();\n    for(String file : filenames){\n         results.add(runAlgorithm(file));\n    }\n    // process results here.\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What is the best algorithm for computing rectilinear minimum Steiner tree?\r\n                \r\nThere are many algorithms that find approximations of rectilinear Steiner minimum trees (RSMT). Among them are:\n\n\na suite of algorithms that find minimum spanning trees\nRST-T (rectilinear single trunk Steiner tree)\nBGA (batcheed greedy algorithm)\nBI1S (Batched Iterated 1-Steiner tree)\nFLUTE (Fast Lookup Table Based Technique for RSMT Construction and Wirelength Estimation)\n\n\nIt was showed that length of RSMT can be as much as 3/2 times that of rectlinear spanning minimum tree. I didn't find in literature bounds for other algorithms. Do they exist?\n\nFLUTE seems to be the most efficient algorithm from all but I don't know it's worst case and upper bound. Was it found?\n\nDoes any algorithm have bound less than 3/2?\n    ", "Answer": "\r\nArora and Mitchell gave polynomial-time approximation schemes (= for all epsilon > 0, a (1 + epsilon)-approximation) for Euclidean Steiner tree. I believe the ideas can be adapted straightforwardly to the rectilinear variant.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Lambda function as a small function argument\r\n                \r\nI'm doing some tutorial on greedy algorithms and I came across ```\nlambda```\n function passed as a key parameter in sorted(). I thought I understood how they work (on simple examples like ```\nlambda a,b: a+b```\n), but now I'm confused, why the last line works ```\ntest_greedy(foods, max_cost, lambda x: 1/Food.get_cost(x))```\n.\nI get that ```\nx```\n must be passed because of ```\nself```\n and it's actually type ```\nFood```\n. What is unclear to me is how and when ```\nx```\n gets instantiated.\n\nHere is the relevant part of the code:\n\n```\nclass Food:\n    def __init__(self, name, value, weight):\n        self.name = name\n        self.value = value\n        self.calories = weight\n\n    def get_value(self):\n        return self.value\n\n    def get_cost(self):\n        return self.calories\n\ndef greedy(items, max_cost, key_function):\n    \"\"\"\n    key_function maps elements of items to numbers, tells what is meant by \"BEST\"\n    \"\"\"\n    items_copy = sorted(items, key = key_function, reverse = True)\n\n    result = []\n    total_value, total_cost = 0.0, 0.0\n\n    for i in range(len(items_copy)):\n        if (total_cost+items_copy[i].get_cost()) <= max_cost:\n            result.append(items_copy[i])\n            total_cost += items_copy[i].get_cost()\n            total_value += items_copy[i].get_value()\n\n    return (result, total_value)\n\ndef use_greedy(max_cost):\n    print(\"Use greedy by cost to allocate\", max_cost, \"calories\")\n    test_greedy(foods, max_cost, lambda x: 1/Food.get_cost(x))\n```\n\n    ", "Answer": "\r\nThe lambda gets evaluated when you call ```\ntest_greedy```\n with that as the argument.  It becomes a function descriptor assigned to ```\nkey_function```\n.  Note that ```\nx```\n is still an unbound parameter at this point.\n\nWhen you later pass that function to ```\nsorted```\n as the sort key, then it gets called to evaluate each comparison between the elements of ```\nitems```\n.  One by one, they are passed as ```\nx```\n to be evaluated, with ```\n1/Food.get_cost(x)```\n being the numerical value used to sort the elements.\n\nDoes that clear it up?\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Bin packing bruteforce method\r\n                \r\nI need to make program that solves bin packing problem, but I already made first fit and greedy algorithms, but my lecturer says in some cases it won't find the minimal solution to the problem. So i decided to try bruteforce, but I have no clue how it should check all possible solutions. So yea.. can someone explain to me or give pseudo-code or something. I would appreciate a lot. \n    ", "Answer": "\r\nNote that bin-packing is an NP-hard problem, basically meaning it will take excessively long to run brute force on it, even for relatively small input, so brute force for NP-hard problems is almost never a good idea. The link above shows some alternatives (or approximations). But I'll continue...\n\nRecursion makes brute force easy. Once you understand a basic recursive algorithm, continue reading...\n\nBasic idea: (for 3 items, 2 bins, assuming everything fits, if it doesn't just skip that branch)\n\n```\nPut the first item in the first bin.\n  Put the second item in the first bin.\n    Put the third item in the first bin.\n      Woo-hoo! We have a solution!\n    Remove the third item from the first bin and put it into the second bin.\n      Woo-hoo! We have a solution!\n    Remove the third item from the second bin.\n  Remove the second item from the first bin and put it into the second bin.\n    Put the third item in the first bin.\n      Woo-hoo! We have a solution!\n    Remove the third item from the first bin and put it into the second bin.\n      Woo-hoo! We have a solution!\n    Remove the third item from the second bin.\n  Remove the second item from the second bin.\nRemove the first item from the first bin and put it into the second bin.\n  Put the second item in the first bin.\n    Put the third item in the first bin.\n      Woo-hoo! We have a solution!\n    Remove the third item from the first bin and put it into the second bin.\n      Woo-hoo! We have a solution!\n    Remove the third item from the second bin.\n  Remove the second item from the first bin and put it into the second bin.\n    Put the third item in the first bin.\n      Woo-hoo! We have a solution!\n    Remove the third item from the first bin and put it into the second bin.\n      Woo-hoo! We have a solution!\n    Remove the third item from the second bin.\n  Remove the second item from the second bin.\nRemove the first item from the second bin.\n```\n\n\n(See how many steps there is already? And this is just for 3 items and 2 bins)\n\nPseudo-code:\n\n```\nrecurse(int itemID)\n  if pastLastItem(itemID)\n    if betterThanBestSolution\n      bestSolution = currentAssignment\n    return\n  for each bin i:\n    putIntoBin(itemID, i)\n    recurse(itemID+1)\n    removeFromBin(itemID, i)\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Proven Algorithm for breaking data into batches of same size\r\n                \r\nI need to club following sorted data into batch of same size, let say ```\n100k```\n.\n```\n181000 : Zee5\n164000 : VootSelect\n40000 : SunNxt\n30000 : SonyLiv\n21213 : Prime\n13505 : VootKids\n10616 : epicOn\n4705 : ErosNow\n2438 : Hungama\n1878 : CuriosityStream\n849 : Tatasky\n116 : docubay\n50 : Shemaroome\n```\n\nExpected:\n\nBatch 1: 100000 : Zee5\nBatch 2: 81000 : Zee5 19000 : VootSelect\nBatch 3: 100000 : VootSelect\nBatch 4: 45000 : VootSelect 40000 : SunNxt 15000 : SonyLiv\nBatch 5: So on....\n\nI tried to build my own logic for same, using the following greedy algorithm found on hackerearth:\n```\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nconst int MAX = 105;\nint A[MAX];\n\nint main()\n{\n    int T, N, numberOfThings = 0, currentTime = 0;\n    cin >> N >> T;\n    for(int i = 0;i < N;++i)\n        cin >> A[i];\n    sort(A, A + N);\n    for(int i = 0;i < N;++i)\n    {\n        currentTime += A[i];\n        if(currentTime > T)\n            break;\n        numberOfThings++;\n    }\n    cout << numberOfThings << endl;\n    return 0;\n}\n```\n\nSolution didn't worked,not sure greedy algorithm is best suited for this.\nAs this scenario is not very rare, peoples may solve this type of use case often, I am looking for proven algorithm to solve this use case.\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "TSP using divide and conquer\r\n                \r\nI'm solving traveling salesman problem in different ways. I've already solved it using backtracking and greedy algorithms. Now I have to solve it using divide and conquer. I understand how divide and conquer works but I can't understand how I can apply it to this problem. I tried looking for something in google but found almost nothing. I'd be vary grateful to hear some advices. Thank you.\n    ", "Answer": "\r\nThe reason is probably, that TSP is not easily partitioned into independent sub-problems. This is a prerequisite to apply a divide and conquer strategy.\nThe paper Multilevel Graph Partitioning Scheme to Solve Traveling Salesman Problem describes how to use multilevel graph partitioning. To reduce the overall complexity, a K-Means clustering/partitioning algorithm is used to divide the TSP into multiple parts. In a second stage, each partition is solved separately.  As a final step, the combined solution is improved by applying the Lin Kernighan heuristic.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Selection of Non-overlapping Intervals\r\n                \r\nI'm trying to implement an algorithm described in this paper (The GBDP strategy, \"matching distance\") and need a bit of clarification.\n\nBasically, the problem is that I have a list of items where each item has a length and an interval (It's actually two intervals, but it's the same idea).\n\n```\nID    LENGTH    START    END\n1     1000      1        1000\n2     20000     5        20005\n3     20        30500    30520\n4     500       30500    31000\n5     200       900      1100     \n```\n\n\nThe goal is to find a subset of items with non-overlapping ranges. In the paper, they say they first sort the items by length\n\n```\nID    LENGTH    START    END\n2     20000     5        20005\n1     1000      1        1000\n4     500       30500    31000\n5     200       900      1100\n3     20        30500    30520\n```\n\n\nand then proceed to \"greedily choosing a subset of [items] with non-overlapping intervals.\" Here's where I'm confused. I know what a greedy algorithm is, but I'm not sure what the authors mean here. I guessed it could be that they simply go through the list, keeping only those items that don't overlap with the ones above them.\n\n```\nID    LENGTH    START    END\n2     20000     5        20005\n4     500       30500    31000\n5     200       900      1100\n3     20        30500    30520\n```\n\n\nNotice that, with this approach, the result still includes items with overlapping ranges (4 and 3). \n\nI managed to easily implement this approach in Perl, but I'm thinking it's probably not what the authors intended. Do they mean keeping items that don't overlap with any of the other items above them? I'd appreciate if someone explained what \"greedy selection\" means in this context.\n    ", "Answer": "\r\nYou are correct almost to the end (and in the point where not, you raise the correct interpretation as an option). \n\nFirst, as you say, sort things so that lengths are decreasing:\n\n```\nID    LENGTH    START    END\n2     20000     5        20005\n4     500       30500    31000\n5     200       900      1100\n3     20        30500    30520\n```\n\n\nNow we will greedily choose intervals as long as they don't conflict with any of the previous ones chose. So, with the chosen set initially empty,\n\n\nInitially, 2 is the greediest choice we can make (the length is 20000). It doesn't conflict, and so we add it to the chosen set.\nDitto for 4, and 5. The chosen set is now {2, 4, 5}.\nThe next greedy (as well as simply remaining) choice is 3. Since it does conflict with any of the previous ones, namely 4, we cannot use it. \n\n\nThe result is {2, 4, 5}, therefore.\n\n\n\nFYI, this is closely related to a well-known problem in computer science - Interval Scheduling. If you're trying to optimize the total number of matches, and not the total length of matches, you sort by end position and greedily choose.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Selection of Non-overlapping Intervals\r\n                \r\nI'm trying to implement an algorithm described in this paper (The GBDP strategy, \"matching distance\") and need a bit of clarification.\n\nBasically, the problem is that I have a list of items where each item has a length and an interval (It's actually two intervals, but it's the same idea).\n\n```\nID    LENGTH    START    END\n1     1000      1        1000\n2     20000     5        20005\n3     20        30500    30520\n4     500       30500    31000\n5     200       900      1100     \n```\n\n\nThe goal is to find a subset of items with non-overlapping ranges. In the paper, they say they first sort the items by length\n\n```\nID    LENGTH    START    END\n2     20000     5        20005\n1     1000      1        1000\n4     500       30500    31000\n5     200       900      1100\n3     20        30500    30520\n```\n\n\nand then proceed to \"greedily choosing a subset of [items] with non-overlapping intervals.\" Here's where I'm confused. I know what a greedy algorithm is, but I'm not sure what the authors mean here. I guessed it could be that they simply go through the list, keeping only those items that don't overlap with the ones above them.\n\n```\nID    LENGTH    START    END\n2     20000     5        20005\n4     500       30500    31000\n5     200       900      1100\n3     20        30500    30520\n```\n\n\nNotice that, with this approach, the result still includes items with overlapping ranges (4 and 3). \n\nI managed to easily implement this approach in Perl, but I'm thinking it's probably not what the authors intended. Do they mean keeping items that don't overlap with any of the other items above them? I'd appreciate if someone explained what \"greedy selection\" means in this context.\n    ", "Answer": "\r\nYou are correct almost to the end (and in the point where not, you raise the correct interpretation as an option). \n\nFirst, as you say, sort things so that lengths are decreasing:\n\n```\nID    LENGTH    START    END\n2     20000     5        20005\n4     500       30500    31000\n5     200       900      1100\n3     20        30500    30520\n```\n\n\nNow we will greedily choose intervals as long as they don't conflict with any of the previous ones chose. So, with the chosen set initially empty,\n\n\nInitially, 2 is the greediest choice we can make (the length is 20000). It doesn't conflict, and so we add it to the chosen set.\nDitto for 4, and 5. The chosen set is now {2, 4, 5}.\nThe next greedy (as well as simply remaining) choice is 3. Since it does conflict with any of the previous ones, namely 4, we cannot use it. \n\n\nThe result is {2, 4, 5}, therefore.\n\n\n\nFYI, this is closely related to a well-known problem in computer science - Interval Scheduling. If you're trying to optimize the total number of matches, and not the total length of matches, you sort by end position and greedily choose.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Select the most appropriate technique and describe the solution for calculating the sum of the even numbers in a given list\r\n                \r\n\"Select the most appropriate technique and describe the solution for calculating the sum of the even numbers in a given list\"\nIt seems like an easy question but I'm stuck. By technique it means backtracking/divide and conquer/greedy/dynamic programming.\nI thought the answer would be greedy? Is this correct? And I have to describe the set of candidates and how I make the selection for the greedy algorithm.\nI thought that we should simply iterate through the list, see if the each element is even. If an element is even, then we add it to the sum. This is not a backtracking/divide and conquer or dynamic programming approach, so it is greedy. So at the start, the set of candidates for the greedy algorithm is each element of the list. We select each time the first element in the set of candidates and we remove it from the set. And then we check if it is even. And the solution function will indicate when we have discovered a complete solution when the set is empty. Is this correct?\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "TypeError: 'bool' object is not subscriptable: Greedy Best First Search\r\n                \r\nI am coding Greedy Best First Search Algorithm in Python, and this is the error that I am getting.\n```\nTypeError                                 Traceback (most recent call last)\n<ipython-input-4-7cb06a2b610d> in <module>\n     41 source = 0\n     42 target = 9\n---> 43 best_first_search(source, target, v)\n\n<ipython-input-4-7cb06a2b610d> in best_first_search(source, target, n)\n     15 \n     16         for v, c in graph[u]:\n---> 17             if visited[v] == False:\n     18                 visited[v] = True\n     19                 pq.put((c, v))\n\nTypeError: 'bool' object is not subscriptable\n```\n\nGreedy Best First Search is basically a combination of DFS and BFS using the PriorityQueue library i am trying to get the one with the lower score.\nMy code is:\n```\nfrom queue import PriorityQueue\nv = 14\ngraph = [[] for i in range(v)]\n \ndef best_first_search(source, target, n):\n    visited = [0] * n\n    visited = True\n    pq = PriorityQueue()\n    pq.put((0, source))\n    while pq.empty() == False:\n        u = pq.get()[1]\n        print(u, end=\" \")\n        if u == target:\n            break\n \n        for v, c in graph[u]:\n            if visited[v] == False:\n                visited[v] = True\n                pq.put((c, v))\n    print()\n\ndef addedge(x, y, cost):\n    graph[x].append((y, cost))\n    graph[y].append((x, cost))\n\n    \naddedge(0, 1, 3)\naddedge(0, 2, 6)\naddedge(0, 3, 5)\naddedge(1, 4, 9)\naddedge(1, 5, 8)\naddedge(2, 6, 12)\naddedge(2, 7, 14)\naddedge(3, 8, 7)\naddedge(8, 9, 5)\naddedge(8, 10, 6)\naddedge(9, 11, 1)\naddedge(9, 12, 10)\naddedge(9, 13, 2)\n \nsource = 0\ntarget = 9\nbest_first_search(source, target, v)\n```\n\nPlz suggest a way to get the error out\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "what is the greedy approach of this?\r\n                \r\nsuppose we have some 2D boxes in a container surrounded by water. Unfortunately there is a hole in left hand side wall of container. The height of this hole is more than height of all boxes.length of all boxes is 1 m and their height is an integer.all boxes are put in one line.in every second the amount of water which insert through container is one square meter(take care our problem is in 2D context).we want to find how long it takes till a given box is one meter under the water.\nis there any greedy algorithm to efficiently solve this?\n    ", "Answer": "\r\nI think this algorithm can solve this in O(n).\n\nfrom the i-th box we first go to the end of line to find the first box which is a higher than the i-th box.since differences between all boxes' height is at least 1 meter so water can't go further than this box.then we go from the i-th box to the beginning of the line.we save height of the i-th box in Max_Height variable.each time we find a box higher than this Max_Height we update Max-Height.so whenever we find a box shorter than the Max_Height we add (Max_Height - box's height) to our result.at the end we have computed area of all previous and next wells.so we just need to compute the distance between the first next higher box and the first previous higher box and add it to our result.\nThat's it.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "How to implement a simple greedy multiset based algorithm in python\r\n                \r\nI would like to implement the following algorithm. For ```\nn```\n and ```\nk```\n, consider all combinations with repetitions in sorted order where we choose ```\nk```\n numbers from ```\n{0,..n-1}```\n with repetitions.  For example, if ```\nn=5```\n and ```\nk =3```\n we have:\n\n\n  [(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 0, 3), (0, 0, 4), (0, 1, 1), (0,\n  1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 2), (0, 2, 3), (0, 2, 4), (0, 3,\n  3), (0, 3, 4), (0, 4, 4), (1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4),\n  (1, 2, 2), (1, 2, 3), (1, 2, 4), (1, 3, 3), (1, 3, 4), (1, 4, 4), (2,\n  2, 2), (2, 2, 3), (2, 2, 4), (2, 3, 3), (2, 3, 4), (2, 4, 4), (3, 3,\n  3), (3, 3, 4), (3, 4, 4), (4, 4, 4)]\n\n\nI will treat each combination as a multiset from now on.  I want to greedily go through these multisets and partition the list.  A partition has the property the size of the intersection  of all the multisets within it must be at least ```\nk-1```\n.  So in this case we have:\n\n```\n(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 0, 3), (0, 0, 4)\n```\n\n\nthen\n\n```\n (0, 1, 1), (0, 1, 2), (0, 1, 3), (0, 1, 4)\n```\n\n\nthen\n\n```\n(0, 2, 2), (0, 2, 3), (0, 2, 4)\n```\n\n\nthen\n\n```\n(0, 3,  3), (0, 3, 4)\n```\n\n\nthen\n\n```\n(0, 4, 4)\n```\n\n\nand so on.\n\nIn python you can iterate over  the combinations as follows:\n\n```\nimport itertools\nfor multiset in itertools.combinations_with_replacement(range(5),3):\n    #Greedy algo\n```\n\n\n\n  How can I create these partitions?\n\n\nOne problem I have is how to compute the size of the intersection of multisets. The intersection of multisets ```\n(2,1,2)```\n and ```\n(3,2,2)```\n has size 2, for example.\n\n\n\nHere is the full answer for ```\nn=4, k=4```\n.\n\n```\n(0, 0, 0, 0), (0, 0, 0, 1), (0, 0, 0, 2), (0, 0, 0, 3)\n(0, 0, 1, 1), (0, 0, 1, 2), (0, 0, 1, 3)\n(0, 0, 2, 2), (0, 0, 2, 3)\n(0, 0, 3, 3)\n(0, 1, 1, 1), (0, 1, 1, 2), (0, 1, 1, 3)\n(0, 1, 2, 2), (0, 1, 2, 3)\n(0, 1, 3, 3)\n(0, 2, 2, 2), (0, 2, 2, 3)\n(0, 2, 3, 3), (0, 3, 3, 3)\n(1, 1, 1, 1), (1, 1, 1, 2), (1, 1, 1, 3)\n(1, 1, 2, 2), (1, 1, 2, 3)\n(1, 1, 3, 3)\n(1, 2, 2, 2), (1, 2, 2, 3)\n(1, 2, 3, 3), (1, 3, 3, 3)\n(2, 2, 2, 2), (2, 2, 2, 3)\n(2, 2, 3, 3), (2, 3, 3, 3)\n(3, 3, 3, 3)\n```\n\n    ", "Answer": "\r\nOne way to create the partitions is to iterate over your iterator and then compare each multiset* to the previous one. I tested 4 ways** to compare the multisets and the fastest I found was to test membership ```\nin```\n an iterator of the previous multiset that is consumed and short-circuits once the membership test fails. If the number of equal items in the multiset and the previous multiset equals the length of the multiset minus 1 then the criteria to group them is met. Then a resulting output generator of ```\nlist```\ns is built up where you ```\nappend```\n items that meet the criteria to the previous ```\nlist```\n and start a new ```\nlist```\n containing the ```\ntuple```\n otherwise, ```\nyield```\ning the groups one at a time to minimize memory usage:\n\n```\nimport itertools\n\ndef f(n,k):\n    prev, group = None, []\n    for multiset in itertools.combinations_with_replacement(range(n),k):\n        if prev:\n            it = iter(prev)\n            for idx, item in enumerate(multiset):\n                if item not in it:\n                    break\n            if idx == len(multiset) - 1:\n                group.append(multiset)\n                continue\n        if group:\n            yield group\n        group = [multiset]\n        prev = multiset\n    yield group\n```\n\n\n\n\nTest cases\n\nInput:\n\n```\nfor item in f(4,4):\n    print(item)\n```\n\n\nOutput:\n\n```\n[(0, 0, 0, 0), (0, 0, 0, 1), (0, 0, 0, 2), (0, 0, 0, 3)]\n[(0, 0, 1, 1), (0, 0, 1, 2), (0, 0, 1, 3)]\n[(0, 0, 2, 2), (0, 0, 2, 3)]\n[(0, 0, 3, 3)]\n[(0, 1, 1, 1), (0, 1, 1, 2), (0, 1, 1, 3)]\n[(0, 1, 2, 2), (0, 1, 2, 3)]\n[(0, 1, 3, 3)]\n[(0, 2, 2, 2), (0, 2, 2, 3)]\n[(0, 2, 3, 3), (0, 3, 3, 3)]\n[(1, 1, 1, 1), (1, 1, 1, 2), (1, 1, 1, 3)]\n[(1, 1, 2, 2), (1, 1, 2, 3)]\n[(1, 1, 3, 3)]\n[(1, 2, 2, 2), (1, 2, 2, 3)]\n[(1, 2, 3, 3), (1, 3, 3, 3)]\n[(2, 2, 2, 2), (2, 2, 2, 3)]\n[(2, 2, 3, 3), (2, 3, 3, 3)]\n[(3, 3, 3, 3)]\n```\n\n\nInput:\n\n```\nfor item in f(5,3):\n    print(item)\n```\n\n\nOutput:\n\n```\n[(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 0, 3), (0, 0, 4)]\n[(0, 1, 1), (0, 1, 2), (0, 1, 3), (0, 1, 4)]\n[(0, 2, 2), (0, 2, 3), (0, 2, 4)]\n[(0, 3, 3), (0, 3, 4)]\n[(0, 4, 4)]\n[(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4)]\n[(1, 2, 2), (1, 2, 3), (1, 2, 4)]\n[(1, 3, 3), (1, 3, 4)]\n[(1, 4, 4)]\n[(2, 2, 2), (2, 2, 3), (2, 2, 4)]\n[(2, 3, 3), (2, 3, 4)]\n[(2, 4, 4)]\n[(3, 3, 3), (3, 3, 4)]\n[(3, 4, 4), (4, 4, 4)]\n```\n\n\n\n\n* I'm calling them multisets to match your terminology but their actually ```\ntuple```\ns (ordered and immutable data structures); using a ```\ncollections.Counter```\n object, for example ```\nCounter((0, 0, 0, 1))```\n ```\nreturn```\ns ```\nCounter({0: 3, 1: 1})```\n, and decrementing would be like a true multiset approach but I found this to be slower because using the order is actually useful.\n\n** Other slower functions that give the same output that I tested:\n\n```\ndef f2(n,k):\n    prev, group = None, []\n    for multiset in itertools.combinations_with_replacement(range(n),k):\n        if prev:\n            if sum(item1 == item2 for item1, item2 in zip(prev,multiset)) == len(multiset) - 1:\n                group.append(multiset)\n                continue\n        if group:\n            yield group\n        group = [multiset]\n        prev = multiset\n    yield group\n\ndef f3(n,k):\n    prev, group = None, []\n    for multiset in itertools.combinations_with_replacement(range(n),k):\n        if prev:\n            lst = list(prev)\n            for item in multiset:\n                if item in lst:\n                    lst.remove(item)\n                else:\n                    break\n            if len(multiset) - len(lst) == len(multiset) - 1:\n                group.append(multiset)\n                continue\n        if group:\n            yield group\n        group = [multiset]\n        prev = multiset\n    yield group\n\nimport collections\ndef f4(n,k):\n    prev, group = None, []\n    for multiset in itertools.combinations_with_replacement(range(n),k):\n        if prev:\n            if sum((collections.Counter(prev) - collections.Counter(multiset)).values()) == 1:\n                group.append(multiset)\n                continue\n        if group:\n            yield group\n        group = [multiset]\n        prev = multiset\n    yield group\n```\n\n\nExample timings:\n\n```\nfrom timeit import timeit\nlist(f(11,10)) == list(f2(11,10)) == list(f3(11,10)) == list(f4(11,10))\n# True\ntimeit(lambda: list(f(11,10)), number = 10)\n# 4.19157001003623\ntimeit(lambda: list(f2(11,10)), number = 10)\n# 7.32002648897469\ntimeit(lambda: list(f3(11,10)), number = 10)\n# 6.236868146806955\ntimeit(lambda: list(f4(11,10)), number = 10)\n# 47.20136355608702\n```\n\n\nNote all approaches becomes slow for large values of ```\nn```\n and ```\nk```\n because of the large number of combinations generated.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "longest common subsequence, python, greedy\r\n                \r\nI have already submitted a draft code for the LCS problem of two sequences. I made bad mistakes trying greedy, now I have implemented I believe a stable greedy algorithm for this problem. Though I have two issues, this part of an online course, when I submit it it says for sequences [1,2,3] and [3,2,1] the correct output is 1, where I believe Why? So, I went to the correct versions and tested, it works fine, that is the output is 0, and tested it for many good test cases against the correct versions, it works. Now, I have threequestions:\nWhy [1,2,3] and [3,2,1] should output 1 instead of 0? If my code is not valid, please help me with some test cases that invalidate it? \nThanks!\nMy code:\n\n```\ndef lcs2(a, b):\n    lst, tag= [], False\n    if len(set(a).intersection(set(b))) != 0: tag = True \n    if len(a) <= len(b): x = a; y = b    \n    else: x = b; y = a\n    for i in y:\n        if i in x:\n            lst.append(x.index(i))\n            x[x.index(i)] = None\n        else:\n            y[i] = None\n    cnt = 0\n    for i in range(1 ,len(lst)):\n        if lst[i] > lst[i-1]: cnt += 1\n    if cnt == 0 and not tag: return 0\n    return cnt + 1\n```\n\n\nNow, I take this one here, some proposed seemed to implement a good one:Python: Length of longest common subsequence of lists\n\nBut when testing it for ```\na = [-1, 1, -1, -1, 4]\nb = [0, -1, 0, 4, 4]```\n it just fails against me, which gives the correct answer 2 rather than one. \n    ", "Answer": "\r\n```\nlcs2([1, 2, 3], [3, 2, 1])```\n correctly returns ```\n1```\n, since ```\n[1]```\n, ```\n[2]```\n and ```\n[3]```\n are all examples of sequences of length 1 that are present in both runs.\n\nYour algorithm has some issues and seems to missing some cases. For one, it only looks for the first occurrence of some element of ```\ny```\n in ```\nx```\n, but it doesn't backtrack to find longer sequences. \n\nAlso, it's unclear why you use ```\ntag```\n as its only function seems to be detecting whether the intersection of the two sets is empty (in which case the result is just 0 and the algorithm should find runs of 1 or over otherwise).\n\nSome examples of runs that don't work well with your algorithm: ```\nprint(lcs2([1, 2, 3], [1, 3, 2, 3]))```\n (answer is 2, but it should be 3) - this because of the lack of backtracking; ```\nprint(lcs2([], [1]))```\n this fails with an IndexError since you try to access elements of the empty list with ```\ny[i] = None```\n.\n\nI won't provide a working implementation, since https://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Code_for_the_dynamic_programming_solution has good solutions that need not be replicated here.\n\nIn general, don't try to prove your code by thinking of random examples in an attempt to break it, but instead try to think of a collection of examples that have all types of variation and test against that set. Also, try to fully understand your own algorithm so you can reason out flaws and possibly optimise it.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Difference between best first search and greedy best first search?\r\n                \r\nIs there a difference at all? I've been told the greedy selects the child with the highest value of the\nheuristic function i.e. the locally best successor. My confusion is what happens in an greedy best first algorithm which do not track it's visited nodes, meets the same node in a different path? I'll draw the problem out to depict it clearly ; \n\nWhat node C will the greedy best-first algorithm expand when it reaches C through B, C(x) or C(y), and what would the output path be? ABCG or ACG?\n\nNote this tree is a graphical representation of a shortest path evaluation of a grid, the child nodes are the valid neighboring nodes of the parent node in the grid.\n    ", "Answer": "\r\n\n  By that way does that mean A-B-C-G is the path greedy best first\n  delivers? Since it will consider only the children of node B for the\n  next selection?\n\n\nYes: a strict \"greedy\" algorithm considers only the best short-term choice at each juncture.  At the first step, ```\nB```\n is cheaper than ```\nC```\n, so it starts down that path.  From here, it treats ```\nB```\n as the start node.  The cheapest move from there is to ```\nC```\n, then to G.\n\nIn contrast, a \"best-first\" algorithm such as ```\nA*```\n or Dijkstra's will make some notice of the cheapest total path.  It starts with the state (A, 0) -- it cost nothing to get to ```\nA```\n.  Then it generates moves (AB, 2), (AC, 3), and (AD, lots); it takes the cheapest move, (AB, 2), but retains the others on the list.  Now it generates moves from ```\nB```\n with total cost: (ABE, 7) and (ABC, 5).  At this point, it drops (ABC, 5) because there's a known cheaper path to ```\nC```\n.\n\nNow the cheapest path on the list is (AC, 3), and the algorithm will generate moves from there: (ACG, 3+unknown).\n\nDoes that clear up enough for you?\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Optimization problem - vector mapping\r\n                \r\n```\nA```\n and ```\nB```\n are sets of ```\nN```\n dimensional vectors (```\nN=10```\n), ```\n|B|>=|A|```\n (```\n|A|=10^2```\n, ```\n|B|=10^5```\n). Similarity measure sim(a,b) is dot product (required). The task is following: for each vector ```\na```\n in ```\nA```\n find vector ```\nb```\n in ```\nB```\n, such that sum of similarities ```\nss```\n of all pairs is maximal.\n\nMy first attempt was greedy algorithm:\n\n\nfind the pair with the highest similarity and remove that pair from A,B \nrepeat (1) until A is empty\n\n\nBut such greedy algorithm is suboptimal in this case:\n\n\na_1=[1, 0]\na_2=[.5, .4]\n\nb_1=[1, 1]\nb_2=[.9, 0]\n\nsim(a_1,b_1)=1\nsim(a_1,b_2)=.9\nsim(a_2,b_1)=.9\nsim(a_2, b_2)=.45\n\n\nAlgorithm returns ```\n[a_1,b_1]```\n and ```\n[a_2, b_2]```\n, ```\nss=1.45```\n, but optimal solution yields ```\nss=1.8```\n.\n\nIs there efficient algo to solve this problem? Thanks\n    ", "Answer": "\r\nThis is essentially a matching problem in weighted bipartite graph. Just assume that weight function ```\nf```\n is a dot product (```\n|ab|```\n).\nI don't think the special structure of your weight function will simplify problem a lot, so you're pretty much down to finding a maximum matching.\n\nYou can find some basic algorithms for this problem in this wikipedia article. Although at first glance they don't seem viable for your data (```\nV = 10^5```\n, ```\nE = 10^7```\n), I would still research them: some of them might allow you to take advantage of your 'lame' set of vertixes, with one part orders of magnitude smaller than the other.\n\nThis article also seems relevant, although doesn't list any algorithms.\n\nNot exactly a solution, but hope it helps.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What algorithm is used in Vim's `gq` paragraph fill?\r\n                \r\nWhat algorithm does Vim use to break paragraphs into lines for paragraph fill (```\ngq```\n)?\nIt is a simple greedy algorithm like the one used in Emacs, or something more sophisticated like the one used in TeX?\nAnd most important, where would I look in the source code to confirm the algorithm that is used?\n    ", "Answer": "\r\nYou can get vim's source code here. Download that and the formatting function is at ```\nvim/src/ops.c line: 4710```\n. You may also want to take a look at par.\n\n```\nformat_lines(line_count, avoid_fex)\n    linenr_T    line_count;\n    int     avoid_fex;      /* don't use 'formatexpr' */\n{\n    int     max_len;\n    int     is_not_par;     /* current line not part of parag. */\n    int     next_is_not_par;    /* next line not part of paragraph */\n    int     is_end_par;     /* at end of paragraph */\n    int     prev_is_end_par = FALSE;/* prev. line not part of parag. */\n    int     next_is_start_par = FALSE;\n#ifdef FEAT_COMMENTS\n    int     leader_len = 0;     /* leader len of current line */\n    int     next_leader_len;    /* leader len of next line */\n    char_u  *leader_flags = NULL;   /* flags for leader of current line */\n    char_u  *next_leader_flags; /* flags for leader of next line */\n    int     do_comments;        /* format comments */\n    int     do_comments_list = 0;   /* format comments with 'n' or '2' */\n#endif\n    int     advance = TRUE;\n    int     second_indent = -1; /* indent for second line (comment\n                     * aware) */\n    int     do_second_indent;\n    int     do_number_indent;\n    int     do_trail_white;\n    int     first_par_line = TRUE;\n    int     smd_save;\n    long    count;\n    int     need_set_indent = TRUE; /* set indent of next paragraph */\n    int     force_format = FALSE;\n    int     old_State = State;\n\n    /* length of a line to force formatting: 3 * 'tw' */\n    max_len = comp_textwidth(TRUE) * 3;\n\n    /* check for 'q', '2' and '1' in 'formatoptions' */\n#ifdef FEAT_COMMENTS\n    do_comments = has_format_option(FO_Q_COMS);\n#endif\n    do_second_indent = has_format_option(FO_Q_SECOND);\n    do_number_indent = has_format_option(FO_Q_NUMBER);\n    do_trail_white = has_format_option(FO_WHITE_PAR);\n\n    /*\n     * Get info about the previous and current line.\n     */\n    if (curwin->w_cursor.lnum > 1)\n    is_not_par = fmt_check_par(curwin->w_cursor.lnum - 1\n#ifdef FEAT_COMMENTS\n                , &leader_len, &leader_flags, do_comments\n#endif\n                );\n    else\n    is_not_par = TRUE;\n    next_is_not_par = fmt_check_par(curwin->w_cursor.lnum\n#ifdef FEAT_COMMENTS\n               , &next_leader_len, &next_leader_flags, do_comments\n#endif\n                );\n    is_end_par = (is_not_par || next_is_not_par);\n    if (!is_end_par && do_trail_white)\n    is_end_par = !ends_in_white(curwin->w_cursor.lnum - 1);\n\n    curwin->w_cursor.lnum--;\n    for (count = line_count; count != 0 && !got_int; --count)\n    {\n    /*\n     * Advance to next paragraph.\n     */\n    if (advance)\n    {\n        curwin->w_cursor.lnum++;\n        prev_is_end_par = is_end_par;\n        is_not_par = next_is_not_par;\n#ifdef FEAT_COMMENTS\n        leader_len = next_leader_len;\n        leader_flags = next_leader_flags;\n#endif\n    }\n\n    /*\n     * The last line to be formatted.\n     */\n    if (count == 1 || curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n    {\n        next_is_not_par = TRUE;\n#ifdef FEAT_COMMENTS\n        next_leader_len = 0;\n        next_leader_flags = NULL;\n#endif\n    }\n    else\n    {\n        next_is_not_par = fmt_check_par(curwin->w_cursor.lnum + 1\n#ifdef FEAT_COMMENTS\n               , &next_leader_len, &next_leader_flags, do_comments\n#endif\n                    );\n        if (do_number_indent)\n        next_is_start_par =\n               (get_number_indent(curwin->w_cursor.lnum + 1) > 0);\n    }\n    advance = TRUE;\n    is_end_par = (is_not_par || next_is_not_par || next_is_start_par);\n    if (!is_end_par && do_trail_white)\n        is_end_par = !ends_in_white(curwin->w_cursor.lnum);\n\n    /*\n     * Skip lines that are not in a paragraph.\n     */\n    if (is_not_par)\n    {\n        if (line_count < 0)\n        break;\n    }\n    else\n    {\n        /*\n         * For the first line of a paragraph, check indent of second line.\n         * Don't do this for comments and empty lines.\n         */\n        if (first_par_line\n            && (do_second_indent || do_number_indent)\n            && prev_is_end_par\n            && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n        {\n        if (do_second_indent && !lineempty(curwin->w_cursor.lnum + 1))\n        {\n#ifdef FEAT_COMMENTS\n            if (leader_len == 0 && next_leader_len == 0)\n            {\n            /* no comment found */\n#endif\n            second_indent =\n                   get_indent_lnum(curwin->w_cursor.lnum + 1);\n#ifdef FEAT_COMMENTS\n            }\n            else\n            {\n            second_indent = next_leader_len;\n            do_comments_list = 1;\n            }\n#endif\n        }\n        else if (do_number_indent)\n        {\n#ifdef FEAT_COMMENTS\n            if (leader_len == 0 && next_leader_len == 0)\n            {\n            /* no comment found */\n#endif\n            second_indent =\n                     get_number_indent(curwin->w_cursor.lnum);\n#ifdef FEAT_COMMENTS\n            }\n            else\n            {\n            /* get_number_indent() is now \"comment aware\"... */\n            second_indent =\n                     get_number_indent(curwin->w_cursor.lnum);\n            do_comments_list = 1;\n            }\n#endif\n        }\n        }\n\n        /*\n         * When the comment leader changes, it's the end of the paragraph.\n         */\n        if (curwin->w_cursor.lnum >= curbuf->b_ml.ml_line_count\n#ifdef FEAT_COMMENTS\n            || !same_leader(curwin->w_cursor.lnum,\n                    leader_len, leader_flags,\n                      next_leader_len, next_leader_flags)\n#endif\n            )\n        is_end_par = TRUE;\n\n        /*\n         * If we have got to the end of a paragraph, or the line is\n         * getting long, format it.\n         */\n        if (is_end_par || force_format)\n        {\n        if (need_set_indent)\n            /* replace indent in first line with minimal number of\n             * tabs and spaces, according to current options */\n            (void)set_indent(get_indent(), SIN_CHANGED);\n\n        /* put cursor on last non-space */\n        State = NORMAL; /* don't go past end-of-line */\n        coladvance((colnr_T)MAXCOL);\n        while (curwin->w_cursor.col && vim_isspace(gchar_cursor()))\n            dec_cursor();\n\n        /* do the formatting, without 'showmode' */\n        State = INSERT; /* for open_line() */\n        smd_save = p_smd;\n        p_smd = FALSE;\n        insertchar(NUL, INSCHAR_FORMAT\n#ifdef FEAT_COMMENTS\n            + (do_comments ? INSCHAR_DO_COM : 0)\n            + (do_comments && do_comments_list\n                               ? INSCHAR_COM_LIST : 0)\n#endif\n            + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);\n        State = old_State;\n        p_smd = smd_save;\n        second_indent = -1;\n        /* at end of par.: need to set indent of next par. */\n        need_set_indent = is_end_par;\n        if (is_end_par)\n        {\n            /* When called with a negative line count, break at the\n             * end of the paragraph. */\n            if (line_count < 0)\n            break;\n            first_par_line = TRUE;\n        }\n        force_format = FALSE;\n        }\n\n        /*\n         * When still in same paragraph, join the lines together.  But\n         * first delete the comment leader from the second line.\n         */\n        if (!is_end_par)\n        {\n        advance = FALSE;\n        curwin->w_cursor.lnum++;\n        curwin->w_cursor.col = 0;\n        if (line_count < 0 && u_save_cursor() == FAIL)\n            break;\n#ifdef FEAT_COMMENTS\n        (void)del_bytes((long)next_leader_len, FALSE, FALSE);\n        if (next_leader_len > 0)\n            mark_col_adjust(curwin->w_cursor.lnum, (colnr_T)0, 0L,\n                              (long)-next_leader_len);\n#endif\n        curwin->w_cursor.lnum--;\n        if (do_join(2, TRUE, FALSE, FALSE) == FAIL)\n        {\n            beep_flush();\n            break;\n        }\n        first_par_line = FALSE;\n        /* If the line is getting long, format it next time */\n        if (STRLEN(ml_get_curline()) > (size_t)max_len)\n            force_format = TRUE;\n        else\n            force_format = FALSE;\n        }\n    }\n    line_breakcheck();\n    }\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy best-first Search Time Complexity\r\n                \r\nI can't understand why the worst-case time complexity of greedy best-first search is O(b^m).\n\nIn my opinion, greedy best-first search doesn't allow to track back, right? This means that the nodes can only get expanded deeper and deeper. So basically, there should be only one path after i run this algorithm, even if the path is incorrect. (because it is incomplete)\n\nAm i right? Thanks for your answers!\n    ", "Answer": "\r\nYou might want to review how a best-first search works. It takes a step based on (for example) an heuristic, but can come back to reconsider that later if it doesn't find a solution. That's why it's a \"best-first\" not a \"best-only\" search. This means that backtracking can happen, which you need to take into your analysis.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Finding the minimum set of coins that make a given value\r\n                \r\nI've been trying to figure out if there would be a way to get the optimal minimum set of coins that would be used to make the change.\nThe greedy algorithm approach for this has an issue such as if we have the set of coins {1, 5, 6, 9} and we wanted to get the value 11. The greedy algorithm would give us {9,1,1} however the most optimal solution would be {5, 6}\nFrom reading through this site I've found that this method can give us the total minimum number of coins needed. Would there be a way to get the set of coins from that as well?\n    ", "Answer": "\r\nI'm assuming you already know the Dynamic Programming method to find only the minimum number of coins needed. Let's say that you want to find the minimum number of coins to create a total value ```\nK```\n. Then, your code could be\n```\nvector <int> min_coins(K + 1);\nmin_coins[0] = 0; // base case\nfor(int k = 1; k <= K; ++k) {\n    min_coins[k] = INF;\n    for(int c : coins) { // coins[] contains all values of coins\n        if(k - c >= 0) {\n            min_coins[k] = min(min_coins[k], min_coins[k - c] + 1);\n        }\n    }\n}\n```\n\nAnswer to your question: In order to find the actual set of coins that is minimal in size, we can simply keep another array ```\nlast_coin[]```\n where ```\nlast_coin[k]```\n is equal to the coin that was last added to the optimal set of coins for a sum of ```\nk```\n. To illustrate this:\n```\nvector <int> min_coins(K + 1), last_coin(K + 1);\nmin_coins[0] = 0; // base case\nfor(int k = 1; k <= K; ++k) {\n    min_coins[k] = INF;\n    for(int c : coins) {\n        if(k - c >= 0) {\n            if(min_coins[k - c] + 1 < min_coins[k]) {\n                min_coins[k] = min_coins[k - c] + 1;\n                last_coin[k] = c; // !!!\n            }\n        }\n    }\n}\n```\n\nHow does this let you find the set of coins? Let's say we wanted to find the best set of coins that sum to ```\nK```\n. Then, we know that ```\nlast_coin[K]```\n holds one of the coins in the set, so we can add ```\nlast_coin[K]```\n to the set. After that, we subtract ```\nlast_coin[K]```\n from ```\nK```\n and repeat until ```\nK = 0```\n. Clearly, this will construct a (not necessarily the) min-size set of coins that sums to K.\nPossible implementation:\n```\nint value_left = K;\nwhile(value_left > 0) {\n    last_coin[value_left] is added to the set\n    value_left -= last_coin[value_left]\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Maximizing profit in graph having positive weight cycles\r\n                \r\nI have a  set of vertices with some profit defined between each pair of vertices such that profit(i,j) may not be equal to profit(j,i). Moreover there exist positive weight cycles and the profit may be negative.\n\nThis is a NP-hard problem to find the maximum profit, so the problem is to maximize the profit visiting each city at most one( all cities need not to be visited).\nI have tried following algorithms to find this:  \n\n\nGreedy algorithm on complete set of vertices.\nGreedy with brute force: First find the greedy sequence of vertices. This gives the approximate sets of vertices which nearly form clusters. Now take consecutive set of say 8 cities and rearrange them to find maximum profit using brute force.\n\n\nBut these do not give very good results when tried on 100 vertices.\n\nAre there any other probabilistic or approximate methods to maximize the cost?\n    ", "Answer": "\r\nIm not sure i understand the question but Can't you sort the edges and thn find the minimum spanning tree. Something how kruskals algo works? \n\nEDIT\nIf there exist negative weight edges, you can stop the moment the weight becomes negative.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Maximizing profit in graph having positive weight cycles\r\n                \r\nI have a  set of vertices with some profit defined between each pair of vertices such that profit(i,j) may not be equal to profit(j,i). Moreover there exist positive weight cycles and the profit may be negative.\n\nThis is a NP-hard problem to find the maximum profit, so the problem is to maximize the profit visiting each city at most one( all cities need not to be visited).\nI have tried following algorithms to find this:  \n\n\nGreedy algorithm on complete set of vertices.\nGreedy with brute force: First find the greedy sequence of vertices. This gives the approximate sets of vertices which nearly form clusters. Now take consecutive set of say 8 cities and rearrange them to find maximum profit using brute force.\n\n\nBut these do not give very good results when tried on 100 vertices.\n\nAre there any other probabilistic or approximate methods to maximize the cost?\n    ", "Answer": "\r\nIm not sure i understand the question but Can't you sort the edges and thn find the minimum spanning tree. Something how kruskals algo works? \n\nEDIT\nIf there exist negative weight edges, you can stop the moment the weight becomes negative.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "I am trying to create a greedy algorithm but my code won't return a value at the end\r\n                \r\n```\n#include <stdio.h>\n#include <math.h>\n#include <cs50.h>\n\nint main(void)\n{\n    float x;\n     printf(\"O hai! How much change is owed?\\n\");\n    do\n    {\n        x = GetFloat();\n        x = x * 100;\n        return roundf(x);\n        int c = 0;\n        do\n        { \n            return x = x - 25;\n            return c = c + 1;\n        }\n        while (x >= 25);\n        printf(\"%d coins\\n\", c);\n    }\n    while (x <= 0);\n}\n```\n\n\nWhen I input a float such as .60 it is supposed to convert it to an integer then detect if it is greater than 25. This will be the first in a process of graduating decreases in coin from quarter to dime to nickel etc. but when I first tried to test it with printing out the value I got after the first sequence had been completed it returned nothing.\n    ", "Answer": "\r\nAs soon as your program hits ```\nreturn roundf(x);```\n it will stop (since ```\nmain```\n has returned), which is why it produces no output after reading the first number.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Distribute given number in a greedy manner\r\n                \r\nI am hitting a wall in coming up with an equation to this simple question.  I need a different perspective coming up with an algorithm.  I have a number ```\nx```\n and I want to distribute it to ```\nn```\n elements in a greedy manner.\n```\nFor x=9, n=3\n[1,2,3],[4,5,6],[7,8,9] OR [3,3,3]\n```\n\n```\nFor x=10, n=3\n[1,2,3,4],[5,6,7],[8,9,10] OR [4,3,3]\n```\n\n```\nFor x=11, n=3\n[1,2,3,4],[5,6,7,8],[9,10,11] OR [4,4,3]\n```\n\n```\nFor x=12, n=3\n[1,2,3,4],[5,6,7,8],[9,10,11,12] OR [4,4,4]\n```\n\n    ", "Answer": "\r\nAs far as I understand, you need to get  array like ```\n[4,4,3]```\n. So use integer division and modulo operation\n```\nsmallvalue = x / n ;  //integer division\nlargecount = x % n;   //number of larger values\nsmallcount = n - largecount\n```\n\nNow fill array with ```\nlargecount```\n quantity of ```\nsmallvalue+1```\n and then with ```\nsmallcount```\n of ```\nsmallvalue```\n\nIf you need result ```\n[1,2,3,4],[5,6,7,8],[9,10,11]```\n - use the same information to generate it.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "graph cut, cutting at least half the edges\r\n                \r\nCan anyone help me find a greedy algorithm that find a  cut in a graph with at least half the edges?\n\nI think the right way has something to do with separating vertexes using DFS, but I am not sure.\n    ", "Answer": "\r\nTheorem 6.3 in Mitzenmacher/Upfal (2005), page 129 gives an algorithm which cuts half of the edges on expectation; like the wikipedia article cited in the above comment says I guess this can be derandomized.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Maximum Flow\r\n                \r\nThe Dining Problem:\nSeveral families go out to dinner together. In order to increase their social interaction, they would like to sit at tables so that no two members of the same family are at the same table. Assume that the dinner contingent has ```\np```\n families and that the ```\ni```\nth family has ```\na(i)```\n members. Also, assume there are ```\nq```\n tables available and that the ```\nj```\nth table has a seating capacity of ```\nb(j)```\n.\n\nThe question is:\nWhat is the maximum number of persons we can sit on the tables?\n\nEDIT:\nThis problem can be solved creating a Graph and running a maximum flow algorithm. But if we have 2*10^3 vertices with Dinic algorithm, the global complexity is O(10^6*10^6) = O(10^12).\n\nIf we only sit always the larger groups first, in a greedy manner. The complexity is O(10^6).\n\nSo my questions are:\n\n1) Does the greedy approach in this problem work?\n\n2) What is the best algorithm to solve this problem?\n    ", "Answer": "\r\nYes, greedily seating the largest families first is a correct solution. We just need to prove that, after we seat the next largest family, there is a way to seat the remaining families correctly.\n\nSuppose that an instance is solvable. We prove by induction that there exists a solution after the greedy algorithm seats the ```\nk```\n largest families. The basis ```\nk = 0```\n is obvious, since the hypothesis to be proved is that there exists a solution. Inductively, suppose that there exists a solution that extends greedy's partial assignment for the first ```\nk - 1```\n families. Now greedy extends its partial assignment by seating the ```\nk```\nth family. We edit the known solution to restore the inductive hypothesis.\n\nWhile we still can, find a table ```\nT1```\n where greedy has seated a ```\nk```\nth family member but the known solution has not. If there is space in the known solution at ```\nT1```\n, move a ```\nk```\nth family member from a table where greedy has none. Otherwise, the known solution has a family member not in the ```\nk```\n largest families seated at ```\nT1```\n. Since that family is smaller than the ```\nk```\nth largest, a ```\nk```\nth largest family member occupies a table ```\nT2```\n that the smaller family does not. Swap these members.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "What will be the heuristic for the tower of Hanoi Question\r\n                \r\nI want to implement python with python with different search algorithms. One of the algorithms is Greedy or A* that needs a heuristic function to work.\nI cant think of any correct heuristic to work. Could someone suggest a heuristic?\n    ", "Answer": "\r\nFor search algorithms, like Greedy and A*, you need to implement the manhattan. It is used to compare distance of two point.\n```\n(n, m) = |xn − xm| + |yn − ym|\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Minimum Spanning tree of a Complete Graph\r\n                \r\nAssume G = (V,E) is a complete graph. \n\nLet the vertices be a set of points in the plane and let the edges be line segments between the points. Let the weight of each edge [a, b] be the length of the segment 'ab'.\n\nAfter reading about Prim's Algorithm and Kruskal's Algorithm, I have some sound knowledge that these greedy algorithms output the minimum spanning tree of a graph.\n\nMy Question is: After obtaining a minimum spanning tree of G, Is there a way to prove that the minimum spanning tree of G is a plane graph?\n    ", "Answer": "\r\nYou can check if the minimum spanning tree is planar as any graph. There are a simple way to check if a graph is planar. The very known Euler formula\n\n“If G is a connected planar graph with e edges and v vertices, where v >= 3, then e <= 3v - 6. Also G cannot have a vertex of degree exceeding 5.”\n\nor you can rely on the following method:\n\nTheorem – “Let G be a connected simple planar graph with e edges and v vertices. Then the number of faces f in the graph is equal to f = e-v+2.”\n\nEuler also showed that for any connected planar graph, the following relationship holds:\n\nv - e + f = 2.\n\nGood lucky\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Scheduling the most intervals rather than scheduling the most tasks\r\n                \r\nInterval scheduling tends to consider how to schedule the greatest number of tasks, rather than have as much time as possible be scheduled. Any thoughts on how to modify the typical greedy algorithm to optimize for time usage rather than # of tasks?\n    ", "Answer": "\r\nHere's an O(nlog n) dynamic programming algorithm:\n\nSuppose there are n tasks, beginning at times b(j) and ending at times e(j) for 1 <= j <= n.  Let f(x) be the greatest amount of time that can be scheduled (used) under the constraint that no scheduled task uses any time after time x.  (x need not be integer.)  We will compute f(max(e(j))), where the maximum is taken over all tasks: this will be the final answer.\n\nInstead of recording the values of f() in an array so that f(x) is given by the xth element of the array, we will record only an array of pairs (x, y), in increasing order of x, but allowing gaps in the x values.  Call this array S.  There will be one (x, y) pair in S for each best (\"fullest\") solution whose last used interval of time ends exactly at time x, and uses y units of time in total.  To find f(x), we will binary search in this array of pairs to find the pair (x', y) with x' <= x but as large as possible.  Intuitively, this means that when looking for the best solution that uses no time after x, if there is no best solution that uses time \"right up to\" time x, then we \"fall back\" to the best solution that ends before then.\n\n\nSort all n tasks by their end time.\nFor j from 1 to n:\n\nIdea: Try adding task j to the best schedule that can accommodate it, namely f(b(j)).  We will compare this schedule to f(e(j)) to see whether it is better to include task j or not.  Calculating f(b(j)) requires a binary search through S, but f(e(j)) can be calculated in constant time because it will always be the rightmost pair in S.\nIf f(b(j)) + e(j) - b(j) > f(e(j)) then remove any trailing pairs (e(j), y) in S and append (e(j), f(b(j)) + e(j) - b(j)) to S.\n\nReturn the final element of S, which corresponds to f(max(e(j))).\n\n\nTo actually recover a schedule, a third element can be added to each of the pairs in the array S to record the identity of the rightmost task just added.  Then once the algorithm above has run, just trace back through the array S starting from the end, at each step binary-searching for the fullest solution that ends at or before b(j), where j was the task reported in the previous step.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "dynamic algorithm to find optimal solution\r\n                \r\nconsidering a game bored with white and red squares ordered as followed:\n\n( start w w w w w w r r w w w w r w r w r w finish )\n\nw = white.\nr = red.\n\nthere are 3 buttons.\ngreen button: move 5 steps.\nyellow button: move 3 steps.\nblue button: move 3 steps.\n\ngame rules:\n- if a players land on a red square lose.\n- first player finish the game win.\n- land on white square is allowed.\n\ngreedy algorithm :\n\n```\nx = 0 \nsteps = 0\nstop = false\nwhile (....)\nif a[x+5] is white then\n push the green buttton and x= x+5, steps++\nif a[x+3] is white then\n push the yellow buttton and x= x+3, steps++\nif a[x+2] is white then\n push the blue buttton and x= x+2, steps++\nelse stop = true\n```\n\n\nrequired: the minimum steps to win the game. \n\nby following the greedy algorithm above the solution will be 552225 whereas the optimal solution is 33555.\n\nmy question is how to apply dynamic algorithm to find the optimal solution?\n    ", "Answer": "\r\nWhat you want to do is produce an array that contains min-cost and best previous move.  You fill it up from the beginning to the end, and then you read the optimal solution from the end to the start.  So like this:\n\n```\nmin_cost = [infinite for all steps]\narriving_move = [none for all steps]\nFor each i in 0 to steps-1:\n    if square[i] = 'r':\n        pass\n    else:\n       for j in 2, 3, 5:\n           if i <= j:\n               if min_cost[i-j] + 1 < min_cost[i]:\n                   min_cost[i] = min_cost[i-j] + 1\n                   arriving_move[i] = j\nreversed_answer = []\ni = steps-1\nwhile arriving_move[i] is not none:\n    reversed_answer.append(arriving_move[i])\n    i = i - arriving_move[i]\nanswer = reversed(reversed_answer)\n```\n\n\nNote, this will find an optimal game where you arrive directly on the finish.  In your example the moves will therefore come out 33553.\n\nIf you're OK with \"overshooting the mark\", you'll have to add a special end node with its own special rules at the end.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Knapsack problem with all profits equal to 1\r\n                \r\nThere is a variation of knapsack problem when all profits are equal to 1. It seems it can be solved much faster than classical discrete (0-1) knapsack problem, but how? Will just greedy algorithm work (on each iteration put an object with minimum weight to the knapsack)?\n    ", "Answer": "\r\nI should think so.\n\nIntuitively, given that all profits equal one, on the profit side you're indifferent to which items you select, you just want as many as you can. The greedy algorithm will give you exactly that.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Optimize multiple if else statements in C\r\n                \r\nCode:\n```\n#include <stdio.h>\n    int main(void)\n    {\n        int coins = 0;\n        float cash_owed = 0;\n        printf(\"Cash owed: \");\n        scanf(\"%f\" , &cash_owed);\n        while(cash_owed > 0)\n        {\n            if(cash_owed >= 0.25)\n            {\n                cash_owed -= 0.25;\n                coins++;\n            }\n            else if(cash_owed >= 0.10)\n            {\n                cash_owed -= 0.10;\n                coins++;\n            }\n            else if(cash_owed >= 0.05)\n            {\n                cash_owed -= 0.05;\n                coins++;\n            }\n            else if(cash_owed >= 0.01) \n            {\n                cash_owed -= 0.01;\n                coins++;\n            }\n        }\n        printf(\"%i\\n\", coins);\n        return 0;\n    }\n```\n\nSo basically this is a greedy algorithm. It takes cash owed as inputs, Evaluates the minimum no. of coins to give. (US Currency). I think there is so much repeatation in my code. It's not optimized. Can someone help me out here?\n    ", "Answer": "\r\nFirstly, you should never (unless you come of with a good reason, and \"there are 100 cents in one dollar\" is not a good reason) use floating point numbers for currency. They can generate rounding error bugs. Use integers instead, and format output later.\nAnd using that, I would do something like this:\n```\nint coins = 0;\nint cash_owed = 0;\nprintf(\"Cash owed (in cents): \");\nscanf(\"%d\" , &cash_owed);\n\nint coin_type[] = {25, 10, 5, 1};\n\nfor(int i=0; i<sizeof(coin_type)/sizeof(coin_type[0]); i++) {\n    while(cash_owed >= coin_type[i]) {\n        cash_owed -= coin_type[i];\n        coins++;\n    }\n}\n```\n\nHere is an example of how to print currency:\n```\nint cents = 7334;\nprintf(\"$%d.%d\", cents/100, cents%100);\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Algorithmusas in an example in a card game\r\n                \r\nYou play a new trading card game. You and the computer each have a card-\nDeck. The computer lays a card, then you lay your card. Each card has a\nStrength value, with the card with the higher strength value winning. If you and the If computers have equally strong cards, the computer wins.\nYou know the cards of the computer. Your goal is to calculate the sum of the strength values of your Maximize cards that have won. For this you get two integer arrays  which represent your cards and those of the computer.\nYou would have the cards [5, 15, 100, 1, 5]. The computer uses the\nsame cards, so also [5, 15, 100, 1, 5]. When the computer places its 100, you place\nYour 1, since you cannot win. If he lays his 15, you lay your 100 and have\nwon. If he lays his 5, then lay your 15th. If he lays his second 5, then lay\nyou get your 5 and lose this round. If he puts his 1, you counter with your 5th total.\nyou will get winning cards worth 120.\nTask: Describe your greedy algorithm idea that can calculate the sum.\nMy algorithm: When the computer places the largest card from its deck (in this case 100) I place the smallest number in my case the 1. I would go on with this and at the i would write  whenever I win add the result\nHas anybody another suggestions for the greedy algorithm\n    ", "Answer": "\r\nYour idea is correct. There is also another point to think about here.\nFor [5, 15, 100, 1, 5],\n\nComputer throws 5 and you throw 100 because it is largest.\nNext computer throws 15, now the maximum you have is 15 and you would lose the point.\n\nTo avoid this, you should choose the next maximum to the given number.\n\nWhen the computer throws 5, you throw  15.\nWhen the computer throws 15, you throw 100 and get the point.\n\nIf all the cards are unique you could win (n-1) points this way where n is the size of the array.\nSo, the algorithm would be to find the next maximum. If it is possible to find it, return it or else return the smallest number in the array.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "knapsack algorithm with two weights\r\n                \r\nI have questions which is the following:\n\n\n  Solve the knapsack 0-1 problem(not fractional) Assuming that every\n  object have weight ```\nw1```\n or ```\nw2```\n (there only two weights). Capacity=W, the algorithm\n  must run on O(nlogn).\n\n\nI tried to solve, the greedy algorithm doesn't work, the dynamic programming algorithm is O(n*W).\n\nCan anyone give me hint.\nThank you.\n    ", "Answer": "\r\nYou can divide the elements in 2 parts, one that have ```\nw1```\n as weight and the other that have ```\nw2```\n as weight.\nNow you can sort the two lists above according to their costs.\n\nA1 : sorted by cost in descending order, elements that have weight as w1\nA2 : sorted by cost in descending order, elements that have weight as w2\n\nNow you can create prefix sum of both the array lets call them ```\nP1, P2```\n.\nexample :\n```\nArray      : 11,  8,  5,  3,  1```\n\n```\nPrefix sum : 11, 19, 24, 27, 28 ```\n\nOnce you have the prefix sum, you can iterate over the ```\nP1```\n array and try to include elements upto the ith index.\nOnce we include elements upto ```\ni```\n, we have ```\nW - (w1*i)```\n weight left we can then try to binary search this weight in the ```\nP2```\n array.\nPseudo code :\n```\nA : input array\ncreate A1 : cost of elements having w1 weight\ncreate A2 : cost of elements having w2 weight\n\nsort(A1, descending)\nsort(A2, descending)\n\nfor(i=0;i <= A1.size();i++){\n      P1[i] = P1[i-1] + A1[i];\n      P2[i] = P2[i-1] + A2[i];\n}\nint ans = 0;\nfor(i=1;i<=A1.size();i++){\n      if(i * w1 <= W){\n            int wLeft = W - i * w1;\n            int ans = binarySearch(wLeft, P2) + p1[i];  \n      }\n}\nans => contains the answer\n\n//-----------Binary search function\nint binarySearch(int weight, P2[]){\n      int start = 0, end = P2.size(), ans = 0;\n      int mid = (start+end)/2;\n      while(start <= end){\n            if(mid * w2 <= weight){\n                  start = mid + 1;\n                  ans = max(ans, p2[mid]);\n            }else{\n                  end = mid - 1;\n            }\n      }\nreturn ans\n}\n```\n\nThe overall complexity is ```\nO(n * log n)```\n.\nAs suggested by @j_random_hacker we can iterate over the second prefix array, as we can only improve the solution by adding elements, it would simplify the code by removing the binary search.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Vertex cover for tree greedy approach\r\n                \r\nQuestion: Let T be an n-node tree rooted at some node r. We want to place as few guards as\npossible on nodes of T, such that every edge of T is guarded: an edge between a parent\nnode v and its child w is guarded if one places a guard on at least one of these two nodes\nv, w.\nGive an O(n) time algorithm for finding an optimal solution to the problem.\n\nMy approach was to do post order traversal from the root and place a guard on a node that is part of an unguarded edge except if that node is a leaf...but this algorithm wouldn't work if all the nodes were arranged in a linear chain because my algorithm would place guards on every node except for the ends of the chain. \n\nI've looked online and checked out the DP solutions, which make sense to me but I was wondering if there's a greedy algorithm to find a vertex cover for a tree\n    ", "Answer": "", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy sequential/parallel task scheduling\r\n                \r\nWe have ```\nN```\n tasks that need to be scheduled for processing. Each task consists of two parts that need to executed in order. The first one is guarded by a mutex and therefore only one task can be executing this part at a time. The second part has no such constraint and any number of the tasks can be executing this at the same time. For task ```\ni```\n we know how much time it needs to spend in each part, namely mi for the guarded part, and ai for the part that can be executed in parallel.\nThe problem is to find a permutation of the tasks such that the time needed to execute all of them is minimized.\nMy intuition says that this can be solved with a greedy algorithm, by scheduling the tasks in descending ai order.\nFor example given the tasks with: \nm1 = 3, a1 = 9 \nm2 = 2, a2 = 7 \nm3 = 6, a3 = 10\nThe optimal solution is the permutation 3, 1, 2 where the tasks overlap as follows (pluses being the time spent in part 1 and minuses being the time spent in part 2):\n```\n3 ++++++---------- (6, 10)\n1       +++--------- (3,9)\n2          ++------- (2,7)\nTotal time needed: 6+3+2+7: 18\n```\n\nAny other permutation gives a higher total time needed, e.g.:\n```\n1 +++--------- (3,9)\n2    ++------- (2,7)\n3      ++++++---------- (6, 10)\nTotal time needed: 3+2+6+10: 21\n```\n\nHowever, I have trouble proving that the greedy solution is optimal. Any ideas on how to do that?\n    ", "Answer": "\r\nTo solve this question, let us first write an equation to calculate the total time it takes for N tasks.\nThis equation is:\nt = m1 + a1 + max((a2 + m2 - a1), (a3 + m3 - a2), ...).\nThe first part of this equation (m1 + m2 + ...) is the time it takes for the first task\nThe second part of the equation is more complicated. Simply, the max() calculates the maximum amount of task time that does not overlap with the first task (in your example, this maximum time is 9).\nLet us now prove the optimal solution through induction. Suppose the optimal answer for n tasks is ordering in descending ai order. Then, if we introduce another an+1 and mn+1 and an+1 is the smallest value of ai (we can assume this through inductive hypothesis), an+1 should go to the bottom of the list.\nTo prove this, suppose an+1 went to any other position, say i. Then the values of ai+1 + mi+1 - an would obviously be greater than it was previously (and even greater than an + mn - ai-1). Therefore, the max() function will return a value greater than or equal to its previous value.\nNow we have to prove the inductive hypothesis for n = 2. Suppose that we had a1 and a2.\nThe value of the equation t = m1 + a1 + a2 + m2 - a1, which simplifies to t = m1 + a2 + m2 is now of interest.\nIt is trivial to see that a2 must be the lesser value for this equation to be minimized. Therefore, the inductive hypothesis has been proven.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "trouble running java program in eclipse\r\n                \r\nI'm just starting out in java and I'm trying to make a greedy algorithm. The first step is to read the file.txt with the jewel values and bag weight limit and such. unfortunately I am having trouble getting the program to run. I am using eclipse and when I click run I get the following error message \"the selection cannot be launched, and there are no recent launches\". \nWhen I select the java greedy algorithm folder in the file tree and select run i get the following message \"selection does not contain a main type\". the work file and file.txt are saved in the same folder on my desktop but I wonder if the program isn't finding it. here's my code:\n\n```\n/** open and read a file, and return the lines in the file as a list of strings */\nprivate List<String> readFile(file.txt)\n{\n    List<String> records = new ArrayList<String>();\n    try\n    {\n        BufferedReader reader = new BufferedReader(new FileReader(file.txt));\n        String line;\n        while (( line = reader.readLine()) != null)\n        {\n            records.add(line);\n        }\n        reader.close():\n        return records;\n    }\n    catch (Exception e)\n    {\n        System.err.format(\"Exception occurred trying to read '%s'.\", file.txt);\n        e.printStackTrace();\n        return null;\n    }\n}\n```\n\n\nThanks for the help.\n    ", "Answer": "\r\nYou have to add a method named ```\nvoid main(String[] args)```\n.\nThis is the method that gets called when you start your program.\nIn this main method you can call your readFile method, like so:\n\n```\npublic static void main(String[] args) {\n  readFile();\n}\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Different Summands problem greedy alogrithm\r\n                \r\nI try to solve Different Summands problem with greedy algorithm \n\nProblem Description\n\nTask. The goal of this problem is to represent a given positive integer 𝑛 as a sum of as many pairwise\ndistinct positive integers as possible. That is, to find the maximum ```\n𝑘```\n such that ```\n𝑛```\n can be written as\n```\n𝑎1 + 𝑎2 + · · · + 𝑎𝑘```\n where ```\n𝑎1, . . . , 𝑎𝑘```\n are positive integers and ```\n𝑎𝑖 ̸= 𝑎𝑗```\n for all ```\n1 ≤ 𝑖 < 𝑗 ≤ 𝑘.```\n\n\nInput Format. The input consists of a single integer 𝑛.\nConstraints. ```\n1 ≤ 𝑛 ≤ 10^9```\n.\n\nOutput Format. In the first line, output the maximum number ```\n𝑘```\n such that ```\n𝑛```\n can be represented as a sum\nof ```\n𝑘```\n pairwise distinct positive integers. In the second line, output ```\n𝑘```\n pairwise distinct positive integers\nthat sum up to ```\n𝑛```\n (if there are many such representations, output any of them).\n\nMy Code: \n\n```\npublic class DifferentSummands {\n    private static List<Integer> optimalSummands(int n) {\n        List<Integer> summands = new ArrayList<Integer>();\n        int start = 1;\n        int newNumber = n;\n\n        if (n == 2) {\n            summands.add(2);\n            return summands;\n        }\n\n        while (true) {\n            if (summands.contains(newNumber - start)) {\n                start++;\n                continue;\n            } else {\n                newNumber -= start;\n                summands.add(start);\n                start++;\n            }\n\n            if (newNumber == 0) {\n                return summands;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Integer> summands = optimalSummands(n);\n        System.out.println(summands.size());\n\n        for (Integer summand : summands) {\n            System.out.print(summand + \" \");\n        }\n    }\n}\n```\n\n\nMy code fails if the input was so big it takes about 3.24 seconds and the max time available is 1.5 seconds.\n    ", "Answer": "\r\nThe smallest number that can be made with at least k different summands is just the sum of all numbers from 1 to k.  Any number smaller than that will have fewer summands... at most k-1.\n\nGauss has a formula for the sum of numbers from 1 to k.  It's just k(k+1)/2.\n\nYou just need to find the largest k such that k(k+1)/2 <= n.  From the above, you know that if k were any larger, then you could not divide n into that many summands, so this is the largest possible answer.\n\nIt's also very easy to actually generate k summands that add to n -- it's just the sum of all numbers from 1 to k-1, and then whatever is left over ( n - k(k-1)/2 ). \n\nYou can solve for k directly:\n\nk(k+1)/2 <= n\n\nk² + k - 2n <=0\n\nk <= (sqrt(8n+1)-1)/2\n\nThe last step is via the quadratic formula.   Since you want the largest possible k, it's just \n\nk = floor((sqrt(8n+1)-1)/2)\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Why split string is done in many questions in hackerrank?\r\n                \r\nIt is Chief Hopper Greedy algorithm question .Here it is\n\nhttps://www.hackerrank.com/challenges/chief-hopper/problem\n\nI  want to ask why splitting of  string is done even though we are not giving any string as input and after that they used stoi function to convert that in int ??\n\n```\nstring arr_temp_temp;\ngetline(cin, arr_temp_temp); \nvector<string> arr_temp = split_string(arr_temp_temp);\nvector<int> arr(n);\n\nfor (int i = 0; i < n; i++) {\n    int arr_item = stoi(arr_temp[i]);\n\n    arr[i] = arr_item;\n}\n\n\nvector<string> split_string(string input_string) {\nstring::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {\n    return x == y and x == ' ';\n});\n\ninput_string.erase(new_end, input_string.end());\n\nwhile (input_string[input_string.length() - 1] == ' ') {\n    input_string.pop_back();\n}\n\nvector<string> splits;\nchar delimiter = ' ';\n\nsize_t i = 0;\nsize_t pos = input_string.find(delimiter);\n\nwhile (pos != string::npos) {\n    splits.push_back(input_string.substr(i, pos - i));\n\n    i = pos + 1;\n    pos = input_string.find(delimiter, i);\n}\n\nsplits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));\n\nreturn splits;\n```\n\n    ", "Answer": "\r\nI don't know where did u find this approach but from my point of view author trying to save time on IO operations. I think that this approach is wrong. I don't know how fast is reading string with getline compared to reading each int value one by one in the loop:\n\n```\nfor(int i = 0; i<n; i++) cin>> x;\n```\n\n\nBut I'm quite sure that converting string to integer is more time-consuming. So it's normal in competive programming to use scanf/printf for the fast IO or \n\n```\nios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n```\n\n\nif you wanna use cout/cin.\nTo sum up I think that code author tried to save time on IO operations.\n\nUPD: Sorry I was in rush and didn't take into account the platform. It should be this platform feature to read input only line by line so they give a template for you to focus only on the problem.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Activity-Selector algorithm: n activities in smallest amout of lecture halls pseudo code\r\n                \r\nI have spent hours trying to understand the answer to this problem. I just don't get it. Can somebody please give me some pseudo code (preferably pseudo code similar to Java) of the algorithm that would solve this problem based on the answer? That will help me understand what the answer is trying to say.\n\nQuestion and answer:\n\nRather than typing it all out, it's styled better in this PDF. The question is the first one on the pdf, Exercise 16.1-4\n\nhttp://mitpress.mit.edu/algorithms/solutions/chap16-solutions.pdf\n\n(To clarify, his is not homework, I am doing the bookwork and want to understand this problem. The link is the solution to the problem, but I don't understand it. I don't understand what it means when it says \"To do this, move through a set of events consisting of activities starting and activities finishing, in order of event time...\" and the rest of the explanation. This is why, if someone understands it, I would like if they could show me the pseudo code of what this is explaining. I could read and understand it that way. Like what the parameters of the function would be, and what is going on inside the function, how the activities are iterated through, how they move between the two lists of busy and free arrays of lecture halls, etc.)\nThank you\n    ", "Answer": "\r\nOkay, I'm not going to answer this with proper code, and at most I'll have pseudocode as I try to define what I understand of the problem. I will also make the assumption that you'll use integer times, as opposed to floating point times, though I'm sure it wouldn't make a massive difference at the end of the day.\n\nThe greedy solution here is to simply assign to a free lecture hall, and always use lecture halls that have been used previously. That is, I'm pretty sure, what the solution is asking for you to do.\n\nSo, firstly, I would create some kind of ```\nstruct```\n or ```\nclass```\n that holds all the \"events\", where we define an \"event\" to be either the starting or finishing time of an activity. This ```\nstruct```\n/```\nclass```\n would also hold a reference to what activity it was the start/finishing time of.\n\nMaybe kinda like (C++ syntax because it's easier and I'm lazy):\n\n```\nstruct evt\n{\n    int activityID;\n    int time;\n    bool isStart;\n};\n```\n\n\nThe next step would be to construct an instance of this ```\nstruct```\n or ```\nclass```\n for each activity's start/finish time, and then place it into some sort of list data structure (if this was C++, I'd use a ```\nvector```\n, and I guess ```\nArrayList```\n for Java) and then sort the events based on their ```\ntime```\n. So, for Java, you'd need some kind of comparison function that  determines an ordering for these events based on their time. Also, within your comparator, an event that is a starting event would go later than an event that is a finishing event (remember, the intervals are half-open). I'll call the ```\nArrayList```\n \"```\neventList```\n\". \n\nNext, you have two lists of what I'd assume are n halls (you would need at most n halls to run all the activities). One list has all the halls. This is the list of halls that are not in use. The other list is empty. This will be the list of halls that are in use. These would be lists that can remove from their front (the Java ```\nArrayList```\n can do this, I think).\n\nYou'd have some way of identifying a hall, and maybe some kind of reference array so that each activity could be assigned to a hall. This part is a little unclear, and I'd rather leave the implementation details to you, but if n wasn't too large I would probably have (again with the C++) a ```\nvector<int>```\n of size n, and the i-th element in that ```\nvector```\n would be the hall identifier, or ```\n-1```\n if it hadn't been assigned yet. And if I was trying this in Java, this would be an ```\nint[n]```\n array.\n\nThen I would iterate through ```\neventList```\n, and at each event, I would check to see if it was a finishing time or a starting time. If it's a starting time, I would take the front element of the \"free halls\" list and put it into the \"in-use\" halls. If it was a finishing time, I'd take the hall that had just finished, remove it from the \"in-use\" list and put it back to the front of the \"free halls\" list. Remember, you'd also need to update that reference array I talked about earlier.\n\nFinally, with a bit of tinkering, you could find how many halls had been used. A linear pass through the array or a counter that was running as you were using halls would have been sufficient. One way I think works is to record the maximum size of the list that holds how many halls are in use at one time, though this may be incorrect (haven't tested it thoroughly).\n\nI'm just doing this out of the top of my head, so this solution is probably a bit confusing at the moment. Sorry about that. I'll try and summarise it here:\n\n\nDeclare a class that summarises the start/finishing times as events\nSort all the start and finishing times into an array, with earlier times going earlier in the list, and finishing times appearing before starting times\nMake a list of the halls, and another (empty list) which will be all the halls being used\nProcess each event, moving a hall to the in-use list if it's a starting time, and to the free list if it's a finishing time\n\n\nSince this is quite a long post, and I haven't provided much code (I tried dropping hints but I don't know whether it was helpful) please let me know if you have more questions and I will attempt to help as best I can.\n\nThe \"activity selection\" problem, as seen here can be solved in a greedy fashion by always choosing the activities that finish earliest. I think this is a little different, but I've just included it because it might be interesting.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "A special case of grouping coordinates\r\n                \r\nI'm trying to write a program to place students in cars for carpooling to an event. I have the addresses for each student, and can geocode each address to get coordinates (the addresses are close enough that I can simply use euclidean distances between coordinates.) Some of the students have cars and can drives others. How can I efficiently group students in cars? I know that grouping is usually done using algorithms like K-Mean, but I can only find algorithms to group N points into M arbitrary-sized groups. My groups are of a specific size and positioning. Where can I start? A simply greedy algorithm will ensure the first cars assigned have minimum pick-up distance, but the average will be high, I imagine.\n    ", "Answer": "\r\nSay that you are trying to minimize the total distance traveled. Clearly traveling salesman problem is a special instance of your problem so your problem is NP-hard. That puts us in the heuristics/approximation algorithms domain.\n\nThe problem also needs some more specification, for example howmany students can fit in a given car. Lets say, as many as you want.\n\nHow about you solve it as a minimum spanning tree rooted at the final destination. Then each student with the car is is responsible for collecting all its children nodes. So the total distance traveled in at most 2x the total length of spanning tree which is a 2x bound right there. Of course this is ridiculous 'coz the nodes next to root will be driving a mega bus instead of a car in this case.\n\nSo then you start playing the packing game where you try to fill the cars greedily.\n\nI know this is not a solution, but this might help you specify the problem better.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Verification of algorithm for variant of gas station\r\n                \r\n\n\nI am studying this problem and I recognise this as a variant of the gas station problem. As a result, I use Greedy algorithm to solve this problem. I would like to ask if anyone helps me to point out my algorithm is correct or not, thanks.\n\nMy algorithm\n\n```\n  var x = input.distance, cost = input.cost, c = input.travelDistance, price = [Number.POSITIVE_INFINITY];\n  var result = [];\n\n  var lastFill = 0, tempMinIndex = 0, totalCost = 0;\n\n  for(var i=1; i<x.length; i++) {\n    var d = x[i] - x[lastFill];\n    if(d > c){ //car can not travel to this shop, has to decide which shop to refill in the previous possible shops\n      result.push(tempMinIndex);\n      lastFill = tempMinIndex;\n      totalCost += price[tempMinIndex];\n      tempMinIndex = i;\n    }\n    //calculate price\n    price[i] = d/c * cost[i];\n    if(price[i] <= price[tempMinIndex])\n      tempMinIndex = i;\n  }\n\n  //add last station to the list and the total cost\n  if(lastFill != x.length - 1){\n    result.push(x.length - 1);\n    totalCost += price[price.length-1];\n  }\n```\n\n\nYou can try out the algorithm at this link\nhttps://drive.google.com/file/d/0B4sd8MQwTpVnMXdCRU0xZFlVRlk/view?usp=sharing\n    ", "Answer": "\r\nFirst, regarding to your solution.\n\nThere is a bug that ruins even at the most simple inputs. When you decided that the distance became too far and you should fulfil at some point before, you don't update distance and gas station charge you more that it should. The fix is simple:\n\n```\nif(d > c){ \n//car can not travel to this shop, has to decide which shop to refill\n//in the previous possible shops\n      result.push(tempMinIndex);\n      lastFill = tempMinIndex;\n      totalCost += price[tempMinIndex];\n      tempMinIndex = i;\n      // Fix: update distance\n      var d = x[i] - x[lastFill];\n    }\n```\n\n\nEven with this fix, your algorithm fails on some input data, like this:\n\n```\n0 10 20 30\n0 20 30 50\n30\n```\n\n\nIt should refill on every gasoline to minimize cost, but it simply fills on the last one.\n\nAfter some research, I came up with solution. I'll try to explain it as simple as possible to make it language independent.\n\n\nIdea\n\n\nFor every gas station ```\nG```\n we will count cheapest way of filling. We'll do that recursively: for each gas station let's find all gas stations ```\ni```\n from which we can reach ```\nG```\n. For every ```\ni```\n count cheapest filling possible and sum up with the cost of the filling at ```\nG```\n given gasoline left. For start gas station cost is 0. More formally:\n\n\n\n\n\n\n```\nCostOfFilling(x)```\n, ```\nCapacity```\n and ```\nPosition(x)```\n can be retrieved from input data.\n\nSo, the answer for the problem is simply ```\nBestCost(LastGasStation)```\n\n\n\nCode\n\n\nNow, solution in javascript to make things clearer.\n\n```\nfunction calculate(input)\n{\n    // Array for keeping calculated values of cheapest filling at each station\n    best = [];\n    var x = input.distance;\n    var cost = input.cost;\n    var capacity = input.travelDistance;\n\n    // Array initialization\n    best.push(0);\n    for (var i = 0; i < x.length - 1; i++)\n    {\n        best.push(-1);\n    }\n\n    var answer = findBest(x, cost, capacity, x.length - 1);\n    return answer;\n}\n\n// Implementation of BestCost function\nvar findBest = function(distances, costs, capacity, distanceIndex)\n{\n    // Return value if it's already have been calculated\n    if (best[distanceIndex] != -1)\n    {\n        return best[distanceIndex];\n    }\n    // Find cheapest way to fill by iterating on every available gas station\n    var minDistanceIndex = findMinDistance(capacity, distances, distanceIndex);\n    var answer = findBest(distances, costs, capacity, minDistanceIndex) + \n        calculateCost(distances, costs, capacity, minDistanceIndex, distanceIndex);\n    for (var i = minDistanceIndex + 1; i < distanceIndex; i++)\n    {\n        var newAnswer = findBest(distances, costs, capacity, i) + \n        calculateCost(distances, costs, capacity, i, distanceIndex);\n        if (newAnswer < answer)\n        {\n            answer = newAnswer;\n        }\n    }\n    // Save best result\n    best[distanceIndex] = answer;\n    return answer;\n}\n\n// Implementation of MinGasStation function\nfunction findMinDistance(capacity, distances, distanceIndex)\n{\n    for (var i = 0; i < distances.length; i++)\n    {\n        if (distances[distanceIndex] - distances[i] <= capacity)\n        {\n            return i;\n        }\n    }\n}\n\n// Implementation of Cost function\nfunction calculateCost(distances, costs, capacity, a, b)\n{\n    var distance = distances[b] - distances[a];\n    return costs[b] * (distance / capacity);\n}\n```\n\n\nFull workable html page with code is available here\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Bad alloc thrown while using vector for knapsack algorithm\r\n                \r\nI'm currently trying data structures and algorithms through a combination of online resources. For one of them, I attempted to solve the famous knapsack problem via a greedy algorithm. I'm sorting the weights and values of the problem in decreasing order before the loop in order to improve performance. When I run the code, I get a bad_alloc. Does this mean I'm just not allocating the memory that I need to? I've been looking for a solution but nothing has really been helpful so far, as I'm not doing explicit access to memory with the \"new\" identifier. \n\nHere's the code:\n\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool decreaseSort(int a, int b)\n{\n    return a > b;   //sort by decreasing value for better performance\n}\n\ndouble get_optimal_value(int capacity, vector<int> weights, vector<int> values) {\n\nsort(weights.begin(),weights.end(), decreaseSort); //sort weights\nsort(values.begin(),weights.end(), decreaseSort); //sort values\n\nvector<int> ourKnapsack(values.size()); //set Knapsack to n elements\n\nfor (size_t i = 0; i < ourKnapsack.size(); i++)\n  ourKnapsack.push_back(0); //fill with zeroes\n\n\ndouble totalValue = 0.0;  //total worth\nint ourInput = 0; //what we are putting in\n\nfor (size_t j = 0; j < ourKnapsack.size(); j++){\n  double unitValue = values.at(j)/weights.at(j); //ratio of value to weight for specific item\n\n  if (capacity == 0) \n      return totalValue; //end program, return value\n\n\n  if (weights.at(j) < capacity){\n      ourInput = weights.at(j); //if we have room, fill with the weight\n  }\n  else {\n      ourInput = capacity; //fill the rest of the pack\n  }\n\n\n  totalValue = totalValue * (ourInput * unitValue); //update totalValue\n  weights.at(j)-=ourInput;  //subtract weight by what we put in\n  ourKnapsack.at(j)+=ourInput; //update knapsack element\n  capacity-=ourInput; //shrink capacity\n\n }\n return totalValue;\n}\n\n int main() {\n int n = 3;  //test case, 3 items, capacity of 50\n int capacity = 50;\n\n vector<int> values(n);\n values = {60,100,120};\n vector<int> weights(n);\n weights = {20,50,30};\n\n double optimal_value = get_optimal_value(capacity, weights, values);\n\n std::cout.precision(10);\n std::cout << optimal_value << std::endl; //should return optimal value\n return 0;\n}\n```\n\n\nThanks in advance \n    ", "Answer": "\r\n```\nfor (size_t i = 0; i < ourKnapsack.size(); i++)\n  ourKnapsack.push_back(0); //fill with zeroes\n```\n\n\nThis will go into an infinite loop.\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Greedy Coin Change Time Complexity\r\n                \r\nI'm trying to figure out the time complexity of a greedy coin changing algorithm. (I understand Dynamic Programming approach is better for this problem but I did that already). I'm not sure how to go about doing the ```\nwhile```\n loop, but I do get the ```\nfor```\n loop.\n\nI have the following where ```\nD[1...m]```\n is how many denominations there are (which always includes a 1), and where ```\nn```\n is how much you need to make change for.\n\nThis is my algorithm:\n\n```\nCoinChangeGreedy(D[1...m], n)\n    numCoins = 0\n    for i = m to 1\n        while n ≥ D[i]\n            n -= D[i]\n            numCoins += 1\n    return numCoins\n```\n\n    ", "Answer": "\r\nLet look at the edge cases.\n\nAt the worse case ```\nD```\n include only 1 element (when ```\nm=1```\n) then you will loop ```\nn```\n times in the while loop -> the complexity is O(n). \n\nIf ```\nm>>n```\n (```\nm```\n is a lot bigger then ```\nn```\n, so ```\nD```\n has a lot of element whom bigger then ```\nn```\n) then you will loop on all ```\nm```\n element till you get samller one then ```\nn```\n (most work will be on the for-loop part) -> then it O(m). \n\nButton line: O(max(m,n))\n\nHope that helps!\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "MaxValueSelect() function has some errors . any fixes?\r\n                \r\n\nMy code is:\n```\ndef maxValueSelection(items,V):\nmaxval = 0\nval = 0\nsorted_dict={}\nfor i in items.items():\n  sorted_dict[i[1][1]] = [i[1][0],i[0]]\nsorted_dict_list = (sorted(sorted_dict))[::-1]\nwhile sorted_dict_list!=[]:\n  item = sorted_dict_list[0]\n  if(sorted_dict[item][0] + val<=V):\n    maxval+=item\n    val = val+sorted_dict[item][0]\n  sorted_dict_list.pop(0)\nreturn maxval\n\n\nitems = {1:(4,400),2:(9,1800),3:(10,3500),4:(20,4000),5:(2,1000),6:(1,200)}\nV = 20\n\nprint(maxValueSelection(items,V))\n```\n\nI have used a greedy algorithm for the question in which I have two values which records the value of the item and one monitors the weight of the items which should not be exceeded more than a threshold value mentioned in the question. It seems like my greedy strategy is working upto some extent but nearly misses the maxValue in every test case. It will be helpful if someone tells me how to fix this issue with my code\n    ", "Answer": "\r\nIf I understood correctly what you need.\nthis code selects V elements from the dict items, with maximum total value.\n```\nfrom operator import itemgetter, truediv\ndef maxValueSelection(items,V):\n    maxval = 0\n    val = 0\n    itemlist = sorted([i[1] for i in items.items()],key=itemgetter(1),reverse=True)\n    for item in itemlist:\n        if V > 0:\n            val = item[1]\n            maxval += val * min(V,item[0])\n            V -= min(V,item[0])\n    return maxval\nitems = {1:(4,400),2:(9,1800),3:(10,3500),4:(20,4000),5:(2,1000),6:(1,200)}\nV = 20\nprint(maxValueSelection(items,V))\n```\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Cutting Stock Problem\r\n                \r\nI'm trying to nest material with the least drop or waste.\n\n```\nTable A\n\nQty Type Description Length\n\n2   W    16x19       16'\n3   W    16x19       12'\n5   W    16x19       5'\n2   W    5x9         3'\n\n\nTable B\n\nType Description StockLength\n\nW    16X19       20'\nW    16X19       25'\nW    16X19       40'\nW    5X9         20'\n```\n\n\nI've looked all over looking into Greedy Algorithms, Bin Packing, Knapsack, 1D-CSP, branch and bound, Brute force, and others.  I'm pretty sure it is a Cutting stock problem.  I just need help coming up with the function(s) to run this.  I don't just have one stock length but multiple and a user may enter his own inventory of less common lengths.  Any help at figuring a function or algorithm to use in PHP to come up with the optimized cutting pattern and stock lengths needed with the least waste would be greatly appreciated.\n\nThanks\n    ", "Answer": "\r\nIf your question is \"gimme the code\", I am afraid that you have not given enough information to implement a good solution. If you read the whole of this answer, you will see why.\n\nIf your question is \"gimme the algorithm\", I am afraid you are looking for an answer in the wrong place. This is a technology-oriented site, not an algorithms-oriented one. Even though we programmers do of course understand algorithms (e.g., why it is inefficient to pass the same string to ```\nstrlen```\n in every iteration of a loop, or why bubble sort is not okay except for very short lists), most questions here are like \"how do I use API X using language/framework Y?\".\n\nAnswering complex algorithm questions like this one requires a certain kind of expertise (including, but not limited to, lots of mathematical ability). People in the field of operations research have worked in this kind of problems more than most of us ever has. Here is an introductory book on the topic.\n\nAs an engineer trying to find a practical solution to a real-world problem, I would first get answers for these questions:\n\n\nHow big is the average problem instance you are trying to solve? Since your generic problem is NP-complete (as Jitamaro already said), moderately big problem instances require the use of heuristics. If you are only going to solve small problem instances, you might be able to get away with implementing an algorithm that finds the exact optimum, but of course you would have to warn your users that they should not use your software to solve big problem instances.\nAre there any patterns you could use to reduce the complexity of the problem? For example, do the items always or almost always come in specific sizes or quantities? If so, you could implementing a greedy algorithm that focuses on yielding high-quality solutions for common scenarios.\nWhat would be your optimality vs. computational efficiency tradeoff? If you only need a good answer, then you should not waste mental or computational effort in trying to provide an optimal answer. Information, whether provided by a person of by a computer, is only useful if it is available when it is needed.\nHow much are your customers willing to pay for a high-quality solution? Unlike database or Web programming, which can be done by practically everyone because algorithms are kept to a minimum (e.g. you seldom code the exact procedure by which a SQL database provides the result of a query), operations research does require both mathematical and engineering skills. If you are not charging for them, you are losing money.\n\n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
{"Question": "Need effective greedy for covering a line segment\r\n                \r\nGiven n segments of line (into the X axis) with coordinates [li; ri]. You are to choose the\nminimum number of segments that cover the segment [0;M]. Design a greedy algorithm to\nsolve this problem.\n\nHere what I did: \nsorting them by starting points in increasing order, then I choose the longest one, second longest.... But here is a problem: Suppose we want to cove [0,12] segment, and there are 3 segments: [0,5],[5,12], [0,10]. Follow the algorithm, it will take [0,10], then it does not cover all the segment, but if we take the other two, it will cover up. \n\nDo you guys have any other idea? without sorting and taking longest lines does not work. we want to cover segment [0,12] and there are 5 segments: [0,2][2,10].[10,12], [0,6][6,12]\nFollow ur algo the first three are chosen but the last 2 r the optimal one\n    ", "Answer": "\r\n\n  Do you guys have any other idea?\n\n\nI can think of a really crappy N^N algorithm. \n    ", "Knowledge_point": "Greedy Algorithms", "Tag": "算法分析"}
