{"Question": "Is it possible to apply alpha-beta pruning for non0zero sum games with 2 players?\r\n                \r\nI understand why it is possible for zero-sum game, but I cannot understand whether it is possible for non-zero sum games with 2 players. Is it because both players do not necessarily have a conflict in their interests?\n    ", "Answer": "\r\nIf the scores for two players are completely arbitrary, then you can't do any pruning. Suppose that the scores were {-10, 10} for P1 and P2 on one branch. P1 might be tempted to prune this branch because, perhaps, at the root P1 could get >= 5. But, perhaps the second branch is {100, 100} which would be a much better outcome. In general there is no guarantee that we won't find another branch with an arbitrarily large score for both players, so we can never prune.\nIf you make stronger assumptions, more can be done.\nFor instance, look at the ```\nM*```\n algorithm which handles opponent models. There they handled the cases of bounded sum. An extended tech report is available online.\nThis is related to multi-player (meaning >=3) constant-sum games, which can use a different set of pruning techniques.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Finding Dominant Strategy, Pure Nash Equilibrium and Mixed Nash Equilibrium in 2 player zero-sum game\r\n                \r\nI am solving Computational Game Theory problems. I want to check if any two player zero-sum game has Dominant Strategy, Pure Nash Equilibrium and Mixed Nash Equilibrium.\nI know that unfortunately Dominant Strategy and Pure Nash Equilibrium does not always exists. As far i know finding Mixed Nash Equilibrium is considerably harder than finding Dominant Strategy solutions or Pure Nash Equilibrium, even when the game is finite and there are only a constant number of players. But couldn't figure it out why?\nI want to know how can I find them or can check if there exists any DS, PNE and MNE, for any two player zero-sum game. For example consider a zero-sum game given by the following matrix:\nI would really appreciate it if someone can give me a better explanation about how to check if the above game has any Dominant Strategy, Pure Nash Equilibrium and Mixed Nash Equilibrium.\nN.B. The example above is used just to make my question more clearer. You are welcome to explain this approach with any other matrix. Any resource link that has a clear derivation will also be count as an answer to my question.\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Zero sum game 16 bit version\r\n                \r\n1. Preface\n\nA common brainteaser is to fill in the spaces below using ```\n0..9```\nexactly once, in such a way that the sum is minimized.\n\n```\n  xxx*xx\n- xxx*xx\n= \n```\n\n\nOne solution is ```\n408 x 37 - 296 x 51 = 0```\n. However this problem can easilly be bruteforced since there are only ```\n10! = 3.6*10^6```\n permutations of numbers. I have written a simple code to solve this problem posted below.\n\n2. The 16byte problem\n\nA similar but much harder problem is to do the same as above with the hexidecimal number system. Use the numbers ```\n0...F```\n exactly once such that\n\n```\n  xxxx * xxx\n- xxxx * xxx\n= \n```\n\n\nis minimized. I have only found two solutions here.\n\n```\n   FD906 x 5A1\n - 7EC83 x B42\n =  0\n\n   FD906 x 15A\n - 7EC83 x 2B4\n = 0\n```\n\n\n3. Question\n\nDoes there exists a more clever way to shuffle through the permutations and find the zero solution? The problem is that there are too many permutations to bruteforce now.\n\n4. Attempt\n\nFor the 16bit number system there exists ```\n3.5 * 10^14```\n in comparison to only ```\n3.6 * 10^6```\n for the base 10 version. So a plain bruteforce solution would takes ages upon ages. My first attempt was to split the list of numbers into two groups\n\n```\n[14, 13, 10, 9, 6, 5, 2, 1] [15, 12, 11, 8, 7, 4, 3, 0]\n```\n\n\nThe first group is the first product and the second is the second product. The way those lists were created was using a greedy sort and both sum to 60. This should give a higher theoretical chance of being equal. Number of permutations to iterate through is now ```\n8! * 8! = 1.6*10^9```\n. A lot better but still about 150 times larger than the base 10 version.\n\nAny tips of a faster way is much appreaciated. \n\nBase10 version\n\n```\nfrom itertools import permutations\n\ndef find_sum_equal_n():\n    n = 0\n    num = range(10)\n    solutions = set()\n    for perm in permutations(num):\n        tple = product_sum(perm)\n        if product_num(tple) == n:\n            tple = well_ordered(tple)\n            solutions.add(tple)\n    return list(solutions)\n\ndef product_num(tple):\n    total = tple[0]*tple[1] - tple[2]*tple[3]\n    return total\n\ndef product_sum(perm):\n    num1 = 100*perm[0] + 10*perm[1] + perm[2]\n    num2 = 10*perm[3] + perm[4]\n    num3 = 100*perm[5] + 10*perm[6] + perm[7]\n    num4 = 10*perm[8] + perm[9]\n    return (num1, num2, num3, num4)\n\ndef well_ordered(tple):\n    a = max(tple[0], tple[1])\n    b = min(tple[0], tple[1])\n\n    c = max(tple[2], tple[3])\n    d = min(tple[2], tple[3])\n\n    if a > c:\n        tple = (a,b,c,d)\n    else:\n        tple = (c,d,a,b)\n    return tple\n\n\ndef display_solutions(lst):\n    print '============================================'\n    for solution in lst:\n        display_sum(solution)\n        print '============================================'\n\n\ndef display_sum(tple):\n    print '   ' + str_num(tple[0], 3) + ' x ' + str_num(tple[1], 2)\n    print ' - ' + str_num(tple[2], 3) + ' x ' + str_num(tple[3], 2)\n    print ' = ', product_num(tple) \n\n\ndef str_num(num, length):\n    str_num = str(num)\n    diff = max(length - len(str_num), 0)\n    string = ' '*diff\n    string += str_num\n    return string\n\nif __name__ == '__main__':\n\n    lst = find_sum_equal_n()\n    display_solutions(lst)\n    print len(lst)\n```\n\n\nBase16 version\n\n```\nfrom itertools import permutations\n\ndef find_sum_equal_n_16bit():\n    solutions = set()\n\n    key1 = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    key = key1 + ['A', 'B', 'C', 'D', 'E', 'F']\n\n    best = 10**6\n    num1, num2 = split_list(16)\n    list_perm2 = list(permutations(num2))\n    for perm1 in permutations(num1):\n        for perm2 in list_perm2:\n            perm = perm1 + perm2\n            tple = product_sum(perm)\n            temp_best = abs(product_num(tple))\n            if temp_best <= best:\n                print perm\n                display_tuple(tuple_2_16bit(perm))\n                best = temp_best\n                if temp_best == 0:\n                    solutions.add(perm)\n    return list(solutions)\n\n\ndef split_list(n):\n    num = range(1, n)\n    high = [num.pop()]\n    low = []\n    while len(num) > 0:\n        while sum(high) >= sum(low) and len(num) > 0:\n            low.append(num.pop())\n        temp_high = high\n        high = low\n        low = temp_high\n    if len(high) > len(low):\n        low.append(0)\n    else:\n        high.append(0)\n    return high, low\n\n\ndef product_sum(tple):\n    lst = list(tple)\n    num1 = sum(k*16**(4-i) for i, k in enumerate(lst[0:5]))\n    num2 = sum(k*16**(2-i) for i, k in enumerate(lst[5:8]))\n    num3 = sum(k*16**(4-i) for i, k in enumerate(lst[8:13]))\n    num4 = sum(k*16**(2-i) for i, k in enumerate(lst[13:16]))\n    return (num1, num2, num3, num4)\n\n\ndef product_num(tple):\n    total = tple[0]*tple[1] - tple[2]*tple[3]\n    return total\n\n\ndef tuple_2_16bit(tple):\n    key1 = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    key = key1 + ['A', 'B', 'C', 'D', 'E', 'F']\n    lst = [str(key[i]) for i in tple]\n    return (''.join(lst[0: 5]), ''.join(lst[5: 8]), ''.join(lst[8: 13]), ''.join(lst[13: 16]))\n\n\ndef display_tuple(tple):\n    print '   ' + tple[0] + ' x ' + tple[1]\n    print ' - ' + tple[2] + ' x ' + tple[3]\n    print ' = ', int(tple[0], 16)*int(tple[1], 16) - int(tple[2], 16)*int(tple[3], 16)\n\nif __name__ == '__main__':\n\n    print find_sum_equal_n_16bit()\n```\n\n    ", "Answer": "\r\nLooking ```\naxx*bxx```\n for some ```\na```\n and ```\nb```\n we can see that this restricts possible ```\nc```\n and ```\nd```\n in ```\ncxx*dxx```\n for 2nd product.\n\nin 10 digit numbers you can build in this order (digits represnts ordering)\n\n```\n048  15\n269  37\n```\n\n\nThis way it is possible to generate numbers in  way to quickly reduce large portion of search tree when it is detected that result will be larger than prevously found optimal solution.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Is it possible to use alpha-beta pruning for non-zero-sum games with more than two players?\r\n                \r\nI have read somewhere that the minimax algorithm can be generalized for more than two players. Imagine that we have 3 players that each of them want to maximize its own answer. Is it possible to use alpha-beta pruning in this case? or it is useless? why?\n\nNote: Games are non-zero-sum.\n\n\n    ", "Answer": "\r\nYes, but you have to be clear on the game mechanics.  Your given tree shows the blue moves first, then green, and red has final choice.\n\nThere are two approaches here, depending on the game mechanics.  If the sole purpose for each player is to maximize their own result, then you need to solve each level for the active player, considering only the associated reward.\n\nIn the given example, assuming the the rewards are listed in the order (blue, green, red), then red's four choices among the pairs (2-4),(9-4),(0-6),(0-2) will be R,L,R,R; presenting ```\ngreen```\n with values (8-5),(9-3).  From these, ```\ngreen```\n will choose L,L; ```\nblue```\n gets the choice (6-8) and will make the R choice, settling on (8, 9, 6) for the game value.\n\n\n\nHowever, if there are any other motives for the players, such as maximizing the overall gain (which we happened to achieve above) or giving value to the net differences, then you'll need to use a somewhat more complex decision algorithm; the same logic applies.\n\nWith a sufficiently complex game, one in which the players are antagonistic, and moves are made in secret and simultaneously, you may have to switch to the \"one-versus-all\" model, in which each player assumes that the others will make the choices that minimize the choosing player's reward.  This worst-case planning takes you back to a simple minimax process, in which the two opponents are combined into one player, pretending that the game is actually a zero-sum problem.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Prevent Genetic algorithm in zero-sum game from cooperating\r\n                \r\nI have a specific game, which is not literally zero-sum, because points are awarded by the game during a match, but close to it, in the sense that the number of total points have a clear upper limit, so the more points you score, the less points are available for your opponents.\nThe game is played by 5 players, with no teams whatsoever.\n\nI'm making a genetic algorithm play rounds against itself with pseudo-random \"mutations\" between generations.\n\nBut after a couple hundred generations, a pattern always emerges. The algorithm ends up strongly favoring a specific player (example: the player who plays first). Since the mutations giving the \"best results\" serve as a base for the next generation, this seems to move towards some version of \"If you are the first player, play this way (the way being a very specific yet pretty random technique that gives bad, or at best average, results), and if not, then play in this specific way that indirectly but strongly favors the first player\".\n\nThen, for the next generations, the player whose turn is strongly favored starts mutating totally randomly because it wins every round no matter what it does, as long as the part of the algorithm that favors that player is still intact.\n\nI'm looking for a way to prevent this specific evolution route, but I can't figure out how to possibly \"reward\" victory by your own strategy more than victory because you were helped a lot.\n    ", "Answer": "\r\nI think this happens because only the winner of the round robbin tournament gets promoted and mutated on each generation. At first players more or less win randomly, but then a strategy comes up that favors a position. Now I guess that slightly diverting from that strategy (pseudo-random mutations) makes you only lose the games where you are in the favoured position but not win any of the others, so you will never divert from that strategy, something like a local Nash equilibrium.\n\nYou could try to keep more than one individual per generation and generate mutations from them. But I doubt this will help and at best delay the effect. Because soon the code of the best individual will spread to all. This seems to be the root cause of the problem.\n\nTherefore my suggestion would be to have t tribes where each tribe has x/t individuals. Now instead of playing a round robbin tournament each individual plays only against the individuals of other tribes. Then you keep the best individual per tribe, mutate and proceed with the next generation. So that the tribes never mix genes.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "What is a good fitness function for an AI of a zero-sum game?\r\n                \r\nI am making an AI for a zero-sum 4-player board game. It's actually not zero-sum (the 4 players will \"die\" when they lose all their lives, so there will be a player who died first, second, third and a player who survived. However, I am telling the AI that only surviving counts as a win and anything else is a lose) After some research, I figured I would use a minimax algorithm in combination with a heuristic function. I came across this question and decided to do the same as the OP of that question - write an evolutionary algorithm that gives me the best weights.\n\nHowever, my heuristic function is different from the one the OP of that question had. Mine takes 9 weights and is a lot slower, so I can't let the agents play 1000 games (takes too much time) or breed them with the crossover method (how do I do a crossover with 9 weights?).\n\nSo I decided to come up with my own method of determining fitness and breeding. And this question is only about the fitness function.\n\nHere are my attempts at this.\n\nFirst Attempt\n\nFor each agent ```\nA```\n in a randomly generated population of 50 agents, select 3 more agents from the population (with replacement but not the same agent as ```\nA```\n itself) and let the 4 agents play a game where ```\nA```\n is the first player. Select another 3 and play a game where ```\nA```\n is the second player, and so on. For each of these 4 games, if ```\nA```\n died first, its fitness does not change. If ```\nA```\n died second, its fitness is increased by 1. If it died third, its fitness is increased by 2. If it survived, its fitness is increased by 3. Therefore, I concluded that the highest fitness one can get is 12 (surviving/wining all 4 games -> 3 + 3 + 3 + 3).\n\nI ran this for 7 generations and starting from the first generation, the highest fitness is as high as 10. And I calculated the average fitness of the top 10 agents, but the average didn't increase a bit throughout the 7 generations. It even decreased a little.\n\nI think the reason why this didn't work is because there's gotta be a few agents that got lucky and got some poor performing agents as its opponents.\n\nSecond Attempt\n\nThe game setups are the same as my first attempt but instead of measuring the results of each game, I decided to measure how many moves did that agent make before it died. \n\nAfter 7 generations the average fitness of top 10 does increase but still not increasing as much as I think it should.\n\nI think the reason why this failed is that the game is finite, so there is a finite number of moves you can make before you die and the top performing agents pretty much reached that limit. There is no room for growth. Another reason is that the fitness of the player who survived and the fitness of the player who died third differs little.\n\nWhat I want\n\nFrom my understanding of EAs (correct me if I'm wrong), the average fitness should increase and the top performing individual's fitness should not decrease over time. \n\nMy two attempts failed at both of these. Since the opponents are randomly selected, the top performing agent in generation 1 might get stronger opponents in the next generation, and thus its fitness decreases.\n\nNotes\n\nIn my attempts, the agents play 200 games each generation and each generation takes up to 3 hours, so I don't want to let them play too many games.\n\nHow can I write a fitness function like this?\n    ", "Answer": "\r\nSeven generations doesn't seem like nearly enough to get a useful result. Especially for a game, I would expect something like 200+ generations to be more realistic. You could do a number of things:\n\n\nImplement elitism in order to ensure the survival of the best individual(s). \nThe strength of evolution stems from repeated mutation and crossover, so I'd recommend letting the agents play only a few games per generation (say, 5 ~ 10), at least at the beginning, and then evolve the population. You might even want to do only one game per generation.\nIn this regard, you could adopt a continuous evolution strategy. What this means is that as soon as an agent dies, they are subjected to mutation, and as soon as an agent wins, they can produce offspring. Or any combination of the two. The point is that the tournament is ongoing, everyone can play against anyone else. This is a little more \"organic\" in the sense that it does not have strictly defined generations, but it should speed up the process (especially if you can parallelise the evaluation).\n\n\nI hope that helps. The accepted answer in the post you referenced has a good suggestion about the way you could implement crossover.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Type Constraint in Constructor [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Type Constraints in Data Declaration Haskell\r\n                            \r\n                                (3 answers)\r\n                            \r\n                    \r\n                Closed 3 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am trying to make a normal form game solver for game theory, and I'm trying to make it as generic as possible for good practice and for my own convenience. I would like to use the same functions to solve both zero-sum and non-zero-sum games, so I am using the following data type:\n\n```\ndata Payoffs = (Num a, Eq a, Ord a) => ZS a\n    | (Num a, Eq a, Ord a) => NZS (a,a)\n```\n\n\nHowever, this is not correct syntax. Is there any way to constrain ```\na```\n so that it must satisfy those type constraints?\n    ", "Answer": "\r\nShort answer (and probably not the one you need):\nTo make your code work as is, you need a ```\nforall```\n quantifier (for which you need to enable ```\nExistentialQuantification```\n):\n\n```\n{-# LANGUAGE ExistentialQuantification #-}\n\ndata Payoffs =\n      forall a. (Num a, Eq a, Ord a) => ZS a\n    | forall a. (Num a, Eq a, Ord a) => NZS (a,a)\n```\n\n\n\n\nIf you have a type variable in the data constructor (i.e. ```\nZS a```\n), then you have two choices: either that variable has to appear in the type constructor (i.e. ```\ndata Payoffs a =```\n), or you need to say \"I don't care what type it is, as long as it supports these classes\" - which is achieved via the ```\nforall```\n quantifier.\n\nBut this looks kinda useless to me, which suggests that you may be misunderstanding what it means. If you write the above code, every value of your ```\nPayoffs```\n type will be able to wrap a value of any type, as long as that type supports ```\nNum```\n, ```\nEq```\n, and ```\nOrd```\n. One subtle consequence of this is that, if you have two values of ```\nPayoffs```\n lying around, they will not necessarily wrap the same type. For example:\n\n```\nlet x = ZS (42 :: Int)  -- wraps an Int\nlet y = NZS (2.71 :: Double, 3.14)  -- wraps two Doubles\n```\n\n\nThis means that, upon unpacking them, you won't be able to, for example, add them together, because, even though they both implement ```\nNum```\n, the compiler doesn't have any proof that they're actually the same type.\n\nWhat I suspect you actually need is a parametrized type, like this:\n\n```\ndata Payoffs a = ZS a | NZS (a, a)\n```\n\n\nBut then, of course, you lose the constraints: anybody can go and create ```\nZS String```\n or something. You can use the GADT syntax (with the ```\nGADTs```\n extension) to bring them back:\n\n```\n{-# LANGUAGE GADTs #-}\n\ndata Payoffs a where\n    ZS :: (Num a, Ord a, Eq a) => a -> Payoffs a\n    NZS :: (Num a, Ord a, Eq a) => (a, a) -> Payoffs a\n```\n\n\nThis notation is equivalent to ```\nZS a | NZS (a, a)```\n, except you get to define each constructor with the same syntax as any function - including constraints. A type defined like this won't allow for creating values of type ```\nPayoffs a```\n unless ```\na```\n satisfies the constraints.\n\nAt the same time, if you have a value of a type like this lying around, you know what type it wraps inside. And this allows you to tell if two ```\nPayoffs```\n values wrap the same type or different. And then, if you know that they're the same, you can do things with them using the supported classes, for example:\n\n```\naddPayoffs :: Payoffs a -> Payoffs a -> Payoffs a\naddPayoffs (ZS a) (ZS b) = ZS (a + b)\naddPayoffs (ZS a) (NZS (x,y)) = NZS (a+x, a+y)\n... etc.\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Precision error with two mathematically identical expressions around zero\r\n                \r\nWhen plotting two mathematically equivalent expressions very close to zero we get two similar results, but one of the curve has steps instead of being smooth.\n\n```\n1-cosh(x) == -2*sinh(x/2)^2\n```\n\n\n\n\nNow a quick observation reveals that the height of the step is indeed equal to the precision of Matlab, i.e. the variable ```\neps = 2.2204e-16 = 2^-52```\n\n\nThis graph was introduced with the name \"zero sum\", obviously not referencing a zero sum game. But apparently this only occurs with results of additions (or substractions) being very close to zero.\n\nHowever, to my knowledge calculations with floating point numbers (or doubles) are similar in precision regardless of the scale at which the calculations are being made. So I'd expect error to only creep when something really big is being operated on with something really small, in which case the smaller number gets rounded off.\n\nMatlab code to reproduce this:\n\n```\nx = linspace(-5*10^-8, 5*10^-8, 1001);\ny1 = @(x) 1 - cosh(x);\ny2 = @(x) -2*(sinh(x/2)).^2;\n\nplot(x,y1(x),'k',x,y2(x),'r')\nlegend('1-cosh(x)', '-2sinh(x/2)^2')\n```\n\n\nCan someone explain how this.. works?\n    ", "Answer": "\r\nThe rounding happens in the ```\ncosh```\n function. If you plot it and zoom in to the graph at the same scale, you'll see the same staircase-like effect, but centered around 1 on the y-axis.\n\nThat is because you cannot represent those intermediate values using doubles. \n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "What exactly is a board in the minimax function and how is it implemented?\r\n                \r\nSo I was recently looking at the minimax function which is used in zero sum games. I understood it perfectly, other then how the board is implemented for the actual function: \n\nFor example this sample implementation I found has this declaration:\n\n```\nint miniMax(Board eval, int iterations)\n```\n\n\nMy only question is what exactly is ```\nBoard```\n? Is it a struct, class, array or some other structure? Also how would I implement a sample board for mini-max, like a tic-tac-toe board (As a example)? Couldn't find anything on Wikipedia or Google.\n    ", "Answer": "\r\nBoard is just the current board game. It could be any structure you use to represent the board of the game.\n\nWhen called first, the minimax function would receive the current board configuration, reached by the different plays made so far (the current state of the game). In the minimax function what you do is modify the board, each modification should represent a possible move according to the game rules. Each of those modified boards should be passed as argument to a new minimax call. Once you reach a certain depth (this is, a number of iterations), you select the best move using an evaluation function to give a score to every modified board and choosing the one with the highest score.\n\nThe algorithm you are reading is generic and could work for any game. You might define Board according to convenience, that is, what suits best for the board of the game you want to represent.\n\nFor tic-tac-toe, you might want to represent the board with a 3x3 array so you might change Board:\n\n```\nint miniMax(char board[3][3], int iterations)\n```\n\n\nOr perhaps, you may want to represent your board using 2 bits for each square:\n\n```\ntypedef struct {\n    unsigned square1: 2;\n    unsigned square2: 2;\n    unsigned square3: 2;\n    unsigned square4: 2;\n    unsigned square5: 2;\n    unsigned square6: 2;\n    unsigned square7: 2;\n    unsigned square8: 2;\n    unsigned square9: 2;\n} Board;\n```\n\n\nThough, for tic-tac-toe you don't need a lightweight board representation since its maximum depth is just 9. I'm just giving you examples to let you understand it can be any structure you use to represent the board game.\n\nIf you are going to deal with minimax function and the game is much more complex than tic-tac-toe, you should seriously consider using alpha-beta pruning which is a big improvement.\n\nEDIT: I think you shouldn't call your board \"eval\" since that can be confused with the evaluation function which is a totally different thing.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Does optimization kill abstraction and vice versa?\r\n                \r\nI always find that to write optimized code, I have to understand the inner-workings of the system (in some cases the operating system), and thus my code will be written with certain knowledge that unveils the abstractions of the OS (whether intentionally or unintentionally).   \n\nIs this an inherent trait of this interaction? In other words, is abstraction vs optimization a zero-sum game?\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Generate batches of random numbers that each are zero-sum and for which mean of the absolute values is uniformly distributed over specified interval\r\n                \r\nIn the context of polls of voting results, I want to generate random numbers with specific properties to sample the possibilities within the margin of error of the poll.\nFor example, suppose I have polling results:\n\nParty A: 34%\nParty B: 25%\nParty C: 14%\nParty D: 27%\n\nWith a margin of error of 3.2% on the poll-results.\nI want to generate batches of 4 (because in this case there are 4 parties) random numbers. Obviously because voting is a zero-sum game, the numbers in the batch need to sum up to zero.\nI want each element of the batch to be smaller (in absolute value) than the given margin of error of the poll-results.\nAn example could be: ```\n(-0.5, +1.2, +0.1, -0.8)```\n. All the elements sum up to zero and each element is in absolute value smaller than ```\n3.2```\n, i.e. the given margin of error of the poll-results.\nWhen generating a large amount of this kind of batches of random numbers, I would like these to have some specific statistic properties:\n\nThe maximum of the absolute values of the elements should be uniformly distributed over ```\n(0, error_of_margin)```\n (this is the easy part).\nThe mean of the absolute values should also be uniformly distributed over ```\n(0, error_of_margin)```\n.\n\nI tried two different approaches. I will link a gist, to not fill the question with code. https://gist.github.com/thomvil/02890ea2873eed6bb155e7dc387c9564\nDoes anybody have some suggestions on how I could tackle this?\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Trouble with scipy linprog simplex\r\n                \r\nI'm trying to solve a zero-sum game finding the optimal probability distribution for player I. To do so I'm using scipy linprog simplex method.\n\nI've seen an example, I need to transform this game :\n\n```\nG=np.array([\n[ 0  2 -3  0]\n[-2  0  0  3]\n[ 3  0  0 -4]\n[ 0 -3  4  0]])\n```\n\n\ninto this linear optimization problem:\n\n```\nMaximize           z\nSubject to:               2*x2 - 3*x3        + z <= 0\n                  -2*x1 +             + 3*x4 + z <= 0\n                   3*x1 +             - 4*x4 + z <= 0\n                        - 3*x2 + 4*x3        + z <= 0\nwith              x1 + x2 + x3 + x4 = 1\n```\n\n\nHere's my actual code:\n\n```\ndef simplex(G):\n    (n,m) = np.shape(G)\n\n    A_ub = np.transpose(G)\n    # we add an artificial variable to maximize, present in all inequalities\n    A_ub = np.append(A_ub, np.ones((m,1)), axis = 1)\n    # all inequalities should be inferior to 0\n    b_ub = np.zeros(m)\n\n    # the sum of all variables except the artificial one should be equal to one\n    A_eq = np.ones((1,n+1))\n    A_eq[0][n] = 0\n    b_eq = np.ones(1)\n\n    c = np.zeros(n + 1)\n    # -1 to maximize the artificial variable we're going to add\n    c[n] = -1\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=(0,None))\n\n    return (res.x[:-1], res.fun)\n```\n\n\nHere's the distribution I get : \n```\n[5.87042987e-01 1.77606350e-10 2.79082859e-10 4.12957014e-01]```\n\nwhich does sum up to 1, but I expect\n```\n[0 0.6 0.4 0]```\n\n\nI'm trying on a larger game with 6 or 7 lines (and so variables) and it doesn't even sum up to 1.. What did I do wrong ?\n\nThanks for any help you could provide.\n    ", "Answer": "\r\n(I suppose Player 1 (row player) is maximizing and Player 2 (column player) is minimizing.)\n\nPlayer 1's strategy in a Nash equilibrium of this game is any ```\n[0, x2, x3, 0]```\n with ```\n4/7 <= x2 <= 3/5```\n, ```\nx2 + x3 = 1```\n.\n\nIn your code, you are missing a negative sign for the inequality constraint ```\n-G.T x + z <= 0```\n.\nTry the following code:\n\n```\ndef simplex(G, method='simplex'):\n    (n,m) = np.shape(G)\n\n    A_ub = -np.transpose(G)  # negative sign added\n    # we add an artificial variable to maximize, present in all inequalities\n    A_ub = np.append(A_ub, np.ones((m,1)), axis = 1)\n    # all inequalities should be inferior to 0\n    b_ub = np.zeros(m)\n\n    # the sum of all variables except the artificial one should be equal to one\n    A_eq = np.ones((1,n+1))\n    A_eq[0][n] = 0\n    b_eq = np.ones(1)\n\n    c = np.zeros(n + 1)\n    # -1 to maximize the artificial variable we're going to add\n    c[n] = -1\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=(0,None),\n                  method=method)  # `method` option added\n\n    return (res.x[:-1], res.fun)\n```\n\n\nWith the simplex method:\n\n```\nsimplex(G, method='simplex')\n```\n\n\n```\n(array([0.        , 0.57142857, 0.42857143, 0.        ]), 0.0)\n# 4/7 = 0.5714285...\n```\n\n\nWith the interior point method:\n\n```\nsimplex(G, method='interior-point')\n```\n\n\n```\n(array([1.77606350e-10, 5.87042987e-01, 4.12957014e-01, 2.79082859e-10]),\n -9.369597151936987e-10)\n# 4/7 < 5.87042987e-01 < 3/5\n```\n\n\nWith the revised simplex method:\n\n```\nsimplex(G, method='revised simplex')\n```\n\n\n```\n(array([0. , 0.6, 0.4, 0. ]), 0.0)\n# 3/5 = 0.6\n```\n\n\n(Run with SciPy v1.3.0)\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Affect on MinMax algorithm if opponent doesn't play optimally\r\n                \r\nHow does it affect the chances of winning a turn based zero sum game by a AI algorithm such as Minmax algorithm if the opponent doesn't play optimally or rationally?\n\nIs it possible to defeat a Minmax algorithm by playing not so optimal moves as standard Minmax algorithm assumes the opponent to be playing optimally and thus makes decision on the basis of the above assumption?\n    ", "Answer": "\r\nIf the opponent makes a less than optimal move, but then does better than they would by making the \"optimal move\"... then the \"optimal move\" is not the optimal move.\n\nOf course, if the opponent does not make the expected (optimal) move, then you have to rerun the Minmax to decide how to respond -- it may be that the optimal response to the opponent's optimal move is no longer suitable (or possible).\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Is there a way of binding all double click events to their single click equivalent in jQuery / JavaScript?\r\n                \r\nI have some jQuery with a lot of different click events. Some of my users are habitual double clickers, which because I have no double click events bound, fires the single click event twice; this can be a pain - for example if one click opens something, and another closes it, double clicking is a zero-sum game.\n\nIs there any way to bind all double click events to their single click equivalent without have the code them individually?\n    ", "Answer": "\r\nI don't think mapping dblclick to click would help; I'd think it would make things worse, if anything.\n\nYou've said you hook up your events using delegation. You could give yourself a function that debounces calls to your event handler:\n\n\r\n\r\n```\n// Very simple debounce, accepts first event and disregards\r\n// subsequent ones for a period of time\r\nfunction debouncedHandler(handler, delay) {\r\n  delay = delay || 300; // milliseconds, I'm told Windows uses 500 but that seems awfully long\r\n  var last;\r\n  return function() {\r\n    var now = Date.now();\r\n    if (last && last + delay > now) {\r\n      return false;\r\n    }\r\n    last = now;\r\n    return handler.apply(this, arguments);\r\n  };\r\n}\r\n\r\n$(document).on(\"click\", \"input[type=button]\", debouncedHandler(function() {\r\n  $(\".container\").toggleClass(\"toggle-open toggle-closed\");\r\n}));```\n\r\n```\n.toggle-open .closed {\r\n  display: none;\r\n}\r\n.toggle-closed .open {\r\n  display: none;\r\n}```\n\r\n```\n<input type=\"button\" value=\"Open/Close\">\r\n<div class=\"container toggle-open\">\r\n  <span class=\"open\">OPEN</span>\r\n  <span class=\"closed\">closed</span>\r\n</div>\r\n<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js\"></script>```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Difference between Hypermax and Approximate Deep Maxn\r\n                \r\nI do not understand the difference between Hypermax and Approximate Deep Maxn (ADP, page 87, 98). ADP predates Hypermax by about 10 years.\n\nTo me it seems like the very small differences between the two algorithms can be transformed away by modifying the score evaluation function. For example ADP requires an upper bound on the sum of all scores while Hypermax wants zero-sum. An upper bounded sum of scores can be transformed to a 0-sum game for example by applying the transformation described in the Hypermax article: subtract the average score from all scores. If the sum of scores is upper bounded then the average is well defined because you don't divide by infinity.\n\nIs my understanding wrong? Are they the same algorithm under different names?\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Error about inequality constraint in cvxopt (using GLPK)\r\n                \r\nI'm using cvxopt to calculate the Nash equilibrium of a the following two-person zero-sum game.\n\n```\n[-5, 3, 1, 8]\n[ 5, 5, 4, 6]\n[-4, 6, 0, 5]\n```\n\n\nHere's the code (with doctest) I'm using.\n\n```\nfrom cvxopt import matrix, solvers\nfrom cvxopt.modeling import op, dot, variable\nimport numpy as np\n\n\ndef solve_lp(a, b, c):\n    \"\"\"\n    >>> a = matrix([[-5., 3., 1., 8., 1.],\n    ...             [ 5., 5., 4., 6., 1.],\n    ...             [-4., 6., 0., 5., 1.],\n    ...             [-1.,-1.,-1.,-1., 0.],\n    ...             [ 1., 1., 1., 1., 0.],\n    ...             [-1., 0., 0., 0., 0.],\n    ...             [ 0.,-1., 0., 0., 0.],\n    ...             [ 0., 0.,-1., 0., 0.],\n    ...             [ 0., 0., 0.,-1., 0.]])\n    >>> b = matrix([0.,0.,0.,0.,1.])\n    >>> c = matrix([0.,0.,0., 1.,-1.,0.,0.,0.,0.])\n    >>> solve_lp(a, b, c)\n\n    \"\"\"\n    variables = c.size[0]\n    x = variable(variables, 'x')\n    eq     =   (a*x == b)\n    ineq   =   (x >= 0)\n    lp = op(dot(c, x), [eq, ineq])\n    lp.solve(solver='glpk')\n    return (lp.objective.value(), x.value)\n```\n\n\nRunning it generates the following error:\n\n```\nTraceback (most recent call last):\n...\nTypeError: 'G' must be a dense or sparse 'd' matrix with 9 columns\n```\n\n\nIt seems that cvxopt is throwing an exception regarding the ```\nineq```\n constraint, even though I seem to be following the syntax for constraints from the modeling examples.\n\nWhat I've tried so far\n\nChanging the code by multiplying ```\nx```\n by a vector of 1s:\n\n```\ndef solve_lp(a, b, c):    \n    variables = c.size[0]\n    x = variable(variables, 'x')\n    e = matrix(1.0, (1, variables))\n    eq     =   (a*x == b)\n    ineq   =   (e*x >= 0)\n    lp = op(dot(c, x), [eq, ineq])\n    lp.solve(solver='glpk')\n    return (lp.objective.value(), x.value)\n```\n\n\nat least it gets to GLPK, which in turn produces this error:\n\n```\nScaling...\n A: min|aij| =  1.000e+00  max|aij| =  8.000e+00  ratio =  8.000e+00\nProblem data seem to be well scaled\nConstructing initial basis...\nSize of triangular part = 6\n*     0: obj =   0.000000000e+00  infeas =  0.000e+00 (0)\nPROBLEM HAS UNBOUNDED SOLUTION\nglp_simplex: unable to recover undefined or non-optimal solution\n```\n\n\nHow do I fix this?\n    ", "Answer": "\r\nI think you should follow the usage of glpk solver in this webpage:\nhttps://github.com/benmoran/L1-Sudoku/blob/master/sudoku.py\n\nFollow this exactly you will fix and use this glpk solver correctly...\n\ndef solve_plain_l1(A, b, solver='glpk'):\n\n```\n'''Find x with min l1 such that Ax=b,\nusing plain L1 minimization'''\n\nn = A.size[1]\n\nc0 = ones_v(2*n)\n\nG1 = concathoriz(A,-A) # concatenate horizontally\nG2 = concathoriz(-A,A)\nG3 = -eye(2*n)\nG = reduce(concatvert, [G1,G2,G3]) # concatenate vertically\nhh = reduce(concatvert, [b, -b, zeros_v(2*n)])\n\nu = cvxopt.solvers.lp(c0, G, hh, solver=solver)\n\nv = u['x'][:n]\n\nreturn v\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to make Minimax function run for multiple piles\r\n                \r\nHere is my brief: 'Nimsticks is a turn-taking zero-sum game for two players. The game state consists of one or more piles of sticks. On their turn, a player may take 1, 2 or 3 sticks from any one pile. The player who takes the last stick is the loser of the game.\nThe problem is my code works fine when there is only one pile ([4], 1) but if I run it with multiple piles ([2, 3], 1) the if statements maxValue < v and minValue > v aren’t triggered (which they always should be due to inf) and are causing an error. Please help!\n```\nimport copy\nimport math\n \ndef minimax_value(state):\n    if (state[0] == []):\n        return(result(state))\n    else:\n        if (state[1] == 1):\n            v, path = (max_value(state))\n        else:\n            v, path = (min_value(state))\n    optimalPath = path\n    optimalPath.append(state)\n    optimalPath.reverse()\n    print('Example play: ' + str(optimalPath))\n    return str(v)\n \ndef terminal(state):\n    if (state[0] == []):\n        return True\n    else:\n        return False\n \ndef utility(state):\n    if (state[1] == 1):\n        return(1, [])\n    else:\n        return(-1, [])\n \ndef max_value(state):\n    if terminal(state):\n        return(utility(state))\n    else:\n        v = -1 * math.inf\n        for c in next_states(state):\n            minValue, minPath = min_value(c)\n            if (minValue > v):\n                v = minValue\n                bestPath = minPath.copy()\n                bestSucc = c\n        bestPath.append(bestSucc)\n        return(v, bestPath)\n \ndef min_value(state):\n    if terminal(state):\n        return(utility(state))\n    else:\n        v = 1 * math.inf\n        for c in next_states(state):\n           maxValue, maxPath = max_value(c)\n           if (maxValue < v):\n               v = maxValue\n               bestPath = maxPath.copy()\n               bestSucc = c\n        bestPath.append(bestSucc)\n        return(v, bestPath)\n \ndef next_states(state):\n   \n    player = state[1]\n    piles = copy.deepcopy(state[0])\n    pilesSave = copy.deepcopy(piles)\n    temp = []\n    newList = []\n \n    for x in range(0, len(piles)):\n        for y in range(1, 4):\n            piles[x] = piles[x] - y\n            if (piles[x] >= 0):\n                temp = copy.deepcopy(piles)\n                if (piles[x] == 0):\n                    del temp[x]\n                    newList.append(temp)\n                    break\n                newList.append(temp)\n            piles[x] = pilesSave[x]\n    newList2 = []\n    for item in newList:\n        if (player == 1):\n            toAdd = (item, 2)\n        else:\n            toAdd = (item, 1)\n        newList2.append(toAdd)\n       \n    return(newList2)\n \n \nprint(minimax_value(([2, 3], 1)))\n```\n\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Tree Implementation in MinMax with Alpha-Beta Pruning\r\n                \r\nI want to implement an AI (Artificial Intelligence) for a checkers-like game\n\nI have written the follow methods:\n\n-the method\n\n```\n   public List<Move> allMoves(){\n       ...\n    }\n```\n\n\nthat returns me the list of all valid moves sorted by weight, where the weight is calculated according the kind of moves and the position\n\n-the method \n\n```\npublic int apply(Move m){\n       ...\n}\n```\n\n\nto apply the moves to board and returns 1 if some pawn has been killed\n\n-the method \n\n```\npublic void undo(){\n     ...\n}\n```\n\n\nto restore the previous status of the board.\n\nThis is a zero-sum games so the AI shoud maximize pawns of the player color and minimize the pawns of the opponent.\n\nFor this the best way seems using min-max with alpha-beta pruning. \nThis has the follow Pseudo-Code\n\n```\nfunction alphabeta(node, depth, α, β, maximizingPlayer)\n\n           if depth = 0 or node is a terminal node\n                return the heuristic value of node\n            if maximizingPlayer\n                v := -∞\n                for each child of node\n                    v := max(v, alphabeta(child, depth - 1, α, β, FALSE))\n                    α := max(α, v)\n                    if β ≤ α\n                        break (* β cut-off *)\n                return v\n            else\n                v := ∞\n                for each child of node\n                    v := min(v, alphabeta(child, depth - 1, α, β, TRUE))\n                    β := min(β, v)\n                    if β ≤ α\n                        break (* α cut-off *)\n                return v\n\n    (* Initial call *)\n    alphabeta(origin, depth, -∞, +∞, TRUE)\n```\n\n\nBut I haven't understood how to adapt this to my problem.'\nSomeone could help me?\n\nEDIT\n\nI have this MinMax but is without pruning\n\n```\nprivate Integer minimax(Board board, Integer depth, Color current, Boolean maximizingPlayer) {\n    Integer bestValue;\n    if (0 == depth)\n        return ((current == selfColor) ? 1 : -1) * this.evaluateBoard(board, current);\n\n    Integer val;\n    if (maximizingPlayer) {\n        bestValue = -INF;\n        for (Move m : board.getPossibleMoves(current)) {\n            board.apply(m);\n            val = minimax(board, depth - 1, current, Boolean.FALSE);\n            bestValue = Math.max(bestValue, val);\n            board.revert(m);\n        }\n        return bestValue;\n    } else {\n        bestValue = INF;\n        for (Move m : board.getPossibleMoves(current)) {\n            board.apply(m);\n            val = minimax(board, depth - 1, current, Boolean.TRUE);\n            bestValue = Math.min(bestValue, val);\n            board.revert(m);\n        }\n        return bestValue;\n    }\n}\n\nthe evaluate function\n\nprivate Integer evaluateBoard(Board board, Color player) {\n    return board.pawns(player) - board.pawns(player.other());\n}\n```\n\n\nHow to edit to obtain alpha beta pruning?\n    ", "Answer": "\r\nThis is some pseudo code for an alpha beta chess program I wrote in the past. Well, checkers or chess - there is no big difference in this part:\n\n```\n  Const White      =      1;\n        Black      =     -1;\n\n        MaxInteger =  32767;\n        MinInteger = -32768;\n\n  Function AlphaBeta (Color, Alpha, Beta, \n                             Depth, MaxDepth : Integer) : Integer; \n  var Value : Integer;\n\n  begin\n    if Depth = MaxDepth then \n       AlphaBeta := EvaluatePosition (Color)\n\n    end else\n    begin\n       GenerateMoves(Color, MoveList);\n\n       For Each Move in MoveList do\n       begin\n           MoveForward (Move);\n\n               Value := AlphaBeta (-Color, Beta, Alpha,\n                                           Depth +1, MaxDepth);\n\n               if Color = White then\n                  if Value > Alpha then Alpha := Value;\n\n               if Color = Black then\n                  if Value < Alpha then Alpha := Value;\n\n           MoveBack (Move);\n\n               if Color = White then\n                  if Alpha >= Beta then Return Alpha;\n\n               if Color = Black then\n                  if Alpha <= Beta then Return Alpha;\n       end;\n\n       AlphaBeta := Alpha;\n    end;\n  end;\n```\n\n\nOnly ```\nGenerateMoves```\n, ```\nEvaluatePosition```\n and ```\nMoveForward```\n/```\nBack```\n are specific. You can find the complete code here. It's not super optimized because tried to make it as readable as possible\n\nadded: so remove ```\ncurrent```\n, as it is not really required. Add two parameters for the search window and add the pruning:\n\n```\nprivate Integer minimax(Board board, Integer depth, Boolean maximizingPlayer, \n                        Integer maxPlayerBestVal, Integer minPlayerBestVal) {\n    Integer bestValue;\n    if (0 == depth)\n        return this.evaluateBoard(board);\n\n    Integer val;\n    if (maximizingPlayer) {\n        bestValue = -INF;\n        // current never changed in your case; so you better use the bool\n        for (Move m : board.getPossibleMoves(maximizingPlayer))) {\n            board.apply(m);\n            val = minimax(board, depth - 1, Boolean.FALSE, \n                          minPlayerBestVal, maxPlayerBestVal); // swap here \n            bestValue = Math.max(bestValue, val);\n            board.revert(m);\n            if (bestValue >= minPlayerBestVal) // too good for the minPlayer\n                return bestValue;              // so cut here (pruning)\n        }\n        return bestValue;\n```\n\n\nFinally you need to call the algorithm with a maximized window:\n\n```\nminimax(board, 3, true, Integer.MinInt, Integer.MaxInt);\n```\n\n\n... meaning its the max. players turn who starts with the worst values possible (```\nInteger.MinInt```\n)\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How I can change learning rate of RLlib training agent in dynamic\r\n                \r\nI'm using ray RLlib library to train multi-agent Trainer on the 5-in-a-row game. This is zero-sum environment so I have a problem of agents behavior degeneration (always win for 1'st agent, 5 moves to win). I have an idea to change learning rate of the agents in a that way: first train the first agent, left second as random with learning rate equal to zero. After first agent learns how to win more than 90% games switch. Then repeat\nBut I can't change learning rate after its initialization in constructor. Is this possible?\n\n```\ndef gen_policy(GENV, lr=0.001):\n    config = {\n        \"model\": {\n            \"custom_model\": 'GomokuModel',\n            \"custom_options\": {\"use_symmetry\": True, \"reg_loss\": 0},\n        },\n        \"custom_action_dist\": Categorical,\n        \"lr\": lr\n    }\n    return (None, GENV.observation_space, GENV.action_space, config)\n\ndef map_fn(agent_id):\n    if agent_id=='agent_0':\n        return \"policy_0\"\n    else:\n        return \"policy_1\"\n\ntrainer = ray.rllib.agents.a3c.A3CTrainer(env=\"GomokuEnv\", config={\n        \"multiagent\": {\n            \"policies\": {\"policy_0\": gen_policy(GENV, lr = 0.001), \"policy_1\": gen_policy(GENV,lr=0)},\n            \"policy_mapping_fn\": map_fn,\n            },\n        \"callbacks\":\n            {\"on_episode_end\": clb_episode_end},\n\n\nwhile True:\n    rest = trainer.train()\n    #here I want to change learning rate of my policies based on environment statistics\n```\n\n\nI've tried to add these lines inside while True loop\n\n```\nnew_config = trainer.get_config()\nnew_config[\"multiagent\"][\"policies\"][\"policy_0\"]=gm.gen_policy(GENV, lr = 0.00321)\nnew_config[\"multiagent\"][\"policies\"][\"policy_1\"]=gm.gen_policy(GENV, lr = 0.00175)\n\ntrainer[\"raw_user_config\"]=new_config\ntrainer.config = new_config\n```\n\n\nit didn't help\n    ", "Answer": "\r\nI stumbled upon the same question and did some research on the RLlib implementation.\nFrom the testing scripts it looks like the lr_schedule is given by an interval like\n```\nlr_schedule: [\n            [0, 0.0005],\n            [20000000, 0.000000000001],\n        ]\n```\n\nAfter that I checked out the implementation details.\nIn ray/rllib/policy/torch_policy.py the function LearningRateSchedule implements the entry point.\nWhen a lr_schedule is defined the PiecewiseSchedule is used.\nFrom the implementation of PiecewiseSchedule in ray/rllib/utils/schedules/piecewise_schedule.py  follows:\n```\nendpoints (List[Tuple[int,float]]): A list of tuples\n                `(t, value)` such that the output\n                is an interpolation (given by the `interpolation` callable)\n                between two values.\n                E.g.\n                t=400 and endpoints=[(0, 20.0),(500, 30.0)]\n                output=20.0 + 0.8 * (30.0 - 20.0) = 28.0\n                NOTE: All the values for time must be sorted in an increasing\n                order.\n```\n\nThat means the learning rate schedule consists of two parameters:\ntimestep t (int) and suppost learning rate (float)\nFor each timestep in-between those values an interpolation is used.\nThe interpolation can be specified inside the function PiecewiseSchedule through the parameter interpolation which defaults to _linear_interpolation\n```\ninterpolation (callable): A function that takes the left-value,\n                the right-value and an alpha interpolation parameter\n                (0.0=only left value, 1.0=only right value), which is the\n                fraction of distance from left endpoint to right endpoint.\n```\n\nTL;DR;\nTherefore the lr_schedule describes the support points of the linear interpolation (using the default interpolation).\nAdditionally to change the parameter during the training from this Github Issue the best choice seems to reinitialize the trainer:\n```\nstate = trainer.save()\ntrainer.stop()\n#re_initialise trainer\ntrainer.restore(state)\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Excel solver 5x5 sum game\r\n                \r\nMy son found this math game app and I've been playing it. Essentially you have a 5x5 grid of numbers from 0-9, and then at the end of each column and row is a target sum. Every number in the grid can be turned on or off, and when the correct sum is achieved that row or column is highlighted. You can actually play on harder levels, but for an excel problem I decided to try 5x5 just to see if I could get solver to find the answer.\n\nThe way I designed this is as follows:\n\n(a) Cells B2-F6 have the number values from the grid.\n(b) Cells H2-L6 I put in all zeroes.\n(c) Cells N2-S6 I put in as the product of B2 and H2, B3 and H3, etc.\n(d) Cells N8-R8 are the sum of N2-N6, O2-O6, etc.\n(e) Cells S2-S6 are the sums of N2-R2, N3-R3, etc.\n(f) Cells N9-R9 are the target identified by the game.\n(g) Cells N10-R10 are N9-N8, O9-O8, etc.\n(h) Cells T2-T6 are the target identified by the game.\n(i) Cells U2-U6 are T2-S2, T3-S3, etc.\n(j) Cell W2 is =MAX(T2:T6,N9:R9)\n(k) Cell T12 is =N10*W2^9+O10*W2^8+P10*W2^7+Q10*W2^6+R10*W2^5+U2*W2^4+U3*W2^3+U4*W2^2+U5*W2^1+U6*W2^0\n\nIn solver, I set the object of $T$12 to be value of 0, with constraints on variable cells $H$2:$L$6 as <=1, >=0, integer.\n\nHowever, I can't seem to get solver to find me a solution. I solved it in the game first so I had a solution. When I put that in, solver will tell me it found a solution after changing nothing, or on the evolutionary one it will tell me it hasn't found anything better...of course not, I've already given you the solution. But if you change just one of the 5x5 grid to be wrong, it still can't find a solution. Is this just too complex for solver? It's weird to me that when it fails it has non-integer values in the cells. I keep wondering why it's trying non-integer values when I told it not to (and I did check to be sure my Ignore Integer Constraints box is unchecked). I understand that there are 2^25 different possibilities it should have to try, but there's an infinite number more (okay, maybe finite if it has a maximum number of decimals in the data type, but for all practical, non-quantum purposes, it's infinite) if it ignores my integer requirements. Maybe it's just not comfortable with a brute-force approach and is trying to head a particular direction and just keeps finding that unsatisfactory. I also recognize that my cell T12 formula may be too much for it to handle. It just won't let me have multiple targets so I was trying to come up with a way for it to guarantee no false positives (e.g., if you just add all the difference cells in N10-S10 and U2-U6, which should all be zero, you can actually get solutions where some of the columns are non-zero but add up to zero because of positives and negatives...and those are result cells, so I can't similarly constrain them, I think).\n\nAnyhow, here's the number set:\n\n2 9 3 2 3\n9 9 8 4 1\n2 6 5 2 6\n3 1 6 8 7\n6 8 3 6 9   \n\nRow totals = 13, 4, 7, 19, 32 from top to bottom\nColumn totals = 13, 18, 8, 20, 16\n\nI'd give you the answer...but where's the fun in that? \n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Minimax function for Nimsticks Game (Python)\r\n                \r\nHere is my brief: 'Nimsticks is a turn-taking zero-sum game for two players. The game state consists of one or more\npiles of sticks. On their turn, a player may take 1, 2 or 3 sticks from any one pile. The player who\ntakes the last stick is the loser of the game.\nThe state will be a tuple containing two parts: the current state of the piles, and who’s turn\nit is (1 = MAX, 2 = MIN). For example, if there is a pile of 3 sticks and 2 sticks, and it is Max’s\nturn to play, then the input should look like ([3, 2], 1)\nminimax_value(([3,2],1))'\nSo far I have a partial solution (below), but it only returns 'inf' or '-inf' which isn't ideal. Any help would be much appreciated.\n```\nimport copy\n\ndef minimax_value(state):\n    if (state[0] == []):\n        return(result(state))\n    else:\n        if (state[-1] == 1):\n            return(max_value(state))\n        else:\n            return(min_value(state))\n    \ndef terminal(state):\n    if (state[0] == []):\n        return True\n    else:\n        return False\n\ndef result(state):\n    if (state[-1] == 1):\n        return(\"+1\")\n    else:\n        return(\"-1\")\n\ndef max_value(state):\n    if terminal(state):\n        return result(state)\n    else:\n        v = float(\"-inf\")\n        for c in next_states(state):\n            v = max(v, min_value(c)) \n        return(v)\n\ndef min_value(state):\n    if terminal(state):\n        return result(state)\n    else:\n        v = float(\"inf\")\n        for c in next_states(state):\n           v = min(v, max_value(c))\n        return(v)\n\ndef next_states(state):\n    if (type(state) == tuple):\n        piles = copy.deepcopy(state[0])\n    else:\n        piles = copy.deepcopy(state)\n    pilesSave = copy.deepcopy(piles)\n    temp = []\n    newList = []\n\n    for x in range(0, len(piles)):\n        for y in range(1, 4):\n            piles[x] = piles[x] - 1\n            if (piles[x] >= 0):\n                temp = copy.deepcopy(piles)\n                newList.append(temp)\n        piles[x] = pilesSave[x]\n    return(newList)\n\n\nprint(minimax_value(([4], 1)))\n```\n\n    ", "Answer": "\r\n```\nmin_value```\n calls ```\nmax_value```\n on each ```\nnext_states(state)```\n which likewise calls ```\nmin_value```\n on each ```\nnext_states(state)```\n because ```\nnext_states```\n returns a list of values less than the given value this process repeats until ```\nstate = [0]```\n at which point ```\nnext_state```\n returns an empty list because ```\nif (piles[x] >= 0):```\n evaluates to ```\nfalse```\n and because ```\nnext_states(state)->[]```\n nothing inside ```\nfor c in next_states(state):```\n happens and ```\nreturn (v)```\n returns ```\ninf```\n or ```\n-inf```\n. Because ```\nmin_value```\n returns ```\ninf```\n to ```\nmax_value```\n ```\nmax_value```\n returns ```\ninf```\n and visa versa for ```\nmax_value```\n returning ```\n-inf```\n for ```\nmin_value```\n.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Java dice rolling game While loops Randomon generation\r\n                \r\nokay so I am attempting to create a dice game where args[0] is the amount of times the game is played. the game.... two dice are rolled and if the sum does not equal 7 their value is added to a sum. If the sum equals 7 the game is over. I want to keep track of the largest sum out of all the games and the smallest which should be zero always because when the sum equals 7 it sets the sum to 0. \nHere is my code. I don't think what it is printing is what I am going for...help?Also how do i auto format in eclipse?\n\n```\npublic class diceGame {\n    public static void main(String[] args) {\n        int dice1;\n        int dice2;\n        int count=0;\n        int theSum=0;\n        int lowest=500;\n        int finalSum=0;\n        int diceSum=0;\n        while (count !=Integer.parseInt(args[0])){\n            count=count+1;\n            theSum=0;\n            while(diceSum!=7){\n                diceSum=0;\n                dice1=1 + (int)(Math.random() * ((6 - 1) + 1));\n                dice2=1 + (int )(Math.random() * ((6 - 1) + 1));\n                diceSum=dice1+dice2;\n                if (diceSum !=7){\n                    theSum=theSum+diceSum;\n                if (theSum>finalSum){\n                    finalSum=theSum;\n                    }\n                if (theSum<lowest){\n                    lowest=theSum;\n                }\n\n\n                }\n\n                }\n            }\n        System.out.println(\"After \"+args[0]+\" simulations: \");\n        System.out.println(\"Biggest sum: \"+finalSum);\n        System.out.println(\"Smallest sum: \"+lowest);\n    }\n    }\n```\n\n\nI fixed it\n\n```\npublic class diceGame {\n    public static void main(String[] args) {\n        int dice1;\n        int dice2;\n        int count = 0;\n        int theSum = 0;\n        int lowest = Integer.MAX_VALUE;\n        int finalSum = 0;\n        int diceSum;\n        int totalSum=0;\n        while (count < Integer.parseInt(args[0])) {\n            count = count + 1;\n            diceSum=0;\n            theSum=0;\n            while (diceSum!=7) {\n                diceSum = 0;\n                dice1 = 1 + (int) ((Math.random() * (6 - 1)) + 1);\n                dice2 = 1 + (int) ((Math.random() * (6 - 1)) + 1);\n                diceSum = dice1 + dice2;\n                if (diceSum != 7) {\n                    theSum = theSum + diceSum;\n                }\n                //System.out.println(\"the sum is \"+theSum);\n            }\n            if (theSum > finalSum) {\n                finalSum = theSum;\n            }\n            if (theSum < lowest) {\n                lowest = theSum;\n            }\n            totalSum=totalSum+theSum;\n        }\n        double average=(double)totalSum/(Double.parseDouble(args[0]));\n        System.out.println(\"After \" + args[0] + \" simulations: \");\n        System.out.println(\"Biggest sum: \" + finalSum);\n        System.out.println(\"Smallest sum: \" + lowest);\n        System.out.println(\"The average is: \"+average);\n\n    }\n}\n```\n\n    ", "Answer": "\r\nIt is because the lowest value of 2 dice when added is 2, not 0.  And if you roll a 7 on the first roll, then you will not update your biggest and lowest.  You need to move those checks outside the loop.\n\n```\n        while(diceSum!=7){\n            diceSum=0;\n            dice1=1 + (int)(Math.random() * ((6 - 1) + 1));\n            dice2=1 + (int )(Math.random() * ((6 - 1) + 1));\n            diceSum=dice1+dice2;\n            if (diceSum !=7) {\n                theSum=theSum+diceSum;\n            }\n        }\n        if (theSum>finalSum){\n            finalSum=theSum;\n        }\n        if (theSum<lowest){\n            lowest=theSum;\n        }\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Calculate Tic-Tac-Toe Game Winner C# || Online Practice assessment test question ||\r\n                \r\n\nI'm trying to figure out if I coded this correctly according to directions within the image.\nPlease inform me on what I did wrong.\n// Here's my Code think it right but not 100% sure\n```\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Reflection;\n\nnamespace TicTacToe.Template\n{\npublic enum CellState\n{\n[Description(\"EMPTY\")]\nEmpty,\n[Description(\"X\")]\nX,\n[Description(\"O\")]\nO\n}\n\npublic enum Winner\n{\n[Description(\"IN_PROGRESS\")]\nInProgress,\n[Description(\"TIED\")]\nTied,\n[Description(\"X\")]\nX,\n[Description(\"O\")]\nO\n}\n\npublic static class EnumExtensions\n{\npublic static string GetDescription(this Enum value)\n{\nType type = value.GetType();\nstring name = Enum.GetName(type, value);\nif (name != null)\n{\nFieldInfo field = type.GetField(name);\nif (field != null)\n{\nDescriptionAttribute attr =\nAttribute.GetCustomAttribute(field,\ntypeof(DescriptionAttribute)) as DescriptionAttribute;\nif (attr != null)\n{\nreturn attr.Description;\n}\n}\n}\nreturn null;\n}\n}\n\npublic class TicTacToe\n{\n\n/**\n* Evaluates the game board to determine the winner.\n* <p>\n* If the game is still in progress, then this method returns InProgress.\n* If the game is tied, then this method returns Tied.\n* Otherwise, returns the winner - either X or O.\n*\n* @param cells - an array of 9 game cells that forms the 3x3 grid of the board.\n* @return the Winner - InProgress, Tied, X, or O\n*/\n```\n\n//Main part of the code where I added in functionality this function below was blank before.\n```\npublic static Winner CalculateWinner(CellState[] cells)\n        { \n            if (cells[0] == cells[1] && cells[1] == cells[2])\n            {\n                 return Winner.X;\n            }\n            else if (cells[3] == cells[4] && cells[4] == cells[5])\n            {\n                return Winner.X;\n            }\n            else if (cells[6] == cells[7] && cells[7] == cells[8])\n            {\n                return Winner.X;\n            }    \n            else if (cells[0] == cells[3] && cells[3] == cells[6])\n            {\n                return Winner.X;\n            }\n            else if (cells[1] == cells[4] && cells[4] == cells[7])\n            {\n                return Winner.X;\n            }\n            else if (cells[2] == cells[5] && cells[5] == cells[8])\n            {\n                return Winner.X;\n            }\n            else if (cells[0] == cells[4] && cells[4] == cells[8])\n            {\n                return Winner.X;\n            }\n            else if (cells[2] == cells[4] && cells[4] == cells[6])\n            {\n                return Winner.X;\n            }\n            else\n            {\n                return Winner.Tied;\n            }\n        }\n\npublic static CellState[] ConvertInputLineToCellStateArray(string inputLine)\n{\nif (inputLine.Length != 9)\n{\nthrow new ArgumentException(\"Invalid state string. Should have 9 characters.\");\n}\n\nList<CellState> cellStates = new List<CellState>();\n\nforeach (char c in inputLine)\n{\nif (c == '_') cellStates.Add(CellState.Empty);\nif (c == 'X') cellStates.Add(CellState.X);\nif (c == 'O') cellStates.Add(CellState.O);\n}\n\nreturn cellStates.ToArray();\n}\n\npublic static void Main(string[] args)\n{\nstring inputLine;\n\nwhile ((inputLine = Console.ReadLine()) != null)\n{\nConsole.WriteLine(CalculateWinner(ConvertInputLineToCellStateArray(inputLine)).GetDescription());\n}\n}\n}\n}\n```\n\nPLease ignore these paragraphs below it just basic Rules, info and history about Tic-Tac Toe. It wasn't letting me post cause it was saying I had too much code. Explanation  in the image Above. Thank You.\nTic-Tac-Toe is a simple and fun game for 2 players, X and O. It is played on a 3x3 grid. Each player's goal is to make 3 in a row.\nTypically, X starts first, but in Gametable's Tabletop Tic Tac Toe, Player 1 starts first on the first game and Player 2 (or the computer) starts first on the next game. The starting player continues to alternate from game to game. This helps keep gameplay fair over time.\nPlayers take turns placing their Mark, X or O, on an open square in the grid. The first player to make 3 of their own mark in a row vertically, horizontally, or diagonally wins the game.\nIf all 9 squares are filled and neither player has 3 in a row, the game is considered a Tie.\nThe expert artificial intelligence (AI) will play a perfect game. Try your best to Tie it for as long as you can!\nZERO-SUM GAME\nTic-Tac-Toe is a zero-sum game, which means that if both players are playing their best, the game will end in a Tie. However, if you learn how to play tic-tac-toe and master some simple strategies, then you'll be able to not only play, but to win the majority of the time.\nHISTORY\nTic-Tac-Toe is a long beloved classic pen and paper or board game for two players. Variations of Tic Tac Toe have been played since the Roman Empire and 3 in a row games can be traced all the way back to ancient Egypt!\nNOUGHTS AND CROSSES\nTic Tac Toe is known by a few other names around the world. The most common of these is \"Noughts and Crosses\" and it is sometimes simply referred to as the \"XO game.\"\ngametable.org\nGametable is an upcoming interactive entertainment company for the desktop and mobile world. We currently have three free online games- dots and boxes, checkers, and tic tac toe. We're actively developing more fun titles by the day. We're offering ad-free online games for a limited time so pull up a chair to the game table today! We value your privacy as much as you do! Privacy Policy, Cookie Policy, and Terms & Conditions.\n    ", "Answer": "\r\nHere is a very straight forward implementation\n```\npublic static Winner CalculateWinner(CellState[] cells)\n{\n    var linesToCheck = new []\n    {\n        // horizontal\n        new [] { cells[0], cells[1], cells[2] },\n        new [] { cells[3], cells[4], cells[5] },\n        new [] { cells[6], cells[7], cells[8] },\n        // vertical\n        new [] { cells[0], cells[3], cells[6] },\n        new [] { cells[1], cells[4], cells[7] },\n        new [] { cells[2], cells[5], cells[8] },\n        // diagonal\n        new [] { cells[0], cells[4], cells[8] },\n        new [] { cells[6], cells[4], cells[2] },\n    };\n\n    foreach (var line in linesToCheck)\n    {\n        if (line.Distinct().Count() == 1)\n        {\n            switch (line.First())\n            {\n                case CellState.X: \n                    return Winner.X;\n                case CellState.O:\n                    return Winner.O;\n                default:\n                    break;\n            }\n        }\n    }\n\n    if (cells.Any( c => c == CellState.Empty ))\n        return Winner.InProgress;\n    else\n        return Winner.Tied;\n}\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Can \"Monte-Carlo Tree Search\" be applied on a \"two player game with imperfect information\" like Stratego?\r\n                \r\nI want to develop a two player game with imperfect information - \"Stratego\".\n\nThe game is \"somewhat\" like chess but initially we don't know anything about the ranks of the opponent's pieces. When a piece attacks or is attacked by some opponent's piece, their ranks are revealed and the higher rank piece kills/captures the lower rank piece.\nMore detail on the game can be found here.\n\nI did a little research. I read \"Opponent Modeling in Stratego\" by J.A. Stankiewicz. But I couldn't find a complete tutorial on how to develop the game. I have successfully developed before a two player game - \"Othello\" a.k.a. Reversi, and I'm familiar with MINIMAX algorithm and alpha-beta pruning. \n\nI found somewhere that Monte-Carlo Tree Search is also used in developing zero-sum two player games. Can it be used for games like stratego? Can I get a complete tutorial for the same?\n\nAny other tutorial not involving Monte-Carlo Tree Search would also be useful :)\n    ", "Answer": "\r\nI think MCTS would have a difficult time in Stratego since the initial spreading function is so large while the best play is very dependent on the ground-truth of the game. That is to say, MCTS would, in the best case, give you a play that's statistically good amongst all the possible variations of your opponent's pieces, but the best next move is highly dependent on which particular variation they've chosen.\n\nI'm still developing a solid understanding of MCTS, but it seems to me that MCTS does not do well in games where multi-round deceptive play involving hidden information is important (poker, canonically, but stratego, I would say, also). In such games, you really need to develop a model of the other player(s) situation/strategy and MCTS by its nature is going to give you an answer that is statistically related to all trees, not just the ground-truth tree. \n\nMCTS works fine with games involving large amounts of chance (backgammon and other board games involving dice and many card games) and seems to me an excellent general-purpose solution that could be rapidly adopted to a large number of modern \"European-style\" board games. (The interesting thing with those is that although they involve \"deceptive strategy\" they generally involve relatively little hidden information.)\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Alternative to minimax for boardgame AI? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm making an AI for a zero-sum board game. It's the following game http://en.wikipedia.org/wiki/Y_%28game%29\n\nThe board i'm using is 15 fields per side, so that is 120 hexagons total. this is obviously way to big for a standard minimax approach. I was thinking I could cut off a lot because of symmetry but I still think it wont be enough.\n\nAre there any viable alternatives for minimax when the game is too complex to search all options?\n\nThanks\n    ", "Answer": "\r\nThere are dozens of \"alternatives\", or rather - modifications, with at least two basic models:\n\n\nAlpha-beta - basic pruning technique for minimax\nUCT - probabilistic method with guaranteed convergence to the minimax tree\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Understanding definition of minimax value\r\n                \r\nIn Russell and Norvig, third edition, they give the following definition of the minimax value of a node in a game tree (zero-sum, perfect information, deterministic)\n\n\n  The minimax value of a node is the utility (for MAX) of being in the corresponding state, assuming that both players play optimally from there to the end of the game.\n\n\nOnly thing is, that in their setup of a game, the utility of a node is only defined for terminal nodes, so how should one understand the utility of a general node ? Thanks. \n    ", "Answer": "\r\nUtility is defined for non-terminal nodes.  It's that for terminal nodes, utility is estimated by some external heuristic (which they call UTILITY), but for non-terminal nodes utility is computed by the minimax algorithm.  The minimax value (or utility) of a non-terminal node is either the maximum or the minimum of the minimax values of its children (depending on whose move it is).  The minimax value of the root will be the utility of the outcome you'll get to if both you and your opponent make optimal moves from there on out.\n\nThere's a worked-out example here that should make it clearer.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Mone Carlo Tree Search and terminal Nodes handling\r\n                \r\nI'm trying to implement AlphaZero on a new game using this repository. I'm not sure if they are handling the MCTS search tree correctly.\nThe logic of their MCTS implementation is as follows:\n\nGet a \"canonical form\" of the current game state. Basically, switching player colors because the Neural Net always needs the input from the perspective of player with ID = 1. So if the current player is 1, nothing changes. If the current player is -1 the board is inverted.\nCall MCTS search. Source code\nIn the expand-step of the algorithm, a new node is generated like this:\n\n```\nnext_s, next_player = self.game.getNextState(canonicalBoard, 1, a)\nnext_s = self.game.getCanonicalForm(next_s, next_player)\n```\n\n\"1\" is the current player and \"a\" is the selected action. Since the input current player is always 1, next_player is always -1 and the board always gets inverted.\nThe problem occurs once we hit a terminal state:\n\nAssume that action a ends the game\nA next state (next_s) is returned by the \"getNextState\" method, next_player is set to -1. The board gets inverted one last time (1 becomes -1, -1 becomes 1). We now view the board from the perspective of the loser player. That means that a call to getGameEnded(canonicalBoard, 1) will always return -1 (or 0.0001 if it's a draw). Which means we can never observe a win for the player with ID 1.\nThe getGameEnded function is implemented from the perspective of player with ID = 1. So it returns +1 if player with ID 1 wins, -1 if player with ID 1 loses.\n\nMy current understanding about MCTS is that we need to observe all possible game ending states of a two player zero-sum game. I tried to use the framework on my game, and it didn't learn or get better. I changed the game logic to explicitly keep track of the current player id so that I can return all three possible outcomes. Now, at least it seems to learn a bit, but I still think that there is something wrong.\nQuestions:\n\nCould this implementation theoretically work? Is it a correct implementation of the MCTS algorithm?\nDoes MCTS need to observe all possible outcomes of a two player zero-sum game?\nAre there any obvious quick fixes of the code? Am I missing something about the implementation?\n\n    ", "Answer": "\r\nConceptually the implementation in the linked repo is correct.  The evaluation of the state is not checked until we recurse 1 more time to the perspective of the losing player, but as soon as that backs up 1 level the last player to move it is viewed as a win for the last player to perform an action and that will back up the tree all the way swapping back and forth to the current state of the real game which will return the correct value.\nThis does represent all possible outcomes.  The outcomes are player 1 wins, player 2 wins or draw.  In the case of a draw, it just returns something close to zero.  In the case that player 1 wins, player 1 made the last move and then we recurse to player 2 who is in a losing evaluation.  In the case that player 2 wins, player 2 would have made the last move and then we recurse once more to where player 1's evaluation is a loss.\nIt should be noted that it is possible for there to be a game where you move last and lose and in that case it is still correct!\n\nIf you wrote your own game rules and are trying to get this to work for your game, it's best to make sure your implementation adheres to the assumptions made by this implementation, i.e. the evaluation is always from the position of the active player and that your evaluation function is actually zero sum.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "PayPal BAID mp_status is not clear and doesn't seem documented\r\n                \r\nWhen setting up a PayPal reference transaction, I receive via the IPN (```\ntxn_type=mp_signup```\n) a status code called ```\nmp_status```\n. I assume that this is the approval code, but there doesn't seem to be any documentation on this code.\n\nMy specific code is ```\nmp_status=0```\n.\n\nThe documentation that does exist states that ```\nmp_status```\n is:\n\n\n  The agreement status. Possible values are A for an active agreement\n  and I for an inactive agreement (equivalent to canceled).\n\n\nAs you can see the mp_status that I received is not covered in this blurb. I assume that this means a failed signup, since the value is not \"A\", payments being a zero-sum game. This is assumption is possibly contradicted by another value in the post ```\nreason_code=mp_2001```\n, which thanks to this SO post, I know is the successful creation of a billing agreement.\n\nGiven these values from the PayPal IPN, what is the status of this reference transaction? Has a recurring billing (BAID) agreement been created?\n    ", "Answer": "\r\nThat mp_status does not appear to indicate anything out of the ordinary; I would ignore it unless you find either a documented or empirical reason to pay attention to it\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Difficulty implementing Alpha-beta pruning to minimax algorithm\r\n                \r\nI'm having some difficulty getting Alpha-beta pruning to work correctly. \nI've got a functional Minimax algorithm, which I've tried to adapt, but to no avail.  I used the example on Wikipedia\n\nCurrently, the algorithm seems to run as expected for the most part, but then it chooses the first node tested regardless. \n\nThis could potentially be due to lack of understanding, but I've spent hours reading up on this already. What confused me is how the algorithm is supposed to know which node is the best choice when it reaches its depth limit in a zero sum game; at which point it can't be certain which player would benefit most from such a move, can it?\n\nAnyway, my .cpp is below. Both my original minimax function and Any help whatsoever will be appreciated!\n\n```\nAIMove ComputerInputComponent::FindBestMove() {\n\nconst Graph<HexNode>* graph = HexgameCore::GetInstance().GetGraph();\n\nstd::vector<AIMove> possibleMoves;\n\nFindPossibleMoves(*graph, possibleMoves);\n\nAIMove bestMove = AIMove();\n\nint alpha = INT_MIN;\nint beta = INT_MAX;\nint depth = 6;\n\nNode* currentNode;\n\nfor (const AIMove &move : possibleMoves) {\n\n    std::cout << move << std::endl;\n\n    graph->SetNodeOwner(move.x, move.y, (NodeOwner)aiPlayer);\n    int v = MiniMaxAlphaBeta(*graph, depth, alpha, beta, true);\n    graph->SetNodeOwner(move.x, move.y, NodeOwner::None);\n\n    if (v > alpha) {\n        alpha = v;\n        bestMove.x = move.x;\n        bestMove.y = move.y;\n    }\n}\nreturn bestMove;\n```\n\n\n}\n\n```\ntemplate<typename T>\n```\n\n\nint ComputerInputComponent::MiniMaxAlphaBeta(const Graph& graph, int depth, int alpha, int beta, bool isMaximiser) {\n\n```\nstd::vector<AIMove> possibleMoves;\nFindPossibleMoves(graph, possibleMoves);\n\nif (lastTestedNode != nullptr) {\n    Pathfinder pathFinder;\n    bool pathFound = pathFinder.SearchForPath(lastTestedNode, graph.GetMaxX(), graph.GetMaxY());\n    if (pathFound) {\n        //std::cout << \"pathfound-\" << std::endl;\n        if ((int)lastTestedNode->GetOwner() == aiPlayer) {\n            std::cout << \"cpuWin-\" << std::endl;\n            return 10;\n        } \n        else if ((int)lastTestedNode->GetOwner() == humanPlayer) {\n            std::cout << \"playerWin-\" << std::endl;\n            return -10;\n        }\n    }\n    else {\n        if (depth == 0) {           \n            //std::cout << \"NoPath-\" << std::endl;\n            return 0;\n        }\n    }\n}\n\n\nif (isMaximiser) {// Max\n    int v = -INT_MAX;\n    for (const AIMove &move : possibleMoves) {\n        graph.SetNodeOwner(move.x, move.y, (NodeOwner)aiPlayer);\n        graph.FindNode(move.x, move.y, lastTestedNode);\n        v = std::max(alpha, MiniMaxAlphaBeta(graph, depth - 1, alpha, beta, false));\n        alpha = std::max(alpha, v);\n        graph.SetNodeOwner(move.x, move.y, NodeOwner::None);\n        if (beta <= alpha)\n            break;\n    }\n    return v;\n}\nelse if (!isMaximiser){ // Min\n    //std::cout << \"Human possiblMoves size  = \" << possibleMoves.size() << std::endl;\n    int v = INT_MAX;\n    for (const AIMove &move : possibleMoves) {\n        graph.SetNodeOwner(move.x, move.y, (NodeOwner)humanPlayer);\n        v = std::min(beta, MiniMaxAlphaBeta(graph, depth - 1, alpha, beta, true));\n        beta = std::min(beta, v);\n        graph.SetNodeOwner(move.x, move.y, NodeOwner::None);\n        if (beta <= alpha)\n            break;\n    }\n    return v;\n}\n```\n\n\n}\n    ", "Answer": "\r\nYour minimax recursive call and moves generations are logically correct except that you shouldn't use it to conclude the winner directly inside. Your leaf nodes evaluation should to be strong , that's the key, which seems lacking in your code. Also a verbose leaf node function will make the AI decision making too slow.\n\nHere's a pseudo code for your recursive MiniMax function.Say parent_graph is the state before evaluation for the best move and leaf_graph is the current leave node status. You have to find the relative ( don't mix with the absolute ) best branch among the minimax tree.\n\n```\nif (depth == 0) {           \n        return EvaluateLeafNode(isMaximizing,parent_graph,leaf_graph);\n    }\n```\n\n\nEvaluateLeafNode function can read like this:\n\n```\nint EvaluateLeafNode(bool isMaximizing,Graph& parent_graph,Graph& leaf_graph)\n{\n   int score = 0;\n   int w = find_relative_white_deads(parent_graph,leaf_graph);\n   int b = find_relative_black_deads(parent_graph,leaf_graph);\n\n   if(isMaximizing)\n      score += b;\n   else\n      score += w;\n   return score;\n}\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "What algorithm to use to determine minimum number of actions required to get the system to \"Zero\" state?\r\n                \r\nThis is kind of more generic question, isn't language-specific. More about idea and algorithm to use.\nThe system is as follows:\nIt registers small loans between groups of friends. ```\nAlice```\n and ```\nBill```\n are going to lunch, Bill's card isn't working, so Alice pays for his meal, $10.\nThe next day ```\nBill```\n and ```\nCharles```\n meet each other on a railway station, Charles has no money for ticket, so ```\nBill```\n buys him one, for $5.\nLater that day ```\nAlice```\n borrows $5 from ```\nCharles```\n and $1 from ```\nBill```\n to buy her friend a gift.\nNow, assuming they all registered that transactions in the system, it looks like this:\n```\nAlice -> Bill $10\nBill -> Alice $1\nBill -> Charles $5\nCharles -> Alice $5\n```\n\nSo, now, only thing that needs to be done is ```\nBill```\n giving ```\nAlice```\n $4 (he gave her $1 and ```\nCharles```\n transferred his $5 to ```\nAlice```\n already) and they're at the initial state.\nIf we scale that to many different people, having multiple transaction, what would be the best algorithm to get as little transactions as possible?\n    ", "Answer": "\r\nThis actually looks like a job that the double entry accounting concept could help with.\n\nYour transactions could be structured as bookkeeping entries thus:\n\n```\n                          Alice  Bill  Charles  Balance\nAlice   -> Bill    $10      10    10-       0        0\nBill    -> Alice    $1       9     9-       0        0\nBill    -> Charles  $5       9     4-       5-       0\nCharles -> Alice    $5       4     4-       0        0\n```\n\n\nAnd there you have it. At each transaction, you credit one ledger account and debit another so that the balance is always zero. At at the end, you simply work out the minimal number transactions to be applied to each account to return it to zero.\n\nFor this simple case, it's a simple $4 transfer from Bill to Alice. What you need to do is to reduce at least one account (but preferably two) to zero for every transaction added. Let's say you had the more complicated:\n\n```\n                          Alice  Bill  Charles  Balance\nAlice   -> Bill    $10      10    10-       0        0\nBill    -> Alice    $1       9     9-       0        0\nBill    -> Charles  $5       9     4-       5-       0\nCharles -> Alice    $5       4     4-       0        0\nCharles -> Bill     $1       4     5-       1        0\n```\n\n\nThen the transactions needed would be:\n\n```\nBill     -> Alice   $4       0     1-       1        0\nBill     -> Charles $1       0     0        0        0\n```\n\n\n\n\nUnfortunately, there are some states where this simple greedy strategy does not generate the best solution (kudos to ```\nj_random_hacker```\n for pointing this out). One example is:\n\n```\n                 Alan  Bill  Chas  Doug  Edie  Fred  Bal\nBill->Alan   $5    5-    5     0     0     0     0    0\nBill->Chas  $20    5-   25    20-    0     0     0    0\nDoug->Edie   $2    5-   25    20-    2     2-    0    0\nDoug->Fred   $1    5-   25    20-    3     2-    1-   0\n```\n\n\nClearly, this could be reversed in four moves (since four moves is all it took to get there) but, if you choose your first move unwisely ```\n(Edie->Bill $2)```\n, five is the minimum you'll get away with.\n\nYou can solve this particular problem with the following rules:\n\n\n(1) if you can wipe out two balances, do it.\n(2) otherwise if you can wipe out one balance and set yourself up to wipe out two in the next move, do it.\n(3) otherwise, wipe out any one balance.\n\n\nThat would result in the following sequence:\n\n\n(a) [1] not applicable, [2] can be achieved with ```\nAlan->Bill $5```\n.\n(b) [1] can be done with ```\nChas->Bill $20```\n.\n(c) and (d), similar reasoning with Doug, Edie and Fred, for four total moves.\n\n\nHowever, that works simply because of the small number of possibilities. As the number of people rises and the group inter-relations becomes more complex, you'll most likely need an exhaustive search to find the minimum number of moves required (basically the rules 1, 2 and 3 above but expanded to handle more depth).\n\nI think that is what will be required to give you the smallest number of transactions in all circumstances. However, it may be that that's not required for the best answer (best, in this case, meaning maximum \"bang per buck\"). It may be that even the basic 1/2/3 rule set will give you a good-enough answer for your purposes.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "how should the tree be expanded if we want to maximize the beneﬁt of αβ-pruning?\r\n                \r\nHey guys does anyone know how to solve this problem, it confuses me on how to get the answer, is there videos or anything that teaches you how to expand a tree. \n\nSuppose you are playing a turn-taking, zero-sum game, where the opponent is a rational agent and you would like to use two-step look ahead to decide your move. You know that the complete min-max tree of the two-step look ahead strategy for this game will be a complete binary tree as shown in Figure 1 Suppose you are given access to a heuristic function that will give you a good estimate on the value of the leaf nodes of the complete tree (these estimated values are also written in Figure 1).\n\n\n\nRelying on the given heuristic, how should the tree be expanded if we want to maximize the beneﬁt of αβ-pruning? Please write the answer as a sequence of edges to be visited.\n\nAnswer given to me was: e1-e4-e10-e9-e3-e8-e2-e6-e13-e14\n    ", "Answer": "\r\nAlpha-beta pruning will eliminate the most branches from evaluation if the best child node (from the perspective of the first-person player at that level) is evaluated first, so e1 before e2 at depth 1 because e1 has the higher score, e4 before e3 because we are minimizing at that level, e10 before e9 (higher score), and so on.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "JavaScript how to ensure sum of two numbers is not negative\r\n                \r\nI am creating a math game for kids using JavaScript and created a function that will generate two numbers, first number is positive and second is negative so that students will have to sum the given two number, but i want to generate numbers that the sum will not be a negative number.\nmy current functions\n```\nfunction randomIntFromInterval(min, max) { // min and max included \n    return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\nfunction generateRandomSubtractNumber() {\n    var base_number = randomIntFromInterval(2, 10)\n    var sub_number = -randomIntFromInterval(1, 5);\n    console.log(base_number, sub_number)\n    return  {\n        \"base_number\" : base_number,\n        \"sub_number\" : sub_number,\n        \"total\" : base_number +  sub_number \n    }\n}\n```\n\nI tried to put an if statement to check if the object.total will be less than zero but not sure how to re-generate again if the statement is true.\n    ", "Answer": "\r\nI think you can pass base_number as param to randomIntFromInterval.\n```\n var base_number = randomIntFromInterval(2, 10)\n var sub_number = -randomIntFromInterval(1, base_number);\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Counting the number of wins for teams in a nested list\r\n                \r\nI have written some code that I'm trying to use in order to calculate how many times a football team have won a match. The matches are placed into a nested list where each sub list contains the names of two teams and their scores for the game respectively. \n\n```\nL = [['Patriots', 'Giants', '3', '1'], ['Steelers', 'Patriots', '1', 2'], ['Giants', 'Steelers', '3', '5']]\n```\n\n\nHowever the list is much larger and contains more football teams who played in matches. \n\nI already have a final List which contains the name of each team and also the number of games they have played, which I calculated successfully. \n\n```\nfinalList = [['Patriots', 7], ['Giants', 3], ['Steelers', 8]]\n```\n\n\nI want the output to be like this:\n\n```\nfinalList = [['Patriots', 7, 2], ['Giants', 3, 0], ['Steelers', 8, 1]]\n```\n\n\nbecause the Patriots played 7 games and won two games, Giants played 3 games and won zero games and Steelers played 8 games and won one game.\n\nThis is my code so far, which doesn't give me the correct results for some of the matches. It also does not sum the counts so it just appends a number of 1's and 0's like this:\n\n```\n[['Giants', 5, 1, 0, 1]]\n```\n\n\nMy code:\n\n```\nfor i in L:\n    countLeft = 0\n    countRight = 0\n    if i[2]>i[3]:\n        countLeft += 1\n    elif i[3]>i[2]:\n        countRight += 1\n        for k in finalList:\n            if i[0]==k[0]:\n                k.append(countLeft)\n            elif i[1]==k[0]:\n                k.append(countRight)\nprint(finalList)\n```\n\n\nI am also not allowed to use any dictionaries in my code!!\n    ", "Answer": "\r\nTry the following:\n\n```\nfor k in finalList:\n    k.append(0)\n\nfor i in L:\n    if int(i[2]) > int(i[3]):\n            for k in finalList:\n                    if k[0] == i[0]:\n                            k[2]+=1\n    elif int(i[3]) > int(i[2]):\n            for k in finalList:\n                    if k[0] == i[1]:\n                            k[2]+=1\n```\n\n\n\n\n```\n>>> finalList\n[['Patriots', 7, 2], ['Giants', 3, 0], ['Steelers', 8, 1]]\n>>> \n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "What is a formula to sum a row based on criteria in a different sheet?\r\n                \r\nI am creating a sheet in Google Sheets for items in a video game called EVE Online, for what that matters. Each item in ```\nSheet1```\n can be \"reprocessed\" into basic minerals. Each item in ```\nSheet2```\n lists the basic minerals.\nIn ```\nSheet1!A1```\n, I have \"Item Name.\"\n```\nSheet1!A2:A251```\n is items.\n```\nSheet1!B1```\n is \"Reprocessed.\"\n```\nSheet2!A1```\n is \"Item Name.\"\n```\nSheet2!A2:A251```\n is the same items from ```\nSheet1```\n, copied and pasted over.\n```\nSheet2!B1:AG1```\n is mineral names.\n```\nSheet2!B2:AG251```\n is numbers of specific minerals the items can be reprocessed into.\nIn ```\nSheet1!B2```\n, I want to put a formula that will look at the item name in ```\nSheet1!A2```\n, find the corresponding item in ```\nSheet2```\n, and sum that row.\nI have tried:\n```\n=SUMIF(Sheet2!$A:$A,$A2,Sheet2!$B:$AG)```\n\nThis yields a sum of zero, where the sum of the numbers I have for ```\nSheet2!A2```\n (the numbers in ```\nSheet2!B2:AG2```\n) should be 23,587.\n    ", "Answer": "\r\nSince I don't know what your data looks like I have prepared a sample data based on what you shared in the question.\nIf your ```\nSheet2```\n looks like this:\n\nthen use the formula ```\n=SUM(INDIRECT(\"Sheet2!\"&MATCH(A2, Sheet2!A:A, 1)&\":\"&MATCH(A2, Sheet2!A:A, 1)))```\n in ```\nSheet1!B2```\n and it should work as shown below\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "jQuery counter stop at zero and if zero show replace HTML\r\n                \r\nI checked in stackoverflow for a solution to this but after trying a few full pages of results, I figured I'd just ask ;)\n\nSum-up:\nI have a mini-game where I am offering hints when an item on a list is clicked. There will be a bunch of items on the list but they can only use 3 hints. The text will change from \"you have 3 hints\" to \"2 hints\" then \"0 hints\" When they use all the hints and get to zero nothing else should be counted and the directions under the hint text should change.\n\nWhat I have working:\nI have a counter that counts down from 3 when an item on the list is clicked and the \"You Have X Hints\" updates.\n\nWhat I need help with:\nThe counter doesn't stop at zero, it just keeps going down into negative numbers if oyu keep clicking the list items. How do I stop it a zero and disable the counter?\n\nThe directions paragraph should only change when they reach zero but it shows after first click. How do I only make it show at zero?\n\nThanks for your help!\nHere is my fiddle: http://jsfiddle.net/gudinne/ophyfd8t/2/\n\nCode below:\n\nJS\n\n```\nvar counter = 3;\n\n$('.itemList li').on('click', function () {\n  counter--;\n\n  if (counter == 0) {\n      $('.xHints').html(counter + ' Hints');\n  } else {\n      $('.xHints').html(counter + ' Hints');\n      $('.directions').html('New directions');\n  }\n})\n```\n\n\nHTML\n\n```\n<div class=\"itemWrapper\">\n   <ul class=\"itemList\">\n       <li>cat</li>\n       <li>mouse</li>\n       <li>cheese</li>\n  </ul>\n  <div id=\"hintBox\"> <span class=\"youHave\">You Have</span>\n<span class=\"xHints\">3 Hints</span>\n\n    <p class=\"directions\">Use a hint by clicking on a name in the list.</p>\n  </div>\n```\n\n\n\n    ", "Answer": "\r\nYou need to check if the counter has reached zero already before you decrement it.\nYou can also simplify your code a bit:\n\n```\nif(counter > 0) {\n    counter--;\n\n    if(counter == 0)\n        $('.directions').html('New directions');\n\n    $('.xHints').html(counter + ' Hints');\n}\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Monte Carlo Tree Search, Backpropagation (Backup) step: Why change perspective of reward value?\r\n                \r\nI've been reading through the Monte Carlo Tree Search survey paper by Browne et. al:\n\nhttp://ccg.doc.gold.ac.uk/papers/browne_tciaig12_1.pdf\n\n\"A Survey of Monte Carlo Tree Search Methods\"\n\nI'm wrestling with just one piece of the pseudocode on p. 9. My question occurs in a similar form in both the Backup and BackupNegamax functions.\n\nSuppose that I'm player 1 in a 2-player zero-sum game. (So, using the BackupNegamax function.) It's my turn to move, and I'm using MCTS to choose my move. In BackupNegamax, why is the delta value negated as you back up the tree? I understand that in a two-player zero-sum game, if the reward is delta for player 1 (me), then it's -delta for player 2. But shouldn't the entire tree be from player 1's perspective? (This would then be similar to how nodes are rated in a minimax tree, if I'm not mistaken.)\n\nIf the perspective of the Q value switches back and forth depending on what level of the tree you're on, wouldn't that mess up the calculation shown in the BestChild function? Specifically, suppose some node v has a very high Q value, because it has often led to high rewards for player 1. The given pseudocode seems to suggest that v's parent, which I'll call u, would likely have a very low (very negative) Q value (of course u's Q value would also account for its other children's Q values.)\n\nSo it doesn't make sense to me that u (the parent) would have a very low Q value while v (the child) has a very high one. I know v is from player 1's perspective in the pseudocode, and u is from player 2's perspective, but my question is why. Why aren't both node's Q values stored from player 1's perspective? That way both u and v would have high Q values, and thus high exploitation ratings, and they'd both be considered valuable for further exploitation according to the BestChild function.\n\n(I'm coming at MCTS from experience with minimax, and in minimax the entire tree is from Max's perspective, so that's why I'm struggling with the different idea here.)\n\nMy question also applies to Backup - why is each Q value updated according to the perspective of the player at that level of the tree, instead of everything being updated from \"my\" perspective?\n\nI hope I've been clear in my question. Thank you very much for your help!\n    ", "Answer": "\r\nThere are two ways to describe this mechanism:\n\n\nGlobally: From the perspective of the root player, in which case the playout values at every second ply are negated, as the opponent is acting against the root player.\nLocally: From the perspective of the player who has just moved at each ply, in which case the playout value is not negated, as each player tries to maximise their own reward.\n\n\nThe standard formulation uses option 1, as it's easier to describe, and has its basis in two-player combinatorial games. However, I tend to use the second formulation in my actual implementations, as it is more flexible; it handles games with more than two players, less than two players, variable move order, multi-part moves, cooperative goals, etc.\n\nThis just confirms what is said in the other answers.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Monte Carlo Tree Search in board games - How to Implement Opponent Moves\r\n                \r\nI am working on an implementation of the MCTS algorithm, in the context of zero-sum board games with perfect information. E.g. Chess, Go, Checkers.\n\nAs I understand, in each iteration of the algorithm, there are four steps: selection, expansion, simulation, and backpropagation.\n\nMy question is about the implementation of the opponent moves, how it should be presented in the tree, and how it should be implemented at each stage. \n\nFor example, let's imagine a game of GO, where we(black) are playing against an AI(white). When black make an action ab from the root node s0, it is then turn for white to make an action aw.\n\nMy initial thought was that each action will produce a new state. So s0 -> ab -> s1 -> aw -> s2, where each s state would represent a node. However, this would effect the selection process in MCTS. In this case, wouldn't MCTS have a tendency to explore bad aw moves? Since this will return better rewards for black.\n\nThe alternative solution I though was to combin the actions into a single node. So s0 -> ab -> aw -> s1. However, this would make the decision making more difficult, since each root level action is now associated with multiple different node.\n\nIs there any framework which suggests how opponents should be represented in MCTS? Any help would be appreciated.\n\nEdit 1:\nSince we will be playing black in the sample above, the reward function at the end of each simulation will be with respect to black. E.g. if black wins at the end of the game, the reward will be back up through all nodes, both black and white nodes. My expectation was that white node (which allowed black to win) which have high state value.\n\nBut maybe I should flip the reward when doing backpropagation? E.g. if black wins, its 1 for black node and -1 for the white node. This way, the selection function stays the same. Would this be correct?\n    ", "Answer": "\r\nYou should run either against a known strong opponent or against the algorithm itself.\n\nAssuming you run against your own algorithm, feed the data into it to figure out the \"best\" move. Make sure the algorithm works for the intended side(i.e. if you play go/chess, the easiest thing is to swap the colors of the game pieces).\n\nIf you play against yourself you basically generate twice as many data points for learning the game.\n\nIf you are just starting out it might be worth playing against some other machine player. You don't get so much data points but the ones you get teach you more (i.e. a bad move will be learned faster).\n\nYou probably want to start by playing against some reasonable, existing AI then switch to play against itself.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Sum count by grouping according to another column in C\r\n                \r\nI have a text file of the following form. Left column is names of players and right column is their score in games they played.\n```\njohn 40\nmary 50\njohn 30\nkevin 88\nkevin 29\njoe 102\ndavid 11\nmary 134\n```\n\nI want to sum up the scores of the players. So, I want to print output of the form\n```\njohn 70\nmary 184\nkevin 117\njoe 102\ndavid 11\n```\n\nI know that this can be easily done in ```\nR```\n or ```\nPython```\n. But I want to do this using ```\nC```\n. So, I try to declare an array of structures in C and try to read each line from the file. struct is defined as a global variable, so by default, the struct members are initialized to zero values or null character in case of char array. Then, I try to read each row into the struct, which itself is an element of the array. But, while implementing this, I got stuck where new rows are to be read and then stored into structs. Is there any efficient way to do this ? Since ```\nR```\n or '```\npandas```\n are based on ```\nC```\n, their underlying code is probably written in ```\nC```\n. How is it done there ?\nThanks\n    ", "Answer": "\r\nTypically you'd read a line, split it up on whitespace, see if an entry with that name already exists in a hash table or tree or other map data structure, and if so, add the current value to it, and if not, insert it using the current value. Then at the end traverse the map printing out the entries. Basically, the same approach you'd take with any language.\nHowever, those other languages often have things like map data structures, high level abstractions for reading files and parsing text, etc., so a task like this can be done in a few lines (Shoot, ```\nawk```\n can do it in one). With C, you have to write most of that stuff yourself, or use add-on libraries - the C standard, for example, has no hash table or trees. You basically have to do everything manually that languages like Python are doing for you under the hood.\nHere's an example that uses the POSIX binary search tree functions (An awkward but portable API):\n```\n#define _GNU_SOURCE\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <search.h>\n\nstruct record {\n  int num;\n  char name[];\n};\n\nstruct record *make_record(const char *name, int num) {\n  size_t len = strlen(name);\n  struct record *r = malloc(sizeof *r + len + 1);\n  r->num = num;\n  memcpy(r->name, name, len);\n  r->name[len] = 0;\n  return r;\n}\n\nint reccmp(const void *va, const void *vb) {\n  const struct record *a = va, *b = vb;\n  return strcmp(a->name, b->name);\n}\n\nvoid print_rec(const void *nodep, VISIT which, int depth) {\n  (void)depth;\n  // Print records in sorted order.\n  if (which == postorder || which == leaf) {\n    const struct record *r = *(const struct record **)nodep;\n    printf(\"%s\\t%d\\n\", r->name, r->num);\n  }\n}\n\nint main(int argc, char **argv) {\n  if (argc != 2) {\n    fprintf(stderr, \"Usage: %s filename\\n\", argc > 0 ? argv[0] : \"program\");\n    return EXIT_FAILURE;\n  }\n\n  FILE *fp = fopen(argv[1], \"r\");\n  if (!fp) {\n    fprintf(stderr, \"%s: Unable to open %s: %s\\n\", argv[0], argv[1],\n            strerror(errno));\n    return EXIT_FAILURE;\n  }\n\n  void *counts = NULL; // Opaque pointer to the root of the tree\n\n  int lineno = 0;\n  char *line = NULL;\n  size_t line_len = 0;\n  while (getline(&line, &line_len, fp) > 0) {\n    lineno += 1;\n\n    char *saveptr = NULL;\n    char *name = strtok_r(line, \" \", &saveptr);\n    char *numstr = strtok_r(NULL, \" \", &saveptr);\n    if (!name || !*name || !numstr || !*numstr) {\n      fprintf(stderr, \"Line %d of input is malformed!\\n\", lineno);\n      continue;\n    }\n    int num = atoi(numstr);\n\n    struct record *new_rec = make_record(name, num);\n    // tsearch() either inserts a new node and returns a pointer to it,\n    // or returns a pointer to an existing matching node.\n    struct record *found_rec =\n        *(struct record **)tsearch(new_rec, &counts, reccmp);\n    if (new_rec != found_rec) {\n      // If it's the latter, update its number sum and free the struct used\n      // to look it up.\n      found_rec->num += num;\n      free(new_rec);\n    }\n  }\n  free(line);\n  fclose(fp);\n\n  twalk(counts, print_rec);\n\n#ifdef __GLIBC__\n  // Prevent spurious warnings from tools like ASan and valgrind about\n  // memory leaks.\n  tdestroy(counts, free);\n#endif\n\n  return 0;\n}\n```\n\nExample usage:\n```\n$ gcc -g -O -Wall -Wextra group.c\n$ ./a.out input.txt\ndavid   11\njoe 102\njohn    70\nkevin   117\nmary    184\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Sum a List, but only for values after a certain point\r\n                \r\nI'm writing a web page to keep the score for a card game. Getting the players score so far would be easy, but there is a twist. During any round the players score can be reset to zero at the start of the round. I don't want to change the score for any previous rounds, so I only want to get a sum of the rounds after (and including) the reset. A player could potentially have their score reset multiple times in a game, or not at all.\nI can get the correct score by a multiple stage process of finding the last (if any) score reset, and summing all hands after that (or all hands in no resets) - see PlayerGame.GetPlayerScore.\nI'm still trying to get my head around the more intricate ways of doing things with LINQ, and I was wondering if there was a way to do this using a single LINQ statement?\nMinimal code:\n```\nclass Program\n{\n    static void Main(string[] args)\n    {\n        PlayerGame playerGame = new PlayerGame();\n\n        playerGame.PlayerHands = new List<PlayerHand>\n        {\n            new PlayerHand { Round = 1, Score = 10 },\n            new PlayerHand { Round = 2, Score = 20 },\n            new PlayerHand { Round = 3, Score = 30 },\n            new PlayerHand { Round = 4, Score = 40, Reset = true },\n            new PlayerHand { Round = 5, Score = 50 },\n            new PlayerHand { Round = 6, Score = 60 }\n        };\n\n        Console.WriteLine($\"Players score was {playerGame.GetPlayerScore()}\");\n        Console.ReadLine();\n    }\n}\n\nclass PlayerHand\n{\n    public int Round { get; set; }\n    public int Score { get; set; }\n    public bool Reset { get; set; } = false;\n}\n\nclass PlayerGame\n{\n    public List<PlayerHand> PlayerHands { get; set; }\n\n    public PlayerGame()\n    {\n        PlayerHands = new List<PlayerHand> { };\n    }\n\n    public int GetPlayerScore()\n    {\n        // Can all this be simplified to a single LINQ statement?\n        var ResetIndex = PlayerHands.OrderBy(t => t.Round).LastOrDefault(t => t.Reset == true);\n\n        if (ResetIndex != null)\n        {\n            return PlayerHands.Where(t => t.Round >= ResetIndex.Round).Sum(t => t.Score);\n        }\n        else\n        {\n            return PlayerHands.Sum(t => t.Score);\n        }\n    }\n}\n```\n\nhttps://dotnetfiddle.net/s5rSqJ\nAs presented, the players score should be 150. I.e. the score gets reset at the start of Round 4, so the total score is the sum of Rounds 4, 5, and 6.\n    ", "Answer": "\r\nSummarizing a few points,\n\nthe number of rounds is finite (otherwise a really long game!). This observation is important when we talk about reversing below.\nrounds are already sorted in ascending order (per the comments), so actual round number doesn't matter\nif we sum backwards, we don't have to scan the whole list\n\nSo, we can come up with an implementation that is O(1) space (in-place, no allocations) and O(n) time (linear, less than the size of the list when there's a reset).\nUsing MoreLinq\n```\nvar score = hands.ReverseInPlace().TakeUntil(x => x.Reset).Sum(x => x.Score);\n```\n\nWhere ```\nReverseInPlace()```\n iterates in reverse order in place, and MoreEnumerable.TakeUntil() takes up to and including the round that has a true value for ```\nReset```\n or end of sequence.\n```\nReverseInPlace```\n would be an extension method (you could generalize to ```\nIEnumerable<>```\n if you wanted).\n```\npublic static class ListExtensions\n{\n    public static IEnumerable<T> ReverseInPlace<T>(this IList<T> source)\n    {\n        // add guard checks here, then do...\n        for (int i=source.Length-1; i != -1; --i)\n            yield return source[i];\n    }\n}\n```\n\nNot using MoreLinq\nYou could create a ```\nTakeInReverseUntil```\n:\n```\npublic static IEnumerable<T> TakeInReverseUntil<T>(this IList<T> source, Func<T, bool> predicate)\n{\n    // add guard checks here, then do...\n    for (int i=source.Length-1; i != -1; --i)\n    {\n        yield return source[i];\n        if (predicate(source[i]) yield break;\n    }\n}\n```\n\ngiving you the simplified call\n```\nvar score = hands.TakeInReverseUntil(x => x.Reset).Sum(x => x.Score);\n```\n\nNOTE: Enumerable.Reverse() allocates a buffer, so is O(n) space, and is why I rolled my own ```\nReverseInPlace```\n instead for this answer.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Pandas: Group by, Cumsum + Shift with a \"where clause\"\r\n                \r\nI am attempting to learn some Pandas that I otherwise would be doing in SQL window functions.\n\nAssume I have the following dataframe which shows different players previous matches played and how many kills they got in each match.\n\n```\n date          player        kills \n 2019-01-01      a             15\n 2019-01-02      b             20\n 2019-01-03      a             10\n 2019-03-04      a             20\n```\n\n\nThroughout the below code I managed to create a groupby where I only show previous summed values of kills (the sum of the players kills excluding the kills he got in the game of the current row).\n\n```\ndf['sum_kills'] =    df.groupby('player')['kills'].transform(lambda x: x.cumsum().shift())\n```\n\n\nThis creates the following values:\n\n```\n date          player        kills    sum_kills\n 2019-01-01      a             15      NaN\n 2019-01-02      b             20      NaN\n 2019-01-03      a             10      15\n 2019-03-04      a             20      25\n```\n\n\nHowever what I ideally want is the option to include a filter/where clause in the grouped values. So let's say I only wanted to get the summed values from the previous 30 days (1 month). Then my new dataframe should instead look like this:\n\n```\n date          player        kills    sum_kills\n 2019-01-01      a             15      NaN\n 2019-01-02      b             20      NaN\n 2019-01-03      a             10      15\n 2019-03-04      a             20      NaN\n```\n\n\nThe last row would provide zero summed_kills because no games from player a had been played over the last month. Is this possible somehow?\n    ", "Answer": "\r\nI think you are a bit in a pinch using ```\ngroupby```\n and ```\ntransform```\n. As explained here, ```\ntransform```\n operates on a single series, so you can't access data of other columns.\n```\ngroupby```\n and ```\napply```\n does not seem the correct way too, because the custom function is expected to return an aggregated result for the group passed by ```\ngroupby```\n, but you want a different result for each row.\n\nSo the best solution I can propose is to use ```\napply```\n without ```\ngroupy```\n, and perform all the selection by yourself inside the custom function:\n\n```\ndef killcount(x, data, timewin):\n    \"\"\"count the player's kills in a time window before the time of current row.\n    x: dataframe row\n    data: full dataframe\n    timewin: a pandas.Timedelta\n    \"\"\"\n    return data.loc[(data['date'] < x['date']) #select dates preceding current row\n            & (data['date'] >= x['date']-timewin) #select dates in the timewin                \n            & (data['player'] == x['player'])]['kills'].sum() #select rows with same player\n\ndf['sum_kills'] = df.apply(lambda r : killcount(r, df, pd.Timedelta(30, 'D')), axis=1)\n```\n\n\nThis returns:\n\n```\n        date player  kills  sum_kills\n0 2019-01-01      a     15          0\n1 2019-01-02      b     20          0\n2 2019-01-03      a     10         15\n3 2019-03-04      a     20          0\n```\n\n\nIn case you haven't done yet, remember do parse ```\n'date'```\n column to datetime type using pandas.to_datetime otherwise you cannot perform date comparison.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "What is the optimal solution for this problem?\r\n                \r\nThere are two players in a game. There are N rods and the players take their turn alternatively with player A going first.\nin each turn-\nplayer remove one rod from the sack (of length x)  and adds this length to his sum (initially there sum is zero) ,also if the length of rod is not one then the player cuts the rod into half and puts it back inside the sack\nGame ends when a player is not able to take his turn i.e. no rods are left in the sack. Both players want to maximize their sum.\nWhat is the maximum sum Player A (who is going first) gets if both players play optimally.\nconsider when the player cuts the rod into half, and if the length of rod is odd then player will cuts it into smallest positive integer that is less than length. For example - if length of rod is 7 the player will cut it into length of 3. and put the rod of length 3 inside sack\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Why must coq mutually inductive types have the same parameters?\r\n                \r\nFollowing Arthur's suggestion, I changed my ```\nFixpoint```\n relation to a mutual ```\nInductive```\n relation which \"builds up\" the different comparisons between games rather than \"drilling down\".\n\nBut now I am receiving an entirely new error message:\n\n```\nError: Parameters should be syntactically the same for each inductive type.\n```\n\n\nI think the error message is saying that I need the same exact parameters for all of these mutual inductive definitions. \n\nI realize there are simple hacks to get around this (unused dummy variables, long functional types with everything inside the ```\nforall```\n), but I don't see why I should have to. \n\nCan somebody explain the logic behind this restriction on mutual inductive types ? Is there a more elegant way to write this ? Does this restriction also imply that the inductive calls to each other must all use the same parameters (in which case I don't know of any hacks save hideous amounts of code duplication) ?\n\n(The definitions of all the types and terms such as compare_quest, game, g1side etc. are unchanged from what they were in my first question.\n\n```\nInductive gameCompare (c : compare_quest) : game -> game -> Prop :=\n | igc : forall g1 g2 : game,\n    innerGCompare (nextCompare c) (compareCombiner c) (g1side c) (g2side c) g1 g2 ->\n    gameCompare c g1 g2\nwith innerGCompare (next_c : compare_quest) (cbn : combiner) (g1s g2s : side)\n    : game -> game -> Prop :=\n | compBoth : forall g1 g2 : game,\n    cbn (listGameCompare next_c cbn (g1s g1) g2)\n        (gameListCompare next_c cbn g1 (g2s g2)) ->\n    innerGCompare next_c cbn g1s g2s g1 g2\nwith listGameCompare (c : compare_quest) (cbn : combiner) : gamelist -> game -> Prop :=\n | emptylgCompare : cbn_init cbn -> forall g2 : game, listGameCompare c cbn emptylist g2\n | otlgCompare : forall (g1_cdr : gamelist) (g1_car g2 : game),\n    (cbn (listGameCompare c cbn g1_cdr g2) (gameCompare c g1_car g2)) ->\n    listGameCompare c cbn (listCons g1_car g1_cdr) g2\nwith gameListCompare (c : compare_quest) (cbn : combiner) : game -> gamelist -> Prop :=\n | emptyglCompare : cbn_init cbn -> forall g1 : game, gameListCompare c cbn g1 emptylist\n | otglCompare : forall (g1 g2_car : game) (g2_cdr : gamelist),\n    (cbn (gameListCompare c cbn g1 g2_cdr) (gameCompare c g1 g2_car)) ->\n    gameListCompare c cbn g1 (listCons g2_car g2_cdr).\n```\n\n\nIn CGT, generally two players (named ```\nLeft```\n and ```\nRight```\n) take turns playing a game where the player to make the last move wins.  Each game (meaning each position in a game) can be read as a set of ```\nLeft```\n's options and a set of ```\nRight```\n's options written as ```\n{G_L | G_R}```\n. When comparing two games, they can compare in any of four different ways: ```\n<```\n, ```\n>```\n, ```\n=```\n, or ```\n||```\n.  \n\nA game is ```\nA < B```\n if ```\nB```\n is strictly better than ```\nA```\n for ```\nLeft```\n, regardless of who goes first. ```\nA > B```\n if ```\nA```\n is better than ```\nB```\n for ```\nLeft```\n. ```\nA = B```\n if the two games are equivalent (in the sense that the sum of games ```\nA + -B```\n is a zero-game so that the player who goes first loses). And, ```\nA || B```\n if which game is better for ```\nLeft```\n depends who goes first.\n\nOne way to check the comparison between two games is as follows:\n\n\n```\nA <= B```\n if all of ```\nA```\n's ```\nLeft```\n children are ```\n<| B```\n and ```\nA <|```\n all of ```\nB```\n's right children. \n```\nA <| B```\n if ```\nA```\n has a right child which is ```\n<= B```\n or if ```\nA <=```\n any of ```\nB```\n's left children. \nAnd, similarly for ```\n>=```\n and ```\n>|```\n.  \n\n\nSo, then by seeing which pair of these relations apply to two games ```\nA```\n and ```\nB```\n, it's possible to determine whether ```\nA < B```\n (```\nA<=B```\n and ```\nA<|B```\n), ```\nA=B```\n (```\nA<=B```\n and ```\nA>=B```\n), ```\nA > B```\n (```\nA>=B```\n and ```\nA>|B```\n), or ```\nA || B```\n (```\nA<|B```\n and ```\nA>|B```\n).\n\nHere's the wiki article on CGT.\n    ", "Answer": "\r\nThis restriction is very interesting, and I had never encountered it before. I don't see any reasons for why this piece of code should be rejected. My best bet is that when people were designing the foundations of Coq this restriction made some of the proofs easier, and since not many people were annoyed by it, it just remained that way. I could be completely wrong, though; I do know that parameters and arguments (i.e., the ones that go to the right of the arrow) are treated slightly differently for some things. For instance, the universe constraints imposed when defining inductive types are less restrictive with parameters when compared to arguments.\n\nPerhaps this should be forwarded to the Coq Club mailing list? :)\n\nYou don't have to put everything to the right of the arrow to get this to work. One thing you can do is to put everything but the ```\ncompare_quest```\n parameter to the right. When you use an inductive of the same type you're defining in a constructor, the parameter you give doesn't have to be the same as the one you give on the header, so that's OK:\n\n```\nInductive gameCompare (c : compare_quest) : game -> game -> Prop :=\n | igc : forall g1 g2 : game,\n    innerGCompare (nextCompare c) (compareCombiner c) (g1side c) (g2side c) g1 g2 ->\n    gameCompare c g1 g2\n\nwith innerGCompare (c : compare_quest) : combiner -> side -> side ->\n    game -> game -> Prop :=\n | compBoth : forall cbn g1s g2s (g1 g2 : game),\n    cbn (listGameCompare c cbn (g1s g1) g2)\n        (gameListCompare c cbn g1 (g2s g2)) ->\n    innerGCompare c cbn g1s g2s g1 g2\n\nwith listGameCompare (c : compare_quest) : combiner -> gamelist -> game -> Prop :=\n | emptylgCompare : forall cbn, cbn_init cbn -> forall g2 : game, listGameCompare c cbn emptylist g2\n | otlgCompare : forall cbn (g1_cdr : gamelist) (g1_car g2 : game),\n    (cbn (listGameCompare c cbn g1_cdr g2) (gameCompare c g1_car g2)) ->\n    listGameCompare c cbn (listCons g1_car g1_cdr) g2\n\nwith gameListCompare (c : compare_quest) : combiner -> game -> gamelist -> Prop :=\n | emptyglCompare : forall cbn, cbn_init cbn -> forall g1 : game, gameListCompare c cbn g1 emptylist\n | otglCompare : forall cbn (g1 g2_car : game) (g2_cdr : gamelist),\n    (cbn (gameListCompare c cbn g1 g2_cdr) (gameCompare c g1 g2_car)) ->\n    gameListCompare c cbn g1 (listCons g2_car g2_cdr).\n```\n\n\nUnfortunately, trying to evaluate this gives a new error :(\n\n```\nError: Non strictly positive occurrence of \"listGameCompare\" in\n \"forall (cbn : Prop -> Prop -> Prop) (g1s g2s : game -> gamelist)\n    (g1 g2 : game),\n  cbn (listGameCompare c cbn (g1s g1) g2) (gameListCompare c cbn g1 (g2s g2)) ->\n  innerGCompare c cbn g1s g2s g1 g2\".\n```\n\n\nThis error is much more common in Coq. It is complaining that you are passing the type you are defining as an argument to ```\ncbn```\n because that could result in that type being to the left of an arrow (a negative occurrence), which is known to lead to logical inconsistencies.\n\nI think you can get rid of this problem by inlining ```\ncompareCombiner```\n in the constructors of last three types, which may require some refactoring of your code. Again, I'm pretty sure that there must be a better way of defining this, but I don't understand what you're trying to do very well, so my help is somewhat limited there.\n\nUPDATE: I've started a series of articles about formalizing some of CGT in Coq. You can find the first one here.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to Check if Costs go Below Zero in Python\r\n                \r\nAs a culminating assignment in my class, we were tasked on writing a game that is meant to be played in the lines of amusement parks. Once completing the game, we need to give the player a chance to buy a certain amount of 6 different prizes, as long as they have the points to afford them.\nIn my program, I made it so that if someone orders a certain amount of one prize that goes over their point average, it tells you you don't have enough points to afford it, and you need to retype your answer.\nHowever, I made an error in that the player's balance (sum of all their points) goes below zero even when a number sent into the program is less then said balance. I think this has something to do with the costs of each prize, since one of them, wooden snakes, is worth 35 points, and the same can be said for the others, albeit with different numbers.\n```\nbalance = 100\n\n#How many glowsticks the player wants\n        prize1 = int(input(\"Tell me again how many glowsticks you want \"))\n        if prize1 <= balance:\n            prize1 = prize1 * 10\n            balance = balance - prize1\n            print(\"Your balance is now\",balance,\"points.\")\n        elif prize1 > balance:\n            print(\"Too many glowsticks, please change your amount\")\n            break\n        \n        #Confirm again if that's how many jumbo glasses the player wanted\n        prize2 = int(input(\"Tell me again how many jumbo glasses you want \"))\n        if prize2 <= balance:\n            prize2 = prize2 * 15\n            balance = balance - prize2\n            print(\"Your balance is now\",balance,\"points.\")\n        elif prize2 > balance:\n            print(\"Too many jumbo glasses, please change your amount.\")\n            break\n        \n        #How many inflatable hammers the player wants\n        prize1 = int(input(\"Tell me again how many inflatable hammers you want \"))\n        if prize1 <= balance:\n            prize1 = prize1 * 25\n            balance = balance - prize1\n            print(\"Your balance is now\",balance,\"points.\")\n        elif prize1 > balance:\n            print(\"Too many inflatable hammers, please change your amount\")\n            break\n        \n        #How many of dinosaur grabbers the player wants\n        prize2 = int(input(\"Tell me again how many dinosaur grabbers you want \"))\n        if prize2 <= balance:\n            prize2 = prize2 * 30\n            balance = balance - prize2\n            print(\"Your balance is now\",balance,\"points.\")\n        elif prize2 > balance:\n            print(\"Too many dinosaur grabbers, please change your amount.\")\n            break\n        \n        #How many wooden snakes the player wants\n        prize1 = int(input(\"Tell me again how many wooden snakes you want \"))\n        if prize1 <= balance:\n            prize1 = prize1 * 35\n            balance = balance - prize1\n            print(\"Your balance is now\",balance,\"points.\")\n        elif prize1 > balance:\n            print(\"Too many wooden snakes, please change your amount\")\n            break\n        \n        #How many foam swords the player wants\n        prize2 = int(input(\"Tell me again how many foam swords you want \"))\n        if prize2 <= balance:\n            prize2 = prize2 * 40\n            balance = balance - prize2\n            print(\"Your balance is now\",balance,\"points.\")\n        elif prize2 > balance:\n            print(\"Too many foam swords, please change your amount.\")\n            break\n```\n\nThis is the fraction of my code where the problem happens. I wanna have it so that the player, once winning, enters how many of each prize they want. If they can't afford the amount they want, as in it would result in your balance going below zero, or it being over your balance, the program would ask you change your amount to suit it.\nP.S. The reason the balance is 100 in this example is for demonstration purposes. It may not always equal that number, and could be higher or lower depending on how well the player did throughout the game.\n    ", "Answer": "\r\nThere is a key rule in programming called DRY: Don't Repeat Yourself.  Notice how this architecture solves the problem with much less code.  It makes it easy to add new items, and if you think of a better way to handle things, one fix works for everything:\n```\nbalance = 100\n\noptions = [\n    ('glowsticks', 10),\n    ('jumbo glasses', 15),\n    ('inflatable hammers', 25),\n    ('dinosaur grabbers', 30),\n    ('wooden snakes',35),\n    ('foam swords', 40)\n]\n\nfor name, cost in options:\n    while True:\n        count = int(input(f\"Tell me again how many {name} you want? \"))\n        if count * cost <= balance:\n            balance -= count * cost\n            print( \"Your balance is now\", balance, \"points.\")\n            break\n        else:\n            print(f\"Too many {name}, please change your amount\")\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Finding sum of all integer substring using dynamic programming\r\n                \r\nI was solving Sam and substrings problem from hackerrank. It is basically finding sum of all substrings of a string having all integers.\n\nSamantha and Sam are playing a numbers game. Given a number as a string, no leading zeros, determine the sum of all integer values of substrings of the string.\n\n\nGiven an integer as a string, sum all of its substrings cast as integers. As the number may become large, return the value modulo 10⁹ + 7.\n\n\nExample: ```\nn = '42'```\n\n\n\nHere n is a string that has three integer substrings: 4, 2, and 42. Their sum is 48, and 48 modulo 10⁹ + 7 = 48.\n\nFunction Description\n\nComplete the substrings function in the editor below.\nsubstrings has the following parameter(s):\nstring n: the string representation of an integer\nReturns\n\nint: the sum of the integer values of all substrings in n, modulo (10⁹ + 7)\nI tried following recursive top down dynamic problem solution with memoization:\n```\nfrom functools import cache\n\ndef substrings(n):\n    @cache\n    def substrSum(curIndex):\n        if curIndex == 0: return int(n[0])\n        return substrSum(curIndex-1)*10 + int(n[curIndex]) * (curIndex+1)\n        \n    totalSum = 0\n    for i in range(len(n)-1, -1,-1): \n        totalSum += substrSum(i) \n        \n    return totalSum % (10 ** 9 + 7) \n```\n\nI also tried recursive bottom up dynamic programming solution with memoization (this simply involves changing ```\nfor```\n loop counting direction):\n```\nfrom functools import cache\n\ndef substrings(n):\n    @cache\n    def substrSum(curIndex):\n        if curIndex == 0: return int(n[0])\n        return substrSum(curIndex-1)*10 + int(n[curIndex]) * (curIndex+1)\n        \n    totalSum = 0\n    for i in range(len(n)): \n        totalSum += substrSum(i) \n        \n    return totalSum % (10 ** 9 + 7) \n```\n\nFor top-down solution gives runtime error in 8 out of 13 test cases, whearas in bottom up solution gives gives runtime error in 6 out of 13 test cases. Where am I making mistake?\n    ", "Answer": "\r\nYour algorithm is correct (both versions), but HackerRank will test with strings that have many thousands of digits, and as you perform a recursive call for each digit, your first code runs into a maximum recursion depth exceeded error, and the second one runs into a memory error (think of the cache).\nIt should be noted that they phrased the constraint wrong. It is not the value of n \"cast to integer\" that is limited by 2 x 105, but the number of digits in n. I checked this, and one of their tests concerns a string of about 199000 digits.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Predicting remaining runtime for minimax algorithm with alpha-beta-pruning\r\n                \r\nProblem\nI am trying to solve a perfekt information zero-sum game (like tick-tack-toe or chess) using a negamax algorithm with alpha-beta-pruning. The goal is to proof wheter one player can force a win or draw. This means that there is no depth-limit but the algorithm always evaluates the gametree until there is a win/draw.\nI spent multiple weeks optimizing my code to my specific game and got it down to a runtime of several days I would say. But there lies the problem:\nBecause of the alpha-beta-pruning the runtime of the minimax-algorithm is highly unpredictable. I can't tell wheter it will be done in the next 5 minutes or run for 5 more weeks until I actually simulated it. I would love to be able to predict the remaining runtime and not be off by several orders of magnitude.\nWhat I tried so far\nI am recording the results of all sub- and subsub-branches up to 5*sub-branches and the time it took my machine to simulate them. Then I just assume that positions on the same level take the same time to evaluate and call it a day. These predictions are sometimes off by a factor of 10 or more.\nI also looked at recorded data to see wheter my assumtion holds. The time needed to evaluate a 5*sub-branch varied between ```\n0.01s```\n to as much as ```\n180s```\n. Thats why my predictions where off. Who would have gessed.\nMy Question\nAs I imagine this would apply to all implementations of minimax:\n\nAre there more sophisticated algorithm out there to accuratly predict the remaining runtime of a minimax-algorithm with alpha-beta-pruning? Or is minimax just unpredictable by design?\n\nIf so how do they work?\n\n\n    ", "Answer": "\r\nI have spent a lot of time with Negamax algorithms which I highly suggest that you switch over to. It will give the same results as Minimax, but is much easier to debug and optimize further since it is just half the code.\nI have no clue about the game you are trying to solve, but if it is even the slightliest complicated I assume it won't be possible without a super computer. To answer your questions though:\n\nMinimax with alpha-beta pruning relies highly on the order of which you try your moves (to use board game terms). You want to try the best moves first, this is done in chess by ordering the possible moves function with e.g. capture moves higher up than castling.\nYou can also optimize the algorithm much much more with different techniques depending on what you are trying to solve. For example transposition tables if the same position can occur in another branch.\n\nWe need to know more about the game you are trying to solve to know what algorithm can work best.\n\n\nFinal words: If you want to get an idea of how long it will take to solve and how far you have gotten after some time, I suggest you use iterative deepending. This will also speed up your search, since you can try the best guesses from the previous iterations first and hence get faster beta cut offs in the next iteration:\n```\nfor depth in range(1, inf):\n    score = minimax(alpha, beta, depth....)\n    time = elapsed_time()\n```\n\nNow you can print the elapsed time for each depth and see how far it gets in a certain period of time. This is also good to measuer if your optimizations are giving any results. Since the Minimax tree is getting exponentially larger for each depth you can get an idea on how much time the next depth will take you.\nSo if you know around how many moves it will take for a win/draw/loss you can pretty easily estimate whether it will be possible or not through this technique.\nHope I make myself clear, English is not my native language :) Feel free ask in the comments if something is not clear.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to perform click event with tags in C#\r\n                \r\nI have been developing a game like Minesweeper and generate buttons with code. The buttons have tags (two-dimensional array, for x and y axis). When I click a button I count mines around that button and wanna click the number is zero. In sum, how can i perform the click events of the buttons with their tags? (Starting from a button that generated with code and has only tag and name)\n\nHere is how i generated the buttons:\n\n```\nfor (int i = 0; i < genişlik; i++)\n        {\n            for (int j = 0; j < yükseklik; j++)\n            {\n\n                Button btn = new Button();\n                btn.Width = 30;\n                btn.Height = 30;\n                btn.Left = i * 30;\n                btn.Top = j * 30;\n                btn.Text = \"\";\n                btn.Tag = new int[] { i, j };\n\n\n\n                this.Controls.Add(btn);\n             }\n         }\n```\n\n    ", "Answer": "\r\nYou simply use:\n\n```\nbtn.Click += method();\n\n       private void Button1_Click(object sender, EventArgs e)\n    {\n        throw new NotImplementedException();\n    }\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Fastest way to sum two lists of items with each other in python\r\n                \r\nI have a bit of a strange request that I'm looking to solve with utmost efficiency; I have two lists ```\nlist_1```\n and ```\nlist_2```\n, which are both the same length and will both only ever contain integers greater than or equal to 0. I want to create a new list ```\nlist_3```\n such that every element ```\ni```\n is the sum of the elements at position ```\ni```\n from ```\nlist_1```\n and ```\nlist_2```\n. In python, this would suffice:\n\n```\nlist_3 = [list_1[i] + list_2[i] for i in range(len(list_1))]```\n\n\nHowever, there is a catch. For every ```\ni```\n such that ```\n0 <= i < len(list_1)```\n, if the item at position ```\ni```\n (i.e. ```\nlist_1[i]```\n) is 0, then the sum of ```\nlist_1[i]```\n and ```\nlist_2[i]```\n should also be zero.\n\nWhat would be the most efficient way to do this? I have to perform this operation on list with 323 elements in it and it needs to be for a game, so it should be able to run easily 60 times per second whilst allowing a lot of extra time for other things to calculate in the game. I was wondering if there might be any fancy numpy way of doing it but I'm not well versed enough with numpy to know for sure.\n\nEDIT:\n\nIn terms of simply summing two elements, some common expressions are:\n\n```\nlist_3 = [list_1[i] + list_2[i] for i in range(len(list_1))]\nlist_3 = [sum(t) for t in zip(list_1, list_2)]\nlist_3 = numpy.add(list_1, list_2)\n```\n\n\nEDIT 2:\n\nI know of conditional list comprehensions, but I'm wondering if there is a faster method than that.\n\nEDIT 3:\n\nHere are some of the timings of methods given:\n\n```\n>>> import timeit\n>>> setup='''\nimport random\nlist_1 = [random.randint(0, 323) for i in range(323)]\nlist_2 = [random.randint(0, 323) for i in range(323)]\n'''\n>>> timeit.timeit('list_3 = [list_1[i] + list_2[i] if list_2[i] else 0 for i in range(len(list_1))]', setup=setup, number=1)\n6.005677381485953e-05\n>>> timeit.timeit('list_3 = [x + y if y else 0 for x, y in zip(list_1, list_2)]', setup=setup, number=1)\n3.604091037417601e-05\n```\n\n\nAnything faster?\n\nEDIT 4:\n\nHere is an explanation as to what I need this for: I'm working on a video game that requires a system of checking the state of certain keys on the keyboard from time to time. The way the system needs to work is that the longer a key is pressed down, the higher a counter for said key increases. Once that key is released, the counter is set back to 0. This needs to be done for all keys, not just a select few. It's currently a bottleneck compared to the rest of the program, according to ```\ncProfile```\n.\n\nHere is the code that generates the state of each key in the keyboard (it uses ```\npygame```\n to grab the key states):\n\n```\nclass KeyState:\n    \"\"\"\n    An object representing the state of the keyboard input at a given frame.\n\n    The KeyState is a global replacement for pygame's event system (or\n    pygame.keys.get_pressed()). It provides a simple interface for updating\n    and retreiving the states of keys in real time.\n\n    To retreive and store the current key information, simply call\n    the update() method. To retreive the given information about a\n    key, use the get_state(key) method where key is any pygame key\n    (i.e. pygame.K_RSHIFT, etc.).\n    \"\"\"\n\n    def __init__(self):\n       self.current_frame = pygame.key.get_pressed()\n\n    def update(self):\n        \"\"\"\n        Retreive the current key state data.\n        \"\"\"\n        new_frame = pygame.key.get_pressed()\n        self.current_frame = [state + new_frame[i] if new_frame[i] else 0 for i, state in enumerate(self.current_frame)]\n\n    def get_state(self, key, strict=True):\n        \"\"\"\n        Retreive the current state of a given key.\n\n        >= 1 - Pressed\n        0    - Unpressed\n        \"\"\"\n        try: \n            return self.current_frame[key]\n        except KeyError:\n            if strict:\n                raise\n```\n\n    ", "Answer": "\r\n\n  the longer a key is pressed down, the higher a counter for said key increases\n\n\nUnless your users have 300 fingers, they likely would only be pressing up to ten keys at a time. You can register for keydown and keyup events; save the frame counter or the return value of time()/clock() on the array when a key is down; and when a key is up or when you need to find the current value of the key, subtract the differences. This will reduce the number of loops to around 10 rather than 300. Note that depending on the system, time()/clock() may be a syscall, which can be slow, so using frame counter may be preferable.\n\n```\ncounter = 0\nkeys = {}\nwhile True:\n    for event in pygame.event.get() :\n        if event.type == pygame.KEYDOWN :\n            keys[event.key] = counter\n        elif event.type == pygame.KEYUP :\n            diff[event.key] = keys.pop(event.key) - counter\n    counter += 1\n```\n\n\nBut I highly doubt that this is the bottleneck of your game.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Get zeros with car plates\r\n                \r\nWhen I was little, I played the next game with my cousins:  \n\n\"Zero in the car's license plates\": by using the numbers in the car's license plate numbers and using the elementary operations (sum, subtraction, product and division) once each, you had to find an order that equaled 0.\n\nFor example, if we have the following license plate: \n\n```\n2591 -->  (2*5)-(9+1) = 0```\n\n\n```\n2491 -->  (2*4)+1 -9  = 0```\n\n\nI would like to make a program in Haskell or Python that it is able to play this game, and print the steps that gives a result of 0.\n\n```\ngetZero 2491 =  2*4+1-9\ngetZero 2591 =  2*5-9+1\n```\n\n\nMaybe its impossible to make this; I hope that you can help me.\n    ", "Answer": "\r\nThis is probably off topic but a fun toy puzzle.\n\nAn easy way to think of the issue is in perhaps four separate parts:\n\n\nBoring plumbing for the arguments and printing the results\nConstruct all possible expressions of binary operations of the given numbers.\nInterpret these expressions to obtain a numeric literal and drop any result that is not zero.\nPretty print the expression.\n\n\nWe could perform extra steps, such as filtering out duplicates based on algebraic rules (```\na + b```\n and ```\nb + a```\n are morally the same), but I skipped that.\n\nThe boring plumbing is just getting our plate numbers (one for each argument), breaking those down into digits, running our computation, and printing the solution.\n\n```\nimport Data.Foldable\nimport Data.List\nimport System.Environment\n\nmain :: IO ()\nmain =\n  do ns <- getArgs\n     for_ ns $ \\n -> do\n        let digitList = map (read . (:[])) (n :: String) :: [Int]\n        putStrLn $ \"---------- \" ++ show n ++ \" ----------\"\n        putStrLn $ unlines (map render (solutions digitList))\n```\n\n\nConstruction The real fun is in this construction of a binary tree of operations and leafs with the literals.  First we define our expression language:\n\n```\ndata Expr = Add Expr Expr\n          | Sub Expr Expr\n          | Mul Expr Expr\n          | Div Expr Expr\n          | Lit Int\n        deriving (Eq, Ord, Show)\n```\n\n\nAnd we can use these expressions along with a Haskell list monad to build all possible expressions (assuming a non-empty list as input):\n\n```\noperations :: [Expr -> Expr -> Expr]\noperations = [Add, Sub, Mul, Div]\n\nexprsOf :: [Expr] -> [Expr]\nexprsOf [term] = [term]\nexprsOf xs =\n  do x <- xs\n     y <- (delete x xs)\n     o <- operations\n     exprsOf (o x y : delete y (delete x xs))\n```\n\n\nThat is, ```\nx```\n is one of the elements in the original set of expressions.  ```\ny```\n is another element (but not x).  ```\no```\n is one of our legal operations (addition, subtraction, etc).  And we recursively reduce this list size till we are left with the top level expression (variable name ```\nterm```\n).  If you don't understand the operation that's OK - specific parts that confuse you would make a fine (on topic) question.\n\nInterpretation With the expressions built we can now interpret them and filter out any that don't result in zero.\n\nThe interpreter is just using addition (```\n+```\n) when we see our ```\nAdd```\n constructor and same for the other operations.  I lifted everything into the Maybe Applicative because I didn't want division by zero or with a remainder to show up in our results.\n\n```\ninterp :: Expr -> Maybe Int\ninterp (Lit n) = Just n\ninterp (Add a b) = (+) <$> interp a <*> interp b\ninterp (Sub a b) = (-) <$> interp a <*> interp b\ninterp (Mul a b) = (*) <$> interp a <*> interp b\ninterp (Div a b) | interp b == Just 0 = Nothing\n                 | interp b == Nothing = Nothing\n                 | otherwise          =\n        case divMod <$> interp a <*> interp b of\n            Nothing -> Nothing\n            Just (x,0) -> Just x\n            _ -> Nothing -- Ignore uneven division\n```\n\n\nApplying this interpretation is just a matter of filtering for ```\nJust 0```\n:\n\n```\nsolutions :: [Int] -> [Expr]\nsolutions xs = filter ((== Just 0) . interp) $ exprsOf (map Lit xs)\n```\n\n\nRendering Finally, there's a pretty ugly render function just to emit the proper parenthesis so we see the right order of operations:\n\n```\nrender :: Expr -> String\nrender (Lit n) = show n\nrender (Add a b) = \"(\" ++ render a ++ \" + \" ++ render b ++ \")\"\nrender (Sub a b) = \"(\" ++ render a ++ \" - \" ++ render b ++ \")\"\nrender (Mul a b) = \"(\" ++ render a ++ \" * \" ++ render b ++ \")\"\nrender (Div a b) = \"(\" ++ render a ++ \" / \" ++ render b ++ \")\"\n```\n\n\nExample Run\n\n```\n*Main> :main 2591\n---------- \"2591\" ----------\n(((2 * 5) - 9) - 1)\n(1 - ((2 * 5) - 9))\n(((2 * 5) - 1) - 9)\n(9 - ((2 * 5) - 1))\n((9 - (2 * 5)) + 1)\n(1 + (9 - (2 * 5)))\n((9 + 1) - (2 * 5))\n((2 * 5) - (9 + 1))\n((1 - (2 * 5)) + 9)\n(9 + (1 - (2 * 5)))\n((1 + 9) - (2 * 5))\n((2 * 5) - (1 + 9))\n(((5 * 2) - 9) - 1)\n(1 - ((5 * 2) - 9))\n(((5 * 2) - 1) - 9)\n(9 - ((5 * 2) - 1))\n((9 - (5 * 2)) + 1)\n(1 + (9 - (5 * 2)))\n((9 + 1) - (5 * 2))\n((5 * 2) - (9 + 1))\n((1 - (5 * 2)) + 9)\n(9 + (1 - (5 * 2)))\n((1 + 9) - (5 * 2))\n((5 * 2) - (1 + 9))\n(((9 + 1) / 2) - 5)\n(5 - ((9 + 1) / 2))\n(((9 + 1) / 5) - 2)\n(2 - ((9 + 1) / 5))\n((2 * 5) - (9 + 1))\n((9 + 1) - (2 * 5))\n((5 * 2) - (9 + 1))\n((9 + 1) - (5 * 2))\n(((1 + 9) / 2) - 5)\n(5 - ((1 + 9) / 2))\n(((1 + 9) / 5) - 2)\n(2 - ((1 + 9) / 5))\n((2 * 5) - (1 + 9))\n((1 + 9) - (2 * 5))\n((5 * 2) - (1 + 9))\n((1 + 9) - (5 * 2))\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Slick pick game - boolean functions and return statements\r\n                \r\nI am working on a project, and I have written the code that I know how to do. I am having multiple problems, and I don't know whether I should post the entire project code at once or just focus on one problem at a time. \n\nThe directions for the games are: \"At the start of the game, both the player's and Slick's scores are set to zero. For each turn, the player picks one number from the pool. That value is added to the player's score. Slick gets the sum of all the remaining numbers in the pool that divide evenly into the player's pick. The player's pick and it's divisors are then removed from the pool. For each turn, Slick must be able to get at least one number. If the player does not have any picks left, the game is over and Slick gets the sum of all remaining numbers in the pool. The highest score wins.\" \n\nIf the player's pick is valid, the list of divisors is printed; if the player's pick is not valid, an error message should be printed and the prompt should appear again. For a pick to be legal, it must be in the pool, and it must have at least one divisor in the pool. My code is below:    \n\n```\n//Name          : pickValidity\n//Description   : This funtion determines if the player's pick is valid.\n//Parameters    : The pool array and the user's pick, in that order.\n//Return        : True/false indicator.  \npublic static boolean pickValidity(int[] pool, int size, int pick){\n    int low=0;\n    int high=size-1;\n    int mid;\n    int poolIndex=0;\n    boolean found=false;\n    boolean isValid=false;\n\n    while(low<=high && !found){\n        mid=(low + high) / 2;\n        if(pick == pool[mid]){\n            found = true;\n        }else if(pick < pool[mid]){\n            high = mid-1;\n        }else{\n            low = mid+1;\n        }\n    }\n    if(found){\n        while(pool[poolIndex] < pick && !isValid){\n        if(pick % pool[poolIndex] == 0){\n            isValid = true; \n        }else{\n            isValid = false;\n        } \n        poolIndex++;\n        }\n    }\n    return(isValid);\n} \n```\n\n\nBelow, I've added my call statements. When I run the program and deliberately enter non-valid picks, the prompt comes up again, but after I enter another number, the program stops. How do I make it keep going? \n\n```\n        // User Input\n    printPool(pool, size);\n    System.out.println();\n    System.out.println();\n    System.out.println(\"Enter a non-prime value listed in the pool above: \");\n    pick=read.nextInt();\n\n        // Pick Validity\n    while(!(pickValidity(pool, size, pick) && poolValidity(pool, pick))){\n        System.out.println(\"Pick is invalid.\");\n        System.out.println();\n        System.out.println(\"Enter a non-prime value listed in the pool above: \");\n        pick=read.nextInt();\n    }\n\n        // Data Processing\n    numDivisors = getDivisors(pool, divisors, pick);\n\n        // Output Section\n    printDivisors(divisors, numDivisors, pick);\n    System.out.println();\n    printScores(divisors, size, pick);\n    System.out.println();\n\n\n    System.out.println();\n    System.out.println();\n    System.out.println();\n    System.out.println(\"Program Ended\");  \n   }\n```\n\n\nPlease & thank you!\n    ", "Answer": "\r\nI guess you want to return \"isValid\" from PoolValidity?\n\nAnother guess is that you want to return at once when you determine that the pool is valid, ie \"isValid=true\"\n\nI would also have a closer look at your if-test. I'm not convinced that it is correct.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Imagelist always returns -1\r\n                \r\nI'm designing a small game using windows forms in which there is 5 labels, each set to resemble an image of dice ( 1 - 6 ) from a specified imagelist. The game is made to be \"rolled\" 3 times, at the end of the roll you can select labels NOT to be rolled by changing their background color. At the end of each roll, the sum of the die faces is calculated and presented.\n\nNow for the problem...\n\nI know that my labels can reach the imagelist as the \"rolling\" function of the dice works very well. Each label is set to be run through a timer tick event that will occur 10 times in which random images are selected from the imagelist, creating the illusion of rolling dice. However, when I wish to ADD the total of the die faces at the end of the rolling cycle using the imagelist index, each index returns -1. Take note, the index of each respective die is one less than the amount of the die. Likewise, if you had a die resembling a one, it's index would be zero. I account for such by adding 1 to the index. So... although I may have a 5,5,6,4,3 - my score counter amounts to 0, rather than say 23.\n\nWhy would the imgaelist index give a value of -1 when the lowest available index is 0?\n\nHere is my code. The actual calculation for the sum of the die faces is made in the else statement. I set m_iScore (the score counter) to zero prior to evaluating the sum because I want the sum to be representative of the faces after EACH roll.\n\n```\nprivate void timer1_Tick(object sender, EventArgs e)\n        {\n            Label[] labelArray = new Label[] { label1, label2, label3, label4, label5 };\n            Random randnum = new Random();\n            if (m_iAnimations < 10)\n            {\n                for (int iCount = 0; iCount < labelArray.Length; iCount++)\n                {\n                    if ((labelArray[iCount]).BackColor == Color.Lime)\n                    {\n                        (labelArray[iCount]).Image = imageList1.Images[randnum.Next(0, 6)];\n                    }\n                }\n                m_iAnimations++;\n            }\n            else\n            {\n                timer1.Enabled = false;\n                m_iAnimations = 0;\n                m_iScore = 0;\n                for (int iCount = 0; iCount < labelArray.Length; iCount++)\n                {\n                    m_iScore = m_iScore + ((labelArray[iCount]).ImageIndex + 1);\n                }\n                scoreval.Text = m_iScore.ToString();\n            }\n\n        }\n```\n\n\nIf I don't add 1 to the image index, scoreval.Text shows -5.\n    ", "Answer": "\r\nSetting the ```\nImage```\n property doesn't change the ```\nImageIndex```\n property -- they're more-or-less completely unrelated.\n\nIn general, UI should display program state, not hold it. Do all your computation, then push the results of that computation into the UI; don't use the UI elements as if they're variables.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to prevent numbers from getting too low/high in python?\r\n                \r\nI'm currently working on a \"Hunger Games\"-Simulator and every player has 17 traits. The traits of the winning person get changed the least and the traits of the worst person get changed much. But after I change the traits they often go below zero or above 1000 (should be max) even though I even coded a backup for this.\n\nI already tried to just set them back into the range 1-1000 and give the leftover trait-points to another trait. It also just happens after multiple iterations.\n\nThis is the code to change the traits:\n\nList \"pl\" is looking like this: [trait1, trait2, ..., trait18]\n\n\"count\" is the rank.\n\n```\nwhile again == True:\n            for k in range(int(count/2)):\n                randnum = random.randint(0,20)\n                randnum2 = random.randint(0,15)\n                randnum3 = random.randint(0,15)\n                pl[randnum2] += randnum\n                pl[randnum3] -= randnum\n            for y in pl:\n                if y > 1000:\n                    over = abs(y - 1000)\n                    randnum = random.randint(0,15)\n                    if pl[randnum] > 1000 - over:\n                        break\n                    else:\n                        y = 1000\n                        pl[random.randint(0,15)] += over\n                if y < 0:\n                    over = abs(y)+1\n                    randnum = random.randint(0,15)\n                    if pl[randnum] < over:\n                        break\n                    else:\n                        y = 1\n                        pl[randnum] -= over\n            for y in pl:\n                if y > 1000 or y < 1:\n                    again = True\n                    break\n                else:\n                    again = False\n```\n\n\nI expected that the traits get updated so that if you add all trait-points together you always get the same result with every player. But it seems like they either get really big or really small and don't have the same sum all the time.\n\nThanks! :)\n    ", "Answer": "\r\nuse special list-like class with method:\n\n```\ndef __setitem__(self, name, value):\n    if minValue < value < maxValue:\n        super().__setitem__(name, value)\n```\n\n\nand define other methods (```\n__add__```\n, ```\nappend```\n, ...) using that\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Pacman AI - Minimax Application - Avoiding repeated game tree states\r\n                \r\nIn the context of a project, following the UC Berkley pacman ai project (its second part), I want to implement the minimax algorithm, without alpha-beta pruning, for an adversarial agent in a layout small enough that recursion is not a problem. \n\nHaving defined the problem as a 2-player (we assume only 1 ghost), turn taking, zero-sum game with perfect information, applying the recursive would be pretty trivial. However, since many different strategies can end up in the same game state (defined as a tuple of pacman's position, the ghost's position, the food's position and the player currently playing), I wanted to find a way to avoid recomputing all those states.\n\nI searched and I read some things about transposition tables. I am not really sure on how to use such a method however and what I thought I should implement was the following: \nEach time a state, not yet visited, is expanded, add it to a 'visited' set. If the state has already been expanded, then if it's the max player's turn (pacman) return a +inf value (which would normally never be chosen by the min player), if it's min's turn return -inf accordingly.\n\nThe problem with this idea, I think, and the reason why it works for some layouts but not others, is that when I hit a node, all the children of which have already been expanded, the only values I have to choose from are +/- infinities. This causes an infinite value to propagate upwards and be selected, while in fact it is possible that this game state leads to a loss. I think, I have understood the problem, but I can't seem to find a way to get around it.\n\nIs there any other method I could use to avoid computing repeated game states? Is there a standard approach to this that I am not aware of?\n\nHere is some pseudocode:\n\n```\n def maxPLayer(currentState, visitedSet):\n     if not isTerminalState\n         for nextState, action in currentState.generateMaxSuccessors()\n             if nextState not in visitedSet\n                mark nextState as visited\n                scores = scores + [minPlayer(nextState, visitedSet)]\n         if scores is not empty\n            return bestScore = max(scores)\n         else\n            return +inf              #The problem is HERE!\n     else\n         return evalFnc(currentState)\n end MaxPlayer\n\ndef minPlayer(currenstState, visitedSet):\n    if not isTerminal\n        for nextState, action in generateMinSuccessors()\n            if nextState not in visitedSet \n                mark nextState as visited\n                scores = scores + [maxPLayer(nextState, visitedSet)]\n        if scores is not empty\n            return bestScore = min(scores)\n        else\n            return -inf            #The problem is also HERE!\n    else\n        return evalFnc(currentState)\n   end MinPlayer\n```\n\n\nNote that the first player to play is max and I choose the action that has the highest score. Nothing changes if I take into account infinite values or not, there are still instances of the game where the agent loses, or loops infinitely.\n    ", "Answer": "\r\nI think the main shortcoming in your approach is that you consider already visited states as undesirable targets for the opponent to move to. Instead of returning an infinity value, you should retrieve the value that was computed at the time when that state was first visited.\n\nPractically this means you should use a map (of state->value) instead of a set (of state).\n\nOnly in case the value of the first visit is not yet computed (because the recursive call leads to a visit of an ancestor state), you would need to use a reserved value. But let that value be undefined/null/None, so that it will not be treated as other numerical results, but will be excluded from possible paths, even when backtracking.\n\nAs a side note, I would perform the lookup & marking of states at the start of the function -- on the current state -- instead of inside the loop on the neighboring states.\n\nHere is how one of the two functions would then look:\n\n```\ndef maxPLayer(currentState, evaluatedMap):\n    if currentState in evaluatedMap\n        return evaluatedMap.get(currentState)\n\n    evaluatedMap.set(currentState, undefined)\n\n    if not isTerminalState\n        bestScore = undefined\n        for nextState in currentState.generateMaxSuccessors()\n            value = minPlayer(nextState, evaluatedMap)\n            if value != undefined\n                scores.append(value)\n        if scores is not empty\n            bestScore = max(scores)\n    else\n        bestScore = evalFnc(currentState)\n\n    evaluatedMap.set(currentState, bestScore)\n    return bestScore\nend MaxPlayer\n```\n\n\nThe value ```\nundefined```\n will be used during the time that a state is visited, but its value has not yet been determined (because of pending recursive calls). If a state is such that the current player has no valid moves (is \"stuck\"), then that state will permanently get the value ```\nundefined```\n, in other cases, the value ```\nundefined```\n will eventually get replaced with a true score.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to choose the right bean scope?\r\n                \r\nI noticed that there are different bean scopes like:\n\n```\n@RequestScoped\n@ViewScoped\n@FlowScoped\n@SessionScoped\n@ApplicationScoped\n```\n\n\nWhat is the purpose of each? How do I choose a proper scope for my bean?\n    ", "Answer": "\r\nIntroduction\nIt represents the scope (the lifetime) of the bean. This is easier to understand if you are familiar with \"under the covers\" working of a basic servlet web application: How do servlets work? Instantiation, sessions, shared variables and multithreading.\n\n```\n@Request/View/Flow/Session/ApplicationScoped```\n\nA ```\n@RequestScoped```\n bean lives as long as a single HTTP request-response cycle (note that an Ajax request counts as a single HTTP request too). A ```\n@ViewScoped```\n bean lives as long as you're interacting with the same JSF view by postbacks which call action methods returning ```\nnull```\n/```\nvoid```\n without any navigation/redirect. A ```\n@FlowScoped```\n bean lives as long as you're navigating through the specified collection of views registered in the flow configuration file. A ```\n@SessionScoped```\n bean lives as long as the established HTTP session. An ```\n@ApplicationScoped```\n bean lives as long as the web application runs. Note that the CDI ```\n@Model```\n is basically a stereotype for ```\n@Named @RequestScoped```\n, so same rules apply.\nWhich scope to choose depends solely on the data (the state) the bean holds and represents. Use ```\n@RequestScoped```\n for simple and non-ajax forms/presentations. Use ```\n@ViewScoped```\n for rich ajax-enabled dynamic views (ajaxbased validation, rendering, dialogs, etc). Use ```\n@FlowScoped```\n for the \"wizard\" (\"questionnaire\") pattern of collecting input data spread over multiple pages. Use ```\n@SessionScoped```\n for client specific data, such as the logged-in user and user preferences (language, etc). Use ```\n@ApplicationScoped```\n for application wide data/constants, such as dropdown lists which are the same for everyone, or managed beans without any instance variables and having only methods.\nAbusing an ```\n@ApplicationScoped```\n bean for session/view/request scoped data would make it to be shared among all users, so anyone else can see each other's data which is just plain wrong. Abusing a ```\n@SessionScoped```\n bean for view/request scoped data would make it to be shared among all tabs/windows in a single browser session, so the enduser may experience inconsitenties when interacting with every view after switching between tabs which is bad for user experience. Abusing a ```\n@RequestScoped```\n bean for view scoped data would make view scoped data to be reinitialized to default on every single (ajax) postback, causing possibly non-working forms (see also points 4 and 5 here). Abusing a ```\n@ViewScoped```\n bean for request, session or application scoped data, and abusing a ```\n@SessionScoped```\n bean for application scoped data doesn't affect the client, but it unnecessarily occupies server memory and is plain inefficient.\nNote that the scope should rather not be chosen based on performance implications, unless you really have a low memory footprint and want to go completely stateless; you'd need to use exclusively ```\n@RequestScoped```\n beans and fiddle with request parameters to maintain the client's state. Also note that when you have a single JSF page with differently scoped data, then it's perfectly valid to put them in separate backing beans in a scope matching the data's scope. The beans can just access each other via ```\n@ManagedProperty```\n in case of JSF managed beans or ```\n@Inject```\n in case of CDI managed beans.\nSee also:\n\nDifference between View and Request scope in managed beans\nAdvantages of using JSF Faces Flow instead of the normal navigation system\nCommunication in JSF2 - Managed bean scopes\n\n\n```\n@CustomScoped/NoneScoped/Dependent```\n\nIt's not mentioned in your question, but (legacy) JSF also supports ```\n@CustomScoped```\n and ```\n@NoneScoped```\n, which are rarely used in real world. The ```\n@CustomScoped```\n must refer a custom ```\nMap<K, Bean>```\n implementation in some broader scope which has overridden ```\nMap#put()```\n and/or ```\nMap#get()```\n in order to have more fine grained control over bean creation and/or destroy.\nThe JSF ```\n@NoneScoped```\n and CDI ```\n@Dependent```\n basically lives as long as a single EL-evaluation on the bean. Imagine a login form with two input fields referring a bean property and a command button referring a bean action, thus with in total three EL expressions, then effectively three instances will be created. One with the username set, one with the password set and one on which the action is invoked. You normally want to use this scope only on beans which should live as long as the bean where it's being injected. So if a ```\n@NoneScoped```\n or ```\n@Dependent```\n is injected in a ```\n@SessionScoped```\n, then it will live as long as the ```\n@SessionScoped```\n bean.\nSee also:\n\nExpire specific managed bean instance after time interval\nwhat is none scope bean and when to use it?\nWhat is the default Managed Bean Scope in a JSF 2 application?\n\n\nFlash scope\nAs last, JSF also supports the flash scope. It is backed by a short living cookie which is associated with a data entry in the session scope. Before the redirect, a cookie will be set on the HTTP response with a value which is uniquely associated with the data entry in the session scope. After the redirect, the presence of the flash scope cookie will be checked and the data entry associated with the cookie will be removed from the session scope and be put in the request scope of the redirected request. Finally the cookie will be removed from the HTTP response. This way the redirected request has access to request scoped data which was been prepared in the initial request.\nThis is actually not available as a managed bean scope, i.e. there's no such thing as ```\n@FlashScoped```\n. The flash scope is only available as a map via ```\nExternalContext#getFlash()```\n in managed beans and ```\n#{flash}```\n in EL.\nSee also:\n\nHow to show faces message in the redirected page\nPass an object between @ViewScoped beans without using GET params\nCDI missing @ViewScoped and @FlashScoped\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Adding an Array's elements to last element and compare it with another Array in Javascript\r\n                \r\nI am having two array with the same length and format given at the end.\nassume the last element on each array is the score if either array has zero values in other elements.\nLet's say we have array p1 and p2 each have 7 elements. If either p1 or p2 first 6 elements has zero value then it means the game is over and we sum up all other elements and add to last element(mail_hole) which define its score. Then compare each score to find the winner.\nHere is my code:\n\r\n\r\n```\nfunction checkWinner(holes, status = \"incomplete\", winner = \"none\") {\n  const p1MainHole = holes[\"p1\"].pop(); // check if all holes has zero stone.(Except main hole)\n  const p2MainHole = holes[\"p2\"].pop(); // check if all holes has zero stone.(Except main hole)\n  if (holes[\"p1\"].every((hole) => hole.value === 0)) {\n    const sumOfAllStone = this.countAllStone(holes, \"p2\", p2MainHole);\n    holes[\"p2\"].push(sumOfAllStone);\n    holes[\"p1\"].push(p1MainHole);\n    status = \"complete\";\n  } else if (holes[\"p2\"].every((hole) => hole.value === 0)) {\n    const sumOfAllStone = this.countAllStone(holes, \"p1\", p1MainHole);\n    holes[\"p1\"].push(sumOfAllStone);\n    holes[\"p2\"].push(p2MainHole);\n    status = \"complete\";\n  } else {\n    holes[\"p1\"].push(p1MainHole);\n    holes[\"p2\"].push(p2MainHole);\n  }\n  if (status === \"complete\") {\n    winner = holes[\"p1\"][holes[\"p1\"].length - 1].value > holes[\"p2\"][holes[\"p2\"].length - 1].value ? \"p1\" : \"p2\";\n  }\n  return {\n    holes,\n    status,\n    winner\n  };\n}\n\n\nfunction countAllStone(holes, player, mainHole) {\n  for (let i = 0; i < holes[player].length; i++) {\n    mainHole.value += holes[player][i].value;\n  }\n  return mainHole;\n}\n\nconsole.log(\n    checkWinner({\n        p1: [\n            {\n                name: \"hole_0\",\n                value: 0,\n            },\n            {\n                name: \"hole_1\",\n                value: 0,\n            },\n            {\n                name: \"hole_2\",\n                value: 0,\n            },\n            {\n                name: \"hole_3\",\n                value: 0,\n            },\n            {\n                name: \"hole_4\",\n                value: 0,\n            },\n            {\n                name: \"hole_5\",\n                value: 0,\n            },\n            {\n                name: \"main_hole\",\n                value: 0,\n            },\n        ],\n        p2: [\n            {\n                name: \"hole_0\",\n                value: 1,\n            },\n            {\n                name: \"hole_1\",\n                value: 1,\n            },\n            {\n                name: \"hole_2\",\n                value: 1,\n            },\n            {\n                name: \"hole_3\",\n                value: 1,\n            },\n            {\n                name: \"hole_4\",\n                value: 2,\n            },\n            {\n                name: \"hole_5\",\n                value: 0,\n            },\n            {\n                name: \"main_hole\",\n                value: 1,\n            },\n        ],\n    })\n);```\n\r\n\r\n\r\n\nAt the end it compares each player's score(last elements) to find the winner.\nI am not satisfied with the amount of code written and the efficiency of it. Any idea would be welcome, Thanks.\n    ", "Answer": "\r\nThis may be one possible alternate solution to achieve the desired objective:\nCode Sample\n```\n  if (allZeroValues(p1) || allZeroValues(p2)) {\n    resObj.status = 'complete';\n    if (allZeroValues(p1)) updateTotal(p2);\n    else updateTotal(p1);\n    resObj.winner = getWinner(p1, p2);\n  };\n```\n\nExplanation\n\nif either ```\np1```\n or ```\np2```\n are zero-valued (except 'main_hole'), then\nset ```\nstatus```\n to complete\nif ```\np1```\n is all zeroes, update ```\np2```\n's total\nelse, update ```\np1```\n's total\nset ```\nwinner```\n based on the totals\n\nThere are several helper methods used which may be understood from perusing the snippet below.\nCode Snippet\n\r\n\r\n```\nconst checkWinner = (holes, status = \"incomplete\", winner = \"none\") => {\n  // first, declare few helper methods\n  \n  // to get an array without the 'main_hole'\n  const skipMainHole = arr => ([\n    ...arr.filter(el => el.name !== 'main_hole')\n  ]);\n  \n  // add total values except 'main_hole'\n  const sumValues = arr => (\n    skipMainHole(arr).reduce(\n      (tot, itm) => (tot + itm.value),\n      0\n    )\n  );\n  \n  // check if array without 'main_hole' is all zeroes\n  // assumption: 'value' will always be non-negative integer\n  const allZeroValues = arr => (sumValues(arr) === 0);\n  \n  // update 'main_hole' value\n  const updateTotal = arr => {\n    arr[arr.length - 1].value += sumValues(arr);\n  };\n  \n  // get winner\n  const getWinner = (arr1, arr2) => (\n    arr1.slice(-1)[0].value === arr2.slice(-1)[0].value\n      ? 'none'\n      : arr1.slice(-1)[0].value > arr2.slice(-1)[0].value\n        ? 'p1'\n        : 'p2'\n  );\n  \n  // now, de-structure holes to get the p1, p2 arrays\n  const {p1, p2} = holes;\n  // set-up a result-object\n  const resObj = {status, winner};\n  \n  // now, for the actual logic\n  if (allZeroValues(p1) || allZeroValues(p2)) {\n    resObj.status = 'complete';\n    if (allZeroValues(p1)) updateTotal(p2);\n    else updateTotal(p1);\n    resObj.winner = getWinner(p1, p2);\n  };\n  \n  // finally, return the updated result-object\n  return {...resObj, holes: {p1, p2}};\n};\n\nconsole.log(\n    checkWinner({\n        p1: [\n            {\n                name: \"hole_0\",\n                value: 0,\n            },\n            {\n                name: \"hole_1\",\n                value: 0,\n            },\n            {\n                name: \"hole_2\",\n                value: 0,\n            },\n            {\n                name: \"hole_3\",\n                value: 0,\n            },\n            {\n                name: \"hole_4\",\n                value: 0,\n            },\n            {\n                name: \"hole_5\",\n                value: 0,\n            },\n            {\n                name: \"main_hole\",\n                value: 0,\n            },\n        ],\n        p2: [\n            {\n                name: \"hole_0\",\n                value: 1,\n            },\n            {\n                name: \"hole_1\",\n                value: 1,\n            },\n            {\n                name: \"hole_2\",\n                value: 1,\n            },\n            {\n                name: \"hole_3\",\n                value: 1,\n            },\n            {\n                name: \"hole_4\",\n                value: 2,\n            },\n            {\n                name: \"hole_5\",\n                value: 0,\n            },\n            {\n                name: \"main_hole\",\n                value: 1,\n            },\n        ],\n    })\n);```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Is it possible to calculate a conditional cumsum with dplyr\r\n                \r\nI'm trying to calculate the historical number of hits a player has gotten in day vs night games. For example given a player with 5 games, sorted from oldest games to most recent game the dn_hits column (daynight) for the first row would be zeros because this is the first game. The dn_hits for the second row would look at if the second game was a day game or a night game and then perform a backward-looking cumsum() on the hits column - summing all hits that happened on a day or night as the case may be. This would happen for each row in the group.\nI have a sample data frame and sample output below. I've also included some psuedo code of what I believe I need to do to make the calculation\nYou can see in the output below:\nRow 1: the dn_hits column for the first row for player AJ is 0 (no prior games or hits to cumsum);\nRow 2: the second row  for player AJ is 2 (AJ's second game was a day game and so was his first game. Therefore, we conditionally cumsum the first game hits = 2 where dn = \"day\");\nRow 3: the third row for player AJ is 0 (game three is a night game, prior to game 3 player AJ only played in (2) day games so the conditional cumsum of hits from where dn = \"night\" is 0)\nCan this be accomplished with dplyr or is this a job for purrr.\n```\n library(tidyverse)\n\ndf <- tibble(game=c(seq(1:5),seq(1,5)),name=c(\"AJ\",\"AJ\",\"AJ\",\"AJ\",\"AJ\",\"CJ\",\"CJ\",\"CJ\",\"CJ\",\"CJ\"),\nhits = c(2,1,0,1,3,2,1,4,1,0), dn=c(\"Day\",\"Day\",\"Night\",\"Night\",\"Night\",\"Night\",\"Day\",\"Night\",\"Night\",\"Day\"))\n\n\noutput  <- tibble(game=c(seq(1:5),seq(1,5)),name=c(\"AJ\",\"AJ\",\"AJ\",\"AJ\",\"AJ\",\"CJ\",\"CJ\",\"CJ\",\"CJ\",\"CJ\"),\nhits = c(2,1,0,1,3,2,1,4,1,0), dn=c(\"Day\",\"Day\",\"Night\",\"Night\",\"Night\",\"Night\",\"Day\",\"Night\",\"Night\",\"Day\"), dn_hits=c(0,2,0,0,1,0,0,2,6,1)) \n\n# Original tibble\n\ndf\n#> # A tibble: 10 x 4\n#>     game name   hits dn   \n#>    <int> <chr> <dbl> <chr>\n#>  1     1 AJ        2 Day  \n#>  2     2 AJ        1 Day  \n#>  3     3 AJ        0 Night\n#>  4     4 AJ        1 Night\n#>  5     5 AJ        3 Night\n#>  6     1 CJ        2 Night\n#>  7     2 CJ        1 Day  \n#>  8     3 CJ        4 Night\n#>  9     4 CJ        1 Night\n#> 10     5 CJ        0 Day\n\n# Desired Output\n\noutput\n#> # A tibble: 10 x 5\n#>     game name   hits dn    dn_hits\n#>    <int> <chr> <dbl> <chr>   <dbl>\n#>  1     1 AJ        2 Day         0\n#>  2     2 AJ        1 Day         2\n#>  3     3 AJ        0 Night       0\n#>  4     4 AJ        1 Night       0\n#>  5     5 AJ        3 Night       1\n#>  6     1 CJ        2 Night       0\n#>  7     2 CJ        1 Day         0\n#>  8     3 CJ        4 Night       2\n#>  9     4 CJ        1 Night       6\n#> 10     5 CJ        0 Day         1\n\n\n# This is what I think needs to happen but not sure how to implement it. \n\n#df %>% \n#group_by(name) %>%\n#arrange(name, desc(game)) %>% \n#mutate(dn_hits = cumsum(dn = [dn on current row],hits, 0))\n```\n\nEDIT: I also tried the following:\n```\ndf %>% \ngroup_by(name) %>%\narrange(name, desc(game)) %>% \nmutate(dn_hits = map_int(dn, ~ cumsum(if_else(.x == dn, hits, 0))))\n```\n\nBut I get the following error:\n```\nError: Problem with `mutate()` input `dn_hits`. x `false` must be a double vector, not an integer vector. i Input `dn_hits` is `map_int(dn, ~cumsum(if_else(.x == dn, hits, 0L)))`. i The error occurred in group 1: name = \"AJ\".\n```\n\n    ", "Answer": "\r\nYou can just ```\ngroup_by```\n by ```\ndn```\n to make a 'conditional' cumulative sum:\n```\ndf %>% \n  group_by(name, dn) %>% \n  mutate(dn_hits = cumsum(hits)-hits)\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Good Evaluation function for Game Playing Minmax Agent with Alpha Beta Pruning\r\n                \r\nI'm trying to build an AI agent for a specific zero-sum board game using alpha-beta pruning. The program will be depth limited because of certain time constraints and hence I need a good evaluation function to use. The game is as follows \n\n\n  It is a two-player game in which each player tries to maximize his/her\n  share from a batch of candies randomly placed in a box. The box is\n  divided into cells and each cell is either empty or filled with one\n  candy of a specific type. At the beginning of each game, all cells are\n  filled with candies. Players play in turn and can pick a cell of the\n  box in their own turn and claim all candies of the same type, in all\n  cells that are connected to the selected cell through horizontal and\n  vertical paths. For each selection or move the agent is rewarded a\n  numeric value which is the square of the number of candies claimed in\n  that move. Once an agent picks the candies from the cells, their empty\n  place will be filled with other candies on top of them(which fall down\n  due to gravity), if any. In this game, no candy is added during\n  gameplay. Hence, players play until all candies have been claimed.\n\n\nGiven the above gameplay, can someone help me get a good eval function for the game ? One thought that comes to my mind is to get the maximum number of fruits that can be claimed from the given board state as a heuristic/eval function. However, this is not a great eval function. What could be better ?\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Game of Craps: Java programming\r\n                \r\nThis is my code I am suppose to be stimulating the game of craps: I am getting an error \n\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n    at Dice.main(Dice.java:71)\n\nplease help the instructions are: \nIn the game of craps, a pass line bet proceeds as follows. Two six-sided dice are rolled; the first roll of the dice in a craps round is called the “come out roll.” A come out roll of 7 or 11 automatically wins, and a come out roll of 2, 3, or 12 automatically loses. If 4, 5, 6, 8, 9, or 10 is rolled on the come out roll, that number becomes the point. The player keeps rolling the dice until either 7 or the point is rolled. If the point is rolled first, then the player wins the bet. If a 7 is rolled first, then the player loses. Write a program that simulates a game of craps using these rules without human input. Instead of asking for a wager, the program should calculate whether the player would win or lose.\n\nThe program should simulate rolling the two dice and calculate the sum. Add a loop so that the program plays 10,000 games.Add counters that count how many times the player wins, and how many times the player loses. At the end of the 10,000 games, compute the probability of winning [i.e., Wins / (Wins + Losses)] and output this value. Over the long run, who is going to win the most games, you or the house? Note: To generate a random number x, where 0 x ≤< 1, use x = Math.random(); . For example, multiplying by 6 and converting to an integer results in an integer that is between 0 and 5. \n\n```\npublic class Dice \n{\n    public static void main(String[]args)\n    {\n        //declaring variables\n        int comeOutRoll1, comeOutRoll2;\n        int roll1, roll2;\n        int numW, numL;\n        int sum, sum2 = 0;\n        int thePoint = 0;\n        double probability; \n\n\n        //initializing variables\n        comeOutRoll1 = (int)(Math.random()*6) +1;\n        comeOutRoll2 = (int)(Math.random()*6) +1;\n        sum = comeOutRoll1 + comeOutRoll2;\n        numW = 0;\n        numL = 0;\n\n\n        for(int timesPlayed = 0; timesPlayed <= 10000; timesPlayed++)\n        {\n\n            switch(sum)\n            {\n            //adds how many wins and losses\n            case 2:\n            case 3:\n            case 12:\n                numL = numL + 1;\n            break;\n            case 7:\n            case 11:\n                numW = numW +1;\n            break;\n            case 4:\n                thePoint = sum;\n            case 5:\n                thePoint = sum;\n            case 6:\n                thePoint = sum;\n            case 8:\n                thePoint = sum;\n            case 9:\n                thePoint = sum;\n            case 10:\n                thePoint = sum;\n            break;\n            //if not any of these cases roll again\n            default:\n\n                roll1 = (int)(Math.random()*6) +1;\n                roll2 = (int)(Math.random()*6) +1;\n                sum2 = roll1 + roll2;\n                break;\n            }\n\n            if(sum2 == thePoint)\n            {\n                do\n                numW = numW +1;\n            }\n            else if(sum2 == 7)\n            {\n                numL = numL +1;\n            }\n        }\n\n\n            probability = (numW/(numW+numL));\n\n            System.out.println(\"Number of Wins: \" + numW);\n            System.out.println(\"Number of Losses: \" + numL);\n            System.out.println(\"The probability of winning is: \" + probability + \" percent\");   \n\n\n    }\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Mathematical error in physics restitution formula\r\n                \r\nI admit it. I'm a mathematical imbecile. should I be attempting this at home? Probably not without serious injury. Anyway. Anyone that has a bit of experience in games and physics who can review this code and provide insight into why there is a built in \"loss\" in velocity in prototype would be hugely admired.\n\nthe concept: the actor falls from the sky, at some point intersects a boundary (trampoline.y) after which gravity (in this example a value of 1.6) stops operating and a restitution factor (in this case a value of -6) takes over. \n\nright now I'm trying to create a zero-sum situation where you have the same velocity coming out of the trampoline \"bounce\" (hero.y >= trampoline.y) as you did going in. That's just not the case as the traces reveal.\n\nI've tried about five different approaches and this is the latest, given the insight that at any given \"tic\" of my game timer (33 ms) we may have passed the boundary of the trampoline and thus the acceleration rules will have changed. I really thought I had it, but the results show a decrease in velocity after each bounce, which is not what I expected.\n\nI submit the following code to your wizened review:\n\n```\nvar newV:Number;\nif (hero.y < trampoline.y) { newV = hero.velocityY + gravityAccelerationInPixels }\nelse { newV = hero.velocityY + TrampolineActor.SPRING_ACCELERATION }\n\nvar newY:Number = hero.y + newV;\ntrace(\"Coming in: y=\" + hero.y + \" oldVelocity=\" + hero.velocityY + \" newVelocity=\" + newV + \" Change in V: \" + (newV - hero.velocityY) + \". Testing for newY=\" + newY);\n\nif ((hero.y < trampoline.y && newY < trampoline.y) || (hero.y >= trampoline.y && newY >= trampoline.y)) {\n    hero.y = newY;\n    hero.velocityY = newV;\n} else {\n    trace(\"SPLIT\");\n\n    var percent:Number = (trampoline.y - hero.y) / newV; trace(\"Percent: \" + percent);\n    var newVV:Number;\n    if (hero.y < trampoline.y) {\n        // going down!\n        newVV = hero.velocityY + percent * gravityAccelerationInPixels; trace(\"New velocity before split: \" + hero.velocityY + \" Change in V: \" + (newVV - hero.velocityY));\n        newVV += (1 - percent) * TrampolineActor.SPRING_ACCELERATION; trace(\"Percent after split: \" + (1 - percent) + \" Change in V: \" + (newVV - hero.velocityY));\n    } else {\n        // movin on up!\n        newVV = hero.velocityY + percent * TrampolineActor.SPRING_ACCELERATION; trace(\"New velocity before split: \" + hero.velocityY + \" Change in V: \" + (newVV - hero.velocityY));\n        newVV += (1 - percent) * gravityAccelerationInPixels; trace(\"Percent after split: \" + (1 - percent) + \" Change in V: \" + (newVV - hero.velocityY));\n    }\n    trace(\"New velocity: \" + newVV + \" Change in V: \" + (newVV - hero.velocityY));\n\n    hero.velocityY = newVV;\n\n    hero.y += hero.velocityY;\n}\n```\n\n\nAdditional INFO:\nScreen origin is top-left, so y-- = higher up\nMy tic is currently set to 33 ms\ngravityAccelerationInPixels is currently 1.62 (reasonably arbitrary)\nSPRING_ACCELERATION is arbitrarily 6, but I hope to tweak that number to control how far below the trampoline the character can go during the deceleration/absorption cycle.\n\nFor now I'm hoping to have a solution where the velocity on the tic after the character leaves contact with the trampoline is the same (but negative) of the velocity just prior to going in. Heck I've even tried storing and retrieving the entry position and velocity, but that just looks like a hiccup.\n    ", "Answer": "\r\nHere are some debugging techniques for this type of simulation:\n\n\nFirst: Make sure you know what units every single one of your variables and constants is in. For example, if ```\nhero.y```\n is a distance in pixels, then since it is adjusted by ```\nhero.y + newV```\n, it must be the case that ```\nnewV```\n is also in pixels; except that it is supposed to be a speed (distance per time), so it must actually be ```\npixels per frame```\n (where the time step is implicit because you're doing this once per frame).\n\nFor the next debugging steps, it would be better to make sure all your values are expressed in “per second” rather than “per frame”; to do this, introduce a value equal to your timestep in seconds per frame. Then you have ```\nhero.y + newV * timestep```\n and similarly ```\nnewV = hero.velocityY + gravityAccelerationInPixelsPerSecondSquared * timestep```\n.\n\nIt's OK to compute ```\ngravityAccelerationInPixelsPerSecondSquared * timestep```\n as a constant in itself, but make sure that all your hardcoded values do not depend on your timestep, so that you can easily:\nTry decreasing your timestep by some factor k. If doing this reduces your error, then your problem is because your discrete timestep calculations are not matching the perfect integral-over-time answer. If this does not reduce your error, then your simulation is consistent but in some sense “unphysical”.\nTry computing the total energy of your system. That is, sum\n\n\nthe kinetic energy of any moving bodies, 1/2·m·v² (m = mass, v = velocity)\nthe potential energy of any falling bodies, m·g·h (g = gravitational acceleration constant, h = height above an arbitrary reference point)\nthe potential energy of any springs, 1/2·k·d² (k = spring constant, hopefully equal to your \"restitution factor\" (but positive), d = distance displaced from relaxed state)\n\n\nIf you let h = ```\nhero.y - trampoline.y```\n, then for your particular system you have\n\nE = 1/2·m·v² + m·g·max(h, 0) + 1/2·k·(min(h, 0))²\n\n(From my reading of your code, gravity is not applied while the character is on the trampoline; if it is, change max(h, 0) to just h.)\n\nMake sure you do this in consistent dimensions (you can't add pixels per second to pixels) and units (you can't add pixels per second to pixels per frame or to inches per second). Don't forget that squaring squares the units too.\n\nFor your stated goal — the character bouncing up with the same velocity — you have a frictionless system, and so the system's energy should be identical before, during, and after the bounce. If the energy changes, then note when it changes. For example:\n\n\nIf it changes while the character is falling, then your simulation of that case, constant acceleration, is incorrect. A common mistake (which it looks like you've made in your code) is to forget the third term of the formula for position under constant acceleration: ```\nnewPos = pos + velocity * timestep + 1/2 * acceleration * timestep^2```\n, where the acceleration is gravity. (It is also important that you update the position before you update the velocity, so that you are not using \"tomorrow's\" velocity with \"yesterday's\" position in the position calculation.) Try simulating bouncing on a hard surface instead of the trampoline to simplify the situation.\nIf it changes exactly when the character touches or leaves the trampoline, your ```\npercent```\n computation is not achieving its goal.\n\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "What is the logic behind the algorithm\r\n                \r\nI am trying to solve a problem from codility \n\n\n  \"Even sums\"\n\n\nbut am unable to do so. Here is the question below.\n\nEven sums is a game for two players. Players are given a sequence of N positive integers and take turns alternately. In each turn, a player chooses a non-empty slice (a subsequence of consecutive elements) such that the sum of values in this slice is even, then removes the slice and concatenates the remaining parts of the sequence. The first player who is unable to make a legal move loses the game.\n\nYou play this game against your opponent and you want to know if you can win, assuming both you and your opponent play optimally. You move first.\n\nWrite a function:\n\n```\nstring solution(vector< int>& A);```\n\n\nthat, given a zero-indexed array A consisting of N integers, returns a string of format \"X,Y\" where X and Y are, respectively, the first and last positions (inclusive) of the slice that you should remove on your first move in order to win, assuming you have a winning strategy. If there is more than one such winning slice, the function should return the one with the smallest value of X. If there is more than one slice with the smallest value of X, the function should return the shortest. If you do not have a winning strategy, the function should return \"NO SOLUTION\".\n\nFor example, given the following array:\n\n\n  A[0] = 4 A[1] = 5 A[2] = 3 A[3] = 7 A[4] = 2\n\n\nthe function should return \"1,2\". After removing a slice from positions 1 to 2 (with an even sum of 5 + 3 = 8), the remaining array is [4, 7, 2]. Then the opponent will be able to remove the first element (of even sum 4) or the last element (of even sum 2). Afterwards you can make a move that leaves the array containing just [7], so your opponent will not have a legal move and will lose. One of possible games is shown on the following picture\n\nNote that removing slice \"2,3\" (with an even sum of 3 + 7 = 10) is also a winning move, but slice \"1,2\" has a smaller value of X.\n\nFor the following array:\n\n\n  A[0] = 2 A[ 1 ] = 5 A[2] = 4\n\n\nthe function should return \"NO SOLUTION\", since there is no strategy that guarantees you a win.\n\nAssume that:\n\nN is an integer within the range [1..100,000]; each element of array A is an integer within the range [1..1,000,000,000]. Complexity:\n\nexpected worst-case time complexity is O(N); expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified.\nI have found a solution online in python.\n\n```\ndef check(start, end):\n    if start>end:\n        res = 'NO SOLUTION'\n    else:\n        res = str(start) + ',' + str(end)\n\n    return res\n\ndef trans( strr ):\n    if strr =='NO SOLUTION':\n        return (-1, -1)\n    else:\n        a, b = strr.split(',')\n        return ( int(a), int(b) )\n\n\ndef solution(A):\n    # write your code in Python 2.7\n\n    odd_list = [ ind for ind in range(len(A)) if A[ind]%2==1 ] \n\n    if len(odd_list)%2==0:\n        return check(0, len(A)-1)\n\n\n    odd_list = [-1] + odd_list + [len(A)]\n    res_cand = []\n    # the numbers at the either end of A are even\n    count = odd_list[1]\n    second_count = len(A)-1-odd_list[-2]\n    first_count = odd_list[2]-odd_list[1]-1\n    if second_count >= count:\n        res_cand.append(  trans(check( odd_list[1]+1, len(A)-1-count )))\n\n    if first_count >= count:\n        res_cand.append(  trans(check( odd_list[1]+count+1, len(A)-1 )))  \n\n    twosum = first_count + second_count\n    if second_count < count <= twosum:\n        res_cand.append(  trans(check( odd_list[1]+(first_count-(count-second_count))+1, odd_list[-2] )))\n\n    ###########################################\n    count = len(A)-1-odd_list[-2]\n    first_count = odd_list[1]\n    second_count = odd_list[-2]-odd_list[-3]-1\n    if first_count >= count:\n        res_cand.append(  trans(check( count, odd_list[-2]-1 )))\n\n    if second_count >= count:\n        res_cand.append(  trans(check( 0, odd_list[-2]-count-1)) )\n\n    twosum = first_count + second_count\n    if second_count < count <= twosum:\n        res_cand.append(  trans(check( count-second_count, odd_list[-3])) )\n\n\n\n    res_cand = sorted( res_cand, key=lambda x: (-x[0],-x[1]) )\n\n    cur = (-1, -2)\n    for item in res_cand:\n        if item[0]!=-1:\n            cur = item\n\n    return check( cur[0], cur[1] )\n```\n\n\nThis code works and I am unable to understand the code and flow of one function to the the other. However I don't understand the logic of the algorithm. How it has approached the problem and solved it. This might be a long task but can anybody please care enough to explain me the algorithm. Thanks in advance.\n    ", "Answer": "\r\nSo far I have figured out that the number of odd numbers are crucial to find out the result. Especially the index of the first odd number and the last odd number is needed to calculate the important values. \n\nNow I need to understand the logic behind the comparison such as \"if first_count >= count\" and if \"second_count < count <= twosum\".\n\nUpdate:\nHey guys I found out the solution to my question and finally understood the logic of the algorithm.\n\nThe idea lies behind the symmetry of the array. We can never win the game if the array is symmetrical. Here symmetrical is defined as the array where there is only one odd in the middle and equal number of evens on the either side of that one odd.\n\nIf there are even number of odds we can directly win the game.\n\nIf there are odd number of odds we should always try to make the array symmetrical. That is what the algorithm is trying to do. \n\nNow there are two cases to it. Either the last odd will remain or the first odd will remain. I will be happy to explain more if you guys didn't understand it. Thanks.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to evaluate two items of the same list and return their sum if equal?\r\n                \r\nThis is part of an online course homework where we are asked to build a merge function for the 2048 game. The function takes a list as an argument and iterate through it to return another list where the same elements are merged, and the list is updated. \n\nSo far I'm able to check for empty tiles \"zeros\" and return a list that has the rest of the numbers. Code:\n\n```\ndef merge(line):\n\"\"\"\nA function that merges a single row or column in 2048.\n\"\"\"\noutput =  [0]* len(line)\noutput1 = [0]* len(line)\nfor num in line:\n    if num != 0:\n        output.insert(-1,num)\n        del output[0]\n```\n\n\nthe next step where I am stuck is how to evaluate the new list to merge \"sum\" items that are of the same value.\n\nI want to extend the function to something that does this:\n\n```\nfor num in output:\n     if num == \"the next item in list\":\n     return the sum of both items and skip to the next item\n\n     output1.insert(-1, \"the sum of the two items\")\n     del output1[0]\n```\n\n\nwe were provided with tests to run to see if our code is functioning properly\n\n```\n[2, 0, 2, 4] should return [4, 4, 0, 0],\n[0, 0, 2, 2] should return [4, 0, 0, 0],\n[2, 2, 0, 0] should return [4, 0, 0, 0],\n[2, 2, 2, 2, 2] should return [4, 4, 2, 0, 0],\n[8, 16, 16, 8] should return [8, 32, 8, 0]\n```\n\n\nyour help is much appreciated \n    ", "Answer": "\r\nI did it in two steps, too.  Move all the numbers left, removing any zeros.  Then iterate through the list of numbers combining 2 like numbers.  I used itertools.groupby to make the iterating through like numbers easier.\n\n```\ngroupby```\n returns an iterator for each group of like numbers so:\n\n```\n[2,2,0,0]\n```\n\n\nbecomes\n\n```\n[(2, [2, 2]), (0, [0, 0])]\n```\n\n\nIt makes it easier to process each similar group as a separate chunk.\n\nFor groups of similar numbers like ```\n[2,2]```\n or ```\n[2,2,2]```\n, the output will always be a list of half the length and the items in the list will all be ```\n2*n```\n (for odd length lists, there is an extra last element that will just be ```\nn```\n).\n\n```\nfrom itertools import groupby\n\ndef merge(line):\n    cnt = len(line)\n    # Move all numbers left, removing zeros\n    line = [num for num in line if num != 0]\n    out = []\n    # Combine like numbers\n    for num, niter in groupby(line):\n        ncnt = len(list(niter))\n        out.extend([num * 2] * (ncnt // 2))\n        if ncnt % 2:\n            out.append(num)\n    # Right pad the list with zeros to the original line length\n    out.extend([0] * (cnt - len(out)))\n    return out\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to update a rating sequentially?\r\n                \r\nGiven this simple dataset:\n```\ndata <- data.frame(ID=seq(1:15),\n                   H.team=c(\"GS\",\"LAC\",\"MIL\",\"CHA\",\"MIL\",\"ATL\",\"TOR\",\"CHA\",\"LAC\",\"GS\",\"TOR\",\"MIL\",\"ATL\",\"CHA\",\"TOR\"),\n                   A.team=c(\"MIL\",\"CHA\",\"TOR\",\"ATL\",\"GS\",\"MIL\",\"LAC\",\"GS\",\"TOR\",\"ATL\",\"CHA\",\"LAC\",\"GS\",\"MIL\",\"ATL\"),\n                   H.pts=c(94,120,91,84,88,96,93,95,113,85,101,116,86,102,90),\n                   A.pts=c(84,107,99,75,90,105,87,99,94,87,92,106,84,89,89))\ndata\n   ID H.team A.team H.pts A.pts\n1   1     GS    MIL    94    84\n2   2    LAC    CHA   120   107\n3   3    MIL    TOR    91    99\n4   4    CHA    ATL    84    75\n5   5    MIL     GS    88    90\n6   6    ATL    MIL    96   105\n7   7    TOR    LAC    93    87\n8   8    CHA     GS    95    99\n9   9    LAC    TOR   113    94\n10 10     GS    ATL    85    87\n11 11    TOR    CHA   101    92\n12 12    MIL    LAC   116   106\n13 13    ATL     GS    86    84\n14 14    CHA    MIL   102    89\n15 15    TOR    ATL    90    89\n```\n\nI'm trying to calculate a new rating variable (rat) for each team, the results should be:\n```\n   ID H.team A.team H.pts A.pts   h.rbef   a.rbef   h.raft   a.raft\n1   1     GS    MIL    94    84 1500.000 1500.000 1508.487 1491.513\n2   2    LAC    CHA   120   107 1500.000 1500.000 1510.021 1489.979\n3   3    MIL    TOR    91    99 1491.513 1500.000 1481.066 1510.447\n4   4    CHA    ATL    84    75 1489.979 1500.000 1498.279 1491.700\n5   5    MIL     GS    88    90 1481.066 1508.487 1475.842 1513.711\n6   6    ATL    MIL    96   105 1491.700 1475.842 1479.614 1487.928\n7   7    TOR    LAC    93    87 1510.447 1510.021 1516.760 1503.708\n8   8    CHA     GS    95    99 1498.279 1513.711 1491.164 1520.826\n9   9    LAC    TOR   113    94 1503.708 1516.760 1517.357 1503.111\n10 10     GS    ATL    85    87 1520.826 1479.614 1514.361 1486.079\n11 11    TOR    CHA   101    92 1503.111 1491.164 1510.678 1483.597\n12 12    MIL    LAC   116   106 1487.928 1517.357 1497.502 1507.783\n13 13    ATL     GS    86    84 1486.079 1514.361 1490.516 1509.924\n14 14    CHA    MIL   102    89 1483.597 1497.502 1494.213 1486.886\n15 15    TOR    ATL    90    89 1510.678 1490.516 1513.711 1487.483\n```\n\nthe first value of rat is ```\n1500```\n for each team;\nafter a match is played, the value of rat is updated as follow:\n\nrat.after=rat.before+k*(S-E)\n\nwhere S = 1 if the team won, 0 otherwise\nE is the matchup winning probabilities before the match starts, and is defined by the following function:\n```\nwin.probs<- function(h.rbef, a.rbef, hca=64) {\n  h = 10^(h.rbef/400)\n  a = 10^(a.rbef/400)\n  hca = 10^(hca/400)\n  den = a + hca*h\n  h.prob = hca*h / den\n  a.prob = a / den\n  return(c(h.prob,a.prob))\n}\n#example (not run): win.probs(1500,1500)\n```\n\nk is a moving constant defined as follow:\n```\nrat.k<- function(h.pts,a.pts,h.rbef,a.rbef) {\n  ifelse(h.pts-a.pts>0,\n         20*(h.pts-a.pts+3)^0.8/(7.5+0.006*(h.rbef-a.rbef)),\n         20*(-(h.pts-a.pts)+3)^0.8/(7.5+0.006*(-(h.rbef-a.rbef))))\n}\n#example (not run): rat.k(94,84,1500,1500)\n```\n\nI wrote the following update function, that works well on a single match:\n```\nup.rat<- function(h.pts, a.pts, h.rbef, a.rbef, hca=64) {\n    h.prob = win.probs(h.rbef, a.rbef, hca)[1]\n    a.prob = win.probs(h.rbef, a.rbef, hca)[2]\n    h.win = ifelse(h.pts-a.pts>0,1,0)\n    a.win = ifelse(h.pts-a.pts<0,1,0)\n    k = rat.k(h.pts,a.pts,h.rbef,a.rbef)\n    h.raft = h.rbef + k * (h.win - h.prob) \n    a.raft = a.rbef + k * (a.win - a.prob) \n  return(c(h.rbef,a.rbef,h.raft,a.raft))\n}\n#example (not run): up.rat(94,84,1500,1500)\n```\n\nand, applying it \"manually\" to the data I found the results above. For example the first game is ```\nGS```\n vs ```\nMIL```\n: before playing the match both teams has a rating of ```\n1500```\n, after the game the home team has ```\n1508.487```\n, while the away team has ```\n1491.513```\n (it's a zero-sum rating). So ```\nGS```\n will start next game with this updated rating, same for ```\nMIL```\n.\nCan someone please help me founding a way to do this \"automatically\" as my original data has way more than 15 rows? My custom functions seems to work good, what I found really challenging here is to update the rating, because teams don't necessary play a match at home and the following away: the value of rating before is equal to rating after of the previous match both it was played home and away .\nNote also that the number of matches played is not necessary the same for each team (here for example ```\nMIL```\n played 6 matches, ```\nLAC```\n 4, and the others 5).\nThanks to anyone who will try to give me any hint or help.\n    ", "Answer": "\r\nWe could create a function\n```\nf1 <- function(dat, start_val) {\n       dat[c(\"h.rbef\", \"a.rbef\", \"h.raft\", \"a.raft\")] <- start_val\n       for(i in seq_len(nrow(data))) {\n       \n    \n        if(i == 1) {\n    \n           h.rbef <- dat$h.rbef[1]\n           a.rbef <- dat$a.rbef[1]\n    \n    \n        } else {\n    \n          hh.ind <- with(dat, tail(which(H.team[seq_len(i-1)] %in% H.team[i]), 1))\n          ha.ind <- with(dat, tail(which(A.team[seq_len(i-1)] %in% H.team[i]), 1))  \n      \n          aa.ind <- with(dat, tail(which(A.team[seq_len(i-1)] %in% A.team[i]), 1))\n          ah.ind <- with(dat, tail(which(H.team[seq_len(i-1)] %in% A.team[i]), 1))\n      \n          if(length(hh.ind) > 0 & length(ha.ind) > 0 ) {\n               ix <- which.max(c(hh.ind, ha.ind))\n               mx <- max(hh.ind, ha.ind)\n               if(ix == 1) {\n                 h.rbef <- dat$h.raft[mx]\n           \n               } else {\n                 h.rbef <- dat$a.raft[mx]\n           \n               }\n      \n          } else {\n        \n                 if(length(hh.ind) > 0) {\n            \n                 h.rbef <- dat$h.raft[hh.ind]\n      \n                }   else if(length(ha.ind) > 0) {\n            \n                 h.rbef <- dat$a.raft[ha.ind]\n      \n                } else {\n      \n                 h.rbef <- dat$h.rbef[i]\n               }\n          }\n      \n          if(length(aa.ind) > 0 & length(ah.ind) > 0 ) {\n               iy <- which.max(c(aa.ind, ah.ind))\n               my <- max(aa.ind, ah.ind)\n               if(iy == 1) {\n                 a.rbef <- dat$a.raft[my]\n           \n               } else {\n                 a.rbef <- dat$h.raft[my]\n           \n               }\n      \n          } else {\n      \n            if(length(aa.ind) > 0) {\n      \n               a.rbef <- dat$a.raft[aa.ind]\n      \n                }   else if(length(ah.ind) > 0) {\n      \n                 a.rbef <- dat$h.raft[ah.ind]\n      \n                } else {\n      \n                 a.rbef <- dat$a.rbef[i]\n             }\n             }\n      \n      \n      \n      \n    \n        }    \n    \n    \n           tmp <- up.rat(dat$H.pts[i], dat$A.pts[i], h.rbef, a.rbef)\n            dat[i, c(\"h.rbef\", \"a.rbef\", \"h.raft\", \"a.raft\")] <- tmp\n       }\n       return(dat)\n\n\n}\n\n\n\n```\n\n-testing\n```\nout <- f1(data, 1500)\n```\n\n-output\n```\nout\n#   ID H.team A.team H.pts A.pts   h.rbef   a.rbef   h.raft   a.raft\n#1   1     GS    MIL    94    84 1500.000 1500.000 1508.487 1491.513\n#2   2    LAC    CHA   120   107 1500.000 1500.000 1510.021 1489.979\n#3   3    MIL    TOR    91    99 1491.513 1500.000 1481.066 1510.447\n#4   4    CHA    ATL    84    75 1489.979 1500.000 1498.279 1491.700\n#5   5    MIL     GS    88    90 1481.066 1508.487 1475.842 1513.711\n#6   6    ATL    MIL    96   105 1491.700 1475.842 1479.614 1487.928\n#7   7    TOR    LAC    93    87 1510.447 1510.021 1516.760 1503.708\n#8   8    CHA     GS    95    99 1498.279 1513.711 1491.164 1520.826\n#9   9    LAC    TOR   113    94 1503.708 1516.760 1517.357 1503.111\n#10 10     GS    ATL    85    87 1520.826 1479.614 1514.361 1486.079\n#11 11    TOR    CHA   101    92 1503.111 1491.164 1510.678 1483.597\n#12 12    MIL    LAC   116   106 1487.928 1517.357 1497.501 1507.783\n#13 13    ATL     GS    86    84 1486.079 1514.361 1490.516 1509.924\n#14 14    CHA    MIL   102    89 1483.597 1497.501 1494.214 1486.885\n#15 15    TOR    ATL    90    89 1510.678 1490.516 1513.710 1487.484\n\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Calculation of Points in a Database in 3rd NF\r\n                \r\nI have a database where the results from a shooter game are stored. I put them to 3NF to allow extensions of the system. So it looks like this:\n\n```\nPlayer\n-------------------\nGameId integer\nPlayerId integer\nTeamId integer\n\nHits\n-------------------\nGameId integer \nFromId integer\nToId integer\nHits integer\n```\n\n\nSo basically for every game there is a ID and every Player and Team has its ID (with their names stored in other databases)\n\nNow I want to calculate points for each player. I need the points for each game but more importantly the total per player. The points are basically: 3 Points for each hit on opponent, -2 points for each hit of a team member and -2 points for each hit taken.\nAlone the calculation of the number of team hits requires a JOIN with 3 tables and I fear for performance in production environment. (Each game has ~8 players-> PlayerDB-Size is 8n and HitsDB-Size is (8-1)^2*n)\n\nAnd at the end: I need to calculate the points per player for each game and sum those up because the minimum points per game should be zero. And finally get a rank for each player (player x has the 2nd most total points etc)\n\nI feel like I'm getting lost in overly complicated queries that will kill the database' performance at some point.\n\nCould anyone judge the design and maybe give me some pointers where to start looking further? I though about storing the TeamHits and Points per Game in the players Database (Points for summing over them, teamHits for statistical purposes) but that would of course break normalization.\n\nPS: I'm working with PHP 5 and MYSQL. I also thought about getting each game from the database, calculating the points in PHP (which I'm already doing when I show the game) and writing this back (optimally on putting in the game to the DB but also when the parameters for the points change)\n\nEdit: Idea to avoid subselects would be:\n\n```\nSELECT p.*, SUM(h.Hits) AS TeamHits, SUM(h2.Hits) as Hits\nFROM player p\nLEFT JOIN\n  (hits h\n    INNER JOIN player p2\n    ON h.GameId=p2.GameId AND h.ToId=p2.PlayerId\n  )\nON p.GameId=p2.GameId AND h.FromId=p.PlayerId AND p.TeamId=p2.TeamId\nGROUP BY p.PlayerId, p.GameId\nLEFT JOIN hits h2\nON h2.GameId=p.GameId AND h2.FromId=p.PlayerId\n```\n\n\nBut of course this does not work. Is it even possible to combine groupings with joins or will I have to use subqueries?\nBest I have is:\n\n```\nSELECT p.PlayerId, SUM((-2-3)*IFNULL(th.TeamHits, 0) + (3)*IFNULL(h.Hits, 0) + (-2)*IFNULL(ht.HitsTaken, 0)) AS Points\nFROM player p\nLEFT JOIN\n    (SELECT p.GameId, p.PlayerId, SUM(h.Hits) AS TeamHits\n    FROM player p\n    INNER JOIN hits h\n    ON h.GameId=p.GameId AND p.PlayerId=h.FromId\n    INNER JOIN player p2\n    ON p.GameId=p2.GameId AND p2.PlayerId=h.ToId AND p.TeamId=p2.TeamId\n    GROUP BY p.PlayerId, p.GameId) th\nON p.GameId=th.GameId AND p.PlayerId=th.PlayerId\nLEFT JOIN\n    (SELECT p.GameId, p.PlayerId, SUM(h.Hits) AS Hits\n    FROM player p\n    INNER JOIN hits h\n    ON h.GameId=p.GameId AND p.PlayerId=h.FromId\n    GROUP BY p.PlayerId, p.GameId) h\nON p.GameId=h.GameId AND p.PlayerId=h.PlayerId\nLEFT JOIN\n    (SELECT p.GameId, p.PlayerId, SUM(h.Hits) AS HitsTaken\n    FROM player p\n    INNER JOIN hits h\n    ON h.GameId=p.GameId AND p.PlayerId=h.ToId\n    INNER JOIN player p2\n    ON p.GameId=p2.GameId AND p2.PlayerId=h.FromId AND p.TeamId!=p2.TeamId\n    GROUP BY p.PlayerId, p.GameId) ht\nON p.GameId=ht.GameId AND p.PlayerId=ht.PlayerId\nGROUP BY p.PlayerId\n```\n\n\nFiddle: http://sqlfiddle.com/#!9/dc0cb/4\n\nCurrent problem: For a database with about 10,000 games calculating the points for all players takes about 18s. This is unusable, so I need to improve this...\n    ", "Answer": "\r\nJoins are not that expensive, subqueries are. as long as you can avoid subqueries you're not hitting too bad.\n\nRemember, a database is built for this stuff these days.\nJust make sure you have the proper indexes on the right fields so its optimised. Like teamID and GameID and playerID should be indexes.\n\nJust run it in phpmyadmin and see how many milliseconds it takes to execute. if it takes more than 50 its a heavy query, but usually its pretty hard to hit this... I once managed to make a very heavy query that joined 100.000+ rows out of different tables and views and still did that in 5ms...\n\nWhat numbers of requests a hour are we talking about? 200 players a day? 200.000 players a day? How often do the requests happen? 10 per second per player? once a minute? how loaded is your database?\n\nI think that all these parameters are low, so you shouldnt worry about this optimisation yet.\nGet your game up and running, clean up the php code where real gains can be had, and stay clear of complex subqueries or views.\n\nAs long as your table does joins and unions its pretty darn fast. and if you must do a subquery see if there is not an alternative way by using a linking table to link certain results to certain other tables so you can do a join instead of a subquery.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Simple encryption - Sum of Hashes in C\r\n                \r\nI am attempting to demonstrate a simple proof of concept with respect to a vulnerability in a piece of code in a game written in C.\n\nLet's say that we want to validate a character login. The login is handled by the user choosing ```\nn```\n items, (let's just assume ```\nn=5```\n for now) from a graphical menu. The items are all medieval themed:\n\neg:\n\n```\n _______________________________\n|           |           |       |\n| Bow       | Sword     | Staff |\n|-----------|-----------|-------|\n| Shield    | Potion    | Gold  |\n|___________|___________|_______|\n```\n\n\nThe user must click on each item, then choose a number for each item.\n\nThe validation algorithm then does the following:\n\n\nDetermines which items were selected\nDrops each string to lowercase (ie: ```\nBow```\n becomes ```\nbow```\n, etc)\nCalculates a simple string hash for each string (ie: `bow => b=2, o=15, w=23, sum = (2+15+23=40)\nMultiplies the hash by the value the user selected for the corresponding item; This new value is called the ```\nkey```\n\nSums together the ```\nkeys```\n for each of the selected items; this is the final validation hash\nIMPORTANT: The validator will accept this hash, along with non-zero multiples of it (ie: if the final hash equals 1111, then 2222, 3333, 8888, etc are also valid).\n\n\nSo, for example, let's say I select:\n\n```\nBow (1)\nSword (2)\nStaff (10)\nShield (1)\nPotion (6)\n```\n\n\nThe algorithm drops each of these strings to lowercase, calculates their string hashes, multiplies that hash by the number selected for each string, then sums these keys together.\n\neg:\n\n```\nFinal_Validation_Hash = 1*HASH(Bow) + 2*HASH(Sword) + 10*HASH(Staff) + 1*HASH(Shield) + 6*HASH(Potion)```\n\n\nBy application of Euler's Method, I plan to demonstrate that these hashes are not unique, and want to devise a simple application to prove it.\n\nin my case, for 5 items, I would essentially be trying to calculate:\n\n```\n(B)(y) = (A_1)(x_1) +  (A_2)(x_2) + (A_3)(x_3) + (A_4)(x_4) + (A_5)(x_5)```\n\n\nWhere:\n\n```\nB is arbitrary\nA_j are the selected coefficients/values for each string/category\nx_j are the hash values for each string/category\ny is the final validation hash (eg: 1111 above)\nB,y,A_j,x_j are all discrete-valued, positive, and non-zero (ie: natural numbers)\n```\n\n\nCan someone either assist me in solving this problem or point me to a similar example (ie: code, worked out equations, etc)? I just need to solve the final step (ie: (B)(Y) = ...).\n\n\n\nIn the end, I wrote a recursive algorithm that goes ```\nn```\n levels deep, then handles incrementing, testing, etc, for all remaining possible combinations. Not very efficient, but it works. I could provide it upon request (too large to post here).\n    ", "Answer": "\r\nIt seems to me that most users will select fairly small numbers for each item (after all \"2\" is easier for them to remember than \"438483\").  \n\nGiven that constraint, brute force is probably actually reasonable.\n\nSimply generating all possible input values for the 5 symbols plus a number say in the range of 1..99, computing the resulting hash, and counting (e.g. using a Dictionary) the number of distinct combinations that yield a given hash should give an empirical understanding of the hash distribution for the most probable input values.\n\nFrom there I would look at how many distinct hash values were actually generated (out of the 2^32 possible hash values if the hash is an Int32), as well as look for the hash values that are generated with particular frequency (have a high count in the Dictionary).\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Mixed strategy approximations in a large game\r\n                \r\nI'm new to game theory and was thinking about how to find mixed strategies for a particular game, and furthermore how to find good mixed strategy approximations of a game that may be too large to compute.\n\nThe setup goes something like this:\n\n\nWe have a list of 2600 locations listed in descending order of size of location, say a100, b100, .., z100, a99, b99, .., z99, ... , a1, b1, .., z1 (so the first 26 locations are of size 100 etc)\nWe cycle through locations in order and group them in to districts. Districts need to be of a certain size (lets say 100 for now but we can vary the threshold if we wish), a list of districts will look something like this then: {a100}, {b100}, .., {z100}, {a99,b99}, {c99,d99}, .., {y50,z50}, {a49,b49,c49},...,{a33,b33,c33,d33},....\na user wants to visit a location, the user does not have any preference of which location to visit\nan adversary can control up to 10% the total size of the locations. If a user visits a district in which an adversary controls at least one of the locations then the user is compromised , otherwise the user is safe. (note: the total size of locations is 131300)\n\n\nSo my questions are:\n\nFirstly how would I draw up the zero sum pay off matrix given the set up?\n\nHow do I find the mixed strategy for both user and adversary? Should I just randomly select a bunch of locations an adversary can control, find the mixed strategies in this subgame and then repeat this process many times? Is it feasible to find an exact solution over such a large matrix?\n\nI'm not even sure whether it makes sense to have this as a one shot game or a sort of hide and seek kind of game?\n\nI apologise for length of the post and the vague nature of my questions but I'm just starting out learning about game theory and couldn't find much literature relating to questions like the ones I posed. Thanks in advance.\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Resetting score in AS3\r\n                \r\nI am creating a \"dice spinner\" game by using Flash action script 3, The rules are if the player rolls a 7 or 11 on first throw then they win but if the user rolls a 2,3 or 12 on the first throw then they lose. If the first throw is 4,5,6,8,9 or 10 then that sum becomes the point and that user has to make a point by rolling again until they make the point (they win) or they throw a 7 (they lose)\n\nI have succesfully created the functions for it to spin, generate a random between 1-6 on each \"dice\" and to add the points up from total but my problem is if the user wins or lose. I can't figure out on how to reset the points back to zero when the user rerolls from last attempt \n\nThe code is blow.\n\n```\nimport flash.events.MouseEvent;\n\nspinner_mc.stop();\nspinner2_mc.stop();\n\nroll_btn.addEventListener(MouseEvent.CLICK, startspin);\nstop_btn.addEventListener(MouseEvent.CLICK, stopspin);\nspinner_mc.addEventListener(Event.ENTER_FRAME, spin);\nspinner2_mc.addEventListener(Event.ENTER_FRAME, spin)\n\nvar spinning = false\n\nfunction spin(evt){\n    if(spinning){\n        spinner_mc.rotation += 5\n        spinner2_mc.rotation += 5\n    }\n} //end spin function\n\nfunction startspin(mEvt:MouseEvent){\n    spinning = true\n\n} //end startspin function\n\nvar points:int = 0;\nfunction stopspin (mEvt){\n    if (spinning){\n        spinning = false\n        var nextVal = newVal()\n        var nextVal2 = newVal2()\n        var addPoints = nextVal + nextVal2\n        points += nextVal + nextVal2\n        spinner_mc.gotoAndStop(nextVal)\n        spinner_mc.rotation = 0\n        spinner2_mc.gotoAndStop(nextVal2)\n        spinner2_mc.rotation = 0\n        value_txt.text = \"point = \" + points + \", new value \" + addPoints\n    }\n    if ((points == 0) && (addPoints == 7) || (addPoints == 11))\n    {\n        info_txt.text = \"You win!! You rolled a 7 or 11 on first throw!\"\n\n    }\n    if ((points == 0) && (addPoints == 2) || (addPoints == 3) || (addPoints == 12))\n    {\n        info_txt.text =\"You lose! You rolled a 2, 3 or 12 on first throw!\"\n    }\n\n} // end stopspin function\n\nfunction newVal(){\n    var temp:int;\n    temp = Math.random() * 6 + 1;\n    return temp;\n}\n\nfunction newVal2(){\n    var temp:int\n    temp = Math.random() * 6 + 1;\n    return temp;\n}\n```\n\n    ", "Answer": "\r\nYou need to check for points and ```\naddPoints```\n before you add points to the player, while your code has check for ```\npoints```\n outside the ```\nif (spinning)```\n block. This makes your checks go awry even if ```\npoints```\n is yet zero. So, you first get the spin values, then check, then assign values.\n\n```\nfunction stopspin(evt:MouseEvent):void {\n    if (!spinning) return; // this is shorter than wrapping the entire function\n    // body into a single \"if (spinning)\" block. If we don't spin, get out\n    spinning=false;\n    var nextVal1:int=newVal();\n    var nextVal2:int=newVal(); // no need of two functions doing the same :)\n    var addPoints:int=nextVal1+nextVal2;\n    spinner_mc.gotoAndStop(nextVal1);\n    spinner_mc.rotation = 0;\n    spinner2_mc.gotoAndStop(nextVal2);\n    spinner2_mc.rotation = 0; // give values to spinners\n    // now check phase\n    if (points==0) {\n        // this means first throw.\n        if ((addPoints==7) || (addPoints==11)) {\n            // player wins, insert win code\n        } else if((addPoints==2)||(addPoints==3)||(addPoints==12)) {\n            // player loses, insert lose code\n        } else {\n            points=addPoints; // otherwise making the player do second throw\n            // add other code, say inform the player that he has to throw again\n        }\n    } else {\n        // not a first throw. We have the \"point\" in \"points\" variable right now\n        if (addPoints==points) {\n            // player wins with second throw, add win code\n            points=0; // okay, back to first throw\n        } else if (addPoints==7) {\n            // player loses second throw, add relevant code\n            points=0; // again, back to first throw\n        } else {\n            // else no match, oh well.\n        }\n    }\n}\n```\n\n\nAlso, you should know better how to use event listeners if you want several objects to listen with a single function (in your case, ```\nspin```\n). See, right now you have your ```\nspin```\n function to update both spinners, and you have it being called twice per frame, so your spinners are spinning at twice the desired speed. You can get the actively listening movie clip using the ```\nEvent```\n class object passed into the listener, you need to get its ```\ntarget```\n property. So, your listener can be rewritten like this:\n\n```\nfunction spin(evt:Event):void {\n    var mc:DisplayObject=evt.target; // the object that's listening\n    mc.rotation+=5; // now turn it.\n}\n```\n\n\nAnd last, please place semicolons at the end of each line. Even if AS3 compiler does not strictly require this, it can save you from some really weird mistakes. \n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Why does this simulation \"explode\"?\r\n                \r\nI am attempting to simulate a steerable vehicle (plane, hovercraft, boat) in a fluid (gas or liquid, e.g. air or water).\nMy JavaScript implementation is based on the 3D rigid body airplane simulator from Physics for Game Developers ported to ```\nThree.js```\n's ```\nVector3```\n, ```\nMatrix3```\n and ```\nQuaternion```\n classes.\nApplying a thrust force to the vehicle causes it to accelerate and move through the medium. It's speed causes drag and lift on a control surface / \"rudder\", depending on its angle.\nThe resulting force is offset from the common center of gravity of the vehicle parts (\"main\" and \"rudder\") and as such also causes a moment (torque) that causes angular motion of the vehicle (steering).\nDrag and lift are quadratic to the speed.\nThus drag will limit the maximum speed given a thrust force.\nIn steady state (no acceleration) the sum of all forces is zero, and that means, the sum of drag and lift are equal and opposing the thrust.\nThis is where the program can start to oscillate (either stable or it \"explodes\"), depending on the parameters.\nOscillation seems to happen when the control surface's normal vector and the drag vector become orthogonal, as then the dot product becomes zero, which is used to determine the angle of attack (control surface in medium), which then is also approaching zero.\nThis happens later rather than sooner with:\n\nsmaller ```\nRHO```\n (affects both, lift and drag)\nsmaller lift coefficient ```\nlc```\n\nlarger drag coefficient ```\ndc```\n (larger drag means less acceleration and speed)\n\nThis JSFiddle shows the problem with a top view (Z is up, vehicle moves along X on XY-plane) on a vector representation of some of the forces at play:\nhttps://jsfiddle.net/ghcse56f/ (easier to play with than snippets here on SO)\nIt includes a crude plot of some values (different scales).\nCalculation of lift and drag start around line 215.\nWhy is this problem happening and how can it be fixed?\n\nI've updated the demo to use a lift coefficient that is proportional to the angle of attack, reduced the drag coefficient and increased RHO - the simulation falls apart in step 227.\n\r\n\r\n```\n//import * as THREE from \"three\";\n//import { Euler, Matrix3, Vector3 } from \"three\";\n\n// colors\nconst cred = 0xff0000;\nconst cgreen = 0x00ff00;\nconst cblue = 0x0000ff;\nconst cyellow = 0xffff00;\nconst ccyan = 0x00ffff;\nconst cmagenta = 0xff00ff;\nconst cblack = 0x000000;\nconst cwhite = 0xffffff;\n\n/** degree to radian */\nfunction rad(deg) {\n  return (deg / 180) * Math.PI;\n}\n/** radian to degree */\nfunction deg(rad) {\n  return (rad / Math.PI) * 180;\n}\n\n// string of vector components\nfunction vstr(v) {\n  return `${v.x}, ${v.y}, ${v.z}, `\n}\n\n\nclass Vehicle {\n  constructor(scene) {\n\n    this.rudder = 10; // [deg]\n    this.thrust = 1; // [N]\n\n    // this.length = 0.3;\n    // this.width = 0.15;\n\n    this.fMass = 0.0; // total mass\n    this.mInertia = new THREE.Matrix3(); // mass moment of inertia in body coordinates\n    this.mInertiaInverse = new THREE.Matrix3(); // inverse of mass moment of inertia\n    this.vPosition = new THREE.Vector3(0, 0, 0.001); // position in earth coordinates\n    this.vVelocity = new THREE.Vector3(); // velocity in earth coordinates\n    this.vVelocityBody = new THREE.Vector3(.0, 0, 0); // velocity in body coordinates\n    this.vAngularVelocity = new THREE.Vector3(); // angular velocity in body coordinates\n    this.vEulerAngles = new THREE.Vector3(0, 0, 0); // Euler angles in body coordinates\n    this.qOrientation = new THREE.Quaternion(); // orientation in earth coordinates\n    this.qOrientation.setFromEuler(new THREE.Euler().setFromVector3(this.vEulerAngles));\n    this.vForces = new THREE.Vector3(); // total force on body\n    this.vMoments = new THREE.Vector3(); // total moment (torque) on body\n\n    this.elements = [{\n        type: \"main\",\n        fMass: 1.0,\n        vDCoords: new THREE.Vector3(0, 0.0, 0.0),\n        vCGCoords: null,\n        vLocalInertia: new THREE.Vector3(.001, .001, .001), // TODO: \n        rotates: false,\n        fIncidence: 0.0,\n        fDihedral: 90.0,\n        fArea: 0.5,\n      },\n      {\n        type: \"rudder\",\n        fMass: .01,\n        vDCoords: new THREE.Vector3(-.1, 0.0, 0.0),\n        vCGCoords: null,\n        vLocalInertia: new THREE.Vector3(.001, .001, .001), // TODO: \n        rotates: true,\n        fIncidence: this.rudder,\n        fDihedral: 90.0,\n        fArea: 0.1,\n      },\n    ];\n\n    // Calculate the vector normal (perpendicular) to each lifting surface.\n    // This is required when you are calculating the relative air velocity for lift and drag calculations.\n    for (let e of this.elements) {\n      let inc = rad(e.fIncidence);\n      let dih = rad(e.fDihedral);\n      e.vNormal = new THREE.Vector3(\n        Math.sin(inc), // \n        Math.cos(inc) * Math.sin(dih), // \n        Math.cos(inc) * Math.cos(dih) // \n      );\n      e.vNormal.normalize();\n    }\n\n    // Calculate total mass\n    for (let e of this.elements) {\n      this.fMass += e.fMass;\n    }\n\n    // Calculate combined center of gravity location\n    let vMoment = new THREE.Vector3();\n    for (let e of this.elements) {\n      vMoment.add(e.vDCoords.clone().multiplyScalar(e.fMass))\n    }\n    let vCG = vMoment.divideScalar(this.fMass);\n\n    // Calculate coordinates of each element with respect to the combined CG\n    for (let e of this.elements) {\n      e.vCGCoords = e.vDCoords.clone().sub(vCG);\n    }\n\n    // (This inertia matrix (tensor) is in body coordinates)\n    // Here we’re using a vector to represent the three local moment of inertia terms \n    // and we’re also assuming that the local products of inertia are zero for each element.\n    let Ixx = 0,\n      Iyy = 0,\n      Izz = 0,\n      Ixy = 0,\n      Ixz = 0,\n      Iyz = 0;\n    for (let e of this.elements) {\n      Ixx += e.vLocalInertia.x + e.fMass * (e.vCGCoords.y ** 2 + e.vCGCoords.z ** 2);\n      Iyy += e.vLocalInertia.y + e.fMass * (e.vCGCoords.x ** 2 + e.vCGCoords.z ** 2);\n      Izz += e.vLocalInertia.z + e.fMass * (e.vCGCoords.x ** 2 + e.vCGCoords.y ** 2);\n      Ixy += e.fMass * (e.vCGCoords.x * e.vCGCoords.y);\n      Ixz += e.fMass * (e.vCGCoords.x * e.vCGCoords.z);\n      Iyz += e.fMass * (e.vCGCoords.y * e.vCGCoords.z);\n    }\n    // mass, inertia matrix and the inverse\n    this.mInertia.e11 = Ixx;\n    this.mInertia.e12 = -Ixy;\n    this.mInertia.e13 = -Ixz;\n\n    this.mInertia.e21 = -Ixy;\n    this.mInertia.e22 = Iyy;\n    this.mInertia.e23 = -Iyz;\n\n    this.mInertia.e31 = -Ixz;\n    this.mInertia.e32 = -Iyz;\n    this.mInertia.e33 = Izz;\n\n    this.mInertiaInverse = this.mInertia.clone().invert();\n\n\n    // three.js\n    this.object = new THREE.Group();\n\n    const axes = new THREE.AxesHelper(0.1);\n    axes.position.copy(vCG);\n    axes.setColors(cblack, new THREE.Color('rgb(50%,50%,50%)'), new THREE.Color('rgb(50%,50%,50%)'));\n    this.object.add(axes);\n\n    this.Athrust = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), vCG, 1, cgreen);\n    this.object.add(this.Athrust);\n\n    this.Anormal = new THREE.ArrowHelper(this.elements[1].vNormal.clone(), this.elements[1].vCGCoords, 1, ccyan);\n    this.object.add(this.Anormal);\n\n    this.Alift = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), this.elements[1].vCGCoords, 1, cblue);\n    this.object.add(this.Alift);\n    this.Adrag = new THREE.ArrowHelper(new THREE.Vector3(-1, 0, 0), this.elements[1].vCGCoords, 1, cred);\n    this.object.add(this.Adrag);\n    this.Aresultant = new THREE.ArrowHelper(new THREE.Vector3(-1, 0, 0), this.elements[1].vCGCoords, 1, cyellow);\n    this.object.add(this.Aresultant);\n    this.Aforce = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), vCG, 1, cwhite);\n    this.object.add(this.Aforce);\n    this.Amoment = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), vCG, 1, cmagenta);\n    this.object.add(this.Amoment);\n\n    // add self to scene\n    scene.add(this.object);\n\n  } // ctor\n\n\n  physics(dt) {\n\n    // reset forces and moments:\n    let vFb = new THREE.Vector3();\n    let vMb = new THREE.Vector3();\n    this.vForces.set(0, 0, 0);\n    this.vMoments.set(0, 0, 0);\n\n    // thrust vector acts through the CG\n    let Thrust = new THREE.Vector3(1, 0, 0).multiplyScalar(this.thrust);\n\n    // forces and moments in body space:\n    let vLocalVelocity = new THREE.Vector3();\n    let fLocalSpeed = 0;\n    let vDragVector = new THREE.Vector3();\n    let fAttackAngle = 0;\n    let tmp = 0.0;\n    let vResultant = new THREE.Vector3();\n\n    let vtmp = new THREE.Vector3();\n\n    // \"rudder\" forces only\n    for (let e of this.elements) {\n      if (e.type == \"main\")\n        continue;\n\n      // Calculate local velocity at element\n      // The local velocity includes the velocity due to linear motion of the airplane,\n      // plus the velocity at each element due to the rotation of the airplane.\n      // Here's the rotational part\n      vtmp.crossVectors(this.vAngularVelocity, e.vCGCoords);\n      vLocalVelocity.addVectors(this.vVelocityBody, vtmp);\n\n      // Calculate local air speed\n      fLocalSpeed = vLocalVelocity.length();\n      pixel(fLocalSpeed * 150, 'green');\n\n      // Find the direction in which drag will act.\n      // Drag always acts inline with the relative velocity but in the opposing direction\n      if (fLocalSpeed > 0) {\n        vDragVector = vLocalVelocity.clone().divideScalar(-fLocalSpeed);\n      }\n\n      // Find the direction in which lift will act.\n      // Lift is always perpendicular to the drag vector\n      const vDN = new THREE.Vector3().crossVectors(vDragVector, e.vNormal)\n      let vLiftVector = new THREE.Vector3().crossVectors(vDN, vDragVector);\n      vLiftVector.normalize();\n      console.log(\"vliftVector\", vstr(vLiftVector));\n\n      // Find the angle of attack.\n      // The attack angle is the angle between the lift vector and the element normal vector.\n      // Note, the sine of the attack angle is equal to the cosine of the angle between the drag vector and the normal vector.\n      tmp = vDragVector.dot(e.vNormal);\n      console.log(\"vDragVector\", vstr(vDragVector));\n      console.log(\"e.vNormal\", vstr(e.vNormal));\n      console.log(\"tmp\", tmp);\n\n      if (tmp > 1) tmp = 1;\n      else if (tmp < -1) tmp = -1;\n      fAttackAngle = deg(Math.asin(tmp));\n      console.log(\"fAttackAngle\", fAttackAngle);\n      pixel(fAttackAngle * 50, 'magenta');\n\n\n      // Determine the resultant force (lift and drag) on the element.\n\n      // fluid density\n      // const RHO = 1.225;       // kg/m^3 for AIR\n      const RHO = 100; // kg/m^3 for WATER\n      tmp = 0.5 * RHO * fLocalSpeed ** 2 * e.fArea;\n\n      // lift coefficient\n      // sign fixes vector direction\n      // depends on angle of incidence - constant to simplify things\n      let lc = 0;\n      //if (fAttackAngle < 0)\n      //  lc = -.1;\n      //if (fAttackAngle > 0)\n      //  lc = .1;\n      lc = fAttackAngle / 2;\n\n      // drag coefficient\n      // depends on angle of incidence - constant to simplify things\n      const dc = .01;\n\n      let vLift, vDrag;\n      vLift = vLiftVector.multiplyScalar(lc);\n      vDrag = vDragVector.multiplyScalar(dc);\n\n      this.Alift.setDirection(vLift.clone().normalize());\n      this.Alift.setLength(vLift.length() * tmp);\n      this.Adrag.setDirection(vDrag.clone().normalize());\n      this.Adrag.setLength(vDrag.length() * tmp);\n\n      pixel(vLift.length() * tmp * 150, 'blue');\n      pixel(vDrag.length() * tmp * 150, 'red');\n\n      const vLiftDrag = vDrag.add(vLift);\n      vResultant = vLiftDrag.multiplyScalar(tmp);\n\n      this.Aresultant.setDirection(vResultant.clone().normalize());\n      this.Aresultant.setLength(vResultant.length());\n\n      // Keep a running total of these resultant forces (total force)\n      vFb.add(vResultant);\n\n      // Calculate the moment about the CG of this element's force\n      // and keep a running total of these moments (total moment)\n      vtmp.crossVectors(e.vCGCoords, vResultant);\n      vMb.add(vtmp);\n\n    } // elements\n\n    // force\n    pixel(vFb.length() * 150, 'yellow'); // drag and lift\n\n    // Now add the thrust\n    vFb.add(Thrust);\n\n    pixel(vFb.length() * 150, 'white'); // total\n    this.Aforce.setDirection(vFb.clone().normalize());\n    this.Aforce.setLength(vFb.length());\n\n    // stop if sim \"explodes\"\n    if (isNaN(vFb.length()))\n      return -1;\n\n    // Convert forces from model space to earth space\n    this.vForces = vFb.clone().applyQuaternion(this.qOrientation);\n\n\n    // moments\n    this.vMoments.add(vMb);\n\n    this.Amoment.setDirection(vMb.clone().normalize());\n    this.Amoment.setLength(vMb.length());\n\n\n    // INTEGRATOR (EULER)\n\n    // calculate the acceleration in earth space:\n    let vAe = this.vForces.clone().divideScalar(this.fMass);\n\n    // calculate the velocity in earth space:\n    vAe.multiplyScalar(dt);\n    this.vVelocity.add(vAe);\n\n    // calculate the position in earth space:\n    let vdp = this.vVelocity.clone().multiplyScalar(dt)\n    this.vPosition.add(vdp);\n\n\n    // calculate the angular velocity in body space:\n    let mv = this.vAngularVelocity.clone().applyMatrix3(this.mInertia);\n    let cp = new THREE.Vector3().crossVectors(this.vAngularVelocity, mv);\n    let sub = this.vMoments.clone().sub(cp);\n    sub.multiplyScalar(dt);\n    this.vAngularVelocity.add(sub.applyMatrix3(this.mInertiaInverse));\n\n    // calculate the new rotation quaternion:\n    // Quaternion * Vector\n    let q = this.qOrientation.clone();\n    let v = this.vAngularVelocity.clone();\n    let vq = new THREE.Quaternion(v.x, v.y, v.z, 0);\n    let qv = q.multiply(vq);\n\n    // Q * Scalar\n    const scalar = 0.5 * dt;\n    qv.x *= scalar;\n    qv.y *= scalar;\n    qv.z *= scalar;\n    qv.w *= scalar;\n\n    // Q+Q\n    this.qOrientation.x += qv.x;\n    this.qOrientation.y += qv.y;\n    this.qOrientation.z += qv.z;\n    this.qOrientation.w += qv.w;\n\n    this.qOrientation.normalize();\n\n    // calculate the velocity in body space:\n    // (we'll need this to calculate lift and drag forces)\n    this.vVelocityBody = this.vVelocity.clone().applyQuaternion(this.qOrientation.clone().conjugate());\n\n    // get the Euler angles for our information\n    let u = new THREE.Vector3().setFromEuler(new THREE.Euler().setFromQuaternion(this.qOrientation));\n\n    this.vEulerAngles.x = u.x; // roll\n    this.vEulerAngles.y = u.y; // pitch\n    this.vEulerAngles.z = u.z; // yaw\n\n    pixel(deg(u.z), 'orange');\n    pixel(this.rudder, 'black');\n\n    // threedee\n    this.object.position.copy(this.vPosition);\n    this.object.rotation.z = this.vEulerAngles.z;\n    camera.position.set(this.vPosition.x, this.vPosition.y - 0.0000001, 6);\n    camera.lookAt(this.vPosition.x, this.vPosition.y, 0);\n\n    return 0;\n  } // physics\n\n\n} // Vehicle\n\n\n\n// minimal graphing\nlet plot = document.querySelector(\"#plot\");\nplot.width = 500;\nplot.height = 300;\nlet ctx = plot.getContext('2d');\nctx.fillStyle = '#333';\nctx.fillRect(0, 0, plot.width, plot.height);\n\nctx.strokeStyle = '#555';\nctx.beginPath();\nctx.moveTo(0, plot.height / 2);\nctx.lineTo(plot.width, plot.height / 2);\nctx.stroke();\n\nlet n = 0;\n\nfunction pixel(y, color) {\n  ctx.fillStyle = color;\n  ctx.fillRect(n, plot.height / 2 - y, 1, 1);\n}\n\n\n// three.js\nlet renderer = new THREE.WebGLRenderer({\n  antialias: true\n});\nrenderer.setPixelRatio(window.devicePixelRatio);\nrenderer.setSize(window.innerWidth / 2, window.innerHeight / 2);\ndocument.body.appendChild(renderer.domElement);\n\nlet scene = new THREE.Scene();\nscene.background = new THREE.Color('rgb(25%,25%,25%)');\n\nconst axes = new THREE.AxesHelper();\nscene.add(axes);\n\nconst grid = new THREE.GridHelper(20, 20);\ngrid.rotation.x = Math.PI / 2; // Z is up \nscene.add(grid);\n\nlet camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 50);\ncamera.up.set(0, 0, 1); // Z is up\ncamera.position.set(0, -0.0000001, 6);\n\n// vehicle\nlet craft = new Vehicle(scene);\n\n// simulation\nlet timestart = performance.now();\nconst dt = 0.01;\nconst duration = plot.width / 60 * 1000;\n\nfunction step(time) {\n  if (time - timestart > duration) return;\n\n  console.log(n);\n  n++;\n\n  const r = craft.physics(dt);\n  if (r == -1) {\n    console.log(\"ERROR\");\n    return;\n  }\n\n  renderer.render(scene, camera);\n  requestAnimationFrame(step);\n}\nrequestAnimationFrame(step);\n\nwindow.addEventListener(\"resize\", e => {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});```\n\r\n```\nbody {\n  margin: 0px;\n}```\n\r\n```\nPlot:\n<span style=\"color:red\">red: drag</span>,\n<span style=\"color:green\">green: localSpeed</span>,\n<span style=\"color:blue\">blue: lift</span>,\n<span style=\"color:gold\">yellow: drag+lift force</span>,\n<span style=\"color:magenta\">magenta: attackangle</span>,\n<span style=\"color:gray\">white: total</span>,\n<span style=\"color:black\">black: rudder angle</span>,\n<span style=\"color:orange\">orange: vehicle angle</span>\n<br>\n<canvas id=\"plot\"></canvas>\n<br> Vectors:\n<span style=\"color:red\">red: drag</span>,\n<span style=\"color:green\">green: thrust</span>,\n<span style=\"color:blue\">blue: lift</span>,\n<span style=\"color:gold\">yellow: drag+lift force</span>,\n<span style=\"color:cyan\">cyan: rudder normal</span>,\n<span style=\"color:gray\">white: total</span>,\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/0.150.0/three.min.js\"></script>```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nI'm not sure how you're calculating the ```\nvtmp```\n vector, but I'm getting insanely large values right before crashing:\n```\nx: 0,\ny: -6e+215,\nz: -3e+199\n```\n\nWhen calculating the ```\n.length()```\n of such a huge vector, you're surpassing JavaScript's ```\nNumber.MAX_VALUE```\n limit, which is 1.7 with 308 zeroes behind it. Instead, it returns ```\nInfinity```\n and you're getting ```\nfLocalSpeed = Infinity```\n, which immediately causes divisions by 0 and all kinds of other problems with your dot products and crossVectors.\nLike I said, I'm not sure how you're calculating ```\nvtmp```\n, but with your approach it seems like ```\nvAngularVelocity```\n reaches incredibly large values... maybe it's accurate that an airplane would explode when subjected to such large forces! :D\nMaybe you need to protect against divisions by 0 or some other undesired result stemming from cross vectors or dot products?\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Excel: Sumif Multiple Columns based on the same Criteria\r\n                \r\nSo I am trying to create a spreadsheet at allows a character in game to total the party inventory.\n\nI am trying to sumif multiple columns based on the same criteria.\n\nSo say I am trying to sum all the rope they have.\n\nIn column A is the Item descriptions\nIn columns B-E are the different totals for each party member (one column per person)\n\nEach party member has 50 rope, so I am expecting 200 rope.\nI have used this formula:\n\n=SUMIF(A:A,\"Rope: Hemp\",B:E) and it is only returning 50 as a value, If I utilise cell values (A1:A100 etc.) it returns a value of Zero.\n\nI have been told that Sum Product could works so I also tried that:\n\n=SUMPRODUCT((A1:A100=\"Rope: Hemp\")*(B3:E100)) and I still get the incorrect result.\n\nWhat am I doing wrong?\n\nEDIT:\nHere are some photos. \nHere is my Raw Data. As you can see I have the inventory and tallies, when you look at rope it says 150, and this was calcualted by summing the B to E cells, however as the list is going to move and grow I thought SUMIF would be better.\n\nAs stated above, I have used a SUMIF making the range Columns B through E, and it only returns a value of 50 (I'm assuming Column B)\n    ", "Answer": "\r\nso came up with this:\n    =SUMIF(A3:A40,\"=\"&J17&\"\",B3:B40)+SUMIF(A3:A40,\"=\"&J17&\"\",C3:C40)+SUMIF(A3:A40,\"=\"&J17&\"\",D3:D40)+SUMIF(A3:A40,\"=\"&J17&\"\",E3:E40)\n\nWhich works, but I can only assume that sumif only work with ONE target range... And I tried curly brackets as well...\n\nSo, I did also use cell J17 for the object you are looking for, so you can drag it down, the \"*\" will find all occurences of \"Rope: Hemp\", or \"Rope: Nylon\" etc. I get a total of 150 as there are only 3 characters with rope...\n\nHope it helps. Someone else may have a better / neater suggestion!\n\nI just tested it by entering Rope, rapier and rations into J17 and got the results I expect.\nImage of spreadsheet:\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "unable to debug segmentation fault for this code\r\n                \r\nThis is the problem from online hackerrank online platform.\nNikita and the Game\nI coded this and my solution passes only the given testcases, it is giving segmentation fault for other testcases on submit.\nI compared my approach with editorial solutions, and one of the solution uses same approach as mine(the binary search approach to find the index at which we'll be able to split the array).\nBut i can't figure out why is it giving the segmentation fault.\n```\n#include <bits/stdc++.h>\n#define lld long long\n\nusing namespace std;\n\n\nlld isPossible(vector<lld>&pre_sum, lld start, lld end){\n    \n    lld low = start-1;\n    lld high = end;\n    \n    while(start<=end){\n        lld mid = (start+end)/2;\n        lld left_sum = pre_sum[mid] - pre_sum[low];\n        lld right_sum = pre_sum[high]- pre_sum[mid];\n        \n        if(left_sum == right_sum) return mid;\n        if(left_sum < right_sum) start = mid+1;\n        if(left_sum > right_sum) end = mid-1;\n    }\n    return -1;\n}\n\nlld calcAns(vector<lld>&pre_sum, lld start, lld end){\n    //cout<<start<<\" \"<<end<<\"\\n\";\n    lld idx = isPossible(pre_sum, start, end);\n    //cout<<idx<<\"\\n\";\n    if(idx == -1) return 0;\n    return 1 + max(calcAns(pre_sum, start, idx), calcAns(pre_sum, idx+1, end));\n    \n}\n/*\n * Complete the arraySplitting function below.\n */\nlld arraySplitting(vector<lld> arr) {\n    \n    vector<lld> pre_sum(arr.size() + 1);\n    pre_sum[0] = 0;\n    \n    for(lld i=0; i<arr.size(); i++){\n        pre_sum[i+1] = pre_sum[i] + arr[i]; \n    }\n    \n    lld ans = calcAns(pre_sum, 1, pre_sum.size()-1);\n    //cout<<ans<<\"\\n\";\n    return ans;\n}\n\nint main()\n{\n\n    lld t;\n    cin >> t;\n\n    for (lld t_itr = 0; t_itr < t; t_itr++) {\n        lld arr_count;\n        cin >> arr_count;\n\n        vector<lld> arr(arr_count);\n\n        for (lld arr_itr = 0; arr_itr < arr_count; arr_itr++) {\n            lld arr_item;\n            cin>>arr_item;\n            arr[arr_itr] = arr_item;\n        }\n\n        lld result = arraySplitting(arr);\n\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}\n```\n\nExplanation of code:\nisPossible function finds the index at which the sum of the left part ```\n[start....mid]```\n of the array is equal to the right part ```\n[mid+1.....end]```\n.\ncalcAns calculates the no of possible such indexes in a way that once it will finds such index, it will ignore one part and finds in other part if any such possible. It will calculate maximum no. of such possible splittings.\narraySplitting just calculates the prefix sum array ```\npre_sum```\n and is one size more than the actual array, i.e first index have sum zero, so that it will ease calculations later while calculating sums between a range. It calls calcAns function for further processing.\nEDIT: i want to learn debugging cases without actually having to use debugger as testcases are not downloadable during a contest submission. so i want to learn what thing's am i missing which causes segmentation faults as i started training myself for programming contests. If someone can predict on seeing the code that these type of tescases is possible where my code probably can give segmentation fault, will be helpful. This is what i'm actually looking for, otherwise it is not any benefit that i debug large testcases by using gdb on setting breakpoints after the contest.\n    ", "Answer": "\r\nThe first step to fixing the issue is to determine where the segfault is occurring.\nYou can debug the program using gdb, step, set breakpoints etc.\nAlso add debug-couts as suggested in the comments.\nYou could add defensive checks to the methods, e.g. compare the indices ```\nlow```\n, ```\nmid```\n, ```\nhigh```\n against the size of the vector.  It's also possible that the vector capacity setting could cause an out-of-memory exception so you should add try-except handlers around the code as well.\nAlternatively you can use a library that catches the segfault and provides a stack trace so you can see where the segfault originates, e.g.\nhttps://github.com/certik/stacktrace\nAlso see related questions such as how to debug c++ runtime errors\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Finding Maximum taking too much time in ILP, why?\r\n                \r\nIn short, we are now trying to change the IQP into the ILP. It took about 2 days with the old implementation to finish, now with linear tools -- it should speed up. Basically the problem is to maximize (with about 50 binary vars):\n\n$$\\sum_{g=1}^{5}sum_{p=1}^{10} ( S[p]x[g][p]-Tiredness[g][p]-Sleepness[g][p] )$$\n\nUpdate \n\nI think David is on the right track but when I try to maximize the expression with bonus -variables, they are zero every time, why? Below some code, scores could be like ```\nS[1..10]=[1,2,3,4,5,6,7,8,9,10];```\n.  \n\n```\nint S[1..10] = ...; // Scores per player =s\n\ndvar int x1[1..10] in 0..1;\ndvar int x2[1..10] in 0..1;\ndvar int x3[1..10] in 0..1;\ndvar int x4[1..10] in 0..1;\ndvar int x5[1..10] in 0..1;\n\ndvar int b1[1..10] in 0..100;\ndvar int b2[1..10] in 0..100;\n\n\n//ERR: the values of b1 and b2 should be maximized...\n// WHY not here so?\n\nmaximize \nsum(i in 1..10) \n(\nS[i] *\n    (\n    (x1[i]+x2[i]+x3[i]+x4[i]+x5[i]) \n    - 1/10 * ( b1 +b2) \n    )\n);\n\nsubject to \n{\n    //We must play in 5 games.\n    //It means that there are 5 players in each game.\n    sum(i in 1..10) x1[i]==5;\n    sum(i in 1..10) x2[i]==5;\n    sum(i in 1..10) x3[i]==5;\n    sum(i in 1..10) x4[i]==5;\n    sum(i in 1..10) x5[i]==5;\n\n    // IQP problem into ILP -problem\n\n    forall (i in 1..10)\n    {\n        //ERROR HERE!\n        //it returns zero for b1 and b2, they should be maximized... \n        //I am trying to use the tip by David here, see his answer.\n\n        // EQ1: x2[i] * (x1[i]+x3[i])\n        b1 <= 2*x2[i];\n        b1 <= x1[i]+x3[i];\n\n        // EQ2: x4[i] * (x3[i]+x5[i]+x1[i])\n        b2 <= 3*x4[i];\n        b2 <= x3[i]+x5[i]+x1[i];\n\n    }\n\n};\n```\n\n    ", "Answer": "\r\nExpressions like\n\n```\nx1 * x2\n```\n\n\nare quadratic if x1, x2 are both variables.  You have a 50-variable integer quadratic programming problem.  Also, your objective function isn't concave so CPLEX is going to have an especially hard time.\n   However, since you have all 0-1 variables, you can convert this into an linear problem by adding an additional variable, say bonus for the expression with positive coefficients and penalty for those with negative coefficients, putting them in the objective function instead of the quadratic terms and adding the following constraints\n\n```\nbonus <= x1\nbonus <= x2\n```\n\n\nor in case of a negative coeficient\n\n```\npenalty >= x1 + x2 - 1\n```\n\n\nSince you are maximizing, cplex will force bonus or penalty to the correct values at optimal solutions.\nThe penalty and bonus variables should be declared to be non-negative\n\n```\ndvar float+ penalty;\ndvar float+ bonus;\n```\n\n\nDo this for for all the quadratic expressions and your problem will become a linear integer problem and solve much faster.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "MySQL: Initialize a summary table with placeholders for non-existent data\r\n                \r\nI'll try to give this as generically as I can so it's reusable.\n\nI am running a site with a fairly large MySQL database which has grown to need some summary/rollup tables initialized.  For the example's sake, let's say it's soccer statistics.  Since I handle multiple soccer leagues in the same database, many of them play games of different lengths - for instance, indoor soccer leagues play four quarters while most outdoor leagues play halves.\n\nI have three tables important to this exercise.  I've redacted all of the fields that I don't consider significant to the answer I'm looking for.\n\n```\nGAME\n`game`.id\n`game`.home_team_id\n`game`.away_team_id\n`game`.number_of_periods\n\nGOAL \n// Records for each goal scored in the game   \n`goal`.id\n`goal`.game_id\n`goal`.team_id\n`goal`.period_number\n`goal`.player_id\n`goal`.assist_player_id\n\nPERIOD_SUMMARY\n`period`.id\n`period`.game_id\n`period`.team_id\n`period`.number\n`period`.goals_scored    \n```\n\n\nUltimately I should have records for EVERY period played in the period summary table, regardless of whether or not a goal was scored.  This table only needs to be initialized once, as it's fairly easy to add the appropriate zero-filled records via a trigger on game creation and fire on insert/update requests to update the period_summary table.\n\nIt is also fairly easy for me to group all of the goals and initialize the period summary table with the SUM(), what I am having a bit of trouble figuring out an efficient way to \"fill\" any periods that don't have a goal scored with a 0.\n\nWhat I am trying to figure out is if it's easier/more efficient to:\n\n\nWrite the trigger and prefill the entire period_summary table with 0-filled values, then run the query I already know to update the appropriate records for periods in which goals were scored.\nUse some other method (perhaps a temporary stored procedure?) that will only 0-fill records where there is not a match in the goals table.\n\n    ", "Answer": "\r\nYou already have a placeholder. The \"placeholder for unknown data\" in SQL is null.\n\nYou don't need to pre-fill anything: either you have a row with some columns having an unknown value (null), or you have no row at all, so that doing an outer join will get a row that is all null. Either way, the attribute data (essentially, non-id fields) will be null.\n\nAnd the ```\nsum()```\n aggregate will ignore nulls.\n\nSo let's say that you do have a row for a game (since it's pre-scheduled), but no corresponding rows for its periods (since they have not yet been played). Then you do an outer join form game to period (outer, so that you include both games with and games without, period data):\n\n```\nselect a.*, sum(b.goals_scored)\nfrom game a left outer join period b on (b.game_id = a.id)\ngroup by a.id;\n```\n\n\nThis shows you the total goals (for both teams) by game; for games with no periods, you get back null (which means in SQL, \"we don't (yet) know\")\n\nThis query shows you only the total goals for completed games and games in progress (games for which at least one period has been played):\n\n```\nselect a.*, sum(b.goals_scored)\nfrom game a join period b on (b.game_id = a.id)\ngroup by a.id;\n```\n\n\nThis view filters out incomplete games (assuming you always add early periods before later ones) :\n\n```\ncreate view complete_games as\nselect a.* from games a\nwhere exists (select * from period b \nwhere b.game_id = a.id and b.number = a.number_of_periods)\n```\n\n\nUsing that view, we can then sum only completed games:\n\n```\nselect a.*, sum(b.goals_scored)\nfrom complete_games a join period b on (b.game_id = a.id)\ngroup by a.id;\n```\n\n\nSo, no need to pre-fill, no need for a trigger, most importantly, no need to add false data (claiming zero goals when in fact the period has not yet been played), no need to update with correct data. Just insert the period when you have data for it. \n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Pandas - deviation from a fixed mean\r\n                \r\nI have this dataframe:\n```\n   df_temp = pd.DataFrame({'Player':['One', 'Two', 'Three'],\n                            'Goals':[1.0, 0.0, 1.0],\n                            'Assists':[2.0, 0.0, 1.0],\n                            'ShotBar':[0.0, 1.0, 0.0],\n                            'ShotDefended':[0.0, 1.0, 0.0],\n                            'ShotOut':[3.0, 2.0, 0.0]})\n```\n\n\nAggregate\nNow I want to aggregate:\n\n'Goals' and 'Assists' under a 'Succeed' column,\n'ShotBar', 'ShotDefended' and 'ShotOut' under a 'Miss' column.\n\n\nRules of the Game\nI'm bound to a rule that must apply specific weights to each feature:\n\nGoals: 8.0 points\nAssists: 5.0 points\nShotBar: 3.0 points\nShotDefended: 1.2 points\nShotOut: 0.8 points\n\nSo, under these rules, the ratio Succeed/Miss is ```\n13.0/5.0```\n, a fixed ```\n2.6```\n.\nTheoretically, if all values were ```\n1.0```\n, after applying the ratio, over ```\n2.6```\n the player is to considered productive, an under ```\n2.6```\n, unproductive.\nThe highest deviation from this mean is the most productive player.\n\nThis is how I try to apply my weights to the dataframe:\n```\ndf_temp['Succeed'] = df_temp['Goals']*8.0 + df_temp['Assists']*5.0\ndf_temp['Miss'] = df_temp['ShotBar']*3.0 + df_temp['ShotDefended']*1.2 + df_temp['ShotOut']*0.8 \ndf_temp['Iprod'] = (df_temp['Succeed']/df_temp['Miss']).replace(np.inf, 0).fillna(0)\n```\n\nProblem is that when the sum of values under 'Miss' concept is ```\n0.0```\n, division ```\ndf_temp['Succeed']/df_temp['Miss']```\n will be zero, which is undesired.\n```\n  Player  Goals  Assists  ShotBar  ShotDefended  ShotOut  Succeed  Miss  Iprod\n0    One    1.0      2.0      0.0           0.0      3.0     18.0   2.4    7.5\n1    Two    0.0      0.0      1.0           1.0      2.0      0.0   5.8    0.0\n2  Three    1.0      1.0      0.0           0.0      0.0     13.0   0.0    0.0   <------------\n```\n\n\nHow do I fix that using pandas?\nAre there any other statistical methods that could achieve my aim?\n    ", "Answer": "\r\nConsider replacing infinity with some max value, say 1000. Then you would want to cap all Iprod values in case some other record exceeds 1000.\n```\ndf_temp['Iprod'] = (df_temp['Succeed']/df_temp['Miss']).replace(np.inf, 1000).fillna(0)\ndf_temp['Iprod'] = df_temp['Iprod'].clip(upper=1000)\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to: One Up' for points and rounds in a game?\r\n                \r\n```\nclass GameController < ApplicationController\n\n  def index\n    @games = Game.all\n\n    respond_to do |format|\n      format.html # index.html.erb\n      format.xml  { render :xml => @games }\n    end\n  end\n\n  def start_game\n    session[:round] = 1\n    session[:points] = 0\n    @round = session[:round]\n    @points = session[:points] \n  end\n\n  def next_round\n  @round += 1\n  @points += 1200\n  end\n\n  def game_over\n  puts \"Game Over.\"\n  end\n\n  def highscore\n  puts \"Leaderboard action here.\"\n  end\n\n  def generate_round\n    numbers = Array.new(6){rand(9)}\n     @addition = []\n     @display = numbers\n    numbers.inject do |s, i|\n       @addition << s + i\n       @addition.last\n    end\n  end\n\n  def new\n    start_game\n  generate_round\n  puts @points\n  puts @round\n\n  if session[:addition]\n     if not session[:addition].index(params[:guess].to_i).nil?\n        puts \"Correct.\"\n        next_round\n     else\n        game_over\n        puts \"Wrong anwser.\"\n        highscore\n     end\n  end\n  session[:addition] = @addition\n  respond_to do |format|\n      format.html \n    end\n  end   \nend\n```\n\n\nHey guys, So Im trying to build a simple game in rails. \nIts premise is to add all the numbers up in your memory and type in the highest sum you can within a predefined time limit. \nRight now I able to generate the numbers and check for correct answers, however I don`t know how to loop the method in a way that points are added after each successful round.\n\nI`m assuming the problem is that for each instance of \"new\" it sets the start_game method again, thus zeroing the points and round again?\n    ", "Answer": "\r\nYou are correct, every time you hit the 'new' action it will start your game over again.\nYou could do something like below to get it to keep over multiple requests to 'new'\n\n```\n  def start_game\n    session[:round] ||= 1\n    session[:points] ||= 0\n    @round = session[:round]\n    @points = session[:points] \n  end\n\n  def game_over\n    session[:round] = nil\n    session[:points] = nil\n    puts \"Game Over.\"\n  end\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Can I apply softmax only on specific output neurons?\r\n                \r\nI am building an Actor-Critic neural network model in pytorch in order to train an agent to play the game of Quoridor (hopefully). For this reason, I have a neural network with two heads, one for the actor output which does a softmax on all the possible moves and one for the critic output which is just one neuron (for regressing the value of the input state).\nNow, in quoridor, most of the times not all moves will be legal and as such I am wondering if I can exclude output neurons on the actor's head that correspond to illegal moves for the input state e.g. by passing a list of indices of all the neurons that correspond to legal moves. Thus, I want to not sum these outputs on the denominator of softmax.\nIs there a functionality like this on pytorch (because I cannot find one)? Should I attempt to implement such a Softmax myself (kinda scared to, pytorch probably knows best, I ve been adviced to use LogSoftmax as well)?\nFurthermore, do you think this approach of dealing with illegal moves is good? Or should I just let him guess illegal moves and penalize him (negative reward) for it in the hopes that eventually it will not pick illegal moves?\nOr should I let the softmax be over all the outputs and then just set illegal ones to zero? The rest won't sum to 1 but maybe I can solve that by plain normalization (i.e. dividing by the L2 norm)?\n    ", "Answer": "\r\nAn easy solution would be to mask out illegal moves with a large negative value, this will practically force very low (log)softmax values (example below).\n```\n# 3 dummy actions for a batch size of 2\n>>> actions = torch.rand(2, 3)     \n>>> actions\ntensor([[0.9357, 0.2386, 0.3264],\n        [0.0179, 0.8989, 0.9156]])\n# dummy mask assigning 0 to valid actions and 1 to invalid ones\n>>> mask = torch.randint(low=0, high=2, size=(2, 3))\n>>> mask\ntensor([[1, 0, 0],\n        [0, 0, 0]])\n# set actions marked as invalid to very large negative value\n>>> actions = actions.masked_fill_(mask.eq(1), value=-1e10)\n>>> actions\ntensor([[-1.0000e+10,  2.3862e-01,  3.2636e-01],\n        [ 1.7921e-02,  8.9890e-01,  9.1564e-01]])\n# softmax assigns no probability mass to illegal actions\n>>> actions.softmax(dim=-1)\ntensor([[0.0000, 0.4781, 0.5219],\n        [0.1704, 0.4113, 0.4183]])\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Dynamic Programming Find All Possible Team Combinations\r\n                \r\nI've been trying to solve a problem in wich i have to compute the number of possible team formations for a random sport. \n\nThe input is something like this:\n\n```\nP → Number of Team Players\nR → Roles  \n[Min, Max] → Role 0\n[Min, Max] → Role 1\n...\n[Min, Max] → Role r-1\n----------\nMin= Minimum number of Players for the Role\nMax= Maximum number of Players for the Role\n```\n\n\n\n\nTake for example Sport1. Let's say Sport1 as 3 types of Roles( A, B, C), now let's imagine each team has 8 players.\n\n```\n8 → Number of Team Players\n3 → Roles  \n[3 , 7] → Role A\n[1 , 5] → Role B\n[0 , 2] → Role C\n```\n\n\n\n  Valid team formations: \n  [```\n3-5-0```\n , ```\n3-4-1```\n, ```\n3-3-2```\n, ```\n4-4-0```\n, ```\n4-3-1```\n, ```\n4-2-2```\n, ```\n5-3-0```\n, ```\n5-2-1```\n, ```\n5-1-2```\n, ```\n6-2-0```\n, ```\n6-1-1```\n, ```\n7-1-0```\n]\n  \n  Number of valid Team Formations: 12\n\n\nI already solved this by going at every possible formation and if the sum of players in each role is equal to the Number of Team Players then add one to the final result. Otherwise add zero a.k.a. do the same for next combination until end not reached. \n\n3+5+0 = 8 → valid team formation. \n\n3+5+1 > 8 → invalid team formation\n\n3+4+0 < 8 → invalid team formation\n\n\n\nThis is all fun and games until the Number of players goes for something like 40 and the number of roles to something like 20 and the Min = 0 and Max = 40 for each role.\n\nExample:\n\n```\n40\n20\n[0; 40] → Role A\n[0; 40] → Role B\n...\n[0; 40] → Role T\n```\n\n\nIn this case i would need to check for 40^20 possible formations for wich i already did some cuts by only doing for the role A 0 and then multiply by 20, but still need to check 40^19 different combinations.\n\nThis problem has to be solved using Dynamic Programming. I already used DP to solve some problems(sequence problems, maximum profit strawberry crates) but can't seem to find a way to solve this one. \n\nCan somebody give some lights on how to solve this problem and/or similar problems i could find online or in a book that could lead me to find the DP solution for this? \n    ", "Answer": "\r\nDynamic programming problems usually end up with you arranging the parts of a problem in a sequence so you can work through them from left to right, doing enough work at stage n so that you can refer to it for all the information at stage n+1.\n\nHere you could think of the first n Roles as the first n stages, so the first n lines like \"[Min, Max] → Role 0\" in your example. At stage n I would compute, for all numbers of players available up to the maximum of P, the number of different formations you can make up using just the first n roles and up to that number of players. \n\nAt stage n+1, for each number of players available, I would consider all the legal numbers of players in role n+1. Subtracting that from the number of players I was currently considering, I get a number of players left for the first n roles and I look up the answer stored there to get the number of different formations for the first n roles. Adding these possibilities up, I get the number of formations I can make up for the first n+1 roles using that number of players in total. Clearly, I repeat this for all numbers up to P to get the answers I need to store for stage n+1 - unless this is the final stage, in which case only need the answer for P players.\n\nIf the decisions you make can be arranged left to right in stages, where the answer for each stage doesn't depend on much information and can be calculated from the answer for previous stages, then dynamic programming is usually a practical way of solving the problem. You can turn almost any problem into a dynamic programming problem, if you are prepared to store and calculate for a very large number of possibilities at each stages, but eventually this number gets so big that the so-called solution becomes quite impractical.\n\nAs an example, in the problem at the top the second stage is the following problem with just two roles, A and B.\n\n[3 , 7] → Role A\n\n[1 , 5] → Role B\n\nIn the original problem, you need to work out the total number of different team formations if P=8, that is, if you have 8 players in the team. The second stage problem is to work out the number of formations if there are just two roles, but you need to work out the number of formations for 0 players, for 1 players, for 2 players... up to 8 players. Then when you come to work out the answer for the third stage you can say for example \"If I put 3 players in role C I have 5 players left and two roles left and I can look at the answer I have already calculated for the two-role problem with 5 players to see how many formations there are with 3 players in role C.\"\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Uniform int is always zero in fragment shader\r\n                \r\nI´m doing my own engine for my game and I have had a lot of problems with shaders. One of the most annoying is that I can't calculate the lights because a condition in the fragment shader is never meet, so never sums the color of the different materials/lights. The piece of code where I found the problem is, is:\n\n```\n// Compute lights\nvec4 totalColorLighting = vec4(0.0);\nfor (int indexComputeLights = 0; indexComputeLights <  MAX_LIGHTS; indexComputeLights++)\n{\n    if (indexComputeLights < numLights) {\n```\n\n\nnumLights is an uniform passed to the fragment shader. If I write ```\ntotalColorLight = vec4(1,0);```\n outside the if statement, my models get drawn in white color. If I put it inside, like I want, the screen remains black...\n\nIn short, the code that shows the white model is: \n\n```\nfor (int indexComputeLights = 0; indexComputeLights <  MAX_LIGHTS; indexComputeLights++)                              \n{\n    totalColorLight = vec4(1,0); // model is white, so here it´s entering\n\n    if (indexComputeLights < numLights) {\n                // code that never get executed\n            }\n}\n```\n\n\nAnd the code is not working:\n\n```\nfor (int indexComputeLights = 0; indexComputeLights <  MAX_LIGHTS; indexComputeLights++)    \n{\n    if (indexComputeLights < numLights) {\n            totalColorLight = vec4(1,0); // model is black, so here it´s NOT entering\n            }\n}\n```\n\n\nOther ways to get a \"workarround\" is to change \"numLights\" to, ie, a constant number like 2 or 1. I revised the vars where I pass the uniform value to the shaders via eclipse debugger, and it´s 1, so it should be entering in the if statement.\n\nThe way I upload the data to this int uniform is:\n\n```\nint[] vecNumLights = new int[1];\nvecNumLights[0] = numLights;            \nGLES20.glUniform1iv(gl_numLights_Uniform_Locator, 1, vecNumLights, 0);\n```\n\n\nGiving a quick look, does somebody knows what I´m down wrong? Do you need more code to be copied ?\n\nBy the way, I´m using the 4.4.2 Api 19 SDK\n\nEDIT 1:\n\nI noticed that indexComputeLights is not zero from the beginning. If I write a condition like this: \n\n```\n if (indexComputeLights > 0) totalColorLight = totalColorLight + vec4(0.05); \n```\n\n\nthe model is less white the higher the condition, I mean, if the condition is \n\n```\n if (indexComputeLights > 6) \n```\n\n\nthe color ends being more transparent and black, just in the reverse order I figured it should be. What´s happend here with the for-unroll ?\n\nEDIT2:\n\nI think my problem is very similar to this: http://www.opengl.org/discussion_boards/showthread.php/171366-problem-with-uniform-int-and-for-loop\n\nThe differences is that I didn´t notice that the for loop was endless\n\nEDIT3:\n\nI have discovered that numLights (which is an int uniform) is always zero. I can´t understand whats failing, because all the other uniforms looks to load fine. I´m sharing the uniform name between vertex and fragment shaders, but in vertex shaders looks to be working fine.\n\nEDIT4:\n\nI would like to share with you the full vertex and fragment code.\n\nVertex shader:\n\n```\n#pragma glsl\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texCoord;\n\n// matrices we'll need\nuniform mat4 inversedTrasposedModelViewMatrix; \nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\n// other uniforms, constant or data we are going to use\nconst int MAX_LIGHTS = 8;\n\nstruct LightSourceParameters {\nmediump vec3 ambient; \nmediump vec3 lightColor;\nmediump vec4 position;  \nmediump float spotExponent; \nmediump float spotCutoff; // (range: [0.0,90.0], 180.0)\nmediump vec3 spotDirection;\nmediump float constantAttenuation; \nmediump float linearAttenuation; \nmediump float quadraticAttenuation; \n};\nuniform LightSourceParameters LightSource[MAX_LIGHTS];\n\nuniform lowp int numLights;\n\n// out parameters to fragment shader: varyings      \nvarying vec3 outNormal;\nvarying vec2 outTextCoord;\nvarying vec3 outViewVector;\nvarying vec3 outLightVector[MAX_LIGHTS];\n\n\n\nvoid main(){\n\n// Calculate view-space position coordinate\nvec4 P = modelViewMatrix * vec4(position,1.0);\n\n// Calculate the normal in view-space\noutNormal = vec3(inversedTrasposedModelViewMatrix * vec4(normal ,0.0));\n\n// Calculate the view vector in view-space space coordinate\noutViewVector = -P.xyz;\n\n// Assign the texture coordinate\noutTextCoord = texCoord;\n\n// Calculate clip-space position of each vertex\ngl_Position = projectionMatrix * P;\n\n// Calculate light vector for all light source\nfor (int indexLightVector = 0; indexLightVector < MAX_LIGHTS; indexLightVector++){\n    if (indexLightVector < numLights) {\n        /* Si no es ambiental: la unica luz que no lleva asociada vector */\n        if ((length(LightSource[indexLightVector].ambient) == 0.0) /* no ambiental */\n                && (LightSource[indexLightVector].position.w != 0.0)){ /* no directional */\n\n            /* La luz es o point o spotLight */                 \n            outLightVector[indexLightVector] = vec3(modelViewMatrix*LightSource[indexLightVector].position) - P.xyz;\n\n        }\n        else if (length(LightSource[indexLightVector].ambient) == 0.0) { /* no ambiental */\n            /* La luz es directional: position es un vector,\n             * lo transformamos con inversedTransposedModelViewMatrix\n             * y lo negamos para que vaya desde el punto a la luz y no al revÃ©s\n             */\n            outLightVector[indexLightVector] = - vec3(inversedTrasposedModelViewMatrix*LightSource[indexLightVector].position);\n\n        }\n    }\n}\n\n\n} \n```\n\n\nFragment shader:\n\n```\n#pragma glsl\n\nprecision mediump float;\n\nconst int MAX_LIGHTS = 8;\n\nstruct LightSourceParameters {\nvec3 ambient; \nvec3 lightColor;\nvec4 position;  \nfloat spotExponent; \nfloat spotCutoff; // (range: [0.0,90.0], 180.0)\nvec3 spotDirection;\nfloat constantAttenuation; \nfloat linearAttenuation; \nfloat quadraticAttenuation; \n};\nuniform LightSourceParameters LightSource[MAX_LIGHTS];\n\nstruct MaterialParameters {\nvec4 emission;   \nvec4 ambient;    \nvec4 diffuse;\nsampler2D diffuseTexture;\nint hasDiffuseTexture;    \nvec4 specular;\nsampler2D specularTexture;\nint hasSpecularTexture;\nfloat shininess; \n};  \nuniform MaterialParameters Material;\n\nuniform lowp int numLights;\n\nvarying vec3 outNormal;\nvarying vec2 outTextCoord;\nvarying vec3 outViewVector;\nvarying vec3 outLightVector[MAX_LIGHTS];\n\n/* Declaramos cabecera de funcion, necesaria para que GLSL no diga que la funcion no existe, al definirse despues de main */\nvec4 computeLight(in MaterialParameters material, in LightSourceParameters lightSource, in vec3 normal, in vec2 textCoord, in vec3 lightVector, in vec3 halfVector);\n\nvoid main(){\n\n    // Normalize the incoming vectors\n    vec3 normal = normalize(outNormal);\n    vec3 viewVector = normalize(outViewVector);\n    vec3 lightVector[MAX_LIGHTS];\n    vec3 halfVector[MAX_LIGHTS];    \n    // normalize lightvector, compute half vectors and lights\n    vec4 totalColorLighting = vec4(0.0);\n    int indexComputeLights = 0;\n    for (indexComputeLights; indexComputeLights <  MAX_LIGHTS; indexComputeLights++){\n\n\n        if (indexComputeLights < numLights) {\n\n            totalColorLighting = totalColorLighting + vec4(0.05); \n\n            if (length(LightSource[indexComputeLights].ambient) == 0.0 ){ /* no es ambiental, que no tienen vector */\n                lightVector[indexComputeLights] = normalize(outLightVector[indexComputeLights]);\n            }\n\n            if (length(LightSource[indexComputeLights].ambient) == 0.0 ){ /* no es ambiental, que no tienen half vector */\n                halfVector[indexComputeLights] = normalize(outLightVector[indexComputeLights] + outViewVector);\n            }\n\n            LightSourceParameters light = LightSource[indexComputeLights];\n            vec3 currentLightVector = lightVector[indexComputeLights];\n            vec3 currentHalfVector = halfVector[indexComputeLights];\n\n            /* Si la luz es ambiental, halfVector y lightVector son \n             * indefinidos para esa luz, pero da igual porque no son \n             * utilizados en el algoritmo que calcula las luces\n             */\n            totalColorLighting = totalColorLighting + computeLight(Material, light, normal, outTextCoord, currentLightVector, currentHalfVector);\n            indexComputeLights = indexComputeLights + 1;\n        }\n\n    }\n\n    vec4 emission = Material.emission;\n    // vec4 emission = vec4(0.5);\n    // totalColorLighting = vec4(0.0);\n    // Compute emission material\n    if (length(emission) != 0.0) { /* El material tiene un termino emisivo, es decir, emite luz. Lo andimos al total de color calculado */\n        totalColorLighting = totalColorLighting + emission;\n    }\n\n    /* Devolvemos el color de fragmento calculado para almacenarlo en el framebuffer */\n    gl_FragColor = totalColorLighting;\n    //gl_FragColor = vec4(1.0);\n}\n\nvec4 computeLight(in MaterialParameters material, in LightSourceParameters lightSource, \n                in vec3 normal, in vec2 textCoord, in vec3 lightVector, in vec3 halfVector){\n\n    float attenuation = 1.0; // no attenuation\n    vec4 totalLightingColor = vec4(0.0); // no color\n\n    if (length(lightSource.ambient) > 0.0){ // es luz ambiente\n        totalLightingColor = vec4(lightSource.ambient, 1.0) * material.ambient;\n    }\n    else { // Is not ambiental light\n        if (lightSource.position.w == 0.0) { // es un vector, por lo tanto es una luz direccional\n            attenuation = 1.0; // no attenuation\n        }\n        else { // Is a point light or a spot light\n            float distanceToLight = length(lightVector);\n            attenuation = 1.0 / (lightSource.constantAttenuation + \n                                                (lightSource.linearAttenuation * distanceToLight) + \n                                                (lightSource.quadraticAttenuation * distanceToLight * distanceToLight));\n\n        if (lightSource.spotCutoff <= 90.0){ /* Is a spot light */\n                vec3 spotDirection = normalize(lightSource.spotDirection);\n                float clampedCosine = max(0.0, dot(-lightVector, spotDirection));\n                if (clampedCosine < cos(radians(lightSource.spotCutoff))){ /* outside the spotlight cone */\n                    attenuation = 0.0; /* full attenuation */\n                }\n                else { /* inside the spotlight cone */\n                    attenuation = attenuation * pow(clampedCosine, lightSource.spotExponent);\n                }\n            }\n        }\n\n        // Calculo de los terminos de color: diffuso y especular\n        vec4 diffuseMaterialTerm = vec4(0.0, 0.0, 0.0, 1.0); /* El canal difuso serÃ¡ opaco y negro hasta que se sobreescriban sus datos */\n        if (material.hasDiffuseTexture == 0) { /* El canal difuso no tiene textura */\n            diffuseMaterialTerm =  material.diffuse;\n        }\n        else if (material.hasDiffuseTexture == 1){\n            diffuseMaterialTerm = texture2D(material.diffuseTexture, textCoord);\n        }\n        vec4 diffuseReflection = attenuation * vec4(lightSource.lightColor, 1.0) * diffuseMaterialTerm * max(0.0, dot(normal, lightVector));\n\n        vec4 specularReflection = vec4(0.0);\n        if (dot(normal, lightVector) < 0.0 ) { // light source in the wrong side\n            specularReflection = vec4(0.0);\n        }\n        else { // light source in the right side\n            float NdotHV = max(dot(normal, halfVector), 0.0); /* Normal-dot-halfvector */\n            vec4 specularMaterialTerm = vec4 (0.0, 0.0, 0.0, 1.0); /* El canal especular serÃ¡ opaco y negro hasta que se sobreescriban sus datos */\n            if (material.hasSpecularTexture == 0){\n                specularMaterialTerm = material.specular;\n            }\n            else if (material.hasSpecularTexture == 1){\n                specularMaterialTerm = texture2D(material.specularTexture, textCoord);\n            }\n            specularReflection = attenuation * pow(NdotHV, material.shininess) * vec4(lightSource.lightColor, 1.0) * specularMaterialTerm;\n        }\n\n        totalLightingColor = diffuseReflection + specularReflection;\n\n    }\n    return totalLightingColor;\n\n}\n```\n\n\nThis is the code (Java) I´m using to upload this uniform (numLights):\n\n```\nGLES20.glUseProgram(gl_Program.GetProgramID()); // GetProgramID() returns 3 in my case  \n\nint numLights = iLightList.size(); // the scene I want to render has 1 light, so this value is 1\n\nString numLightsString = \"numLights\";\nint gl_numLights_Uniform_Locator = gl_Program.GetUniformLocation(numLightsString); // is 83 in my program\n\nGLES20.glUniform1i(gl_numLights_Uniform_Locator, numLights);\nint error = GLES20.glGetError(); // error is always 0\n```\n\n\nAny help would be very appreciated\n\nEDIT 5:\n\nI found something very strange. If I comment this code in the fragment shader, the uniform numLights is loaded with the correct value:\n\n```\n // vec4 emission = Material.emission;\n // if (length(emission) != 0.0) { /* El material tiene un termino emisivo, es decir, emite luz. Lo añadimos al total de color calculado */\n //     totalColorLighting = totalColorLighting + emission;\n // }\n```\n\n\nBut if I do so, I lost the emission light part calculation... Any ideas ?\n    ", "Answer": "\r\nIt looks like ```\nGLES20.glUniform1i```\n should be used as the ```\nGLES20.glUniform1iv```\n case would be for ```\nuniform int numLights[1];```\n. As I'm sure you already have, ```\nGLES20.glUniform1i```\n should be after ```\nGLES20.glUseProgram```\n and before drawing anything.\n\n```\n83```\n is getting pretty high for a location, though not unreasonable. I don't know much about android specs but it's certainly possible to run out of uniform locations and memory. Maybe try simplifying the shader (test with less lights) or placing the uniform higher up.\n\n[EDIT] To continue this idea, GLSL compilers can be really unintuitive when loops and functions are concerned. Also when branching starts to get quite large. You may just be hitting some weird GLSL compiler bug. You could try unrolling the loop manually, throwing ```\nindexComputeLights <  MAX_LIGHTS && indexComputeLights < numLights```\n inside the for-loop condition should cause the generated conditionals to nest (at least on my nvidia card with current drivers). Maybe replace the expensive ```\ncomputeLight```\n call with a constant just for testing. I've hit cases where generated code seems to be too large and I get an invalid result rather than a compile error.\n\nDoes ```\nlowp```\n affect the ability to set the uniform?\n\nAnother way to get the desired outcome, which may also be faster, is to compile a shader for each number of lights. This can be done easily by injecting a ```\n#define NUM_LIGHTS x```\n at the top of your source.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Finding elements in a 3x3 array\r\n                \r\nI'm new to programming, and I have created a tic-tac-toe game. The game completely works, but I would like to add some \"intelligence\" to the computer. \n\nThe traditional 3 by 3 tic tac toe board (looks like \"#\") is being represented by an array, where all the elements(all the values) are initially set to zero. When a player chooses his/her position, the value changes to 1. For example, if a player put a X in the top right hand corner, array[0][2] becomes 1. If a player puts a X in the bottom left hand corner, array[2][0] becomes 1.\n\nI'm trying to create two methods, one which returns the row (denoted by r())and another that returns the column(denoted by c()) of the coordinate of where the player would have to place the final X such that they win (). Basically I'm trying to make methods that return the location of where the player would need to place the final X to win, so the computer can block it.  \n\nI've tried searching the array using loops looking for a sum of 2, but I'm completely lost. Any help is appreciated. Also any advice for offense \"intelligence\" would be helpful.\n\n```\nimport java.awt.Toolkit;\nimport javax.swing.ImageIcon;\nimport javax.swing.JOptionPane;\npublic class TicTacToe {\n\n    //-------------------------------------------------------------------------\n    private static int[][] grid;\n    private static final int XPOS = 1;\n    private static final int OPOS = -1;\n    private static final int EMPTY = 0;\n\n\n    //-------------------------------------------------------------------------\n    public static void main(String[] args) {\n\n//game\n\n\n        do {\n            initBoard();\n\n            do {\n                moveX();\n\n                if (isTicTacToe()) {\n                    JOptionPane.showMessageDialog(null, \"X wins\");\n                } else if (isCatsGame()) {\n                    JOptionPane.showMessageDialog(null, \"Cats Game\");\n                } else {\n                    moveO();\n                    if (isTicTacToe()) {\n                        JOptionPane.showMessageDialog(null, \"O wins\");\n                    }\n                }\n\n            } while (!isCatsGame() && !isTicTacToe());\n        } while (JOptionPane.showConfirmDialog(null, \"Playagain?\") == JOptionPane.YES_OPTION);\n    }\n\n //-------------------------------------------------------------------------\n\n//Methods\n\n    public static void moveX() {\n        // PRECONDITION: The grid is initialized and not full\n        // POSTCONDITION: XPOS is assigned to the location in grid chosen by the user\n\n        // Algorithm: Ask the user for a location from 1-9, convert it to (r,c), \n        // make sure it is valid and empty, assign XPOS to that locaion\n\n        int move;\n        do {\n            move = Integer.parseInt(JOptionPane.showInputDialog(displayBoard()\n                    + \"\\n\\n Enter your move for X\"));\n        } while ((move < 1) || (move > 9)\n                || grid[getRow(move)][getCol(move)] != EMPTY);\n        grid[getRow(move)][getCol(move)] = XPOS;\n\n    }\n    //-------------------------------------------------------------------------\n\n    public static void moveO() {\n        // PRECONDITION: The grid is initialized and not full\n        // POSTCONDITION: a random available location has been assigned OPOS\n\n        int move = (int) (Math.random() * 9 + 1);\n\n        if (check(move, move) == true)  {\n            grid[getRow(move)][getCol(move)] = OPOS;\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    public static boolean isTicTacToe() {\n        // PRECONDITION:  grid is initialized\n        // POSTCONDITION: Returns TRUE if there is a winner, FALSE otherwise\n\n        for (int i = 0; i <= 2; i++) {\n            if (Math.abs(grid[i][0] + grid[i][1] + grid[i][2]) == 3) {\n                return true;\n            } else if (Math.abs(grid[0][i] + grid[1][i] + grid[2][i]) == 3) {\n                return true;\n            } else if (Math.abs(grid[0][0] + grid[1][1] + grid[2][2]) == 3) {\n                return true;\n            } else if (Math.abs(grid[0][2] + grid[1][1] + grid[2][0]) == 3) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //-------------------------------------------------------------------------\n    public static void initBoard() {\n        // PRECONDITION: \n        // POSTCONDITION: The grid has been initialize and all values set to EMPTY//initilize the board by creating a 3 by 3 array of integers\n\n        grid = new int[3][3];\n        // Make all the vakues empty\n        for (int i = 0; i > grid.length; i++) {\n            for (int j = 0; j > grid.length; j++) {\n                grid[i][j] = EMPTY;\n            }\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    public static boolean isCatsGame() {\n        // PRECONDITION: The grid is initialized\n        // POSTCONDITION: returns TRUE if there are no EMPTY spots, FALSE otherwise\n\n        for (int r = 0; r >= 2; r++) {\n            for (int c = 0; c >= 2; c++) {\n                if (grid[r][c] == EMPTY) {\n                    return true;\n                }\n            }\n\n        }\n\n        return false;\n    }\n\n    //-------------------------------------------------------------------------\n    private static int getRow(int n) {\n        // PRECONDITION: 1 <= n <= 9\n        // POSTCONDITION: returns the correct row - 0, 1, or 2\n        return ((n - 1) / 3);\n    }\n\n    private static int getCol(int n) {\n        // PRECONDITION: 1 <= n <= 9\n        // POSTCONDITION: returns the correct col - 0, 1, or 2\n        return ((n - 1) % 3);\n    }\n\n    //-------------------------------------------------------------------------\n    public static String displayBoard() {\n        // PRECONDITION: The grid is initialized\n        // POSTCONDITION: returns a string representatin of the grid to be used\n        //                in a JOPTIONPANE (\\n's but no \\t's).\n        //                XPOS is replaced with X, OPOS with O, \n        //                EMPTY with the correct number 1 - 9\n\n        String s = \"\";\n        for (int i = 1; i <= 9; i++) {\n            int r = getRow(i);\n            int c = getCol(i);\n            if (grid[r][c] == EMPTY) {\n                s += \" \" + i;\n            } else if (grid[r][c] == XPOS) {\n                s += \" X\";\n            } else {\n                s += \" O\";\n            }\n            if (i % 3 == 0) {\n                s += \"\\n\";\n            }\n        }\n        return s;\n    }\n\n    private static boolean check(int x, int y) {\n        //PRECONDITION: CHECKS IF A COORDINATE ON THE TABLE IS OCCUPIED\n        //POSTCONDITION: RETURNS TRUE IF ITS NOT BEING USED\n        if (grid[getRow(x)][getCol(y)] != EMPTY) {\n            return false;\n        }\n        return true;\n    }\n\n    //need a method to see if there is two in a row, and one to find where the \n    // winning x,y coordinate is \n    private static boolean matchPoint() {\n        for (int i = 0; i <= 2; i++) {\n            if (Math.abs(grid[i][0] + grid[i][1] + grid[i][2]) == 2) {\n                return true;\n            } else if (Math.abs(grid[0][i] + grid[1][i] + grid[2][i]) == 2) {\n                return true;\n            } else if (Math.abs(grid[0][0] + grid[1][1] + grid[2][2]) == 2) {\n                return true;\n            } else if (Math.abs(grid[0][2] + grid[1][1] + grid[2][0]) == 2) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static int r() {\n\n    }\n\n    private static int c() {\n\n}\n```\n\n    ", "Answer": "\r\nFor a more complex game with perfect information and alternating moves, there exists plentyful game theory. Games like Chess, Go, TicTacToe, Mills and Tak all underly the same basic rule set. However TicTacToe is simplified, because the options are so limited, that you can basically 'work around' the complex solving way, and could implement a direct way, by making very direct placement decisions.\n\nUsually such games are solved creating a ply-tree. This is a search tree, where all the possible placements are run through. However (most of) these games are not solvable this way, because the trees are too lagre (they grow exponentially with every ply you try to look ahead). But for TicTacToe, which is so small and simple, you actually can solve the tree, without running out of time or memory.\n\nWhen searching in a tree like this, you usually don't separate the functions to x and y, but handle both together (for example with a ```\nPoint```\n or ```\nCoordinate```\n class). Use a recursive algorithm to grind through all options and then place your piece according to the best option available to your AIs player.\n\n(That said, I personally would recommend you to diverge from the iterative way you code and go a bit more into Object-Oriented programming. That way the code becomes more readable and you can isolate problems better)\n\nHint:\nSince the board is square, and the pieces are 'flat', you can simplify the tree by 'merging' board positions. For example, the following two scenarios are (effectively)  the same:\n\n```\nX|  |\n------\n |O |\n------\n |  |\n```\n\n\nand\n\n```\n |  |X\n------\n |O | \n------\n |  |\n```\n\n\nSo when you 'search' for the right move, you can tread them as the same, as long as you can later still figure out which way you turned and/or flipped the board, to figure out the right placement.\nBut even without this simplificytion you should be able to solve the tree fairly easiely.\n\nWhen you are done implementing TicTacToe, take a look at the board game 'Tak'.\nMultiple open source AIs have been written, and the game is more fun than TicTacToe in the long run ;)\nhttps://www.playtak.com/ (Find the rules under 'Help'. There are multiple interesting links there).\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "What is phi in Deep Q-learning algorithm\r\n                \r\nI'm trying to make a learning football game from scratch with Java and I'm  trying to implement the reinforcement learning with Google DeepMind's Deep Q-learning algorithm (without convolutional network though). I've already built neural network and Q-learning and now I'm trying to sum them up together but there are somethings I don't understand in this code.\n\n\nAren't Q-values usually initialized with zeros instead of random values? Or does this mean the weights of the neural network (line 2)\nWhat is meant by \n\n\n\n  preprocessed sequenced Φ1 = Φ(s1) (line 4)\n\n\nI just couldn't figure out what does Φ stand for in this algorithm.\n\n\n    ", "Answer": "\r\n\nIt refers to the weights of the neural network\nΦ(s) refers to the preprocessing map/step, Φ is a shorthand for Φ(s1)\nEach frame is 210x160 pixels x 128 colors. Some preprocessing was used in the paper. They remove flickering, use only luminance, rescale and stack.\nHave a look at the 'Methods' section in the 2015 paper.\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Algorithmic puzzle: Ball Stacking Problem\r\n                \r\nI am trying to solve this problem: https://www.urionlinejudge.com.br/judge/en/problems/view/1312\n\nThe XYZ TV channel is developing a new game show, where a contestant\nhas to make some choices in order to get a prize. The game consists of\na triangular stack of balls, each of them having an integer value, as\nthe following example shows.\n\nThe contestant must choose which balls he is going to take and his\nprize is the sum of the values of those balls. However, the contestant\ncan take any given ball only if he also takes the balls directly on\ntop of it. This may require taking additional balls using the same\nrule. Notice that the contestant may choose not to take any ball, in\nwhich case the prize is zero.\nThe TV show director is concerned about\nthe maximum prize a contestant can make for a given stack. Since he is\nyour boss and he does not know how to answer this question, he\nassigned this task to you.\nInput\nEach test case is described using several lines. The first line\ncontains an integer N representing the number of rows of the stack (1\n≤ N ≤ 1000). The i th of the next N lines contains i integers Bij\n(−105 ≤ Bij ≤ 105 for 1 ≤ j ≤ i ≤ N); the number Bij is the value of\nthe j th ball in the i th row of the stack (the first row is the\ntopmost one, and within each row the first ball if the leftmost one).\nThe last test case is followed by a line containing one zero.\nOutput\n```\nSample Input  | Sample Output\n4             |   7 \n3             |   0\n-5 3          |   6\n-8 2 -8       |\n3 9 -2 7      |\n2             |\n-2            |\n1 -10         |\n3             |\n1             |\n-5 3          |\n6 -4 1        |\n0             |\n```\n\n\nI'd love a pointer or two on how to solve this problem.\nIt seems like it is solvable using a DP approach, but I can't quite formulate the recurrence. The fact that two adjacent balls could have overlapping children is making things a bit difficult.\n    ", "Answer": "\r\nThis is DP, but we're going sideways instead of top-down. Let's tilt the ball stack a little to the left, so we can look at the whole stack as a sequence of columns.\n\n```\n 3  3 -8  7\n-5  2 -2\n-8  9\n 3\n```\n\n\nFrom this viewpoint the rule of the game becomes: if we want to take a ball, we also need to take the ball above, and the ball directly to its left.\n\nNow, solving the problem. We'll calculate a quantity ```\nS[i, j]```\n for each ball\n-- this represents the best sum we could achieve if the ball at position [i, j] is taken (the `jth ball from the top of the ith column), while considering only the first i columns.\n\nI claim that the following recurrence holds (with some sensible initial conditions):\n\n```\nS[i, j] = MAX(S[i-1, j] + C[i, j], S[i, j+1])\n```\n\n\nwhere ```\nC[i, j]```\n is the sum of the first j balls in the ith column.\n\nLet's break that down a bit. We want to calculate ```\nS[i, j]```\n.\n\n\nWe have to take the ball at [i, j]. And let's suppose for now that this is the bottom-most ball we take from this column.\nThis requires all the balls in this column above it to be taken, with the sum (including [i, j] itself) being ```\nC[i, j]```\n.\nIt also requires the ball at [i-1, j] to be taken (unless we're at the leftmost column, of course). We know that the best sum from taking this ball is ```\nS[i-1, j]```\n, by definition.\nSo the best possible total sum is: ```\nS[i-1, j] + C[i, j]```\n, or just ```\nC[i, j]```\n for the leftmost column.\nBut we can choose differently and take more balls from this column (if we have more balls). We need to calculate and take the maximum value out of ```\nS[i-1, j] + C[i, j]```\n, ```\nS[i-1, j+1] + C[i, j+1]```\n, and so on, all the way down to the bottom of the pile.\nWith a little induction it's easy to see this is equal to ```\nMAX(S[i-1, j] + C[i, j], S[i, j+1])```\n.\n\n\nThe implementation should be obvious now. We process the stack column-by-column, in each column calculate the partial sum ```\nC[i, j]```\n from the top down, then work out ```\nS[i, j]```\n from bottom up.\nFinally, just take the maximum value of ```\nS[i, j]```\n we've encountered (or 0) as the answer.\n\nThis runs in linear time to the number of balls, so O(N^2).\n\nTo illustrate, here's (```\nC[i, j]```\n, ```\nS[i, j]```\n) pairs for the given example.\n\n```\n(  3, 3) ( 3,7) ( -8,-1)  (7,6)\n( -2,-2) ( 5,7) (-10,-3) \n(-10,-7) (14,7)\n( -7,-7)\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to express ordinal/cardinal directions that can be added together in C#?`\r\n                \r\nFor a personal games project I am working on, I am wanting to implement 8-point movement for a character - a character can move North, North-East, East, South-East, etc.\n\nAfter spending a few minutes trying to find ways to organize this setup to be mathematically convenient to code, I finally hit upon a winning setup - associating ordinal (NESW) directions to prime numbers greater than zero, one or two, and calculating cardinal directions (NE NW SE SW) from the sums of the two ordinals!\n\n```\nNorth: 3\nNortheast: 10\nEast: 7\nSoutheast: 12\nSouth: 5\nSouthwest: 14\nWest: 9\nNorthwest: 11\n```\n\n\n...One problem: I then tried to implement it in a C# ```\nEnum```\n, which in hindsight, and with some research I found to be a way that is not supported by C#.  Specifically:\n\n```\npublic enum MotionDirection\n{\n    North = 3,\n    NorthEast = 10,\n    East = 7,\n    SouthEast = 12,\n    South = 5,\n    SouthWest = 14,\n    West = 9,\n    NorthWest = 11\n}\n\n// ...SNIP...\n\nMotionDirection direction;\n\nfloat verticalDirection = ControlManager.GetAxis(VerticalAxis);\nfloat horizontalDirection = ControlManager.GetAxis(HorizontalAxis);\n\nif (verticalDirection > 0.0f)\n    direction = MotionDirection.North;\nelse if (verticalDirection < 0.0f)\n    direction = MotionDirection.South;\n\n// Red-squigglies appear here, and they're well-earned.\nif (horizontalDirection > 0.0f)\n    direction += MotionDirection.East;\nelse\n    direction += MotionDirection.West;\n```\n\n\nThe reason I did it this was, was that I mis-remembered the concept of bitmasking, and thought that I could associate any integer to an Enum property without the ```\n[Flags]```\n attribute, when in fact the [Flags] attribute only allows for power-of-two values to be assigned (0, 1, 2, 4, 8, etc.)\n\nMy question this time is simple - other than having a dictionary like ```\nDictionary<MotionDirection, int> directions```\n, or constants (I shudder at the thought), am I either forgetting, or ignorant of some C# language construct that can let me simply add two ```\nMotionDirection```\ns together as if they were two ```\nint```\ns?  \n    ", "Answer": "\r\nHere is how you do it using two numbers between 0 and 360 (if you don't have such a function built into your graphics card):\n\n```\n if a = b then \n   new_direction = a\n else      \n   if a < b then \n     if (b-a < 180) then\n       new_direction = (a + (b-a)/2) mod 360\n     else\n       new_direction = (b + (360 - b + a)/2) mod 360\n   else\n     if (a-b < 180) then\n       new_direction = (b + (a-b)/2) mod 360 \n     else\n       new_direction = (a + (360 - a + b)/2) mod 360\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Game of LIfe: Modifying array values in numpy while iterating with conditions\r\n                \r\nI am a Physics student with very basic knowledge of Python and I have been trying to look for a simple solution to this problem, but I have only been running around in circles. I am writing my own rendition for a program called \"The Game of Life\" (WikiPage). The rules are straightforward:\n\nThe Game consists of so called cells that live on a 2 dimensional grid. These cells evolve in cycles. The initial pattern of dead and live cells is the first generation. The second generation evolves from applying some simple rules simultaneously to all cells. The rules are:\nCells die if they dont have enough company (less than 2 cells neighboring)\nCells die of overpopulation if there are 4 or more cells neighboring.\nA dead cell is reborn if there are (exactly) 3 cells neighboring.\n\nThis is a part of an assignment, but I am not looking for a spoon-fed solution. We are required to use numpy and arrays.\nMy approach was to generate an array ```\nboard```\n with an initial feed of random 1's and 0's. Then, in a function, I create another array with one row and one column greater than ```\nboard```\n which will store the new values and then feed it back. I iterate (I know its not pythonic to iterate over an array, so I am open to suggestions and alternatives) over the elements ```\ni```\n and ```\nj```\n and make a sum (```\nnp.sum```\n) of the subarray ```\nnBlock[i-1:i+1,j-1:j+1]```\n. If the sum is greater than 4 or less than 4, then the element ```\nnBlock[np.array([i,j])]```\n becomes zero (cell dies), otherwise, it is 1 (cell lives, or is reborn).\nThe problem is, this doesn't work. The code is as follows:\n```\nimport numpy as np\nimport matplotlib.pyplot as plot\nimport time as t\n%matplotlib inline\n\ndef printBoard(board):\n    im = plot.imshow(board, cmap='Greys', interpolation='none')\n    plot.show()\n    plot.close()\n\ndef initializeBoard():\n    board = np.random.randint(2, size=(100, 100))\n    return board\n\nboard = initializeBoard()\nprintBoard(board)\n\ndef checkAlive():\n    if 1 not in board:\n        print(\"All cells are dead! Life is over!\")\n        return 0\n    else:\n        return board\n\ndef calculateNeighbours(board):\n    nBlock = np.zeros((102, 102))\n    nBlock[1:101, 1:101] = board\n    \n    for i in range(1, 100):\n        for j in range(1, 100):\n            checksum = np.sum(nBlock[i-1:i+2, j-1:j+2])\n            \n            nBlock[:,0] = 0\n            nBlock[0,:] = 0\n            \n            if checksum == 4:\n                nBlock[np.array([i,j])] = 1\n            elif checksum > 4 or checksum < 4:\n                nBlock[np.array([i,j])] = 0\n    \n    return nBlock\n\ndef play(board):\n    for i in range(1, 10):\n        neighbours = calculateNeighbours(board)\n\n        board = neighbours[1:101, 1:101]\n\n        board = checkAlive()\n\n        printBoard(board)\n\nplay(board)\n```\n\nThe array ```\nboard```\n doesn't get modified. It returns the same ```\nboard```\n.\nAnother odd thing I noticed is that if I remove the conditions in my ```\nfor```\n loop, the array is successfully modified. For example,\n```\nfor i in range(0, 100):\n    for j in range(0, 100):\n        board[np.array([i,j])] = 1\n```\n\ngives me a matrix which has all elements changed to 1. So there is something about the ```\nif...else```\n conditions which is not allowing me to manipulate the data in my array.\nAny and all help is appreciated :)\n    ", "Answer": "\r\nError:\n\nYour major error is in your interface logic for checkAlive.  You have no parameters to the routine; when you do find a live cell, you return the symbiont board, which play immediately assigns to its parameter board.\n\nThe board in play is a local variable: changing this does not change the global board you initialized.  In contrast, since checkAlive has no local variable, what it returns is the global variable board, which is never changed, anywhere in the program.\n\nSolution:\n\nSince checkAlive doesn't alter the board, don't return it.  Instead, return a simple boolean.  play can check this and terminate the program, if needed.\n\nAlso:\n\nYour cell health algorithm is wrong in a couple of respects.  Walk through the logic and repair.  Most notably, you use a value of 4 to let a cell live; this is massively incorrect.  2 neighbours leave the cell in its current state; 3 neighbours make the cell live; any other number kills it.\n\nYour current logic includes the cell itself in the count.  This does not differentiate between a live cell with 3 friends and a dead cell with 4.  As a result, you're creating some cells incorrectly, and you're killing off viable cells (live cell with 2 friends).\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "game countdown bad accuracy in react-native\r\n                \r\nI'm developing a game in react-native and the main game View must contain also a countdown. Here I reduce it to just have a numeric representation.\nI wrote a simple custom hook ```\nuseTimer```\n mainly to check how much the timing fluctuations make the actual time diverge from the target.\n```\nimport { useState, useEffect, useRef } from \"react\";\nconst useTimer = (ms, tick) => {\n    const [time, setTime] = useState(ms),\n        [started, setStarted] = useState(false),\n        ref = useRef(),\n        stop = () => {ref.current && clearInterval(ref.current)},\n        start = time => {\n            time && setTime(time)\n            setStarted(true)\n        };\n    useEffect(() => {\n        if (!started || time <= 0) { stop() return stop}\n        ref.current = setInterval(() => setTime(t => t - tick), tick)\n        return stop\n    }, [time, started])\n    return { time: (time / 1e3).toFixed(2), start, stop }\n};\n\nexport default useTimer;\n```\n\nthen in a naked View\n```\nimport React from 'react'\nimport { StyleSheet, View, Text, Pressable } from 'react-native'\nimport useTimer from './../hooks/useTimer'\nimport {FIFTYTHREE, tick} from './../constants'\n/**\n * as u might suspect FIFTYTHREE value is 53\n * then tick is 10, yes 10\n */\nconst Timer = () => {\n    const {start, stop, time} = useTimer(FIFTYTHREE * 1e3, tick)\n    return <View>\n            <Pressable  onPress={() => start()}>\n                <Text>{time}</Text>\n            </Pressable>\n    </View>\n};\nexport default Timer\n```\n\nthen I start it in the emulator and everything seems fine for few seconds then,\nsomething feels wrong, it is slow, so I put aside my phone and I measure it roughy takes\n1 minute and 34 seconds!!!\nIt is vital for the game that this countdown is quite precise (tolerance ok to ±1%)\nIt is well know the native ```\nsetTimeout```\n and ```\nsetInterval```\n suffer fluctuations (mostly in excess) which sum up, and this explains the delay, and this grows inversely to the ```\ntick```\n value;\nthus I tried to change ```\ntick```\n to ```\n100```\n ms getting the countdown to complete in ```\n59```\n seconds, quite a good step ahead ...but still far away from the needed constraints.\nSo just for curiosity I try setting ```\ntick```\n to ```\n500```\n ms (really not acceptable to see) and it takes ```\n55```\n seconds to reach zero.\nNext attempt I made was to use a self calibrating version of setInterval I wrote quite some time ago,\n```\nvar t = 53e3,\n    tick = 10,\n    start = +new Date,\n    end,\n    i = interval(() => {\n        t -= tick;\n        if (t <=0) {\n          end = +new Date;\n          console.log(end-start)\n          i.clear();\n        }\n    }, tick).run();\n```\n\nI got here ```\n53001```\n in console thus now I can reasonably exclude the interval issue from the equation,\nthings got better but still the error (excess or defect) is strictly related to the ```\ntick```\n value and definitely affected the react-native.\nMoreover sounds reasonable that also the device specs and resources will concur to distort the measure and making that absolutely non deterministic. This is the reason why I start suspecting there is no way to have a good solution in react-native but I should rather move to ios proper development with swift.\nI would like to know if anyone faced and maybe solved a similar problem in react-native or if the only way is really to move to Xcode.\nUPDATE.\nbased on @Viktor W feedback\nI updated the hook to\n```\nconst useTimer = (ms, tick) => {\n    const [time, setTime] = useState(ms);\n    const ref = useRef();\n    useEffect(() => {\n        ref.current = interval(() => {\n            setTime(t => t - tick)\n        }, tick).run()\n        return () => ref.current.clear()\n    }, [])\n    return { time }\n};\n```\n\nand removed the start button, it starts right away when rendered.\nStill it takes 1 min and 28 sec to go to zero :(\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Slow performance in agent based model python\r\n                \r\nI originally posted this on code-review (hence the lengthy code) but failed to get an answer.\n\nMy model is based on this game https://en.wikipedia.org/wiki/Ultimatum_game . I won't go into the intuition behind it but generally speaking it functions as follows:\n\n\nThe game consists of a n x n lattice on which an agent is placed at each node.\nDuring each time step, each player on each node plays against a random neighbour by playing a particular strategy. \nEach of their strategies (a value between 1-9) has a propensity attached to it (which is randomly assigned and is just some number). The propensity then in turn determines the probability of playing that strategy. The probability is calculated as the propensity of that strategy over the sum of the propensities of all strategies. \nIf a game results in a positive payoff, then the payoffs from that game get added to the propensities for those strategies. \nThese propensities then determine the probabilities for their strategies in the next time step, and so on.  \nThe simulation ends after time step N is reached. \n\n\nFor games with large lattices and large time steps, my code runs really really slowly. I ran cProfiler to check where the bottleneck(s) are, and as I suspected the ```\nupdate_probabilities```\nand ```\nplay_rounds```\n functions seem to be taking up a lot time. I want to be able to run the game with gridsize of about 40x40 for about 100000+ time steps, but right now that is not happening. \n\nSo what would be a more efficient way to calculate and update the probabilities/propensities of each player in the grid? I've considered implementing NumPy arrays but I am not sure if it would be worth the hassle here?\n\n```\n\nimport numpy as np\nimport random\nfrom random import randint\nfrom numpy.random import choice\nfrom numpy.random import multinomial\nimport cProfile\n\nmew = 0.001 \nerror = 0.05\n\ndef create_grid(row, col):\n    return [[0 for j in range(col)] for i in range(row)]\n\ndef create_random_propensities():\n    propensities = {}\n    pre_propensities = [random.uniform(0, 1) for i in range(9)]\n    a = np.sum(pre_propensities)\n    for i in range(1, 10):\n        propensities[i] = (pre_propensities[i - 1]/a) * 10 # normalize sum of propensities to 10\n    return propensities\n\nclass Proposer:\n    def __init__(self):\n        self.propensities = create_random_propensities()\n        self.probabilites = []\n        self.demand = 0 # the amount the proposer demands for themselves\n\n    def pick_strat(self, n_trials): # gets strategy, an integer in the interval [1, 9]\n        results = multinomial(n_trials, self.probabilites)\n        i, = np.where(results == max(results))\n        if len(i) > 1:\n            return choice(i) + 1\n        else:\n            return i[0] + 1\n\n    def calculate_probability(self, dict_data, index, total_sum): # calculates probability for particular strat, taking propensity\n        return dict_data[index]/total_sum                           # of that strat as input\n\n    def calculate_sum(self, dict_data):\n        return sum(dict_data.values())\n\n    def initialize(self):\n        init_sum = self.calculate_sum(self.propensities)\n        for strategy in range(1, 10):\n            self.probabilites.append(self.calculate_probability(self.propensities, strategy, init_sum)) \n        self.demand = self.pick_strat(1)\n\n    def update_strategy(self):\n        self.demand = self.pick_strat(1)\n\n    def update_probablities(self):\n        for i in range(9):\n            self.propensities[1 + i] *= 1 - mew \n        pensity_sum = self.calculate_sum(self.propensities)\n        for i in range(9):\n            self.probabilites[i] = self.calculate_probability(self.propensities, 1 + i, pensity_sum)\n\n    def update(self):\n        self.update_probablities()\n        self.update_strategy()\n\nclass Responder: # methods same as proposer class, can skip-over\n    def __init__(self):\n        self.propensities = create_random_propensities()\n        self.probabilites = []\n        self.max_thresh = 0 # the maximum demand they are willing to accept \n\n    def pick_strat(self, n_trials):\n        results = multinomial(n_trials, self.probabilites)\n        i, = np.where(results == max(results))\n        if len(i) > 1:\n            return choice(i) + 1\n        else:\n            return i[0] + 1\n\n    def calculate_probability(self, dict_data, index, total_sum):\n        return dict_data[index]/total_sum\n\n    def calculate_sum(self, dict_data):\n        return sum(dict_data.values())\n\n    def initialize(self):\n        init_sum = self.calculate_sum(self.propensities)\n        for strategy in range(1, 10):\n            self.probabilites.append(self.calculate_probability(self.propensities, strategy, init_sum)) \n        self.max_thresh = self.pick_strat(1)\n\n    def update_strategy(self):\n        self.max_thresh = self.pick_strat(1)\n\n    def update_probablities(self):\n        for i in range(9):\n            self.propensities[1 + i] *= 1 - mew # stops sum of propensites from growing without bound\n        pensity_sum = self.calculate_sum(self.propensities)\n        for i in range(9):\n            self.probabilites[i] = self.calculate_probability(self.propensities, 1 + i, pensity_sum)\n\n    def update(self):\n        self.update_probablities()\n        self.update_strategy()\n\nclass Agent:\n    def __init__(self):\n        self.prop_side = Proposer()\n        self.resp_side = Responder()\n        self.prop_side.initialize()\n        self.resp_side.initialize()\n\n    def update_all(self):\n        self.prop_side.update()\n        self.resp_side.update()\n\nclass Grid:\n    def __init__(self, rowsize, colsize):\n        self.rowsize = rowsize\n        self.colsize = colsize\n\n    def make_lattice(self):\n        return [[Agent() for j in range(self.colsize)] for i in range(self.rowsize)]\n\n    @staticmethod\n    def von_neumann_neighbourhood(array, row, col, wrapped=True): # gets up, bottom, left, right neighbours of some node\n        neighbours = set([])\n\n        if row + 1 <= len(array) - 1:\n            neighbours.add(array[row + 1][col])\n\n        if row - 1 >= 0:\n            neighbours.add(array[row - 1][col])\n\n        if col + 1 <= len(array[0]) - 1:\n            neighbours.add(array[row][col + 1])\n\n        if col - 1 >= 0:    \n            neighbours.add(array[row][col - 1])\n        #if wrapped is on, conditions for out of bound points\n        if row - 1 < 0 and wrapped == True:\n            neighbours.add(array[-1][col])\n\n        if col - 1 < 0 and wrapped == True:\n            neighbours.add(array[row][-1])\n\n        if row + 1 > len(array) - 1 and wrapped == True:\n            neighbours.add(array[0][col])\n\n        if col + 1 > len(array[0]) - 1 and wrapped == True:\n            neighbours.add(array[row][0])\n        return neighbours\n\ndef get_error_term(pay, strategy):\n    index_strat_2, index_strat_8 = 2, 8\n    if strategy == 1:\n        return (1 - (error/2)) * pay, error/2 * pay, index_strat_2\n    if strategy == 9:\n        return (1 - (error/2)) * pay, error/2 * pay, index_strat_8\n    else:\n        return (1 - error) * pay, error/2 * pay, 0\n\nclass Games:\n    def __init__(self, n_rows, n_cols, n_rounds):\n        self.rounds = n_rounds\n        self.rows = n_rows\n        self.cols = n_cols\n        self.lattice = Grid(self.rows, self.cols).make_lattice()\n        self.lookup_table = np.full((self.rows, self.cols), False, dtype=bool)  # if player on grid has updated their strat, set to True \n\n    def reset_look_tab(self):\n        self.lookup_table = np.full((self.rows, self.cols), False, dtype=bool)\n\n    def run_game(self):\n        n = 0\n        while n < self.rounds:\n            for r in range(self.rows):\n                for c in range(self.cols):\n                    if n != 0:\n                        self.lattice[r][c].update_all() \n                        self.lookup_table[r][c] = True\n                    self.play_rounds(self.lattice, r, c)\n            self.reset_look_tab()\n            n += 1\n\n    def play_rounds(self, grid, row, col):  \n        neighbours = Grid.von_neumann_neighbourhood(grid, row, col)\n        neighbour = random.sample(neighbours, 1).pop() \n        neighbour_index = [(ix, iy) for ix, row in enumerate(self.lattice) for iy, i in enumerate(row) if i == neighbour]\n        if self.lookup_table[neighbour_index[0][0]][neighbour_index[0][1]] == False: # see if neighbour has already updated their strat\n            neighbour.update_all()                                                      \n        player = grid[row][col]\n        coin_toss = randint(0, 1) # which player acts as proposer or responder in game\n        if coin_toss == 1:\n            if player.prop_side.demand <= neighbour.resp_side.max_thresh: # postive payoff\n                payoff, adjacent_payoff, index = get_error_term(player.prop_side.demand, player.prop_side.demand)\n                if player.prop_side.demand == 1 or player.prop_side.demand == 9: # extreme strategies get bonus payoffs\n                    player.prop_side.propensities[player.prop_side.demand] += payoff\n                    player.prop_side.propensities[index] += adjacent_payoff\n                else:\n                    player.prop_side.propensities[player.prop_side.demand] += payoff\n                    player.prop_side.propensities[player.prop_side.demand - 1] += adjacent_payoff\n                    player.prop_side.propensities[player.prop_side.demand + 1] += adjacent_payoff\n            else:\n                return 0 # if demand > max thresh -> both get zero\n\n        if coin_toss != 1:\n            if neighbour.prop_side.demand <= player.resp_side.max_thresh:\n                payoff, adjacent_payoff, index = get_error_term(10 - neighbour.prop_side.demand, player.resp_side.max_thresh)\n                if player.resp_side.max_thresh == 1 or player.resp_side.max_thresh == 9:\n                    player.resp_side.propensities[player.resp_side.max_thresh] += payoff\n                    player.resp_side.propensities[index] += adjacent_payoff\n                else:\n                    player.resp_side.propensities[player.resp_side.max_thresh] += payoff\n                    player.resp_side.propensities[player.resp_side.max_thresh - 1] += adjacent_payoff\n                    player.resp_side.propensities[player.resp_side.max_thresh + 1] += adjacent_payoff\n            else:\n                return 0\n\n#pr = cProfile.Profile()\n#pr.enable()\n\nmy_game = Games(10, 10, 2000) # (rowsize, colsize, n_steps)\nmy_game.run_game()\n\n#pr.disable()\n#pr.print_stats(sort='time')\n\n```\n\n\n(For those who might be wondering, the ```\nget_error_term```\n just returns the propensities for strategies that are next to strategies that receive a positive payoff, for example if the strategy 8 works, then 7 and 9's propensities also get adjusted upwards and this is calculated by said function. And the first ```\nfor```\n loop inside ```\nupdate_probabilities```\n just makes sure that the sum of propensities don't grow without bound).\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How to properly update Monogame with a Github PR\r\n                \r\nHeey,\n\nI got a little problem. The current Monogame 3.2 build available hasn't got a working template for Windows Phone 8. This will result into a black screen and a non working app. So I went onto their git hub and found the issue https://github.com/mono/MonoGame/pull/2089 and someone who fixed it and posted a Pull request. \n\nThe problem now is I have close to zero experience with building my own version or editing project template files. I got some common knowledge and started to delve into this all and already tried copying the template files to my visual studio files and building projects and throwing around the new .DLL but it all doesn't want to work properly. I started to work with the older template but I need the new version due to proper support for landscape in windows phone 8 that we need to utilize for our game.\n\nNow is my question if someone knows the right/proper way to do this. A short summing up from what to copy where will do. \n\nThanks in advance.\n    ", "Answer": "\r\nOkay it took me some time but I figured out what to copy,build,set and run. \n\nYou download the .Zip or make a pull with your Github into an empty folder and when finished extract it.\n\n\nIn the map open the MonoGame.Framework or MonoGame.Framework.”your\ntarget platform” which will startup visual studio.\nBuild the solution/project (don’t forget to build in ARM, x86 and\nx64 if enabled and needed) and navigate to “Extracted\nfolder”/MonoGame.Framework/bin/”your targeted platform” at the same\ntime open a new explorer and navigate to your MonoGame installation\nby default C:\\Program Files (x86)\\MonoGame\\v3.0\nNavigate in your extracted folder to your targeted platform and\nbuild and copy the MonoGame.Framework.dll to the opposing C:\\Program\nFiles (x86)\\MonoGame\\v3.0\\Assemblies\\”targeted platform”\\”build”\nRebuild your Project/Solution\n\n\nGratz you now updated your MonoGame :) \n\nThis could fix your problem but it’s possible that you still get an error when initializing your app on your phone or emulator DXGI related.\nIf this occurs then follow these steps. The problem lies probably by your SharpDX.WP8.dll how to fix this? In my case download and install the newest SharpDX http://sharpdx.org/download/ you could also look further how to only download the SharpDX.WP8.dll & .winmd!\n\n\nNavigate to your SharpDX install (by default C:\\Program Files\n(x86)\\SharpDX) navigate further to\nBin\\DirectX11_1-“platform”-“build”\\ and copy the SharpDX.WP8.dll and\n.winmd to C:\\Program Files\n(x86)\\MonoGame\\v3.0\\Assemblies\\WindowsPhone\\”build”\nRebuild your Project/Solution (if this still doesn't work you may\nneed to manually add the references again to SharpDX.WP8.winmd for\nboth builds)\n\n\nSo if it’s alright this should fix most issues but there is one left. Between MonoGame 3.0.x and 3.2 the project template of a windows phone game has changed but this didn't went well in the code. So we’re now going to update the project template of our Visual Studio.\n\n\nGo back to your extracted Monogame map and head into the folder\n“ProjectTemplates”\\”your visual studio version”\\WindowsPhone\nSelect all files and create a .Zip (could be done by the integrated\nwindows option “Send To”) make sure when you open the .Zip you will\nimmediately see all the files and they aren't nested into a folder\ninside the .Zip\nNavigate to C:\\Users\\”your PC name”\\Documents\\Visual Studio\n201X\\Templates\\ProjectTemplates\\Visual C#\\MonoGame and copy your\njust created .Zip and overwrite the existing file.\n\n\nYou may have to follow these steps if you use different version of Visual Studio because of the lack of support for XNA inside VS2013.\nNow you should've fixed any possible problem. If your project still gives errors try to recreate a new one (this would now use the new updated template you just copy pasted and would work) If this still doesn't work than please post what goes wrong but this all should do! These instructions should also work for all other platforms (at least which you could build of course)\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "What must I add to this code to meet very detailed requirements about a turn based game?\r\n                \r\nThe game starts by initializing Heroes. Heroes have 4 properties: strength, agility, stamina and health. By default, Health is set to 50 and  stamina is set to 25, but strength and agility must be initialized by rolling one 12 sided die, one 10 sided die, and one 8 sided die. I am having trouble assigning the highest value to strength and setting agility to the sum of the other two values.\n\nA round should consist of each player selecting a move and calculating the resulting damage. Each player must select a move for their hero (attack or defend). Each move requires stamina so if the hero cannot afford the stamina cost, it must rest.\n\nMove details:\nAttacking and resting provide no defense so if you are attacked in these states, you receive full damage.\nResting adds health, which mitigates damage, but it is not the same as blocking\nBlocking provides defense so if a hero is attacked when blocking, damages could be averted.\nIf the block value is greater than or equal to the attack value, the attack is dodged.\nOtherwise the difference between the attack and the block is the damage.\n\nAttack - Roll a 20 sided die. The attack value is the strength plus the roll. If the Hero cannot meet the stamina cost (6), it must rest and the attack value is zero.\nDefend - Roll a 20 sided die. The defend value is the agility plus the die roll. If the Hero cannot meet the stamina cost (4), it must rest and the attack value is zero\nRest - When a player tries to attack/defend but is out of stamina, roll a 6 sided, an 8 sided die, and a 10 sided die. Add the highest value to health. Add the sum of the other two to stamina. No stamina cost here.\n\nEnd goal is to write a class to test everything:\nCreate a new BattleManager, Use the BattleManager to setup 2 new Heroes. Print the stats of each hero. Call the round method using the heroes as input parameters. Print the stats of each hero, Call the round method using the heroes as input parameters. Print the stats of each hero. Compare the health of the two heroes. Print the name of the hero with the most health and declare them the winner.\n\n```\npublic class Hero \n{\n private String name;\n private int health;\n private int strength;\n private int agility;\n private int stamina;\n Die die1;\n Die die2;\n Die die3;\n\npublic Hero(String name) \n{\n    this.name = name;\n    this.health = 50;\n    this.stamina = 25;\n    this.strength = 5;\n    this.agility = 5;\n}\n\npublic void setName(String Name) \n{\n    this.name = name;\n}\n\npublic String getName() \n{\n    return name;\n}\n\npublic void setHealth(int health) \n{\n    this.health = health;\n}\n\npublic int getHealth() \n{\n    return health;\n}\n\npublic void setStrength(int strength) \n{\n    this.strength = strength;\n}\n\npublic int getStrength() \n{\n    return strength;\n}\n\npublic void setAgility(int agility) \n{\n    this.agility = agility;\n}\n\npublic int getAgility() \n{\n    return agility;\n}\n\npublic void setStamina(int stamina) \n{\n    this.stamina = stamina;\n}\n\npublic int getStamina() \n{\n    return stamina;\n}\n\npublic int addHealth() \n{\n    if(health < 45 || health >= 0) \n    {\n        health = health + 5;\n    }\n    return health;\n}\n\npublic int removeHealth() \n{\n    if(health <= 50 || health >= 5) \n    {\n        health = health - 5;\n    }\n    return health;\n}\n\npublic int addStamina() \n{\n    if(stamina <= 20 || stamina >= 0) \n    {\n        stamina = stamina + 5;\n    }\nreturn stamina;\n}\n\npublic int removeStamina() \n{\n    if(stamina <= 25 || stamina >= 5) \n    {\n        stamina = stamina - 5;\n    }\nreturn stamina;\n}\n\nprivate void rest() \n{\n    health = health + addHealth();\n    stamina = stamina + addStamina();\n}\n\npublic int attack(int damage) \n{\n    die1 = new Die(20);\n    die1.roll();\n\n    if(stamina <= 5) \n    {\n        rest();\n    }\n    else \n    {\n        damage = strength + die1.getValue();\n        stamina = stamina - 6;\n    }\n    return damage;\n}\n\npublic int defend(int block) \n{\n    die1 = new Die(20);\n    die1.roll();\n\n    if(stamina <= 3) \n    {\n        rest();\n    }\n\n    if(die1.getValue() <= 6) \n    {\n        block = getAgility() + (die1.getValue() * 2);\n    }\n    else \n    {\n        block = getAgility() + (die1.getValue());\n    }\n    stamina = stamina - 4;\n    return block;\n}\n\npublic void printStats() \n{\n    System.out.println(\"Thy hero's name is: \" + getName());\n    System.out.println(\"Thy strengh is: \" + getStrength());\n    System.out.println(\"Thy agility is: \" + getAgility());\n    System.out.println(\"Thy stamina is: \" + getStamina());\n    System.out.println(\"Thy health is: \" + getHealth());\n}\n}\n```\n\n\nNext Class, it needs to be updated to include: setupHero - Takes a string, the name of the hero, as a parameter. The method uses the initialization instructions above (in hero class) to create and initialize a hero object. The method returns the hero object that was created. \nround - takes two hero objects, returns void. Allows user to select moves, performs the moves, and applies damage. Print any info you would like upon completion.\nYou may include any other private methods you like which would assist the code.\n\n```\n    public class Battle_Manager\n   {\n    public static void main(String[] args) \n   {\n     Hero hA = new Hero(\"Ayy\");\n     Hero hB = new Hero(\"Bee\");\n\n    Die die1 = new Die(12);\n    Die die2 = new Die(8);\n    Die die3 = new Die(6);\n\n    die1.roll();\n    die2.roll();\n    die3.roll();\n\n    hA.printStats();\n    hB.printStats();\n}   \n}\n```\n\n\nLast Class\n\n```\nimport java.util.Random;\n\npublic class Die \n{\nprivate int sides;\nprivate int dieValue;\n\n public void roll() \n{\n    Random r = new Random();\n    dieValue = (r.nextInt(sides) + 1);\n}\n\npublic int getSides() \n{\n    return sides;\n}\n\npublic void setSides(int sides) \n{\n    this.sides = sides;\n}\n\npublic Die() \n{\n    sides = 1;\n    dieValue = 1;\n}\n\npublic Die (int sides) \n{\n    sides = 1;\n    dieValue = 1;\n\n    if(sides >= 0) \n    {\n        this.sides = sides;\n    }\n}\n\npublic int getValue() \n{\n    int value = dieValue;\n    return value;\n}\n}\n```\n\n\nI understand my code needs a scanner, and possibly a loop, to fight the multiple rounds needed to declare the winner. How would I go about fulfilling all the these rules for the code? I have done the very basics but prompting the user for input is difficult for me. Any help would be great but the more detailed the better.\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Algorithm for evaluating chess positions with custom pieces and different board shapes\r\n                \r\nI am in the process of designing a chess game which will feature an AI opponent to play against. The user will also have the ability to create custom chess pieces for their starting lineup by combining behaviours of current pieces they have unlocked (for example a Heroine; a hybrid of Queen and Horse) plus completely new pieces, and will also feature new board shapes different to the original 8x8.\nThe question then is how to design the AI. I decided I will start simple and try the minimax algorithm with alpha-beta pruning, but the problem arises in determining how to evaluate the position.\nEvaluating a position with new pieces and new board shapes that can't be pre-determined at compile-time is something I have not seen people mention much, so I am stuck on how to even approach it. A simple point-wise sum of each piece value doesn't really work either because you can't score how the custom pieces. I am aware that Alpha Zero and other chess engines use a large neural network for evaluating their position.\nEdit: I discussed possible architectures with a friend of mine, and we considered a theoretical architecture where the behaviour of each custome piece is encoded in a binary string, which is then combined with the board layout (which would also be a binary string) to create the first input layer of a MLP for the evaluation function, which would have a single output neuron, which outputs a number which is the evaluation of the position (positive for white and negative for black as usual).\nThe evaluation function is then put in a minimax to create an AI bot, and using this we make it play against itself, and to train the evaluation function we get the result of the game (1 for white wins and 0 for black) and use that to create a cost function - if white wins, then the eval function for white should have been evaluating the position as positive most of the time.\nOf course, this doesn't protect against sudden mistakes the opponent may make, which completely change the tide of the game, even though they may have been winning most of the time. To rectify this, we play the same model against itself with the same game multiple times, butting adding random noise to the moves each time.\nI have no clue if this would work, and I'm hoping some AI experts could point out any flaws ro alternatives.\n    ", "Answer": "\r\nGeneral Game Playing (GGP) is an AI field where the rules are not known in advance of game play. So if the player unlocked new custom piece moves, you could encode those into Game Description Language (GDL) and have it play. There are many open source players available, like Cadiaplayer, Sancho, and some others.\n\nhttps://en.wikipedia.org/wiki/General_game_playing\nhttp://cadia.ru.is/wiki/public:cadiaplayer:main\nhttp://sanchoggp.github.io/sancho-ggp/\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Bulgarian Solitaire Java\r\n                \r\nI the following assignment due in a few days in my AP Computer Science course:\n\n\"In this assignment you will model the game of Bulgarian Solitaire. The game starts with 45 cards. Randomly divide them into some number of piles of random size. For example, you might start with piles of size 20, 5, 1, 9, and 10. In each round you take one card from each pile, forming a new pile with these cards. For example, the sample starting configuration would be transformed into piles of size 19, 4, 8,10, and 5. The solitaire is over when the piles have size 1, 2, 3, 4, 5, 6, 7, 8, and 9, in some order.\n\nIn your program, produce a random starting configuration and print it. Then keep applying the solitaire step and print the result. Stop when the solitaire final configuration is reached.\"\n\nI have come up with a program that solves this, but the problem is that it takes a VERY long time sometimes. Other times it will solve it almost instantly, as I expected, but other times it can 18,000 iterations or more. \n\nAccording to http://mancala.wikia.com/wiki/Bulgarian_Solitaire the solution can be found in (k^2)-k steps or less, with k being 9 in this case. I'm definitely not finding the solution in 72 steps or less a lot of the time. I've been looking at this program for hours, messing with different things in order to see if I can make it faster and I just cannot get it working in a sufficient number of iterations. So now I've come to Stack Overflow to see if any of you can help to push me in the right direction.\n\nHere is my code: \n\n```\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Random;\n\npublic class BulgarianSolitaire {\n\n    ArrayList<Integer> cards = new ArrayList<Integer>();\n    Random rand = new Random();\n    boolean cont = true;\n    boolean cont2 = true;\n\n    public static void main(String[] args) {\n        BulgarianSolitaire game = new BulgarianSolitaire();\n    }\n\n    public BulgarianSolitaire() {\n        System.out.println(\"Started\");\n        int sum = 0;\n        while (cont) {\n            if (sum < 45) {\n                cards.add(rand.nextInt(46 - sum));\n            } else {\n                cont = false;\n            }\n\n            sum = 0;\n            for (int i = 0; i < cards.size(); i++) {\n                sum += cards.get(i);\n            }\n\n            removeZeros(cards);\n\n            System.out.println(cards);\n        }\n\n        System.out.println(\"Finished Generating Start\");\n\n        while (cont2) {\n            solitaireStep();\n            System.out.println(cards);\n            if (checkCards()) {\n                cont2 = false;\n            }\n        }\n\n        Collections.sort(cards);\n        System.out.println(\"Cards are sorted\");\n        System.out.println(cards);\n    }\n\n    public void removeZeros(ArrayList<Integer> list) {\n        for (int j = 0; j < list.size(); j++) {\n            if (list.get(j) == 0) {\n                list.remove(j);\n            }\n        }\n    }\n\n    public void solitaireStep() {\n\n        int numberRemoved = 0;\n\n        for (int i = 0; i < cards.size(); i++) {\n            int value = cards.get(i);\n            cards.set(i, value - 1);\n            removeZeros(cards);\n            numberRemoved++;\n        }\n\n        cards.add(numberRemoved);\n    }\n\n    public boolean checkCards() {\n        ArrayList<Integer> expectedCards = new ArrayList<Integer>();\n\n        for (int i = 1; i < 10; i++) {\n            expectedCards.add(i);\n        }\n\n        ArrayList<Integer> sortedCards = cards;\n        Collections.sort(sortedCards);\n        boolean equal = true;\n        if (sortedCards.size() != expectedCards.size()) {\n            equal = false;\n        }\n\n        for (int i = 0; i < sortedCards.size(); i++) {\n            if (sortedCards.size() == expectedCards.size()) {\n                if (sortedCards.get(i) != expectedCards.get(i)) {\n                    equal = false;\n                }\n            }\n        }\n\n        return equal;\n    }\n}\n```\n\n\nSo I basically start by generating a random number between 0 and 45 and add that to the list of cards. Then I continue generating random numbers and putting them in the list as long as the sum is less than 45, such that the random numbers generated are between 0 and 45-the sum of the numbers in it in the last iteration. The zeros in the list are removed as it goes along as well.\n\nOnce the list has been generated, it will run through the step of subtracting 1 from every number in the list, removing zeros and adding a new value equal to the number of stacks that were decreased. It also checks an ordered version of the card stack against the list {1, 2, 3, 4, 5, 6, 7, 8, 9} and once it finds a match, it sets the boolean cont2 to false so that it will stop performing that solitaire step.\n\nThat's about it. I give my thanks to anyone that can help.\n    ", "Answer": "\r\nYour flaw lies in your ```\nremoveZeros```\n method.\n\n```\npublic void removeZeros(ArrayList<Integer> list) {\n    for (int j = 0; j < list.size(); j++) {\n        if (list.get(j) == 0) {\n            list.remove(j);\n        }\n    }\n}\n```\n\n\nIf you remove the element at ```\nj```\n,  then the list size decreases by 1. You have to decrease ```\nj```\n, too.\n\nChange that for this:\n\n```\n  public void removeZeros(ArrayList<Integer> list) {\n        for (int j = 0; j < list.size(); j++) {\n            if (list.get(j) == 0) {\n                list.remove(j);\n                j--;\n            }\n        }\n    }\n```\n\n\nYour checking method is also overly complicated. \n\nIn your solitaire step, set all of the values that should be equal to zero, to zero.\n\nThen, remove zeros (with the revised method) outside of the loop.\n\nThen, sort the array.\n\nThen, in your checking method, since the array is sorted:\n\n```\npublic boolean checkCards() {\n    for(int i = 0; i < cards.size(); i++) {\n        if(cards.get(i) != i + 1) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n\nMuch simpler. And it works.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Combinatorics Counting Puzzle: Roll 20, 8-sided dice, what is the probability of getting at least 5 dice of the same value\r\n                \r\nAssume a game in which one rolls 20, 8-sided die, for a total number of 8^20 possible outcomes. To calculate the probability of a particular event occurring, we divide the number of ways that event can occur by 8^20. \n\nOne can calculate the number of ways to get exactly 5 dice of the value 3. (20 choose 5) gives us the number of orders of 3. 7^15 gives us the number of ways we can not get the value 3 for 15 rolls.\n\n```\nnumber of ways to get exactly 5, 3's = (20 choose 5)*7^15.\n```\n\n\nThe answer can also be viewed as how many ways can I rearrange the string 3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 (20 choose 5) times the total number of values we the zero's (assuming 7 legal values) 7^15 (is this correct).\n\n\nQuestion 1: How can I calculate the number of ways to get exactly 5 dice of the same value(That is, for all die values).\nNote: if I just naively use my first answer above and multiply bt 8, I get an enormous amount of double counting?\n\nI understand that I could solve for each of the cases (5 1's), (5, 2's), (5, 3's), ... (5's, 8) sum them (more simply 8*(5 1's) ). Then subtract the sum of number of overlaps (5 1's) and (5 2's), (5 1's) and (5 3's)... (5 1's) and (5, 2's) and ... and (5, 8's) but this seems exceedingly messy. I would a generalization of this in a way that scales up to large numbers of samples and large numbers of classes.\nHow can I calculate the number of ways to get at least 5 dice of the same value?\n\nSo 111110000000000000000 or 11110100000000000002 or 11111100000001110000 or 11011211222222223333, but not 00001111222233334444 or 000511512252363347744.\n\n\nI'm looking for answers which either explain the math or point to a library which supports this (esp python modules). Extra points for detail and examples.\n    ", "Answer": "\r\nI suggest that you spend a little bit of time writing up a Monte Carlo simulation and let it run while you work out the math by hand.  Hopefully the Monte Carlo simulation will converge before you're finished with the math and you'll be able to check your solution.\n\nA slightly faster option might involve creating a SO clone for math questions.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "A and B and Chess\r\n                \r\nI am working on the Codeforces problem \"A and B and Chess\", which is as follows:\n\n\n  A. A and B and Chess time limit per test 1 second memory limit per\n  test 256 megabytes input standard input output standard output\n  \n  A and B are preparing themselves for programming contests.\n  \n  To train their logical thinking and solve problems better, A and B\n  decided to play chess. During the game A wondered whose position is\n  now stronger.\n  \n  For each chess piece we know its weight:\n\n```\nthe queen's weight is 9,\nthe rook's weight is 5,\nthe bishop's weight is 3,\nthe knight's weight is 3,\nthe pawn's weight is 1,\nthe king's weight isn't considered in evaluating position. \n```\n\n  \n  The player's weight equals to the sum of weights of all his pieces on\n  the board.\n  \n  As A doesn't like counting, he asked you to help him determine which\n  player has the larger position weight. Input\n  \n  The input contains eight lines, eight characters each — the board's\n  description.\n  \n  The white pieces on the board are marked with uppercase letters, the\n  black pieces are marked with lowercase letters.\n  \n  The white pieces are denoted as follows: the queen is represented is\n  'Q', the rook — as 'R', the bishop — as'B', the knight — as 'N', the\n  pawn — as 'P', the king — as 'K'.\n  \n  The black pieces are denoted as 'q', 'r', 'b', 'n', 'p', 'k',\n  respectively.\n  \n  An empty square of the board is marked as '.' (a dot).\n  \n  It is not guaranteed that the given chess position can be achieved in\n  a real game. Specifically, there can be an arbitrary (possibly zero)\n  number pieces of each type, the king may be under attack and so on.\n  Output\n  \n  Print \"White\" (without quotes) if the weight of the position of the\n  white pieces is more than the weight of the position of the black\n  pieces, print \"Black\" if the weight of the black pieces is more than\n  the weight of the white pieces and print \"Draw\" if the weights of the\n  white and black pieces are equal. Sample test(s)\n\n```\nCase 1\n\nInput\n\n...QK...\n........\n........\n........\n........\n........\n........\n...rk...\n\nOutput\n\nWhite\n\n\nCase 2\n\nInput\n\nrnbqkbnr\npppppppp\n........\n........\n........\n........\nPPPPPPPP\nRNBQKBNR\n\nOutput\n\nDraw\n\n\nCase 3:\n\nInput\n\nrppppppr\n...k....\n........\n........\n........\n........\nK...Q...\n........\n\nOutput\n\nBlack\n```\n\n  \n  Note\n  \n  In the first test sample the weight of the position of the white\n  pieces equals to 9, the weight of the position of the black pieces\n  equals 5.\n  \n  In the second test sample the weights of the positions of the black\n  and the white pieces are equal to 39.\n  \n  In the third test sample the weight of the position of the white\n  pieces equals to 9, the weight of the position of the black pieces\n  equals to 16.\n\n\nMy code is:\n\n```\nimport java.util.Scanner;\n\npublic class chess {\n\n\n    private final static int QUEEN = 9;\n    private final static int ROOK = 5;\n    private final static int BISHOP = 3;\n    private final static int KNIGHT = 3;\n    private final static int PAWN = 1;\n    private final static int KING = 0;\n\n\n    public static void main(String[] args) {\n\n        int blackScore = 0;\n        int whiteScore = 0;\n\n        Scanner scan = new Scanner(System.in);\n\n        String[] input = new String[8];\n        input[0] = scan.nextLine();\n        input[1] = scan.nextLine();\n        input[2] = scan.nextLine();\n        input[3] = scan.nextLine();\n        input[4] = scan.nextLine();\n        input[5] = scan.nextLine();\n        input[6] = scan.nextLine();\n        input[7] = scan.nextLine();\n\n        for(int i = 0; i < input.length; i++) {\n            if(input[i].contains(\"Q\")) {\n                whiteScore += QUEEN;\n            }\n\n            if(input[i].contains(\"R\")) {\n                whiteScore += ROOK;\n            }\n\n            if(input[i].contains(\"N\")) {\n                whiteScore += KNIGHT;\n            }\n\n            if(input[i].contains(\"B\")) {\n                whiteScore += BISHOP;\n            }\n\n            if(input[i].contains(\"P\")) {\n                whiteScore += PAWN;\n            }\n\n            if(input[i].contains(\"K\")) {\n                whiteScore += KING;\n            }\n\n\n            if(input[i].contains(\"q\")) {\n                blackScore += QUEEN;\n            }\n\n            if(input[i].contains(\"n\")) {\n                blackScore += KNIGHT;\n            }\n\n            if(input[i].contains(\"b\")) {\n                blackScore += BISHOP;\n            }\n\n            if(input[i].contains(\"p\")) {\n                blackScore += PAWN;\n            }\n\n            if(input[i].contains(\"k\")) {\n                blackScore += KING;\n            }\n\n            if(input[i].contains(\"r\")) {\n                blackScore += ROOK;\n            }    \n\n\n        }\n\n        if(whiteScore != blackScore) {\n\n            if(blackScore > whiteScore) {\n                System.out.println(\"Black\");\n            }\n\n            if (whiteScore > blackScore) {\n                System.out.println(\"White\");\n\n            } \n        }else {\n            System.out.println(\"Draw\");\n        }    \n\n\n        System.out.println(whiteScore);\n        System.out.println(blackScore);\n    }\n\n}\n```\n\n\nCan anyone explain what I've done wrong? Thanks!!\n    ", "Answer": "\r\nI think you have to use the \"else if\" statement instead of \"if\", try this one, I hope this help. \n\n```\nimport java.util.Scanner;\n\npublic class chess {\n\nprivate final static int QUEEN = 9;\nprivate final static int ROOK = 5;\nprivate final static int BISHOP = 3;\nprivate final static int KNIGHT = 3;\nprivate final static int PAWN = 1;\nprivate final static int KING = 0;\n\n\npublic static void main(String[] args) {\n\n    int blackScore = 0;\n    int whiteScore = 0;\n\n    Scanner scan = new Scanner(System.in);\n\n    String[] input = new String[8];\n    input[0] = scan.nextLine();\n    input[1] = scan.nextLine();\n    input[2] = scan.nextLine();\n    input[3] = scan.nextLine();\n    input[4] = scan.nextLine();\n    input[5] = scan.nextLine();\n    input[6] = scan.nextLine();\n    input[7] = scan.nextLine();\n\n    for(int i = 0; i < input.length; i++) {\n        if(input[i].contains(\"Q\")) {\n            whiteScore += QUEEN;\n        }\n\n        else if(input[i].contains(\"R\")) {\n            whiteScore += ROOK;\n        }\n\n        else if(input[i].contains(\"N\")) {\n            whiteScore += KNIGHT;\n        }\n\n        else if(input[i].contains(\"B\")) {\n            whiteScore += BISHOP;\n        }\n\n        else if(input[i].contains(\"P\")) {\n            whiteScore += PAWN;\n        }\n\n        else if(input[i].contains(\"K\")) {\n            whiteScore += KING;\n        }\n\n\n        else if(input[i].contains(\"q\")) {\n            blackScore += QUEEN;\n        }\n\n        else if(input[i].contains(\"n\")) {\n            blackScore += KNIGHT;\n        }\n\n        else if(input[i].contains(\"b\")) {\n            blackScore += BISHOP;\n        }\n\n        else if(input[i].contains(\"p\")) {\n            blackScore += PAWN;\n        }\n\n        else if(input[i].contains(\"k\")) {\n            blackScore += KING;\n        }\n\n        else if(input[i].contains(\"r\")) {\n            blackScore += ROOK;\n        }\n\n\n    }\n\n    if(whiteScore != blackScore) {\n\n    if(blackScore > whiteScore) {\n        System.out.println(\"Black\");\n    }\n\n    if (whiteScore > blackScore) {\n        System.out.println(\"White\");\n\n    } \n    }else {\n        System.out.println(\"Draw\");\n    }\n\n\n    System.out.println(whiteScore);\n    System.out.println(blackScore);\n}\n}\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Generate all combinations from a limited list of single digit numbers equating to a digital root\r\n                \r\nI am attempting to generate a \"Nonary Game\" based on the data you feed to the code.\n\nIn the game Zero Escape 999, there are 9 players, each carrying an index from 1 to 9. The players are forced to split up into groups due to Numbered Doors blocking their path, which requires from 3 to 5 players to sum their indexes and create a digital root. Example:\n\nTwo doors numbered 4 and 5.\n\nAvailable players: 123456789.\n\nOne of many viable split-ups:\n\nGroup #4: 1237=1+2+3+7=13=1+3=4, players #1, #2, #3, #7 can make it through the door\n\nGroup #5: 45689=4+5+6+8+9=32=3+2=5, players #4, #5, #6, #8, #9 can make it through the door.\n\nNow this is where my code plays in:\nThe objective is to generate a long list of possible combinations from currently available player list and display all the outcomes where:\n\nA) There are players left behind, and\n\nB) No players are left behind.\n\nThe current code snippet works as intended, however, it cannot account for more than 2 doors and does not let you display all the available combinations should you provide only a single door number. I am stuck on this part as I cannot come up with a good, recursive method that would account for 3-door split-up possibilities in a decent manner.\n\nThe minimum amount of groups should be 2, and the maximum amount of groups should be equal to the number of doors available.\n\nSo if there are three doors, the script will spit out from two to three teams. If there are four doors, it'll display from two to four teams, etc.\n\nTo minimize the amount of data displayed, I am using a smaller pool of players of 123456; 2 players per door minimum, 4 maximum and two numbered doors 4 and 8. This is the console output:\n\n```\nPlease input the total players in a single string, e.g. 123456789. 123456\nPlease input lowest amount of players per door. 2\nPlease input highest amount of players per door. 4\nPlease input amount of doors. 2\nPlease input number for door 1. 4\nPlease input number for door 2. 8\nThe digital root of the doors is 3.\n4: 13, 8: 26    left behind: 45\n4: 13, 8: 2456  left behind:\n4: 256, 8: 134  left behind:\n4: 346, 8: 125  left behind:\n4: 1246, 8: 35  left behind:\n4: 1345, 8: 26  left behind:\nDisplaying all possible combos.```\n\n\n```\nfrom itertools import combinations\n\ndef digit_root(n): \n    return (n - 1) % 9 + 1 if n else 0\n\n\nplayers = input('Please input the total players in a single string, e.g. 123456789. ')\nplayer_combinations = [''.join(l) for i in range(len(players)) for l in combinations(players, i+1)]\nminplayers = int(input(\"Please input lowest amount of players per door. \"))\nmaxplayers = int(input(\"Please input highest amount of players per door. \"))\nwhile True:\n    doortotal = int(input(\"Please input amount of doors. \"))\n\n    doors = []\n    for i in range(doortotal):\n        doors.append({\"num\": int(input(\"Please input number for door {}. \".format(i+1))), \"combos\": []})\n\n        for combo in player_combinations:\n            if len(combo) >= minplayers and len(combo) <= maxplayers and digit_root(int(combo)) == doors[i][\"num\"]:\n                doors[i][\"combos\"].append(combo)\n\n    door_root = digit_root(sum([door[\"num\"] for door in doors]))\n    print(\"The digital root of the doors is {}.\".format(door_root))\n\n    # for door in doors:\n    #   print('Door #{} individual combos:'.format(door[\"num\"]))\n    #   print('\\n'.join(door[\"combos\"]))\n\n    def get_combo(comboA, comboB):\n        if any(a for a in comboA if a in comboB) == True: #We can't have the same player entering one or several doors at once\n            return None\n        combo = comboA + comboB\n        dif = ''.join([a for a in players if not (a in combo)])\n        print(\"{}: {}, {}: {} \\tleft behind: {}\".format(doors[0][\"num\"], comboA, doors[1][\"num\"], comboB, dif))\n        return combo\n\n    for comboA in doors[0][\"combos\"]:\n        for comboB in doors[1][\"combos\"]:\n            get_combo(comboA, comboB)\n\n    input(\"Displaying all possible combos.\")\n```\n\n\nThe script is expected to account for more than 2 doors and list all available combinations for teams of 2 to door count. I need assistance in creating a viable recursive loop that goes in such fashion:\n\n```\n3 doors - 3,7,8.```\n\n\nDisplay possible combinations for:\n\n```\nDoors 3+7, doors 3+8, doors 7+8, doors 3+7+8```\n\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Chessboard Game Excercise c#\r\n                \r\nProblem 2 – Chessboard Game\n\nGoshko is a keen chess player. One day he was bored with his work and decided to take a break and create a game using the chessboard. He takes a string, e.g. \"Software University_2345\", converts its symbols to numbers through their ASCII codes and fills a chessboard with them. He takes the values of capital and small letters and digits only. The value of any other symbol is zero. He fills the board’s squares with the numbers, from left to right and from top to bottom (see the example below). The size of the chessboard is n*n (e.g. n = 5) and it always starts with a black square. N will always be an odd number.\n\n```\nS   o   f   t   w       \n\na   r   e       U       \n\nn   i   v   e   r       \n\ns   i   t   y   _       \n\n2   3   4   5       \n\n\n\n83  111 102 116 119\n\n97  114 101 0   85\n\n110 105 118 101 114\n\n115 105 116 121 0\n\n50  51  52  53  0\n```\n\n\nLet’s assume that there are two competing teams: the black team and the white team. Every team’s score is the sum of the values in its squares. However if a square contains a capital letter its value should be given to the opposing team. In the example above the scores are calculated as follows:\n\nWhite Team Score = 83 'S' + 111 'o' + 116 't' + 97 'a' + 101 'e' + 105 'i' + 101 'e' + 115 's' + 116 't' + 51 '3' + 53 '5' = 1049\n\nBlack Team Score = 102 'f' + 119 'w' + 114 'r' + 85 'U' + 110 'n' + 118 'v' + 114 'r' + 105 'i' + 121 'y' + 50 '2' + 52 '4' = 1090.\n\nInput\nThe input data should be read from the console.\n\n•   The first line holds the size n of the chessboard.\n\n•   The second line holds the input string.\n\nThe input data will always be valid and in the format described. There is no need to check it explicitly.\n\nOutput\nThe output should be printed on the console.\n\n•   The first output line holds the winning team in format: “The winner is: {name} team”.\n\n•   The second line holds the difference between the scores of the winning and the losing team. \n\n•   In case the score is equal, print “Equal result: {points}”. Do not print the difference in this case!\n\nHere is my current code:\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChessboardGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int boardSize = int.Parse(Console.ReadLine());\n            string inputString = Console.ReadLine();\n            char[,] board = new char[boardSize, boardSize];\n            int p = inputString.Length;                                         //check so it doesnt go out of range of the string\n            int i = 0;                                                          //to know which element of the string to store into the matrix\n            int whiteScore = 0;\n            int blackScore = 0;\n            int oddOrEven = 0;                                                  //to know if the cell is odd or even\n\n            for (int row = 0; row < boardSize; row++)                           //filling the matrix\n            {\n                if (p == 0)\n                    break;\n\n                for (int col = 0; col < boardSize; col++)\n                {\n                    if (p == 0)\n                        break;\n\n                    board[row, col] = inputString[i];\n                    i++;\n                    p--;\n                }\n            }                                                                  \n            for (int row = 0; row < boardSize; row++)                           //calculating score\n            {\n                for (int col = 0; col < boardSize; col++)\n                {\n                    if (oddOrEven % 2 == 0)\n                    {\n                        if (!(((int)board[row, col] >= 65 && (int)board[row, col] <= 90) && ((int)board[row, col] >= 97 && (int)board[row, col] <= 122)))\n                        {\n                            if ((int)board[row, col] >= 65 && (int)board[row, col] <= 90)\n                            {\n                                whiteScore += (int)board[row, col];\n                            }\n                            else\n                            {\n                                blackScore += (int)board[row, col];\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if (!(((int)board[row, col] >= 65 && (int)board[row, col] <= 90) && ((int)board[row, col] >= 97 && (int)board[row, col] <= 122)))\n                        {\n                            if ((int)board[row, col] >= 65 && (int)board[row, col] <= 90)\n                            {\n                                blackScore += (int)board[row, col];\n                            }\n                            else\n                            {\n                                whiteScore += (int)board[row, col];\n                            }\n                        }\n                    }\n                    oddOrEven++;\n                }\n            }\n            if (whiteScore > blackScore)\n            {\n                Console.WriteLine(\"The winner is: white team\");\n                Console.WriteLine(whiteScore - blackScore);\n            }\n            else if (blackScore > whiteScore)\n            {\n                Console.WriteLine(\"The winner is: black team\");\n                Console.WriteLine(blackScore - whiteScore);\n            }\n            else\n            {\n                Console.WriteLine(\"Equal result: {0}\", whiteScore);\n            }\n\n        }\n    }\n}\n```\n\n\nI am getting wrong answers.\n\nI enter\n\n\n  5\n  Software University_2345\n\n\nI expect\n\n\n  The winner is: black team\n  41\n\n\nBut I receive\n\n\n  The winner is: white team\n  22\n\n\nI just can't figure it out. I've been trying to switch the teams places. Also I think there might be something wrong with my expression for checking weather a letter is capital or not.\n    ", "Answer": "\r\nI've made a few changes in your loops:\n\n```\nfor (int row = 0; row < boardSize; row++) //calculating score\n{\n    for (int col = 0; col < boardSize; col++)\n    {\n        char c = board[row, col];\n        if (oddOrEven % 2 == 0)\n        {\n            if (char.IsLetterOrDigit(c))\n            {\n                if (char.IsUpper(c))\n                {\n                    whiteScore += c;\n                }\n                else\n                {\n                    blackScore += c;\n                }\n                Console.WriteLine(c);\n            }\n        }\n        else\n        {\n            if (char.IsLetterOrDigit(c))\n            {\n                if (char.IsUpper(c))\n                {\n                    blackScore += c;\n                }\n                else\n                {\n                    whiteScore += c;\n                }\n                Console.WriteLine(c);\n            }\n        }\n        oddOrEven++;\n    }\n}\n```\n\n\nIt now works like a charm. The issue was the way you were checking is a char was valid or not. ```\n.Net```\n framework is full of useful tools, don't hesitate to use them. Here I just used ```\nchar.IsLetterOrDigit(c)```\n to save you.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Problems calling another class [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have to use 2 classes to complete a sort of game,\n\"Units\" are the soldiers that fight in our fictitious war. Units will be defined by a class in python called Unit. For Nick Wars, our units will have the following properties:\nTeam - A string indicating which team the unit belongs to. This will always either be \"Red\" or \"Blue\". Must be initialized.\nHP - hitpoints / health / energy / pep. The amount of damage a unit can sustain before being killed. Units can not regain or recover HP. Must be initialized.\nATT - attack / strength. The amount of damage a unit can do in a single hit. Must be initialized.\nattack_timeout - The amount of time that must pass between attacks, measured in tick's (see methods below). Must be initialized.\nisDead - True if this unit is dead, False if it is living. Initializes to False.\nMethods:\ntick(self, opponents) - each time tick is called, we simulate one unit of time passing inside the game scenario. Any \"automatic\" behaviours of a unit are defined here (so, we are in essence programming the unit AI). The argument opponents is a list of all units which are valid attack targets. The following behaviours must be created if isDead is False. A dead unit performs none of these behaviours and immediately returns the integer value 0.\nIf the list of opponents has any living units, this unit attacks the unit with the lowest HP (see the attack method). In this case, this method returns the integer value 0. If multiple units have the same HP, go with the first unit with that HP in the list of opposing units.\nIf the list of opponents is empty or contains no living units, return this unit's attack value. This will be used later to calculate damage to the enemy's base.\nThe above two actions can only occur if it has been the specified number of ticks since the last attack by this unit. How to keep try of this is left as an exercise to the reader.\nattack(self, other) - Called when this unit (self) attacks a defending unit (other). The defending unit has it's HP reduced by this unit's attack value. If this reduces the defending unit's HP to or past zero, set isDead to True.\nI've completed this part and it looks like this\n```\nclass Unit:\n\ndef __init__(self,Team,HP,ATT,attack_timeout,isDead = False):\n    self.Team = Team\n    self.HP = HP\n    self.ATT = ATT\n    self.attack_timeout = attack_timeout\n    self.isDead = isDead\n    self.lastuse = attack_timeout\n    \ndef attack(self,other):\n    self.lastuse = 0\n    other.HP -= self.ATT\n    if other.HP <= 0:\n        other.isDead = True\n\ndef tick(self,opponents):\n    \n    if self.isDead == True:\n        return 0\n    \n    else:\n        \n        healths = []\n        lowest = None\n        \n        if not opponents:\n            self.lastuse = 0\n            return self.ATT\n        \n        \n            \n        if self.lastuse == self.attack_timeout:\n            \n            for i in opponents:\n                healths.append(i.HP)\n            \n            if sum(healths)<=0:\n                self.lastuse = 0\n                return self.ATT\n            \n            else:\n                for i in opponents:\n                    if lowest == None or i.HP < lowest:\n                        lowest = i.HP\n                for j in opponents:\n                    if j.HP == lowest:\n                        break\n\n                Unit.attack(self,j)\n                return (0)\n\n\n        self.lastuse += 1\n        return 0\n```\n\nthe second part that is giving me difficulty is using this class in an army class given below\nSince a lot of code will be reused between the two opposing armies, it makes sense to encapsulate them as their own class.\nDefine an Army class with the following properties and methods:\nProperties:\nTeam - A string indicating which team the unit belongs to. This will always either be \"Red\" or \"Blue\". Must be initialized.\nBaseHP - The amount of health the army's base has remaining. Initializes to 1000\nGoldRate - The number of gold the army gains per tick. Initializes to 10.\nGold - The amount of gold the team has for buying units and increasing GoldRate. Initializes to 0.\nRoster - A list of dictionaries specifying the properties of the units available for purchase. Must be initialized.\nPrice - The amount of gold the unit costs\nHP - amount of health the unit starts with\nATT - attack power of the unit\nattack_timeout - number of time the unit must wait between attacks.\nUnits - A list of Unit objects which currently exist.\nMethods:\ntick(self,opponents) - Aside from self, takes a list of the other team's units opponents. Invokes the tick methods of every unit in the list of Units, and passes each the list of opponents. The return values of each Unit's tick method indicate the amount of damage done to the opponent's base. Compute the sum of these return values and return that sum from this tick method. In addition, the team's Gold value is increased by the value of GoldRate.\nBuryDead(self) - Removes from the list of Units all Units for which isDead is True.\nBuyGoldRate(self) - If the team has more than 250 gold, reduces the team's gold by 250 and adds 2 to GoldRate.\nBuyUnit(self, x) - x is an integer indicating the index of the unit in the roster is to be purchased. If the team has an amount of gold greater than or equal to the Price value of the unit specified by x, a new Unit is initialized with the properties specified in the roster entry, and is added to the Units list. If the specified roster item doesn't exist, raise a NoSuchUnitError exception. If there is not enough gold to purchase the unit, create a TooPoorError exception.\nI tried doing this\n```\nclass TooPoorError (Exception):\n     pass\n\nclass NoSuchUnitError (Exception):\n     pass\n\nclass Army(Unit):\n\n     def __init__ (self,Team,Roster,BaseHP = 1000,GoldRate = 10,Gold = 0):\n         self.Team = Team\n         self.BaseHP = BaseHP\n         self.GoldRate = GoldRate\n         self.Gold = Gold\n         self.Roster = Roster\n         self.Units = []\n    \n    def tick (self,opponents):\n         self.Gold += self.GoldRate  \n         for i in self.Units:\n             return (Unit.tick(i,opponents))       \n        \n    def BuryDead(self):\n         pass\n            \n        \n    def BuyGoldRate(self):\n         if self.Gold>=250:\n             self.GoldRate += 2\n              self.Gold-= 250\n\n    def BuyUnit(self, x):\n             if self.Gold>=self.Roster[x][\"Price\"]:\n                 self.Gold -= self.Roster[x][\"Price\"]\n                 self.Units.append(Unit(self,self.Roster[x][\"HP\"],self.Roster[x][\"ATT\"],self.Roster[x][\"attack_timeout\"]) )\n            \n             if self.Gold<self.Roster[x][\"Price\"]:\n                 raise TooPoorError\n```\n\nI'm having trouble using my previous class in order to run the tick function and keep getting a return of 0\nthe test case is below:\n```\n#Visible test\n\nRedArmy  = Army('Red',  [{'Price': 20, 'HP': 100, 'ATT': 7, 'attack_timeout': 3},\n                         {'Price': 15, 'HP':  70, 'ATT': 5, 'attack_timeout': 2}])\n\nBlueArmy = Army('Blue', [{'Price': 13, 'HP':  60, 'ATT': 4, 'attack_timeout': 1},\n                         {'Price': 16, 'HP':  80, 'ATT': 6, 'attack_timeout': 3}])\n\n# Collecting gold\n\nfor i in range(30):\n    RedArmy.tick([])\n    BlueArmy.tick([])\n\nRedArmy.BuyGoldRate()\nBlueArmy.BuyGoldRate()\n\nfor i in range(5):\n    RedArmy.tick([])\n    BlueArmy.tick([])\n\n    \n# Training the army\n\nRedArmy.BuyUnit(0)\nRedArmy.BuyUnit(0)\nRedArmy.BuyUnit(1)\n\nBlueArmy.BuyUnit(1)\nBlueArmy.BuyUnit(1)\nBlueArmy.BuyUnit(1)\nBlueArmy.BuyUnit(0)\n\nprint('Gold calculation for Blue: --------', BlueArmy.Gold == 49)\nprint('Gold calculation for Red: ---------', RedArmy.Gold == 55)\n\n# Fight\n    \nBlueDamage = 0\nRedDamage  = 0\n\nBlueUnits_HP = []\nBlueUnits_Dead = []\n\nRedUnits_HP = []\nRedUnits_Dead = []\n\nfor i in range(80):\n    BlueDamage += RedArmy.tick(BlueArmy.Units)\n    RedDamage  += BlueArmy.tick(RedArmy.Units)\n    \nfor u in BlueArmy.Units:\n    BlueUnits_HP += [u.HP]\n    BlueUnits_Dead += [u.isDead]\n\nfor u in RedArmy.Units:\n    RedUnits_HP  += [u.HP]\n    RedUnits_Dead += [u.isDead]\n\nprint('Damage calcultion for Blue: -------', BlueDamage == 0)\nprint('Damage calcultion for Red: --------', RedDamage == 42)\nprint('Blue units HP: --------------------', BlueUnits_HP == [-4, 31, 80, -4] or BlueUnits_HP == [0, 31, 80, 0])\nprint('Blue units status: ----------------', BlueUnits_Dead == [True, False, False, True])\nprint('Red units HP: ---------------------', RedUnits_HP == [-4, -2, 0] or RedUnits_HP == [0, 0, 0])\nprint('Red units status: -----------------', RedUnits_Dead == [True, True, True])\n```\n\n    ", "Answer": "\r\nthis was pretty fun code to play around with!\nI had to make a few changes to get it to work, partly to understand what was happening and make the code a bit more pythonic. I made some assumptions about the intended purpose of various methods/how you wanted the attack priorities to work, but I'll explain everything and try justify it all.\nGeneral\nThroughout I've switched from CamelCase to snake_case for variable names, and have passed the code through a linter to bring it in line with the Python PEP 8 style guide.\nAdded the ```\nTooPoorError```\n\n```\nclass NoSuchUnitError(Exception):\n    pass\n\n\nclass TooPoorError(Exception):\n    pass\n```\n\nArmy\nAdded guard clauses to raise exceptions when buying units.\nChanged how tick worked a little - now you can call it as ```\narmy.tick()```\n to just advance gold, or pass in another army to battle them. The way you had called the tick was a bit weird, so I'm not sure if that was perhaps what was giving you a return of 0? You can just loop over the units in ```\narmy.units```\n and for each ```\nunit```\n, call the ```\ntick```\n method against the opponent. I used a list comprehension to do this loop and sum the output damage. I think you may have been encountering some issues because you were returning the output of the first units 'tick', and killing the loop.\nYou were also inheriting from Unit - I wouldn't say an Army is-a Unit, instead that an Army has-a Unit.\n```\nclass Army:\n\n    def __init__(self, team, roster, hp=1000, gold_rate=10, gold=0):\n        self.team = team\n        self.hp = hp\n        self.gold_rate = gold_rate\n        self.gold = gold\n        self.roster = roster\n        self.units = []\n\n    def tick(self, opponents=None):\n        self.gold += self.gold_rate\n\n        if opponents is not None:\n            return sum([unit.tick(opponents) for unit in self.units])\n\n    def buy_gold_rate(self):\n        if self.gold >= 250:\n            self.gold_rate += 2\n            self.gold -= 250\n\n    def buy_unit(self, x):\n        if self.gold < self.roster[x][\"Price\"]:\n            raise TooPoorError\n\n        if x > len(self.roster):\n            raise NoSuchUnitError\n\n        self.gold -= self.roster[x][\"Price\"]\n        self.units.append(Unit(self.roster[x][\"HP\"], self.roster[x][\"ATT\"],\n                               self.roster[x][\"attack_timeout\"]))\n```\n\nUnit\nRemoved the team passed in as a keyword to clear things up a bit, as it wasn't used. Removed the isDead argument (would you ever make a new Unit that starts dead?).\nGuard clauses are a nice way to minimise the amount of indentation used, and I put a couple in the ```\ntick```\n method. I also added a property that helps make the tracking of whether the unit is on cooldown a bit simpler.\n```\nclass Unit:\n    def __init__(self, hp, attack_strength, attack_timeout):\n        self.hp = hp\n        self.attack_strength = attack_strength\n        self.attack_timeout = attack_timeout\n        self._last_use = attack_timeout\n\n        self.is_dead = False\n\n    def attack(self, other):\n        self.lastuse = 0\n        other.hp -= self.attack_strength\n        if other.hp <= 0:\n            other.hp = 0\n            other.is_dead = True\n\n    def tick(self, opponent):\n        # \n        if self.is_dead:\n            return 0\n\n        if self.on_cooldown:\n            self._last_use += 1\n            return 0\n\n        # Find out if any opposing units are alive\n        if all([unit.is_dead for unit in opponent.units]):\n            self._last_use = 0\n            return self.attack_strength\n        else:\n            lowest_hp = 1e10\n            for unit in opponent.units:\n                if unit.hp < lowest_hp and not unit.is_dead:\n                    lowest = unit\n                    lowest_hp = unit.hp\n\n            self.attack(lowest)\n\n        self._last_use = 0\n        return 0\n\n    @property\n    def on_cooldown(self):\n        if self._last_use != self.attack_timeout:\n            return True\n        else:\n            return False\n```\n\nHere are the updated tests:\n```\n\nred_army = Army('Red',  [{'Price': 20, 'HP': 100, 'ATT': 7, 'attack_timeout': 3},\n                         {'Price': 15, 'HP':  70, 'ATT': 5, 'attack_timeout': 2}])\n\nblue_army = Army('Blue', [{'Price': 13, 'HP':  60, 'ATT': 4, 'attack_timeout': 1},\n                          {'Price': 16, 'HP':  80, 'ATT': 6, 'attack_timeout': 3}])\n\n# Collecting gold\nfor _ in range(30):\n    red_army.tick()\n    blue_army.tick()\n\nred_army.buy_gold_rate()\nblue_army.buy_gold_rate()\n\nfor _ in range(5):\n    red_army.tick()\n    blue_army.tick()\n\n# Training the army\nred_army.buy_unit(0)\nred_army.buy_unit(0)\nred_army.buy_unit(1)\n\nblue_army.buy_unit(1)\nblue_army.buy_unit(1)\nblue_army.buy_unit(1)\nblue_army.buy_unit(0)\n\nprint('Gold calculation for Blue: --------', blue_army.gold == 49)\n\nprint('Gold calculation for Red: ---------', red_army.gold == 55)\n\n# Fight\nblue_damage = 0\nred_damage = 0\n\nfor i in range(80):\n    blue_damage += red_army.tick(blue_army)\n    red_damage += blue_army.tick(red_army)\n\nblue_units_hp = [unit.hp for unit in blue_army.units]\nblue_units_dead = [unit.is_dead for unit in blue_army.units]\n\nred_units_hp = [unit.hp for unit in red_army.units]\nred_units_dead = [unit.is_dead for unit in red_army.units]\n\nprint('Damage calculation for Blue: ---', blue_damage == 0)\nprint('Damage calculation for Red: ----', red_damage == 42)\nprint('Blue units HP: -----------------', blue_units_hp == [0, 31, 80, 0])\nprint('Blue units status: -------------', blue_units_dead == [True, False, False, True])\nprint('Red units HP: ------------------', red_units_hp == [0, 0, 0])\nprint('Red units status: --------------', red_units_dead == [True, True, True])\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Need help figuring out orbits in 2D for my game\r\n                \r\nIn a game that I'm making, the idea is that the mouse cursor is representing a center of mass and there are objects orbiting around it.\nThe cursor itself is not an object and there is no collision between the cursor and the objects. \n\nThe ideal method would be the one where I can enter x and y coordinates of the target, and maybe the orbit radius, and the object would go into orbit and would be accelerating constantly. \nWhen I move the mouse, the object would follow; and when I stop it, it would fall back into the same orbit radius. \nThe objects acceleration should also be able to change so it gives an effect that the mouse has more or less mass.\n\nI thought the best way to achieve this would probably be with vectors. \n\nIn the Projectile class I gave each projectile 4 fields: x coordinate, y coordinate, PVector speed and PVector acc (acceleration). \n\nThe first thing I tried is giving the object constant acceleration. Speed vector starts as zero, the acceleration vector is calculated, its magnitude is then set to some value and it is added to the speed vector. \nThis produced very large orbits, slow acceleration and when the mouse is moved, the orbit just became larger. \n\nNext I tried making the acceleration increase when it is closer to the center of mass inspired by the actual planets. This did not work either. The orbits were still too large and not controllable. Kind o disappointed I tried making the acceleration constantly increasing which gave the best results. The orbit is now getting smaller, but it just keeps decreasing to some radius and then stops. This would be perfect if the radius at which it stops decreasing would be configurable, but no matter the parameters the orbit is always too large and the orbit size keeps decreasing frustratingly slowly. My guess is that the acceleration and speed somehow end up in an equilibrium, and then the orbit stops decreasing.\n\n```\nvoid move(float x,float y,float accm)\n  {\n    PVector target = new PVector(x, y);\n    PVector ball = new PVector(this.x, this.y);\n    acc = PVector.sub(target, ball);\n    acc.setMag(accm);\n    speed.add(acc);\n    println(acc.mag() + \" \" + speed.mag());\n    this.x = this.x + speed.x;\n    this.y = this.y + speed.y;\n  }\n```\n\n\nThis is the function that gave the best results. The function is called in ```\ndraw()```\n:\n\n```\nif(mousePressed == true)\n  {\n    for(i=0;i<nproj;i++)\n    {\n      a[i].move(mouseX, mouseY,k);\n    }\n    k += n;\n  }\n```\n\n\nk is the number given to the function and n is the rate at which acceleration increases. I tried many different acceleration magnitudes and different rates of acceleration and just couldn't figure it out. Nproj is the number of projectiles and a is the name of the projectile array.\n\nI found that for k = 0 and n = 0.002 it gave the most reliable and stable results. If n is larger (around 0.01 or larger), the objects sometimes randomly flies off way further than expected, and it actually increases the orbit radius. As the acceleration increases this happens more often, and the object sometimes ends up off the screen and then it never comes back. I know that orbit radius doesn't exist because the orbits are elliptical, but it just makes it easier to explain.\n\nUpdate:\nThis is what I came up with so far\n\n```\nvoid move(float x,float y,float accm)\n  {\n    PVector target = new PVector(x, y);\n    PVector ball = new PVector(this.x, this.y);\n    acc = PVector.sub(target, ball);\n    acc.setMag(accm);\n    vel.add(acc);\n    this.x = this.x + vel.x;\n    this.y = this.y + vel.y;\n    vel.limit(15);\n  }\n```\n\n\nand in ```\ndraw()```\n\n\n```\nif(mousePressed == true)\n  {\n    for(i=0;i<nproj;i++)\n    {\n      a[i].move(mouseX, mouseY,k);\n    }\n    k += n;\n    if(k > 25)\n    n = 0;\n  }\n```\n\n\nBy limiting the velocity vector and constantly increasing acceleration vector, magnitude difference begins to increase and since the acceleration vector is increasing and the velocity vector is constant and acceleration vector points towards the target the sum of the vectors starts slowly pointing more and more towards the target. The condition ```\nif(k < 25)```\n is there to limit the acceleration and by changing the limit of the acceleration you can change the orbit radius.\n    ", "Answer": "\r\nI think you probably would have gotten a quicker answer over at https://physics.stackexchange.com/ and framing your question as \"how do I simulate gravity in a game?\"\n\nAnyway I will give it a try...\n\n\n  In the class Projectile I gave each projectile 4 fields: x coordinate, y coordinate PVector speed and PVector acc\n\n\nSounds good so far, except you don't need to store the acceleration vector with the object.  You'll calculate a new acceleration vector for each object on each \"tick\" of your simulation.\n\nI would use standard physics terminology here and call each object's vector ```\nvelocity```\n instead of ```\nspeed```\n.\n\n\n  Next I tried making the acceleration increase when it is closer to the center of mass inspired by the actual planets.\n\n\nThis behavior should just happen naturally if you use the right algorithm for calculating an orbit.\n\nYour \"sun\" and the \"planets\" each have a mass.  Masses attract each other with a gravitational force, which is ```\nF = G * m1 * m2 / d^2```\n from Wikipedia.\n\nRemember that ```\nForce = mass * acceleration```\n, and you have the acceleration as ```\na = m * G / d^2```\n where ```\nm```\n is the mass of the other object (in this case the sun), and ```\nd```\n is the distance between the two objects.  So the important part is that the acceleration of an object due to gravity varies with the distance squared between the two objects.\n\nSo your basic algorithm for a single tick of your simulation looks like this:\n\n\nFor each planet, calculate an acceleration vector\nUse the distance to the \"sun\" squared as the magnitude of the acceleration vector (times a constant value that depends on your \"gravitational constant\" and your sun's mass), and the direction is of course the direction from the planet towards the sun\nAdd this acceleration vector to the velocity vector for the planet\nAdd the velocity vector to the (x, y) position of the planet to move it forward.\n\n\nWith appropriate values for the length of each simulation tick, the gravitational constant, and the sun's mass, this should start to look pretty reasonable.\n\nSince you're assuming that the planets are all independent and cannot collide, you can just do the calculation independently for each planet.\n\nHowever, I think the game might be more interesting with a more accurate simulation.  In reality, every object has a gravitational force on every other object.  This would mean looping over all pairs of objects and doing the same kind of acceleration/velocity/position calculation.\n\nThe point of the game could then be to get the \"planets\" from one side of the screen to the other, in increasingly difficult starting configurations as they are all affecting each other and moving in different directions.\n\nIn order to make all of this work well, it would be important to set the mass of the \"sun\" many times higher than the mass of the planets, and to choose a reasonable value for your gravitational constant based on the timing of your simulation.  You'll have to play with these constants to find the best results.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How do I find the maximim number of iterations in a 4-tuple ducci series given some parameters for a, b, c and s?\r\n                \r\nAs mentioned in the title, I am trying to solve a math problem where I need to find the maximum number of iterations (M) of a 4-tuple ducci series. The question is below.\nAssign four nonnegative integers to the corners of a square, which we designate the active square. During a step, for each side of the active square, the absolute difference between the numbers on that side’s endpoints is assigned to its midpoint. Then these four new midpoints are connected into a new square (tilted 45 degrees from the previous). This new smaller square becomes the active square. Continue these steps until the active square has all zeroes on its corners.\nDefine f(a, b, c, d) to be the total number of squares drawn during this process when beginning with the numbers (a, b, c, d) written on the starting square in clockwise order. For example, given a starting arrangement of (10, 6, 3, 1), we would get the sequence of\n(4, 3, 2, 9)\n(1, 1, 7, 5)\n(0, 6, 2, 4)\n(6, 4, 2, 4)\n(2, 2, 2, 2)\n(0, 0, 0, 0)\nwhere the game ends (pictured above). So f(10, 6, 3, 1) = 7. And trivially, f(0, 0, 0, 0) = 1.\nConsider the set S = {(a, b, c, d) | a, b, c, and d are all integers with 0 <= a, b, c, d <= 10,000,000}. Let M be the maximum value f obtains on S. Find (a, b, c, d) in S with minimum sum (a+b+c+d) where f(a, b, c, d) = M. Enter your answer as a semicolon-separated list, 10;6;3;1 for example.\nI first tried this problem using excel solver, and while my solution is correct, it is too big of a calculation for my laptop.\nI then tried it in python, I have found a way to make and check ducci sequences using the code below, but not to actually find the answer to the question.\n```\ndef ducci_sequence(*ns):\n    while True:\n        yield ns\n        ns = tuple(abs(ns[i - 1] - ns[i]) for i in range(len(ns)))\n\ndef ducci(*ns):\n    known = set()\n    for ns in ducci_sequence(*ns):\n        print(ns)\n        if ns in known or set(ns) == {0}:\n            break\n        known.add(ns)\n    return len(known) + 1\nprint(ducci(0, 24, 68, 149), \"steps\")\n```\n\nThis will output:\n(0, 24, 68, 149)\n(149, 24, 44, 81)\n(68, 125, 20, 37)\n(31, 57, 105, 17)\n(14, 26, 48, 88)\n(74, 12, 22, 40)\n(34, 62, 10, 18)\n(16, 28, 52, 8)\n(8, 12, 24, 44)\n(36, 4, 12, 20)\n(16, 32, 8, 8)\n(8, 16, 24, 0)\n(8, 8, 8, 24)\n(16, 0, 0, 16)\n(0, 16, 0, 16)\n(16, 16, 16, 16)\n(0, 0, 0, 0)\n17 steps\nAny guidance will be much appreciated.\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "How can I create arrays within a loop (within another loop) and pass them back out in Javascript?\r\n                \r\nI'm using Google Docs Spreadsheet API to keep track of a competition between some of my friends. I have some big ideas, but I'm stumped right now. I'm trying to create 20 different arrays inside of loops (see below) and then evaluate each one outside of the loop, and I really don't want to write 20 \"if...then\" statements.\n\nNOTE: the following SUMMARY may or may not help you answer my question. You might want to skip down to the code, then read this if you need it :)\n\nSummary of the program: Each player assigns point values in favor of one possible outcome of a set of binary-outcome events. As the events happen, players either gain the points assigned if their outcome occurs, or gain no points if the opposite outcome occurs. My goal is to 1) figure out exactly when a player is eliminated, and 2) highlight all remaining events that must be won for them to have a chance at tying for first.\n\nInstead of trying to somehow evaluate all possibilities (5 players picking, 2^16 outcomes... I have zero computer science knowledge, but this seems like an incredibly huge task even for the modern computer) I've come up with an alternate idea. The script loops through each player, against each other opponent. It calculates the maximum number of points a player can score based on their value assignments and the already determined game. For one player and one opponent, it checks the best possible outcome by the player against that opponent, and if there is any opponent he cannot beat, even in the best case, then he is eliminated.\n\nThis part is easy-- after the loop runs inside the loop, I just adjust a global variable that I created earlier, and when the outer loop is done, just grab those variables and write them to the sheet.\n\nUnfortunately, this misses the case of where he could have a best case against each individual opponent, but not against multiple opponents at once.\n\nSo the next step is what I'm trying to do now. I'm not even sure I can give a good explanation without just showing you the entire spreadsheet w/script, but I'll try. So what I want to do now is calculate the \"value\" of each event for each player against a given other player. If both player and opponent assigned points in favor of the same event outcome for one event, the event's value is the difference between the picks (positive if player picked higher, negative if lower), and it's the SUM if they picked opposite event outcomes. Now, I do the same thing as before-- take a best-case scenario for a player against a given opponent-- but now I check by how much the player can beat the opponent in a best-case scenario. Then I evaluate the (absolute value of the) event value against this difference, and if it's greater, then the event is a must win (or must lose if the event value is negative). And, if an event is both a \"must-win\" and a \"must lose\" event, then the player is eliminated.\n\nThe problem is that this second step requires me to create a new array of values for each player-opponent combination, and then do things with the values after they're created.\n\nI realize one approach would be to create 20 different arrays, and throughout the entire loops, keep checking \"if (player == \"1\" && opponent == 2){}\" and populate the arrays accordingly, but this seems kind of ridiculous. And more importantly, this entire project is my attempt at learning javascript, so what's the point in using a time-intensive workaround that doesn't teach me anything new?\n\nI'm trying to understand square bracket notation, since it seems to be the answer to my question, but a lot of people are also suggesting that it's impossible to create variable names by concatenating with the value of another variable... so anyway, here's what I'm trying. I'd really appreciate either a fix to my approach, or a better approach.\n\n```\nfor (var player=1; player<6; player++){\n  if(player==1){look up certain columns in the spreadsheet and save them to variables}\n  //ditto for other players\n\n  for(var opponent=1; opponent<6; opponent++){\n    if(player!=opponent){\n      if(opponent==1){save more values to variables}\n      //ditto for other players\n\n  for(var row=9; row<24; row++) {\n//Now the script goes down each row of an array containing the original\n//spreadsheet info, and, based on information determined by the variables\n//created above, get values corresponding to the player and opponent.\n//So what I'd like to do here is create \"array[1,2]==\" and then \"array[1,3]==\"\n//and so forth, creating them globally (I think I understand that term by now) \n//so I can refer to them outside of the loops later to do some evaluatin'.\n  }\n}}\n//get array[1,2]...array[5,4] and do some operations with them.\n```\n\n\nThanks for getting through this little novel... really looking forward to your advice and ideas!\n    ", "Answer": "\r\nHow can I create arrays within a loop (within another loop)?\n\nCode update 2\n\nAs you said: \"i am trying to understand square bracket notation\" You may take a look at my new demo and the code: \n\n```\nfunction getTeam(){\n    var array = [[1,2,3],[4,5,6],[7,8,9]]; // arrays within arrays\n    // array myTeam \n    var myTeam = [[],[],[],[]];\n    var playerNames = [\"John\", \"Bert\", \"Dave\", \"Milton\"]; \n    var ages =[]; \n    var weight = 104;\n    // loop over the team arrayadd each player (name, age and weight) to the team  \n    for (i=0; i < myTeam.length; i++){            \n        // fill the age array in a loop\n        for (j=0;j<myTeam.length;j++) {\n            ages[j] = 23 + j;            \n        }        \n        myTeam[i].push([playerNames[i], ages[i], weight]);\n    }\n    return myTeam;\n}\n```\n\n\nAnd pass them back out in Javascript\n\nCould you elaborate on this part?\n\nUpdate\n\n```\nvar valuesOfPlayers=[];\nfor (var player=1; player<6; player++){\n\n  // look up certain columns in the spreadsheet and save them to variables\n  // you could call a funcntion and return the values you \n  // collected in an array within an array as in the demo above\n  valuesOfPlayers[player] = lookupColumnValues(player);\n\n  for(var opponent=1; opponent<6; opponent++){\n    if(player!=opponent){\n       // save more values to variables\n       valuesOfPlayers[player] = addValuesToVar(player);\n    }\n\n  for(var row=9; row<24; row++) {\n       // if you collect the values in your first and second if clause\n       // what other information do you want to collect\n       // Please elaborate this part?\n  }\n}}\n```\n\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "generating a list in arrays and use of functions\r\n                \r\nI am wondering how to make an array with values that start at 1111 and go all the way up to 8888. I am asking this because I need to generate a list of 4 digit numbers with each digit ranging from 1-8. I would like to have this in a loop form. Also, I am lost on my functions trim, methodicalEliminate, guessAndEliminate, and guessThreeThenEliminate in my following program. Here are the directions:\n\nThis assignment focuses on the use of arrays in a program, including using one as a parameter to a function. \n\nPROBLEM DESCRIPTION\nIn the game of Mastermind, a player is only given a finite number of guesses to try to identify the hidden combination (such as twelve guesses). Often that is the only constraint in playing the game. \nBut some players might make a competition with each other to see who can guess the other's combination in fewer tries. In this case, the problem is not only to come up with a strategy that can find the answer within a specified limit, but to find one that is likely to require the minimal number of guesses. \n\nHere is where the computer comes in -- one can write a program that would try out different guessing strategies, and see how they work out. Since a computer can do the analysis and computations more rapidly than a person, it could just pretend to play Mastermind on our behalf using any strategy we choose, and tell us how long it took to do that. \n\nOVERALL SOLUTION\n\nOf course, it would be extremely difficult to teach the computer to reason along the same lines as a person. For example, if we guessed a combination 1111 and got one black peg, we would make a mental note that the answer has exactly one 1 in it, and then proceed to make other guesses with that one fact in mind. If we next guesses 1222 and got one white peg, we would know there were no 2's, and that the single 1 is not in the first position. But how to keep track of such information after a series of guesses would be rather hard. \n\nFortunately, for a computer simulation with an array, we can record all of our known facts in a different way. We just maintain a list of all possible answers that there could be, and then remove numbers from the list that could no longer be the solution. If our first guess tells us there is exactly one 1 digit, we would remove all the numbers that do not have that feature. When we find out there are no 2's, we eliminate all the values that contain 2's. Eventually, the only number left would be the correct answer. \n\nSOME SIMPLE STRATEGIES\n\n\nThis is a strategy that many players use, resembling what was described above. Just methodically got through the possibilities in a straightforward fashion. The first guess of 1111 would answer how many 1's are in the solution; the next guess would answer how many 2's are in the solution, and also say something about where any 1's might be, and so on. \nWith our list approach, which contain a whole lot of possibilities in order beginning with 1111, 1112, 1113, 1114, etc., our next guess would always be the first in the list. \nThe next strategy is for those who like a little more excitement. The guesses appear to be more or less random, with the hopes that a lot more information can be discovered. Simulating this approach is surprisingly simple -- if you have a list of numbers, just pick one at random. If you have 837 possibilities to choose from in an array, just pick a random subscript in the range of 0 to 836. \nThis third strategy considers the possibility that answers that give similar results to a given guess are in a sense similar to each other. So to try to get a little more information, it will still pick some numbers at random without regard to how they were evaluated, and then only start thinking about the results. \nTo implement this one, let us just pick any three possible answers and guess them, temporarily ignoring how many black pegs and white pegs they earn us. Only after making those guesses will we trim the list of possibilities, then proceeding as the second strategy above. \n\n\nSAMPLE INTERFACE\nThese are the sample results from the current implementation: Please enter a combination to try for, or 0 for a random value:  0\nGuessing at 2475\n\n```\nGuessing 1111...\nGuessing 2222...\nGuessing 2333...\nGuessing 2444...\nGuessing 2455...\nGuessing 2456...\nGuessing 2475...\n```\n\n\nMethodical Eliminate required 7 tries.\n\n```\nGuessing 6452...\nGuessing 2416...\nGuessing 2485...\nGuessing 2445...\nGuessing 2435...\nGuessing 2425...\nGuessing 2475...\n```\n\n\nGuess and Eliminate required 7 tries.\n\n```\nGuessing 7872...\nGuessing 6472...\nGuessing 1784...\nGuessing 2475...\n```\n\n\nGuess Three then Eliminate required 4 tries.\n\nPlay another game?  (y/n) y\nPlease enter a combination to try for, or 0 for a random value:  0\nGuessing at 4474\n\n```\nGuessing 1111...\nGuessing 2222...\nGuessing 3333...\nGuessing 4444...\nGuessing 4445...\nGuessing 4464...\nGuessing 4474...\n```\n\n\nMethodical Eliminate required 7 tries.\n\n```\nGuessing 3585...\nGuessing 7162...\nGuessing 4474...\n```\n\n\nGuess and Eliminate required 3 tries.\n\n```\nGuessing 8587...\nGuessing 1342...\nGuessing 1555...\nGuessing 7464...\nGuessing 6764...\nGuessing 4468...\nGuessing 4474...\n```\n\n\nGuess Three then Eliminate required 7 tries.\nNOTE: This program allows each digit to go up to 8 instead of 6. Even though there are 4096 possible answers, it still finds them rather rapidly. \n\nPROGRAM SPECIFICATIONS\nThe assigned program must implement all of the following functions. Additional ones are permitted as desired -- these below are required. Future assignments will not detail the functions as below -- but will instead require the students to design their own function descriptions in advance to writing the program. main:\nSimply governs the overall behavior of the program.  A number will be\nchosen as the target combination, and then each strategy will attempt\nto find it.\nCalls:  generateAnswer,      (to compare all three must have the same answer)\n        methodicalEliminate, guessAndEliminate, guessThreeThenEliminate\n\ngenerateAnswer:\nEither lets the user at the keyboard choose the mystery combination,\nor gives the option to have the computer generate a random combination.\n(For a competitive game, it might be interesting to know what sorts\nof combinations would be the hardest to guess!)\nParameters:   none!\nReturns:      a 4-digit combination, each digit in the range 1 to 8\n\ngenerateSearchSpace:\nPopulates an array with all possible combinations of four-digit\nvalues in the range 1 to 8.\nParameters:\n    guesses (modified int array)    list of guesses\n    length  (output int)        number of values in list\nPre-condition:\n    The array must be allocated to no fewer than 4096 elements.\n\ntrim:\nAnalyzes the response to a particular guess and then eliminates\nany values from the list of possibilities that are no longer\npossible answers.  In each case, it assumes that a value in the\nlist is an answer, and evaluates the guess accordingly.  If the\nnumber of black and white pegs is not the same as those specified,\nthen it cannot be the correct answer.\nParameters:\n    guesses (modified int array)    list of guesses\n    length  (modified int)      number of values in list\n    guess   (input int)     a guess that has been evaluated\n    black   (input int)     how many black pegs that guess earned\n    white   (input int)     how many white pegs that guess earned\nPre-condition:\n    black and white actually do contain the results of comparing\n    the guess with the actual answer\nPost-condition:\n    length has been reduced (we learned something)\n    the viable answers occupy the first 'length' positions\n        in the guesses array (so the list is shorter)\nCalls:  evaluate\n\nmethodicalEliminate:\n    beginning with a list of all possible candidate answers\n    continually guesses the first element in the list, and\n    trim answers accordingly, until an answer is found\nParameter:\n    answer  (input int)     the actual answer\n                    (necessary to get black/white pegs)\nReturns: number of guesses required to find the answer\nCalls:   generateSearchSpace, evaluate, trim\n\ngusssAndEliminate:\n    beginning with a list of all possible candidate answers\n    continually guesses a random element in the list, and\n    trim answers accordingly, until an answer is found\nParameter:\n    answer  (input int)     the actual answer\nReturns: number of guesses required to find the answer\nCalls:   generateSearchSpace, evaluate, trim\n\ngusssThreeThenEliminate:\n    beginning with a list of all possible candidate answers\n    first guesses three answers at random before trimming\n    the list of possibilites, and then narrows on the answer\n    one random guess at a time\nParameter:\n    answer  (input int)     the actual answer\nReturns: number of guesses required to find the answer\nCalls:   generateSearchSpace, evaluate, trim\n\nNOTE: These last functions use the correct answer to evaluate\neach guess and then use the black/white pegs for the guessing\nstrategy.  NOne of these strategies may peek at the answer to\ndecide what to do next!\n\nALSO: The following functions should also appear in this program\nfrom the previous assignment, though they are not themselves\npart of the grade for this one.\n\nevaluate:\nevaluates a combination by comparing it with the answer\nCorrectness is indicated by black pegs (correct digit in correct position)\nand white pegs (correct digit in incorrect position)\nParameters:\n    answer  (input int) the correct combination\n    guess   (input int) the current guess\n    black   (output int)    number of black pegs\n    white   (output int)    number of white pegs\npre-conditions:\n    answer and guess are both 4-digit numbers with no zero digits\npost-conditions:\n    black and white are both > 0  and their sum is <= 4\nCalls: nthDigit, clearNthDigit\n\nnthDigit:\nidentified the n'th digit of a combination\nwhether digits count from left to right or right to left is unspecified\nParameters:\n    combination (input int) combination to examine\n    position    (input int) which digit to examine\n    (returned)  (output int)    the value of the actual digit\npre-conditions:\n    combination has the appropriate number of digits, and\n    0 < position <= number of digits\npost-condition:\n    0 <= returned digit <= 9    (single digit)\n\nclearNthDigit:\nears the n'th digit of a combination to zero, so it will no longer match\ndigits must be counted in the same manner as nthDigit above.\nparameters:\n    combination (in/out int)    combination to modify\n    position    (input int) which digit to set to 0\npre-condition:\n    same as those for nthDigit above\npost-condition:\n    corresponding digit is set to zero\nCalls: nthDigit (optional, depending on the implementation)\n\nThank you for reading such this long question, and I hope you can help me on arrays!\n    ", "Answer": "\r\nJust because your guesses have the form of 1111 through to 8888, it does not mean they are numbers.\n\nThey are numbers if it makes sense to do arithmetic calculations on them. It does not make sense to define arithmetic calculations on the guesses: what would it mean to add a guess 4571 to a guess 6214?\n\nIf your guesses are not numbers, don't use a representation that is reserved for numbers. You can, however, use an array of four integers:\n\n```\nint guesses[4][4096];\nint g = 0;\nfor (int i = 1; i <= 8; ++i)\n  for (int j = 1; j <= 8; ++j)\n    for (int k = 1; k <= 8; ++k)\n      for (int m = 1; m <= 8; ++m)\n        guesses[g++] = {i, j, k, m};\n```\n\n\nI am pretty convinced that putting all possible guesses into the array ```\nguesses```\n like that is not a good idea either; the code mainly demonstrates how the guesses could be generated.\n\nGo through the other functions, think of what high level operations should be performed on the remaining gueses (like \"eliminate all guesses that has a certain number in the thrid position\" etc). This should give you an idea about what would be a better data structure to replace the ```\nguesses```\n array.\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "My implementation of the evaluation function and Alpha-beta pruning for Connect Four is not smart enough\r\n                \r\nI am trying to implement correctly the Connect Four game AI yet not to avail my AI acts stupid: \n\n\nIt does not block the opposite player pattern which can lead to failure of the AI,\nIt does not take moves that might lead to AI's victory.\n\n\nMy project consists of the following two GitHub-repositories:\n\n\nGameAI,\nConnectFour,\n\n\nwhere GameAI contains:\n\nSortingAlphaBetaPruningGameEngine\n\n```\npackage net.coderodde.zerosum.ai.impl;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport net.coderodde.zerosum.ai.EvaluatorFunction;\nimport net.coderodde.zerosum.ai.GameEngine;\nimport net.coderodde.zerosum.ai.State;\n\n/**\n * This class implements the \n * <a href=\"https://en.wikipedia.org/wiki/Minimax\">Minimax</a> algorithm for \n * zero-sum two-player games.\n * \n * @param <S> the game state type.\n * @param <P> the player color type.\n * @author Rodion \"rodde\" Efremov\n * @version 1.6 (May 26, 2019)\n */\npublic final class SortingAlphaBetaPruningGameEngine\n        <S extends State<S>, P extends Enum<P>> \n        extends GameEngine<S, P> {\n\n    /**\n     * Stores the terminal node or a node at the depth zero with the best value\n     * so far, which belongs to the maximizing player moves.\n     */\n    private S bestTerminalMaximizingState;\n\n    /**\n     * Stores the value of {@code bestTerminalMaximizingState}.\n     */\n    private double bestTerminalMaximizingStateValue;\n\n    /**\n     * Stores the terminal node or a node at the depth zero with the best value\n     * so far, which belongs to the minimizing player moves.\n     */\n    private S bestTerminalMinimizingState;\n\n    /**\n     * Stores the value of {@code bestTerminalMinimizingState}.\n     */\n    private double bestTerminalMinimizingStateValue;\n\n    /**\n     * Indicates whether we are computing a next ply for the minimizing player \n     * or not. If not, we are computing a next ply for the maximizing player.\n     */\n    private boolean makingPlyForMinimizingPlayer;\n\n    /**\n     * Maps each visited state to its parent state.\n     */\n    private final Map<S, S> parents = new HashMap<>();\n\n    /**\n     * Constructs this minimax game engine.\n     * @param evaluatorFunction the evaluator function.\n     * @param depth the search depth.\n     */\n    public SortingAlphaBetaPruningGameEngine(\n            EvaluatorFunction<S> evaluatorFunction,\n            int depth) {\n        super(evaluatorFunction, depth, Integer.MAX_VALUE);\n    }\n\n    /**\n     * {@inheritDoc }\n     */\n    @Override\n    public S makePly(S state, \n                     P minimizingPlayer,\n                     P maximizingPlayer,\n                     P initialPlayer) {\n        // Reset the best known values:\n        bestTerminalMaximizingStateValue = Double.NEGATIVE_INFINITY;\n        bestTerminalMinimizingStateValue = Double.POSITIVE_INFINITY;\n        makingPlyForMinimizingPlayer = initialPlayer != minimizingPlayer;\n\n        // Do the game tree search:\n        makePlyImpl(state,\n                    depth,\n                    Double.NEGATIVE_INFINITY, // intial alpha\n                    Double.POSITIVE_INFINITY, // intial beta\n                    minimizingPlayer,\n                    maximizingPlayer,\n                    initialPlayer);\n\n        // Find the next game state starting from 'state':\n        S returnState =\n                inferBestState(\n                        initialPlayer == minimizingPlayer ? \n                                bestTerminalMinimizingState : \n                                bestTerminalMaximizingState);\n\n        // Release the resources:\n        parents.clear();\n        bestTerminalMaximizingState = null;\n        bestTerminalMinimizingState = null;\n        // We are done with a single move:\n        return returnState;\n    }\n\n    private S inferBestState(S bestTerminalState) {\n        List<S> statePath = new ArrayList<>();\n        S state = bestTerminalState;\n\n        while (state != null) {\n            statePath.add(state);\n            state = parents.get(state);\n        }\n\n        if (statePath.size() == 1) {\n            // The root node is terminal. Return null:\n            return null;\n        }\n\n        // Return the second upmost state:\n        Collections.<S>reverse(statePath);\n        return statePath.get(1);\n    }\n\n    /**\n     * Performs a single step down the game tree branch.\n     * \n     * @param state the starting state.\n     * @param depth the maximum depth of the game tree.\n     * @param minimizingPlayer the minimizing player.\n     * @param maximizingPlayer the maximizing player.\n     * @param currentPlayer the current player.\n     * @return the value of the best ply.\n     */\n    private double makePlyImpl(S state,\n                               int depth,\n                               double alpha,\n                               double beta,\n                               P minimizingPlayer,\n                               P maximizingPlayer,\n                               P currentPlayer) {\n        if (depth == 0 || state.isTerminal()) {\n            double value = evaluatorFunction.evaluate(state);\n\n            if (!makingPlyForMinimizingPlayer) {\n                if (bestTerminalMinimizingStateValue > value) {\n                    bestTerminalMinimizingStateValue = value;\n                    bestTerminalMinimizingState = state;\n                }\n            } else {\n                if (bestTerminalMaximizingStateValue < value) {\n                    bestTerminalMaximizingStateValue = value;\n                    bestTerminalMaximizingState = state;\n                }\n            }\n\n            return value;\n        }\n\n        if (currentPlayer == maximizingPlayer) {\n            double value = Double.NEGATIVE_INFINITY;\n            List<S> children = state.children();\n            children.sort((S a, S b) -> {\n                double valueA = super.evaluatorFunction.evaluate(a);\n                double valueB = super.evaluatorFunction.evaluate(b);\n                return Double.compare(valueB, valueA);\n            });\n\n            for (S child : children) {\n                value = Math.max(\n                        value, \n                        makePlyImpl(child, \n                                    depth - 1, \n                                    alpha,\n                                    beta,\n                                    minimizingPlayer, \n                                    maximizingPlayer, \n                                    minimizingPlayer));\n\n                parents.put(child, state);\n                alpha = Math.max(alpha, value);\n\n                if (alpha >= beta) {\n                    break;\n                }\n            }\n\n            return value;\n        } else {\n            // Here, 'initialPlayer == minimizingPlayer'.\n            double value = Double.POSITIVE_INFINITY;\n            List<S> children = state.children();\n            children.sort((S a, S b) -> {\n                double valueA = super.evaluatorFunction.evaluate(a);\n                double valueB = super.evaluatorFunction.evaluate(b);\n                return Double.compare(valueA, valueB);\n            });\n\n            for (S child : children) {\n                value = Math.min(\n                        value,\n                        makePlyImpl(child, \n                                    depth - 1,\n                                    alpha,\n                                    beta,\n                                    minimizingPlayer, \n                                    maximizingPlayer, \n                                    maximizingPlayer));\n\n                parents.put(child, state);\n                beta = Math.min(beta, value);\n\n                if (alpha >= beta) {\n                    break;\n                }\n            }\n\n            return value;\n        }\n    }\n}\n```\n\n\nand I have two evaluation functions from the web/my head. The first one (see below), finds all the patterns of length 2, 3 and 4 and multiplies their occurrence counts by the constants that will favour the longer of them. Didn't seem to work. Another one maintains a matrix of integers; each integer denotes the number of patterns that may occupy the slot of that integers. Didn't work either.\n\nBruteForceConnectFourStateEvaluatorFunction\n\n```\npackage net.coderodde.games.connect.four.impl;\n\nimport net.coderodde.games.connect.four.ConnectFourState;\nimport net.coderodde.games.connect.four.PlayerColor;\nimport net.coderodde.zerosum.ai.EvaluatorFunction;\n\n/**\n * This class implements the default Connect Four state evaluator. The white \n * player wants to maximize, the red player wants to minimize.\n * \n * @author Rodion \"rodde\" Efremov\n * @version 1.6 (May 24, 2019)\n */\npublic final class BruteForceConnectFourStateEvaluatorFunction\n        implements EvaluatorFunction<ConnectFourState> {\n\n    private static final double POSITIVE_WIN_VALUE = 1e9;\n    private static final double NEGATIVE_WIN_VALUE = -1e9;\n    private static final double POSITIVE_CLOSE_TO_WIN_VALUE = 1e6;\n    private static final double NEGATIVE_CLOSE_TO_WIN_VALUE = -1e6;\n    private static final double BASE_VALUE = 1e1;\n\n    /**\n     * The weight matrix. Maps each position to its weight. We need this in \n     * order to \n     */\n    private final double[][] weightMatrix;\n\n    /**\n     * The winning length.\n     */\n    private final int winningLength;\n\n    /**\n     * Constructs the default heuristic function for Connect Four game states.\n     * \n     * @param width the game board width.\n     * @param height the game board height.\n     * @param maxWeight the maximum weight in the weight matrix.\n     * @param winningPatternLength the winning pattern length.\n     */\n    public BruteForceConnectFourStateEvaluatorFunction(final int width,\n                                             final int height,\n                                             final double maxWeight,\n                                             final int winningPatternLength) {\n        this.weightMatrix = getWeightMatrix(width, height, maxWeight);\n        this.winningLength = winningPatternLength;\n    }\n\n    /**\n     * Evaluates the given input {@code state} and returns the estimate.\n     * @param state the state to estimate.\n     * @return the estimate.\n     */\n    @Override\n    public double evaluate(ConnectFourState state) {\n        PlayerColor winnerPlayerColor = state.checkVictory();\n\n        if (winnerPlayerColor == PlayerColor.MAXIMIZING_PLAYER) {\n            return POSITIVE_WIN_VALUE - state.getDepth();\n        }\n\n        if (winnerPlayerColor == PlayerColor.MINIMIZING_PLAYER) {\n            return NEGATIVE_WIN_VALUE + state.getDepth();\n        }\n\n        // 'minimizingPatternCounts[i]' gives the number of patterns of \n        // length 'i':\n        int[] minimizingPatternCounts = new int[state.getWinningLength() + 1];\n        int[] maximizingPatternCounts = new int[minimizingPatternCounts.length];\n\n        // Do not consider patterns of length one!\n        for (int targetLength = 2; \n                targetLength <= winningLength; \n                targetLength++) {\n            int count = findMinimizingPatternCount(state, targetLength);\n\n            if (count == 0) {\n                // Once here, it is not possible to find patterns of larger \n                // length than targetLength:\n                break;\n            }\n\n            minimizingPatternCounts[targetLength] = count;\n        }\n\n        for (int targetLength = 2;\n                targetLength <= state.getWinningLength();\n                targetLength++) {\n            int count = findMaximizingPatternCount(state, targetLength);\n\n            if (count == 0) {\n                // Once here, it is not possible to find patterns of larger\n                // length than targetLength:\n                break;\n            }\n\n            maximizingPatternCounts[targetLength] = count;\n        }\n\n        double score = computeBaseScore(minimizingPatternCounts, \n                                        maximizingPatternCounts);\n        score += computeAlmostFullPatternScores(state, winningLength);\n        return score + getWeights(weightMatrix, state);\n    }\n\n    private static final double \n        computeAlmostFullPatternScores(ConnectFourState state,\n                                       int winningLength) {\n        final int targetLength = winningLength - 2;\n        double score = 0.0;\n\n        for (int y = state.getHeight() - 1; y >= 0; y--) {\n            loop:\n            for (int x = 0; x < state.getWidth() - targetLength; x++) {\n                if (state.readCell(x, y) == null) {\n                    // Try to find 'targetLength' marks:\n                    PlayerColor targetPlayerColor = state.readCell(x + 1, y);\n\n                    if (targetPlayerColor == null) {\n                        continue loop;\n                    }\n\n                    int currentLength = 1;\n\n                    for (int xx = x + 1; xx < state.getWidth() - 1; xx++) {\n                        if (state.readCell(xx, y) == targetPlayerColor) {\n                            currentLength++;\n\n                            if (currentLength == targetLength) {\n                                if (state.getPlayerColor() ==\n                                        PlayerColor.MINIMIZING_PLAYER) {\n                                    score += NEGATIVE_CLOSE_TO_WIN_VALUE;\n                                } else {\n                                    score += POSITIVE_CLOSE_TO_WIN_VALUE;\n                                }\n\n                                continue loop;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return score;\n        }\n\n        return score;\n    }\n\n    /**\n     * Finds the number of red patterns of length {@code targetLength}.\n     * @param state the target state.\n     * @param targetLength the length of the pattern to find.\n     * @return the number of red patterns of length {@code targetLength}.\n     */\n    private static final int findMinimizingPatternCount(ConnectFourState state,\n                                                        int targetLength) {\n        return findPatternCount(state, \n                                targetLength, \n                                PlayerColor.MINIMIZING_PLAYER);\n    }\n\n    /**\n     * Finds the number of white patterns of length {@code targetLength}. \n     * @param state the target state.\n     * @param targetLength the length of the pattern to find.\n     * @return the number of white patterns of length {@code targetLength}.\n     */\n    private static final int findMaximizingPatternCount(ConnectFourState state,\n                                                   int targetLength) {\n        return findPatternCount(state,\n                                targetLength, \n                                PlayerColor.MAXIMIZING_PLAYER);\n    }\n\n    /**\n     * Implements the target pattern counting function for both the player \n     * colors.\n     * @param state the state to search.\n     * @param targetLength the length of the patterns to count.\n     * @param playerColor the target player color.\n     * @return the number of patterns of length {@code targetLength} and color\n     * {@code playerColor}.\n     */\n    private static final int findPatternCount(ConnectFourState state,\n                                              int targetLength,\n                                              PlayerColor playerColor) {\n        int count = 0;\n\n        count += findHorizontalPatternCount(state, \n                                            targetLength, \n                                            playerColor);\n\n        count += findVerticalPatternCount(state, \n                                          targetLength, \n                                          playerColor);\n\n        count += findAscendingDiagonalPatternCount(state, \n                                                   targetLength,\n                                                   playerColor);\n\n        count += findDescendingDiagonalPatternCount(state, \n                                                    targetLength,\n                                                    playerColor);\n        return count;\n    }\n\n    /**\n     * Scans the input state for diagonal <b>descending</b> patterns and \n     * returns the number of such patterns.\n     * @param state the target state.\n     * @param patternLength the target pattern length.\n     * @param playerColor the target player color.\n     * @return the number of patterns.\n     */\n    private static final int \n        findDescendingDiagonalPatternCount(ConnectFourState state,\n                                           int patternLength,\n                                           PlayerColor playerColor) {\n        int patternCount = 0;\n\n        for (int y = 0; y < state.getWinningLength() - 1; y++) {\n            inner:\n            for (int x = 0;\n                    x <= state.getWidth() - state.getWinningLength(); \n                    x++) {\n                for (int i = 0; i < patternLength; i++) {\n                    if (state.readCell(x + i, y + i) != playerColor) {\n                        continue inner;\n                    }\n                }\n\n                patternCount++;\n            }\n        }\n\n        return patternCount;\n    }\n\n    /**\n     * Scans the input state for diagonal <b>ascending</b> patterns and returns\n     * the number of such patterns.\n     * @param state the target state.\n     * @param patternLength the target pattern length.\n     * @param playerColor the target player color.\n     * @return the number of patterns.\n     */\n    private static final int \n        findAscendingDiagonalPatternCount(ConnectFourState state,\n                                          int patternLength,\n                                          PlayerColor playerColor) {\n        int patternCount = 0;\n\n        for (int y = state.getHeight() - 1;\n                y > state.getHeight() - state.getWinningLength();\n                y--) {\n\n            inner:\n            for (int x = 0; \n                    x <= state.getWidth() - state.getWinningLength();\n                    x++) {\n                for (int i = 0; i < patternLength; i++) {\n                    if (state.readCell(x + i, y - i) != playerColor) {\n                        continue inner;\n                    }\n                }\n\n                patternCount++;\n            }\n        }\n\n        return patternCount;\n    } \n\n    /**\n     * Scans the input state for diagonal <b>horizontal</b> patterns and returns\n     * the number of such patterns.\n     * @param state the target state.\n     * @param patternLength the target pattern length.\n     * @param playerColor the target player color.\n     * @return the number of patterns.\n     */\n    private static final int findHorizontalPatternCount(\n            ConnectFourState state,\n            int patternLength,\n            PlayerColor playerColor) {\n        int patternCount = 0;\n\n        for (int y = state.getHeight() - 1; y >= 0; y--) {\n\n            inner:\n            for (int x = 0; x <= state.getWidth() - patternLength; x++) {\n                if (state.readCell(x, y) == null) {\n                    continue inner;\n                }\n\n                for (int i = 0; i < patternLength; i++) {\n                    if (state.readCell(x + i, y) != playerColor) {\n                        continue inner;\n                    }\n                }\n\n                patternCount++;\n            }\n        }\n\n        return patternCount;\n    }\n\n    /**\n     * Scans the input state for diagonal <b>vertical</b> patterns and returns\n     * the number of such patterns.\n     * @param state the target state.\n     * @param patternLength the target pattern length.\n     * @param playerColor the target player color.\n     * @return the number of patterns.\n     */\n    private static final int findVerticalPatternCount(ConnectFourState state,\n                                                      int patternLength,\n                                                      PlayerColor playerColor) {\n        int patternCount = 0;\n\n        outer:\n        for (int x = 0; x < state.getWidth(); x++) {\n            inner:\n            for (int y = state.getHeight() - 1;\n                    y > state.getHeight() - state.getWinningLength(); \n                    y--) {\n                if (state.readCell(x, y) == null) {\n                    continue outer;\n                }\n\n                for (int i = 0; i < patternLength; i++) {\n                    if (state.readCell(x, y - i) != playerColor) {\n                        continue inner;\n                    }\n                }\n\n                patternCount++;\n            }\n        }\n\n        return patternCount;\n    }\n\n    /**\n     * Gets the state weight. We use this in order to discourage the positions\n     * that are close to borders/far away from the center of the game board.\n     * @param weightMatrix the weighting matrix.\n     * @param state the state to weight.\n     * @return the state weight.\n     */\n    private static final double getWeights(final double[][] weightMatrix,\n                                           final ConnectFourState state) {\n        double score = 0.0;\n\n        outer:\n        for (int x = 0; x < state.getWidth(); x++) {\n            for (int y = state.getHeight() - 1; y >= 0; y--) {\n                PlayerColor playerColor = state.readCell(x, y);\n\n                if (playerColor == null) {\n                    continue outer;\n                }\n\n                if (playerColor == PlayerColor.MINIMIZING_PLAYER) {\n                    score -= weightMatrix[y][x];\n                } else {\n                    score += weightMatrix[y][x];\n                }\n            }\n        }\n\n        return score;\n    }\n\n    /**\n     * Computes the base scorer that relies on number of patterns. For example,\n     * {@code redPatternCounts[i]} will denote the number of patterns of length \n     * [@code i}.\n     * @param minimizingPatternCounts the pattern count map for red patterns.\n     * @param maximizingPatternCounts the pattern count map for white patterns.\n     * @return the base estimate.\n     */\n    private static final double computeBaseScore(\n            int[] minimizingPatternCounts,\n            int[] maximizingPatternCounts) {\n        final int winningLength = minimizingPatternCounts.length - 1;\n\n        double value = 0.0;\n\n        if (minimizingPatternCounts[winningLength] != 0) {\n            value = NEGATIVE_WIN_VALUE;\n        }\n\n        if (maximizingPatternCounts[winningLength] != 0) {\n            value = POSITIVE_WIN_VALUE;\n        }\n\n        for (int length = 2; length < minimizingPatternCounts.length; length++) {\n            int minimizingCount = minimizingPatternCounts[length];\n            value -= minimizingCount * Math.pow(BASE_VALUE, length);\n\n            int maximizingCount = maximizingPatternCounts[length];\n            value += maximizingCount * Math.pow(BASE_VALUE, length);\n        }\n\n        return value;\n    }\n\n    /**\n     * Computes the weight matrix. The closer the entry in the board is to the\n     * center of the board, the closer the weight of that position will be to\n     * {@code maxWeight}.\n     * \n     * @param width the width of the matrix.\n     * @param height the height of the matrix.\n     * @param maxWeight the maximum weight. The minimum weight will be always\n     * 1.0.\n     * @return the weight matrix. \n     */\n    private static final double[][] getWeightMatrix(final int width,\n                                                    final int height,\n                                                    final double maxWeight) {\n        final double[][] weightMatrix = new double[height][width];\n\n        for (int y = 0; y < weightMatrix.length; y++) {\n            for (int x = 0; x < weightMatrix[0].length; x++) {\n                int left = x;\n                int right = weightMatrix[0].length - x - 1;\n                int top = y;\n                int bottom = weightMatrix.length - y - 1;\n                int horizontalDifference = Math.abs(left - right);\n                int verticalDifference = Math.abs(top - bottom);\n                weightMatrix[y][x] =\n                        1.0 + (maxWeight - 1.0) / \n                              (horizontalDifference + verticalDifference);\n            }\n        }\n\n        return weightMatrix;\n    }\n}\n```\n\n\nWeightMatrixConnectFourStateEvaluatorFunction\n\n```\npackage net.coderodde.games.connect.four.impl;\n\nimport net.coderodde.games.connect.four.ConnectFourState;\nimport net.coderodde.games.connect.four.PlayerColor;\nimport net.coderodde.zerosum.ai.EvaluatorFunction;\n\n/**\n * This evaluation function relies on a weight matrix that reflects how many\n * patterns visit each matrix position.\n * \n * @author Rodion \"rodde\" Efremov\n * @version 1.6 (Jun 19, 2019)\n */\npublic class WeightMatrixConnectFourStateEvaluatorFunction implements EvaluatorFunction<ConnectFourState> {\n\n    private final double[][] matrix;\n\n    public WeightMatrixConnectFourStateEvaluatorFunction() {\n        this.matrix =  new double[][] {{3, 4,  5,  7,  5, 4, 3}, \n                                       {4, 6,  8, 10,  8, 6, 4},\n                                       {5, 8, 11, 13, 11, 8, 5}, \n                                       {5, 8, 11, 13, 11, 8, 5},\n                                       {4, 6,  8, 10,  8, 6, 4},\n                                       {3, 4,  5,  7,  5, 4, 3}};\n    }\n\n    @Override\n    public double evaluate(ConnectFourState state) {\n        PlayerColor winner = state.checkVictory();\n\n        if (winner == PlayerColor.MINIMIZING_PLAYER) {\n            return -1e6;\n        }\n\n        if (winner == PlayerColor.MAXIMIZING_PLAYER) {\n            return 1e6;\n        }\n\n        double sum = 0.0;\n\n        for (int y = 0; y < state.getHeight(); y++) {\n            for (int x = 0; x < state.getWidth(); x++) {\n                if (state.readCell(x, y) == PlayerColor.MAXIMIZING_PLAYER) {\n                    sum += matrix[y][x];\n                } else if (state.readCell(x, y) ==\n                        PlayerColor.MINIMIZING_PLAYER) {\n                    sum -= matrix[y][x];\n                }\n            }\n        }\n\n        return sum;\n    }\n}\n```\n\n\nI am completely clueless why both the evaluator functions fail to provide smart gaming. Any advice?\n    ", "Answer": "\r\nWinning and losing moves in a case like this are not heuristic functions, they are binary yes/no discrete answers. You shouldn't be treating them heuristically for a simple game like connect 4. You test each move \"will this win?\" (if so do it). If no, test each move \"does this prevent the other player from winning on their next move?\" (again, if so, do it). After that you apply heuristics to find the best move of those available.\n\nI suspect you're running into problems like \"a winning move in a corner (3 value) will never beat a losing move in the middle (13 value)\".\n    ", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Running Mr. Job in Hadoop mode. \"Error launching job , bad input path : File does not exist:\"\r\n                \r\nI'm running Apache Hadoop 3.1.0 in pseudo-distributed mode using the default configurations from the Wiki. \n\nI've created a simple python program that counts the article tag in the dblp.xml file posted below\n\n```\nfrom mrjob.job import MRJob\nimport sys\n\nclass MRArticleCount(MRJob):\n\n    def mapper(self, _, line):\n        yield \"articles\", line.count('</article>')\n\n    def reducer(self, key, counts):\n        yield key, sum(counts)\n\nif __name__ == '__main__':\n    MRArticleCount.run()\n```\n\n\nand running it with the command\n\n```\npython articleCounter.py -r hadoop hdfs:///user/hadoop/dblp/dblp.xml\n```\n\n\nreturns \n\n```\nNo configs found; falling back on auto-configuration\nNo configs specified for hadoop runner\nLooking for hadoop binary in $PATH...\nFound hadoop binary: /home/hadoop/hadoop/bin/hadoop\nUsing Hadoop version 3.1.0\nLooking for Hadoop streaming jar in /home/hadoop/hadoop...\nFound Hadoop streaming jar: /home/hadoop/hadoop/share/hadoop/tools/lib/hadoop-streaming-3.1.0.jar\nCreating temp directory /tmp/articleCounter.hadoop.20180416.013824.692915\nCopying local files to hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.013824.692915/files/...\nRunning step 1 of 1...\n  loaded properties from hadoop-metrics2.properties\n  Scheduled Metric snapshot period at 10 second(s).\n  JobTracker metrics system started\n  JobTracker metrics system already initialized!\n  Cleaning up the staging area file:/tmp/hadoop/mapred/staging/hadoop890329391/.staging/job_local890329391_0001\n  Error launching job , bad input path : File does not exist: /tmp/hadoop/mapred/staging/hadoop890329391/.staging/job_local890329391_0001/files/articleCounter.py#articleCounter.py\n  Streaming Command Failed!\nAttempting to fetch counters from logs...\nCan't fetch history log; missing job ID\nNo counters found\nScanning logs for probable cause of failure...\nCan't fetch history log; missing job ID\nCan't fetch task logs; missing application ID\nStep 1 of 1 failed: Command '['/home/hadoop/hadoop/bin/hadoop', 'jar', '/home/hadoop/hadoop/share/hadoop/tools/lib/hadoop-streaming-3.1.0.jar', '-files', 'hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.013824.692915/files/articleCounter.py#articleCounter.py,hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.013824.692915/files/mrjob.zip#mrjob.zip,hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.013824.692915/files/setup-wrapper.sh#setup-wrapper.sh', '-input', 'hdfs:///user/hadoop/dblp/dblp.xml', '-output', 'hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.013824.692915/output', '-mapper', 'sh -ex setup-wrapper.sh python articleCounter.py --step-num=0 --mapper', '-reducer', 'sh -ex setup-wrapper.sh python articleCounter.py --step-num=0 --reducer']' returned non-zero exit status 512\n```\n\n\nRunning it with verbose returns me this monstrosity:\n\n```\nLooking for configs in /home/hadoop/.mrjob.conf\nLooking for configs in /etc/mrjob.conf\nNo configs found; falling back on auto-configuration\nNo configs specified for hadoop runner\nActive configuration:\n{'bootstrap_mrjob': None,\n 'bootstrap_spark': None,\n 'check_input_paths': True,\n 'cleanup': ['ALL'],\n 'cleanup_on_failure': ['NONE'],\n 'cmdenv': {},\n 'hadoop_bin': None,\n 'hadoop_extra_args': [],\n 'hadoop_log_dirs': [],\n 'hadoop_streaming_jar': None,\n 'hadoop_tmp_dir': 'tmp/mrjob',\n 'interpreter': None,\n 'jobconf': {},\n 'label': None,\n 'libjars': [],\n 'local_tmp_dir': '/tmp',\n 'owner': 'hadoop',\n 'py_files': [],\n 'python_bin': None,\n 'setup': [],\n 'sh_bin': ['sh', '-ex'],\n 'spark_args': [],\n 'spark_master': 'yarn',\n 'spark_submit_bin': None,\n 'steps_interpreter': None,\n 'steps_python_bin': None,\n 'task_python_bin': None,\n 'upload_archives': [],\n 'upload_dirs': [],\n 'upload_files': []}\nLooking for hadoop binary in $PATH...\nFound hadoop binary: /home/hadoop/hadoop/bin/hadoop\n> /home/hadoop/hadoop/bin/hadoop fs -ls hdfs:///user/hadoop/dblp/dblp.xml\nSTDOUT: -rw-r--r--   1 hadoop supergroup 2257949018 2018-04-15 04:23 hdfs:///user/hadoop/dblp/dblp.xml\n> /home/hadoop/hadoop/bin/hadoop version\nUsing Hadoop version 3.1.0\n> /usr/bin/python /home/hadoop/articleCounter.py --steps\nLooking for Hadoop streaming jar in /home/hadoop/hadoop...\nFound Hadoop streaming jar: /home/hadoop/hadoop/share/hadoop/tools/lib/hadoop-streaming-3.1.0.jar\nCreating temp directory /tmp/articleCounter.hadoop.20180416.014112.103990\narchiving /home/hadoop/.local/lib/python2.7/site-packages/mrjob -> /tmp/articleCounter.hadoop.20180416.014112.103990/mrjob.zip as mrjob/\nWriting wrapper script to /tmp/articleCounter.hadoop.20180416.014112.103990/setup-wrapper.sh\nWRAPPER: # store $PWD\nWRAPPER: __mrjob_PWD=$PWD\nWRAPPER: \nWRAPPER: # obtain exclusive file lock\nWRAPPER: exec 9>/tmp/wrapper.lock.articleCounter.hadoop.20180416.014112.103990\nWRAPPER: python -c 'import fcntl; fcntl.flock(9, fcntl.LOCK_EX)'\nWRAPPER: \nWRAPPER: # setup commands\nWRAPPER: {\nWRAPPER:   export PYTHONPATH=$__mrjob_PWD/mrjob.zip:$PYTHONPATH\nWRAPPER: } 0</dev/null 1>&2\nWRAPPER: \nWRAPPER: # release exclusive file lock\nWRAPPER: exec 9>&-\nWRAPPER: \nWRAPPER: # run task from the original working directory\nWRAPPER: cd $__mrjob_PWD\nWRAPPER: \"$@\"\n> /home/hadoop/hadoop/bin/hadoop fs -mkdir -p hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/\nCopying local files to hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/...\n  /tmp/articleCounter.hadoop.20180416.014112.103990/mrjob.zip -> hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/mrjob.zip\n> /home/hadoop/hadoop/bin/hadoop fs -put /tmp/articleCounter.hadoop.20180416.014112.103990/mrjob.zip hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/mrjob.zip\n  /home/hadoop/articleCounter.py -> hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/articleCounter.py\n> /home/hadoop/hadoop/bin/hadoop fs -put /home/hadoop/articleCounter.py hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/articleCounter.py\n  /tmp/articleCounter.hadoop.20180416.014112.103990/setup-wrapper.sh -> hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/setup-wrapper.sh\n> /home/hadoop/hadoop/bin/hadoop fs -put /tmp/articleCounter.hadoop.20180416.014112.103990/setup-wrapper.sh hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/setup-wrapper.sh\nRunning step 1 of 1...\n> /home/hadoop/hadoop/bin/hadoop jar /home/hadoop/hadoop/share/hadoop/tools/lib/hadoop-streaming-3.1.0.jar -files 'hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/articleCounter.py#articleCounter.py,hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/mrjob.zip#mrjob.zip,hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/setup-wrapper.sh#setup-wrapper.sh' -input hdfs:///user/hadoop/dblp/dblp.xml -output hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/output -mapper 'sh -ex setup-wrapper.sh python articleCounter.py --step-num=0 --mapper' -reducer 'sh -ex setup-wrapper.sh python articleCounter.py --step-num=0 --reducer'\n  with environment: [('HOME', '/home/hadoop'), ('LANG', 'C'), ('LOGNAME', 'hadoop'), ('LS_COLORS', 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:'), ('MAIL', '/var/mail/hadoop'), ('OLDPWD', '/home/hadoop/hadoop/share/hadoop/tools/lib'), ('PATH', '/home/hadoop/hadoop/bin:/home/hadoop/hadoop/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games'), ('PWD', '/home/hadoop'), ('SHELL', '/bin/bash'), ('SHLVL', '1'), ('SSH_CLIENT', '192.168.1.188 40594 22'), ('SSH_CONNECTION', '192.168.1.188 40594 192.168.1.150 22'), ('SSH_TTY', '/dev/pts/2'), ('TERM', 'xterm-256color'), ('USER', 'hadoop'), ('XDG_RUNTIME_DIR', '/run/user/1000'), ('XDG_SESSION_ID', '18543'), ('_', '/usr/bin/python')]\nInvoking Hadoop via PTY\n  loaded properties from hadoop-metrics2.properties\n  Scheduled Metric snapshot period at 10 second(s).\n  JobTracker metrics system started\n  JobTracker metrics system already initialized!\n  Cleaning up the staging area file:/tmp/hadoop/mapred/staging/hadoop108797154/.staging/job_local108797154_0001\n  Error launching job , bad input path : File does not exist: /tmp/hadoop/mapred/staging/hadoop108797154/.staging/job_local108797154_0001/files/articleCounter.py#articleCounter.py\n  Streaming Command Failed!\nAttempting to fetch counters from logs...\nCan't fetch history log; missing job ID\nNo counters found\nScanning logs for probable cause of failure...\nCan't fetch history log; missing job ID\nCan't fetch task logs; missing application ID\nStep 1 of 1 failed: Command '['/home/hadoop/hadoop/bin/hadoop', 'jar', '/home/hadoop/hadoop/share/hadoop/tools/lib/hadoop-streaming-3.1.0.jar', '-files', 'hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/articleCounter.py#articleCounter.py,hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/mrjob.zip#mrjob.zip,hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/files/setup-wrapper.sh#setup-wrapper.sh', '-input', 'hdfs:///user/hadoop/dblp/dblp.xml', '-output', 'hdfs:///user/hadoop/tmp/mrjob/articleCounter.hadoop.20180416.014112.103990/output', '-mapper', 'sh -ex setup-wrapper.sh python articleCounter.py --step-num=0 --mapper', '-reducer', 'sh -ex setup-wrapper.sh python articleCounter.py --step-num=0 --reducer']' returned non-zero exit status 512\n```\n\n\nThe program itself runs perfectly fine inline with a test dataset but with the hadoop runner, fails. I believe that the problem is with the bad input path when launching the job but I do not know how to solve that. Any help would be appreciated and I would be happy to provide any configuration file or logs that will help solve the issue!\n\nThanks!\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
{"Question": "Shiny App won't deploy but it runs locally\r\n                \r\nMy Shiny app is running locally but won't deploy. I've looked through similar questions and tried going through simple things which could be causing it e.g., wrong filepaths, setwd but that's not the case.\nHere is some stuff from the logs:\nError in value[3L] :\nExecution halted\ndataTableOutput, renderDataTable\nError in value[3L] :\nShiny application exiting ...\nThe following object is masked from ‘package:graphics’:\ndataTableOutput, renderDataTable\nHere are some of the more relevant bits of the app.R file:\n```\npreds_with_mins <- read.csv(\"data/preds_with_mins.csv\", \n                             stringsAsFactors = FALSE)\n\n\nfilename <- paste0(\"data/all_players_final/all_players_finalgw\", season,\"_\",current_gw, \".csv\")\nxg_data <- read.csv(filename, stringsAsFactors = FALSE) %>% \n  dplyr::rename('npxg90' = \"npxG.90\",\n                'xa90'= \"xA.90\") %>% \n  dplyr::select(player_name, npxg90, xa90, Team)\n\nxg_data <- normal_preds %>% \n  dplyr::select(Player, Price, Position) %>% \n  dplyr::left_join(xg_data, by = c(\"Player\" = \"player_name\"))\n\n# xg_data[xg_data$Player == \"Rúben Dias\", \"Price\"] <- 6\n# normal_preds[normal_preds$Player == \"Rúben Dias\", \"Player\"] <- \"Ruben Dias\"\n# normal_preds[normal_preds$Player == \"João Cancelo\", \"Player\"] <- \"Joao Cancelo\"\n\nreview_data <- read.csv(\"data/fplreview_mins.csv\",\n                        stringsAsFactors = FALSE,\n                        encoding = \"UTF-8\") %>%\n  dplyr::select(2,3,4,6,8,10,12,14,16,1) %>%\n  dplyr::rename('Price' = 'BV') %>%\n  dplyr::select(1,2, 5:9, 3:4,10) %>%\n  dplyr::rename('Position' = 'X.U.FEFF.Pos')\n\nreview_data[review_data$Position ==  \"D\", \"Position\"] <- \"Defenders\"\nreview_data[review_data$Position ==  \"M\", \"Position\"] <- \"Midfielders\"\nreview_data[review_data$Position ==  \"F\", \"Position\"] <- \"Forwards\"\nreview_data[review_data$Position ==  \"G\", \"Position\"] <- \"Goalkeepers\"\n\nrev_gw_cols <- paste0(\"X\", c(first_gw:(first_gw + 4)), \"_Pts\")\n\nreview_total <- review_data %>%\n  tidyr::pivot_longer(rev_gw_cols,names_to = \"Gameweek\",values_to = \"points\") %>%\n  dplyr::select(ID, Name,Team,Position,Price,Gameweek,points)%>%\n  dplyr::group_by(ID,Name,Team,Position,Price) %>%\n  dplyr::summarise(`Review Total`=round(sum(points),1)) %>%\n  dplyr::ungroup() %>%\n  dplyr::select(ID,\n                Team,\n                Name,\n                `Review Total`,\n                Price,\n                Position) %>%\n  rename('Price (£m)' = 'Price',\n         'Player' = 'Name') %>%\n  filter(`Review Total` > 0) %>%\n  dplyr::arrange(desc(`Review Total`)) %>%\n  dplyr::filter(Position != \"Goalkeepers\")\n\nae_total <- preds_with_mins %>%\n  dplyr::select(1,2,4,6,8,10, id)  %>%\n  tidyr::pivot_longer(rev_gw_cols,names_to = \"Gameweek\",values_to = \"points\") %>%\n  dplyr::select(id, player_name,Gameweek,points) %>%\n  dplyr::group_by(id,player_name) %>%\n  dplyr::summarise(`AE Total`=round(sum(points),1)) %>%\n  dplyr::ungroup()\n\n\n\nall_model_preds <- review_total %>%\n  dplyr::left_join(ae_total,\n                   by = c(\"ID\" = \"id\")) %>%\n  dplyr::filter(!is.na(`AE Total`)) %>%\n  dplyr::select(Player,\n                `AE Total`,\n                `Review Total`,\n                `Price (£m)`,\n                Position,\n                Team)\n\n\nlevels(all_model_preds$Position) <- c(\"Defenders\",\"Midfielders\",\"Forwards\")\n\n\n\n#ui / front end\nui <- fluidPage(\n  titlePanel(tags$h1(\"Albert's FPL Model\" ,align=\"center\")),\n  sidebarLayout(\n    sidebarPanel(#h3(\"Filters\"),\n                 sliderInput(\"gwrange\",\"Gameweek Range\",value=c(first_gw,first_gw + 3),min = first_gw, max = 38, step=1),\n                 sliderInput(\"price_filter\",\"Price (£m)\",value=c(0,13.5),min=0,max=13.5,step=0.5),\n                 selectInput(\"plot_pos\",label=\"Position\",choices=c(\"All Players\",\"Defenders\",\"Midfielders\",\"Forwards\")),\n                 selectInput(\"team_filter\",label=\"Team\",choices=c(\"All Teams\", sort(unique(normal_preds$Team)))),\n                 selectInput(\"time_decay\", label = \"Time Decay\", choices = c(\"Yes\", \"No\"))\n                 ,width=2) #,textOutput(\"gwrange\") #h3(\"Gameweek Range:3-6\"),\n  ,\n  mainPanel(\n    tabsetPanel(\n      tabPanel(\"Albert's Model\",\n               DT::dataTableOutput(\"dynamic_df\"),downloadButton('download','Download')\n      ),\n      # tabPanel(\"Comparison With Review\",\n      #          DT::dataTableOutput(\"all_models\")),\n      tabPanel(\"Points vs Price Graph\",plotlyOutput(\"plot\", width = \"800px\")\n      ),\n      tabPanel(\"xG graphs\",plotlyOutput(\"xgplot\", width = \"800px\")\n      ),\n      tabPanel(\"Methodology\",htmlOutput(\"text\"))\n      \n  )#,width=10\n  \n  )\n ) \n)\n\n\n#server/back end\nserver <- function(input, output, session) {\n\n  \n  \n  #summarise data based on the gw range they've chosen\n  gws_cols <- reactive(paste0(\"gw\",seq(input$gwrange[1],input$gwrange[2],1)))\n  #gws_cols <- paste0(\"gw\",gws())\n  predictions <- shiny::reactive(\n    if (input$time_decay == \"No\") {\n      normal_preds\n    } else {\n      decayed_preds\n    })\n  all_model_preds2 <- shiny::reactive(\n    if (input$time_decay == \"No\") {\n      all_model_preds\n    } else {\n      all_model_preds\n    })\n\n  base_data <- reactive(pivot_longer(predictions(),gws_cols(),names_to = \"Gameweek\",values_to = \"Expected_points\") %>% \n    select(Player,Team,Position,Price,Gameweek,Expected_points)%>% \n    group_by(Player,Team,Position,Price) %>% \n    summarise(Points=round(sum(Expected_points),1)) %>% \n    ungroup() %>% \n    dplyr::select(Team,\n                  Player,\n                  Points,\n                  Price,\n                  Position) %>% \n    rename('Price (£m)' = 'Price') %>%\n      filter(Points>0) %>% \n      arrange(desc(Points)) ) \n  \n  \n  price_filtered_data <- reactive(base_data() %>% \n                                  dplyr::filter(`Price (£m)` >= input$price_filter[1],\n                                                  `Price (£m)` <= input$price_filter[2]))\n  \n  #output$static <- renderTable(head(all_preds))\n  #table_data <- reactive(if(input$plot_pos==\"All Players\"){filter(select(base_data(),-Position),`Price (£m)` >= input$price_filter[1] & `Price (£m)` <= input$price_filter[2])}else{ select(filter(base_data(),Position==input$plot_pos & `Price (£m)` >= input$price_filter[1] & `Price (£m)` <= input$price_filter[2], Team == input$team_filter),-Position)}) \n  table_data <- reactive(if(input$plot_pos==\"All Players\" & input$team_filter == \"All Teams\"){\n    price_filtered_data()} else if (input$plot_pos==\"All Players\" & input$team_filter != \"All Teams\"){\n      dplyr::filter(price_filtered_data(),Team == input$team_filter)}\n    else if (input$plot_pos!=\"All Players\" & input$team_filter == \"All Teams\"){\n      dplyr::filter(price_filtered_data(),Position==input$plot_pos)} else {\n        dplyr::filter(price_filtered_data(),Position==input$plot_pos & Team == input$team_filter)\n      }) \n  output$dynamic_df <- DT::renderDataTable(select(table_data(), -Team),options = list(pageLength = 10))#,extensions=\"buttons\",buttons=c('csv')\n  \n  price_filtered_data_rev <- reactive(all_model_preds2() %>%\n                                    dplyr::filter(`Price (£m)` >= input$price_filter[1],\n                                                  `Price (£m)` <= input$price_filter[2]))\n\n  #output$static <- renderTable(head(all_preds))\n  #table_data <- reactive(if(input$plot_pos==\"All Players\"){filter(select(base_data(),-Position),`Price (£m)` >= input$price_filter[1] & `Price (£m)` <= input$price_filter[2])}else{ select(filter(base_data(),Position==input$plot_pos & `Price (£m)` >= input$price_filter[1] & `Price (£m)` <= input$price_filter[2], Team == input$team_filter),-Position)})\n  table_data_rev <- reactive(if(input$plot_pos==\"All Players\" & input$team_filter == \"All Teams\"){\n    price_filtered_data_rev()} else if (input$plot_pos==\"All Players\" & input$team_filter != \"All Teams\"){\n      dplyr::filter(price_filtered_data_rev(),Team == input$team_filter)}\n    else if (input$plot_pos!=\"All Players\" & input$team_filter == \"All Teams\"){\n      dplyr::filter(price_filtered_data_rev(),Position==input$plot_pos)} else {\n        dplyr::filter(price_filtered_data_rev(),Position==input$plot_pos & Team == input$team_filter)\n      })\n  \n  \n  #output$all_models <- DT::renderDataTable(table_data_rev(),options = list(pageLength = 10), rownames = FALSE)\n  output$download <- downloadHandler(filename=function(){\"albertsfplmodel.csv\"},\n                                     content=function(fname){\n                                       write.csv(preds_with_mins,fname)\n                                     })\n  #output$plot <-  renderPlotly({if (input$plot_pos==\"Defenders\"){\n   # ggplotly(plot1, tooltip = \"text\") #ggplotly(plot1, tooltip = \"text\")\n  #} #else if (input$plot_pos==\"Midfielders\"){\n   # plot2 \n  #\n  #} else {\n   # plot3\n  #}}) #, res = 96\n  plot_data <- reactive(if(input$plot_pos==\"All Players\" & input$team_filter == \"All Teams\"){\n    base_data()} else if (input$plot_pos==\"All Players\" & input$team_filter != \"All Teams\"){\n      dplyr::filter(base_data(),Team == input$team_filter)}\n    else if (input$plot_pos!=\"All Players\" & input$team_filter == \"All Teams\"){\n      dplyr::filter(base_data(),Position==input$plot_pos)} else {\n        dplyr::filter(base_data(),Position==input$plot_pos & Team == input$team_filter)\n      }) \n # plot_cols <- reactive(if(input$plot_pos==\"All Players\"))\n  output$plot <- renderPlotly({ggplotly(ggplot(plot_data(),\n                                               aes(x=`Price (£m)`,y=Points,group=1,col=Position,\n                                                   text=paste(\"Player: \",Player,\"<br> Points: \",Points,\"<br> Price: £\",`Price (£m)`,\"m\",sep=\"\")))+  \n                                          geom_point() +\n                                          xlab(\"Price (£m)\")+\n                                          ylab(\"Points\")+scale_color_manual(values=c(\"Defenders\"=\"#F8766D\",\"Midfielders\"=\"#00BA38\",\"Forwards\"=\"#619CFF\")),tooltip=\"text\")}) \n  \n  xg_plot_data <- reactive(if(input$plot_pos==\"All Players\" & input$team_filter == \"All Teams\"){\n    xg_data} else if (input$plot_pos==\"All Players\" & input$team_filter != \"All Teams\"){\n      dplyr::filter(xg_data,Team == input$team_filter)}\n    else if (input$plot_pos!=\"All Players\" & input$team_filter == \"All Teams\"){\n      dplyr::filter(xg_data,Position==input$plot_pos)} else {\n        dplyr::filter(xg_data,Position==input$plot_pos & Team == input$team_filter)\n      })   \n  output$xgplot <- renderPlotly({ggplotly(ggplot(xg_plot_data(),\n                                               aes(x=xa90,y=npxg90,group=1,col=Position,\n                                                   text=paste(\"Player: \",Player,\"<br> Price: £\",Price,\"m\",sep=\"\")))+  \n                                          geom_point() +\n                                          xlab(\"xA/90\")+\n                                          ylab(\"npxG/90\")+scale_color_manual(values=c(\"Defenders\"=\"#F8766D\",\"Midfielders\"=\"#00BA38\",\"Forwards\"=\"#619CFF\")),tooltip=\"text\")}) \n  \n  \n  output$text <- renderText({paste0(h3(\"Data\"),\"The data used for the model is expected goal and assist data from www.Fbref.com \" ,\"</p>\",h3(\"Goal and Assist Points\"),\"</p>\",\n     \"A weighted average of the last 20 games is used to calculate a player's average non-penalty expected goals per 90 (npxg/90) and expected assists per 90 (xA/90).\n    A player's average npxg/90 and xa/90 are adjusted for each game by the defensive strength of the opposition and if they're playing home or away. This is then multiplied by the number of points scored for a goal or assist.\",h3(\"Clean Sheet Points\"),\"</p>\",\n    \"Weighted averages of non-penalty expected goals are also used to determine the attacking and defensive strength of each team.\",\"</p>\",\"To estimate points from clean sheets, a team's defensive strength is adjusted by the attacking strength of the opposition team and if they are playing at home or away. Their adjusted defsenive strength is then used as the mean of a poisson distribtution, to work out the probability of conceding zero goals.\n    This probability is then multiplied by the number of points scored for keeping a clean sheet.\",\"</p>\",h3(\"Miscallaneous\"),\"</p>\",\"Players may also have their npxg/90 average modified depending on their finishing skill and if they take penalties.\",\n     \"</p>\",\"All Predictions are adjusted by the number of minutes each player is estimated to play, with estimates taken from www.fplreview.com. This means players who are currently injured and more likely to be rotated are predicted fewer points.\",\"</p>\",\"Predictions for new signings or promoted players are not available or inaccurate due to lack of data.\",\n    \"</p>\", \"Alpha = 0.8 is used for the decayed predictions.\")})\n  #output$gwrange <- renderText({\"These Predictions are for gameweeks 3 to 6\"})\n  #+\n  #scale_color_manual(values=c(\"#F8766D\",\"00BA38\",\"619CFF\"))\n  #\n  #original mins_data df\n  #output$mins_data_original <- DT::renderDataTable(mins_data,options = list(pageLength = 10))\n  #reactive values to store mins_data df (which gets updated)\n  #values <- reactiveValues(df = mins_data)\n  #updating the df when user updates their estimates of a player's mins\n  #observeEvent(input$update_mins,{values$df[values$df$player_name==input$player_name,\"avg_mins\"] <- input$new_mins})\n  #output$mins_data_dynamic <- DT::renderDataTable(values$df)#,options = list(pageLength = 10))\n}\nshinyApp(ui, server)\n```\n\nIt deployed fine before but I'm now having problems due to the 'all_model_preds' dataframe.\nI've written this in a rush as I'm about to head out, please let me know if I need to be more specific\n    ", "Answer": "", "Knowledge_point": "Zero-Sum Games", "Tag": "算法分析"}
