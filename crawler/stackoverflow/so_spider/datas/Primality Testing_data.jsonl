{"Question": "Primality Testing [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Fastest primality test  \n\n\n\n\nCan somebody give an efficient algorithm for determining the primality of an number?\n\nThe conventional iteration method seems to take a lot of time when testing primality of large numbers. I have tried some probabilistic algorithms but was not satisfied by the accuracy.\n    ", "Answer": "\r\nOn of the most efficient probabilistic primality tests is the Rabin-Miller primality test (implementation in C). This is what RSA uses.\n\nDeterministic tests are more difficult if you need speed and are seldomly useful in real world applications.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fastest primality test\r\n                \r\nCould you suggest a fast, deterministic method that is usable in practice, for testing if a large number is prime or not?   \n\nAlso, I would like to know how to use non-deterministic primality tests correctly. For example, if I'm using such a method, I can be sure that a number is not prime if the output is \"no\", but what about the other case, when the output is \"probably\"? Do I have to test for primality manually in this case?\n\nThanks in advance. \n    ", "Answer": "\r\nThe only deterministic, polynomial-time algorithm for primality testing I know of is the AKS primality test (http://en.wikipedia.org/wiki/AKS_primality_test).  However, there are a lot of very good randomized primality tests that are fast and have extremely good probability of success.  They usually work by finding whether the number is composite with exponentially good probability, so they'll either report that the number is composite or will require you to say \"maybe\" with very good confidence.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Sample code for fast primality testing in C# [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Fastest algorithm for primality test  \n\n\n\n\nWould appreciate a reference to sample code for fast primality testing in C#, preferably using BigInteger or other variable size type.\n    ", "Answer": "\r\nThis is a ```\nMiller Rabin```\n test in c#:\n\n```\n    bool MillerRabin(ulong n)\n    {\n        ulong[] ar;\n        if (n < 4759123141) ar = new ulong[] { 2, 7, 61 };\n        else if (n < 341550071728321) ar = new ulong[] { 2, 3, 5, 7, 11, 13, 17 };\n        else ar = new ulong[] { 2, 3, 5, 7, 11, 13, 17, 19, 23 };\n        ulong d = n - 1;\n        int s = 0;\n        while ((d & 1) == 0) { d >>= 1; s++; }\n        int i, j;\n        for (i = 0; i < ar.Length; i++)\n        {\n            ulong a   = Math.Min(n - 2, ar[i]);\n            ulong now = pow(a, d, n);\n            if (now == 1) continue;\n            if (now == n - 1) continue;\n            for (j = 1; j < s; j++)\n            {\n                now = mul(now, now, n);\n                if (now == n - 1) break;\n            }\n            if (j == s) return false;\n        }\n        return true;\n    }\n\n    ulong mul(ulong a, ulong b, ulong mod)\n    {\n        int i;\n        ulong now = 0;\n        for (i = 63; i >= 0; i--) if (((a >> i) & 1) == 1) break;\n        for (; i >= 0; i--)\n        {\n            now <<= 1;\n            while (now > mod) now -= mod;\n            if (((a >> i) & 1) == 1) now += b;\n            while (now > mod) now -= mod;\n        }\n        return now;\n    }\n\n    ulong pow(ulong a, ulong p, ulong mod)\n    {\n        if (p == 0) return 1;\n        if (p % 2 == 0) return pow(mul(a, a, mod), p / 2, mod);\n        return mul(pow(a, p - 1, mod), a, mod);\n    }\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality Test Comparison [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI found a new primality test below which determines if 1000000007 is prime.\nHow does its speed compare to other existing primality algorithms?\nDoes it win the award for most \"computationally worthless\" primality test?\nThanks.\nEDIT\nWas able to improve speed using this method described here:\nhttps://math.stackexchange.com/questions/3979118/speedup-primality-test\n\"So it's enough to go from x=n/2 up to n/2+√n/2. With this improvement, your algorithm will still be somewhat slower than your isPrimeNumber routine--just because calculating a gcd is slower than calculating divisibility. This will be feasible for testing numbers with maybe 15-20 digits, but you would need completely different methods to test something much larger, like the 183-digit number you mention.\"\n```\n// Primality Test\n// Every n is prime if all lattice points on x+y=n are visible from the origin.\n\n#include <stdio.h>\n#include <stdint.h>\n#include <math.h>\n\n\nuint64_t gcd(uint64_t a, uint64_t b)\n{\n    return (b != 0) ? gcd(b, a % b) : a;\n}\n\n\nint isPrimeNumber(uint64_t n)\n{\n    if (n == 1) return 0;\n    if (n == 2 || n == 3) return 1;\n    if (n % 2 == 0) return 0;\n\n    // Start near line x=y.\n    uint64_t x = (n / 2) + 2;\n    uint64_t y = n - x;\n    uint64_t count = sqrt(n) / 2;\n\n    for (uint64_t i = 0; i < count; ++i) {\n        // Check lattice point visibility...\n        if (gcd(x, y) != 1) return 0;\n        x++; y--;\n    }\n\n    return 1;\n}\n\n\nint main(int argc, char* argv)\n{\n    uint64_t n = 1000000007;\n\n    if (isPrimeNumber(n) == 1)\n    {\n        printf(\"%llu prime.\", n);\n    }\n    else\n    {\n        printf(\"%llu not prime.\", n);\n    }\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nWhen you write any code, you should do basic debugging to verify that your code does what you think it does. Run your code on a few small numbers; print values of ```\nx```\n and ```\ny```\n to verify that it does the correct checks.\nIn addition to this, if you mix integers and floating-point variables, you should be careful: implicit conversions e.g. from ```\nfloat```\n to ```\nunsigned```\n can lead to data loss and completely incorrect calculations. Compilers usually warn about this; you should compile with all warnings enabled ```\n-Wall```\n and pay attention to what the compiler says.\nIt looks like you should always have ```\nx + y = n```\n during your computations - this is your invariant. This can be more easily expressed like this:\n```\n// initialization\nx = n / 2;\ny = n - x;\n// it should be evident that your invariant holds here\n\ndo {\n    ...\n    x++; y--;\n    // your invariant holds here too, by induction\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test in python [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to create the most compact mapping n → isprime(n) up to a limit N?\r\n                            \r\n                                (30 answers)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm trying to do a simple primality test in Python.\n\nAccoding to Wikipedia, a primality test is the following:\n\n\n  Given an input number n, check whether any integer m from 2 to n − 1 divides n. If n is divisible by any m then n is composite, otherwise it is prime.\n\n\nI started with ruling out the even numbers - with the exception of 2 - as candidates to prime\n\n```\ndef prime_candidates(x):\n    odd = range(1, x, 2)\n    odd.insert(0, 2)\n    odd.remove(1)\n    return odd\n```\n\n\nThen writing a function to check for primes, according to the rules above.\n\n```\ndef isprime(x):\n    for i in range(2, x-1):\n            if x % i == 0:\n                    return False\n            else:\n                    return True\n```\n\n\nAnd this is the main function, which iterates over a list of 8000 prime candidates and tests their primality\n\n```\ndef main():\n    end = 8000\n    candidates = prime_candidates(end)\n    for i in candidates:\n            if isprime(i) and i < end:\n                    print 'prime found ' + str(i)\n```\n\n\nThe problem is that the ```\nisprime```\n function returns True for numbers that aren't primes.\n    ", "Answer": "\r\nHave a look at the Miller–Rabin primality test if a probabilistic algorithm will suffice. You could also prove a number to be prime, with for instance Elliptic Curve Primality Proving (ECPP), but it takes more effort.\n\nA simple trial division algorithm is the following\n\n```\ndef prime(a):\n     return not (a < 2 or any(a % x == 0 for x in range(2, int(a ** 0.5) + 1)))\n```\n\n\nEdit:\nHere's a more educational version because the first solution is very condensed and perhaps harder to read:\n\n```\nfrom math import sqrt\ndef prime(a):\n    if a < 2: return False\n    for x in range(2, int(sqrt(a)) + 1):\n        if a % x == 0:\n            return False\n    return True\n```\n\n\nI've substituted in ```\nsqrt(a)```\n in place of ```\na ** 0.5```\n to make things more clear. The square root is used to not look at more factors than we have to. \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality Testing in Java\r\n                \r\nSo I'm doing some primality testing, using Fermat's test, and also a method I call ```\nPrecise```\n, which takes way too long for large integers, but is a solid reference point to wether my ```\nFermat```\n method is right or wrong.\nActually, the only difference between these two methods is that while ```\nFermat```\n will check the primality equation (```\na^(p-1) % p == 1 % p```\n) for ```\nk```\n random a's, ```\nPrecise```\n will check the equation for all a's in the interval (```\n2 <= a <= p-2```\n).\n\nMy problem is, that in order to calculate ```\na^(p-1)```\n, I need to use a function that returns an integer (in order to calculate the remainder of the division by ```\np```\n), so I guess that ```\nMath.random()```\n is out of the question.\n\nWhat should I do? Should I make another method to calculate powers which returns an integer somehow, and if so, how? Is there already such a method?\n\n```\nFermat```\n code:\n\n```\npublic static boolean Fermat(int p, int k)\n{\n    int a, i, counter = 0;\n    int[] used_a = new int[p-3];\n\n    a = (int) (Math.random() * (p-1) + 2);\n    for(i=0;i<k;i++){\n        used_a[counter] = a;\n        if(Math.pow(a, p-1) % p != 1 % p){\n            return false;\n        }\n        while((contains(used_a, a)) && (counter < p-4)){ // contains(int[] array, int key) is just a method which tells us if key is in the array\n            a = (int) (Math.random() * (p-1) + 2);\n        }\n    }\n    return true;\n}\n```\n\n\n```\nPrecise```\n code:\n\n```\npublic static boolean Precise(int p)\n{\n    int a;\n\n    for(a=2;a<=p-2;a++){\n        if(Math.pow(a, p-1) % p != 1 % p){\n            return false;\n        } \n    }\n    return true;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fermat primality test\r\n                \r\nI have tried to write a code for Fermat primality test, but apparently failed.\nSo if I understood well: if ```\np```\n is prime then ```\n((a^p)-a)%p=0```\n where ```\np%a!=0```\n.\nMy code seems to be OK, therefore most likely I misunderstood the basics. What am I missing here?\n\n```\nprivate bool IsPrime(int candidate)\n    {\n        //checking if candidate = 0 || 1 || 2\n        int a = candidate + 1; //candidate can't be divisor of candidate+1\n        if ((Math.Pow(a, candidate) - a) % candidate == 0) return true;\n        return false;\n    }\n```\n\n    ", "Answer": "\r\nReading the wikipedia article on the Fermat primality test, You must choose an ```\na```\n that is less than the candidate you are testing, not more. \n\nFurthermore, as MattW commented, testing only a single ```\na```\n won't give you a conclusive answer as to whether the candidate is prime. You must test many possible ```\na```\ns before you can decide that a number is probably prime. And even then, some numbers may appear to be prime but actually be composite.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Memory Error in Python Primality Testing program\r\n                \r\ndef repeated(m, result, a, s, d):\n\n```\ncheck = True\nr = 0\nwhile r <= s - 1:\n    if result == m - 1:\n        check = False\n        return check\n    result = (result ** 2) % m\n    r = r + 1\nreturn check\n```\n\n\nI need to write a primality testing python program to test very large numbers, like at least 100-digit numbers. The code above is part of the code for Miller Rabin deterministic primality test for repeated squaring. It works really slow for large numbers. How can I speed it up? It is for a project. Thanks!\n    ", "Answer": "\r\nyour problem is probably the ```\n(result ** 2) % m```\n, use the 3 argument version of ```\npow```\n that do the same but more efficiently because the algorithm use is the Modular exponentiation and that is much better than first doing ```\nx**n```\n and then calculate its modulo. this way you are guaranty to never have a number bigger than ```\nm```\n while if you do ```\n(x**n) % m```\n you can have that ```\nx**n```\n is very much bigger than ```\nm```\n that may be the cause your problems\n\nAlso no need for the ```\ncheck```\n variable and you don't use ```\na```\n. \nAlso as you go from 0 to s-1, better use range\n\n```\ndef repeated(m, result, s, d):\n    for r in range(s):\n        if result == m - 1:\n            return False\n        result = pow(result, 2, m )\n    return True\n```\n\n\nNow for this part of the test \n\nif  \n\nyou need ```\na```\n, ```\nd```\n, ```\ns```\n, and ```\nn```\n this is how I would do it\n\n```\ndef mr_check(n,a,s,d):\n    result = pow(a,d,n)\n    if result == 1 :\n        return False\n    for r in range(s):\n        result = pow(result,2,n)\n        if result == n-1:\n            return False\n    return True\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test in Haskell\r\n                \r\nI have the following code in Haskell. I want to repeat 30 times the Fermat primality test for a given number n, but the problem is that it always returns False...I tried to fix the problem but I always get wrong answers..Any ideas?\n\n```\nimport System.Random\nimport System.IO.Unsafe\n\ntakeARandomNum n=unsafePerformIO (getStdRandom (randomR (2,n)))\n\nfermatTestA :: (Int, Int) -> Bool\nfermatTestA (n, a) =((a^(n-1) `mod` n)==1)\n\nsolve :: (Int, Int) -> Bool\nsolve (n, 1) = fermatTestA (n, takeARandomNum (n-2))\nsolve (n, maxTest)\n    | fermatTestA (n, takeARandomNum (n-2)) = (solve (n, (maxTest-1)))\n    | otherwise = False\n\nfermatTest :: Int ->Bool\nfermatTest n = solve (n, 30)\n```\n\n    ", "Answer": "\r\nYour integers are getting truncated. \"Int\" in Haskell is not the big-integer type. Change all your \"Int\" type declarations to \"Integer\" and your code should work.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "What would be the fastest method to test for primality in Java?\r\n                \r\nI am trying to find the fastest way to check whether a given number is prime or not (in Java). Below are several primality testing methods I came up with. Is there any better way than the second implementation(isPrime2)?\n```\npublic class Prime {\n    public static boolean isPrime1(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        for (int i = 2; i <= Math.sqrt(n) + 1; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static boolean isPrime2(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n) + 1; i = i + 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\npublic class PrimeTest {\n    public PrimeTest() {\n    }\n \n    @Test\n    public void testIsPrime() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n \n        Prime prime = new Prime();\n        TreeMap<Long, String> methodMap = new TreeMap<Long, String>();\n \n        for (Method method : Prime.class.getDeclaredMethods()) {\n \n            long startTime = System.currentTimeMillis();\n \n            int primeCount = 0;\n            for (int i = 0; i < 1000000; i++) {\n                if ((Boolean) method.invoke(prime, i)) {\n                    primeCount++;\n                }\n            }\n \n            long endTime = System.currentTimeMillis();\n \n            Assert.assertEquals(method.getName() + \" failed \", 78498, primeCount);\n            methodMap.put(endTime - startTime, method.getName());\n        }\n \n \n        for (Entry<Long, String> entry : methodMap.entrySet()) {\n            System.out.println(entry.getValue() + \" \" + entry.getKey() + \" Milli seconds \");\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nHere's another way:\n\n```\nboolean isPrime(long n) {\n    if(n < 2) return false;\n    if(n == 2 || n == 3) return true;\n    if(n%2 == 0 || n%3 == 0) return false;\n    long sqrtN = (long)Math.sqrt(n)+1;\n    for(long i = 6L; i <= sqrtN; i += 6) {\n        if(n%(i-1) == 0 || n%(i+1) == 0) return false;\n    }\n    return true;\n}\n```\n\n\nand ```\nBigInteger's isProbablePrime(...)```\n is valid for all 32 bit ```\nint```\n's.\n\nEDIT\n\nNote that ```\nisProbablePrime(certainty)```\n does not always produce the correct answer. When the certainty is on the low side, it produces false positives, as @dimo414 mentioned in the comments.\n\nUnfortunately, I could not find the source that claimed ```\nisProbablePrime(certainty)```\n is valid for all (32-bit) ```\nint```\n's (given enough certainty!).\n\nSo I performed a couple of tests. I created a ```\nBitSet```\n of size ```\nInteger.MAX_VALUE/2```\n representing all uneven numbers and used a prime sieve to find all primes in the range ```\n1..Integer.MAX_VALUE```\n. I then looped from ```\ni=1..Integer.MAX_VALUE```\n to test that every ```\nnew BigInteger(String.valueOf(i)).isProbablePrime(certainty) == isPrime(i)```\n.\n\nFor certainty 5 and 10, ```\nisProbablePrime(...)```\n produced false positives along the line. But with ```\nisProbablePrime(15)```\n, no test failed.\n\nHere's my test rig:\n\n```\nimport java.math.BigInteger;\nimport java.util.BitSet;\n\npublic class Main {\n\n    static BitSet primes;\n\n    static boolean isPrime(int p) {\n        return p > 0 && (p == 2 || (p%2 != 0 && primes.get(p/2)));\n    }\n\n    static void generatePrimesUpTo(int n) {\n        primes = new BitSet(n/2);\n\n        for(int i = 0; i < primes.size(); i++) {\n            primes.set(i, true);\n        }\n\n        primes.set(0, false);\n        int stop = (int)Math.sqrt(n) + 1;\n        int percentageDone = 0, previousPercentageDone = 0;\n        System.out.println(\"generating primes...\");\n        long start = System.currentTimeMillis();\n\n        for(int i = 0; i <= stop; i++) {\n            previousPercentageDone = percentageDone;\n            percentageDone = (int)((i + 1.0) / (stop / 100.0));\n\n            if(percentageDone <= 100 && percentageDone != previousPercentageDone) {\n                System.out.println(percentageDone + \"%\");\n            }\n\n            if(primes.get(i)) {\n                int number = (i * 2) + 1;\n\n                for(int p = number * 2; p < n; p += number) {\n                    if(p < 0) break; // overflow\n                    if(p%2 == 0) continue;\n                    primes.set(p/2, false);\n                }\n            }\n        }\n        long elapsed = System.currentTimeMillis() - start;\n        System.out.println(\"finished generating primes ~\" + (elapsed/1000) + \" seconds\");\n    }\n\n    private static void test(final int certainty, final int n) {\n        int percentageDone = 0, previousPercentageDone = 0;\n        long start = System.currentTimeMillis();\n        System.out.println(\"testing isProbablePrime(\" + certainty + \") from 1 to \" + n);\n        for(int i = 1; i < n; i++) {\n            previousPercentageDone = percentageDone;\n            percentageDone = (int)((i + 1.0) / (n / 100.0));\n            if(percentageDone <= 100 && percentageDone != previousPercentageDone) {\n                System.out.println(percentageDone + \"%\");\n            }\n            BigInteger bigInt = new BigInteger(String.valueOf(i));\n            boolean bigIntSays = bigInt.isProbablePrime(certainty);\n            if(isPrime(i) != bigIntSays) {\n                System.out.println(\"ERROR: isProbablePrime(\" + certainty + \") returns \"\n                    + bigIntSays + \" for i=\" + i + \" while it \" + (isPrime(i) ? \"is\" : \"isn't\" ) +\n                    \" a prime\");\n                return;\n            }\n        }\n        long elapsed = System.currentTimeMillis() - start;\n        System.out.println(\"finished testing in ~\" + ((elapsed/1000)/60) +\n                \" minutes, no false positive or false negative found for isProbablePrime(\" + certainty + \")\");\n    }\n\n    public static void main(String[] args) {\n        int certainty = Integer.parseInt(args[0]);\n        int n = Integer.MAX_VALUE;\n        generatePrimesUpTo(n);\n        test(certainty, n);\n    }\n}\n```\n\n\nwhich I ran by doing:\n\n```\njava -Xmx1024m -cp . Main 15\n```\n\n\nThe generating of the primes took ~30 sec on my machine. And the actual test of all ```\ni```\n in ```\n1..Integer.MAX_VALUE```\n took around 2 hours and 15 minutes.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fermat's primality test\r\n                \r\nFrom my understanding, the fermat's primality test should fail for all carmichael numbers. This seems to identify prime numbers fine, but all the carmichael numbers that I tested returned 'composite' for high k values, which is unexpected.\nCan anyone see what mistake I made?\n```\ndef mod_exp(x, y, N):\n    if y == 0:\n        return 1\n    z = mod_exp(x, y//2, N)\n    if y % 2 == 0:\n        return z*z % N\n    else:\n        return x * z*z % N\n\ndef fermat(N,k):\n    isPrime = 'prime'\n    for i in range(k):\n        a = random.randint(1, N - 1)\n        if mod_exp(a, N - 1, N) != 1:\n            isPrime = 'composite'\n    return isPrime\n```\n\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality Test algorithm fails\r\n                \r\nI created a simple primality test algorithm, but it fails for numbers like 15. Why? \n\n```\nnumber = int(input(\"Test if Prime: \"))\n\nprint (\"Is \" + str(number) + \" Prime?: \")\n\nfor i in range (2, number): \n  if number % i == 0: \n    print (\"No\")\n    break\n  else: \n    print (\"Yes\")\n```\n\n\nI tried an elif statement with other variations, but it still doesn't work: \n\n```\nnumber = int(input(\"Test if Prime: \"))\n\nprint (\"Is \" + str(number) + \" Prime?: \")\n\nfor i in range (2, number): \n  if number % i == 0: \n    break\n  elif number % i != 0: \n    print (\"Yes\")\n```\n\n\nAny help is appreciated. \n    ", "Answer": "\r\nYou have your else condition inside the loop. At any point in time, it'll only check for one value...\n\nModifying your for loop to print out the number it is checking for:\n\n```\nfor i in range (2, number): \n  print (i)\n  if number % i == 0: \n    print (\"No\")\n    break\n  else: \n    print (\"Yes\")\n```\n\n\nprints out (for number = 15):\n\n```\n2\nYes\n3\nNo\n```\n\n\nWhich you know works if it prints out 'No' number - 1 times\n\nTo slightly modify what you did, we can just change it to:\n\n```\nflag = False\nfor i in range (2, number): \n  if number % i == 0: \n    print (\"No\")\n    flag = True\n    break\nif (!flag)\n  print(\"Yes\")\n```\n\n\nAll this does is push the print statement outside the loop (for a number to be prime it needs to be non-divisible by all numbers less than it). The flag ensures that you only print out True or False (you don't want to print out both)\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fastest algorithm for primality test [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI need to test primality on intervals between numbers which are really big (in the range of long long), so i need some fast algorithm for checking if a number is prime or not. Please suggest your ideas.\n    ", "Answer": "\r\nOne good method is the Miller-Rabin test. It should be noted however, that this is only a probabilistic test.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Implementation of Fermat's primality test\r\n                \r\nWho wants to help me with my homework?\n\nI'm try to implement Fermat's primality test in Java using BigIntegers. My implementation is as follows, but unfortunately it doesn't work.  Any ideas?\n\n```\npublic static boolean checkPrime(BigInteger n, int maxIterations)\n{\n    if (n.equals(BigInteger.ONE))\n        return false;\n\n    BigInteger a;\n    Random rand = new Random();\n\n    for (int i = 0; i < maxIterations; i++)\n    {\n        a = new BigInteger(n.bitLength() - 1, rand);\n        a = a.modPow(n.subtract(BigInteger.ONE), n);\n\n        if (!a.equals(BigInteger.ONE))\n            return false;\n    }\n\n    return true;\n}\n```\n\n\nI'm new to BigIntegers.\n\nThanks!\n    ", "Answer": "\r\nYour use of the particular BigInteger constructor is reasonable, but you should use a rejection method to select a fermat base a. Here is a slight modification of your method in a class which also uses exactly one Random object:  \n\n```\nimport java.math.BigInteger;\nimport java.util.Random;\n\npublic class FermatTestExample\n{\n\n    private final static Random rand = new Random();\n\n    private static BigInteger getRandomFermatBase(BigInteger n)\n    {\n        // Rejection method: ask for a random integer but reject it if it isn't\n        // in the acceptable set.\n\n        while (true)\n        {\n            final BigInteger a = new BigInteger (n.bitLength(), rand);\n            // must have 1 <= a < n\n            if (BigInteger.ONE.compareTo(a) <= 0 && a.compareTo(n) < 0)\n            {\n                return a;\n            }\n        }\n    }\n\n    public static boolean checkPrime(BigInteger n, int maxIterations)\n    {\n        if (n.equals(BigInteger.ONE))\n            return false;\n\n        for (int i = 0; i < maxIterations; i++)\n        {\n            BigInteger a = getRandomFermatBase(n);\n            a = a.modPow(n.subtract(BigInteger.ONE), n);\n\n            if (!a.equals(BigInteger.ONE))\n                return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"checkprime(2) is %b%n\", checkPrime(BigInteger.valueOf(2L), 20));\n        System.out.printf(\"checkprime(5) is %b%n\", checkPrime(BigInteger.valueOf(5L), 20));\n        System.out.printf(\"checkprime(7) is %b%n\", checkPrime(BigInteger.valueOf(7L), 20));\n        System.out.printf(\"checkprime(9) is %b%n\", checkPrime(BigInteger.valueOf(9L), 20));\n    }\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality Test not working in Python\r\n                \r\nI have been trying to compact my code for a primality test in python so that it makes use of list comprehensions, but for some reason it doesn't return the correct results:\n\n```\ndef isPrime(n):\n    if n > 1:\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n```\n\n\nThat's the code for my current primality test, but I want to condense it:\n\n```\ndef isPrime(n):\nif n > 1:\n    return [False for i in range(2, int(n ** 0.5) + 1) if n % i == 0]\n    return True\n```\n\n\nI tried the above, but it outputs all non-prime integers up to n. What am I doing wrong?\n    ", "Answer": "\r\nAs you want ```\nFalse```\n if any lesser number is a divisor, code it directly that way:\n\n```\ndef isPrime(n):\n    return n<=1 or not any(i for i in range(2, int(n ** 0.5) + 1) if n % i == 0)\n```\n\n\nNote that this uses a genexp, not a listcomp, because that allows ```\nany```\n to terminate the whole operation as soon as it finds any suitable ```\ni```\n divisor and thus knows ```\nn```\n cannot be prime.  List comprehensions generate an in-memory list of all their items, while generator expressions yield items one at a time, and only as long as they're being asked for \"the next one\" (by a ```\nfor```\n loop, an accumulator such as ```\nany```\n or ```\nall```\n, or directly by the ```\nnext```\n built-in).\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Simple deterministic primality testing for small numbers\r\n                \r\nI am aware that there are a number of primality testing algorithms used in practice (Sieve of Eratosthenes, Fermat's test, Miller-Rabin, AKS, etc). However, they are either slow (e.g. sieve), probabalistic (Fermat and Miller-Rabin), or relatively difficult to implement (AKS).\n\nWhat is the best deterministic solution to determine whether or not a number is prime?\n\nNote that I am primarily (pun intended) interested in testing against numbers on the order of 32 (and maybe 64) bits. So a robust solution (applicable to larger numbers) is not necessary.\n    ", "Answer": "\r\nUp to ```\n~2^30```\n you could brute force with trial-division.\n\nUp to ```\n3.4*10^14```\n, Rabin-Miller with the first 7 primes has been proven to be deterministic.\n\nAbove that, you're on your own. There's no known sub-cubic deterministic algorithm.\n\nEDIT : I remembered this, but I didn't find the reference until now:\n\nhttp://reference.wolfram.com/legacy/v5_2/book/section-A.9.4\n\n\n  PrimeQ first tests for divisibility using small primes, then uses the\n  Miller-Rabin strong pseudoprime test base 2 and base 3, and then uses\n  a Lucas test.\n  \n  As of 1997, this procedure is known to be correct only for ```\nn < 10^16```\n,\n  and it is conceivable that for larger ```\nn```\n it could claim a composite\n  number to be prime.\n\n\nSo if you implement Rabin-Miller and Lucas, you're good up to 10^16.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller Rabin Primality test\r\n                \r\nI have wrote a Miller Rabin primality test in C sharp, but it return false on every input.\n\nHere's the code:\n\n```\n    static Boolean MilRab(UInt64 n)\n    {\n        UInt64[] ar = new UInt64[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };\n        for (int i = 0; i < 10; i++)\n        {\n            if (Tanu(ar[i], n) == true) return false;\n        }\n        return true;\n    }//MilRab\n\n    static Boolean Tanu(UInt64 a, UInt64 n)\n    {\n        UInt64 b = n - 1;\n        UInt64 d = 1;\n        UInt64 x;\n        Int16 i;\n        for (i = 63; i >= 0; i--) if (((b >> i) & 1) == 1) break;\n\n        for (;i>=0;i--)\n        {\n            x = d;\n            d = ((d * d) % n);\n            if (d == 1 && x != 1 && x != n - 1) return true;\n            if (b>>i == 1) d = (d * a) % n;\n        }\n        if (d != 1) return true;\n      return false;\n    }//Tanu\n```\n\n\nWhat do you think the problem can be? I spent a hole day debugging and its driving me crazy. Thank you.\n    ", "Answer": "\r\nCheck this implementation for int and BigInteger\n\nhttp://rosettacode.org/wiki/Miller-Rabin_primality_test#C.23\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin Primality test in Java\r\n                \r\nI am currently working on Project Euler and thought that it might be more interesting (and a better learning experience) if don't just brute force all of the questions. On question 3 it asks for prime factors of a number and my solution will be to factor the number (using another factoring algorithm) and then test the factors for primality. I came up with this code for a Miller-Rabin Primality test (after thoroughly researching primality test) and it returns true for all the composite odd number I have put in. Can anybody help me to figure out why? I thought I had coded the algorithm correctly.\n\n```\n    public static boolean isPrime(long num)\n{\nif(num % 2 == 0)\n    return false;\nelse\n{\n    double d;\n    int r=0;\n    while((num-1) % Math.pow(2,r+1) == 0)\n        r++;\n    d = (num-1) % Math.pow(2,r);\n    int[] a = {2,3,5,7,11,13,17,23,31,62,73,1662803};\n    boolean primality = true;\n    for(int k = 0; k < a.length; k++)\n    {\n        if((Math.pow(a[k],d)-1) % num != 0)\n        {\n            for(int s = 0; s < r-1; s++)\n            {\n                if((Math.pow(a[k],Math.pow(2,s)*d)+1) % num != 0)\n                    primality = false;\n\n            }\n        }\n    }\n    return primality;\n}\n```\n\n    ", "Answer": "\r\nGiven ```\nnum > 3```\n, you want: ```\nd, r s.t. pow(2,r) * d = num - 1, where d is odd```\n.\n\nYou are effectively counting trailing zeroes from ```\nnum - 1```\n, to remove factors of ```\n2```\n. However, after that loop, you know ```\npow(2,r)```\n is a factor of ```\nnum - 1```\n. Hence:   \n\n```\nd = (num-1) % Math.pow(2,r);\n```\n\n\nwill always yield: ```\nd = 0```\n. I suspect you meant to replace ```\n%```\n (mod) with ```\n/```\n (div) here; otherwise, ```\nMath.pow(a[k],d)-1```\n will always yield ```\n(0)```\n, and the inner loop will never be executed.\n\nAs others pointed out, some simple trace statements or assertions would have found these errors. I think you have other issues, such as integer overflow. The loop for testing against the ```\na[]```\n candidates (the a-SPRP test) looks completely wrong to me.\n\nPerhaps you've got the algorithm from Wikipedia, I prefer the more detailed reference in The Handbook of Applied Cryptography: 4.2.3: Miller-Rabin test, Algorithm: 4.24.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller Rabin Primality test accuracy\r\n                \r\nI know the Miller–Rabin primality test is probabilistic. However I want to use it for a programming task that leaves no room for error.\n\nCan we assume that it is correct with very high probability if the input numbers are 64-bit integers (i.e. ```\nlong long```\n in C)?\n    ", "Answer": "\r\nMiller–Rabin is indeed probabilistic, but you can trade accuracy for computation time arbitrarily. If the number you test is prime, it will always give the correct answer. The problematic case is when a number is composite, but is reported to be prime. We can bound the probability of this error using the formula on Wikipedia: If you select ```\nk```\n different bases randomly and test them, the error probability is less than 4-k. So even with ```\nk = 9```\n, you only get a 3 in a million chance of being wrong. And with ```\nk = 40```\n or so it becomes ridiculously unlikely.\n\nThat said, there is a deterministic version of Miller–Rabin, relying on the correctness of the generalized Riemann hypothesis. For the range u\nup to 264, it is enough to check ```\na = 2, 3, 5, 7, 11, 13, 17, 19, 23```\n. I have a C++ implementation online which was field-tested in lots of programming contests. Here's an instantiation of the template for unsigned 64-bit ints:\n\n```\nbool isprime(uint64_t n) { //determines if n is a prime number\n    const int pn = 9, p[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23 };\n    for (int i = 0; i < pn; ++i)\n        if (n % p[i] == 0) return n == p[i];\n    if (n < p[pn - 1]) return 0;\n    uint64_t s = 0, t = n - 1;\n    while (~t & 1)\n        t >>= 1, ++s;\n    for (int i = 0; i < pn; ++i) {\n        uint64_t pt = PowerMod(p[i], t, n);\n        if (pt == 1) continue;\n        bool ok = 0;\n        for (int j = 0; j < s && !ok; ++j) {\n            if (pt == n - 1) ok = 1;\n            pt = MultiplyMod(pt, pt, n);\n        }\n        if (!ok) return 0;\n    }\n    return 1;\n}\n```\n\n\n```\nPowerMod```\n and ```\nMultiplyMod```\n are just primitives to multiply and exponentiate under a given modulus, using square-and-{multiply,add}.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller Rabin Primality Test Error on JavaScript\r\n                \r\nIm working on JavaScript to get three different algorithms to work in the same code, I set up a function for each algorithm. I'm trying to get three Primality testing methods: Trial Division, the Fermat Primality Test, and the Miller-Rabin Primality Test. The first two are working fine but the Miller-Rabin isn't. I'm pretty new to JavaScript and programming in general, so if you can find where I went wrong or can think of a way to make it work, please let me know! Thanks!\n\n\r\n\r\n```\n// 1531 6389 68819 688889 6388819\r\n// 68883889 688838831 1000000009\r\n// 561 is a Carmichael number; a Fermat pseudoprime with the property a^n-1 = 1 mod n, for any \"a\" coprime to 561.\r\ninput = 5491763;\r\nnumTrials = 2000;\r\n\r\ndocument.getElementById(\"input\").innerHTML = input;\r\n\r\nfunction TrialDiv(n) {\r\n\r\n  if (n === 1) {\r\n    return false;\r\n  } else if (n === 2) {\r\n    return true;\r\n  } else {\r\n    for (var x = 2; x < n; x++) {\r\n      if (n % x === 0) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\nif ((TrialDiv(input)) === true) {\r\n  a = \"Prime\"\r\n} else if ((TrialDiv(input)) === false) {\r\n  a = \"Composite\"\r\n}\r\n//---------------------------------------------------------------------------\r\nfunction gcd(x, y) {\r\n  while (y !== 0) {\r\n    var z = x % y;\r\n    x = y;\r\n    y = z;\r\n  }\r\n  return x;\r\n}\r\n\r\nfunction getRndInteger(max) {\r\n  return Math.floor(Math.random() * (max - 2)) + 2;\r\n}\r\n//--------------------------------------------------------------------------\r\nfunction Fermat(n) {\r\n\r\n  for (var t = 0; t = numTrials; t++) {\r\n    m = getRndInteger(input);\r\n    if (gcd(m, n) !== 1) {\r\n      return false;\r\n    }\r\n  }\r\n  return (Math.pow(m, n - 1) % n !== 1);\r\n}\r\n\r\nif ((Fermat(input)) === true) {\r\n  b = \"Prime\";\r\n} else if ((Fermat(input)) === false) {\r\n  b = \"Composite\";\r\n}\r\n//---------------------------------------------------------------------------\r\nfunction genD(n) { // Generates \"d\" such that \"n-1 = 2^s * d\"\r\n  var p = n - 1;\r\n  var d = p / 2;\r\n  while (d % 2 === 0) {\r\n    d = d / 2;\r\n  }\r\n  return d;\r\n}\r\n\r\nfunction genS() { // Generates \"s\" such that \"n-1 = 2^s * d\"\r\n  var s = Math.log2(p / d);\r\n  return s;\r\n}\r\n//---------------------------------------------------------------------------\r\nfunction MillerRabin(n) {\r\n\r\n  for (var t = 0; t < numTrials; t++) {\r\n    m = getRndInteger(input);\r\n    if (gcd(m, n) !== 1) {\r\n      return false;\r\n    } else {\r\n      for (var r = 0; r < genS(); r++) {\r\n        power = (Math.pow(2, r) * genD(input));\r\n        if (Math.pow(m, genD(input)) % n === 1 || Math.pow(m, power) % n === -1) {\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\nif ((MillerRabin(input)) === true) {\r\n  c = \"Prime\";\r\n} else if ((MillerRabin(input)) === false) {\r\n  c = \"Composite\";\r\n}```\n\r\n```\n<body>\r\n  <button type=\"button\" onclick='document.getElementById(\"TrialDivision\").innerHTML = a;  document.getElementById(\"FermatTest\").innerHTML = b; document.getElementById(\"MillerRabinTest\").innerHTML = c; '>Show</button>\r\n\r\n  <hr>\r\n  <b style=\"color:rgb(0,0,120)\">PRIMALITY TESTS</b>\r\n  <p></p>\r\n  Input:\r\n  <l id=\"input\"></l>\r\n\r\n  <hr>\r\n  <h5 style=\"color:rgb(160,0,0)\">TRIAL DIVISION</h5>\r\n  <p></p>\r\n  Output:\r\n  <i id=\"TrialDivision\"></i>\r\n\r\n  <hr>\r\n  <h5 style=\"color:rgb(160,0,0)\">FERMAT PRIMALITY TEST</h5>\r\n  <p></p>\r\n  Output:\r\n  <i id=\"FermatTest\"></i>\r\n\r\n  <hr>\r\n  <h5 style=\"color:rgb(160,0,0)\">MILLER-RABIN PRIMALITY TEST</h5>\r\n  <p></p>\r\n  Output:\r\n  <i id=\"MillerRabinTest\"></i>\r\n</body>\r\n<script>```\n\r\n\r\n\r\n\n\nThat's how I wrote it up, this was purely created by me from the original mathematical algorithms for each test. What happens is that the Miller-Rabin Output doesn't show anything when the input number is prime; the algorithm isn't able to identify it. But it does identify composites correctly.\n\nPlease let me know of any improvements you think of!\n    ", "Answer": "\r\nYou have some problems with loops not running. I'm not sure how the algorithm is supposed to work, so I don't if it's working or not, but the immediate problem is cause by leaky variable and variables not declared in functions (which makes them global).\n\nThe fix for this immediate problem is to declare the local variables in the functions so you don't depend on having them set by some other function.\n\n```\nfunction genD(n) { // Generates \"d\" such that \"n-1 = 2^s * d\"\n    var p = n - 1;\n    var d = p / 2;\n    while (d % 2 === 0) {\n        d = d / 2;\n    }\n    return d;\n}\n\nfunction genS(n) { // Generates \"s\" such that \"n-1 = 2^s * d\"\n    var p = n - 1\n    var d = p / 2\n    var s = Math.log2(p / d);\n    return s;\n}\n```\n\n\nOnce you start fixing the errors that crash there are a few other big problems. For example your ```\nfermat()```\n potentially runs for ever:\n\n```\nfor (var t = 0; t = numTrials; t++) {\n```\n\n\nShould be:\n\n```\nfor (var t = 0; t == numTrials; t++) {\n```\n\n\n```\n=```\n sets ```\nt```\n to ```\nnumTrails```\n for every loop\n\nI think you should start at the beginning, put all your functions together and all you other logic code that calls the functions together so you can see what's going on.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin primality test-SAGE\r\n                \r\nI'm trying to program the Miller-Rabin primality test in SAGE. Here is my code: \n\n```\ndef miller(n,k):\ni=1\ns=(n-1).valuation(2)\nt=(n-1)/(2**s)\nwhile(i>0 and i<=k):\n    a=randint(3,n-3)\n    if gcd(a,n)!=1:\n        i=0\n    else:\n        y=a**t%n\n        if y!=1 and y!=n-1:\n            j=1\n            while(j>0 and j<=s-1 and y!=n-1):\n                y=y**2%n\n                if y==1:\n                    j=0\n                else:\n                    j=j+1\n            if y!=n-1:\n                i=0\n        if i>0:\n            i=i+1\nif i==0:\n    print \"n composite\"\nelse:\n    print \"n probably prime\"\n```\n\n\nIt works fine for not-too small numbers, however for n=3847982374893247238947238473289472348923784923748723482374832748923748932478239472389478239479273 I get \"exponent must be at most 9223372036854775807\". I would apreciate any advice :)\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Naive Primality Testing Optimization\r\n                \r\nI have an algorithm to test for primality, which uses the naive implementation as listed here http://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\n```\n       static boolean check(int n)\n   {\n           if(n == 2 || n == 3)\n           {\n                   return true;\n           }\n           if(n < 2 || n % 2 == 0 || n % 3 == 0)\n           {\n                   return false;\n           }\n           for(int i = 6; i * i <= n; i += 6)\n           {\n                   if(n % (i - 1) == 0 || n % (i + 1) == 0)\n                   {\n                           return false;\n                   }\n           }\n           return true;\n   }\n```\n\n\nI got all the way to the 6k+1 section, but after that, I'm lost. How else can I further optimize this for speed?\n    ", "Answer": "\r\nIf you want to stick with the naive method, then your next step is to use the next property listed in the wikipedia page you link to:\n\n\n  So all prime numbers are of the form 30k + i for i = 1, 7, 11, 13, 17,\n  19, 23, 29 (i.e. for i < 30 such that gcd(i,30) = 1).\n\n\nExcept you might pick slightly different / more primes than 2.3.5\n\nYou would replace the 6 stepping loop with a 30 stepping loop, (and check with all primes less than 30 by hand )\n\nThe code might look like this:\n\n```\n    static boolean check(int n)\n   {\n           if(n<30)\n           {\n              return n==2 || n==3 || n==5 || n==7 || ...\n           }\n\n           for(int i = 30; i * i <= n; i += 30)\n           {\n              if (n % (i + 1))==0 return false;\n              if (n % (i + 7))==0 return false;\n              if (n % (i + 11))==0 return false;\n              if (n % (i + 13))==0 return false;\n              if (n % (i + 17))==0 return false;\n              if (n % (i + 19))==0 return false;\n              if (n % (i + 23))==0 return false;\n              if (n % (i + 29))==0 return false;\n           }\n           return true;\n   }\n```\n\n\nHowever you'll note that this scans 8/30 (=27%) numbers, while the 6 stepping loop scans 2/6\n(=33%) So it scans about 20% less numbers, so you'd expect a speed up of at best 20%. As you add more primes to the list you get diminishing returns. \n\nReally if you need fast prime checking then you need to move away from the naive methods. And there's been plenty of questions about those on stack overflow previously.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Implementation of AKS primality test in Scheme or C++\r\n                \r\nI was reading about the prime test algorithm and found the AKS primality test. Could this algorithm be implemented in Scheme or in C++?\n\nHas anyone tried implementing the AKS test?\n    ", "Answer": "\r\nScheme and C++ (and Racket and Pascal and Logo and Modula-3 and Postscript) are all Turing equivalent, meaning that they can all be used to simulate each other, and hence that they can all compute the same things. \n\nSo: yes, you can implement this in Scheme. Or any other Turing-complete language.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "128 bit Miller Rabin Primality test\r\n                \r\nI wanted to implement Miller Rabin Primality Test for large numbers. I wanted to know how to deal with such huge numbers in C++. Should I write any special function to store and process those large numbers or care is taken automatically?\n    ", "Answer": "\r\nYou should use an arbitrary precision library. Since you only need integers, GMP is a very popular and well-maintained such library. It has a nice C++ interface provided by ```\n<gmpxx.h>```\n.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller Rabin primality test two types?\r\n                \r\nI encountered two types of Miller Rabin primality test methods suddenly.\nOne which uses randoms and another does not use randoms.\n\nIs there a hidden random generation inside the second one or what? Thank you.\n    ", "Answer": "\r\nThe second one is a deterministic variant of the Miller-Rabin primality test. Instead of using \"witness\" numbers generated from random numbers, a list of primes that are known to be sufficient is used instead:\n\nWhen the number n to be tested is small, trying all a < 2(ln n)2 is not necessary, as much smaller sets of potential witnesses are known to suffice\"\nif n < 3,825,123,056,546,413,051, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, and 23.\n\nThis is the list of primes in ```\nalist```\n in the linked source code.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why naive primality test algorithm is not polynomial\r\n                \r\nI would like to understand why the following naive primality test algorithm is not polynomial.\n\n```\nIsPrime (n: an integer)\nBegin\n   For i=2 to n-1 do\n     If (n % i == 0) then\n        return (no)\n     EndIf\n   EndFor\n\n   return (yes)\nEnd\n```\n\n\nThis algorithm is said to be exponential in the size of the input n. Why is it true? And why the following sorting test algorithm is said polynomial and not exponential?\n\n```\nIsSorted (T[n]: an array of n integer)\nBegin\n  For i = 1 to n-1 do\n     If (T[i] > T[i+1]) then\n        return (no)\n     EndIf\n  EndFor\n\n  return (yes)\nEnd\n```\n\n    ", "Answer": "\r\nThe input size is typically measured in bits. To represent the number n the input size would be log2(n). The primitive primality test is linear in n, but exponential in log2(n).\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why is my algorithm about Fermat primality test so slow?\r\n                \r\nI am learning Number theory. Now, I want to write a program that perform Fermat primality test.\n\nFirst, I write a modular square algorithm:\n\n```\n#modular_square.py\ndef modular_square(a, n, m):\n    res = 1\n    exp = n\n    b = a \n\n    while exp !=0 :\n\n        if exp % 2 == 1:\n            res *= b\n            res %= m\n\n        b *= b\n        exp >>= 1\n\n    return res\n\n\ndef main():\n    a = [   12996,      312,        501,        468,        163]\n    n = [   227,        13,         13,         237,        237]\n    m = [   37909,      667,        667,        667,        667]\n    res = [ 7775,       468,        163,        312,        501]\n    #test modular_square()\n    print(\"===test modular_square()===\")\n    for i, r in enumerate(res):\n        if modular_square(a[i], n[i], m[i]) != r:\n            print(\"modular_square() failed...\")\n        else:\n            print(\"modular_square({},{},{})={}\".format(a[i], n[i], m[i], r))  \n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n\nThen, I write Fermat primality test algorithm based on the above algorithm.\n\n```\n#prime_test_fermat.py\n\nimport modular_square\nimport random\n\ndef Fermat_base(b, n):\n    res = modular_square.modular_square(b, n-1, n)\n\n    if res == 1:\n        return True\n    else:\n        return False\n\n\ndef Fermat_test(n, times):\n\n    for i in range(times):\n        b = random.randint(2, n-1)\n        if Fermat_base(b, n) == False:\n            return False\n\n    return True\n\ndef main():\n    b = [8,         2]\n    n = [63,        63]\n    res = [True,    False]\n    #test Fermat_base()\n    print(\"===test Fermat_base()===\")\n    for i,r in enumerate(res):\n        if Fermat_base(b[i], n[i]) != res[i]:\n            print(\"Fermat_base() failed...\")\n        else:\n            print(\"Fermat_base({},{})={}\".format(b[i], n[i], res[i]))\n\n    n = [923861,\n        1056420454404911\n         ]\n\n    times = [2, 2]\n\n    res = [True,True ]\n    #test Fermat_test()\n    print(\"==test Fermat_test()===\")\n    for i,r in enumerate(res):\n        if Fermat_test(n[i], times[i]) != res[i]:\n            print(\"Fermat_test() failed...\")\n        else:\n            print(\"Fermat_test({},{})={}\".format(n[i], times[i], res[i]))\n\nif __name__ == '__main__':\n    main()\n\n```\n\n\nWhen I run ```\nprime_test_fermat.py```\n program, it didn't stop. This is caused by Fermat primality or my code that exists bug.\n    ", "Answer": "\r\nThe problem is with your modular exponentiation algorithm: The modulus is applied to ```\nres```\n but not to ```\nb```\n. Since ```\nb```\n is squared in every iteration, it will become extremely large (as in several thousand digits). This slows down your algorithm.\nTo solve this, you have to apply the modulus to ```\nb```\n as well. Replace ```\nb *= b```\n with:\n```\nb *= b\nb %= m\n```\n\nAs an additional optimization, you can also apply the modulus when you initialize ```\nb```\n, by replacing ```\nb = a```\n with:\n```\nb = a\nb %= m\n```\n\nYou can take this pseudo-code as reference.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Python 2.7.6(64-bit) overflow error in primality testing\r\n                \r\nI am running the following code, which is a version of erathosthene's sieve in python 2.7.6 64-bit on win8 on a computer with 4GB RAM.  \n\n```\ndef erathosthenes_sieve2(n):\n    '''Tests n>1 primality using improved erathostene's method'''  \n    if n==2:  \n        return True          \n    if n%2==0:  \n        return False          \n    limit=long(math.floor(math.sqrt(n)))  \n    for i in xrange(3,limit+1,2):  \n       if n%i==0:  \n           return False   \n    return True  \n```\n\n\n\n\nWhen I call this function for sufficiently big numbers, for example 48112959837082048697(which is a prime) i get the following error.\n\n```\nerathosthenes_sieve2(48112959837082048697)  \n---------------------------------------------------------------------------\nOverflowError                             Traceback (most recent call last)\n<ipython-input-28-b0a5b24a8b94> in <module>()\n----> 1 erathosthenes_sieve2(48112959837082048697)\n\nD:\\repos\\PrimalityTests\\Eratosthenes2.py in erathosthenes_sieve2(n)\n      9         return False\n     10     limit=long(math.floor(math.sqrt(n)))\n---> 11     for i in xrange(3,limit+1,2):\n     12        if n%i==0:\n     13            return False\n\nOverflowError: Python int too large to convert to C long\n```\n\n\nWhat ways could be used to work around this problem? I know that this is not a good algorithm for testing primes, but this is just a part of my project of comparing efficiency of different primality tests, so please ignore that.\n    ", "Answer": "\r\nThe issue is that ```\nxrange```\n takes a ```\nC long```\n, meaning you can't have the arbitrary precision ```\nint```\n. But there is a way around this. To quote the docs:\n\n\n  CPython implementation detail: xrange() is intended to be simple and\n  fast. Implementations may impose restrictions to achieve this. The C\n  implementation of Python restricts all arguments to native C longs\n  (“short” Python integers), and also requires that the number of\n  elements fit in a native C long. If a larger range is needed, an\n  alternate version can be crafted using the itertools module:\n\n\n```\nislice(count(start, step), (stop-start+step-1+2*(step<0))//step)\n```\n\n\nSo in your case:\n\n```\nfor i in islice(count(3, 2), ((limit+1)-3+2-1+2*(2<0))//2):\n    ...\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Modulus warning in R- Lehmann Primality Test\r\n                \r\nI spent a little time hacking an R implementation of the lehmann primality test. The function design I borrowed from http://davidkendal.net/articles/2011/12/lehmann-primality-test \n\nHere is my code:\n\n```\nprimeTest <- function(n, iter){\n  a <- sample(1:(n-1), 1)\n    lehmannTest <- function(y, tries){\n    x <- ((y^((n-1)/2)) %% n)\n    if (tries == 0) {\n      return(TRUE)\n            }else{          \n      if ((x == 1) | (x == (-1 %% n))){\n        lehmannTest(sample(1:(n-1), 1), (tries-1))\n      }else{\n    return(FALSE)\n      }\n    }\n  }\n  lehmannTest(a, iter)\n}\n\nprimeTest(4, 50) # false\nprimeTest(3, 50) # true\nprimeTest(10, 50)# false\nprimeTest(97, 50) # gives false # SHOULD BE TRUE !!!! WTF\n\nprime_test<-c(2,3,5,7,11,13,17 ,19,23,29,31,37)\n\nfor (i in 1:length(prime_test)) {\n  print(primeTest(prime_test[i], 50))\n}\n```\n\n\nFor small primes it works but as soon as i get around ~30, i get a bad looking message and the function stops working correctly:\n\n```\n2: In lehmannTest(a, iter) : probable complete loss of accuracy in modulus\n```\n\n\nAfter some investigating i believe it has to do with floating point conversions. Very large numbers are rounded so that the mod function gives a bad response.\n\nNow the questions.\n\n\nIs this a floating point problem? or in my implementation?\nIs there a purely R solution or is R just bad at this?\n\n\nThanks\n\nSolution:\n\nAfter the great feedback and a hour reading about modular exponentiation algorithms i have a solution. first it is to make my own modular exponentiation function. The basic idea is that modular multiplication allows you calculate intermediate results. you can calculate the mod after each iteration, thus never getting a giant nasty number that swamps the 16-bit R int.\n\n```\nmodexp<-function(a, b, n){\n    r = 1\n    for (i in 1:b){\n        r = (r*a) %% n\n    }\n    return(r)\n}\n\n\nprimeTest <- function(n, iter){\n   a <- sample(1:(n-1), 1)\n    lehmannTest <- function(y, tries){\n      x <- modexp(y, (n-1)/2, n)   \n    if (tries == 0) {\n      return(TRUE)\n            }else{          \n      if ((x == 1) | (x == (-1 %% n))){\n        lehmannTest(sample(1:(n-1), 1), (tries-1))\n        }else{\n        return(FALSE)\n         }\n    }\n  }\n   if( n < 2 ){\n     return(FALSE)\n     }else if (n ==2) {\n       return(TRUE)\n       } else{\n         lehmannTest(a, iter)\n         }\n}\n\nprimeTest(4, 50) # false\nprimeTest(3, 50) # true\nprimeTest(10, 50)# false\nprimeTest(97, 50) # NOW IS TRUE !!!!\n\n\nprime_test<-c(5,7,11,13,17 ,19,23,29,31,37,1009)\n\nfor (i in 1:length(prime_test)) {\n  print(primeTest(prime_test[i], 50))\n}\n#ALL TRUE\n```\n\n    ", "Answer": "\r\nOf course there is a problem with representing integers. In R integers will be represented correctly up to 2^53 - 1 which is about 9e15. And the term ```\ny^((n-1)/2)```\n will exceed that even for small numbers easily. You will have to compute ```\n(y^((n-1)/2)) %% n```\n by continually squaring ```\ny```\n and taking the modulus. That corresponds to the binary representation of ```\n(n-1)/2```\n.\n\nEven the 'real' number theory programs do it like that -- see Wikipedia's entry on \"modular exponentiation\". That said it should be mentioned that programs like R (or Matlab and other systems for numerical computing) may not be a proper environment for implementing number theory algorithms, probably not even as playing fields with small integers.\n\nEdit: The original package was incorrect\nYou could utilize the function modpower() in package 'pracma' like this: \n\n```\nprimeTest <- function(n, iter){\n  a <- sample(1:(n-1), 1)\n    lehmannTest <- function(y, tries){\n    x <- modpower(y, (n-1)/2, n)  # ((y^((n-1)/2)) %% n)\n    if (tries == 0) {\n      return(TRUE)\n            }else{          \n      if ((x == 1) | (x == (-1 %% n))){\n        lehmannTest(sample(1:(n-1), 1), (tries-1))\n      }else{\n    return(FALSE)\n      }\n    }\n  }\n  lehmannTest(a, iter)\n}\n```\n\n\nThe following test is successful as 1009 is the only prime in this set:\n\n```\nprime_test <- seq(1001, 1011, by = 2)\nfor (i in 1:length(prime_test)) {\n    print(primeTest(prime_test[i], 50))\n}\n# FALSE FALSE FALSE FALSE TRUE  FALSE\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Time complexity of Miller Rabin Primality Test\r\n                \r\nWhat would be the time complexity be for this algorithm below?\n```\nusing ll = long long;\nusing u64 = ll;\nusing u128 = ll;\n\nu64 binpower(u64 base, u64 e, u64 mod) {\n    u64 result = 1;\n    base %= mod;\n    while (e) {\n        if (e & 1)\n            result = (u128)result * base % mod;\n        base = (u128)base * base % mod;\n        e >>= 1;\n    }\n    return result;\n}\n\nbool check_composite(u64 n, u64 a, u64 d, int s) {\n    u64 x = binpower(a, d, n);\n    if (x == 1 || x == n - 1)\n        return false;\n    for (int r = 1; r < s; r++) {\n        x = (u128)x * x % n;\n        if (x == n - 1)\n            return false;\n    }\n    return true;\n};\n\nbool MillerRabin(u64 n) { // returns true if n is prime, else returns false.\n    if (n < 2)\n        return false;\n\n    int r = 0;\n    u64 d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n\n    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n        if (n == a)\n            return true;\n        if (check_composite(n, a, d, r))\n            return false;\n    }\n    return true;\n}\n```\n\nRecently I have gotten interested in primality tests, and have wondered what would the time complexity be for the deterministic version of Miller-Rabin. Code directly taken by https://cp-algorithms.com/\nI would think that the time complexity would be at least ```\nO(log(d))```\n because the binpower function is ```\nO(log(e))```\n. Also the ```\ncheck_composite```\n function runs in ```\nO(s)```\n. But the thing that I am having trouble with is the total time complexity.\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Problems with implementing Lucas–Lehmer primality test\r\n                \r\nI try to implement the Lucas–Lehmer test (LLT) primality test for Mersenne numbers (https://en.wikipedia.org/wiki/Lucas%E2%80%93Lehmer_primality_test). It should be polynomial and hence fast. Here is my code:\n\n```\nfunction countPrimeNumberWithDigits(numberOfDigits)\n    {\n        if(numberOfDigits < 1)\n        {return \"Please give a valid input!\";}\n\n        var shouldBeMoreThanThis = Math.pow(10, numberOfDigits-1), n = 3, M = countMWithIndex(n);\n        while(M < shouldBeMoreThanThis)\n        {\n            n += 2;\n            M = countMWithIndex(n);\n        }\n\n        console.log(n);\n\n        while(true)\n        {\n            var S = 4, k = 1;\n            M = countMWithIndex(n);\n\n            while(k != n - 1)\n            {\n                S = (S*S - 2)%M;\n                k +=1;\n            }\n\n            if(S!=0)\n            {n+=2;}\n            else\n            {break;}\n        }\n\n        return \"Prime number: \" + countMWithIndex(n);\n    }\n\nfunction countMWithIndex(n)\n    {return Math.pow(2, n) - 1;}\n```\n\n\nHere is attempt to use the algorithm implemented above:\nhttps://oobarbazanoo.github.io/findPrimeNumberWithSpecifiedQuantumOfDigits/\n\nWhen I try number of digits which is less than 7 everything is okay, but when I try to ask for prime number with at least 7 digits the program just stumbles and doesn`t give an answer.\n\nPlease, help me. What is wrong with my algorithm implementation or what is wrong with my program itself?\n    ", "Answer": "\r\nIf I run the code on https://repl.it/languages/javascript with this change:\n\n```\nS = (S*S - 2 + M)%M;\n```\n\n\nThen it finishes for (seemingly) any number of digits. However, the results seem incorrect: it outputs non-primes with more digits than requested.\n\nThe problem is that javascript can evaluate modulo to negative results. For example, ```\n-2 % 5```\n will be ```\n-2```\n. This is mathematically correct, but most computer science algorithms require positive values, so ```\n3```\n in this case.\n\nAdding ```\nM```\n in that formula will ensure that the result is positive regardless of language quirks.\n\nThe problem with incorrect results is likely due to the fact that you do not follow this requirement:\n\n\n  The Lucas–Lehmer test works as follows. Let Mp = 2**p − 1 be the Mersenne number to test with p an odd prime. \n\n\nThe ```\np```\n there is the ```\nn```\n in your code. Nowhere do you ensure that ```\nn```\n is prime.\n\nThen there is also that javascript's integer type might not be big enough. With ```\nn```\n larger than ```\n23```\n, it starts to reach its limits. For example, there is no Mersenne prime with 7 digits. The next is with 10 digits, which is ```\n2**31 - 1```\n.\n\nYou won't be able to find it in (pure) javascript however, because the computation involves squaring ```\n2**31 - 1```\n, which exceeds the bounds of javascript's integers.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Having trouble getting Miller-Rabin primality test in Python\r\n                \r\nI have been trying to implement Miller-Rabin primality test in Python. Unfortunately there seems to be a problem on some prime numbers. Any help is appreciated.\nCode:\n```\ndef _isPrime(n):\n\nif n % 2 == 0:\n    return False\n\na = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\ns, d = _Apart(n) # turns it into 2^s x d\nprint(s, d)\n\nbasePrime = False\nisPrime = True\n\nfor base in a:\n    if base >= n-2:\n        break \n\n    if isPrime == False and basePrime == False:\n        return False\n    \n    witness = pow(base, d)\n\n    if (witness % n) == 1 or (witness % n) == (n-1):\n        basePrime = True\n        continue\n    else:\n        basePrime = False\n\n    for r in range(1, s):\n        witness = pow(base, pow(2, r) * d)\n\n        if (witness % n) != ( n - 1 ):\n            isPrime = False\n\nreturn True\n```\n\nTest:\n```\nisPrime(17)\n```\n\nExpected:\n```\nTrue\n```\n\nResult:\n```\nFalse\n```\n\n    ", "Answer": "\r\nI wrote a Miller Rabin test that is deterministic, no need for random numbers. This implementation is for python 3.7. In python 3.8, llinear_diophantinex can be replaced with pow(x, -1, y).  Also i used gmpy2 as it's very fast, but you can just replace the gmpy2 statements with normal pow if you can't use that, and just remove the gmpy2.mpz() wrappers since those are just used to overload operators.\n```\nimport gmpy2\n\nsinn = 2110229697309202254897383305762150945330987087513434511395506048950594976569434432057019507105035289374307720719984431280856161609820548842778454256113246763860786119268583367543952735347969627478873317341364209555365064365565504232770227619462128918701942169785585423104678142850200975026619010035331023744330713985615650556129731348659986462960062760308034462660525448390420668021248422741300646552941285862310410598374242189448623917196191138254637812716211329113836605859918549332304189053950819346551095911511755911832183789503704294770046935064469435830299623205136625543859303686699678929069468518950480476841246805908501510754550017255944080874819287974625925494008373883250410775902993163965873632474224574883242826458163446781002284368017611606202344050570737818087202137703099075773680753707346415849787963446390136517016131227807076254668461445862154978026041507116570585784569893773262639243954090283224759975513502582494002154146757110676408972377044584495342170277522887809749465855954126593100747444378301829661568735873345178089061677917127496915956539418931430313218084338374827152407795095072639044306222222695685778907958272820576498682506540189586657786292950574081739269257159839589987847266550007783514316481286222515710538845836151864127815058116482680058626451349913138908040817800742009650450811565324184631847563730941344941348929727603343965091116543702880556850922077216848669966268219928808236163268726995495688157209747596437162960244538054993785127947211290438554095851924381172697827312534174244295581184309147813790451951453564726742200569263225639113681905176376701339808868274637448606821696026703034737428319530072483125495383057919894902076566679023694181381398377144302767983385253577700652358431959604517728821603076762965129019244904679015099154368058005173028200266632883632953133017055122970338782493475762548347258351148037427739052271661340801912188203749647918379812483260399614599813650518046331670764766419886619324840045611486524123102046413946014624119568013100078163986683199814025915420877588778260860713148420321896163326473203441644820182490479899368048072263481024886708136521847014624735722333931331098969321911443978386868675912141648200500219168920887757573018380579532261231821382787339600631297820996466930957801607217549420247654458172818940238337170577825003408756362106088558651381993611741503374243481167926898332728164900189941804942580426055589622673679047058619682175301326905577843405270203660160407401675700528981573327582844330828861745574031416926871562443652858767649050943181353635950301154441954046214987718582670685455252774874198771086552440702483933126644594300464549471422237478151976561680719370424626162642534252062987911763456822609569209140676822858933588602318066530038691463577379331113471591913447226829868760176810195567325921301390329055242213842898142597360121925124635965685365925901913816717677946911762631634793638450106377437599347740569467683272089859392249351406815344105961234868327316964137925419770514177021722214309784062017826024217906664090209434553785436385765927274067126192143337589109608949427467825999057058702263715338956534536892852849984934736685814891286495169007648767081688963426768409476169071460997622740467533572971356017575900999100928776382541052696124463195981888715845688808970103527288822088031150716134784735332326775370417950625124642515148342694377095213470544739900830244879573205335578256682901821773047071352497997708791157012233232529777513203024818391621220967964874173106990772425289900446640237659116713251437567138729645677868024033209183367071421651937808005637679844370347367922676824239404492688418047080583797577102267329067247758368597488680401670673861120323439239792549053895366970423259196919428554146265587250617656401028722578111927104663315250291888502226235291264834968061065817079511872899991276288365723969841290984981957389126603952133124328219936785870274843554107325931034103072894378438818494802517594594270034007832922248742746517915210656205746338575621725899098414488628833412591266637224507533934158213117522503993423240638893845121918647788013\n\n\ndef llinear_diophantinex(a, b, divmodx=1, x=1, y=0, offset=0, withstats=False, pow_mod_p2=False):  \n  origa, origb = a, gmpy2.mpz(b)  \n  r=a   \n  q = a//b  \n  prevq=1   \n  if a == 1: \n    return 1 \n  if withstats == True:  \n    print(f\"a = {a}, b = {b}, q = {q}, r = {r}\")    \n  while r != 0:   \n       prevr = r   \n       a,r,b = b, b, r    \n       q,r = divmod(a,b)  \n       x, y = y, x - q * y  \n       if withstats == True:  \n         print(f\"a = {a}, b = {b}, q = {q}, r = {r}, x = {x}, y = {y}\")   \n  y = gmpy2.mpz(1 - origb*x // origa - 1) \n  if withstats == True:  \n    print(f\"x = {x}, y = {y}\")   \n  x,y=y,x  \n  modx = (-abs(x)*divmodx)%origb  \n  if withstats == True:  \n    print(f\"x = {x}, y = {y}, modx = {modx}\")  \n  if pow_mod_p2==False:    \n    return (x*divmodx)%origb, y, modx, (origa)%origb \n  else:  \n    if x < 0: return (modx*divmodx)%origb  \n    else: return (x*divmodx)%origb \n \ndef ffs(x): \n    \"\"\"Returns the index, counting from 0, of the \n    least significant set bit in `x`. \n    \"\"\" \n    return (x&-x).bit_length()-1 \n \ndef MillerRabin(arglist):  \n  N = arglist[0] \n  primetest = arglist[1] \n  iterx = arglist[2] \n  powx = arglist[3] \n  withstats = arglist[4] \n  primetest = gmpy2.powmod(primetest, powx, N)  \n  if withstats == True: \n     print(\"first: \", primetest)  \n  if primetest == 1 or primetest == N - 1:  \n    return True  \n  else:  \n    for x in range(0, iterx):  \n       primetest = gmpy2.powmod(primetest, 2, N)  \n       if withstats == True: \n          print(\"else: \", primetest)  \n       if primetest == N - 1: return True  \n       if primetest == 1: return False  \n  return False  \n       \ndef sfactorint_isprime(N, withstats=False): \n \n    N = gmpy2.mpz(N) \n    from multiprocessing import Pool \n \n    if N <= 1: return False \n    if N == 2: \n      return True \n    if N % 2 == 0: \n      return False \n    if N < 2: \n        return False \n         \n    # Add Trial Factoring here to speed up smaller factored number testing \n \n     \n    iterx = ffs(N-1) \n    \"\"\" This k test is an algorithmic test builder instead of using \n        random numbers. The offset of k, from -2 to +2 produces pow tests \n        that fail or pass instead of having to use random numbers and more \n        iterations. All you need are those 5 numbers from k to get a  \n        primality answer.  \n    \"\"\" \n    k = llinear_diophantinex(N, 1<<N.bit_length(), pow_mod_p2=True) - 1 \n    t = N >> iterx \n    tests = [k-2, k-1, k, k+1, k+2] \n     \n    for primetest in range(len(tests)): \n      if tests[primetest] >= N: \n         tests[primetest] %= N \n   \n    arglist = [] \n    for primetest in range(len(tests)): \n      if tests[primetest] >= 2: \n        arglist.append([N, tests[primetest], iterx, t, withstats]) \n      \n    with Pool(5) as p: \n       s=p.map(MillerRabin, arglist)     \n     \n    if s.count(True) == len(arglist): return True\n    else: return False \n     \n    return s   \n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Optimizing a primality test based on runtime in Python\r\n                \r\nI'm pretty new to algorithms and runtimes, and I'm trying to optimise a bit of my code for a personal project. \n\n```\nimport math\nfor num in range(0, 10000000000000000000000):\n    if all((num**(num+1)+(num+1)**(num))%i!=0 for i in range(2,int(math.sqrt((num**(num+1)+(num+1)**(num))))+1)):\n        print(num)\n```\n\n\nWhat can I do to speed this up? I know that ```\nnum=80```\n should work but my code isn't getting past ```\nnum=0, 1, 2```\n (it's not fast enough). \n\nFirst I define my range, then I say if 'such-and-such' is prime from range 2 to sqrt(such-and-such) + 1, then return that number. Sqrt(n) + 1 is the minimum number of factors to test for the primality of n. \n\nThis is a primality test of sequence A051442\n    ", "Answer": "\r\nYou would probably get a minor boost from computing ```\n(num**(num+1)+(num+1)**(num))```\n only once per iteration instead of ```\nsqrt(num**(num+1)+(num+1)**(num))```\n times. As you can see, this will greatly reduce the constant factor in your complexity. It won't change the fundamental complexity because you still need to compute the remainder. Change\n\n```\nif all((num**(num+1)+(num+1)**(num))%i!=0 for i in range(2,int(math.sqrt((num**(num+1)+(num+1)**(num))))+1)):\n```\n\n\nto\n\n```\nk = num**(num+1)+(num+1)**(num)\nif all(k%i for i in range(2,int(math.sqrt(k))+1)):\n```\n\n\nThe ```\n!= 0```\n is implicit in Python.\n\nUpdate\n\nAll this is just trivial improvement to an extremely inefficieny algorithm. The biggest speedup I can think of is to reduce the check ```\nk % i```\n to only prime ```\ni```\n. For any composite ```\ni = a * b```\n such that ```\nk % i == 0```\n, it must be the case that ```\nk % a == 0 and k % b == 0```\n (if ```\nk```\n is divisible by ```\ni```\n, it must also be divisible by the factors of ```\ni```\n).\n\nI am assuming that you don't want to use any kind of pre-computed prime tables in your code. In that case, you can compute the table yourself. This will involve checking all the numbers up to a given ```\nsqrt(k)```\n only once ever, instead of once per iteration of ```\nnum```\n, since we can stash the previously computed primes in say a ```\nlist```\n. That will effectively increase the lower limit of the range in your current ```\nall```\n from 2 to the square root of the previous ```\nk```\n.\n\nLet's define a function to extend our set of primes using the seive of Eratosthenes:\n\n```\nfrom math import sqrt\n\ndef extend(primes, from_, to):\n    \"\"\"\n    primes: a sequence containing prime numbers from 2 to `from - 1`, in order\n    from_: the number to start checking with\n    to: the number to end with (inclusive)\n    \"\"\"\n    if not primes:\n        primes.extend([2, 3])\n        return\n    for k in range(max(from_, 5), to + 1):\n         s = int(sqrt(k))  # No need to compute this more than once per k\n         for p in primes:\n            if p > s:\n                # Reached sqrt(k) -> short circuit success\n                primes.append(k)\n                break\n            elif not k % p:\n                # Found factor -> short circuit failure\n                break\n```\n\n\nNow we can use this function to extend our list of primes at every iteration of the original loop. This allows us to check the divisibility of ```\nk```\n only against the slowly growing list of primes, not against all numbers:\n\n```\nprimes = []\nprev = 0\nfor num in range(10000000000000000000000):\n    k = num**(num + 1) + (num + 1)**num\n    lim = int(sqrt(k)) + 1\n    extend(primes, prev, lim)\n    #print('Num={}, K={}, checking {}-{}, p={}'.format(num, k, prev, lim, primes), end='... ')\n    if k <= 3 and k in primes or all(k % i for i in primes):\n        print('{}: {} Prime!'.format(num, k))\n    else:\n        print('{}: {} Nope'.format(num, k))\n    prev = lim + 1\n```\n\n\nI am not 100% sure that my extend function is optimal, but I am able to get to ```\nnum == 13```\n, ```\nk == 4731091158953433```\n in <10 minutes on my ridiculously old and slow laptop, so I guess it's not too bad. That means that the algorithm builds a complete table of primes up to ~7e7 in that time.\n\nUpdate #2\n\nA sort-of-but-not-really optimization you could do would be to check ```\nall(k % i for i in primes)```\n before calling ```\nextend```\n. This would save you a lot of cycles for numbers that have small prime factors, but would probably catch up to you later on, when you would end up having to compute all the primes up to some enormous number. Here is a sample of how you could do that:\n\n```\nprimes = []\nprev = 0\nfor num in range(10000000000000000000000):\n    k = num**(num + 1) + (num + 1)**num\n    lim = int(sqrt(k)) + 1\n    if not all(k % i for i in primes):\n        print('{}: {} Nope'.format(num, k))\n        continue\n    start = len(primes)\n    extend(primes, prev, lim)\n    if all(k % i for i in primes[start:]):\n        print('{}: {} Prime!'.format(num, k))\n    else:\n        print('{}: {} Nope'.format(num, k))\n    prev = lim + 1\n```\n\n\nWhile this version does not do much for the long run, it does explain why you were able to get to 15 so quickly in your original run. The prime table does note get extended after ```\nnum == 3```\n, until ```\nnum == 16```\n, which is when the terrible delay occurs in this version as well. The net runtime to 16 should be identical in both versions.\n\nUpdate #3\n\nAs @paxdiablo suggests, the only numbers we need to consider in ```\nextend```\n are multiples of 6 +/- 1. We can combine that with the fact that only a small number of primes generally need to be tested, and convert the functionality of ```\nextend```\n into a generator that will only compute as many primes as absolutely necessary. Using Python's lazy generation should help. Here is a completely rewritten version:\n\n```\nfrom itertools import count\nfrom math import ceil, sqrt\n\nprime_table = [2, 3]\n\ndef prime_candidates(start=0):\n    \"\"\"\n    Infinite generator of prime number candidates starting with the\n    specified number.\n\n    Candidates are 2, 3 and all numbers that are of the form 6n-1 and 6n+1\n    \"\"\"\n    if start <= 3:\n        if start <= 2:\n            yield 2\n        yield 3\n        start = 5\n        delta = 2\n    else:\n        m = start % 6\n        if m < 2:\n            start += 1 - m\n            delta = 4\n        else:\n            start += 5 - m\n            delta = 2\n    while True:\n        yield start\n        start += delta\n        delta = 6 - delta\n\ndef isprime(n):\n    \"\"\"\n    Checks if `n` is prime.\n\n    All primes up to sqrt(n) are expected to already be present in\n    the generated `prime_table`.\n    \"\"\"\n    s = int(ceil(sqrt(n)))\n    for p in prime_table:\n        if p > s:\n            break\n        if not n % p:\n            return False\n    return True\n\ndef generate_primes(max):\n    \"\"\"\n    Generates primes up to the specified maximum.\n\n    First the existing table is yielded. Then, the new primes are\n    found in the sequence generated by `prime_candidates`. All verified\n    primes are added to the existing cache.\n    \"\"\"\n    for p in prime_table:\n        if p > max:\n            return\n        yield p\n    for k in prime_candidates(prime_table[-1] + 1):\n        if isprime(k):\n            prime_table.append(k)\n            if k > max:\n                # Putting the return here ensures that we always stop on a prime and therefore don't do any extra work\n                return\n            else:\n                yield k\n\nfor num in count():\n    k = num**(num + 1) + (num + 1)**num\n    lim = int(ceil(sqrt(k)))\n    b = all(k % i for i in generate_primes(lim))\n    print('n={}, k={} is {}prime'.format(num, k, '' if b else 'not '))\n```\n\n\nThis version gets to 15 almost instantly. It gets stuck at 16 because the smallest prime factor for ```\nk=343809097055019694337```\n is ```\n573645313```\n. Some future expectations:\n\n\n```\n17```\n should be a breeze: ```\n16248996011806421522977```\n has factor ```\n19```\n\n```\n18```\n will take a while: ```\n812362695653248917890473```\n has factor ```\n22156214713```\n\n```\n19```\n is easy: ```\n42832853457545958193355601```\n is divisible by ```\n3```\n\n```\n20```\n also easy: ```\n2375370429446951548637196401```\n is divisible by ```\n58967```\n\n```\n21```\n: ```\n138213776357206521921578463913```\n is divisible by ```\n13```\n\n```\n22```\n: ```\n8419259736788826438132968480177```\n is divisible by ```\n103```\n\netc... (link to sequence)\n\n\nSo in terms of instant gratification, this method will get you much further if you can make it past 18 (which will take >100 times longer than getting past 16, which in my case took ~1.25hrs).\n\nThat being said, your greatest speedup at this point would be re-writing this in C or some similar low-level language that does not have as much overhead for loops.\n\nUpdate #4\n\nJust for giggles, here is an implementation of the latest Python version in C. I chose to go with GMP for arbitrary precision integers, because it is easy to use and install on my Red Hat system, and the docs are very clear:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <gmp.h>\n\ntypedef struct {\n    size_t alloc;\n    size_t size;\n    mpz_t *numbers;\n} PrimeTable;\n\nvoid init_table(PrimeTable *buf)\n{\n    buf->alloc = 0x100000L;\n    buf->size = 2;\n    buf->numbers = malloc(buf->alloc * sizeof(mpz_t));\n    if(buf == NULL) {\n        fprintf(stderr, \"No memory for prime table\\n\");\n        exit(1);\n    }\n    mpz_init_set_si(buf->numbers[0], 2);\n    mpz_init_set_si(buf->numbers[1], 3);\n    return;\n}\n\nvoid append_table(PrimeTable *buf, mpz_t number)\n{\n    if(buf->size == buf->alloc) {\n        size_t new = 2 * buf->alloc;\n        mpz_t *tmp = realloc(buf->numbers, new * sizeof(mpz_t));\n        if(tmp == NULL) {\n            fprintf(stderr, \"Ran out of memory for prime table\\n\");\n            exit(1);\n        }\n        buf->alloc = new;\n        buf->numbers = tmp;\n    }\n    mpz_set(buf->numbers[buf->size], number);\n    buf->size++;\n    return;\n}\n\nsize_t print_table(PrimeTable *buf, FILE *file)\n{\n    size_t i, n;\n\n    n = fprintf(file, \"Array contents = [\");\n    for(i = 0; i < buf->size; i++) {\n        n += mpz_out_str(file, 10, buf->numbers[i]);\n        if(i < buf->size - 1)\n            n += fprintf(file, \", \");\n    }\n    n += fprintf(file, \"]\\n\");\n    return n;\n}\n\nvoid free_table(PrimeTable *buf)\n{\n    for(buf->size--; ((signed)(buf->size)) >= 0; buf->size--)\n        mpz_clear(buf->numbers[buf->size]);\n    free(buf->numbers);\n    return;\n}\n\nint isprime(mpz_t num, PrimeTable *table)\n{\n    mpz_t max, rem, next;\n    size_t i, d, r;\n\n    mpz_inits(max, rem, NULL);\n    mpz_sqrtrem(max, rem, num);\n\n    // Check if perfect square: definitely not prime\n    if(!mpz_cmp_si(rem, 0)) {\n        mpz_clears(rem, max, NULL);\n        return 0;\n    }\n\n    /* Normal table lookup */\n    for(i = 0; i < table->size; i++) {\n        // Got to sqrt(n) -> prime\n        if(mpz_cmp(max, table->numbers[i]) < 0) {\n            mpz_clears(rem, max, NULL);\n            return 1;\n        }\n        // Found a factor -> not prime\n        if(mpz_divisible_p(num, table->numbers[i])) {\n            mpz_clears(rem, max, NULL);\n            return 0;\n        }\n    }\n\n    /* Extend table and do lookup */\n    // Start with last found prime + 2\n    mpz_init_set(next, table->numbers[i - 1]);\n    mpz_add_ui(next, next, 2);\n    // Find nearest number of form 6n-1 or 6n+1\n    r = mpz_fdiv_ui(next, 6);\n    if(r < 2) {\n        mpz_add_ui(next, next, 1 - r);\n        d = 4;\n    } else {\n        mpz_add_ui(next, next, 5 - r);\n        d = 2;\n    }\n    // Step along numbers of form 6n-1/6n+1. Check each candidate for\n    // primality. Don't stop until next prime after sqrt(n) to avoid\n    // duplication.\n    for(;;) {\n        if(isprime(next, table)) {\n            append_table(table, next);\n            if(mpz_divisible_p(num, next)) {\n                mpz_clears(next, rem, max, NULL);\n                return 0;\n            }\n            if(mpz_cmp(max, next) <= 0) {\n                mpz_clears(next, rem, max, NULL);\n                return 1;\n            }\n        }\n        mpz_add_ui(next, next, d);\n        d = 6 - d;\n    }\n\n    // Return can only happen from within loop.\n}\n\nint main(int argc, char *argv[])\n{\n    PrimeTable table;\n    mpz_t k, a, b;\n    size_t n, next;\n    int p;\n\n    init_table(&table);\n    mpz_inits(k, a, b, NULL);\n    for(n = 0; ; n = next) {\n        next = n + 1;\n        mpz_set_ui(a, n);\n        mpz_pow_ui(a, a, next);\n        mpz_set_ui(b, next);\n        mpz_pow_ui(b, b, n);\n        mpz_add(k, a, b);\n        p = isprime(k, &table);\n        printf(\"n=%ld k=\", n);\n        mpz_out_str(stdout, 10, k);\n        printf(\" p=%d\\n\", p);\n        //print_table(&table, stdout);\n    }\n    mpz_clears(b, a, k, NULL);\n    free_table(&table);\n    return 0;\n}\n```\n\n\nWhile this version has the exact same algorithmic complexity as the Python one, I expect it to run a few orders of magnitude faster because of the relatively minimal overhead incurred in C. And indeed, it took about 15 minutes to get stuck at ```\nn == 18```\n, which is ~5 times faster than the Python version so far.\n\nUpdate #5\n\nThis is going to be the last one, I promise.\n\nGMP has a function called ```\nmpz_nextprime```\n, which offers a potentially much faster implementation of this algorightm, especially with caching. According to the docs:\n\n\n  This function uses a probabilistic algorithm to identify primes. For practical purposes it’s adequate, the chance of a composite passing will be extremely small.\n\n\nThis means that it is probably much faster than the current prime generator I implemented, with a slight cost offset of some false primes being added to the cache. This cost should be minimal: even adding a few thousand extra modulo operations should be fine if the prime generator is faster than it is now.\n\nThe only part that needs to be replaced/modified is the portion of ```\nisprime```\n below the comment ```\n/* Extend table and do lookup */```\n. Basically that whole section just becomes a series of calls to ```\nmpz_nextprime```\n instead of recursion.\n\nAt that point, you may as well adapt ```\nisprime```\n to use ```\nmpz_probab_prime_p```\n when possible. You only need to check for sure if the result of ```\nmpz_probab_prime_p```\n is uncertain:\n\n```\nint isprime(mpz_t num, PrimeTable *table)\n{\n    mpz_t max, rem, next;\n    size_t i, r;\n    int status;\n\n    status = mpz_probab_prime_p(num, 50);\n    // Status = 2 -> definite yes, Status = 0 -> definite no\n    if(status != 1)\n        return status != 0;\n\n    mpz_inits(max, rem, NULL);\n    mpz_sqrtrem(max, rem, num);\n\n    // Check if perfect square: definitely not prime\n    if(!mpz_cmp_si(rem, 0)) {\n        mpz_clears(rem, max, NULL);\n        return 0;\n    }\n\n    mpz_clear(rem);\n\n    /* Normal table lookup */\n    for(i = 0; i < table->size; i++) {\n        // Got to sqrt(n) -> prime\n        if(mpz_cmp(max, table->numbers[i]) < 0) {\n            mpz_clear(max);\n            return 1;\n        }\n        // Found a factor -> not prime\n        if(mpz_divisible_p(num, table->numbers[i])) {\n            mpz_clear(max);\n            return 0;\n        }\n    }\n\n    /* Extend table and do lookup */\n    // Start with last found prime + 2\n    mpz_init_set(next, table->numbers[i - 1]);\n    mpz_add_ui(next, next, 2);\n\n    // Step along probable primes\n    for(;;) {\n        mpz_nextprime(next, next);\n        append_table(table, next);\n        if(mpz_divisible_p(num, next)) {\n            r = 0;\n            break;\n        }\n        if(mpz_cmp(max, next) <= 0) {\n            r = 1;\n            break;\n        }\n    }\n\n    mpz_clears(next, max, NULL);\n    return r;\n}\n```\n\n\nSure enough, this version makes it to ```\nn == 79```\n in a couple of seconds at most. It appears to get stuck on ```\nn == 80```\n, probably because ```\nmpz_probab_prime_p```\n can't determine if ```\nk```\n is a prime for sure. I doubt that computing all the primes up to ~10^80 is going to take a trivial amount of time.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to make primality test accept large numbers\r\n                \r\nI have a code for primality test that accepts integers up to 10 digits, but I want to extend this expansively so that the code accepts more than 200 digits. What should I switch in the code?\n\n```\nimport java.util.*; \nimport java.math.*; \n\nclass CheckPrimeTest { \n\n    static boolean checkPrime(long n) \n    { \n        // Corner case \n        if (n <= 1) return false; \n\n        // Check from 2 to n-1 \n        for (int i = 2; i < n; i++) \n            if (n % i == 0) \n                return false; \n\n        return true; \n    } \n\n    // Driver Program  \n    public static void main(String args[]) \n\n                         throws java.lang.Exception \n    { \n Scanner input = new Scanner(System.in);\n  System.out.print(\"Enter an integer: \");\n        long n = input.nextInt();  \n\n       System.out.println(checkPrime(n)); \n\n    } \n} \n```\n\n    ", "Answer": "\r\nIf you have such large numbers you can't use ```\nint```\ns and ```\nlong```\ns, you will have to use ```\nBigInteger```\n which already defines an ```\nisProbablePrime```\n method for you:\n\n```\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    BigInteger integer = new BigInteger(scanner.nextLine());\n    System.out.println(integer.isProbablePrime(1));\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How about big numbers? ( primality tests ) [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nIs this a 'real' task, that can be written on any language ( C/C++, for example ) \n\nSo, my task is 'generate' random number with length over 50 digits ( maximum = 200 )?\n\nThen, i must check this number on primality test. \n\nSo, is this task 'real' and how many time/resources it will consume?\n\nalternative way is to generate prime Mersenn numbers or other numbers from special class ( which class could be used? )\n    ", "Answer": "\r\nThere are efficient probabilistic algorithms for primality testing like Miller-Rabin that are usually used for such purposes.\n\nPicking a random number and testing for primality using a randomized algorithm is efficient since the density of primes guarantees you that for n-bit numbers you need to pick around n numbers to test.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Finding Mersenne primes with Lucas–Lehmer primality test\r\n                \r\nI want to implement a ```\nStream```\n in Scala for finding Mersenne primes with the Lucas-Lehmer primality test. I already have:\n\n```\nobject Main {\n  //Mersenne Numbers:\n  def msrn():Stream[BigInt] = 7#::msrn.map(_*2+1)\n  def s():Stream[BigInt] = 14 #:: s.map(n => n*n-2)\n  lazy val zips = s.zip(msrn)\n  def main(args: Array[String]) {\n     zips take 7 foreach println\n  }\n}\n```\n\n\nWhat I need to do now is find all Mersenne Numbers (elements in ```\nmsrn```\n) which divides the element in ```\ns```\n and write them in a ```\nStream```\n.\n\nEdit: Solved it:\n\n```\nobject Main {\n  def msrn():Stream[BigInt] = 7#::msrn.map(_*2+1)\n  def s():Stream[BigInt] = 14 #:: s.map(n => n*n-2)\n  lazy val zips = s.zip(msrn).filter(x=>x._1%x._2==0)\n  def mersennePrimeStream():Stream[BigInt] = zips.map(x => x._2)\n  def main(args: Array[String]) {\n     mersennePrimeStream take 4 foreach println\n  }\n}\n```\n\n\nIs there a way to make it shorter though?\n    ", "Answer": "\r\nYou are much faster if you calculate the s-sequence modulo the Mersenne number you are testing: \n\n```\nobject Main {\n  def s(k: Int, m: BigInt) = Iterator.iterate(BigInt(14))(n => (n * n - 2) % m) drop k next\n  lazy val msrn: Stream[(Int,BigInt)] = (0,BigInt(7)) #:: msrn.map(t => (t._1 + 1, t._2 * 2 + 1))\n  val mersennePrimeStream = msrn filter(x => s(x._1, x._2) % x._2 == 0) map (_._2)\n  def main(args: Array[String]) = mersennePrimeStream take 10 foreach println\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin deterministic primality test (C)\r\n                \r\nI have found a program in C that implemented a deterministic variant of the Miller-Rabin primality test here. However, the modified code (which can be seen below) doesn't work when dealing with numbers bigger than 2^32, even though I use unsigned long long data type to store my numbers. Which should be able to hold integers up to 2^64. Where does it go wrong?\n\nIn short: my problem is that my code correctly determines if a number is prime or not but only if it is smaller than 2^32, which shouldn't be the case since I can store numbers up to 2^64\n\n```\n\nunsigned long long power(unsigned long long a, unsigned long long n, unsigned long long mod)\n{\n    unsigned long long power = a;\n    unsigned long long result = 1;\n\n    while (n)\n    {\n        if (n & 1)\n            result = (result * power) % mod;\n        power = (power * power) % mod;\n        n >>= 1;\n    }\n    return result;\n}\n\n// n−1 = 2^s * d with d odd by factoring powers of 2 from n−1\nunsigned long long witness(unsigned long long n, unsigned long long s, unsigned long long d, unsigned long long a)\n{\n    unsigned long long x = power(a, d, n);\n    unsigned long long y;\n\n    while (s) {\n        y = (x * x) % n;\n        if (y == 1 && x != 1 && x != n-1)\n            return 0;\n        x = y;\n        --s;\n    }\n    if (y != 1)\n        return 0;\n    return 1;\n}\n\n/*\n * if n < 1,373,653, it is enough to test a = 2 and 3;\n * if n < 9,080,191, it is enough to test a = 31 and 73;\n * if n < 4,759,123,141, it is enough to test a = 2, 7, and 61;\n * if n < 1,122,004,669,633, it is enough to test a = 2, 13, 23, and 1662803;\n * if n < 2,152,302,898,747, it is enough to test a = 2, 3, 5, 7, and 11;\n * if n < 3,474,749,660,383, it is enough to test a = 2, 3, 5, 7, 11, and 13;\n * if n < 341,550,071,728,321, it is enough to test a = 2, 3, 5, 7, 11, 13, and 17.\n */\n\nint is_prime_mr(unsigned long long n)\n{\n    if (((!(n & 1)) && n != 2 ) || (n < 2) || (n % 3 == 0 && n != 3))\n        return 0;\n    if (n <= 3)\n        return 1;\n\n    unsigned long long d = n / 2;\n    unsigned long long s = 1;\n    while (!(d & 1)) {\n        d /= 2;\n        ++s;\n    }\n    unsigned long long a1 = 4759123141;\n    unsigned long long a2 = 1122004669633;\n    unsigned long long a3 = 2152302898747;\n    unsigned long long a4 = 3474749660383;\n    if (n < 1373653)\n        return witness(n, s, d, 2) && witness(n, s, d, 3);\n    if (n < 9080191)\n        return witness(n, s, d, 31) && witness(n, s, d, 73);\n    if (n < a1)\n        return witness(n, s, d, 2) && witness(n, s, d, 7) && witness(n, s, d, 61);\n    if (n < a2)\n        return witness(n, s, d, 2) && witness(n, s, d, 13) && witness(n, s, d, 23) && witness(n, s, d, 1662803);\n    if (n < a3)\n        return witness(n, s, d, 2) && witness(n, s, d, 3) && witness(n, s, d, 5) && witness(n, s, d, 7) && witness(n, s, d, 11);\n    if (n < a4)\n        return witness(n, s, d, 2) && witness(n, s, d, 3) && witness(n, s, d, 5) && witness(n, s, d, 7) && witness(n, s, d, 11) && witness(n, s, d, 13);\n    return witness(n, s, d, 2) && witness(n, s, d, 3) && witness(n, s, d, 5) && witness(n, s, d, 7) && witness(n, s, d, 11) && witness(n, s, d, 13) && witness(n, s, d, 17);\n}\n\nint main()\n{\n  unsigned long long in1 = 4294967291;\n  unsigned long long in2 = 4294967311;\n  int a = is_prime_mr(in1); //4294967291 is the last prime below 2^32, should return 1 and does so correctly\n  printf(\"%d\\n\",a);\n  int b = is_prime_mr(in2); //4294967311 is the first prime after 2^32, should also return 1 but returns 0\n  printf(\"%d\",b);\n  return 0;\n}\n```\n\n    ", "Answer": "\r\nAs @Michael Dorgan suggested, the problem lied in the multiplication of two 64-bit integers which was resolved using a different implementation of ```\npowermod```\n.\n\n```\n//computes (a*b) (mod n)\nunsigned long long mul_mod(unsigned long long a, unsigned long long b, unsigned long long m)\n{\n   unsigned long long d = 0, mp2 = m >> 1;\n   if (a >= m) a %= m;\n   if (b >= m) b %= m;\n   for (int i = 0; i < 64; ++i)\n   {\n       d = (d > mp2) ? (d << 1) - m : d << 1;\n       if (a & 0x8000000000000000ULL)\n           d += b;\n       if (d >= m) d -= m;\n       a <<= 1;\n   }\n   return d;\n}\n//computes (a^b) (mod m)\nunsigned long long powermod(unsigned long long a, unsigned long long b, unsigned long long m)\n{\n    unsigned long long r = m==1?0:1;\n    while (b > 0) {\n        if (b & 1)\n            r = mul_mod(r, a, m);\n        b = b >> 1;\n        a = mul_mod(a, a, m);\n    }\n    return r;\n}\n```\n\n\nMy code now works for integers up to 2^64.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin Primality test FIPS 186-3 implementation\r\n                \r\nIm trying to implement the Miller-Rabin primality test according to the description in FIPS 186-3 C.3.1. No matter what I do, I cannot get it to work. The instructions are pretty specific, and I dont think I missed anything, and yet Im getting ```\ntrue```\n for non-prime values.\n\nWhat did I do wrong?\n\n```\ntemplate <typename R, typename S, typename T>\nT POW(R base, S exponent, const T mod){\n    T result = 1;\n    while (exponent){\n        if (exponent & 1)\n            result = (result * base) % mod;\n        exponent >>= 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n\n\n\n// used uint64_t to prevent overflow, but only testing with small numbers for now\nbool MillerRabin_FIPS186(uint64_t w, unsigned int iterations = 50){\n    srand(time(0));\n    unsigned int a = 0;\n    uint64_t W = w - 1; // dont want to keep calculating w - 1\n    uint64_t m = W;\n    while (!(m & 1)){\n        m >>= 1;\n        a++;\n    }\n\n    // skipped getting wlen\n    // when i had this function using my custom arbitrary precision integer class,\n    // and could get len(w), getting it and using it in an actual RBG \n    // made no difference \n\n    for(unsigned int i = 0; i < iterations; i++){\n        uint64_t b = (rand() % (W - 3)) + 2; // 2 <= b <= w - 2\n        uint64_t z = POW(b, m, w);\n        if ((z == 1) || (z == W))\n            continue;\n        else\n            for(unsigned int j = 1; j < a; j++){\n                z = POW(z, 2, w);\n                if (z == W)\n                    continue;\n                if (z == 1)\n                    return 0;// Composite\n            }\n    }\n    return 1;// Probably Prime\n}\n```\n\n\nthis:\n\n```\nstd::cout << MillerRabin_FIPS186(33) << std::endl;\nstd::cout << MillerRabin_FIPS186(35) << std::endl;\nstd::cout << MillerRabin_FIPS186(37) << std::endl;\nstd::cout << MillerRabin_FIPS186(39) << std::endl;\nstd::cout << MillerRabin_FIPS186(45) << std::endl;\nstd::cout << MillerRabin_FIPS186(49) << std::endl;\n```\n\n\nis giving me: \n\n```\n0\n1\n1\n1\n0\n1\n```\n\n    ", "Answer": "\r\nThe only difference between your implementation and Wikipedia's is that you forgot the second return composite statement. You should have a return 0 at the end of the loop.\n\nEdit: As pointed out by Daniel, there is a second difference. The continue is continuing the inner loop, rather than the outer loop like it's supposed to. \n\n```\nfor(unsigned int i = 0; i < iterations; i++){\n    uint64_t b = (rand() % (W - 3)) + 2; // 2 <= b <= w - 2\n    uint64_t z = POW(b, m, w);\n    if ((z == 1) || (z == W))\n        continue;\n    else{\n        int continueOuter = 0;\n        for(unsigned int j = 1; j < a; j++){\n            z = POW(z, 2, w);\n            if (z == W)\n                continueOuter = 1;\n                break;\n            if (z == 1)\n                return 0;// Composite\n        }\n        if (continueOuter) {continue;}\n    }\n    return 0; //This is the line you're missing.\n}\nreturn 1;// Probably Prime\n```\n\n\nAlso, if the input is even, it will always return probably prime since a is 0. You should add an extra check at the start for that.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "C++ long long Fermat Primality test for largest prime factor\r\n                \r\nI'm a little new to programming, right now trying to find the largest prime factor of 600851475143, for Project Euler. My code won't compile when I actually try and do the Fermat Primality test.\n\n```\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nint main () {\n\nlong long int num = 600851475143;\nlong long int factor = num / 2;\n\nfor (long long factor; factor > 0; factor--) {\n\n    //Use Fermat primality test.\n\n    if (num % factor == 0) {\n\n        long long int testNum1 = rand() % 50 + 1;\n        long long int testNum2 = rand() % 50 + 1;\n\n        long long int test1 = (pow(testNum1, factor - 1) % factor);\n        long long int test2 = (pow(testNum2, factor - 1) % factor);\n\n        if (test1 == 1 && test2 == 1){\n\n        cout << \"The greatest prime factor is: \" << factor;\n        break;\n\n        }\n    }\n\n}\n\nreturn 0;\n}\n```\n\n    ", "Answer": "\r\nHave a look at the documentation available for ```\nstd::pow```\n:\n\n\n  If any argument has integral type, it is cast to double\n\n\nSo in the expression ```\npow(testNum, factor - 1)```\n,  the arguments ```\ntestNum```\n and ```\nfactor - 1```\n are promoted to double-precision floats, and the result then is a double-precision float. \n\nYou can't use the ```\noperator %```\n on a double, as this operator is for integral types. Downcasting the result of ```\npow```\n might work, but you may easily run into integer overflow issues.\n\nEDIT\nSee this answer, regarding how to do this sort of big-integer computations.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fast primality test with 100% certainty?\r\n                \r\nI'm using GMP (with MPIR) for arbitrary size datatypes. I also use its primality test function, which uses Miller-Rabin method, but it is not accurate. This is what I want to fix.\n\nI was able to confirm that the number 18446744073709551253 is a prime by using brute-force, with the sqrt approach.\n\nIs there any way of checking large numbers being prime or not, with 100% accuracy?\n\n\nIt should not use too much memory/storage space, few megabytes is acceptable.\nIt should be faster than the sqrt method I used.\nIt should work for numbers that are at least 64bit in size, or larger.\nFinally, it should be 100% accurate, no maybes!\n\n\nWhat are my options ?\n\nI could live with the brute force method (for 64bit numbers) though, but out of interest, I want faster & larger. Also, the 64bit number check was too slow: total 43 seconds!\n    ", "Answer": "\r\nFor very large numbers, the AKS primality test is a deterministic primality test that runs in time O(log7.5n log log n), where n is the number of interest.  This is exponentially faster than the O(√n) algorithm.  However, the algorithm has large constant factors, so it's not practical until your numbers get rather large.\n\nHope this helps!\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Success probability of naive monte carlo algorithm for primality testing\r\n                \r\nConsider the following naive monte Carlo algorithn for primality testing of a number n.\n\n```\nisPrimeMonteCarlo(n,t){\n/*\n * Take an integer n as input and check wheather it is prime or not\n * using the naive monte carlo method.\n * If the number is prime return True else return False.\n * */\nif(n<=1)\n    return False\nm = sqrt(n);\nfor i = 1 to t:\n    j = random()%m+2\n    if n%j==0:\n        return False\nreturn True\n}\n```\n\n\nFind the value of t such that the algorithm produces the correct output with high probability?\n\nWhat i could come up with so far:\n\nAssume n is non prime, the algorithm will fail when it outputs that n is prime.This happens when no number j gives n%j==0.\nj is chosen from [2,sqrt(n)+2].\nWe want j such that j does not divide n in any of the t iterations.\n\nAny such j must be a divisor of n.\nThe problem reduces to finding the number of divisors of n such that they are <= sqrt(n)+2.\nI am not able to find a bound on this number.\nAny help would be appreciated.\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller Rabin Primality test in C++ bug?\r\n                \r\nI'm currently solving Project Euler Problem 216.\nFirst, I implemented Miller-Rabin primality test in Python:\n\n```\nalist=[2,3,5,7,11,13,17,19,23]\ndef isPrime(n):\n    s=0\n    d=n-1\n    while not d&1:\n        s+=1\n        d/=2\n    for a in alist:\n        if a>=n:continue\n        compo=True\n        val=pow(a,d,n)\n        if val==1 or val==n-1:continue\n        for r in range(s-1):\n            val=val*val%n\n            if val==n-1:\n                compo=False\n                break\n        if(compo):return False\n    return True\n\nN=10000\ncnt=0\nfor i in range(2,N+1):\n    if isPrime(2*i*i-1):cnt+=1\nprint cnt\n```\n\n\nIt looks fine because example in PE for N=10000 matches. But python is slower than C++, so I translated this code to C++. In Problem, N=5e7, so we should use ```\nlong long```\n 64-bit int, and for exponent, we should use 128-bit int.\n\n```\n#include <cstdio>\nlong long list[9]={2,3,5,7,11,13,17,19,23};\nlong long exp(int a,long long d,long long n){\n    if (d==0)return 1LL;\n    if (d&1){\n        __int128_t tmp=exp(a,d-1,n);\n        return tmp*a%n;\n        //return exp(a,d-1,n)*a%n\n    }\n    __int128_t tmp=exp(a,d/2,n);\n    tmp=tmp*tmp%n;\n    return tmp;\n}\nbool isPrime(long long n){\n    int s=0;\n    long long d=n-1;\n    while(!d&1){\n        s++;\n        d/=2;\n    }\n    for(int i=0;i<9;i++){\n        int a=list[i];\n        if(a>=n)continue;\n        bool com=true;\n        long long val=exp(a,d,n);\n        if (val==1||val==n-1)continue;\n        for (int r=0;r<s-1;r++){\n            __int128_t tmp=val;\n            tmp=tmp*tmp%n;\n            val=tmp;\n            if (val==n-1){\n                com=false;\n                break;\n            }\n        }\n        if(com)return false;\n    }\n    return true;\n}\nint main(){\n    long long N=10000;\n    int cnt=0;\n    for(long long i=2;i<=N;i++){\n        if (isPrime(2LL*i*i-1))cnt++;\n    }\n    printf(\"%d \\n\",cnt);\n    return 0;\n}\n```\n\n\nThis is deterministic code because, if n < 3,825,123,056,546,413,051, it has been shown it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, and 23.\n\nBut surprisingly, it prints 2203, while python prints 2202. And I tested primality for small numbers (<1e7), there is no problem. I'm guessing this little difference does not mean my code has serious error such as integer overflow, but some error in using 128-bit integers.\n\nAlso i tried to determine is there any integer overflow evidence, I edited my code if val in ```\nisPrime```\n method gets <0, then assert, but it didn't assert for N=1e6.\n\nWhy did this error occur? I used g++ 4.6.3 on Windows.\n\nAfter some debugging, I discovered that C++ says 2*1939*1939-1 is a prime, but it is actually not.\n    ", "Answer": "\r\nThe error is in the line: \n\n```\nwhile(!d&1)\n```\n\n\nIf you look at C++'s Operator Precedence, you see that ```\n!```\n has the priority ```\n3```\n and ```\n&```\n has only the priority ```\n10```\n. That means, that the condition ```\n!d&1```\n gets parsed as ```\n(!d)&1```\n. But you actually want ```\n!(d&1)```\n. \n\nFor the future, how can you find such errors? Simple run both codes in parallel and compare some of the values. Since you wrote that the ```\ni = 1939```\n is the bad case. I simple made a breakpoint after the while loop and compared the values of ```\ns```\n and ```\nd```\n and noticed, that they are different in the Python version and the C++ version. And if you don't want to use a debugger, you can simple insert a line in both codes, that prints the values of ```\ns```\n and ```\nd```\n. \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fast primality testing for large `n` in Python\r\n                \r\nI'm working on a project that requires me to find whether extremely large numbers are prime numbers or not. Of course, I've read how to find prime numbers and have come up with a very simple brute force method:\n\n```\ndef is_prime_brute_force(p):\n    if p == 2 or p == 3:\n        return true\n    if p == 1 or p % 2 == 0 or any(p % i == 0 for i in range(3, floor_sqrt(p), 2)):\n        return false\n    return true\n```\n\n\nI've also investigated such probabilistic methods as the Miller-Rabin Primality Test and Fermat's little theorem (see here for Rosetta code's implementation of the former).\n\nThough the probabilistic options are an order of magnitude faster than brute force, they're still very slow for very large inputs of ```\nn```\n (for example, the known prime ```\n10**9999 + 33603```\n). \n\nI came across an interesting observation (of course I'm not the first to come across such an observation) that all primes fit the equation ```\np = 6 * k + 1```\n or ```\np = 6 * k -1```\n. In Python, such a function looks like this\n\n```\ndef is_prime_eq(p):\n    if p == 2 or p == 3:\n        return True\n    if p == 0 or p == 1:\n        return False\n\n    # The same as `return (p % 6 == 1) or (p % 6 == 5)`\n    prime_test = lambda p, a, m : (p % a == m) or (p % a == (a-m))\n    return prime_test(p, 6, 1)\n```\n\n\nThe above is guaranteed to return true if ```\np```\n is a prime, but a true result does not mean the ```\np```\n is a prime. An easy example is 25 (25 = 1 (mod 6), but clearly 25 = 5^2).\n\nI'm wondering if there's some more general way to apply this interesting property of primes, perhaps with different values of ```\na```\n to improve the speed of my ```\nis_prime```\n function.\n    ", "Answer": "\r\nA rather helpful solution was posted on math.stackexchange (here) which I've mirrored below\n\n\n\nIn relation to this algorithm, your proposed \"faster\" algorithm is equivalent to\n\n```\ndef is_prime_brute_force(p):\n    if p == 2 or p == 3:\n        return true\n    if p == 1 or p % 2 == 0 or p % 3 == 0:\n        return false\n    return true\n```\n\n\nHopefully you see why this is not terribly helpful.  Any composite which is a product of primes ```\n>= 5```\n will evaluate as a prime.  Usually we use probabilistic primality tests (e.g. Miller-Rabin) for numbers whose prime divisors are all sufficiently large, so ignoring all prime divisors greater than 3 makes it fairly useless.  \n\n\n\nPrimality tests are by their nature rather costly on current hardware.  The best you can do is to try to optimize for some given assumptions on the input.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "What is the fastest deterministic primality test for numbers in the range 2^1024 to 2^4096?\r\n                \r\nI am writing an implementation of a cryptography protocol.  So far I've been having a difficult time finding the fastest deterministic primality test for 1024-bit to 4096-bit integers (308- to 1233-digit numbers).  I am aware of several options but I have not been able to find real world speed comparisons.\n\nSpecifically, how does the AKS test perform compared to the deterministic version of Rabin-Miller and the Elliptic Curve Primality Proving test (and others) for general random numbers this size ?\n    ", "Answer": "\r\nThis article is answering your question:\n\nPRIMALITY TESTING by Richard P. Brent:\nhttp://cs.anu.edu.au/student/comp4600/lectures/comp4600_primality.pdf\n\nIt compares in complexity and in \"real world speed\" the 3 algorithms.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Trial Division faster than Sieve for Primality Test?\r\n                \r\nI wrote two primality tests in python. First one is based on trial division, the second one applies sieve of Eratosthenes. My understanding is that sieve should have a smaller time complexity than trial, so sieve should be asymptotically faster. \n\nHowever when I run it, trial division is much faster. For example, when ```\nn = 6*(10**11)```\n, ```\nis_prime(n)```\n takes less than a second, but ```\nis_prime_sieve(n)```\n practically never ends! Did I wrote the sieve wrong? \n\nMy code is:\n\n```\n# determines if prime using trial division\ndef is_prime(n):\n    d = {}\n    u = math.floor(math.sqrt(n))\n    i = 2\n    # trial division: works pretty well for determining 600 billion\n    while (i <= u):\n        if (n % i == 0):\n            return False\n        i += 1\n    return True\n\n# primality test with sieve\ndef is_prime_sieve(n):\n    # first find all prime numbers from 2 to u\n    # then test them\n    u = math.floor(math.sqrt(n))\n    prime = {}\n    lst = range(2, int(u)+1)\n    for i in lst:\n        j = 2\n        prime[i] = True\n        while (i*j <= u):\n            prime[i*j] = False\n            j += 1\n    while (u >= 2):\n        if (u not in prime) or (prime[u]):\n            if (n % u == 0):\n                return False\n        u -= 1\n    return True\n```\n\n    ", "Answer": "\r\nFor the Sieve of Erastothenes you are recomputing the sieve every time. The sieve should be cached so that you only generate it once. It works well when you build the sieve once and then perform many primality checks; it is very inefficient if you only check a single number.\n\nThis means, by the way, that you need to anticipate the highest prime number and generate the sieve table up to that number.\n\nWhen done right, ```\nis_prime_sieve```\n becomes simply:\n\n```\ndef is_prime_sieve(n):\n    return prime[n]\n```\n\n\nYou would not need the ```\nwhile```\n loop.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fermat primality test too slow - issues with big integers\r\n                \r\nThis is my code for Fermat's primality test:\n```\ndef fermat(n):\n    counter = 0\n    prime = False\n    if n >= 40:\n        upper_bound = 40\n    else:\n        upper_bound = n - 1\n\n    for a in range(2, upper_bound + 1):\n        print(a)\n        if pow_mod(a, n - 1, n) == 1:\n            counter += 1\n\n    if counter == n - 2 and upper_bound == n - 1 or counter == 39 and upper_bound == 40:\n        prime = True\n\n    return prime\n```\n\npow_mod function calculates a^b mod n with repeated multiplication, applying mod n each time, like this:\n```\ndef pow_mod(a, b, n):\n        result = 1\n        for i in range(b):\n            result = result * a % n\n        return result\n```\n\nIt works for relatively small primes. However, if I run it for a large prime such as 67280421310721, it doesn't produce a result in a desirable amount of time. Is it due to the large numbers? How do I fix this?\n    ", "Answer": "\r\nIt's because your ```\npow_mod```\n is terribly slow. Use a fast algorithm or just use Python's built-in ```\npow```\n function.\nBtw, if I understand your rather convoluted code correctly, you're simply checking whether all tests were successful. Which can be written more clearly:\n```\ndef fermat(n):\n    upper_bound = 40 if n >= 40 else n - 1\n    return all(pow(a, n - 1, n) == 1\n               for a in range(2, upper_bound + 1))\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "What is a convenient base for a bignum library & primality testing algorithm?\r\n                \r\nI am to program the Solovay-Strassen primality test presented in the original paper on RSA.\n\nAdditionally I will need to write a small bignum library, and so when searching for a convenient representation for bignum I came across this specification:\n\n```\nstruct {\n  int sign;\n  int size;\n  int *tab;\n} bignum;\n```\n\n\nI will also be writing a multiplication routine using the Karatsuba method.\n\nSo, for my question:\n\nWhat base would be convenient to store integer data in the bignum struct?\n\nNote: I am not allowed to use third party or built-in implementations for bignum such as GMP.\n\nThank you.\n    ", "Answer": "\r\nA power of 2.\n\nFor a simple implementation, probably half the size of a word on your machine, so that you can multiply two digits without overflow. So 65536 or 4294967296. Or possibly half the size of the largest integer type, for the same reason but maybe better performance over all.\n\nBut I've never actually implemented such a library: if you're using best known algorithms then you won't be doing school-style long multiplication. Karatsuba multiplication (and whatever other clever tricks you use) might benefit from being done in an integer that's more than twice the size of the digits, I really don't know how the performance works out. If so, then you'd be best off using 256 and 32 bit arithmetic, or 65536 and 64 bit arithmetic.\n\nIn any case if your representation is binary, then you can pick and choose larger power-of-two bases as convenient for each operation. For instance, you could treat the data as base 2^16 for multiplication, but base 2^32 for addition. It's all the same thing provided you're careful about endian-ness. I'd probably start with base 2^16 (since that forces me to get the endian-ness right to begin with, while 2^8 wouldn't), and see how I get on - as each operation is optimised, part of the optimisation is to identify the best base.\n\nUsing a size which isn't a multiple of bytes is a possibility, but then you have to use the same base for everything, because there are unused bits in the storage in specific places according to the base.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why doesn't my Fermat's primality test method work?\r\n                \r\nI'm trying to implement a method which checks any integer and returns true if it's prime using Fermat's primality test. \n\nI divided the problem depending on whether the input is less than 40 or not. If the input is less than 40 then I apply the test for every integer up until n-1. Else, if the integer is greater than 40 then the test is applied for every integer up until 40. However, it fails for some primes. \n\n```\npublic static boolean isPrime (double n){\n    int counter=0;\n    boolean isPrime=false;\n    if(n<40) {\n        for (int a = 2; a < n - 1; a++) {\n            if (Math.pow(a, n - 1) % n == 1) counter++;\n        }\n\n        if (counter == n - 3) isPrime = true;\n    }\n        else {\n\n        for (int a = 2; a <= 40; a++) {\n            if (Math.pow(a, n - 1) % n == 1) counter++;\n\n        }\n        if (counter == 39) isPrime = true;\n    }\n    return isPrime;\n}\n```\n\n\nIs it a logical issue or something else?\n    ", "Answer": "\r\nMath.pow works on doubles and the result is only approximate. Modulo on the other hand works on ints which have a range up to a little over 2 billion, is your pow producing some numbers larger than that by any chance? (17^18 seems to be a sure bet for 19...)\n\nSo how to fix this:\nyou can implement your own pow(a,b,n) (power modulo n) using multiplication and modulo on integers. That should work correctly. Make a function to raise a to power b using a series of multiplications, apply %n to the intermediate result after each step...\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Wilson's Theorem for Primality Testing wrong implementation?\r\n                \r\n```\n/**\n*    Finds whether a given number is prime or not\n*    using Wilson's Theorem\n*/\nboolean isPrime(long n){\n    if( fact(n-1) % n == (n-1) % n  ){ return true }\n    else{ return false }\n}  \n```\n\n\nThis is my implementation of Wilson's Theorem for primality. It works well till ```\nn = 19```\n and fails for ```\nn = 23```\n and afterwards.   \n\nWhat is wrong here?    \n\nI am using this way of writing the formula as a reference:\n\n    ", "Answer": "\r\nLook at the numbers (19 - 1)! (=6402373705728000) and (23 - 1)! (=1124000727777607680000).  Now compare these numbers to MAX_LONG (=9223372036854775807).  @AndreasBrinck's comment was correct.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin Primality test fails for large numbers\r\n                \r\nAfter studying other SO answers related to the Miller-Rabin test for primality, I implemented a version in C#, but it begins to occasionally fail somewhere in the region of three billion, and by the time it gets to four billion, it stops recognizing any primes. I suspect that I am suffering overflow, but cannot figure out where. My goal is to get this to work for any value in the range 0 <= n <= 2^63 - 1.\n\nI created a fiddle: https://dotnetfiddle.net/3F7P97\n\nAmong the ideas I tried were:\n\n\nUsing precalculated bases 2, 325, 9375, 28178, 450775, 9780504, 1795265022 advertised as working well for numbers less than 2^64 from this website: http://miller-rabin.appspot.com/\nThis was recommended by an answerer of this question: Miller Rabin Primality test accuracy\nWriting an overflow resistant power-mod function for computing a^b mod n.\nWriting an overflow resistant multiplication function for computing a*b mod n (using Russian peasant algorithm).\n\n\nHere is the code from the fiddle as of the time I created this question:\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n// AUTHOR: Paul A. Chernoch\n//\n// Purpose: Use Rabin-Miller algorithm to test if numbers are prime.\n// Problem: Somewhere between 2 billion and 4,194,304,903 it stops working and always says the number is not prime.\n// Hypothesis: The code should work for all 64-bit values, but suspiciously breaks near the maximum value for a signed 32-bit integer.\npublic class Program\n{\n    public static void Main()\n    {\n        // These cases always succeed.\n        for (long n = 0; n < 20; n++)\n        {\n            TestRabinMiller(n);\n        }\n\n        TestRabinMiller(2000000011L);\n        TestRabinMiller(2147483647L); // 2^31 - 1 is prime.\n        TestRabinMiller(2147483659L); // 2^31 + 11 is prime.\n\n        // These cases fail! I think it has to do with overflow on a multiplication or something.\n\n        TestRabinMiller(3042000007L); // Sometimes succeeds, sometimes fails\n        TestRabinMiller(3043000003L); // Sometimes succeeds, sometimes fails\n        TestRabinMiller(3045000031L); // Sometimes succeeds, sometimes fails\n        TestRabinMiller(4000000007L); // Always fails\n        TestRabinMiller(4194304903L); // Always fails\n        TestRabinMiller(4294967291L); // Always fails\n        TestRabinMiller(4294967311L); // Always fails\n    }\n\n    public static void TestRabinMiller(long n)\n    {\n        var factors = BuggyCode.RabinMiller.Factor(n);\n        var expectedIsPrime = factors.Count() == 1 && n >= 2;\n        var expectedWords = expectedIsPrime ? \"IS A PRIME.  \" : \"IS NOT PRIME.\";\n        var actualIsPrime = BuggyCode.RabinMiller.IsPrime(n,20);\n        var actualWords = actualIsPrime ? \"IS A PRIME.  \" : \"IS NOT PRIME.\";\n        var results = actualIsPrime == expectedIsPrime ? \"SUCCEEDED.\" : \"FAILED.   \";\n        Console.WriteLine(String.Format(\"Test of RabinMiller {0} It says that {1} {2} In reality, the number {1} {3}\", results, n, actualWords, expectedWords));\n    }\n}\n\nnamespace BuggyCode\n{\n\n    /// <summary>\n    /// Test if a number is prime using the Rabin-Miller primality test.\n    /// </summary>\n    public class RabinMiller\n    {\n        private static HashSet<long> KnownPrimes = new HashSet<long>()\n        {\n            2, 3, 5, 7, 11, 13, 17, 19, 23, 29, \n            31, 37, 41, 43, 47, 53, 59, 61, 67, 71, \n            73, 79, 83, 89, 97, 101, 103, 107, 109, 113, \n            127, 131, 137, 139, 149, 151, 157, 163, 167, 173, \n            179, 181, 191, 193, 197, 199, 211, 223, 227, 229, \n            233, 239, 241, 251, 257, 263, 269, 271, 277, 281, \n            283, 293, 307, 311, 313, 317, 331, 337, 347, 349, \n            353, 359, 367, 373, 379, 383, 389, 397, 401, 409, \n            419, 421, 431, 433, 439, 443, 449, 457, 461, 463, \n            467, 479, 487, 491, 499, 503, 509, 521, 523, 541, \n            547, 557, 563, 569, 571, 577, 587, 593, 599, 601, \n            607, 613, 617, 619, 631, 641, 643, 647, 653, 659, \n            661, 673, 677, 683, 691, 701, 709, 719, 727, 733, \n            739, 743, 751, 757, 761, 769, 773, 787, 797, 809, \n            811, 821, 823, 827, 829, 839, 853, 857, 859, 863, \n            877, 881, 883, 887, 907, 911, 919, 929, 937, 941, \n            947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, \n            1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, \n            1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, \n            1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, \n            1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, \n            1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, \n            1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, \n            1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, \n            1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, \n            1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, \n            1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, \n            1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, \n            1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, \n            1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, \n            1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, \n            2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, \n            2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, \n            2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, \n            2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, \n            2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, \n            2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, \n            2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, \n            2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, \n            2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, \n            2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, \n            2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, \n            2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, \n            3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, \n            3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, \n            3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, \n            3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, \n            3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, \n            3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, \n            3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, \n            3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, \n            3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, \n            3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, \n            3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, \n            3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, \n            4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, \n            4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, \n            4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, \n            4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, \n            4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, \n            4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, \n            4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, \n            4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, \n            4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, \n            4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, \n            4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, \n            4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, \n            5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, \n            5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, \n            5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, \n            5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, \n            5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, \n            5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, \n            5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, \n            5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, \n            5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, \n            5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, \n            5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, \n            5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, \n            6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, \n            6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, \n            6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, \n            6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, \n            6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, \n            6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, \n            6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, \n            6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, \n            6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, \n            6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, \n            6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, \n            7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, \n            7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207,\n            7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, \n            7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, \n            7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, \n            7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, \n            7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, \n            7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, \n            7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, \n            7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919\n        };\n\n        private static long MaxKnownPrime { get; set; }\n\n        static RabinMiller()\n        {\n            MaxKnownPrime = KnownPrimes.Max ();\n        }\n\n        /// <summary>\n        /// For the deterministic Rabin-Miller test, these are the best bases for numbers below 2^64.\n        /// \n        /// See http://miller-rabin.appspot.com/\n        /// </summary>\n        private static long[] BestRabinMillerBases = new long[] { 2, 325, 9375, 28178, 450775, 9780504, 1795265022 };\n\n        /// <summary>\n        /// The smallest prime factor for small numbers.\n        /// </summary>\n        private static long[] FactorsForSmallNumbers = new long[] { 0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2, 11, 2, 13, 2, 3, 2, 17, 2, 19, 2 };\n\n\n        /// <summary>\n        /// Rabin-Miller primality test.\n        /// \n        /// The error rate of false results is (1/4)^k.\n        /// </summary>\n        /// <param name=\"n\">Number to test for primality.</param>\n        /// <param name=\"k\">Number of different bases to test. \n        /// The higher the number, the more accurate the test and the longer the running time.</param>\n        /// <returns><c>true</c> if n is prime; otherwise, <c>false</c>.\n        /// Note: Zero and one are not considered prime.\n        /// </returns>\n        public static bool IsPrime(long n, int k)\n        {\n            if(n < 2)\n            {\n                return false; // Zero and one are not prime.\n            }\n\n            // Speedup for low values that also improves accuracy.\n            if (n <= MaxKnownPrime)\n                return KnownPrimes.Contains (n);\n\n            foreach(var knownPrime in KnownPrimes)\n            {\n                if (n % knownPrime == 0) return false;  \n            }\n\n            var s = n - 1L;\n            while((s & 1L) == 0L)\n            {\n                s >>= 1;\n            }\n            Random r = new Random();\n            for (int i = 0; i < k; i++)\n            {\n                long a;\n                if (i < BestRabinMillerBases.Length)\n                    a = BestRabinMillerBases [i];\n                else // Random choice of base.\n                    a = (long)(r.NextDouble() * (n - 1L)) + 1L;\n                var temp = s;\n                var mod = ModuloPower(a, temp, n);\n                while(temp != n - 1L && mod != 1L && mod != n - 1L)\n                {\n                    mod = RussianPeasant(mod, mod, n);\n                    temp = temp << 1;\n                }\n                if(mod != n - 1L && (temp & 1L) == 0L)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static bool IsPrime(long n) \n        {\n            var k = 1;\n            var temp = n;\n            while (temp > 0L) \n            {\n                temp /= 10L;\n                k++;\n            }\n            k = Math.Max (5, k);\n            return IsPrime (n, k);\n        }\n\n        /// <summary>\n        /// Return a^b mod n but guard against overflow.\n        /// \n        /// Use repeated squarings to reduce the number of operations.\n        /// Special case: Assume 0 ^ 0 = 1 to be consistenct with Math.Pow.\n        /// \n        /// See https://helloacm.com/compute-powermod-abn/\n        /// </summary>\n        /// <param name=\"a\">Base to be exponentiated.</param>\n        /// <param name=\"b\">The exponent.</param>\n        /// <param name=\"n\">Modulus.</param>\n        /// <returns>a^b mod n.</returns>\n        public static long ModuloPower(long a, long b, long n)\n        {\n            // return (a^b)%n -> Simple calculation that would often overflow\n            // Example: For a^19, there are five squarings, two multipications and seven modulos, instead of 18 multiplications and eighteen modulos\n            //     a^19 -> (a^2)^9 * a -> (((a^2)^2)^4 * (a^2)) * a -> ((((a^2)^2)^2)^2 * (a^2)) * a\n            if (b == 0L) return 1L;\n            if (a == 0L) return 0L;\n            if (b == 1L) return a % n;\n            var r = ModuloPower (a, b >> 1, n);\n            r = RussianPeasant(r, r, n);\n            if ((b & 1L) == 1L)\n                r = RussianPeasant(r, a, n);\n            return r;\n        }\n\n        /// <summary>\n        /// Russian peasant multiplication of a*b mod c, which avoids overflow.\n        /// </summary>\n        /// <param name=\"a\">First multiplicand.</param>\n        /// <param name=\"b\">Second multiplicand.</param>\n        /// <param name=\"c\">Modulus.</param>\n        /// <returns>a * b mod c</returns>\n        public static long RussianPeasant(long a, long b, long c)\n        {\n            const long _2_32 = 1L << 32;\n            a = Math.Abs (a);\n            b = Math.Abs (b);\n            if (a < _2_32 && b < _2_32)\n                return (a * b % c); // No possibility of overflow.\n            if (c < _2_32)\n                return (a % c) * (b % c) % c;\n            long ret = 0;\n            while(b != 0) {\n                if((b&1L) != 0L) {\n                    ret += a;\n                    ret %= c;\n                }\n                a *= 2;\n                a %= c;\n                b /= 2;\n            }\n            return ret;\n        }\n\n\n\n        /// <summary>\n        /// Slow, exhaustive but simple method of finding prime factors, useful for testing against the more complex methods.\n        /// \n        /// Its only speedup is a table of known primes.\n        /// </summary>\n        /// <param name=\"n\">The number to be factored.</param>\n        /// <returns>Prime factors of n, sorted frmo low to high.</returns>\n        public static List<long> Factor(long n) \n        {\n            var factors = new List<long> ();\n            var lowFactor = 2;\n            var factorFound = true;\n            while (factorFound) \n            {\n                if (n <= MaxKnownPrime && KnownPrimes.Contains (n))\n                    break;\n\n                factorFound = false;\n                var maxFactor = (long) Math.Sqrt (n);\n                for (var fac = lowFactor; fac <= maxFactor; fac++) \n                {\n                    if (n % fac == 0) \n                    {\n                        factors.Add (fac);\n                        n /= fac;\n                        lowFactor = fac;\n                        factorFound = true;\n                        break;\n                    }\n                }\n            }\n            factors.Add (n);\n            return factors;\n        }\n    }\n\n}\n```\n\n    ", "Answer": "\r\nFinally found the problem: RussianPeasant. I did not test every edge case. My overflow limit should have been 2^31, not 2^32, to account for the sign bit. Here is the corrected method:\n\n```\n    public static long RussianPeasant(long a, long b, long c)\n    {\n        const long overflow_limit = 1L << 31;\n        a = Math.Abs (a);\n        b = Math.Abs (b);\n        if (a < overflow_limit && b < overflow_limit)\n            return (a * b % c); // No possibility of overflow.\n        if (c < overflow_limit)\n            return (a % c) * (b % c) % c;\n        long ret = 0;\n        while(b != 0) {\n            if((b&1L) != 0L) {\n                ret += a;\n                ret %= c;\n            }\n            a *= 2;\n            a %= c;\n            b /= 2;\n        }\n        return ret;\n    }\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test Python C extension is slower than pure Python\r\n                \r\nI've implemented a 6k+-1 primality test function both in a C extension and pure Python code but seems pure Python code is much faster! is there something wrong with my C code or something else?\nI also compiled a similar test in pure C with the ```\nis_prime```\n function, and its execution time was the same as the C extension (almost 2sec)\n```\nprimemodule.c```\n\n```\n#define PY_SSIZE_T_CLEAN\n#include \"Python.h\"\n\nint is_prime(int n)\n{\n    int i;\n\n    if (n <= 3)\n        return (n > 1);\n    if (n % 2 == 0 || n % 3 == 0)\n        return (0);\n    i = 5;\n    while ((i * i) <= n)\n    {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return (0);\n        i += 6;\n    }\n    return (1);\n}\n\nstatic PyObject *prime_isprime(PyObject *self, PyObject *args)\n{\n    int n;\n\n    if (!PyArg_ParseTuple(args, \"i\", &n))\n        return (NULL);\n    if (is_prime(n))\n        Py_RETURN_TRUE;\n    Py_RETURN_FALSE;\n}\n\nstatic PyMethodDef prime_methods[] = {\n    {\"is_prime\", prime_isprime, METH_VARARGS, \"Check if a number is prime\"},\n    {NULL, NULL, 0, NULL}};\n\nstatic struct PyModuleDef prime_module = {\n    PyModuleDef_HEAD_INIT,\n    \"prime\",\n    NULL,\n    -1,\n    prime_methods};\n\nPyMODINIT_FUNC PyInit_prime(void)\n{\n    return (PyModule_Create(&prime_module));\n}\n\n```\n\n```\npy_test.py```\n\n```\nimport time\n\nMAX_INT = 2147483647\n\ndef is_prime(n: int) -> bool:\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nt1 = time.process_time()\n\nfor i in range(MAX_INT - 100, MAX_INT):\n    is_prime(i)\n        \nprint(time.process_time() - t1, \"seconds\")\n```\n\n```\nc_test.py```\n\n```\nimport time\nimport prime\n\nMAX_INT = 2147483647\n\nt1 = time.process_time()\n\nfor i in range(MAX_INT - 100, MAX_INT):\n    prime.is_prime(i)\n        \nprint(time.process_time() - t1, \"seconds\")\n```\n\n```\npython c_test.py```\n\n```\n2.078125 seconds\n```\n\n```\npython py_test.py```\n\n```\n0.03125 seconds\n```\n\n```\ntimecmd.bat a.exe```\n\n```\n2.13 seconds\n```\n\n    ", "Answer": "\r\nI think your C implementation is buggy regarding integer overflows and signedness and ends up in a bigger loop than the Python version.\nChanging the parameter type to ```\nunsigned int```\n (and ```\ni```\n too, since otherwise that's a compiler warning):\n```\nstatic int is_prime(unsigned int n)\n{\n    unsigned int i;\n\n    if (n <= 3)\n        return (n > 1);\n    if (n == 2 || n == 3)\n        return (1);\n    if (n % 2 == 0 || n % 3 == 0)\n        return (0);\n    i = 5;\n    while ((i * i) <= n)\n    {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return (0);\n        i += 6;\n    }\n    return (1);\n}\n```\n\nmakes it (anecdotally, on my machine, approximately) 37 times faster than the Python implementation.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Testing Primality in C++ [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        C - determine if a number is prime\r\n                            \r\n                                (12 answers)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nCan anyone help me out? I am trying to test primality but I cant seem to get this to work. For whatever reason, whenever I run it, it runs fine as long as I start with a number that is not prime. However, after running something that is not prime, the output is \"0 1\" instead of just 0. It also seems that if I start with a number that is not prime, everything is \"0 1\" instead of the correct output.\n\n```\n#include <iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\n#include <cmath>\n\nint main()\n{\n    int num;\n    int x = 2;\n    //cin >> num;\n    while(cin >> num)         //(x<=num-1) \n    { \n\n        for(x<=num-1; x++;)\n        {\n            if(num%x==0)\n            { \n                cout << \"0\" << endl ; //1 is prime, 0 is not prime\n                break; \n            }\n\n            if(x==num)\n            {\n                cout << \"1\" << endl ;\n                break; \n            }\n        }\n\n        if(x==num)\n        {\n            cout << \"1\" << endl ;\n        }\n\n    }\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nwell you have the cout << \"1\" twice, you probably didn't mean that\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Python: attempting a recursive primality test with a try-except-else statement\r\n                \r\nI've been learning about recursion and error handling. I'm having a hard time understanding why my primality test isn't working:\n\n```\ndef is_prime4(n):\n    \"\"\"Recursive primality test\"\"\"\n    try:\n        div\n    except NameError:\n        div = n - 1\n    else:\n        div = div - 1\n    while div >= 2:\n        if n % div == 0:\n            print 'No, {number} is not prime because it is divisible by {div}.'.format(number = n, div = div)\n            return False\n        else:\n            return is_prime4(n)\n    else:\n        print 'Yes, {number} is prime indeed.'.format(number = n)\n        return 'True'\n\nis_prime4(2)\nis_prime4(3)\nis_prime4(4)\n```\n\n\nI believe that the problem is in the try-except-else statement, but I have a difficult time understanding why.\n\nThank you for your help.\n    ", "Answer": "\r\nThe recursion depth problem is because div is new with each local context.  It is not a global variable.  Every time you enter the routine, you get a new context, including a new set of local variables.  Thus, if you have n = 7, every call sets div = 6.  You never change that, so you go into infinite recursion.\n\nYou need to adopt a cleaner solution, such as those suggested by the other posters.\n\n\n\nHere is your code, using a global div.  Note that you have to reset it after every completion ... somehow ... and it's ugly ...\n\n```\ndiv = -1\n\ndef is_prime4(n):\n    \"\"\"Recursive primality test\"\"\"\n    global div\n    if div < 0:\n        div = n - 1\n    else:\n        div = div - 1\n\n    while div >= 2:\n        if n % div == 0:\n            print 'No, {number} is not prime because it is divisible by {div}.'.format(number = n, div = div)\n            div = -1\n            return False\n        else:\n            return is_prime4(n)\n    else:\n        print 'Yes, {number} is prime indeed.'.format(number = n)\n        div = -1\n        return True\n\n    for i in range(20):\n        is_prime4(i)\n```\n\n\nOutput:\n\n```\nYes, 0 is prime indeed.\nYes, 1 is prime indeed.\nYes, 2 is prime indeed.\nYes, 3 is prime indeed.\nNo, 4 is not prime because it is divisible by 2.\nYes, 5 is prime indeed.\nNo, 6 is not prime because it is divisible by 3.\nYes, 7 is prime indeed.\nNo, 8 is not prime because it is divisible by 4.\nNo, 9 is not prime because it is divisible by 3.\nNo, 10 is not prime because it is divisible by 5.\nYes, 11 is prime indeed.\nNo, 12 is not prime because it is divisible by 6.\nYes, 13 is prime indeed.\nNo, 14 is not prime because it is divisible by 7.\nNo, 15 is not prime because it is divisible by 5.\nNo, 16 is not prime because it is divisible by 8.\nYes, 17 is prime indeed.\nNo, 18 is not prime because it is divisible by 9.\nYes, 19 is prime indeed.\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How would I go about testing the primality of a large integer in R?\r\n                \r\nI have a 2500 digit integer which I need to determine the primality of. There are many methods in R for testing primality of 'small' numbers but the language doesn't seem to be suited for storing massive numbers. There are packages designed to store such numbers but they all seem to revolve around saving it in a string which makes me uncertain of how I could then perform a primality test on it. Any clarification on what the capabilities of the language are with regards to this topic would be appreciated.\n    ", "Answer": "\r\nLook up the Lucas-Lehmer Test for checking primality of huge numbers... it is already in the numbers library as the mersenne function and you can view it with the getAnywhere function.\n\n```\nlibrary(numbers); getAnywhere(mersenne)```\n\n\nI recommend Haskell or Cython to squeeze some extra speed out of this if you actually plan to run it on a number that large - you will want it running in C/C++ and NOT in R, hopefully this lets you read some interesting R code though.\n\nhttps://cran.r-project.org/web/packages/numbers/numbers.pdf\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "primality test function is_prime (n, k) based on Fermat Little Theorem,\r\n                \r\nI solved this question: Implement a primality test function is_prime (n, k) based on Fermat Little Theorem, where n is the number to be tested, and k is the number of bases to be used. The function should return False if n is not prime, and True if n is pseudoprime to these k bases. Notice that k is a small constant, and therefore, some composites will be counted as primes.\n```\ndef is_prime (n, k) :\n    bases = []\n    for i in range(2,k+1):\n        bases.append(i)\n    for base in bases:\n       a =  math.pow(base,n-1) % n\n       if (a==1):\n           return True\n           \n       else:\n           False\n```\n\ntesting for primes under 20000, for k = 10\n```\nbases = int(input(\"Enter the number of bases: \"))\n\nfor m in range(1,2000):\n\n    print(is_prime(m,bases))\n    print(m)\n```\n\nthis the error:\n```\n File \"/Users/IA/Desktop/ICS254_Project/project.py\", line 48, in <module>\n    print(is_prime(m,bases))\n  File \"/Users/IA/Desktop/ICS254_Project/project.py\", line 30, in is_prime\n    a =  math.pow(base,n-1) % n\nOverflowError: math range error\n```\n\nWhat is wrong and how can I correct it?\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Faster bitwise modulus for Lucas-Lehmer primality test\r\n                \r\nThe Lucas-Lehmer primality test tests prime numbers to determine whether they are also Mersenne primes. One of the bottlenecks is the modulus operation in the calculation of ```\n(s**2 − 2) % (2**p - 1)```\n.\n\nUsing bitwise operations can speed things up considerably (see the L-L link), the best I have so far being:\n\n```\ndef mod(n,p):\n    \"\"\" Returns the value of (s**2 - 2) % (2**p -1)\"\"\"\n    Mp = (1<<p) - 1\n    while n.bit_length() > p: # For Python < 2.7 use len(bin(n)) - 2 > p\n        n = (n & Mp) + (n >> p)\n    if n == Mp:\n        return 0\n    else:\n        return n\n```\n\n\nA simple test case is where ```\np```\n has 5-9 digits and ```\ns```\n has 10,000+ digits (or more; not important what they are). Solutions can be tested by ```\nmod((s**2 - 2), p) == (s**2 - 2) % (2**p -1)```\n. Keep in mind that p - 2 iterations of this modulus operation are required in the L-L test, each with exponentially increasing ```\ns```\n, hence the need for optimization.\n\nIs there a way to speed this up further, using pure Python (Python 3 included)? Is there a better way?\n    ", "Answer": "\r\nThe best improvement I could find was removing ```\nMp = (1<<p) - 1```\n from the modulus function altogether, and pre-calculating it in the L-L function before starting the iterations of the L-L test. Using ```\nwhile n > Mp:```\n instead of ```\nwhile n.bit_length() > p:```\n also saved some time.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to implement the primality test algorithm from Wikipedia?\r\n                \r\nOn Wikipedia the algorithm below is supposed to test if an odd integer, n, is a composite by the probabilistic Rabin-Miller primality test.\n\n```\nInput: n > 3, an odd integer to be tested for primality;\nInput: k, a parameter that determines the accuracy of the test\nOutput: _composite_ if n is composite, otherwise _probably prime_\nwrite n − 1 as 2^r·d with d odd by factoring powers of 2 from n − 1\nWitnessLoop: repeat k times:\n   pick a random integer a in the range [2, n − 2]\n   x ← a^d mod n\n   if x = 1 or x = n − 1 then do next WitnessLoop\n      repeat r − 1 times:\n      x ← x^2 mod n\n      if x = 1 then return _composite_\n      if x = n − 1 then do next WitnessLoop\n   return _composite_\nreturn _probably prime_\n```\n\n\nMy implementation of the algorithm in BigIntANSForth on GitHub below might be erroneous. The prefix 'b' stands for 'big'; there is a parameterstack for big numbers and an extra big number stack 'bx'. Also 'ys' is an extra stack for one cell integers.\n\n```\nbarmod ( w -- v ) is a faster variant of\nbmod ( w u -- v ) where u is stored in a big variable 'den' used in the word 'barmod'\n```\n\n\nThe bar prefix stands for 'Barrett reduction'.\n\n```\n5 value accuracy\n: bmiller~ \\ u -- | k -- f   false=composite, u odd >3, k is accuracy.\n  bdup >bx rs true >ys accuracy 0          \\ d   | r k 0\n  do bx xsi bover bx b**mod                \\ d x | r\n     bdup 1 digit= b1+ bx b= or 0=         \\ d   | r f\n     if dup 1- 0                           \\ d   | r r-1 0\n        do bx bdup b* barmod               \\ d x | r\n           bdup 1 digit= b1+ bx b= 0= or   \\ d   | r f\n           if false ys! leave\n           then\n        loop ys@ 0= if leave then\n     then\n  loop drop bdrop xdrop ys> ;\n\\ b**mod ( b e m -- x ) calculates x=b^e(mod m)\n\\ The word rs (u -- d | -- r ) above calculates d (big) and r (cell) as described in the algorithm.\n\\ 'bx xsi' gives the random (big) integer a in the algorithm\n\\ '1 digit=' compare top of big stack with the single cell number '1'\n\\ 'xdrop' drop the bx stack and 'bx' correspond to 'r@' etc\n```\n\n\n83568136581357135713573105731571385713857130571301111111111111111111111112429\nis a composite due to the implementation for any accuracy, but a prime due to Wolfram Alpha.\n\nI'm not sure that I have interpreted the algorithm correctly. Any suggestion?\n    ", "Answer": "\r\nHere's how you can implement Miller-Rabin method.\n\n```\n// This procedure is called for all k trials. (explained later)\n// It returns false if n is composite and\n// returns true if n is probably prime\n// d is an odd number such that d * 2ʳ = n - 1 for some r >= 1\n\nProcedure millerTest(int n, int d):\n1. Pick a random number 'a' in range [2, n-2]\n2. Compute: x = (aᵈ) mod n\n3. If x is 1 or n-1, Return true\n4. while d doesn't equal to n - 1\n    a) x = (x*x) mod n\n    b) if x is equal to 1 Return false.\n    c) if x is equal to n-1 Return true\n\n\n// The procedure returns false if n is composite and \n// returns true if n is probably prime.\n// k is an input parameter that determines the accuracy level.\n// Higher value of k indicates more accuracy\n\nProcedure isPrime(int n, int k):\n1. Handle base cases for n < 3\n2. If n is even Return false\n3. Find an odd number d such that n-1 can be written as d * 2ʳ\n   Since n can't be even here, so n-1 must be even\n   and r must be greater than 0.\n4. Do the following for k times\n   if millerTest(n, d) returns false\n        Return false.\n5. Return true.\n```\n\n\nHope this helps. Good luck!\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Codechef \"Primality Test\" Wrong answer\r\n                \r\nProblem:\nAlice and Bob are meeting after a long time. As usual they love to play some math games. This times Alice takes the call and decides the game. The game is very simple, Alice says out an integer and Bob has to say whether the number is prime or not. Bob as usual knows the logic but since Alice doesn't give Bob much time to think, so Bob decides to write a computer program.\nHelp Bob accomplish this task by writing a computer program which will calculate whether the number is prime or not .\nInput\n\nThe first line of the input contains T testcases, T lines follow\nEach of T line contains an integer N which has to be tested for primality\nOutput\n\nFor each test case output in a separate line, \"yes\" if the number is prime else \"no\"\n\nMy solution:\n\n```\n`import java.io.*;\nimport java.math.*;\nimport java.util.*;\nclass ex6\n{\npublic static void main(String args[])throws IOException\n{\n    try\n    {\n        BufferedReader input=new BufferedReader(new InputStreamReader(System.in));          \n    int t=0;\n\n       t=Integer.parseInt(input.readLine());\n\n    int n=0;\n    int c=0;\n\n    while(c!=(t))\n    {\n        int j=0;\n        n=Integer.parseInt(input.readLine());\n        if(n==1)\n        System.out.println(\"No\");\n        else{\n            for(int x=2;x<n/2;x++)\n            {\n             if(n%x==0){j++;break;}\n            }\n            if(j==0)\n            System.out.println(\"Yes\");\n            else \n            System.out.println(\"No\");\n        }\n\n            c++;\n\n\n        } }\n catch(Exception e)\n {return;}}}`\n```\n\n    ", "Answer": "\r\nYour whole approach is wrong, read about https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes. Besides, all these exercises assume that you use a known algorithm.\n\nThe idea is that you have an array with boolean values, where \"true\" means \"prime\" and \"false\" means \"non-prime\", what you do is start with an array of all true boolean values (besides 1 and 0), then starting with 2 eliminate the multiples of 2 (marking them false), then move to the next prime number, which is 3, mark false multiples of that, etc, until you're done.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Parallelization of a primality test (python)\r\n                \r\nI coded a primality test and it works. It's called the bosma-test and it checks whether numbers of the form h * 2^k+1 are prime, where h is odd and h<2^k.\nHere is a short outline of the functionality:\nLet n = h * 2^k + 1.\nThe test takes a list of finite prime numbers.\nIt then chooses a prime number D and checks whether the jacobi-symbol J(n, D) is 0 or -1. If it is 0, the number n is not prime. So it returns False.\nIf the symbol is -1, it calculates the congruence D^( (n-1) / 2) mod n. If it's congruent to -1, the number is prime and it returns True. Otherwise it is not and it returns False.\nIn case that the symbol is +1, we just use another prime (the primes are checked in ascending order).\nIf and only if every symbol is +1, the test returns \"-1\" which lets me know, that the list is too short. But this not important here).\nI coded it and it works, here is my code:\n```\nfrom pathlib import Path\nimport pickle\nfrom sympy.ntheory import jacobi_symbol\n\nPRIMES_FILE = Path(\"/primes_up_to_10_7\")\n\nwith open(PRIMES_FILE, 'rb') as file:\n    primes = pickle.load(file)\nprimes.remove(2)\n\ndef bosma(h, k, primes):\n    for D in primes:\n        jacobi = jacobi_symbol( h*2**k + 1, D)\n        if jacobi == 0:\n            return False\n        if jacobi == -1:\n            exp = h*2**(k-1)\n            n = 2*exp+1\n            return True if pow(D, exp, n) == n-1 else False\n    return -1\n\ncoeff_lower = 1\ncoeff_upper = 100\nexponent = 20000\n\ndef main():\n    print(\"Script started\")\n    for coefficient in range(coeff_lower, coeff_upper+1):\n        print(f\"{coefficient} * 2^{exponent}+1: \", bosma(coefficient, exponent, primes))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNow comes my question.\nI want to run this code on our cluster in university. Therefore, I want to parallelize it. That means, I choose an exponent and a lower and an upper bound for the coefficients.\nLet's say, the exponent is 50.000 and the bounds are 10.000 and 20.000.\nThen I want that one kernel (is that the right word) calculates 10.001 * 2^50.000 + 1 with the bosma test, the next one 10.003 * 2^50.000 + 1 and so on.\nSince the calculations take different time, a kernel shall always take the next \"free\" coefficient and do the bosmatest with this coefficient and the fixed exponent 50.000.\nBut I don't know how I could do that.\nSo I know that I can get the amouont of kernels via multiprocessing.cpu_count()\nBut how do I go on?\nP.S: I can upload and attach the primes-file if you like.\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Please explain how Trial Division works for Primality Test\r\n                \r\nI came across this algorithm for testing primality through trial division I fully understand this algorithm\n\n```\nstatic boolean isPrime(int N) {\n    if (N < 2)\n        return false;\n    for (int i = 2; i <= Math.sqrt(N); i++)\n        if (N % i == 0)\n            return false;\n    return true;\n}\n```\n\n\nIt works just fine. But then I came across this other one which works just as good but I do not fully understand the logic behind it.\n\n```\nstatic boolean isPrime(int N) {\n    if (N < 2)\n        return false;\n    for (int i = 2; i * i<N; i++)\n        if (N % i == 0)\n            return false;\n    return true;\n}\n```\n\n\nIt seems like ```\ni *i < N```\n behaves like ```\ni <= Math.sqrt(N)```\n. If so, why?\n    ", "Answer": "\r\nAs an aside, you can speed up your code with a few tweaks, if you think it is too slow:\n\n```\nstatic boolean isPrime(int N) {\n    if (N <= 1)\n        return false;\n    if (N % 2 == 0)\n        return N == 2;\n    for (int i = 3; i <= Math.sqrt(N); i += 2)\n        if (N % i == 0)\n            return false;\n    return true;\n}\n```\n\n\nThis version does special tests for negatives and divisibility by 2 and then only divides by odd numbers from then on: 3, 5, 7, ... (note the  \"+= 2\").\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Can someone explain this Miller-Rabin Primality test pseudo-code in simple terms?\r\n                \r\nHere it is...\n\n```\nInput: n > 3, an odd integer to be tested for primality;\nInput: k, a parameter that determines the accuracy of the test\nOutput: composite if n is composite, otherwise probably prime\nWrite n − 1 as (2^s)·d with d odd by factoring powers of 2 from n − 1\nWitnessLoop: repeat k times:\n   pick a random integer a in the range [2, n − 2]\n   x ← a^d mod n\n   if x = 1 or x = n − 1 then do next WitnessLoop\n   repeat s − 1 times:\n      x ← x^2 mod n\n      if x = 1 then return composite\n      if x = n − 1 then do next WitnessLoop\n   return composite\nreturn probably prime\n```\n\n\nI got this from the Wikipedia article on the Miller-Rabin primality test. But I've not been able to comprehend it...... I'm not looking to understand the math behind it but only to implement it in a program. This algorithm seems to me, to be kind of confusing. A better, more simpler pseudo-code or implementation of it in vb.net, would be helpful.\n\nEDIT code written so far:\n\n```\nFunction Miller_Rabin(ByVal n As Integer) As Boolean\n    If n <= 3 Then : Return True\n    ElseIf n Mod 2 = 0 Then : Return False\n    Else\n        Dim k, s, a, d, x As Integer\n        k = 3\n        d = n - 1\n\n        While d Mod 2 = 0\n            d = d / 2\n            s += 1\n        End While\n\n        For c = 1 To k\n            a = Random(2, n - 1)\n            x = a ^ d Mod n\n            If x = 1 Or x = n - 1 Then GoTo skip\n            For r = 1 To s - 1\n                x = x ^ 2 Mod n\n                If x = 1 Then\n                    Return False\n                    Exit Function\n                Else\n                    If x = n - 1 Then\n                        GoTo skip\n                    Else\n                        Return False\n                        Exit Function\n                    End If\n                End If\n            Next\nskip:   Next\n        Return True\n    End If\nEnd Function\n\nFunction Random(ByVal x As Integer, ByVal n As Integer) As Integer\n    Dim a As Integer = Now.Millisecond * Now.Second\nskip:\n    a = (a ^ 2 + 1) Mod (n + 1)\n    If a < x Then\n        GoTo skip\n    Else\n        Return a\n    End If\nEnd Function\n```\n\n    ", "Answer": "\r\nHere is simple pseudocode, as requested:\n\n```\nfunction isStrongPseudoprime(n, a)\n    d := n - 1; s := 0\n    while d % 2 == 0\n        d := d / 2\n        s := s + 1\n    t := powerMod(a, d, n)\n    if t == 1 return ProbablyPrime\n    while s > 0\n        if t == n - 1\n            return ProbablyPrime\n        t := (t * t) % n\n        s := s - 1\n    return Composite\n\nfunction isPrime(n)\n    for i from 1 to k\n        a := randInt(2, n-1)\n        if isStrongPseudoprime(n, a) == Composite\n            return Composite\n    return ProbablyPrime\n\nfunction powerMod(b, e, m)\n    x := 1\n    while e > 0\n        if e % 2 == 1\n            x := (b * x) % m\n        b := (b * b) % m\n        e := e // 2 # integer division\n    return x\n```\n\n\nThe ```\nisStrongPseudoprime```\n function tests if a is a witness to the compositeness of n; note that if ```\nisStrongPseudoprime```\n returns ```\nComposite```\n the number is definitely composite, but the opposite of that is ```\nProbablyPrime```\n because there is a chance that the number is still composite. The ```\nisPrime```\n function tests k witnesses; by setting the value of k you can determine the likelihood of error as 1 chance in 4^k. Most people use a value of k somewhere between 10 and 25. The ```\npowerMod```\n function performs exponentiation by squaring, and is provided on the chance that your language doesn't provide it for you.\n\nIf you want to know more about the mathematics behind this test, I modestly recommend this essay at my blog, which also includes implementations in five languages, though none of them is VBA.\n\nEDIT: Although he didn't say so, what the original poster actually wants to do is to find the sum of the primes less than two million and thus solve Project Euler 10. Looping through the numbers from 2 to n is a very inefficient way to sum the primes less than n; instead, the recommended method is to use a sieve. Pseudocode again:\n\n```\nfunction sumPrimes(n)\n    sum := 0\n    sieve := makeArray(2..n, True)\n    for p from 2 to n step 1\n        if sieve[p]\n            sum := sum + p\n            for i from p * p to n step p\n                sieve[i] := False\n    return sum\n```\n\n\nThe algorithm used here is the Sieve of Eratosthenes, invented over two thousand years ago by a Greek mathematician. Again, an explanation and code is in the essay at my blog.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Improving trial division primality test using 6k+/-1 rule\r\n                \r\nI was going through the basics of trial division primality test, and hence, implementing it in code. The performance of the algorithm can be increased using many tricks like:\n\n1) running the trial division only up to square-root(n)\n\n2) trading memory for time by creating a sieve up to square-root(n), and then running the trial division only on the primes in the created sieve\n\nBut nowhere did I find the idea of returning the result as composite if the value of ```\nn%6```\n (n mod 6) if found out to be ```\n1 or 5```\n (using the 6k +/- 1 rule). Will using this rule in our prime number determination test not improve its performance? If yes, why hasn't it been mentioned anywhere? If no, why is it so?\n\nThanks.\n    ", "Answer": "\r\nIt seems you fall into the category above the beginner level (people who would never come up with the idea) and below people looking for extreme performance. So the idea is a bit difficult to explain to the beginners, and seems trivial to the very advanced ones. \n\nIt reduces the running time by one third, or lets you test 50% more numbers in the same time. You can save a bit more by doing fewer tests that the divisor isn't too large: Let's say you test a number around a billion. You have a loop, with a divisor d = 6k-1, and you want to test d and d+2 = 6k+1. So you only test that d^2 ≤ p, you don't test that (d+2)^2 ≤ p. Worst case, you test one divisor more than you needed. Best case, you save a few thousand tests that (d+2)^2 ≤ p. \n\nYou can save slightly more by observing that the only possible primes ≥ 30 are 30k + 1, 7, 11, 13, 17, 19, 23, 29, avoiding 30k + 5 and 30k + 25. \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin Primality Test Often Returns Composite for Prime Numbers\r\n                \r\nI have been trying to implement a Miller-Rabin primality test from scratch (only primitives and Strings) that works for 64 bit integers (longs). I've tried the Java and pseudocode from Wikipedia, as well as various other websites. So far, only very small numbers have worked correctly. Most numbers are incorrectly marked composite, such as 53 or 101. I have tried tracking various sections of the code to see where the problem is. It seems to be in the innermost loop. I don't know what the specific issue is. Any help is appreciated. Thanks!\n\nHere is my code:\n\n```\npublic class PrimeTest\n{\npublic static void main(String[] args)\n{\n    PrimeTest app = new PrimeTest();\n}\n\nprivate PrimeTest()\n{\n    long n = 53; // Change to any number. 53 is prime, but is reported as composite\n    if (checkPrime(n, 10))\n    {\n        System.out.println(n + \" is prime.\");\n    }\n    else\n    {\n        System.out.println(n + \" is not prime.\");\n    }\n}\n\n// Check if n is prime with 4^(-k) change of error\nprivate boolean checkPrime(long n, int k)\n{\n    // Factor n-1 as d*2^s\n    long d = n - 1;\n    int s = 0;\n    while (d % 2 == 0)\n    {\n        d /= 2;\n        s++;\n    }\n\n    // Repeat k times for 4^-k accuracy\n    for (int i = 0; i < k; i++)\n    {\n        long a = (long) ((Math.random() * (n - 3)) + 2);\n        long x = modPow(a, d, n);\n        if (x == 1 || x == (n - 1))\n        {\n            continue;\n        }\n        int r;\n        for (r = 0; r < s; r++)\n        {\n            x = modPow(x, 2, n);\n            if (x == 1)\n            {\n                return false;\n            }\n            if (x == (n - 1))\n            {\n                break;\n            }\n        }\n        if (r == s)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Return (base^exp) % mod\nprivate long modPow(long base, long exp, long mod)\n{\n    if (mod == 1)\n    {\n        return 0;\n    }\n    long result = 1;\n    base = base % mod;\n    while (exp > 0)\n    {\n        if ((exp & 1) == 0)\n        {\n            result = (result * base) % mod;\n        }\n        exp = exp >> 1;\n        base = (base * base) % mod;\n        if (base == 1)\n        {\n            break;\n        }\n    }\n    return result;\n}\n}\n```\n\n    ", "Answer": "\r\nThis line in modPow:\n\n```\nif ((exp & 1) == 0)\n```\n\n\nis wrong and should instead be\n\n```\nif ((exp & 1) == 1)\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Lehmann primality test [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm doing Lehman's test and below function is not giving 100% accurate output. It says all p as prime number. I have been searching and the algorithm seems correct. What could be the issue, please?\n\n```\nprivate static boolean lehmanTest(int p, int tries) {\n\n        boolean isPrime = true;\n\n        int a = randomGenerator();\n\n        int e = (p - 1 )/2;\n        int result = (a^e) % p;\n\n        System.out.println (\"Result: \" + result);\n\n        while (tries!=0)\n        {\n            if(result % p != 1 && result % p != p - 1)\n            {\n                a = randomGenerator();\n                tries--;\n            }\n                else\n                {\n                    isPrime = false;\n                }\n        }\n        return isPrime;\n```\n\n\n        }\n\nAmended code\n\n```\nprivate static boolean lehmanTest(int p, int tries) {\n\n        //boolean isPrime = true;\n\n        //generate random number a\n        int a = randomGenerator(p);\n\n\n        int e = (p - 1 )/2;\n        int result = ((int)Math.pow(a,e)) % p;\n\n\n        while (tries!=0)\n        {\n            result = ((int)Math.pow(a,e)) % p;\n\n\n            if(result % p != p - 1)\n            //if(result % p != 1 && result % p != p - 1)\n            {\n                a = randomGenerator(p);             \n                tries--;\n            }\n                else\n                {\n                    return false;\n                }\n        }\n        return true;\n\n    }\nprivate static int randomGenerator (int p) {        \n        //generate random numbers a, n times        \n        Random rand = new Random();\n\n        int randomInt = rand.nextInt(p);\n        return randomInt;       \n    }\n```\n\n    ", "Answer": "\r\nYour first problem is in this line:\n\n```\n    int result = (a^e) % p;\n```\n\n\na^e is \"a xor e\" not \"a to the eth power\". You need Math.pow(a, e) or something equivalent. You should probably re-read the description of the algorithm.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "RTU tool for long long (64 bits) primality test\r\n                \r\nI've got a simple problem, but somehow fail to solve it properly :\n\nI would like to test the primality of long long integers (64bits).\nThe primality requirement comes from the mixing of several hash values; if not respected, there is some kind of \"echo\" in the resulting output, which degrades the distribution property of the hash formula.\n\nI've got a few interesting candidates, but cannot test at this stage their primality.\n\nI've found a website which proposes just that :\ninput a number, and it provides the next value which is prime.\nThe problem is, this website only works for values within the 32 bits range limit.\n\nI've been roaming SO for the same question, and it was asked several times already. However, all answers i've been consulting up to now only points towards methods and algorithms (such as miller rabin, or AKS), carrying a hidden \"do-it-yourself\" tag.\n\nAnd that's not what i'm looking for. I do not need to test primality regularly every day from now on, or for a huge numbers of candidates. I just have this need now, and for a very limited number of candidates.\nTherefore a Ready-to-use tool which answer just this question (preferably, an online one), would better fit the bill.\n\nBut does that exist ?\n    ", "Answer": "\r\nYou can plug in your number at http://www.alpertron.com.ar/ECM.HTM, which will tell you if it is prime or give you its factors if it is not. Or you could use the Factors[n] function at http://www.wolframalpha.com, which does the same thing. Either can quickly handle 64-bit integers.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin Primality Test in python: Why I keep getting decimal.Overflow: [<class 'decimal.Overflow'>]?\r\n                \r\nI was trying to do the Miller-Rabin Primality Test in python. I've written the code like below based on pseudocode on Wikipedia:\n\n```\nfrom math import *\nfrom numpy import *\n\ndef Miller_Rabin(n, k):    #Miller-Rabin Primality Test\n    if n == 2 or n == 3:\n        return True\n\n    if n % 2 == 0:\n        return False\n\n    s = n - 1\n    d = 0\n    r = 0\n\n    while True:\n        if s % 2 == 0:\n            r += 1\n            s /= 2\n\n        else:\n            d = s\n            break\n\n    for i in range(k):\n\n        a = random.randint(2, n-1)\n        t = a**d\n        x = t % n\n\n        if x == 1 or x == n-1:\n            continue\n\n        for j in range(r-1):\n            x = x**2 % n\n\n            if x == n-1:\n                continue\n\n        return False\n    return True\n```\n\n\nBut when I run the code and enter a prime number like 5336101, I got the following error:\n\n```\nFile \"C:\\Users\\kienp\\Documents\\Math Projects\\Primality Test\\primality_test.py\", line 46, in Miller_Rabin\n    t = a**d\nOverflowError: (34, 'Result too large')\n```\n\n\nSo I decide to use the Decimal module, modified a few lines of code:\n\n\nAdding part:\n\n\n```\nfrom decimal import Decimal  #Adding\nfrom decimal import Context  #Adding\n```\n\n\n\nModifying part:\n\n\n```\n    for i in range(k):\n\n        a = random.randint(2, n-1)\n        t = Decimal(Decimal(a)**Decimal(d))\n        x = Decimal(t) % n\n```\n\n\nBut then I got another error:\n\n```\nFile \"C:\\Users\\kienp\\Documents\\Math Projects\\Primality Test\\primality_test.py\", line 46, in Miller_Rabin\n    t = Decimal(Decimal(a)**Decimal(d))\ndecimal.Overflow: [<class 'decimal.Overflow'>]\n```\n\n\nHow can I fix this? \n    ", "Answer": "\r\nApparently you are using Python 3 where ```\nx / y```\n always returns a ```\nfloat```\n even if the operand types are both ```\nint```\n. ```\nfloat```\n is limited in what it can represent to an overflow error can occur. In order to perform integer division you can use ```\nx // y```\n. Specifically in your code the line ```\ns /= 2```\n should be changed to ```\ns //= 2```\n.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How can I test for primality?\r\n                \r\nI am writing a little library with some prime number related methods. As I've done the groundwork (aka working methods) and now I'm looking for some optimization. \nOfcourse the internet is an excellent place to do so. I've, however, stumbled upon a rounding problem and I was wondering how to solve this.\n\nIn the loop I use to test a number for it's primality it's more efficient to search until sqrt(n) instead of n/2 or even n - 1. But due to rounding problems some number get skipped and thus some primes are skipped! For example, the 10000th prime should be: 104729, but the 'optimized' version ends up with: 103811.\n\nSome code (it's open for more optimization, I know, but I can handle only one thing at a time):\n\n```\n/// <summary>\n/// Method for testing the primality of a number e.g.: return IsPrime(29);\n/// History:\n/// 1. Initial version, most basic form of testing: m smaller then n -1\n/// 2. Implemented m smaller then sqrt(n), optimization due to prime factoring\n/// </summary>\n/// <param name=\"test\">Number to be tested on primality</param>\n/// <returns>True if the number is prime, false otherwise</returns>\npublic static bool IsPrime(int test)\n{\n    // 0 and 1 are not prime numbers\n    if (test == 0 || test == 1) return false;\n\n    // 2 and 3 are prime numbers\n    if (test == 2) return true;\n\n    // all even numbers, save 2, are not prime\n    if (test % 2 == 0) return false;\n\n    double squared = Math.Sqrt(test);\n    int flooredAndSquared = Convert.ToInt32(Math.Floor(squared));\n\n    // start with 5, make increments of 2, even numbers do not need to be tested\n    for (int idx = 3; idx < flooredAndSquared; idx++)\n    {\n        if (test % idx == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n\nI know the squared part fails me (or I fail), tried Math.Ceiling as well, with about the same results.\n    ", "Answer": "\r\nI guess this is your problem:\n\n```\nfor (int idx = 3; idx < flooredAndSquared; idx++)\n```\n\n\nThis should be\n\n```\nfor (int idx = 3; idx <= flooredAndSquared; idx++)\n```\n\n\nso you don't get square numbers as primes. Also, you can use \"idx += 2\" instead of \"idx++\" because you only have to test odd numbers (as you wrote in the comment directly above...).\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test for numbers of form 10^n + k\r\n                \r\nI have some numbers of form 10N + K, where N is about 1000, and K is really small (lower than 500). I want to test these numbers for primality. Currently I'm using Fermat's test by base 2, preceded by checking small factors (<10000).\n\nHowever, this is rather slow for my purposes. Is there any algorithm quicker than that? Can this special form be exploited somehow? \n\nAlso, maybe if two numbers differ only in K, is it possible to test these two numbers a bit quicker?\n    ", "Answer": "\r\nIf K has a factor of either 2 or 5 then 10^N + K is composite.  This allows testing a small number quickly.  Large primes are all such that P mod 6 = 1 or 5.  You can use this to eliminate 2/3 of possible K values.  With a little work you can set up a 2-4 wheel to avoid a lot of division:\n\n```\nincrement <- either 2 or 4 as required\nrepeat\n  K <- K + increment\n  increment <- 6 - increment\n  if (K mod 5 = 0) then \n    continue \n  endif\nuntil (isPrime(10^N + K) or (K > 500))\n```\n\n\nTrial factoring up to 10,000 if fine.  Are you building a list of the primes up to 10,000 first?  Use Eratosthenes' Sieve to create the list and just read off numbers.\n\nRunning a Fermat Test base 2 is a good start, it finds a lot of composites reasonably quickly.\n\nAfter that you need to implement the probabilistic Miller-Rabin test, and run it enough times that it is more probable your hardware has failed rather than the number is composite.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Time complexity of this primality testing algorithm?\r\n                \r\nI have the following code which determines whether a number is prime:\n\n```\npublic static boolean isPrime(int n){\n    boolean answer = (n>1)? true: false;\n\n    for(int i = 2; i*i <= n; ++i)\n    {\n        System.out.printf(\"%d\\n\", i);\n        if(n%i == 0)\n        {\n            answer = false;\n            break;\n        }\n    }\n    return answer;      \n}\n```\n\n\nHow can I determine the big-O time complexity of this function? What is the size of the input in this case?\n    ", "Answer": "\r\nThink about the worst-case runtime of this function, which happens if the number is indeed prime.  In that case, the inner loop will execute as many times as possible.  Since each iteration of the loop does a constant amount of work, the total work done will therefore be O(number of loop iterations).\n\nSo how many loop iterations will there be?  Let's look at the loop bounds:\n\n```\nfor(int i = 2; i*i <= n; ++i)\n```\n\n\nNotice that this loop will keep executing as long as i2 ≤ n.  Therefore, the loop will terminate as soon as i ≥ √n + 1.  Consequently, the loop will end up running O(√n) times, so the worst-case time complexity of the function is O(√n).\n\nAs to your second question - what is the size of the input? - typically, when looking at primality testing algorithms (or other algorithms that work on large numbers), the size of the input is defined to be the number of bits required to write out the input. In your case, since you're given a number n, the number of bits required to write out n is Θ(log n). This means that \"polynomial time\" in this case would be something like O(logk n). Your runtime, O(√n), is not considered polynomial time because O(√n) = O((2log n)1/2), which is exponentially larger than the number of bits required to write out the input.\n\nHope this helps!\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fermat Primality Test Haskell\r\n                \r\nI have implemented the following two functions for establishing if n is a fermat prime number (will return n if its true, -1 if not), but it returns always -1, can't figure out why (gc is a funct taht calculates gcd)\n\n```\nfermatPT :: Int -> Int\nfermatPT n = fermatPT' n list\n  where\n    list = [a | a <- [1..n-1]]\n\n-- | heper function\nfermatPT' :: Int -> [Int] -> Int\nfermatPT' n l      | gc (n, head l) == 1 && fermatTest n (head l) = fermatPT' n (tail l)\n                   | null l                                       = n\n                   | otherwise                                    = -1\n                where\n                  fermatTest n a = mod (a^(n-1)) n == 1\n```\n\n    ", "Answer": "\r\nYour function should return a boolean indicating if the given number is a prime. If you do that, you can use the ```\nall```\n function to define this simply as\n\n```\nfermatPT :: Integer -> Bool\nfermatPT n = all (fermatTest n) (filter (\\a -> gcd n a == 1) [1..n-1])\n             where fermatTest n a = mod (a^(n-1)) n == 1\n```\n\n\n```\ngcd```\n is defined in the Prelude.\n\n```\nall```\n avoids the explicit recursion that requires you to apply the test to one element of ```\n[1..n-1]```\n at a time; its definition is effectively\n\n```\nall _ [] = True\nall p (x:xs) = p x && all p xs\n```\n\n\n\n\nNote that ```\nmod (a ^ (n - 1)) n```\n is inefficient, since it may require computing an absurdly large number before ultimately reducing it to the range ```\n[0..n-1]```\n. Instead, take advantage of the fact that ```\nab mod n == (a mod n * b mod n) mod n```\n, and reduce the value after each multiplication. One way to implement this (not the fastest, but it's simple):\n\n```\nmodN :: Integer -> Integer -> Integer -> Integer\nmodN a 0 _ = 1\nmodN a b n = ((a `mod` n) * (modN a (b - 1) n)) `mod` n\n```\n\n\nThen use\n\n```\nfermatTest n a = modN a (n-1) n == 1\n```\n\n\nNote that you could use this (with ```\nInt```\n instead of ```\nInteger```\n) to correctly implement ```\nfermatPT :: Int -> Bool```\n; although the input would still be restricted to smaller integers, it won't suffer from overflow.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "MillerRabin primality test in C#\r\n                \r\nWelcome. I am trying to implement MillerRabin test for checking if large given number is a prime. Here is my code:\n\n```\n public static bool MillerRabinTest(BigInteger number)\n        {\n\n            BigInteger d;\n            var n = number - 1;\n            var s = FindK(n, out d);\n\n            BigInteger a = 2;\n            BigInteger y = Calc(a, d, number);  //a^d mod number\n            if (y != BigInteger.One && y != n)\n            {\n                for (var r = 1; r <= s - 1; r++)\n                {\n                    y = Calc(y, 2, number);\n                    if (y == 1)\n                        return false;  \n                }\n\n                if (y != n)\n                    return false;\n            }\n            return true; //it is probably prime\n        }\n```\n\n\nIt is working fine for small Bigintegers. But if my programs needs to evalute numbers containing of more than 16 bits, program freezes. For instance after  succesful  checking if number is a prime, program suddenly is not responsive. I dont understand how is that possible. If it checked one big number, it should have no problem for checking another one again. Even debugger is not being helpful ,becasue  ```\nstep options```\n disappear. I can share more  code of functions if needed. Above function is working correctly for small numbers.\n\nEDIT. Changing my modulo function for BigInteger.ModPow helped. Unfortunately now for bigger numbers, more than 3000 bits it is never returning prime number which is rather impossible. Or really prme numbers are hard to find out?\n    ", "Answer": "\r\nWell, it takes about 5 seconds at my workstation (Core i5 3.2GHz, IA64 .Net 4.5) to test for being prime for numbers equals to ```\n2**3000```\n:\n\n```\n  public static class PrimeExtensions {\n    // Random generator (thread safe)\n    private static ThreadLocal<Random> s_Gen = new ThreadLocal<Random>(\n      () => {\n        return new Random();\n      }\n    );\n\n    // Random generator (thread safe)\n    private static Random Gen {\n      get {\n        return s_Gen.Value;\n      }\n    }\n\n    public static Boolean IsProbablyPrime(this BigInteger value, int witnesses = 10) {\n      if (value <= 1)\n        return false;\n\n      if (witnesses <= 0)\n        witnesses = 10;\n\n      BigInteger d = value - 1;\n      int s = 0;\n\n      while (d % 2 == 0) {\n        d /= 2;\n        s += 1;\n      }\n\n      Byte[] bytes = new Byte[value.ToByteArray().LongLength];\n      BigInteger a;\n\n      for (int i = 0; i < witnesses; i++) {\n        do {\n          Gen.NextBytes(bytes);\n\n          a = new BigInteger(bytes);\n        }\n        while (a < 2 || a >= value - 2);\n\n        BigInteger x = BigInteger.ModPow(a, d, value);\n        if (x == 1 || x == value - 1)\n          continue;\n\n        for (int r = 1; r < s; r++) {\n          x = BigInteger.ModPow(x, 2, value);\n\n          if (x == 1)\n            return false;\n          if (x == value - 1)\n            break;\n        }\n\n        if (x != value - 1)\n          return false;\n      }\n\n      return true;\n    }\n  }\n```\n\n\nTest and benchmark\n\n```\n  BigInteger value = BigInteger.Pow(2, 3217) - 1; // Mersenne prime number (2.5e968)\n\n  Stopwatch sw = new Stopwatch();\n\n  sw.Start();\n\n  Boolean isPrime = value.IsProbablyPrime(10);\n\n  sw.Stop();\n\n  Console.Write(isPrime ? \"probably prime\" : \"not prime\");\n  Console.WriteLine();\n  Console.Write(sw.ElapsedMilliseconds);\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality tests in OpenSSL library\r\n                \r\nI am working with prime numbers. I would like to have an algorithm which would conduct prime test as fast as possible. As far as I know 'SSL' library uses the test and it is pretty good in there.\n\nI tried to find the part with the test in the OpenSSL source code. I went through almost every file in source code but found nothing. So, I would appreciate very much if someone helped me to find the part of code with prime test.\n    ", "Answer": "\r\nIn OpenSSL, prime testing uses ```\nBN_is_prime_fasttest_ex()```\n, which is a part of\nlibcrypto.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test for subsequences in C\r\n                \r\ni want to print all the prime numbers which subsequences are not primes.For example 881 is an acceptable number(8,8,81,81,88,1 are not primes) but 109 is not acceptable (1,0,9,10,19..19 is a prime number).I found the subsequences of each number by using a mask.So the problem here is that i cannot find a way to check the subsequences of each number separately.I cannot store my subsequences because I am not supposed to use arrays or functions.Can you give me an advice?I am a C begginer.Thanks in advance!\n\n```\n#include <stdio.h>\n\n#define MAXNUMB 100\n\nint main (void) \n{\n    int i,j,x,l,mask,max=1,mult,sub,c;\n    for (i = 11 ; i < MAXNUMB; i += 2 ) {\n       //\n        for (j = 3; j * j <= i; j += 2) {  \n           if (i % j == 0) { \n               break; \n           }           \n        }\n        if (j * j > i) {\n\n            int length = 0;\n            int tmp=i;\n            while (tmp != 0) {\n                tmp /= 10;\n                length++;\n            }\n\n\n           for (x=1;x<length*2;x++) {\n              mask=x;\n              mult=1;\n              sub=0;\n              int num=i;\n              while ( num != 0 ) {\n                  if ( mask % 2 == 1 ) {\n                      sub += num % 10 * mult;\n                      mult *= 10; \n                   }\n                   num /= 10;\n                   mask /= 2;\n\n                }\n           //the problem is here.If we use a printf command for the subsequences printf(\"%d \\n,sub); it runs perfectly\n\n\n                int k=sub;\n\n                for (l = 2; l * l <= k; l ++) {  \n                    if (k % l == 0) { \n                    printf(\"%d \\n\",i);\n                    break; \n                   }           \n                }   \n\n\n            }\n\n\n        }\n\n\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nI find things like this much easier to understand when they use subroutines. \nFor example, for each integer from 11 to MAXNUMB you have to decide whether the integer has any prime subsequence. So write a function ```\nint hasPrimeSubsequence(int value)```\n. Within this function, you will need to look at each subsequence and decide if it is prime. So write a function ```\nint isPrime(int value)```\n.\n\nSince it is non-trivial to compute a subsequence of a number,\nI would even write a function\n```\nint getSubsequenceOfNumberUsingMask(int value, int mask)```\n.\nA function ```\nint getMaximumMask(int value)```\n would also be handy.\n\nThe implementation of ```\nhasPrimeSubsequence```\n then looks like this:\n\n```\n/* Returns 1 if the value has a prime subsequence, 0 if it does not. */\nint hasPrimeSubsequence(int value)\n{\n  int has_found_prime = 0;\n  int maximum_mask    = getMaximumMask(value);\n  for (mask = 1; mask <= maximum_mask; ++mask )\n  {\n    int subsequence = getSubsequenceOfNumberUsingMask(value, mask);\n    if (isPrime(subsequence))\n    {\n      /* We found a prime subsequence, so the answer is \"yes\". */\n      has_found_prime = 1;\n      break;\n    }\n  }\n\n  return has_found_prime;\n}\n```\n\n\nNotice that when we pass numbers into subroutines by value,\nthe subroutine can mess around with the values as much as it wants\n(things like ```\nmask /= 2```\n) without affecting the values in the caller,\nso we don't have to make so many different-named copies of numbers.\n\nThe variable ```\nhas_found_prime```\n is how you keep track of whether any\nsubsequences are prime. It starts at ```\n0```\n (false) because we have not\nfound any prime subsequences (we have not even looked for one yet).\nBut if any of the subsequences is prime, we set ```\nhas_found_prime = 1```\n\n(true) and we never set it back to ```\n0```\n.\n\nAn alternative implementation is not to even bother with the\nvariable ```\nhas_found_prime```\n; if you find a prime, just return ```\n1```\n right away,\nand if you get to the end of the function without having returned ```\n1```\n already, then there were no prime subsequences and you return ```\n0```\n.\nBut some people do not like that style.\n\nYou may notice that this implementation of ```\nhasPrimeSubsequence```\n\ndoes not test whether the input value is prime before it starts\ntrying masks. That's because I assume the last mask will select all\nthe digits of the original number, that is, the number itself is\none of the subsequences. If you find this does not work, all you\nhave to do is insert something like this before the ```\nfor```\n loop\n(or even better, before you actually call ```\ngetMaximumMask```\n):\n\n```\n  if (isPrime(value))\n  {\n    has_found_prime = 1;\n  }\n```\n\n\n\n\nAdded note: The \"mask\" that you are apparently supposed to use here\nis treated as a binary number with the same number of binary bits as the number of decimal digits in the number from which you want to\nextract subsequences (which I'll call the \"input value\").\n\nEach mask selects a subsequence from the input value;\neach bit of the mask determines whether the corresponding\ndecimal digit of the input value is included in that subsequence.\nFor example, if the input value is 1237, then only the least significant\nfour bits of the mask are used, and\n\nmask 0001 (binary) selects the subsequence 7,\n\nmask 0010 (binary) selects the subsequence 3,\n\nmask 1000 (binary) selects the subsequence 1,\n\nmask 1011 (binary) selects the subsequence 137, and so forth.\n\nThe highest-valued mask using four bits is binary 1111,\nwhich is 1 less than 2 to the 4th power.\nThis mask selects all the digits of a four-digit input value.\n\nIn general, if the length of the input value is N decimal digits, then the  largest possible mask is 2 raised to the Nth power, minus 1.\nThis is also the number of possible subsequences\n(excluding the empty subsequence, which contains no digits at all).\n\nIf you do not try every mask from 1 to (2 to the Nth power, minus 1),\ninclusive,\nthen you have not tried all subsequences and you may get a wrong answer\n(guessing that the number has no prime subsequences when actually it has one).\n\nSimply trying mask values from 1 up to ```\nlength```\n (the number of digits),\nor even up to ```\n2*length```\n, is almost always wrong.\n\nA comment suggested something like\n\n```\n  for (mask = 1; mask < (1 << length); ++mask)\n```\n\n\nThis will work, because ```\n(1 << length)```\n is 2 raised to the ```\nlength```\n power,\nand using ```\n<```\n the last mask that will actually be tried is 1 less than that.\nI still find that it makes much more readable code if you make a variable\nwith a reasonably self-explanatory name such as\n```\nmaximum_mask```\n or ```\nend_of_masks```\n, and set that variable so that the loop will\nrun just the right number of times.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Modified version of Miller-Rabin to test deterministic primality?\r\n                \r\nThe Miller-Rabin test uses k random integers to test for primality.\nAccording to CLRS, 3rd Edition, Page 971:\n\nTheorem 31.38\nIf n is an odd composite number, then the number of witnesses to the compositeness of n is at least (n - 1)/2.\n\nThen why don't we just instead of running random tests k times, use different ( n - 1 ) / 2 values and test them for primality? Since all primes except 2 are odd and no of witnesses are atleast ( n - 1 ) / 2 we are guaranteed to find a witness if exists.\n    ", "Answer": "\r\nThe running time goes from poly(log(n)) to n*poly(log(n)), which is terrible for large numbers, since n is exponentially bigger than log(n).\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Improving trial division primality test\r\n                \r\nI'm learning about checking is number a prime, and I curious how can I make it faster for big numbers (Like 2^64-1)         \n\n```\nbool IsPrime(BigInteger number)\n{\n    if (number< 2) return false;\n    else if (number< 4) return true;\n    else if (number% 2 == 0) return false;\n    else for (BigInteger u = 3; u*u <= Num; u += 2)\n        if (number % u == 0) return false;\n    return true;\n}\n```\n\n    ", "Answer": "\r\nFor a very minor improvement, so minor you won't notice it, you can save a single ```\nif```\n statement:\n\n```\nif (number < 2) return false;\nelse if (number % 2 == 0) return number == 2;\nelse for...\n```\n\n\nFor a noticeable improvement I would suggest using the Sieve of Eratosthenes in place of trial division.  If that is still too slow, then research other methods, such as Miller-Rabin.\n\nEven with the fast methods, it is worth using the slower methods for a short time, say trying all the primes up to 5,000 as factors, before going to the trouble of setting up one of the more complex tests.  There is no point in doing a lot of work to determine that 4,327,856,799,435 is composite.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fermat Primality Test failure in C\r\n                \r\n```\n#include <stdio.h>\n#include <time.h>\n#include <math.h>\n#include <stdlib.h> \n\n#define MAXNUM 2000000000\n#define MINNUM 1990000001\n#define MAXTRIES 10\n\nunsigned long long b, e, m, result; \n\nint modulo(b, e, m) \n{\n    result = 1;\n\n    while(e > 0)\n    {\n        if(e % 2 == 1)\n        {\n            result = (result * b);\n        } \n\n        b = (b * b) % m;\n        e = e / 2;\n    }\n\n    return result % m;\n}\n\nint isPrime(n) \n{\n    unsigned long long a; \n\n    int i; \n\n    for(i = 1; i <= 10; i++)\n    {\n        a = rand() % (n - 1) + 1;\n        if(modulo(a, n - 1, n) != 1)\n        {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\nint main() \n{\n    unsigned int prime = 0;\n    unsigned int flag = 0;\n    unsigned int tries;\n    unsigned int start;\n    long curtime;\n    unsigned long long p;\n\n    curtime = time(NULL);\n    srand((unsigned int) curtime);\n    printf(\"Checking range [1990000001, 2000000000] for prime numbers.\\n\");\n    if(MINNUM % 2 == 0)\n    {            \n        start = MINNUM + 1;      \n    }\n    else\n    {\n        start = MINNUM;    \n    }\n\n    printf(\"Trying Fermat test with seed %ld \\n\\n\",curtime);\n    prime = 0;\n\n    for(tries = 1; tries <= MAXTRIES; tries++)\n    {\n        clock_t tic = clock();\n        for(p = start; p <= MAXNUM; p += 2)\n        {\n            if(isPrime(p))\n                prime++;\n        } \n\n        clock_t toc = clock();\n        printf(\"Probabilistic algorithm: Found %ld primes in %f seconds.(tries = %d)\\n\", prime, (double)(toc - tic) / CLOCKS_PER_SEC,tries);\n        prime = 0;\n    } \n\n    return 0;\n}\n```\n\n\nSo the problem is that the algorithm finds in every try 5000000 prime numbers when it should find around 466646 with some deviation. Which means that in every try it should find a number of primes close to the one mentioned above.\n    ", "Answer": "\r\nIt looks like the main problem is caused by integer overflows in the ```\nmodulo()```\n function. Specifically, ```\nresult=(result*b)```\n is going to overflow quite regularly. You need to store these variables in 64-bit unsigned integers, and calculate the modulus of this result every time.\n\nThis will work (with a few minor corrections elsewhere):\n\n```\n#include <inttypes.h>\n\n#define MAXNUM 2000000000\n#define MINNUM 1990000001\n#define MAXTRIES 10\n\n\nuint64_t modulo(uint64_t b, uint64_t e, uint64_t m){\n    uint64_t result=1;\n    while(e>0){\n        if(e%2==1){\n            result=(result*b)%m;\n        }\n        b=(b*b)%m;\n        e=e/2;\n    }\n    return result%m;\n}\n```\n\n\nResult:\n\n```\nChecking range [1990000001, 2000000000] for prime numbers.\nTrying Fermat test with seed 1416322197 \n\nProbabilistic algorithm: Found 466646 primes in 5.157485 seconds.(tries=1)\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test taking longer than brute force method, how can I improve?\r\n                \r\nI am trying to calculate prime numbers on a single machine, around the size of 2^30-2^100.\nMy algorithm is included below for anyone interested.\nI've optimized this Python code to be ```\nO(sqrt(n/2))```\n (I believe) for each number: it only accepts odd numbers, and I ensure the number passed to it is odd in another method. \n\nI used the Fermat primality test to try and speed up the process. However, the numbers are too large for the built-in ```\nmath.pow()```\n method so I used Exponentiation by Squaring.\nHowever, this is taking a very long time for larger numbers - which would be faster using just brute force. \n\nIs my implementation wrong?\nThe time comes from the squaring algorithm, its recurrence stack also eats up my memory, is there a faster algorithm for this that I should research?\n\nTo calculate if the number 35184372088967 is prime, it took .00100111 seconds using my brute force algorithm, but took .40608 seconds to run the prime test.  \n\nBrute force prime number check:\n\n```\ndef isPrime(n):\n    for i in range(3,int(math.sqrt(n)),2):\n        if(n%i==0):\n            return False\n    return True\n```\n\n\nImplementation of Fermat's algorithm:\n\n```\ndef couldBePrime(n):\n        if(n>308):\n            return power(2,n-1)%n==1\n        else:\n            return math.pow(2,n-1)%n==1\n```\n\n\nExponentiation by squaring algorithm (The time consuming part):\n\n```\ndef power(base,exp):\n    if exp == 0:\n        return 1\n    elif exp == 1:\n        return base\n    elif (exp & 1) != 0:\n        return base * power(base * base, exp // 2)\n    else:\n        return power(base * base, exp // 2)\n```\n\n    ", "Answer": "\r\nBug: ```\nmath.pow```\n calculates floating-point values. Floating point calculations are approximate, and will give you meaningless results here. You need integer calculations, such as you do (inefficiently) in your ```\npower```\n function. Python's built-in ```\n**```\n operator and ```\npow```\n function (not ```\nmath.pow```\n, which is a different function) both operate on integers.\n\nIn Python, like in many programming languages, the library called ```\nmath```\n is specifically about floating point computations, not about other kinds of mathematical computations such as calculations done on integers.\n\nInefficiency: to calculate b^e mod n, it is a lot more efficient to perform arithmetic modulo n, rather than first calculate b^e and then divide the result by n. Calculating b^e requires building a very large number, and this will be slow because the numbers get large pretty quickly as the calculation goes through higher and higher powers of b. (The optimal way to calculate b^e is not easy to determine, but all the ways involve calculating intermediate powers of b, the only practical uncertainty is in what order.) When you want the result modulo n, do all the successive multiplications modulo n: calculate b^2 mod n, then square and reduce modulo n to get b^4 mod n, etc. Each time you perform a multiplication, take the remainder of the division by n before you do anything else.\n\nIn Python, the standard library function ```\npow```\n (remember, not ```\nmath.pow```\n) will do that for you. It's as simple as\n\n```\ndef couldBePrime(n):\n    return pow(2, n-1, n) == 1\n```\n\n\nIf Python didn't have this function, then your ```\npower```\n function a reasonable way to implement it, if you reduced each intermediate result modulo n.\n\n```\ndef power(base, exp, mod):\n    if exp == 0:\n        return 1\n    elif exp == 1:\n        return base % mod\n    elif (exp & 1) != 0:\n        return (base * power((base * base) % mod, exp // 2, mod)) % mod\n    else:\n        return power((base * base) % mod, exp // 2)\n```\n\n\nCalling a built-in function is a lot faster, of course, both because this is a decent but not extremely good way to perform the operation, and because Python is more optimized for ease of writing than for speed so it's best to leave the as much as possible of the numerical heavy lifting to built-in functions.\n\nAn additional note: to calculate a power of two, there's a much faster way than multiplications — do bit shifting. But that doesn't help here because you want to do calculate 2^e mod n and not 2^e.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fermat's primality test and Carmichael number\r\n                \r\nI am playing with prime numbers and Fermat's Little Theorem. I read about Carmichael numbers and that they should pass the tests. The problem is, when I test it and use two different conditions it should end with the same result, but it isn't.\n\nCode :\n\n```\nimport java.math.BigInteger;\n\npublic class FermatTest {\n    public static boolean passesAllFermatTests(BigInteger n) {\n        BigInteger testValue = BigInteger.ONE;\n\n        while (testValue.compareTo(n) == -1) {\n            if (!passesFermatTest(n, testValue)) {\n                return false;\n            }\n            testValue = testValue.add(BigInteger.ONE);\n        }\n        return true;\n    }\n\n    public static boolean passesFermatTest(BigInteger n, BigInteger a) {\n        //if( !a.modPow(n.subtract(BigInteger.ONE), n).equals(BigInteger.ONE)) {\n        if(! a.modPow(n, n).equals(a)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(passesAllFermatTests(BigInteger.valueOf((long) 561)));\n    }\n}\n```\n\n\nWhen I run it with this condition, it returns true ( pass it ). If I run it with the commented condition, it returns false. It should be the same, isn't it? Is there an error in my code or I misunderstood something?\n    ", "Answer": "\r\nThe problem is when a = 3, your commented condition return false, it is because 3 and 561 is not relatively prime! Carmichael number require gcd(a,n) = 1 (please refer to the wikipedia: https://en.wikipedia.org/wiki/Carmichael_number).\n\nSo in your program, you should first check \"a\" and \"n\" is relatively prime first before applying the commented condition.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "What are typical runtimes for Miller-Rabin primality testing?\r\n                \r\nI'm well aware that a single Miller-Rabin test runs in cubic log time. I know about Montgomery modular exponentiation and GNFS and I'm not asking about any of that fancy theory. What I am wondering is what some representative runtimes for MR (note that this is not the same as an RSA operation) on characteristic hardware (e.g., a 2.2 GHz Opteron or such-and-such graphics card or FPGA).\n    ", "Answer": "\r\nOne random-base Miller-Rabin test implemented in GMP, average of multiple primes and multiple runs.  i4770K @ 4.3GHz, GMP 6.0.0a.  For numbers under 64-bit, times can be faster using a non-GMP implementation (with x86_64 asm mulmod).  This implementation seems to follow most other C+GMP implementations fairly closely in performance (for the same numbers, mpz_aprcl's mpz_sprp runs within a couple percent of the times below).  Using non-standard API calls to do Montgomery math may be faster (and maybe not).\n\n\n20 digits:  1.1 uS\n40 digits:  3.4 uS\n80 digits: 14 uS\n200 digits:  0.11 mS\n400 digits:  0.65 mS\n800 digits:  4.7 mS\n1200 digits:  15 mS\n1600 digits:  31 mS\n2000 digits:  53 mS\n4000 digits:  310 mS\n\n\nWith a good implementation, BPSW (base 2 M-R + [extra] strong Lucas test) takes ~3x the cost of one M-R test.  Lucas test implementations differ a lot more in performance.  A Frobenius test is on the order of 2.5x the cost of a single M-R test.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Lucas-Lehmer primality test with python\r\n                \r\nI wrote the code below, to get the Lucas-Lehmer series up to p, for p the exponent of a Mersenne number. After checking it I found that it doesn't work for some primes p such as 11, 23, 29 etc. Any help will be very valuable! \n\nHere's the code:\n\n```\ndef ll_series (p):\n    ll_list=[4]\n    print 4\n    for i in range(1, p+1):\n        ll_list.append((ll_list[i-1]**2 - 2) % (2**p-1))\n        print(ll_list[i])\n    return ll_list\n```\n\n    ", "Answer": "\r\nThe Lucas-Lehmer test tests if a Mersenne number is prime. 11 is not a Mersenne number therefore the test fails.\nMersennse number is - ```\nM_n = 2^n-1```\n.\n\nhttp://mathworld.wolfram.com/MersenneNumber.html\n\np.s the implementation can be more efficient if you calculate ```\nM=(2^p-1)```\n only once\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Basic primality test predicate in Prolog\r\n                \r\nI am trying to create a predicate ```\nisPrime/1```\n that checks if a given number is prime or not. I have come up with the following code:\n```\nprimeRec(_, 2).\nprimeRec(X, Y) :- Y > 2, X mod Y-1 > 0, primeRec(X, Y-1).\n\nisPrime(2).\nisPrime(X) :- X > 1, X mod 2 > 0, primeRec(X, X).\n```\n\nbut it does not seem to work, and I have no idea why. I've found my code to follow the same idea as this one here, except that mine always returns ```\nfalse.```\n for any ```\n?- isPrime(X).```\n with X bigger than 2, which obviously should not happen.\n    ", "Answer": "\r\nThe problem is that you need to define another variable, say ```\nY1```\n, and unify it with the evaluation of ```\nY-1```\n, i.e., ```\nY1 is Y - 1```\n and use ```\nY1```\n instead of ```\nY-1```\n in the second rule for ```\nprimeRec/1.```\n This because if you want to evaluate an arithmetic expression you need to use ```\nis```\n.\n```\nprimeRec(X, Y) :- Y > 2, Y1 is Y - 1, X mod Y1 > 0, primeRec(X, Y1).\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to speed up this primality test\r\n                \r\nI would like to find the largest prime factor of a given number. After several attempts, I've enhanced the test to cope with rather big numbers (i.e. up to one billion in milliseconds). The problem is now if go beyond one billion, the execution time goes forever, so to speak. I wonder if I can do more improvements and reduce the execution time. I'm hoping for better  execution time because in this link Prime Factors Calculator, the execution time is incredibly fast. My target number at this moment is 600851475143. The code is rather self-explanatory. Note: I've considered Sieve of Eratosthenes algorithm with no luck regarding the execution time. \n\n```\n#include <iostream>\n#include <cmath>\n\nbool isPrime(int n)\n{\n    if (n==2)\n        return true;\n\n    if (n%2==0)\n        return false;\n\n    for (int i(3);i<=sqrt(n);i+=2) // ignore even numbers and go up to sqrt(n)\n        if (n%i==0)\n            return false;\n\n    return true;\n}\n\nint main()\n{\n    int max(0);\n    long long target(600851475143);\n\n    if( target%2 == 0 )\n        max = 2;\n\n    for ( int i(3); i<target; i+=2 ){ // loop through odd numbers. \n        if( target%i == 0 )  // check for common factor\n            if( isPrime(i) ) // check for prime common factor\n                max = i;\n    }\n\n    std::cout << \"The greatest prime common factor is \" << max << \"\\n\";\n\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nOne obvious optimization that I can see is:\n\n```\nfor (int i(3);i<=sqrt(n);i+=2) // ignore even numbers and go up to sqrt(n)\n```\n\n\ninstead of calculating ```\nsqrt```\n everytime you can cache the result in a variable.\n\n```\nauto maxFactor = static_cast<int>sqrt(n);\nfor (int i(3); i <= maxFactor; i+=2);\n```\n\n\nThe reason I believe this could lead to speed up is ```\nsqrt```\n deals with ```\nfloating point arithematic```\n and compilers usually aren't generous in optimizing floating point arithematic. gcc has a special flag ffast-math to enable floating point optimizations explicitely.\n\nFor numbers upto the target range that you mentioned, you will need better algorithms.  repeated divisioning should suffice. \n\nHere is the code (http://ideone.com/RoAmHd) which hardly takes any time to finish:\n\n```\nint main() {\n    long long input = 600851475143;\n    long long mx = 0;\n    for (int x = 2; x <= input/x; ++x){\n        while(input%x==0) {input/=x; mx = x; }\n\n    }\n    if (input > 1){\n        mx = input;\n    }\n    cout << mx << endl;\n    return 0;\n}\n```\n\n\nThe idea behind repeated division is if a number is already a factor of p, it is also a factor of p^2, p^3, p^4..... So we keep eliminating factors so only prime factors remain that eventually get to divide the number.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fermat primality test for big primes\r\n                \r\nI’m currently trying to implement RSA encryption algorithm for a school project. And after looking into it I thought that generating my own prime numbers would be interesting too. I’m using the gmp lib to store the numbers.\n\nA few sources said that this is generally done by using a sieving method and then doing probabilistic test on the numbers, in my case I’m starting with the Fermat test:\n\na^(potPrime-1) ≡ 1 (mod potPrime)\n\nThe problem I’m having is calculating “a^(potPrime-1)”, I couldn’t find a function in the gmp lib that can calculate an mpz_t power another mpz_t so I wrote my own which is really a while that keeps looping until I’ve multiplied the number by itself the desired amount of times.\nThis works with small numbers, but when potPrime can go up to 2^2048 this solution isn’t adequate. \n\nDoes anyone know how I could get around this? Here’s the code for the Fermat test:\n\n```\nint fermatTest(mpz_t potPrime, mpz_t a) //The fermat test is a mathimatical test that will determine if a number is potentialy prime.\n{                                       //a is a random number between ]1;p-1[\n    int result;\n    mpz_t potPrimeMin1,aSqPotPrimeMin1,val1; //decalre mpz type value, val1=1\n    mpz_init(potPrimeMin1); //initialises the mpz type value of the number containing potPrime minus 1\n    mpz_init(aSqPotPrimeMin1);//value of a^(p-1)\n    mpz_init(val1); //a mpz type var where val1 is allways 1\n    mpz_set_ui(val1,1);\n\n    mpz_sub_ui(potPrimeMin1,potPrime,1); //subtracts 1 from potPrime and stores it in potPrimeMin1\n\n    mympz_pow(aSqPotPrimeMin1,a,potPrimeMin1);//aSqPotPrimeMin1=a^potPrimeMin1\n\n    result = mpz_congruent_p(aSqPotPrimeMin1,val1,potPrime); //test checks if a^(potPrime-1) ≡ 1 (mod potPrime) - returns non zero if congruent\n\n    //returns non zero if operation is true, 0 if not\n\n    mpz_clear(potPrimeMin1);//frees the variables used\n    mpz_clear(aSqPotPrimeMin1);\n    mpz_clear(val1);\n\n    return result;\n}\n```\n\n\nand this is the code for the pow function:\n\n```\nint mympz_pow(mpz_t result, mpz_t base, mpz_t power)\n{\n    mpz_t i;\n    mpz_init(i);\n    mpz_set_ui(i,1);\n    mpz_set(result,base);\n    //mpzPrint(\"1\",result);\n    while(mpz_cmp(i,power) < 0)\n    {\n        mpz_mul(result,result,base);\n        //mpzPrint(\"2\",result);\n        mpz_add_ui(i,i,1);\n        mpzPrint(\"pow\",power);\n        mpzPrint(\"i\",i);\n    }\n    //mpzPrint(\"3\",result);\n    mpz_clear(i);\n    return 1;\n}\n```\n\n    ", "Answer": "\r\nGmp has a function ```\nmpz_powm```\n that does modular exponentiation. If you want to do it yourself, use the square-and-multiply algorithm:\n\n```\nfunction powerMod(b, e, m)\n    x := 1\n    while e > 0\n        if e%2 == 1\n            x, e := (x*b)%m, e-1\n        else b, e := (b*b)%m, e//2\n    return x\n```\n\n\nThis takes time logarithmic in the exponent rather than linear, as your algorithm does. Or you may prefer to use the ```\nmpz_probab_prime_p```\n and let gmp do all the work for you.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why does python skip my while loop in my primality test when I enter a huge number?\r\n                \r\nI'm currently trying to make a simple primality test using python to test prime number. \n\nHere is the code I've made for the test:\n\n```\ndef is_prime(n):      \n    if np.mod(n, 2) == 0:          \n        return False\n\n    f = 3\n\n    while np.square(f) <= n:       \n        if np.mod(n, f) == 0:\n            return False\n        f += 2\n\n    return True             \n```\n\n\nI run the code, and it works fine for small numbers. Then I enter a huge number (for convenience, I chose ```\n2^128```\n), it returns True. But when I enter  ```\n2^129```\n, ```\n2^130```\n, ```\n2^131```\n, ```\n2^132```\n (and so on), it always returns True. I believe my loop has been skipped. To verify this, I modified the code like below:\n\n```\nwhile np.square(f) <= n:       \n    if np.mod(n, f) == 0:\n        print(f)    #Added line\n        return False\n    f += 2\n\nprint(f)     #Added line\n```\n\n\nI test this again for some small numbers, and it'll print the correct value of f. But for arbitrarily large numbers (higher than '2^50', maybe), it'll only print 3 (the initial value of f). So I am sure that this while loop has been skipped.\n\nIs there a way to fix this?\n\nP/S: \n\n\nI've also made other primality test. But I want to use this test as a verification for the result of those tests (though it'll take longer)\nI also using Numba to speed up my code (```\n@jit(nopython=True)```\n). This is why I use a lot of np function, as Numba work efficiency with NumPy\n\n\nEdit 1:\n\n\nI have re-test the code without, and it works perfectly fine (even with massive numbers) but it much slower. So I guess there is a problem with Numba when handling a large number\n\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Is it worth memoising a primality test?\r\n                \r\nI have another backtracking challenge, in which I have to get all possible combinations of prime numbers that add up to a certain number. I have finished the task using the general use algorithm from Wikipedia, but for the number 100, it took more than an hour to run, and it still hadn't finished by the end of class. I was wondering: Would memoisation(how do you spell that?) have significantly improved the algorithm's performance(as in, would it have made it noticeably faster)? I am using c++, and the function is called a huge number of times. I am using recursive backtracking, which I seem to remember is roughly O(n!) for simple problems.\n    ", "Answer": "\r\nCreate an array external to the function checking for primarity and reachable from it. Global or static, depending on the used language. That array will content all found primary numbers. \n\n```\nIf the number in question is in the array, return true. \nif number is less or equal than squared max number in the array, return false.\nCheck for divisibility for all known primaries\nif the number is primary, write it into array and return true\nreturn false\n```\n\n\nThat adding is simple enough. Do it and check the changed time. \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Testing for primality on a large integer that is stored as a string in C++\r\n                \r\nI have a program that calculates large numbers by storing them as strings, so that I can have very large digits that extend beyond long long.\n\nI can add the strings using a function I've written that models how we humans do addition by hand on paper, and it works. I'm able to add large \"string integers\" together accurately, even when they have hundreds of digits in them.\n\nI now want to use this to enumerate large numbers and test for primality. The problem is, I don't know how I would do this on a string-int that is very large, because I can't convert it to a long long and then perform the test.\n\nAre there techniques for testing for prime numbers that would work on the digits of the number or something? How would I try to factor large numbers that are represented as strings, and test if numbers are factors of it, etc? How do I approach this problem?\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "What is the shortest way to count prime numbers from an array. All normal primality test are not passing the test cases because of time limit\r\n                \r\nThe code given below passes two test cases and sieve of eratosthenes passes 1 test case. How can this problem be solved.\n\nI have already tried miller rabin and sieve eratosthenes primality test.\nNone is passing all the test cases because of time restriction. Is there any possible way faster than these?\nThe below code is passing two of the 5 test cases. Can it be made any shorter in terms of time complexity?\n\n```\n#include<stdio.h>\n#include<math.h>\nint isPrime(int n) \n{\n    int i;\n    int x=(int)(sqrt(n));\n    if(n==2)\n    return 1;\n    else if(n%2==0)\n    return 0;\n    else\n    {\n        for(i=3;i<=x;i+=2)\n        {\n            if(n%i==0)\n            {\n                return 0;\n            }\n        }\n    }\n    return 1;\n\n}\nint counting(int *a,int n)\n{\n    int i,c=0;\n    for(i=0;i<n;i++)\n    {\n        if(isPrime(a[i]))\n        c++;\n    }\n    return c;\n}\nvoid main()\n{\n    int cases,n,a[100000],i,j,count;\n    scanf(\"%d\",&cases);\n    for(i=0;i<cases;i++)\n    {\n        scanf(\"%d\",&n);\n        for(j=0;j<n;j++)\n        scanf(\"%d\",&a[j]);\n        count=counting(a,n);\n\n        printf(\"%d\\n\",count);\n    }\n}\n```\n\n    ", "Answer": "\r\nMaybe you should try this algorithm, i got from this site. It seems to be more time-efficient:\n\n```\n    #include <stdio.h>\n    int main()\n    {\n        int n, i, flag = 0;\n        printf(\"Enter a positive integer: \");\n        scanf(\"%d\", &n);\n        for(i = 2; i <= n/2; ++i)\n        {\n            // condition for nonprime number\n            if(n%i == 0)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if (n == 1) \n        {\n          printf(\"1 is neither a prime nor a composite number.\");\n        }\n        else \n        {\n            if (flag == 0)\n              printf(\"%d is a prime number.\", n);\n            else\n              printf(\"%d is not a prime number.\", n);\n        }\n\n        return 0;\n    }\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test using Fermat little theorem\r\n                \r\ncode: \n\n```\nvoid prime()    \n{    \n    int i,N;    \n    scanf(\"%d\",&N);    \n    for(i=2;i<N;i++)            \n    {    \n        if (((i^(N-1))%N )==1);     \n        else{    \n            printf(\"not prime\");   \n            return;\n        }     \n    }    \n    printf(\"prime\");    \n    return;    \n}    \n```\n\n\nThis program is based on Fermat's Theorem on prime numbers. N is number to be tested as prime. This program is not showing correct result for '11'. Maybe due to some mistake which is not identified by me.\n    ", "Answer": "\r\nYou are running into overflow if this is pseudo-code  or\nIf C code, use of ```\n^```\n as power operator is not valid.\n\nWorking with large integers quickly becomes a problem in C.  The are various ```\nBigInt```\n libraries available.\n\nUsing floating point is challenging with large integer computation.  Recommend avoiding ```\ndouble```\n, ```\npow()```\n, etc.\n\nSince the problem is all >= 0, suggest using unsigned integers.  Also use the largest integer type available - typically ```\nunsigned long long```\n.  As overflow is a real possibility, detect it.\n\n```\nunsigned long long upower(unsigned i, unsigned N) {\n  unsigned long long power = 1;\n  if (i <= 1) return i;\n  while (N-- > 0) {\n    unsigned long long power_before = power;\n    power *= i;\n    if (power < power_before) {\n      printf(\"Overflow\\n\");\n      return 0;\n    }\n  }\n  return power;\n}\n\nvoid prime() {\n  unsigned i, N;\n  scanf(\"%u\", &N);\n  for (i = 2; i < N; i++) {\n    if ((upower(i, N - 1) % N) != 1) {\n      printf(\"not prime\");\n      return;\n    }\n  }\n  printf(\"prime\");\n  return;\n}\n```\n\n\nIn lieu of huge integers, the Chinese remainder theorem may offer an alternative to ```\n(upower(i, N - 1) % N) != 1```\n.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why does my primality test stop after 1 and not seem to be able to go on?\r\n                \r\nI apologize if this is a dumb question, I'm pretty new to Java, but I can't figure out why my mod operator based primality test for numbers 1-100 stops at 1. I've tried following my code and I don't understand why it fails to continue to the last else statement when possiblePrime = 2.\nIt should just take possiblePrime = 2 through the if and else if statements all the way to the last else statement and print \"2 is a prime.\" and then continue on to possiblePrime = 3, but instead it goes through the loops as it should when possiblePrime = 1, as it is when it is initialized at the start, and then stops entirely once possiblePrime is incremented at the end of the last else statement, solely printing \"1 is a prime.\"\nThank you for any help you might be able to offer, it is much appreciated! I am definitely racking my brain trying to figure this out, and I'm almost 100% sure it is some stupid and obvious mistake I'm just not seeing.\n```\npublic class PrimeFind {\n    public static void main(String[] args){\n        int possiblePrime = 1;\n        for(int i = 1 ; i <= 100 ; i++){\n            int possibleDivisor = 1;\n            if(possiblePrime%possibleDivisor != 0){\n                possibleDivisor++;\n            }\n            else if(possiblePrime != possibleDivisor){\n                possiblePrime++;\n            }\n            else{\n                System.out.println(possiblePrime + \" is a prime.\");\n                possiblePrime++;\n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nYou are setting ```\npossibleDivisor = 1```\n inside the for loop. hence it will always equal 1. This in turn will make the modulo operation equal to 0 in every case. The possiblePrime will always be different from the possibleDivisor (1) except for 1. Hence you only get 1.\n```\npublic class PrimeFind {\n    public static void main(String[] args){\n        int possiblePrime = 1;\n        for(int i = 1 ; i <= 100 ; i++){\n            int possibleDivisor = 1; // Always 1\n            if(possiblePrime%possibleDivisor != 0){ // Always False because something%1 == 0\n                possibleDivisor++;\n            }\n            else if(possiblePrime != possibleDivisor){ // Always True except for possiblePrime=1\n                possiblePrime++;\n            }\n            else{\n                System.out.println(possiblePrime + \" is a prime.\");\n                possiblePrime++;\n            }\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Time Complexity of this primality test function\r\n                \r\nWhat would be the time complexity of this function\n```\nbool prime(int n) {\n    if(n <= 1) {\n        return false;\n    } else if(n <= 3) {\n        return true;\n    } else if(n % 2 == 0 || n % 3 == 0) {\n        return false;\n    } else {\n        for(int i = 5; i * i <= n; i += 6) {\n            if(n % i == 0 || n % (i + 2) == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n\nIf I had to guess, it would be\n```\nO(sqrt(log(n)))\n```\n\n    ", "Answer": "\r\nEach if is constant time.\n```\nfor```\n loop is executed until ```\ni * i```\n reaches ```\nn```\n this means it is executed ```\nsqrt(n) / 6```\n times. So complexity is ```\nO(sqrt(n))```\n.\nIt doesn't meter that density of prime numbers is proportional to ```\n1/log(n)```\n (probably this is source of ```\nlog(n)```\n in your solution.\nNote that time complexity (no adjective) usually is consider as worst time complexity:\nTime complexity - Wikipedia\n\nSince an algorithm's running time may vary among different inputs of the same size, one commonly considers the worst-case time complexity, which is the maximum amount of time required for inputs of a given size. Less common, and usually specified explicitly, is the average-case complexity\n\nAverage time complexity is much harder to compute in this case. You would have to prove how fast loop terminates on average when ```\nn```\n is not a prime number.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "What's the Time Complexity of my Primality Test?\r\n                \r\nI have a basic understanding of how to calculate Time Complexities, but I'm not sure how to calculate it in this case due to the random nature of primes.\n\nA quick explanation --> Essentially, I'm keeping a running count of the remainders so that I know when the next prime is.\n\nMy code:\n\n```\nimport math\n\nn = int(input(\"Enter the number:\\t\"))\n\nprimeList = []\ncheckList = []\n\nnumber = 3\nisPrime = True\nwhile number <= math.sqrt(n) and isPrime:\n\n    isChanged = False\n    for i, checkNum in enumerate(checkList):\n        if checkNum == 1:\n            isChanged = True\n            checkList[i] = primeList[i]\n        else:\n            checkList[i] = checkNum - 1\n\n    if not isChanged:\n\n        primeList.append(number)\n        checkList.append(number)\n\n        if n % number == 0:\n            isPrime = False\n\n    number += 2\n\nif isPrime:\n    print(\"Prime\")\nelse:\n    print(\"Not Prime\")\n```\n\n    ", "Answer": "\r\nYour algorithm seems to be ```\nO(n/log(n))```\n\n\nThere are ```\nsqrt(n)```\n passes through the outer loop. The inner loop is bounded by the number of primes which are less than ```\nsqrt(n)```\n. By the Prime Number Theorem this is asymptotically given by ```\nsqrt(n)/log(sqrt(n))```\n. By the laws of logarithms this is equivalent to ```\nsqrt(n)/(0.5*log(n)) = 2*sqrt(n)/log(n)```\n. The overall complexity is thus\n\n```\nO(sqrt(n)*2*sqrt(n)/log(n)) = O(2*n/log(n)) = O(n/log(n))\n```\n\n\nNeedless to say, this isn't a very efficient way to check if ```\nn```\n is prime. It is asymptotically little better than the ```\nO(n)```\n naive check for divisibility by all numbers less than ```\nn```\n. \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "primality test for BigIntegers runs without stopping\r\n                \r\nGiven a BigInteger, I want to test if is prime or not.\n\nHere is my class:\n\n```\npublic class Prime {\n\n    public static boolean checkPrimality(BigInteger number) {\n\n        if (number.compareTo(BigInteger.valueOf(3)) <= 0) {\n            return number.compareTo(BigInteger.ONE) > 0;\n        } else {\n            if (number.mod(BigInteger.valueOf(2)).equals(BigInteger.ZERO) || number.mod(BigInteger.valueOf(3)).equals(BigInteger.ZERO)) {\n                return false;\n            }\n        }\n\n        for (BigInteger i = BigInteger.valueOf(5); i.multiply(i).compareTo(number) < 0; i = i.add(BigInteger.valueOf(6))) {\n            if (number.mod(i.add(BigInteger.valueOf(2))).equals(BigInteger.ZERO) || number.mod(i).equals(BigInteger.ZERO)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    public static void main(String[] args) {\n        System.out.println(checkPrimality(BigInteger.ONE.shiftLeft(31).subtract(BigInteger.ONE)));\n        System.out.println(checkPrimality(BigInteger.ONE.shiftLeft(60).subtract(BigInteger.ONE)));\n        System.out.println(checkPrimality(BigInteger.ONE.shiftLeft(61).subtract(BigInteger.ONE)));\n    }\n}\n```\n\n\nFor the first 2 numbers, the output is true and false as expected, but for the third one (which is a prime number), the program runs without stopping.\n\nQ: I want to know why the program does not stop, my guess is that there is some logic problem inside my method.\n    ", "Answer": "\r\nLet's try to estimate the run times.\n\nYour first number is:\n\n```\nN_1 = 2^31 - 1 = 2147483647\nSqrt(N_1) = 46430.95...\nSqrt(N_1) / 6 = 7723.49...\n```\n\n\nso your loop has to run less than 8k times, which is not a lot. Your second number is divisible by three:\n\n```\nN_2 = 2^60 - 1 = 1152921504606846975\nN_2 / 3 = 384307168202282325\n```\n\n\nso the loop is never even entered. For the third number, however\n\n```\nN_3 = 2^61 - 1 = 2305843009213693951\nSqrt(N_3) = 1518500249.99\nSqrt(N_3) / 6 = 253083374.998\nSqrt(N_3) / Sqrt(N_1) = 32768.007...\n```\n\n\nNot surprisingly, since N_3 is about 2^30 times bigger than N_1, the number of loop iterations needed is about 2^15 times bigger. So if the algorithm finishes in a second for N_1, we'd expect it to take about nine hours for N_3.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin primality test issue in C++\r\n                \r\nI've been trying to implement the algorithm from wikipedia and while it's never outputting composite numbers as primes, it's outputting like 75% of primes as composites.\n\nUp to 1000 it gives me this output for primes:\n\n3, 5, 7, 11, 13, 17, 41, 97, 193, 257, 641, 769\n\nAs far as I know, my implementation is EXACTLY the same as the pseudo-code algorithm. I've debugged it line by line and it produced all of the expected variable values (I was following along with my calculator). Here's my function:\n\n```\nbool primeTest(int n)\n{\n    int s = 0;\n    int d = n - 1;\n\n    while (d % 2 == 0)\n    {\n        d /= 2;\n        s++;\n    }\n\n    // this is the LOOP from the pseudo-algorithm\n    for (int i = 0; i < 10; i++)\n    {\n        int range = n - 4;\n        int a = rand() % range + 2;\n        //int a = rand() % (n/2 - 2) + 2;\n        bool skip = false;\n        long x = long(pow(a, d)) % n;\n\n        if (x == 1 || x == n - 1)\n            continue;\n\n        for (int r = 1; r < s; r++)\n        {\n            x = long(pow(x, 2)) % n;\n\n            if (x == 1)\n            {\n                // is not prime\n                return false;\n            }\n            else if (x == n - 1)\n            {\n                skip = true;\n                break;\n            }\n        }\n\n        if (!skip)\n        {\n            // is not prime\n            return false;\n        }\n    }\n\n    // is prime\n    return true;\n}\n```\n\n\nAny help would be appreciated D:\n\nEDIT: Here's the entire program, edited as you guys suggested - and now the output is even more broken:\n\n```\nbool primeTest(int n);\n\nint main()\n{\n    int count = 1;     // number of found primes, 2 being the first of course\n    int maxCount = 10001;\n    long n = 3;\n    long maxN = 1000;\n    long prime = 0;\n\n    while (count < maxCount && n <= maxN)\n    {\n        if (primeTest(n))\n        {\n            prime = n;\n            cout << prime << endl;\n            count++;\n        }\n\n        n += 2;\n    }\n\n    //cout << prime;\n    return 0;\n}\n\nbool primeTest(int n)\n{\n    int s = 0;\n    int d = n - 1;\n\n    while (d % 2 == 0)\n    {\n        d /= 2;\n        s++;\n    }\n\n    for (int i = 0; i < 10; i++)\n    {\n        int range = n - 4;\n        int a = rand() % range + 2;\n        //int a = rand() % (n/2 - 2) + 2;\n        bool skip = false;\n        //long x = long(pow(a, d)) % n;\n        long x = a;\n        for (int z = 1; z < d; z++)\n        {\n            x *= x;\n        }\n\n        x = x % n;\n\n        if (x == 1 || x == n - 1)\n            continue;\n\n        for (int r = 1; r < s; r++)\n        {\n            //x = long(pow(x, 2)) % n;\n            x = (x * x) % n;\n\n            if (x == 1)\n            {\n                return false;\n            }\n            else if (x == n - 1)\n            {\n                skip = true;\n                break;\n            }\n        }\n\n        if (!skip)\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n\nNow the output of primes, from 3 to 1000 (as before), is:\n\n3, 5, 17, 257\n\nI see now that x gets too big and it just turns into a garbage value, but I wasn't seeing that until I removed the \"% n\" part.\n    ", "Answer": "\r\nThe likely source of error is the two calls to the pow function. The intermediate results will be huge (especially for the first call) and will probably overflow, causing the error. You should look at the modular exponentiation topic at Wikipedia.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test predicate isPrime/1 in Prolog\r\n                \r\nI am trying to understand solutions of exercises in order to prepare my logic programming exam and somehow I could not understand the logic of the code below.\n\nExplanations in the question:\n\n\n  n is a prime number n > 1 and 1 < m < n\n  n/m has a non-zero remainder.\n\n\nHere is the code:\n\n```\nisPrime(X) :- help(X,X).\n\nhelp(X,Y) :-\n   Y > 2,\n   LOW is Y-1,\n   Z is X mod LOW,\n   Z > 0,\n   help(X,LOW).\nhelp(X,2).\n```\n\n\nCould someone please explain the code for me.\n    ", "Answer": "\r\nThis code is attempting to determine if  X is a prime number, by doing the following:\n\n```\nlet Y = X initially\n1. Check to see if the number (Y) is greater than 2.\n2. Assign a new variable (LOW) one-less than the starting number (Y-1)\n3. If X mod LOW is greater than zero, then recurse with LOW as the new Y\n```\n\n\nRepeat this until X mod LOW is greater than zero and your mod is 1 (Y=2), then if I'm reading this (and remembering the formula) correctly, you should have X as a prime.\n\n```\nIf at some point X mod LOW equals zero, then X is a non-prime.\nExample:  X=6 (non-prime)\nY=6, LOW=5, Z = 6 mod 5 = 1 --> help(6,5)\nY=5, LOW=4, Z = 6 mod 4 = 2 --> help(6,4)\nY=4, LOW=3  Z = 6 mod 3 = 0  --> non prime because it's divisible by 3 in this case\n\nExample: X=5 (prime)\nY=5, LOW=4, Z= 5 mod 4 = 1  --> help(5,4)\nY=4, LOW=3, Z= 5 mod 3 = 2  --> help(5,3)\nY=3, LOW=2  Z= 5 mod 2 = 3  --> help(5,2)\nY=2, --> once you get to this point, X is prime, because LOW=1, \nand any number mod 1 is greater than zero, and you can't \"X mod 0\".\n```\n\n\nMake sense? It's effectively iterating over numbers less than X to see if it divides equally (mod = 0).\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality testing: How to make sure not to test numbers which are multiples of already tested numbers?\r\n                \r\nHere is my code:\n\n```\nfrom math import sqrt\n\n\ndef isPrime(value):\n    a = []\n    for i in range(1, int(sqrt(value)) + 1):\n        if value <= 3:\n            return value\n        if value % 2 == 0:\n            break\n        if value % i == 0:\n            a.append(i)\n            i += 1\n            continue\n        elif value % i != 0:\n            a = a\n            continue\n    if len(a) == 1:\n        return value\n    else:\n        pass\n```\n\n\nI want to be able to use this for testing big numbers too, but as fast as possible.\n    ", "Answer": "\r\nPrimality testing with the Rabin-Miller algorithm\n\nUsed Wikipedia: Primality testing\n\n```\nimport math\n\n\ndef initial_data(number):\n    count = 0\n    goree = number - 1\n    floor = number // 2\n    while goree % 2 == 0:\n        goree //= 2\n        count += 1\n    results = [floor, count]\n    return results\n\n\ndef test_values(num):\n    test_vals = []\n    if num < 2047:\n        test_vals = [2]\n    elif num < 1373653:\n        test_vals = [2, 3]\n    elif num < 9080191:\n        test_vals = [31, 73]\n    elif num < 25326001:\n        test_vals = [2, 3, 5]\n    elif num < 3215031751:\n        test_vals = [2, 3, 5, 7]\n    elif num < 4759123141:\n        test_vals = [2, 7, 61]\n    elif num < 1122004669633:\n        test_vals = [2, 13, 23, 1662803]\n    elif num < 2152302898747:\n        test_vals = [2, 3, 5, 7, 11]\n    elif num < 3474749660383:\n        test_vals = [2, 3, 5, 7, 11, 13]\n    elif num < 341550071728321:\n        test_vals = [2, 3, 5, 7, 11, 13, 17]\n    elif num < 3825123056546413051:\n        test_vals = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    elif num < 2**64:\n        test_vals = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    elif num < 318665857834031151167461:\n        test_vals = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    elif num < 3317044064679887385961981:\n        test_vals = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n    return test_vals\n\n\ndef rabin_miller(num):\n    base_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\n                   101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\n                   199, 211, 223, 227, 229, 233, 239,241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,\n                   317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449,\n                   457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521,523, 541, 547, 557, 563, 569, 571, 577, 587,\n                   593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661,673, 677, 683, 691, 701, 709,\n                   719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853,\n                   857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991,\n                   997]\n    if num <= 1:\n        return False\n    elif num in base_primes:\n        return True\n    else:\n\n        for value in base_primes:  # making sure value does not have prime factors in\n            if num not in base_primes and num % value == 0:\n                return False\n        data = initial_data(num)\n        s = data[1]\n        d = data[0]\n        res = False\n        testing_values = []\n        if num < 3317044064679887385961981:\n            testing_values = test_values(num)  # Get values of a to be used from test_values\n        else:\n            testing_values = [2, min(num - 1, int(2 * (math.log1p(num - 1))**2))]\n        for a in testing_values:\n            for r in range(1, s + 1):\n                power = (2**r)*d\n\n                if pow(a, d, num) != 1 and pow(a, power, num) != 1:\n                    res = False\n\n                elif pow(a, d, num) == 1 or pow(a, power, num) == 1:\n                    return True\n                else:\n                    continue\n        if res:\n            return False\n        else:\n            return False\n\nprint(rabin_miller(5547337572376305111955330958342147474062293202868155909393))\n```\n\n\nThis will work very fast for values greater than 64-bits, any hint and comment aimed at improving this code both in accuracy and efficiency (time efficiency) are welcomed. \n\n\n  The base_primes list was obtained using and improved version of the\n  code in this question: Primality testing: How to make sure not to\n  test numbers which are multiples of already tested numbers?\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Mersenne primes using Lucas-Lehmer primality test\r\n                \r\nHere is the code, where ```\nlimit = 8```\n:\n```\n#include <stdio.h>\n#include <math.h> // pow(x, exp)\n\n//----------------------------------------------------------\n\nchar isMersenneLucasLehmer(unsigned int prime)\n{\n    unsigned int i, termN = 4;\n    unsigned long mersenne;\n    unsigned int limit;\n    int res;\n\n    mersenne = (unsigned long) pow(2, (double)prime) - 1;\n    if (prime % 2 == 0)\n    {\n        return prime == 2;\n    }\n    else \n    {\n        res = (int) sqrt((double) prime);\n        for (i = 3; i <= res; i += 2)\n        {\n            if (prime % i == 0)\n            {\n                return 0;  \n            }\n        }\n\n        limit = prime - 2;\n        for (i = 1; i <= limit; ++i)\n        {\n            termN = (termN * termN - 2) % mersenne;\n        }\n    }\n    return termN == 0;\n}\n//----------------------------------------------------------\n\n/*\n    Function: findMersenneLucasLehmer()\n\n*/\nvoid findMersenneLucasLehmer(unsigned int limit)\n{\n    unsigned int i, current = 0;\n    unsigned long mersenne, bitsInLong = 64;\n\n    for (i = 2; i <= bitsInLong; i++)\n    {\n        if (current >= limit)\n        {\n            break;\n        }\n\n        if (isMersenneLucasLehmer(i))   \n        {\n            mersenne = (unsigned long) pow(2, (double)i) - 1;\n            printf(\"current = %lu, mersenne = %lu, index = %u\\n\", current, mersenne, i);\n            ++current;\n        } \n    }\n}\n//----------------------------------------------------------\n\nint main()\n{\n    unsigned int limit = 8;\n    findMersenneLucasLehmer(limit);\n    return 0;\n}\n```\n\nOutput:\n```\ncurrent = 0, mersenne = 3, index = 2\ncurrent = 1, mersenne = 7, index = 3\ncurrent = 2, mersenne = 31, index = 5\ncurrent = 3, mersenne = 127, index = 7\ncurrent = 4, mersenne = 8191, index = 13\n```\n\nIt is only returning the first ```\n5```\n instead of ```\n8```\n and I can't figure out why.\n\nUpdate:\nit is skipping all the indexes from 13 and on. I suspect that the error is in somewhere in the last lines of ```\nisMersenneLucasLehmer(unsigned int)```\n. I've been staring for too long and couldn't find it.\n    ", "Answer": "\r\nChange this:\n\n```\nunsigned int termN = 4;\n```\n\n\nto this:\n\n```\nunsigned long int termN = 4;\n```\n\n\nmostly because you later do ```\ntermN * termN```\n which is likely to cause an overflow when a type of ```\nunsigned int```\n.\n\nOutput:\n\n```\ncurrent = 0, mersenne = 3, index = 2\ncurrent = 1, mersenne = 7, index = 3\ncurrent = 2, mersenne = 31, index = 5\ncurrent = 3, mersenne = 127, index = 7\ncurrent = 4, mersenne = 8191, index = 13\ncurrent = 5, mersenne = 131071, index = 17\ncurrent = 6, mersenne = 524287, index = 19\ncurrent = 7, mersenne = 2147483647, index = 31\n```\n\n\n\n\nIt would be nice to print your types as you ought to:\n\n```\nC02QT2UBFVH6-lm:~ gsamaras$ gcc -Wall main.c\nmain.c:58:67: warning: format specifies type 'unsigned long' but the argument has type 'unsigned int' [-Wformat]\n            printf(\"current = %lu, mersenne = %lu, index = %u\\n\", current, mersenne, i);\n                              ~~~                                 ^~~~~~~\n                              %u\n```\n\n\nSo change ```\n%lu```\n to ```\n%u```\n.\n\n\n\nHow did I start debugging?\n\nBy using a print statement in the start of your loop, like this:\n\n```\nfor (i = 2; i <= bitsInLong; i++)\n{\n    printf(\"Loop i = %u, current = %u\\n\", i, current);\n    ...\n```\n\n\nYou will see this:\n\n```\ncurrent = 4, mersenne = 8191, index = 13\nLoop i = 14, current = 5\n...\nLoop i = 63, current = 5\nLoop i = 64, current = 5\n```\n\n\nwhich means that you don't see 8 Mersenne numbers, because you are ending your loop, before your function fins 8 of them!\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Testing for primes\r\n                \r\nI'm trying to write a simple Python (ver 3.5) code for testing a given integer for primality. When I input 97 (for example) I get four ```\nTrue```\n outputs.\nWhat am I doing wrong?\n\n```\n# Testing for primality: True or False 25.11.2015\n# True means prime, False means divisible\n\nnum = int(input('Input an integer for primality test: '))\n\nif num < 2 or num % 2 == 0:\n    print('False')\nelse:\n    for i in range(3, int(num ** (1/2)) + 1, 2):\n        if num % i == 0:\n            print('False')\n            break\n        else:\n            print('True')\n```\n\n    ", "Answer": "\r\nJust unindent the last two lines:\n\n```\n# Testing for primality: True or False 25.11.2015\n# True means prime, False means divisible\n\nnum = int(input('Input an integer for primality test: '))\n\nif num < 2 or num % 2 == 0:\n    print('False')\nelse:\n    for i in range(3, int(num ** (1/2)) + 1, 2):\n        if num % i == 0:\n            print('False')\n            break\n    else:\n        print('True')\n```\n\n\nIn Python, ```\nfor```\n can have an ```\nelse```\n clause that only is called when the ```\nfor```\n loop naturally exhausts its iteration.  So if you ```\nbreak```\n from a ```\nfor```\n loop it won't print ```\nTrue```\n.  It prevents what other languages need a ```\nflag```\n for that is tested outside the loop as seen in another answer.\n\nYou have an additional error, though, in that ```\n2```\n returns ```\nFalse```\n.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why is filtering by primality in an inifinite stream of numbers taking forever if processed in parallel?\r\n                \r\nI'm creating an infinite stream of Integers starting at 200 Million, filter this stream using a naive primality test implementation to generate load and limit the result to 10.\n\n```\nPredicate<Integer> isPrime = new Predicate<Integer>() {\n    @Override\n    public boolean test(Integer n) {\n        for (int i = 2; i < n; i++) {\n            if (n % i == 0) return false;   \n        }\n        return true;\n    }\n};\n\nStream.iterate(200_000_000, n -> ++n)\n    .filter(isPrime)\n    .limit(10)\n    .forEach(i -> System.out.print(i + \" \"));\n```\n\n\nThis works as expected.\n\nNow, if I add a call to parallel() before filtering, nothing is produced and the processing does not complete.\n\n```\nStream.iterate(200_000_000, n -> ++n)\n    .parallel()\n    .filter(isPrime)\n    .limit(10)\n    .forEach(i -> System.out.print(i + \" \"));\n```\n\n\nCan someone point me in the right direction of what's happening here?\n\nEDIT: I am not looking for better primality test implementations (it is intended to be a long running implementation) but for an explanation of the negative impact of using a parallel stream.\n    ", "Answer": "\r\nProcessing actually completes, though may take quite a long time depending on number of hardware threads on your machine. API documentation about limit warns that it might be slow for parallel streams.\n\nActually the parallel stream first splits the computation to the several parts according to the available parallelism level, performs a computation for every part, then join the results together. How many parts do you have in your task? One per common FJP thread (=```\nRuntime.getRuntime().availableProcessors()```\n) plus (sometimes?) one for current thread if it's not in FJP. You can control it adding\n\n```\nSystem.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\", \"4\");\n```\n\n\nPractically for your task the lower number you set, the faster it will compute.\n\nHow to split the unlimited task? You particular task is handled by IteratorSpliterator which trySplit method creates chunks of ever-increasing size starting from 1024. You may try by yourself:\n\n```\nSpliterator<Integer> spliterator = Stream.iterate(200_000_000, n -> ++n).spliterator();\nSpliterator[] spliterators = new Spliterator[10];\nfor(int i=0; i<spliterators.length; i++) {\n    spliterators[i] = spliterator.trySplit();\n}\nfor(int i=0; i<spliterators.length; i++) {\n    System.out.print((i+1)+\": \");\n    spliterators[i].tryAdvance(System.out::println);\n}       \n```\n\n\nSo the first chunk handles numbers of range 200000000-200001023, the second handles numbers of range 200001024-200003071 and so on. If you have only 1 hardware thread, your task will be split to two chunks, so 3072 will be checked. If you have 8 hardware threads, your task will be split to 9 chunks and 46080 numbers will be checked. Only after all the chunks are processed the parallel computation will stop. The heuristic of splitting the task to such a big chunks doesn't work good in your case, but you would see the performance boost had the prime numbers around that region appear once in several thousand numbers.\n\nProbably your particular scenario could be optimized internally (i.e. stop the computation if the first thread found that limit condition is already achieved). Feel free to report a bug to Java bug tracker.\n\n\n\nUpdate after digging more inside the Stream API I concluded that current behavior is a bug, raised an issue and posted a patch. It's likely that the patch will be accepted for JDK9 and probably even backported to JDK 8u branch. With my patch the parallel version still does not improve the performance, but at least its working time is comparable to sequential stream working time.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin primality test gives wrong answer\r\n                \r\nI'm trying to make a RSA algorithm. For that i need rabin-miller+witness+modular exponentiation(at least I'm required to use that). The problem comes when i generate random numbers to check with rabin miller if they are primes, and the result is that non-prime numbers are prime for rabin-miller algorithm. Could somebody give me a hand to see where i fail.\nThanks in advance.\n\n```\nint mod_exp(int a, int b, int n){\n\n    int d = 1,i,j=0;\n    int binary[15];\n    for(i=0;i<=15;i++){\n        binary[i] = -1;\n    }\n    i=0;\n    do{\n        binary[i]=(b%2);\n\n            if((b%2)==1)\n                b=(b-1)/2;\n            else\n                b=b/2;\n        i++;\n    }while(b!=0);\n\n    do{\n        d= (d*d)%n;\n        if(binary[i]==1)\n            d=(d*a)%n;\n        i--;\n    }while(i!=-1);\n    return d;\n\n}\n\nbool wittness(int a, int n){\n    int u=n-1,k=0;\n    long x, temp;\n    while(u%2== 0 ){\n        u=u/2;\n        k++;\n    }\n    x=mod_exp(a,u,n);\n    for(int i=1;i<=k;i++){\n        temp=x;\n        cout<< \"primera x:\"<<x<<endl;\n        x=long(x*x)%n;\n        cout<< \"segunda x:\"<<x<<endl;\n        if(x==1 && temp!=1 && temp != n-1)\n            return true;\n\n    }\n    if(x!=1)\n        return true;\n    return false;\n\n}\n\n\nbool miller_rabin(int n, int s){\n\n    int a,j;\n    srand(time(NULL));\n\n    for(j = 0; j<=s;j++){\n\n       a=rand()%s+1;\n       if(!wittness(a,n))\n        return false;\n    }\n    return true;\n}\n```\n\n    ", "Answer": "\r\nI haven't looked at all of the code, but your mod_exp function is certainly incorrect. The two expressions ```\n(d*d)%n```\n and ```\n(d*a)%n```\n are both susceptible to overflow, and if overflow occurs you will get an incorrect result.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Find n primes after a given prime number, without using any function that checks for primality\r\n                \r\nHow to write a Program to find n primes after a given number?\ne.g. first 10 primes after 100, or first 25 primes after 1000.\nEdited:\n below is what I tried. I am getting output that way, but can we do it without using any primality-testing function?\n\n```\n#include<stdio.h>\n#include<conio.h>\nint isprime(int);\nmain()\n{\n    int count=0,i;\n    for(i=100;1<2;i++)\n    {\n        if(isprime(i))\n        {\n            printf(\"%d\\n\",i);\n            count++;\n            if(count==5)\n                break;\n        }\n    }\n    getch();\n}\nint isprime(int i)\n{\n    int c=0,n;\n    for(n=1;n<=i/2;n++)\n    {\n        if(i%n==0)\n        c++;\n    }\n    if(c==1)\n        return 1;\n    else\n        return 0;\n}\n```\n\n    ", "Answer": "\r\nSure. Read about the Sieve of Eratosthenes. Instead of checking for primality, you generate prime numbers.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Trans-compiling Python aks primality test to JavaScript\r\n                \r\nI am trans-compiling this Python code:\n\n```\ndef expand_x_1(p):\n    ex = [1]\n    for i in range(p):\n        ex.append(ex[-1] * -(p-i) / (i+1))\n    return ex[::-1]\ndef aks_test(p):\n    if p < 2: return False\n    ex = expand_x_1(p)\n    ex[0] += 1\n    return not any(mult % p for mult in ex[0:-1])\nfor p in range(101):\n    if aks_test(p):\n        print(p)\n```\n\n\nInto JavaScript. Here is what I have done so far:\n\n```\nfunction expand_x_1(p){\n    var ex = [1];\n    for(i = 0; i < p; i++){\n        ex.push(ex[ex.length - 2] * -(p-i) / (i+1));\n    }\n    return ex.reverse();\n}\nfunction aks_test(p){\n    if(p < 2)\n        return false;\n    var ex = expand_x_1(p);\n    ex[0] += 1;\n    // the return part right here is what I need help with.\n}\n// Python equivalent of any()\nfunction any(iterable){\n    for(element in iterable)\n        if(element)\n            return true;\n    return false;\n}\n```\n\n\nI just need help converting this line of Python code into JavaScript:\n\n```\nreturn not any(mult % p for mult in ex[0:-1])\n```\n\n\nThanks!\n    ", "Answer": "\r\nYour JavaScript implementation of ```\nany```\n will not work with Arrays. You better be using ```\nArray.prototype.some```\n (and ```\nArray.prototype.every```\n for Python's ```\nall```\n).\n\nSince we don't have generator expressions, in JavaScript, you can do\n\n```\nreturn ex.slice(0, -1).some(function(currentItem) {\n    currentItem % p;\n});\n```\n\n\nWe ```\nslice```\n the array, so we can exclude the last element.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How do i improve the complexity of this randomized primality testing algorithm?\r\n                \r\nI wrote the following program which returns 1 if a number is prime and 0 if it is composite. \nThough there's a possibility of falsely identifying a composite  as prime .I want suggestions on improving(decreasing) the time complexity for the following algorithm.\n\n```\nint compute(int n)\n{\n    int x;\n    for(int i = 1; i < 100 * sqrt(n); i++)\n    {\n        x = rand() % ((int)sqrt(n) + 1);\n        if(x != 0 && x != 1 && x!=n)\n        {\n            if(n % x == 0)\n            return 0;\n        }\n    }\n    return 1;\n}\n```\n\n    ", "Answer": "\r\nYou might want to take a look at the Miller-Rabin primality test. In this test\nyou use a series of \"witness\" values and perform some calculations.  Each witness\ncalculation gives a result of \"composite\" or \"possibly prime\".  If you use k witnesses\nand they all give \"possibly prime\" results, the probability that the number is actually\ncomposite is 1/4^k.\n\nThe runtime is O(k log^3 n), which is a substantial improvement over your O(sqrt(n))\nalgorithm.  \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "C++ and way-too-big numbers (Miller-Rabin primality test; calculating a power with pow() and then applying the modulo operator)\r\n                \r\nI had to write a code, that determines whether a number is prime or not via Miller-Rabin primality test.\nThe code here:\n```\n#include <iostream>\n#include <time.h>\n#include <cmath>\n#include <stdio.h>  \n\nusing namespace std;\n\nint main()\n{\n    srand(time(0));\n    int m, r, st, a, x, t,st2;\n    cout << \"Введите число m: \";\n    cin >> m;\n    cout << \"Введите число r: \";\n    cin >> r;\n    t = m - 1;\n    st = 0;\n\n    while (t % 2 == 0)\n    {\n        st = st + 1;\n        t = t / 2;\n    }\n\n    for (int i = 0; i < r; i++)\n    {\n        a = rand() % (m - 1) + 1;\n        int y = int(pow(a, t));\n        if ((int(pow(a, t))) == (1 % m))\n        {\n            cout << \"Number \" << m << \" is probably prime\" << endl;\n            exit(0);\n        }\n        for (int j = 0; j < st - 1; j++)\n        {\n            st2 = int(pow(2, i));\n            x = int(pow(a, st2 * t));\n            if (x == -1 % m)\n            {\n                continue;\n            }\n            else\n            {\n                cout << \"Number \" << m << \" is composite\" << endl;\n                exit(0);\n            }\n        }\n    }\n    cout << \"Number \" << m << \" probably prime\" << endl;\n}\n```\n\nIt did pretty well with small numbers like 221, 12 etc. But i had a bunch of numbers and on one of them, number 2633, something went wrong: this number is prime, but program says it's not. I did a line by line run and noticed it is stucks on line\n```\nif ((double(pow(a, t))) == (1 % m))```\n\nThe problem here is that it needs to evaluate power 329 for some random number between 1 and 2632. For example we'll take 1595 (one of the numbers taken randomly during debug). Now we evaluate\n```\nint y = int(pow(a, t))```\n\n(took it for debug to see what it evaluates) and working with Windows Calculator we're getting this number:\n5,1081795295996211569794748579036e+1053\nand the program gets -2147483648... Every time...\nI don't know exactly where is the problem - in pow function or in number types. Also tried double instead of int but it didn't work (i guess because 5 * 10^1053 is way bigger than double's 1.5 * 10^308)\nHow do i solve that problem and get it to work?\n    ", "Answer": "\r\nThis\n```\nif ((int(pow(a, t))) == (1 % m))\n```\n\nis very wrong. First of all ```\n1 % m```\n is just ```\n1```\n for any ```\nm > 1```\n. And indeed, Miller–Rabin needs\n```\nif ( int(pow(a, t)) % m == 1 )\n```\n\nkind of tests. This is how you perform modular arithmetic in programming languages and you should modify your algorithm to use this approach everywhere, e.g. ```\n(x == -1 % m)```\n should be replaced with ```\n(x % m == m-1)```\n (because ```\n%```\n always returns a nonnegative value for nonnegative input and ```\n-1```\n corresponds to ```\nm-1```\n in modular arithmetic).\nSecondly, yes, this will go out of range very quickly. Calculating a power and then applying modulo operator is not a valid approach for big numbers. What you should do is to implement one of modular exponentiation algorithms instead. The simplest solution is\n```\nint modular_pow(int base, int exponent, int modulus) {\n    if (modulus == 1) return 0;\n    \n    int c = 1;\n    for (int i = 0; i < exponent; i++)\n        c = (1LL * c * base) % modulus;  // 1LL to avoid overflow\n\n    return c;\n}\n```\n\nNot very efficient but at least will do the job. And then you check\n```\nif (modular_pow(a,t,m) == 1)\n```\n\nThirdy, you use ```\nint(pow(...))```\n conversion, which can lead to numerical errors, since ```\npow```\n returns a floating point value. But you need exact values to perform exact modular arithmetic. Do not use ```\npow```\n in such cases. Read more about integer pow here: The most efficient way to implement an integer based power function pow(int, int) Although let me remind you that modular exponentiation is what you really need here.\nIt is possible that there are other issues with your Miller-Rabin's implementation, but these three are the biggest I see.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test involving Wilson's theorem not working as planned\r\n                \r\nI'm just getting started with programming and I've run into a problem I can't seem to figure out. I've written this function, ```\nisPrime```\n that seems to always pass the equality test. I can confirm that the ```\nfactorial```\n function works because I had separately tested it.\n\nWilson's theorem states that a number p is prime if (p - 1)! + 1 is a multiple of p.\n\n```\n#include <stdio.h>\n#include <math.h>\n\nvoid isPrime(double p);\ndouble factorial(double n);\n\nint main(void) {\n    double userInput;\n    while(1) {\n        scanf(\"%lf\", &userInput);\n        isPrime(userInput);\n    }\n    return 0;\n}\n\n//\n\ndouble factorial(double n) {\n    if(n <= 1)\n        return n;\n    else\n        return n * factorial(n - 1);\n}\n\nvoid isPrime(double p) {\n    if(modf(factorial(p - 1) + 1, &p) == 0)\n        printf(\"Prime!\\n\");\n    else\n        printf(\"Not prime!\\n\");\n}\n```\n\n    ", "Answer": "\r\nDon't use doubles to hold integers. Roundoff error will make tests for equality completely bogus. See \"What Every Computer Scientist Should Know about Floating Point\".\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Optimising/correcting my miller rabin primality test in python\r\n                \r\nHere is my code:\n\n```\n    import random\ndef one_d(n):\n    b = n\n    # initialize n\n    s = 0\n    # while loop, terminating when s becomes odd\n    while n % 2 == 0:\n        # increment s\n        s = s+1\n        # divide n by 2\n        n = n/2\n    tuple1 = tuple([s,n])\n    return tuple1\n    print \"2^\",s,\"*\",n,\"=\", b\ndef miller_rabin(n, a):\n    list1 = []\n    tuple1 = one_d(n-1)\n    for r in xrange(tuple1[0]):\n        list1.append((a**(2**(r)*tuple1[1])) % n)\n        if list1[r] == n-1 or list1[r] == 1:\n            return \"True\"\n    else:\n        return \"False\"\ndef isprime(n):\n    for i in xrange(10):\n        a = random.randrange(2, n-1)\n        if miller_rabin(n, a) == \"False\":\n            return \"False\"\n    return \"True\n```\n\n\nAs I understand it, this test should be able to deal with very large numbers, but my script gets stuck on numbers like 50034901. I'm assuming I've made an error/ grave inefficiency somewhere - since my script still works for smaller numbers. \n    ", "Answer": "\r\nOk after further investigating I realised it's because I'm using the \"%\" code to perform my modulus calculation which is much more inefficient than using python's 'pow' function. The former calculates the full exponent before calculating the modulus, and thus has to deal with very large numbers. The latter goes in steps, re-adjusting by modulus n each time and thus is more efficient\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How does this primality test make the code 5000x faster?\r\n                \r\nWarning: This code is a solution for Project Euler Problem 50. If you don't want it spoiled, don't look here.\n\nHere I have code that searches for a long sequence of consecutive prime numbers, which summed together are also a prime. At one point, I need to test whether a sum is prime.\n\nI have two tests, which are ifdef'd in the function computeMaxPrime. The first checks the sum against a std::set of prime numbers. The second uses a Miller-Rabin test implemented by GMP. The function only gets called 6 times. When I use the first test, the function computeMaxPrime takes .12 seconds. When I use the second test, it only takes ~.00002 seconds. Can someone explain how that's possible? I wouldn't think 6 calls to check whether a number is in a set would take 100 ms. I also tried using an unordered_set, and it performs the same.\n\nI thought that maybe it was a timing issue, but I've verified it via timing the whole program execution from Terminal (on OSX). I've also verified that if I change the test to use the Miller-Rabin test first, and then confirm using the set, it makes a single call to the set and the clock reports .02 seconds, exactly what I would expect (1/6th the total time of only using the set test).\n\n```\n#include \"PrimeGenerator2.h\"\n#include <set>\n#include <stdio.h>\n#include <time.h>\n#include <gmp.h>\n\ntypedef std::set<u_int64t>       intSet;\n\nbool isInIntSet (intSet       set,\n                 u_int64t     key)\n{\n  return (set.count(key) > 0);\n}\n\nbool isPrime (u_int64t key)\n{\n  mpz_t      integ;\n\n  mpz_init (integ);\n  mpz_set_ui (integ, key);\n  return (mpz_probab_prime_p (integ, 25) > 0);\n}\n\nvoid computeInitialData (const u_int64t   limit,\n                         intSet      *primeSet,\n                         intList     *sumList,\n                         u_int64t    *maxCountUpperBound)\n{\n  PrimeSieve     sieve;\n  u_int64t     cumSum = 0;\n  u_int64t     pastUpperBound = 0;\n\n  *maxCountUpperBound = 0;\n\n  for (u_int64t prime = sieve.NextPrime(); prime < limit; prime = sieve.NextPrime()) {\n    primeSet->insert(prime);\n\n    cumSum += prime;\n    sumList->push_back(cumSum);\n    if (cumSum < limit)\n      (*maxCountUpperBound)++;\n    else\n      pastUpperBound++;\n  }\n}\n\nu_int64t computeMaxPrime (const u_int64t   limit,\n                          const intSet  &primeSet,\n                          const intList &sumList,\n                          const u_int64t   maxCountUpperBound)\n{\n  for (int maxCount = maxCountUpperBound; ; maxCount--) {\n    for (int i = 0; i + maxCount < sumList.size(); i++) {\n      u_int64t   sum;\n\n      sum = sumList[maxCount + i] - sumList[i];\n      if (sum > limit)\n        break;\n#if 0\n      if (isInIntSet (primeSet, sum))\n        return sum;\n#else\n      if (isPrime (sum))\n        return sum;\n#endif\n    }\n  }\n\n  return 0; // This should never happen\n}\n\nu_int64t findMaxCount (const u_int64t   limit)\n{ \n  intSet       primeSet;  // Contains the set of all primes < limit\n  intList      sumList; // Array of cumulative sums of primes\n\n  u_int64t     maxCountUpperBound = 0;  // Used an initial guess for the maximum count\n  u_int64t     maxPrime;          // Final return value\n\n  clock_t      time0, time1, time2;\n\n  time0     = clock();\n  computeInitialData (limit, &primeSet, &sumList, &maxCountUpperBound);\n  time1     = clock();\n  maxPrime  = computeMaxPrime (limit, primeSet, sumList, maxCountUpperBound);\n  time2     = clock();  \n\n  printf (\"%f seconds for primes \\n\"  , (double)(time1 - time0)/CLOCKS_PER_SEC);\n  printf (\"%f seconds for search \\n\"  , (double)(time2 - time1)/CLOCKS_PER_SEC);  \n\n  return maxPrime;\n}\n\nint main(void)\n{\n  printf (\"%lld\\n\", findMaxCount(1000000));\n}\n```\n\n\nEDIT: Oh it's even weirder. Appears to have nothing to do with the STL set. If I do a hack to make isInIntSet just check how many times it's been called, it's equally slow compared to the GMP test. This makes me think I've likely just run across a compiler bug (EDIT2: Never blame the compiler!)\n\n```\nbool isInIntSet (intSet set, u_int64t key)\n{\n  static int  counter = 0;\n  counter++;\n  return (counter == 6);\n}\n```\n\n    ", "Answer": "\r\nDuh. The function isInIntSet is taking an intSet as an argument directly, so the entire set is being copied. I meant to pass by reference (intSet &set). That takes the search time down to .000003 seconds with an unordered_set.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test. Is this program performing faster than all others?\r\n                \r\n```\nbool is_prime(BigInt num)\n{\n    if(num == 0 || num == 1 || (num != 2 && num % 2 == 0))\n        return false;\n\n        BigInt sq = sqrt(num);\n\n        for(BigInt i = 3; i <= sq; i += 2)\n            if(num % i == 0)\n                 return false;\n\n       return true;\n}\n```\n\nWe only need to check upto square root.\nProof -> https://scienceparv.blogspot.com/2021/07/mathematics-if-one-divisor-of-dividend.html\n    ", "Answer": "\r\nYour code is doing so called Trial Division primality test, which is slow for big numbers. It has time complexity ```\nO(Sqrt(N))```\n of primitive operations.\nIf you have really big numbers, 1024 bits or bigger then Trial Division will be a way too slow.\nThere are two kinds of Primality Tests - deterministic and probabilistic. Trial Division is one example of deterministic algorithm. All deterministic algorithms are much slower then probabilitic.\nProbabilistic algorithms are never certain about if a number is really prime. But for any small chosen probability ```\nP```\n they can tell in very little computational time if the number is prime with certainty of this probability. Deterministic algorithm are always certain if a number is prime or not.\nThere exist faster than yours algorithms of deterministic primality testing, for example Elliptic Curve Primality Test, which is fast but difficult to implement. But you can easily test any number for free with fast software like Primo for Linux, this is free software but with closed sources and for Linux only (there is no Windows version at all).\nI decided to implement for you from scratch one probabilistic primality test, which is Fermat Primality Test, it is very fast and easy to implement in few lines of code, which I did in below C++ code. It has complexity of ```\nO(Log2(N))```\n which is blazingly fast time even for 20000-bit numbers.\nTry it online!\n```\n#include <cstdint>\n#include <iostream>\n\nusing Word = uint32_t;\nusing DWord = uint64_t;\n\nWord PowMod(Word a, Word b, Word const & c) {\n    // https://en.wikipedia.org/wiki/Modular_exponentiation\n    Word r = 1;\n    while (b != 0) {\n        if (b & 1)\n            r = (DWord(r) * a) % c;\n        a = (DWord(a) * a) % c;\n        b >>= 1;\n    }\n    return r;\n}\n\nWord Rand(Word const & prev, Word const & begin, Word const & end) {\n    Word constexpr magic_prime = uint32_t(-1) - 4;\n    return Word((DWord(prev) * magic_prime) % (end - begin)) + begin;\n}\n\nbool IsFermatProbablePrime(Word const & n, int trials = 32) {\n    // https://en.wikipedia.org/wiki/Fermat_primality_test\n    if (n <= 16)\n        return n == 2 || n == 3 || n == 5 || n == 7 || n == 11 || n == 13;\n    Word witness = 2;\n    for (size_t i = 0; i < trials; ++i) {\n        witness = Rand(witness, 2, n - 2);\n        if (PowMod(witness, n - 1, n) != 1)\n            return false;\n    }\n    return true;\n}\n\nint main() {\n    Word const prime_num = 3941362591U, comp_num = 2245837171U;\n    std::cout\n        << std::boolalpha\n        << \"num1 is prime: \" << IsFermatProbablePrime(prime_num) << \", \"\n        << \"num2 is prime: \" << IsFermatProbablePrime(comp_num)  << std::endl;\n}\n```\n\nOutput:\n```\nnum1 is prime: true, num2 is prime: false\n```\n\n(and really first number ```\nprime_num```\n is prime and second ```\ncomp_num```\n is composite)\nYou can see that I used two typedefs for ```\nWord```\n and ```\nDWord```\n, like this:\n```\nusing Word = uint32_t;\nusing DWord = uint64_t;\n```\n\nThis kind of typedefs only allow you to check primality of 32-bit numbers, for your case to check big numbers just replace with:\n```\nusing Word = BigInt;\nusing DWord = BigInt;\n```\n\nto use your class ```\nBigInt```\n that you already used in your code.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Test for the Primality of Mersenne numbers\r\n                \r\nplease assist in solving this problem;\n\nFor a given Mersenne number with exponent p, the number is prime if the Lucas-Lehmer series is 0 at position p - 2. Write a function that tests if a Mersenne number with exponent p is prime. Test if the Mersenne numbers with prime p between 3 and 65 are prime. Your final answer should be a list of tuples consisting of (Mersenne exponent, 0) or (1) for each Mersenne number you test, where 0 and 1 are replacements for 'False' and 'True' respectively. Shown below is my attempted solution\n\n```\n#function to define a mersenne number\ndef mersenne_number(p):\n    return 2**p - 1\n\n#function to generate the Lucas-Lehmer sequence\ndef lucas_lehmer(p):\n    ll_seq = [4]\n    if p > 2:\n        for i in range(1, (p - 2) + 1):\n            n_i = (ll_seq[i-1] ** 2 - 2)%(2**p - 1)\n            ll_seq.append(n_i)\n    return ll_seq\n\n#To generate a list of Tuples consisting of (mersenne exponents, 1 or 0), 1 and 0 represent True and False respectively.\nmersenne_primes = []\n\ndef ll_prime(num1, num2):\n    for p in range(3, 65):\n        if lucas_lehmer(p)[-1] == 0:\n            mersenne_primes.append((p, 1))\n        else:\n            mersenne_primes.append((p, 0))\n\n    print(mersenne_primes)\n```\n\n\nI am getting a wrong output at this stage. The function is returning prime mersenne exponents as not prime meaning 0.\n    ", "Answer": "\r\nI implemented the Lucas Lehmer test from the psuedocode on it's wikipedia page here:\n```\ndef LucasLehmer(p):\n   if p == 2:\n     return True\n   s = 4\n   M = pow(2, p) - 1\n   for x in range (1, (p-2)+1):\n      s = ((s * s) - 2) % M\n   if s == 0: return True\n   else: return False\n\nfor x in range(2,10000): \n   if LucasLehmer(x): \n      print(f\"2**{x}-1 is Prime\") \n                                                                                                                                                           \n2**2-1 is Prime\n2**3-1 is Prime\n2**5-1 is Prime\n2**7-1 is Prime\n2**13-1 is Prime\n2**17-1 is Prime\n2**19-1 is Prime\n2**31-1 is Prime\n2**61-1 is Prime\n2**89-1 is Prime\n2**107-1 is Prime\n2**127-1 is Prime\n2**521-1 is Prime\n2**607-1 is Prime\n2**1279-1 is Prime\n2**2203-1 is Prime\n2**2281-1 is Prime\n\n\n```\n\nI also changed the math around to make it a factorization engine, if your interested in using it for factoring here it is:\n```\nimport math\n\ndef PrimeFinderLucasLehmer4(N):\n   p = 1<<N.bit_length()-1\n   if N == 2:\n     return 2\n   if N == 3:\n     return 3\n   s = 4\n   M = pow(p, 2) - 1\n   for x in range (1, 100000):\n     s = (((s * N ) - 2 )) % M\n     xx = [math.gcd(s, N)] + [math.gcd(s*p+x,N) for x in range(7)] + [math.gcd(s*p-x,N) for x in range(1,7)] \n     try:\n        prime = min(list(filter(lambda x: x not in set([1]),xx)))\n     except:\n        prime = 1\n     if prime == 1:\n        continue\n     else:\n        break\n   #print (s, x, prime, xx)\n   return prime\n\n\nIn [70]: PrimeFinderLucasLehmer4(1009732533765211)                                                                                                                                        \nOut[70]: 11344301\n\nAnd from https://stackoverflow.com/questions/4078902/cracking-short-rsa-keys\n\nIn [71]: PrimeFinderLucasLehmer4(10142789312725007)                                                                                                                                       \nOut[71]: 100711423\n\n\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Is Rabin-Miller primality test algorithm using modular squaring correct?\r\n                \r\nI have recently come across this piece of code for Rabin-Miller algorithm, as decribed here:\n\n```\nfrom random import randint\n\n    def _bits_of_n(n):\n        \"\"\" Return the list of the bits in the binary\n            representation of n, from LSB to MSB\n        \"\"\"\n        bits = []\n\n        while n:\n            bits.append(n % 2)\n            n /= 2\n\n        return bits\n\n    def _MR_composite_witness(a, n):\n        \"\"\" Witness functions for the Miller-Rabin\n            test. If 'a' can be used to prove that\n            'n' is composite, return True. If False\n            is returned, there's high (though < 1)\n            probability that 'n' is prime.\n        \"\"\"\n        rem = 1\n\n        # Computes a^(n-1) mod n, using modular\n        # exponentation by repeative squaring.\n        #\n        for b in reversed(_bits_of_n(n - 1)):\n            x = rem\n            rem = (rem * rem) % n\n\n            if rem == 1 and x != 1 and x != n - 1:\n                return True\n\n            if b == 1:\n                rem = (rem * a) % n\n\n        if rem != 1:\n            return True\n        return False\n\n    def isprime_MR(n, trials=6):\n        \"\"\" Determine whether n is prime using the\n            probabilistic Miller-Rabin test. Follows\n            the procedure described in section 33.8\n            in CLR's Introduction to Algorithms\n\n            trials:\n                The amount of trials of the test.\n                A larger amount of trials increases\n                the chances of a correct answer.\n                6 is safe enough for all practical\n                purposes.\n        \"\"\"\n        if n < 2:\n            return False\n\n        for ntrial in xrange(trials):\n            if _MR_composite_witness(randint(1, n - 1), n):\n                return False\n\n        return True\n```\n\n\nI know that RM test should take N, decompose N-1 = t*(2^s) and then try to find a such that a^t != 1 and a^((2^r)t) != -1 for all 0 <= r < s\n\nBut this algorithm does something different. It reminds me partly of Fermats algorithm, where we test a^(n-1) mod n == 1, as it uses square and multiply to get a^(n-1) but checks if any of the intermediate results are congruent 1 mod n. \n\nI do not see how these 2 are equivalent, can you please explain why (x^2==1 and x != 1 and x!=n-1) works as a sufficient condition?\n\nThanks!\n    ", "Answer": "\r\nIf we find an intermediate result that is congruent to 1 (modulo n) and such that the previous result x was not congruent to 1 or -1 (i.e. n-1) modulo n, then this number x is a nontrivial square root of 1 modulo n (i.e. a number x such that x ≠ -1, 1 mod n but x^2 = 1 mod n). This means that n is composite. \n\nProof: Suppose for the sake of contradiction that x^2 is congruent to 1 modulo p, x is not 1 or -1 modulo p, and p is prime. This is equivalent to saying that p divides x^2 - 1 = (x-1)(x+1). Therefore, since p is prime, p divides x-1 or x+1, which means that x is congruent to 1 or -1 modulo p.\n\nThis is why (x^2==1 and x != 1 and x!=n-1) is a sufficient condition - this immediately implies that n is composite. Thus we can stop the algorithm early to save computational time.\n\nAs your link states (with a typo), a good explanation of this is found in section 31.8 of Introduction to Algorithms by Cormen, Leiserson, Rivest, and Stein, and some of my answer is adapted from that book.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Pollard Rho factorization method implementation\r\n                \r\nEvery time I factor a number using Pollard Rho factorization method is it necessary to check for its primality before Pollard Rho factorization ? If yes then I have to implement Miller Rabin's primality test or any primality test each time I want to factor any number and stil I have to take care of strong pseudoprimes , isn't it complex ? Is there any simpleand still faster way to handle this ? (I am using these tests on numbers upto 10 digits)\n    ", "Answer": "\r\nYes, you must check before you apply Pollard Rho that the number you are factoring is composite. If it is prime, the gcd step will always return 1, because a prime number is always co-prime to every other number, and Pollard Rho will run forever without result.\n\nFor numbers up to ten digits, Pollard Rho is not necessary. Simple trial division will be quick enough, since you only need the primes less than 100000, and there are only 9592 of them.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to test primality in Verilog?\r\n                \r\nI have the Verilog code shown below, and if I try to compile it I get an error message. The point is that I'm trying to manipulate an input, which as long as I know cannot be done in Verilog. The point is that I need check the following condition in Verilog:\n\n```\nstatic int prime(unsigned long long n)\n{\n    unsigned long long val = 1;\n    unsigned long long divisor = 5;\n\n    if (n == 2 || n == 3)\n        return 1;\n    if (n < 2 || n%2 == 0 || n%3 == 0)\n        return 0;\n    for ( ; divisor<=n/divisor; val++, divisor=6*val-1)\n    {\n        if (n%divisor == 0 || n%(divisor+2) == 0)\n            return 0;\n    }\n    return 1;\n}\n```\n\n\nAt the moment I have the following code: \n\n```\nmodule prime(clk, rst, start, A, ready, P);\n\ninput clk, rst, start;\ninput [7:0] A;\n\noutput ready, P;\n\nreg ready, P;\n\nwire [7:0] divisor;\nassign divisor = 5;\n\nwire [7:0] val;\nassign val = 1;\n\n\nalways @ (posedge clk or posedge rst) begin\n    if (!rst) begin\n        P <= 0;\n    end\n    else if (start) begin\n        case (A)\n            0 : P <= 1;\n            1 : P <= 1;\n            2 : P <= 1;\n            3 : P <= 1;\n        endcase\n\n        if (A%2 == 0 && A != 2) begin\n            P <= 0;\n        end\n        else begin\n            for( ; divisor <= A/divisor; val=val+1, divisor=6*val-1) begin\n                if (A%divisor == 0 || A%(divisor+2) == 0) begin\n                    P <= 0;\n                end\n            end\n\n            // need to set P to 1\n        end\n    end\nend\n\nendmodule\n```\n\n\nPlease also note I need to test primes in the form of 6n+1 or 6n-1, and I also need to assume in my code that 0 and 1 are also primes.\n\nIf I try the above code I get an error message saying: \n\n\n  Enhanced FOR loop is not enabled for verilog\n\n\nIf anyone can help me solve the error and finish my logic in Verilog, I would be glad.\n    ", "Answer": "\r\nThe Verilog BNF does not allow empty or compound statements in ```\nfor(;;)```\n. Change the file to *.sv to compile it under SystemVerilog rules. Otherwise change your for loop statement to have simple statements\n\n```\nfor( divisor =5; divisor <= A/divisor; divisor=6*val-1) begin\n                if (A%divisor == 0 || A%(divisor+2) == 0) begin\n                    P <= 0;\n                end\n                val++;\n            end\n```\n\n\nAlso, you can't make procedural assignments to wires. make them variables.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "why the iteration is done by i+6 every time and why the condition is i*i<=n for this prime testing function?\r\n                \r\nhttps://www.geeksforgeeks.org/primality-test-set-1-introduction-and-school-method/\n\n// A optimized school method based C++ program to check \n// if a number is prime \n\n```\n#include <bits/stdc++.h> \nusing namespace std; \n\nbool isPrime(int n) \n{ \n    // Corner cases \n    if (n <= 1)  return false; \n    if (n <= 3)  return true; \n\n    // This is checked so that we can skip  \n    // middle five numbers in below loop \n    if (n%2 == 0 || n%3 == 0) return false; \n\n    for (int i=5; i*i<=n; i=i+6) \n        if (n%i == 0 || n%(i+2) == 0) \n           return false; \n\n    return true; \n}\n```\n\n    ", "Answer": "\r\nWhen you search for primes you can loop through all the numbers between 2 and your number to see if they divide into your number.\n\n```\nfor (int i=2; i < n; i=i+1) \n    if (n%i == 0)\n       return false; \n```\n\n\nBut that checks a lot of number you don't need to.\nThe first observation (optimization) is that any multiple of 2 (even number) is already checked by simply doing a divide by 2 check once.\n\nSo now we do a check for 2 and then skip every other even character.\n\n```\nif (n%2 == 0 ) return false;\n\nfor (int i=3; i < n; i=i+2) \n    if (n%i == 0)\n       return false; \n```\n\n\nThe next observation (optimization) is that you can do nearly the same thing for three. So the first test covers all combinations of 2 and three. Now in the loop you skip every 6 numbers (2*3) and do some tests to cover all numbers that are not multiples of 2 or 3 that happen in between.\n\n```\nif (n%2 == 0 || n%3 == 0) return false; \n\nfor (int i=5; i<n; i=i+6) \n    if (n%i == 0 || n%(i+2) == 0) \n       return false; \n```\n\n\nSo this is simply an optimization that means you do not have to try every number.\n\nThe next observation we make is that you don't need to try numbers greater than the square root of n (these will never divide into n). So you can limit your loop to ```\ni*i < n```\n as ```\ni*i```\n is faster than ```\nsqrt(n)```\n.\n\n```\nif (n%2 == 0 || n%3 == 0) return false; \n\nfor (int i=5; i*i<=n; i=i+6) \n    if (n%i == 0 || n%(i+2) == 0) \n       return false; \n```\n\n\nThough personally I would do ```\nsqrt()```\n once rather than ```\ni*i```\n every time around the loop. But that may be slower for small values of ```\nn```\n.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "'Unexpected result from lpSolveAPI for primal test' error for Logistic Regression\r\n                \r\nI am trying build a logistic regression model in R and I am also using the 'safeBinaryRegression' package. When I enter the my model code and hit enter, I get the following message:\n\nError in separator(X, Y, purpose = \"find\") : \nunexpected result from lpSolveAPI for primal test\n\nI am not sure what this error means and how to resolve this. Does this mean that there is something wrong with my data or something else?\n\nI'd greatly appreciate if someone can help me to understand this error and how to resolve it.\n\nVery much appreciate your time and insights in advance.\n    ", "Answer": "\r\nI had the same problem. In the end it went away when I converted the response from a numeric variable to a factor. \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Multiplicative modular inverse using fermat's primality test (Assembly MIPS)\r\n                \r\nReceive two integers ```\na```\n and ```\np```\n and print ```\nx```\n such that ```\nax ≡ 1 (mod p)```\n \n```\np```\n is prime and ```\na```\n is not a multiple of p\nThe code works perfectly in MARS, but in QTSpim it complains about overlfow (```\nimmediate value 825265 out of range```\n) and accuses error when ```\np```\n and prime. Why this difference between the two?\n\n```\n    .data\nmessage1: .asciiz \"Invali Input\\n\"\nmessage2: .asciiz \"inverse = \"\nmessage3: .asciiz \"The module is not a prime\\n\"\nfinalLine: .asciiz \"\\n\"\n    .text\nmain:\n    li $v0, 5\n    syscall\n    move $t8, $v0\n    \n    li $v0, 5\n    syscall\n    move $t9, $v0\n    beq $t8, 2, verifyMult\n    ble $t8, 1, invalidInput\n    ble $t9, 1, invalidInput\n    \n    j pr\n\nverifyMult:\n    div $t9, $t8\n    mfhi $s1\n    beq $s1, 0, invalidInput\n    j modInverse\nmain3:  \n    li $v0, 4\n    la $a0, message2\n    syscall\n    \n    li $v0, 1\n    move $a0, $t4\n    syscall\n    \n    li $v0, 4\n    la $a0, finalLine\n    syscall\n    \n    li $v0, 10\n    syscall\n\ninvalidInput:\n    li $v0, 4\n    la $a0, message1\n    syscall \n    \n    li $v0, 10\n    syscall\n    \ninvalidMod:\n    li $v0, 4\n    la $a0, message3\n    syscall \n    \n    li $v0, 10\n    syscall\nmodInverse:\n    move $t0, $t8\n    move $t1, $t9\n    \n    addi $t2, $t0, 0 \n    addi $t3, $zero, 0\n    addi $t4, $zero, 1\n    while:\n        ble $t1, 1, exit  \n        div $t1, $t0\n        mflo $t5\n        addi $t6, $t0, 0\n        mfhi $t0\n        \n        addi $t1, $t6, 0\n        addi $t6, $t3, 0\n        \n        mult $t5, $t3\n        mflo $s0\n        \n        sub $t3, $t4, $s0\n        addi $t4, $t6, 0\n        j while \n        \n    exit:\n        blt $t4, 0, makePositive\n        j main3\n        \n    makePositive: \n        add $t4, $t4, $t2\n        j main3\n\npr: \n      add  $s5, $t8, $zero  \n      \n      andi $t1,$s5,1\n      beq $t1,$zero, invalidMod \n      \n      xor $t0,$t0,$t0\n      addiu $t0,$t0,561\n      beq $s5,$t0, invalidMod \n      \n      xor $t0,$t0,$t0\n      addiu $t0,$t0,1105\n      beq $s5,$t0, invalidMod \n      \n      xor $t0,$t0,$t0\n      addiu $t0,$t0,1729\n      beq $s5,$t0, invalidMod \n      \n      xor $t0,$t0,$t0\n      addiu $t0,$t0,2465\n      beq $s5,$t0, invalidMod\n      \n       xor $t0,$t0,$t0\n      addiu $t0,$t0,2821\n      beq $s5,$t0, invalidMod\n      \n      xor $t0,$t0,$t0\n      addiu $t0,$t0,6601\n      beq $s5,$t0, invalidMod \n      \n      xor $t0,$t0,$t0\n      addiu $t0,$t0,8911\n      beq $s5,$t0, invalidMod \n      \n      xor $t0,$t0,$t0\n      addiu $t0,$t0,10585\n      beq $s5,$t0, invalidMod\n      \n      addiu $t2,$t2,41041\n      beq $s5,$t2, invalidMod \n      \n      addiu $t3,$t3,825265\n      beq $s5, $t3 , invalidMod \n      \n      addiu $t4,$t4,321197185 \n      beq $s5,$t4, invalidMod \n      \n      move $s1,$s5\n      xor $t2,$t2,$t2\n\n      xor $t3,$t3,$t3\n     \n      xor $t4,$t4,$t4\n      addiu $t4,$t4,2 \n     \n     \nloop_exponent:\n     andi $t1,$s5,1      \n     beq $t1,$zero, even_exponent\n    \n     subiu $s5,$s5,1\n     \n     sll $t2,$t2,1   \n     addiu $t2,$t2,1   \n\n     j next_iteration   \n\neven_exponent:\n    sll $t2,$t2,1\n    srl $s5,$s5,1\n    \nnext_iteration:\n     addiu $t3,$t3,1      \n     bne $s5,$t4, loop_exponent      \n     \n\n     sll $t2,$t2,1\n     addiu $t3,$t3,1  \n    \n     xor $t5,$t5,$t5\n     addiu $t5,$t5,3\n     \n     xor $t6,$t6,$t6\n     addiu $t6,$t6,3\n     \nloop_compute_mod:\n     andi $t1,$t2,1      \n     beq $t1,$zero, even\n     \n     multu $t5,$t6\n     mflo $t5\n     divu $t5,$s1\n\n     mfhi $t5\n     j next_exponent_bit\neven:\n    multu $t5,$t5\n    mflo $t5\n    divu $t5,$s1\n\n    mfhi $t5\n \n next_exponent_bit:\n\n    subiu $t3,$t3,1\n    srl $t2,$t2,1\n    bgtz $t3, loop_compute_mod     \n     \n     divu $t6,$s1\n     mfhi $t6\n     \n     beq $t5,$t6,verifyMult\n     j invalidMod         \n      \n\n \n\n```\n\n    ", "Answer": "\r\nMARS allows treating every instruction as a pseudo-instruction, handling large immediates by constructing the value in another register.\nQtSpim is more like traditional MIPS assemblers that only treat a few instructions (like ```\nli```\n) as pseudo-instructions, not ```\naddiu```\n.\n```\n825265```\n doesn't fit in a 16-bit signed immediate.  Neither does ```\n41041```\n - SPIM should have complained about that, too.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why is factoring in NP, but not in P?\r\n                \r\nFactoring: Gven an integer N, find integers 1 < a, b < N such that N = ab if they exist, otherwise say N is prime.\n\nI know that primality testing is in P, but why not factoring?\n\nHere is my algorithm:\n\n```\nFor each a = 1 ... sqrt(N)\n    if(N % a == 0)\n        b = N/a\n        add (a,b) to the result\n    Endif\nEndFor\n```\n\n\nThis runs in O(sqrt(N)).\n    ", "Answer": "\r\nThe input size of a single numeric value, is measured by the length of its binary representation. To be precise, the size of an input numeric value ```\nn```\n is proportional to ```\nlog_2(n)```\n. Therefore your algorithm runs in expotential time.\n\nFor instance, suppose we are factoring a number ```\nN```\n with your algorithm. If ```\nN```\n is prime, you have to test at least ```\nsqrt(N)```\n factors. (Or alternatively you can compute a prime number table for this but it is still not linear).\n\nAnyway, you test for ```\nsqrt(N)```\n times. But the size of the problem is defined as ```\nS=log2(N)```\n. So we have ```\nN=2^S```\n. Therefore it's a ```\nsqrt(2^S)=2^(S/2)```\n which is expotential.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Optimal method to check whether a number is prime or not? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already exists:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Checking if a number is prime in Python [duplicate]\r\n                    \r\n                Closed 2 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nThe best method known to me is of order sqrt(n). I read about Fermat’s Primality Test and  Miller-Rabin Primality Test. They operate in O(log(n)) time, but a major drawback is that they fail sometimes as well.\nCan you help me out?\nIf possible provide an algorithm and code in python ( Even algorithm will be sufficient).\n    ", "Answer": "\r\nHere's what I found after a quick search in google. Tested and seems to work. The check for if the number is higher than 1 can be changed to ```\nnum > 0```\n if you consider 1 a prime number.\n```\n# Program to check if a number is prime or not\n\nnum = 407\n    \n# prime numbers are greater than 1\nif num > 1:\n   # check for factors\n   for i in range(2,num):\n       if (num % i) == 0:\n           print(num,\"is not a prime number\")\n           print(i,\"times\",num//i,\"is\",num)\n           break\n   else:\n       print(num,\"is a prime number\")\n       \n# if input number is less than\n# or equal to 1, it is not prime\nelse:\n   print(num,\"is not a prime number\")\n```\n\nCredit: https://www.programiz.com/python-programming/examples/prime-number\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Optimization for Fermat Primality test for large prime number (DHKE application)\r\n                \r\nSo for DHKE, I need to generate a large prime g (> 500 bits in this case), and then calculate N = 2g+1, then test if N is a prime. Repeat the process until such N is found. \n\nTo accomplish this, I generate a random number g, run fermatTest on it, then run fermatTest on N after. However, I noticed that the run time is extremely slow (sometime the program would take minutes)\n\nHere is my implementation of Fermat test on arbitrary numbers:\n\n```\ndef fermatTest(p):\n    for i in range(5):   # probability of getting a fool: 1/32\n        a = secrets.randbelow(p)      \n        if gcd(p,a) == 1:\n            if (pow(a,p-1,p) == 1):\n                return True\n        else:\n            return False\n```\n\n\nI noticed that to have a good Fermat test, I need to check p with multiple rounds of a, which reduce the chance of getting a Fermat's fool (composite behaves like prime), but also slow down the computation.\n\nMy questions are:\n\nIs there a way to make this function faster? \nOr are there other known algorithms that are faster than Fermat? \n    ", "Answer": "\r\nYou can use sympy library which has a sympy.isprime() function which uses a better implementation of Fermat's test (I could be wrong, but the idea is pretty much the same). However, right now I still have no idea on how to bring the overall time to be less than 30 seconds (sometimes you are lucky you can generate a Safe Prime within 1 second, but other time it can be up to 120s)\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Conditional tests in primality by trial division\r\n                \r\nMy question is about the conditional test in trial division.  There seems to be some debate on what conditional test to employ.  Let's look at the code for this from  RosettaCode.\n\n```\nint is_prime(unsigned int n)\n{\n    unsigned int p;\n    if (!(n & 1) || n < 2 ) return n == 2;\n\n    /* comparing p*p <= n can overflow */\n    for (p = 3; p <= n/p; p += 2)\n        if (!(n % p)) return 0;\n    return 1;\n}\n```\n\n\nWheel factorization or using a predetermined list of primes will not change the essence of my question.\n\nThere are three cases I can think of to do the conditional test:\n\n\np<=n/p\np*p<=n\nint cut = sqrt(n); for (p = 3; p <= cut; p += 2)\n\n\nCase 1: works for all n but it has to do an extra division every iteration (edit: actually it does not need an extra division but it's still slower.  I'm not sure why.  See the assembly output below).  I have found it to be twice as slow as case 2 for large values of n which are prime (on my Sandy Bridge system).\n\nCase 2: is signficantly faster than case 1 but it has a problem that it overflows for large n and goes into an infinitive loop.  The max value it can handle is \n\n```\n(sqrt(n) + c)^2 = INT_MAX  //solve\nn = INT_MAX -2*c*sqrt(INT_MAX) + c^2\n//INT_MAX = 2^32 -> n = 2^32 - c*s^17 + c^2; in our case c = 2\n```\n\n\nFor example for uint64_t case 2 will go into an infinite loop for x =-1L-58 (x^64-59) which is a prime.\n\nCase 3: no division or multiplication has to be done every iteration and it does not overflow like case 2.  It's slightly faster than case 2 as well.  The only question is if sqrt(n) is accurate enough. \n\nCan someone explain to me why case 2 is so much faster than case 1?  Case 1 does NOT use an extra division as I though but despite that it's still a lot slower.\n\nHere are the times for the prime 2^56-5;\n\n```\ncase 1 9.0s\ncase 2 4.6s\ncase 3 4.5s\n```\n\n\nHere is the code I used to test this http://coliru.stacked-crooked.com/a/69497863a97d8953.  I also added the functions to the end of this question.\n\nHere is the assembly output form GCC 4.8 with -O3 for case 1 and case 2.  They both only have one division.  Case 2 has a multiplication as well so my first guess is that case 2 would be slower but it's about twice as fast on both GCC and MSVC.  I don't know why.\n\nCase 1:\n\n```\n.L5:\n  testl %edx, %edx\n  je  .L8\n.L4:\n  addl  $2, %ecx\n  xorl  %edx, %edx\n  movl  %edi, %eax\n  divl  %ecx\n  cmpl  %ecx, %eax\n  jae .L5\n```\n\n\nCase 2:\n\n```\n.L20:\n  xorl  %edx, %edx\n  movl  %edi, %eax\n  divl  %ecx\n  testl %edx, %edx\n  je  .L23\n.L19:\n  addl  $2, %ecx\n  movl  %ecx, %eax\n  imull %ecx, %eax\n  cmpl  %eax, %edi\n  jae .L20\n```\n\n\nHere are the functions I'm using to test the time:\n\n```\nint is_prime(uint64_t n)\n{\n    uint64_t p;\n    if (!(n & 1) || n < 2 ) return n == 2;\n\n    /* comparing p*p <= n can overflow */\n    for (p = 3; p <= n/p; p += 2)\n        if (!(n % p)) return 0;\n    return 1;\n}\n\nint is_prime2(uint64_t n)\n{\n    uint64_t p;\n    if (!(n & 1) || n < 2 ) return n == 2;\n\n    /* comparing p*p <= n can overflow */\n    for (p = 3; p*p <= n; p += 2)\n        if (!(n % p)) return 0;\n    return 1;\n}\n\nint is_prime3(uint64_t n)\n{\n    uint64_t p;\n    if (!(n & 1) || n < 2 ) return n == 2;\n\n    /* comparing p*p <= n can overflow */\n    uint32_t cut = sqrt(n);\n    for (p = 3; p <= cut; p += 2)\n        if (!(n % p)) return 0;\n    return 1;\n}\n```\n\n\nAdded content after the bounty.\n\nAean discovered that in case 1 saving the quotient as well as the remainder is just as fast (or slightly faster) than case 2.  Let's call this case 4.  The following following code is twice as fast as case 1.\n\n```\nint is_prime4(uint64_t n)\n{\n    uint64_t p, q, r;\n    if (!(n & 1) || n < 2 ) return n == 2;\n\n    for (p = 3, q=n/p, r=n%p; p <= q; p += 2, q = n/p, r=n%p)\n        if (!r) return 0;\n    return 1;\n}\n```\n\n\nI'm not sure why this helps.  In any case there is no need to use case 2 anymore.  For case 3, most versions of the ```\nsqrt```\n function in hardware or software get the perfect squares right so it's safe to use in general.  Case 3 is the only case that will work with OpenMP.\n    ", "Answer": "\r\nUPD: This is a compiler optimization issue, obviously. While MinGW used only one ```\ndiv```\n instruction in loop body, both GCC on Linux and MSVC failed to reuse the quotient from previous iteration.\n\nI think the best we could do is explicitly define ```\nquo```\n and ```\nrem```\n and calculate them in the same basic instruction block, to show the compiler we want both quotient and remainder.\n\n```\nint is_prime(uint64_t n)\n{\n    uint64_t p = 3, quo, rem;\n    if (!(n & 1) || n < 2) return n == 2;\n\n    quo = n / p;\n    for (; p <= quo; p += 2){\n        quo = n / p; rem = n % p;\n        if (!(rem)) return 0;\n    }\n    return 1;\n}\n```\n\n\n\n\nI tried your code from http://coliru.stacked-crooked.com/a/69497863a97d8953 on a MinGW-w64 compiler, ```\ncase 1```\n is faster than ```\ncase 2```\n.\n\n\n\nSo I guess you are compiling targeted to a 32-bit architecture and used ```\nuint64_t```\n type. Your assembly shows it doesn't use any 64-bit register.\n\nIf I got it right, there is the reason.\n\nOn 32-bit architecture, 64-bit numbers is represented in two 32-bit registers, your compiler will do all concatenation works. It's simple to do 64-bit addition, subtraction and multiplication. But modulo and division is done by a small function call which named as ```\n___umoddi3```\n and ```\n___udivdi3```\n in GCC, ```\naullrem```\n and ```\naulldiv```\n in MSVC.\n\nSo actually you need one ```\n___umoddi3```\n and one ```\n___udivdi3```\n for each iteration in ```\ncase 1```\n, one ```\n___udivdi3```\n and one concatenation of 64-bit multiplication in ```\ncase 2```\n. That's why ```\ncase 1```\n seems twice slower than ```\ncase 2```\n in your test.\n\nWhat you really get in ```\ncase 1```\n:\n\n```\nL5:\n    addl    $2, %esi\n    adcl    $0, %edi\n    movl    %esi, 8(%esp)\n    movl    %edi, 12(%esp)\n    movl    %ebx, (%esp)\n    movl    %ebp, 4(%esp)\n    call    ___udivdi3         // A call for div\n    cmpl    %edi, %edx\n    ja  L6\n    jae L21\nL6:\n    movl    %esi, 8(%esp)\n    movl    %edi, 12(%esp)\n    movl    %ebx, (%esp)\n    movl    %ebp, 4(%esp)\n    call    ___umoddi3        // A call for modulo.\n    orl %eax, %edx\n    jne L5\n```\n\n\nWhat you really get in ```\ncase 2```\n:\n\n```\nL26:\n    addl    $2, %esi\n    adcl    $0, %edi\n    movl    %esi, %eax\n    movl    %edi, %ecx\n    imull   %esi, %ecx\n    mull    %esi\n    addl    %ecx, %ecx\n    addl    %ecx, %edx\n    cmpl    %edx, %ebx\n    ja  L27\n    jae L41\nL27:\n    movl    %esi, 8(%esp)\n    movl    %edi, 12(%esp)\n    movl    %ebp, (%esp)\n    movl    %ebx, 4(%esp)\n    call    ___umoddi3         // Just one call for modulo\n    orl %eax, %edx\n    jne L26\n```\n\n\nMSVC failed to reuse the result of ```\ndiv```\n. The optimization is broken by ```\nreturn```\n.\nTry these code:\n\n```\n__declspec(noinline) int is_prime_A(unsigned int n)\n{\n    unsigned int p;\n    int ret = -1;\n    if (!(n & 1) || n < 2) return n == 2;\n\n    /* comparing p*p <= n can overflow */\n    p = 1;\n    do {\n        p += 2;\n        if (p >= n / p) ret = 1; /* Let's return latter outside the loop. */\n        if (!(n % p)) ret = 0;\n    } while (ret < 0);\n    return ret;\n}\n\n__declspec(noinline) int is_prime_B(unsigned int n)\n{\n    unsigned int p;\n    if (!(n & 1) || n < 2) return n == 2;\n\n    /* comparing p*p <= n can overflow */\n    p = 1;\n    do {\n        p += 2;\n        if (p > n / p) return 1; /* The common routine. */\n        if (!(n % p)) return 0;\n    } while (1);\n}\n```\n\n\nThe ```\nis_prime_B```\n will be twice slower than ```\nis_prime_A```\n on MSVC / ICC for windows.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Problem when converting 'Fermat's primality test' from a Java to Python\r\n                \r\nI took the following program from here,  \n\n```\nimport java.io.*; \nimport java.math.*; \n\nclass GFG { \n\n    /* Iterative Function to calculate \n    // (a^n)%p in O(logy) */\n    static int power(int a,int n, int p) \n    { \n        // Initialize result \n        int res = 1; \n\n        // Update 'a' if 'a' >= p \n        a = a % p;  \n\n        while (n > 0) \n        { \n            // If n is odd, multiply 'a' with result \n            if ((n & 1) == 1) \n                res = (res * a) % p; \n\n            // n must be even now \n            n = n >> 1; // n = n/2 \n            a = (a * a) % p; \n        } \n        return res; \n    } \n\n    // If n is prime, then always returns true,  \n    // If n is composite than returns false with  \n    // high probability Higher value of k increases \n    //  probability of correct result. \n    static boolean isPrime(int n, int k) \n    { \n    // Corner cases \n    if (n <= 1 || n == 4) return false; \n    if (n <= 3) return true; \n\n    // Try k times \n    while (k > 0) \n    { \n        // Pick a random number in [2..n-2]      \n        // Above corner cases make sure that n > 4 \n        int a = 2 + (int)(Math.random() % (n - 4));  \n\n        // Fermat's little theorem \n        if (power(a, n - 1, n) != 1) \n            return false; \n\n        k--; \n        } \n\n        return true; \n    } \n\n    // Driver Program  \n    public static void main(String args[]) \n    { \n        int k = 3; \n        if(isPrime(11, k)) \n            System.out.println(\" true\"); \n        else\n            System.out.println(\" false\"); \n        if(isPrime(15, k)) \n            System.out.println(\" true\"); \n        else\n            System.out.println(\" false\"); \n\n    } \n} \n```\n\n\nand converted into a Python program:\n\n```\n#############################\n#  random number generation\n#############################\nm = 4294967296\na = 1664525\nc = 1013904223\nseed = 1\n\ndef NextInt():\n    global seed\n    seed = (((a * seed + c) % m))\n    return seed\n\ndef NextInt2(min, max):\n    temp = NextInt()\n    ddd = temp / m\n    return int((max - min) * ddd + min)\n\ndef NextDouble():\n    temp = NextInt()\n    return temp / m\n\ndef NextDouble2(min, max):\n    temp = NextInt()\n    fraction = temp / m\n    return (max - min) * fraction + min  \n\n#######################################\n# Fermet's method of primality test\n#######################################    \ndef Power(a, n, p): \n    res = 1; \n    a = a % p;  \n    while (n > 0):\n        if ((n and 1) == 1): \n            res = (res * a) % p; \n\n        n = n / 2;  \n        a = (a * a) % p; \n\n    return res; \n\ndef IsPrime(n, k): \n    if (n <= 1 or n == 4): \n        return False; \n\n    if (n <= 3):\n        return True; \n\n    while (k > 0): \n        a = 2 + NextInt() % (n - 4);  \n\n        if (Power(a, n - 1, n) != 1): \n            return False; \n\n        k = k-1; \n\n    return True;\n\n#####################      \n#    Main Program  \n#####################    \nk = 3; \n\nif(IsPrime(11, k)): \n    print(\" true\"); \nelse:\n    print(\" false\"); \n\nif(IsPrime(15, k)): \n    print(\" true\"); \nelse:\n    print(\" false\");               \n```\n\n\nThis Python program is always returning ```\nFalse```\n.\n\nWhy?\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Looking for a fast deterministic primality test for numbers above 64 bits\r\n                \r\nI have searched for ways to determinate if a number is prime or not, but most ways are either probabilistic (Miller Rabin) or for numbers smaller than 64 bits. \n\nThe other solution would be to use the brute force method with a few improvements or the sieves, but neither of those is very efficient when the numbers go above the 64 bit threshold.\n    ", "Answer": "\r\nWhat you are looking for does not exist. There is no simple deterministic primality test that works always for all ranges of integers.\n\nYou already know about the Miller-Rabin test. It can be made deterministic on particular ranges; see here or here for details. If you assume the Riemann Hypothesis, then n is prime if n is an a-SPRP (a Miller strong pseudoprime) for all integers a with 1 < a < 2(log n)². A similar and somewhat better test is the Baillie-Wagstaff test; it is not deterministic, but no failures are known.\n\nFor numbers n up to 2128, it's not too hard to factor n − 1 and use a Pocklington test to prove primality. You can use trial division, or Pollard rho, or ECM to perform the factorization. There are also tests (BLS75) that can prove primality based on a partial factorization. Larger n can also be proved prime using a Pocklington test, though sometimes the factorization becomes difficult.\n\nFor n up to about 101000, a fast ECPP prime test is not unreasonable, though for the larger numbers in that range it might take a while. Beyond that, unless your number has some special form, you're pretty much out of luck.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Pelles C and GCC give different result with this C primality test\r\n                \r\nI compile this code with this compilers. For number i write 18446744073709551615 (2^64-1). Pelles's executable says \"18446744073709551615 is prime\" but GCC's executable says \"18446744073709551615  isn't prime\". Why results are different?\n\n```\n#include <stdio.h>\n#include <math.h>\nint main(void)\n{\n    unsigned long long number;\n    printf(\"number: \");\n    scanf(\"%llu\",&number);\n    unsigned long trsq=truncl(sqrtl(number));\n    char s=1;\n    for(unsigned long i=2;i<=trsq;i++) {\n        if (number%i==0) {\n            s=0;\n            break;\n        }\n    }\n    if (s==1) {\n        printf(\"%llu is prime\\n\",number);\n    } else {\n        printf(\"%llu isn't prime\\n\",number);\n    }\n    return 0;\n}\n```\n\n\nEdit:\n\nI've tested and gcc give 12, pelles c give 8 for sizeof(long double).\n    ", "Answer": "\r\nMany things are left unspecified in the definition of the C language, including the size of numeric types and what happens in case of overflow or loss of precision. So it is common to get different results with different implementations (different compilers, different hardware, different operating systems) when you don't check numeric type ranges or when you use floating point.\n\nGiven the information provided by self. in two comments, here is a plausible explanation of what's happening. I don't have Pelles C to check.\n\nPelles warns:\n\n\n  warning #2215: Conversion from 'unsigned long long int' to 'long double'; possible loss of data.\n  warning #2215: Conversion from 'long double' to 'unsigned long int'; possible loss of data\n\n\nConjecture #1: the mathematical value 2^64-1 cannot be represented exactly in a ```\nlong double```\n (this is likely, as 2^64-1 requires 64 bits of mantissa and few implementations have that much). It is rounded to 2^64, which can be represented exactly.\n\nThe value of ```\nnumber```\n is 2^64-1, and it is an ```\nunsigned long long```\n. Since the function ```\nsqrtl```\n expects a ```\nlong double```\n argument, the value is converted to that type. Given conjecture #1, ```\nsqrtl```\n receives a value of 2^64. The result is therefore 2^32. Since this is an integer, ```\ntruncl```\n returns the same value.\n\nConjecture #2: ```\nunsigned long```\n is a 32-bit type (this is pretty much the norm on 32-bit machines, and is also the case on 64-bit versions of Windows, at least with the Microsoft compiler).\n\nIf ```\nunsigned long```\n is a 32-bit type, then the value 2^32 overflows it. What happens in case of overflow in a conversion from a floating-point value to an integer value is not defined by the C standard, compilers can choose to do whatever they want.\n\nConjecture #3: In Pelles C, when a floating-point value is converted to an integer type, it is wrapped modulo the size of the type, like what happens when converting to a smaller integer type.\n\nUnder conjecture #3, trying to assign the value 2^32 to ```\ntrsq```\n, which is of type ```\nunsigned long```\n and 32-bit wide, sets it to 0. Thus ```\ntrsq```\n has the value 0, the ```\nfor```\n loop runs 0 times, and the program erroneously reports that the number is prime.\n\nAn easy fix is to change ```\ntrsq```\n to be ```\nunsigned long long```\n.\n\nNote that your program may report some numbers as prime if their largest prime factor is very close to their square root (e.g. if the number is the square of a prime), because the conversion of ```\nnumber```\n to a floating-point value may round it down, so ```\ntrsq```\n may end up being less than the square root, even less than the largest integer that is smaller than the square root.\n\nYou can avoid all this trouble by performing an integer square root computation.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "GMP faulty naive primality algorithm c++\r\n                \r\nI implemented the following GMP function for an RSA program. Basically, the program generates random ```\nmpz*t```\n numbers until one of them returns ```\ntrue```\n for this function.\n\n```\nbool isPrime(const mpz_t bignum)\n{\n    mpz_t modnum; mpz_init(modnum);\n    if(mpz_cmp_ui(bignum,4)<0 && mpz_cmp_si(bignum,0)>=0) {\n        fprintf(stderr,\"Trivially prime.\\n\");\n        return false;\n    }\n    else if(mpz_mod_ui(modnum,bignum,2)==0)\n        return false;\n    mpz_clear(modnum);\n\n    mpz_t i,rootnum; \n    mpz_inits(i,modnum,rootnum,NULL);\n    mpz_sqrt(rootnum,bignum);\n    mpz_set_str(i,\"3\",10);\n\n    for(;mpz_cmp(rootnum,i)>0; mpz_add_ui(i,i,2)) {\n        mpz_mod(modnum,bignum,i);\n        if(mpz_cmp(modnum,i)==0)\n            return false;\n    }\n    mpz_clears(modnum,i,rootnum,NULL);\n    return true;\n}\n```\n\n\nHere is the function that calls ```\nisPrime()```\n as a subroutine:\n\n```\nvoid generate_pq(mpz_t& p, mpz_t& q) \n{\n    gmp_randstate_t rstate;\n    gmp_randinit_default(rstate);\n    gmp_randseed_ui(rstate,time(NULL));\n\n    printf(\"\\nGenerating keys...\\n\");\n    do {\n        mpz_urandomb(p,rstate,32);\n    } while(!isPrime(p));\n    printf(\"\\n***** p *****\\n\");\n    gmp_printf(\"    %Zd\\n\",p);\n    do {\n        mpz_urandomb(q,rstate,32);\n    } while(!isPrime(q));\n    gmp_randclear(rstate);\n\n    printf(\"\\n***** q *****\\n\");\n    gmp_printf(\"    %Zd\\n\",q);\n}\n```\n\n\nThe program compiles and runs no problem. However, the numbers generated are not prime and yet ```\nisPrime()```\n still returns true for them. Could anyone point out the flaw in the algorithm of my primality test? Here is the regular ```\nint```\n version of my ```\nisPrime()```\n function, if you'd like to compare:\n\n```\nbool isPrime(uint64_t n) \n{\n    //waste of time\n    if(n < 4) {\n        fprintf(stderr,\"Trivially prime.\\n\");\n        return true;\n    }\n    //even #, not prime\n    else if(n%2==0) {\n        return false;\n    }\n    //check if divisible by all odd #s < sqrt(n)\n    for(uint64_t i=3; i<(uint64_t)sqrt(n+1); i+=2) {\n        if(n%i==0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    ", "Answer": "\r\nThe error was in my for-loop.\n\n```\nfor(;mpz_cmp(rootnum,i)>0; mpz_add_ui(i,i,2)) {\n    mpz_mod(modnum,bignum,i);\n    if(mpz_cmp(modnum,i)==0) // <-----not supposed to do if(modnum==i)\n        return false;\n```\n\n\nThe correct version of this for-loop is here:\n\n```\nfor(;mpz_cmp(rootnum,i)>0; mpz_add_ui(i,i,2)) {\n    mpz_mod(modnum,bignum,i);\n    if(mpz_cmp_ui(modnum,0)==0) // <-- if bignum % modnum == 0, return false\n        return false;\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "64 bit operations\r\n                \r\nI'm writing code for a primality testing function that handles long long int's.Do I have to use special operators for such large numbers?Is there any documentation concerning large number manipulation in C?I'm using the gnu standard library.Thanks.\n    ", "Answer": "\r\nNo, you don't need to do anything special. You handle a ```\nlong long int```\n just the same way as you would handle a ```\nint```\n. Just beware of overflows, as with every native integer type.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "My primality test ignores a condition. What am I doing wrong?\r\n                \r\nAs a newbie python enthusiast, I find this very annoying:\n\n```\ndef isPrime(x):\n    if x < 0: raise Exception(\"The number is negative.\")\n    if x == 0 or x == 1: return False\n    if x == 2: return True\n    else:\n        if x % 2 == 0: return False\n        for i in xrange (3, int(math.sqrt(x)), 2): #-------> This doesn't do anything.\n            if x % i == 0: return False # Even if I put 3 instead of i, it still prints numbers that are divisible by 3.\n    return True\n\nfor i in xrange (100):\n    if isPrime(i):\n        print i\n```\n\n\nI get numbers like 9, 15, 21 - divisible by 3, therefore not primes. What am I missing?\n    ", "Answer": "\r\nYou want ```\nxrange (3, int(math.sqrt(x)) + 1, 2)```\n - remember that ```\nxrange```\n iterates through all values from its start point, inclusive, to its stop point, exclusive.\n\nMore concretely, when ```\nx```\n is 9, you have ```\nxrange (3, 3, 2)```\n which does not iterate over anything.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Numpy AKS primality function\r\n                \r\nI'm implementing the AKS-primality test using Numpy. Specifically, I'm using the polynomial capabilities of Numpy to find the coefficients of the equation (x - 1)^n - (x^n - 1) and then returning True if all those coefficients are divisible by the prime candidate.\n```\ndef isPrime(n):\n    if n < 2:\n        return False\n    poly1 = np.polynomial.polynomial.polypow([1, -1], n)\n    poly2 = np.zeros(n + 1, dtype=int)\n    poly2[0] = 1\n    poly2[-1] = -1\n    coefficients = np.polysub(poly1, poly2)\n    divisibility_test = lambda x : x % n != 0\n    non_divisibles = filter(divisibility_test, coefficients)\n    try:\n        _ = next(non_divisibles)\n        return False\n    except StopIteration:\n        return True\n```\n\nI recognize I don't have the most performant solution here. I'm confused why this implementation produces correct answers only for inputs below 59. It fails to recognize any primes greater than 53.\nEdit:\nAn easy way to demonstrate the results looks like this:\n```\nprint(list(filter(isPrime, range(100))))\n```\n\n    ", "Answer": "\r\nTo use python's arbitrary precision integers you can specify ```\ndtype=object```\n to the appropriate methods when constructing coefficient lists, i.e.\n```\npoly1 = np.polynomial.polynomial.polypow(np.array([1, -1], dtype=object), n)\npoly2 = np.zeros(n + 1, dtype=object)\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test using logical or relational operators on a 3-bit number\r\n                \r\nI am looking forward to check if a 3 bits number is prime using both logical and relational operators.The number is represented using 3 variables with bits 7-1 set to 0 and only the bit on position 0 being the actual data. Suppose we have:\n\n```\nunsigned char x3, x2, x1;\n```\n\n\nOne can assume that a prime number is function ```\nf```\n which outputs ```\n1```\n if the number is prime, ```\n0```\n otherwise.\n\nHow would one solve this using bit-wise operations (logical operators) as optimal as possible? One can assume that a minimum conjunctive/disjunctive form can be extracted from a K.V. diagram of the truth table. \n\nHow would one solve this using relational operators? \n\nWhich one would be faster?\n\nSome useful data:\n\n```\nCDF: (~x2 & X1) | (X0 & X2)\nCCF: (X1 | X2) & (X0 | ~X2)\n```\n\n    ", "Answer": "\r\nBitwise\n\nI think the best you can do here is ```\n(x3 & x1) | (~x3 & x2)```\n. In boolean algebra, this would be expressed as ```\nAC + (!A)B```\n.```\n*```\n None of the usual rules for simplifying boolean algebra expressions would seem to apply here, and several online boolean algebra expression simplifiers seem to agree.\n\n```\n*```\n (the second ```\nA```\n would normally be written with a bar over it, but I don't know how to do that in markdown).\n\nSo you'd get something like this (using ```\nuchar```\n as shorthand for ```\nunsigned char```\n):\n\n```\nuchar f_bitwise(uchar x3, uchar x2, uchar x1) \n{\n   return (x3 & x1) | (~x3 & x2);\n}\n```\n\n\nThe assembly produced by this (with ```\n-O0```\n and discarding the function call overhead), looks like this:\n\n```\nmovzx   eax, BYTE PTR [rbp-4]  # move x3 into register eax\nand     al, BYTE PTR [rbp-12]  # bitwise AND the lower half of eax with x1\nmov     ecx, eax               # store the result in ecx\ncmp     BYTE PTR [rbp-4], 0    # compare x3 with 0\nsete    al                     # set lower half of eax to 1 if x3 was equal to 0\nmov     edx, eax               # store the result in edx (this now equals ~x3)\nmovzx   eax, BYTE PTR [rbp-8]  # move x2 into eax\nand     eax, edx               # bitwise AND ~x3 (in edx) with x2 (in eax)\nor      eax, ecx               # finally, bitwise OR eax and ecx\n```\n\n\nThe result is stored in ```\neax```\n. \n\nLogical\n\nLooking at the bits of values 0-7, and trying to discern an easy pattern to key off of, you notice that for values 0-3, the number is prime if and only if ```\nx2```\n is 1. Likewise, for values 4-7, the number is prime if and only if ```\nx1```\n is 1. This observation yields a simple expression: ```\nx3 ? x1 : x2```\n. \n\nI have no proof that this is the shortest possible expression using logical operators, so if someone has a shorter version, by all means post it in a comment. However, it does seem unlikely that there's a shorter version, given that this is essentially a single logical operator, as you can see if you expand the ternary operator into a proper ```\nif```\n/```\nelse```\n:\n\n```\nuchar f_logical(uchar x3, uchar x2, uchar x1) \n{\n   if (x3 != 0) \n      return x1;\n   else\n      return x2;\n}\n```\n\n\nThe assembly produced by this is as follows (again with ```\n-O0```\n and not counting the function call overhead):\n\n```\ncmp     BYTE PTR [rbp-4], 0      # compare x3 with 0\nje      .L2                      # if equal, jump to label L2\nmovzx   eax, BYTE PTR [rbp-12]   # move x1 into register eax\njmp     .L4                      # jump to label L4 (i.e., return from function)\n.L2: \nmovzx   eax, BYTE PTR [rbp-8]    # move x2 into register eax\n.L4:\n# Function return. Result is once again stored in eax.\n```\n\n\nI haven't tested the performance of either of these functions, but just from looking at the assembly, it seems almost certain that ```\nf_logical```\n would run faster than ```\nf_bitwise```\n. It uses significantly fewer instructions, and although fewer instructions doesn't always equate to faster, none of these instructions seem like they would be particularly expensive in terms of CPU cycles. \n\nIf you cancel out the instructions that both functions have in common and compare what's left, you get:\n\n```\nf_logical```\n: ```\nje```\n, ```\njmp```\n\n\n```\nf_bitwise```\n: ```\nand```\n (2), ```\nmov```\n (2), ```\nsete```\n, ```\nor```\n\n\nAs for why the logical version is shorter, I think the answer is branching. With only bitwise operations and no branching, you have to account for all possibilities in a single expression. \n\nFor instance, in ```\n(x3 & x1) | (~x3 & x2)```\n, it would be nice to get rid of the ```\n~x3```\n on the right hand side, given that you already know ```\nx3```\n is zero there, given that the right hand side represents the test for values 0-3. But the computer has no way of knowing this, and you can't factor it out into a simpler expression. \n\nWith the ability to branch, you can split the problem into two sub-problems using a single comparison operator. Again, this works because for values 0-3, the ```\nx2```\n bit is essentially an \"is prime\" bit, and for values 4-7, the ```\nx1```\n bit is an \"is prime\" bit.\n\nAlso, alinsoar is correct that a lookup table would be faster, but only if the value isn't split into individual bits. With the bit values in separate variables, you either have to reconstruct the number using something like ```\nx3<<2 | x2<<1 | x1```\n, or you have to define your lookup table as a 3D array, in which case the compiler generates a bunch of extra instructions to do the address arithmetic necessary to index a 3D array.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "AKS Primes algorithm in Python\r\n                \r\nA few years ago, it was proven that PRIMES is in P. Are there any algorithms implementing their primality test in Python? I wanted to run some benchmarks with a naive generator and see for myself how fast it is. I'd implement it myself, but I don't understand the paper enough yet to do that.\n    ", "Answer": "\r\nQuick answer: no, the AKS test is not the fastest way to test primality. There are much much faster primality tests that either assume the (generalized) Riemann hypothesis and/or are randomized. (E.g. Miller-Rabin is fast and simple to implement.) The real breakthrough of the paper was theoretical, proving that a deterministic polynomial-time algorithm exists for testing primality, without assuming the GRH or other unproved conjectures.\n\nThat said, if you want to understand and implement it, Scott Aaronson's short article might help. It doesn't go into all the details, but you can start at page 10 of 12, and it gives enough. :-)\nThere is also a list of implementations (mostly in C++) here.\n\nAlso, for optimization and improvements (by several orders of magnitude), you might want to look at this report, or (older) Crandall and Papadopoulos's report, or (older still) Daniel J Bernstein's report. All of them have fairly detailed pseudo-code that lends itself well to implementation.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Probability of n-bit integers [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  random a 512-bit integer N that is not a multiple of 2, 3, or 5  \n\n\n\n\nI have a question\n\nfor a random 512-bit integer n that isn't a multiple of 2,3, or 5 what is the chance that n is prime? what about that n is composite but fools the fermat primality test? what about that it is composite but doesn't fool the fermat primality test?\n    ", "Answer": "\r\nSince this is definitely a homework problem, I'll point you at the Prime Number Theorem, which should give you the probability that any large number is prime. \n\nFrom there, modify the probability with your new information about composite numbers that have been eliminated (Hint: Think about how the problem space shrinks).\n\nBest of luck!\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Converting Baillie–PSW test from Python to Java\r\n                \r\nI'm trying to convert an implementation of the Baillie–PSW primality test from Python to Java.\nI think I've done it mostly right, but there's a part where the answers start to deviate, and as a result the whole algorithm cannot detect any primes. This deviation starts to occur when the algorithm starts using the Lucas Primality Test.\n\nHere's the original code for part of that test (part of this repo):\n\n```\ndef U_V_subscript(k, n, U, V, P, Q, D):\nk, n, U, V, P, Q, D = map(int, (k, n, U, V, P, Q, D))\ndigits = list(map(int, str(bin(k))[2:]))\nsubscript = 1\n\nfor digit in digits[1:]:\n\n    U, V = U*V % n, (pow(V, 2, n) - 2*pow(Q, subscript, n)) % n\n\n    subscript *= 2\n    if digit == 1:\n\n        if not (P*U + V) & 1:\n            if not (D*U + P*V) & 1:\n\n                U, V = (P*U + V) >> 1, (D*U + P*V) >> 1\n            else:\n                U, V = (P*U + V) >> 1, (D*U + P*V + n) >> 1\n        elif not (D*U + P*V) & 1:\n            U, V = (P*U + V + n) >> 1, (D*U + P*V) >> 1\n        else:\n            U, V = (P*U + V + n) >> 1, (D*U + P*V + n) >> 1\n        subscript += 1\n        U, V = U % n, V % n\n\nreturn U, V\n```\n\n\nAnd Here is my Java counterpart:\n\n```\nstatic long[] UVSubscript(long k, long n, long U, long V, long P, long Q, long D){\n    BitSet bitDigits = convert(k);\n    long subscript = 1;\n    for (int i = bitDigits.length()-2; i >= 0; i--) {\n        U = U*V % n;\n        V = (powerModulus(V, 2, n) - 2*powerModulus(Q, subscript, n)) % n;\n\n        subscript *= 2; \n\n        if (bitDigits.get(i)){\n\n\n            if (((P * U + V) & 1) == 0){\n                if (((D*U + P*V) & 1) == 0){\n\n                     U = (P*U + V) >> 1;\n                     V = (D*U + P*V) >> 1;\n                }else{\n                     U = (P*U + V) >> 1;\n                     V = (D*U + P*V + n) >> 1;\n                }\n            } else if (((D * U + P * V) & 1) == 0){\n                U = (P*U + V + n) >> 1;\n                V = (D*U + P*V) >> 1;\n            }else{\n                U = (P*U + V + n) >> 1;\n                V = (D*U + P*V + n) >> 1;\n            }\n\n            subscript += 1;\n            U = U % n;\n            V = V % n; \n\n        }\n    }\n    return new long[]{U, V};\n}\n```\n\n\nCan someone please help me? Here's a runnable version of the whole Python script, if anyone's interested.  And here's a pastebin of my whole Java translation.\n\nPS If anyone knows of a ready-made Java implementation of the Baillie–PSW primality test, I could just use that!\n    ", "Answer": "\r\nOne place I can see deviations happening is in your translation of this line, and the three similar ones:\n\n```\nU, V = (P*U + V + n) >> 1, (D*U + P*V + n) >> 1\n```\n\n\nThese are parallel assignments in Python, that is ```\nV```\n is being calculated with the old value of ```\nU```\n from before the statement.  But in your translation:\n\n```\nU = (P*U + V + n) >> 1;\nV = (D*U + P*V + n) >> 1;\n```\n\n\nThe ```\nV```\n is being calculated using the new value of ```\nU```\n.  A better translation might be along the lines of:\n\n```\nlong old_U = U;\nU = (P*U + V + n) >> 1;\nV = (D*old_U + P*V + n) >> 1;\n```\n\n\nAnd again, this would also need to be done for the other parallel assignments.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How Java BigInteger nextProbablePrime method works?\r\n                \r\nI'm working with Java ```\nBigInteger```\n Class and curious about the Algorithm behind ```\nnextProbablePrime```\n method. I know about some efficient primality testing algorithm like ```\nMiller-Rabin```\n but not sure about which algorithm was implemented here.\n\nTrying the following code for a good time and still no response.\n\n```\nBigInteger number = BigInteger.ZERO;\nnumber = number.setBit(82589933);\nnumber = number.nextProbablePrime();\n```\n\n    ", "Answer": "\r\nI have gone through with the source code of ```\nBigInteger```\n. It is internally using the MillerRabin algorithm for the ```\nnextProbablePrime```\n method.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "why is my primality test failing so often when randomizing a BigInteger?\r\n                \r\nI wasn't able to get true for both p and q, most of the results is both false or rarely p is true but q is false, why wouldn't this test ever be true for both p and q?\n```\nBigInteger bitSize100 = new BigInteger(\"1\").setBit(99);\n\nfor(int i = 0; i < 20; i++) {\n        BigDecimal randomizer = new BigDecimal(Math.random()).multiply(new BigDecimal(bitSize100)); // get random 99 bit number\n        BigInteger q = randomizer.toBigInteger().setBit(99); // must be 100 bits\n        BigInteger p = q.add(q).add(BigInteger.ONE);\n         System.out.println(p.isProbablePrime(100) + \" \" + q.isProbablePrime(100));\n         \n     }\n\n\noutput:\nfalse false\nfalse false\nfalse false\nfalse false\ntrue false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\nfalse false\n```\n\n    ", "Answer": "\r\nFirst of all ```\nBigDecimal randomizer = new BigDecimal(Math.random()).multiply(new BigDecimal(bitSize100))```\n does not result in 100 bit of randomness.\n```\nMath.random```\n returns a ```\ndouble```\n value that's 64 bit large, so that's the maximum amount of randomness this can create (and since the value is limited to values between 0 and 1, the actual amount of randomness is even smaller).\nYou should use a combination of ```\nRandom.nextBytes()```\n to fill a ```\nbyte[]```\n with random data and the ```\nBigInteger```\n constructor that takes such a ```\nbyte[]```\n to construct your ```\nBigInteger```\n. Avoid going through ```\ndouble```\n and ```\nBigDecimal```\n values at all here.\nEdit: and that's in fact exactly what you've been told on this other question of yours 4 hours ago.\nSecond: most numbers simply aren't prime. If you randomly pick numbers (and don't even exclude even numbers) then the huge majority of them will not be prime.\nI don't know how what fraction of prime numbers are Sophie Germain primes, but it's obviously not all of them.\nSo with your code taking many attempts (definitely more than 20 on average) to find such a prime number pair is not surprising.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality test for n by checking whether n divides 2^n-2\r\n                \r\nSo the question I have is how do i implement this formula: A positive integer n (larger than 1) is a prime if and only if n divides 2^n-2. So far i came up with this code, but i am stuck. I am a newbie at this, just starting to learn java, any help would be great, thanks! \n\n```\npublic boolean isPrime(int x){\n     if(x==1) \n        return false; \n     if(x==2) \n        return true;\n     if(x % 2 == 0)\n        return false;\n\n     for(int i=3; i<Math.sqrt(x); i++)\n```\n\n\nThis is where i am confused.  \n    ", "Answer": "\r\nThe direct way, calculating 2n-2 and then testing for divisibility, is obviously completely unscalable. Fortunately we can just work modulo ```\nn```\n the entire way, that way there will be no big numbers. This proof of concept uses ```\nBigInteger```\n anyway, just because it has a convenient implementation of ```\nmodPow```\n, it could be rewritten without that.\n\n```\nstatic boolean isProbablyPrime(int n) {\n    BigInteger bigN = BigInteger.valueOf(n);\n    BigInteger two = BigInteger.valueOf(2);\n    BigInteger t = two.modPow(bigN, bigN);\n    return t.longValue() == 2;\n}\n```\n\n\nI renamed the function because it passes some non-primes, such as 561 as mentioned in the comments.\n\nTry it on ideone.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "'None' is printed when I want 'True' for input 5\r\n                \r\nIn this primality test program, 'None' is printed when I input a prime, instead of 'True'. How can I get it to print 'True'?. \n\n```\n    def main():\n        import math\n        def check_n(n):\n            n_s = int(math.sqrt(n))\n            for i in range(2, n_s):\n                if (n_s % i) == 0:\n                    return False\n                    break\n                else:\n                    return True\n        def msg():\n            n = int(input('Enter a number, I will return True if it is a prime'))\n            return n\n\n        print(check_n(msg()))\n\n    main()\n```\n\n    ", "Answer": "\r\nYou need to change ```\nint(math.sqrt(n))```\n to ```\nint(math.sqrt(n)+1)```\n, because ```\nrange```\n runs until ```\nn_s-1```\n. So if the input is 5, ```\nrange(2,int(math.sqrt(5)))```\n is just ```\nrange(2,2)```\n, which is empty.\n\nIn addition, you need to take the ```\nreturn True```\n outside of the ```\nfor```\n loop, otherwise your code may stop in a too early stage. You also don't need the ```\nbreak```\n statement after ```\nreturn False```\n (the function will never arrive to that line, as it will return ```\nFalse```\n if it enters to that ```\nif```\n statement).\n\nFinally, change ```\nif (n_s % i) == 0:```\n to ```\nif (n % i) == 0:```\n, as you need to check if ```\nn```\n is divisible by ```\ni```\n (and not its square root).\n\nHere is a more clean version:\n\n```\nimport math\ndef check_n(n):\n    n_s = int(math.sqrt(n)+1)\n    for i in range(2, n_s):\n        if (n % i) == 0:\n            return False\n    return True\ndef msg():\n    n = int(input('Enter a number, I will return True if it is a prime'))\n    return n\nprint(check_n(msg()))\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "A formula to count the number of primes in an certain range in Google Sheets\r\n                \r\nI am a beginner in Google Sheets formulas, so I do not know anything in this area. I need to know a formula that returns the number of primes. I'm very sure primality testing algorithms are not very simple (I've never made one before).\n    ", "Answer": "\r\na scripted solution for:\n\n\ndetecting primes: ```\n=ISPRIME(A1)```\n\ncounting primes in a range: ```\n=COUNTPRIME()```\n\ncounting composite numbers in a range: ```\n=COUNTCOMPOSITE()```\n\n\n\ncredit to OP\n\n```\nfunction ISPRIME(n) {\n  if(typeof n !== \"number\") return false;\n  if(Math.floor(n) !== n) return false;\n  if(n <= 1) return false;\n  if(n <= 3) return true;\n  if(n % 2 === 0 || n % 3 === 0) return false;\n  for(var i = 5; i*i <= n; i += 6) {\n    if(n % i === 0  || n % (i + 2) === 0) return false;\n  }\n  return true;\n}\nfunction COUNTPRIME() {\n  var sheet = SpreadsheetApp.getActiveSheet();\n  var range = sheet.getRange(\"A1:T25\");\n  var values = range.getValues();\n  var count = 0\n  values.forEach(function (array){\n    array.forEach(function (value){\n      if (ISPRIME(value)) count++;\n    })\n  })\n  return count;\n}\nfunction COUNTCOMPOSITE() {\n  var sheet = SpreadsheetApp.getActiveSheet();\n  var range = sheet.getRange(\"A1:T25\");\n  var values = range.getValues();\n  var count = 0\n  values.forEach(function (array){\n    array.forEach(function (value){\n      if (!ISPRIME(value)) count++;\n    })\n  })\n  return count;\n}\n```\n\n\nnote: change ```\nA1:T25```\n in the script to reflect your range\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "What would be a better way to check if a number is prime? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Checking if an int is prime more efficiently  \n\n\n\n\n```\nbool isPrime(int num)\n{\n    for(int i = 2; i <= (num/2)+1; i++)\n    {\n        if(num % i == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n\nI've looked on Wikipedia, but I don't understand any of the fast primality tests it describes.\n    ", "Answer": "\r\nFor one thing, you only need to iterate while ```\ni * i <= num```\n.\n\nAfter that, you might notice that testing whether a number is a multiple of 2 is just a bit test.  Once you know the number isn't even, you know there are no even factors, so you can skip testing them.\n\nThat leads to:\n\n```\nbool isPrime(int num)\n{\n    if (num < 4) return true;\n    if (~num & 1) return false;\n    for( int i = 3; i * i <= num; i += 2 )\n    {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "I'm using the sieve of Eratosthenes as a primality test. Why am I getting that 2297 is composite?\r\n                \r\nI am using the Sieve of Eratosthenes to calculate the first 500 prime numbers. What the program does is evauate ```\nn % p```\n where ```\nn```\n is the user input and ```\np```\n is between 2 and sqrt(n). \n\nI'm testing my program for the case ```\nn = 2297```\n, which is a prime. Why does my program say it's composite?\n\n```\nbool primalityTestSieve(int n){\n    if(n == 2) return true; //tiny complication due to ceil(sqrt(2))\n\n    //Sieve with first MAX\n    bool arr[MAX - 1];\n    int i, j, s = ceil(sqrt(n));\n    for(i = 2; i < MAX; i++){\n        arr[i - 2] = true;          //fill arr[] with true\n    }\n    for(i = 2; i < (int) sqrt(MAX); i++){\n        if(arr[i - 2]){\n            for(j = i*i; j < MAX; j+= i)\n                arr[j - 2] = false;\n        }\n    }\n\n    //Array storing the primes\n    int primes[MAX];\n    j = 0;  //Counter for the index of the primes\n    for(i = 0; i < MAX; i++)\n        if(arr[i]){\n            primes[j] = i + 2;\n            j++;\n        }\n\n    //Prime test, first using sieve\n    for(i = 0; primes[i] <= s; i++)\n        if(n % primes[i] == 0) return false;\n\n    //Naive prime test for larger divisors\n    for (i = primes[j]; i <= s/2; i++)\n            if(((n % 2) == 0)||((n % (2*i + 1)) == 0))  return false;\n    return true;\n}\n```\n\n\nNote that ```\nMAX```\n is a parameterised macro and is equal to 500. \n    ", "Answer": "\r\nYour code uses the sieve to find the primes between ```\n2```\n and ```\n500```\n.  (Not the first 500 primes as you seem to say in your text).  \n\nThen you copy those primes into the ```\nprimes[]```\n array with ```\nj```\n as the count of how many items are in the array. So at this point ```\nprimes[]```\n contains some numbers less than ```\n500```\n followed by a bunch of junk.\n\nThen you have the code:\n\n```\nfor(i = 0; primes[i] <= s; i++)\n```\n\n\n```\ns```\n would be ```\n48```\n for ```\nn == 2297```\n. This loop will then check for ```\nn```\n being divisible by any of the primes up to ```\n48```\n , which would fail.  (This loop should also have ```\ni < j```\n as a condition so it does not read into the junk if you enter a large ```\nn```\n).\n\nHowever you then write:\n\n```\nfor (i = primes[j]; i <= s/2; i++)\n```\n\n\nRemmeber that ```\nj```\n currently holds the prime count, and the primes are in ```\nprimes[0]```\n through ```\nprimes[j-1]```\n. This means ```\nprimes[j]```\n is a junk value; so you set ```\ni```\n to junk causing undefined behaviour.\n\n(I'm not sure what you were actually trying to do in that last loop, it's unclear where you want to start and finish, or why you test ```\nn%2```\n every loop iteration, etc. - if you can describe what you are trying to do there then I'll suggest some code).\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Haskell - What does the lambda in this primality test mean and how does this work?\r\n                \r\nFrom http://www.haskell.org/haskellwiki/Testing_primality, there is this code:\n\n```\nisPrime n = n > 1 &&\n    foldr (\\p r -> p*p > n || ((n `rem` p) /= 0 && r)) True primes\n```\n\n\nWhere primes is a list of prime numbers (possibly infinite).\n\nTwo questions:\n\n\nHow would one read the lambda passed to ```\nfoldr```\n function\nSince ```\nfoldr```\n starts from the right, why does this function work when it is passed an infinite list of primes?  I'm guessing there is a short circuit built into the lambda?\n\n    ", "Answer": "\r\nLazy evaluation means boolean short-circuit logic stops a chain of functions being evaluated, even where the logic is inside the functions.\n\nAs a simple example, for any Foldable data type, you can write a ```\nnull```\n function like this:\n\n```\nnull t = foldr (\\x b -> False && b) True t\n```\n\n\nThis function will never be called more than once, because for an instance with more than one element it will evaluate to\n\n```\nFalse && *thunk* foldr...\n```\n\n\nThe short-circuit boolean and means that the thunk is never evaluated, so this will happily work with infinite structures.  Which is why you shouldn't implement ```\nnull```\n as a check to see if ```\nsize == 0```\n\n\nThis doesn't work in a strict language; each iterations of foldr would be evaluated in turn and passed to the next. \n\nAs for the lambda...\n\n```\nisPrime n = n > 1 &&\n    foldr (\\p r -> p*p > n || ((n `rem` p) /= 0 && r)) True primes\n```\n\n\ncould be written like this:\n\n```\nisPrime n = n > 1 &&\n    foldr f True primes\n    where\n        f p r = p*p > n || ((n `rem` p) /= 0 && r)\n```\n\n\nHope that helps.\n\nEDIT: If it wasn't clear, the short-circuit boolean or ```\n||```\n in that function works in the same way as the simpler example above.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Lisp - \"when\" condition executing no matter what?\r\n                \r\nI'm defining a function to test if a number is prime and I have an algorithm which works (in Python) and I have ported most of it to Lisp. The problem however is that my primality test keeps passing even when it shouldn't. For example, ```\nisPrime(13)```\n still reaches the ```\nreturn NIL```\n even though it should fail the ```\nwhen```\n condition.\n```\n(defun isPrime(n)\n    (cond \n        ((< n 2); numbers less than 2 aren't prime\n            NIL\n        )\n        ((equal n 2); 2 is the only even prime\n            T\n        )\n        ((equal (rem n 2) 0); Even numbers are never prime (besides 2)\n            NIL\n        )\n        ((> n 2)\n            (loop for i from 2 to n do(\n                    when(equal (rem n i) 0);If n is evenly divisible by i, we have found a factor other than 1 and n\n                        (return NIL)                   \n                )\n            ) \n        )\n        (t T); If we get through all that with no issue, the number is prime\n    )\n)\n```\n\nQuestion: Why does my function reach the ```\nreturn NIL```\n branch no matter what?\nAlso, if this is just a bad approach to testing primality, is there a more lisp-like way of doing this (not worried about performance, just algorithmic correctness and readability.)\n    ", "Answer": "\r\nFirst of all your code has a fairly obvious bug: once you've hit the ```\n(> n 2)```\n case of the ```\ncond```\n then either it's going to explicitly return ```\nnil```\n or it will get to the end of the loop and ... implicitly return ```\nnil```\n.  The final case of the ```\ncond```\n will never be reached.\nHere is a version of it which\n\nis formatted using standard Lisp conventions not ones imported from C or somewhere;\nuses a conventional Lisp name for the function;\nuses better operations (compare numbers with ```\n=```\n not ```\nequal```\n, for instance);\nuses better bounds on the loop and a better step (no need to check even numbers, you've just done that);\nfixes the bug.\n\n```\n(defun primep (n)\n  (cond\n   ((< n 2)\n    ;; numbers less than 2 are not prime\n    nil)\n   ((= n 2)\n    ;; 2 is prime\n    t)\n   ((evenp n)\n    ;; even numbers are not prime\n    nil)\n   (t\n    ;; Otherwise it is a prime if no odd integer less than or equal to\n    ;; its root divides it.\n    (loop for i from 3 to (isqrt n) by 2\n          never (zerop (rem n i))))))\n```\n\nHowever a more natural way to express this in Lisp might well be to say what you would say in English:\n\nn is prime if it is 2 or if it is greater 2 and if it is odd, and if it has no odd divisors less than or equal to its square root.\n\nWhich we would write like this\n```\n(defun primep (n)\n  (or (= n 2)                           ;2 is prime ...\n      (and                              ;... otherwise ...\n       (> n 2)                          ;... primes must be > 2 ...\n       (oddp n)                         ;... odd ...\n       ;; ... and have no odd divisorts <= their roots\n       (loop for i from 3 to (isqrt n) by 2\n             never (zerop (rem n i))))))\n```\n\nFinally you might want to check that the argument has a reasonable type: primality testing makes sense for natural numbers, so:\n```\n(defun primep (n)\n  (check-type n (integer 0) \"a natural number\")\n  (or (= n 2)                           ;2 is prime ...\n      (and                              ;... otherwise ...\n       (> n 2)                          ;... primes must be >= 2 ...\n       (oddp n)                         ;... odd ...\n       ;; ... and have no odd divisorts <= their roots\n       (loop for i from 3 to (isqrt n) by 2\n             never (zerop (rem n i))))))\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Working with large numbers in PHP\r\n                \r\nTo use modular exponentiation as you would require when using the Fermat Primality Test with large numbers (100,000+), it calls for some very large calculations.\n\nWhen I multiply two large numbers (eg: 62574 and 62574) PHP seems to cast the result to a float. Getting the modulus value of that returns strange values.\n\n```\n$x = 62574 * 62574;\nvar_dump($x);          // float(3915505476) ... correct\nvar_dump($x % 104659); // int(-72945)  ... wtf.\n```\n\n\nIs there any way to make PHP perform these calculations properly? Alternatively, is there another method for finding modulus values that would work for large numbers?\n    ", "Answer": "\r\nFor some reason, there are two standard libraries in PHP handling the arbitrary length/precision numbers: BC Math and GMP. I personally prefer GMP, as it's fresher and has richer API.\n\nBased on GMP I've implemented Decimal2 class for storing and processing currency amounts (like USD 100.25). A lot of mod calculations there w/o any problems. Tested with very large numbers.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Proving the primality of strong probable primes\r\n                \r\nUsing the probabilistic version of the Miller-Rabin test, I have generated a list of medium-large (200-300 digit) probable primes. But probable ain't good enough! I need to know these numbers are prime. Is there a library -- preferably wrapped or wrappable in Python -- that implements one of the more efficient primality proving algorithms?\n\nAlternatively, does anyone know where I can find a clear, detailed, and complete description of ECPP (or a similarly fast algorithm) that does not assume a great deal of prior knowledge?\n\nUpdate: I've found a Java implementation of another test, APRT-CLE, that conclusively proves primality. It verified a 291-digit prime candidate in under 10 minutes on an atom processor. Still hoping for something faster, but this seems like a promising start.\n    ", "Answer": "\r\nAs an algorithm that gives a reliable polynomial primality test, consider AKS. There is an older SO article referencing implementations and presentations of the algorithm.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why is pow(a, d, n) so much faster than a**d % n?\r\n                \r\nI was trying to implement a Miller-Rabin primality test, and was puzzled why it was taking so long (> 20 seconds) for midsize numbers (~7 digits). I eventually found the following line of code to be the source of the problem:\n\n```\nx = a**d % n\n```\n\n\n(where ```\na```\n, ```\nd```\n, and ```\nn```\n are all similar, but unequal, midsize numbers, ```\n**```\n is the exponentiation operator, and ```\n%```\n is the modulo operator)\n\nI then I tried replacing it with the following:\n\n```\nx = pow(a, d, n)\n```\n\n\nand it by comparison it is almost instantaneous.\n\nFor context, here is the original function:\n\n```\nfrom random import randint\n\ndef primalityTest(n, k):\n    if n < 2:\n        return False\n    if n % 2 == 0:\n        return False\n    s = 0\n    d = n - 1\n    while d % 2 == 0:\n        s += 1\n        d >>= 1\n    for i in range(k):\n        rand = randint(2, n - 2)\n        x = rand**d % n         # offending line\n        if x == 1 or x == n - 1:\n            continue\n        for r in range(s):\n            toReturn = True\n            x = pow(x, 2, n)\n            if x == 1:\n                return False\n            if x == n - 1:\n                toReturn = False\n                break\n        if toReturn:\n            return False\n    return True\n\nprint(primalityTest(2700643,1))\n```\n\n\nAn example timed calculation:\n\n```\nfrom timeit import timeit\n\na = 2505626\nd = 1520321\nn = 2700643\n\ndef testA():\n    print(a**d % n)\n\ndef testB():\n    print(pow(a, d, n))\n\nprint(\"time: %(time)fs\" % {\"time\":timeit(\"testA()\", setup=\"from __main__ import testA\", number=1)})\nprint(\"time: %(time)fs\" % {\"time\":timeit(\"testB()\", setup=\"from __main__ import testB\", number=1)})\n```\n\n\nOutput (run with PyPy 1.9.0):\n\n```\n2642565\ntime: 23.785543s\n2642565\ntime: 0.000030s\n```\n\n\nOutput (run with Python 3.3.0, 2.7.2 returns very similar times):\n\n```\n2642565\ntime: 14.426975s\n2642565\ntime: 0.000021s\n```\n\n\nAnd a related question, why is this calculation almost twice as fast when run with Python 2 or 3 than with PyPy, when usually PyPy is much faster?\n    ", "Answer": "\r\nSee the Wikipedia article on modular exponentiation.  Basically, when you do ```\na**d % n```\n, you actually have to calculate ```\na**d```\n, which could be quite large.  But there are ways of computing ```\na**d % n```\n without having to compute ```\na**d```\n itself, and that is what ```\npow```\n does.  The ```\n**```\n operator can't do this because it can't \"see into the future\" to know that you are going to immediately take the modulus.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "miller-rabin test don't work for 252097800623\r\n                \r\nI'm trying to write miller-rabin test. I found few codes such as:\n\nhttps://www.sanfoundry.com/cpp-program-implement-miller-rabin-primality-test/\nhttps://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/\n\nOf course all this codes works for 252097800623 ( which is prime number ), but this is becaouse they are parsing it to int. When I changed all ints to long long in this codes they are now returning NO. I also wrote my own code based on another article and it worked when I was testing it with small numbers like 11, 101, 17 and even 1000000007, but chrashed on greater numbers like 252097800623. I want to write program that works for all integers from 1 to 10^18\n\nEDIT\n\nhere is modified code form 1st link:\n\n```\n/* \n\n * C++ Program to Implement Milong longer Rabin Primality Test\n\n */\n\n#include <iostream>\n\n#include <cstring>\n\n#include <cstdlib>\n\nusing namespace std;\n\n\n\n/* \n\n * calculates (a * b) % c taking long longo account that a * b might overflow \n\n */\n\nlong long mulmod(long long a, long long b, long long mod)\n\n{\n\n    long long x = 0,y = a % mod;\n\n    while (b > 0)\n\n    {\n\n        if (b % 2 == 1)\n\n        {    \n\n            x = (x + y) % mod;\n\n        }\n\n        y = (y * 2) % mod;\n\n        b /= 2;\n\n    }\n\n    return x % mod;\n\n}\n\n/* \n\n * modular exponentiation\n\n */\n\nlong long modulo(long long base, long long exponent, long long mod)\n\n{\n\n    long long x = 1;\n\n    long long y = base;\n\n    while (exponent > 0)\n\n    {\n\n        if (exponent % 2 == 1)\n\n            x = (x * y) % mod;\n\n        y = (y * y) % mod;\n\n        exponent = exponent / 2;\n\n    }\n\n    return x % mod;\n\n}\n\n\n\n/*\n\n * Milong longer-Rabin primality test, iteration signifies the accuracy\n\n */\n\nbool Miller(long long p,long long iteration)\n\n{\n\n    if (p < 2)\n\n    {\n\n        return false;\n\n    }\n\n    if (p != 2 && p % 2==0)\n\n    {\n\n        return false;\n\n    }\n\n    long long s = p - 1;\n\n    while (s % 2 == 0)\n\n    {\n\n        s /= 2;\n\n    }\n\n    for (long long i = 0; i < iteration; i++)\n\n    {\n\n        long long a = rand() % (p - 1) + 1, temp = s;\n\n        long long mod = modulo(a, temp, p);\n\n        while (temp != p - 1 && mod != 1 && mod != p - 1)\n\n        {\n\n            mod = mulmod(mod, mod, p);\n\n            temp *= 2;\n\n        }\n\n        if (mod != p - 1 && temp % 2 == 0)\n\n        {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n\n//Main\n\nint main()\n\n{\n\n    long long iteration = 5;\n\n    long long num;\n\n    cout<<\"Enter long longeger to test primality: \";\n\n    cin>>num;\n\n    if (Miller(num, iteration))\n\n        cout<<num<<\" is prime\"<<endl;\n\n    else\n\n        cout<<num<<\" is not prime\"<<endl;\n\n    return 0;\n\n}\n```\n\n    ", "Answer": "\r\nThe code in the first link, which you replicated in your question, replacing the (bad) macro ```\nll```\n with ```\nlong long```\n (although this produces exactly the same preprocessed code) and all ```\nint```\n with ```\nlong long```\n, is already broken for large values, see compiler explorer here. I forced the compiler to evaluate the ```\nMiller```\n function for ```\n252097800623```\n at compile time, replacing the call to ```\nrand()```\n with one random number ```\n123456```\n.\n\nAs you can see the compiler is telling me that it cannot do so, because there are integer overflows in the program. In particular:\n\n```\n<source>:133:17: error: static_assert expression is not an integral constant expression\n  static_assert(Miller(num, iteration));\n                ^~~~~~~~~~~~~~~~~~~~~~\n<source>:62:12: note: value 232307310937188460801 is outside the range of representable values of type 'long long'\n    y = (y * y) % mod;\n           ^\n<source>:104:14: note: in call to 'modulo(123457, 63024450155, 252097800623)'\n    ll mod = modulo(a, temp, p);\n             ^\n<source>:133:17: note: in call to 'Miller(252097800623, 5)'\n  static_assert(Miller(num, iteration));\n```\n\n\nAs you can see ```\nlong long```\n is simply too small to handle inputs that large to this algorithm.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fast algorithm for finding the nearest smaller prime number\r\n                \r\neg:- If the given number is 10 we have to return 7 (as it the nearest smaller prime number)\nThe way I could think of is this:-\nMainloop: Test whether the given number is prime or not (by applying a primality test),\nIf it's prime then return the number else decrement the number by 1 and goto                     Mainloop.\nBut I have to work on long long int range and its taking a lot of time.\nIs there a better approach to it, also if I should go with the above way only then which primality test should I use?\n    ", "Answer": "\r\nIf the size of your inputs is bounded, lookup in a table of precomputed primes will probably be the fastest.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Deterministically checking whether a large number is prime or composite?\r\n                \r\nI'm searching for an algorithm to primality test large (like 10200) numbers. \nAre there any good algorithms? \n\nIdeally, I'd prefer an algorithm that isn't probabalistic.\n\nNote: Numbers have over 50 and less then 200 digits.\n    ", "Answer": "\r\nIf you're looking for a non-probabalistic test, you may want to check out the AKS primality testing algorithm, which runs in roughly O(log6 n) time.  For the number of digits you have, this is probably feasible.\n\nThat said, probabalistic primality tests are extremely good and many have exponentially small error rates.  I would suggest using one of those unless there's a good reason not to.\n\nEDIT: I just found this page containing several C++ implementations of AKS.  I have no idea whether they work correctly or not, but they might be a good starting point.\n\nHope this helps!\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why do we close scanner like this?\r\n                \r\nI was creating a primality testing program and here's the following snippet.\n\n```\nimport java.util.Scanner;\n\npublic class LargestPrime {\n\npublic static boolean CheckPrimality(int num){\n\n    int factor = 1;\n    int limit = (int) Math.sqrt(num);\n    for(int i = 2; i<= limit; i++){\n        if(num % i == 0){\n            factor = i;\n        }\n    }\n\n    if(factor == 1){\n        return true;\n    }\n    else {return false;}\n}\n\n    public static void main(String[] args) {\n        Scanner reader = new Scanner(System.in);\n        System.out.println(\"Please enter a number: \");\n        int number = reader.nextInt();\n        System.out.println(CheckPrimality(number));\n\n        if(reader != null){\n            reader.close();\n        }\n\n    }\n\n}\n```\n\n\nI'm just confused as to why we close the scanner when 'reader != null'. When the reader is not null, that means there is still stuff in the scanner, right? Why wouldn't we close the scanner when reader IS null instead?\n    ", "Answer": "\r\nTo be blunt:  you shouldn't be closing STDIN.  You don't know what other parts of the application (even those that you didn't implement) may still be using that stream.\n\n\n  I'm just confused as to why we close the scanner when 'reader != null'. When the reader is not null, that means there is still stuff in the scanner, right?\n\n\nNo.  This is a ```\nScanner```\n that has nothing in its buffer, yet is non-null:\n\n```\nScanner scan = new Scanner(new File(\"file.txt\"));\n```\n\n\nIf you want to see if anything still left in the scanner, then you can use ```\nhasNext()```\n or ```\nhasNextLine()```\n, depending on what you need to verify.\n\n\n  Why wouldn't we close the scanner when reader IS null instead?\n\n\nWhat would we be closing then?  The ```\n.close()```\n method lives on an instance of ```\nScanner```\n, and if that's ```\nnull```\n, then we'd be doing this:\n\n```\nScanner badScanner = null;\nbadScanner.close(); // NullPointerException\n```\n\n\nIf you're concerned about resource management, a ```\nScanner```\n in Java 7 implements ```\nAutoCloseable```\n, so you can use a ```\ntry```\n-with-resources to handle the closure of the stream (but please, not STDIN).\n\n```\ntry(Scanner scan = new Scanner(new File(\"myFile.txt\")) {\n    // work done with file\n}\n```\n\n\nIn Java 6 and below, you can use a ```\ntry...finally```\n block to accomplish the same thing.\n\n```\nScanner scan = null;\ntry {\n    scan = new Scanner(new File(\"myFile.txt\"));\n    // work done with file\n} finally {\n    scan.close();\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Need to print out value in Catch statement after a thrown out of memory error [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Is it possible to catch out of memory exception in java? [duplicate]\r\n                            \r\n                                (9 answers)\r\n                            \r\n                    \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have a primality testing routine that is running out of memory and I want to find the value that it is barfing on, but I can't print it out! Relevant code fragment:\n\n```\ntry{\n            // truncate left to right\n            for( int xTruncation = 1; xTruncation < lenValue; xTruncation++ ){\n                integerValue[0]--;\n                long value = Arithmetic.integerToLong10( integerValue );\n                if( ! Numbers.primeIs( value ) ) continue NextPermutation; // the number is not prime\n            }\n            integerValue[0] = lenValue; // restore length\n\n            // truncate right to left\n            for( int xTruncation = 1; xTruncation < lenValue; xTruncation++ ){\n                Arithmetic.integerReduce( integerValue, 1 );\n                long value = Arithmetic.integerToLong10( integerValue );\n                if( ! Numbers.primeIs( value ) ) continue NextPermutation; // the number is not prime\n            }\n} catch( Throwable t ) {\n    System.out.println( \"last value: \" + nValue );\n}\n```\n\n\nHere is the output:\n\n```\n23\n37\n73\n313\n317\n373\n797\n3137\n3797\n739397\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n    at cra.common.Numbers_jsc.factor(Numbers.java:153)\n    at cra.common.Numbers_jsc.primeIs(Numbers.java:78)\n    at Euler50.Euler_37(Euler50.java:803)\n    at Euler50.main(Euler50.java:15)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:601)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)\n```\n\n\nThe System.out.println in the catch clause never gets called. How can I print out the problematic value?\n    ", "Answer": "\r\nYou can add the ```\nSystem.out.println```\n before the exception thrown. For example:\n\n```\ntry{\n            // truncate left to right\n            for( int xTruncation = 1; xTruncation < lenValue; xTruncation++ ){\n                integerValue[0]--;\n\n                System.out.println( \"integerValue: \" + integerValue );\n                long value = Arithmetic.integerToLong10( integerValue );\n                System.out.println( \"value: \" + value );\n                if( ! Numbers.primeIs( value ) ) continue NextPermutation; // the number is not prime\n            }\n            integerValue[0] = lenValue; // restore length\n\n            // truncate right to left\n            for( int xTruncation = 1; xTruncation < lenValue; xTruncation++ ){\n                Arithmetic.integerReduce( integerValue, 1 );\n                System.out.println( \"integerValue: \" + integerValue );\n                long value = Arithmetic.integerToLong10( integerValue );\n                System.out.println( \"value: \" + value );\n                if( ! Numbers.primeIs( value ) ) continue NextPermutation; // the number is not prime\n            }\n} catch( Throwable t ) {\n    System.out.println( \"last value: \" + nValue );\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Enumerating large (20-digit) [probable] prime numbers\r\n                \r\nGiven A, on the order of 10^20, I'd like to quickly obtain a list of the first few prime numbers greater than A. OK, my needs aren't quite that exact - it's alright if occasionally a composite number ends up on the list.\n\nWhat's the fastest way to enumerate the (probable) primes greater than A?\n\nIs there a quicker way than stepping through all of the integers greater than A (other than obvious multiples of say, 2 and 3) and performing a primality test for each of them? If not, and the only method is to test each integer, what primality test should I be using?\n    ", "Answer": "\r\nGreat question. This is still not proved to be in polynomial time (polynomial in the number of digits, here 20) — this was the Finding Primes Polymath project, where several mathematicians (including Fields Medallists Terence Tao and Tim Gowers!) tried to come up with an algorithm, but the project doesn't seem to have had any concrete results yet.\n\nAnyway, there are several things you can do. One of them, as you and others have pointed out, is to try each number and check whether it's prime, with a fast primality test like Miller–Rabin. By well-known number-theoretic heuristics (based on the prime number theorem), the \"probability\" of a number near n being prime is around 1/ln(n), so with 10^20, about in every 46 numbers will be prime. So if you want k 20-digit numbers, you'll run the Miller-Rabin test on about 50k numbers.\n\nThe second approach, which I think might be faster if you're doing this for many many A's (haven't thought carefully) is to instead use a sieve, like the Sieve of Eratosthenes. If you want k primes, make an array with about 50k numbers (or more to be safe), and sieve through them. You'd start with a precomputed list of primes less than some number. (1010 to be perfectly correct, but since you're willing to tolerate some composite numbers, a smaller list of prime numbers will do, e.g. testing by the first 50 million primes, ensures your numbers have no prime factors below 982,451,653, and there aren't many of them.)\n\nThe third approach is to find someone else's implementation for this problem. :-) For example, there's a webpage that given a number, finds the next prime number or finds the next ten prime numbers. If you use it online it appears you'll have to copy them down by hand, but the source code is available too.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Does this code make sense? Prime numbers in Python\r\n                \r\n```\ndef prime_checker(num):\n    if num <=1:\n        print('Not Prime')\n    elif num == 2:\n        print('Prime')\n    else:\n        for i in (2, (num ** (1/2))):\n                if num%i == 0:\n                    print('Not Prime')\n                    break\n                else:\n                    print('Prime')\n                    break\n```\n\n\nI am super new to coding, just learning the basics. I based it off of the primality test I found on Wikipedia.\n\nI think it works. It might be cumbersome, but it seems to work. \n    ", "Answer": "\r\nThe iterator for your ```\nfor```\n loop should be a range of integers, not just a tuple of 2 and the square root the number. When using ```\nrange```\n, be sure to convert the bounds to integers with ```\nint```\n first. And it's only considered a prime number if the number cannot be divided by any of the numbers in the loop, so you should declare a prime number only after the loop finishes, or otherwise the loop should declare \"not prime\" and returns.\n\n```\ndef prime_checker(num):\n    if num <=1:\n        print('Not Prime')\n    elif num == 2:\n        print('Prime')\n    else:\n        for i in range(2, int(num ** (1/2)) + 1):\n            if num%i == 0:\n                print('Not Prime')\n                return\n        print('Prime')\n\nprime_checker(63)\nprime_checker(31)\nprime_checker(9)\n```\n\n\nThis outputs:\n\n```\nNot Prime\nPrime\nNot Prime\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How can I generate prime palindromes in a given range without complete searching it and using a check function?\r\n                \r\nI have seen previous solutions to this problem, but it is all complete search with a check function and not fast enough for me.\nI am working on a C++ program trying to generate all prime palindromes highly efficiently in a given range of integers. For the prime part, I have created a fast primality tester by cutting down on divisors I test by eliminating all multiples of 2 and 3, though suggestions for improvement here would also be appreciated (function pasted below).\nMy main issue is that I need to generate palindromes fast enough without using the conventional complete search and palindrome test that slowly increments the tested integer. My current search code and primality test are pasted below.\nI have tried to increment the digits of a number in the middle then the outer ones, but because over time more digits are added over time I couldn't even piece together an algorithm.\nPrimality Test:\n```\nbool CheckPrime(int n){\n    switch (n) {\n    case 1: return false;  break;\n    case 2: return true;  break;\n    case 3: return true;  break;\n    default: break;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\nPalindrome Test + Main Function\n```\nbool CheckPalindrome (int n) {\n    string temp = to_string(n);\n    reverse(temp.begin(), temp.end());\n    if (temp.compare((to_string(n))) == 0) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\nint main() {\nint L, R; cin >> L >> R;\nvector <int> Palindromes;\nfor (int i = L; i <= R; i++) {\n    if (CheckPalindrome(i)) {\n        Palindromes.push_back(i);\n    }\n}\n}\n```\n\n    ", "Answer": "\r\nString conversions are not only slow, but put pressure on the memory allocator. This is a big issue if you are performing lots of queries.\nInstead, you can use math to reverse the digits. All you do is pull each digit off the right-hand side of your number and add it to the right-hand side of another number:\ne.g.\n```\nStep      Value     Digit     Reversed\n0         12345     -         0\n1         1234      5         5\n2         123       4         54\n3         12        3         543\n4         1         2         5432\n5         0         1         54321\n```\n\nNotice that by step 3 we can already determine that the number will not be a palindrome, because the \"reversed\" value has become greater than the remaining value.\nThe code might look something like this:\n```\nbool CheckPalindrome(unsigned int value)\n{\n    unsigned int reverse = 0;\n    while (value > reverse)\n    {\n        reverse = reverse * 10 + value % 10;\n        if (value == reverse) return true;\n        value /= 10;\n    }\n    return value == reverse;\n}\n```\n\nNote that the check in the middle of the loop catches the case where the number of digits in the palindrome is odd.\nThis will help improve performance. And if you really want a speed boost then you should use something like the Sieve of Eratosthenes. Provided you know the maximum value required for prime testing, you can generate the prime table extremely fast.\nHere's a quick and dirty implementation. It's not very memory efficient, but it's simple to write. You're welcome to make it use less memory by condensing the data to bits and removing all even entries. That will reduce the memory consumption by a factor of 16.\n```\nclass PrimeSieve\n{\npublic:\n    PrimeSieve(unsigned int maxval)\n    {\n        isPrime.resize(maxval, 1);\n        isPrime[0] = isPrime[1] = 0;\n        for(unsigned int i = 2; i < maxval; i++)\n        {\n            if (!isPrime[i]) continue;\n            for(int x = i *2; x < maxval; x += i) isPrime[x] = 0;\n        }\n    }\n\n    bool operator[](unsigned int value) const\n    {\n        return isPrime[value] != 0;\n    }\n\n    unsigned int size() const {\n        return isPrime.size();\n    }\n\nprivate:\n    std::vector<char> isPrime;\n};\n```\n\nNow, if you have a sieve already computed, then your prime test actually becomes way faster than your palindrome test. So you only need to call it as many times as there are prime numbers. With that approach, you can generate lots of palindromic primes rather quickly:\n```\nint main()\n{\n    PrimeSieve sieve(100000000);\n    for (unsigned int i = 1; i < sieve.size(); i++)\n    {\n        if (sieve[i] && CheckPalindrome(i))\n        {\n            std::cout << i << \" is a palindromic prime.\\n\";\n        }\n    }\n}\n```\n\n\nResults, after some experiments\nI did a little bit of basic testing, and found to my surprise that using the sieve for prime-testing is actually overkill here, and leads to worse performance -- at least when searching the entire space once.\nBecause the actual number of palindromic primes is very small compared to the number of primes, it seems there's better efficiency by first using the fast palindrome test, and then performing the naive prime-test if required.\nOn my computer, searching the first 1 billion integers (to find 5953 total palindromic primes), I get the following results:\nUsing sieve approach:\n```\nGenerating prime table: 14.374s\nSearching palindromic primes: 1.138s\nTotal search using sieve: 15.513s\n```\n\nUsing naive approach:\n```\nSearching palindromic primes: 9.206s\nTotal search with naive prime calculation: 9.206s\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Checks the primality of consecutive odd integers in a specified range\r\n                \r\nThe following program finds the smallest integral divisor (greater than ```\n1```\n) of a given number ```\nn```\n. It does this in a straightforward way, by testing ```\nn```\n for divisibility by successive integers starting with ```\n2```\n.\n\n```\nn```\n is prime if and only if ```\nn```\n is its own smallest divisor.\n\n```\n(define (square x) (* x x))\n\n(define (divisible? a b)\n  (= (remainder a b) 0))\n\n(define (find-divisor n test)\n  (cond ((> (square test) n) n)\n        ((divisible? n test) test)\n        (else (find-divisor n (+ test 1)))))\n\n(define (smallest-divisor n)\n  (find-divisor n 2))\n\n(define (prime? n)\n  (= (smallest-divisor n) n))\n```\n\n\nHow to write a procedure that checks the primality of consecutive odd integers in a specified range?\n\n```\n(define (search_for_primes from to)\n   (cond ((> from to) false)\n         ((prime? from) (display from))\n         (else (search_for_primes (+ 1 from) to))))\n```\n\n\nMy solution just write ```\n1```\n to the output. \n    ", "Answer": "\r\nA ```\ncond```\n will stop at the first match and execute the corresponding expressions only. So if you execute ```\n(search_for_primes 1 xxx)```\n, 1 is erroneously identified as a prime and the procedure stops there.\n\nWhat you want is something like\n\n```\n(define (search_for_primes from to)\n  (unless (> from to)\n    (when (prime? from)\n      (display from)\n      (display \" \"))\n    (search_for_primes (+ 1 from) to)))\n```\n\n\nwhere the recursion is done regardless of whether you found a prime or not.\n\nTesting:\n\n```\n> (search_for_primes 2 100)\n2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 \n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Counting Twins-primes with AKS primality test in C++ What am I doing wrong?\r\n                \r\nGood night, I'm not a C++ especialist. I need to count the quantity of twin-primes inside 3 and the limit. My output is always giving 1. What am I doing wrong? Here's my algorithm with AKS working as well! \n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long c[100];\n\nvoid coef(int n)\n{\n    c[0] = 1;\n    for (int i = 0; i < n; c[0] = -c[0], i++) {\n        c[1 + i] = 1;\n\n        for (int j = i; j > 0; j--)\n            c[j] = c[j - 1] - c[j];\n    }\n}\n\nbool isPrime(int n)\n{\n\n    coef(n);\n\n\n    c[0]++, c[n]--;\n\n\n    int i = n;\n    while (i-- && c[i] % n == 0)\n        ;\n\n\n    return i < 0;\n}\n\nint main()\n{\n    int limit=10000,counter=1,i;\n    for(i=3;i<=limit;i+=2){\n    if (isPrime(i)){\n\n        if(isPrime(i+2)){\n                counter++;\n    }\n }\n}\ncout <<counter;\nreturn 0;\n}\n```\n\n\nI'm on codeblocks 17.02 on Windows 10 Pro. What's the stupidity am I doing? \n    ", "Answer": "\r\nThat isn't at all the AKS algorithm for primality.  It looks like a slightly modified version of the RosettaCode task which implements the exponential time lemma.  It will be slower than simple trial division, not to mention that without modular arithmetic this implementation is basically useless since it will overflow on even toy size inputs.\n\nOnce you have a proper primality test, one thing to consider would be not calling isprime() on the same inputs over and over.  You can call it once per number and just remember the last prime you found.  If isprime(i) is true, then count if the last one you found was i-2.  Now you don't need repeated calls, nor an array of values.\n\nEven better, since you want to generate all the primes to n, is to use a sieve.  It is much more efficient for that task than primality tests, even with much better primality tests.  You can find a trivial C version at the RosettaCode page for that task.  There are better ones out there, but that doesn't really matter here given what you're starting with.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "I am trying to write a function in Python encapsulating the Miller-Rabin primality test, but it is very slow\r\n                \r\nHere is my code:\n```\nimport random\n\ndef miller(n, k):\n\"\"\"\ntakes an integer n and evaluates whether it is a prime or a composite\nn > 3, odd integer to be tested for primality\nk, rounds of testing (the more tests, the more accurate the result)\n\"\"\"\ntemp = n - 1  # used to find r and d in n = 2**d * r + 1, hence temporary\nr = 0\nwhile True:\n    if temp / 2 == type(int):\n        r += 1\n    else:\n        d = temp\n        break\n    temp = temp / 2\n\nfor _ in range(k):\n    a = random.SystemRandom().randrange(2, n - 2)\n    x = a**d % n\n    if x == 1 or x == n - 1:\n        continue\n    for _ in range(r - 1):\n        x = x**2 % n\n        if x == n - 1:\n            continue\n    return \"Composite\"\nreturn \"Probably prime\"\n```\n\nCertainly there must be more effective ways to implement the algorithm in Python, so that it may handle large integers with ease?\nCheers\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to limit my output to false statements?\r\n                \r\nenter code hereMy code takes the numbers in range 500-100000 and tests them for primality twice. Once with fermit's little theorem and again with a better primality test. The output given is every number identified as prime in fermits and next to it, its correct primality in the form of true=prime and false=not prime for example:2753 is prime True,\n2767 is prime True,\n2777 is prime True,\n2779 is prime False,\n2789 is prime True,\nWhat I need to know is how do I only output the ones that are false? I can't change the functions I called on.\n\n```\n    from exactPrimalityTest import *\n    import random\n    from fastPowerMod import *\n    for n in range(500,100001):\n        a = random.randint(1,n-1)\n        for i in range(10):\n            if (fastPowerMod(a,n-1, n) != 1):\n                break\n        else:\n            print n, \"is prime\", exactPrimalityTest(n)\n```\n\n    ", "Answer": "\r\nadd this check before you print\n\n```\nres = exactPrimalityTest(n)\nif not res:\n    print n, \"is prime\", res\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Unhandled exception: NoSuchMethodException\r\n                \r\nI'm trying to write my own implementation of the Miller Rabin primality test. \nI could get it working, but it was very slow for values larger than 64 bits.\n\nIn the draft standard ANSI X9.80, \"PRIME NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES\", they specify behavior up to 1024 bits. My program (on a i7 6700k) would take months at best to run on a single 1024 bit integer.\n\nSo I turned to the java implementation of the Miller Rabin test to see what micro-optimizations they used to make the performance tenable. \n\nI've been working my way through their source code, but I've run up against a wall. A lot of the methods they use are private, and testing your codes behavior against code you can't execute is quite difficult.For starters, the first internal method I wanted to call is BigInteger.mod2( int )\n\nI've not programmed extensively in java before, but here's where I got stuck:\n\n```\nimport java.lang.reflect.*;\nimport java.math.BigInteger;\n\npublic class HelloWorld\n{\n    public static void main(String[] args)\n    {\n        BigInteger a = new BigInteger( \"123456789101112\" );\n        Method mod2 = BigInteger.class.getDeclaredMethod( \"mod2\", int.class );\n        //Class[] arg_types = new Class[1];\n        //arg_types[0] = int.class;\n        //Method mod2 = BigInteger.class.getDeclaredMethod( \"mod2\", arg_types );\n        mod2.setAccessible( true );\n        Object b = mod2.invoke( a, 32 );\n        System.out.print( b );\n    }\n}\n```\n\n\nBoth version of the 'getDeclaredMethod' call throw NoSuchMethodException exceptions. I've looked at the documentation for 'getDeclaredMethod' and they say to do exactly what I'm currently doing when people are asking how to get this function to work.\n\nAny advice on how to invoke the private methods of BigInteger, in particular ```\nBigInteger.mod2( int )```\n would be greatly appreciated. Thanks!\n    ", "Answer": "\r\nYou are on the right track. The only way to invoke private methods in Java is using reflection API. You are already using it. The only error in your program is that you are not handling the checked exception. Just surround your getDeclaredMethod call and method invocation calls with ```\ntry-catch```\n and you are good to go.\n\n```\n    BigInteger a = new BigInteger( \"123456789101112\" );\n    Method mod2 = null;\n    try {\n        mod2 = BigInteger.class.getDeclaredMethod( \"mod2\", int.class );\n    } catch (NoSuchMethodException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (SecurityException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    //Class[] arg_types = new Class[1];\n    //arg_types[0] = int.class;\n    //Method mod2 = BigInteger.class.getDeclaredMethod( \"mod2\", arg_types );\n    mod2.setAccessible( true );\n    Object b;\n    try {\n        b = mod2.invoke( a, 32 );\n           System.out.print( b );\n    } catch (IllegalAccessException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IllegalArgumentException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvocationTargetException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n```\n\n\nRead the Javadoc for the method Class::getDeclaredMethod. It says that this method throws two exceptions (1) NoSuchMethodException and (2) SecurityException. \n\nSame way, read the Javadoc for the method Method::invoke. It says that this method throws three exceptions (1) IllegalAccessException (2)                IllegalArgumentException (3) InvocationTargetException. \n\nThe calling method of these methods must catch these exceptions or add a ```\nthrows```\n clause to its own method signature listing out all these exceptions that it is not handling.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Working with large primes in Python [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhat is an efficient way for working with large prime numbers with Python? You search on here or on google, and you find many different methods for doing so... sieves, primality test algorithms... Which ways work for larger primes?\n    ", "Answer": "\r\nFor determining if a number is a prime, there a sieves and primality tests.\n\n```\n# for large numbers, xrange will throw an error.\n# OverflowError: Python int too large to convert to C long\n# to get over this:\n\ndef mrange(start, stop, step):\n    while start < stop:\n        yield start\n        start += step\n\n# benchmarked on an old single-core system with 2GB RAM.\n\nfrom math import sqrt\n\ndef is_prime(num):\n    if num == 2:\n        return True\n    if (num < 2) or (num % 2 == 0):\n        return False\n    return all(num % i for i in mrange(3, int(sqrt(num)) + 1, 2))\n\n# benchmark is_prime(100**10-1) using mrange\n# 10000 calls, 53191 per second.\n# 60006 function calls in 0.190 seconds.\n```\n\n\nThis seems to be the fastest. There is another version using ```\nnot any```\n that you see,\n\n```\ndef is_prime(num)\n    # ...\n    return not any(num % i == 0 for i in mrange(3, int(sqrt(num)) + 1, 2))\n```\n\n\nHowever, in the benchmarks I got ```\n70006 function calls in 0.272 seconds.```\n over the use of ```\nall```\n ```\n60006 function calls in 0.190 seconds.```\n while testing if ```\n100**10-1```\n was prime.\n\nIf you're needing to find the next highest prime, this method will not work for you. You need to go with a primality test, I have found the Miller-Rabin algorithm to be a good choice. It is a little slower the Fermat method, but more accurate against pseudoprimes. Using the above mentioned method takes +5 minutes on this system.\n\n```\nMiller-Rabin```\n algorithm:\n\n```\nfrom random import randrange\ndef is_prime(n, k=10):\n    if n == 2:\n        return True\n    if not n & 1:\n        return False\n\n    def check(a, s, d, n):\n        x = pow(a, d, n)\n        if x == 1:\n            return True\n        for i in xrange(s - 1):\n            if x == n - 1:\n                return True\n            x = pow(x, 2, n)\n        return x == n - 1\n\n    s = 0\n    d = n - 1\n\n    while d % 2 == 0:\n        d >>= 1\n        s += 1\n\n    for i in xrange(k):\n        a = randrange(2, n - 1)\n        if not check(a, s, d, n):\n            return False\n    return True\n```\n\n\n```\nFermat```\n algoithm:\n\n```\ndef is_prime(num):\n    if num == 2:\n        return True\n    if not num & 1:\n        return False\n    return pow(2, num-1, num) == 1\n```\n\n\nTo get the next highest prime:\n\n```\ndef next_prime(num):\n    if (not num & 1) and (num != 2):\n        num += 1\n    if is_prime(num):\n        num += 2\n    while True:\n        if is_prime(num):\n            break\n        num += 2\n    return num\n\nprint next_prime(100**10-1) # returns `100000000000000000039`\n\n# benchmark next_prime(100**10-1) using Miller-Rabin algorithm.\n1000 calls, 337 per second.\n258669 function calls in 2.971 seconds\n```\n\n\nUsing the ```\nFermat```\n test, we got a benchmark of ```\n45006 function calls in 0.885 seconds.```\n, but you run a higher chance of pseudoprimes.\n\nSo, if just needing to check if a number is prime or not, the first method for ```\nis_prime```\n works just fine. It is the fastest, if you use the ```\nmrange```\n method with it.\n\nIdeally, you would want to store the primes generated by ```\nnext_prime```\n and just read from that.\n\nFor example, using ```\nnext_prime```\n with the ```\nMiller-Rabin```\n algorithm:\n\n```\nprint next_prime(10^301)\n\n# prints in 2.9s on the old single-core system, opposed to fermat's 2.8s\n1000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000000000000000000000000531\n```\n\n\nYou wouldn't be able to do this with ```\nreturn all(num % i for i in mrange(3, int(sqrt(num)) + 1, 2))```\n in a timely fashion. I can't even do it on this old system.\n\nAnd to be sure that ```\nnext_prime(10^301)```\n and ```\nMiller-Rabin```\n yields a correct value, this was also tested using the ```\nFermat```\n and the ```\nSolovay-Strassen```\n algorithms.\n\nSee: fermat.py, miller_rabin.py, and solovay_strassen.py on gist.github.com\n\nEdit: Fixed a bug in ```\nnext_prime```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Efficiently find prime numbers in range close to 10^9\r\n                \r\nRange is [10^9-10^6 tiill 10^9]. I've tried all I could find and think off - precomputation with Sieve of Eratosthenes and precheck with Fermat's Primality Test. But still could not get it done in less than 1 minute.\n    ", "Answer": "\r\nBecause the range is only 10^6. What I think is that Sieve shouldn't perform so bad.\nFirst generate all prime numbers between 1 and 10^5 (because 10^5 squared is 10^10, and the maximum number is 10^9). And then use sieve as follows : \nCreate an array of size 10^6, where index i means, number 10^9-10^6+i, and then use your prime list to cross out all the non-primes.\nWhile using Sieve, of course you should cross out all the even numbers, initially and then you only have nearly 5000 primes in range 2 to 10^5. So overall it's roughly 10^3*10^6 which is 10^9 steps, which doesn't seems extremely complex, running time for Modern Processors.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Algorithm to find prime numbers with odd digits in large range\r\n                \r\nGiven a range of [1, 1000000000] we need to find prime numbers and all the digits of the prime number must be odd. (Example: 23 is not okay, 31 is okay)\nIf we go on by looping through each number and checking if it is prime etc, it is very slow. Is there a way to make this close to O(N) ?\nI tried to eliminate as much as possible by looking at digits first. But after eliminating numbers with even digits the prime test is too slow. \n\n\nfor all numbers in [1, N] \ncheck all digits, if any even digit, continue\ncheck primality (this step is very slow)\n\n\nAnd the primality test should not be very complex (probabilistic etc. is not possible, it must be possible to implement in a few minutes). The one I use is:\n\n```\n    private static boolean isPrime(int n) {\n        boolean isPrime = true;\n        for (int divisor = 2; divisor <= n / 2; divisor++) {\n            if (n % divisor == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n\n        return isPrime;\n   }\n```\n\n\nMaybe there is a trick to ensure a quick primality test but I couldn't find. Any suggestions?  Thanks for reading.\n    ", "Answer": "\r\nYou don't need to check all milliard numbers. Generate all numbers with only odd digits -  there are at most 5^9~2 millions of them. Exclude those ending with 5 and not generate numbers divisible by 3 (in the moment of the last digit generation)\n\nThen check these numbers for primality. Note that loop limit might be sqrt(n)\n\nIdeone\n\n```\nclass Ideone\n{\n   static int oddcnt;\n\n        public static void checkprime(int x) {\n           for (int i=3; i <= Math.sqrt(x); i +=2)\n              if ((x % i) == 0)\n                 return;\n             oddcnt++;\n        }\n\n\n    public static void genodd(int x, int curlen, int maxlen) {\n        x *= 10;\n        for (int i=1; i<10; i+=2) {\n            int nx = x + i;\n            checkprime(nx);\n            if (curlen < maxlen)\n                genodd(nx, curlen + 1, maxlen);\n        } \n    }\n\n    public static void main (String[] args) throws java.lang.Exception\n    {\n\n    genodd(0, 1, 8);\n    System.out.println(oddcnt);\n    }\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primality Macro in Common Lisp (SBCL)\r\n                \r\nHere is a macro which I wrote to test a number for primality:\n\n```\n(defmacro primep (num)\n  `(not (or ,@(loop for p in *primes* collecting `(= (mod ,num ,p) 0)))))\n```\n\n\n```\n*primes*```\n is a dynamic variable which contains a list of the primes generated so far (the context is a 'next prime generator' function). Here are the results of a few eval-ed statements:\n\n```\n(let ((*primes* (list 2 3)))\n  (primep 6))\n-> T\n\n(let ((*primes* (list 2 3)))\n  (macroexpand-1 '(primep 6))\n-> (NOT (OR (= (MOD 6 2) 0) (= (MOD 6 3) 0)))\n-> T\n\n(NOT (OR (= (MOD 6 2) 0) (= (MOD 6 3) 0)))\n-> NIL\n```\n\n\nWhat is going on?\n    ", "Answer": "\r\nYou should use a function for this. Macros are for generating code. The problem here is that the ```\nLET```\n binding for ```\n*PRIMES*```\n happens at run-time, not during macroexpansion.\n\nYour code as a function would look something like this.\n\n```\n(defparameter *primes* (list))\n\n(defun primep (num)\n  (not (loop for p in *primes* thereis (zerop (mod num p)))))\n\n(let ((*primes* (list 2 3)))\n  (primep 6))\n;=> NIL\n\n(let ((*primes* (list 2 3)))\n  (primep 7))\n;=> T\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "BigInteger logic problems in simple statement [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Compare two objects with .equals() and == operator\r\n                            \r\n                                (16 answers)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nSo I'm writing a primality test program, and somewhere along my code I have this:\n\n```\nBigInteger temp = BigInteger.valueOf(0);\nBigInteger p_Big = BigInteger.valueOf(p); // p is just an integer\n\ntemp = power(a, p-1); // a method to calculate a^(p-1)\ntemp = temp.mod(p_Big);\n\nif(temp != BigInteger.ONE){\n    return false;\n}\n```\n\n\nProblem is, I get ```\nfalse```\n for values that should've returned ```\ntrue```\n, and the weird thing is that when I do\n\n```\nSystem.out.println(temp+\",\"+BigInteger.ONE);\n```\n\n\nfor ```\np = 5, a = 2```\n I get\n\n```\n1,1\n```\n\n\nSo what's causing it to return ```\nfalse```\n?\n    ", "Answer": "\r\nReplace \n\n```\nif(temp != BigInteger.ONE)\n```\n\n\nwith\n\n```\nif(!temp.equals(BigInteger.ONE))\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Java API for Prime Number and Factorization [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am looking for Java API for fast primality testing and factorization of Big Numbers. Any pointer would be very helpful to me.\n\nUpdate\n\nThe resources I found are:\n\n\nBigInteger - doesn't have factorization\nPrimes - deals with integer\nLargeInteger - doesn't have factorization\n\n\nI am looking forward to an API which uses Elliptic Curve Factorization or Quadratic Sieve.\n\nAnother resource: Factorization using the Elliptic Curve Method.\n\nLimit: Number with 10000 digit.\n    ", "Answer": "\r\nI suggest Commons Math. You can find lib here API here. The class that would be interesting for you is Primes.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Method using Big Integers returns nothing\r\n                \r\nI created a Fermat primality test using Java's Big Integers. However, although no error shows up and everything looks fine, it won't return neither true nor false for any input (except for BigInteger.valueOf(3)).\n\n```\npublic static boolean isPrime (BigInteger n){\n    BigInteger counter=BigInteger.ZERO;\n    boolean isPrime=false;\n    if(n.equals(BigInteger.valueOf(2)))isPrime=true;\n    if(n.compareTo(BigInteger.valueOf(2))>0 && n.compareTo(BigInteger.valueOf(40))<0) {\n        for (BigInteger a=BigInteger.valueOf(2);a.compareTo(n.subtract(BigInteger.ONE))<0;a.add(BigInteger.ONE)) {\n            if (a.modPow(n.subtract(BigInteger.ONE),n).equals(BigInteger.ONE)) counter.add(BigInteger.ONE);\n        }\n\n        if (counter.equals(n.subtract(BigInteger.valueOf(3)))) isPrime = true;\n    }\n        else {\n\n        for (BigInteger a=BigInteger.valueOf(2);a.compareTo(BigInteger.valueOf(40))<=0;a.add(BigInteger.ONE)) {\n            if (a.modPow(n.subtract(BigInteger.ONE),n).equals(BigInteger.ONE)) counter.add(BigInteger.ONE);\n\n        }\n        if (counter.equals(BigInteger.valueOf(39))) isPrime = true;\n    }\n    return isPrime;\n}\n\n        }\n```\n\n\nIs this problem occurring due to Big Integers?\n    ", "Answer": "\r\nYour ```\na.add(BigInteger.ONE)```\n should be ```\na = a.add(BigInteger.ONE)```\n. Otherwise your ```\na```\n always has the same value, and your loop is infinite.\n\nSee BigInteger#add(value):\n\n\n  Returns a BigInteger whose value is (this + val)\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin test: impossible result\r\n                \r\nI was trying to implement the Miller-Rabin primality test on Java and confront its computational time with the native primality test of the ```\nBigInteger```\n class. Given that I'm here, you will probably have guessed that my code doesn't work. Problem is, the error I obtain is one that Lady Math says to be impossible. I would like to know what I'm doing wrong.\n\nThe idea behind the Miller-Rabin primality test, without much math, is that all primes satisfy a propriety. If that propriety is not satisfied, than the number is composite; if the propriety is satisfied, however, the number may be a prime or it may belong to a subset of the composite number called pseudoprimes. What definitely cannot happen is for a prime number to be recognized by the test as composite.\nThat is precisely what sometime happens while running my code.\n\nI searched my code for math errors and I think there are none. I tried searching for Java mistakes and I found none. Obviously there is something (or many something) I am not seeing, so I would like to ask for help.\n\n\n\nBelow is the ```\nmain```\n of a static class created just to house the implementation of the Miller-Rabin test, which is presented after the ```\nmain```\n. It is not the probabilistic test, but the deterministic one: the method searches for all possible witnesses and, if one is found, returns ```\nfalse```\n (i.e. not prime); otherwise it returns ```\ntrue```\n.\n\n```\n    public static void main(String[] args) {\n        long start;\n        Random random = new Random();\n        int N = Integer.parseInt(\"10\");\n        BigInteger a,b,c,d;\n\n        long stopMR, stopNative;\n        boolean answerMR, answerNative;\n\n        for(int i=0 ; i<6 ; i++, N*=3)\n            {\n            a = new BigInteger(N, random);\n            System.out.printf(\"\\tTEST %d\\n\\nThe number to be checked is: \\n\\t %s\\n\"     + \n    //              \"Written in 2-base:  \\n\\t %s\\n\"                     +\n                    \"Number of bits of a: %d \\n\", i,\n                    a.toString(), \n    //              a.toString(2), \n                    a.toString(2).length());\n\n            start = System.nanoTime();\n            answerMR = primalityTest_MillerRabin(a);\n            stopMR = System.nanoTime();\n            stopMR -= start;\n\n            start = System.nanoTime();\n            answerNative = a.isProbablePrime(40);\n            stopNative = System.nanoTime();\n            stopNative -= start;\n\n            System.out.printf(\"The test of Miller-Rabin said that the number %s.\\n\"\n                    + \"The native test said that the number %s.\\n\"\n                    + \"The time of MR is %d.\\n\"\n                    + \"The time of the native is %d.\\n\"\n                    + \"The difference Time(MR)-Time(native) is %d.\\n\",\n                    answerMR        ? \"is prime\" : \"isn't prime\"   ,\n                    answerNative    ? \"is prime\" : \"isn't prime\"   ,\n                    stopMR, stopNative, stopMR - stopNative\n                    );\n\n            a = BigInteger.probablePrime(N, random);\n            System.out.printf(\"\\tTEST %d\\n\\nThe number to be checked is: \\n\\t %s\\n\"     + \n    //              \"Written in 2-base:  \\n\\t %s\\n\"                     +\n                    \"Number of bits of a: %d \\n\", i,\n                    a.toString(), \n    //              a.toString(2), \n                    a.toString(2).length());\n\n            start = System.nanoTime();\n            answerMR = primalityTest_MillerRabin(a);\n            stopMR = System.nanoTime();\n            stopMR -= start;\n\n            start = System.nanoTime();\n            answerNative = a.isProbablePrime(40);\n            stopNative = System.nanoTime();\n            stopNative -= start;\n\n            System.out.printf(\"The test of Miller-Rabin said that the number %s.\\n\"\n                    + \"The native test said that the number %s.\\n\"\n                    + \"The time of MR is %d.\\n\"\n                    + \"The time of the native is %d.\\n\"\n                    + \"The difference Time(MR)-Time(native) is %d.\\n=====\\n\",\n                    answerMR        ? \"is prime\" : \"isn't prime\"   ,\n                    answerNative    ? \"is prime\" : \"isn't prime\"   ,\n                    stopMR, stopNative, stopMR - stopNative\n                    );\n            }\n\n    }\n\n    /** Tests {@code n} for primality using the <i>Miller-Rabin algorithm</i>.\n     * \n     * <p><br> For {@code n} minor than <b>3,825,123,056,546,413,051</b> (i.e. roughtly four millions of millions of millions,\n     *  i.e. 4·10<sup>18</sup>) the test is deterministic and have time complexity of Θ<font size=+1>(</font>10·modPow(·,n)<font size=+1>)</font>.\n     * <br> For {@code n} greater than <b>3,825,123,056,546,413,051</b> the test is deterministic and have time complexity of \n     * Θ<font size=+1>(</font>2·log<sub>2</sub><sup>2</sup>(n)·modPow(·,n)<font size=+1>)</font>.\n     * \n     * @param n\n     * @return\n     */\n    public static boolean primalityTest_MillerRabin(BigInteger n){\n        // If n is divided by 2 or is less than 2, then n is not prime.\n        if( n.intValue()%2== 0       ||       n.equals(TWO) )\n            {\n            System.out.printf(\"The number is even.\\n\");\n            return false;\n            }\n\n        // n = d*2^s +1\n        BigInteger pMinus1 = n.subtract(ONE);\n\n        int s = 0;\n        while (pMinus1.mod(TWO).equals(ZERO)) \n            {\n            s++;\n            pMinus1 = pMinus1.divide(TWO);\n            }\n        BigInteger d = pMinus1;\n\n        System.out.printf(\"%s is %s*2^%d+1.\\n\", n.toString(), d.toString(),s);\n\n        // Old code:\n        // pMinus1.divide(BigInteger.valueOf(2L << r - 1));\n\n\n        // For some n is known what witness one has to choose in order to verify is n is composite.\n        // While the code for EVERY known limit is shown, only those not-redundant is not comment.\n\n        if(n.compareTo(LIMIT_2047)<0)\n            return  ! isTWOWitnessOfCompositenessOfN_MR(                     n, d, s)           ;\n        if(n.compareTo(LIMIT_9080191)<0)\n            return  ! (\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(31) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(73) , n, d, s)          );\n        if(n.compareTo(LIMIT_4759123141)<0)\n            return  ! (\n                    isTWOWitnessOfCompositenessOfN_MR(                       n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(7) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(61) , n, d, s)          );\n\n\n        if(n.compareTo(LIMIT_1122004669633)<0)\n            return  ! (\n                    isTWOWitnessOfCompositenessOfN_MR(                        n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(13) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(23) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(1662803) , n, d, s) );\n        if(n.compareTo(LIMIT_2152302898747)<0)\n            return  ! (\n                    isTWOWitnessOfCompositenessOfN_MR(                       n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(3) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(5) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(7) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(11) , n, d, s)          );\n        if(n.compareTo(LIMIT_3474749660383)<0)\n            return  ! (\n                    isTWOWitnessOfCompositenessOfN_MR(                       n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(3) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(5) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(7) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(11) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(13) , n, d, s)          );\n        if(n.compareTo(LIMIT_341550071728321)<0)\n            return  ! (\n                    isTWOWitnessOfCompositenessOfN_MR(                       n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(3) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(5) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(7) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(11) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(13) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(17) , n, d, s)          );\n        if(n.compareTo(LIMIT_3825123056546413051)<0)\n            return  ! (\n                    isTWOWitnessOfCompositenessOfN_MR(                       n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(3) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(5) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(7) , n, d, s)           ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(11) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(13) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(17) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(19) , n, d, s)          ||\n                    isAWitnessOfCompositenessOfN_MR( BigInteger.valueOf(23) , n, d, s)          );\n\n\n        // ...otherwise the program does an exaustive search for witness\n        System.out.printf(\"The Miller-Rabin Test has no shortcuts.\\n\");\n\n\n        boolean witnessFound = false;\n        int logn = (int) log(n,2) +1;\n        BigInteger limit = (    n.subtract(ONE) ).min(  BigInteger.valueOf(2*logn*logn)   );\n\n        for(BigInteger a = TWO ; witnessFound && a.compareTo(limit)<=0 ; a.add(ONE))\n                witnessFound = isAWitnessOfCompositenessOfN_MR( a , n, d, s);\n\n        return !witnessFound;\n    }\n\n    /** Return {@code true} if and only if {@code a} is a witness for the compositeness of {@code n}, i.e. if and only if: \n     * <ol> n = d·2<sup>s</sup> + 1                         <br>\n     *      gcd(a,n) = 1    (i.e. a doesn't divide n)       <br>\n     *      _<br>\n     *      a<sup>d</sup> ≠ 1 (mod n)                       <br>\n     *      a<sup>(d·2^r)</sup> ≠ -1 (mod n)        for all rϵ[0,s)         </ol>\n     * \n     * If the method returns {@code true} then {@code n} is definitely a composite number. However if the method returns {@code false} it \n     * still may be possible for {@code n} to be composite.\n     * \n     * <p>If this method recognize {@code a} as a witness for the compositeness of {@code n}\n     * \n     * @param a\n     * @param n\n     * @param d\n     * @param s\n     * @return\n     */\n    public static boolean isAWitnessOfCompositenessOfN_MR(BigInteger a, BigInteger n, BigInteger d, int s){\n        System.out.printf(\"\\t Verifying if %s is a witness of the compositness of %s.\\n\", a.toString(), n.toString());\n        if( a.gcd(n) == ONE )\n            {\n            BigInteger dMultiplyTwoPowR = a.modPow(d, n),\n                        nMinusOne = NEGATIVE_ONE.mod(n);\n            boolean answer = dMultiplyTwoPowR != ONE;\n            for(int r=1 ; answer && r<s ; r++)\n                {\n                System.out.printf(\"\\t\\t Testing r=%d.\\n\", r);\n                    answer = answer && \n                            dMultiplyTwoPowR.modPow(TWO, n) != nMinusOne;\n                }\n\n            System.out.printf(\"\\t The number %s %s a witness of the compositness of %s.\\n\", a.toString(), answer ? \"is\" : \"isn't\", n.toString());\n            return answer;\n            }\n        else \n            {\n            System.out.printf(\"\\t %s divides %s.\\n\", a.toString(), n.toString());\n            return true;\n            }\n    }\n\n        /** Returns {@code isAWitnessOfCompositenessOfN_MR(TWO, n, d, s)}. \n         * \n         * <p><u><b>Warning:</b></u> This method avoids to control if gcd(2, {@code n})=1.\n             * \n             * @param n\n             * @param d\n         * @param s\n         * @return\n         */\n    public static boolean isTWOWitnessOfCompositenessOfN_MR( BigInteger n, BigInteger d, int s){\n        System.out.printf(\"\\t Verifying if 2 is a witness of the compositness of %s.\\n\", n.toString());\n        BigInteger dMultiplyTwoPowR = TWO.modPow(d, n),\n                nMinusOne = NEGATIVE_ONE.mod(n);\n        boolean answer = dMultiplyTwoPowR != ONE;\n        for(int r=1 ; answer && r<s ; r++)\n             {\n            System.out.printf(\"\\t\\t Testing r=%d.\\n\", r);\n            answer = answer && \n                    dMultiplyTwoPowR.modPow(TWO, n) != nMinusOne;\n             }\n\n        System.out.printf(\"\\t The number 2 %s a witness of the compositness of %s.\\n\", answer ? \"is\" : \"isn't\", n.toString());\n        return answer;\n    }\n```\n\n\n\n\nEdit: the following lines are the method ```\nlog(x,base)```\n.\n\n```\n    /** Returns the logarithm of a number {@code x} in the selected {@code base}.\n     * <p>\n     * <b>Time Complexity:</b> Θ(1).                                <br>\n     * <b>Space Complexity:</b> Θ(log<sub>10</sub>(x)).                                                         <br>\n     * \n     * @param x\n     * @param base\n     * @return\n     */\n    public static double log(BigInteger x, float base){\n        String support = x.toString();\n        int n = support.length();\n        double log10 = n + Float.parseFloat(\"0.\"+support);\n        if(base==10)    return log10;\n        else            return log10 / Math.log10(base);\n\n    }\n```\n\n    ", "Answer": "\r\nYou have several expressions comparing BigInteger objects using == and !=. This must be replaced by calls to equals, negating the result for !=.\n\nAlso, I think that there is a copy-paste error in isAWitnessOfCompositenessOfN_MR:\n\n```\n! dMultiplyTwoPowR.modPow(TWO, n).equals( nMinusOne );\n```\n\n\nI think that TWO should be replaced by a.\n\nEdit A bug in log. Use the code below:\n\n```\npublic static double log(BigInteger x, base b){\n    String support = x.toString();\n    int n = support.length();\n    double log10 = n + Math.log10( Double.parseDouble(\"0.\"+support) );\n    return log10/Math.log10(b);\n}\n```\n\n\nI suppose that there's more errors, but these fixes should help a little.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why is one of these prime number generators faster than the other?\r\n                \r\nRecently interested in simple primality tests. I have the following two functions that return a list of all primes up to the given input. The first I made, the other is based off wikipedia's pseudocode for primality tests. I then slightly altered mine to be what I thought was the closest to wikipedia's. \n\nWhen I time them (with 10000 as the input/limit), mine takes an order of magnitude longer than the other. I'm not quite sure why, as to me they're doing really similar things. Mine checks through a list of primes with \"any\", whereas wiki's checks through those same numbers but generates them with a while loop. What am I missing? \n\n```\ndef my_primality(lim):                                                                                                                         \n    count = 5                                                                                                                          \n    slbprimes = [2,3];                                                                                                                 \n    while count<lim:                                                                                                                   \n        if count%3==0:                                                                                                                 \n            pass                                                                                                                       \n        elif any(count%i==0 for i in slbprimes if i**2<=count):                                                                        \n            pass                                                                                                                       \n        else:                                                                                                                          \n            slbprimes.append(count)                                                                                                    \n        count+=2                                                                                                                       \n    return slbprimes \n\ndef evenbetter(lim):                                                                                                                          \n    count = 5                                                                                                                          \n    ebprimes=[2,3];                                                                                                                    \n    while count < lim:                                                                                                                 \n        if count%3==0:                                                                                                                 \n            count+=2                                                                                                                   \n            continue                                                                                                                   \n        i=5                                                                                                                            \n        while i**2<=count:                                                                                                             \n            if count%i==0 or count%(i+2)==0:                                                                                           \n                count+=2                                                                                                               \n                break                                                                                                                  \n            i=i+6                                                                                                                      \n        else:                                                                                                                          \n            ebprimes.append(count)                                                                                                     \n            count+=2                                                                                                                   \n    return ebprimes \n```\n\n    ", "Answer": "\r\n```\nany```\n will traverse the whole list in order to see if any of the elements are evaluated to true. The ```\nwhile```\n loop breaks faster, because it takes into account the elements are in increasing order. You can play with ```\ntakewhile```\n from ```\nitertools```\n and you should get similar run time as the while loop.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Numbers 3, 5, and 7 not being displayed as prime\r\n                \r\nI need to create a function that generates prime numbers between two input numbers. I do this by testing the primality of each number in range. The problem is that the numbers 3, 5, or 7 are never displayed. I'm not sure what's wrong.\n\nThis is how I test primality of a number:\n\n```\nbool isPrime(int number){\n    using namespace std;\n    if((number%2==0) || (number%3==0) || (number%4==0) || (number%5==0) ||\n       (number%6==0) || (number%7==0) || (number%8==0) || (number%9==0))\n    {\n        return false;\n    }\n    else if ((number/1==number) && (number/number==1))\n    {\n        return true;\n    }\n}\n```\n\n    ", "Answer": "\r\n3 is a multiple of 3. 5 is a multiple of 5. 7 is a multiple of 7. You wrote code that returns false for any multiple of 3, 5, or 7, so it can't possibly return true for those numbers. You need to only check for divisibility by primes smaller than the number you're checking.\n\nYou also check for divisibility by a lot of unnecessary composite numbers; for example, a number can't be a multiple of 4 without being a multiple of 2, and it can't be a multiple of 6 without being a multiple of 2 and 3. Those checks do nothing except waste time.\n\nFinally, your code is wrong 100% of the time in the long run, because the highest prime it checks is 7. It will say that 169 (13 * 13) is prime because it isn't divisible by any of the numbers you check, but it's clearly composite. For trial division you need to check all of the primes less than or equal to floor(sqrt(n)), either by doing a lot of unneccessary checks against composites, or by building up a list of primes as you go (akin to the Sieve of Eratosthenes, and often called that by CS types, but I don't think it's strictly equivalent).\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Python program performance and memory management\r\n                \r\nI've written primality test program in python but I'm certain of big issues. One being that program execution becomes very slow if the number to test is extremely big, I've used a generator. And it could be that the program utilizes a huge memory space. Is there any way the program can be optimized?\n```\n#define function\ndef isprime(n):\n    return next((False for i in range(2,n) if n%i == 0), (n > 1))\n#test it\nnums = [i for i in range(101) if isprime(i)]\nprint(nums)\n```\n\n    ", "Answer": "\r\nAs indicated in the comments, the fastest way to find all primes below a certain number is the ```\nSieve Of Eratosthenes```\n method. Checked on my machine, this algorithm is about 1000 times faster than the above one.\nA nice comparison between different methods can be found here: analysis-different-methods-find-prime-number-python\nJust in case the external link will change in the future, I'm putting here the code:\n```\n# Python Program to find prime numbers in a range\nimport time\n\nprimes = []\n\ndef SieveOfEratosthenes(n):\n    # Create a boolean array \"prime[0..n]\" and\n    # initialize all entries it as true. A value\n    # in prime[i] will finally be false if i is\n    # Not a prime, else true.\n    prime = [True for i in range(n + 1)]\n\n    p = 2\n    while (p * p <= n):\n\n        # If prime[p] is not changed, then it is\n        # a prime\n        if (prime[p] == True):\n\n            # Update all multiples of p\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    c = 0\n\n    for p in range(2, n):\n        if prime[p]:\n            primes.append(p)\n            c += 1\n    return c\n\n\nt0 = time.time()\nc = SieveOfEratosthenes(100000)\nprint(\"Total prime numbers in range:\", c)\nprint(\"Primes: \", primes)\n\nt1 = time.time()\nprint(\"Time required:\", t1 - t0)\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Python program performance and memory management\r\n                \r\nI've written primality test program in python but I'm certain of big issues. One being that program execution becomes very slow if the number to test is extremely big, I've used a generator. And it could be that the program utilizes a huge memory space. Is there any way the program can be optimized?\n```\n#define function\ndef isprime(n):\n    return next((False for i in range(2,n) if n%i == 0), (n > 1))\n#test it\nnums = [i for i in range(101) if isprime(i)]\nprint(nums)\n```\n\n    ", "Answer": "\r\nAs indicated in the comments, the fastest way to find all primes below a certain number is the ```\nSieve Of Eratosthenes```\n method. Checked on my machine, this algorithm is about 1000 times faster than the above one.\nA nice comparison between different methods can be found here: analysis-different-methods-find-prime-number-python\nJust in case the external link will change in the future, I'm putting here the code:\n```\n# Python Program to find prime numbers in a range\nimport time\n\nprimes = []\n\ndef SieveOfEratosthenes(n):\n    # Create a boolean array \"prime[0..n]\" and\n    # initialize all entries it as true. A value\n    # in prime[i] will finally be false if i is\n    # Not a prime, else true.\n    prime = [True for i in range(n + 1)]\n\n    p = 2\n    while (p * p <= n):\n\n        # If prime[p] is not changed, then it is\n        # a prime\n        if (prime[p] == True):\n\n            # Update all multiples of p\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    c = 0\n\n    for p in range(2, n):\n        if prime[p]:\n            primes.append(p)\n            c += 1\n    return c\n\n\nt0 = time.time()\nc = SieveOfEratosthenes(100000)\nprint(\"Total prime numbers in range:\", c)\nprint(\"Primes: \", primes)\n\nt1 = time.time()\nprint(\"Time required:\", t1 - t0)\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Prime-sieve optimized for memory\r\n                \r\nI am looking for a prime-sieve implementation which is efficient in terms of memory consumption.\n\nOf course, the primality-test itself should execute at a constant and minimal number of operations.\n\nI have implemented a sieve that indicates primality only for numbers that are adjacent to multiples of 6.\n\nFor any other number, either it is 2 or 3 (therefore prime), or it is a multiple of 2 or 3 (therefore non-prime).\n\nSo this is what I came up with, and I've been wondering if there is anything better under those requirements:\n\nInterface:\n\n```\n#include <limits.h>\n\n// Defined by the user (must be less than 'UINT_MAX')\n#define RANGE 4000000000\n\n// The actual length required for the prime-sieve array\n#define ARR_LEN (((RANGE-1)/(3*CHAR_BIT)+1))\n\n// Assumes that all entries in 'sieve' are initialized to zero\nvoid Init(char sieve[ARR_LEN]);\n\n// Assumes that 'Init(sieve)' has been called and that '1 < n < RANGE'\nint IsPrime(char sieve[ARR_LEN],unsigned int n);\n\n#if RANGE >= UINT_MAX\n    #error RANGE exceeds the limit\n#endif\n```\n\n\nImplementation:\n\n```\n#include <math.h>\n\n#define GET_BIT(sieve,n) ((sieve[(n)/(3*CHAR_BIT)]>>((n)%(3*CHAR_BIT)/3))&1)\n#define SET_BIT(sieve,n) sieve[(n)/(3*CHAR_BIT)] |= 1<<((n)%(3*CHAR_BIT)/3)\n\nstatic void InitOne(char sieve[ARR_LEN],int d)\n{\n    unsigned int i,j;\n    unsigned int root = (unsigned int)sqrt((double)RANGE);\n\n    for (i=6+d; i<=root; i+=6)\n    {\n        if (GET_BIT(sieve,i) == 0)\n        {\n            for (j=6*i; j<RANGE; j+=6*i)\n            {\n                SET_BIT(sieve,j-i);\n                SET_BIT(sieve,j+i);\n            }\n        }\n    }\n}\n\nvoid Init(char sieve[ARR_LEN])\n{\n    InitOne(sieve,-1);\n    InitOne(sieve,+1);\n}\n\nint IsPrime(char sieve[ARR_LEN],unsigned int n)\n{\n    return n == 2 || n == 3 || (n%2 != 0 && n%3 != 0 && GET_BIT(sieve,n) == 0);\n}\n```\n\n    ", "Answer": "\r\nYou've correctly deduced that you can exploit the fact that there are only two number that are relatively prime to 6, i.e. 1 and 5 (aka +1 and -1). Using that fact and storing the sieve as bits instead of bytes, you reduce the memory requirement by a factor of 24.\n\nTo save a little more memory, you can go to the next level and note that there are only 8 numbers (modulo 30) that are relatively prime to 30. They are 1, 7, 11, 13, 17, 19, 23, 29. Using that fact and storing as bits, the memory is reduced by a factor of 30. \n\nImplementation note: each byte in the sieve represents the 8 numbers relatively prime to some multiple of 30. For example, the bits contained in ```\nsieve[3]```\n represent the numbers ```\n91, 97, 101, ...```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Modulo Multiplication Function: Multiplying two integers under a modulus\r\n                \r\nI came across this modulo multiplication function in a code for the miller-rabin primality test. This is supposed to eliminate the integer overflow that occurs when calculating ```\n( a * b ) % m```\n.\nI need some help in understanding what is going on here. Why does this work? and what is the significance of that number literal ```\n0x8000000000000000ULL```\n?\n```\nunsigned long long mul_mod(unsigned long long a, unsigned long long b, unsigned long long m) {\n    unsigned long long d = 0, mp2 = m >> 1;\n    if (a >= m) a %= m;\n    if (b >= m) b %= m;\n    for (int i = 0; i < 64; i++)\n    {\n        d = (d > mp2) ? (d << 1) - m : d << 1;\n        if (a & 0x8000000000000000ULL)\n            d += b;\n        if (d >= m) d -= m;\n        a <<= 1;\n    }\n    return d;\n}\n```\n\n    ", "Answer": "\r\nThis code, which currently appears on the modular arithmetic Wikipedia page, only works for arguments of up to 63 bits -- see bottom.\nOverview\nOne way to compute an ordinary multiplication ```\na * b```\n is to add left-shifted copies of ```\nb```\n -- one for each 1-bit in ```\na```\n. This is similar to how most of us did long multiplication in school, but simplified: Since we only ever need to \"multiply\" each copy of ```\nb```\n by 1 or 0, all we need to do is either add the shifted copy of ```\nb```\n (when the corresponding bit of ```\na```\n is 1) or do nothing (when it's 0).\nThis code does something similar. However, to avoid overflow (mostly; see below), instead of shifting each copy of ```\nb```\n and then adding it to the total, it adds an unshifted copy of ```\nb```\n to the total, and relies on later left-shifts performed on the total to shift it into the correct place. You can think of these shifts \"acting on\" all the summands added to the total so far. For example, the first loop iteration checks whether the highest bit of ```\na```\n, namely bit 63, is 1 (that's what ```\na & 0x8000000000000000ULL```\n does), and if so adds an unshifted copy of ```\nb```\n to the total; by the time the loop completes, the previous line of code will have shifted the total ```\nd```\n left 1 bit 63 more times.\nThe main advantage of doing it this way is that we are always adding two numbers (namely ```\nb```\n and ```\nd```\n) that we already know are less than ```\nm```\n, so handling the modulo wraparound is cheap: We know that ```\nb + d < 2 * m```\n, so to ensure that our total so far remains less than ```\nm```\n, it suffices to check whether ```\nb + d < m```\n, and if not, subtract ```\nm```\n. If we were to use the shift-then-add approach instead, we would need a ```\n%```\n modulo operation per bit, which is as expensive as division -- and usually much more expensive than subtraction.\nOne of the properties of modulo arithmetic is that, whenever we want to perform a sequence of arithmetic operations modulo some number ```\nm```\n, performing them all in usual arithmetic and taking the remainder modulo ```\nm```\n at the end always yields the same result as taking remainders modulo ```\nm```\n for each intermediate result (provided no overflows occur).\nCode\nBefore the first line of the loop body, we have the invariants ```\nd < m```\n and ```\nb < m```\n.\nThe line\n```\nd = (d > mp2) ? (d << 1) - m : d << 1;\n```\n\nis a careful way of shifting the total ```\nd```\n left by 1 bit, while keeping it in the range ```\n0 .. m```\n and avoiding overflow. Instead of first shifting it and then testing whether the result is ```\nm```\n or greater, we test whether it is currently strictly above ```\nRoundDown(m/2)```\n -- because if so, after doubling, it will surely be strictly above ```\n2 * RoundDown(m/2) >= m - 1```\n, and so require a subtraction of ```\nm```\n to get back in range. Note that even though the ```\n(d << 1)```\n in ```\n(d << 1) - m```\n may overflow and lose the top bit of ```\nd```\n, this does no harm as it does not affect the lowest 64 bits of the subtraction result, which are the only ones we are interested in. (Also note that if ```\nd == m/2```\n exactly, we wind up with ```\nd == m```\n afterward, which is slightly out of range -- but changing the test from ```\nd > mp2```\n to ```\nd >= mp2```\n to fix this would break the case where ```\nm```\n is odd and ```\nd == RoundDown(m/2)```\n, so we have to live with this. It doesn't matter, because it will be fixed up below.)\nWhy not simply write ```\nd <<= 1; if (d >= m) d -= m;```\n instead? Suppose that, in infinite-precision arithmetic, ```\nd << 1 >= m```\n, so we should perform the subtraction -- but the high bit of ```\nd```\n is on and the rest of ```\nd << 1```\n is less than ```\nm```\n: In this case, the initial shift will lose the high bit and the ```\nif```\n will fail to execute.\nRestriction to inputs of 63 bits or fewer\nThe above edge case can only occur when ```\nd```\n's high bit is on, which can only occur when ```\nm```\n's high bit is also on (since we maintain the invariant ```\nd < m```\n). So it looks like the code is taking pains to work correctly even with very high values of ```\nm```\n. Unfortunately, it turns out that it can still overflow elsewhere, resulting in incorrect answers for some inputs that set the top bit. For example, when ```\na = 3```\n, ```\nb = 0x7FFFFFFFFFFFFFFFULL```\n and ```\nm = 0xFFFFFFFFFFFFFFFFULL```\n, the correct answer should be ```\n0x7FFFFFFFFFFFFFFEULL```\n, but the code will return ```\n0x7FFFFFFFFFFFFFFDULL```\n (an easy way to see the correct answer is to rerun with the values of ```\na```\n and ```\nb```\n swapped). Specifically, this behaviour occurs whenever the line ```\nd += b```\n overflows and leaves the truncated ```\nd```\n less than ```\nm```\n, causing a subtraction to be erroneously skipped.\nProvided this behaviour is documented (as it is on the Wikipedia page), this is just a limitation, not a bug.\nRemoving the restriction\nIf we replace the lines\n```\n    if (a & 0x8000000000000000ULL)\n        d += b;\n    if (d >= m) d -= m;\n```\n\nwith\n```\n    unsigned long long x = -(a >> 63) & b;\n    if (d >= m - x) d -= m;\n    d += x;\n```\n\nthe code will work for all inputs, including those with top bits set. The cryptic first line is just a conditional-free (and thus usually faster) way of writing\n```\n    unsigned long long x = (a & 0x8000000000000000ULL) ? b : 0;\n```\n\nThe test ```\nd >= m - x```\n operates on ```\nd```\n before it has been modified -- it's like the old ```\nd >= m```\n test, but ```\nb```\n (when the top bit of ```\na```\n is on) or 0 (otherwise) has been subtracted from both sides. This tests whether ```\nd```\n would be ```\nm```\n or larger once ```\nx```\n is added to it. We know that the RHS ```\nm - x```\n never underflows, because the largest ```\nx```\n can be is ```\nb```\n and we have established that ```\nb < m```\n at the top of the function.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Calculating complexity of js alghortim\r\n                \r\nI'm trying to caluclate complexity of below method in Big O notation\n\r\n\r\n```\nfunction algorithm(n,m){\n    let result = [];\n\n    for (let i = 0; i < n.length; i++) {\n      const total = m.filter((x) => x === n[i]).length;\n  \n      if (PrimalityTest(total)) {\n        result.push(n[i]);\n      }\n    }\n    return result;\n  };\n\n\nfunction PrimalityTest(c){\n    if (c <= 1) {\n        return false;\n      } else if (c === 2) {\n        return true;\n      } else {\n        for (let i = 2; i * i <= c; i++) {\n          if (c % i === 0) {\n            return false;\n          }\n        }\n        return true;\n      }\n}```\n\r\n\r\n\r\n\nSo, firstly there is loop which have O(n) and then there is nested loop and primality test function so that means complexity of all is O(n * m * sqrt(c))?\nCan you please confirm If my understanding is correct?\n    ", "Answer": "\r\nThe loop ```\nfor (let i = 0; i < n.length; i++) ```\n is executed n times. The function ```\n m.filter((x) => x === n[i]).length```\n checks every element in m, so executes m-times. So we have an execution time of O(n*m).\nConsidering\n```\nif (PrimalityTest(total)) {\n      result.push(n[i]);\n}\n```\n\nis executed n times because it is in the same loop as above. So at worst it is O(n*sqrt(c))\nTo sum it up: It is O(n*m)+O(n*sqrt(c)). Because O(n*m) surpasses O(n*sqrt(c)) we get as result: O(n*m).\nYour solution would mean that the filter function integrates the PrimalityTest method.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Find a largest prime number less than n [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nHow can I find a largest prime number which is less than n, where  n ≤ 10¹⁸ ?\nPlease help me find an Efficient Algorithm.\n\n```\nfor(j=n;j>=2;j--) {\n  if(j%2 == 1) {\n    double m = double(j);\n    double a = (m-1)/6.0;\n    double b = (m-5)/6.0;\n    if( a-(int)a == 0 || b-(int)b == 0 ) {\n      printf(\"%llu\\n\",j);\n      break;\n    }\n  }\n}\n```\n\n\nI used this approach but this is not efficient to solve for n>10^10;\n\nHow to optimize this..\n\nEdit: \nSolution: Use Primality test on each j. \n\nMiller Rabin, Fermat's  Test. \n    ", "Answer": "\r\nI don't think this question should be so quickly dismissed, as efficiency is not so easy to determine for numbers in this range. First of all, given the average prime gap is ```\nln(p)```\n, it makes sense to work down from the given ```\n(n)```\n. i.e., ```\nln(10^18) ~ 41.44)```\n, so you would expect around ```\n41```\n iterations on average working down from ```\n(n)```\n. e.g., testing: ```\n(n), (n - 2), (n - 4), ...```\n\n\nGiven this average gap, the next step is to decide whether you wish to use a naive test - check for divisibility by primes ```\n<= floor(sqrt(n))```\n. With ```\nn <= (10^18)```\n, you would need to test against primes ```\n<= (10^9)```\n. There are ~ 50 million primes in this range. If you are willing to precompute and tabulate these values (all of which fit in 32 bits), you have a reasonable test for 64-bit values ```\nn <= 10^18```\n. In this case, is a 200MB prime table an acceptable approach? 20 years ago, it might not have been. Today, it's not an issue.\n\nCombining a prime table with sieving and/or Pocklington's test might improve efficiency. Alternatively, if memory is more constrained, a deterministic variant of the Miller-Rabin test with bases: ```\n2, 325, 9375, 28178, 450775, 9780504, 1795265022```\n (SPRP set). Most composites fail immediately with an SPRP-2 test.\n\nThe point is - you have a decision to make between algorithmic complexity, both theoretical and in terms of implementation difficulty, and a balance with space/time trade-offs.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "While coding for a solution to a question of Primality Test, my code was not being processed in the vs code\r\n                \r\nThe Question:\nAlice and Bob are meeting after a long time. As usual they love to play some math games. This times Alice takes the call and decides the game. The game is very simple, Alice says out an integer and Bob has to say whether the number is prime or not. Bob as usual knows the logic but since Alice doesn't give Bob much time to think, so Bob decides to write a computer program.\nHelp Bob accomplish this task by writing a computer program which will calculate whether the number is prime or not .\nMy code:\n\n```\n#include <iostream>\nusing namespace std;\n\nbool isPrime (int n)\n {\n     if (n==1)\n     {\n         return false;\n     }\n     for (int i=2;i*i<=n;i++)\n     {\n         if (n % i == 0)\n         {\n             return false;\n         }\n     }  \n     return true;\n }\n int main ()\n {\n     int t,n;\n     cin>>t;\n     while (t--)\n     {\n         cin>>n;\n         if (isPrime(n))\n         {\n         cout<<\"yes\"<<endl;\n         }\n         else\n         {\n             cout<<\"no\"<<endl;\n         }\n     }\n    \n }\n```\n\n    ", "Answer": "\r\nAssuming that your method of calling your program succeeds for a HelloWorld example...\nExecuting your program will not give any visible output before it is necessary to input numbers. Even if this is required behaviour, you could check by inserting a prompt output before the first needed input.\nYou might change that by calling your program like ```\necho 3 2 1 0 | .\\primal```\n.\nOr by calling the created executable directly from a prompt and interactively entering numbers.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why my implementation of aks prime test is slower than my implementation of the naive version? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI tried to compare multiple algorithms to find the largest prime number under \"i\".\nBut when I tested the implementation, \"aks\" was slower than my naive implementation.\nI was thinking that aks was a better implementation for primality test, did I get this wrong?\n```\n def expand_x_1(n): \n    c =1\n    for i in range(n//2+1):\n        c = c*(n-i)//(i+1)\n        yield c\n \ndef aks(p):\n    if p==2:\n        return True\n \n    for i in expand_x_1(p):\n        if i % p:\n            return False\n    return True\n\ndef all_factors(x): # naive version\n    i = 2\n    s = int(x ** 0.5)\n    while i < s:\n        if x % i == 0:\n            return False\n        i += 1\n    return True\n\ndef find(i, func) :\n    while not func(i) :\n        i -= 1\n    print(i)\n\n%time find(2**16, aks)\n%time find(2**16, all_factors)\n```\n\nI tried to compare both and obtain:\n\nfor aks\n\n```\n65521\nCPU times: user 1.7 s, sys: 3.24 ms, total: 1.7 s\nWall time: 1.7 s\n```\n\n\nfor all_factor\n\n```\n65521\nCPU times: user 81 µs, sys: 0 ns, total: 81 µs\nWall time: 83.9 µs\n```\n\n    ", "Answer": "\r\nWhen the input is a prime, ```\nexpand_x_1(n)```\n eventually yields all possible ```\nn//2+1```\n results, but the loop in ```\nall_factors(n)```\n goes around only about ```\nsqrt(n)```\n times. That's a huge difference right there.\nBut also very much in play:\n```\nc = c*(n-i)//(i+1)\n```\n\ngrows without bound across iterations. Add\n```\n            print(c.bit_length())\n```\n\nbefore the ```\nyield```\n, and you'll see that ```\nfind(65521, aks)```\n is doing arithmetic on integers over 65000 bits wide before it's done. That too is far more expensive than\nthe 16-bit arithmetic ```\nfind(65521, all_factors)```\n does.\nNote: in practice, nobody uses the AKS primality test because even versions that have been massively optimized by world-class mathematicians are slower than alternatives. See AKS Primes algorithm in Python for more on that.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "how to show a number is prime or not if number is <2^63?\r\n                \r\nI have read about Fermat's primality test... it was nice but there was one flaw about Carmichael number... it shows that it coulnd't find the distiguish them with prime numbers..\n\nMy code:\n\n```\nbool fermat(long long p,int itr)\n{\n  if(p==1)return false;\n  for(int i=0;i<itr;i++)\n  {\n    long long a=rand()%(p-1)+1;\n    if(modulo(a,p-1,p)!=1)\n       return false;\n    else\n       return true;\n  }\n}\n```\n\n\nHow can I find that ```\np```\n is prime without getting into the problem of Carmichael number? Any modification of this algo?\n    ", "Answer": "\r\nPseudocode for the Miller-Rabin test, which gives a probabilistic answer, is shown below:\n\n```\nfunction isPrime(n, k=5)\n    if n < 2 then return False\n    for p in [2,3,5,7,11,13,17,19,23,29]\n        if n % p == 0 then return n == p\n    s, d = 0, n-1\n    while d % 2 == 0\n        s, d = s+1, d/2\n    for i from 0 to k\n        x = powerMod(randint(2, n-1), d, n)\n        if x == 1 or x == n-1 then next i\n        for r from 1 to s\n            x = (x * x) % n\n            if x == 1 then return False\n            if x == n-1 then next i\n        return False\n    return True\n```\n\n\nThat uses k (default 5) random bases. If you know in advance the limit on n you could chose a set of bases that gives a deterministic answer; see miller-rabin.appspot.com for lists of bases for various n.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Looking to Maximize CPU Utilization with a python benchmarking program using concurrent.futures\r\n                \r\nI have been working on developing a synthetic benchmarking program in python in order to stress-test the CPU in various systems for a class project. I have based my approach on Mersenne primality tests (inspired by prime95). The program is intended to test the Mersenne primality of numbers over a working set, defined by the user. I have so far implemented this in python, however once implementing the concurrent.futures module in order to run the task in parallel to maximize CPU utilization, I hit a snag. When testing my program I ran into 2 issues.\n\nCPU utilization is still only ~35%\nWhen testing larger working sets, the program stalls for several minutes before it starts iterating through each prime - I am assuming this has something to do with concurrent.futures's setup.\n\nI was hoping someone could provide some insight into how to maximize system resource usage with this program and iron out the issues with larger sets.\nCode below:\n```\nsys = platform.uname()\nc = wmi.WMI()\nwinSys = c.Win32_ComputerSystem()[0]\n\nmode1 = \"Integer Mode\"\nmode2 = \"Floating-Point Mode\"\n\ndef lehmer(p: int) -> bool:\n\n    s = 4\n    M = (1 << p) - 1\n    for i in range(p - 2):\n        s = ((s * s) - 2) % M\n    return s == 0\n\n\n\n\n\n#Initial printout of system information and menu screen schowing benchamrking options\nprint(\"_________________________________________________________________________________\")\nprint(\"------------------------------System Information---------------------------------\")\nprint(f\"\\tOS: {sys.system} {sys.release} \") #\nprint(f\"\\tMachine Name: {sys.node}\")\nprint(f\"\\tVersion: {sys.version}\")\nprint(f\"\\tCPU: {sys.processor}\")\nprint(\"\\tNumber of Cores: \" + str(psutil.cpu_count()))\nprint(f\"\\tRAM: {psutil.virtual_memory()}\")\nprint(\"---------------------------------------------------------------------------------\")\n\n\nmodeSelect = 0;\nprint(\"Welcome to ParaBench! Please select what benchmarking mode you would like to use.\" + '\\n')\nmodeSelect = int(input(\"[1] -> \" + mode1 + '\\n' + \"[2] -> \" + mode2\n    + \"\\n[9] -> Exit\\n_________________________________________________________________________________\\n\"))\n\n\n#User selects Integer benchmarking mode\nif modeSelect == 1:\n    print(\"User Selected \" + mode1)\n\n    #Printout of selection for order of magnitude\n    print(\"[1] -> First 1x10^2 Primes\\n\" +  \"[2] -> First 1x10^3 Primes\\n\"\n        +\"[3] -> First 1x10^4 Primes\\n\" + \"[4] -> First 1x10^5 Primes\\n\" + \"[5] -> First 1x10^6 Primes\\n\")\n    mersenneOrder = int(input(\"Please Select an option\\n\"))\n\n\n    if mersenneOrder == 1:\n        print(\"Starting Benchmark...\")\n        with ThreadPoolExecutor(15) as executor:\n            timeStart = perf_counter()\n\n            for result in executor.map(lehmer,range(2,100)):\n                print(result)\n            timeStop = perf_counter()\n\n            print(\"1E2 Benchmark Complete in \",timeStop-timeStart)\n\n\n    if mersenneOrder == 2:\n        print(\"Starting Benchmark...\")\n        with ThreadPoolExecutor(15) as executor:\n            timeStart = perf_counter()\n\n            for result in executor.map(lehmer,range(2,1000)):\n                print(result)\n            timeStop = perf_counter()\n            print(\"1E3 Benchmark Complete!!\", timeStop-timeStart)\n\n\n    if mersenneOrder == 3:\n        print(\"Starting Benchmark...\")\n        with ThreadPoolExecutor() as executor:\n            timeStart = perf_counter()\n\n            for result in executor.map(lehmer,range(2,10000)):\n                print(result)\n            timeStop = perf_counter()\n            print(\"1E4 Benchmark Complete!!\", timeStop-timeStart)\n\n\n    if mersenneOrder == 4:\n        print(\"Starting Benchmark...\")\n        with ThreadPoolExecutor(15) as executor:\n            timeStart = perf_counter()\n\n            for result in executor.map(lehmer,range(2,100000)):\n                print(result)\n            timeStop = perf_counter()\n            print(\"1E5 Benchmark Complete!!\", timeStop-timeStart)\n\n\n    if mersenneOrder == 5:\n        print(\"Starting Benchmark...\")\n        with ThreadPoolExecutor(15) as executor:\n            timeStart = perf_counter()\n\n            for result in executor.map(lehmer,range(2,1000000)):\n                print(result)\n            timeStop = perf_counter()\n            print(\"1E6 Benchmark Complete!!\", timeStop-timeStart)\n\n        #Single-threaded test (DEPRECATED)\n        #for x in range(2,1000000):\n        #    if lehmer(x):\n        #        print(x)\n```\n\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Comparison for BigInteger not working\r\n                \r\nI'm not getting the output that I'm expecting. This is for a primality test. I'm not really sure what's wrong. Either my loop isn't working correctly, or this isn't.\n\nn is a BigInteger. It's a random generated by user inputted length.\n\n```\npublic static boolean isPrime(BigInteger n) {\n\n    BigInteger zero = new BigInteger(\"0\");\n    BigInteger one = new BigInteger(\"1\");\n    BigInteger two = new BigInteger(\"2\");\n    BigInteger three = new BigInteger(\"3\");\n\n    System.out.println(n + \" Mod 2 \" + n.mod(two));\n\n    if (n.compareTo(one) == 0 || n.compareTo(one) < 0) {\n        //System.out.println(\"HIT1\");\n        return false;\n    } else if (n.compareTo(three) == 0 || n.compareTo(three) < 0) {\n        //System.out.println(\"HIT2\");\n        return false;\n    } else if ((n.mod(two)).compareTo(zero) == 0 || (n.mod(three)).compareTo(zero) == 0) {\n        //System.out.println(\"HIT3\");\n        return false;\n    } else {\n        System.out.println(\"Heres n : \" + n);\n        return true;\n    }\n}\n```\n\n\nHere's my loop. I know for sure that my number generator works though.\n\n```\ndo {\n    num1 = generateNumber(p);\n} while (isPrime(generateNumber(p)) == false);\n\ndo {\n    num2 = generateNumber(q);\n} while (isPrime(generateNumber(q)) == false);\n```\n\n    ", "Answer": "\r\nDon't test if the result of ```\ncompareTo()```\n equals -1. When you want to mean ```\na < b```\n, you should write ```\na.compareTo(b) < 0```\n. Always compare with 0, not any other constant.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Numbapro trying to vectorize a jit'd function\r\n                \r\nI'm trying to understand the semantics behind jit/vectorize in numbapro by trying a few simple algorithms. This is the miller-rabin primality test, which I want to subsequently run multiple times.\n\nThis works fine\n\n```\nfrom numbapro import jit , guvectorize , vectorize, uint64, int32, int8, bool_\nimport random\n@jit(bool_(uint64,int32),target='cpu')\ndef is_prime(n,k):\n    if n % 2 == 0:\n        return False\n    # n-1 as 2^s * d\n    dn = n - 1\n    s1 = 0\n    while dn % 2 == 0:\n        dn = dn >> 1\n        s1 += 1\n    for j in range(k):\n        a1 = random.randint(2,n-2)\n        x = pow(a1,dn) % n\n        if x == 1 or x == n - 1:\n            continue\n        for i in range(s1):\n            x = (x * x) % n\n            if x == 1:\n                return False\n            if x == n - 1:\n                break\n    return True\n```\n\n\nBut replacing the decorator with\n\n```\n@vectorize(bool_(uint64,int32),target='cpu')\n```\n\n\ngives an error\n\n```\nTraceback (most recent call last):\n  File \"h:\\users\\mushfaque.cradle\\documents\\visual studio 2013\\Projects\\EulerPraxis\\EulerPraxis\\EulerPraxis.py\", line 12, in <module>\n    @vectorize(int8(uint64,int32),target='cpu')\n  File \"H:\\Apps\\Anaconda3\\lib\\site-packages\\numba\\npyufunc\\decorators.py\", line 67, in wrap\n    for fty in ftylist:\nTypeError: 'NotImplementedType' object is not callable\n```\n\n\nI  understand that vectorize should be used on ufuncs, but what am I missing to make this a ufunc?\n    ", "Answer": "\r\nI've solved this.\n\n\n@vectorize([int32(uint64,int32)],target='cpu') fixes the first issue.\nNote the '[]' around the type annotation\nbool_ as a return type is unsupported (bug) which has been reported. In the mean time use int32\nA more subtle issue is that randint throws an exception if you use n = 3 . Numba doesn't handle exceptions in code yet so there should be an extra 'if' to catch that possibility\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How do I generate a 160 bit prime number in java?\r\n                \r\nI want to generate a 160-bit prime number in java. I know that I'll have to loop through all the 160-bit numbers and for any number ```\nn```\n, I'll have to check if they are divisible by any primes less than ```\nsqroot(n)```\n or by any primality test like ```\nMiller-Rabin test```\n. My questions are:\n\n\nIs there any specific library which does this?\nIs there any other (better) way to do this?\n\n    ", "Answer": "\r\n```\nBigInteger.probablePrime(160, new Random())```\n generates a ```\nBigInteger```\n that is almost certainly prime -- the probability that it is not a prime is less than the probability that you will get struck by lightning.  In general, ```\nBigInteger```\n already has heavily tested and optimized primality testing operations built in.\n\nFor what it's worth, the reason this won't take forever is that by the prime number theorem, a randomly chosen n-bit number has probability proportional to 1/n of being prime, so on average you only need to try O(n) different random n-bit numbers before you'll find one that's prime.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Rust implement the function as long as `Integer::from` works\r\n                \r\nI'm trying to implement a ```\nnum_to_rug```\n function, whch converts a generic number into a ```\nrug::Integer```\n.\n(the purpose is to call Rug's primality test, ```\nInteger::from(n).is_probably_prime```\n)\nThis is easy to do for ```\nu32```\n and ```\nu64```\n, as ```\nInteger::from```\n is implemented for them:\n```\nimpl PrimeQ<u32> {\n  fn num_to_rug(n: u32) -> Integer {\n    Integer::from(n)\n  }\n}\n\nimpl PrimeQ<u64> {\n  fn num_to_rug(n: u64) -> Integer {\n    Integer::from(n)\n  }\n}\n```\n\nNow I want to implement this function for any type that:\n\nSatisfy my own ```\nPrimeSieveTrait```\n\nHas ```\nInteger::from```\n implemented\n\n```\npub trait PrimeSieveTrait:\n  AddAssign + SubAssign + MulAssign + DivAssign + integer::Roots + PrimInt + FromPrimitive {}\nimpl<T> PrimeSieveTrait for T\n  where T:\n    AddAssign + SubAssign + MulAssign + DivAssign + integer::Roots + PrimInt + FromPrimitive {}\n```\n\nHow do I modify the code below so it compiles?\n```\nimpl<T: ?> PrimeQ<T> {\n  fn num_to_rug(n: T) -> Integer {\n    Integer::from(n)\n  }\n}\n```\n\n    ", "Answer": "\r\nIf you literally want to use the ```\nFrom<T>```\n trait, then this cannot be expressed as an inline trait bound – you need to use a ```\nwhere```\n clause instead:\n```\nimpl<T> PrimeQ<T>\nwhere\n    T: PrimeSieveTrait,\n    Integer: From<T>,\n{\n    fn num_to_rug(n: T) -> Integer {\n        Integer::from(n)\n    }\n}\n```\n\nA better alternative would be to use the ```\nInto<Integer>```\n trait instead, in which case you only need trait bounds on ```\nT```\n:\n```\nimpl<T: PrimeSieveTrait + Into<Integer>> PrimeQ<T> {\n    fn num_to_rug(n: T) -> Integer {\n        n.into()\n    }\n}\n```\n\n(I would usually write this with a ```\nwhere```\n clause as well, as I find that more readable.)\nMore generally, the trait bound ```\nU: From<T>```\n implies ```\nT: Into<U>```\n because of a blanket implementation in the standard library. This means that using the trait bound ```\nT: Into<U>```\n as in the second code snippet above makes your function more general, and it's also more convenient to use, so it should be preferred over the ```\nFrom```\n trait bound.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Stackoverflow exception while testing Miller Rabin\r\n                \r\nAll,\n\nI have implemented a code that generates 2 random prime numbers and the multiplication of these 2 numbers should pass the Miller Rabin primality test. However, my code keeps looping all the time trying to find a number that passes Miller rabin test and ends up with a Stackoverflow exception. Here is the code:\n\n```\nprivate void populateRandomPrimes()\n{\n    onePrimeValue = RandomPrime.getValue();\n\n    do\n    {\n        secondPrimeValue= RandomPrime.getValue();\n    }while(onePrimeValue == secondPrimeValue);\n\n    BigInteger calcNum = new BigInteger(Integer.toString(onePrimeValue*secondPrimeValue));\n\n    try\n    {\n        **if (calcNum.isProbablePrime(20))**\n            populateMultiplicativeForPlayer();\n        else\n            populateRandomPrimes();\n    }\n    catch (Exception io)\n    {\n        io.printStackTrace();\n    }\n}\n```\n\n\nIn the code above:\n1 > RandomPrime class returns a random prime number\n2 > Both onePrimeValue and secondPrimeValue should be different\n3 > Since the code line : ```\nif (calcNum.isProbablePrime(20))```\n never returns a ```\ntrue```\n, I end up calling the same till I get ```\nStackoverflow```\n exception  \n\nCan anyone suggest me how to get around with this issue?  \n    ", "Answer": "\r\nPlease see my comment below your question...\n\n```\nprivate void populateRandomPrimes()\n{\n    while (true){\n      onePrimeValue = RandomPrime.getValue();\n\n      do\n      {\n          secondPrimeValue= RandomPrime.getValue();\n      }while(onePrimeValue == secondPrimeValue);\n\n      BigInteger calcNum = new BigInteger(Integer.toString(onePrimeValue*secondPrimeValue));\n\n      try\n      {\n          if (calcNum.isProbablePrime(20)){\n              populateMultiplicativeForPlayer();\n              return;\n          }\n      }\n      catch (Exception io)\n      {\n          io.printStackTrace();\n      }\n    }\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How do I check the primality of a very large BigInt fast?\r\n                \r\nI am generating a large BigInt and need to test whether it is a prime number or not. However, this simple algorithm takes way to long.\n```\nbool _isProbablePrime(BigInt n) {\n  var _isPrime = true;\n  for (var i = BigInt.from(2); i < (n); i = i + BigInt.one) {\n    if (n % i == BigInt.zero) _isPrime = false;\n  }\n  return _isPrime;\n}\n```\n\nIs there another more efficient algorithm that has a fairly high certainty of correctly checking the primality of n?\nAny help is appreciated, and thanks in advance! :D\n    ", "Answer": "\r\nFor everyone interested: The simplest solutions seems to be to use an implementation of the Miller-Rabin primality test.\nThere is a dart-package called ninja_prime that uses this algorithm to determin the primality of BigInts.\nhttps://pub.dev/packages/ninja_prime\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Rabin-Miller test to Carmichael numbers\r\n                \r\nI am a computer science student, I am studying the Algorithms course independently.\nDuring the course I saw this question:\n\nShow an efficient randomized algorithm to factor Carmichael numbers\n(that is, we want a polynomial time algorithm, that given any\nCarmichael number C, with probability at least 3/4 finds a nontrivial\nfactor of C). Hint: use the Rabin-Miller test.\n\nmy solution:\nmy idea is use Rabin-Miller test:\ni will check if C is prime\ni will use  Rabin-Miller Primality tests steps:\n\n\nFind n-1=c^k*m\nchoose a: 1 < a < n-1\ncompute b_0 = a^m(mod n), b_i = b_(i-1)^2 (mod n)\nif b_0 = -/+1 this is prime, i will return nothing.  if b_i = -1 this is prime, will return nothing. else if = 1 this is not prime i will return the factor of C.\n\n\nalgorithm:\n```\nfunction MillerRabinPrimality(n)\n    Input: integer n, Carmichael number\n    Output: return with probability 3/4 nontrivial factor of n\n    Find integers k,q > 0, q odd, so that (n-1)=2^(k)\n    Select a random integer a, 1<a<n-1\n    if a^q mod n = +/-1 \n        return 'this prime'\n    for j = 0 to k-1 do\n        a = a^2 mod q\n        if (a = -1)\n            return 'this prime'\n        if (a = 1)\n            return 'this is composite, factor is ?'     \n```\n\ni dont sure how to return the factor of c, for example i run Rabin-Miller Primality tests for 561, first carmichael number:\n```\nn = 561\nn-1 = 2(^k)*m => 560\n\n560/2^1 = 280 => 560/2^2 = 140 => 560/2^3 = 70 => **560/2^4 = 35** \nk = 4\nm = 35\n\nchoose a: 1<a<560\na = 2\n\nb_0 = 2^35 mod 561 = 263\nb_1 = 263^2 mod 561 = 166\nb_2 = 166^2 mod 561 = 67\nb_3 = 17^2 mod 561 = 1 --> composite \n\ni found that 561 is composite but not sure how to return his factors (3 / 11 / 17)\n```\n\n    ", "Answer": "\r\nIf Miller–Rabin fails on a Carmichael number n, then as a byproduct you get some x ≢ ±1 mod n such that x² ≡ 1 mod n. Both gcd(x + 1, n) and gcd(x − 1, n) are proper divisors of n.\nThe proof: x ≢ 1 mod n is equivalent to x − 1 ≢ 0 mod n, which is equivalent to x − 1 not being divisible by n. Therefore gcd(x − 1, n) ≠ n. Likewise, x ≢ −1 mod n implies that gcd(x + 1, n) ≠ n.\nOn the other hand, x² ≡ 1 mod n is equivalent to (x + 1) (x − 1) being divisible by n, hence gcd((x + 1) (x − 1), n) = n. We cannot have gcd(x + 1, n) = 1, or else gcd(x − 1, n) = n (since gcd(a b, c) = gcd(a, c) for all b such that gcd(b, c) = 1). Likewise, gcd(x − 1, n) ≠ 1.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Of Ways to Count the Limitless Primes [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nAlright, so maybe I shouldn't have shrunk this question sooo much... I have seen the post on the most efficient way to find the first 10000 primes.  I'm looking for all possible ways.  The goal is to have a one stop shop for primality tests.  Any and all tests people know for finding prime numbers are welcome.\n\nAnd so:\n\n\nWhat are all the different ways of finding primes?\n\n    ", "Answer": "\r\nSome prime tests only work with certain numbers, for instance, the Lucas–Lehmer test only works for Mersenne numbers.\n\nMost prime tests used for big numbers can only tell you that a certain number is \"probably prime\" (or, if the number fails the test, it is definitely not prime). Usually you can continue the algorithm until you have a very high probability of a number being prime.\n\nHave a look at this page and especially its \"See Also\" section.\n\nThe Miller-Rabin test is, I think, one of the best tests. In its standard form it gives you probable primes - though it has been shown that if you apply the test to a number beneath 3.4*10^14, and it passes the test for each parameter 2, 3, 5, 7, 11, 13 and 17, it is definitely prime.\n\nThe AKS test was the first deterministic, proven, general, polynomial-time test. However, to the best of my knowledge, its best implementation turns out to be slower than other tests unless the input is ridiculously large.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Execution Time: Boost Multi-precision vs Java BigInteger\r\n                \r\nI'm trying to Implement the Lucas–Lehmer primality test.  \n\nI've two implementations, one in C++ and other in Java, These are follows:\n\nC++:\n\n```\nint p = 86243;\ncpp_int M;\n\nbit_set(M, p);\nM = M-1; // M = 2^p - 1;\n\ncpp_int S;\nS = 4;\n\nwhile(p>2) {\n         S = pow(S, 2);\n         S -= 2;\n\n         S %= M;\n         p--;         \n}\n```\n\n\nJava:\n\n```\nint p = 86243;\n\nBigInteger M = BigInteger.ZERO;\nBigInteger Two = BigInteger.valueOf(2L);\n\nM = M.setBit(p);\nM = M.subtract(BigInteger.ONE); // M = 2^p - 1;\n\nBigInteger S = BigInteger.valueOf(4L);\n\nwhile(p>2) {\n         S = S.pow(2).subtract(Two).mod(M);\n         p--;        \n}\n```\n\n\nThe Java code runs much faster than C++ code, for C++ I'm using CodeBlocks and Eclipse for Java.\n\nAny reason for that? Am I missing anything particularly in C++ code? \nAny suggestions will be appreciated.\n    ", "Answer": "\r\nI think you should not expect both programs (Java and C++ versions) to be equivalent. The performance depends mostly on the algorithms used rather than the language. Running the C++ version in a profiler shows that the divide (i.e. mod) is the bottle-neck. If you then look at the source of the divide (/boost/multiprecision/cpp_int/divide.hpp) you can see this comment:\n\n\n  Very simple, fairly braindead long division.\n  [...]\n  Note that there are more efficient algorithms than this\n  available, in particular see Knuth Vol 2.  However for small\n  numbers of limbs this generally outperforms the alternatives\n  and avoids the normalisation step which would require extra storage.\n\n\nThe BigInteger implementation in Java however uses algorithms called Knuth and/or BurnikelZiegler. Seems like these are better suited for larger numbers. If performance really matters you can try to use the gnu multi-precision library (gmp). On my machine the gmp version is roughly 3x faster than Java/BigInteger:\n\n```\n#include <iostream>\n#include <gmp.h>\nusing namespace std;\n\nint main()\n{\n    int p = 86243;\n    mpz_t M;\n    mpz_init(M);\n    mpz_set_ui(M, 0);\n    mpz_setbit(M, p);\n    mpz_sub_ui(M, M, 1); // M = 2^p - 1;\n\n    mpz_t S;\n    mpz_init(S);\n    mpz_set_ui(S, 4);\n\n    while(p > 2) {\n        mpz_pow_ui(S, S, 2);\n        mpz_sub_ui(S, S, 2);\n\n        mpz_mod(S, S, M);\n\n        p--;\n    }\n    int r = mpz_get_ui(S);\n    cout << \"Is mersenne prime: \" << (r == 0 ? \"yes\" : \"no\") << endl;\n    return 0;\n}\n```\n\n\nLink with -lgmp\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "What does the notation a (mod b, n) mean?\r\n                \r\nI'm trying to write a Python program for the AKS primality test.\n\nThe 5th step states ```\nif (X+a)^n≠ X^n+a (mod X^r − 1,n), output composite;```\n but I'm not sure what to do when the modulo has 2 arguments: ```\nXr-1```\n and ```\nn```\n. In this case, what is it supposed to be calculating?\n\nI understand ```\na(mod b)```\n means that the remainder after dividing a number with ```\nb = a```\n, but not sure what the 2 arguments in this are meant to mean.\n    ", "Answer": "\r\nThe X here means that we're working with polynomials. Mod ```\nX^r - 1```\n means that we mod all of the polynomial exponents by ```\nr```\n. Mod ```\nn```\n means that we mod all of the coefficients by ```\nn```\n.\n\nAs an example, if we have a polynomial ```\nX^4 + 4 X^3 + 6 X^2 + 4 X + 1```\n and we're modding by ```\nX^3 - 1```\n (i.e., ```\nr = 3```\n) and ```\nn = 5```\n, then we get\n\n```\nX^4 + 4 X^3 + 6 X^2 + 4 X + 1 -> (mod by X^3 - 1)\nX^1 + 4 X^0 + 6 X^2 + 4 X + 1 =\nX   + 4     + 6 X^2 + 4 X + 1 =\n6 X^2 + 5 X + 5 -> (mod by 5)\n1 X^2 + 0 X + 0 =\nX^2.\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Using State Monad turns all of my functions into monadic functions\r\n                \r\nI write a cryptography library in Haskell to learn about cryptography and monads. (Not for real-world use!) The type of my function for primality testing is\n\n```\nprime :: (Integral a, Random a, RandomGen g) => a -> State g Bool\n```\n\n\nSo as you can see I use the State Monad so I don't have the thread through the generator all the time. Internally the prime function uses the Miller-Rabin test, which rely on random numbers, which is why the prime function also must rely on random number. It makes sense in a way since the prime function only does a probabilistic test.\n\nJust for reference, the entire prime function is below, but I don't think you need to read it.\n\n```\n-- | findDS n, for odd n, gives odd d and s >= 0 s.t. n=2^s*d.\nfindDS :: Integral a => a -> (a, a)\nfindDS n = findDS' (n-1) 0\n  where\n    findDS' q s\n      | even q = findDS' (q `div` 2) (s+1)\n      | odd  q = (q,s)\n\n-- | millerRabinOnce n d s a does one MR round test on\n-- n using a.\nmillerRabinOnce :: Integral a => a -> a -> a -> a -> Bool\nmillerRabinOnce n d s a\n  | even n           = False\n  | otherwise        = not (test1 && test2)\n  where\n    (d,s) = findDS n\n\n    test1 = powerModulo a d n /= 1\n    test2 = and $ map (\\t -> powerModulo a ((2^t)*d) n /= n-1) \n                      [0..s-1]\n\n-- | millerRabin k n does k MR rounds testing n for primality.\nmillerRabin :: (RandomGen g, Random a, Integral a) =>\n  a -> a -> State g Bool\nmillerRabin k n = millerRabin' k\n  where\n    (d, s)          = findDS n\n    millerRabin' 0 = return True\n    millerRabin' k = do\n      rest <- millerRabin' $ k - 1\n      test <- randomR_st (1, n - 1)\n      let this = millerRabinOnce n d s test\n      return $ this && rest\n\n-- | primeK k n. Probabilistic primality test of n\n-- using k Miller-Rabin rounds.\nprimeK :: (Integral a, Random a, RandomGen g) => \n  a -> a -> State g Bool\nprimeK k n\n  | n < 2            = return False\n  | n == 2 || n == 3 = return True\n  | otherwise        = millerRabin (min n k) n\n\n-- | Probabilistic primality test with 64 Miller-Rabin rounds.\nprime :: (Integral a, Random a, RandomGen g) => \n  a -> State g Bool\nprime = primeK 64\n```\n\n\nThe thing is, everywhere I need to use prime numbers, I have to turn that function into a monadic function too. Even where it's seemingly not any randomness involved. For example, below is my former function for recovering a secret in Shamir's Secret Sharing Scheme. A deterministic operation, right?\n\n```\nrecover :: Integral a => [a] -> [a] -> a -> a\nrecover pi_s si_s q = sum prods `mod` q\n  where\n    bi_s  = map (beta pi_s q) pi_s\n    prods = zipWith (*) bi_s si_s\n```\n\n\nWell that was when I used a naive, deterministic primality test function. I haven't rewritten the ```\nrecover```\n function yet, but I already know that the ```\nbeta```\n function relies on prime numbers, and hence it, and ```\nrecover```\n too, will. And both will have to go from simple non-monadic functions into two monadic function, even though the reason they use the State Monad / randomness is really deep down.\n\nI can't help but think that all the code becomes more complex now that it has to be monadic. Am I missing something or is this always the case in situations like these in Haskell?\n\nOne solution I could think of is\n\n```\nprime' n = runState (prime n) (mkStdGen 123)\n```\n\n\nand use ```\nprime'```\n instead. This solution raises two questions.\n\n\nIs this a bad idea? I don't think it's very elegant.\nWhere should this \"cut\" from monadic to non-monadic code be? Because I also have functions like this ```\ngenPrime```\n:\n\n\n_\n\n```\ngenPrime :: (RandomGen g, Random a, Integral a) => a -> State g a\ngenPrime b = do\n  n  <- randomR_st (2^(b-1),2^b-1)\n  ps <- filterM prime [n..]\n  return $ head ps\n```\n\n\nThe question becomes whether to have the \"cut\" before or after ```\ngenPrime```\n and the like.\n    ", "Answer": "\r\nThat is indeed a valid criticism of monads as they are implemented in Haskell. I don't see a better solution on the short term than what you mention, and switching all the code to monadic style is probably the most robust one, even though they are more heavyweight than the natural style, and indeed it can be a pain to port a large codebase, although it may pay off later if you want to add more external effects.\n\nI think algebraic effects can solve this elegantly, for examples:\n\n\neff (example program with randomness)\nF*\n\n\nAll functions are annotated with their effects ```\na -> eff b```\n, however, contrary to Haskell, they can all be composed simply like pure functions ```\na -> b```\n (which are thus a special case of effectful functions, with an empty effect signature). The language then ensures that effects form a semi-lattice so that functions with different effects can be composed.\n\nIt seems difficult to have such a system in Haskell. Free(r) monads libraries allow composing types of effects in a similar way, but still require the explicit monadic style at the term level.\nOne interesting idea would be to overload function application, so it can be implicitly changed to ```\n(>>=)```\n, but a principled way to do so eludes me. The main issue is that a function ```\na -> m b```\n is seen as both an effectful function with effects in ```\nm```\n and codomain ```\nb```\n, and as a pure function with codomain ```\nm b```\n. How can we infer when to use ```\n($)```\n or ```\n(>>=)```\n?\n\nIn the particular case of randomness, I once had a somewhat related idea involving splittable random generators (shameless plug): https://blog.poisson.chat/posts/2017-03-04-splittable-generators.html\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fermat little theorem fails in MATLAB?\r\n                \r\nI'm currently trying to write a program in MATLAB which checks if a number ```\nn```\n is prime or not. For starters I'm implementing the Fermat Primality Test.\n\nFermat states that for a prime ```\np```\n and ```\n1 <= b < p```\n:\n\n```\nb^(p-1) = 1  (mod p)\n```\n\n\nSo in MATLAB with ```\np = 17```\n, and ```\nb = 11```\n\n\n```\n>> mod(b^(p-1),p)\n```\n\n\nor\n\n```\n>> rem(b^(p-1),p)\n```\n\n\nProblem I have is that for this instance MATLAB returns ```\n0```\n. However if ```\np```\n is prime it should return ```\n1```\n. I cannot see what I'm missing, so any help is much appreciated!\n    ", "Answer": "\r\n@James gave a correct explanation, I just wanted to expand a bit more.\n\nYou see in double-precision floating-point format, integers in the range ```\n[2^52,2^53]```\n are exactly representable (that's because we have 52+1 bits for the fraction part). In the next range ```\n[2^53,2^54]```\n, integers representable are the even ones (previous range multiplied by two). And so on for the next ranges where the spacing doubles every time we go higher.\n\nThe number ```\n11^16```\n (which equals ```\n45949729863572161```\n) unfortunately is not exactly representable in double-precision. In fact the list of representable numbers around that one is:\n\n```\n45949729863572144\n45949729863572152\n45949729863572160\n45949729863572168\n45949729863572176\n```\n\n\nAccording to rounding mode, ```\n45949729863572161```\n will be approximated by the closest representable number which is in this case ```\n45949729863572160```\n.\n\nTo understand what happens, let's try to store the numbers ```\n45949729863572100 + [44:76]```\n and display the result:\n\n```\n% build a cell array of strings containing the numbers, then convert to doubles\n% (you could also enter the numbers as literals directly)\nstr = cellstr(num2str((44:76)', '459497298635721%d'));\nnum = str2double(str);\n\n% print the original number, its stored value (in decimal and hex notations)\nfor i=1:numel(num)\n    fprintf('%s %17.0f %bX\\n', str{i}, num(i), num(i));\nend\n```\n\n\nHere is the output (with some annotations):\n\n```\n    actual           stored          stored in HEX\n----------------------------------------------------\n45949729863572144 45949729863572144 436467E125C16356    % exact representation\n45949729863572145 45949729863572144 436467E125C16356\n45949729863572146 45949729863572144 436467E125C16356\n45949729863572147 45949729863572144 436467E125C16356\n45949729863572148 45949729863572144 436467E125C16356\n45949729863572149 45949729863572152 436467E125C16357\n45949729863572150 45949729863572152 436467E125C16357\n45949729863572151 45949729863572152 436467E125C16357\n45949729863572152 45949729863572152 436467E125C16357    % exact representation\n45949729863572153 45949729863572152 436467E125C16357\n45949729863572154 45949729863572152 436467E125C16357\n45949729863572155 45949729863572152 436467E125C16357\n45949729863572156 45949729863572160 436467E125C16358\n45949729863572157 45949729863572160 436467E125C16358\n45949729863572158 45949729863572160 436467E125C16358\n45949729863572159 45949729863572160 436467E125C16358\n45949729863572160 45949729863572160 436467E125C16358    % exact representation\n45949729863572161 45949729863572160 436467E125C16358\n45949729863572162 45949729863572160 436467E125C16358\n45949729863572163 45949729863572160 436467E125C16358\n45949729863572164 45949729863572160 436467E125C16358\n45949729863572165 45949729863572168 436467E125C16359\n45949729863572166 45949729863572168 436467E125C16359\n45949729863572167 45949729863572168 436467E125C16359\n45949729863572168 45949729863572168 436467E125C16359    % exact representation\n45949729863572169 45949729863572168 436467E125C16359\n45949729863572170 45949729863572168 436467E125C16359\n45949729863572171 45949729863572168 436467E125C16359\n45949729863572172 45949729863572176 436467E125C1635A\n45949729863572173 45949729863572176 436467E125C1635A\n45949729863572174 45949729863572176 436467E125C1635A\n45949729863572175 45949729863572176 436467E125C1635A\n45949729863572176 45949729863572176 436467E125C1635A    % exact representation\n```\n\n\nAs you can see there can be no numbers in between ```\nxxx44```\n and ```\nxxx52```\n (since their HEX representation only differ in the last bit by one). Anything in between will have to be approximated to the nearest representable number. So the range is divided by two, half assigned to the lower bound, the other half assigned to the upper bound (note that there are 7 numbers in between, so the middle one is a special case, and gets assigned to the upper/lower bounds in an alternating fashion).\n\nAs a result, entering any number between ```\n45949729863572156```\n and ```\n45949729863572164```\n (which includes ```\n11^16```\n) will actually store the double-value ```\n45949729863572160```\n.\n\n\n\nNow others have suggested using a bignum library to avoid these numerical limitations (the Symbolic Math Toolbox from MathWorks, VPI or HPF by John D'Errico, or one of the other solutions available on the File Exchange ...). For example:\n\n```\n>> b = sym(11);    % Symbolic Math Toolbox\n>> b^16\nans =\n45949729863572161\n>> mod(b^16,17)\nans =\n1\n```\n\n\nHowever, in your case, ```\nuint64```\n is capable of accurately storing those numbers:\n\n```\n>> b = uint64(11); p = uint64(17);\n>> b^(p-1)\nans =\n    45949729863572161\n>> mod(b^(p-1),p)\nans =\n                    1\n```\n\n\nJust keep in mind that:\n\n```\n>> intmax('uint64')\nans =\n 18446744073709551615\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Put an output from a function into a data frame or a list or a vector in R\r\n                \r\nI am trying to test the accuracy of the Euler's primality test. I wrote a function euler() that takes in a numeric and tests all numbers for primality up to the input and outputs them to the console including the nonprimes. Here is how it looks:\n\n```\neuler(10)\n[1] 1\n[1] 2\n[1] 3\n[1] \"Not prime:\" \"4\"         \n[1] 5\n[1] \"Not prime:\" \"6\"         \n[1] 7\n[1] \"Not prime:\" \"8\"         \n[1] \"Not prime:\" \"9\"         \n[1] \"Not prime:\" \"10\"        \n> \n```\n\n\nI am trying to take this output and put it into a data frame or a factor or a list. I tried ```\nx<-euler(10)```\n, but it did not work. I just get a NULL vector. Here is the code of my euler function:\n\n```\n## Euler's primality test\n\neuler <- function(k) {\n  for(i in 1:k) {\n    a  <- 2;\n    if((a^i-a) %% i == 0) {\n      print(i)\n    } else{print(c(\"Not prime:\",i))}\n  }   \n}\n```\n\n\nI tried defining a data frame outside the \"for\" loop and then use rbind(), but I do not know how to do it when there is an if statement. Any help appreciated. If I was unclear let me know and I will make the necessary edits.\n    ", "Answer": "\r\nIt is recommended that a function return something instead of printing it. (And you are still free to print the output after calling the function if that's what you want.)\n\nIt is also recommended that the output of a function be consistent, e.g. do not return a number in one case, or a string \"Not prime\" in another. Here, returning a boolean (TRUE or FALSE for prime or not) is what makes most sense.\n\nIt is also recommended (beneficial) to vectorize functions when you can. So you could call the function using a vector like ```\n1:10```\n and it will quickly return a vector of ten booleans.\n\nTaking all that into account, I would define the function as follows:\n\n```\nis.euler.prime <- function(k) (2^k-2) %% k == 0\n```\n\n\nThen you can do things like:\n\n```\nis.euler.prime(10)\nis.euler.prime(1:10)\nwhich(is.euler.prime(1:10))\ndata.frame(x = 1:10, euler.prime = is.euler.prime(1:10))\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Unable to do tail recursion in C++ using clang with -O3 option\r\n                \r\nI am unable to tell the clang compiler to perform tail-recursive optimisation in my C++ code. I saw this post Which, if any, C++ compilers do tail-recursion optimization?, where the advice is to use the -O3 flag with clang and it would do it. But in spite of that, I am having stack overflow for large inputs to the below primality testing code.\n```\n#include <iostream>\n#include <chrono>\n#include <gmp.h>\n#include <string>\n\nbool mpz_is_divisible(mpz_t n, mpz_t d);\n\nvoid mpz_sqr(mpz_t res, mpz_t x) {\n   //computes square of x and puts the result into res\n\n   mpz_pow_ui(res, x, 2);\n}\n\n//the below function causes stack overflow for large inputs\n\nvoid smallest_divisor(mpz_t n, mpz_t div, mpz_t div_sqr, mpz_t smallest_div) {\n //finds the smallest number which divides n and puts the result into smallest_div\n\n  mpz_sqr(div_sqr, div);\n  \n  if (mpz_cmp(div_sqr, n) > 0) {\n     mpz_set(smallest_div, n);\n     return;\n  }\n\n  if (mpz_is_divisible(n, div)) {\n    mpz_set(smallest_div, div);\n    return;\n  }\n\n  mpz_add_ui(div, div, 1);\n  smallest_divisor(n, div, div_sqr, smallest_div); //<-- should do tail recursion optimisation?\n}\n\nbool mpz_prime_test_basic(mpz_t n) {\n  //checks if n is prime\n\n  mpz_t div, div_sqr, smallest_div;\n\n  mpz_inits(div, div_sqr, smallest_div, NULL);\n  mpz_set_ui(div, 2);\n\n  smallest_divisor(n, div, div_sqr, smallest_div);\n\n  if (mpz_cmp(smallest_div, n) == 0) {\n    mpz_clear(div);\n    mpz_clear(div_sqr);\n    mpz_clear(smallest_div);\n    return true;\n  }\n  mpz_clear(div);\n  mpz_clear(div_sqr);\n  mpz_clear(smallest_div);\n  return false;\n}\n\nbool mpz_is_divisible(mpz_t n, mpz_t d) {\n  //checks if n is divisible by d\n  mpz_t rem;\n  mpz_init(rem);\n  mpz_tdiv_r(rem, n, d);\n  int cmp = mpz_cmp_si(rem, 0); //checks if remainder is equal to 0\n  if (cmp == 0) return true;\n  return false;\n}\n\nint main() {\n  std::string num_str;\n  mpz_t num;\n  mpz_init(num);\n  std::cout << \"Enter number to check\" << '\\n';\n  std::cin >> num_str;\n  mpz_set_str(num, num_str.c_str(), 10);\n\n  bool is_prime = mpz_prime_test_basic(num);\n\n  if (is_prime) {\n    std::cout << num_str << \" is a prime\\n\";\n  } else {\n    std::cout << num_str << \" is not a prime\\n\";\n  }\n\n  return 0;\n}\n```\n\nI am going through chapter 1 of SICP right now and there's an exercise (1.22) about checking primality using an O(√n) algorithm. Tail-recursion is enforced by the Scheme standard, hence there is no problem there for large inputs but I am doing the same problem in C++, and for large numbers, the smallest-divisor function consumes the stack. I am using the GMP library for big integer arithmetic.\nIs it possible to enforce tail recursion in such a program?\nThanks\n    ", "Answer": "\r\nSomething is odd about ```\nmpz_is_divisible```\n. For one, you forget to free the memory held by ```\nrem```\n. Even if you add the ```\nmpz_clear(rem)```\n call, you don't get TCO in ```\nsmallest_divisor```\n. What you have to do is mark it ```\n__attribute__((noinline))```\n to get Clang to do the optimization (though GCC does it without it). Very strange, and also moot, since ```\nmpz_is_divisible```\n is just a worse version of ```\nmpz_divisible_p```\n.\n```\nvoid smallest_divisor(mpz_t n, mpz_t div, mpz_t div_sqr, mpz_t smallest_div) {    \n    mpz_sqr(div_sqr, div);\n    if (mpz_cmp(div_sqr, n) > 0) {\n        mpz_set(smallest_div, n);\n        return;\n    }\n    if (mpz_divisible_p(n, div)) {\n        mpz_set(smallest_div, div);\n        return;\n    }\n    mpz_add_ui(div, div, 1);\n    smallest_divisor(n, div, div_sqr, smallest_div); // gets TCO\n}\n```\n\nGodbolt (steals GMP from trunk GCC, may have to update some paths with the current date to make it work)\nI've also cleaned up the code a lot to produce a new version. In particular, my FP intuition tells me that ```\nsmallest_divisor```\n is really not supposed to be its own function. It's a recursive worker that belongs inside of ```\nmpz_prime_test_basic```\n. We can use this answer to write local recursive definitions. I couldn't find ```\ngmpxx.h```\n on Godbolt, so I also wrote a clone of ```\nmpz_class```\n. Then we can write\n```\nbool is_prime(mpz_t n) noexcept {\n    mpz div(2L);\n    fix{[](auto rec, mpz_t n, mpz_t div, mpz_t div_sqr) noexcept -> void {\n        mpz_mul(div_sqr, div, div);\n        if(mpz_cmp(div_sqr, n) > 0) mpz_set(div, n);\n        else if(!mpz_divisible_p(n, div)) {\n            mpz_add_ui(div, div, 1);\n            rec(n, div, div_sqr);\n        }\n    }}(n, div, mpz());\n    return mpz_cmp(div, n) == 0;\n}\n```\n\nSince we're not actually changing the arguments between the calls, just mutating behind them, we can also just write\n```\nbool is_prime(mpz_t n) noexcept {\n    mpz div(2L), div_sqr;\n    fix{[&](auto rec) noexcept -> void {\n        mpz_mul(div_sqr, div, div);\n        if(mpz_cmp(div_sqr, n) > 0) mpz_set(div, n);\n        else if(!mpz_divisible_p(n, div)) {\n            mpz_add_ui(div, div, 1);\n            rec();\n        }\n    }}();\n    return mpz_cmp(div, n) == 0;\n}\n```\n\nGodbolt (same caveat)\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Extremely fast method for modular exponentiation with modulus and exponent of several million digits\r\n                \r\nAs a hobby project I'm taking a crack at finding really large prime numbers. The primality tests for this contain modular exponentiation calculations, i.e. a^e mod n. Let's call this the modpow operation to keep the explanation simple. I am wanting to speed up this particular calculation.\n\nCurrently I am using GMP's mpz_pown function, but, it is kind of slow. The reason I think it's too slow, is because a function call to GMP's modpow is slower than a full-blown primality test of the software called PFGW for the same large number. (So to be clear, this is just the GMP's modpow part, not my whole custom primality testing routine I am comparing). PFGW is considered the fastest in it's field and for my use case it uses a Brillhart-Lehmer-Selfridge primality test - which also uses the modpow procedure - so it's not because of mathematical cleverness that PFGW is faster in that aspect (please correct me if I'm wrong here). It looks like the bottleneck in GMP is the modpow operation. An example runtime for numbers which have a little over 20,000 digits: GMP's modpow operation takes about 45 seconds and PFGW finishes the whole primality test (involving a modpow) in 9 seconds flat. The difference gets even more impressive with even bigger numbers. GMP uses FFT multiplication and Montgomery reduction for this test comparison, see comments on this post below.\n\nI did some research. So far I understand that the modpow algorithm uses exponentiation by squaring, integer multiplication and modulo reduction - these all sound very familiar to me. Several helper methods could improve the running time of integer multiplication:\n\n\nMontgomery multiplication\nFFT multiplication\n\n\nTo improve the running time of the exponentiation by squaring part, one may use a signed digit representation to reduce the number of multiplications (i.e. bits are represented as 0, 1 or -1, and the bit string is represented in such a way so that it contains many more zeros than in it's original base-2 representation - this reduces the running time of exponentiation by squaring).\n\nFor optimizing the modulo part of the operation, I know of these methods:\n\n\nMontgomery reduction\n\n\nSo here is the 150,000 dollar question: is there a software library available to do a modpow operation efficiently given a very large base, exponent and modulus? (I'm aiming for several millions of digits). If you would like to suggest an option, please try to explain the inner workings of the algorithm for the case with millions of digits for the base, modulus and exponents, as some libraries use different algorithms based on the number of digits. Basically I am looking for a library which supports the techniques mentioned above (or possibly more clever techniques) and it should perform well while running the algorithm (well, better than GMP at least). So far I've searched, found and tried GMP and PFGW, but didn't find these satisfying (PFGW is fast, but I'm just interested in the modpow operation and there is no direct programming interface to that). I'm hoping that maybe an expert in the field can suggest a library with these capabilities, as there seem to be very few that are able to handle these requirements.\n\nEdit: made the question more concise, as it was marked too broad.\n    ", "Answer": "\r\nFirst off, re. the Answer 1 writer's comment \"I do not use GMP but I suspect when they wrote they use FFT\nthey really mean the NTT\" -- no, when GMP says \"FFT' it means a floating-point FFT. IIRC they also have some NTT-based routines, but for bignum mul those are uncompetitive with FFT.\n\nThe reason a well-tuned FFT-mul beats any NTT is that the slight loss of per-word precision due to roundoff error accumulation is more than made up for by the vastly superior floating-point capabilities of modern CPU offerings, especially when one considers high-performance implementations which make use of the vector-math capabilities of CPUs such as the x86_64 family, the current iterations of which - Intel Haswell, Broadwell and Skylake - have massive vector floating-point capability. (I don't cite AMD in this regard because their AVX offerings have lagged far behind Intel's; their high-water mark was circa 2002 and since then Intel has been beating the pants off them in progressively-worse fashion each year.) The reason GMP disappoints in this area is that GMP's FFT is, relatively speaking, crap. I have great respect for the GMP coders overall, but FFT timings are FFT timings, you don't get points for effort or e.g. having a really good bignum add. Here is a paper detailing a raft of GMP FFT-mul improvements:\n\nPierrick Gaudry, Alex Kruppa, Paul Zimmerman: \"A GMP-based Implementation of Schönhage-Strassen's Large Integer Multiplication Algorithm\" [http://www.loria.fr/~gaudry/publis/issac07.pdf]\n\nThis is from 2007, but AFAIK the performance gap noted in the snippet below has not been narrowed; if anything it has widened. The paper is excellent for detailing various mathematical and algorithmic improvements which can be deployed, but let's cut to the money quote:\n\n\"A program that implements a complex floating-point FFT for integer multiplication is George Woltman’s Prime95. It is written mainly for testing large Mersenne numbers 2^p − 1 for primality in the in the Great Internet Mersenne Prime Search [24]. It uses a DWT for multiplication mod a*2^n ± c, with a and c not too large, see [17]. We compared multiplication modulo 2^2wn − 1 in Prime95 version 24.14.2 with multiplication of n-word integers using our SSA implementation on a Pentium 4 at 3.2 GHz, and on an Opteron 250 at 2.4 GHz, see Figure 4. It is plain that Prime95 beats our im- plementation by a wide margin, in fact usually by more than a factor of 10 on a Pentium 4, and by a factor between 2.5 and 3 on the Opteron.\"\n\nThe next few paragraphs are a raft of face-saving spin. (And again, I am personally acquainted with 2 of the 3 authors, and they are all top guys in the field of computational number theory.)\n\nNote that the aforementioned George Woltman, whose Prime95 code has discovered all of the world-record primes since shortly after its debut 20 years ago, has made his core bignum routines available in a general API-ized form called the GWNUM library. You mentioned how much faster PFGW is than GMP for FFT-mul - that's because PFGW uses GWNUM for the core 'heavy lifting' arithmetic, that's where the 'GW' in PFGW comes from.\n\nMy own FFT implementation, which has generic-C build support but like George's uses reams of x86 vector-math assembler for high performance on that CPU family, is roughly 60-70% slower than George's on current Intel processor families. I believe that makes it the world's 2nd-fastest bignum-mul code on x86. By way of example, my code is currently running a primality test on a number with roughly 2^29 bits using a 30-Mdouble-length FFT (30*2^20 doubles); thus a little more than 17 bits per input word. Using all four of my 3.3 GHz Haswell 4670 quad's cores it takes ~90 ms per modmul.\n\nBTW, many (if not most) of the world's top bignum-math coders hang out at mersenneforum.org, I encourage you to check it out and ask your questions to the broader (at least in this particular area) expert audience there. I appear under the same handle there as here; George Woltman appears as \"Prime95', PFGW's Mark Rodenkirch goes as \"rogue\".\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to extract the prime numbers generated by RSACryptoServiceProvider?\r\n                \r\nThe below code is attempting to get the two RSA prime numbers generated by ```\nRSACryptoServiceProvider```\n. I'm testing ```\nprimeq```\n for primality and it always turns up to be non prime. What am I doing wrong here ?\n\n```\nRSACryptoServiceProvider rsa = new RSACryptoServiceProvider(384);\nvar p = rsa.ExportParameters(true);\nvar primeq = new BigInteger(p.Q);\n```\n\n    ", "Answer": "\r\nI struggled with this problem myself. I have found that there are in fact two issues:\n\n\nFirst, ```\nBigInteger```\n uses different endianess from the ```\nRSACryptoServiceProvider```\n\n```\nBigInteger```\n is signed and uses two's compliment notation, whereas RSA keys are unsigned integers.\n\n\nTo solve this I would modify your code as follows:\n\n```\nRSACryptoServiceProvider rsa = new RSACryptoServiceProvider(384);\nvar p = rsa.ExportParameters(true);\nvar primeq = new BigInteger(p.Q.Reverse().Concat(new Byte[1]).ToArray());\n```\n\n\nThis was tested with the following code:\n\n```\nusing (var rsa = new RSACryptoServiceProvider()) {\n    var a = rsa.ExportParameters(true);\n    BigInteger p = new BigInteger(a.P.Reverse().Concat(new byte[1]).ToArray());\n    BigInteger q = new BigInteger(a.Q.Reverse().Concat(new byte[1]).ToArray());\n    BigInteger n = new BigInteger(a.Modulus.Reverse().Concat(new byte[1]).ToArray());\n    Console.WriteLine(p * q == n);\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Big primes loop with GMP library C++\r\n                \r\nIt's the first time that I use the gmp library, so I'm really lost, I've found a code implementing the \"miller rabin primality test\" in c++ but I wanted to be able to apply it to integers with arbitrary precision so I installed the GMP library.\n\nThe problem is, I've got no idea of how GMP library actually works (I've read trough a few pages of the manual but I understand very little about it also since I haven't even studied object oriented programming), I want to adapt the primality test to be able to input integers 'num' of about 1000-2000 digits, here's the code:\n\n```\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <gmpxx.h>\n#include <gmp.h>\n#define ll long long\nusing namespace std;\n/* \n * calculates (a * b) % c taking into account that a * b might overflow \n */\nll mulmod(ll a, ll b, ll mod)\n{\n    ll x = 0,y = a % mod;\n    while (b > 0)\n    {\n        if (b % 2 == 1)\n        {    \n            x = (x + y) % mod;\n        }\n        y = (y * 2) % mod;\n        b /= 2;\n    }\n    return x % mod;\n}\n/* \n * modular exponentiation\n */\nll modulo(ll base, ll exponent, ll mod)\n{\n    ll x = 1;\n    ll y = base;\n    while (exponent > 0)\n    {\n        if (exponent % 2 == 1)\n            x = (x * y) % mod;\n        y = (y * y) % mod;\n        exponent = exponent / 2;\n    }\n    return x % mod;\n}\n/*\n * Miller-Rabin primality test, iteration signifies the accuracy\n */\nbool Miller(ll p,int iteration)\n{\n    if (p < 2)\n    {\n        return false;\n    }\n    if (p != 2 && p % 2==0)\n    {\n        return false;\n    }\n    ll s = p - 1;\n    while (s % 2 == 0)\n    {\n        s /= 2;\n    }\n    for (int i = 0; i < iteration; i++)\n    {\n        ll a = rand() % (p - 1) + 1, temp = s;\n        ll mod = modulo(a, temp, p);\n        while (temp != p - 1 && mod != 1 && mod != p - 1)\n        {\n            mod = mulmod(mod, mod, p);\n            temp *= 2;\n        }\n        if (mod != p - 1 && temp % 2 == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n//Main\nint main()\n{\n    int w=0;\n    int iteration = 5;\n    mpz_t num;\n    cout<<\"Enter integer to loop: \";\n    cin>>num;\n    if (num % 2 == 0)\n    num=num+1;\n    while (w==0) {\n    if (Miller(num, iteration)) {\n        cout<<num<<\" is prime\"<<endl;\n        w=1;\n    }\n    else    \n        num=num+2;\n    }\n    system (\"PAUSE\");\n    return 0;\n}\n```\n\n\n(If I define num to be 'long long' the program works just fine, but I have no idea how I should adapt the whole thing to \"match\" num being defined as 'mpz_t' instead, also I didn't mention it but the program basically takes an initial integer value and loops it by adding 2 if the integer is composite until it becomes a prime number)\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Easy and fast Random Prime generator?\r\n                \r\nI know that there are many prime generators, such as the sieve of Eratosthenes or Atkin.\nBut they generate numbers sequentially, starting from the small ones. \nWhat method can I use to get prime numbers in an interval without starting from the smallers?\n\nAn option could be to use a random number generator and test the output with a primality test, deterministic or probabilistic, depending of what I want to achieve. Anyway the test would be slow and complex.\n\nIs there any quick and easy method to generate primes non consecutively?\nA pseudoprime generator would also be OK.\n\nregards\n\n\n\nI rewrite the question more clearly:\n\nHow can I generate prime numbers in a given interval without:\n- going sequentially from the smallers to the largest ones (as with a Erathostenes Sieve) \n- nor using slow probabilistic primality tests on a random sequence?\n\nIs there any FAST and EASY algorithm or function that generates numbers in such a way that if you run it for a long time you get all prime numbers on an interval? (I don't mind if it also generates some composites).\n    ", "Answer": "\r\nIf the interval is not too big and the low end of the interval is not too high, you can use a segmented Sieve of Eratosthenes; the definitions of \"too big\" and \"too high\" depend on your aspirations and your patience, but anything bigger than about 10^15 is unlikely to be successful. Otherwise you can pick a random odd number in the desired interval, test it for primality, and either keep it if it is prime or try the next larger odd number, continuing until you find a prime; you could speed that up if you wish by using a prime wheel to generate candidate primes rather than just testing the next odd number. There is no third choice.\n\nYou've said that you don't mind too much if the number is composite. In that case, you could generate a random odd number, test it just for strong pseudoprimality to base 2 and no other bases, and keep it if the test says it is prime or try again with the next odd number if the test says it is composite. That's not a perfect primality test, but it is faster than doing 25 tests of random bases for a Miller-Rabin test, and faster than a Lucas pseudoprime test, and may be good enough for your purposes.\n\nYou can find descriptions of all these things by searching at Stack Overflow, or by looking at my blog, or you can ask here if you have additional specific questions.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Limit Cython CPU and RAM usage?\r\n                \r\nRecently I installed Cython and use it to speed up my python program (primality test). As I give a small number, it works fine and runs much faster. But giving such a huge number, my computer started to freeze as both CPU and RAM reach 100%.\n\nIs there a way to limit Cython CPU and RAM usage?\n\nHere's my code by the way (in Cython language):\n\n```\nfrom math import *\n\ncpdef trial_factoring(float M, float p, list bits_list):\n    cdef float t\n    t = sqrt((M+1)*2)\n\n    cdef float k_range\n    k_range = (t-1)//(2*p)\n\n    cdef float k\n    k = 1 \n\n    cdef list potential_filter\n    potential_filter = []                   \n\n    cdef float potential\n\n    while k <= k_range:\n        potential = 2*k*p + 1\n        if potential % 8 == 3 or potential % 8 == 5:\n            pass\n        else:\n            potential_filter.append(potential)\n        k += 1\n\n    cdef int a\n    a = 1   \n\n    cdef int factor\n    cdef int i\n\n    for factor in potential_filter:\n        for i in range(len(bits_list)):\n            a *= a                  \n            if bits_list[i] == 1:        \n                a *= 2              \n                a %= factor         \n\n        if a == 1:                  \n            return False            \n\n    return True                     \n```\n\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Wrong calculation when using Cython [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        C left shift on 64 bits fail\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 3 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI implemented Lucas-Lehmer primality test to check Mersenne prime in python. Then I use Cython to speed up the calculation.\n\n\nOriginal Python code:\n\n\n```\ndef lucas_lehmer(p):    \n    if p == 2:\n        return True\n\n    s = 4\n    M = (1 << p) - 1\n\n    for i in range(p-2):    \n        s = ((s * s) - 2) % M\n        print(\"Processed: {}%\".format(100*i//(p-2)))\n\n    if s == 0:\n        return True\n\n    else:\n        return False\n```\n\n\n\nCython code:\n\n\n```\ncpdef lucas_lehmer(int p):    \n    if p == 2:\n        return True\n\n    cdef unsigned long long int M\n    M = (1 << p) - 1\n\n    cdef unsigned long long int s\n    s = 4\n\n    cdef int i\n\n    for i in range(p-2):    \n        s = ((s * s) - 2) % M\n        print(\"Processed: {}%\".format(100*i//(p-2)))\n\n    if s == 0:\n        return True\n\n    else:\n        return False\n```\n\n\nRunning the original Python code, it works correctly. But for Cython, it's only correct with ```\np = 31```\n and lower, testing with ```\np = 61```\n and bigger (all tested p values are values that ```\n2^p-1```\n is prime), it returns False (not a prime number), except for ```\np = 86243```\n.\n\nFor some p like 97, even though ```\n2^97-1```\n is not a prime number, the program actually return True (is a prime number), which is a contradiction. \n\nWhy does this happen? Without using cdef for variable ```\nM```\n and ```\ns```\n, the calculation will be correct, but the performance won't get any improved.\n    ", "Answer": "\r\nRunning a few tests on your code I found that M was always equal to 1\nso I defined p as a cdef and got the required result.\n\nNot sure exactly what the issue is but it's something to do with that bit operation on p. p needs to be of the same type as M for it to make sense and if one is cdef and one is python int somehow it doesn't work?\n\n```\ncpdef lucas_lehmer(int py):    \n    cdef p\n    p = py\n    if p == 2:\n        return True\n\n    cdef M\n    M = (1 << p) - 1\n\n    cdef s\n    s = 4\n\n    cdef int i\n\n    for i in range(p-2):    \n        s = ((s * s) - 2) % M\n        print(\"Processed: {}%\".format(100*i//(p-2)))\n\n    if s == 0:\n        return True\n\n    else:\n        return False\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How can I define the \"primality order\" in pari/gp?\r\n                \r\nI'm deeply interested in number theory and want to test some of my ideas in pari/gp, but am not familiar with this software. Specifically, I want to define a 'primeorder' function that maps an integer n to what I call its primality order, which is 0 if and only if n is composite and equal to the least integer k such that the k-th iterate of the prime counting function evaluated at n is composite otherwise.\n\nHow can I define such a function in pari/gp?\n    ", "Answer": "\r\nPlease, review this:\n\n```\nprimeorder(x) = {\n  if(!isprime(x), return(0));\n\n  my(k=1, p=primepi(x));\n  while(isprime(p), p=primepi(p); k++);\n  return(k);\n}\n```\n\n\nI highly recommend to read PARI/GP tutorial.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Generate large(512 bit+) prime number python 3.6\r\n                \r\nI've been attempting to generate large prime numbers with Python for RSA encryption for the past week and a half, with no luck. The Fermat primality test is infeasible at scales of 512 bits, and I can't quite wrap my head around Miller-Rabin. (I'm 13) All the scripts online seem to work with versions of Python below the one I'm using.  What should I do to generate massive primes? (Yes, probabilistic primes are fine.)\n    ", "Answer": "\r\nHere is my Miller-Rabin prime checker:\n\n```\ndef isPrime(n, k=5): # miller-rabin\n    from random import randint\n    if n < 2: return False\n    for p in [2,3,5,7,11,13,17,19,23,29]:\n        if n % p == 0: return n == p\n    s, d = 0, n-1\n    while d % 2 == 0:\n        s, d = s+1, d/2\n    for i in range(k):\n        x = pow(randint(2, n-1), d, n)\n        if x == 1 or x == n-1: continue\n        for r in range(1, s):\n            x = (x * x) % n\n            if x == 1: return False\n            if x == n-1: break\n        else: return False\n    return True\n```\n\n\nIf you want a guaranteed prime (not a probable prime), that's not very much harder to arrange. See my blog for a method due to Pocklington.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why in .Net HashHelpers.IsPrime is implemented in this way?\r\n                \r\nLooking at .NET ```\nSystem.Collections.Generic.Dictionary<T,T>```\n implementation I found a method HashHelpers.IsPrime(n) which check if number is prime or not. \nI was confused a little bit why they use very simple optimization technique testing only odd numbers starting from 3.  \n\n(from source code)\n\n```\nint limit = (int)Math.Sqrt (candidate);\nfor (int divisor = 3; divisor <= limit; divisor+=2)\n{\n     if ((candidate % divisor) == 0)\n          return false;\n     }\nreturn true;\n```\n\n\nSo, they reduce checks in twice from 3 to limit. But more optimal is testing for numbers 6*k-1,6*k+1 according to Wikipedia reducing tests in 3 times. And I think there's even more optimal and faster solutions for primality test.\n\nI understand that in particular ```\nDictionary<T,T>```\n implementation it's not so important because it is called only for huge dictionaries and in pretty rare cases while resizing. But in general, it's a framework and very popular from well known company. Maybe some logic exists or I don't see something here? Thanks.\n    ", "Answer": "\r\n\n  I think there's even more optimal and faster solutions for primality test.\n\n\nYep.\n\n\n  Maybe some logic exists or I don't see something here?\n\n\nNope.  You've accurately summed up the situation.\n\nYou ask:\n\n\n  Why in .Net HashHelpers.IsPrime is implemented in a non-optimal way?\n\n\nand then you answer your own question:\n\n\n  I understand that in particular ```\nDictionary<T,T>```\n implementation it's not so important because it is called only for huge dictionaries and in pretty rare cases while resizing.\n\n\nSo you know the answer to your question. It's not optimized because fast enough is by definition fast enough, and the given algorithm is fast enough.\n\nIf you want to make it faster, hey, it's open source. Go implement an algorithm you like better and submit the detailed results of your carefully designed, accurate and precise empirical performance tests that clearly demonstrate that making an unnecessary change to a widely used foundational piece of functionality is justified by your superior performance algorithm in an unimportant and rare scenario.\n\nIf that sounds like a lot of work for almost no benefit then again, you know the answer to your question.  Expensive work that has small benefits gets sorted to the bottom of the priority list.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Is it possible to test whether a number is prime or not in O(logn)?\r\n                \r\nI have been reading a competitive programming book for one month. The book is written by one of the world finalists of our country (Bangladesh). Point to be noted, the book is written in our native language (Bengali) and that is not so popular worldwide. Because of having the content in Bengali I can't refer it here. That's why I am sorry first of all.\n\nIn Number theory chapter of that book, there are given many algorithms to test Primality. The most optimal he has shown, is \"Sieve of Eratosthenes\" in O(nloglogn). But he wrote one line. I am translating it.\n\"There is a more efficient method of testing primality in O(logn). Think it yourself. And if you are undone, just google it!!\"\n\nI have googled about it.But I didn't find anything satisfactory.\n\nIs it really possible to test the primality of a number in O(logn) ??\n And if it is possible then up to which range it can be concluded ??\n    ", "Answer": "\r\nThe statement is incorrect. For a number N, the number of digits is ```\nO(log N)```\n, so the statement means that there is an algorithm that's linear in the number of digits. The best known result is polynomial in the number of digits. (Agrawal–Kayal–Saxena primality test, Õ(logN 12). That's logN to the power of twelve, not one.\n\nStill, Õ(logN 12) ⊂ O(N)\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Detecting primes -- both \"if\" and \"else\" branches run in a loop, but only one should [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to create the most compact mapping n → isprime(n) up to a limit N?\r\n                            \r\n                                (30 answers)\r\n                            \r\n                    \r\n                    \r\n                        Debugging a Python Prime Number Program\r\n                            \r\n                                (7 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n```\nimport math\nwhile True:\n n=(raw_input(\"Please enter a number to check if it is prime or not \" ))\n if n == \"gate\":\n    exit()\n n=int(n)\n x=int( math.sqrt(n))\n if n%2==0:\n    print n , \"is an even number\"\n else:\n    for i in range(3,x+1,2):\n        if n%i==0 :\n           print \" Composite\",n, \"div by\" ,i ,\".\"\n        else:\n           print \"PRIME\"\n```\n\n\nThis code runs fine if I enter an even but acts abnormal when I input an odd or prime integer. It identifies composite accurately. Irrespective of prime or composite odd it prints  PRIME many times.(sometimes twice or thrice).\nThe output is like:\n\n```\nPlease enter a number to check if it is prime or not  53\nPRIME\nPRIME\nPRIME\nPlease enter a number to check if it is prime or not  36\n36 is an even number\nPlease enter a number to check if it is prime or not  21\nComposite 21 div by 3 .\nPlease enter a number to check if it is prime or not  23\nPRIME\nPlease enter a number to check if it is prime or not  37\nPRIME\nPRIME\nPlease enter a number to check if it is prime or not  \n```\n\n\nI think I have done some indentation error or implemented while loop incorrectly.\nplease help.\n\nThis question is not just about an algorithm for primality test but this addresses an implementation problem.\n    ", "Answer": "\r\nYou need to exit the loop when a factor is found, and print that the number is prime only after all factors have been tested. So your loop should look more like this:\n\n```\nfor i in range(3, x + 1, 2):\n    if not n % i:\n       print \" Composite\", n, \"div by\" , i ,\".\"\n       break      # exit loop explicitly\nelse:             # execute only if we didn't break out of loop\n   print \"PRIME\"\n```\n\n\nNote that the ```\nelse```\n lines up with the ```\nfor```\n, not with the ```\nif```\n.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Cython No Performance Increase with prange/parallel\r\n                \r\nI'm using Cython version 0.27.3 to compile the following source for a simple primality testing module that contains both python and cython implementations of the same algorithm. When I set the ```\nthreads```\n parameter to different values, I see no performance increase, despite the GIL being released. Is there something that's preventing this from running in parallel?\n\nThe function in question is the ```\ncdef void _getprimes```\n which accepts a memoryview slice as a parameter and should set all non-prime values to 0 in that slice.\n\nprimes.pyx\n\n```\n#cython: boundscheck=False, wraparound=False, nonecheck=False\ncimport cython\nfrom cpython cimport array\nfrom cython.parallel cimport parallel, prange\nfrom libc.math cimport sqrt, ceil\nfrom libc.stdlib cimport malloc, free\nfrom libc.stdio cimport printf\nimport math\n\n# =====================\n# Python implementation\n# =====================\n\ndef pyisprime(n):\n    \"\"\"Python implementation\"\"\"\n    if n < 2 or n & 1 == 0:\n        if n == 2:\n            return True\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef pygetprimes(nums):\n    return [num for num in nums if pyisprime(num)]\n\n\n# =====================\n# Cython implementation\n# =====================\ncdef int _isprime(unsigned long long n) nogil:\n    \"\"\"Cython implementation of a simple primality check\"\"\"\n    cdef unsigned long long upper \n    cdef unsigned long long i = 3\n    cdef int prime = 1\n    if n < 2 or n & 1 == 0:\n        if n == 2:\n            return 1\n        return 0\n    upper = <unsigned long long>ceil(sqrt(<double>n))\n    while i <= upper:\n        if n % i == 0:\n            prime = 0\n            break\n        i += 1\n    return prime\n\ndef isprime(unsigned long long n):\n    \"\"\"Wrapper for _isprime\"\"\"\n    cdef int result\n    with nogil:\n        result = _isprime(n)\n    return result\n\ncdef void _getprimes(unsigned long long[:] nums, int threads) nogil:\n    cdef unsigned long num\n    cdef int i = 0\n    with parallel(num_threads=threads):\n        for i in prange(nums.shape[0], schedule=\"dynamic\"):\n            if _isprime(nums[i]) == 0:\n                nums[i] = 0\n\ndef getprimes(nums, int threads = 1):\n    \"\"\"Wrapper for _getprimes\"\"\"\n    cdef unsigned long long num\n    cdef unsigned long long[:] primes = array.array(\"Q\", nums)\n\n    with nogil:\n        _getprimes(primes, threads)\n\n    return [num for num in primes if num != 0]\n```\n\n\nsetup.py\n\n```\n#!/usr/bin/env python3\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\n\nsetup(\n    name=\"primes\",\n    ext_modules=cythonize('primes.pyx'),\n)\n```\n\n\ntest.py\n\n```\n#!/usr/bin/env python3\nimport functools\nimport random\nimport time\nimport primes\n\ndef timed(func):\n    def wrapped(*args, **kwargs):\n        start = time.time()\n        val = func(*args, **kwargs)\n        end = time.time()\n        print(func.__name__, end - start)\n        return val\n    return functools.wraps(func)(wrapped)\n\n\ndef main():\n    nums = [random.randint(0, 0xffffff) for _ in range(500000)]\n\n    pyfoo = timed(primes.pygetprimes)\n    cyfoo = timed(primes.getprimes)\n\n    x = pyfoo(nums)\n    y = cyfoo(nums, 1)\n    z = cyfoo(nums, 4)\n    assert x == y == z\n\nif __name__ == \"__main__\":\n    main()\n```\n\n\nWhen I run ```\ncyfoo```\n, I expected that increasing the number of threads from 1 to 4 would show some type of speed increase, but this is not the case:\n\n```\n[aarcher@Arch]: ~/Programming/Cython/build/lib.linux-x86_64-3.6>$ ./test.py \npygetprimes 5.11554741859436\ngetprimes 1.1129701137542725\ngetprimes 1.1306445598602295\n```\n\n    ", "Answer": "\r\nIt seems you  need to enable compiler flags for OpenMP for the parallel statements to actually do anything.\n\nSee cython docs here\nhttp://cython.readthedocs.io/en/latest/src/userguide/parallelism.html#compiling\n\n```\n# setup.py\n# ... omitted ...\n\next_modules = [\n    Extension(\n        \"hello\",\n        [\"hello.pyx\"],\n        extra_compile_args=['-fopenmp'],\n        extra_link_args=['-fopenmp'],\n    )\n]\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Behavioral to Structural Conversion Problems VHDL\r\n                \r\nI designed a primality testing for Rabin Miller algorithm in behavioral type. I used functions to create my modules. Unfortunately, when I tried to synthesize it by my Altera Kit via Quartus, I realized that function are not synthesize. Here I will write my whole program, and I really need you help to give me at least some hints to change it to structural as it is my senior design project. Here is my program:\n\n```\n library ieee;\n use ieee.std_logic_1164.all;\n use ieee.numeric_std.all;\n\n entity PrimeTest is\n port( N: in integer;\n Test1 : out std_logic);\n end PrimeTest;  \n\n  Architecture Behavior1 of PrimeTest is\n\n\n  function integer_binary (b1:std_logic_vector(31 downto 0)) return integer is\n  variable a: integer:=0;\n  variable i: integer;\n   begin\n    i:=0;\n\n     while (i<32) loop\nif b1(i) = '1' then\na:=a+2**i; \nend if;\ni:=i+1;   \nend loop;\n     return a;\n    end integer_binary;\n\n       function integer_binary1 (b1:std_logic) return integer is\n        variable a: integer;\n\n       begin\nif b1 = '1' then\na:= 1; \nelse\n  a:=0;\nend if;\n     return a;\n     end integer_binary1;\n\n     function binary1 (int1:integer) return std_logic_vector is\n     variable int2: integer;\n     variable a:std_logic_vector(31 downto 0);\n  variable i: integer;\n\n   begin\n   int2:=int1;\n  i:=0;\n while (i<32) loop    \n  if (int2 mod 2 = 0) then\n    a(i):='0';\n  else\n    a(i):='1';\n  end if;\n  i:=i+1;\n    int2:=int2/2;\n  end loop;\n  return a;\n  end binary1;\n\n function mul_mod (x1,y1,m1: std_logic_vector (31 downto 0)) return std_logic_vector is\nvariable p1: std_logic_vector (31 downto 0);\nvariable k: integer;\nvariable n: integer;\nvariable i: integer;\n variable j: std_logic_vector (31 downto 0);\n begin\nn:=32;\ni:=31;\np1:=\"00000000000000000000000000000000\";\nwhile(i>=0) loop\n\n  p1:=binary1((integer_binary(p1))*2);\n\nj:=binary1((integer_binary(y1))*((integer_binary1 (x1(i)))));\n\np1:=binary1((integer_binary(p1))+((integer_binary (j))));\n\nif (p1 >= m1) then\n  p1:=binary1(((integer_binary(p1))-(integer_binary (m1))));\nend if;\n\n    if (p1 >= m1) then\n  p1:=binary1(((integer_binary(p1))-(integer_binary (m1))));\nend if;\ni:=i-1; \n\nend loop;\nreturn p1;\nend mul_mod;\n\n\n\n FUNCTION modexp3 (exp_m,exp_n: integer; \n                      exp_e: std_logic_vector(31 downto 0)) return integer is \n                 variable s:integer; \n                  variable result: integer:=1;\n                        begin\n    S := exp_m;\n\n   L1: for I in 0 to 31 loop\n\n    I2:    if (exp_e(I) = '1') then\n        result := integer_binary(mul_mod(binary1(result),binary1(s),binary1(exp_n)));\n       S := integer_binary(mul_mod(binary1(s),binary1(s),binary1(exp_n)));\n   else\n       S := integer_binary(mul_mod(binary1(s),binary1(s),binary1(exp_n)));\n   end if I2;\n\n    end loop L1 ;\n    return result; \n  end modexp3;\n\n\n FUNCTION park1 (in_seed1,max1: integer) return integer is \n                 variable hi:integer;\n                 variable lo:integer; \n                  variable out_seed:integer;\n                  variable test:integer;\n                  variable random1: integer;\n                   variable rejected: integer;\n                   variable a:integer:=16807;\n                  variable m:integer:=2147483647;\n                  variable q: integer:=127773;\n                  variable r: integer:=2836;\n                  variable seed:integer;\n\n                        begin\n                          seed:=in_seed1;\n\n              for en in 0 to 1 loop\n                if (en = 0) then\n                  hi:=in_seed1 / q;\n                 else\n                  hi:=out_seed / q;\n               end if;\n\nlo:=in_seed1 mod q;\ntest:=((a*lo) - (r*hi));\n\nif test > 0 then\nOut_seed:= test;\n\nelse\nOut_seed:= test + m;\n\n    end if;\n  end loop;\n random1:=out_seed mod max1;\n if random1 = 0 then\n   seed:=(seed-1)**2;\n   random1:= park1(seed,max1);\n end if;\n    return random1; \n  end park1;\n\n-- Primality Test Function\nFunction IS_Prime(number: integer) return STD_Logic is\nVariable d: integer;\nVariable d_binary: std_logic_vector(31 downto 0);\nVariable s_1: integer :=0;\nVariable iteration: integer :=1;\nVariable x: integer;\nVariable a: integer;\nvariable two:std_logic_vector(31 downto 0):=\"00000000000000000000000000000010\";\nVariable fake: integer;\n\n\nBegin\nd:= number -1; \nif ( number < 2) then\nReturn '0';\nend if;  \nif ( number = 2) then\nReturn '1';\nend if;\nif ( number /= 2 and number mod 2 = 0) then\n return '0';\nend if;\nwhile ( d mod 2 = 0 ) loop \nd:=d/2;\ns_1:=s_1+1;\nend loop;\nd_binary:=binary1(d);\nii_loop: for ii in 0 to iteration-1 loop\na:=park1((ii+(s_1*100000))+number,(number-2));\nx:=modexp3 (a,number,d_binary);\nz4: if ((x /= 1) and (x /= number -1)) then \n R_LOOP:         for r in 0 to s_1-1 loop\n        fake:=0;\n        x:=modexp3(x,number,two);\n            z0: if (x = number -1) then\n                fake:=1;\n                 exit R_LOOP when fake = 1;\n            end if z0;\n            z1: if (x = 1) then \n                    return '0';\n                end if z1;\n    end loop R_LOOP;\n\n        z2: if (fake/=1) then\n            return '0'; \n        end if z2;\n\nend if z4;\nend loop ii_loop;\nreturn '1';\nEnd IS_Prime;\nBegin\n\nTest1 <= IS_Prime(N);\n\n\nend Behavior1;\n```\n\n\nI am new to VHDL and this is really confusing me where I have no progress in my project. Please, I need that program to be in structural type (port mapping).\n    ", "Answer": "\r\nYou asked for some hints, so I'll just write some things that come to mind from looking at your code, hoping it will be helpful.\n\n\nThere is no problem in using functions; they are a good way to organize your design. They are synthesizable, as long as the statements you use in the function body are synthesizable as well.\nDon't reinvent the wheel. Most of the functions you wrote are already predefined in the standard libraries. Do some research before implementing, and try to think whether it is a common subprogram, one that would be useful to most designers. If this is the case, there is probably a ready solution, especially if it involves type conversions or math.\nAs Brian Drummond said, try to avoid ```\nwhile```\n loops because they are harder for the compiler to guess the total number of iterations. ```\nfor```\n loops with constant limits are easier on the synthesizer. And forget about nested loops with variable ranges.\nJerry Coffin is also right when he says that there may be some confusion between how you implement an algorithm in hardware vs. in software. Most of the times, drawing a hardware diagram before writing any code helps sort things out. Many times, it at least reveals that the designer does not have a very good idea of what it takes to implement the algorithm in hardware.\nYou want to make the transition from software to hardware. A big part of it is to decide what you need to do instantly (within a single clock cycle), and what you want to do sequentially (spread over several clock cycles). So, suppose you have some behavioral (non-synthesizable) code that calculates something using a loop, and you want to make this calculation in hardware.\n\nIf you need to calculate it in a syngle clock cycle, the compiler will have replicate the hardware for all loop iterations, which might be huge.\nIf you can spread the calculation over several clock cycles, your best bet is to design a finite state machine (FSM) for this calculation. Again, draw a diagram before writing the code, this will help a lot in your case.\n\n\n\nHope this helps point you in the right direction.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "how to generate and store an RSA key (mod,public_exponent,private_exponent) in VBA?\r\n                \r\nI want to implement a macro for RSA encryption of my own in VBA MS Word. So far so good, I implemented Miller-Rabin primality test to check if a number is primal or not, the problem is that according to a website: \"http://www.di-mgt.com.au/rsa_alg.html#keylength\" I must atleast provide a key length of 1024 bits in size, that's like 2^1024 in decimal which cleary no Type in VBA can hold. Even for the two random prime numbers that must be of length(Key)/2, 2^512 is still a long shot, How do I go about this ?\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "is there a major inefficiency in this miller-rabin pseudocode in CLRS?\r\n                \r\nThis question may actually have nothing to do with the Miller-Rabin primality testing procedure; it may only easy analysis of some simple pseudocode.\n\nOn p 969 of CLRS (Introduction to Algorithms 3ed), an auxiliary function to Miller-Rabin is presented:\n\n```\nWITNESS(a, n)\n    let t and u be such that t >= 1, u is odd, and n-1 = 2^t u\n    x_0 = MODULAR-EXPONENTIATION(a, u, n)\n    for i = 1 to t\n        x_i = x_{i-1}^2 mod n\n        if x_i == 1 and x_{i-1} != 1 and x_{i-1} != n-1\n            return TRUE\n    if x_t != 1\n        return TRUE\n    return FALSE\n```\n\n\nI copied the above exactly from the textbook.\n\nNow, knowing only that ```\nMODULAR-EXPONENTIATION```\n returns a result between 0 and n-1, inclusive, I think the pseudocode above is entirely equivalent to \n\n```\nWITNESS(a, n)\n    let t and u be such that t >= 1, u is odd, and n-1 = 2^t u\n    x_0 = MODULAR-EXPONENTIATION(a, u, n)\n    if x_0 == 1 or x_0 == n-1\n        return FALSE\n    else\n        return TRUE\n```\n\n\nIf so, there's probably something else wrong with the original implementation, since if I'm not mistaken Miller-Rabin witnessing does require some sort of looping. Can someone provide a simple counterexample to show that I am wrong?\n    ", "Answer": "\r\nThe Miller-Rabin primality test is designed to be TRUE for n being a prime, so returning FALSE should only apply to composite numbers. Let's test this with a little Python program.\n\n```\ndef wrongwitness(a, n):             #implementation of your shortcut\n    u = n - 1\n    t = 0\n    while u % 2 == 0:               #n - 1 = 2^t * u\n        u //= 2\n        t += 1\n\n    x_0 = pow(a, u, n)              #x0 = a ^ u (mod n), oops, where is t?\n\n    if x_0 == 1 or x_0 == n - 1:\n        return False\n    else:\n        return True\n\nprimes = [5, 7, 11, 13, 17, 19, 23, 29, 31]\n\nfor p in primes:         \n    for a in range(2, p):           #1 < a < p\n        if not wrongwitness(a, p):  #witness returned FALSE, though we have a prime number\n            print(\"Found counter example: a = \", a, \"and p = \", p )\n```\n\n\nThis gives us lots of counterexamples for your shortcut implementation as small as ```\na = 2```\n and ```\np = 5```\n or ```\na = 3```\n and ```\np = 7```\n. Actually all ```\n(p - 1, p)```\n tuples are counter examples. So no shortcut, you have to test all square roots of ```\na^(n-1)```\n as explained in your text book. \n\nP.S.: But there are ways to reduce the number of calculations, you have to perform. Subsets of witnesses have been identified for n up to 3,317,044,064,679,887,385,961,981. So for n < 1,373,653 it is for instance sufficient just to test a=2 and a=3. \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Huge discrepancy between Python time.clock() and Sublime Text 2 timing\r\n                \r\nI'm trying to compare the run times of two different algorithms for determining whether a number is prime, using Python's time module, for example:\n\n```\ntest = primesComparisonTXT()\nstart = time.clock()\nprint 'Fermat Method'\nfor prime in test:\n    print isFermatProbablePrime(prime, 5)\ntotal = time.clock() - start\nprint total\n```\n\n\nprimesComparisonTXT() is a function that returns a list of the confirmed primes in (1, 1000000). \n\nisFermatProbablePrime() is a function that takes in 1. a suspected prime 2. a parameter that indicates how many times that suspected prime should be tested for primality using Fermat's primality test. The function returns True or False depending whether the suspect is a probable prime. (http://en.wikipedia.org/wiki/Fermat_primality_test)\n\nThe algorithm correctly outputs that every prime in that list is indeed a probable prime, but I'm getting largely different results for the timing. 4.57107920129 is what's printed as \"total,\" but Sublime Text states that the build was \"[Finished in 15.1s]\". Sublime's timing is more accurate. Is there any particular reason for this discrepancy; perhaps a better timing method should be used (timeit)?\n    ", "Answer": "\r\nThis is exactly what you should expect. As the docs say:\n\n\n  On Unix, return the current processor time as a floating point number expressed in seconds. The precision, and in fact the very definition of the meaning of “processor time”, depends on that of the C function of the same name…\n\n\nPOSIX says that the C function:\n\n\n  … shall return the implementation's best approximation to the processor time used by the process since the beginning of an implementation-defined era related only to the process invocation.\n\n\nIn other words, this is processor time, not wall-clock time. If your processor is doing anything else (like, say, running other programs), or waiting around doing nothing while your program blocks on I/O, it isn't counted.\n\nActually, it's even worse than that—such time may be counted on some Unix and Unix-like systems, and will be counted on Windows… so if you don't understand your platform, it's not necessarily easy to understand what ```\nclock```\n actually means.\n\nAt any rate, the time reported by ```\nclock```\n should be <= the wall-clock time, not ==.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "CMAKE_BUILD_TYPE Release: strange results\r\n                \r\nWe are creating an Android app to compare execution time between ART and native code. We are using Android Studio and CMake for compiling C/C++.\n\nWhen in CMakeList.txt we set the flag\n\n```\nset(CMAKE_BUILD_TYPE Release)\n```\n\n\nin some algorithms (Primality Test and Fibonacci) the execution time drastically drop to 0ms for all different input.\n\nHere the native lib\n\n```\nbool flag = false;\n\nextern \"C\" JNIEXPORT void JNICALL Java_javacpp_cmr_com_sdkvsndk_MainActivity_cancel(JNIEnv *env, jobject obj) {\n        flag = true;\n    }\n\n\nextern \"C\" JNIEXPORT jlong JNICALL Java_javacpp_cmr_com_sdkvsndk_MainActivity_primalityTest(JNIEnv *env, jobject obj, jlong r) {\n    if(r < 0) return -1L;\n    timeval start, stop;\n    long long t;\n    gettimeofday(&start, NULL);\n\n    bool prime = true;\n\n    unsigned long long sr = (unsigned long long) sqrt(r);\n    for (unsigned long long i = 2; (i <   sr) && prime; i++) {\n        if (flag) return -1;\n        if (r % i == 0) prime = false;\n    }\n\n    gettimeofday(&stop, NULL);\n    t = (stop.tv_sec - start.tv_sec) * 1000;\n    t += (long long) ((stop.tv_usec - start.tv_usec) / 1000) \n    return (jlong) t;\n    }\n```\n\n\nflag is a flag that is set true when we terminate the asyncTask that execute the algorithm. \n\nI can not figure how this is possible. Any suggestion? Thank you.\n    ", "Answer": "\r\nThis is because by default your CMake project is build with ```\nDebug```\n type. In this type the debugging information is generated as well as optimisations are disabled (```\n-O0 -g```\n flags to gcc). \n\nThis is to enable you to step trough your C++ code line by line as it was written by you. If you change the type to ```\nRelease```\n the optimisations are turned on and the debug info is not included with the binary.\n\nThe optimisations make the code run so fast, no matter how well you think you wrote something, the compiler is still ahead of you and will make it better. Those optimisations however will show erratic behaviour when the code is debugged, lines executed out of order, or not at all, variables not showing in watches or shown wrong, this is not nice for debugging.\n\nThe missing debug info means the binary is lighter but if you need to debug it better practice some assembly since any information on what line of C++ resulted in these assembly instructions is lost. As a side note there is also ```\nRelWithDebugInfo```\n build type in case you really need to debug the optimised code.\n\nNormally the Android Studio should take care of the appropriate build type for you so there is no need to fiddle with that.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "What is complexity measured against? (bits, number of elements, ...)\r\n                \r\nI've read that the naive approach to testing primality has exponential complexity because you judge the algorithm by the size of its input.  Mysteriously, people insist that when discussing primality of an integer, the appropriate measure of the size of the input is the number of bits (not n, the integer itself).\n\nHowever, when discussing an algorithm like Floyd's, the complexity is often stated in terms of the number of nodes without regard to the number of bits required to store those nodes.  \n\nI'm not trying to make an argument here.  I honestly don't understand the reasoning.  Please explain.  Thanks.\n    ", "Answer": "\r\nTraditionally speaking, the complexity is measured against the size of input.\n\nIn case of numbers, the size of input is log of this number (because it is a binary representation of it), in case of graphs, all edges and vertices must be represented somehow in the input, so the size of the input is linear in ```\n|V|```\n and ```\n|E|```\n.\n\nFor example, naive primality test that runs in linear time of the number itself, is called pseudo-polynomial. It is polynomial in the number, but it is NOT polynomial in the size of the input, which is ```\nlog(n)```\n, and it is in fact exponential in the size of the input.\n\n\n\nAs a side note, it does not matter if you use the size of the input in bits, bytes, or any other CONSTANT factor for this matter, because it will be discarded anyway later on when computing the asymptotical notation as constants.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Finding the exponent of n = 2**x using bitwise operations [logarithm in base 2 of n]\r\n                \r\nIs there a straightforward way to extracting the exponent from a power of 2 using bitwise operations only?\n\nEDIT: Although the question was originally about bitwise operations, the thread is a good read also if you are wondering \"What's the fastest way to find X given Y = 2X in Python?\"**\n\nI am currently trying to optimize a routine (Rabin-Miller primality test) that reduces an even number N in the forms ```\n2**s * d```\n. I can get the ```\n2**s```\n part by:\n\n```\ntwo_power_s = N & -N\n```\n\n\nbut I can't find a way to extract just \"s\" with a bitwise operation. Workarounds I am currently testing without too much satisfaction (they are all pretty much slow) are:\n\n\nusing the logarithm function\nmanipulating the binary representation of 2**s (i.e. counting the trailing zeroes)\nlooping on a division by 2 until the result is 1\n\n\nI am using python, but the answer to this question should be language agnostic, I suppose.\n    ", "Answer": "\r\n\"language agnostic\" and worrying about performance are pretty much incompatible concepts. \n\nMost modern processors have a CLZ instruction, \"count leading zeros\". In GCC you can get to it with __builtin_clz(x) (which also produces reasonable, if not the fastest, code for targets that lack clz). Note that this CLZ is undefined for zero, so you'll need an extra branch to catch that case if it matters in your application.\n\nIn CELT ( http://celt-codec.org ) the branchless CLZ we use for compliers lacking a CLZ was written by Timothy B. Terriberry:\n\n```\n\nint ilog(uint32 _v){\n  int ret;\n  int m;\n  ret=!!_v;\n  m=!!(_v&0xFFFF0000)<<4;\n  _v>>=m;\n  ret|=m;\n  m=!!(_v&0xFF00)<<3;\n  _v>>=m;\n  ret|=m;\n  m=!!(_v&0xF0)<<2;\n  _v>>=m;\n  ret|=m;\n  m=!!(_v&0xC)<<1;\n  _v>>=m;\n  ret|=m;\n  ret+=!!(_v&0x2);\n  return ret;\n}\n```\n\n\n(The comments indicate that this was found to be faster than a branching version and a lookup table based version)\n\nBut if performance is that critical you probably shouldn't be implementing this part of your code in python.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Find the greatest prime less than n, with n = ~10^230\r\n                \r\nIs there something wrong with my solution to find the largest prime less than ```\nn```\n when ```\nn```\n can be up to ~10^230? Are there any suggestions for a better approach?\n\nHere is my attempt, using the following version of a Miller-Rabin primality test in Python:\n\n```\nfrom random import randrange\n\nsmall_primes = [\n    2,  3,  5,  7, 11, 13, 17, 19, 23, 29,\n    31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\n    73, 79, 83, 89, 97,101,103,107,109,113,\n    127,131,137,139,149,151,157,163,167,173,\n    179,181,191,193,197,199,211,223,227,229,\n    233,239,241,251,257,263,269,271,277,281,\n    283,293,307,311,313,317,331,337,347,349,\n    353,359,367,373,379,383,389,397,401,409,\n    419,421,431,433,439,443,449,457,461,463,\n    467,479,487,491,499,503,509,521,523,541,\n    547,557,563,569,571,577,587,593,599,601,\n    607,613,617,619,631,641,643,647,653,659,\n    661,673,677,683,691,701,709,719,727,733,\n    739,743,751,757,761,769,773,787,797,809,\n    811,821,823,827,829,839,853,857,859,863,\n    877,881,883,887,907,911,919,929,937,941,\n    947,953,967,971,977,983,991,997\n]\n\ndef probably_prime(n, k):\n    \"\"\"Return True if n passes k rounds of the Miller-Rabin primality\n    test (and is probably prime). Return False if n is proved to be\n    composite.\n\n    \"\"\"\n    if n < 2: return False\n    for p in small_primes:\n        if n < p * p: return True\n        if n % p == 0: return False\n    r, s = 0, n - 1\n    while s % 2 == 0:\n        r += 1\n        s //= 2\n    for _ in range(k):\n        a = randrange(2, n - 1)\n        x = pow(a, s, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n            else:\n                return False\n    return True\n```\n\n\nI start by testing ```\nprobably_prime(n)```\n where I decrement and test each value of ```\nn```\n until I get a \"probably prime\" number. When I test this on values of ```\nn```\n = ~10^230, I am finding primes about 20-30 numbers apart. After reading more about prime gap, my results seem highly unlikely, as I should not be finding primes so frequently. I have tested ```\nk```\n values of up to 50,000, and I am getting the same answer. What am I doing wrong, and are there any suggestions for a better solution?\n    ", "Answer": "\r\nYou're right, your code seems to be having difficulty as soon as it gets beyond the ```\nsmall_primes```\n table. Looking more closely, there's an error here:\n\n```\n    for _ in range(r - 1):\n        x = pow(x, 2, n)\n        if x == n - 1:\n            break\n        else:\n            return False\n```\n\n\nYou want to return ```\nFalse```\n (i.e. composite) if you never find ```\nx == n-1```\n (or you can short-circuit and return ```\nFalse```\n if ```\nx == 1```\n, I think: see here).  This can be done simply by changing the indentation:\n\n```\n    for _ in range(r - 1):\n        x = pow(x, 2, n)\n        if x == n - 1:\n            break\n    else:\n        return False\n```\n\n\n(The ```\nfor/else```\n combination is really ```\nfor/if-not-break```\n.)\n\nAfter making this change, I get:\n\n```\n>>> sum(orig(p, 20) for p in range(10**6, 2*10**6))\n54745\n>>> sum(fixed(p, 20) for p in range(10**6, 2*10**6))\n70435\n>>> sum(orig(p, 20) for p in range(10**230, 10**230+10**3))\n40\n>>> sum(fixed(p, 20) for p in range(10**230, 10**230+10**3))\n2\n```\n\n\nwhich is correct.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Is there a way to generate large primes in C#, without the use of an external library?\r\n                \r\nI need to generate large prime numbers for a cryptography project. I noticed that .NET 4.0 has some built-in cryptographic primitive (for example RSA) which use random generated large primes (p,q for RSA). Do they all use a common built-in library which is public and can be accessed from outside their class scopes, or do I have to use an external library (I know there are simple algorithms for primality tests, I just don't want to implement more than i have to.).\n    ", "Answer": "\r\nGenerate a large number in the range you require.  Test it to see if it is prime.  Reject and repeat if it isn't.\n\nFor the testing, just use trial division with primes up to, say, 1500 and then switch to Miller-Rabin.  With a properly implemented Miller-Rabin the chances of a hardware failure are greater than mistakenly flagging a composite as prime.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Can somebody explain this to me about time complexity regarding the primality problem\r\n                \r\nWe are covering the class P in my class and this one part is tripping me up regarding if the primality problem is in P\nOur program:\n```\n\"{prime(x): i =2; while i < x { if n mod i == 0 { return 0 } i++ } return 1 }\"\n```\n\nComplexity for the program:\nIf x is n digits long, then x is in the rough vicinity of 10^n\n. (Assuming no leading 0s, 10^n−1 ≤ x < 10^n.) The division algorithm that you learned\nin elementary school divides an m-digit number by an n-digit number in\ntime O(mn). Puting that all together, we find that our algorithm for testing\nwhether an integer is prime takes time O(n^2 10^n).\nMy questions:\nWhere in the world does the professor get that x is 10^n, for example if x is 17 how does that turn into x being 10^2 = 100 operations long.\nFurthermore where is the n^2 coming from in the final big O notation.\n    ", "Answer": "\r\nThis trial division algorithm has to try x−2 divisors (i.e.,\nΘ(10n) of them) when x is prime. The vast majority of these\ndivisors have n or n−1 digits, so each division takes Θ(n2)\ntime on average since m = Θ(n).\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "cannot do substraction in mpir\r\n                \r\nI am new to programming and I have a coding homework. We have to implement RSA using MPIR. I generated p and q the best way I could think of. I could not make them 512 bits, but I will continue as it is. I also did not test for primality yet. I will deal with the byte size and primality test if I have time.\nMy problem is regarding finding Phi(n) = (p-1)*(q-1). I manage to find p, q and N, but Phi(n) and N give the same result. I checked the functions in the MPIR document multiple times and I tried two similar functions for substraction as you will see, but still no luck. (I did not write the code for q here as it is a repetition of p.)\nCan someone guide me? I would like to say thank you in advance.\n```\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <mpir.h>\n#include <cstdlib> \n#include <iostream>\n\nusing std::cout;\nusing std::cin;\n\n\n   int main()\n   {\n\n    mpz_t p;\n    mpz_init(p); \n\n    mpz_t randint;\n    mpz_init(randint);\n\n    gmp_randstate_t state;\n    gmp_randinit_mt(state);\n\n    mpir_ui seed;\n\n\n    cout << \"Please choose a number for the seed of the random number \n    generator:\";\n    cin >> seed;\n\n    gmp_randseed_ui(state, seed);\n    mpz_urandomb(randint, state, 512); \n\n    mpz_t limit;\n    mpz_init(limit);\n    mpz_t winner;\n    mpz_init(winner);\n\n\n    mpz_ui_pow_ui(limit, 2, 511);\n\n    mpz_ior(winner, limit, randint);\n\n    mpz_next_prime_candidate(p, winner, state);\n\n    gmp_randclear(state);\n    mpz_clear(randint);\n    mpz_clear(winner);\n\n    mpz_t q;\n    mpz_init(q);\n\n    mpz_init(randint);\n    gmp_randinit_mt(state);\n\n    cout << \"Please choose a number for the seed for the random number \n    generator :\";\n    cin >> seed;\n\n\n    gmp_randseed_ui(state, seed);\n    mpz_urandomb(randint, state, 512);\n\n\n    mpz_init(limit);\n\n    mpz_init(winner);\n\n    mpz_ui_pow_ui(limit, 2, 511);\n\n    mpz_ior(winner, limit, randint);\n\n    mpz_next_prime_candidate(q, winner, state);\n\n    gmp_randclear(state);\n    mpz_clear(randint); \n    mpz_clear(limit);\n    mpz_clear(winner);\n\n\n   // Now we find n=p*q\n \n    mpz_t N; \n    mpz_init(N);\n\n    mpz_mul(N, p, q);\n\n\n    mpz_t phin;\n    mpz_init(phin);\n\n\n    mpz_t pa;\n    mpz_init(pa);\n    mpz_t qa;\n    mpz_init(qa);\n```\n\n1st way\n```\n    mpz_t one;\n    mpz_init(one);\n    mpz_set_ui(one, 1);\n\n\n    mpz_sub(pa, p, one); \n    mpz_sub(qa, q, one);\n\n    mpz_mul(phin, pa, qa);\n```\n\nSecond way\n```\n    mpz_sub_ui(pa, p, 1); \n    mpz_sub_ui(qa, q, 1);\n\n    mpz_mul(phin, pa, qa);\n```\n\nThen I write them to a document and clear everything.\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "TypeError: unsupported operand type(s) for &: 'sage.rings.rational.Rational' and 'int'\r\n                \r\nSo for my cryptography course we were given an assignment and on problem 1 we had to write in the rest of the function for Solovay-Strassen Primality Test and heres what I wrote out:\n\n```\ndef SolovayStrassen(n,k):\n    for i in [1..k]:\n        a = randint(2,n-1) #picks a random number between 2 and n-1\n        j = jacobi_symbol(a,n) #computes jacobi function\n        p = power_mod(a,(n-1)/2,n) #uses the power mod function \n        #now we test if both are equal to find if both are equal in order to check if the number is \"composite\" or \"probably prime\"\n        if (j != p):\n            return False #\"composite\"\n    return True #\"probably prime\"\n```\n\n\nNow mind you this is being complied in sage online but when I run the code it pops up with this error message\n\n```\nError in lines 2-2\nTraceback (most recent call last):\n  File \"/cocalc/lib/python2.7/site-packages/smc_sagews/sage_server.py\", line 1013, in execute\n    exec compile(block+'\\n', '', 'single') in namespace, locals\n  File \"\", line 1, in <module>\n  File \"\", line 5, in SolovayStrassen\n  File \"/ext/sage/sage-8.1/local/lib/python2.7/site-packages/sage/arith/misc.py\", line 1939, in power_mod\n    while n&1 == 0:\nTypeError: unsupported operand type(s) for &: 'sage.rings.rational.Rational' and 'int'\n```\n\n\nIt looks like its referring to this line of where the error seems to occur\n\n```\n p = power_mod(a,(n-1)/2,n) #uses the power mod function \n```\n\n\nI assume that the error maybe that its trying to convert a rational number to an integer based on the power_mod function?\n    ", "Answer": "\r\nYou need to use the ```\n//```\n operator for integer division. The ```\n/```\n operator will produce a rational number in Sagemath if the numerator is not divisible by the denominator. I suspect that your algorithm should not be attempted on even values of ```\nn```\n anyway, which is the only way this problem could manifest itself. Even ```\nn```\n are usually treated as a special case because their primality is so easy to determine.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Couldn't match type Integer in Haskell\r\n                \r\nIn the exercise that i'm doing for the Functional Programming course i'm asked to find the lowest x for which ```\nx mod a = b```\n, being given a series of pairs ```\n(a, b)```\n.\n\nIn the case when i'm given three pairs (tuples), i am using the following code:\n\n```\nsolveModularEq :: [(Integer,Integer)] -> Integer\nsolveModularEq [(a),(b),(c)] = lowestModThree(fst(a) snd(a) fst(b) snd(b) fst(c) snd(c) 1)\n\nlowestModThree :: Integer -> Integer -> Integer -> Integer -> Integer -> \nInteger -> Integer -> Integer \nlowestModThree a b c aa bb cc k\n  | k `mod` a == aa && k `mod` b == bb && k `mod` c == cc = k\n  | k > (aa * bb * cc) = aa * bb * cc\n  | otherwise = lowestModThree a b c aa bb cc (k+1)\n```\n\n\nIn the case that there is no such x, return the product of the moduli.\n\nThe errors i am getting are strange because it doesn't seem that i'm mismatching any types.\n\n```\nmodEq.hs:3:32:\n   Couldn't match expected type ‘Integer’\n              with actual type ‘Integer\n                                 -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer’\n   Probable cause: ‘lowestModThree’ is applied to too few arguments\n  In the expression:\n     lowestModThree (fst (a) snd (a) fst (b) snd (b) fst (c) snd (c) 1)\n   In an equation for ‘solveModularEq’:\n      solveModularEq [(a), (b), (c)]\n         = lowestModThree\n             (fst (a) snd (a) fst (b) snd (b) fst (c) snd (c) 1)\n\nmodEq.hs:3:51:\n  Couldn't match type ‘Integer’\n                  with ‘((a0, b0) -> b0)\n                       -> (Integer, Integer)\n                        -> ((a1, b1) -> a1)\n                        -> (Integer, Integer)\n                        -> ((a2, b2) -> b2)\n                        -> (Integer, Integer)\n                        -> ((a3, b3) -> a3)\n                        -> (Integer, Integer)\n                        -> ((a4, b4) -> b4)\n                        -> (Integer, Integer)\n                        -> Integer\n                        -> Integer’\n   Expected type: (((a0, b0) -> b0)\n                   -> (Integer, Integer)\n                   -> ((a1, b1) -> a1)\n                   -> (Integer, Integer)\n                   -> ((a2, b2) -> b2)\n                   -> (Integer, Integer)\n                   -> ((a3, b3) -> a3)\n                   -> (Integer, Integer)\n                   -> ((a4, b4) -> b4)\n                   -> (Integer, Integer)\n                   -> Integer\n                   -> Integer,\n                   Integer)\n     Actual type: (Integer, Integer)\n   In the first argument of ‘fst’, namely ‘(a)’\n   In the first argument of ‘lowestModThree’, namely\n     ‘(fst (a) snd (a) fst (b) snd (b) fst (c) snd (c) 1)’\n```\n\n\nSame happens in this implementation of mine of a recursive primality test implementation.\n\n```\nisPrimeRec :: Int -> Bool\nisPrimeRec n = isPrimeRec'(isqrt(n) n)\n\nisPrimeRec' :: Int -> Int -> Bool\nisPrimeRec' divisor n\n  | mod n divisor == 0 = isPrimeRec' (divisor-1) n\n  | mod n divisor /= 0 = False\n  | divisor < 2 = True\n```\n\n\nThe error for this one is\n\n```\npalPrimes.hs:10:16:\n    Couldn't match expected type ‘Bool’ with actual type ‘Int -> Bool’\n    Probable cause: ‘isPrimeRec'’ is applied to too few arguments\n    In the expression: isPrimeRec' (isqrt (n) n)\n    In an equation for ‘isPrimeRec’:\n        isPrimeRec n = isPrimeRec' (isqrt (n) n)\n\npalPrimes.hs:10:28:\n    Couldn't match expected type ‘Int -> Int’ with actual type ‘Int’\n    The function ‘isqrt’ is applied to two arguments,\n    but its type ‘Int -> Int’ has only one\n    In the first argument of ‘isPrimeRec'’, namely ‘(isqrt (n) n)’\n    In the expression: isPrimeRec' (isqrt (n) n)\n```\n\n    ", "Answer": "\r\nThe syntax to apply function ```\nf```\n to argument ```\nx```\n is ```\nf x```\n, not ```\nf(x)```\n. Applications associate left, so ```\nf x y```\n means ```\n(f x) y```\n -- that is, apply ```\nf```\n to ```\nx```\n, and apply the resulting function to ```\ny```\n. If ```\nx```\n is itself a complicated expression with function applications in it, you can use extra parentheses to disambiguate; so, for example:\n\n\n```\na b c d```\n applies function ```\na```\n to arguments ```\nb```\n, ```\nc```\n, and ```\nd```\n\n```\na (b c) d```\n applies function ```\na```\n to arguments ```\nb c```\n and ```\nd```\n\n```\na b (c d)```\n applies function ```\na```\n to arguments ```\nb```\n and ```\nc d```\n\n```\na (b c d)```\n applies function ```\na```\n to a single argument, ```\nb c d```\n\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Time comeplexity difference in between inner loop and by calling function\r\n                \r\nThis is a question regarding Complexity of algorithm. If I am creating a loop ('for' loop for instance) and want to test the primality of the values returned (after some operations definitely) in this loop and therefore, I run an inner loop. Instead of that, if I create a function to test primality and then call that function during the first loop, still, the time complexity remains same right?\nAnd what is the complexity in both cases? How to calculate that?\n\nThanks  \n    ", "Answer": "\r\nComplexcity of a code is measured in terms of space and time. Lets try to understand the time complexcity. \n\nLets see one way to measure time Complexcity, it is most famous and called Big O notqtion. As per wikipedia \"Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. \" \n\nSuppose there is an operation (which may be performed by few lines of code) whose single execution takes ```\nT```\n units of time. Time complexcity is the function of number of input values and represents the time taken to execute the operation for those input items.\n\n\nIf the time taken is always ```\nT```\n irrespective of the number of inputs then it is said to be a constant function and time complexcity is said to be O(1).  \nIf the time taken increases linearly with respect to the number of input then it is linear function amd time complexcity is ```\nO(N)```\n\n\n\nLets see a simple example \n\n```\npublic int sumOfFirstNNumbersWayOne( int n ){              \n    int sum = 0;\n     for (int i = 1; i <= n; i++){\n           sum += i; // this loops executes as per the number n\n     }\n     return sum;\n}\n\n\n  public int sumOfFirstNNumbersWayTwo( int n ){ \n       int sum = n*(n+1)/2; // the number of times this operation is executed is independent of the input n\n      return sum;\n }\n```\n\n\nTime complexcity of ```\nsumOfFirstNNumbersWayOne```\n is O(n) and for \n```\nsumOfFirstNNumbersWayTwo```\n is O(1).\n\nIt does not matter if the operation os performed within loops or a method is called in measuring time complexcity. ( Overhead of method call, method call's entry in stack, are negligible)\n\n```\n public int sumOfFirstNNumbersWayThree( int n ){ \n     int sum = 0;\n     for (int i = 1; i <= n; i++){\n           sum = sum( sum, i);\n     }\n     return sum;\n }\n\npublic int sum(int a , int b){ \n     return a+b;\n}\n```\n\n\nTime compelxcity of ```\nsumOfFirstNNumbersWayThree```\n is still O(n). \n\nSimilarly suppose the number of times a particular set of operations gets increased exponentially as the number of input is increased then time complexcity is said to be exponential. \n\nOther famous time complexcites are ```\nO(log(n)), O(n^2), O(nlog(n)), O(n!)```\n, [ ```\nn```\n is the reference and it can be number of input with respect to which we want to measure the time complexcity, it can be size of the input array, number of bits of input number, number of digits of input number, length of input string, number of lines in a file, etc]\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "pow and lround (from math.h) not working in solaris\r\n                \r\nI am writing and implementation of the Miller-Rabin primality test. I believe I have implemented it correctly, but I cannot get my C code to compile on solaris. The code compiles fine in OS X and Debian, but I am getting linking errors in solaris. When I try to link my program, I get the following errors:\n\n```\ngcc -Wall prime.o -o prime\nUndefined                       first referenced\n symbol                             in file\npow                                 prime.o\nlround                              prime.o\n```\n\n\nI am include stdio.h, stdlib.h, and math.h. Does anyone know what the problem could be? I know that in solaris you sometimes need to link against addition libraries, could this be the problem?\n    ", "Answer": "\r\nYou need to link with the ```\n-lm```\n. Try:\n\n```\ngcc -Wall prime.o -o prime -lm\n```\n\n\nThere's also a C FAQ about this.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "computing (a^b)%m in java\r\n                \r\nWhile trying to implement the Miller-Rabin primality test I came across a strange behaviour of java. Regard the following code:\n```\nlong x = (long) (Math.pow(a, b));```\n\nFor a and b large enough (doesn't need that much) you will always get x = 9223372036854775807 = ```\nLong.MAX_VALUE```\n instead of an overflow value.\nThis result is completely useless and won't help calculating (a^b)%m, which is what we need.\nNow since (a^b)%m would easily fit into 64 bits when (a^b) doesn't, I wonder if there is a way to calculate this number without using ```\nBigInteger```\n?\n    ", "Answer": "\r\nYou can always implement the pow(...) yourself and mod as often as possible. Generally speaking (in pseudo-code):\n\n```\npowMod(a, b, m) {\n    result = 1\n    for (i = 0; i < b; i++) {\n        result = (result * a) % m\n    }\n    return result\n}\n```\n\n\nIf ```\nresult * a```\n may be too large then you may want to implement ```\n*```\n by repeated addition and modding after each ```\n+```\n. Furthermore you can (and should) always use ```\na' = a % m```\n and ```\nb' = b % m```\n if you don't do that already.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "in Primality Test ,i do not understand why we increase i by 6 (i=i+6) ? and the if statment conditions in the for loop block?\r\n                \r\ni need some help please !!\nthis is the code i founded in data-strucure   book i understand that t all primes are of the form 6k ± 1, with the exception of 2 and 3 where k is some integer. the problem is in the for loop why we add 6 to i (i+6) and this condition in if statment if (n%i == 0 || n%(i+2) == 0):\n```\nfunction isPrime(n){\nif (n <= 1) return false;\nif (n <= 3) return true;\n\n// This is checked so that we can skip\n // middle five numbers in below loop\nif (n%2 == 0 || n%3 == 0) return false;\n\nfor (var i=5; i*i<=n; i=i+6){\n    if (n%i == 0 || n%(i+2) == 0)\n    return false;\n}\n    \n    return true;\n}\n```\n\n    ", "Answer": "\r\nfirstly, it is checking for 0(mod2) and 0(mod3), we know any one of consecutive 2 numbers are divisible by 2 and any one of 3 consecutive number are divisible by 3 and other must be divisible by 2\n\nso, the for loop starts only if number is not divisible by 2 or 3 and it is >=25. And skip count has simple math behind it.\nAll integers can be represented as 6k+m, where m ε {0, 1, 2, 3, 4, 5}, and k is some integer.  In fact the base of this comes from the fact that all integers can be represented in form of 3k,3k+1,3k+2.\n\nThis is obvious. Therefore:\nm=0: 6k is divisible by 6. Not prime\nm=1: 6k+1 has no immediate factors. May be prime.\nm=2: 6k+2 = 2 x (3k+1). Not prime\nm=3: 6k+3 = 3 x (2k+1). Not prime\nm=4: 6k+4 = 2 x (3k+2). Not prime\nm=5: 6k+5 has no immediate factors. May be prime\n\nBut 6k+5=6k-1 (mod 6), so only two prime possible are 6k+1 and 6k-1.\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Lucas probable prime test\r\n                \r\nI have been trying to implement the Baillie-PSW primality test for a few days, and have ran into some problems. Sepcifically when trying to use the Lucas probable prime test. My question is not about Baile, but on how to generate the correct Lucas sequence modulo some number\n\nFor the first two psudoprimes my code gives the correct result, eg for ```\n323```\n and ```\n377```\n. However for the next psudoprime, both the standard implementation and the doubling version fails. \n\nTrying to do modulo operations on ```\nV_1```\n completely breaks the doubling version of the Luckas sequence generator. \n\nAny tips or suggestions on how to correctly implement the Lucas probable prime test in Python?\n\n```\nfrom fractions import gcd\nfrom math import log\n\ndef luckas_sequence_standard(num, D=0):\n    if D == 0: \n        D = smallest_D(num) \n\n    P = 1\n    Q = (1-D)/4\n\n    V0 = 2\n    V1 = P\n\n    U0 = 0\n    U1 = 1\n\n    for _ in range(num):\n        U2 = (P*U1 - Q*U0) % num\n        U1, U0 = U2, U1\n\n        V2 = (P*V1 - Q*V0) % num\n        V1, V0 = V2, V1  \n\n    return U2%num, V2%num\n\n\ndef luckas_sequence_doubling(num, D=0):\n    if D == 0:\n        D = smallest_D(num) \n    P = 1\n    Q = (1 - D)/4\n\n    V0 = P\n    U0 = 1\n\n    temp_num = num + 1\n    double = []\n    while temp_num > 1:\n        if temp_num % 2 == 0:\n            double.append(True)\n            temp_num //= 2\n        else:\n            double.append(False)\n            temp_num  += -1\n\n    k = 1\n    double.reverse()\n    for is_double in double:\n        if is_double:\n\n            U1 = (U0*V0) % num\n            V1 = V0**2 - 2*Q**k \n\n            U0 = U1\n            V0 = V1\n\n            k *= 2\n\n        elif not is_double:\n\n            U1 = ((P*U0 + V0)/2) % num\n            V1 = (D*U0 + P*V0)/2\n\n            U0 = U1\n            V0 = V1\n\n            k += 1\n    return U1%num, V1%num\n\n\ndef jacobi(a, m):\n    if a in [0, 1]:\n        return a\n    elif gcd(a, m) != 1:\n        return 0\n    elif a == 2:\n        if m % 8 in [3, 5]:\n            return -1\n        elif m % 8 in [1, 7]:\n            return 1\n    if a % 2 == 0:\n        return jacobi(2,m)*jacobi(a/2, m)\n    elif a >= m or a < 0:\n        return jacobi(a % m, m)\n    elif a % 4 == 3 and m % 4 == 3:\n        return -jacobi(m, a)\n    return jacobi(m, a)\n\n\ndef smallest_D(num):\n    D = 5\n    k = 1\n    while k > 0 and jacobi(k*D, num) != -1:\n        D += 2\n        k *= -1\n    return k*D\n\n\nif __name__ == '__main__':\n\n    print luckas_sequence_standard(323)\n    print luckas_sequence_doubling(323)\n    print \n    print luckas_sequence_standard(377)\n    print luckas_sequence_doubling(377)\n    print \n    print luckas_sequence_standard(1159)\n    print luckas_sequence_doubling(1159)\n```\n\n    ", "Answer": "\r\nHere is my Lucas pseudoprimality test; you can run it at ideone.com/57Iayq.\n\n```\n# lucas pseudoprimality test\n\ndef gcd(a,b): # euclid's algorithm\n    if b == 0: return a\n    return gcd(b, a%b)\n\ndef jacobi(a, m):\n    # assumes a an integer and\n    # m an odd positive integer\n    a, t = a % m, 1\n    while a <> 0:\n        z = -1 if m % 8 in [3,5] else 1\n        while a % 2 == 0:\n            a, t = a / 2, t * z\n        if a%4 == 3 and m%4 == 3: t = -t\n        a, m = m % a, a\n    return t if m == 1 else 0\n\ndef selfridge(n):\n    d, s = 5, 1\n    while True:\n        ds = d * s\n        if gcd(ds, n) > 1:\n            return ds, 0, 0\n        if jacobi(ds, n) == -1:\n            return ds, 1, (1 - ds) / 4\n        d, s = d + 2, s * -1\n\ndef lucasPQ(p, q, m, n):\n    # nth element of lucas sequence with\n    # parameters p and q (mod m); ignore\n    # modulus operation when m is zero\n    def mod(x):\n        if m == 0: return x\n        return x % m\n    def half(x):\n        if x % 2 == 1: x = x + m\n        return mod(x / 2)\n    un, vn, qn = 1, p, q\n    u = 0 if n % 2 == 0 else 1\n    v = 2 if n % 2 == 0 else p\n    k = 1 if n % 2 == 0 else q\n    n, d = n // 2, p * p - 4 * q\n    while n > 0:\n        u2 = mod(un * vn)\n        v2 = mod(vn * vn - 2 * qn)\n        q2 = mod(qn * qn)\n        n2 = n // 2\n        if n % 2 == 1:\n            uu = half(u * v2 + u2 * v)\n            vv = half(v * v2 + d * u * u2)\n            u, v, k = uu, vv, k * q2\n        un, vn, qn, n = u2, v2, q2, n2\n    return u, v, k\n\ndef isLucasPseudoprime(n):\n    d, p, q = selfridge(n)\n    if p == 0: return n == d\n    u, v, k = lucasPQ(p, q, n, n+1)\n    return u == 0\n\nprint isLucasPseudoprime(1159)\n```\n\n\nNote that 1159 is a known Lucas pseudoprime (A217120).\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Implementing Miller-Rabin in C\r\n                \r\nI'm trying to implement the Miller-Rabin primality test in C99, but I'm coming across some problems getting it to work. I crafted a small test-set to verify whether or not the implementation works, here's how I'm checking for primes \n\n```\nint main() {\n    int foo[11] = {0, 1, 2, 3, 4, 7, 28, 73, 125, 991, 1000};\n    for (int i = 0; i < 11; i++) {\n        printf(\"%s; \", isprime(foo[i], 5000) ? \"Yes\" : \"No\");\n    }\n    return 0;\n}\n```\n\n\nFrom the numbers listed, the expected output would be\n\n\n  No; No; Yes; Yes; No; Yes; No; Yes; No; Yes; No;\n\n\nHowever, as implemented , the output I get is the following:\n\n\n  No; No; Yes; Yes; No; Yes; No; No; No; No; No; \n\n\nHere's how I wrote the algorithm\n\n```\nint randint (int low, int up){\n    return rand() % (++up - low)+low;\n}\n\nint modpow(int a, int b, int m) {\n    int c = 1;\n    while (b) {\n        if (b & 1) {\n            c *= a;\n        }\n        b >>= 1;\n        a *= a;\n    }\n    return c % m;\n}\n\nbool witness(int a, int s, int d, int n) {\n    int x = modpow(a,d,n);\n    if(x == 1) return true;\n    for(int i = 0; i< s-1; i++){\n        if(x == n-1) return true;\n        x = modpow(x,2,n);\n    }\n    return (x == n- 1);\n}\n\nbool isprime(int x, int j) {\n    if (x == 2) {\n        return true;\n    }\n    if (!(x & 1) || x <= 1) {\n        return false;\n    }\n    int a = 0;\n    int s = 0;\n    int d = x - 1;\n\n    while (!d&1){\n        d >>=1;\n        s+=1;\n    }\n    for(int i = 0; i < j; i++){\n        a = randint(2, x-1);\n        if(!witness(a,s,d,x)){\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n\nWhat am I doing wrong? Why is the test failing for \"large\" primes, but working for very small ones? How may I fix this?\n    ", "Answer": "\r\nWith Visual Studio 2015 Community edition I found two problems. First the line:\n\n```\nwhile (!d&1){\n```\n\n\nneeds to be:\n\n```\nwhile (!(d&1)){\n```\n\n\nSecondly, as mentioned in the comments your modpow function is overflowing. Try:\n\n```\nint modpow(int a, int d, int m) {\n    int c = a;\n    for (int i = 1; i < d; i++)\n        c = (c*a) % m;\n    return c % m;\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Primarily Test in O(1)\r\n                \r\nWe know that all prime numbers are of the form 6k+-1. To check if n is a prime number, can't we just divide n by 6, take the floor of that, then check if adding or subtracting 1 equals n? That would check if a number is prime in constant time, right? If this is true, why do other methods bother using sieves for primality tests? Also, using this method, wouldn't finding a range of primes from 2 to n be O(n)? So this method is faster than the sieve of Eratosthenes?\n    ", "Answer": "\r\nYes, all primes are of the form 6k +/- 1, but that doesn't mean that each number that is of the form 6k +/- 1 is prime. Consider 25, which is 6 * 4 + 1. Clearly, 25 is not prime. \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Write a number N as sum of K prime numbers\r\n                \r\nIs there any condition for writing a number N as sum of K prime numbers(prime numbers not necessarily distinct)?\n\nExample: If N=6 and K=2 then we can write N as 6=3+3 whereas if N=11 and K=2 then we cannot  represent 11 as sum of two primes.\n\nMy Approach- I deduced the condition that If K>=N then we cannot represent N as sum of K primes.Also if K=1 then by primality testing we can check whether whether N is a prime number. Also by goldbach's conjecture for even numbers(except 2) N can be represented as sum of two prime numbers.\n\nBut the main problem is that I'm not able to predict it for K>=3.\n    ", "Answer": "\r\n1.Well, first list out all the prime numbers less than and equal to N.\n\n2.Brute Force Approach with backtracking method.\n\nex :\n\nN = 8\n\nk = 2.\n\n\n2 2 \n2 3\n2 5\n2 7\n3 3(Don't again consider 3 and 2)\n3 5.\nDone!\n\n\nex : 2\n\nN = 12, \nk = 4\n\n\n2 2 2 2\n2 2 2 3\n2 2 2 5\n2 2 2 7 \n2 2 3 3(don't again check for 2232)\n2 2 3 5.\nDone!\n\n\nex 3:\n\nN = 11, \nk = 3\n\n\n2 2 2\n2 2 3\n2 2 5\n2 2 7\n2 2 11\n2 3 3(don't check again for 232)\n2 3 5\n2 3 7>11(don't check for 2311)\n3 3 3(don't again check the 32.. series.)\n10.3 3 5\nDone!\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "prime sieve returning some strange numbers\r\n                \r\nI'm trying to develop a prime sieve, and on paper my algorithm makes perfect sense on paper, but returns a very short selection of composite numbers among the primes JUST above the square root.\n\nFor example, with a limit (finding all the primes up to the limit) of 10,000 (which has a square root of 100), the composite numbers it has mixed in with it's primes are 115, 119, 121, and 125 (all very close to (and above!) 100). \n\nPlease let me know what's wrong with my code, and which parts need fixing / how to fix it.\n\nCLARIFICATION: I'm worried about the composite (non-primes) it returns, where in my primality testing did i go wrong and how could i correct it?\n\nHere's my sieve so far:\n\n```\ndef primes(limit):\n    # Just make an empty list where the primes go\n    prime = []\n    # This next for loop just adds all the numbers of the form 6n+/-1 to the list, as all primes are of this form\n    for i in range(1,limit / 6 + 1):\n        prime.append(6*i - 1)\n        prime.append(6*i + 1)\n    # If the limit is divisible by 6, the last number on the list is sometimes over the limit\n    if limit % 6 == 0 and prime[-1] > limit:\n        prime.remove(prime[-1])\n    # This next line just finds the place of the 'square root' of the limit, which is as high as it has to check for factors\n    squareroot = min(range(len(prime)), key=lambda i: abs(prime[i]-(limit**0.5))) + 1\n    # Removing composites BELOW the square root\n    for p in prime[:squareroot][:]:\n        for f in range(2, int(p ** 0.5) + 1):\n            if p % f == 0:\n                prime.remove(p)\n                break\n    # Removing composites ABOVE the square root\n    for f in prime[:squareroot][:]:\n        for p in prime[squareroot:]:\n            if p % f == 0:\n                prime.remove(p)\n    return [2, 3] + prime\n```\n\n    ", "Answer": "\r\nOnce you remove primes below the square root, you can no longer use ```\nsquareroot```\n as an index into ```\nprimes```\n, since the length of ```\nprimes```\n will have changed.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "polynomial section of the AKS algorithm in Python\r\n                \r\nI need a bit of help with the polynomial section of the AKS algorithm.\n\nI have read quite a few descriptions online.\nI have got the perfect power test working and I think my get_r() function is correct.\nI am not sure how to go about doing this part of the algorithm:\n\n```\nFor a = 1 to square-root(totient(r) * log(n)):\nif (X+a)^n != X^n+a (mod X^r − 1,n), output composite\n```\n\n\n(Also see wikipedia article AKS primality test for a statement of the algorithm.) \n\nBelow are links to a program I wrote to implement the miller-rabin test and my (unfinished) aks code.\n\nIf someone can explain the maths or give me a bit of pseudocode, I should be okay.\nthanks\n\naks.py\nmiller.py\n    ", "Answer": "\r\nI describe AKS in detail at my blog. I'm typing this on my phone so you will have to search for it yourself.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Modular Exponentiation for high numbers in C++\r\n                \r\nSo I've been working recently on an implementation of the Miller-Rabin primality test.  I am limiting it to a scope of all 32-bit numbers, because this is a just-for-fun project that I am doing to familiarize myself with c++, and I don't want to have to work with anything 64-bits for awhile.  An added bonus is that the algorithm is deterministic for all 32-bit numbers, so I can significantly increase efficiency because I know exactly what witnesses to test for.\n\nSo for low numbers, the algorithm works exceptionally well.  However, part of the process relies upon modular exponentiation, that is (num ^ pow) % mod.  so, for example,\n\n```\n3 ^ 2 % 5 = \n9 % 5 = \n4\n```\n\n\nhere is the code I have been using for this modular exponentiation:\n\n```\nunsigned mod_pow(unsigned num, unsigned pow, unsigned mod)\n{\n    unsigned test;\n    for(test = 1; pow; pow >>= 1)\n    {\n        if (pow & 1)\n            test = (test * num) % mod;\n        num = (num * num) % mod;\n    }\n\n    return test;\n\n}\n```\n\n\nAs you might have already guessed, problems arise when the arguments are all exceptionally large numbers.  For example, if I want to test the number 673109 for primality, I will at one point have to find:\n\n(2 ^ 168277) % 673109\n\nnow 2 ^ 168277 is an exceptionally large number, and somewhere in the process it overflows test, which results in an incorrect evaluation.\n\non the reverse side, arguments such as\n\n4000111222 ^ 3 % 1608\n\nalso evaluate incorrectly, for much the same reason.\n\nDoes anyone have suggestions for modular exponentiation in a way that can prevent this overflow and/or manipulate it to produce the correct result?  (the way I see it, overflow is just another form of modulo, that is num % (UINT_MAX+1))\n    ", "Answer": "\r\nExponentiation by squaring still \"works\" for modulo exponentiation. Your problem isn't that ```\n2 ^ 168277```\n is an exceptionally large number, it's that one of your intermediate results is a fairly large number (bigger than 2^32), because 673109 is bigger than 2^16.\n\nSo I think the following will do. It's possible I've missed a detail, but the basic idea works, and this is how \"real\" crypto code might do large mod-exponentiation (although not with 32 and 64 bit numbers, rather with bignums that never have to get bigger than 2 * log (modulus)):\n\n\nStart with exponentiation by squaring, as you have.\nPerform the actual squaring in a 64-bit unsigned integer.\nReduce modulo 673109 at each step to get back within the 32-bit range, as you do.\n\n\nObviously that's a bit awkward if your C++ implementation doesn't have a 64 bit integer, although you can always fake one.\n\nThere's an example on slide 22 here: http://www.cs.princeton.edu/courses/archive/spr05/cos126/lectures/22.pdf, although it uses very small numbers (less than 2^16), so it may not illustrate anything you don't already know.\n\nYour other example, ```\n4000111222 ^ 3 % 1608```\n would work in your current code if you just reduce ```\n4000111222```\n modulo ```\n1608```\n before you start. ```\n1608```\n is small enough that you can safely multiply any two mod-1608 numbers in a 32 bit int.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why OpenMP doesn't speed up my C program?\r\n                \r\nI'm new with OpenMP and I was trying to use it to speed up my C program (with GMP). The code below is a primality test I've made:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <math.h>\n#include <omp.h>\n#include <gmp.h>\n\nint lucas_lehmer(unsigned long int p) {\n  mpz_t M, s, t;\n\n  // Let M = 2^p - 1\n\n  mpz_init_set_ui(t, p);\n\n  mpz_init(M);\n  mpz_setbit(M, p);\n  mpz_sub_ui(M, M, 1);\n\n  unsigned long int I;\n\n  mpz_init_set_ui(s, 4);\n\n  #pragma omp parallel for\n  {\n    for (i = 3; i <= p; i++) {\n    printf(\"Processed: %d\\n\", i-3);\n    mpz_mul(s, s, s);\n    mpz_sub_ui(s, s, 2);\n    /* mpz_mod(s, s, mp) but more efficiently done gisen mod 2^p-1 */\n    if (mpz_sgn(s) < 0) mpz_add(s, s, M);\n    /* while (n > mp) { n = (n >> p) + (n & mp) } if (n==mp) n=0 */\n    /* but in this case we can hase at most one loop plus a carry */\n    mpz_tdiv_r_2exp(t, s, p);\n    mpz_tdiv_q_2exp(s, s, p);\n    mpz_add(s, s, t);\n    #pragma omp parallel\n    {\n      while (mpz_cmp(s, M) >= 0) mpz_sub(s, s, M);\n    }    \n    }\n  }\n\n  int res;\n  res = !mpz_sgn(s);\n  mpz_clear(t); mpz_clear(M); mpz_clear(s);\n  return res;\n}\n\n\nint main() {\n  unsigned long int p;\n  printf(\"Enter an exponent:\");\n  scanf(\"%d\", &p);\n\n  int boolean;\n  boolean = lucas_lehmer(p);\n\n  if (lucas_lehmer(p)) {\n    printf(\"\\nPrime number: True\\n\");\n  }\n  else {\n    printf(\"\\nPrime number: False\\n\");\n  }\n  system(\"pause\");\n  return 0;\n}\n```\n\n\nI added ```\n#pragma omp parallel for```\n and ```\n#pragma omp parallel```\n to see if the performance of the program is improved.\n\nAfter I compiled with the command ```\ng++ lucas_lehmer.c -lgmp  -I C:/gmp-6.2.0/include/ -L C:/gmp-6.2.0/lib/```\n (I use MinGW-MSYS), compared to my code without using OpenMP, I found no speedup in my code. What was the problem here? How do I fix this?\n\n\nOptional question: The code above seems to have a problem with the loop. It repeats the loop twice before checking. How do I prevent this?\n\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why is NodeJS faster than Rust in computing the sum of the primes?\r\n                \r\nI wrote a benchmark that calculates the sum of the first 10000 primes and compared Rust to JavaScript. JavaScript on NodeJS is the fastest among Rust, Scala, and Java. Even though the programs intentionally use a functional style for testing primality aiming to show the advantages of Rust's zero-cost abstraction, NodeJS beats them all. \n\nHow can NodeJS, a dynamic typing runtime, be so fast?\n\nRust code\n\n```\nfn sum_primes(n: usize) -> u64 {\n    let mut primes = Vec::new();\n    let mut current: u64 = 2;\n    let mut sum: u64 = 0;\n\n    while primes.len() < n {\n        if primes.iter().all(|p| current % p != 0) {\n            sum += current;\n            primes.push(current);\n        }\n        current += 1;\n    }\n    sum\n}\n```\n\n\nJavaScript code\n\n```\nfunction sumPrimes(n) {\n    let primes = [];\n    let current = 2;\n    let sum = 0;\n    while (primes.length < n) {\n        if (primes.every(p => current % p != 0)) {\n            sum += current;\n            primes.push(current);\n        }\n        ++current;\n    }\n    return sum;\n}\n```\n\n\nThe full benchmark can be found on GitHub.\n    ", "Answer": "\r\nThe answer can't be simple because V8 does a lot of transformations, but here's a major point:\n\nNode's optimizing compiler dynamically adapts the types it uses (especially for array elements). It's able to use one word integers when they fit (and deoptimizes the function when it receives a non fitting value).\n\nIf I take your functions as they are, the Rust one takes 1.28ms to compute ```\nsum_prime(500)```\n when Node takes only 1.04ms (after some warming). If I change the ```\nu64```\n to ```\nu32```\n in the Rust code, then it only takes 608µs.\n\n\n\nThe JavaScript code I used:\n\n```\nfunction sum_primes(n) {\n    var primes = [];\n    var current = 2;\n    var sum = 0;\n    while (primes.length < n) {\n        if (primes.every(function (p) { return current % p != 0; })) {\n            sum += current;\n            primes.push(current);\n        }\n        ++current;\n    }\n    return sum;\n}\nconsole.log(sum_primes(200));\n// some warming\nfor (let i=0; i<100; i++) sum_primes(100);\nconsole.time(\"primes\");\nconsole.log(sum_primes(500));\nconsole.timeEnd(\"primes\");\n```\n\n\nThis JavaScript code is faster than your Rust code, but slower than this one:\n\n```\nuse std::time::Instant;\n\nfn sum_primes(n: usize) -> u32 {\n    let mut primes = Vec::new();\n    let mut current: u32 = 2;\n    let mut sum: u32 = 0;\n\n    while primes.len() < n {\n        if primes.iter().all(|p| current % p != 0) {\n            sum += current;\n            primes.push(current);\n        }\n        current += 1;\n    }\n    sum\n}\n\nfn main() {\n    println!(\"{}\", sum_primes(200));\n    let s = Instant::now();\n    println!(\"{}\", sum_primes(500));\n    println!(\"duration: {:?}\", s.elapsed());\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Javascript - Prime number function problem, memory overload [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Sieve of Eratosthenes algorithm in JavaScript running endless for large number\r\n                            \r\n                                (8 answers)\r\n                            \r\n                    \r\n                Closed 3 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have the next problem. I am trying to find all the prime numbers until the specified number as input but when I am inputting for example really big numbers such as 13480000 or 643513511, the algorithm somehow stops to iterate and my browser is getting too slow in terms of processing the function. Here is the html code:\n\n```\n<!DOCTYPE html>\n<html lang=\"es\">\n<head>\n<script src=\"esPrimo.js\">\n</script>\n</head>\n<body>\n<h1>Lista de primos</h1>\n<form name=\"formu\">\n    <input id=\"txtValue\" type=\"text\" />\n    <input type=\"button\" value=\"Calcular!\" onclick=\"proceso()\">\n</form>\n\n<p id=\"res\">El resultado se escribe aqui</p>\n</body>\n</html>\n```\n\n\nHere is my javascript code for the file of esPrimo.js\n\n```\nfunction proceso() {\n    var value = document.querySelector('#txtValue').value;\n    var primos = getPrimos(value);\n    var output = document.querySelector('#res');\n    output.innerHTML = primos.toString();\n\n}\n\nfunction getPrimos (value) {\n    var primos = [];\n    for (var i = 1; i <= value; i++){\n        if (esPrimo(i)) primos.push(i);\n    }\n    return primos;\n}\n\nfunction esPrimo(n){\n     if (isNaN(n) || !isFinite(n) || n%1 || n<2) return false; \n        var m = Math.sqrt(n);\n        for (var i = 2; i <= m; i++)\n            if (n % i == 0) return false;\n        return true;\n}\n```\n\n\nOn the last function where the program is getting the parameter, gets very slow.\nIt checks if n is dividible by every integer 2, 3, 4, 5 ... \nup to sqrt(n) but this version has the fewest lines of code.\nMoreover, I tried another way of iterating through all prime numbers like:\n\n```\nfunction esPrimo(n) {\nif (isNaN(n) || !isFinite(n) || n%1 || n<2) return false; \n if (n%2==0) return (n==2);\n var m=Math.sqrt(n);\n for (var i=3;i<=m;i+=2) {\n  if (n%i==0) return false;\n }\n return true;\n}\n```\n\n\nHere it checks the divisor 2 separately:\nthen, it proceeds to check odd divisors only, from 3 up to sqrt(n).\nAt most half of the numbers between 3 and sqrt(n) are checked.\n\nHow could I be  able to optimize the code so that my program is able to calculate faster this kind of iterations ? \n\nAny suggestions or advice, it would be really appreciating and helpful cause I have been trying to find somehow of a solution this past week, but it was of no use.\nFurthermore, I have one last link of interest in which I delved into and helped me quite a lot I would say in terms of grasping the primality test of numbers. \n\nJavascript Primality Tests\n\nThanks\n    ", "Answer": "\r\nGoing off of what Pointy said in the comments, below is your JavaScript refactored to use Eratosthenes \"sieve\" algorithm.  Before I get to the code, first a quick explanation of Erastosthenes.  Erastosthenes found that you can more efficiently find prime numbers between 2 and N, where N is a large number, by finding the multiples of each number between the two and removing them from your list.  Whatever you're left with must be prime.\n\nE.G. N = 10\n\n2, 3, 4, 5, 6, 7, 8, 9, 10 --> Multiples of 2 include 4, 6, 8 and 10, so they aren't prime. Multiples of 3 include 6 and 9, so they're removed.  And so on.  You're ultimately left with 2, 3, 5, 7, none of which had a number multiply into them.\n\nNow, the code below uses Erastosthenes algorithm, but it will still break if you try your example of 643513511, I just think the processing power required by the browser is too much, but I could be wrong.  It will, however, work for your example of 13 million.\n\nNote: This code was refactored using your code and code taken from another Stackoverflow post, Sieve of Eratosthenes algorithm in JavaScript running endless for large number.\n\n```\nvar getPrimos = function(n) {\n    // Eratosthenes algorithm to find all primes under n\n    var array = [], upperLimit = Math.sqrt(n), output = [];\n\n    // Make an array from 2 to (n - 1)\n    for (var i = 0; i < n; i++) {\n        array.push(true);\n    }\n\n    // Remove multiples of primes starting from 2, 3, 5,...\n    for (var i = 2; i <= upperLimit; i++) {\n        if (array[i]) {\n            for (var j = i * i; j < n; j += i) {\n                array[j] = false;\n            }\n        }\n    }\n\n    // All array[i] set to true are primes\n    for (var i = 2; i < n; i++) {\n        if(array[i]) {\n            output.push(i);\n        }\n    }\n\n    return output;\n};\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Determining prime number\r\n                \r\nIm doing exercise from the Bjarne Stroustrup book called \"Programming principles and practice using c++\". I have to find first n prime numbers that user wants[user enters 5, and program finds first five prime numbers]. I found the solution on this site:\nhttp://people.ds.cam.ac.uk/nmm1/C++/Exercises/Chapter_04/ex_15.cpp\n\n```\nbool prime (vector<int> table, int number) {\nfor (int i = 0; i < table.size(); ++i)\n    if (number%table[i] == 0) return false;\nreturn true;\n}\n```\n\n\nbut i cant understand the test for primality. Why modulo? I have my own test for primality and its much easier to understand for me, albeit its less elegant and more verbose. \n\n```\nbool isPrime(int num) {\n  for (int i = 2; i < num; i++) {\n    for (int j = 0; j < num; j++) {\n        if (i*j == num) {\n            return false;\n        }\n    }\n  }\n  if (num == 1) {\n    return false;\n  }\n  return true;\n}\n```\n\n\nSo if anyone can explain me that guy code i would be greatful. \n    ", "Answer": "\r\nHere's the other code, included in its entirety:\n\n```\n#include \"std_lib_facilities.h\"\n\nbool prime (vector<int> table, int number) {\n    for (int i = 0; i < table.size(); ++i)\n        if (number%table[i] == 0) return false;\n    return true;\n}\n\nint main () {\n    int count, next;\n    cout << \"Input the number of primes\\n\";\n    cin >> count;\n    vector<int> table;\n    next = 2;\n    while (table.size() < count) {\n        if (prime(table,next)) table.push_back(next);\n        ++next;\n    }\n    for (int n = 0; n < table.size(); ++n)\n        cout << table[n] << \" \";\n    cout << endl;\n\n    // keep_window_open();\n    return 0;\n}\n```\n\n\nThis code populates the vector ```\ntable```\n with all the prime numbers it has found so far. Starting from 2, it checks if the number is divisible by any of the numbers in this ```\ntable```\n it has constructed. If it isn't divisible, it means that this number is a prime, and it gets entered into the ```\ntable```\n.\nThe modulo operator is used to check for divisibility here. ```\na%b```\n returns the remainder that occurs when the division ```\na/b```\n is performed. If this value is 0, there is no remainder, and we can conclude that a is divisible by b.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why won't my if/else statement work? (JavaScript)\r\n                \r\nI'm trying to code a script to test whether a user-inputted number is prime or not. I'm coding several different primality tests, but one in particular is giving me a hard time. \n\n```\nfunction isPrimeSix() {\n    var numberPrimeSix = document.getElementById(\"primeSixInput\").value;\n    var loopCount = 0;\n    for (var i = 1; i < Math.floor((numberPrimeSix / 6) + 1) + 1; i++)\n    {\n        if (numberPrimeSix === (6 * i) + 1)\n        {\n            //Irrelevant code here//\n        }\n        else if (numberPrimeSix === (6 * i) - 1)\n        {\n            //More irrelevant code//\n        }\n        else\n        {\n            loopCount++\n        }\n    };\n    if (numberPrimeSix === 2 || numberPrimeSix === 3 || numberPrimeSix === 5 || numberPrimeSix === 7)\n    {\n        alert(numberPrimeSix + \" is prime.\");\n    }\n    else if (prime === false || loopCount === Math.floor((numberPrimeSix / 6) + 1))\n    {\n        alert(numberPrimeSix + \" is not prime.\");\n    }\n    else if (prime === true)\n    {\n        alert(numberPrimeSix + \" is prime.\");\n    }\n    else\n    {\n        alert(\"Error\");\n    };\n}\n```\n\n\nEvery time the ```\nfor```\n loop goes around, the embedded ```\nif```\n statement will not evaluate, even if for that particular value of ```\ni```\n one of the statements is true. Regardless of what number is assigned to ```\nnumberPrimeSix```\n, the script will always go to the ```\nelse```\n section of the loop, meaning that an alert will pop up telling me that the number is not prime (because the value of ```\nloopCount```\n is equal to the value defined by the last ```\nif```\n statement).\n\nCan anyone tell me why this is? I hope this makes sense, and if the 'irrelevant code' is needed I'll provide it. Thanks!\n    ", "Answer": "\r\nA string will never be exactly equal (```\n===```\n) to a number. In JavaScript, if you use ```\n==```\n, the operands will be converted to be the same type before comparing. If you instead use ```\n===```\n, that step will be skipped and instead they will be tested for strict equality, meaning same type and value, not just same value.\n\nYou have two options. Replace ```\n===```\n with ```\n==```\n, or, convert the value before the loop and continue using strict equal. It will be much faster to convert the value before the loop so that you're not converting it over and over with each iteration.\n\n```\nvar numberPrimeSix = parseInt(document.getElementById(\"primeSixInput\").value, 10);\n```\n\n\n\n\nmore reading: Which equals operator (== vs ===) should be used in JavaScript comparisons?\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Probability of finding a prime (using miller-rabin test)\r\n                \r\nI've implemented Miller-Rabin primality test and every function seems to be working properly in isolation. However, when I try to find a prime by generating random numbers of 70 bits my program generates in average more than 100000 numbers before finding a number that passes the Miller-Rabin test (10 steps). This is very strange, the probability of being prime for a random odd number of less than 70 bits should be very high (more than 1/50 according to Hadamard-de la Vallée Poussin Theorem). What could be wrong with my code? Would it be possible that the random number generator throws prime numbers with very low probability? I guess not... Any help is very welcome.\n\n```\nimport random\n\n\ndef miller_rabin_rounds(n, t):\n    '''Runs miller-rabin primallity test t times for n'''\n\n    #  First find the values r and s such that 2^s * r = n - 1\n    r = (n - 1) / 2\n    s = 1\n    while r % 2 == 0:\n        s += 1\n        r /= 2\n\n    #  Run the test t times\n    for i in range(t):\n        a = random.randint(2, n - 1)\n        y = power_remainder(a, r, n)\n\n        if y != 1 and y != n - 1:\n            #  check there is no j for which (a^r)^(2^j) = -1 (mod n)\n            j = 0\n            while j < s - 1 and y != n - 1:\n                y = (y * y) % n\n                if y == 1:\n                    return False\n                j += 1\n            if y != n - 1:\n                return False\n\n    return True\n\n\ndef power_remainder(a, k, n):\n    '''Computes (a^k) mod n efficiently by decomposing k into binary'''\n    r = 1\n    while k > 0:\n        if k % 2 != 0:\n            r = (r * a) % n\n        a = (a * a) % n\n        k //= 2\n    return r\n\n\ndef random_odd(n):\n    '''Generates a random odd number of max n bits'''\n    a = random.getrandbits(n)\n    if a % 2 == 0:\n        a -= 1\n    return a\n\nif __name__ == '__main__':\n    t = 10  # Number of Miller-Rabin tests per number\n    bits = 70  # Number of bits of the random number\n    a = random_odd(bits)\n    count = 0\n    while not miller_rabin_rounds(a, t):\n        count += 1\n        if count % 10000 == 0:\n            print(count)\n        a = random_odd(bits)\n    print(a)\n```\n\n    ", "Answer": "\r\nThe reason this works in python 2 and not python 3 is that the two handle integer division differently. In python 2, ```\n3/2 = 1```\n, whereas in python 3, ```\n3/2=1.5```\n.\n\nIt looks like you should be forcing integer division in python 3 (rather than float division). If you change the code to force integer division (```\n//```\n) as such:\n\n```\n#  First find the values r and s such that 2^s * r = n - 1\nr = (n - 1) // 2\ns = 1\nwhile r % 2 == 0:\n    s += 1\n    r //= 2\n```\n\n\nYou should see the correct behaviour regardless of what python version you use.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Akka streams don't run when Source has large number of records\r\n                \r\nI'm trying to write a very simple introductory example of using Akka Streams. I'm attempting to basically create a stream that takes a range of integers as a source and filters out all the integers that are not prime, producing a stream of prime integers as its output.\n\nThe class that constructs the stream is rather simple; for that I have the following.\n\n```\nimport akka.NotUsed;\nimport akka.actor.ActorSystem;\nimport akka.stream.javadsl.Flow;\nimport com.aparapi.Kernel;\nimport com.aparapi.Range;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class PrimeStream {\n    private final AverageRepository averageRepository = new AverageRepository();\n    private final ActorSystem actorSystem;\n\n    public PrimeStream(ActorSystem actorSystem) {\n        this.actorSystem = actorSystem;\n    }\n\n    public Flow<Integer, Integer, NotUsed> filterPrimes() {\n        return Flow.of(Integer.class).grouped(10000).mapConcat(PrimeKernel::filterPrimes).filter( v -> v != 0);\n    }\n}\n```\n\n\nWhen I run the following test, it works fine.\n\n```\nprivate final ActorSystem actorSystem = ActorSystem.create(\"Sys\");\n\n@Test\npublic void testStreams() {\n    Flow<Integer, Integer, NotUsed> filterStream = new PrimeStream(actorSystem).filterPrimes();\n    Source<Integer, NotUsed> flow = Source.range(10000000, 10001000).via(filterStream);\n    flow.runForeach(System.out::println, ActorMaterializer.create(actorSystem));\n}\n```\n\n\nHowever, when I increase the range by a factor of x10 by changing the line in the test to the following, it no longer works.\n\n```\nSource<Integer, NotUsed> flow = Source.range(10000000, 10010000).via(filterStream);\n```\n\n\nNow when the test runs, no exceptions are thrown, no warnings. It simply runs, then exits, without displaying any text to the console at all.\n\nJust to be extra certain that the problem wasn't in my primality test itself, I ran the test over the same range without using Akka Streams, and it runs fine. The following code runs without a problem.\n\n```\n@Test\npublic void testPlain() {\n    List<Integer> in = IntStream.rangeClosed(10000000, 10010000).boxed().collect(Collectors.toList());\n    List<Integer> out = PrimeKernel.filterPrimes(in);\n    System.out.println(out);\n}\n```\n\n\nJust for the sake of clarity, the primality test itself takes in a list of integers and sets any element in the list to 0 if it is not prime.\n\nAs suggested by @RamonJRomeroyVigil if i remove the mapConcat part all together but leave everythig the same it does, in fact, print out 10,000 integers. However If i leave everything the same but simply replace filterPrimes with a method that just returns the method parameter as is without touching it, then it doesnt print anything to the screen at all. I've also tried adding a println to the begining filterPrime to debug it. Whenever it doesnt print any output that includes the debugging statement. So no attempt is even made to call filterPrimes at all.\n    ", "Answer": "\r\n```\nrunForeach```\n returns a ```\nCompletionStage```\n, so if you want to see all the numbers getting printed then you have to await on the ```\nCompletionStage```\n otherwise the test function returns and the program terminates without the ```\nCompletionStage```\n getting completed.\n\nExample:\n\n```\nflow.runForeach(System.out::println, ActorMaterializer.create(actorSystem)).toCompletableFuture().join();\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Arbitrary precision integer on GPU\r\n                \r\nI'm currently doing a primality test on huge numbers (up to 10M digits).\nRight now, I'm using a c program using the GMP library. I did some parallelization using OpenMP and got a nice speedup (3.5~ with 4 cores). The problem is that I don't have enough CPU cores to make it feasible to run with my whole dataset.\nI have an NVidia GPU and, I tried to find an alternative to GMP, but for GPUs. It can be either CUDA or OpenCL.\nIs there an arbitrary precision library that I can run on my GPU? I'm also open to using another programming language if there is a simple or more elegant way of doing it.\n    ", "Answer": "\r\nIt seems the Julia Language is already able to do multiprecision arithmetic and use the GPU (see here for a simple example combining these two), but you might have to learn Julia and rewrite your code.\nThe CUMP library is meant to be a GMP substitute for CUDAs, it attempts to make it easier for porting GMP code to CUDAs by offering an interface similar to GMP, for example you replace ```\nmpf_...```\n variables and functions by ```\ncumpf_...```\n ones. There is a demo you can ```\nmake```\n if it fits your CUDA. No documentation or support though, you'll have to go through the code to see if it works.\nThe CAMPARY library from people in LAAS-CNRS might be a shot as well, but no documentation either. It has been applied in more research than CUMP, so some chance there. An answer here gives some clarification on how to use it.\nGRNS uses the residue number system on CUDA-compatible processors, it has no documentation but an interesting paper is available. Also, see this one.\nXMP comes directly from NVIDIA labs, but seems incomplete and has no docs also. Some info here and a paper here.\nXMP 2.0 seems newer but only support sizes up to 32k bits for now.\nGPUMP looks promising, but seems not available for download, perhaps by contacting the authors.\nThe MPRES-BLAS is a multiprecision library for linear algebra on CUDAs, and does - of course - have code for basic arithmetic. Also, papers here and here.\nI haven't tested any of those, so please let us know if any of those work well.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Fast prime factorization module\r\n                \r\nI am looking for an implementation or clear algorithm for getting the prime factors of N in either python, pseudocode or anything else well-readable. There are a few requirements/constraints:\n\nN is between 1 and ~20 digits\nNo pre-calculated lookup table, memoization is fine though\nNeed not to be mathematically proven (e.g. could rely on the Goldbach conjecture if needed)\nNeed not to be precise, is allowed to be probabilistic/deterministic if needed\n\nI need a fast prime factorization algorithm, not only for itself, but for usage in many other algorithms like calculating the Euler phi(n).\nI have tried other algorithms from Wikipedia and such but either I couldn't understand them (ECM) or I couldn't create a working implementation from the algorithm (Pollard-Brent).\nI am really interested in the Pollard-Brent algorithm, so any more information/implementations on it would be really nice.\nThanks!\nEDIT\nAfter messing around a little I have created a pretty fast prime/factorization module. It combines an optimized trial division algorithm, the Pollard-Brent algorithm, a miller-rabin primality test and the fastest primesieve I found on the internet. gcd is a regular Euclid's GCD implementation (binary Euclid's GCD is much slower then the regular one).\nBounty\nOh joy, a bounty can be acquired! But how can I win it?\n\nFind an optimization or bug in my module.\nProvide alternative/better algorithms/implementations.\n\nThe answer which is the most complete/constructive gets the bounty.\nAnd finally the module itself:\n```\nimport random\n\ndef primesbelow(N):\n    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    #\"\"\" Input N>=6, Returns a list of primes, 2 <= p < N \"\"\"\n    correction = N % 6 > 1\n    N = {0:N, 1:N-1, 2:N+4, 3:N+3, 4:N+2, 5:N+1}[N%6]\n    sieve = [True] * (N // 3)\n    sieve[0] = False\n    for i in range(int(N ** .5) // 3 + 1):\n        if sieve[i]:\n            k = (3 * i + 1) | 1\n            sieve[k*k // 3::2*k] = [False] * ((N//6 - (k*k)//6 - 1)//k + 1)\n            sieve[(k*k + 4*k - 2*k*(i%2)) // 3::2*k] = [False] * ((N // 6 - (k*k + 4*k - 2*k*(i%2))//6 - 1) // k + 1)\n    return [2, 3] + [(3 * i + 1) | 1 for i in range(1, N//3 - correction) if sieve[i]]\n\nsmallprimeset = set(primesbelow(100000))\n_smallprimeset = 100000\ndef isprime(n, precision=7):\n    # http://en.wikipedia.org/wiki/Miller-Rabin_primality_test#Algorithm_and_running_time\n    if n < 1:\n        raise ValueError(\"Out of bounds, first argument must be > 0\")\n    elif n <= 3:\n        return n >= 2\n    elif n % 2 == 0:\n        return False\n    elif n < _smallprimeset:\n        return n in smallprimeset\n\n\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n\n    for repeat in range(precision):\n        a = random.randrange(2, n - 2)\n        x = pow(a, d, n)\n    \n        if x == 1 or x == n - 1: continue\n    \n        for r in range(s - 1):\n            x = pow(x, 2, n)\n            if x == 1: return False\n            if x == n - 1: break\n        else: return False\n\n    return True\n\n# https://comeoncodeon.wordpress.com/2010/09/18/pollard-rho-brent-integer-factorization/\ndef pollard_brent(n):\n    if n % 2 == 0: return 2\n    if n % 3 == 0: return 3\n\n    y, c, m = random.randint(1, n-1), random.randint(1, n-1), random.randint(1, n-1)\n    g, r, q = 1, 1, 1\n    while g == 1:\n        x = y\n        for i in range(r):\n            y = (pow(y, 2, n) + c) % n\n\n        k = 0\n        while k < r and g==1:\n            ys = y\n            for i in range(min(m, r-k)):\n                y = (pow(y, 2, n) + c) % n\n                q = q * abs(x-y) % n\n            g = gcd(q, n)\n            k += m\n        r *= 2\n    if g == n:\n        while True:\n            ys = (pow(ys, 2, n) + c) % n\n            g = gcd(abs(x - ys), n)\n            if g > 1:\n                break\n\n    return g\n\nsmallprimes = primesbelow(1000) # might seem low, but 1000*1000 = 1000000, so this will fully factor every composite < 1000000\ndef primefactors(n, sort=False):\n    factors = []\n\n    for checker in smallprimes:\n        while n % checker == 0:\n            factors.append(checker)\n            n //= checker\n        if checker > n: break\n\n    if n < 2: return factors\n\n    while n > 1:\n        if isprime(n):\n            factors.append(n)\n            break\n        factor = pollard_brent(n) # trial division did not fully factor, switch to pollard-brent\n        factors.extend(primefactors(factor)) # recurse to factor the not necessarily prime factor returned by pollard-brent\n        n //= factor\n\n    if sort: factors.sort()\n\n    return factors\n\ndef factorization(n):\n    factors = {}\n    for p1 in primefactors(n):\n        try:\n            factors[p1] += 1\n        except KeyError:\n            factors[p1] = 1\n    return factors\n\ntotients = {}\ndef totient(n):\n    if n == 0: return 1\n\n    try: return totients[n]\n    except KeyError: pass\n\n    tot = 1\n    for p, exp in factorization(n).items():\n        tot *= (p - 1)  *  p ** (exp - 1)\n\n    totients[n] = tot\n    return tot\n\ndef gcd(a, b):\n    if a == b: return a\n    while b > 0: a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return abs((a // gcd(a, b)) * b)\n```\n\n    ", "Answer": "\r\nIf you don't want to reinvent the wheel, use the library sympy\n```\npip install sympy\n```\n\nUse the function ```\nsympy.ntheory.factorint```\n\n\nGiven a positive integer ```\nn```\n, ```\nfactorint(n)```\n returns a dict containing\nthe prime factors of ```\nn```\n as keys and their respective multiplicities\nas values. For example:\n\nExample:\n```\n>>> from sympy.ntheory import factorint\n>>> factorint(10**20+1)\n{73: 1, 5964848081: 1, 1676321: 1, 137: 1}\n```\n\nYou can factor some very large numbers:\n```\n>>> factorint(10**100+1)\n{401: 1, 5964848081: 1, 1676321: 1, 1601: 1, 1201: 1, 137: 1, 73: 1, 129694419029057750551385771184564274499075700947656757821537291527196801: 1}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Lucas-Lehmer test using Python not working for large numbers\r\n                \r\nI am trying to write a function that should take in a Mersenne number and return whether it is a prime number or not using the Lucas-Lehmer primality test. I am trying to return the last number generated in the Lucas-Lehmer sequence which should be 0 if it is a prime number\n\n\n\nI have written the following function to do the above\n\n```\ndef lucas_lehmer_modified(p):\n   M=2**p-1\n   for i in range (0,p-1):\n     if i == 0:\n       x = 4\n     else : \n        x = (prev**2-2)%(M)\n     prev=x\n   return x\n```\n\n\nMy problem is that this code works for small numbers such as ```\n127```\n but not for large numbers like ```\n2305843009213693951```\n and even for ```\n524287```\n. My Python Jupyter notebook hangs up. Any advice on how I can get a function that takes in a Mersenne prime as an input and returns whether it is a prime number or not using the Lucas Lehmer test. I need to make it work for at least ```\n2^65-1```\n\n    ", "Answer": "\r\nI wrote a Lucas Lehmer test from the psuedocode from the wikipedia entry, here is what i came up with ( p being the mersenne power number ):\n```\ndef LucasLehmer(p):\n   if p == 2:\n     return True\n   s = 4\n   M = pow(2, p) - 1\n   for x in range (1, (p-2)+1):\n      s = ((s * s) - 2) % M\n   if s == 0: return True\n   else: return False\n```\n\nAnd some answers:\n```\nIn [388]: LucasLehmer(9689)                                                                                                                                                                     \nOut[388]: True\n\nIn [389]: LucasLehmer(19937)                                                                                                                                                                    \nOut[389]: True\n\nIn [390]: LucasLehmer(500)                                                                                                                                                                      \nOut[390]: False\n\n\n\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Python - Modulo Operation as a Conditional\r\n                \r\nI saw such a use of the modulo operator in a lambda function testing for primality. Can someone explain why the following statement will execute as long as i is greater than x if this isn't to my knowledge an actual boolean statement. It works with division as well if the numerator is greater than the denominator regardless if they are factors or not.\n\n```\nif x % i:\n    # Execute random foolishness\n```\n\n\nNOTE: I have only tried this in Python and Java so if this works in another language I apologize as it is probably not a language specific question. \n    ", "Answer": "\r\nPython treats non-zero values as True, so ```\nif x % i:```\n is the same as ```\nif x % i != 0:```\n. It's just a quick way to test if ```\nx```\n is evenly divisible by ```\ni```\n.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Is there a way to do a right bit-shift on a BigInt in Rust?\r\n                \r\nI get this error when attempting to do >> or >>= on a BigInt:\n```\nno implementation for `BigInt >> BigInt```\n\nusing the ```\nnum_bigint::BigInt```\n library\nEdit: More Context:\nI am rewriting this program https://www.geeksforgeeks.org/how-to-generate-large-prime-numbers-for-rsa-algorithm/ from python/c++ into rust however I will focus on the python implementation as it is written to handle 1024 bit prime numbers which are extremely big.\nIn the code we run the Miller Rabin Primality test which includes shifting EC: (prime-candidate - 1) to the right by 1 if we find that EC % 2 == 0. As I mentioned in the python implementation EC can be an incredibly large integer.\nIt would be convenient to be able to use the same operator in rust, if that is not possible can someone suggest an alternative?\n    ", "Answer": "\r\nAccording to the documentation for the ```\nnum-bigint```\n crate, the ```\nBigInt```\n struct does implement the ```\nShr```\n trait for the right-shift operator, just not when the shift amount is itself a ```\nBigInt```\n. If you convert the shift amount to a standard integer type (e.g. ```\ni64```\n) then it should work.\nIt is unlikely you would ever want to shift by an amount greater than ```\ni64::MAX```\n, but if you do need this, then the correct result is going to be zero (because no computer has 2^60 bytes of memory), so you can write a simple implementation which checks for that case.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Is the function gmp_prob_prime in PHP a bit lack luster?\r\n                \r\nHere is a snippet of code where I'm using gmp_prob_prime.  Even though I'm currently only testing numbers in the 10^6 range this function VERY regularly \"fails\" my QuickTest and ends up needing to do a manual check of $NumberToTest for primality.\n\nIs gmp_prob_prime not very robust?  I didn't expect it to suggest \"probable prime\" until I was in the 10^9 or even 10^12 range.\n\nHere is the snippet of my code's function that is being called:\n\n```\nfunction IsPrime($DocRoot, $NumberToTest, $PowOf2)\n{\n// First a quick test...\n// 0 = composite\n// 1 = probable prime\n// 2 = definite prime\n$Reps = 15;\n$QuickTest = gmp_prob_prime($NumberToTest,$Reps);\nif( $QuickTest == 0 )\n        {\n        return 0;\n        }\nif ( $QuickTest == 2 )\n        {\n        return 1;\n        }\n\n// If we get to here then gmp_prob_prime isn't sure whether the $NumberToTest is prime or not.\nprint \"Consider increasing the Reps for gmp_prob_prime.\\n\";\n\n// Find the sqrt of $NumberToTest;\n```\n\n\n... code continues ...\n    ", "Answer": "\r\nI had the same behavior when calling ```\nmpz_probab_prime_p```\n directly from C++, but I can't recall if the below information fixed it or not (copied from the manual).\n\n\n  Function: int mpz_probab_prime_p (const mpz_t n, int reps)\n  \n  Determine whether n is prime. Return 2 if n is definitely prime, return 1 if n is probably prime (without being certain), or return 0 if n is definitely composite.\n  \n  This function does some trial divisions, then some Miller-Rabin probabilistic primality tests. The argument reps controls how many such tests are done; a higher value will reduce the chances of a composite being returned as “probably prime”. 25 is a reasonable number; a composite number will then be identified as a prime with a probability of less than 2^(-50).\n  \n  Miller-Rabin and similar tests can be more properly called compositeness tests. Numbers which fail are known to be composite but those which pass might be prime or might be composite. Only a few composites pass, hence those which pass are considered probably prime.\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why does this RSA keygen/encryption function return the original message for encryption and a large number for decryption?\r\n                \r\nI am trying to create my own function for RSA encryption, but the results are not what I want.\n\nI have tested the external modules for lcm, gcd, exponents by squaring with exponents, modular multiplicative inverse, and primality test. I was following https://en.wikipedia.org/wiki/RSA_(cryptosystem).\n\nI have created valid primes digest1 and digest2. I checked those to make sure they are prime. They are also very large.\n\n```\nn=digest1*digest2\ntn=lcm.lcm(digest1-1,digest2-1)\n#totient of n\nfor e in range(start,1000000000000000000000):\n    #a large number for coprime to tn\n    if math.gcd(e,tn)==1.0:\n        d=modularminverse.modInverse(e,tn)\n        if len(str(d))<200:\n            #for small e\n            break\nn=int(n)\ne=int(e)\nd=int(d)\npublickey=(n,e)\nprivatekey=(n,d)\nreturn (publickey, privatekey)\n\n```\n\n\nI created e and d, and this is the encryption.\n\n```\nkeys=None\nwhile keys == None:\n    keys=rsa()\nprint(keys)\nencryptmessage=fastpower.fast_power(101,keys[0][1],keys[0][0])\nprint(encryptmessage)\ndecryptmessage=fastpower.fast_power(encryptmessage,keys[1][1],keys[1][0])\nprint(decryptmessage)\n```\n\n\nHere, the external function names suggest their usage e.g. fastpower.fast_power is exponentiation with modulus.\n\nI expect the result to be a long number then 101, but with start = 10000000, it gives me something like:\n\n\n  101\n  1943008535967955120523586573083029590205252967627388466351631986945832635342057989695130781235934234951139601298113497667511028938689905543444926395107114\n\n\nwhich is backwards. With start=10000000000000000 or a sufficiently large number, both encryptmessage and decryptmessage becomes a large number.\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Better way to find all the prime factors of huge integers in C?\r\n                \r\nI have written a code in C that basically makes a list of all the prime factors of a huge number, which is stored using the ```\ngmp```\n library. Here it is :\n\n```\nint is_div(mpz_t number, mpz_t i) {\n    return mpz_divisible_p(number,i)!=0;\n}\n\nmpz_t * prime_divs(mpz_t number){\n    mpz_t * prime_dividers = NULL;\n    mpz_t i, i_squared,TWO, comp;\n    mpz_inits(i, i_squared, TWO, comp, NULL);\n    mpz_set_ui(i,2);\n    mpz_mul(i_squared, i ,TWO);\n    while(mpz_cmp(i_squared,number)<=0){\n        if(is_div(number,i)){\n            mpz_fdiv_q(comp, number, i);\n            if(is_prime(i)) append(&prime_dividers,i);\n            if(is_prime(comp)) append(&prime_dividers,comp);\n        }\n        mpz_add_ui(i,i,1);\n        mpz_mul(i_squared, i ,i);\n    }\n    mpz_clears(i, i_squared, TWO, comp, NULL);\n    return prime_dividers;\n}\n```\n\n\nNote that the function ```\nint is_prime(mpz_t n)```\n is not defined here because it is quite long. Just know that it is an implementation of a deterministic variant (up to 3,317,044,064,679,887,385,961,981) of Miller-Rabin's primality test. Same goes for the function ```\nvoid append(mpz_t** arr, mpz_t i)```\n, it is just a function that appends it to a list.\n\nSo my ```\nprime_divs```\n function searches for all integers ```\ni```\nin the range ```\n[2,sqrt(number)]```\n which divide ```\nnumber```\n. If it is the case, it then calculates it's complementary divisor (i.e. ```\nnumber/i```\n) and determines if any of them are primes. Would these integers be prime, then they would be appended to a list using ```\nappend```\n.\n\nIs there any way to make```\nprime_divs```\n faster?\n    ", "Answer": "\r\nI suspect you can save time by first checking for small divisors.  Use the Sieve of Eratosthenes to set up a list of prime numbers below 5,000 or 10,000.  Then use that list to find the small factors, if any, of your large number.  Every time you find a factor (possibly multiple times for the same factor) divide out that factor to reduce the target number's size.\n\nWhen you have exhausted the list of small primes, it may be worth running a quick primality check on the large residue before trying to factor it.  This avoids wasting a lot of time looking for factors of a large prime.  You will need to test this idea to see if it actually saves time for you.\n\nOnly then should you call the M-R test to find the remaining factors.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Sieve of Eratosthenes implementations and comparisons\r\n                \r\nBesides the simple implementation of Sieve of Eratosthenes with time complexity of O(N log log N), I also tried to implement a modification with time complexity O(N). Although, both produce the desired result, somehow the earlier one takes much lesser time compared to the next one and I'm unable to figure out why. I'd really appreciate some pointers on this.\n\nImplementation 1:\n\n```\ndef build_sieve_eratosthenes(num):\n    ## Creates sieve of size (num+1) to correct for 0-indexing.\n    primes_sieve = [1] * (num+1)\n    primes_sieve[0] = primes_sieve[1] = 0\n    for p in range(2, num):\n        if primes_sieve[p] == 1:\n            for mul in range(2*p, num+1, p):\n                primes_sieve[mul] = 0\n    return primes_sieve\n```\n\n\nImplementation 2: \n\n```\ndef build_sieve_eratosthenes_linear(num):\n    ## Creates sieve of size (num+1) to correct for 0-indexing.\n    primes_sieve = [1] * (num+1)\n    primes_sieve[0] = primes_sieve[1] = 0\n\n    ## Builds a list of size (num+1) recording the smallest prime factor of each number.\n    SPF = [1] * (num+1)\n\n    ## Builds a list of all primes seen so far with pos indicator of position where to insert the next prime.\n    ## Uses a large fixed memory allocation scheme to avoid the usage of append list operation.\n    primes = [0] * num\n    pos = 0\n\n    for p in range(2, num+1):\n        if primes_sieve[p] == 1:\n            primes[pos] = p\n            pos = pos + 1\n            ## Smallest prime factor of a prime is a prime itself.\n            SPF[p] = p\n        for i in range(0, pos):\n            if p * primes[i] <= num and primes[i] <= SPF[p]:\n                primes_sieve[p*primes[i]] = 0\n                SPF[p * primes[i]] = primes[i]\n            else:\n                break\n    return primes_sieve\n\ntest_num = 2000000\n```\n\n\nTest method\n\n```\ndef find_sum_of_primes_upto_num_with_sieve(sieve, num):\n    primes_sieve = sieve(num)\n    primes_sum = 0\n    for n in range(len(primes_sieve)):\n        if primes_sieve[n] == 1:\n            primes_sum = primes_sum + n\n    return primes_sum\n```\n\n\nResults:\n\n```\nstart2 = time.time()\nsum_2 = find_sum_of_primes_upto_num_with_sieve(build_sieve_eratosthenes, test_num)\nend2 = time.time()\nprint(\"Sum of primes obtained: \", sum_2)\nprint(\"Time taken by checking primality of each number is %f sec\" % (end2 - start2))\n```\n\n\nSum of primes obtained:  142913828922\nTime taken by checking primality of each number is 0.647822 sec\n\n```\nstart3 = time.time()\nsum_3 = find_sum_of_primes_upto_num_with_sieve(build_sieve_eratosthenes_linear, test_num)\nend3 = time.time()\nprint(\"Sum of primes obtained: \", sum_3)\nprint(\"Time taken by checking primality of each number is %f sec\" % (end3 - start3))\n```\n\n\nSum of primes obtained:  142913828922\nTime taken by checking primality of each number is 1.561308 sec\n    ", "Answer": "\r\nI dropped a simple iteration counter into each routine, and ran for powers of 10 from 10^3 through 10^7\n\nbuild_sieve_eratosthenes:\n\n```\n    1000 has     1958 iterations in sieve\n   10000 has    23071 iterations in sieve\n  100000 has   256808 iterations in sieve\n 1000000 has  2775210 iterations in sieve\n10000000 has 29465738 iterations in sieve\n```\n\n\nbuild_sieve_eratosthenes_linear:\n\n```\n    1000 has      831 iterations in sieve_linear\n   10000 has     8770 iterations in sieve_linear\n  100000 has    90407 iterations in sieve_linear\n 1000000 has   921501 iterations in sieve_linear\n10000000 has  9335420 iterations in sieve_linear\n```\n\n\nYour ```\nlinear```\n function is not linear: note that inner loop, which runs ```\npos```\n times ... and ```\npos```\n is a count of the quantity of primes found, which is not a constant.\n\n```\nlinear```\n grows more slowly than the \"normal\" function, and has significantly fewer iterations overall.  However, it has a larger cost for each iteration, which is why you're seeing \"inverted\" times.  Each number found and each \"cross-out\" is more expensive in your ```\nlinear```\n function; the slower growth hasn't caught up by your limit of only 2*10^6, not by my limit of 10*7.  You could extrapolate this out for about a day to get a better feel of the appropriate timing, if that's worth it to you ... but the central \"problem\" is the slower processing for each number.\n\nFor the detail-curious, here's the full output:\n\n```\n1000 has 1958 iterations in sieve\nSum of primes obtained:  76127\nTime taken by checking primality of each number is 0.000904 sec\n10000 has 23071 iterations in sieve\nSum of primes obtained:  5736396\nTime taken by checking primality of each number is 0.008270 sec\n100000 has 256808 iterations in sieve\nSum of primes obtained:  454396537\nTime taken by checking primality of each number is 0.067962 sec\n1000000 has 2775210 iterations in sieve\nSum of primes obtained:  37550402023\nTime taken by checking primality of each number is 0.428727 sec\n10000000 has 29465738 iterations in sieve\nSum of primes obtained:  3203324994356\nTime taken by checking primality of each number is 5.761439 sec\n1000 has 831 iterations in sieve_linear\nSum of primes obtained:  76127\nTime taken by checking primality of each number is 0.001069 sec\n10000 has 8770 iterations in sieve_linear\nSum of primes obtained:  5736396\nTime taken by checking primality of each number is 0.010398 sec\n100000 has 90407 iterations in sieve_linear\nSum of primes obtained:  454396537\nTime taken by checking primality of each number is 0.107276 sec\n1000000 has 921501 iterations in sieve_linear\nSum of primes obtained:  37550402023\nTime taken by checking primality of each number is 1.087080 sec\n10000000 has 9335420 iterations in sieve_linear\nSum of primes obtained:  3203324994356\nTime taken by checking primality of each number is 11.008726 sec\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "not getting output for euler challenge 3\r\n                \r\nI am attempting to solve Project Euler: Problem 3, and I am using the following function to test for primality,\n\n```\ndef check_prime(x):\n    i = 1\n    b = 0\n    while b == 0 :\n        i += 1\n        if i >= x :\n            return True \n            b += 1\n        elif  x%i  == 0 :\n            return False\n            b += 1\n```\n\n\nWhich I call from the rest of my program\n\n```\na = 3\nz = []\nnumber_used = 600851475143\nwhile a < number_used/2 :\n    if check_prime(a) and number_used%a == 0 :\n        z.append(a);\n        a += 2\n    else :\n        a += 2  \n        print z\n```\n\n\nBut, the code is not printing the  prime factors needed for the third Euler problem. Is my code too inefficient to manage it?\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to do arithmetic modulo another number, without overflow?\r\n                \r\nI'm trying to implement a fast primality test for Rust's ```\nu32```\n and ```\nu64```\n datatypes. As part of it, I need to compute ```\n(n*n)%d```\n where ```\nn```\n and ```\nd```\n are ```\nu32```\n (or ```\nu64```\n, respectively).\n\nWhile the result can easily fit in the datatype, I'm at a loss for how to compute this. As far as I know there is no processor primitive for this.\n\nFor ```\nu32```\n we can fake it -- cast up to ```\nu64```\n, so that the product won't overflow, then take the modulus, then cast back down to ```\nu32```\n, knowing this won't overflow. However since I don't have a ```\nu128```\n datatype (as far as I know) this trick won't work for ```\nu64```\n.\n\nSo for ```\nu64```\n, the most obvious way I can think of to accomplish this is to somehow compute ```\nx*y```\n to get a pair ```\n(carry, product)```\n of ```\nu64```\n, so we capture the amount of overflow instead of just losing it (or panicking, or whatever).\n\nIs there a way to do this? Or another standard way to solve the problem?\n    ", "Answer": "\r\nRichard Rast pointed out that Wikipedia version works only with 63-bit integers. I extended the code provided by Boiethios to work with full range of 64-bit unsigned integers. \n\n```\nfn mul_mod64(mut x: u64, mut y: u64, m: u64) -> u64 {\n    let msb = 0x8000_0000_0000_0000;\n    let mut d = 0;\n    let mp2 = m >> 1;\n    x %= m;\n    y %= m;\n\n    if m & msb == 0 {\n        for _ in 0..64 {\n            d = if d > mp2 {\n                (d << 1) - m\n            } else {\n                d << 1\n            };\n            if x & msb != 0 {\n                d += y;\n            }\n            if d >= m {\n                d -= m;\n            }\n            x <<= 1;\n        }\n        d\n    } else {\n        for _ in 0..64 {\n            d = if d > mp2 {\n                d.wrapping_shl(1).wrapping_sub(m)\n            } else {\n                // the case d == m && x == 0 is taken care of \n                // after the end of the loop\n                d << 1\n            };\n            if x & msb != 0 {\n                let (mut d1, overflow) = d.overflowing_add(y);\n                if overflow {\n                    d1 = d1.wrapping_sub(m);\n                }\n                d = if d1 >= m { d1 - m } else { d1 };\n            }\n            x <<= 1;\n        }\n        if d >= m { d - m } else { d }\n    }\n}\n\n#[test]\nfn test_mul_mod64() {\n    let half = 1 << 16;\n    let max = std::u64::MAX;\n\n    assert_eq!(mul_mod64(0, 0, 2), 0);\n    assert_eq!(mul_mod64(1, 0, 2), 0);\n    assert_eq!(mul_mod64(0, 1, 2), 0);\n    assert_eq!(mul_mod64(1, 1, 2), 1);\n    assert_eq!(mul_mod64(42, 1, 2), 0);\n    assert_eq!(mul_mod64(1, 42, 2), 0);\n    assert_eq!(mul_mod64(42, 42, 2), 0);\n    assert_eq!(mul_mod64(42, 42, 42), 0);\n    assert_eq!(mul_mod64(42, 42, 41), 1);\n    assert_eq!(mul_mod64(1239876, 2948635, 234897), 163320);\n\n    assert_eq!(mul_mod64(1239876, 2948635, half), 18476);\n    assert_eq!(mul_mod64(half, half, half), 0);\n    assert_eq!(mul_mod64(half+1, half+1, half), 1);\n\n    assert_eq!(mul_mod64(max, max, max), 0);\n    assert_eq!(mul_mod64(1239876, 2948635, max), 3655941769260);\n    assert_eq!(mul_mod64(1239876, max, max), 0);\n    assert_eq!(mul_mod64(1239876, max-1, max), max-1239876);\n    assert_eq!(mul_mod64(max, 2948635, max), 0);\n    assert_eq!(mul_mod64(max-1, 2948635, max), max-2948635);\n    assert_eq!(mul_mod64(max-1, max-1, max), 1);\n    assert_eq!(mul_mod64(2, max/2, max-1), 0);\n}\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Converting arbritrary size strings into arbritrary precision integers (bigints)\r\n                \r\nI'm trying to implement the Solovoy-Strassen primality test for arbritrary large integers. I will also be writing a bignum (cannot use 3rd party implementation as this is an academic project). I have decided on the following structure for the bignum:\n\n```\nstruct {\n  uint64_t *tab;\n  int size; // number of limbs\n  int sign;\n}\n```\n\n\nI will be using base-32 for my digits (hence uint64_t, for partial products, at least I assume they will be partial products). This decision was based on a previous question asked.\n\nI'm at a standstill. I cannot conceive how one can take a string represented as an arbitrary size decimal and convert it into the bignum structure above.\n\nCould someone please enlighten me. Even a smaller example would be nice, such as converting maybe an arbitrary string into octal digits which would be stored in a uint16_t array.\n\nThanks.\n    ", "Answer": "\r\nYou need to do the arithmetic, calling your routines. For example, if the string is \"2013\" (representing 2013 in decimal), do: ```\na=0; a=10*a+2; a=10*a+0; a=10*a+1; a=10*a+3```\n.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Precision and Large Numbers\r\n                \r\nI've written a function in JavaScript to calculate prime numbers:\n\n```\nfunction isDivisible(dividend, divisor) {\n    return dividend % divisor === 0;\n}\n\nfunction isPrime(n) {\n    var factor = 2;\n\n    n = Math.abs(n);\n\n    if (n <= 1) {\n        return true;\n    }\n\n    while (factor < n) {\n        if (isDivisible(n, factor)) {\n            return false;\n        }\n\n        factor += 1;\n    }\n\n    return true;\n}\nfunction getPrimes(max) {\n    var primes = [], i = 1;\n\n    while (i <= max) {\n        if (isPrime(i)) {\n            primes.push(i);\n        }\n\n        i += 1;\n    }\n\n    return primes;\n}\n\nfunction M(p) {\n    return Math.pow(2, p) - 1;\n}\n\nfunction isMersennePrime(p) {\n    var s, m, i;\n\n    s = 4;\n    m = M(p);\n\n    for (i = 0; i < p - 2; i++) {\n        s = (s * s - 2) % m;\n    }\n\n    return s === 0 ? true : false;\n}\n\nfunction findLargestMersennePrime(pMax) {\n    var p, primes = getPrimes(pMax);\n\n    while (primes.length) {\n        p = primes.pop();\n\n        if (isMersennePrime(p)) {\n            return M(p);\n        }\n    }\n\n    return null;\n}\n```\n\n\nThe function, findLargestMersennePrime, takes argument, p, which is used as a seed value for calculating Mersenne Prime numbers, M(p). The program uses the Lucas Lehmer Primality test.\n\nThe test cases I'm using correspond to this table. For any given input, pMax, the program gets a list of prime numbers less than or equal to pMax, and then checks to see if the Mersenne number of p is prime. The test cases pass for the first 7 Mersenne Primes, that is p < 31.\n\nWhen p = 31, 61, 89... the M(p) is prime, but the function isMersennePrime(31) always returns false.\n\nI think this may have something to do with the maximum size of number in JavaScript. I'm running Node 0.5. Is it a bug in my code or a limitation of JavaScript? Is there another language that would be better suited for this problem or a way of making it work in JS?\n    ", "Answer": "\r\nJavascript numbers are standard double precision floating numbers and are good up to 252 - 1. This should be enough for your 8th Mersenne prime (but will not be precise enough for the 9th)\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Using nested for loops to generate primes\r\n                \r\nI created a primality test algorithm, but it doesn't work. \n\nIn essence, these are the steps my program takes: \n\n\nAsk the user for a lower and upper bound in which to look for primes\nAn array, primes, will store my primes\nA nested for loop; the first ```\nfor loop```\n takes every number between the user's lower and upper bounds and then checks if every one of those numbers is divisible by any of the numbers between 2 and the user's upper bound\nIf any number between the lower and upper bounds is divisible by any number between 2 and the user's upper bound, the number is obviously not prime. \nOtherwise, the number is appended to the array primes: \n\n\n```\nlower = int(input(\"Lower Bound: \"))\nupper = int(input(\"Upper Bound: \"))\n\nprint (\"Primes between \" + str(lower) + \" and \" + str(upper) + \": \")\n\nprimes = []\n\nfor i in range (lower, upper): \n  for num in range (2, upper/2):\n    if i % num == 0: \n      print (str(i-(lower-1)) + \". \" + str(i) + \" = No\")\n      break\n  else: \n    primes.append(i)\n\nprint(primes)\n```\n\n\nHowever, the regardless whether a number is prime or not, the function always outputs no, but I have no idea why! \n    ", "Answer": "\r\nFixed it. First, I did the floor division ```\n//```\n operator so it returns an integer. Also, I made a condition that the divisor couldn't be divided by itself. Because otherwise 4 would be a prime of 4. \n\n```\nlower = int(input(\"Lower Bound: \"))\nupper = int(input(\"Upper Bound: \"))\n\nprint (\"Primes between \" + str(lower) + \" and \" + str(upper) + \": \")\n\nprimes = []\n\nfor i in range (lower, upper):\n  for num in range (2, upper//2):\n    if i % num == 0 and num != i: # modification here\n      print (str(i-(lower-1)) + \". \" + str(i) + \" = No\")\n      break\n  else:\n    primes.append(i)\n\nprint(primes)\n```\n\n\n```\nOut[1]: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How can I improve this Pollard's rho algorithm to handle products of semi-large primes?\r\n                \r\nBelow is my implementation of Pollard's rho algorithm for prime factorization:\n\n```\n#include <vector>\n#include <queue>\n\n#include <gmpxx.h>\n\n// Interface to the GMP random number functions.\ngmp_randclass rng(gmp_randinit_default);\n\n// Returns a divisor of N using Pollard's rho method.\nmpz_class getDivisor(const mpz_class &N)\n{\n    mpz_class c = rng.get_z_range(N);\n    mpz_class x = rng.get_z_range(N);\n    mpz_class y = x;\n    mpz_class d = 1;\n    mpz_class z;\n\n    while (d == 1) {\n        x = (x*x + c) % N;\n        y = (y*y + c) % N;\n        y = (y*y + c) % N;\n        z = x - y;\n        mpz_gcd(d.get_mpz_t(), z.get_mpz_t(), N.get_mpz_t());\n    }\n\n    return d;\n}\n\n// Adds the prime factors of N to the given vector.\nvoid factor(const mpz_class &N, std::vector<mpz_class> &factors)\n{\n    std::queue<mpz_class> to_factor;\n    to_factor.push(N);\n\n    while (!to_factor.empty()) {\n        mpz_class n = to_factor.front();\n        to_factor.pop();\n        if (n == 1) {\n            continue; // Trivial factor.\n        } else if (mpz_probab_prime_p(n.get_mpz_t(), 5)) {\n            // n is a prime.\n            factors.push_back(n);\n        } else {\n            // n is a composite, so push its factors on the queue.\n            mpz_class d = getDivisor(n);\n            to_factor.push(d);\n            to_factor.push(n/d);\n        }\n    }\n}\n```\n\n\nIt's essentially a straight translation of the pseudocode on Wikipedia, and relies on GMP for big numbers and for primality testing. The implementation works well and can factor primes such as\n\n```\n1000036317378699858851366323 = 1000014599 * 1000003357 * 1000018361\n```\n\n\nbut will choke on e.g.\n\n```\n1000000000002322140000000048599822299 = 1000000000002301019 * 1000000000000021121\n```\n\n\nMy question is: Is there anything I can do to improve on this, short of switching to a more complex factorization algorithm such as Quadratic sieve?\n\nI know one improvement could be to first do some trial divisions by pre-computed primes, but that would not help for products of a few large primes such as the above.\n\nI'm interested in any tips on improvements to the basic Pollard's rho method to get it to handle larger composites of only a few prime factors. Of course if you find any stupidities in the code above, I'm interested in those as well.\n\nFor full disclosure: This is a homework assignment, so general tips and pointers are better than fully coded solutions. With this very simple approach I already get a passing grade on the assignment, but would of course like to improve.\n\nThanks in advance.\n    ", "Answer": "\r\nYou are using the original version of the rho algorithm due to Pollard. Brent's variant makes two improvements: Floyd's tortoise-and-hare cycle-finding algorithm is replaced by a cycle-finding algorithm developed by Brent, and the gcd calculation is delayed so it is performed only once every hundred or so times through the loop instead of every time. But those changes only get a small improvement, maybe 25% or so, and won't allow you to factor the large numbers you are talking about. Thus, you will need a better algorithm: SQUFOF might work for semi-primes the size that you mention, or you could implement quadratic sieve or the elliptic curve method. I have discussion and implementation of all those algorithms at my blog.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Miller-Rabin test: bug in my code\r\n                \r\nI've written a Miller-Rabin primality test based on the following pseudo code:\n\n```\nInput: n > 2, an odd integer to be tested for primality;\n       k, a parameter that determines the accuracy of the test\nOutput: composite if n is composite, otherwise probably prime\nwrite n − 1 as 2s·d with d odd by factoring powers of 2 from n − 1\nLOOP: repeat k times:\n   pick a randomly in the range [2, n − 1]\n   x ← ad mod n\n   if x = 1 or x = n − 1 then do next LOOP\n   for r = 1 .. s − 1\n      x ← x2 mod n\n      if x = 1 then return composite\n      if x = n − 1 then do next LOOP\n   return composite\nreturn probably prime\n```\n\n\nThe code I have rarely gets past 31 (if I put it in a loop to test numbers from 2 to 100). There must be something wrong but I can't see what it is.\n\n```\nbool isProbablePrime(ulong n, int k) {\n    if (n < 2 || n % 2 == 0) \n        return n == 2;\n\n    ulong d = n - 1;\n    ulong s = 0;\n    while (d % 2 == 0) {\n        d /= 2;\n        s++;\n    }\n    assert(2 ^^ s * d == n - 1); \n    outer:\n    foreach (_; 0 .. k) {\n        ulong a = uniform(2, n);\n        ulong x = (a ^^ d) % n;\n        if (x == 1 || x == n - 1)\n            continue;\n        foreach (__; 1 .. s) {\n            x = (x ^^ 2) % n;\n            if (x == 1) return false;\n            if (x == n - 1) continue outer;\n        }\n        return false;\n    }\n    return true;\n}\n```\n\n\nI've also tried the variant\n\n```\n    ...\n\n    foreach (__; 1 .. s) {\n        x = (x ^^ 2) % n;\n        if (x == 1) return false;\n        if (x == n - 1) continue outer;\n    }\n    if ( x !=  n - 1) return false;  // this is different\n\n    ...\n```\n\n\nI have a different version of the test that works correctly but it uses modpow. I'd like to have a version that stays closer to the pseudo code that's part of the rossetta.org task description.\n\nEdit: Re: overflow problem. I suspected something like that. I'm still puzzled why the Ruby version doesn't have that problem. It probably handles it differently under the hood.\nIf I use BigInt, the code does work, but becomes a lot slower than when I use modpow. So I guess I can't get away from that. It's a pity Phobos doesn't have a modpow built-in, or I must have overlooked it.\n\n```\nulong x = ((BigInt(a) ^^ d) % BigInt(n)).toLong();\n```\n\n    ", "Answer": "\r\nIn this statement\n\n```\nulong x = (a ^^ d) % n;\n```\n\n\nthe quantity ```\n(a ^^ d)```\n is probably overflowing before the mod operation can take place.  The modpow version wouldn't suffer from this problem, since that algorithm avoids the need for arbitrarily large intermediate values.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Generating and Verifying 1024-bit Primes in VHDL\r\n                \r\nI'm implementing RSA encryption and need to generate random 1024-bit primes.\nI can't use ```\nINTEGER```\n signals because of the limit, and so I'm using ```\nSTD_LOGIC_VECTOR```\n and convert it to ```\nUNSIGNED```\n when I need to perform arithmetic operations.\n\nI began by using ```\nUNIFORM```\n to generate 32 random 32-bit numbers which I then copy over into a 1024-bit ```\nSTD_LOGIC_VECTOR```\n.\nI then set the most significant and least significant bits to '1' to ensure it is 1024-bits and odd.\nI then check for primality using an implementation of the Miller Rabin algorithm, which is where my problem lies.\n\nThis is where I generate the random primes:\n```\nfunction GEN_1024_PRIME return STD_LOGIC_VECTOR is\n\n  VARIABLE s1, s2 : POSITIVE;\n  VARIABLE random : REAL;\n  VARIABLE small_random : STD_LOGIC_VECTOR (31 downto 0); \n  VARIABLE large_random : STD_LOGIC_VECTOR (1023 downto 0); \n  VARIABLE prime : STD_LOGIC := '0';\n\nbegin\n\nwhile prime /= '1' loop\n  for I in 0 to 31 loop\n    UNIFORM(s1, s2, random); \n    small_random := STD_LOGIC_VECTOR(to_unsigned(INTEGER(TRUNC(random * REAL(2147483647))), 32));\n    large_random (I*32 + 31 downto I*32) := small_random;\n  end loop;\n      \n  large_random(0) := '1';\n  large_random(1023) := '1';\n  prime := MILLER_RABIN (large_random);\nend loop;\n\nreturn large_random;\n\nend function;\n```\n\nAnd my implementation of Miller Rabin:\n```\nfunction MILLER_RABIN (prime : STD_LOGIC_VECTOR (1023 downto 0)) return STD_LOGIC is\n    \n  VARIABLE t : INTEGER := 4;\n  VARIABLE temp, r, a, x, j, n: UNSIGNED (1023 downto 0); \n  VARIABLE small_random : UNSIGNED (31 downto 0); \n  VARIABLE large_random : UNSIGNED (1023 downto 0); \n  VARIABLE s1, s2 : POSITIVE;\n  VARIABLE random : REAL;\n\nbegin\n    \nn := UNSIGNED(prime);\n    \nif n MOD 2 = 0 OR n MOD 3 = 0 then\n  return '0';\nelse\n  -- calculate n - 1 = 2^s * r such that r is odd\n  r := n - 1;\n  while r MOD 2 = 0 loop\n    r := r / 2;\n  end loop;\n\n  for I in 1 to t loop\n    -- choose random a, 2 <= a <= n-2\n    for I in 0 to 31 loop\n      UNIFORM(s1, s2, random); \n      small_random := to_unsigned(INTEGER(TRUNC(random * REAL(2147483647))), 32);\n      large_random (I*32 + 31 downto I*32) := small_random;\n    end loop;\n\n    a := large_random;\n    temp := r;\n    x := MOD_3(a, temp, n); \n\n    while (temp /= (n - 1) AND x /= 1 AND x /= (n - 1)) loop\n      x := (x * x) MOD n;\n      temp := temp * 2;\n    end loop;\n        \n    if x /= (n - 1) AND temp MOD 2 = 0 then\n      return '0';\n    end if; \n\n  end loop;\n      \n  return '1';\nend if;\n\nend function;\n\nfunction MOD_3 (a, b, c : UNSIGNED (1023 downto 0)) return UNSIGNED is\n\n  VARIABLE x : UNSIGNED (1023 downto 0) := TO_UNSIGNED(1, 1024);\n  VARIABLE y : UNSIGNED (1023 downto 0) := a;\n  VARIABLE b_temp : UNSIGNED (1023 downto 0) := b;\n\nbegin\n\nwhile b_temp > 0 loop\n  if b_temp MOD 2 = 1 then\n    x := (x * y) MOD c;\n  end if; \n  y := (y * y) MOD c;\n  b_temp := b_temp / 2;\nend loop;\nreturn x MOD c;\n\nend function;\n```\n\nI convert the input to ```\nUNSIGNED```\n in order to perform arithmetic operations, which seemed like it would work until I realized there will be instances in which the product of 2 values will be larger than 1024 bits.  For example, in this while loop:\n```\nwhile (temp /= (n - 1) AND x /= 1 AND x /= (n - 1)) loop\n  x := (x * x) MOD n;\n  temp := temp * 2;\nend loop;\n```\n\nThe resultant of ```\ntemp := temp * 2;```\n is 2048 bits.\nI feel like I could get this to work by messing around with the sizes of my ```\nUNSIGNED```\n variables, but I think it is getting messier than it needs to be, so I'm wondering if I am approaching this the wrong way?  Is there a simpler way to generate 1024-bit primes?  Is there another primality test that would be better suited for my problem?\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Prime factor in javascript, why is this case not working?\r\n                \r\nI'm writing a primality checker in in j/s and I was wondering why I'm getting true as a return for when I test 55... It seems to work fine for all the other cases I checked just not 55, can someone tell me where I went wrong?\n\n```\nvar isPrime = function(num){\n\n    if (num === 2){\n        return true;\n    }\n    else if(num%2 === 0){\n        return false;\n    }\n    else{\n        var i = 2;\n        while(i<num){\n\n            if((num/i) % i === 0 ){\n                return false;\n            }\n                i++\n        }\n        return true;\n    }\n\n};\n```\n\n\nThanks in advance and apologies for the noobness!\n    ", "Answer": "\r\n```\n       if((num/i) % i === 0 ){\n            return false;\n       }\n```\n\n\nWhat is this case?\nShouldn't it be\n\n```\n       if(num % i === 0 ){\n            return false;\n       }\n```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "More efficient way to calculate the nth term\r\n                \r\nI have the recurrence relation : (n-2)an = 2(4n-9)an-1 - (15n-38)an-2 - 2(2n-5)an-3 with initial conditions being a0 = 0, a1 = 1 and a2 = 3. I mainly want to calculate an mod n and 2n mod n for all odd composite numbers n from 1 up to say 2.5 million.\nI have written down a code in Python. Using sympy and memoization, I did the computation for an mod n but it took it more than 2 hours. It got worse when I tried it for a2n mod n. One main reason for the slowness is that the recurrence has non-constant coefficients. Are there more efficient codes that I could use? Or would it help to do this on some other language (which preferably should have an in-built function or a function from some package that can be used directly for the primality testing part of the code)?\nThis is my code.\n```\nfrom functools import lru_cache\n\nimport sympy\n\n@lru_cache(maxsize = 1000)\n\ndef f(n):\n\n    if n==0:\n\n        return 0\n\n    elif n==1:\n\n        return 1\n\n    elif n==2:\n\n        return 3\n\n    else:\n\n        return ((2*((4*n)-9)*f(n-1)) - (((15*n)-38)*f(n-2)) - (2*((2*n)-5)*f(n-3)))//(n-2)\n\nfor n in range(1,2500000,2):\n\n    if sympy.isprime(n)==False:\n\n        print(n,f(n)%n)\n\n    if n%10000==1:\n\n        print(n,'check')\n```\n\nThe last 'if' statement is just to check how much progress is being made.\n    ", "Answer": "\r\nFor a somewhat faster approach avoiding any memory issues, you could calculate the an directly in sequence, while always retaining only the last three values in a queue:\n```\nfrom collections import deque\n\na = deque([0, 1, 3])\n\nfor n in range(3, 2_500_000):\n    a.append(((8 * n - 18) * a[2] \n              - (15 * n - 38) * a[1] \n              - (4 * n - 10) * a.popleft()) \n             // (n - 2))\n    if n % 2 == 1:\n        print(n, a[2] % n)\n```\n\n```\n3 2\n5 0\n7 6\n9 7\n11 1\n[...]\n2499989 1\n2499991 921156\n2499993 1210390\n2499995 1460120\n2499997 2499996\n2499999 1195814\n```\n\nThis took about 50 minutes on my PC. Note I avoided the ```\nisprime()```\n call in view of Rodrigo's comment.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "how to iterate a list consisting of long integer value using python?\r\n                \r\nI'm trying to iterate a list consisting of long integer number (more than 10 digits) but while doing it with for-loop it is taking a longer time and the shell-window get stuck during execution.\n\nfor example:\ni have a list as mention below:\n\n```\nmy_list: [7,31,127,2047,8191,131071,524287,838607,536870911,2147483647]\n```\n\n\nand i want to  iterate the above list within a function with lucas lehmer primality test formula and  want to derive the boolean values using the lucas lehmer series where if the number has 0 in its p-2 index than the number from ```\nmy_list```\n should be consider as prime and return 1 (True) else 0 (False)\n\n```\ndef ll_list(p):\n    ll_myList = [4]\n    for i in range(1,p-1):\n          number = ((ll_myList[i-1])**2 -2) % (2**p - 1)\n          ll_myList.append(number)\n    #validating if the lucas-lehmer series (ll_myList) is a prime or not\n    if ll_myList[p-2] == 0:\n     return int(True)\n    else:\n     return int(False)\n```\n\n\nnow when i call the ```\nll_list```\n function the shell window crashes while printing the list for each number mention in the ```\nmy_list```\n\n\n```\nprime_ll = [ll_list(i) for i in my_list]\nprint(prime_ll, '\\n')\n```\n\n\nis there any way to speedup the iteration and at the same time i want to print the list ```\nprime_ll```\n?\n    ", "Answer": "\r\nThis code won't decrease the runtime of your program by much, but I think it should theoretically run faster. I basically translated the pseudo-code on the Wikipedia article you referenced. \n\n```\ndef lucas_lehmer(p):\n    s = 4\n    m = (1 << p) - 1\n    for _ in range(p - 2):\n        s = (s**2 - 2) % m\n    return not s\n```\n\n\nThe ```\nnot s```\n part basically checks if ```\ns```\n is equal to 0. If it is, ```\nnot s```\n will return ```\nTrue```\n; ```\nFalse```\n otherwise. \n\nThe reason why it takes so long to execute this code is that there are two for loops at play: the one within the ```\nlucas_lehmer```\n function, and the one that goes through each element in ```\nmy_list```\n. Of course, this is coupled with the fact that the numbers in your example are large by orders of magnitude. \n\nI also found a link containing other efficient implementations of this algorithm that might be of interest to you. \n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to get iOS CPU Core usage?\r\n                \r\nThere has been a lot of the same question, but yet I cannot find great answers. I've looked at codes from this particular post which gives me usage per core, but it is inaccurate, always stuck at 14% or so even when Instrument tells me one core is under full load (primality test!).\n\nI also read this question which I actually got the code from.\n\nI have little knowledge of ```\nsysctl```\n, which seems to be the key for these kind of things. Can someone explain to me how I could achieve that, code example will be even more appreciated. Thanks!\n\nThis is my current code, it was ran on a separate thread, which I just realized could be a problem, can anyone confirm? (I use NSThread and NSNotificationCenter to send usage information to main thread.)\n\n```\n- (void)updateCPUUsage\n{\n    NSMutableArray* arrayOfCPUUsage = [NSMutableArray array];\n    while ( 1 )\n    {\n        processor_info_array_t _cpuInfo, _prevCPUInfo = nil;\n        mach_msg_type_number_t _numCPUInfo, _numPrevCPUInfo = 0;\n        unsigned _numCPUs;\n        NSLock *_cpuUsageLock;\n\n        int _mib[2U] = { CTL_HW, HW_NCPU };\n        size_t _sizeOfNumCPUs = sizeof(_numCPUs);\n        int _status = sysctl(_mib, 2U, &_numCPUs, &_sizeOfNumCPUs, NULL, 0U);\n        if(_status)\n            _numCPUs = 1;\n\n        _cpuUsageLock = [[NSLock alloc] init];\n\n        natural_t _numCPUsU = 0U;\n        kern_return_t err = host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &_numCPUsU, &_cpuInfo, &_numCPUInfo);\n        if(err == KERN_SUCCESS) {\n            [_cpuUsageLock lock];\n            for(unsigned i = 0U; i < _numCPUs; ++i) {\n                Float32 _inUse, _total;\n                if(_prevCPUInfo) {\n                    _inUse = (\n                              (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER]   - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER])\n                              + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM])\n                              + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE]   - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE])\n                              );\n                    _total = _inUse + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]);\n                } else {\n                    _inUse = _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE];\n                    _total = _inUse + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE];\n                }\n                [arrayOfCPUUsage addObject:@(_inUse / _total)];\n            }\n\n            [_cpuUsageLock unlock];\n\n            if(_prevCPUInfo) {\n                size_t prevCpuInfoSize = sizeof(integer_t) * _numPrevCPUInfo;\n                vm_deallocate(mach_task_self(), (vm_address_t)_prevCPUInfo, prevCpuInfoSize);\n            }\n\n            _prevCPUInfo = _cpuInfo;\n            _numPrevCPUInfo = _numCPUInfo;\n\n            _cpuInfo = nil;\n            _numCPUInfo = 0U;\n        }\n        [[NSNotificationCenter defaultCenter] postNotification:[NSNotification notificationWithName:@\"CPUUsageUpdate\" object:[arrayOfCPUUsage copy]]];\n        [arrayOfCPUUsage removeAllObjects];\n        usleep(1000);\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "AKS- Unable to compile 16 bit integer for primality check\r\n                \r\nI am trying to perform primality check on a 16 bit long number by using the AKS algorithm. I keep getting an error. Can someone please compile my codes and help me about where i am making a mistake. (number example which i want to compile: 1425412525412545.)\n\nThis is my AKSPrime class:\n\n```\nimport java.math.BigInteger;\n\npublic class AKSPrime\n{\npublic static void main(String[] args)\n{\n    AKSPrime p = new AKSPrime();\n\n    TextReader k = new TextReader();\n\n    System.out.print(\"Input number for primality testing: \");\n\n    int i = k.readInt();\n\n    System.out.println(\"Is \" + i + \" prime? \" + p.isPrime(i));\n}\npublic boolean isPrime(int numberToTest)\n{\n    boolean prime = true;\n    boolean flag = true;\n    boolean suitableQFound = false;\n    boolean polynomialsCongruent = true;\n    int b, q;\n    int suitableQ;\n    double power;\n\n    for(int a = 2; a <= Math.sqrt(numberToTest); a++)\n    {\n        b = 2;\n        power = Math.pow(a, b);\n\n        while(!(power > numberToTest))\n        {\n            power = Math.pow(a, b);\n\n            if(power == numberToTest)\n            {\n                prime = false;\n                break;\n            }\n\n            b++;\n        }\n    }\n\n    // Algorithm Line 2\n    int r = 2;\n\n    // Algorithm Line 3\n    while( r < numberToTest && flag && !suitableQFound)\n    {\n        //Algorithm Line 4\n        if(GCD(numberToTest, r) != 1)\n        {\n            return false;\n        }\n\n        //Algorithm Line 5\n        if(nonAKSisPrime(r))\n        {\n            // Algorithm Line 6\n            q = largestPrimeFactor(r - 1);\n            double sqrtR = Math.sqrt(r);\n            double logN = Math.log(numberToTest)/Math.log(2);\n\n            // Algorithm Line 7\n            if( q >= 4*Math.sqrt(r)*Math.log(numberToTest)/Math.log(2) )\n            {\n                // Algorithm Line 8\n                suitableQ = q;\n                suitableQFound = true;\n            }\n        }\n\n        // Algorithm Line 9\n        if(!suitableQFound)\n            r++;\n    }\n\n\n    for(int a = 1; a <= 2 * Math.sqrt(r) * Math.log(numberToTest)/Math.log(2); a++)\n    {\n\n        PolynomialArray poly1 = new PolynomialArray();\n        poly1.binomialExpansionViaSquaring(-1 * a, numberToTest);\n\n        int [] coeffs2 = {1, numberToTest, -1 * a, 0};\n        PolynomialArray poly2 = new PolynomialArray(coeffs2);\n\n        poly1.subtract(poly2);\n\n        polynomialsCongruent = poly1.specialMod(r, numberToTest);\n\n        if(!polynomialsCongruent)\n            prime = false;\n\n    }\n\n    return prime;\n}\n\nprivate boolean nonAKSisPrime(int x)\n{\n    int f = 2;\n    boolean result = true;\n\n    int s = (int)Math.sqrt(x);\n\n    while(f <= s && result)\n    {\n        if(x % f == 0)\n            result = false;\n        f++;\n    }\n\n    return result;\n}\nprivate static int GCD(int u, int v)\n{\n    BigInteger bigU = new BigInteger (Integer.toString (u));\n    BigInteger bigV = new BigInteger (Integer.toString (v));\n    int gcd = bigU.gcd (bigV).intValue ();\n\n    return gcd;\n}\n\nprivate static int largestPrimeFactor(int input)\n{\n    int f = 1;\n    int r = 2;\n    int x = input;\n\n    while(x != 1 && r * r <= input)\n    {\n        while(x % r == 0)\n        {\n            x = x / r;\n            f = r;\n        }\n\n        r++;\n    }\n\n    if(x == 1)\n        return f;\n    else\n        return x;\n}\n}\n```\n\n\nThis is my PolynomialArray class:\n\n```\nimport java.math.BigInteger;\n\n\npublic class PolynomialArray\n{\n// instance variables\nprivate BigInteger [] poly;\nprivate int degree;\nprivate int arraySize;\nprivate static final int DEFAULT_SIZE = 1000000;\n\n\n// constructor\npublic PolynomialArray()\n{\n    arraySize = DEFAULT_SIZE;\n    poly = new BigInteger[arraySize];\n    degree = 0;\n}\n\n// constructor that takes size as input\npublic PolynomialArray(int size)\n{\n    poly = new BigInteger[size];\n    degree = 0;\n    arraySize = size;\n}\n\n// constructor that takes data as input\npublic PolynomialArray(int[] data)\n{\n    poly = new BigInteger[DEFAULT_SIZE];\n\n\n    for(int ctr = 1; ctr < data.length; ctr = ctr + 2)\n    {\n        if(data[ctr] > degree)\n            degree = data[ctr];\n\n        poly[data[ctr]] = new BigIntExtended(data[ctr - 1]);\n    }\n}\n\n// constructor that takes size and data as inputs\npublic PolynomialArray(BigInteger[] data, int deg)\n{\n    poly = data;\n    degree = deg;\n}\n\n\n\n\n\n// This method returns a String representation of the object.\npublic String toString()\n{\n    String outputString = \"\";\n\n    if(degree != 0)\n    {\n        for(int i = 0; i <= degree; i++)\n        {\n            if(poly[i] != null && !poly[i].equals(BigInteger.ZERO))\n            {\n                outputString += \"\" + poly[i] + \"*x^\" + i + \" + \";\n            }\n        }\n    }\n    else\n        outputString += \"0\";\n    return outputString;\n}\n\n// This method adds two PolynomialArrays\npublic void add(PolynomialArray p)\n{\n    if(p.getDegree() > degree)\n    {\n        degree = p.getDegree();\n        BigInteger [] temp = new BigInteger [degree + 1];\n\n        for(int d = 0; d <= degree; d++)\n        {\n            if(!this.getCoeffAtIndex(d).equals(BigIntExtended.ZERO))\n            {\n                if(temp[d] != null)\n                    temp[d] = temp[d].add(this.getCoeffAtIndex(d));\n                else\n                    temp[d] = this.getCoeffAtIndex(d);\n            }\n        }\n\n        for(int c = 0; c <= degree; c++)\n        {\n            if(!p.getCoeffAtIndex(c).equals(BigIntExtended.ZERO))\n            {\n                    temp[c] = p.getCoeffAtIndex(c);\n            }\n        }\n\n        poly = temp;\n    }\n\n    for(int c = 0; c <= p.getDegree(); c++)\n    {\n        if(!p.getCoeffAtIndex(c).equals(BigIntExtended.ZERO))\n        {\n            this.addCoeffAtIndex(c, p.getCoeffAtIndex(c));\n        }\n    }\n\n\n\n}\n\n// This method subtracts p from this polynomial\npublic void subtract(PolynomialArray p)\n{\n\n    p.multiplyByConstant(-1);\n\n    this.add(p);\n}\n\n// This method multiplies the coefficients of this polynomial\n// by a constant c\npublic void multiplyByConstant(int c)\n{\n    for(int p = 0; p <= degree; p++)\n    {\n        if(poly[p] != null)\n            poly[p] = poly[p].multiply(new BigIntExtended(c));\n    }\n\n}\n\n// makes this Polynomial into a polynomial\n// representing (x + a)^n, using an algorithm of\n//  binomial expansion\npublic void binomialExpansion(int a, int n)\n{\n    poly = new BigInteger[n + 1];\n    BigInteger temp = new BigIntExtended(\"0\");\n    BigInteger bigA = new BigIntExtended(a);\n\n\n    for(int k = 0; k <= n; k++)\n    {\n\n        temp = factorial(n);\n        temp = temp.divide(factorial(n-k).multiply(factorial(k)));\n\n        bigA = new BigIntExtended(a);\n        bigA = bigA.pow(k);\n\n        poly[n - k] = temp.multiply( bigA);\n    }\n\n    degree = n;\n}\n\n\n// makes this Polynomial into a polynomial\n// representing (x + a)^n, using an algorithm of\n// successive squaring\npublic void binomialExpansionViaSquaring(int a, int n)\n{\n    poly = new BigInteger[n + 1];\n    BigInteger[] tempPoly = new BigInteger[n + 1];\n    tempPoly[0] = new BigIntExtended(a);\n    tempPoly[1] = new BigIntExtended(1);\n    int tempDegree = 1;\n\n    BigInteger[] newPoly = new BigInteger[n + 1];\n    newPoly[0] = new BigIntExtended(a);\n    newPoly[1] = new BigIntExtended(1);\n    int newDegree = 1;\n\n    String binaryN = Integer.toBinaryString(n);\n\n    char c;\n\n    tempPoly = multiply(tempPoly, tempDegree, tempPoly, tempDegree);\n    tempDegree *= 2;\n\n    for(int index = 1; index < binaryN.length(); index++)\n    {\n        c = binaryN.charAt(index);\n        if(c == '1')\n        {\n            tempPoly = multiply(tempPoly, tempDegree, newPoly, newDegree);\n            tempDegree++;\n        }\n\n        if(index != binaryN.length() - 1)\n        {\n            tempPoly = multiply(tempPoly, tempDegree, tempPoly, tempDegree);\n            tempDegree *= 2;\n        }\n\n    }\n\n    poly = tempPoly;\n    degree = tempDegree;\n}\n\n\n\n// This private helper method multiplies two polynomials\nprivate BigInteger[] multiply(BigInteger[] bi1, int degree1, BigInteger[] bi2, int degree2)\n{\n    BigInteger [] polya = bi1;\n    BigInteger [] polyb = bi2;\n    int newDegree = degree1 + degree2;\n\n    BigInteger [] polytemp = new BigInteger[newDegree + 1];\n\n    for(int c = 0; c <= degree1; c++)\n    {\n        for(int d = 0; d <= degree2; d++)\n        {\n            if(polya[c] != null && polyb[d] != null)\n            {\n                BigInteger t = polya[c].multiply(polyb[d]);\n\n                if(polytemp[c + d] != null)\n                    polytemp[c + d] = polytemp[c + d].add(t);\n                else\n                {\n                    polytemp[c + d] = new BigInteger(\"0\");\n                    polytemp[c + d] = polytemp[c + d].add(t);\n                }\n            }\n        }\n    }\n\n    return polytemp;\n}\n\n\n\n\n\n\n\n\n\n// This method checks to see if this Polynomial\n// is congruent to zero mod (x^r - 1, n)\npublic boolean specialMod(int r, int n)\n{\n    BigInteger total = new BigIntExtended(\"0\");\n    boolean mod = true;\n\n    for(int start = 0; start < r; start++)\n    {\n\n        total = new BigIntExtended(\"0\");\n\n        for(int x = start; x < this.getDegree(); x = x + r)\n        {\n            BigInteger temp = poly[x];\n            total = total.add(temp);\n        }\n\n        BigIntExtended bigN = new BigIntExtended(n);\n\n        if(!total.mod(bigN).equals(BigIntExtended.ZERO))\n            mod = false;\n    }\n\n    return mod;\n}\n\n\n\n// This method multiplies two polynomials together.\n// Its runtime is O(n^2), because it has two nested\n// loops that each run O(n) time.\npublic void multiply(PolynomialArray p)\n{\n    BigInteger [] poly2 = p.getPoly();\n    int newDegree = this.getDegree() + p.getDegree();\n\n    BigInteger [] polytemp = new BigInteger[newDegree + 1];\n\n    for(int c = 0; c < poly.length; c++)\n    {\n        for(int d = 0; d < poly2.length; d++)\n        {\n            BigInteger t = poly[c].multiply(poly[d]);\n            if(polytemp[c + d] != null)\n                polytemp[c + d].add(t);\n            else\n            {\n                polytemp[c + d] = new BigInteger(\"0\");\n                polytemp[c + d].add(t);\n            }\n        }\n    }\n\n    poly = polytemp;\n    degree = newDegree;\n}\n\n\n\n// GETTERS AND SETTERS\n\n// This method returns the array of coefficients\npublic BigInteger[] getPoly()\n{\n    return poly;\n}\n\n// This method returns the degree of the polynomial.\npublic int getDegree()\n{\n    return degree;\n}\n\n// This method returns the coefficient at the given\n// power in the polynomial\npublic BigInteger getCoeffAtIndex(int index)\n{\n    if(poly[index] != null)\n        return poly[index];\n    else\n        return BigInteger.ZERO;\n}\n\n// This method adds a to the coefficient at the given index\npublic void addCoeffAtIndex(int index, BigInteger a)\n{\n    if(poly[index] != null)\n        poly[index] = poly[index].add(a);\n    else\n        poly[index] = a;\n}\n\n// This method computes the factorial of x, and\n// returns it as a BigInteger, due to the tendency\n// of factorial to exceed the capacity of ints\n// extremely rapidly\npublic static BigInteger factorial(int x)\n{\n    if(x == 0)\n        return new BigInteger(\"1\");\n\n    BigInteger result = new BigIntExtended(\"1\");\n    BigIntExtended c;\n\n    for(int i = x; i >= 1; i--)\n    {\n        c = new BigIntExtended(i);\n        result = result.multiply(c);\n    }\n    return result;\n}\n}\n```\n\n\nThis is my BigIntExtended Class:\n\n```\nimport java.math.BigInteger;\n\npublic class BigIntExtended extends BigInteger\n{\n\n// constructor that takes a primitive int,\n// parses it to a String, and calls the\n// superclass's constructor\npublic BigIntExtended(int n)\n{\n    super(new Integer(n).toString());\n}\n\n// constructor that takes a String\npublic BigIntExtended(String s)\n{\n    super(s);\n}\n}\n```\n\n\nMy third class TextReader: \n\n```\nimport java.io.*;\npublic class TextReader\n{\n  private PushbackReader in;   // the input stream\n  private boolean rePrompting; // users should be prompted, but not files\n  public TextReader(  )\n  { \n    in = new PushbackReader( new InputStreamReader( System.in ) );\n   rePrompting = true;\n  }\n  public TextReader( String fileName )\n  { \n    try {\n      in = new PushbackReader(new FileReader(fileName));\n     rePrompting = false;\n   }\n    catch( Exception e ) {\n      System.out.println(\"Can't open input file '\" + fileName + \"', program terminated\");\n      System.exit(1);\n    }\n  }\n  private void error( String where )\n\n  { \n    System.out.println(\"\\n***Failure in \" + where + \" message. Program terminated***\" );\n    System.exit( 1 );\n  }   \n  public boolean readBoolean()\n  {  \n    do \n    {\n      String torf = readWord( );\n      if( torf.equalsIgnoreCase( \"true\" ) ) \n       return true;\n      else if( torf.equalsIgnoreCase( \"false\" ) ) \n        return false;\n      else  \n       System.out.println( torf + \" is not 'true' or 'false'. Try again\"); \n    } while( true );\n  }\n  public String readLine( )\n  {\n    String result = \"\";\n    try {\n      do\n      {\n        int next = in.read( );\n        if( next == '\\r' ) \n          continue;\n        if( next == -1 || next == '\\n' )\n          break;\n        result += (char)next;\n      } while(true); \n    } \n    catch( Exception e ) {\n      error ( \"readLine\" );\n    }\n    return result;\n\n  }\n  public char readChar()\n  {\n    return read( );\n  }\n  public char read( )\n\n  {\n    char result = ' ';\n\n    try {\n      result = (char)in.read();\n      if (result == '\\r') \n       result = (char)in.read();\n    }\n    catch( Exception e ) {\n      System.out.println( \"Failure in call on read method, program terminated.\" );\n      System.exit( 1 );\n    }\n  return result;\n  }\n\n  public void unread( char ch )\n  { \n    try {\n      in.unread((byte)ch);\n    }\n    catch( Exception e )\n    {\n      error( \"unread\" );\n    }\n  }\n\n  public char peek( )\n  {\n    int next = 0;\n    try {\n      next = in.read( );\n    }\n    catch( Exception e ) {\n      error( \"peek\" );\n   }\n\n    if( next != -1 )\n\n      unread( (char)next );\n\n    return (char)next;\n\n  }\n\n  public String readWord()   \n  { \n    String result = \"\";\n    try {\n      int next;\n      do\n      {\n        next = in.read();\n      } while( next != -1 && Character.isWhitespace( (char)next) );\n\n      while (next != -1 && !Character.isWhitespace( (char)next ) ) \n      {\n        result += (char)next;\n\n        next = in.read();\n\n      }\n     while (next != -1 && next != '\\n' && Character.isWhitespace((char)next))\n      {\n        next = in.read();\n      }  \n  if (next != -1 && next != '\\n')\n        unread((char)next);\n      } // end try\n      catch (Exception e) \n      {\n\n       error( \"readWord\" );\n\n      } // end catch\n    return result;\n  }\n  public int readInt()\n  { \n    int result = 0;\n    do // keep on trying until a valid double is entered\n    {\n      try \n      {\n        result = Integer.parseInt(readWord());\n        break;  // result is good, jump out of loop down to return result; \n      } \n      catch (Exception e) \n      {\n        if(rePrompting)\n          System.out.println(\"Invalid integer. Try again.\");\n        else\n        {\n          error( \"readInt\" );\n\n          break;\n        }  \n      }\n    } while( true );\n\n    return result;\n  }\n  public double readDouble()\n\n  {    double result = 0.0;\n    do  // keep on trying until a valid double is entered\n    {\n      try {\n        result = new Double(readWord()).doubleValue();\n        break;  // result is good, jump out of loop down to return result;\n      } \n      catch( Exception e )\n      {\n        if(rePrompting)\n          System.out.println(\"Invalid floating-point number. Try again.\");\n        else\n        {\n          error(\"readDouble\");\n          break;\n        }\n      }\n    } while( true );\n    return result;\n  }\n  public boolean ready( )\n  {\n    boolean result = false;\n    try {\n      result = in.ready();\n    }\n    catch (IOException e) {\n      error ( \"ready\" );\n    }\n    return result;\n  }\n  public static void main( String[] args )\n  {\n     System.out.print( \"Enter password: \" );\n     String pass = \"\";\n     TextReader k = new TextReader( );\n     while( true )\n     {\n       char ch = k.peek();\n       if(ch == '\\n')\n         break;\n       pass += \"\"+ch;\n//       k.unread( '*' );\n     }\n     System.out.println( pass );\n  }\n}\n```\n\n    ", "Answer": "\r\nI am afraid you mean 16 byte integer, not bit. A java ```\nint```\n is 4 byte, 32 bits, a ```\nlong```\n 8 bytes, 64 bits.\n\n```\n1425412525412545```\n might fit in a long, certainly not an int, and maybe you should use ```\nBigInteger```\n on principle, to cover the full 16 bytes.\n\nAs that no longer is a primitive type, a bit more writing is required.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "AKS- Unable to compile 16 bit integer for primality check\r\n                \r\nI am trying to perform primality check on a 16 bit long number by using the AKS algorithm. I keep getting an error. Can someone please compile my codes and help me about where i am making a mistake. (number example which i want to compile: 1425412525412545.)\n\nThis is my AKSPrime class:\n\n```\nimport java.math.BigInteger;\n\npublic class AKSPrime\n{\npublic static void main(String[] args)\n{\n    AKSPrime p = new AKSPrime();\n\n    TextReader k = new TextReader();\n\n    System.out.print(\"Input number for primality testing: \");\n\n    int i = k.readInt();\n\n    System.out.println(\"Is \" + i + \" prime? \" + p.isPrime(i));\n}\npublic boolean isPrime(int numberToTest)\n{\n    boolean prime = true;\n    boolean flag = true;\n    boolean suitableQFound = false;\n    boolean polynomialsCongruent = true;\n    int b, q;\n    int suitableQ;\n    double power;\n\n    for(int a = 2; a <= Math.sqrt(numberToTest); a++)\n    {\n        b = 2;\n        power = Math.pow(a, b);\n\n        while(!(power > numberToTest))\n        {\n            power = Math.pow(a, b);\n\n            if(power == numberToTest)\n            {\n                prime = false;\n                break;\n            }\n\n            b++;\n        }\n    }\n\n    // Algorithm Line 2\n    int r = 2;\n\n    // Algorithm Line 3\n    while( r < numberToTest && flag && !suitableQFound)\n    {\n        //Algorithm Line 4\n        if(GCD(numberToTest, r) != 1)\n        {\n            return false;\n        }\n\n        //Algorithm Line 5\n        if(nonAKSisPrime(r))\n        {\n            // Algorithm Line 6\n            q = largestPrimeFactor(r - 1);\n            double sqrtR = Math.sqrt(r);\n            double logN = Math.log(numberToTest)/Math.log(2);\n\n            // Algorithm Line 7\n            if( q >= 4*Math.sqrt(r)*Math.log(numberToTest)/Math.log(2) )\n            {\n                // Algorithm Line 8\n                suitableQ = q;\n                suitableQFound = true;\n            }\n        }\n\n        // Algorithm Line 9\n        if(!suitableQFound)\n            r++;\n    }\n\n\n    for(int a = 1; a <= 2 * Math.sqrt(r) * Math.log(numberToTest)/Math.log(2); a++)\n    {\n\n        PolynomialArray poly1 = new PolynomialArray();\n        poly1.binomialExpansionViaSquaring(-1 * a, numberToTest);\n\n        int [] coeffs2 = {1, numberToTest, -1 * a, 0};\n        PolynomialArray poly2 = new PolynomialArray(coeffs2);\n\n        poly1.subtract(poly2);\n\n        polynomialsCongruent = poly1.specialMod(r, numberToTest);\n\n        if(!polynomialsCongruent)\n            prime = false;\n\n    }\n\n    return prime;\n}\n\nprivate boolean nonAKSisPrime(int x)\n{\n    int f = 2;\n    boolean result = true;\n\n    int s = (int)Math.sqrt(x);\n\n    while(f <= s && result)\n    {\n        if(x % f == 0)\n            result = false;\n        f++;\n    }\n\n    return result;\n}\nprivate static int GCD(int u, int v)\n{\n    BigInteger bigU = new BigInteger (Integer.toString (u));\n    BigInteger bigV = new BigInteger (Integer.toString (v));\n    int gcd = bigU.gcd (bigV).intValue ();\n\n    return gcd;\n}\n\nprivate static int largestPrimeFactor(int input)\n{\n    int f = 1;\n    int r = 2;\n    int x = input;\n\n    while(x != 1 && r * r <= input)\n    {\n        while(x % r == 0)\n        {\n            x = x / r;\n            f = r;\n        }\n\n        r++;\n    }\n\n    if(x == 1)\n        return f;\n    else\n        return x;\n}\n}\n```\n\n\nThis is my PolynomialArray class:\n\n```\nimport java.math.BigInteger;\n\n\npublic class PolynomialArray\n{\n// instance variables\nprivate BigInteger [] poly;\nprivate int degree;\nprivate int arraySize;\nprivate static final int DEFAULT_SIZE = 1000000;\n\n\n// constructor\npublic PolynomialArray()\n{\n    arraySize = DEFAULT_SIZE;\n    poly = new BigInteger[arraySize];\n    degree = 0;\n}\n\n// constructor that takes size as input\npublic PolynomialArray(int size)\n{\n    poly = new BigInteger[size];\n    degree = 0;\n    arraySize = size;\n}\n\n// constructor that takes data as input\npublic PolynomialArray(int[] data)\n{\n    poly = new BigInteger[DEFAULT_SIZE];\n\n\n    for(int ctr = 1; ctr < data.length; ctr = ctr + 2)\n    {\n        if(data[ctr] > degree)\n            degree = data[ctr];\n\n        poly[data[ctr]] = new BigIntExtended(data[ctr - 1]);\n    }\n}\n\n// constructor that takes size and data as inputs\npublic PolynomialArray(BigInteger[] data, int deg)\n{\n    poly = data;\n    degree = deg;\n}\n\n\n\n\n\n// This method returns a String representation of the object.\npublic String toString()\n{\n    String outputString = \"\";\n\n    if(degree != 0)\n    {\n        for(int i = 0; i <= degree; i++)\n        {\n            if(poly[i] != null && !poly[i].equals(BigInteger.ZERO))\n            {\n                outputString += \"\" + poly[i] + \"*x^\" + i + \" + \";\n            }\n        }\n    }\n    else\n        outputString += \"0\";\n    return outputString;\n}\n\n// This method adds two PolynomialArrays\npublic void add(PolynomialArray p)\n{\n    if(p.getDegree() > degree)\n    {\n        degree = p.getDegree();\n        BigInteger [] temp = new BigInteger [degree + 1];\n\n        for(int d = 0; d <= degree; d++)\n        {\n            if(!this.getCoeffAtIndex(d).equals(BigIntExtended.ZERO))\n            {\n                if(temp[d] != null)\n                    temp[d] = temp[d].add(this.getCoeffAtIndex(d));\n                else\n                    temp[d] = this.getCoeffAtIndex(d);\n            }\n        }\n\n        for(int c = 0; c <= degree; c++)\n        {\n            if(!p.getCoeffAtIndex(c).equals(BigIntExtended.ZERO))\n            {\n                    temp[c] = p.getCoeffAtIndex(c);\n            }\n        }\n\n        poly = temp;\n    }\n\n    for(int c = 0; c <= p.getDegree(); c++)\n    {\n        if(!p.getCoeffAtIndex(c).equals(BigIntExtended.ZERO))\n        {\n            this.addCoeffAtIndex(c, p.getCoeffAtIndex(c));\n        }\n    }\n\n\n\n}\n\n// This method subtracts p from this polynomial\npublic void subtract(PolynomialArray p)\n{\n\n    p.multiplyByConstant(-1);\n\n    this.add(p);\n}\n\n// This method multiplies the coefficients of this polynomial\n// by a constant c\npublic void multiplyByConstant(int c)\n{\n    for(int p = 0; p <= degree; p++)\n    {\n        if(poly[p] != null)\n            poly[p] = poly[p].multiply(new BigIntExtended(c));\n    }\n\n}\n\n// makes this Polynomial into a polynomial\n// representing (x + a)^n, using an algorithm of\n//  binomial expansion\npublic void binomialExpansion(int a, int n)\n{\n    poly = new BigInteger[n + 1];\n    BigInteger temp = new BigIntExtended(\"0\");\n    BigInteger bigA = new BigIntExtended(a);\n\n\n    for(int k = 0; k <= n; k++)\n    {\n\n        temp = factorial(n);\n        temp = temp.divide(factorial(n-k).multiply(factorial(k)));\n\n        bigA = new BigIntExtended(a);\n        bigA = bigA.pow(k);\n\n        poly[n - k] = temp.multiply( bigA);\n    }\n\n    degree = n;\n}\n\n\n// makes this Polynomial into a polynomial\n// representing (x + a)^n, using an algorithm of\n// successive squaring\npublic void binomialExpansionViaSquaring(int a, int n)\n{\n    poly = new BigInteger[n + 1];\n    BigInteger[] tempPoly = new BigInteger[n + 1];\n    tempPoly[0] = new BigIntExtended(a);\n    tempPoly[1] = new BigIntExtended(1);\n    int tempDegree = 1;\n\n    BigInteger[] newPoly = new BigInteger[n + 1];\n    newPoly[0] = new BigIntExtended(a);\n    newPoly[1] = new BigIntExtended(1);\n    int newDegree = 1;\n\n    String binaryN = Integer.toBinaryString(n);\n\n    char c;\n\n    tempPoly = multiply(tempPoly, tempDegree, tempPoly, tempDegree);\n    tempDegree *= 2;\n\n    for(int index = 1; index < binaryN.length(); index++)\n    {\n        c = binaryN.charAt(index);\n        if(c == '1')\n        {\n            tempPoly = multiply(tempPoly, tempDegree, newPoly, newDegree);\n            tempDegree++;\n        }\n\n        if(index != binaryN.length() - 1)\n        {\n            tempPoly = multiply(tempPoly, tempDegree, tempPoly, tempDegree);\n            tempDegree *= 2;\n        }\n\n    }\n\n    poly = tempPoly;\n    degree = tempDegree;\n}\n\n\n\n// This private helper method multiplies two polynomials\nprivate BigInteger[] multiply(BigInteger[] bi1, int degree1, BigInteger[] bi2, int degree2)\n{\n    BigInteger [] polya = bi1;\n    BigInteger [] polyb = bi2;\n    int newDegree = degree1 + degree2;\n\n    BigInteger [] polytemp = new BigInteger[newDegree + 1];\n\n    for(int c = 0; c <= degree1; c++)\n    {\n        for(int d = 0; d <= degree2; d++)\n        {\n            if(polya[c] != null && polyb[d] != null)\n            {\n                BigInteger t = polya[c].multiply(polyb[d]);\n\n                if(polytemp[c + d] != null)\n                    polytemp[c + d] = polytemp[c + d].add(t);\n                else\n                {\n                    polytemp[c + d] = new BigInteger(\"0\");\n                    polytemp[c + d] = polytemp[c + d].add(t);\n                }\n            }\n        }\n    }\n\n    return polytemp;\n}\n\n\n\n\n\n\n\n\n\n// This method checks to see if this Polynomial\n// is congruent to zero mod (x^r - 1, n)\npublic boolean specialMod(int r, int n)\n{\n    BigInteger total = new BigIntExtended(\"0\");\n    boolean mod = true;\n\n    for(int start = 0; start < r; start++)\n    {\n\n        total = new BigIntExtended(\"0\");\n\n        for(int x = start; x < this.getDegree(); x = x + r)\n        {\n            BigInteger temp = poly[x];\n            total = total.add(temp);\n        }\n\n        BigIntExtended bigN = new BigIntExtended(n);\n\n        if(!total.mod(bigN).equals(BigIntExtended.ZERO))\n            mod = false;\n    }\n\n    return mod;\n}\n\n\n\n// This method multiplies two polynomials together.\n// Its runtime is O(n^2), because it has two nested\n// loops that each run O(n) time.\npublic void multiply(PolynomialArray p)\n{\n    BigInteger [] poly2 = p.getPoly();\n    int newDegree = this.getDegree() + p.getDegree();\n\n    BigInteger [] polytemp = new BigInteger[newDegree + 1];\n\n    for(int c = 0; c < poly.length; c++)\n    {\n        for(int d = 0; d < poly2.length; d++)\n        {\n            BigInteger t = poly[c].multiply(poly[d]);\n            if(polytemp[c + d] != null)\n                polytemp[c + d].add(t);\n            else\n            {\n                polytemp[c + d] = new BigInteger(\"0\");\n                polytemp[c + d].add(t);\n            }\n        }\n    }\n\n    poly = polytemp;\n    degree = newDegree;\n}\n\n\n\n// GETTERS AND SETTERS\n\n// This method returns the array of coefficients\npublic BigInteger[] getPoly()\n{\n    return poly;\n}\n\n// This method returns the degree of the polynomial.\npublic int getDegree()\n{\n    return degree;\n}\n\n// This method returns the coefficient at the given\n// power in the polynomial\npublic BigInteger getCoeffAtIndex(int index)\n{\n    if(poly[index] != null)\n        return poly[index];\n    else\n        return BigInteger.ZERO;\n}\n\n// This method adds a to the coefficient at the given index\npublic void addCoeffAtIndex(int index, BigInteger a)\n{\n    if(poly[index] != null)\n        poly[index] = poly[index].add(a);\n    else\n        poly[index] = a;\n}\n\n// This method computes the factorial of x, and\n// returns it as a BigInteger, due to the tendency\n// of factorial to exceed the capacity of ints\n// extremely rapidly\npublic static BigInteger factorial(int x)\n{\n    if(x == 0)\n        return new BigInteger(\"1\");\n\n    BigInteger result = new BigIntExtended(\"1\");\n    BigIntExtended c;\n\n    for(int i = x; i >= 1; i--)\n    {\n        c = new BigIntExtended(i);\n        result = result.multiply(c);\n    }\n    return result;\n}\n}\n```\n\n\nThis is my BigIntExtended Class:\n\n```\nimport java.math.BigInteger;\n\npublic class BigIntExtended extends BigInteger\n{\n\n// constructor that takes a primitive int,\n// parses it to a String, and calls the\n// superclass's constructor\npublic BigIntExtended(int n)\n{\n    super(new Integer(n).toString());\n}\n\n// constructor that takes a String\npublic BigIntExtended(String s)\n{\n    super(s);\n}\n}\n```\n\n\nMy third class TextReader: \n\n```\nimport java.io.*;\npublic class TextReader\n{\n  private PushbackReader in;   // the input stream\n  private boolean rePrompting; // users should be prompted, but not files\n  public TextReader(  )\n  { \n    in = new PushbackReader( new InputStreamReader( System.in ) );\n   rePrompting = true;\n  }\n  public TextReader( String fileName )\n  { \n    try {\n      in = new PushbackReader(new FileReader(fileName));\n     rePrompting = false;\n   }\n    catch( Exception e ) {\n      System.out.println(\"Can't open input file '\" + fileName + \"', program terminated\");\n      System.exit(1);\n    }\n  }\n  private void error( String where )\n\n  { \n    System.out.println(\"\\n***Failure in \" + where + \" message. Program terminated***\" );\n    System.exit( 1 );\n  }   \n  public boolean readBoolean()\n  {  \n    do \n    {\n      String torf = readWord( );\n      if( torf.equalsIgnoreCase( \"true\" ) ) \n       return true;\n      else if( torf.equalsIgnoreCase( \"false\" ) ) \n        return false;\n      else  \n       System.out.println( torf + \" is not 'true' or 'false'. Try again\"); \n    } while( true );\n  }\n  public String readLine( )\n  {\n    String result = \"\";\n    try {\n      do\n      {\n        int next = in.read( );\n        if( next == '\\r' ) \n          continue;\n        if( next == -1 || next == '\\n' )\n          break;\n        result += (char)next;\n      } while(true); \n    } \n    catch( Exception e ) {\n      error ( \"readLine\" );\n    }\n    return result;\n\n  }\n  public char readChar()\n  {\n    return read( );\n  }\n  public char read( )\n\n  {\n    char result = ' ';\n\n    try {\n      result = (char)in.read();\n      if (result == '\\r') \n       result = (char)in.read();\n    }\n    catch( Exception e ) {\n      System.out.println( \"Failure in call on read method, program terminated.\" );\n      System.exit( 1 );\n    }\n  return result;\n  }\n\n  public void unread( char ch )\n  { \n    try {\n      in.unread((byte)ch);\n    }\n    catch( Exception e )\n    {\n      error( \"unread\" );\n    }\n  }\n\n  public char peek( )\n  {\n    int next = 0;\n    try {\n      next = in.read( );\n    }\n    catch( Exception e ) {\n      error( \"peek\" );\n   }\n\n    if( next != -1 )\n\n      unread( (char)next );\n\n    return (char)next;\n\n  }\n\n  public String readWord()   \n  { \n    String result = \"\";\n    try {\n      int next;\n      do\n      {\n        next = in.read();\n      } while( next != -1 && Character.isWhitespace( (char)next) );\n\n      while (next != -1 && !Character.isWhitespace( (char)next ) ) \n      {\n        result += (char)next;\n\n        next = in.read();\n\n      }\n     while (next != -1 && next != '\\n' && Character.isWhitespace((char)next))\n      {\n        next = in.read();\n      }  \n  if (next != -1 && next != '\\n')\n        unread((char)next);\n      } // end try\n      catch (Exception e) \n      {\n\n       error( \"readWord\" );\n\n      } // end catch\n    return result;\n  }\n  public int readInt()\n  { \n    int result = 0;\n    do // keep on trying until a valid double is entered\n    {\n      try \n      {\n        result = Integer.parseInt(readWord());\n        break;  // result is good, jump out of loop down to return result; \n      } \n      catch (Exception e) \n      {\n        if(rePrompting)\n          System.out.println(\"Invalid integer. Try again.\");\n        else\n        {\n          error( \"readInt\" );\n\n          break;\n        }  \n      }\n    } while( true );\n\n    return result;\n  }\n  public double readDouble()\n\n  {    double result = 0.0;\n    do  // keep on trying until a valid double is entered\n    {\n      try {\n        result = new Double(readWord()).doubleValue();\n        break;  // result is good, jump out of loop down to return result;\n      } \n      catch( Exception e )\n      {\n        if(rePrompting)\n          System.out.println(\"Invalid floating-point number. Try again.\");\n        else\n        {\n          error(\"readDouble\");\n          break;\n        }\n      }\n    } while( true );\n    return result;\n  }\n  public boolean ready( )\n  {\n    boolean result = false;\n    try {\n      result = in.ready();\n    }\n    catch (IOException e) {\n      error ( \"ready\" );\n    }\n    return result;\n  }\n  public static void main( String[] args )\n  {\n     System.out.print( \"Enter password: \" );\n     String pass = \"\";\n     TextReader k = new TextReader( );\n     while( true )\n     {\n       char ch = k.peek();\n       if(ch == '\\n')\n         break;\n       pass += \"\"+ch;\n//       k.unread( '*' );\n     }\n     System.out.println( pass );\n  }\n}\n```\n\n    ", "Answer": "\r\nI am afraid you mean 16 byte integer, not bit. A java ```\nint```\n is 4 byte, 32 bits, a ```\nlong```\n 8 bytes, 64 bits.\n\n```\n1425412525412545```\n might fit in a long, certainly not an int, and maybe you should use ```\nBigInteger```\n on principle, to cover the full 16 bytes.\n\nAs that no longer is a primitive type, a bit more writing is required.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Modular exponentiation in Assembly x86 using a large base, exponent and modulus (i.e. 512 bits)\r\n                \r\nI want to generate random RSA primes in Assembly x86. This requires handling large numbers, i.e. 512 bits long. The Miller-Rabin primality test makes use of modular exponentiation, for which the base, exponent and modulus can be the same size as the prime. The problem is that algorithms for calculating the modular exponent still require to take the modulus, which is very big. Which method can be used to calculate this modulus in Assembly?\nCalculations which can already be done are multiplying or dividing a large number by a 32-bit number and adding, subtracting and comparing two big numbers.\nEDIT:\nI found an algorithm to perform division between two large integers. An implementation is given at https://skanthak.homepage.t-online.de/division.html. A more in-depth explanation is given at https://ridiculousfish.com/blog/posts/labor-of-division-episode-iv.html\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to solve stack trace error\r\n                \r\nI am writing a program to get prime numbers by trial division. First it sieves all primes below ```\n2^32```\n, then It test ```\n2^64-1```\n and below for primality.\nWith the code mentioned below I get, while executing:\n\n\n  Initializing... \n  done. \n  710 [main] a 15444 cygwin_exception::open_stackdumpfile: Dumping stack trace to a.exe.stackdump. \n\n\nWhat am I doing wrong?\n\nCode:\n\n```\n#include <math.h>\n#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nbool* SieveOfEratosthenes(unsigned long long number) {\n    bool* prime = new bool[number + 1];\n    for (unsigned long i = 0; i <= number; i++)\n        prime[i] = true;\n    // 0 and 1 are not prime, and we mark because we do not check in the\n    // algorithm\n    //(because will cause bad results, if we divide by 0, we go to hell, and if\n    //we divide one by one, we will mark all numbers a nonprime.\n    prime[0] = false;\n    prime[1] = false;\n    unsigned long squareRoot = sqrt(number);\n    for (unsigned long i = 2; i <= squareRoot; i++) {\n        // If is gray (Is prime)\n        if (prime[i]) {\n            // cout << i << \",\";\n            // We start j by the next multiple of i (that is: 2*i), and we\n            // increase it by i each time until j is less than or equal to\n            // sqrt(number)\n            for (unsigned long j = i * i; j <= number; j += i)\n                prime[j] = false;\n        }\n    }\n    return prime;\n}\n\nint main() {\n    printf(\"Initializing...\");\n    unsigned long number = 4294967295;\n    unsigned long long c;\n    bool* primes;\n    unsigned long* p;\n    p = new unsigned long[203280221];\n    primes = SieveOfEratosthenes(number);\n    for (unsigned long i = 0; i < number; i++) {\n        if (primes[i] == true) {\n            // cout << i << endl;\n            p[c] = i;\n            // cout << p[c] << endl;\n            c++;\n        }\n    }\n    delete[] primes;\n    printf(\"done.\\n\");\n    for (c = 18446744073709551615; c > 1; c -= 2) {\n        unsigned long root = (unsigned long)sqrt(c);\n        unsigned long i = 0;\n        bool flag = true;\n        while (p[i] <= root) {\n            cout << \"DEBUG: Test \" << p[i];\n            if (c % p[i] == 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag == true)\n            cout << c << endl;\n    }\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThe exception most probably is ```\nout of memory```\n.\n\nYou are allocating ```\n4294967295 bool```\n in ```\nSieveOfEratosthenes```\n function. Depending the platform and compiler bool could be 1 byte or 4 byte. With bool size ```\n1 byte```\n the result is 4096Mb allocation (```\n4Gb```\n), if the program is compiled in 32bits an error is certain.\n\nIn main you are allocating other 775Mb for ```\np```\n (assuming ```\nunsigned long```\n size 4 byte)\n\nIf you are compiling with GCC try add the parameter ```\n-m64```\n to compile in 64bits mode, if you are using Visual Studio in the properties of the project change the target to ```\nx64```\n.\n\nYou could change the ```\nbool```\n array to ```\nstd::vector<bool>```\n in most of the implementation of the ```\nSTL```\n are implemented as ```\nbit```\n (in one ```\nunsigned long```\n is saved 32 bool values), this mean that ```\n4294967295 bool```\n would be ```\n511Mb```\n\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why does this miller rabin test implement the use of n-1 instead of -1?\r\n                \r\nWell, i was learning Miller-Rabin Primality test algorithm through this tutorial(video). At 8:28, instead of checking ```\nif pow(a,exp,n)==-1```\nin the last while loop, he used ```\nif pow(a,exp,n)==n-1```\n. Why does it have to be n-1? I did check it by writing it in C++ and turns out, n-1 is the only possible way of getting the right answer(he did also try to explain why but it is just weird to me). Why is this the case? It makes no sense to me, It is supposed to be -1 instead of n-1 and n-1 makes it work but -1 doesn't make it work. I really need someone to clarify this for me. One more thing, i did watch the first video where he explains how the algorithm works so i think i comprehended most of what he said.\n    ", "Answer": "\r\nIt's not supposed to be ```\n-1```\n - the condition is that the power is congruent to -1 in modulo n arithmetic. (```\nA```\n is congruent to ```\nB```\n modulo ```\nN```\n if and only if ```\nA mod N = B mod N```\n.)\n```\npow(a,exp,n)```\n never produces a negative result - ```\na```\n is positive - and in modulo ```\nn```\n arithmetic, ```\nn - 1 = -1 mod n```\n.\nAlso, the behaviour of the ```\n%```\n operator with negative operands in C++ used to be implementation-defined, so ```\n-1 % n```\n is not really an option.\nSo ```\nn-1```\n is mathematically equivalent and portable.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Is using `str` the correct idiom for working with digits in Python\r\n                \r\nI understand that one way to work with the digits of a number in Python is to convert the number to a string, and then use string methods to slice the resulting \"number\" into groups of \"digits\". For example, assuming I have a function ```\nprime```\n that tests primality, I can confirm that an integer n is both a left and right truncatable prime with\n\n```\nall(prime(int(str(n)[:-i])) and prime(int(str(n)[i:])) for i in range(1, len(str(n))))\n```\n\n\nThis method involves first converting n to a string so that it can be sliced, and converting that slice back to an integer so that its primality can be checked. Perhaps it's my history with statically typed languages, or some vague idea that strings are \"expensive\", or experience with languages that include builtin functionality for similar manipulations (like Mathematica's ```\nIntegerDigits```\n and ```\nFromDigits```\n); but I'm left wondering whether this is the right way to go about such tasks.\n\nIs conversion back and forth between stings and numbers the correct — or even only — approach for accessing digits in Python. Are there more efficient approaches?\n    ", "Answer": "\r\nIn your example code, you could get away using ```\ndivmod```\n rather than string slicing the digits. ```\ndivmod(x, y)```\n returns the tuple ```\nx//y, x%y```\n, which for ```\ny```\n values that are ```\n10**i```\n is exactly what you want for the left and right pieces of your number. This isn't necessarily more Pythonic, though it might be a bit faster.\n\n```\nsn = str(n)\nall(prime(int(sn[:i])) and prime(int(sn[i:])) for i in range(1, len(sn))) # original\nall(all(map(prime, divmod(n, 10**i))) for i in range(1, len(sn))) # variant using divmod\n```\n\n\nI think for more general digit operations, using ```\nstr```\n is probably pretty sensible, as doing lots of math on powers of your numerical base is likely to be harder to understand than doing stuff directly on the digits in a string.\n\nWrite code to be read, unless it's really performance sensitive.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Speed up my algorithm for finding the 4 squares that sums up to a given number\r\n                \r\nI wrote this algorithm in JS with the main goal that it will give an answer for 10^750-10^1000 in 2-3 seconds but it solves  10^150 in 2-3 seconds so I am a little far from my goal, the problem is that I sieved through the algorithm couple of times, but nothing I do seems to speed the algorithm significantly.\nI would appreciate if any one could enhance my code or give a new one in JS to reach my goal of solving 10^750-10^1000  in under 3 seconds\nI implemented Michael O. Rabin and Jeffrey Shallit algorithm for finding the 4 squares summing up to given number n and Miller-Rabin for primality test, I think that these are the very best and fast, so why is my algorithm is not fast as \"theoretically could be\" ?!\n\r\n\r\n```\nlet primes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n];\n\nfunction power(x, y, p) {\n  let res = 1n;\n  x %= p;\n  while (y > 0n) {\n    if (y % 2n == 1n)\n      res = (res * x) % p;\n    x = (x * x) % p;\n    y /= 2n;\n  }\n  return res;\n}\n\nfunction millerTest(a, d, n) {\n    let x = power(a, d, n);\n    if (x == 1n || x == n - 1n)\n        return true;\n    while (d != n - 1n) {\n        x = (x * x) % n;\n        d *= 2n;\n        if (x == 1n)\n            return false;\n        if (x == n - 1n)\n            return true;\n    }\n    return false;\n}\n\nfunction isPrime(n) {\n    if (n <= 1n || n == 4n) return false;\n    for (let i = 0; i < primes.length; i++) if (n == primes[i]) return true;\n    let d = n - 1n;\n    while (d % 2n == 0)\n        d /= 2n;\n    for (let i = 0; i < primes.length; i++)\n        if (!millerTest(primes[i], d, n))\n            return false;\n    return true;\n}\n\nfunction abs(a) {\n    if (a < 0n) return -a;\n    return a;\n}\n\nfunction round(a, b) {\n    if (b == 0n) return undefined;\n    if (a % b == 0n) return a / b;\n    let d = a / b;\n    let x = abs(a - (d - 1n) * b);\n    let y = abs(a - d * b);\n    let z = abs(a - (d + 1n) * b);\n    if (x <= y && x <= z) return d - 1n;\n    if (z <= y && z <= x) return d + 1n;\n    return d;\n}\n\nfunction complexIsZero(c) {\n    if (c[0] == 0n && c[1] == 0n) return true;\n    return false;\n}\n\nfunction complexNorm(c) {\n    return c[0] * c[0] + c[1] * c[1];\n}\n\nfunction complexGCD(c1, c2) {\n    if (complexIsZero(c1)) return c2;\n    if (complexIsZero(c2)) return c1;\n    let u = c1[0];\n    let v = c1[1];\n    let x = c2[0];\n    let y = c2[1];\n    let a = round(u * x + v * y, x * x + y * y);\n    let b = round(v * x - u * y, x * x + y * y);\n    while (!complexIsZero(c2)) {\n        c1 = c2;\n        c2 = [u - a * x + b * y, v - b * x - a * y];\n        u = c1[0];\n        v = c1[1];\n        x = c2[0];\n        y = c2[1];\n        a = round(u * x + v * y, x * x + y * y);\n        b = round(v * x - u * y, x * x + y * y);\n    }\n    return c1;\n}\n\nfunction twoSquares(p) {\n    if (isPrime(p) && p % 4n == 1n) {\n        for (let i = 0; i < primes.length; i++)\n            if (power(primes[i], (p - 1n) / 2n, p) == p - 1n) {\n                let x = power(primes[i], (p - 1n) / 4n, p);\n                return complexGCD([x, 1n], [p, 0n]);\n            }\n    }\n    return [0n, 0n];\n}\n\nfunction randomInteger(n) {\n    let str = n + \"\";\n    if (str.length <= 8) return BigInt(Math.floor(Math.random() * parseInt(n)));\n    let res = \"\";\n    for (let i = 0; i < str.length - 1; i++)\n        res += Math.floor(Math.random() * 10);\n    return BigInt(res);\n}\n\nfunction log2(n) {\n    let count = 3;\n    while (n > 1n) {\n        n /= 8n;\n        count++;\n    }\n    return count;\n}\n\nfunction isPrimeSimple(n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    for (let i = 2; i * i <= n; i++) if (n % i == 0) return false;\n    return true;\n}\n\nfunction nextPrime(n) {\n    n++;\n    while (!isPrimeSimple(n)) n++;\n    return n;\n}\n\nfunction primorial(n) {\n    let M = 1n;\n    let prime = 2;\n    let logN = log2(n);\n    for (let i = 2; i <= logN; i++) {\n        M *= BigInt(prime);\n        prime = nextPrime(prime);\n    }\n    return M;\n}\n\n//Quaternion Class\nfunction QIsZero(q1) {\n    for (let i = 0; i < q1.length; i++) q1[i] = BigInt(q1[i]);\n    for (let i = 0; i < q1.length; i++) if (q1[i] != 0n) return false;\n    return true;\n}\n\nfunction Qadd(q1, q2) {\n    for (let i = 0; i < q1.length; i++) q1[i] = BigInt(q1[i]);\n    for (let i = 0; i < q2.length; i++) q2[i] = BigInt(q2[i]);\n    let a1 = q1[0];\n    let b1 = q1[1];\n    let c1 = q1[2];\n    let d1 = q1[3];\n    let a2 = q2[0];\n    let b2 = q2[1];\n    let c2 = q2[2];\n    let d2 = q2[3];\n    return [a1 + a2, b1 + b2, c1 + c2, d1 + d2];\n}\n\nfunction Qsub(q1, q2) {\n    for (let i = 0; i < q1.length; i++) q1[i] = BigInt(q1[i]);\n    for (let i = 0; i < q2.length; i++) q2[i] = BigInt(q2[i]);\n    let a1 = q1[0];\n    let b1 = q1[1];\n    let c1 = q1[2];\n    let d1 = q1[3];\n    let a2 = q2[0];\n    let b2 = q2[1];\n    let c2 = q2[2];\n    let d2 = q2[3];\n    return [a1 - a2, b1 - b2, c1 - c2, d1 - d2];\n}\n\nfunction Qconj(q1) {\n    for (let i = 0; i < q1.length; i++) q1[i] = BigInt(q1[i]);\n    let a1 = q1[0];\n    let b1 = q1[1];\n    let c1 = q1[2];\n    let d1 = q1[3];\n    return [a1, -b1, -c1, -d1];\n}\n\nfunction Qmul(q1, q2) {\n    for (let i = 0; i < q1.length; i++) q1[i] = BigInt(q1[i]);\n    for (let i = 0; i < q2.length; i++) q2[i] = BigInt(q2[i]);\n    let a1 = q1[0];\n    let b1 = q1[1];\n    let c1 = q1[2];\n    let d1 = q1[3];\n    let a2 = q2[0];\n    let b2 = q2[1];\n    let c2 = q2[2];\n    let d2 = q2[3];\n    let x = a1 * a2 - b1 * b2 - c1 * c2 - d1 * d2;\n    let y = a1 * b2 + b1 * a2 + c1 * d2 - d1 * c2;\n    let z = a1 * c2 - b1 * d2 + c1 * a2 + d1 * b2;\n    let w = a1 * d2 + b1 * c2 - c1 * b2 + d1 * a2;\n    return [x, y, z, w];\n}\n\nfunction Qnorm(q1) {\n    for (let i = 0; i < q1.length; i++) q1[i] = BigInt(q1[i]);\n    let a1 = q1[0];\n    let b1 = q1[1];\n    let c1 = q1[2];\n    let d1 = q1[3];\n    return a1 * a1 + b1 * b1 + c1 * c1 + d1 * d1;\n}\n\nfunction Qdiv(q, r) {\n    let q0 = q[0];\n    let q1 = q[1];\n    let q2 = q[2];\n    let q3 = q[3];\n    let r0 = r[0];\n    let r1 = r[1];\n    let r2 = r[2];\n    let r3 = r[3];\n    let t0 = r0 * q0 + r1 * q1 + r2 * q2 + r3 * q3;\n    let t1 = r0 * q1 - r1 * q0 - r2 * q3 + r3 * q2;\n    let t2 = r0 * q2 + r1 * q3 - r2 * q0 - r3 * q1;\n    let t3 = r0 * q3 - r1 * q2 + r2 * q1 - r3 * q0;\n    let norm = Qnorm(r);\n    let a = round(t0, norm);\n    let b = round(t1, norm);\n    let c = round(t2, norm);\n    let d = round(t3, norm);\n    return [a, b, c, d];\n}\n\nfunction gcdQuaternion(a, b) {\n    if (QIsZero(a)) return b;\n    if (QIsZero(b)) return a;\n    let c, t;\n    while (!QIsZero(b)) {\n        c = Qdiv(a, b);\n        t = Qsub(a, Qmul(b, c));\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nfunction fourSquares(n) {\n    if (n < 0n) return undefined;\n    if (n == 0n) return [0n, 0n, 0n, 0n];\n    let d = 0n;\n    while (n % 2n == 0) {\n        n /= 2n;\n        d += 1n;\n    }\n    let e = (-4n) ** (d / 4n);\n    let f = d % 4n;\n    let M = primorial(n);\n    let k = 1n;\n    let p = M * n * k - 1n;\n    while (!isPrime(p)) {\n        k += 2n;\n        p = M * n * k - 1n;\n    }\n    let AB = twoSquares(p);\n    let A = AB[0];\n    let B = AB[1];\n    let Q = gcdQuaternion([A, B, 1n, 0n], [n, 0n, 0n, 0n]);\n    for (let i = 0; i < Q.length; i++) Q[i] *= e;\n    if (f == 1n) Q = Qmul([1n, 1n, 0n, 0n], Q);\n    if (f == 2n) Q = Qmul([0n, 2n, 0n, 0n], Q);\n    if (f == 3n) Q = Qmul([-2n, 2n, 0n, 0n], Q);\n    return Q;\n}\n\nfunction randomPrime(len) {\n    let str = randomInteger(10n ** BigInt(len));\n    let index = 1;\n    while (!isPrime(BigInt(str.toString() + index))) index += 2;\n    return BigInt(str.toString() + index);\n}\n\nconsole.log(fourSquares(10n ** 150n));```\n\r\n\r\n\r\n\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "why is integer factorization a non-polynomial time?\r\n                \r\nI am just a beginner of computer science. I learned something about running time but I can't be sure what I understood is right. So please help me. \n\nSo integer factorization is currently not a polynomial time problem but primality test is. Assume the number to be checked is n. If we run a program just to decide whether every number from 1 to sqrt(n) can divide n, and if the answer is yes, then store the number. I think this program is polynomial time, isn't it? \n\nOne possible way that I am wrong would be a factorization program should find all primes, instead of the first prime discovered. So maybe this is the reason why. \n\nHowever, in public key cryptography, finding a prime factor of a large number is essential to attack the cryptography. Since usually a large number (public key) is only the product of two primes, finding one prime means finding the other. This should be polynomial time. So why is it difficult or impossible to attack? \n    ", "Answer": "\r\nCasual descriptions of complexity like \"polynomial factoring algorithm\" generally refer to the complexity with respect to the size of the input, not the interpretation of the input. So when people say \"no known polynomial factoring algorithm\", they mean there is no known algorithm for factoring N-bit natural numbers that runs in time polynomial with respect to N. Not polynomial with respect to the number itself, which can be up to 2^N.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "In RSA, how would I choose e so it has nearly 400 digits?\r\n                \r\nYes this is admittedly for an assignment. I've already generated ```\nphi(n)```\n using ```\np```\n and ```\nq```\n using Miller-Rabin, and now I need to generate ```\ne```\n. It's my understanding that it's standard to use 3 or 65537 as ```\ne```\n, but I'm specifically supposed to \"find e – a 398 digit number that is relatively prime with phi(n)\"\n\nMy question is how? It seems like trying to find the factors of huge numbers is the very problem that makes RSA secure, and looping through every 400-digit number and testing for relative primality seems obviously wrong so I feel like I'm misunderstanding something.\n\nThanks for any help\n\n\n\nEdit: \n\nCode I'm currently working with\n\n```\ndef generate_e(r):\n    # r is phi(n)\n    e = long_string()  # uses a string as a seed\n    e = base_10(e)  # converts string to base-10\n    e = e % pow(10, 398)  # make len(e) == 398\n\n    # make e odd\n    if e % 2 == 0:\n        e -= 1\n\n    # iterate over increasing odd numbers until relative prime with phi(n) is found\n    while extended_euclid(e, r) != 1:\n        e += 2\n\n    return e\n```\n\n    ", "Answer": "", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "How to implement Frobenius pseudoprime algorithm?\r\n                \r\nSomeone told me that the Frobenius pseudoprime algorithm take three times longer to run than the Miller–Rabin primality test but has seven times the resolution. So then if one where to run the former ten times and the later thirty times, both would take the same time to run, but the former would provide about 233% more analyse power. In trying to find out how to perform the test, the following paper was discovered with the algorithm at the end:\n\nA Simple Derivation for the Frobenius Pseudoprime Test\n\nThere is an attempt at implementing the algorithm below, but the program never prints out a number. Could someone who is more familiar with the math notation or algorithm verify what is going on please?\n\nEdit 1: The code below has corrections added, but the implementation for ```\ncompute_wm_wm1```\n is missing. Could someone explain the recursive definition from an algorithmic standpoint? It is not \"clicking\" for me.\n\nEdit 2: The erroneous code has been removed, and an implementation of the ```\ncompute_wm_wm1```\n function has been added below. It appears to work but may require further optimization to be practical.\n\n```\nfrom random import SystemRandom\nfrom fractions import gcd\nrandom = SystemRandom().randrange\n\ndef find_prime_number(bits, test):\n    number = random((1 << bits - 1) + 1, 1 << bits, 2)\n    while True:\n        for _ in range(test):\n            if not frobenius_pseudoprime(number):\n                break\n        else:\n            return number\n        number += 2\n\ndef frobenius_pseudoprime(integer):\n    assert integer & 1 and integer >= 3\n    a, b, d = choose_ab(integer)\n    w1 = (a ** 2 * extended_gcd(b, integer)[0] - 2) % integer\n    m = (integer - jacobi_symbol(d, integer)) >> 1\n    wm, wm1 = compute_wm_wm1(w1, m, integer)\n    if w1 * wm != 2 * wm1 % integer:\n        return False\n    b = pow(b, (integer - 1) >> 1, integer)\n    return b * wm % integer == 2\n\ndef choose_ab(integer):\n    a, b = random(1, integer), random(1, integer)\n    d = a ** 2 - 4 * b\n    while is_square(d) or gcd(2 * d * a * b, integer) != 1:\n        a, b = random(1, integer), random(1, integer)\n        d = a ** 2 - 4 * b\n    return a, b, d\n\ndef is_square(integer):\n    if integer < 0:\n        return False\n    if integer < 2:\n        return True\n    x = integer >> 1\n    seen = set([x])\n    while x * x != integer:\n        x = (x + integer // x) >> 1\n        if x in seen:\n            return False\n        seen.add(x)\n    return True\n\ndef extended_gcd(n, d):\n    x1, x2, y1, y2 = 0, 1, 1, 0\n    while d:\n        n, (q, d) = d, divmod(n, d)\n        x1, x2, y1, y2 = x2 - q * x1, x1, y2 - q * y1, y1\n    return x2, y2\n\ndef jacobi_symbol(n, d):\n    j = 1\n    while n:\n        while not n & 1:\n            n >>= 1\n            if d & 7 in {3, 5}:\n                j = -j\n        n, d = d, n\n        if n & 3 == 3 == d & 3:\n            j = -j\n        n %= d\n    return j if d == 1 else 0\n\ndef compute_wm_wm1(w1, m, n):\n    a, b = 2, w1\n    for shift in range(m.bit_length() - 1, -1, -1):\n        if m >> shift & 1:\n            a, b = (a * b - w1) % n, (b * b - 2) % n\n        else:\n            a, b = (a * a - 2) % n, (a * b - w1) % n\n    return a, b\n\nprint('Probably prime:\\n', find_prime_number(300, 10))\n```\n\n    ", "Answer": "\r\nYou seem to have misunderstood the algorithm completely due to not being familiar with the notation.\n```\ndef frobenius_pseudoprime(integer):\n    assert integer & 1 and integer >= 3\n    a, b, d = choose_ab(integer)\n    w1 = (a ** 2 // b - 2) % integer\n```\n\nThat comes from the line\n\nW0 ≡ 2 (mod n) and W1 ≡ a2b−1 − 2 (mod n)\n\nBut the b-1 doesn't mean ```\n1/b```\n here, but the modular inverse of ```\nb```\n modulo ```\nn```\n, i.e. an integer ```\nc```\n with ```\nb·c ≡ 1 (mod n)```\n. You can most easily find such a ```\nc```\n by continued fraction expansion of ```\nb/n```\n or, equivalently, but with slightly more computation, by the extended Euclidean algorithm. Since you're probably not familiar with continued fractions, I recommend the latter.\n```\n    m = (integer - d // integer) // 2\n```\n\ncomes from\n\nn − (∆/n) = 2m\n\nand misunderstands the Jacobi symbol as a fraction/division (admittedly, I have displayed it here even more like a fraction, but since the site doesn't support LaTeX rendering, we'll have to make do).\nThe Jacobi symbol is a generalisation of the Legendre symbol - denoted identically - which indicates whether a number is a quadratic residue modulo an odd prime (if ```\nn```\n is a quadratic residue modulo ```\np```\n, i.e. there is a ```\nk```\n with ```\nk^2 ≡ n (mod p)```\n and ```\nn```\n is not a multiple of ```\np```\n, then ```\n(n/p) = 1```\n, if ```\nn```\n is a multiple of ```\np```\n, then ```\n(n/p) = 0```\n, otherwise ```\n(n/p) = -1```\n). The Jacobi symbol lifts the restriction that the 'denominator' be an odd prime and allows arbitrary odd numbers as 'denominators'. Its value is the product of the Legendre symbols with the same 'numerator' for all primes dividing ```\nn```\n (according to multiplicity).  More on that, and how to compute Jacobi symbols efficiently in the linked article.\nThe line should correctly read\n```\nm = (integer - jacobi_symbol(d,integer)) // 2\n```\n\nThe following lines I completely fail to understand, logically, here should follow the calculation of\nWm and Wm+1 using the recursion\n\nW2j ≡ Wj2 − 2 (mod n)\nW2j+1 ≡ WjWj+1 − W1 (mod n)\n\nAn efficient method of using that recursion to compute the required values is given around formula (11) of the PDF.\n```\n    w_m0 = w1 * 2 // m % integer\n    w_m1 = w1 * 2 // (m + 1) % integer\n    w_m2 = (w_m0 * w_m1 - w1) % integer\n```\n\nThe remainder of the function is almost correct, except of course that it now gets the wrong data due to earlier misunderstandings.\n```\n    if w1 * w_m0 != 2 * w_m2:\n```\n\nThe (in)equality here should be modulo ```\ninteger```\n, namely ```\nif (w1*w_m0 - 2*w_m2) % integer != 0```\n.\n```\n        return False\n    b = pow(b, (integer - 1) // 2, integer)\n    return b * w_m0 % integer == 2\n```\n\nNote, however, that if ```\nn```\n is a prime, then\n```\nb^((n-1)/2) ≡ (b/n) (mod n)\n```\n\nwhere ```\n(b/n)```\n is the Legendre (or Jacobi) symbol (for prime 'denominators', the Jacobi symbol is the Legendre symbol), hence ```\nb^((n-1)/2) ≡ ±1 (mod n)```\n. So you could use that as an extra check, if Wm is not 2 or ```\nn-2```\n, ```\nn```\n can't be prime, nor can it be if ```\nb^((n-1)/2) (mod n)```\n is not 1 or ```\nn-1```\n.\nProbably computing ```\nb^((n-1)/2) (mod n)```\n first and checking whether that's 1 or ```\nn-1```\n is a good idea, since if that check fails (that is the Euler pseudoprime test, by the way) you don't need the other, no less expensive, computations anymore, and if it succeeds, it's very likely that you need to compute it anyway.\nRegarding the corrections, they seem correct, except for one that made a glitch I previously overlooked possibly worse:\n```\nif w1 * wm != 2 * wm1 % integer:\n```\n\nThat applies the modulus only to ```\n2 * wm1```\n.\nConcerning the recursion for the Wj, I think it is best to explain with a working implementation, first in toto for easy copy and paste:\n```\ndef compute_wm_wm1(w1,m,n):\n    a, b = 2, w1\n    bits = int(log(m,2)) - 2\n    if bits < 0:\n        bits = 0\n    mask = 1 << bits\n    while mask <= m:\n        mask <<= 1\n    mask >>= 1\n    while mask > 0:\n        if (mask & m) != 0:\n            a, b = (a*b-w1)%n, (b*b-2)%n\n        else:\n            a, b = (a*a-2)%n, (a*b-w1)%n\n        mask >>= 1\n    return a, b\n```\n\nThen with explanations in between:\n```\ndef compute_wm_wm1(w1,m,n):\n```\n\nWe need the value of W1, the index of the desired number, and the number by which to take the modulus as input. The value W0 is always 2, so we don't need that as a parameter.\nCall it as\n```\nwm, wm1 = compute_wm_wm1(w1,m,integer)\n```\n\nin ```\nfrobenius_pseudoprime```\n (aside: not a good name, most of the numbers returning ```\nTrue```\n are real primes).\n```\n    a, b = 2, w1\n```\n\nWe initialise ```\na```\n and ```\nb```\n to W0 and W1 respectively. At each point, ```\na```\n holds the value of Wj and ```\nb```\n the value of Wj+1, where ```\nj```\n is the value of the bits of ```\nm```\n so far consumed. For example, with ```\nm = 13```\n, the values of ```\nj```\n, ```\na```\n and ```\nb```\n develop as follows:\n```\nconsumed remaining  j    a    b\n           1101     0   w_0  w_1\n   1        101     1   w_1  w_2\n   11        01     3   w_3  w_4\n   110        1     6   w_6  w_7\n   1101            13  w_13  w_14\n```\n\nThe bits are consumed left-to-right, so we have to find the first set bit of ```\nm```\n and place our 'pointer' right before it\n```\n    bits = int(log(m,2)) - 2\n    if bits < 0:\n        bits = 0\n    mask = 1 << bits\n```\n\nI subtracted a bit from the computed logarithm just to be entirely sure that we don't get fooled by a floating point error (by the way, using ```\nlog```\n limits you to numbers of at most 1024 bits, about 308 decimal digits; if you want to treat larger numbers, you have to find the base-2 logarithm of ```\nm```\n in a different way, using ```\nlog```\n was the simplest way, and it's just a proof of concept, so I used that here).\n```\n    while mask <= m:\n        mask <<= 1\n```\n\nShift the mask until it's greater than ```\nm```\n,so the set bit points just before ```\nm```\n's first set bit. Then shift one position back, so we point at the bit.\n```\n    mask >>= 1\n    while mask > 0:\n        if (mask & m) != 0:\n            a, b = (a*b-w1)%n, (b*b-2)%n\n```\n\nIf the next bit is set, the value of the initial portion of consumed bits of ```\nm```\n goes from ```\nj```\n to ```\n2*j+1```\n, so the next values of the W sequence we need are W2j+1 for ```\na```\n and W2j+2 for ```\nb```\n. By the above recursion formula,\n```\nW_{2j+1} = W_j * W_{j+1} - W_1 (mod n)\nW_{2j+2} = W_{j+1}^2 - 2 (mod n)\n```\n\nSince ```\na```\n was Wj and ```\nb```\n was Wj+1, ```\na```\n becomes ```\n(a*b - W_1) % n```\n and ```\nb```\n becomes ```\n(b * b - 2) % n```\n.\n```\n        else:\n            a, b = (a*a-2)%n, (a*b-w1)%n\n```\n\nIf the next bit is not set, the value of the initial portion of consumed bits of ```\nm```\n goes from ```\nj```\n to ```\n2*j```\n, so ```\na```\n becomes W2j = (Wj2 - 2) (mod n), and ```\nb```\n becomes\nW2j+1 = (Wj * Wj+1 - W1) (mod n).\n```\n        mask >>= 1\n```\n\nMove the pointer to the next bit. When we have moved past the final bit, ```\nmask```\n becomes 0 and the loop ends. The initial portion of consumed bits of ```\nm```\n is now all of ```\nm```\n's bits, so the value is of course ```\nm```\n.\nThen we can\n```\n    return a, b\n```\n\nSome additional remarks:\n```\ndef find_prime_number(bits, test):\n    while True:\n        number = random(3, 1 << bits, 2)\n        for _ in range(test):\n            if not frobenius_pseudoprime(number):\n                break\n        else:\n            return number\n```\n\nPrimes are not too frequent among the larger numbers, so just picking random numbers is likely to take a lot of attempts to hit one. You will probably find a prime (or probable prime) faster if you pick one random number and check candidates in order.\nAnother point is that such a test as the Frobenius test is disproportionally expensive to find that e.g. a multiple of 3 is composite. Before using such a test (or a Miller-Rabin test, or a Lucas test, or an Euler test, ...), you should definitely do a bit of trial division to weed out most of the composites and do the work only where it has a fighting chance of being worth it.\nOh, and the ```\nis_square```\n function isn't prepared to deal with arguments less than 2, divide-by-zero errors lurk there,\n```\ndef is_square(integer):\n    if integer < 0:\n        return False\n    if integer < 2:\n        return True\n    x = integer // 2\n```\n\nshould help.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why is this not faster using parallel collections?\r\n                \r\nI just wanted to test the parallel collections a bit and I used the following line of code (in REPL):\n\n```\n(1 to 100000).par.filter(BigInt(_).isProbablePrime(100))\n```\n\n\nagainst:\n\n```\n(1 to 100000).filter(BigInt(_).isProbablePrime(100))\n```\n\n\nBut the parallel version is not faster. In fact it even feels a bit slower (But I haven't really measured that).\n\nHas anyone an explanation for that?\n\nEdit 1: Yes, I do have a multi-core processor\n\nEdit 2: OK, I \"solved\" the problem myself. The implementation of ```\nisProbablePrime```\n seems to be the problem and not the parallel collections. I replaced ```\nisProbablePrime```\n with another function to test for primality and now I get an expected speedup.\n    ", "Answer": "\r\nBoth with sequential and parallel ranges, ```\nfilter```\n will generate a vector data structure - a ```\nVector```\n or a ```\nParVector```\n, respectively.\n\nThis is a known problem with parallel vectors that get generated from range collections - transformer methods (such as ```\nfilter```\n) for parallel vectors do not construct the vector in parallel.\n\nA solution for this that allows efficient parallel construction of vectors has already been developed, but was not yet implemented. I suggest you file a ticket, so that it can be fixed for the next release.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Project Euler #3, infinite loop on factorization\r\n                \r\nSo I'm doing Project Euler because dear gods do I need to practice writing code, and also my math skills are rusty as something very rusty. Thusly; Project Euler. I'm sure most here have already seen or heard of the problem, but I'll put it here just for completeness:\n\nThe prime factors of 13195 are 5, 7, 13 and 29.\nWhat is the largest prime factor of the number 600851475143 ?\n\nFor this, I've written two functions:\n\n```\nfrom math import sqrt\n\ndef isprime(n):\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    for x in range(3, round(sqrt(n))+1, 2):\n        if n % x == 0:\n            return False\n    else:\n        return True\n```\n\n\nThis just checks any fed number for primality. It's working as intended (as far as I know), but now that I've said that I grow unsure. Anyway, it checks for special cases first: 1 (never prime), 2 (prime) or if it's divisible by 2 (not prime). If none of the special cases happen, it runs a general primality test. \n\nThis is my factorization code:\n\n```\ndef factorization(n):\n   factor = 2\n   x = 3\n   while True:\n       if n % x == 0:\n           if isprime(x):\n               factor = x\n               n = n // x\n               if n == 1:\n                   return factor\n           else:\n               return factor\n       x += 2\n```\n\n\nAnd this is definitely not working as intended. It is, sadly, working for the particular value of the Project Euler problem, but it doesn't work for, say, 100. I'm unsure what I need to do to fix this: what happens is that if it's a number like 100, it will correctly find the first 5 (2*2*5), but after that will loop around and set x = 7, which will make the entire thing loop infinitely because the answer is 2*2*5*5. Would recursion help here? I tried it, but it didn't get any prettier (it would still go into an endless loop for some numbers). I'm unsure how to solve this now.\n    ", "Answer": "\r\nYou're on a good track, but you need to take account of the possibility of repeating factors.  You can do that with something like this:\n\n```\nfactors = []\n\nwhile num % 2 == 0:\n  factors.append(2)\n  num /= 2\n```\n\n\nThe idea here being that you're going to continue adding 2's to the factor list until the number you're testing becomes odd.  You can use similar logic for other factors as well to enhance your factorization method.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "Why is Python Printing out multiple values here?\r\n                \r\nI am writing this function to test the primality of numbers, I know that it is not the best code but I would wish it prints out Not prime when a number is not prime and Is prime when a number is prime. The problem is that it prints out Not prime then Is prime for numbers that are not prime...\nFor example this code:\n\n```\ndef isPrime(n):\n  for i in range(2, n):\n    if n%i==0:\n        print \"Not Prime!\"\n        break\n  print \"Is Prime\"\n\nisPrime(5)\nisPrime(18)\nisPrime(11)\n```\n\n\nPrints out.\n\n```\nIs Prime\nNot Prime!\nIs Prime\nIs Prime\n```\n\n\nHelp me out, What should I do? I am a beginner.\n    ", "Answer": "\r\nHere is a fix (python 3)\n\n```\n\ndef isPrime(n):\n  prime = True\n  for i in range(2, n):\n    if n%i==0:\n        print(\"Not Prime!\")\n        prime = False\n        break\n  if prime:\n      print(\"Is Prime\") \n\nisPrime(5)\nisPrime(18)\nisPrime(11)\n```\n\n\nThe problem in the code you posted is that the last ```\nprint```\n is always executed.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
{"Question": "A console app with Biginteger calculation freezes\r\n                \r\nIssue\n\nA console app with Biginteger calculation freezes\n\nDetails\n\nI'm developing a console application in C# which tests whether very big numbers (10 to the power of several tens to hundreds) are prime. Since default integer types can deal with numbers only up to 10^19 (```\nlong```\n, ```\nulong```\n), I'm using ```\nBitInteger```\n class. But when I run the app in the debug mode in Visual Studio, the app freezes.\n\n```\n    static void Main(string[] args)\n    {\n        int exp = 100;\n        var bi = BigInteger.Pow(10, exp);\n        var sw = new Stopwatch();\n        sw.Start();\n        for (int i = 0; i < 1000; i++)\n        {\n            bi++;\n            Console.WriteLine($\"{i}th try : {bi} ({sw.Elapsed.ToString(\"mm\\\\:ss\\\\.ff\")})\");\n\n            bool b = IsPrime(bi);\n            if (b)\n            {\n                Console.WriteLine($\"{bi} is a prime number\");\n            }\n\n            //GC.Collect();\n        }\n        sw.Stop();\n\n        Console.Read();\n    }\n\n    static private bool IsPrime(BigInteger n)\n    {\n        if (n <= 1)\n            return false;\n        else if (n <= 3)\n            return true;\n        else if (n % 2 == 0 || n % 3 == 0)\n            return false;\n        for (BigInteger i = 5; i * i <= n; i += 6)\n        {\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n        }\n\n        return true;\n\n    }\n```\n\n\nWhether the program freezes depends on the variable ```\nexp```\n. I tested several values of ```\nexp```\n.\n\n\n(the values of ```\nexp```\n) : (```\ni```\n at which the program froze)\n10 : didn't freeze (the app finished in less than a second\n15 : didn't freeze (however the console window refreshes only every 2 seconds)\n17 : didn't freeze (however the console window refreshes only every 17 seconds)\n20 : 39\n25 : 13\n30 : 37\n50 : 27\n100 : 37\n\n\nIt's weird that ```\ni```\n doesn't monotonically go up as ```\nexp```\n increases. So I ran the program for ```\nexp```\n = 100 three times but got the same results. The numbers seem to be reproducible and reliable. \n\nI know there are algorithms to test primality better than this one but I will try them later. First, I'd like to check the entire behavior of the program.\n\nI googled \"biginteger console freeze c#\" for this issue and found two articles.\n\n\nMillerRabin primality test in C#\nC# BigInteger and int How to save memory?\n\n\nThe first one says \"freeze\" and \"Biginteger\" but the answer wasn't much helpful. The second one referred to saving memory so I thought the issue is about garbage collection. Then I added ```\nGC.Collect()```\n at the end of the ```\nfor```\n loop (the commented out line) but this didn't solve the issue. I got the same result.\n\nHow should I solve this issue?\n\nEnvironment\n\n\nWindows 8\nVisual Studio 2017\nC#\n.NET Framework 4.6.1\n\n    ", "Answer": "\r\nYour algorithm basically says:\n\n\n  are you divisible by 2? what about 3? what about 5? 7? 11? 13? 17? 19?\n\n\netc etc\n\nFor small input values, checking all those permutations is fast. For large input values, it can be fast if the large input value has a small factor (e.g. 2, 3, 5 or 37).\n\nBut if the large input lacks a small factor (either because it is prime, or because its smallest factor is quite large), your algorithm has to do a lot of checking. Basically it has to check one in three (i.e. two out of every six) numbers up to the square root of the input (until it finds a match). For large numbers, this involves a lot of calculations.\n\nIf it is taking too long, you need to code a better / faster ```\nIsPrime```\n algorithm. This answer may be helpful in that regard.\n\nYou could also consider storing a list of some of the known large prime numbers, to enable those numbers to be looked up quickly (e.g. from a database) rather than 'calculated'.\n\nRe:\n\n\n  (however the console window refreshes only every 17 seconds)\n\n\nThis is because some of the inputs are indeed prime - and thus it takes 17 seconds or so to verify that (i.e. check every permutation). It looks to you like the console is refreshing only every 17 seconds, but instead it is calculating for 17 seconds. Then the subsequent ones calculate very quickly (since they aren't prime) - so it looks like they are coming out 'as a batch'.\n    ", "Knowledge_point": "Primality Testing", "Tag": "算法分析"}
