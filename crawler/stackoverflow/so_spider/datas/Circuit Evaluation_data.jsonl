{"Question": "Does JavaScript have \"Short-circuit\" evaluation?\r\n                \r\nI would like to know if JavaScript has \"short-circuit\" evaluation like ```\n&&```\n-operator in C#. If not, I would like to know if there is a workaround that makes sense to adopt.\n    ", "Answer": "\r\nYes, JavaScript has \"short-circuit\" evaluation.\n\n```\nif (true == true || foo.foo){\n    // Passes, no errors because foo isn't defined.\n}\n```\n\n\nLive DEMO\n\n```\nif (false && foo.foo){\n    // Passes, no errors because foo isn't defined.\n}\n```\n\n\nLive DEMO\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is the SQL WHERE clause short-circuit evaluated?\r\n                \r\nAre boolean expressions in SQL WHERE clauses short-circuit evaluated\n?\nFor example:\n```\nSELECT * \nFROM Table t \nWHERE @key IS NULL OR (@key IS NOT NULL AND @key = t.Key) \n```\n\nIf ```\n@key IS NULL```\n evaluates to ```\ntrue```\n, is ```\n@key IS NOT NULL AND @key = t.Key```\n evaluated?\nIf no, why not?\nIf yes, is it guaranteed? Is it part of ANSI SQL or is it database specific?\nIf database specific, SQLServer? Oracle? MySQL?\n    ", "Answer": "\r\nANSI SQL Draft 2003 5WD-01-Framework-2003-09.pdf\n\n6.3.3.3 Rule evaluation order\n[...]\nWhere the precedence is not determined by the Formats or by\nparentheses, effective evaluation of expressions is generally\nperformed from left to right. However, it is\nimplementation-dependent whether expressions are actually evaluated left to right, particularly when operands or operators might\ncause conditions to be raised or if the results of the expressions\ncan be determined without completely evaluating all parts of the\nexpression.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "if statement - short circuit evaluation vs readability\r\n                \r\nSometimes, an ```\nif```\n statement can be rather complicated or long, so for the sake of readability it is better to extract complicated calls before the ```\nif```\n.\n\ne.g. this:\n\n```\nif (SomeComplicatedFunctionCall() || OtherComplicatedFunctionCall())\n{\n    // do stuff\n}\n```\n\n\ninto this\n\n```\nbool b1 = SomeComplicatedFunctionCall();\nbool b2 = OtherComplicatedFunctionCall();\n\nif (b1 || b2)\n{\n    //do stuff\n}\n```\n\n\n(provided example is not that bad, it's just for illustration... imagine other calls with multiple arguments, etc.)\n\nBut with this extraction I lost the short circuit evaluation (SCE).\n\n\nDo I really lose SCE every time? Is there some scenario where the compiler is allowed to \"optimize it\" and still provide SCE?\nAre there ways of keeping the improved readability of the second snippet without losing SCE?\n\n    ", "Answer": "\r\nOne natural solution would look like this:\n\n```\nbool b1 = SomeCondition();\nbool b2 = b1 || SomeOtherCondition();\nbool b3 = b2 || SomeThirdCondition();\n// any other condition\nbool bn = bn_1 || SomeFinalCondition();\n\nif (bn)\n{\n  // do stuff\n}\n```\n\n\nThis has the benefits of being easy to understand, being applicable to all cases and having short circuit behaviour.\n\n\n\nThis was my initial solution: A good pattern in method calls and for-loop bodies is the following:\n\n```\nif (!SomeComplicatedFunctionCall())\n   return; // or continue\n\nif (!SomeOtherComplicatedFunctionCall())\n   return; // or continue\n\n// do stuff\n```\n\n\nOne gets the same nice performance benefits of shortcircuit evaluation, but the code looks more readable.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why would a language NOT use Short-circuit evaluation?\r\n                \r\nWhy would a language NOT use Short-circuit evaluation? Are there any benefits of not using it?\n\nI see that it could lead to some performances issues... is that true? Why?\n\n\n\nRelated question : Benefits of using short-circuit evaluation\n    ", "Answer": "\r\nReasons NOT to use short-circuit evaluation:\n\n\nBecause it will behave differently and produce different results if your functions, property Gets or operator methods have side-effects.  And this may conflict with: A) Language Standards, B) previous versions of your language, or C) the default assumptions of your languages typical users.  These are the reasons that VB has for not short-circuiting.\nBecause you may want the compiler to have the freedom to reorder and prune expressions, operators and sub-expressions as it sees fit, rather than in the order that the user typed them in.  These are the reasons that SQL has for not short-circuiting (or at least not in the way that most developers coming to SQL think it would).  Thus SQL (and some other languages) may short-circuit, but only if it decides to and not necessarily in the order that you implicitly specified.\n\n\nI am assuming here that you are asking about \"automatic, implicit order-specific short-circuiting\", which is what most developers expect from C,C++,C#,Java, etc.  Both VB and SQL have ways to explicitly force order-specific short-circuiting.  However, usually when people ask this question it's a \"Do What I Meant\" question;  that is, they mean \"why doesn't it Do What I Want?\", as in, automatically short-circuit in the order that I wrote it.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation in Go\r\n                \r\nMy understanding of short circuit evaluation is that an expression is only called when needed in an if statement. Does Go follow this?\n\nFor instance, would I get better performance on average from:\n\n```\nif !isValidQueryParams(&queries) || r == nil || len(queries) == 0 {\n    return \"\", fmt.Errorf(\"invalid querystring\")\n}\n```\n\n\n...to this:\n\n```\nif r == nil || len(queries) == 0 || !isValidQueryParams(&queries) {\n    return \"\", fmt.Errorf(\"invalid querystring\")\n}\n```\n\n\n...since ```\nisValidQueryParams```\n is a function with much more overhead than ```\nr == nil```\n or testing the length of a map?\n\ni.e. will the interpreter evaluate r == nil first, see it's true and not bother to evaluate the other conditions?\n\nEDIT: Incorrectly referred to short circuit evaluation as lazy evaluation\n    ", "Answer": "\r\nThank you to Kostix and mkrieger for their answers - they are correct, I'm referring to short circuit evaluation and not lazy evaluation.\n\nGo does implement normal short circuit evaluation, as can be deduced with the following code:\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 0; i < 10; i++ {\n        if testFunc(1) || testFunc(2) {\n            // do nothing\n        }\n    }\n}\n\nfunc testFunc(i int) bool {\n    fmt.Printf(\"function %d called\\n\", i)\n    return true\n}\n```\n\n\n...which will always give:\n\n```\n$ function 1 called\n$ function 1 called\n$ function 1 called\n$ function 1 called\n$ function 1 called\n$ function 1 called\n$ function 1 called\n$ function 1 called\n$ function 1 called\n$ function 1 called\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to avoid short-circuit evaluation on\r\n                \r\nI'm working with Ruby on Rails and would like to validate two different models :\n\n```\nif (model1.valid? && model2.valid?)\n...\nend\n```\n\n\nHowever, \"&&\" operator uses short-circuit evaluation (i.e. it evaluates \"model2.valid?\" only if \"model1.valid?\" is true), which prevents model2.valids to be executed if model1 is not valid.\n\nIs there an equivalent of \"&&\" which would not use short-circuit evaluation? I need the two expressions to be evaluated.\n    ", "Answer": "\r\nTry this:\n```\n[model1, model2].map(&:valid?).all?\n```\n\nIt'll return true if both are valid, and create the errors on both instances.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Any difference between Lazy evaluation and Short-circuit evaluation?\r\n                \r\nFrom Wikipedia:\n\nLazy evaluation is:\n\n\n  In programming language theory, lazy evaluation or call-by-need is\n  an evaluation strategy which delays the evaluation of an expression\n  until its value is needed\n\n\nShort-circuit evaluation is:\n\n\n  Short-circuit evaluation, minimal evaluation, or McCarthy evaluation\n  denotes the semantics of some Boolean operators in some programming\n  languages in which the second argument is only executed or evaluated\n  if the first argument does not suffice to determine the value of the\n  expression\n\n\nSo what's the difference between them for example when I have:\n\n```\nif(false && true && true) {\n    //boo\n} \n```\n\n\nAs far as I know, compiler doesn't execute expressions after ```\nfalse```\n because I have ```\n&&```\n so the whole expression will be ```\nfalse```\n finally. (right?)  \n\nSo is that behavior called Lazy evaluation or Short-circuit evaluation?\n    ", "Answer": "\r\nThe difference is that in case of lazy evaluation an expression is evaluated only when it is needed, while in case of short-circuit evaluation expression evaluation stops right after you know the result. It's sort of orthogonal notions.\n\nLazy evaluation can be applied to any computation (short-circuit scheme usually is used only with bools). It doesn't cut-off useless computation, but delays the whole computation until its result is required.\n\n```\nvariable = bigAndSlowFunc() or evenSlowerFnc()\nif (carry out heavy computations)\n  print \"Here it is: \", variable\nelse\n  print \"As you wish :-)\"\n```\n\n\nIf evaluation is lazy, ```\nvariable```\n will be computed only if we choose to go into the first (```\nthen```\n) branch of ```\nif```\n, otherwise it won't. At the evaluation stage (when we prepare arguments for ```\nprint```\n) short-circuit scheme can be used to decide if we need to call ```\nevenSlowerFnc```\n.\n\nSo in your example, it's short-circuit evaluation since no delay of computation happen.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Java short circuit evaluation\r\n                \r\nI thought Java had short circuit evaluation, yet this line is still throwing a null pointer exception:\n\n```\nif( (perfectAgent != null) && (perfectAgent.getAddress().equals(entry.getKey())) ) {\n```\n\n\nIn this case ```\nperfectAgent```\n is ```\nnull```\n, so I just want the whole expression to return ```\nfalse```\n, but my app is still crashing on this line with a NullPointerException.\n\nEDIT, general response:\n\nSince ```\nperfectAgent```\n is ```\nnull```\n, nothing to the right of the ```\n&&```\n should be executed, as it is impossible for the expression to be true.  More to the point, it is impossible to execute ```\nperfectAgent.getAddress()```\n since ```\nperfectAgent```\n does not contain a valid reference (it being null and all).  I'm trying to use short circuit evaluation to not have to check for null in a seperate statement as that makes the logic more sloppy.\n\nEDIT 2 (or, I'm an idiot):\nYeah, like many things in life you figure out the answer right after announcing to the world that you're a moron.  In this case, I had turned off Eclipse's autobuild while doing something else and not turned it back on, so I was debugging class files that didn't match up with my source.\n    ", "Answer": "\r\nIf ```\nperfectAgent```\n is genuinely null, that code won't throw an exception (at least assuming there aren't weird threading things going on, changing it from non-null to null half way through the expression). I would be utterly shocked if you could produce a short but complete program demonstrating it doing so.\n\nSo yes, your intuition is right - this shouldn't be a problem. Look elsewhere for the cause. I strongly suspect that ```\nperfectAgent```\n isn't actually null, and that you're running into any of the other situations in that code which could cause an exception.\n\nI suggest you try to extract that bit of code out into a short but complete example - if you can do so, I'll eat my metaphorical hat; if not, you'll hopefully find the problem while you attempt the extraction.\n\nWhat makes you think that ```\nperfectAgent```\n really is null? Try inserting this code before it:\n\n```\nif (perfectAgent == null)\n{\n    System.out.println(\"Yup, it's null\");\n}\n```\n\n\nAnother very, very slim possibility is that you've run into a JIT bug - but I highly doubt it. \n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation for SQL query optimisation\r\n                \r\nI want to optimize my query using short circuit evaluation as below: \n\nQuery 1: \n\n```\nSelect emp_id, emp_name \nFrom emp_table \nWhere emp_name = \"xyz\" \nand emp_id >= 50; \n```\n\n\nQuery 2 : \n\n```\nSelect emp_id, emp_name \nFrom emp_table \nWhere emp_name = \"xyz\" \nand (emp_id >= 50 or 1 = 0); \n```\n\n\nWill the addition of ```\nor 1 = 0```\n condition (short circuit evaluation) in query 2 result in optimization?\nHow exactly would the short circuit evaluation work in above example? \n    ", "Answer": "\r\nit won't result in optimization (well,, it could in case there is a bug in the database engine and this would workaround the bug ;)\n\nbut i don't thing this question has anything to do with short circuit evaluation - ```\n0 and ?```\n,  ```\n1 or ?```\n are short circuit evaluated, not ```\n1 = 0```\n,  ```\n0 or ?```\n, ```\n1 and ?```\n nor ```\n? and (? or 1 = 0)```\n\n\nplus the engine should delete ```\nor 1 = 0```\n from your query during compile time (= optimize the query), but i don't know how to inspect the resulting bytecode, so i'm not sure about this...\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation assignment in python?\r\n                \r\nRuby supports this:\n\n```\nname = name || \"default\"\n```\n\n\nIf I try it in python: \n\n```\nname = name or \"default\"\n```\n\n\nInterpreter reports:\n\n```\nNameError: name 'name' is not defined\n```\n\n\nWhat is the equivalent of the short circuit evaluation assignment in python?\n    ", "Answer": "\r\nIf you actually defined ```\nname```\n it'd work:\n\n```\nname = None\nname = name or 'default'\n```\n\n\nThe short-circuiting is independent from actually having to define your variables. Generally, ```\nname```\n has been pulled from somewhere but is an empty (falsy) value:\n\n```\nname = somefunction('name') or 'default'\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Allow for zero-value in short-circuit evaluation\r\n                \r\nShort-circuit evaluation determines if the first value is falsey. If so, return the second value, as follows:\n\n```\nvar x = y || z; // if y is falsey return z\n```\n\n\nIs there a way to disregard zero-values as being falsey when using short-circuit evaluation without resorting to if/else statements or ternary operators?\n    ", "Answer": "\r\nYou could check first if ```\ny```\n is unequal to zero and take the numerical value and get the result of the default of ```\nz```\n for ```\ny```\n.\n\n```\nx = +(y !== 0) && (y || z)\n```\n\n\n\n  How it works:\n\n```\nexpression              y          part result  result  comment\n----------------------  ---------  -----------  ------  ----------------------------\n+(y !== 0) && (y || z)                                  complete expression\n\n+(y !== 0)              0          0            0       result found, omit next part\n                                                        because of falsy value\n\n+(y !== 0)              1          1                    check next part\n1          && (y || z)             y            y       take y, omit default\n\n+(y !== 0)              undefined  1                    check next part \n1          && (y || z)             z            z       take z as default\n```\n\n\n\n\r\n\r\n```\nfunction x(y, z) {\r\n    return +(y !== 0) && (y || z);\r\n}\r\n\r\nconsole.log(x(0, 42));           // 0\r\nconsole.log(x(4, 42));           // 4\r\nconsole.log(x(undefined, 42));   // 42\r\nconsole.log(x(0, null));         // 0\r\nconsole.log(x(4, null));         // 4\r\nconsole.log(x(undefined, null)); // null\r\nconsole.log(x(0, 0));            // 0\r\nconsole.log(x(4, 0));            // 4\r\nconsole.log(x(undefined, 0));    // 0```\n\r\n```\n.as-console-wrapper { max-height: 100% !important; top: 0; }```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation In javascript\r\n                \r\nI am in a need to implement short circuit evaluation logic in my code. And I read some articles http://en.wikipedia.org/wiki/Short-circuit_evaluation, http://www.grauw.nl/blog/entry/510 to understand about it . But they haven't covered in detail and I tried up some examples.\n\nEx:\n\n```\nfunction a() {return true;}\n\nfunction b() {return false;}\n\nfunction c() {return true;}\n```\n\n\nExpression\n\nCase 1) ```\na() && b() && c();```\n\n\nCase 2) ```\na() || b() && c();```\n\n\nCase 3) ```\na() && c() || b();```\n\n\nCase 1:\n\n```\nc()```\n will not be executed.\n\nCase 2:\n\n```\nb()```\n and ```\nc()```\n will not be executed\n\nCase 3:\n\n```\nb()```\n will not be executed.\n\nWhere should we learn about this short-circuit evaluation?\n    ", "Answer": "\r\n\n  Where should we learn about this short-circuit evaluation?\n\n\nThe specification is handy, as is MDN.\n\nBut the short version is:\n\n\nThe left-hand operand to ```\n&&```\n or ```\n||```\n is always evaluated, giving us the left-hand value.\nWith ```\n&&```\n, if the left-hand value is falsey, the right-hand operand is not evaluated; the expression's value is the left-hand value.\nWith ```\n||```\n, if the left-hand value is truthy, the right-hand operand is not evaluated; the expression's value is the left-hand value.\nOtherwise, the right-hand operand is evaluated and the expression's result is its value.\n\n\n\"Falsey\" values are any value that coerces to ```\nfalse```\n when used as a boolean. Those are ```\n0```\n, ```\n\"\"```\n, ```\nNaN```\n, ```\nundefined```\n, ```\nnull```\n, and of course, ```\nfalse```\n.\n\n\"Truthy\" values are any values that aren't falsey.\n\nMore on my blog: JavaScript's Curiously-Powerful OR Operator (```\n||```\n). (I keep meaning to do the ```\n&&```\n version of that...)\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short Circuit evaluation in Pascal\r\n                \r\nI am trying to see how to test short circuit evaluation in Pascal but not sure if doing it correctly. This is what I have so far.\n```\nprogram shortcircuit;\nvar\n   { local variable definition }\n   a : integer;\n   b : integer;\n\nbegin\n   a := 8;\n   b := 0;\n   if( (b <> 0) and (a / b) ) then\n      (* if condition is true then print the following *)\n      writeln('...' )\n\nend.\n```\n\n    ", "Answer": "\r\nIt is unclear what your question is, but you should try to provide a program that actually compiles before posting. This will help you answer your own questions.\nThe first problem you have is that Pascal has no concept of automatically convert to boolean that many C-derived languages do. You must test the inequity with zero explicitly.\nI would also add an ```\nelse```\n clause to print when your test works successfully.\n```\nvar\n   { local variable definition }\n   a : integer;\n   b : integer;\n\nbegin\n   a := 8;\n   b := 0;\n   if( (b <> 0) and ((a / b) <> 0.0) ) then\n      (* if condition is true then print the following *)\n      writeln('fooey' )\n   else writeln('short circuited')\nend.\n```\n\nhttp://tpcg.io/_HUNS7P\nIt is possible, should you make some minor modifications to the LHS of the ```\nand```\n expression, that the compiler will notice you are hard-coding an attempt to divide by zero and complain.\nFinally, Pascal always does short-circuit evaluation by default. You can disable it with a compiler directive, but that is always The Wrong Thing To Do.\nFor your example (avoiding a divide by zero error), the code will do the correct thing by default.\n```\nif (b <> 0) and some_predicate_function( a / b ) then ...\n```\n\nThough if you are just doing a checked divide, you could just make yourself a useful function that defaults to an acceptable value:\n```\nfunction checked_divide( a,b:integer; fooey:double = 0.0 ) : double;\n  begin\n    if b <> 0\n      then result := a / b\n      else result := fooey\n  end;\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short Circuit Evaluation with Components in Unity\r\n                \r\nI have a line of code: ```\nRigidbody rigidbody = go.GetComponent<Rigidbody>() ? go.GetComponent<Rigidbody>() : go.AddComponent(typeof(Rigidbody)) as Rigidbody;```\n where ```\ngo```\n is a GameObject. When I try to simplify this using short circuit evaluation to ```\nRigidbody rigidbody = go.GetComponent<Rigidbody>() || go.AddComponent(typeof(Rigidbody)) as Rigidbody;```\n it gives the error ```\nCS0029: Cannot implicitly convert type 'bool' to 'UnityEngine.Rigidbody'```\n.\nAm I doing the short circuit evaluation incorrectly here? Is it possible to do this using short circuit or must I use my longer solution.\nAny help or advice is appreciated. Thanks.\n    ", "Answer": "\r\nThe scenario you’ve described here is the reason Unity have also provided ```\nTryGetComponent<T>(out T component)```\n.\nYou would use it like this:\n```\nif ( !go.TryGetComponent<Rigidbody>( out var rigidbody ) )\n    rigidbody = go.AddComponent<Rigidbody>() as Rigidbody;\n// rigidbody is now set ...\n\n```\n\nThis protects you from the quirk of Unity objects appearing to be non-null under certain conditions, and satisfies the Unity engineers requests that you not use the null-conditional/coalescing operators.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Eclipse and short circuit evaluation\r\n                \r\nim trying to use the short-circuit evaluation to simplify the writing of a check , but eclipse calls \"The local variable inherit may not have been initialized\" in the last statment of the if clause, am i using the evaluation method correctly ? Can the IDE understand the evaluation of the statement ?\n\n```\nif ((className.startsWith(\"Svl\")) &&\n                ((inherit = aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE)) == null)\n                || !(inherit.getText().equals(\"Servlet******\"))) {\n            log(aAST.getLineNo(), \"error\" + tokenIdent.getText());\n        }\n```\n\n    ", "Answer": "\r\nYou have got your parentheses wrong, that's what is causing the error. Simplified, the structure of your boolean expression is\n\n```\n(A && B) || C\n```\n\n\nwhere in B you assign to ```\ninherit```\n. if A fails, (A && B) is short-circuited to false, B is not evaluated, and C needs to be evaluated to find out the final result. Clearly, ```\ninherit```\n may not have been initialized when C is evaluated.\n\nDepending on what you are actually after, you can swap the positions of A and B. That will ensure B is evaluated always. Alternatively, what you really need may be A && (B || C). The requirements are up to you.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "RPN short circuit evaluation [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am now in the midst of making a simple bytecode interpreter that uses RPN for expression notation and really postfix notation for anything, but now I've come to the question which is: can short circuit evaluation actually be used on postfix expressions? For example when evaluating the expression (false && (factorial(7) > factorial(5))) C++ knows the result of the && operator on the two operands evaluates to false before it even gets to the second operand, since (false && anything) is always equal to false. Now when you put this in RPN, you get (false (7 factorial 5 factorial >) &&). \n\nI wanted to build an efficient RPN expression parser, so the problem is this: how do I make an efficient RPN expression parser with short circuit evaluation?\n    ", "Answer": "\r\nYou would evaluate an ```\nRPN```\n expression in two phases.\n\nPhase 1: parse the ```\nRPN```\n, and construct a tree representation of the RPN. So, in this tree, for example, the ```\n&&```\n node has two children nodes, for each half of the expression. Constructing this tree is a nearly identical process as evaluating the ```\nRPN```\n, except for the evaluating part, which gets replaced by the operation of constructing a new node, and linking its child nodes to their new parent node, then pushing the parent node back on the ```\nRPN```\n evaluation stack.\n\nPhase 2: evaluate the constructed tree, using recursive descent. At this point, short-circuit evaluation becomes trivial: evaluate the left-hand child of a ```\n&&```\n, then decide whether you actually want to evaluate the right-hand child.\n\nDitto for the ```\n||```\n node, etc...\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "SpEL - disable short circuit evaluation\r\n                \r\nIn my application, I have objects with several ```\nSpEL```\n expressions that usually contains signatures of methods with ```\nboolean```\n return type to invoke and logical operators. Before these objects are cached, I check the consistency of the expression by simply executing the parsed expression. When an exception is thrown, I set an appropriate flag inside the object to indicate that the expression is invalid to avoid further execution.\n\nI am executing the expression on an ```\nEvaluationContext```\n that implements all methods that are permitted to be a part of the expression. All these methods return ```\nfalse```\n. I have come across a problem that involves a short circuit evaluation.\n\nGiven ```\nmethodOne```\n and ```\nmethodTwo```\n are the only permitted methods to invoke, this expression correctly sets the inconsistency flag\n\n```\nmethodERROROne(\"arg\") AND methodTwo(\"arg\")\n```\n\n\nthis one, however, does not because ```\nmethodOne```\n returns ```\nfalse```\n, ```\nSpring```\n uses short circuit evaluation and does not execute the remaining operands. This causes the expression to fail when it is executed on real ```\nEvaluationContext```\n and the ```\nmethodOne```\n returns ```\ntrue```\n\n\n```\nmethodOne(\"arg\") AND methodERRORTwo(\"arg\")\n```\n\n\nIs there a way to disable short circuit evaluation is Spring expression language?\n    ", "Answer": "\r\nNo; the ```\nOpAnd```\n operator always short-circuits...\n\n```\n@Override\npublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n    if (!getBooleanValue(state, getLeftOperand())) {\n        // no need to evaluate right operand\n        return BooleanTypedValue.FALSE;\n    }\n    return BooleanTypedValue.forValue(getBooleanValue(state, getRightOperand()));\n}\n```\n\n\n...there is no equivalent to Java's ```\n&```\n operator.\n\nEDIT\n\n\n  All these methods return false\n\n\nIf they all return ```\nfalse```\n can't you use ```\n\"!(!m1() and !m2())\"```\n ?\n\nor even\n\n```\n\"!((!m1() or m1()) and (!m2() or m2()))\"```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is Short Circuit Evaluation guaranteed In C++ as it is in Java?\r\n                \r\nIn Java, I use\n\n```\nif (a != null && a.fun());\n```\n\n\nby taking full advantage of short-circuit evaluation and expression are evaluated from left to right?\n\nIn C++, can I do the same? Are they guarantee to portable across different platform and compiler?\n\n```\nif (a != 0 && a->fun());\n```\n\n    ", "Answer": "\r\nYes, it is guaranteed for the \"built in\" types. However, if you overload && or || for your own types, short-circuited evaluation is NOT performed. For this reason, overloading these operators is considered to be a bad thing.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Oracle 10 - query short circuit evaluation\r\n                \r\nDoes Oracle 10 support a short circuit evaluation query? if yes, there are some special key for use it?\n    ", "Answer": "\r\nYou are probably talking about short circuit evaluation. \n\nA DBMS has cost-based optimizer. There is no guarantee wich condition will get evaluated first and there's no special key to activate this.\n\nNote that PL/SQL does use short circuit evaluation\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short Circuit Evaluation to undefined?\r\n                \r\nI am using short circuit evaluation to set a key in an object. For example:\n\n```\nvar obj = {foo : 'bar'}\nvar obj2 = {}\n\nobj2.somekey = obj.baz || obj.foo //will assign 'bar' to obj2.somekey\n```\n\n\nThe only difference with my code from that above, is that instead of assigning obj.foo if obj.baz doesn't exist, I would like obj.somekey to stay undefined. I tried ```\nobj2.somekey = obj.baz ||```\n, but it threw me a syntax error. \n\nNote that ```\nnull```\n and ```\nundefined```\n, as this question suggests, are not actually undefined either. \n\nSo is there any way I can do this with short circuit syntax?\n    ", "Answer": "\r\nIt seems like the simplest solution would be:\n\n```\nobj2.somekey = obj.baz;\n```\n\n\nBut if you really want the semantics of the logical operator (i.e. empty string, ```\nnull```\n, ```\n0```\n, ```\nNaN```\n, and ```\nfalse```\n, all evaluate to ```\nfalse```\n and so ```\n||```\n returns whatever is on the right), use ```\nvoid```\n:\n\n```\nobj2.somekey = obj.baz || void(0);\n```\n\n\nNote that in this case the property ```\n.somekey```\n will be assigned, but the value assigned to it may be ```\nundefined```\n. See Felix Kling's excellent answer for a full explanation. To leave the property ```\n.somekey```\n itself undefined simply use:\n\n```\nif ('baz' in obj) obj2.somekey = obj.baz;\n```\n\n\nOr to leave ```\n.somekey```\n undefined even if ```\n.baz```\n is falsey, use:\n\n```\nif (obj.baz) obj2.somekey = obj.baz;\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "JavaScript Short Circuit Evaluation - Missing Property Value\r\n                \r\nI'm trying to improve my coding practices so I attempted to refactor the following code:\n\nEDIT My question is what is about the best practice for short circuit evaluation https://codeburst.io/javascript-what-is-short-circuit-evaluation-ff22b2f5608c\n\n```\nvar idArray = [\n    { id: 15 },\n    { id: -1 },\n    { id: 0 },\n    { id: 3 },\n    { },\n    { id: null },\n    { id: NaN },\n    { id: 'undefined' }\n  ]\n\nlet idFilteredArray0 = []\n\nidArray.forEach(idObj  =>{\nif(typeof idObj.id === 'number' && !isNaN(idObj.id))\n    idFilteredArray0.push(idObj.id)\n})\n\n// from a forEach loop which returns [ 15, -1, 0, 3, 12.2 ]\n\nlet idF0 = idArray.reduce((acc, obj) => {\n  if((obj.id || obj.id)  && !isNaN(obj.id))\n    acc.push(obj.id)\n  return acc\n},[]) \n\n// to reduce which returns [15, -1, 3, 12.2]\n```\n\n\nI think &&'ing is the issue, but I can't see a different way to exclude the NaN value. I'd settle for getting the ```\n0```\n back into the result array at this point . Lastly if anyone knows of a good source to learn short circuit evaluation, I'd greatly appreciate it. Thanks.\n\nJ.\n    ", "Answer": "\r\nYou could filter and map the items and check the type and id the value is not ```\nNaN```\n.\n\n\r\n\r\n```\nvar idArray = [{ id: 15 }, { id: -1 }, { id: 0 }, { id: 3 }, { id: 12.2 }, {}, { id: null }, { id: NaN }, { id: 'undefined' }],\r\n    idFiltered = idArray\r\n        .filter(({ id }) => typeof id === 'number' && !isNaN(id))\r\n        .map(({ id }) => id);\r\n\r\nconsole.log(idFiltered);```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation with ternary output [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is not reproducible or was caused by typos. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question was caused by a typo or a problem that can no longer be reproduced. While similar questions may be on-topic here, this one was resolved in a way less likely to help future readers.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am using short circuit evaluation to assign some variables. I had to use a ternary operator in some of them, but it does not behave as I expected :\n\n\r\n\r\n```\nconsole.log(false || \"bar\"); // Outputs \"bar\"\r\nconsole.log(\"foo\" || \"bar\"); // Outputs \"foo\"\r\nconsole.log(\"foo\" || (true) ? \"42\" : \"bar\"); // Ouputs \"42\", why ?```\n\r\n\r\n\r\n\n\nShouldn't the third ```\nconsole.log```\n output \"foo\" instead ?\n    ", "Answer": "\r\n```\nconsole.log(\"foo\" || (true) ? \"42\" : \"bar\"); // Ouputs \"42\", why ?\n```\n\n\nbecause it's being evaluated as\n\n```\nconsole.log((\"foo\" || true) ? \"42\" : \"bar\");\n```\n\n\nwith ```\n(\"foo\" || true)```\n being evaluated first as a truthy value.\n\nYour bracket is in the wrong place perhaps you meant\n\n```\nconsole.log(\"foo\" || (true ? \"42\" : \"bar\"));\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is short-circuiting logical operators mandated? And evaluation order?\r\n                \r\nDoes the ANSI standard mandate the logical operators to be short-circuited, in either C or C++?\n\nI'm confused for I recall the K&R book saying your code shouldn't depend on these operations being short circuited, for they may not. Could someone please point out where in the standard it's said logic ops are always short-circuited? I'm mostly interested on C++, an answer also for C would be great.\n\nI also remember reading (can't remember where) that evaluation order isn't strictly defined, so your code shouldn't depend or assume functions within an expression would be executed in a specific order: by the end of a statement all referenced functions will have been called, but the compiler has freedom in selecting the most efficient order.\n\nDoes the standard indicate the evaluation order of this expression?\n\n```\nif( functionA() && functionB() && functionC() ) cout<<\"Hello world\";\n```\n\n    ", "Answer": "\r\nYes, short-circuiting and evaluation order are required for operators ```\n||```\n and ```\n&&```\n in both C and C++ standards.\n\nC++ standard says (there should be an equivalent clause in the C standard):\n\n\n  1.9.18\n  \n  In the evaluation of the following expressions\n\n```\na && b\na || b\na ? b : c\na , b\n```\n\n  \n  using the built-in meaning of the operators in these expressions, there is a sequence point after the evaluation of the first expression (12).\n\n\nIn C++ there is an extra trap: short-circuiting does NOT apply to types that overload operators ```\n||```\n and ```\n&&```\n.\n\n\n  Footnote 12: The operators indicated in this paragraph are the built-in operators, as described in clause 5. When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation, and the operands form an argument list, without an implied sequence point between them.\n\n\nIt is usually not recommended to overload these operators in C++ unless you have a very specific requirement. You can do it, but it may break expected behaviour in other people's code, especially if these operators are used indirectly via instantiating templates with the type overloading these operators.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation and side effects [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Is short-circuiting logical operators mandated? And evaluation order?\r\n                            \r\n                                (7 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nOK, I'm a little embarassed to ask this question, but I just want to be sure...\n\nIt is known that C uses short circuit evaluation in boolean expressions:\n\n```\nint c = 0;\nif (c && func(c)) { /* whatever... */ }\n```\n\n\nIn that example ```\nfunc(c)```\n is not called because ```\nc```\n evaluates to ```\n0```\n. But how about more sophisticated example where side effects of comparison would change the variable being compared next? Like this:\n\n```\nint c; /* this is not even initialized... */\nif (canInitWithSomeValue(&c) && c == SOMETHING) { /*...*/ }\n```\n\n\nFunction ```\ncanInitWithSomeValue```\n returns true and changes value at given pointer in case of success. Is it guaranteed that subsequent comparisons (```\nc == SOMETHING```\n in this example) uses value set by ```\ncanInitWithSomeValue(&c)```\n?\n\nNo matter how heavy optimizations the compiler uses?\n    ", "Answer": "\r\n\n  Is it guaranteed that subsequent comparisons (c == SOMETHING  in this example) uses value set by canInitWithSomeValue(&c)?\n\n\nYes. Because there is a sequence point\n\n\n  Between evaluation of the left and right operands of the ```\n&&```\n (logical AND), ```\n||```\n (logical OR), and comma operators. For example, in the expression ```\n*p++ != 0 && *q++ != 0```\n, all side effects of the sub-expression *p++ != 0 are completed before any attempt to access q.\n\n\n\n\n\n  A sequence point defines any point in a computer program's execution at which it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation with both && || operator\r\n                \r\nI know what is short circuit evaluation in C.\n\n```\na && b```\n (operand b is not checked if a = 0)\n\n```\na || b```\n (operand b is not checked if a = non zero)\n\nBut I am stuck at this question \n\n```\nint x = 0;\nif (5 || 2 && ++x)\n    printf(\"%d\", x);\n```\n\n\nThis outputs ```\n0```\n.\n\nMy first thinking goes as follows:\n\nAccording to precedence table , precedence is ```\n++```\n, ```\n&&```\n, ```\n||```\n (descending order)\n\n\n```\n++x```\n: ```\nevaluated.x```\n becomes 1.\n```\n2 && ++x```\n evaluated. Both operands are evaluated.\n```\n||```\n is evaluated.\n\n\nBut according to this, ```\n1```\n should be printed, not ```\n0```\n.\n\nMy second thinking goes as this:\n\n```\n5 || anything\n```\n\n\n```\nanything```\n is not evaluated because of short circuit evaluation, so no precedence comes into play here.\n    ", "Answer": "\r\nThe expression ```\n5 || 2 && ++x```\n is equivalent to ```\n5 || (2 && ++x)```\n due to operator precedence.\n\nThe run time evaluates the expression ```\n5 || 2 && ++x```\n from left to right.  \n\nAs we know in OR if first condition is true it will not check the second condition.\nSo here 5 evaluated as true and so ```\n(2 && ++x)```\n  will not be performed.  \n\nThat's why x will remain 0 here.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "inner short circuit evaluation in c\r\n                \r\nI know that Java and C/C++ have short circuit evaluation, i.e., in ```\nif (a && b)```\n, ```\nb```\n will never evaluated if ```\na```\n is not true. \n\nBut what if I have expression like ```\nif ( (a && b) OP c )```\n (where ```\nOP```\n is an arbitrary logical operator), will ```\nb```\n evaluated if ```\na = false```\n? Thanks.\n    ", "Answer": "\r\nC Standards say that -\n\n6.5.13 Logical AND operator\n\nThe && operator guarantees left-to-right evaluation......\n.If the first operand compares equal to 0, the second operand is not evaluated.\n\n\nSo in case ```\na==flase```\n ```\nb```\n will not be evaluated.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "converting short-ciruit evaluation to non short-circuit evaluation\r\n                \r\nI have to rewrite this segment of code code that assumes short-circuit evaluation of Boolean expressions:\n\n```\nwhile ((p!=NULL) && (p->val != v)) p=p->next;\n```\n\n\nsuch that it performs exactly the same task without assuming the short-circuit evaluation of Boolean expressions. Can anyone help me out with this?\n\nI've searched the internet but all I get is the differences between short-circuit eval and non short-circuit eval, but I can't find anything on rewriting one or the other to get them to do the same thing. It's for an exam review (not homework) so it would be great help someone solved it so I'd atleast know howto do this for simple code. Explanations welcome :-)\n    ", "Answer": "\r\n```\nwhile(true)\n{\n    if (p == NULL)\n        break;\n    if (p->val == v)\n        break;\n    p = p->next;\n}\n```\n\n\nSome explanation: the original code relies on short-circuit evaluation. ```\np->val != v```\n isn't evaluated if ```\np!=NULL```\n evaluates to false. If it would always evaluate the second expression, this might lead to an access violation. If you don't hva a short-circuiting ```\n&&```\n operator, you need to make sure in your code, ```\np->val```\n is only evaluated if ```\np!=NULL```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation using procedures\r\n                \r\nI am currently developing a compiler for a very limited object oriented language. I want to treat all values as objects and operators on those values will be implemented as methods. The compiler transforms the program into assembler for a stack-based virtual machine. \n\nDuring compilation I transform integer literals into objects of a special \"Integer\" class. Arithmetic operators are implemented as methods of that class (using inline assembler). So that ```\n4 + 5```\n basically equals to ```\n4.add(5)```\n.\n\nThe problem I am facing right now is the special case for boolean values. If there is an ```\nif```\n statement:\n\n```\nif(10 > 5 || 12 < 10)\n```\n\n\nthis would currently be transformed into: ```\n10.greaterThan(5).or(12.lessThan(10))```\n\n\nNow obviously those integer literals can also be calls to a function with side-effects. Implementing those binary operators as method calls yields a problem in this case as short-circuit evaluation gets impossible. \n\nSo my questions are:\n\n\nHow do other languages achieve short-circuit evaluation but still treating every value as an object? \nAccording to Wikipedia \"ALGOL 68 used \"proceduring\" to achieve user defined short-circuit operators & procedures.\" - How does this work?\n\n    ", "Answer": "\r\nThe usual technique, I believe, involves either call by name or call by need.  The idea is that the parameter of ```\nor```\n is not the result of the comparison, instead it is the comparison itself converted in to a thunk, which is converted into the result value whenever (in call by name) or the first time (in call by need) it is needed.\n\nWhen converting an expression into a thunk, you are basically creating an anonymous function, and you can treat the compilation problem as such.  It involves compiling the expression into code that will evaluate the expression.  It also involves creating an object (the thunk itself) which refers to (or contains copies of) those local variables that the expression uses, along with a pointer to the compiled code of the expression.  The object needs to be interface compatible with your boolean class so that the code using it does not have to care whether it has a genuine boolean or a thunk posing as such.  Whenever  someone needs the boolean value, the thunk would execute the compiled expression code and provide the resulting value.\n\nIf call by name is sufficient to you, that's all there is to it.  For call by need, there's added complexity from caching the result of the evaluation.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "short-circuit evaluation a language flaw?\r\n                \r\nHere is some code to check that a value falls in between a range\n\n```\n if((i <= n) && ( (i+m) >= n){\n   //do something.....\n };\n```\n\n\nThis is basically a Boolean AND condition, and if both operands are true then the outcome of the condition is true.\nHowever with short circuit evaluation C++ only tests to see if the first condition is true, and if so, then it never checks whether the second condition is true.\nIn the proper mathematical sense how is this a Boolean test? This totally deranges the logic of my code and instead I had to write it like this:\n\n```\n if( (i <= n){\n    if((i+m) >= n){\n       //do something......\n    }\n }\n```\n\n\nWhat is the sense of short-circuit evaluation, and how can I make C++ do a proper Boolean test without using nested if conditions.\n    ", "Answer": "\r\n\n  However with short circuit evaluation C++ only tests to see if the first condition is true, and if so, then it never checks whether the second condition is true. \n\n\nThat is the case for ```\n||```\n, but not ```\n&&```\n. ```\n&&```\n short circuits if the first condition is ```\nfalse```\n. Your two snippets are equivalent.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "short-circuit evaluation in leon --xlang\r\n                \r\nConsider the following complicated way of negating a boolean (which depends on short-circuit evaluation):\n\n```\ndef negate(a: Boolean) = {\n  var b = true\n  a && { b = false; true }\n  b\n} ensuring { res => res != a }\n```\n\n\nIf I test this code in the Scala console, it works as expected.\nBut ```\nleon --xlang```\n says that the postcondition is invalid.\nIs this expected/specified?\n    ", "Answer": "\r\nLooking at the (simplified) encoding after the xlang transformation phase, we get the following:\n\n```\n  def negate0(a0 : Boolean): Boolean = {\n    val b1 = true\n    val b2 = false\n    b2\n  } ensuring {\n    res19 => res19 != a0\n  }\n```\n\n\nThe first ```\nb1```\n corresponds to the initialization ```\nvar b = true```\n. The second ```\nb2```\n is introduced to correspond to the assignment ```\nb = false```\n. Unfortunately XLang does not do any special treatment of ```\n&&```\n and ```\n||```\n operators meaning that it will extract all side effects in sub-expression and move them in order to the \"top\" level (hence why you have the ```\nval b2 = false```\n). The final returned value is ```\nb2```\n, the last known name of ```\nb```\n, and obviously the expression ```\na && ...```\n is ignored (except for side-effect).\n\nSo basically this is a limitation in Leon, and we will be looking into fixing it.\n\nEdit:\nNote that this got fixed in the most recent version of Leon: https://github.com/epfl-lara/leon/commit/2485477f4e91cba7fe6e0c137817d62f513a3c42\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to make `short-circuit evaluation` also available in `fold expressions`?\r\n                \r\n```\n#include <type_traits>\n\n#define FORWARD(arg)\\\nstd::forward<decltype(arg)>(arg)\n\ntemplate<typename... Args>\nconstexpr bool AndL(Args&&... args)\n{\n    return (... && FORWARD(args));\n}\n\ntemplate<typename... Args>\nconstexpr bool AndR(Args&&... args)\n{\n    return (FORWARD(args) && ...);\n}\n\nint main()\n{\n    bool* pb = nullptr;\n\n    false && (*pb = true);       // ok at runtime.\n    AndL(false, (*pb = true));  // error at runtime!\n    AndR(false, (*pb = true));  // error at runtime!\n}\n```\n\n\nThe traditional ```\n&&```\n operator supports short-circuit evaluation, so ```\nfalse && (*pb = true)```\n will be ok at runtime, but the following two cases are not.\n\nHow to make short-circuit evaluation also available in ```\nfold expressions```\n?\n    ", "Answer": "\r\nThe problem here is just a misconception of what's actually happening.\n\n\n  How to make short-circuit evaluation also available in fold expressions?\n\n\nIt is available in fold expressions. ```\n(args && ... )```\n follows the exactly the same rules as ```\n(a && b && c && d)```\n. That is, ```\nd```\n will only be evaluated if ```\na```\n, ```\nb```\n, and ```\nc```\n all evaluate to truthy.\n\nThat's not the actual difference between your two cases.\n\n```\nfalse && (*pb = true);       // ok at runtime.\nAndL(false, (*pb = true));   // error at runtime!\n```\n\n\nWhile fold expressions do exactly the same thing as their non-fold counterparts, there's one important difference between these two statements. The first is just a statement-expression, the second is a function call. And all function arguments must be evaluated before the start of the body begins. \n\nSo the second is equivalent to:\n\n```\nauto&& a = false;\nauto&& b = (*pb = true);\n(FORWARD(a) && FORWARD(b));\n```\n\n\nIt's that ordering that is causing the problem, not the fold expression (note: ```\nb```\n could be evaluated before ```\na```\n). \n\nIn order to make this transparent, what you really need are lazy arguments. This is a feature in several languages (e.g. Scala), but not in C++. If you need laziness, the best you could do is wrap everything in a lambda:\n\n```\ntemplate<typename... Args>\nconstexpr bool AndL(Args&&... args)\n{\n    return (... && FORWARD(args)());\n}\n\nAndL([]{ return false; }, [&]{ return *pb = true; });\n```\n\n\nYou could then make this arbitrarily complex - maybe only \"unwrap\" those types that are callable, otherwise assume that they're bool:\n\n```\ntemplate <class T, std::enable_if_t<std::is_invocable<T>::value, int> = 0>\nbool unwrap(T&& val) { return std::forward<T>(val)(); }\n\ntemplate <class T, std::enable_if_t<std::is_convertible<T, bool>::value, int> = 0>\nbool unwrap(T&& val) { return std::forward<T>(val); }\n\ntemplate<typename... Args>\nconstexpr bool AndL(Args&&... args)\n{\n    return (... && unwrap(FORWARD(args)));\n}\n\nAndL(false, [&]{ return *pb = true; });\n```\n\n\nBut really, the main point is that function argument evaluation precedes the function body, and the issue is not the fold expression itself. \n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Benefits of using short-circuit evaluation\r\n                \r\n```\nboolean a = false, b = true;\nif ( a && b ) { ... };\n```\n\n\nIn most languages, ```\nb```\n will not get evaluated because ```\na```\n is false so ```\na && b```\n cannot be true. My question is, wouldn't short circuiting be slower in terms of architecture? In a pipeline, do you just stall while waiting to get the result of a to determine if b should be evaluated or not? Would it be better to do nested ifs instead? Does that even help?\n\nAlso, does anyone know what short-circuit evaluation is typically called? This question arose after I found out that my programming friend had never heard of short-circuit evaluation and stated that it is not common, nor found in many languages, and is inefficient in pipeline. I am not certain about the last one, so asking you folks!\n\nOkay, I think a different example to perhaps explain where my friend might be coming from. He believes that since evaluating a statement like the following in parallel:\n\n```\n(a) if ( ( a != null ) && ( a.equals(b) ) ) { ... }\n```\n\n\nwill crash the system, an architecture that doesn't have short-circuiting (and thereby not allowing statements like the above) would be faster in processing statements like these:\n\n```\n(b) if ( ( a == 4 ) && ( b == 5 ) )\n```\n\n\nsince if it couldn't do (a) in parallel, it can't do (b) in parallel. In this case, a language that allows short-circuiting is slower than one that does not.\n\nI don't know if that's true or not.\n\nThanks\n    ", "Answer": "\r\nShort circuit evaluation is translated into branches in assembly language in the same way if statements are (branches are basically a goto), which means it is not going to be any slower than if statements.\n\nBranches don't typically stall the pipeline, but the processor will guess whether the branch is taken or not, and if the processor is wrong it will have to flush everything that has happened since it made the wrong guess from the pipeline.\n\nShort circuit evaluation is also the most common name for it, and is found in most languages in some form or another.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation should be faster than bitwise evaluation, but it is not. Why? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How do I write a correct micro-benchmark in Java?\r\n                            \r\n                                (11 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nTo compare how short circuit evaluation logical operators, for example ```\n&&```\n, perform compared to bitwise evaluation logical operators, i.e. ```\n&```\n, I wrote this example and ran it:\n\n```\npackage examples1;\n\nimport java.util.Scanner;\n\npublic class ShortCircuitOperatorsVSBitwiseOperators {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter A: \"); boolean a = scanner.nextBoolean();\n        System.out.print(\"Enter B: \"); boolean b = scanner.nextBoolean();\n        long startTimeShortCircuited = System.currentTimeMillis();\n        boolean resultShortCircuited = true;\n        for(long i = 0; i < 10000000000L; i++) {\n            resultShortCircuited = a && b;\n        }\n        long endTimeShortCircuited = System.currentTimeMillis();\n        System.out.println(resultShortCircuited + \" in \" + (endTimeShortCircuited - startTimeShortCircuited) + \" milliseconds, short-circuited\");\n\n        long startTimeBitwise = System.currentTimeMillis();\n        boolean resultBitwise = true;\n        for(long i = 0; i < 10000000000L; i++) {\n            resultBitwise = a & b;\n        }\n        long endTimeBitwise = System.currentTimeMillis();\n        System.out.println(resultBitwise + \" in \" + (endTimeBitwise - startTimeBitwise) + \" milliseconds, bitwise\");\n        scanner.close();\n    }\n}\n```\n\n\nAn example run shows the following:\n\n```\njava examples1/ShortCircuitOperatorsVSBitwiseOperators\nEnter A: false\nEnter B: true\nfalse in 4829 milliseconds, short-circuited\nfalse in 3276 milliseconds, bitwise\n```\n\n\nThis doesn't make sense. I would expect the short circuit evaluation to be faster since it doesn't evaluate the right side of the ```\n&&```\n in this case if the left side was ```\nfalse```\n. What is the reason for the counter-intuitive results?\n    ", "Answer": "\r\nShort circuited operation is complicated.\n\n```\npublic static boolean shortCircuitedAnd(boolean a, boolean b) {\n    return a && b;\n}\n\npublic static boolean bitwiseAnd(boolean a, boolean b) {\n    return a & b;\n}\n```\n\n\nThey are compiled to\n\n```\npublic static boolean shortCircuitedAnd(boolean, boolean);\n  Code:\n     0: iload_0\n     1: ifeq          10\n     4: iload_1\n     5: ifeq          10\n     8: iconst_1\n     9: ireturn\n    10: iconst_0\n    11: ireturn\n\npublic static boolean bitwiseAnd(boolean, boolean);\n  Code:\n     0: iload_0\n     1: iload_1\n     2: iand\n     3: ireturn\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Idiomatic Scala.js translation of JavaScript short circuit evaluation\r\n                \r\nJavaScript short-circuit evaluation is commonly used to e.g. deal with browser incompatibilities:\n\n```\nvar scrollPosition =\n  window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0\n```\n\n\nWhat's the idiomatic way to write this in Scala.js?\n    ", "Answer": "\r\nA contrario @gurghet's answer, IMO the most idiomatic version is to adopt JavaScript's idiom right into Scala.js. After all, you are exploiting the dynamic nature of JavaScript anyway, so you might as well be explicit about it. You can do that with ```\njs.Dynamic```\n:\n\n```\nimport scala.scalajs.js\nimport js.Dynamic.{global => g}\n\ndef scrollPosition: Double = {\n  import js.DynamicImplicits._ // to \"write JavaScript\"\n  val pos = g.window.pageYOffset || g.document.documentElement.scrollTop || g.document.body.scrollTop || 0\n  pos.asInstanceOf[Double]\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Are short circuit evaluation rules expected at compile time?\r\n                \r\nProgram A produces a compilation error (as expected) since ```\nisFinite```\n is called with a non-integral type.\n\nProgram A\n\n```\n#include <iostream>\n\nclass Foo {};\n\ntemplate<typename T>\nbool isFinite(const T& t)\n{\n    static_assert(std::is_integral<T>::value, \"Called isFinite with a non-integral type\");\n    return false;\n}\n\nint main()\n{\n    Foo f;\n    std::cout << \"Foo is finite? \" << ((isFinite(f)) ? \"yes\" : \"no\") << \"\\n\";\n\n    return 0;\n}\n```\n\n\nHowever, a slight modification (see Program B) allows the program to compile (Visual Studio 2013) and produce the following output.\n\nProgram B Visual Studio 2013 Ouput\n\n```\nFoo is finite? yes```\n\n\nProgram B\n\n```\n#include <iostream>\n\nclass Foo {};\n\ntemplate<typename T>\nbool isFinite(const T& t)\n{\n    static_assert(std::is_integral<T>::value, \"Called isFinite with a non-integral type\");\n    return false;\n}\n\nint main()\n{\n    Foo f;\n    std::cout << \"Foo is finite? \" << ((true || isFinite(f)) ? \"yes\" : \"no\") << \"\\n\";\n\n    return 0;\n}\n```\n\n\nIt appears that Program B is short circuiting on the logical OR operation and not attempting to compile the rest of the expression. However, this application does not compile using g++ 4.8.3 (```\ng++ -std=c++11 -o main main.cpp```\n). I get the following output.\n\n```\nmain.cpp: In instantiation of 'bool isFinite(const T&) [with T = Foo]':\nmain.cpp:15:56:   required from here\nmain.cpp:8:2: error: static assertion failed: Called isFinite with a non-integral type\n  static_assert(std::is_integral<T>::value, \"Called isFinite with a non-integral type\");\n  ^\n```\n\n\nMy intuition leads me to believe that the compilation failure is the correct behavior but it is curious that Visual Studio 2013 compiles successfully. My intuition is based on the fact that it is expected that the following code cannot be compiled.\n\n```\n#include <iostream>\n\nstruct Foo\n{\n    void doOperation1() {}\n    void doOperation2() {}\n};\n\nstruct Bar\n{\n    void doOperationA() {}\n    void doOperation2() {}\n};\n\ntemplate<typename T>\nvoid performOperation(T& t, bool value)\n{\n    if (value)\n    {\n        t.doOperation1();\n    }\n    else\n    {\n        t.doOperation2();\n    }\n}\n\nint main()\n{\n    Foo f;\n    performOperation(f, true);\n    performOperation(f, false);\n\n    Bar b;\n    performOperation(b, false); // Fails to compile (as expected)\n\n    return 0;\n}\n```\n\n\nRestated Question\n\nAre the logical operators supposed to adhere to short circuit evaluation rules at compile time (i.e., what is the expected compilation behavior of Program B)?\n    ", "Answer": "\r\nShort circuit is not supposed to compile ```\ntrue || (whatever_ill_formed)```\n. ```\nisFinite<Foo>```\n is instantiated as part of expression and during instantiation it should be compiled and during compilation it should static assert. After that the compiler may never evaluate ```\nisFinite<Foo>(f)```\n because of short circuit but static assert is not supposed to happen during it.\n\nIt is unclear why Visual Studio 2013 compiles Program B. Standard only allows bypassing syntax checking of templates when template is never instantiated. Even then the code is still ill formed only diagnostics are not required. Behind the defect is perhaps the same internal issue in Visual C++ that does not let Microsoft to implement ```\nconstexpr```\n.\n\nEdit I add some language lawyer texts from standard per @zneak request\n\n3.2/3 \n\n\n  A function whose name appears as a potentially-evaluated expression is\n  odr-used if it is the unique lookup result or the selected member of a\n  set of overloaded functions (3.4, 13.3, 13.4), unless it is a pure\n  virtual function and its name is not explicitly qualified. [Note: This\n  covers calls to named functions (5.2.2), operator overloading (Clause\n  13), user-defined conversions (12.3.2), allocation function for\n  placement new (5.3.4), as well as non-default initialization (8.5). A\n  constructor selected to copy or move an object of class type is\n  odr-used even if the call is actually elided by the implementation\n  (12.8). —end note]\n\n\n5.13/1 \n\n\n  The || operator groups left-to-right. The operands are both\n  contextually converted to bool (Clause 4). It returns true if either\n  of its operands is true, and false otherwise. Unlike |, || guarantees\n  left-to-right evaluation; moreover, the second operand is not\n  evaluated if the first operand evaluates to true.\n\n\n7.1/4 \n\n\n  In a static_assert-declaration the constant-expression shall be a\n  constant expression (5.19) that can be contextually converted to bool\n  (Clause 4). If the value of the expression when so converted is true,\n  the declaration has no effect. Otherwise, the program is ill-formed,\n  and the resulting diagnostic message (1.4) shall include the text of\n  the string-literal, except that characters not in the basic source\n  character set (2.3) are not required to appear in the diagnostic\n  message.\n\n\n14.7.1/3 \n\n\n  Unless a function template specialization has been explicitly\n  instantiated or explicitly specialized, the function template\n  specialization is implicitly instantiated when the specialization is\n  referenced in a context that requires a function definition to exist.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to perform short-circuit evaluation in Windows PowerShell 4.0?\r\n                \r\nTechnet's about_Logical_Operators with respect to Windows PowerShell 4.0 states the following:\n\n```\nOperator     Description                        Example\n\n--------     ------------------------------     ------------------------\n-or          Logical or. TRUE when either       (1 -eq 1) -or (1 -eq 2) \n             or both statements are TRUE.       True\n\n-xor         Logical exclusive or. TRUE         (1 -eq 1) -xor (2 -eq 2)\n             only when one of the statements    False \n             is TRUE and the other is FALSE.\n```\n\n\n\n\nNeither seem to perform short-circuit evaluation.\n\nHow can I mimic the C# ```\n||```\n or VB ```\nOrElse```\n in Windows Powershell 4.0?\n    ", "Answer": "\r\nA simple set of test cases show that short-circuiting works:\n\n```\nPS C:\\> 1 -eq 0 -or $(Write-Host 'foo')\nfoo\nFalse\nPS C:\\> 1 -eq 1 -or $(Write-Host 'foo')\nTrue\n\nPS C:\\> 1 -eq 1 -and $(Write-Host 'foo')\nfoo\nFalse\nPS C:\\> 1 -eq 0 -and $(Write-Host 'foo')\nFalse\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation in JavaScript - SyntaxError: Unexpected token 'return'\r\n                \r\nI would like to use short circuit evaluation syntax (with ```\n&&```\n operator) as described by example in the article: \n\nSay, I have this situation:\n\n```\nfunction externalFunction() {\n\n    id == ...\n    text == ...\n\n    // OK: Standard if syntax is fine\n\n    if ( aFunction(id, text) ) return\n\n    // KO: Short circuit evaluation generate a RUN-TIME ERROR: \n    // SyntaxError: Unexpected token 'return'\n    // anotherFunction(id, text) && return\n    //                              ^^^^^^\n\n    anotherFunction(id, text) && return\n\n\n}\n```\n\n\nWhy I have the error?\nMaybe I can't use a single statement with language keyword (```\nreturn```\n)? \n    ", "Answer": "\r\nThe right hand side of ```\n&&```\n needs to be an expression. You're trying to put a statement there.\n\nThe ```\n&&```\n has to evaluate as something but ```\nreturn x```\n doesn't give you a value. It exits the function and passes its RHS to the calling function.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short Circuit evaluation of an if-then-else operator (e.g. ?: in C)\r\n                \r\nI need to write a program in any language, that would print 1 if the language uses short circuit evaluation in the if-then-else operator and 0 if the languages does not.\n\nMy question is, what does short circuit evaluation in the if-then-else operator mean? \n\nis it simply the lazy evaluation that occurs in the && and || operators?\n    ", "Answer": "\r\nIf I'm reading this question correctly, then yes. In languages that implement this, if you had a statement like\n\n```\nif (A || B || C || D)\n```\n\n\nthe runtime would stop evaluating as soon as it found a statement that was true. For example, if A and B are false but C is true, it would evaluate A, B, and C but not D. This is important if you do something like this:\n\n```\nif (a != null && a.ToString() == \"abc\")\n```\n\n\nThe short-circuit behavior means that the second half of this if statement won't be executed if ```\na```\n is, in fact, ```\nnull```\n, which is critical because if that wasn't the case then this statement could throw a null reference exception. If it wasn't for that you'd have to do something like\n\n```\nif (a != null) {\n   if (a.ToString() == \"abc\") {\n      // ...\n```\n\n\nwhich is obviously a lot less concise.\n\n&& behaves in a similar way:\n\n```\nif (A && B && C && D) ...\n```\n\n\nIf ```\nA```\n is ```\nfalse```\n, for example, why bother to check the rest of the expressions?\n\nIn terms of the assignment, I'll give you a hint: what would happen if you had a side effect in one of the expressions?\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does Twig have short-circuit evaluation? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Do Twig's logical operators evaluate both expressions?\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                    \r\n                        Does PHP have short-circuit evaluation?\r\n                            \r\n                                (8 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nPHP has short-circuit evaluation, such that ```\ny```\n in ```\nif x and y```\n is only evaluated if ```\nx```\n is ```\ntrue```\n. It seems likely that Twig, being built on PHP, would as well. Does it?\n\nEdit: appreciate the \"almost certainly the case for Twig\" comments. Would love to hear from someone who can speak with certainty about Twig\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is short circuit evaluation a language feature in C/C++ or compiler implementation\r\n                \r\nI'm wondering if short circuit evaluation of\n\n```\nlong param = 0;\nif ( functAWithSideEffects(&param) || funcBWithSideEffects(&param) )\n```\n\n\nCan be relied on.  For example, if funcAWithSideEffects returns true, will the compiler evaluation funcBWithSideEffects?  Is short circuit evaluation a language feature or a compiler implementation detail?\n    ", "Answer": "\r\nYes. It can be relied on.\nThe C standard guarantees it (emphasis mine):\n\n4 Unlike the bitwise | operator, the || operator guarantees\nleft-to-right evaluation; if the second operand is evaluated, there is\na sequence point between the evaluations of the first and second\noperands. If the first operand compares unequal to 0, the second\noperand is not evaluated.\n\nand while C++ diverges from C in several ways, I'm 99.99% sure short circuit evaluation isn't one of them.\nA similar guarantee can be found for ```\n&&```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Using short circuit evaluation to define variable\r\n                \r\nWhy do you have to use the var keyword when defining a variable using short circuit evaluation?\n\nThis works...\n\n```\nvar sum=sum||5;\nconsole.log(sum); //shows 5;\n```\n\n\nThis does not work...\n\n```\nsum=sum||5;\nconsole.log(sum); //error sum is not defined;\n```\n\n\nShouldn't the second example just make sum===5 but at the global scope and not the local?\n    ", "Answer": "\r\nWhat happens internally when you do ```\nvar sum=sum||5;```\n is this:\n\n\nvariable ```\nsum```\n is defined, it's created, \nvariable ```\nsum```\n is assigned an ```\nundefined```\n value\nvariable ```\nsum```\n is assigned the result of ```\nsum || 5```\n, which is like saying ```\nundefined || 5```\n, which is ```\n5```\n\n\n\nWhen you simply do ```\nsum = sum||5```\n the first and second steps from above do not happen, so in the third step you are short-circuiting something that does not exist at all with the value ```\n5```\n, and that's why you get that error.\n\nIn order to understand that better, do this: Open up your browser's console and simply write ```\nsum```\n. You will get an error because ```\nsum```\n does not exist. Now, do ```\nsum = ''```\n. What happened here is that a variable ```\nsum```\n was defined/created, as if you had done ```\nvar sum```\n, it now exists, and it was assigned the value ```\n''```\n.\n\nThe essence of the above, which you should understand, is that there is a difference between short-circuiting the value ```\nundefined```\n with the value ```\n5```\n and short-circuiting something that does not exist with value ```\n5```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How does short circuit evaluation work in MSIL\r\n                \r\nHow does the short circuit evaluation work in the msil interpreter? Does the And instruction contain information about where to jump to if false, and same for the Or with true?\n    ", "Answer": "\r\nNo - the IL instructions for And and Or actually perform bitwise operations on the top two operands on the stack.  If a high level language uses short circuit evaluation, it is compiled down to explicit branching operations at the IL level and doesn't rely on the And instruction at all.  Use a tool like Reflector to see the actual IL produced by the compiler in question.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to prevent short-circuit evaluation?\r\n                \r\nThis is a problem that occurred to me while working on a Django project. It's about form validation.\nIn Django, when you have a submitted form, you can call ```\nis_valid()```\n on the corresponding form object to trigger the validation and return a Boolean value. So, usually you have code like that inside your view functions:\n```\nif form.is_valid():\n    # code to save the form data\n```\n\n```\nis_valid()```\n not only validates the form data but also adds error messages to the form object that can afterwards be displayed to the user.\nOn one page I use two forms together and also want the data to be saved only if both forms contain valid data. That means I have to call ```\nis_valid()```\n on both forms before executing the code to save the data. The most obvious way:\n```\nif form1.is_valid() and form2.is_valid():\n    # ...\n```\n\nwon't work because of the short circuit evaluation of logical operators. If ```\nform1```\n is not valid, ```\nform2```\n will not be evaluated and its error messages would be missing.\nThat's only an example. As far as I know, there is no greedy alternative to ```\nand```\n/```\nor```\n as in other languages (i.e. Smalltalk). I can imagine that problem occurring under different circumstances (and not only in Python). The solutions I could think of are all kind of clumsy (nested ```\nif```\ns, assigning the return values to local variables and using them in the ```\nif```\n statement). I would like to know the pythonic way to solve this kind of problem.\n    ", "Answer": "\r\nHow about something like:\n\n```\nif all([form1.is_valid(), form2.is_valid()]):\n   ...\n```\n\n\nIn a general case, a list-comprehension could be used so the results are calculated up front (as opposed to a generator expression which is commonly used in this context).  e.g.:\n\n```\nif all([ form.is_valid() for form in (form1,form2) ])  \n```\n\n\nThis will scale up nicely to an arbitrary number of conditions as well ... The only catch is that they all need to be connected by \"```\nand```\n\" as opposed to ```\nif foo and bar or baz: ...```\n.\n\n(for a non-short circuiting ```\nor```\n, you could use ```\nany```\n instead of ```\nall```\n).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does Objective-C use short-circuit evaluation for messages to nil objects?\r\n                \r\nFollowing the usual short-circuit evaluation question, does short-circuit evaluation work for parameters built and sent against nil objects? Example:\n\n```\nNSMutableArray *nil_array = nil;\n....\n[nil_array addObject:[NSString stringWithFormat:@\"Something big %@\",\n     function_that_takes_a_lot_of_time_to_compute()]];\n```\n\n\nIs that slow function going to be called or will the whole addObject call be optimized out without processing the parameters?\n    ", "Answer": "\r\nA message is always dispatched to an object pointer, regardless of whether it points to an object or points to ```\nnil```\n. Additionally, messages are sent in the runtime and therefore the compiler cannot just assume ```\nnil_array```\n really is ```\nnil```\n and optimize it away. What if the initialization did something else, and ```\nnil_array```\n turns out to be an instance?\n\nThat means all the expressions you pass as arguments to your methods will be evaluated in order to be passed, so no short-circuiting of any sort happens. Your slow function will be executed, and if it takes a long time it'll affect the performance of your program.\n\nEDIT: I just whipped up a little test case for the heck of it (empty Objective-C command line program). If you run this and observe the debugger console, you'll notice that output from all three calls to ```\nfunction_that_takes_a_lot_of_time_to_compute()```\n appears (in 5-second intervals), while output from only ```\nt1```\n's and ```\nt3```\n's ```\ntest:```\n methods appears — naturally, since these are not ```\nnil```\n.\n\nmain.m\n\n```\n#import \"Test.h\"\n\nint function_that_takes_a_lot_of_time_to_compute(void)\n{\n    static int i = 1;\n\n    sleep(5);\n    NSLog(@\"%d\", i);\n\n    return i++;\n}\n\nint main(int argc, const char *argv[])\n{\n    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\n    Test *t1 = [[Test alloc] init], *t2 = nil, *t3 = [[Test alloc] init];\n\n    [t1 test:function_that_takes_a_lot_of_time_to_compute()];\n    [t2 test:function_that_takes_a_lot_of_time_to_compute()]; // nil\n    [t3 test:function_that_takes_a_lot_of_time_to_compute()];\n\n    [t1 release];\n    [t3 release];\n\n    [pool drain];\n    return 0;\n}\n```\n\n\nTest.h\n\n```\n@interface Test : NSObject {}\n\n- (void)test:(int)arg;\n\n@end\n```\n\n\nTest.m\n\n```\n@implementation Test\n\n- (void)test:(int)arg\n{\n    NSLog(@\"Testing arg: %d\", arg);\n}\n\n@end\n```\n\n\nOutput\n\n\n1\nTesting arg: 1\n2\n3\nTesting arg: 3\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is short-circuiting logical operators mandated? And evaluation order?\r\n                \r\nDoes the ANSI standard mandate the logical operators to be short-circuited, in either C or C++?\n\nI'm confused for I recall the K&R book saying your code shouldn't depend on these operations being short circuited, for they may not. Could someone please point out where in the standard it's said logic ops are always short-circuited? I'm mostly interested on C++, an answer also for C would be great.\n\nI also remember reading (can't remember where) that evaluation order isn't strictly defined, so your code shouldn't depend or assume functions within an expression would be executed in a specific order: by the end of a statement all referenced functions will have been called, but the compiler has freedom in selecting the most efficient order.\n\nDoes the standard indicate the evaluation order of this expression?\n\n```\nif( functionA() && functionB() && functionC() ) cout<<\"Hello world\";\n```\n\n    ", "Answer": "\r\nYes, short-circuiting and evaluation order are required for operators ```\n||```\n and ```\n&&```\n in both C and C++ standards.\n\nC++ standard says (there should be an equivalent clause in the C standard):\n\n\n  1.9.18\n  \n  In the evaluation of the following expressions\n\n```\na && b\na || b\na ? b : c\na , b\n```\n\n  \n  using the built-in meaning of the operators in these expressions, there is a sequence point after the evaluation of the first expression (12).\n\n\nIn C++ there is an extra trap: short-circuiting does NOT apply to types that overload operators ```\n||```\n and ```\n&&```\n.\n\n\n  Footnote 12: The operators indicated in this paragraph are the built-in operators, as described in clause 5. When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation, and the operands form an argument list, without an implied sequence point between them.\n\n\nIt is usually not recommended to overload these operators in C++ unless you have a very specific requirement. You can do it, but it may break expected behaviour in other people's code, especially if these operators are used indirectly via instantiating templates with the type overloading these operators.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit evaluation and LINQ-to-NHibernate\r\n                \r\nIt seems that LINQ-to-NHibernate and LINQ-to-SQL does not support short-circuit evaluation in ```\nwhere```\n clause of query.\n\nAm I right? \nIs there any workaround? \nMay it be added to next versions of LINQ-to-NHibernate and LINQ-to-SQL?\n\nfor more information plz see followings:\n\nThe || (or) Operator in Linq with C#\n\nWhy ordinary laws in evaluting boolean expression does not fit into LINQ?\n    ", "Answer": "\r\nHuh?  In LinqToSql, your c# query in code is converted to an expression tree and then a sql statement.  The sql statement is handed to mssqlserver which certainly does do short circuiting.\n\nAlso note: mssqlserver does not throw null reference exceptions.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "CASE expression that does NOT have short-circuit evaluation?\r\n                \r\nI recently began teaching myself (terrible) SQLite.  One thing that struck me as annoying was the CASE expression, namely the fact that it employs short-circuit evaluation.\n\nIs there any way to get around this?  I am looking for a CASE statement that does not employ short-circuit evaluation.\n\n```\nUPDATE [table]SET [counting_column] =\n\n(\nCASE\n    when [column1] = NULL \n    then [counting_column] + 1\n\n    ...\n\n    when [column31] = NULL\n    then [counting_column] + 1\nend\n)\n```\n\n\nI would like each entry in the database to be tested by each case statement, not just the first one that evaluates to true.  Any help would be much appreciated.\n\nNOTE: I apologize if there's some glaring error-- I'm quite new at this so go easy please.\n    ", "Answer": "\r\nIf you are indeed just adding 1 to ```\ncounting_column```\n for each condition that is met, you can use a chain of n ```\nCASE```\n statements and add the results together.  Each individual ```\nCASE```\n supplies a ```\n0```\n or ```\n1```\n, all of which are added together and added to the current value of ```\ncounting_column```\n.\n\n```\nUPDATE [table] SET [counting_column] =\n(\n  [counting_column] + \n  (CASE when [column1] IS NULL then 1 ELSE 0 END) +\n  (CASE when [column2] IS NULL then 1 ELSE 0 END) +\n    ...\n    ...\n  (CASE when [column30] IS NULL then 1 ELSE 0 END) +\n  (CASE when [column31] IS NULL then 1 ELSE 0 END)\n)\n```\n\n\nNote that I have changed the ```\n= NULL```\n to ```\nIS NULL```\n.  ```\nNULL```\n is a special non-value that cannot be compared with an equality ```\n=```\n.\n\nI'll also point out that although ```\n[]```\n enclosed identifiers are ok in SQLite, this is mostly for compatibility with T-SQL.  The more standard approach is to use double-quotes as in ```\nUPDATE \"table\" SET \"counting_column\" = ...```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "if vs short circuit evaluation in Ruby\r\n                \r\nI am wondering what makes if faster than short-circuit evaluation in my code:\n```\nGC.disable\nN = 5000\n\ndef x\n    j = nil\n    N.times {\n        if j\n            j << 'a'.freeze\n        else\n            j = ''\n        end\n    }\n    j\nend\n\ndef y\n    j = nil\n    N.times {\n        j && j << 'a'.freeze || j = ''\n    }\n    j\nend\n\nt = Time.now\nN.times { x }\np Time.now - t\n\nsleep 0.1\n\nt = Time.now\nN.times { y }\np Time.now - t\n```\n\nNo matter how many times I run the code under no extra CPU load, I get:\n```\n3.826009846\n4.137173916\n```\n\nOr something close to that.\nSame goes with integers, if slightly modify the code and make j = nil, and then 0, and then add + 1 to j.\nWhat makes the method y slower than method x?\n    ", "Answer": "\r\nUPDATED as per comment. Here's a way to improve the x method. B is your method, C is the improved version because with this syntax the right side of && never gets executed.  Benchmark is the standard Ruby way of doing exactly what the class is intended to be used for easy to read docs.  To see why ```\nTime.now```\n is not recommended, see this answer.  Also it's common to move the iteration to the Benchmark as to not clutter up your actual methods.\n```\nrequire 'benchmark'\nGC.disable\n\nN=50000\n\nclass Foo\n  def a\n    j = nil\n    if j\n        j << 'a'.freeze\n    else\n        j = 'not nil'\n    end\n    j\n  end\n\n  def b\n    j = nil\n    j && j << 'a'.freeze || j = 'not nil'\n    j\n  end\n\n  def c\n    j = nil\n    j && (j << 'a' || j = 'j')\n    j\n  end\nend\nfoo = Foo.new\nfoo.a\nfoo.b\nfoo.c\nBenchmark.bmbm(10) do |x|\n  x.report(:a) { N.times {foo.a }}\n  puts \"j is no longer nil, but it's a string #{foo.a} <- see\"\n  x.report(:b) { N.times {foo.b }}\n  puts \"j is equal to #{foo.b} which is a string, not nil\"\n  x.report(:c) { N.times {foo.c }}\n  puts \"look for j, nothing here *#{foo.c}* but emptiness\"\nend\n\nputs \"\\n take 2\\n\"\n\nBenchmark.bmbm(10) do |x|\n  x.report(:c) { N.times {foo.c }}\n  x.report(:a) { N.times {foo.a }}\n  x.report(:b) { N.times {foo.b }}\nend\n```\n\nResults:\n```\nj is no longer nil, but it's a string not nil <- see\nj is equal to not nil which is a string, not nil\nlook for j, nothing here ** but emptiness\nRehearsal ----------------------------------------------\na            0.005619   0.001018   0.006637 (  0.007648)\nb            0.005097   0.000924   0.006021 (  0.006847)\nc            0.003488   0.000025   0.003513 (  0.003783)\n------------------------------------- total: 0.016171sec\n\n                 user     system      total        real\na            0.006934   0.000331   0.007265 (  0.010790)\nb            0.004609   0.000086   0.004695 (  0.005038)\nc            0.004939   0.000148   0.005087 (  0.009489)\n\n take 2\nRehearsal ----------------------------------------------\nc            0.004118   0.000097   0.004215 (  0.005652)\na            0.005844   0.000155   0.005999 (  0.017280)\nb            0.005498   0.000161   0.005659 (  0.013625)\n------------------------------------- total: 0.015873sec\n\n                 user     system      total        real\nc            0.006040   0.000133   0.006173 (  0.013035)\na            0.005715   0.000081   0.005796 (  0.006672)\nb            0.004042   0.000016   0.004058 (  0.004220)\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "programming with short-circuit evaluation in Java\r\n                \r\nDoes relying on short-circuit evaluation make the code fragile?\nI wrote a piece of code that essentially looks like the following. My professor wanted me to rewrite it. \n\n(Note: I know for sure that only one of the four conditions will be true, because given any stream, there is only one 'next token', right?)\n\n```\nfoo getFoo()\n{\n        Bar bar;\n        if ((bar = peekAndGet('x')) != null \n                || (bar = peekAndGet('y')) != null \n                || (bar = peekAndGet('z')) != null \n                || (bar = peekAndGet('t')) != null) \n            return produce(bar);\n        else \n            return null;\n}\n```\n\n\nIs this really fragile? I find it working perfectly. But how should I rewrite it?\n    ", "Answer": "\r\nI would refactor it and write it like this:\n\n```\nchar[] values = {'x', 'y', 'z', 't'};\nfor (char c : values) {\n    Bar bar = peekAndGet(c);\n    if (bar != null) return produce(bar);\n}\nreturn null;\n```\n\n\nNote: one good reason to do it, is that the first time I read your code I thought it looked buggy until I read your question. You want to keep those \"Something looks wrong\" moments for things that really are wrong.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What order are conditions evaluated in short circuit evaluation\r\n                \r\nSo I've got 3 conditions for an if-statements, and I want to ensure the first two are true before checking the third one. Here's some pseudo code demonstrating what I mean:\n\n```\nif (A && B && C) {\n   doSomething\n}\n```\n\n\nIs that equivalent to:\n\n```\nif (A && B) {\n   if (C) {\n      doSomething\n   }\n}\n```\n\n\nOr can we not rely on the ordering of the conditions in a short circuit evaluation?\n\nThanks in advance!\n    ", "Answer": "\r\nYes, short circuiting respects the order and will only evaluate until it finds a failure (hence taking a short cut when it knows it can't possibly succeed any more no matter how any future check might evaluate).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "JavaScript short circuit evaluation error?\r\n                \r\nThe two below snippets of JS code have had me confused, in my eyes both should work the same, due to short circuit evaluation. But for some reason snippet '1' causes the error (on the third line): \n\nCannot read property 'match' of undefined \n\nArray 'a' holds 3 character values user entered into inputs. I want the code to return true if the char is undefined, an empty string, or a letter or number.\n\nTo be clear, this fails when a = ['a', '/'];\n\nSnippet 1)\n\n```\nreturn typeof a[0] === 'undefined' || a[0] === '' || a[0].match(/^[a-z0-9]+$/i) \n    && typeof a[1] === 'undefined' || a[1] === '' || a[1].match(/^[a-z0-9]+$/i) \n    && typeof a[2] === 'undefined' || a[2] === '' || a[2].match(/^[a-z0-9]+$/i);\n```\n\n\nSnippet 2)\n\n```\nif (typeof a[0] === 'undefined' || a[0] === '' || a[0].match(/^[a-z0-9]+$/i)) {\n    if (typeof a[1] === 'undefined' || a[1] === '' || a[1].match(/^[a-z0-9]+$/i)) {\n        if (typeof a[2] === 'undefined' || a[2] === '' || a[2].match(/^[a-z0-9]+$/i)) {\n            return true;           \n        }\n        return false;\n    }\n    return false;\n}\nreturn false;\n```\n\n\nSurely a[2].match should never be evaluated if a[2] is undefined due to the first conditional in the 'if'?\n    ", "Answer": "\r\nThe answer is simple. Take a look to the order of operations .\nAND binds more than OR.\n\nIn your Snippet 1 the expression is like:\n\n```\na1 || b1 || (c1 && a2) || b2 || (c2 && a3) || b3 || c3\n```\n\n\nYour Snippet 2 is like:\n\n```\n(a1 || b1 || c1) && (a2 || b2 || c2) && (a3 || b3 || c3)\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short Circuit Evaluation Order\r\n                \r\nAll this time my thinking of short circuit evaluations seems to be wrong.\n\nIn javascript:\n\n```\nvar a = false, b = true, c=true;\na && b || c; // Evaluates to true\n```\n\n\nCompared to\n\n```\nvar a = false, b = true, c=true;\na && (b || c); // Evaluates to true\n```\n\n\nWhy doesn't the VM stop when it sees that ```\na```\n is false?\n\nMore explicit example:\n\n```\nfunction a(){\n  console.log(\"I'm A\");\n  return false;\n}\nfunction b(){\n  console.log(\"I'm B\");\n  return true;\n}\nfunction c(){\n  console.log(\"I'm C\");\n  return true;\n}\n\na() && b() || c();\n```\n\n\nThe output is:\n\n```\nI'm A\nI'm C\ntrue\n```\n\n\nSo apparently \n\n```\na && b || c === (a && b) || c\n```\n\n\nSo I'm confused, why does it automatically wrap the a && b together? What exactly is the order of operations for these expressions?\n\nDo most languages adhere to this order (PHP seems to be like this)?\n    ", "Answer": "\r\nThese simple rules apply:\n- shortcuts in logical expression evaluation does not mean that expressions are evaluated incorrectly, i.e. the result is the same with or witout shortcutting;\n- the AND boolean operator (&&) is of higher precedence than the OR (||). This is why a && b are 'wrapped' together;\n- it is not safe to rely on precedence order, use parentheses ; this improves readability too;\n- most languages do shortcuts when evaluating logical expressions if the result is already defined, incl. PHP; There are exceptions however most notably in reverse polish notation languages like PostScript.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do all? and any? guarantee short-circuit evaluation?\r\n                \r\nTesting out some code in both ```\npry```\n and ```\nirb```\n, I get the following results:\n\n```\n[1] pry(main)> a = [1, 3, 5, 7, 0]\n=> [1, 3, 5, 7, 0]\n[2] pry(main)> a.any? {|obj| p obj; 3 / obj > 1}\n1\n=> true\n[3] pry(main)> a.all? {|obj| p obj; 3 / obj > 1}\n1\n3\n=> false\n```\n\n\nIn ```\n[2]```\n and ```\n[3]```\n I see that there appears to be short-circuit evaluation that aborts the iteration as soon as possible, but is this guaranteed behaviour? Reading the documentation there is no mention of this behaviour. I realise that I can use ```\ninject```\n instead as that will iterate over everything, but I'm interested in finding out what the official Ruby view is.\n    ", "Answer": "\r\nYes.\n\nIn the final draft of the Ruby standard, ```\nall?```\n is defined as such:\n\n\nInvoke the method ```\neach```\n on the receiver\nFor each element X which the method ```\neach```\n yeilds:\n\nIf block is given, call block with X as argument. If this call returns a falseish object, return false.\nIf block is not given, and X is a falseish object, return false.\n\nReturn true.\n\n\nNote the word return in step 2. This guarantees short circuit evaluation. ```\nany?```\n is defined similarly. However the standard is still a draft and I don't know which Ruby implementations (if any) aim to be standards-compliant.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does PySpark support the short-circuit evaluation of conditional statements?\r\n                \r\nI want to create a new boolean column in my dataframe that derives its value from the evaluation of two conditional statements on other columns in the same dataframe:\n```\ncolumns = [\"id\", \"color_one\", \"color_two\"]\ndata = spark.createDataFrame([(1, \"blue\", \"red\"), (2, \"red\", None)]).toDF(*columns)\n\ndata = data.withColumn('is_red', data.color_one.contains(\"red\") | data.color_two.contains(\"red\"))\n```\n\nThis works fine unless either ```\ncolor_one```\n or ```\ncolor_two```\n is NULL in a row. In cases like these, ```\nis_red```\n is also set to ```\nNULL```\n for that row instead of ```\ntrue```\n or ```\nfalse```\n:\n```\n+-------+----------+------------+-------+\n|id     |color_one |color_two   |is_red |\n+-------+----------+------------+-------+\n|      1|      blue|         red|   true|\n|      2|       red|        NULL|   NULL|\n+-------+----------+------------+-------+\n```\n\nThis means that PySpark is evaluating all of the clauses of the conditional statement rather than exiting early (via short-circuit evaluation) if the first condition happens to be true (like in row 2 of my example above).\nDoes PySpark support the short-circuit evaluation of conditional statements?\nIn the meantime, here is a workaround I have come up with to null-check each column:\n```\nfrom pyspark.sql import functions as F\n\ncolor_one_is_null = data.color_one.isNull()\ncolor_two_is_null = data.color_two.isNull()\ndata = data.withColumn('is_red', F.when(color_two_is_null, data.color_one.contains(\"red\"))\n                                  .otherwise(F.when(color_one_is_null, data.color_two.contains(\"red\"))\n                                              .otherwise(F.when(color_one_is_null & color_two_is_null, F.lit(False))\n                                                          .otherwise(data.color_one.contains(\"red\") | data.color_two.contains(\"red\"))))\n                      )\n```\n\n    ", "Answer": "\r\nI don't think Spark support short-circuit evaluation on conditionals as stated here https://docs.databricks.com/spark/latest/spark-sql/udf-python.html#:~:text=Spark%20SQL%20(including,short-circuiting%E2%80%9D%20semantics.:\n\nSpark SQL (including SQL and the DataFrame and Dataset API) does not guarantee the order of evaluation of subexpressions. In particular, the inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order. For example, logical AND and OR expressions do not have left-to-right “short-circuiting” semantics.\n\nAnother alternative way would be creating an array of column_one and column_two, then evaluate if the array contains 'red' using SQL ```\nEXISTS```\n\n```\ndata = data.withColumn('is_red', F.expr(\"EXISTS(array(color_one, color_two), x -> x = 'red')\"))\ndata.show()\n+---+---------+---------+------+\n| id|color_one|color_two|is_red|\n+---+---------+---------+------+\n|  1|     blue|      red|  true|\n|  2|      red|     null|  true|\n|  3|     null|    green| false|\n|  4|   yellow|     null| false|\n|  5|     null|      red|  true|\n|  6|     null|     null| false|\n+---+---------+---------+------+\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation VS 2017 c++\r\n                \r\nI'm trying to get a number from the user using std::string and want to check first if that string is empty and it contains only numbers, and then check if the number there is higher than zero\n\nWhen I build it and just press enter I get an exception unhandled of invalid argument at the stoi function.\n\nI try it in an older version of VS (2012), and get the same error.\n\nDoes short circuit evaluation works on VS?\n\n```\nstatic const bool is_number(const char caracter)\n{\n    return(caracter >= '0' && caracter <= '9');\n}\n\ntemplate <typename T> static const bool all_numbers(const T &str)\n{\n    if (!str.empty())\n    {\n        auto it = str.cbegin();\n\n        if ((str.front() == '+' || str.front() == '-') && (str.size()>1)) ++it;\n\n        for (it; it != str.cend(); ++it) if (!is_number(*it))  return false;\n\n        return true;\n    }\n    else return false;\n}\n\nint main()\n{\n    std::string str;\n\n    do\n    {\n        std::cout << \" Number: \";\n        getline(std::cin, str);\n        std::cin.clear();\n\n    }while (!all_numbers(str) && std::stoi(str) <= 0);\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nOf course short-circuiting works in Visual Studio, and you could easily have verified this for yourself.\n\nHowever, your logic is wrong:\n\n```\n(!all_numbers(str) && std::stoi(str) <= 0);\n```\n\n\nHere you're only performing ```\nstoi```\n if the input isn't all numbers. That is clearly backwards.\n\nI think maybe you meant to write ```\n||```\n instead?\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "In Excel, is there an early opt out AND/OR functions (Short Circuit Evaluation)?\r\n                \r\nIn Excel, is there an early opt out AND function (also known as short-circuit evaluation)?\n\nFor example:\n\n```\n=AND(FALSE, #N/A)\n```\n\n\nReturns #N/A.  If the function was an \"early opt out\", it would return FALSE as soon as the first FALSE was found, as no additional value could make the function ever return true.\n\nDoes such a function exist in excel?\n    ", "Answer": "\r\nWhat you're calling \"early opt out\" is more commonly called \"short-circuit evaluation,\" and is generally a feature of languages in the C/C++/C#/Java family (but, notably, not Visual BASIC).\n\nFor Excel formulas, some logical functions practice short-circuit evaluation but some do not.  ```\nAND```\n does not, as you've found.  Neither does ```\nOR```\n--if the first argument in an ```\nOR```\n expression is true, Excel will still try to evaluate the subsequent arguments.\n\nThe solution is to use nested ```\nIF```\ns; evaluation of ```\nIF```\ns goes step-by-step from outer to inner, branching as necessary, and stopping when there is no further nested formula to be evaluated.  This produces the correct short-circuit behavior.  So you can write your code above as \n\n```\n=IF(FALSE, IF(ISNA(<address of cell to test for the #N/A state>), TRUE), FALSE)\n```\n\n\nAnother example that may be more clear:\n\n```\nCell A1 contains the value 1 and cell A2 contains the formula \"=1/0\",\ncausing a #DIV/0 error.\n\nPut this formula in A3:\n=IF(A1 = 0, IF(A2 = 5, \"Never get here\"), \"Short-circuit OK: A1 <> 0\")\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does PHP have short-circuit evaluation?\r\n                \r\nGiven the following code:\n\n```\nif (is_valid($string) && up_to_length($string) && file_exists($file)) \n{\n    ......\n}\n```\n\n\nIf ```\nis_valid($string)```\n returns ```\nfalse```\n, does the php interpreter still check later conditions, like ```\nup_to_length($string)```\n?\nIf so, then why does it do extra work when it doesn't have to?\n    ", "Answer": "\r\nYes, the PHP interpreter is \"lazy\", meaning it will do the minimum number of comparisons possible to evaluate conditions.\n\nIf you want to verify that, try this: \n\n```\nfunction saySomething()\n{\n    echo 'hi!';\n    return true;\n}\n\nif (false && saySomething())\n{\n    echo 'statement evaluated to true';\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does Python's `all` function use short circuit evaluation?\r\n                \r\nI wish to use the Python ```\nall()```\n function to help me compute something, but this something could take substantially longer if the ```\nall()```\n does not evaluate as soon as it hits a ```\nFalse```\n. I'm thinking it probably is short-circuit evaluated, but I just wanted to make sure. Also, is there a way to tell in Python how the function gets evaluated?\n\nBecause ```\nany```\n and ```\nall```\n are functions, their arguments must be evaluated before they are called. That often creates the impression of no short-circuiting - but they do still short-circuit. To work around the problem, pass a generator expression, or other lazily evaluated expression, rather than a sequence. See Python: Lazy Function Evaluation in any() / all() for details.\n    ", "Answer": "\r\nYes, it short-circuits:\n\n```\n>>> def test():\n...     yield True\n...     print('one')\n...     yield False\n...     print('two')\n...     yield True\n...     print('three')\n...\n>>> all(test())\none\nFalse\n```\n\n\nFrom the docs:\n\nReturn True if all elements of the iterable are true (or if the iterable is empty). Equivalent to:\n\n```\ndef all(iterable):\n    for element in iterable:\n        if not element:\n            return False\n    return True\n```\n\n\n\n\nSo when it ```\nreturn```\ns False, then the function immediately breaks.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "CASE and COALESCE short-circuit evaluation works with sequences in PL/SQL but not in SQL\r\n                \r\nDoes the short-circuit evaluation described in the documentation for ```\nCASE```\n and ```\nCOALESCE()```\n apply to sequences when used in SQL? This does not appear to be happening.\n\nThe Oracle documentation on ```\nCASE```\n states that:\n\n\n  Oracle Database uses short-circuit evaluation. For a simple ```\nCASE```\n expression... Oracle never evaluates a comparison_expr if a previous comparison_expr is equal to expr. For a searched CASE expression, the database... never evaluates a condition if the previous condition was true.\n\n\nSimilarly for ```\nCOALESCE()```\n the documentation states that:\n\n\n  Oracle Database uses short-circuit evaluation. The database evaluates each expr value and determines whether it is NULL, rather than evaluating all of the expr values before determining whether any of them is NULL.\n\n\nWhen calling a sequence from SQL this does not appear to be the case; as you can see no short circuiting occurs and the sequence is incremented.\n\n```\nSQL> create sequence tmp_test_seq start with 1 increment by 1;\nSQL> select tmp_test_seq.nextval from dual;\n\n   NEXTVAL\n----------\n         1\nSQL> select tmp_test_seq.currval from dual;\n\n   CURRVAL\n----------\n         1\nSQL> select coalesce(1, tmp_test_seq.nextval) from dual;\n\nCOALESCE(1,TMP_TEST_SEQ.NEXTVAL)\n--------------------------------\n                               1\nSQL> select tmp_test_seq.currval from dual;\n\n   CURRVAL\n----------\n         2\nSQL> select case when 1 = 1 then 1 else tmp_test_seq.nextval end as s from dual;\n\n\n         S\n----------\n         1\nSQL> select tmp_test_seq.currval from dual;\n\n   CURRVAL\n----------\n         3\n```\n\n\nSQL Fiddle.\n\nHowever, when calling from PL/SQL the sequence is not incremented:\n\n```\nSQL> create sequence tmp_test_seq start with 1 increment by 1;\nSQL> declare\n  2     i number;\n  3  begin\n  4     i := tmp_test_seq.nextval;\n  5     dbms_output.put_line(tmp_test_seq.currval);\n  6     i := coalesce(1, tmp_test_seq.nextval);\n  7     dbms_output.put_line(i);\n  8     dbms_output.put_line(tmp_test_seq.currval);\n  9     i := case when 1 = 1 then 1 else tmp_test_seq.nextval end;\n 10     dbms_output.put_line(i);\n 11     dbms_output.put_line(tmp_test_seq.currval);\n 12  end;\n 13  /\n1\n1\n1\n1\n1\nSQL> select tmp_test_seq.nextval from dual;\n\n   NEXTVAL\n----------\n         2\n```\n\n\nCalling the sequence in SQL from PL/SQL the same results as with SQL happens:\n\n```\nSQL> create sequence tmp_test_seq start with 1 increment by 1;\nSQL> declare\n  2     i number;\n  3  begin\n  4     select tmp_test_seq.nextval into i from dual;\n  5     dbms_output.put_line(tmp_test_seq.currval);\n  6     select coalesce(1, tmp_test_seq.nextval) into i from dual;\n  7     dbms_output.put_line(i);\n  8     dbms_output.put_line(tmp_test_seq.currval);\n  9     select case when 1 = 1 then 1 else tmp_test_seq.nextval end into i\n 10       from dual;\n 11     dbms_output.put_line(i);\n 12     dbms_output.put_line(tmp_test_seq.currval);\n 13  end;\n 14  /\n1\n1\n2\n1\n3\n```\n\n\nThere doesn't seem to be anything in the documentation about this; the Administrator's guide for managing sequences, the SQL language reference on sequence psuedocolumns, the PL/SQL language reference on CURRVAL and NEXTVAL or the database concepts overview of sequences.\n\nDoes the short-circuit evaluation of ```\nCASE```\n and ```\nCOALESCE()```\n occur for sequences when used in SQL? Is this documented?\n\nWe're on 11.2.0.3.5 if it's of interest.\n    ", "Answer": "\r\nFor PL/SQL Oracle assures that it will use short-circuit evaluation:\n\n\n  When evaluating a logical expression, PL/SQL uses short-circuit\n  evaluation. That is, PL/SQL stops evaluating the expression as soon as\n  it can determine the result. Therefore, you can write expressions that\n  might otherwise cause errors.\n\n\nFrom: 2 PL/SQL Language Fundamentals\n\nWhen you use the ```\nnextval```\n in SQL code, we have a different situation.\n\nFirst of all we have to keep in mind that ```\ncurrval```\n and ```\nnextval```\n are pseudocolumns:\n\n\n  A pseudocolumn behaves like a table column, but is not actually stored\n  in the table. You can select from pseudocolumns, but you cannot\n  insert, update, or delete their values. A pseudocolumn is also similar\n  to a function without arguments (please refer to Chapter 5,\n  \"Functions\". However, functions without arguments typically return the\n  same value for every row in the result set, whereas pseudocolumns\n  typically return a different value for each row.\n\n\nFrom: 3 Pseudocolumns. \n\nThe question now is: why Oracle evaluate ```\nnextval```\n? or Is this behaviour stated somewhere?\n\n\n  Within a single SQL statement containing a reference to NEXTVAL,\n  Oracle increments the sequence once:\n  \n  \n  For each row returned by the outer query block of a SELECT statement.    Such a query block can appear in the following places:\n  \n  \n  A top-level SELECT statement\n  An INSERT ... SELECT statement (either single-table or multitable).    For a multitable insert, the reference to NEXTVAL must\n  appear in the    VALUES clause, and the sequence is updated once for\n  each row returned by the subquery, even though NEXTVAL may be\n  referenced in multiple    branches of the multitable insert.\n  A CREATE TABLE ... AS SELECT statement\n  A CREATE MATERIALIZED VIEW ... AS SELECT statement\n  \n  For each row updated in an UPDATE statement\n  For each INSERT statement containing a VALUES clause\n  For each row merged by a MERGE statement. The reference to NEXTVAL can appear in the merge_insert_clause or the merge_update_clause or\n  both. The NEXTVALUE value is incremented for each row updated and for\n  each row inserted, even if the sequence number is not actually used in\n  the update or insert operation. If NEXTVAL is specified more than once\n  in any of these locations, then the sequence is incremented once for\n  each row and returns the same value for all occurrences of NEXTVAL for\n  that row.\n  \n\n\nFrom: Sequence Pseudocolumns\n\nYour case is clearly \"1. A top-level SELECT statement\", but it doesn't mean that the short-circuit logic is not in place, but only that ```\nnextval```\n is always evaluated.\n\nIf you are interested to the short-circuit logic, then it's better to remove the ```\nnextval```\n from the equation.\n\nA query like this doesn't evaluate the subquery:\n\n```\nselect 6 c\n  from dual\nwhere  'a' = 'a' or 'a' = (select dummy from dual) \n```\n\n\nBut if try to do something similar with ```\ncoalesce```\n or ```\ncase```\n we will see that the Oracle Optimizer decides to execute the subqueries:\n\n```\nselect 6 c\n  from dual\nwhere  'a' = coalesce('a', (select dummy from dual) )\n```\n\n\nI created annotated tests in this demo in SQLFiddle to show this.\n\nIt looks like Oracle applies the short-circuit logic only if with OR condition, but with ```\ncoalesce```\n and ```\ncase```\n it has to evaluate all branches.\n\nI think your first tests in PL/SQL shows that ```\ncoalsce```\n and ```\ncase```\n use a short-circuit logic in PL/SQL, as Oracle states. Your second test, including the sequence in SQL statements, shows that in that case the ```\nnextval```\n is evaluated anyway, even if the result is not used, and Oracle also documents that. \n\nPutting together the two things looks a bit odd, because ```\ncoalesce```\n and ```\ncase```\n behaviour seems to be really inconsistent too me too, but we have also to keep in mind that the implementation of that logic is implementation dependent (here my source)\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Visual Studio C# and Short-circuit evaluation\r\n                \r\nWith the || Operator, Microsoft describes  short circuit evaluation here Short Circuit Evaluation\n\nHowever, I have the following code which seems to contradict this process:\n\n```\n  if ((_opcLoaded || DoLoadOPC()) &&\n     (_tagsAdded || DoAddTags()) &&\n     DoWriteRecipe() && \n     (DoResume()))\n```\n\n\nWhat I'm trying to prevent is the function DoAddTags from being called if _tagsAdded is true (DoAddTags sets _tagsAdded to true).\n\nHowever, I'm finding that ```\nDoAddTag```\ns is called even when ```\n_tagsAdded```\n is true. It's the same for ```\n_opcLoaded```\n and ```\nDoLoadOPC```\n. I've had to put a condition inside ```\nDoAddTags```\n to check for ```\n_tagsAdded```\n, which shouldn't be necessary.\n\nCan someone explain why this is happening?\n\nHere is the Complete Code\n\n```\n    //\n                        // Resume a Paused recipe\n                    case MonitoredTasks.Resume:\n                        Task.Factory.StartNew(() =>\n                            {\n                                MonitoredTask = MonitoredTasks.None;\n                                if ((_opcLoaded || DoLoadOPC()) &&\n                                      **(_tagsAdded || DoAddTags())** &&\n                                      DoWriteRecipe() && \n                                      (DoResume()))\n                                {\n                                    MonitoredTask = MonitoredTasks.None;\n                                    RunningState = RecipeRunningStates.Running;\n                                    Status = CIPStatuses.Running;\n                                }\n                                else\n                                {\n                                    MonitoredTask = MonitoredTasks.Resume;\n                                }\n                            });\n\n                        break;\n```\n\n\nAnd the code for DoAddTags\n\n```\n        /// <summary>\n    /// Adds all necessary tags to the OPC Server Manager\n    /// </summary>\n    /// <returns></returns>\n    bool DoAddTags()\n    {\n\n        bool result = false;\n        var oldActivity = Activity;\n        //\n        // Not doing anything OPC related?\n        if (Activity != CIPActivities.AddingOPCTags && !_tagsAdded && Activity != CIPActivities.StartingOPC)\n        {\n            lock (_locks[LOCK_OPC])\n            { \n                Activity = CIPActivities.AddingOPCTags;\n                Status = CIPStatuses.Initialising;\n                RecipeError = Errors.None;\n                try\n                {\n                    //\n                    // Reset connection and internal tags list\n                    _serverManager.Reset();\n\n                    //\n                    // Now to add all OPC Tags - Area\n                    CIPStatusTag = _serverManager.AddTag(_area.CIPStatusTag);\n                    RecipeIDTag = _serverManager.AddTag(_area.RecipeIDTag);\n                    RecipeInstructionIDTag = _serverManager.AddTag(_area.RecipeInstructionIDTag);\n                    HandshakingTag = _serverManager.AddTag(_area.HandshakingTag);\n                    GlobalInstructionIDTag = _serverManager.AddTag(_area.GlobalInstructionIDTag);\n                    InstructionAttemptsTag = _serverManager.AddTag(_area.InstructionAttemptsTag);\n\n                    //\n                    // Area tags OK?\n                    if (CIPStatusTag == null || RecipeIDTag == null || RecipeInstructionIDTag == null || HandshakingTag == null || GlobalInstructionIDTag == null || InstructionAttemptsTag == null)\n                    {\n                        RecipeError = Errors.InvalidAreaTags;\n                        DoError(new RecipeErrorHandlerEventArgs(this) { Message = FormatMessage(\"CIPRecipe.DoAddTags - Invalid AREA Tags\"), Sender = this });\n                    }\n                    else\n                    {\n\n                        VM_CIPInstruction vm = null;\n                        bool instructionTagErrors = false;\n                        //\n                        // For each area instruction that is used, assig a link to the instruction\n                        foreach (var i in _areaInstructions)\n                        {\n                            //\n                            // Create a View Model for the specified area instruction : this allows us to determine the number of parameters (tags) that apply to the instruction\n                            vm = new VM_CIPInstruction(i.Value.Instruction);\n                            //\n                            // Assign device reference tags\n                            if (vm.DeviceReferencesAvailable)\n                            {\n                                i.Value.DeviceTag = _serverManager.AddTag(i.Value.Instruction.DeviceReferenceTag);\n                                instructionTagErrors = i.Value.DeviceTag == null;\n                            }\n                            //\n                            // For  each required parameter, add tag\n                            for (int paramNo = 1; paramNo <= vm.NoOfParams; paramNo++)\n                            {\n                                switch (paramNo)\n                                {\n                                    case 1:\n                                        //\n                                        // Tag defined? Add it \n                                        if (vm.AreaInstruction.Param1Tag >= 0)\n                                        {\n                                            i.Value.Param1 = _serverManager.AddTag(i.Value.Instruction.Param1Tag);\n\n                                            if (i.Value.Param1 == null)\n                                            {\n                                                instructionTagErrors = true;\n                                            }\n                                        }\n                                        else\n                                        {\n                                            instructionTagErrors = true;\n                                        }\n                                        break;\n                                    case 2:\n                                        //\n                                        // Tag defined? Add it \n                                        if (vm.AreaInstruction.Param2Tag >= 0)\n                                        {\n                                            i.Value.Param2 = _serverManager.AddTag(i.Value.Instruction.Param2Tag);\n\n                                            if (i.Value.Param2 == null)\n                                            {\n                                                instructionTagErrors = true;\n                                            }\n                                        }\n                                        else\n                                        {\n                                            instructionTagErrors = true;\n                                        }\n                                        break;\n                                    case 3:\n                                        //\n                                        // Tag defined? Add it \n                                        if (vm.AreaInstruction.Param3Tag >= 0)\n                                        {\n                                            i.Value.Param3 = _serverManager.AddTag(i.Value.Instruction.Param3Tag);\n\n                                            if (i.Value.Param3 == null)\n                                            {\n                                                instructionTagErrors = true;\n                                            }\n                                        }\n                                        else\n                                        {\n                                            instructionTagErrors = true;\n                                        }\n                                        break;\n                                    case 4:\n                                        //\n                                        // Tag defined? Add it and then check quality\n                                        if (vm.AreaInstruction.Param4Tag >= 0)\n                                        {\n                                            i.Value.Param4 = _serverManager.AddTag(i.Value.Instruction.Param4Tag);\n\n                                            if (i.Value.Param4 == null)\n                                            {\n                                                instructionTagErrors = true;\n                                            }\n                                        }\n                                        else\n                                        {\n                                            instructionTagErrors = true;\n                                        }\n                                        break;\n\n                                    case 5:\n                                        //\n                                        // Tag defined? Add it and then check quality\n                                        if (vm.AreaInstruction.Param5Tag >= 0)\n                                        {\n                                            i.Value.Param5 = _serverManager.AddTag(i.Value.Instruction.Param5Tag);\n\n                                            if (i.Value.Param5 == null)\n                                            {\n                                                instructionTagErrors = true;\n                                            }\n                                        }\n                                        else\n                                        {\n                                            instructionTagErrors = true;\n                                        }\n                                        break;\n\n                                    case 6:\n                                        //\n                                        // Tag defined? Add it and then check quality\n                                        if (vm.AreaInstruction.Param6Tag >= 0)\n                                        {\n                                            i.Value.Param6 = _serverManager.AddTag(i.Value.Instruction.Param6Tag);\n\n                                            if (i.Value.Param6 == null)\n                                            {\n                                                instructionTagErrors = true;\n                                            }\n                                        }\n                                        else\n                                        {\n                                            instructionTagErrors = true;\n                                        }\n                                        break;\n                                }\n                            }\n\n                            if (instructionTagErrors)\n                            {\n                                RecipeError = Errors.InvalidInstructionTags;\n                                DoError(new RecipeErrorHandlerEventArgs(this) { Message = FormatMessage(String.Format(\"CIPRecipe.DoAddTags - Invalid Instruction {0} Tags\", vm.Name)), Sender = this });\n                                break;\n                            }\n                        }\n                        //\n                        // Any problems adding tags?\n                        if (RecipeError == Errors.None)\n                        {\n                            Activity = CIPActivities.StartingOPC;\n                            //\n                            // Once all tags added, start OPC Server\n                            result = _serverManager.Start();\n\n                            if (!result)\n                            {\n                                Status = CIPStatuses.AddTagsFailed;\n                                RecipeError = Errors.OPC;\n                                DoError(new RecipeErrorHandlerEventArgs(this) { Message = FormatMessage(\"CIPRecipe.DoAddTags - Start of OPC failed\"), Sender = this });\n                            }\n                            else\n                            {\n                                **_tagsAdded = true;**\n                                Status = CIPStatuses.TagsAdded;\n                            }\n                        }\n                        else\n                        {\n                            Status = CIPStatuses.AddTagsFailed;\n                        }\n                    }\n                }\n                catch (Exception ex)\n                {\n                    RecipeError = Errors.Exception_AddTags;\n                    DoError(new RecipeErrorHandlerEventArgs(this) { Message = FormatMessage(\"CIPRecipe.DoAddTags\"), Exception = ex, Sender = this });\n                }\n                finally\n                {\n                    Activity = oldActivity;\n                }\n            }\n        }\n        return Status == CIPStatuses.TagsAdded;\n    }\n```\n\n\nI've highlighted the relevant lines with **\n\nOn the first pass DoAddTags is executed and _tagsAdded set to TRUE- I've placed a breakpoint here, so I know it is being set. Shortly afterwards (with or without the former breakpoint) DoAddTags is again entered (on the first line) despite_doAddTags == true.\n\nI've even set a breakpoint on the code \"(_tagsAdded || DoAddTags())\". _tagsAdded == true, yet DoAddTags is still entered.\n\nSo what I'm seeing is, and all the Watches/Debugging info is consistent with is that DoAddTags is being called whilst _tagsAdded == true\n    ", "Answer": "\r\nThis code won't display the behavior you describe, the short-circuiting works just as described.\n\nWhat actually happens: ```\n_tagsAdded```\n is initially ```\nfalse```\n, so ```\nDoAddTags()```\n is called, which sets ```\n_tagsAdded```\n to ```\ntrue```\n.\n\nThen the debugger kicks in, you inspect ```\n_tagsAdded```\n and see it's ```\ntrue```\n.\n\nInstead step through your code using F11 and inspect or watch all relevant variables.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Linear Search and Short Circuit Evaluation (run time error)\r\n                \r\nI am studying computer science (distance learning) and am confused about an \"extra info question\" that appears in the textbook but which has no answer. It's regarding the linear search algorithm and short circuit evaluation. \n\nThe algorithm for a linear search in the book is written as follows:\n\npointer = 0\nWHILE pointer < LengthOfList  AND   list[pointer] != searchedfor:\n      ------  Add one to pointer\nENDWHILE\nIF pointer >= LengthOfList THEN:\n------- PRINT(\"Item is not in the list\")\nELSE\n    ------- PRINT(\"Item is at location \" +pointer)\nENDIF     \n\nIn the extra info box it talks about short circuit evaluation and how when there are multiple parts linked by Boolean operators the computer only evaluates the second condition if it is necessary. So I get that with Condition 1 AND Condition 2 (when using short circuit evaluation) Condition 2 will not be evaluated if Condition 1 is false. \n\nHowever it then asks   \"Can you spot the run-time error that might occur if short-circuit evaluation wasn't in use in the line:\n\nWHILE pointer < LengthOfList  AND list[pointer] != searched for    \"\n\nI have searched and searched for an answer and have run through the algorithm on paper with different items over and over for the past 2 weeks but I just cannot get my head round what the run time error could possibly be. Could anyone please see if they can spot this error and explain it to me? Many thanks.\n    ", "Answer": "\r\nI think the question needs to be reevaluated here. First, let's define short-circuit evaluation. Short-circuit evaluation is the use of boolean operators such as ```\n&&```\n(the AND operator) and ```\n||```\n(the OR operator) so that only one of two arguments have to be checked due to the result of one argument. For example consider these examples where ```\nA```\n and ```\nB```\n are conditions,\n\n```\nif(A && B)\n```\n\n\nAccording to short-circuit evaluation, if A is false then B will never have to be checked since the overall result of ```\nA && B```\n is false no matter what B is and the if statement's body will be skipped.\n\n```\nif(A || B)\n```\n\n\nHere according to short-circuit evaluation, if A is true then B will never have to be checked since the overall result of ```\nA || B```\n is true no matter what B is and the if statement's body is executed.\n\nNow the question is asking what will happen if short circuit evaluation is NOT used. So the question is just asking about the errors of a differently written algorithm (note the algorithm you have written above is completely fine as it is). In essence, what errors can occur if both conditions in the while loop are checked with each iteration? Because right now, what's preventing the runtime error is that in the last iteration, only the first condition is checked to prevent an ```\nArrayIndexOutOfBoundsException```\n. If the last iteration of the while loop checked both conditions, then a runtime error would occur because the program is trying to access an element that is outside the bounds of the array.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit evaluation on C++ logical && and || operators\r\n                \r\nUser overloaded logical operators in C++ ( ```\n&&, ||```\n) behave like regular functions. That is, both arguments in ```\nbool operator&&(const T &a, const T2 &b);```\nare evaluated before entering the function, as entering a function is a sequence point[1] in C++. All good up to here. \n\nNow, “builtin operators && and || perform short-circuit evaluation” [2][3], where there is a sequence point between the left and right sides. The cited reference isn’t clear what “builtin” are, only that they take ```\nbool```\n operands, or convert them using “contextual conversion to bool”. It also mentions that only “two standard library classes overload these operators [because] the short-circuiting properties (...) do not apply to overloads, and because types with boolean semantics are uncommon.” [2]\n\nTypes with boolean semantics? How exactly do “builtin operators” work? Is it simply impossible to define logical operators with short-circuit evaluation? \n\n[1] https://en.wikipedia.org/wiki/Sequence_point\n\n[2] http://en.cppreference.com/w/cpp/language/operator_logical\n\n[3] https://en.wikipedia.org/wiki/Short-circuit_evaluation\n    ", "Answer": "\r\nYou can imagine that a short-circuit ```\n&&```\n acts like this:\n\n```\nbool b = expr1 && expr2;\n```\n\n\nfirst, it takes ```\nexpr1```\n and ```\nexpr2```\n and stores them in lambdas:\n\n```\nbool b = and_helper( [&]{return expr1;}, [&]{return expr2;} );\n```\n\n\nand forwards them to a helper, where ```\nand_helper```\n is (simplified slightly):\n\n```\ntemplate<class Lhs, class Rhs>\nbool and_helper( Lhs&& lhs, Rhs&& rhs ) {\n  if (lhs()) return rhs();\n  return false;\n}\n```\n\n\nthis has similar short-circuit behavior.\n\nFor user-overridden ```\n&&```\n to work this way, we'd have to auto-lambda the arguments and pass said lambdas into the user-written ```\noperator&&```\n.\n\nSo the only barrier for this to happen with user-defined operations is syntactic.  You can get the same behavior after a relatively mechanical transformation of your types, without resorting to magic.\n\nThe compiler just did a roughly equivalent operation (even before lambdas existed) when it ran into that construct.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Expression tree library ignores short-circuit evaluation concept\r\n                \r\nPlease, take a look at following proof of concept:\n\n```\nprivate class Model\n{\n    public string Data { get; set; }\n    public bool NonEmpty() { return Data.Length > 0; }\n}\n\nprivate static Func<Model, bool> Compile()\n{\n    var type = typeof(Model);\n    var expr = Expression.Parameter(typeof(Model));\n\n    var subarg1 = Expression.Property(expr, type.GetProperty(\"Data\"));\n    var subarg2 = Expression.Constant(null);\n    var arg1 = Expression.NotEqual(subarg1, subarg2);\n\n    var arg2 = Expression.Call(expr, type.GetMethod(\"NonEmpty\"));\n\n    var tree = Expression.And(arg1, arg2); // Data != null && NonEmpty()\n    var func = Expression.Lambda<Func<Model, bool>>(tree, expr).Compile();\n    return func;\n}\n\nvar model = new Model {Data = null};\nvar standardTest = model.Data != null && model.NonEmpty(); // returns false\nvar exprTreeTest = Compile().Invoke(model); // throws null ref exception\n```\n\n\nBecause the first operand evaluates to false, the result of the AND operation is false no matter what the value of second one may be. That's why the second operand shouldn't be computed. While C# compiler does it correctly, expression library does not. \n\nHow to fix my code to respect the short-circuit evaluation?\n    ", "Answer": "\r\n```\nExpression.And```\n represents the non-short circuiting AND operator (```\n&```\n).\n\n```\nExpression.AndAlso```\n represents the short circuiting AND operator (```\n&&```\n).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does PHP have short-circuit evaluation?\r\n                \r\nGiven the following code:\n\n```\nif (is_valid($string) && up_to_length($string) && file_exists($file)) \n{\n    ......\n}\n```\n\n\nIf ```\nis_valid($string)```\n returns ```\nfalse```\n, does the php interpreter still check later conditions, like ```\nup_to_length($string)```\n?\nIf so, then why does it do extra work when it doesn't have to?\n    ", "Answer": "\r\nYes, the PHP interpreter is \"lazy\", meaning it will do the minimum number of comparisons possible to evaluate conditions.\n\nIf you want to verify that, try this: \n\n```\nfunction saySomething()\n{\n    echo 'hi!';\n    return true;\n}\n\nif (false && saySomething())\n{\n    echo 'statement evaluated to true';\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Safety concerns about short circuit evaluation [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Is short-circuiting boolean operators mandated in C/C++? And evaluation order?  \n\n\n\n\nAFAIK Short circuit evaluation means that a boolean expression is evaluated only up to the point that we can guarantee its outcome.\n\nThis is a common idiom in perl where we can write things like:\n(is_ok() returns non-zero value on \"OK\")\n\n```\nis_ok() || die \"It's not OK!!\\n\";\n```\n\n\ninstead of\n\n```\nif ( ! is_ok() ) {\n    die \"It's not OK!!\\n\";\n}\n```\n\n\nThis only works because the order of evaluation is always left-to right and that guarantees that the rightmost statement is only executed if the first statement if not \"false\".\n\nIn C I can do something simillar like:\n\n```\nstruct foo {\n    int some_flag;\n} *ptr = 0;\n\n/* do some work that may change value of ptr */\nif ( 0!=ptr && ptr->some_flag ) {\n    /* do something */\n}\n```\n\n\nIs it safe to use this kind of idiom?\n\nOr is there any chance that the compiler may generate code that evaluates ```\nptr->some_flag```\n before making sure that ptr is not a zero pointer? (I am assuming that if it is non-null it points to some valid memory region).\n\nThis syntax is convenient to use because it saves typing without losing readability (in my opinion anyway). However I'm not sure if it is entirely safe which is why I'd like to learn more on this.\n\nNB: If the compiler has an effect on this, I'm using gcc 4.x\n    ", "Answer": "\r\nThe evaluation order of short-circuit operators (```\n||```\n and ```\n&&```\n) is guaranteed by the standard to be left to right (otherwise they would lose part of their usefulness).\n\n§6.5.13 ¶4\n\n\n  Unlike the bitwise binary ```\n&```\n operator, the ```\n&&```\n operator guarantees left-to-right evaluation;\n  there is a sequence point after the evaluation of the first operand. If the first operand\n     compares equal to ```\n0```\n, the second operand is not evaluated.\n\n\n§6.5.14 ¶4\n\n\n  Unlike the bitwise ```\n|```\n operator, the ```\n||```\n operator guarantees left-to-right evaluation; there is\n  a sequence point after the evaluation of the first operand. If the first operand compares\n     unequal to 0, the second operand is not evaluated.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to avoid short circuit evaluation in C# while doing the same functionality\r\n                \r\nDo we have any operator in C# by which I can avoid short circuit evaluation and traverse to all the conditions. \n\nsay \n\n```\nif(txtName.Text.xyz() || txtLastName.Text.xyz())\n{\n\n}\n\npublic static bool xyz(this TextBox txt)\n{\n//do some work.\nreturn false;\n}\n```\n\n\nIt should evaluate all conditions irrespective of output obtained. And after evaluating last condition continues according to result obtained. ?\n    ", "Answer": "\r\nJust use a single bar, this will evaluated both arguments regardless of the outcome of the first result.\n\n```\nif(txtName.Text.xyz() | txtLastName.Text.xyz()) { }\n```\n\n\nYou can also do the same with AND, i.e. You can replace ```\n&&```\n with a single ampersand to get the same affect as above:\n\n```\nif(txtName.Text.xyz() & txtLastName.Text.xyz()) { } // Both sides will be called\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C# short-circuit evaluation without return value\r\n                \r\nI have an EventHandler, it needs to call function with different values. If anyone returns true then stop going and return. That fits || short-circuit evaluation. What's the best way to write this?\n\nExample:\n\n```\nprivate void EventHandler(object sender, EventArgs e)\n{\n    // how to call foo(1), foo(3), foo(2)?\n}\nprivate bool foo(int i)\n{\n    return i == 3;\n}\n```\n\n\nboring one without ||:\n\n```\nprivate void EventHandler(object sender, EventArgs e)\n{\n    if (foo(1)) { return; }\n    if (foo(3)) { return; }\n    foo(2);\n}\n```\n\n\nError:\n\n```\nprivate void EventHandler(object sender, EventArgs e)\n{\n    foo(1) || foo(3) || foo(2);\n}\n```\n\n\nSilly one with || and useless return:\n\n```\nprivate void EventHandler(object sender, EventArgs e)\n{\n    if (foo(1) || foo(3) || foo(2)) { return; }\n}\n```\n\n\nSilly one with || and useless assignment:\n\n```\nprivate void EventHandler(object sender, EventArgs e)\n{\n    var boo = foo(1) || foo(3) || foo(2);\n}\n```\n\n\nSilly one with additional function:\n\n```\nprivate void EventHandler(object sender, EventArgs e)\n{\n    bar();\n}\nprivate bool bar()\n{\n    return foo(1) || foo(3) || foo(2);\n}\n```\n\n\nComplex one:\n\n```\nprivate void EventHandler(object sender, EventArgs e)\n{\n    foreach (int i in new[] { 1, 3, 2 })\n    {\n        if (foo(i))\n        {\n            return;\n        }\n    }\n}\n```\n\n\nLinq one (harder to understand and maintain):\n\n```\nprivate void EventHandler(object sender, EventArgs e)\n{\n    (new[] { 1, 3, 2 }).Any(i => foo(i));\n}\n```\n\n\nMy best choice is useless return. Do you have other choices?\n    ", "Answer": "\r\nA loop seems to be the best choice, if you have a lot of different values.\nif it's only a few values (no more then 3 or 4) you can go with the useless return, or something like this (that's basically the same):\n\n```\nprivate void EventHandler(object sender, EventArgs e)\n{\n   if (foo(1) || foo(3) || foo(2)) { /* do nothing */ }\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short Circuit Evaluation of Logicals in Impala?\r\n                \r\nI am new to Impala having come from an Oracle SQL background. I am tasked with improving an existing SQL script from a performance point of view. The existing script includes the following in the where clause\n```\ncolA > 0 and colB - colA > 10```\n\nI am fairly sure that the first part, ```\ncolA > 0```\n, is just there in an effort to prevent the second part being evaluated. I am of this opinion because, in the context that this script is being run, the evaluation of ```\ncolB - colA > 10```\n can go ahead irrespective of whether ```\ncolA > 0```\n or not.\nCan someone confirm to me that neither AND nor OR are short-circuit evaluated in Impala? I would be really surprised if they are but I cannot find a definitive answer anywhere.\n    ", "Answer": "\r\nIts hard to find this information in the internet, free version of chatGPT is not sure so i think that we can take a look at source code and try to find something here\nLets start from sql-scanner (Lexer in jflex): sql-scanner.flex\n```\npublic static void init(TReservedWordsVersion reservedWordsVersion) {\n    // initilize keywords\n    keywordMap = new LinkedHashMap<>();\n    keywordMap.put(\"&&\", SqlParserSymbols.KW_AND);\n    keywordMap.put(\"add\", SqlParserSymbols.KW_ADD);\n    keywordMap.put(\"aggregate\", SqlParserSymbols.KW_AGGREGATE);\n    keywordMap.put(\"all\", SqlParserSymbols.KW_ALL);\n    keywordMap.put(\"alter\", SqlParserSymbols.KW_ALTER);\n    keywordMap.put(\"analytic\", SqlParserSymbols.KW_ANALYTIC);\n    keywordMap.put(\"and\", SqlParserSymbols.KW_AND);\n```\n\nHere you can see that in Impala you can't use \"&\", the second thing is that \"and\" and \"&&\" are resolved to the same key word - KW_AND\nIt suggests that only short-circuit \"and\" is used in Impala but lets dig deeper\nIn sql parser i found this: sql-parser\n```\ncompound_predicate ::=\n  expr:e1 KW_AND expr:e2\n  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.AND, e1, e2); :}\n  | expr:e1 KW_OR expr:e2\n  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.OR, e1, e2); :}\n  | KW_NOT expr:e\n  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT, e, null); :}\n  | NOT expr:e\n  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT, e, null); :}\n  ;\n```\n\nWhich shows that KW_AND with its operands is translated to CompoundPredicate(CompoundPredicate.Operator.AND, e1, e2)\nIn this file i found this: AndPredicate\n```\n// (<> && false) is false, (true && NULL) is NULL\nBooleanVal AndPredicate::GetBooleanValInterpreted(\n    ScalarExprEvaluator* eval, const TupleRow* row) const {\n  DCHECK_EQ(children_.size(), 2);\n  BooleanVal val1 = children_[0]->GetBooleanVal(eval, row);\n  if (!val1.is_null && !val1.val) return BooleanVal(false); // short-circuit\n\n  BooleanVal val2 = children_[1]->GetBooleanVal(eval, row);\n  if (!val2.is_null && !val2.val) return BooleanVal(false);\n\n  if (val1.is_null || val2.is_null) return BooleanVal::null();\n  return BooleanVal(true);\n}\n```\n\nWhich probably confirms that it is short-circuit but i think that you should treat my finding with causion.\nYou can try to dig dipper if you want to see more, i think that my answer is good starting point :)\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is there a way to tell python to stop short-circuit evaluation?\r\n                \r\nI want to check if a list contains 1 or 2 or 3\n```\n    arr = [2,5,7]\n    if (1 or 2 or 3) in arr:\n      print(\"true\")\n    else: \n      print(\"false\")\n```\n\nI know this will print false, because of short-circuit evaluation.\nHowever, is there a way I can tell Python to stop this style of evaluation, without laying out each condition?\nI've tried any(), all() but they only seem to work for iterables\n    ", "Answer": "\r\nOne way to do this is with ```\nset.isdisjoint```\n. Note that this only works if your elements are hashable (which integers are).\n```\narr = [2, 5, 7]\nif not {1, 2, 3}.isdisjoint(arr):\n    print(\"true\")\nelse: \n    print(\"false\")\n```\n\nAs the other answer has said, you can't easily make ```\nor```\n do what you want here.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation of a statement with ++ operator in C\r\n                \r\nI have executed the following code in Code::Blocks 10.05 on Windows 7.   \n\n```\nint a=0,b=0,c;\nc=a++&&b++;\nprintf(\"\\na=%d\\nb=%d\\nc=%d\\n\\n\",a,b,c);\n```\n\n\nThe output I obtained is given below,\n\n```\na=1\nb=0\nc=0\n```\n\n\nThis makes perfect sense because of short circuit evaluation.\n\nThe expression ```\na++```\n is post increment and ```\n0```\n is returned to the logical and (```\n&&```\n). Hence the part ```\nb++```\n is not evaluated since both ```\n0 && 0```\n and \n```\n0 && 1```\n evaluates to ```\n0```\n. \n\nBut here arises my doubt. The precedence value of operators clearly states that ```\n++```\n is having higher precedence over ```\n&&```\n. So my understanding was like this, both ```\na++```\n and b++ are evaluated and then ```\n&&```\n only checks the result of expression ```\na++```\n to come to a decision. But this has not happened only ```\na++```\n is evaluated here. \n\nWhat is the reason for this behavior? Does ```\n&&```\n being a sequence point has something to do with this behavior? If so why we say that ```\n&&```\n is having lower precedence than ```\n++```\n?      \n    ", "Answer": "\r\nYou are confused about precedence and order of evaluation.\n\nPrecedence defines how the operators are grouped, i.e\n\n```\nc = a++ && b++;\n```\n\n\nis equivalent to:\n\n```\nc = ((a++) && (b++));\n```\n\n\nOrder of evaluation defines how the expression is evaluated, the short circuit of ```\n&&```\n means ```\na++```\n is evaluated first, if it's zero, the end; if it's not zero, ```\nb++```\n is then evaluated.\n\n\n\nAs another example:\n\n```\nc = (a++) + (b++);\n```\n\n\nIs ```\na++```\n evaluated before ```\nb++```\n? The answer is we don't know. Most operators don't define the order of evaluation. ```\n&&```\n is one of the few operators that do define. (The rest are ```\n||```\n, ```\n,```\n and ```\n?:```\n)\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C++ compiler optimizations and short-circuit evaluation [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Is short-circuiting logical operators mandated? And evaluation order?\r\n                            \r\n                                (7 answers)\r\n                            \r\n                    \r\n                Closed 8 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nHere is my code :\n\n```\nb = f() || b;\n```\n\n\nThe function ```\nf()```\n has side effect and it must be always executed. Normally, only the right operand can be short-circuited and this code should work. But I am afraid some compilators reverse the two operands, since it's more efficient to short-circuit a function evaluation rather than a simple variable evaluation. I know that g++ -O3 can break some specifications, but I don't know if this code can be affected.\n\nSo, is my code risk-free?\n\nI knew Is short-circuiting logical operators mandated? And evaluation order? but my question was about compilers optimizations, I didn't know that they can't break the standards (even if this would be strange).\n    ", "Answer": "\r\n\n  But I am afraid some compilators reverse the two operands\n\n\nThese expressions must be evaluated left-to-right. This is covered in the standard about the operators ```\n&&```\n, ```\n||```\n, ```\n?```\n, and ```\n,```\n. They specifically mention the order, as well as enforced sequence points.\n\n§5.14.1 (Logical AND)\n\n\n  The ```\n&&```\n operator groups left-to-right. The operands are both contextually converted to bool (Clause 4). The result is true if both operands are true and false otherwise. Unlike ```\n&```\n, ```\n&&```\n guarantees left-to-right evaluation: the second operand is not evaluated if the first operand is false.\n\n\n§5.15.1 (Logical OR)\n\n\n  The ```\n||```\n operator groups left-to-right. The operands are both contextually converted to bool (Clause 4). It returns true if either of its operands is true, and false otherwise. Unlike ```\n|```\n, ```\n||```\n guarantees left-to-right evaluation; moreover, the second operand is not evaluated if the first operand evaluates to true.\n\n\n§5.16.1 (Conditional operator)\n\n\n  Conditional expressions group right-to-left. The first expression is contextually converted to bool (Clause 4). It is evaluated and if it is true, the result of the conditional expression is the value of the second expression,\n  otherwise that of the third expression. Only one of the second and third expressions is evaluated. Every value computation and side effect associated with the first expression is sequenced before every value computation\n  and side effect associated with the second or third expression.\n\n\n§5.19.1 (Comma operator)\n\n\n  The comma operator groups left-to-right. A pair of expressions separated by a comma is evaluated left-to-right; the left expression is a discarded value\n  expression (Clause 5). Every value computation and side effect associated with the left expression is sequenced before every value computation and side effect associated with the right expression. The type and value of the result are the type and value of the right operand; the result is of the same value category\n  as its right operand, and is a bit-field if its right operand is a glvalue and a bit-field. If the value of the right operand is a temporary (12.2), the result is that temporary.\n\n\nRegarding your concern about optimizations violating this order, no compilers are not allowed to change the order. Compilers must first and foremost (try to) follow the standard. Then they can try to make your code faster. They may not violate the standard just for the sake of performance. That undermines the entire premise of having a standard.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Can typescript detect short-circuit evaluation automatically?\r\n                \r\nConsider this code:\n\n```\nfunction myFunction( object_argument: {} | {optional_property: string}) {\n  const fallback: string = 'Foo'\n  return object_argument.optional_property || fallback\n}\n```\n\n\nThis gives me an error:\n\n\n  Property 'optional_property' does not exist on type '{} | {\n  optional_property: string; }'. Property 'optional_property' does not\n  exist on type '{}'.\n\n\nA workaround I found was to add explicit type declaration right before the problematic place like this:\n\n```\nfunction myFunction( object_argument: {} | {optional_property: string}) {\n  const fallback: string = 'Foo'\n  return (<{optional_property}>object_argument).optional_property || fallback\n}\n```\n\n\nFrom my perspective however it's very obvious that I'm performing a \"short-circuit\" evaluation and therefore existence of \"optional_property\" is literally optional.\n\nIs it possible to make typescript find this out automatically without the need of implicit declarations?\nShould I create a feature request on GitHub?\n    ", "Answer": "\r\nYou can make object properties optional with a question mark: ```\n{field?: type}```\n.\nSo your function will be:\n\n```\nfunction myFunction( object_argument: {optional_property?: string}) {\n  const fallback: string = 'Foo'\n  return object_argument.optional_property || fallback\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "which will be executed first in a short-circuit evaluation (a&&b) [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Is short-circuiting logical operators mandated? And evaluation order?\r\n                            \r\n                                (7 answers)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nLets say I have the following code:\n\n```\nif (a&&b)\n{\n...\n}\n```\n\n\nFirst question, who decides to use short-circuit evaluation in this circumstance? the compiler or the C standard?\n\nSecond question, which one will be evaluated first? ```\na```\n or ```\nb```\n. The sequence is decided by whom and is there way to change the sequence in my code?\n    ", "Answer": "\r\n\nShort-circuit evaluation is required by the standard. \nIt's always ```\na```\n first. You can't change that in your program.\n\n\nReference: 6.5.13 Logical AND operator, paragraph 4:\n\n\n  Unlike the bitwise binary ```\n&```\n operator, the ```\n&&```\n operator guarantees left-to-right evaluation; if the second operand is evaluated, there is a sequence point between the evaluations of the first and second operands. If the first operand compares equal to 0, the second operand is not evaluated.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C: Is there any wrong understanding about short-circuit evaluation? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Short circuit evaluation of a statement with ++ operator in C\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 11 months ago.\r\n            The community reviewed whether to reopen this question 11 months ago and left it closed:\r\n            \r\n                    Original close reason(s) were not resolved\r\n            \r\n        \r\n\r\n\r\n    \r\n\r\nHi I have little confused about logical operator.\nAccording to KNK C chapter 5 exercise 3-4.\n```\nint i=1;\nint j=1;\nint k=1;\n    \nprintf(\"%d\\n\",++i || ++j && ++k);\nprintf(\"%d %d %d\",i,j,k);\n```\n\nI thought the result is 1\\n 2 1 2 due to the short -circuit evaluation\nlike ((++i || ++j) && ++k ).\nBut the answer is 1\\n 2 1 1.\nWhy does variable k increase?\n    ", "Answer": "\r\nFrom C Operator Precedence:\n\n\n\n\nPrecedence\nOperator\nDescription\nAssociativity\n\n\n\n\n11\n```\n&&```\n\nLogical AND\nLeft-to-right\n\n\n12\n```\n||```\n\nLogical OR\nLeft-to-right\n\n\n\n\nSince ```\n&&```\n has precedence 11 and ```\n||```\n has 12, the expression ```\n++i || ++j && ++k```\n is equal to this:\n```\n++i || (++j && ++k)\n```\n\nLeft-to-right associativity makes it evaluate ```\n++i```\n first, concludes that it's ```\ntrue```\n and short-circuits so ```\n(++j && ++k)```\n will not be evaluated.\nThe result is therefore\n```\n1\n2 1 1\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Performance impact of short-circuit evaluation\r\n                \r\nDisclaimer: I don't have much experience with reverse-engineering byte-code, so please don't be too harsh on me if that could \"easily\" answer my question.\n\nOn modern processors, branching can be extremely expensive if prediction fails (see Why is it faster to process a sorted array than an unsorted array?).\n\nLet's say I have some short-circuit evaluation in Java like this:\n\n```\nif (condition && (list!=null) && (list.size()>0)) /* Do something */ ;\n```\n\n\nIs that basically equivalent to a bunch of branches like this:\n\n```\nif (condition) {\n    if (list!=null) {\n        if (list.size()>0) {\n            // Do something\n        }\n    }\n}\n```\n\n\nor does Java have some other way to do the short-circuiting more cleverly?\n\nIn other words, would it be better to avoid at least one branching by rewriting the line like this:\n\n```\nif ((condition & (list!=null)) && (list.size()>0)) /* Do something */ ;\n```\n\n\nsince the simple ```\nlist!=null```\n-check is much less expensive than a potentially ill-predicted branching?\n\n(Clearly I can't get rid of the second ```\n&&```\n without risking a ```\nNullPointerException```\n.)\n\nNow, before I get ripped to shreds with statements like \"premature optimization is the root of all evil!\", please keep in mind that this is a choice between general coding habits (always use short-circuiting vs. never use short-circuiting unless required), that will affect pretty much all of my code, so making sure that I use the right habit here is definitely worth spending some thought on.\n    ", "Answer": "\r\nNothing here mentions any kind of branching. This is a mere expression evaluation, a ```\n&&```\n in an ```\nif```\n statement is no different from a ```\n&&```\n in an expression. Would you ask the same question with the following code ?\n\n```\nboolean isValid = condition && (list!=null) && (list.size()>0);\nif (isValid) {\n    ...\n}\n```\n\n\nThis is basically what happens, the expression gets evaluated and then the branching happens.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do modern DBMS include short-circuit boolean evaluation?\r\n                \r\nMany modern programming languages have short-circuit boolean evaluation such as the following:\n\n```\nif (x() OR y())\n```\n\n\nIf ```\nx()```\n returns true, ```\ny()```\n is never evaluated.  \n\nDoes SQL on modern DBMS (SQL Server, Sybase, Oracle, DB2, etc) have this property?\n\nIn particular if the left side of the boolean statement is a boolean constant, will it be short circuited?\n\n\n\nRelated: Do all programming languages have boolean short-circuit evaluation?\n    ", "Answer": "\r\nYes and no.\n\n(Below refers to ```\nSQL Server```\n exclusively)\n\nSome operators short circuit and some don't.  ```\nOR```\n CAN short circuit, but may not depending on the order of operations selected by the query engine.\n\n```\nCASE```\n is (I believe) 100% guaranteed to short-circuit.\n\nYou can also try to force order of evaluation with nested parentheses, like:\n\n```\nIF ((X) OR Y)```\n\n\nBut I'm not positive this is always consistent either.\n\nThe trouble with SQL in this regard is it's declarative, and the actual logic is performed by the engine.  It may in fact be more efficient to check for ```\nY```\n first from your example and then check for ```\nX```\n - if, for instance, ```\nY```\n is indexed and ```\nX```\n requires a table scan.\n\nFor Reference:\n\nFrom the ANSI-SQL documentation from this answer:\n\n\n  Where the precedence is not determined by the Formats or by\n  parentheses, effective evaluation of expressions is generally\n  performed from left to right. However, it is implementation-dependent\n  whether expressions are actually evaluated left to right, particularly\n  when operands or operators might cause conditions to be raised or if\n  the results of the expressions can be determined without completely\n  evaluating all parts of the expression.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Difference between using a ternary operator or just short-circuit evaluation?\r\n                \r\nRecently came across short-circuit evaluation and was a little confused by it as i only got into programming the past week. From what i understand if what ever comes before the first double pipe is true then it will stop and not evaluate what comes after the double pipe. For Example:\n\nExample 1:\n\n```\nvar a = true;\nvar b = a || {};\n```\n\n\nSo i assume if a exists then assign a to b otherwise b is equal to an object.\nWhat i dont understand is where i will use this and how it differs to a ternary operator, isn't the short circuit evaluation the same as:\n\nExample 2:\n\n```\nvar a = true;\nvar b = (a) ? a : {};\n```\n\n\nWhy would one use example 1 over example 2 as it isn't any slower to write out or is there a speed benefit of the use of one over the other? or is this just a silly question and perhaps i'm missing something. If someone could clear this up for me that would be great.\n    ", "Answer": "\r\nThere are several ways short circuit operators can affect correctness and performance.\n\nThe critical thing is avoiding side effects or performance hits of the second operand.\n\nShort circuiting can avoid errors by only evaluating the second operand when it is safe:\n\n```\nvar a = a && someFunctionThatWillThrowIfAIsNull(a);\n```\n\n\nA slow function can be avoided by placing it second if a faster function's result can make the second operand redundant:\n\n```\nvar a = someFastFunction() || someSlowFunction();\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-Circuit Evaluation of Logical Expressions in JavaScript\r\n                \r\nI am learning JavaScript and going through the JavaScript: The Complete Reference, Third Edition 2012. Considering the abstract from the same book.\n\nLike many languages, JavaScript short circuits the evaluation of a logical AND (&&) or logical OR (||) expression once the interpreter has enough information to infer the result. For example, if the first expression of an || operation is true, there really is no point in evaluating the rest of the expression, since the entire expression will evaluate to true, regardless of the other value. Similarly, if the first expression of an && operation evaluates to false, there is no need to continue evaluation of the right-hand operand since the entire expression will always be false. The script here demonstrates the effect of short-circuit evaluation:\n\n```\n    var x = 5, y = 10;\n\n    // The interpreter evaluates both expressions\n    if ( (x >>= 5)  &&  (y++ == 10) )\n        document.write(\"The y++ subexpression evaluated so y is \" + y);\n\n    // The first subexpression is false, so the y++ is never executed\n    if ( (x << 5) && (y++ == 11) )\n        alert(\"The if is false, so this isn't executed. \");\n\n    document.write(\"The value of y is still \" + y);\n```\n\n\nMy O/P gets reflected as :\n\n```\nThe value of y is still 10\n```\n\n\nwhereas that of author's as:\n\n```\nThe y++ subexpression evaluated so y is 11\nThe value of y is still 11\n```\n\n\nI see that this expression doesn't gets executed:\n\n```\nif ( (x >>= 5)  &&  (y++ == 10) )\n```\n\n\nI see the red line drawn under the second '&' in the above expression in Eclipse IDE with this:\n\n```\nThe entity name must immediately follow the '&' in the entity reference.\n```\n\n\nWhat is the reason behind this?\n    ", "Answer": "\r\nx is 5 which is binary 101, (x >>= 5) is therefore zero, x is assigned zero, and y++ in the first statement is not executed.\n\n(x << 5) is likewise zero since x is now zero, so the y++ in the second statement also does not execute. The value of y remains 10, since no y++ is executed.\n\nI don't know where your author is getting y == 11 from, it's wrong.\n\nThe IDE error is a red herring - it does not understand your file contains javascript (or you delimiited the javascript incorrectly) and is trying to parse it as XML / HTML.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Rails Tutorial: Short-Circuit Evaluation in section 8.4.4\r\n                \r\nI'm going in circles with a bit of code in section 8.4.4 (\"Two Subtle Bugs\") in the 3rd edition of Michael Hartl's Rails tutorial. (Link to this section of the text: https://www.railstutorial.org/book/log_in_log_out#sec-two_subtle_bugs[1])\n\nSpecifically I'm confused about the following text/code:\n\n\n  \"The second subtlety is that a user could be logged in (and\n  remembered) in multiple browsers, such as Chrome and Firefox, which\n  causes a problem if the user logs out in one browser but not the\n  other. For example, suppose that the user logs out in Firefox, thereby\n  setting the remember digest to nil (via user.forget in Listing 8.38).\n  This would still work in Firefox, because the log_out method in\n  Listing 8.39 deletes the user’s id, so the user variable would be nil\n  in the current_user method:\n\n\n```\ndef current_user\n  if (user_id = session[:user_id])\n    @current_user ||= User.find_by(id: user_id)\n  elsif (user_id = cookies.signed[:user_id])\n    user = User.find_by(id: user_id)\n    if user && user.authenticated?(cookies[:remember_token])\n      log_in user\n      @current_user = user\n    end\n  end\nend\n```\n\n\n\n  As a result, the expression \n  \n  ```\nuser && user.authenticated?(cookies[:remember_token])```\n \n  \n  returns false due to short-circuit evaluation.\"\n\n\nFor this question, let's stick with Firefox and not worry about the second browser bug. Hartl seems to be saying the following:\n\n\nThe log_out method sets the remember digest to nil in the database.\nThe log_out method deletes the user_id stored in both the session\nand cookie. \nA subsequent call to the current_user method from within the same browser would not raise  an error because \"the user variable would be nil in the current_user method.\" This would cause short-circuiting of the expression ```\nuser && user.authenticated?(cookies[:remember_token])```\n. \n\n\nMy questions is how this could ever happen. If the log_out method works as stated, shouldn't the line ```\nelsif (user_id = cookies.signed[:user_id])```\n be false on subsequent calls? The elsif block wouldn't run and  the user variable would never be set. In fact both conditionals in the current_user method would be false and the method would return nil. There would be no short-circuiting based on the user variable.  \n\nCan the short-circuit evaluation that he describes take place?   \n    ", "Answer": "\r\nYou are correct that the short-circuit does not occur since\n\n\n  elsif (user_id = cookies.signed[:user_id])\n\n\ndoes not run and the user variable would never be set IN FIREFOX., since the cookie is delted in Sessions Helper: \n\n```\n# Forgets a persistent session.\n  def forget(user)\n    user.forget\n    cookies.delete(:user_id)\n    cookies.delete(:remember_token)\n  end\n\n  # Logs out the current user.\n  def log_out\n    forget(current_user)\n    session.delete(:user_id)\n    @current_user = nil\n  end\n```\n\n\nHowever, that doesn't change Hartl's main point that the user was also logged in via Chrome, which is where the error occurs.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "pre/post-increment in conditional skipped by short-circuit evaluation\r\n                \r\nSo, if I have an expression like:\n\n```\nif (obj != null && i++ % divisor == 0)\n{\n....\n}\n```\n\n\nand ```\nobj```\n is ```\nnull```\n, then ```\ni```\n is never incremented. If I use\n\n```\ni++; \nif (obj != null && i % divisor == 0)\n{\n....\n}\n```\n\n\ninstead, then, of course, ```\ni```\n is incremented. \n\nIs this by design? I understand short-circuit evaluation from an optimization point of view, but I had (incorrectly) assumed that the compiler would recognize the post-increment expression and evaluate it regardless. \n\n(If this is in the spec, I couldn't find it - just looking for some (gasp) opinions here.)\n\nUpdate\n\nHere's the actual code.\n\n```\n    private int _frameNumber = 0;\n\n    private void simulator_OnFrameEnd(object sender, System.EventArgs e)\n    {\n        _frameNumber++; \n\n        if (_visualizer != null && _frameNumber % _config.VisualizerUpdateFrequency == 0)\n        {\n            var field = _simulator.GetField(_config.PreviewField);\n\n            _visualizer.Update(field, _simulator.FrameTime);\n        }\n\n        if (_frameNumber % _config.OptimizerRegridFrequency == 0)\n        {\n            _simulator.UpdateFieldGrids();\n\n        }\n\n    }\n```\n\n    ", "Answer": "\r\nIt is most definitely by design. MSDN states:\n\n\n  The operation ```\nx && y```\n corresponds to the operation ```\nx & y```\n except\n  that if x is false, y is not evaluated, because the result of the AND\n  operation is false no matter what the value of y is. This is known as\n  \"short-circuit\" evaluation.\n\n\nSo, it doesn't matter what your statement is, whether it has a post-increment or not, it won't be evaluated if it's short-circuited.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Are short circuit evaluation rules expected at compile time?\r\n                \r\nProgram A produces a compilation error (as expected) since ```\nisFinite```\n is called with a non-integral type.\n\nProgram A\n\n```\n#include <iostream>\n\nclass Foo {};\n\ntemplate<typename T>\nbool isFinite(const T& t)\n{\n    static_assert(std::is_integral<T>::value, \"Called isFinite with a non-integral type\");\n    return false;\n}\n\nint main()\n{\n    Foo f;\n    std::cout << \"Foo is finite? \" << ((isFinite(f)) ? \"yes\" : \"no\") << \"\\n\";\n\n    return 0;\n}\n```\n\n\nHowever, a slight modification (see Program B) allows the program to compile (Visual Studio 2013) and produce the following output.\n\nProgram B Visual Studio 2013 Ouput\n\n```\nFoo is finite? yes```\n\n\nProgram B\n\n```\n#include <iostream>\n\nclass Foo {};\n\ntemplate<typename T>\nbool isFinite(const T& t)\n{\n    static_assert(std::is_integral<T>::value, \"Called isFinite with a non-integral type\");\n    return false;\n}\n\nint main()\n{\n    Foo f;\n    std::cout << \"Foo is finite? \" << ((true || isFinite(f)) ? \"yes\" : \"no\") << \"\\n\";\n\n    return 0;\n}\n```\n\n\nIt appears that Program B is short circuiting on the logical OR operation and not attempting to compile the rest of the expression. However, this application does not compile using g++ 4.8.3 (```\ng++ -std=c++11 -o main main.cpp```\n). I get the following output.\n\n```\nmain.cpp: In instantiation of 'bool isFinite(const T&) [with T = Foo]':\nmain.cpp:15:56:   required from here\nmain.cpp:8:2: error: static assertion failed: Called isFinite with a non-integral type\n  static_assert(std::is_integral<T>::value, \"Called isFinite with a non-integral type\");\n  ^\n```\n\n\nMy intuition leads me to believe that the compilation failure is the correct behavior but it is curious that Visual Studio 2013 compiles successfully. My intuition is based on the fact that it is expected that the following code cannot be compiled.\n\n```\n#include <iostream>\n\nstruct Foo\n{\n    void doOperation1() {}\n    void doOperation2() {}\n};\n\nstruct Bar\n{\n    void doOperationA() {}\n    void doOperation2() {}\n};\n\ntemplate<typename T>\nvoid performOperation(T& t, bool value)\n{\n    if (value)\n    {\n        t.doOperation1();\n    }\n    else\n    {\n        t.doOperation2();\n    }\n}\n\nint main()\n{\n    Foo f;\n    performOperation(f, true);\n    performOperation(f, false);\n\n    Bar b;\n    performOperation(b, false); // Fails to compile (as expected)\n\n    return 0;\n}\n```\n\n\nRestated Question\n\nAre the logical operators supposed to adhere to short circuit evaluation rules at compile time (i.e., what is the expected compilation behavior of Program B)?\n    ", "Answer": "\r\nShort circuit is not supposed to compile ```\ntrue || (whatever_ill_formed)```\n. ```\nisFinite<Foo>```\n is instantiated as part of expression and during instantiation it should be compiled and during compilation it should static assert. After that the compiler may never evaluate ```\nisFinite<Foo>(f)```\n because of short circuit but static assert is not supposed to happen during it.\n\nIt is unclear why Visual Studio 2013 compiles Program B. Standard only allows bypassing syntax checking of templates when template is never instantiated. Even then the code is still ill formed only diagnostics are not required. Behind the defect is perhaps the same internal issue in Visual C++ that does not let Microsoft to implement ```\nconstexpr```\n.\n\nEdit I add some language lawyer texts from standard per @zneak request\n\n3.2/3 \n\n\n  A function whose name appears as a potentially-evaluated expression is\n  odr-used if it is the unique lookup result or the selected member of a\n  set of overloaded functions (3.4, 13.3, 13.4), unless it is a pure\n  virtual function and its name is not explicitly qualified. [Note: This\n  covers calls to named functions (5.2.2), operator overloading (Clause\n  13), user-defined conversions (12.3.2), allocation function for\n  placement new (5.3.4), as well as non-default initialization (8.5). A\n  constructor selected to copy or move an object of class type is\n  odr-used even if the call is actually elided by the implementation\n  (12.8). —end note]\n\n\n5.13/1 \n\n\n  The || operator groups left-to-right. The operands are both\n  contextually converted to bool (Clause 4). It returns true if either\n  of its operands is true, and false otherwise. Unlike |, || guarantees\n  left-to-right evaluation; moreover, the second operand is not\n  evaluated if the first operand evaluates to true.\n\n\n7.1/4 \n\n\n  In a static_assert-declaration the constant-expression shall be a\n  constant expression (5.19) that can be contextually converted to bool\n  (Clause 4). If the value of the expression when so converted is true,\n  the declaration has no effect. Otherwise, the program is ill-formed,\n  and the resulting diagnostic message (1.4) shall include the text of\n  the string-literal, except that characters not in the basic source\n  character set (2.3) are not required to appear in the diagnostic\n  message.\n\n\n14.7.1/3 \n\n\n  Unless a function template specialization has been explicitly\n  instantiated or explicitly specialized, the function template\n  specialization is implicitly instantiated when the specialization is\n  referenced in a context that requires a function definition to exist.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation in ruby / rails with defined?\r\n                \r\nLooking to have two tests on a variable, that might not be defined in a rails view.\n\n```\n<% if defined(:var) && var.present? %>\n    <%= var.value %>\n<% end %>\n```\n\n\nHowever, this is throwing a ```\nundefined local variable or method```\n error when ```\nvar```\n is not defined. I assumed ruby/rails would short circuit the first expression and not try to evaluate the second, similar to python\n\n```\n>>> a = False\n>>> a and b\nFalse\n>>> b\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'b' is not defined\n```\n\n\nAny reason why short circuit is preceeding to the second evaluation?\n    ", "Answer": "\r\nI think you want this:\n\n```\nif defined?(var) && var.present?\n```\n\n\n```\n:var```\n will always be defined as it's a symbol.\n\n```\n> defined?(:var)\n=> \"expression\"\n> defined?(var)\n=> nil\n> var = 1\n=> 1\n> defined?(var)\n=> \"local-variable\"\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Can short-circuit evaluation trigger a race condition?\r\n                \r\nI like code golf. In light of CVE-2016-5195, I was wondering if any of my \"golfed\" code can trigger race conditions.\n\nLet's say we have two functions, both of which return a boolean value, and we are initializing a boolean variable called ```\nresult```\n:\n\n```\nresult = foo() || bar();\n```\n\n\nIn an ideal world, we have two scenarios:\n\n\n```\nfoo```\n returns ```\ntrue```\n. Do not call ```\nbar```\n. ```\nresult```\n equals ```\ntrue```\n. [short-circuit scenario]\n```\nfoo```\n returns ```\nfalse```\n. Do call ```\nbar()```\n. ```\nresult```\n equals what ```\nbar```\n returns.\n\n\n\n\nMy question: Will there ever be a time when short-circuit evaluation is violated, and ```\nbar```\n is called despite ```\nfoo```\n returning ```\ntrue```\n, or even worse, ```\nbar```\n is called before ```\nfoo```\n is called, perhaps because of multi-threading? If so, can you provide a piece of code that would trigger such behavior?\n\nYour answer may be about any language(s) in which this syntax is valid, although I suppose some languages will be more strict about this kind of thing than others.\n    ", "Answer": "\r\nRace conditions occur when the outcome of a series of operations depends on the sequence upon which they are executed.\n\nThe ```\n&&```\n and ```\n||```\n operators in C++ guarantee left-to-right evaluation and to not evaluate the second operator if the first one is false / true, respectively. Since the sequence of operations is guaranteed, there is no race condition between operations of ```\nfoo```\n and operations of ```\nbar```\n. There can still be race conditions between the operations in each one, though.\n\nCode that violates the aforementioned guarantees is not C++ code, and likewise conforming C++ compilers will never emit code that violates those guarantees.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why won't a Boolean cast narrow type in short-circuit evaluation?\r\n                \r\nI'm trying to narrow an optional argument in short-circuit evaluation.\nHere's a Typescript playground with the below code: https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABFApgZygCgA5zWmAIwBsBPAVTABMVgYwUqB+ALkQwCd6BzASkQDeAWABQiRAHoJiAO4ALFEghwQxKogAGufETKUadBlQ2IEyBYi7c5URHICG1djBqJCKROAP1GTUeI4UKBAOJAAhODhiFEccPAISCmpaHyp+ADJ0xG0EvWTDRgA6aLBuKDkAblEAXyA\n```\nfunction test(possiblyUndefined?: string) {\n  // when could `possiblyUndefined` on the right hand side be undefined?\n  return Boolean(possiblyUndefined) && possiblyUndefined.length;\n}\n```\n\nThis errors out with: ```\n'possiblyUndefined' is possibly 'undefined'. ```\n\n...But that can't be right. The left-hand side of the statement can only ever succeed when ```\npossiblyUndefined```\n is not undefined, right?\n    ", "Answer": "\r\nBecause the ```\nBoolean```\n function will happily accept ```\nundefined```\n, and TypeScript doesn't have it defined as a type predicate that guarantees its input isn't ```\nundefined```\n (probably because that's not its purpose, even though it's true that ```\nBoolean```\n will return ```\nfalse```\n for ```\nundefined```\n). If you look at the current definition of it, it's this (relevant portion highlighted):\n```\ninterface BooleanConstructor {\n    new(value?: any): Boolean;\n    <T>(value?: T): boolean;             // <====\n    readonly prototype: Boolean;\n}\n\ndeclare var Boolean: BooleanConstructor;\n```\n\nThat's just a function that returns ```\nboolean```\n, not a type predicate.¹\nIf you want to handle ```\nundefined```\n, you can do so explicitly. I'd also use ```\n> 0```\n so your function always returns ```\nboolean```\n, not ```\nfalse | number```\n (though that's up to you, of course):\n```\nreturn typeof possiblyUndefined !== \"undefined\" && possiblyUndefined.length > 0;\n// or\nreturn possiblyUndefined !== undefined && possiblyUndefined.length > 0;\n```\n\nAlthough these days I think I'd probably go for optional chaining (```\n?.```\n) and nullish coalescing (```\n??```\n):\n```\nreturn possiblyUndefined?.length ?? 0 > 0;\n```\n\nPlayground link for the above\n\n¹ It's interesting to see from the link in Leland's own answer that there's at least talk of making it a predicate function. But it isn't one as of this writing. It's just a conversion function.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is there a way to disable short circuit evaluation in Java?\r\n                \r\nSay I have code like this:\n\n```\nboolean ret = a() && b() && c() && d() && e();\n```\n\n\nUsually e() is only called if all other calls a()-d() return true. Is there maybe some compiler or JVM option to disable short circuit evaluation, so e() would be called always, regardless of other functions' results?\n\nBasically I am doing UAT of huge system and need to test e(), however setting up environment and scenario that assures all a(), b() etc. return true is extremely painful...\n\nEDIT: ok, I guess using bit AND instead of logical one could provide SOME sort of workaround, however ideally I am looking for a solution that does not require ANY CHANGES in the source code. Both due to formal and technical reason (as i mentioned system is big and we have whole process of promoting and deploying code between staging areas and getting sign-offs). And this is for testing only, production version needs to have lazy evaluation enabled (i.e. use &&)\n\nPOST-MORTEM:\n\n\n\"Correct\" answer is: No, there is not.\n\"Useful\" answer: you can change && to &\n\"What I did in the end\" answer: debug system remotely, put breakpoint on expression and told eclipse to run e() -_-\n\n    ", "Answer": "\r\nIn order to disable short-circuit use single '&' or '|' rather than two:\n\n```\nboolean ret = a() & b() & c() & d() & e();\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "The short circuit evaluation in C is not reflected by compiler\r\n                \r\nI am trying to compile the below C code with -O3 optimization flag by GCC and Clang, and after looking at the generated assembly code, I find neither of these compilers implements the short circuit evaluation which is mentioned in the C standard for the && operator.\nYou can refer to the below assembly code for further information, the first five lines of code of the foo function would be run sequentially, and it would compare both two operands of the && operators which actually violates the standard. So, any misunderstandings here?\nC code:\n```\n#include <stdio.h>\n#include <stdbool.h>\nvoid foo(int x, int y) {\n  bool logical = x && y;\n  printf(\"%d\", logical);\n}\nint main(void) {\n  foo(1, 3);\n  return 0;\n}\n```\n\nGenerated assembly code:\n```\nfoo:                                    # @foo\n        test    edi, edi\n        setne   al\n        test    esi, esi\n        setne   cl\n        and     cl, al\n        movzx   esi, cl\n        mov     edi, offset .L.str\n        xor     eax, eax\n        jmp     printf                          # TAILCALL\nmain:                                   # @main\n        push    rax\n        mov     edi, offset .L.str\n        mov     esi, 1\n        xor     eax, eax\n        call    printf\n        xor     eax, eax\n        pop     rcx\n        ret\n.L.str:\n        .asciz  \"%d\"\n```\n\n    ", "Answer": "\r\nFirst, your example is faulty.\nGiven ```\nx```\n = 1 and ```\ny```\n = 3, evaluating ```\nx && y```\n requires evaluating both operands, since the ```\n&&```\n is only true if both operands are true.\nSecond, C 2018 5.1.2.3 6 says:\n\nThe least requirements on a conforming implementation are:\n— Accesses to volatile objects are evaluated strictly according to the rules of the abstract machine.\n— At program termination, all data written into files shall be identical to the result that execution of the program according to the abstract semantics would have produced.\n— The input and output dynamics of interactive devices shall take place as specified in 7.21.3. The intent of these requirements is that unbuffered or line-buffered output appear as soon as possible, to ensure that prompting messages actually appear prior to a program waiting for input.\nThis is the observable behavior of the program.\n\nThis means the compiler is only responsible for ensuring the above behaviors occur as specified. It is not required to generate assembly language that does not evaluate the right operand of ```\n&&```\n or ```\n||```\n when the result can be deduced from the left operand as long as that evaluation does not alter the observable behaviors. The compiler has no obligation to generate the assembly language you seek, just to ensure the observable behaviors are as specified.\nWhen the standard describes expressions as being evaluated or not, it is describing them in the context of an “abstract machine” (C 2018 5.1.2.3 1), not describing what the generated program must actually do on the assembly language level. The idea is that the C standard describes what a program would generate in an abstract machine, and then the compiler may generate any program that has the same observable behavior as the program in an abstract machine, even if it obtains that result in a completely different way than the program in the abstract machine does.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "In Perl - can a short circuit evaluation be disabled if needed?\r\n                \r\nThis is a follow-up question for this one.\n\nFor example, let's say I have three procedures that I need to run no matter what and exit if all of them return 1.\n\n```\nwhile (&proc1 && &proc2 && &proc3);\n```\n\n\nBecause Perl is using short-circuit evaluation, the code may or may not execute subs &proc2 and &proc3 depending on preceding operands (if an operand is false the following operands won't be executed; more info here and on wiki). If needed, is there any way to turn the feature off?\n    ", "Answer": "\r\nYou could just evaluate every clause to temporary variables, then evaluate the entire expression. For example, to avoid short-circuit evaluation in:\n\n```\nif ($x < 10 and $y < 100) { do_something(); }\n```\n\n\nwrite:\n\n```\n$first_requirement = ($x < 10);\n$second_requirement = ($y < 100);\nif ($first_requirement and $second_requirement) { do_something(); }\n```\n\n\nBoth conditionals will be evaluated. Presumably, you want more complex conditions with side effects, otherwise there's no reason to evaluate the second condition if the first is false.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to implement Short-Circuit evaluation in user-defined functions?\r\n                \r\nSome operators such as ```\n&&```\n and ```\n||```\n perform short-circuit evaluation. Also, when a function is called with arguments, all arguments are constructed before calling the function.\n\nFor instance, take the following three functions\n\n```\nbool f1();\nbool f2();\nbool f3(bool, bool);\n```\n\n\nif I call\n\n```\nif( f3(f2(),f1()) )//Do something\n```\n\n\nThen the return value of both ```\nf2```\n and ```\nf1```\n are evaluated before ```\nf3```\n is called. But,  if I had used (the regular) ```\noperator||```\n instead of ```\nf3```\n, than the code above would be equivalent to\n\n```\nif( f2()||f1() )//Do something\n```\n\n\nand ```\nf1```\n won't be evaluated if ```\nf2```\n evaluates to true.\n\nMy question is: is it possible to have ```\nf3```\n (a user defined function taking two booleans) behave the same way? If not, what makes the ```\noperator||```\n so special? \n    ", "Answer": "\r\nNot if f3() takes the values of the result of the functions.\n\nBut if it takes the address of the functions (or more generically treats its input as functors) rather than the results then f3() can decide if it needs to call the function.\n\n```\ntemplate<typename F1, typename F2>\nbool f3(F1 const& f1, F2 const& f2)\n{\n    return f1() || f2();\n}\n\nbool f1();\nbool f2();\n\nint main()\n{\n    f3(&f1, &f2);\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do the &= and |= operators for bool short-circuit?\r\n                \r\nWhen writing code like this in C++:\n\n```\nbool allTrue = true;\nallTrue = allTrue && check_foo();\nallTrue = allTrue && check_bar();\n```\n\n\n```\ncheck_bar()```\n will not be evaluated if ```\ncheck_foo()```\n returned ```\nfalse```\n. This is called short-circuiting or short-circuit evaluation and is part of the lazy evaluation principle.\n\nDoes this work with the compound assignment operator ```\n&=```\n?\n\n```\nbool allTrue = true;\nallTrue &= check_foo();\nallTrue &= check_bar(); //what now?\n```\n\n\nFor logical ```\nOR```\n replace all ```\n&```\n with ```\n|```\n and ```\ntrue```\n with ```\nfalse```\n.\n    ", "Answer": "\r\nFrom C++11 ```\n5.17 Assignment and compound assignment operators```\n:\n\n\n  The behavior of an expression of the form E1 op = E2 is equivalent to E1 = E1 op E2 except that E1 is evaluated only once.\n\n\nHowever, you're mixing up logical AND which does short-circuit, and the bitwise AND which never does.\n\nThe text snippet ```\n&&=```\n, which would be how you would do what you're asking about, is nowhere to be found in the standard. The reason for that is that it doesn't actually exist: there is no logical-and-assignment operator.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Safe short circuit evaluation in C++11\r\n                \r\nPre-C++11 we know that short-circuiting and evaluation order are required for operator ```\n&&```\n because of:\n\n\n  1.9.18\n  \n  In the evaluation of the following expressions\n\n```\na && b\na || b\na ? b : c\na , b\n```\n\n  \n  using the built-in meaning of the operators in these expressions, there is a sequence point after the evaluation of the first expression (12).\n\n\nBut sequence points no longer exist in C++11, so where is the standard part that says:\n\n```\nif (ptr && ptr->do_something())\n{\n}\n```\n\n\nis safe?\n    ", "Answer": "\r\n[expr.log.and]\n\n\n  The ```\n&&```\n operator groups left-to-right. The operands are both contextually converted to ```\nbool```\n (Clause 4).\n  The result is true if both operands are true and false otherwise. Unlike ```\n&```\n, ```\n&&```\n guarantees left-to-right\n  evaluation: the second operand is not evaluated if the first operand is false.\n  \n  The result is a ```\nbool```\n. If the second expression is evaluated, every value computation and side effect associated\n  with the first expression is sequenced before every value computation and side effect associated with the\n  second expression.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "ClangTool parse code short-circuit evaluation can't work when Macro preprocess\r\n                \r\nI used ```\nClangTool```\n to develop a code generate tool, but I found Clang code parser can't preprocess macro with short-circuit evaluation.\nHere is the minimal reproducible code\n```\n#include <clang/ASTMatchers/ASTMatchers.h>\n#include <clang/Frontend/FrontendActions.h>\n#include <clang/Tooling/Tooling.h>\n#include <gtest/gtest.h>\n\nusing namespace clang::tooling;\nusing namespace clang::ast_matchers;\nusing namespace clang;\n\nusing namespace llvm::cl;\n\n\nconst char *simpleCode = R\"(\n#if defined(__MINGW32__)\nclass A {B}\n#endif\n#if defined(__MINGW32__) && __has_include(<pthread.h>)\nclass C {D}\n#endif\nclass X {};\n)\";\n\nTEST(runToolOnCode, CanSyntaxCheckCode)\n{\n    EXPECT_TRUE(runToolOnCode(std::make_unique<clang::SyntaxOnlyAction>(), simpleCode));\n}\n```\n\nI expect to be able to parse correctly, but I got\n```\ninput.cc:5:43: fatal error: cannot open file '/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/pthread.h': No such file or directory\nRunning main() from /Volumes/Demon/Demo/Polaris/cmake-build-debug/_deps/googletest-src/googletest/src/gtest_main.cc\n#if defined(__MINGW32__) && __has_include(<pthread.h>)\n                                          ^\n1 error generated.\n/Volumes/Demon/Demo/Polaris/tests/hello.cpp:28: Failure\nValue of: runToolOnCode(std::make_unique<clang::SyntaxOnlyAction>(), simpleCode)\n  Actual: false\nExpected: true\n\n```\n\n\nAbout my environment\n\nMaxOSX 11.3.1\nXCode 12.5.1\n\n\n\n```\n➜  ~ clang++ -E -x c++ - -v\nHomebrew clang version 12.0.0\nTarget: x86_64-apple-darwin20.4.0\nThread model: posix\nInstalledDir: /usr/local/opt/llvm/bin\n (in-process)\n \"/usr/local/Cellar/llvm/12.0.0_1/bin/clang-12\" -cc1 -triple x86_64-apple-macosx11.0.0 -Wundef-prefix=TARGET_OS_ -Werror=undef-prefix -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -E -disable-free -disable-llvm-verifier -discard-value-names -main-file-name - -mrelocation-model pic -pic-level 2 -mframe-pointer=all -fno-rounding-math -munwind-tables -fcompatibility-qualified-id-block-type-checking -fvisibility-inlines-hidden-static-local-var -target-cpu penryn -tune-cpu generic -debugger-tuning=lldb -target-linker-version 650.9 -v -resource-dir /usr/local/Cellar/llvm/12.0.0_1/lib/clang/12.0.0 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk -stdlib=libc++ -internal-isystem /usr/local/opt/llvm/bin/../include/c++/v1 -internal-isystem /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/local/include -internal-isystem /usr/local/Cellar/llvm/12.0.0_1/lib/clang/12.0.0/include -internal-externc-isystem /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include -fdeprecated-macro -fdebug-compilation-dir /Users/abao -ferror-limit 19 -stack-protector 1 -fblocks -fencode-extended-block-signature -fregister-global-dtors-with-atexit -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fmax-type-align=16 -fcolor-diagnostics -o - -x c++ -\nclang -cc1 version 12.0.0 based upon LLVM 12.0.0 default target x86_64-apple-darwin20.4.0\nignoring nonexistent directory \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/local/include\"\nignoring nonexistent directory \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/Library/Frameworks\"\n#include \"...\" search starts here:\n#include <...> search starts here:\n /usr/local/opt/llvm/bin/../include/c++/v1\n /usr/local/Cellar/llvm/12.0.0_1/lib/clang/12.0.0/include\n /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include\n /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks (framework directory)\nEnd of search list.\n```\n\n    ", "Answer": "\r\nuse ```\nllvm 11.1.0```\n could circumvent this problem, this may be a bug in version 12.0.0\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Not expected behavior while setting a string with short-circuit evaluation in Javascript\r\n                \r\nI want to use this short-circuit evaluation to report a nice status of multiple items in an one liner. But the result is not as expected as shown below:\n\n\r\n\r\n```\nvar items = [{\r\n    \"id\": 1,\r\n    \"available\": true\r\n}, {\r\n    \"id\": 2,\r\n    \"available\": false\r\n}, {\r\n    \"id\": 3,\r\n    \"error\": \"Server not found for that TLD\"\r\n}];\r\n\r\nitems.forEach(function(item) {\r\n\tconsole.log(item.id, item.error || item.available ? \"Available\" : \"Not available\");\r\n});```\n\r\n\r\n\r\n\n\nThis produced the following log:\n\n```\n1 \"Available\"\n2 \"Not available\"\n3 \"Available\"\n```\n\n\nAt ```\n3```\n I expected it to show the error because item.error is a string and should evaluate to `true, why does it skip it to item.available?\n    ", "Answer": "\r\n```\nitem.error || item.available```\n is truthy.\n\nYou need parentheses:\n\n```\nitem.error || (item.available ? \"Available\" : \"Not available\")\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation and assigning either true or false to a variable\r\n                \r\nI have the following pre-configuration\n```\nconst preloadedConfig = {\n  \"configA\": null, // either true, false or null is allowed\n};\n```\n\nand then I have the following initialization on page load\n```\nlet finalConfig = preloadedConfig.configA || true;\n```\n\nThe scenario:\n\nProperties in the preloaded config can be changed to either true, false or null based on the user's preference\n\nI wish to use short-circuit evaluation to determine the user choice on page load. If no choice(null) is supplied by the user, default the choice to true\n\n\nMy issue:\nBased on the following extracted from here:\n\nFalsy values are those who coerce to false when used in boolean context, and they are 0, null, undefined, an empty string, NaN and of course false.\n\nThe following is evaluated:\n```\ntrue >> evaluted true // ok\nnull >> evaluted true // ok\nfalse >> evaluted true // the problem area\n```\n\nIf the user supplies the config option of false, the final evaluated value will always result in true due to it being a \"falsy value\".\nMy desired outcome is a boolean value of false if the value supplied is false.\nWhat should I do to make this work while using short-circuit evaluation and allowing 3 types of input values of null, true or false?\n    ", "Answer": "\r\nYou can use the nullish coalescing operator instead.\n```\nlet finalConfig = preloadedConfig.configA ?? true;\n```\n\nAlternatively, you can use a ```\nhasOwnProperty```\n check.\n```\nlet finalConfig = preloadedConfig.hasOwnProperty('configA') ? preloadedConfig.configA : true;\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Order of short circuit evaluation and prefix increment operators\r\n                \r\nWhen evaluating a Boolean expression in java, I find myself a bit bewildered by short circuit evaluation and pre-fix increment operators.  Consider the following:\n\n```\n    int e=20;\n    int f=25;\n    if(++e>21 || ++e>21 && f>30){\n\n        System.out.println(\"Hi\");\n    }\n    System.out.println(e);\n```\n\n\nI understand that if ++e were greater than 21, the rest of the IF statement would skip over (due to short circuit eval).  But in this case, it doesn't, as the first part is not true, so we move on to the AND statement.  At this point, is e still 20?  Or during the short circuit eval, did it go up to 21?  \n\nWell, I am assuming at this point, we evaluate the AND statement (as we normally do before OR), we add 1 to e, which I assume becomes 21 now?  It is false, and therefore the entire AND statement is false.\n\nDo we, at this point, go BACK and do the OR statement?  Since it comes after AND?  Shouldn't e be pumped up to 22 now? And since it's an OR statement, it should come out to TRUE OR FALSE, which should be TRUE, and \"Hi\" should appear on the screen. But it doesn't.\n\nWeirdly, the value for e is 22 when the code finishes.  22 is the value we needed for the IF statement to be true, but the condition inside didn't run.\n\nI am extremely confused.\n    ", "Answer": "\r\nLet's unwind what short-circuiting actually is!\n\n```\nint e=20;\nint f=25;\nif((++e>21) || (++e>21 && f>30)){\n\n    System.out.println(\"Hi\");\n}\nSystem.out.println(e);\n```\n\n\nSo, if that left hand side of the ```\nor```\n condition evaluates to true, we don't need to do anything more, so let's be more explicit about that:\n\n```\nint e=20;\nint f=25;\nif (++e > 21)\n{\n    System.out.println(\"Hi\");\n}\n// the or becomes an else if, if the first condition fails then we check the second\nelse if (++e>21 && f>30)\n{\n    System.out.println(\"Hi\");\n}\nSystem.out.println(e);\n```\n\n\nNow, let's be more explicit about when that first increment happens:\n\n```\nint e=20;\nint f=25;\ne += 1;\nif (e > 21) // e = 21, 21 is not > 21\n{\n    System.out.println(\"Hi\");\n}\n// We need to test this condition, as you've said\n// e is still 21\nelse if (++e>21 && f>30)\n{\n    System.out.println(\"Hi\");\n}\nSystem.out.println(e);\n```\n\n\nAgain, let's unwind what ```\nand```\n means in terms of short-circuiting\n\n```\nint e=20;\nint f=25;\ne += 1;\nif (e > 21) // e = 21, 21 is not > 21\n{\n    System.out.println(\"Hi\");\n}\n// We need to test this condition, as you've said\n// e is still 21\nelse if (++e > 21) // the and becomes a nested if, first the left must be true before we test the right\n{\n    if (f > 30)\n    {\n        System.out.println(\"Hi\");\n    }\n}\nSystem.out.println(e);\n```\n\n\nAnd again, let's be explicit about that increment!\n\n```\nint e=20;\nint f=25;\ne += 1;\nif (e > 21) // e = 21, 21 is not > 21\n{\n    System.out.println(\"Hi\");\n}\n// We need to test this condition, as you've said\n// e is still 21\nelse \n{\n    e += 1;\n    if (e > 21) // e is now 22, this condition succeeds\n    {\n        if (f > 30) // f is not >30, this condition fails!\n        {\n            System.out.println(\"Hi\");\n        }\n    }\n    // e is still 22\n}\n// e is still 22\nSystem.out.println(e);\n```\n\n\nHopefully this makes it all clear!\n\nEDIT: Actually, having re-read your question a couple of times, it appears you are getting confused with the precedence of the logical operators. You seem to think that the ```\nand```\n should execute before the ```\nor```\n right? presumably because ```\nand```\n has the higher precedence. All that means, however, is that the implicit brackets go round the ```\nand```\n first like so;\n\n```\np || q && r == p || (q && r)```\n\n\nYou should be able to see that in this form, the outside ```\nor```\n must be evaluated first, before the ```\nand```\n is. We always evaluate left to right! \n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Clone function speed: if/else vs short circuit evaluation\r\n                \r\nI'm tweaking an algorithm that analyzes large amounts of data to make it run a little faster. It makes heavy use of ```\nclone```\n functions like the following:  \n\n```\nconst Object* clone() const {\n    if (this != INVALID_OBJECT) {\n        return new DerivedObject(*this);\n    } else {\n        return this;\n    }\n}\n```\n\n\nThe algorithm uses a pointer to a single invalid object to dramatically reduce memory requirements, and passing it through a copy constructor would defeat the purpose.\n\nMy question is whether using short circuit evaluation would increase the performance of the ```\nclone```\n functions by reducing execution time:\n\n```\nconst Object* clone() const {\n    const Object* clonedObject = INVALID_OBJECT;\n    (void)((this != INVALID_OBJECT)&&(clonedObject = new DerivedObject(*this));\n    return clonedObject;\n}\n```\n\n\nIs there any way to reduce the execution time of the ```\nclone```\n functions? The copy constructors generally follow the pattern\n\n```\nDerivedObject(const DerivedObject& derivedObj) : Object(derivedObj.getField1()),\n    field2(derivedObj.getField2()) {}\n```\n\n    ", "Answer": "\r\nYour optimization, complex as it may seem, is actually trivial, in the sense that it likely emits the same code than the previous one.\n\nThink in low level operations, not syntax: one condition, one branch. It is difficult to do less.\n\nUPDATE: I've noticed that I didn't really answer your question: Can it be done faster? Well, yes! You can write a subclass just for the uninitialized value.\n\n```\nclass InvalidObject : public Object\n{\npublic:\n    const Object* clone() const {\n        return this;\n    }\n};\n```\n\n\nAnd make the global ```\nINVALID_OBJECT```\n an instance of this class:\n\n```\nObject *INVALID_OBJECT = new InvalidObject();\n```\n\n\nNow you don't need the condition in any of the ```\nclone()```\n overrides:\n\n```\nclass DerivedObject : public Object\n{\npublic:\n    const Object* clone() const {\n        return new DerivedObject(*this);\n    }\n};\n```\n\n\nNaturally, depending on the structure of your hierarchy and the definition of your ```\nINVALID_OBJECT```\n instance, you may need to write a ```\nInvalid*```\n subclass for each ```\nDerivedObject```\n type.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C++ Short Circuit Evaluation\r\n                \r\nMaybe I am missing something rather simple, but I am getting a crash when I dereference a pointer even though I check the point at the very beginning of the expression.\n\n```\nif( var1 &&\n    bool1 || bool2 &&\n    var1->DoSomething() )\n{\n\n}\n```\n\n\nvar1 is a null pointer, but Var1->Dosomething() is still being called. My understanding is that the && and the || operator in C++ are short circuit so if var1 was null then it would just terminate at the very beginning. Or is there something else I am missing?\n    ", "Answer": "\r\nOperator precedence is the key here. Because ```\n&&```\n has higher precedence than ```\n||```\n, your expression is equivalent to \n\n```\n(var1 && bool1) || (bool2 && var1->DoSomething() )\n```\n\n\nSo, since ```\nvar1```\n evaluates to false, ```\nbool1```\n is not evaluated and ```\n(var1 && bool1)```\n yields false, therefore  ```\n(bool2 && var1->DoSomething())```\n has to be evaluated. And if ```\nbool2```\n happens to be true, then ```\nvar1->DoSomething()```\n will also be evaluated, resulting in undefined behavior. \n\nJust add some parentheses (for the specific expression tree that you require) and you'll be fine.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does C# perform short circuit evaluation of if statements with await?\r\n                \r\nI believe that C# stops evaluating an if statement condition as soon as it is able to tell the outcome. So for example:\n```\nif ( (1 < 0) && check_something_else() )\n    // this will not be called\n```\n\nSince the condition ```\n(1 < 0)```\n evaluates as ```\nfalse```\n, the ```\n&&```\n condition cannot be met, and ```\ncheck_something_else()```\n will not be called.\nHow does C# evaluate an if statement with asynchronous functions? Does it wait for both to return? So for example:\n```\nif( await first_check() && await second_check() )\n    // ???\n```\n\nWill this ever be short-circuited?\n    ", "Answer": "\r\nYes, it will be short-circuited. Your code is equivalent to:\n```\nbool first = await first_check();\nif (first)\n{\n    bool second = await second_check();\n    if (second)\n    {\n        ...\n    }\n}\n```\n\nNote how it won't even call ```\nsecond_check```\n until the awaitable returned by ```\nfirst_check```\n has completed. So note that this won't execute the two checks in parallel. If you wanted to do that, you could use:\n```\nvar t1 = first_check();\nvar t2 = second_check();\n\nif (await t1 && await t2)\n{\n}\n```\n\nAt that point:\n\nThe two checks will execute in parallel (assuming they're genuinely asynchronous)\nIt will wait for the first check to complete, and then only wait for the second check to complete if the first returns true\nIf the first check returns false but the second check fails with an exception, the exception will effectively be swallowed\nIf the second check returns false really quickly but the first check takes a long time, the overall operation will take a long time because it waits for the first check to complete first\n\nIf you want to execute checks in parallel, finishing as soon as any of them returns false, you'd probably want to write some general purpose code for that, collecting the tasks to start with and then using ```\nTask.WhenAny```\n repeatedly. (You should also consider what you want to happen to any exceptions thrown by tasks that are effectively irrelevant to the end result due to another task returning false.)\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Order of evaluation for short-circuit operators and let in OCaml\r\n                \r\nIn OCaml, when using a ```\nlet```\n to assign an alias to a short-circuit operator (```\n&&```\n or ```\n||```\n), it no longer short-circuits evaluation of the operands.\n\nThis is not intuitive. What is the reason for this behavior?\n\nConsider the following code:\n\n```\nlet f() = Printf.printf \"f\"; false;;\nlet g() = Printf.printf \"g\"; true;;\nlet a = (&&);;\n\nf() && g();; (* outputs 'f' *)\n\n(&&) (f()) (g());; (* outputs 'f' *)\n\na (f()) (g());; (* outputs 'gf' *)\n```\n\n\nThis also happens with ```\nlet ... in```\n, so ```\nlet b = (&&) in b (f()) (g());;```\n also outputs ```\ngf```\n.\n    ", "Answer": "\r\nIt's because ```\n&&```\n is a primitive operator whose semantics is quite different from a normal function. In fact, ```\n(&&)```\n is more or less equivalent to ```\nfun x y -> x && y```\n, which as explained by nlucaroni will evaluate its arguments before they are being applied (in an unspecified order, which happens to be usually right-to-left, but you should not rely on it). \n\nYou can see that by using ```\nocaml -dlambda```\n. This will launch an interpreter which outputs the translation in one of the intermediate languages of each command you enter. Then, you'll have the following result:\n\n```\n# (&&);;\n(function prim/1044 prim/1043 (&& prim/1044 prim/1043))\n- : bool -> bool -> bool = <fun>\n```\n\n\nThe ```\nlambda```\n format is not documented, but it should be clear enough that eta-expansion is happening.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "In Python 3, is it possible to use short-circuit evaluation in an any call that doesn't have a for .. in expression in it?\r\n                \r\nIn Python 3, is it possible to use short-circuit evaluation in an ```\nany```\n call that doesn't have a ```\nfor .. in```\n expression in it?\nI know that I can take advantage of short-circuit evaluation in a statement like this:\n```\nprint('Hello' if True or 3/0 else 'World')  # this prints \"Hello\"\n```\n\nBut if I try something similar with ```\nany```\n, I get an exception because the ```\n3/0```\n is evaluated:\n```\nprint('Hello' if any([True, 3/0]) else 'World')  # this raises an exception\n```\n\nIs there a way I can use ```\nany```\n to do this?\n    ", "Answer": "\r\nThe issue here is not ```\nany```\n, it is the immediate evaluation of ```\n3/0```\n as the list literal is evaluated:\n```\n>>> [True, 3/0]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nZeroDivisionError: division by zero\n```\n\nThe only way to avoid that is to delay the evaluation until a later time with the use of a function or iterator:\n```\ndef f(e):\n    return e[0]/e[1] if isinstance(e,(list,tuple)) else e\n\n>>> print('Hello' if any(map(f, [True, [3,0]])) else 'World')\nHello\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Typescript Error, thrown even after && short-circuit evaluation\r\n                \r\nPlease read the code below\n```\ntype type1 = string[] | undefined;\n\nlet variable1 : type1 = undefined;\n\nconsole.log(variable1 && variable1.length);\n```\n\nAttempting to execute the aforementioned code in Typescript Playground, results in the following code\nProperty 'length' does not exist on type 'never'.\nWhy does typescript throw error the possibility of variable1 being a falsy value has been handled by && short-circuit evaluation.\nI have also tried using ?. option chaining, but it is logically the same thing as above code.\nI am expecting typescript to not show any error.\nIt is a necessity to have undefined as a posible value of variable1, there are typeOf checks for conditions in my code.\n    ", "Answer": "\r\nThis is because TypeScript already knows that you will be assigning ```\nundefined```\n to the variable ```\nvariable1```\n.\nInstead, you can do this so TypeScript will not be smart enough to auto detect the type that you are assigning to ```\nvariable1```\n:\n```\ntype type1 = string[] | undefined;\n\nlet variable1 = undefined as type1;\n\nconsole.log(variable1 && variable1.length);\n```\n\nAlternatively, try to indirectly refers to the ```\ntype1```\n type like so, which TypeScript will not be able to find it immediately:\n```\ntype type1 = string[] | undefined;\n\nfunction getSomeType(): type1 {\n    return undefined;\n}\n\nlet variable1 = getSomeType();\n\nconsole.log(variable1 && variable1.length);\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is using short-circuit evaluation to avoid an index out of range exception a bad habit? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nThis question applies to every programming language that has a short-circuit AND operator, not just C#.\n\nThe question is simple - is using short circuit evaluation to avoid an out of range index exception, for example:\n\n```\nif ((x > 0) && (bar[x] == foo))\n```\n\n\nor \n\n```\nif (((x > 0) && (x < bar.Length)) && (bar[x] == foo))\n```\n\n\nbad coding style? I know I could nest the loops like this:\n\n```\nif (x > 0)\n{\n    if (bar[x] == foo)\n    {\n    }\n}\n```\n\n\nbut I find it to be extremely unreadable.\n    ", "Answer": "\r\nI would say that\n\n```\nif ((x > 0) && (bar[x] == foo))\n```\n\n\nis not bad coding style. It's probably even good. I would definitely prefer it to a nested ```\nif```\n structure like you describe.\n\nAs an aside, I would reduce the number of parentheses you use. Both these are equally correct, at least in C# and most other C-derived languages:\n\n```\nif (x > 0 && bar[x] == foo)\nif (x > 0 && x < bar.Length && bar[x] == foo)\n```\n\n\nReaders who know the language (you have to assume this at some level) will easily be able to understand the above short-circuit expressions. Those readers would probably object to the nested ```\nif```\n style, because it takes way more room than is necessary to get the correct behaviour.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Kotlin null check with !! does not short-circuit evaluation?\r\n                \r\nIs Kotlin null safety check is not short circuit in if statement evaluation?\nPlease see following example.\n```\nfun main(){\n    var myEmps : List<Emp>? = null\n    println(myEmps) //null\n    var address = if(myEmps?.get(0)!!.address?.line1!=null) myEmps?.get(0)!!.address!!.line1 else \"no address\" //Exception in thread \"main\" java.lang.NullPointerException\n    println(address)\n}\n\ndata class Emp (var name: String?, var address: Address?) {}\ndata class Address(var line1: String?, var line2: String) {}\n```\n\nMy assumption is since myEmps is null and null safety check is there, the get(0)!! should not be evaluated at all and control should jump to else block. but the behavior is otherwise and I am seeing a NullPointerException.\nAnd the same with address element, as below.\n```\nvar address = if(myEmps?.get(0)?.address!!.line1!=null) myEmps?.get(0)?.address!!.line1 else \"no address\" //Exception in thread \"main\" java.lang.NullPointerException\n```\n\nSo null check with !! comes with this caveat of short-circuit not applicable and always ensure entire chain is properly checked? If so, how good is this useful in such scenarios of object chain validations?\n    ", "Answer": "\r\nYou should think of a chain of calls as a series of steps that evaluate to something. Each call on the chain is called on the previous evaluated value. Any ```\n?.```\n call will evaluate to a nullable type.\nFirst you have ```\nmyEmps```\n which is a ```\nList<Emp>?```\n.\nThen you call ```\n?.get(0)```\n. This evaluates to an ```\nEmp?```\n because of the null-safe ```\n?.```\n call.\nThen you call ```\n!!```\n on the ```\nEmp?```\n. ```\n!!```\n means to evaluate it to either a non-nullable ```\nEmp```\n or throw a KotlinNullPointerException. It is essentially the opposite of a null-safe call.\nWhat you actually need if you want null-safety is to continue using null-safe ```\n?.```\n calls all the way down the chain once you have something that is nullable, so you should replace ```\n!!```\n with ```\n?```\n. Like this:\n```\nvar address = if(myEmps?.get(0)?.address?.line1 != null) myEmps?.get(0)?.address!!.line1 else \"no address\"\n```\n\nThe second use of ```\n!!```\n is OK to keep since it happens after your ```\n!= null```\n check so you know the ```\nEmp?```\n is not going to evaluate to ```\nnull```\n. But it is clumsy to repeat that long call chain. You can eliminate this if-statement by using the Elvis operator ```\n?:```\n like this:\n```\nvar address = myEmps?.get(0)?.address?.line1 ?: \"no address\"\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit evaluation in RavenDB\r\n                \r\nDoes ravenDB automatically Short-circuit queries ?\nIf not is there a way to achieve this.\n\nExample:\nI search in my database using a full text search. But this search has other fields which should meet specific values. So how would I prioritize this other fields first before doing the expensive full text search.\n\nAtm my query looks something like this:   \n\n```\ncondition1 AND condition2 AND FTS\n```\n\n\nI'm using Raven embedded client on the .Net 4.5 framework\n    ", "Answer": "\r\nNo. Lucene, the index implementation under the hood, will sometimes re-arrange your query on a best-effort basis. But there's no short-circuit behavior available, and no way to achieve that.\n\nYour assumption of full-text search being \"expensive\" is wrong. Phrase searches, and sometimes wildcard/prefix queries may be a bit costlier to perform due to large lists of terms to enumerate or the requirement to load position data, but all queries in RavenDB are practically a Lucene query so both ```\ncondition1```\n and ```\nFTS```\n in your query are practically the same.\n\nHTH\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Interlocked.CompareExchange \"short-circuit\" evaluation\r\n                \r\nI have just realized that I allocate a lot of objects in ```\nInterlocked.CompareExchange```\n and throw them away to GC, because the value (second argument) is always evaluated, compared to ```\n&&```\n or ```\n||```\n, which use ```\nshort-circuit```\n evaluation .\n\nIs lock the only alternative to atomically check for null and allocate a new object only if the target location is ```\nnull```\n?\n\nThis test prints \"I am created\" three times and fails on the last assertion.\n\n```\ninternal class TestCompareExchange {\n    public static TestCompareExchange defalt = new TestCompareExchange();\n    public static bool allocated = false;\n    public TestCompareExchange() {\n        allocated = true;\n        Console.WriteLine(\"I am created\");\n    }\n}\n\n[Test]\npublic void CompareExchangeAllocatesValue() {\n\n    if (TestCompareExchange.allocated && (new TestCompareExchange()) != null) // the second part after && is not evaluated \n    {\n\n    }\n    Assert.IsFalse(TestCompareExchange.allocated);\n\n    TestCompareExchange target = null;\n    var original = Interlocked.CompareExchange(ref target, new TestCompareExchange(), (TestCompareExchange)null);\n    Assert.AreEqual(null, original);\n    Assert.IsTrue(TestCompareExchange.allocated);\n\n    TestCompareExchange.allocated = false;\n    target = null;\n    original = Interlocked.CompareExchange(ref target, new TestCompareExchange(), TestCompareExchange.defalt);\n    Assert.AreEqual(null, original);\n    Assert.IsFalse(TestCompareExchange.allocated); // no exchange, but objetc is allocated\n}\n```\n\n\nIn my real code, I use ```\nTaskCompletionSource```\n instead of the fake object. Does it matter? Is there some pooling for TCS objects that makes allocation and collection irrelevant for them?\n    ", "Answer": "\r\nBefore performing the ```\nInterlocked```\n operation and the allocation see if the target location is not null already. If yes, there is no need to try and initialize it.\n\n```\nif (Volatile.Read(ref target) == null) InitAtomically();```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "short-circuit evaluation also does evaluate the right hand operand even if it determines the result from the left one?\r\n                \r\nbased on short-circuit evaluation rules the right hand operand is evaluated only if the left hand operand does not determine the result. \nso why \n\n```\nvoid inverse(string& s)\n{\n    string::iterator first = s.begin();\n    string::iterator last = s.end();\n    while (first!= last && first!=--last)\n    {\n        swap(first, last);\n        ++first;\n\n    }\n}\n```\n\n\nseems to evaluate the right one even if the left condition is true?\n\nand this is my swap function :\n\n```\nvoid swap(string::iterator beg, string::iterator end)\n{\n    std::cout << *end << std::endl; //to test if end points to the last element or one past the last element\n    char temp = *beg;\n    *beg = *end;\n    *end = temp;\n}\n```\n\n    ", "Answer": "\r\n\n  Why seems to evaluate the right one even if the left condition is true?\n\n\nBecause ```\n&&```\n is ```\nand```\n operator – it returns true when both operands are true.\n\nOnly left operand being true is not enough to turn whole expression true.\nIf you want that, use ```\nor```\n operator (```\n||```\n) instead.\n\nHowever, when left operand is false, no matter what the right operand is,\nwhole expression can't be true. Then, right operand is not evaluated.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does Objective-C use short-circuit evaluation?\r\n                \r\nI tried something along the lines of:\n\n```\nif(myString != nil && myString.length) { ... }\n```\n\n\nAnd got:\n\n-[NSNull length]: unrecognized selector sent to instance\n\nDoes Objective-C not short-circuit after the first condition fails?\n    ", "Answer": "\r\nObjective-C does support short-circuit evaluation, just like C.\n\nIt seems that in your example ```\nmyString```\n is ```\nNSNull```\n and not ```\nnil```\n, therefore ```\nmyString != nil```\n is true.\n\nNSNull is a singleton and is used to represent ```\nnil```\n where only objects are allowed, for example in an NSArray.\n\nBtw, normally, people write ```\nif (!myString && myString.length == 0)```\n. Comparing to ```\nnil```\n is quite ugly. Also, I'd compare the length to 0. That seems to be more clear.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Would this be a good solution to avoid short-circuit evaluation?\r\n                \r\nI am new in programming and have been recently learning Java by myself. While I was studying, I came into a problem that wants me to find a way to avoid Short-Circuit Evaluation. I came up with two solutions that either maintains or breaks the SCE. I want to know which one would be more preferable answer in real work situations.  \n\nI have first tried separating the computation of int variables from the logical operators. Although it worked and maintained the SCE, I wanted to reduce the number of lines for my coding. So I came up with a code that is shorter but breaks up the SCE. \n\n//the given problem\n\n```\nint n1 = 0, n2 = 0;\nboolean result = ((n1 += 10) < 0) && (num2 +=10) > 0); // false, n1 = 10, n2 = 0\n```\n\n\n//first answer\n\n```\nint n1 = 0, n2 = 0;\nn += 10; n2 += 10; \nboolean result = (n1 < 0) && (n2 > 0); // n1=10, n2=10, false\n```\n\n\n//shorter code\n\n```\nboolean result = !(!((n1 += 10)<0) && (n2 +=10)>0); // false, n1=10, n2=10          \n```\n\n\nAlthough both answers show the same result, shoud I keep SCE alive or aim for shorter coding? I hope my question makes sense.\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit evaluation\r\n                \r\nI understand how the & and && operators differ in many languages. For example\n\n```\nif(condition1 && condition2)\n```\n\n\nwill only evaluate condition2 if condition1 is true, and\n\n```\nif(condition1 & condition2)\n```\n\n\nwill evaluate both condition1 and condition2 regardless of whether condition1 is true or not. My question is when you should use & over && (and respectively | and ||), since the result will always be the same.\n    ", "Answer": "\r\nThe result will not always be the same. You may be thinking of ```\ncondition1```\n and ```\ncondition2```\n as fully-evaluated variables or constants, but they could be function calls with side effects, or ```\ncondition2```\n may be undefined if the value of ```\ncondition1```\n is one way or the other. (The canonical example for this is probably \n\n```\nif (x != null && x.isCondition()) { x.doSomething(); }\n```\n\n\nIn my experience, I've almost never come across a case where I wanted the non-short-circuit evaluation, at least not in an ```\nif```\n clause.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How does C++ handle &&? (Short-circuit evaluation) [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Is short-circuiting logical operators mandated? And evaluation order?\r\n                            \r\n                                (7 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nWhen encountering a (bool1 && bool2), does c++ ever attempts to check bool2 if bool1 was found false or does it ignore it the way PHP does?\n\nSorry if it is too basic of a question, but I really could not find a mentioning of that neither in Schildt nor on the Internet.\n    ", "Answer": "\r\nYes, the ```\n&&```\n operator in C++ uses short-circuit evaluation so that if ```\nbool1```\n evaluates to ```\nfalse```\n it doesn't bother evaluating ```\nbool2```\n.\n\"Short-circuit evaluation\" is the fancy term that you want to Google and look for in indexes.\nThe same happens with the ```\n||```\n operator, if ```\nbool1```\n evaluates to ```\ntrue```\n then the whole expression will evaluate to true, without evaluating ```\nbool2```\n.\nIn case you want to evaluate all expressions anyway you can use the ```\n&```\n and ```\n|```\n operators.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to / is that possible to turn off short-circuit evaluation?\r\n                \r\nI am coding a kind of command line user interface where an arbitrary boolean expression can be given as input. This expression must be repeatedly evaluated on a dictionary that is changing after some update.\nHere is the simplified code :\n```\nimport traceback\n\n\ndef update_my_dict():\n    return {'a': 1}\n\n\nmy_dict = {'a': 0}\n\nbool_exp = input()\n\n# -- verify code can be executed in the current context\ntry:\n    result = eval(bool_exp, my_dict)\nexcept Exception:\n    print(f'Expression cannot be evaluated, evaluation raise the following error:')\n    print(traceback.format_exc())\n    quit()\n\n# -- verify code return a boolean\nif not isinstance(result, bool):\n    print(f'Expression return {type(result)}, expect bool')\n    quit()\n\n# -- go\nwhile not eval(bool_exp, my_dict):\n    my_dict = update_my_dict()\n```\n\nBefore running the last while loop I want to verify that the expression can be executed in the current context and ensuring that its return a boolean.\nMy problem is if the expression is, for example ```\nbool_exp = a == 1 and b == 2```\n the first test evaluation of the expression while return false but do not raise exception because off lazy evaluation. But when ```\nmy_dict```\n is updated then an error will be raised.\nSo is that possible to, some how, disable the lazy/short-circuit evaluation for the first test evaluation ? I searched some solution using ast, but it seems complicated since ```\nbool_exp```\n can be arbitrary long and complex, like containing entangled boolean expressions and so on.\nPS: I know ```\neval()```\n is unsafe in a general context but my code will not be usable externaly\nPS2: I know its possible to catch the exception in the while loop but it looks a bit sub-optimized knowing ```\nmy_dict```\n keys will never change when updated, only their values. Also this question is more like if its possible to control the evaluation behavior\nEDIT\n\"but you could use ```\n&```\n and ```\n|```\n instead of ```\nand```\n and ```\nor```\n !\"\nNo. I cannot tell what will be entered as input. So the user can input whatever s.he want.\nA Correct input expression:\n\nShould return a boolean.\nShould only involve dictionary keys in the tests.\n\n\"Correct\" meaning it will be repeatedly evaluated in the ending while loop without raised any exception.\nWe assume that the keys in the dictionary will stay constant. i.e only the values of the dict will change during the update phase. In other words, the first ```\ntry/except```\n aim to verify that the expression is only doing some test on variables that are in ```\nmy_dict```\n.\nI cannot explain further the global use of this or I'll need a very long post with lost of what seems irrelevant information to resolve the issue.\n    ", "Answer": "\r\nYou could put the \"verification\" code inside the loop. This makes sense as your input is changing so you should verify it on each change. You already ```\neval```\nuate the expression every time the dict values change, so the only added logic compared to your current code is that the ```\nisinstance```\n check is now done as well with every change of the dict:\n```\nimport traceback\n\ndef update_my_dict():\n    return {'a': 1}\n\nmy_dict = {'a': 0}\n\nbool_exp = input()\n\n# -- go\nwhile True:\n    # -- verify code can be executed in the current context\n    try:\n        result = eval(bool_exp, my_dict)\n    except Exception:\n        print(f'Expression cannot be evaluated, evaluation raise the following error:')\n        print(traceback.format_exc())\n        quit()\n\n    # -- verify code return a boolean\n    if not isinstance(result, bool):\n        print(f'Expression return {type(result)}, expect bool')\n        quit()\n\n    if result:\n        break\n\n    my_dict = update_my_dict()\n```\n\nOn the same example input ```\na == 1 and b == 2```\n this will output:\n```\nExpression cannot be evaluated, evaluation raise the following error:\nTraceback (most recent call last):\n  File \"main.py\", line 14, in <module>\n    result = eval(bool_exp, my_dict)\n  File \"<string>\", line 1, in <module>\nNameError: name 'b' is not defined\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Methods for optimizing short-circuit evaluation for conditions of varying evaluation-cost\r\n                \r\nThis is a bit of an abstract question, I hope that's ok (if not, please let me know of a better place to ask it):\n\nI have a bunch of boolean conditions, let's call them ```\nA, B, C, D, ...```\n.\n\nIn my code, I need to use these conditions to distinguish between several different possible scenarios. For example, I could have something like this (in pseudo code):\n\n```\nif ((A and B) or not (C or D)) then process case 1\nif (A and (not B) and (C or D)) then process case 2\notherwise process case 3\n```\n\n\nNow, I can start to combine these if-statements to optimize the number of evaluations needed, like:\n\n```\nif (A) then {\n    if (B) then {\n        process case 1\n    } else {\n        if (C or D) then process case 2\n                    else process case 1\n    }\n} else {\n    if (C or D) then process case 3\n                else process case 1\n}\n```\n\n\nBut I could equally well \"short-circuit\" (I'm using the term loosely) some of the evaluations differently, like:\n\n```\nif (C or D) then {\n    if (A) then {\n        if (B) then process case 1\n               else process case 2\n    } else {\n        process case 3\n    }\n} else {\n    process case 1\n}\n```\n\n\nLet's say that there is a significant difference in the cost of evaluating these conditions, e.g. some require a database call, others are simple variable-null-checks, etc. Then, there is probably an optimal solution for how to break up the code (assuming all cases are somewhat equally likely).\n\nFor example, if the evaluation of A and B is cheap while the evaluation of C or D is expensive, the first version above is probably better on average as there is a chance that if A and B turn out true, C and D never need to get evaluated. Whereas if C and D are cheap while A or B are expensive, version two is better on average.\n\nIs there some formal framework or other approach for figuring out this optimization?\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How can I render multiple elements after an inline condition using short circuit evaluation?\r\n                \r\nUsing a short circuit evaluation in a functional component (with hooks):\n\n```\nconst Filters = () => {\n  const [options, setOptions] = useState([]);\n\n  return (\n    <div className=\"row\">\n      {options.length > 0 && (\n        <div className=\"col-md-3\">\n          <CustomComponent />\n        </div>\n      )}\n    </div>\n  )\n}\n```\n\n\nIs there a way to render multiple elements right after an inline if condition?\n\n```\n{options.length > 0 && (\n  <div className=\"col-md-3\">\n    <CustomComponent />\n  </div>\n  <div className=\"col-md-3\">\n    <SecondComponent />\n  </div>\n)}\n```\n\n\nCode above doesn't work, react throws an error. ```\noptions```\n array is filled after a promise resolved from ```\nuseEffect()```\n. That's why i've added this check, to display elements only when a promise resolved.\n\nUPDATED CODE for @wentjun:\n\n```\nreturn (\n  {options.length > 0 && (\n    <div className=\"row\">\n      <div className=\"col-md-3\">\n        <CustomComponent />\n      </div>\n    </div>\n  )}\n  )\n```\n\n\nThis throws a syntax error.\n    ", "Answer": "\r\nI think the error is due to returning two react elements. Try wrapping then in fragment\n\n```\n{options.length > 0 && (\n  <>\n    <div className=\"col-md-3\">\n      <CustomComponent />\n    </div>\n    <div className=\"col-md-3\">\n      <SecondComponent />\n    </div>\n  </>\n)}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to explain the two way of Clang code generation for short-circuit evaluations?\r\n                \r\nOriginal C code is\n```\nstruct Customer\n{CityName city;     // city name\n FavcName favorite; // favorite category of goods\n int   age;         // age \n int   gender;      // 1 = M; 2 = F; 3 = genderfluid;\n bool  married;     // true = married\n int   reg;         // registration date (unixtime)\n int   lastdeal;    // last deal date (unixtime)\n float total; };    // total spended (UAH)\n\nbool __cdecl filter_A( har city[24], char favorite[24], int age, int gender, bool married, int reg, int lastdeal, float total)\n{ return strcmp(favorite,\"Tools\") == 0 && age <= 25; }\n\nbool __cdecl filter_B(Customer c)\n{ return strcmp(c.favorite,\"Tools\") == 0 && c.age <= 25; }\n```\n\nUse clang with -O1 optimization and get:\n(name mangling replased to normal names)\n```\ndefine dso_local noundef zeroext i1 @filter_A(ptr %0, ptr %1, i32 %2, i32 %3, i1 %4, i32 %5, i32 %6, float %7) {\n  %9 = tail call i32 @strcmp(ptr %1, ptr @\"Tools\")\n  %10 = icmp eq i32 %9, 0\n  %11 = icmp slt i32 %2, 26\n  %12 = and i1 %11, %10\n  ret i1 %12\n}\n\ndefine dso_local noundef zeroext i1 @filter_B(ptr %0) {\n  %2 = getelementptr inbounds %struct.Customer, ptr %0, i64 0, i32 1\n  %3 = tail call i32 @strcmp(ptr %2, ptr @\"Tools\")\n  %4 = icmp eq i32 %3, 0\n  br i1 %4, label %5, label %9\n\n5:                                                ; preds = %1\n  %6 = getelementptr inbounds %struct.Customer, ptr %0, i64 0, i32 2\n  %7 = load i32, ptr %6, align 4, !tbaa !4\n  %8 = icmp slt i32 %7, 26\n  br label %9\n\n9:                                                ; preds = %5, %1\n  %10 = phi i1 [ false, %1 ], [ %8, %5 ]\n  ret i1 %10\n}\n```\n\nSo why in Filter_A are doesn't used short-circuit evaluation, while Filter_B does?\nThe logic expression is same in both functions.\n    ", "Answer": "\r\nExplanation why this is happening\nTo understand why this is the case, you need to look at what benefit you get from short-circuiting and what the added cost is.\nFor ```\nfilter_B```\n you add the short-circuit branch, but eliminate a load from ```\nc.age```\n in the case that the first comparison evaluates to ```\n0```\n.\nNow we look at ```\nfilter_A```\n. In this function, there is no need to load ```\nage```\n from memory, as ```\nage```\n is located in a virtual register, not a memory location. Since comparing two values produces no side effects, the compiler decides the compare is cheaper than a short-circuit branch.\nForcing ```\nfilter_A```\n to also short-circuit\nIf you change the ```\nage```\n variable to be ```\nvolatile```\n, you force the compiler to assume that loading the variable might have side effects. In this case, the code will be similar to your second case. See this example on Compiler Explorer.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C++ short circuit evaluation w.r.t optimization\r\n                \r\nSimple question, but surprisingly hard to search for.\nFor the statement ```\nA && B```\n I know there is a sequence point between the evaluation of ```\nA```\n and ```\nB```\n, and I know that the order of evaluation is left-to-right, but what is a compiler allowed to do when it can prove that ```\nB```\n is always false (perhaps even explicitly so)?\n\nNamely, for ```\nfunction_with_side_effects() && false```\n is the compiler allowed to optimize away the function call?\n    ", "Answer": "\r\nA compiler is allowed to optimise out anything, as long as it doesn't break the as-if rule. The as-if rule states that with respect to observable behaviour, a program must behave as if it was executed by the exact rules of the C++ abstract machine (basically normal, unoptimised semantics of code).\n\nObservable behaviour is:\n\n\nAccess to ```\nvolatile```\n objects\nWriting to files\nInput & output on interactive devices\n\n\nAs long as the program does the three things above in correct order, it is allowed to deviate from other source code functionality as much as it wants.\n\nOf course, in practice, the number of operations which must be left intact by the compiler is much larger than the above, simply because the compiler has to assume that any function whose code it cannot see can, potentially, have an observable effect.\n\nSo, in your case, unless the compiler can prove that no action inside ```\nfunction_with_side_effects```\n can ever affect observable behaviour (directly or indirectly by e.g. setting a flag tested later), it has to execute a call of ```\nfunction_with_side_effects```\n, because it could violate the as-if rule if it didn't.\n\n\n\nAs @T.C. correctly pointed out in comments, there are a few exceptions to the as-if rule, when a compiler is allowed to perform optimisations which change observable behaviour; the most commonly encountered among these exceptions being copy elision. However, none of the exceptions come into play in the code in question.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit logic evaluation operators\r\n                \r\nAre there any short-circuit logic operators (specifically short-circuit ```\nAND```\n and short-circuit ```\nOR```\n) that I can use in a ```\nWHERE```\n clause in MySQL 5.5? If there isn't, what are the alternatives?\n\nAn abstract view at my problem along with an explanation as to why I need this can be found at this fiddle:\n\nhttp://sqlfiddle.com/#!2/97fd1/3\n\nIn reality we are looking at millions of books in millions of bookstores in thousands of cities in hundreds of countries, which is why we cannot accept the overhead of receiving the unneeded information with every query we dispatch  and seriously need to find a way to make the evaluation stop as soon as we have all rows that satisfy the current condition, before moving on to the next OR.\n\nLet me know if you need more information. Thanks in advance.\n\n\n\nAs requested, here is the schema used in the fiddle:\n\n```\nCREATE TABLE quantitycache (\n  id INT AUTO_INCREMENT,\n  quantity INT,\n  book_id INT NOT NULL,\n  bookstore_id INT NULL,\n  city_id INT NULL,\n  country_id INT NULL,\n  PRIMARY KEY (id)\n);\n```\n\n\nAs well as some example data:\n\n```\nINSERT INTO quantitycache \n     (quantity, book_id, bookstore_id, city_id, country_id)\nVALUES\n     (5,        1,       1,            NULL,    NULL),\n     (100,      2,       1,            NULL,    NULL),\n     (7,        1,       2,            NULL,    NULL),\n     (12,       1,       NULL,         1,       NULL),\n     (12,       1,       NULL,         NULL,    1),\n     (100,      2,       NULL,         1,       NULL),\n     (100,      2,       NULL,         NULL,    1),\n     (200,      3,       NULL,         1,       NULL),\n     (250,      3,       NULL,         NULL,    1);\n```\n\n    ", "Answer": "\r\nKeep in mind that a query does not execute imperatively.  The query you wrote may run on multiple threads, and therefore a short-circuit operator in the where clause would not result in only one result.\n\nInstead, use the ```\nLIMIT```\n clause to only return the first row.\n\n```\nSELECT * FROM quantitycache\nWHERE bookstore_id = 1 OR city_id = 1 OR country_id = 1\nORDER BY bookstore_id IS NULL ASC,\n         city_id IS NULL ASC,\n         country_id IS NULL ASC\nLIMIT 1;\n```\n\n\n\n\nTo get the best match for all books in a result set, save the results to a temp table, find the best result, then return interesting fields.\n\n```\nCREATE TEMPORARY TABLE results (id int, book_id int, match_rank int);\n\nINSERT INTO results (id, book_id, match_rank)\nSELECT id, book_id, \n    -- this assumes that lower numbers are better\n    CASE WHEN Bookstore_ID is not null then 1 \n         WHEN City_ID is not null then 2 \n         ELSE 3 END as match_rank\nFROM quantitycache\nWHERE bookstore_id = 1 OR city_id = 1 OR country_id = 1;\n\nSelect * \nfrom (\n    select book_id, MIN(match_rank) as best_rank \n    from results \n    group by book_id\n) as r\ninner join results as rid \n    on r.book_id = rid.book_id \n    and rid.match_rank = r.best_rank\ninner join quantitycache as q on q.id = rid.id;\n\nDROP TABLE results;\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is short-circuit evaluation possible in multiplication?\r\n                \r\nSuppose I have this code in Java:\n\n```\n    public static double function(double x, double y, int k) {\n        return Math.pow(x, 2) + Math.pow(y, 2) + y + k*Math.sqrt(Math.pow(y, x));\n}\n```\n\n\nIt calculates some function at certain point ```\n(x,y)```\n. Notice that square root is multiplied by integer ```\nk```\n. There will be instances where I will give ```\nk = 0```\n (because I wouldn't need square root evaluated). It gives the value I need but the problem is that I am writing time sensitive program, i.e I will call method ```\nfunction```\n many, many times. So, I want that my program wouldn't evaluate ```\nMath.sqrt(Math.pow(y, x))```\n if ```\nk = 0```\n.\nI googled a bit, but there doesn't seem to be a 'short-circuit' equivalent for arithmetic (well, in many cases it doesn't even make sense, with multiplication possibly being an exclusion) operations as there is for logic operations.\n\nHow could I achieve the desired result? \n    ", "Answer": "\r\nI think adding ternary operator at the end will avoid calling of ```\nMath.sqrt(Math.pow(y, x))```\n computation. As shown below\n\n```\n public static double function(double x, double y, int k) {\n        return Math.pow(x, 2) + Math.pow(y, 2) + y \n             + ( k!=0 ?  k*Math.pow(y, x/2) : 0); //ternary operator here\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "PHP Short-Circuit Evaluation (Good/Bad?)\r\n                \r\nThis is a general question of sorts, but to explain it I will use a specific example.\n\nI have a function that loads a document. If that document does not exist it will create it, if it does exist it will convert it to a JSON array. I always want this function to return an array of some sort, whether or not there is an issue with ```\njson_decode()```\n or if the file does not exist. Currently I am doing it like so...\n\n```\nfunction load($file) {\n    if( ! file_exists($file)) {\n        $handle = fopen($file, 'w');\n        fclose($handle);\n    }\n\n    $raw = file_get_contents($file);\n    $contents = json_decode($raw, TRUE);\n\n    return( ! $contents ? array() : $contents);\n    //cant use ternary shorthand \"?:\" in PHP 5.2, otherwise this would be shorter\n}\n```\n\n\nNow, there is nothing wrong with the above code (at least I don't think there is and it works fine). However I'm always looking for ways to improve my code and condense it while keeping it perfectly legible. And that return statement has always bothered me because of how inefficient it seems. So today I got to thinking and something occurred to me. I remember seeing mysql tutorials that do something to the effect of ```\nconnect() or die();```\n so I thought, why not ```\njson_decode() or array();```\n? Would this even work? So I rewrote my function to find out...\n\n```\nfunction load($file) {\n    if( ! file_exists($file)) {\n        $handle = fopen($file, 'w');\n        fclose($handle);\n    }\n\n    $raw = file_get_contents($file);\n    return json_decode($raw, TRUE) or array();\n}\n```\n\n\nIt seems to, and it even reads pleasantly enough. So on to my next bout of questions. Is this good practice? I understand it, but would anyone else? Does it really work or is this some bug with a happy ending? I got to looking around and found out that what I'm asking about is called short-circuit evaluation and not a bug. That was good to know. I used that new term to refine my search and came up with some more material.\n\nBlog Entry\n\nWikipedia\n\nThere wasn't much and most everything I found that talked about using short-circuiting in the way I'm inquiring about always referred to MySQL connections. Now, I know most people are against using the ```\nor die()```\n terminology, but only because it is an inelegant way to deal with errors. This isn't a problem for the method I'm asking about because I'm not seeking to use ```\nor die()```\n. Is there any other reason not to use this? Wikipedia seems to think so, but only in reference to C. I know PHP is written in C, so that is definitely pertinent information. But has this issue been wheedled out in the PHP compilation? If not, is it as bad as Wikipedia makes it out to be?\n\nHere's the snippet from Wikipedia.\n\nWikipedia - \"Short-circuiting can lead to errors in branch prediction on modern processors, and dramatically reduce performance (a notable example is highly optimized ray with axis aligned box intersection code in ray tracing)[clarification needed]. Some compilers can detect such cases and emit faster code, but it is not always possible due to possible violations of the C standard. Highly optimized code should use other ways for doing this (like manual usage of assembly code)\"\n\nWhat do you all think?\n\nEDIT\n\nI've polled another forum and gotten some good results there. General consensus appears to be that this form of variable assignment, while valid, is not preferred, and may even be considered bad form in the real world. I'll continue to keep an ear to the ground and will update this if anything new comes around. Thank you Corbin and Matt for your input, especially Corbin for clearing up a few things. Here's a link to the forum post should you be interested.\n    ", "Answer": "\r\nThere's a few different questions you ask, so I'll try to address them all.\n\nMissed branch predictions: Unless you're coding in C or assembly, don't worry about this.  In PHP, you're so far from the hardware that thinking about branch predictions isn't going to help you.  Either way, this would be a very-micro optimization, especially in a function that does extensive string parsing to begin with.\n\n\n  Is there any other reason not to use this? Wikipedia seems to think so, but only in reference to C. I know PHP is written in C, so that is definitely pertinent information.\n\n\nPHP likely parses it to a different execution structure.  Unless you're planning on running this function millions of times, or you know it's a bottleneck, I wouldn't worry about it.  In 2012, I find it very unlikely that using an ```\nor```\n to short circuit would cause even a billionth of a second difference.\n\nAs for the formatting, I find ```\n$a or $b```\n rather ugly.  My mind doesn't comprehend the short circuiting the same it sees it in an if clause.\n\n```\nif (a() || b())\n```\n\n\nIs perfectly clear to my mind that b() will execute only if a() does not evaluate to true.\n\nHowever:\n\n```\nreturn a() or b();\n```\n\n\nDoesn't have the same clarity to me.\n\nThat's obviously just an opinion, but I'll offer two alternatives as to how I might write it (which are, in my opinion, a very tiny bit clearer):\n\n```\nfunction load($file) {\n    if (!file_exists($file)) {\n        touch($file);\n        return array();\n    }\n\n    $raw = file_get_contents($file);\n\n    $contents = json_decode($raw, true);\n\n    if (is_array($contents)) {\n        return $contents;\n    } else {\n        return array();\n    }\n\n}\n```\n\n\nIf you don't care if the file actually gets created, you could take it a step farther:\n\n```\nfunction load($file) {\n\n    $raw = file_get_contents($file);\n\n    if ($raw !== false) {\n        $contents = json_decode($raw, true);\n        if ($contents !== null) {\n            return $contents;\n        }\n    }\n\n    return array();\n\n}\n```\n\n\nI guess really these code snippets come down to personal preference.  The second snippet is likely the one I would go with.  The critical paths could be a bit clearer in it, but I feel like it maintains brevity without sacrificing comprehensibility.\n\nEdit: If you're a 1-return-per-function type person, the following might be a bit more preferable:\n\n```\nfunction load($file) {\n\n    $contents = array();\n\n    $raw = file_get_contents($file);\n\n    if ($raw !== false) {\n        $contents = json_decode($raw, true);\n        if ($contents === null) {\n            $contents = array();\n        }\n    }\n\n    return $contents;\n\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How would I modify the definition of the operators \"&&\" and \"||\" so that they do not use short circuit evaluation?\r\n                \r\nHow would I modify the definition of the operators \"&&\" and \"||\" so that they do not use short circuit evaluation? Please show the new semantic rule.\nI tried the following:\n\"AND (&&): It returns expression #1 if it can be converted to false - if else it returns expression #2. Therefore, when used with the Boolean value, it returns true if both operands can be converted to true; otherwise, it returns false.\nOR (||): it returns expression #1 if it can be converted to true – if-else, it returns expression #2. Therefore, when used with Boolean values, || returns true if either operand can be converted to true - if both can be converted to false, it returns false. \"\nHowever, apparently, that's still using short-circuit evaluation.\n    ", "Answer": "\r\nShort-circuit evaluation means that you stop immediately whenever you encounter a value of false for AND and a value of true for OR. This is because the value of the entire expression will always be that no matter what the second term is.\nYour AND description is wrong because if expression #1 evaluates to false, expression #2 is not evaluated at all. Same thing with OR.\nWhat you want to do is to evaluate both expressions before manipulating either values.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "PHP short circuit lazy evaluation, where is it in the php.net manual?\r\n                \r\nSorry if this sounds like a really silly question.\n\nBut I Googled the web and also Googled specifically both the php.net site and the stackoverflow.com site.\nI know PHP does short circuit lazy evaluation when using ```\nand, or, &&, ||```\n operators, but where is it stated loud and clear in the PHP manual???\n\nI found only Wikipedia as the only 'trusted' source that say PHP does lazy evaluation on these operators.\n    ", "Answer": "\r\nClosest thing I can find to an 'official' mention of PHP's short-circuit implementation: http://php.net/manual/en/language.operators.logical.php\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "SQLServer CASE expressions - short circuit evaluation?\r\n                \r\nI am trying to optimize a query that does something like this:\n\n```\nSELECT\n   ...\n   CASE WHEN (condition) THEN (expensive function call #1)\n   ELSE (expensive function call #2) \n   END\n...\n```\n\n\nThe query plan shows that for even in cases where 100% of rows satisfy the WHEN clause, a substantial portion of the time is spent in calls to the result in the ELSE branch.\n\nThe only way I can make sense of this is to presume that SQLServer is evaluating both results, then only selecting one based on evaluation of the WHEN condition, but I can't find any definitive reference as to whether or not the results of a CASE statement are evaluated before the conditionals.  Can anyone please clarify or point me to a reference?\n    ", "Answer": "\r\nSQL is a declarative language. You express in a query the desired result and the server is free to choose whatever means to deliver those results. As such the order of evaluation of SQL epxressions is not determined and ```\nOR```\n and ```\nAND```\n evaluation short circuit does not occur. \n\nHowever for ```\nCASE```\n the documentation actually states that the order of evaluation occurs in the order of declaration and the evaluation stops after the first condition is met:\n\n\n  \n  Evaluates ```\ninput_expression```\n, and then in the order specified, evaluates\n  ```\ninput_expression```\n = ```\nwhen_expression```\n for\n  each ```\nWHEN```\n clause.\n  Returns the ```\nresult_expression```\n of the first ```\ninput_expression =\n  when_expression```\n that evaluates to\n  ```\nTRUE```\n.\n  \n\n\nThat means that if you see the expression in the FALSE branch evaluated, your CASE condition is incorrect and sometimes evaluates to FALSE or UNKNOWN. Make sure that tri-values logic of SQL is taken into account (ie. you account for NULLs). Also make sure the data in the tables is the one you expect (ie. the condition really evaluates to FALSE 100% of the cases).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Force DAX SWITCH function to use strict (lazy) short-circuit evaluation\r\n                \r\nSet up:\nSimilar to this question on a MSDN forum, I have a measure that switches between various other measures (some of them much more complex than others). The measure looks like this (my actual measure has more cases):\n```\nVariableMeasure =\nVAR ReturnType =\n    SELECTEDVALUE ( ParamReturnType[ReturnType] )\nSWITCH (\n    ReturnType,\n    \"NAV\", [Nav],\n    \"Income\", [Income],\n    \"ROI\", [Roi],\n    \"BM\", [Benchmark],\n    BLANK ()\n)\n```\n\n\nContext:\nThe reason for the switching measure is to have the ability to choose which measures to display on a report by choosing the ```\nReturnType```\n with a slicer and then the selected measures show up as column headers in a matrix visual. For example, my matrix may look like this:\n\n(As you can see, it's not showing ```\nBM```\n since it's not selected.)\n\nProblem: The problem is that when I just have ```\nNAV```\n selected the measure is still nearly as slow as with everything selected despite it being a cheap measure to compute. When I profile the query with DAX Studio, it takes about 2.7 seconds for what should be a simple query. Indeed, if I comment out the lines with measures other than ```\n[Nav]```\n in the switching measure the performance improves drastically, running in less than 100 milliseconds (30x faster). DAX Studio shows that the formula engine (FE) is responsible for about 99.5% of the 2.7 seconds whereas the storage engine (SE) uses less than 20 milliseconds.\n\nResearch:\nI've read the following SQL BI articles, which mention lazy/strict evaluation and short-circuiting.:\nUnderstanding eager vs. strict evaluation in DAX\nOptimizing IF and SWITCH expressions using variables\nMy measure is analogous to the last example in the second link but does not benefit from \"short-circuit evaluation\" as it does in their case.\nThis Power BI Community question is similar but provides no additional insight.\nThis Power BI Usergroup Community post references a couple more interesting articles but those haven't ultimately led me to a resolution, unfortunately.\n\nQuestion: How can I get each measure in the ```\nSWITCH```\n to evaluate independently of the other cases since building a query plan to accommodate all of the cases simultaneously results in poor performance everywhere?\nI'm open to suggestions or workarounds that resolve my issue even if it doesn't narrowly answer this question.\n\nAdditional information: I have a hunch that the query engine may indeed be strictly evaluating the switch function but only after building a generalized query that can support all of the cases and since the different measures are built with dissimilar logic, this is highly inefficient (and also where my situation is not analogous to the SQL BI example I referred to).\n\nUpdate:\nMicrosoft has addressed this problem at least to some extent in a May 2021 update of Power BI:\nhttps://powerbi.microsoft.com/en-us/blog/power-bi-report-server-may-2021-feature-summary/#perf\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Browser short circuit evaluation not working?\r\n                \r\nI have the following code: \n\nLogic:\n\n```\nvar describe = document.getElementById('describe');\nvar brandpower = document.getElementById('brandpower');\n\nvar describeV = describe.options[describe.selectedIndex].value || describe.value;\nvar brandpowerV = brandpower.options[brandpower.selectedIndex].value || describe.value;\n\nfunction pollRadio() {\n    var handle = window.setInterval(function() {\n      if (jQuery('input[name=\"dealer\"]:checked').val() == 'Non-Pro') {\n          jQuery('#domain').value = \"null\";\n\n        jQuery('#website-container').addClass('important-hide')\n         //window.clearInterval(handle);\n       } else if (jQuery('input[name=\"dealer\"]:checked').val() == 'Pro') {\n      jQuery('#website-container').removeClass('important-hide')\n      jQuery('#domain').value = \"\";\n      jQuery('#describe').replaceWith('<select id=\"describe\" class=\"describeClass custom-select\" required ><option value=\"\" selected>Tell us about your business.</option><option value=\"Just getting started\">Just getting started</option><option value=\"Expanding Quickly\">Expanding Quickly</option><option value=\"Need new cutsomers\">Need new cutomers</option><option value=\"I need better products & solutions\">I need better products & solutions</option><option value=\"Other\">Other</option></select>');\n    window.clearInterval(handle);\n       }\n    }, 100);\n  }\n    pollRadio();\n\n\n      $(document).on('change', \"#describe\", function() {                                \n         if (jQuery('.describeClass').val() == 'Other') {\n             jQuery('.describeClass').replaceWith('<input id=\"describe\" class=\"describeClass form-text\" placeholder=\"Tell us about Other\" type=\"text\" style=\"height:52px; width:100%;\" required> ')\n            }\n    });\n\n    $('#brandpower').on('change', function(){\n      if (jQuery('#brandpower').val() == 'Other') {\n      jQuery('#brandpower').replaceWith('<input id=\"brandpower\" placeholder=\"Tell us about Other\" type=\"text\" class=\"form-text\" style=\"height:52px; width:100%;\" required> ')\n         }\n    });\n```\n\n\nMarkup: \n\n```\n<div class=\"padded-container\">\n                        <div class=\"form-container-padded\">\n                            <select id=\"describe\" class=\"custom-select describeClass\" required >\n                                <option value=\"\" selected>Which best describes you?</option>\n                                <option value=\"Household CEO\">Household CEO</option>\n                                <option value=\"Geek Dad\">Geek Dad</option>\n                                <option value=\"Geek Mom\">Geek Mom</option>\n                                <option value=\"Home Automation Thought Leader\">Home Automation Thought Leader</option> \n                                <option value=\"New Home Automation Business Owner\">New Home Automation Business Leader</option>\n                                <option value=\"Z-Wave Evangelist\">Z-Wave Evangelist</option> \n                                <option value=\"Integrator\">Integrator</option>\n                                <option value=\"IoT Expert\">IoT Expert</option>\n                                <option value=\"Enviormentalist\">Enviormentalist</option>\n                                <option value=\"Educator\">Educator</option>\n                                <option value=\"Computer Science Graduate\">Computer Science Graduate</option>\n                                <option value=\"CES Atendee\">CES Atendee</option>\n                                <option value=\"Competitor\">Competitor</option>\n                                <option value=\"College Student\">College Student</option>\n                                <option value=\"Urban Dweller\">Urban Dweller</option>\n                                <option value=\"Minimalist\">Minimalist</option>\n                                <option value=\"Home Builder\">Home Builder</option>\n                                <option value=\"New Home Owner\">New Home Owner</option>\n                                <option value=\"Electrician\">Electrician</option>\n                                <option value=\"Plumber\">Plumber</option>\n                                <option value=\"Other type of Tradesmen/Tradeswoman\">Other type of Tradesmen/Tradeswoman</option>\n                                <option value=\"General Contractor\">General Contractor</option>\n                                <option value=\"Generalist\">Generalist</option>\n                                <option value=\"Summer Home Owner\">Owner</option>\n                                <option value=\"Serial Entreprenour\">Serial Entreprenour</option>\n                                <option value=\"Tech Savvy\">Tech Savvy</option>\n                                <option value=\"Tinkerer\">Tinkerer</option>\n                                <option value=\"Other\">Other</option>\n                            </select>\n                        </div>\n                    </div>\n                    <div class=\"padded-container\">\n                        <div class=\"form-container-padded\">\n                            <select id=\"brandpower\" class=\"custom-select\" required>\n                                <option value=\"\" selected>How well do you know dome?</option>\n                                <option value=\"I don't. This is my first time hearing about Dome.'\">I don't. This is my first time hearing about Dome.</option>\n                                <option value=\"Have heard of somewhere, but not sure where.\">Have heard of somewhere, but not sure where.</option> \n                                <option value=\"I discovered Dome while researching on the internet.\">I discovered Dome while researching on the internet.</option>\n                                <option value=\"I clicked on an ad for Dome I saw online\">I clicked on an ad for Dome I saw online</option> \n                                <option value=\"Someone told about Dome\">Someone told about Dome</option>\n                                <option value=\"We met at a tradeshow\">We met at a tradeshow</option>\n                                <option value=\"I'm alreaedy interested in working with Dome\">I'm alreaedy interested in working with Dome</option>\n                                <option value=\"I have Dome installed in my home\">I have Dome installed in my home</option>\n                                <option value=\"I've been to Dome's websites several times\">I've been to Dome's websites several times</option>\n                                <option value=\"Other\">Other</option> \n                            </select>\n                        </div>\n                    </div>\n```\n\n\nSo, the idea is, on lines 2 - 4, if one element doesn't exist the interpreter picks up the value of the one that does hence the ```\n||```\n operator. \n\nThe jQuery that is using the replaceWith method is dynamically changing DOM elements if certian conditions are met. Part of me feels as if this, coupled with getDocumentById is part of the issue because an ID can only exist once. It looks to exist properly though in the console.\n\nHowever, while I believe this should work in theory, chrome throws an error where at the ```\n[element.selectedIndex].value```\n part because it is undefined. How can I overcome this error and have my forms work the way I want them to?\n\nEDIT: Short Circut Evaluation JavaScript OR (||) variable assignment explanation\n    ", "Answer": "\r\nThe interpreter will try to evaluate everything before the ```\n||```\n, so it will blow up if any of the following are true:\n\n\n```\ndescribe```\n is undefined (no element in the DOM with that ID), so you can't access ```\ndescribe.options```\n\n```\ndescribe.options```\n is undefined, meaning you can't reference the ```\n[describe.selectedIndex]```\n property on it\n```\ndescribe.selectedIndex```\n is undefined, which means that ```\ndescribe.options[describe.selectedIndex]```\n will return ```\nundefined```\n, and then you cannot access the ```\nvalue```\n property on it\n\n\nYou'll just need to be more defensive, maybe something like this:\n\n```\nvar describeV = (describe && describe.options && describe.selectedIndex) ? describe.options[describe.selectedIndex].value : describe.value;\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C++ What are the conditions of short circuit evaluation? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        A warning - comparison between signed and unsigned integer expressions\r\n                            \r\n                                (6 answers)\r\n                            \r\n                    \r\n                    \r\n                        Is short-circuiting logical operators mandated? And evaluation order?\r\n                            \r\n                                (7 answers)\r\n                            \r\n                    \r\n                Closed 11 months ago.\r\n        \r\n\r\n\r\n    \r\n\r\n```\nif (i - word.size() >= 0 && dp[i - word.size()] && s.substr(i - word.size(), word.size()) == word)\n    dp[i] = true;\n```\n\n```\ni - word.size() >= 0```\n is the condition that I was using to prevent an out-of-bound indexing. The expectation was that if the condition was not satisfied, the equation would short circuit and the reference ```\ndp[i - word.size()]```\n would not be happen.\nBut the reference happened regardless of the first condition. Only when I changed the code to the following, it started to short circuit.\n```\nint lookback = i - word.size();\nif (lookback >= 0 && dp[lookback] && s.substr(i - word.size(), word.size()) == word)\n    dp[i] = true;\n```\n\nWhy does the second code short circuit while the first one doesn't? I've read that if the logical operators ```\n&&```\n and ```\n||```\n are overloaded, short circuiting doesn't happen, but that doesn't seem to be the case here and I can't figure out why it's not happening.\nHere's the full code for context\n```\nbool wordBreakFaulty(string s, vector<string>& wordDict) {\n    int n = s.size() + 1;\n    vector<bool> dp(n, false);\n    dp[0] = true;\n    for (int i = 1; i < dp.size(); ++i) {\n        for (auto& word : wordDict) {\n            if (i - word.size() >= 0 && dp[i - word.size()] && s.substr(i - word.size(), word.size()) == word)\n                dp[i] = true;\n        }\n    }\n\n    return dp.back();\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "PHP short-circuit evaluation\r\n                \r\nI have this code:\n\n```\nif (!in_array('array_item', $body) || !is_int($body['array_item']))\n    throw new Exception();\n```\n\n\nNow due to short-circuiting I would expect ```\nis_int```\n not to execute if ```\narray_item```\n does not exist in ```\n$body```\n. However I still get complaints from PHP about \"undefined index array_item\", which I assume is from ```\n$body['array_item']```\n.\n\nCan someone explain to me why ```\n$body['array_item']```\n is executed if ```\nis_int```\n isn't?\n    ", "Answer": "\r\n```\nin_array```\n looks for a value in an array. If you want to see, if a key exists, use ```\narray_key_exists```\n instead\n\n```\nif (!array_key_exists('array_item', $body) || !is_int($body['array_item']))\n    throw new Exception();\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit evaluation like Python's \"and\" while storing results of checks\r\n                \r\nI have multiple expensive functions that return results.  I want to return a tuple of the results of all the checks if all the checks succeed.  However, if one check fails I don't want to call the later checks, like the short-circuiting behavior of ```\nand```\n.  I could nest ```\nif```\n statements, but that will get out of hand if there are a lot of checks.  How can I get the short-circuit behavior of ```\nand```\n while also storing the results for later use?\n\n```\ndef check_a():\n    # do something and return the result,\n    # for simplicity, just make it \"A\"\n    return \"A\"\n\ndef check_b():\n    # do something and return the result,\n    # for simplicity, just make it \"B\"\n    return \"B\"\n\n...\n```\n\n\nThis doesn't short-circuit:\n\n```\na = check_a()\nb = check_b()\nc = check_c()\n\nif a and b and c:\n    return a, b, c\n```\n\n\nThis is messy if there are many checks:\n\n```\nif a:\n   b = check_b()\n\n   if b:\n      c = check_c()\n\n      if c:\n          return a, b, c\n```\n\n\nIs there a shorter way to do this?\n    ", "Answer": "\r\nJust use a plain old for loop:\n\n```\nresults = {}\nfor function in [check_a, check_b, ...]:\n    results[function.__name__] = result = function()\n    if not result:\n        break\n```\n\n\nThe results will be a mapping of the function name to their return values, and you can do what you want with the values after the loop breaks.  \n\nUse an ```\nelse```\n clause on the for loop if you want special handling for the case where all of the functions have returned truthy results.  \n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "relying on Java's short-circuiting evaluation (coding style) [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIs it ever a good coding style to heavily rely on short-circuit in boolean evaluation?\n\nI've known someone who loves to do this.\nFor instance, if the business logic is \"If Alice is not hungry OR if both Alice and Bob are hungry\", instead of writing \n\n```\n// if Alice is not hungry or both alice and bob are hungry\nif (!A || A && B)` \n```\n\n\nhe would write\n\n```\n// if Alice is not hungry OR both alice and bob are hungry\nif (!A || B)\n```\n\n\narguing that ```\n||```\n is short-circuited, so the right-operand is evaluated if and only if the first one is ```\nfalse```\n (which means ```\nA = true```\n).\n\n(The annoying thing about this is that at first glance, you would think this is a bug but then feel you would look stupid if you change it to what is more obvious!)\n    ", "Answer": "\r\nYou certainly can and should rely on short circuiting in expressions, but the example you give is just bad programming. The logic of the expression should match the comment and the human-readable logic of the test. The optimizer fully understands boolean logic and will optimize away any apparent inefficiency that your teammate might complain about.\n\nThe most important thing is to make the code clear and understandable for the developer. Writing clever code to prove how clever you are is never a good practice.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does Oracle use short-circuit evaluation?\r\n                \r\nI have an Oracle query that is structured as followed:\n\n```\nSELECT   *\nFROM     table\nWHERE    X='true' OR\n         Y IN (complicated subquery)\n```\n\n\nIf Oracle sees that X does equal 'true' will it still try to evaluate the Y IN (subquery) part of the WHERE clause? Also, in a statement such as this would the subquery be executed multiple times for each entry in the table? Would I be better off with something like:\n\n```\nWITH subQ as (complicated subquery)\nSELECT   *\nFROM     table\nWHERE    X='true' OR\n         Y IN (SELECT id FROM subQ)\n```\n\n    ", "Answer": "\r\nIt depends.\n.\nIn general, Oracle does not guarantee that a SQL statement will use short-circuit evaluation (though PL/SQL is guaranteed to perform short-circuit evaluation).  The Oracle optimizer is free to evaluate the predicates in whatever order it expects to be most efficient.  That might mean that the first predicate is evaluated first and only the matching rows have the second predicate evaluated but it is entirely possible that either the reverse happens or that Oracle transforms the query into a sort of ```\nUNION```\n and fully evaluates both predicates before combining the results.\n\nThat being said, if the optimizer can determine at compile time that a predicate will always evaluate to ```\nTRUE```\n or ```\nFALSE```\n, the optimizer should just treat that as a constant.  So if, for example, there is a constraint on the table that prevents ```\nX```\n from ever having a value of 'true', the optimizer shouldn't evaluate the second predicate at all (though different versions of the optimizer will have different abilities to detect that something is a constant at compile time).\n\nAs for the second part of your question, without seeing the query plans, it's very hard to tell.  The Oracle optimizer tends to be pretty good at transforming queries from one form to another if there are more efficient ways of evaluating it.  In general, however, if ```\nsubQ```\n is going to return a relatively large number of rows compared to ```\ntable```\n, it may be more efficient to structure the query as an ```\nEXISTS```\n rather than as an ```\nIN```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short Circuit Evaluation in JavaScript?\r\n                \r\nI don't understand how the following code works. I know the difference between AND and OR but this code has confused me.\n\n```\n console.log(3 === 3 && 'cow' && console.log(34));\n```\n\n    ", "Answer": "\r\n```\nconsole.log(3 === 3 && 'cow' && console.log(34)); \n```\n\n\n```\n3 === 3```\n is ```\ntrue```\n, hence goes for the next statement\n\n```\nconsole.log( true && 'cow' && console.log(34));\n```\n\n\n```\n'cow'```\n is ```\ntrue```\n since it's a non empty string literal, hence the next statement\n\n```\nconsole.log( true && true && console.log(34));\n```\n\n\n```\nconsole.log(34)```\n executes function, prints ```\n34```\n, returns ```\nundefined```\n\n\n```\nconsole.log( true && true && undefined);\n```\n\n\nprints ```\nundefined```\n\n\nso finally in the console you'll have \n\n```\n34 \nundefined\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "list(), if and short-circuit evaluation\r\n                \r\nI have the following code snipplet:\n\n```\n$active_from = '31-12-2009';\nif(list($day, $month, $year) = explode('-', $active_from) \n    && !checkdate($month, $day, $year)) {\n    echo 'test';\n}\n```\n\n\nWhy do I get an undefined variable error?\n\n```\nlist($day, $month, $year) = explode('-', $active_from)```\n returns ```\ntrue```\n, so ```\nlist()```\n is evaluated, isn't it? I think, the variables should be defined? What do I oversee?\n\nThis does in my opinion the same and throws no error:\n\n```\n$active_from = '31-12-2009';\nlist($day, $month, $year) = explode('-', $active_from);\nif(checkdate($month, $day, $year)) {\n    echo 'test';\n}\n```\n\n\nThis raises no error:\n\n```\nif((list($day, $month, $year) = explode('-', $active_from)) && checkdate($month, $day, $year)) {\n```\n\n\nBut I really don't understand why :-)\n\nThanks for explanation\n    ", "Answer": "\r\nThis is an issue of operator precedence, in your case, the ```\n&&```\n evaluates before the ```\n=```\n, leading to the errors you describe.\n\nYou can resolve this problem by placing the assignment statement inside of a parentheses.\n\nExplicitly, your code should read\n\n```\nif(  (list($day, $month, $year) = explode('-', $active_from))\n     && !checkdate($month, $day, $year)) {\n```\n\n\nNote that I have changed it from ```\nif( $a=$b && $c )```\n to ```\nif( ($a=$b) && $c )```\n. The parentheses force the assignment operator (```\n=```\n) to evaluate before the conjunction (```\n&&```\n), which is what you want.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to split up complex conditions and keep short circuit evaluation?\r\n                \r\nSometimes conditions can become quite complex, so for readability I usually split them up and give each component a meaningful name. This defeats short-circuit evaluation however, which can pose a problem. I came up with a wrapper approach, but it is way too verbose in my opinion. \n\nCan anybody come up with a neat solution for this?\n\nSee code below for examples of what I mean:\n\n```\npublic class BooleanEvaluator {\n\n    // problem: complex boolean expression, hard to read\n    public static void main1(String[] args) {\n\n        if (args != null && args.length == 2 && !args[0].equals(args[1])) {\n            System.out.println(\"Args are ok\");\n        }\n    }\n\n    // solution: simplified by splitting up and using meaningful names\n    // problem: no short circuit evaluation\n    public static void main2(String[] args) {\n\n        boolean argsNotNull = args != null;\n        boolean argsLengthOk = args.length == 2;\n        boolean argsAreNotEqual = !args[0].equals(args[1]);\n\n        if (argsNotNull && argsLengthOk && argsAreNotEqual) {\n            System.out.println(\"Args are ok\");\n        }\n    }\n\n    // solution: wrappers to delay the evaluation \n    // problem: verbose\n    public static void main3(final String[] args) {\n\n        abstract class BooleanExpression {\n            abstract boolean eval();\n        }\n\n        BooleanExpression argsNotNull = new BooleanExpression() {\n            boolean eval() {\n                return args != null;\n            }\n        };\n\n        BooleanExpression argsLengthIsOk = new BooleanExpression() {\n            boolean eval() {\n                return args.length == 2;\n            }\n        };\n\n        BooleanExpression argsAreNotEqual = new BooleanExpression() {\n            boolean eval() {\n                return !args[0].equals(args[1]);\n            }\n        };\n\n        if (argsNotNull.eval() && argsLengthIsOk.eval() && argsAreNotEqual.eval()) {\n            System.out.println(\"Args are ok\");\n        }\n    }\n}\n```\n\n\nResponse to answers:\n\nThanks for all your ideas! The following alternatives were submitted so far:\n\n\nBreak lines and add comments\nLeave as is\nExtract methods\nEarly returns\nNested / Split up if's\n\n\nBreak lines and add comments:\n\nJust adding linebreaks within a condition gets undone by the code formatter in Eclipse (ctrl+shift+f). Inline comments helps with this, but leaves little space on each line and can result in ugly wrapping. In simple cases this might be enough however.\n\nLeave as is:\n\nThe example condition I gave is quite simplistic, so you might not need to address readability issues in this case. I was thinking of situations where the condition is much more complex, for example:\n\n```\nprivate boolean targetFound(String target, List<String> items,\n        int position, int min, int max) {\n\n    return ((position >= min && position < max && ((position % 2 == 0 && items\n            .get(position).equals(target)) || (position % 2 == 1)\n            && position > min && items.get(position - 1).equals(target)))\n            || (position < min && items.get(0).equals(target)) || (position >= max && items\n            .get(items.size() - 1).equals(target)));\n}\n```\n\n\nI would not recommend leaving this as it is.    \n\nExtract methods:\n\nI considered extracting methods, as was suggested in several answers. The disadvantage of that is that these methods typically have a very low granularity and may not be very meaningful by themselves, so it can clutter your class, for example:\n\n```\nprivate static boolean lengthOK(String[] args) {\n    return args.length == 2;\n}\n```\n\n\nThis would not really deserve to be a separate method at class level. Also you have to pass all the relevant arguments to each method. If you create a separate class purely for evaluating a very complex condition then this might be an ok solution IMO.\n\nWhat I tried to achieve with the BooleanExpression approach is that the logic remains local. Notice that even the declaration of BooleanExpression is local (I don't think I've ever come across a use-case for a local class declaration before!).\n\nEarly returns:\n\nThe early returns solution seems adequate, even though I don't favor the idiom. An alternative notation:\n\n```\npublic static boolean areArgsOk(String[] args) {\n\n    check_args: {\n        if (args == null) {\n            break check_args;\n        }\n        if (args.length != 2) {\n            break check_args;\n        }\n        if (args[0].equals(args[1])) {\n            break check_args;\n        }\n        return true;\n    }\n    return false;\n}\n```\n\n\nI realize most people hate labels and breaks, and this style might be too uncommon to be considered readable.\n\nNested/split up if's:\n\nIt allows the introduction of meaningful names in combination with optimized evaluation. A drawback is the complex tree of conditional statements that can ensue\n\nShowdown\n\nSo to see which approach I utlimately favor, I applied several of the suggested solutions to the complex targetFound example presented above. Here are my results:\n\nnested / split if's, with meaningful names\nvery verbose, meaningful names don't really help the readability here \n\n```\nprivate boolean targetFound1(String target, List<String> items,\n        int position, int min, int max) {\n\n    boolean result;\n    boolean inWindow = position >= min && position < max;\n    if (inWindow) {\n\n        boolean foundInEvenPosition = position % 2 == 0\n                && items.get(position).equals(target);\n        if (foundInEvenPosition) {\n            result = true;\n        } else {\n            boolean foundInOddPosition = (position % 2 == 1)\n                    && position > min\n                    && items.get(position - 1).equals(target);\n            result = foundInOddPosition;\n        }\n    } else {\n        boolean beforeWindow = position < min;\n        if (beforeWindow) {\n\n            boolean matchesFirstItem = items.get(0).equals(target);\n            result = matchesFirstItem;\n        } else {\n\n            boolean afterWindow = position >= max;\n            if (afterWindow) {\n\n                boolean matchesLastItem = items.get(items.size() - 1)\n                        .equals(target);\n                result = matchesLastItem;\n            } else {\n                result = false;\n            }\n        }\n    }\n    return result;\n}\n```\n\n\nnested / split if's, with comments\nless verbose, but still hard to read and easy to create bugs\n\n```\nprivate boolean targetFound2(String target, List<String> items,\n        int position, int min, int max) {\n\n    boolean result;\n    if ((position >= min && position < max)) { // in window\n\n        if ((position % 2 == 0 && items.get(position).equals(target))) {\n            // even position\n            result = true;\n        } else { // odd position\n            result = ((position % 2 == 1) && position > min && items.get(\n                    position - 1).equals(target));\n        }\n    } else if ((position < min)) { // before window\n        result = items.get(0).equals(target);\n    } else if ((position >= max)) { // after window\n        result = items.get(items.size() - 1).equals(target);\n    } else {\n        result = false;\n    }\n    return result;\n}\n```\n\n\nearly returns\neven more compact, but the conditional tree remains just as complex\n\n```\nprivate boolean targetFound3(String target, List<String> items,\n        int position, int min, int max) {\n\n    if ((position >= min && position < max)) { // in window\n\n        if ((position % 2 == 0 && items.get(position).equals(target))) {\n            return true; // even position\n        } else {\n            return (position % 2 == 1) && position > min && items.get(\n                    position - 1).equals(target); // odd position\n        }\n    } else if ((position < min)) { // before window\n        return items.get(0).equals(target);\n    } else if ((position >= max)) { // after window\n        return items.get(items.size() - 1).equals(target);\n    } else {\n        return false;\n    }\n}\n```\n\n\nextracted methods\nresults in nonsensical methods in your class\nthe parameter passing is annoying\n\n```\nprivate boolean targetFound4(String target, List<String> items,\n        int position, int min, int max) {\n\n    return (foundInWindow(target, items, position, min, max)\n            || foundBefore(target, items, position, min) || foundAfter(\n            target, items, position, max));\n}\n\nprivate boolean foundAfter(String target, List<String> items, int position,\n        int max) {\n    return (position >= max && items.get(items.size() - 1).equals(target));\n}\n\nprivate boolean foundBefore(String target, List<String> items,\n        int position, int min) {\n    return (position < min && items.get(0).equals(target));\n}\n\nprivate boolean foundInWindow(String target, List<String> items,\n        int position, int min, int max) {\n    return (position >= min && position < max && ((position % 2 == 0 && items\n            .get(position).equals(target)) || (position % 2 == 1)\n            && position > min && items.get(position - 1).equals(target)));\n}\n```\n\n\nBooleanExpression wrappers revisited\nnote that the method parameters must be declared final\nfor this complex case the verbosity is defendable IMO\nMaybe closures will make this easier, if they ever agree on that (-\n\n```\nprivate boolean targetFound5(final String target, final List<String> items,\n        final int position, final int min, final int max) {\n\n    abstract class BooleanExpression {\n        abstract boolean eval();\n    }\n\n    BooleanExpression foundInWindow = new BooleanExpression() {\n\n        boolean eval() {\n            return position >= min && position < max\n                    && (foundAtEvenPosition() || foundAtOddPosition());\n        }\n\n        private boolean foundAtEvenPosition() {\n            return position % 2 == 0 && items.get(position).equals(target);\n        }\n\n        private boolean foundAtOddPosition() {\n            return position % 2 == 1 && position > min\n                    && items.get(position - 1).equals(target);\n        }\n    };\n\n    BooleanExpression foundBefore = new BooleanExpression() {\n        boolean eval() {\n            return position < min && items.get(0).equals(target);\n        }\n    };\n\n    BooleanExpression foundAfter = new BooleanExpression() {\n        boolean eval() {\n            return position >= max\n                    && items.get(items.size() - 1).equals(target);\n        }\n    };\n\n    return foundInWindow.eval() || foundBefore.eval() || foundAfter.eval();\n}\n```\n\n\nI guess it really depends on the situation (as always). For very complex conditions the wrapper approach might be defendable, although it is uncommon. \n\nThanks for all your input!\n\nEDIT: afterthought. It might be even better to create a specific class for complex logic such as this:\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class IsTargetFoundExpression {\n\n    private final String target;\n    private final List<String> items;\n    private final int position;\n    private final int min;\n    private final int max;\n\n    public IsTargetFoundExpression(String target, List<String> items, int position, int min, int max) {\n        this.target = target;\n        this.items = new ArrayList(items);\n        this.position = position;\n        this.min = min;\n        this.max = max;\n    }\n\n    public boolean evaluate() {\n        return foundInWindow() || foundBefore() || foundAfter();\n    }\n\n    private boolean foundInWindow() {\n        return position >= min && position < max && (foundAtEvenPosition() || foundAtOddPosition());\n    }\n\n    private boolean foundAtEvenPosition() {\n        return position % 2 == 0 && items.get(position).equals(target);\n    }\n\n    private boolean foundAtOddPosition() {\n        return position % 2 == 1 && position > min && items.get(position - 1).equals(target);\n    }\n\n    private boolean foundBefore() {\n        return position < min && items.get(0).equals(target);\n    }\n\n    private boolean foundAfter() {\n        return position >= max && items.get(items.size() - 1).equals(target);\n    }\n}\n```\n\n\nThe logic is complex enough to warrant a separate class (and unit test, yay!). It will keep the code using this logic more readable and promotes reuse in case this logic is needed elsewhere. I think this is a nice class because it truely has a single responsibility and only final fields.\n    ", "Answer": "\r\nYou can use early returns (from a method) to achieve the same effect: \n\n[Some fixes applied]\n\n```\n  public static boolean areArgsOk(String[] args) {\n     if(args == null)\n        return false;\n\n     if(args.length != 2)\n        return false;\n\n     if(args[0].equals(args[1]))\n        return false;\n\n     return true;\n  }\n\n  public static void main2(String[] args) {\n\n        boolean b = areArgsOk(args);\n        if(b)\n           System.out.println(\"Args are ok\");\n  }\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is order of evaluation gauranteed with short circuit evaluation? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Logical AND, OR: Is left-to-right evaluation guaranteed?\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nIs the left part of the ```\n&&```\n always evaluated before the right part?\n\nI want to know because I'm wondering if I can change \n\n```\nif(i > 0)\n    if(someFunc(arr[i-1], arr[i]))\n        //do work\n```\n\n\nto\n\n```\nif(i > 0 && someFunc(arr[i-1], arr[i]))```\n\n\nor would this cause undefined behaviour if the right side gets evaluated first and ```\narr[0-1]```\nis referenced?\n    ", "Answer": "\r\nYes, because of short-circuit behavior of logical ```\n&&```\n operator, in case of ```\n&&```\n second expression evaluates only  when first is true. Read following:\n\n\n  6.5.13 Logical AND operator\n  \n  4 Unlike the bitwise binary ```\n&```\n operator, the ```\n&&```\n operator guarantees ```\nleft-to-right```\n evaluation;\n  there is a sequence point after the evaluation of the first operand. If the first operand\n  compares equal to 0, the second operand is not evaluated.\n\n\nFrom Is short-circuiting boolean operators mandated in C/C++? And evaluation order?\n\nSo  if ```\ni > 0```\n is false (for example if ```\ni = 0```\n) then result of ```\ni > 0```\n expression will be false, and then second operand  ```\nsomeFunc(arr[i-1], arr[i]```\n will not be called (evaluated).\n\nAccordingly,  ```\nif(i > 0 && someFunc(arr[i-1], arr[i]))```\n is safe to code, but be-careful ```\ni - 1```\n shouldn't be > max index value of ```\narr[]```\n. Really I will prefer this form of if compare to nested if blocks (flat is better then nested). \n\nFrom @Maroun Maroun's answer \"Is there any reason for asking ```\nif(1 || Foo())```\n?\" Additional information that might help you:\n\n\n  \n  ```\nif(a && b)```\n - if ```\na```\n is ```\nfalse```\n, ```\nb```\n won't be checked. \n  ```\nif(a && b)```\n - if ```\na```\n is ```\ntrue```\n, ```\nb```\n will be checked, because if it's ```\nfalse```\n, the expression will be ```\nfalse```\n.\n  ```\nif(a || b)```\n - if ```\na```\n is ```\ntrue```\n, ```\nb```\n won't be checked, because this is ```\ntrue```\n anyway.\n  ```\nif(a || b)```\n - if ```\na```\n is ```\nfalse```\n, ```\nb```\n will be checked, because if ```\nb```\n is ```\ntrue```\n then it'll be ```\ntrue```\n.\n  \n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Can you prevent short-circuit evaluation in Lua?\r\n                \r\nI am working on a script that allows user entry of Lua (specifically, boolean conditionals), and I am trying to provide a feature that will perform a quick error check for the script that is entered.\n\nIt's easy enough to throw an error if ```\nloadstring()```\n fails, so syntax issues are readily handled.\n\nHowever, if variables are improperly entered, it is harder to detect a problem.\n\nLet's say the user enters the following:\n\n```\nvalue.custom_value_1 == 1 and valse.custom_value_2 ~= 1\n```\n\n\nAs far as the syntax goes, ```\nloadstring()```\n is quite satisfied -- it adds 'return ' as a prefix to that string.\n\nMy next step is to check for errors when we execute what was entered by the user.  The problem is, when ```\nvalue.custom_value_1 ~= 1```\n, the logic will short-circuit since we're dealing with ```\nand```\n - there's no point in going further, we already have false on the left-hand side.\n\nWhat I would like is to find a way to cause Lua to completely evaluate the expression, rather than short-circuiting.  If it did so, the spelling error ```\nvalse```\n would be caught (regardless of ```\nvalue.custom_value_1```\n's value) and I can provide an error message to the end user.\n\nAny thoughts?\n\nMy current best idea is to filter through the user input, sorting out every value entered (basically, whatever's not an a conditional ```\nor```\n, ```\nand```\n, ...) and just doing it manually.  But I thought it's worth checking to see if there's a better way.\n    ", "Answer": "\r\nIf you don't mind parsing the string up-front you could use a library like https://github.com/stravant/LuaMinify/blob/master/ParseLua.lua to parse the source into an AST, modify the short-circuiting notes into function calls like\n\n```\nfunction my_and(x, y)\n    return x and y\nend\n```\n\n\nThen you compile this AST to check for the errors.\n\nSeems a lot hassle though just to catch trivial errors.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "|= operator, possible short circuit evaluation?\r\n                \r\nIn C++, If I have a boolean that is already true, and I perform an |= on it, it is guaranteed to still execute whatever is to the right of the operator?\n\nFor example:\n\n```\nbool myBool = true;\nmyBool |= someFcnThatReturnsBoolean();\n```\n\n\nI find that it is executing that function, but I need to know if it's explicitly guaranteed by a standard that it will be guaranteed to execute. I'd hate to run into an issue where it stops executing based on some optimization, or on certain compilers.\n    ", "Answer": "\r\n```\nbool myBool = true;\nmyBool |= someFcnThatReturnsBoolean();\n```\n\n\nwould be equivalent to\n\n```\nbool myBool = true;\nmyBool = myBool | someFcnThatReturnsBoolean();\n```\n\n\nThe bitwise OR (```\n|```\n) will always evaluate both operands, thus your function will always be called.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do all programming languages have boolean short-circuit evaluation?\r\n                \r\nIn the PHP code \n\n```\nif(a() && b())\n```\n\n\nwhen the first operand evaluates to ```\nfalse```\n, ```\nb()```\n will not be evaluated.\n\nSimilarly, in\n\n```\nif (a() || b())\n```\n\n\nwhen the first operand evaluates to ```\ntrue```\n, ```\nb()```\n will not be evaluated..\n\nIs this true for all languages, like Java, C#, etc?\n\nThis is the test code we used.\n\n```\n<?php\nfunction a(){\necho 'a';\nreturn false;\n}\n\nfunction b(){\necho 'b';\nreturn true;\n}\n\n\nif(a() && b()){\necho 'c';\n}\n?>\n```\n\n    ", "Answer": "\r\nThis is called short-circuit evaluation.\n\nIt is generally true for languages derived from C (C, C++, Java, C#) but not true for all languages.\n\nFor example, VB6 does not do this, nor was it done in early versions of VB.NET.  VB8 (in Visual studio 2005) introduced the AndAlso and OrElse operators for this purpose.\n\nAlso, from comments, it seems that csh performs short-circuit evaluation from right to left, to make matters even more confusing.\n\nIt should also be pointed out that short-circuit evaluation (or lack of) has its dangers to be aware of.  For example, if the second operand is a function that has any side effects, then the code may not perform exactly as the programmer intended.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What is short-circuit evaluation in C?\r\n                \r\nI'm studying C from A Book on C by Kelley-Pohl, and there's this exercise that I don't understand:\n```\nint a = 0, b = 0, x;\n\nx = 0 && (a = b = 777);\nprintf(\"%d %d %d\\n\", a, b, x);\nx = 777 || (a = ++b);\nprintf(\"%d %d %d\\n\", a, b, x);\n```\n\nThey just say to imagine the output and compare it to the real one. I thought the output would have been\n\n777 777 0\n778 778 1\n\nbut it is\n\n0 0 0\n0 0 1\n\n    ", "Answer": "\r\nFrom the C Standard (6.5.13 Logical AND operator)\n\n\n  3 The && operator shall yield 1 if both of its operands compare\n  unequal to 0; otherwise, it yields 0. The result has type int.\n\n\nand\n\n\n  4 Unlike the bitwise binary & operator, the && operator guarantees\n  left-to-right evaluation; if the second operand is evaluated, there is\n  a sequence point between the evaluations of the first and second\n  operands. If the first operand compares equal to 0, the second\n  operand is not evaluated.\n\n\nIn this expression statement\n\n```\nx = 0 && (a = b = 777);\n```\n\n\nthe first operand compares equal to 0. So the second operand is not evaluated that is the values of the variables ```\na```\n and ```\nb```\n are not changed. So the variable ```\nx```\n will be set to ```\n0```\n according to the paragraph #3 of the section.\n\nFrom the C Standard (6.5.14 Logical OR operator)\n\n\n  3 The || operator shall yield 1 if either of its operands compare\n  unequal to 0; otherwise, it yields 0. The result has type int.\n\n\nand\n\n\n  4 Unlike the bitwise | operator, the || operator guarantees\n  left-to-right evaluation; if the second operand is evaluated, there is\n  a sequence point between the evaluations of the first and second\n  operands. If the first operand compares unequal to 0, the second\n  operand is not evaluated.\n\n\nIn this expression statement \n\n```\nx = 777 || (a = ++b);\n```\n\n\nthe first operand compares unequal to 0. So the second operand is not evaluated that is the values of the variables ```\na```\n and ```\nb```\n are not changed.. So the variable ```\nx```\n will be set to ```\n1```\n according to the paragraph #3 of the section.\n\nIf you will change the order of the operands in the expressions like\n\n```\nx = (a = b = 777) && 0;\nx = (a = ++b) || 777;\n```\n\n\nyou get the expected by you result.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Object destructuring with Short-Circuit Evaluation\r\n                \r\nIs it possible to do achieve something like this?\n\n```\nconst obj1 = { name: 'tom' }\nconst obj2 = { age: 20 }\n\nlet { name, age } = obj1 || obj2\n```\n\n\nGetting as a result -> name = 'tom' and age=20\n\nThe code above doesn't work, as it evaluates the condition one time and not on each variable assignment, which of course makes sense. It evaluates to name='tom', age=undefined\n\nIs there any way to make that logic work?\n\nThanks!\n    ", "Answer": "\r\nYou can merge the objects and then try to destructure like:\n\n\r\n\r\n```\nconst obj1 = { name: 'tom' }\r\nconst obj2 = { age: 20 }\r\n\r\nlet { name, age } = {...obj1, ...obj2}; \r\nconsole.log( name, age )```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Stream of boolean values, is any true?\r\n                \r\nI want to parallelize the following code snipped using a parallelStream:\n\n```\nboolean anyTrue() {\n  for (Element e : setOfE) {\n    if (eval(e)) {\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n\nWill the following work on parallel streams and use regular short-circuit evaluation?\n\n```\nsetOfE.parallelStream().map(e -> eval(e)).reduce(false, (a,b) -> a || b))\n```\n\n    ", "Answer": "\r\nStreams API actually has first-class support for your requirement:\n```\nsetOfE.parallelStream().anyMatch(e -> eval(e));\n```\n\nAs opposed to your approach with ```\nreduce```\n, this is guaranteed to have short-circuit evaluation and optimally leverage parallelism.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Using \"?:\" to emulate short-circuit evaluation\r\n                \r\nHow would one be able to emulate ```\nfoo() || bar()```\n and ```\nfoo() && bar()```\n using short-circuiting and the ```\n?:```\n operator? \n\nI'm a student and have never used the ```\n?:```\n operator and would like to try. After doing some Googling I've found out that it's essentially: \n\n```\nCondition ? (things to do if true) : (things to do if false);```\n \n\nWould this be possible to achieve without using ```\n&&```\n and ```\n||```\n? I'm trying to get a grip on short-circuiting, as I'm very new to it and finals are coming up! \n    ", "Answer": "\r\nAssuming ```\nfoo()```\n and ```\nbar()```\n both return ```\nboolean```\n, then\n\n```\nfoo() || bar()\n```\n\n\nis the same as\n\n```\nfoo() ? true : bar();\n```\n\n\nbecause ```\nfoo()```\n is evaluated first, and ```\nbar()```\n only needs to be evaluated if ```\nfoo()```\n is false.\n\nLikewise,\n\n```\nfoo() && bar()\n```\n\n\nis the same as\n\n```\nfoo() ? bar() : false;\n```\n\n\n```\nfoo()```\n is evaluated first, and ```\nbar()```\n only needs to be evaluated if ```\nfoo()```\n is true.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "short-circuit evaluation with three variables\r\n                \r\nI wrote the following code, thinking it would fail to work because it would go like this: \"if it is not running and the ID matches this one, execute the code\" disregarding the cap on the break size:\n\n```\nif(!isRunning && id===\"break-increment\" && breakvar<=59){\nthis.setState((state) => ({\n  break: this.state.break +1}))}\n```\n\n\nMuch to my surprise, it worked. But I don´t really understand why. Wouldn´t it fail because the cap size would never be evaluated?\n    ", "Answer": "\r\n\n  I thought you couldn´t have three conditions without short-circuiting (eg, if isRunning is false then it only evaluates id) \n\n\nNo.\n\nIf ```\n!isRunning```\n is false, the first ```\n&&```\n short circuits and is evaluated as its LHS (false) without evaluating the RHS.\n\nIf ```\n!isRunning```\n is true, the first ```\n&&```\n doesn't short circuit and is evaluated as its RHS (```\nid===\"break-increment\" && breakvar<=59```\n)\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "type error and short-circuit evaluation?\r\n                \r\nTS Code\n\n```\nimage = this.selectedItem.image.url || null;\n```\n\n\nThe Error\n\n```\nTypeError: Cannot read property 'url' of null\n```\n\n\nMy question is, why isn't the || null kicking in instead of it throwing a type error? \n    ", "Answer": "\r\nThe shortest option you have is:\n\n```\nimage = this.selectedItem && this.selectedItem.image && this.selectedItem.image.url || null;\n```\n\n\nIf any of the ```\n&&```\n fails, you'll get ```\nnull```\n instead, but you have to check every \"level\" of the object you're trying to access.\n\nThis works because the ```\n&&```\n takes priority over ```\n||```\n for order of operation. The above statement is similar to:\n\n```\nx = (((a.b) && (a.b.c)) && (a.b.c.url)) || null;\n```\n\n\nWhat you had, on the other hand, was similar to:\n\n```\nx = (a.b.c.url) || null;\n```\n\n\nYou can't get ```\nurl```\n if ```\na.b```\n does not have a property ```\nc```\n. That's what the error was thrown on, and that's not something the \"or\" at the end can catch.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Find's cost-based optimiser breaks short-circuit evaluation\r\n                \r\nQuoting the man page of find (GNU findutils 4.7.0, emphasis mine): \n\n\n  GNU find searches the directory tree rooted at each given starting-point by evaluating the given expression from left to right, according to the rules of precedence (see section PERATORS), until the outcome is known (the left hand side is false for and operations, true for or), at which point find moves on to the next file name.\n\n\nTherefore when ```\nfind```\n evaluates ```\n<expr1> -and <expr2>```\n I would expect that ```\n<expr2>```\n is not evaluated unless ```\n<expr1>```\n is true and I rely on that to avoid some error messages, specifically, I do not want ```\nfind```\n to test whether a non readable directory is empty. Here is a SCCCE:\n\n```\nmkdir some_dir\nchmod 333 some_dir\nfind * -readable ! -empty -printf \"yes\" -or -printf \"no\" -prune  \n```\n\n\nwhich yields\n\n```\nfind: ‘some_dir’: Permission denied\nno\n```\n\n\nAdding, otherwise implicit, ```\n-and```\n and parentheses, the expression evaluated by ```\nfind```\n should be equivalent to\n\n```\n( ( -readable -and (! -empty ) ) -and -printf \"yes\" ) -or ( -printf \"no\" -and -prune )\n```\n\n\nHence, after realising that ```\nsome_directory```\n is not readable, ```\nfind```\n should forgo the emptiness test and the evaluation of ```\n-printf \"yes\"```\n. Instead, it should jump to the evaluation of ```\n-printf \"no\"```\n and finally ```\n-prune```\n. The \"Permission denied\" in the output suggests it's evaluating ```\n-empty```\n anyway. (Removing ```\n! -empty```\n from the original expression makes the error go away.)\n\nUsing ```\n-D tree```\n to inspect the evaluation tree, I see that the optimised form (edited here for the sake of brevity and clarity) is:\n\n```\n(  (  ( ! -empty ) -and -readable ) -and -printf \"yes\" ) -or ( -printf \"no\" -and -prune ) \n```\n\n\naccording to which ```\n-empty```\n is indeed evaluated and, worse, prior to ```\n-readable```\n which completely screws up the intended logic. I reckon this is a bug. Am I right?\n\nUpdate: (26-May-2020) A bug report has been submitted and it has been confirmed as a bug by the developers.\n    ", "Answer": "\r\nIn my opinion, this is a bug in findutils' \"arm-swapping\" optimization, because it fails to consider that ```\n-empty```\n and ```\n-xtype```\n may have the side effect of causing ```\nfind```\n to report an error and exit with a non-zero status.  I've reported the same issue about ```\n-xtype```\n, which the findutils devs agreed was a bug.  It's hard to work around this bug too, because findutils doesn't have a way to turn off this optimization.  ```\n-O0```\n is equivalent to ```\n-O1```\n which already applies it.\n\nIf you need a workaround, I wrote a drop-in replacement for ```\nfind```\n called ```\nbfs```\n: https://github.com/tavianator/bfs.  It's fully compatible with all of GNU find's options, and doesn't have this bug.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit evaluation causing an invalid assignment location error\r\n                \r\nThe docs for Julia indicate that a valid short-cut to writing out an ```\nif```\n statement is the syntax\n\n```\n<cond> && <statement>\n```\n\n\nI've used this a lot for error messages, e.g. ```\nlength(x) < N && error(\"x is too short\")```\n, and it works as expected. However, the following does not work:\n\n```\nx = 3\nx < 4 && x = 5\n```\n\n\nI get an error of the form ```\nsyntax: invalid assignment location```\n. What is going on here? \n\nWhat I'm trying to do is check if ```\nx```\n is less than ```\n4```\n, and if it is, then set ```\nx```\n to ```\n5```\n. Should I do the following?\n\n```\nif x < 4\n     x = 5\nend\n```\n\n\nIs there a valid short-circuit method for this situation?\n    ", "Answer": "\r\nYour error is caused because the ```\n&&```\n operator has higher precedence than the assignment operator ```\n=```\n so your line of code is executed as if you would write ```\n(x < 4 && x) = 5```\n.\n\nFor a solution you have to add parantheses.\n\n```\nx < 4 && (x = 5)\n```\n\n\nSee my code running in the browser\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Implementions of algorithms for evaluating circuits\r\n                \r\nConsider the problem of circuit evaluation, where the input is a boolean circuit C and an input string x and you want to compute C(x). (Assume fan-in 2 if you like.)\n\nThis is a 'trivial' problem algorithmically, however it appears non-trivial to implement when C can be huge (think several million gates) and memory management becomes an issue. \n\nThere are several ways this problem can be approached, trading off memory, time, and disc access. But before going through all this work myself, does anyone know of any existing implementations of algorithms for this problem? It would be surprising to me if none exist...\n    ", "Answer": "\r\nFor C/C++, the standard digital circuit design & simulation system for more than 10 years now is SystemC.\n\nIt is a library that allows you to design digital logic in C++. There are supporting software that allows you to do timing analysis and even generate schematic netlist for C code. \n\nI've only played with it a little before deciding that I was more comfortable with Verilog. But it is a mature piece of software with lots of industry support. Googling around will yield a lot of information including several tutorial pages.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does Verilog support short circuit evaluation?\r\n                \r\nIf I have an if statement like:\n\n```\nif(risingEdge && cnt == 3'b111)\nbegin\n  ...\nend\n```\n\n\nWill it check on cnt if risingEdge is not true?\n\nDoes this even matter inside of an HDL?\n    ", "Answer": "\r\nFor simulation it is undefined as to whether short-circuited expressions are evaluated or not. In the above example it makes no difference, but if you have a function call on the right hand side then you may run into problems with undefined side effects.\n\nSee Gotcha #52 in \"Verilog and SystemVerilog Gotchas: 101 Common Coding Errors and How to Avoid Them\" by Stuart Sutherland and Don Mills.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Linq to object Multiple Where short circuit evaluation\r\n                \r\nWhen including multiple Where clauses in a Linq to object expression, will they  evaluates short-circuiting like the && operator? Meaning will condition B only be evaluated if condition A return true\n\nFor example ```\ncollection.Where(condition1).Where(condition2)```\n\n\n(Not talking about Linq to sql that will not do that even with the && operator short-circuiting-in-linq-where)\n    ", "Answer": "\r\nLet's take a look at some more code. We'll test both scenarios:\n\n\nFirst we will test for && by using two if statements\nWe'll use two Where calls\n\n\nSo:\n\n```\nvar elements = new List<string>(new[] { \"A\", \"B\", \"C\" });\n\nConsole.WriteLine(\"C#'s &&\");\n\nelements.Where(x => {\n    if (x == \"A\")\n    {\n        Console.WriteLine(\"ConditionA is true\");\n        if (1 == 1)\n        {\n            Console.WriteLine(\"ConditionB is true\");\n            return true;\n        }\n\n        Console.WriteLine(\"ConditionB is false\");\n    }\n\n    Console.WriteLine(\"ConditionA is false\");\n\n    return false;           \n}).ToList();\n\nConsole.WriteLine();\nConsole.WriteLine(\"Double Linq.Where\");\n\nelements.Where(x => {\n    if (x == \"A\")\n    {\n        Console.WriteLine(\"ConditionA is true\");\n        return true;\n    }\n\n    Console.WriteLine(\"ConditionA is false\");\n    return false;           \n})\n    .Where(x => {\n        if (1 == 1)\n        {\n            Console.WriteLine(\"ConditionB is true\");\n            return true;\n        }\n\n        Console.WriteLine(\"ConditionB is false\");\n        return false;\n    }).ToList();\n```\n\n\nHere are the results:\n\n```\nC#'s &&\nConditionA is true\nConditionB is true\nConditionA is false\nConditionA is false\n\nDouble Linq.Where\nConditionA is true\nConditionB is true\nConditionA is false\nConditionA is false\n```\n\n\nAs you can see, it's the same. Elements that don't pass ConditionA aren't tested for ConditionB.\nYou can try this out here: https://dotnetfiddle.net/vals2r\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "PHP && Short-circuit Evaluation Operator\r\n                \r\nIn JavaScript, I can do:\n\n```\nconsole.log( 'a' || 'b' ); // Prints 'a'\n```\n\n\nIn PHP, the equivalent is:\n\n```\necho 'a' ?: 'b'; // Prints 'a'\n```\n\n\nIn JavaScript:\n\n```\nconsole.log( 'a' && 'b' ); // Prints 'b'\n```\n\n\nMy question is, what is the PHP equivalent of JavaScript's 'a' && 'b'?\n\nIf I do the following in PHP:\n\n```\necho 'a' && 'b'; // Prints 1\n```\n\n\nAs you can see, it type casts to boolean 1 (true).\n\nWhat is the PHP operator that will get me the actual values, like JavaScript's &&?\n\nP.S. I know about ternary statements, please don't suggest that.\n    ", "Answer": "\r\n```\n&&```\n is a logical operator, and it evaluates to ```\ntrue | false```\n. There is a slightly different operator in PHP named null coalesce operator. It is denoted ```\n??```\n. It evaluates whether the first operand is ```\nnull```\n. If it is ```\nnull```\n, the result is the second operand of the statement.\n\n```\n$variable = 'String';\nreturn $variable ?? 'default'; // results in 'String'\n\n$variable = null;\nreturn $variable ?? 'default'; // results in 'default'\n```\n\n\nMore on the operator: https://wiki.php.net/rfc/isset_ternary\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "is there any plausible scenario in which a programmer might wish to avoid shortcircuit evaluation of a Boolean expression? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nshort circuit evaluation can shorten the compile time, so i learned that C, C++ is using that way. But are there any situations that short-circuit evaluation ruining the code?\n    ", "Answer": "\r\nShort circuiting does not shorten the compile time of the code. (by any meaningful amounts, at least) \n\nIt might be shortening the runtime, but it's not its intended purpose.\n\nThe purpose of short circuiting is to do the minimal amount of work in order to check a certain condition.\n\nFor example:\n\nWhen using ```\n&&```\n (as opposed to a single ```\n&```\n), the right operand won't be evaluated if the left one is false. This is due to the nature of a ```\nlogical and```\n operation: if at least one of the operands is false, the whole expression is false.\n\nTechnically, it will shorten the runtime if the condition fails early, but the amount of saved runtime is dependent on the expressions inside each operand.\n\nAnyway, it's incorrect to use ```\n&&```\n because it's \"faster\" than ```\n&```\n. You should use either when appropriate.\n\n```\n&```\n is used for bitwise operations.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Code generation for short-circuit Boolean operators\r\n                \r\nWhat would be an example of a ```\nboolean expression```\n in which the outcome would be different if short-circuit\nevaluation is used than if the boolean expressions are fully evaluated. Then I was wonder how would I sketch it out in terms of the three address\nintermediate code for the short-circuit evaluation of your boolean expression?\n    ", "Answer": "\r\nThe most common use of short-circuiting booleans is to ensure that undefined computations are not performed. In other words, it is not so much that the value of the expression differs with short-circuiting as that the value of the expression is well-defined.\n\nFor example, consider a common C idiom:\n\n```\nif ( ptr != NULL && *ptr == some_value ) { /* Do something */ }\n```\n\n\nIn this case, the short-circuiting ```\n&&```\n ensures that the pointer will not be dereferenced if it happens to be ```\nNULL```\n. With full evaluation, the computation would presumably do something really undesirable (like segfault) if the first condition were false.\n\nSince the point of the short-circuiting evaluation is to conditionally not evaluate a part of the expression, the TAC implementation needs to include a conditional branch statement after the evaluation of the left-hand expression. In other words, the above statement would be compiled in a very similar manner to the equivalent:\n\n```\nif ( ptr != NULL ) {\n  if ( *ptr == some_value ) {\n    /* Do something */\n  }\n}\n```\n\n\nwhich would presumably be implemented with two conditional jumps.\n\nI'm not sure what this has to do with semantic analysis or type checking.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is short-circuiting logical operators mandated? And evaluation order?\r\n                \r\nDoes the ANSI standard mandate the logical operators to be short-circuited, in either C or C++?\n\nI'm confused for I recall the K&R book saying your code shouldn't depend on these operations being short circuited, for they may not. Could someone please point out where in the standard it's said logic ops are always short-circuited? I'm mostly interested on C++, an answer also for C would be great.\n\nI also remember reading (can't remember where) that evaluation order isn't strictly defined, so your code shouldn't depend or assume functions within an expression would be executed in a specific order: by the end of a statement all referenced functions will have been called, but the compiler has freedom in selecting the most efficient order.\n\nDoes the standard indicate the evaluation order of this expression?\n\n```\nif( functionA() && functionB() && functionC() ) cout<<\"Hello world\";\n```\n\n    ", "Answer": "\r\nYes, short-circuiting and evaluation order are required for operators ```\n||```\n and ```\n&&```\n in both C and C++ standards.\n\nC++ standard says (there should be an equivalent clause in the C standard):\n\n\n  1.9.18\n  \n  In the evaluation of the following expressions\n\n```\na && b\na || b\na ? b : c\na , b\n```\n\n  \n  using the built-in meaning of the operators in these expressions, there is a sequence point after the evaluation of the first expression (12).\n\n\nIn C++ there is an extra trap: short-circuiting does NOT apply to types that overload operators ```\n||```\n and ```\n&&```\n.\n\n\n  Footnote 12: The operators indicated in this paragraph are the built-in operators, as described in clause 5. When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation, and the operands form an argument list, without an implied sequence point between them.\n\n\nIt is usually not recommended to overload these operators in C++ unless you have a very specific requirement. You can do it, but it may break expected behaviour in other people's code, especially if these operators are used indirectly via instantiating templates with the type overloading these operators.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to refactor a short circuit evaluation [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am from c++ background and I am confused with one of the statement like this\n\n```\n   if TUtils.CheckValue(objData, LChan) and\n         (LChan.Int.Value = (aObject as TomDBChan).Int.Value) then\n   begin\n          //Operation\n   end;\n```\n\n\nis it ok to convert this to\n\n```\n         LChan.Int.Value = (aObject as TomDBChan).Int.Value ;\n          if TUtils.CheckValue(objData, LChan) then\n          begin\n            //Operation\n          end;\n```\n\n\nor should i also check whether LChan.Int.Value has some value in it?\n    ", "Answer": "\r\nIf your goal is to prevent any short-circuit evaluation, just make sure the constituent parts of the expression are calculated separately:\n\n```\nb1 := TUtils.CheckValue(objData, LChan);\nb2 := (LChan.Int.Value = (aObject as TomDBChan).Int.Value);\n\nif b1 and b2 then\nbegin\n   //Operation\nend;\n```\n\n\nThis ensures that any side effects in CheckValue() or the .Value methods will be  executed.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does C use short circuit evaluation even when arguments are function calls?\r\n                \r\nI know that logical operators do short-circuit checking.  That is, if there is a statement like ```\nA && B && C```\n, then if ```\nA```\n is false, ```\nB```\n and ```\nC```\n are not evaluated.  But is this also true in cases where ```\nB```\n and ```\nC```\n are function calls?\n\nFor example, the return statement in this code:\n\n```\nbool areIdentical(struct node * root1, struct node *root2)\n{\n    /* base cases */\n    if(root1 == NULL && root2 == NULL)\n        return true;\n\n    if(root1 == NULL || root2 == NULL)\n        return false;\n\n    /* Check if the data of both roots is same and data of left and right\n       subtrees are also same */\n    return (root1->data == root2->data   &&               //I am talking about this statement\n            areIdentical(root1->left, root2->left) &&\n            areIdentical(root1->right, root2->right) );  \n}\n```\n\n    ", "Answer": "\r\nYes, the functions are not called if ```\nroot1->data == root2->data```\n is ```\nfalse```\n.\n\nSimple check is to do this:\n\n```\n#include <unistd.h>\n#include <stdlib.h>\n\nint main(void)\n{\n  write(1, \"z\", 1);\n  if ((1 == 0) && write(1, \"a\", 1) && write(1, \"b\", 1))\n  {\n    write(1, \"c\", 1);\n  }\n  write(1, \"d\", 1);\n  return (EXIT_SUCCESS);\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Unassigned local variable and short-circuit evaluation\r\n                \r\nI have two methods, both of them compiles correctly:\n\n```\npublic int A()\n{\n    int i;\n    if(!int.TryParse(\"0\", out i))\n    {\n        return -1;\n    }\n    // do sth\n    return i;\n}\n\npublic int B()\n{\n    int i;\n    if(true)\n    {\n        return -1;\n    }\n    return i;\n}\n```\n\n\nIn the second case (method ```\nB```\n) compiler is smart enough to detect that variable ```\ni```\n is never used so it doesn't complain about not assigning it.\n\nHowever, I have another example (a combination of both) that seems to be equivalent to method ```\nB```\n:\n\n```\npublic int C()\n{\n    int i;\n    if (true || !int.TryParse(\"0\", out i))\n    {\n        return -1;\n    }\n    return i;\n}\n```\n\n\nWhen compiling on Windows under VisualStudio 2012 (.NET Framework 4.6.01055) it throws an error: ```\nUse of unassigned local variable 'i'```\n. The solution is to:\n\n\ninitialize ```\ni```\n with any value, or\nuse ```\n|```\n operator instead of ```\n||```\n.\n\n\nWhy is that so? It looks like a compiler has all the necessary data to detect unreachable code.\n\nSide note: Example ```\nC```\n compiles on Linux under mono 4.6.2 with warnings about unreachable code as expected.\n    ", "Answer": "\r\nThis can't be considered a bug but its an improvable feature. You are correct when you say that the compiler has enough information to know that the unassigned ```\ni```\n is never used and therefore it should omit the compiler error.\n\nIts improvable because, as a matter of fact, it has been improved; in VS 2015 the behavior of the compiler is the expected one : no compile time error. I can't say the same thing for previous versions of the compiler because I can't test them at the moment.\n\nFunnily enough, neither VS 2015 or VS 2017 RC report an unreachable code warning at ```\nreturn i```\n which seems a bit odd. ```\nif (true)```\n will give this warning and ```\nif (true || ....)```\n figures out correctly that ```\ni```\n is not used, but the warning has been omitted for reasons I dont understand.\n\nFor more insight on why the behavior was changed, check out this answer. I knew this question rung a bell...I asked a similar one a couple years ago myself ;).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Evaluation order of logical ANDs and ORs\r\n                \r\nI've got two expressions in the debugger watch (at the same time):\n\n```\nitem.isSelected() === true```\n: ```\nfalse```\n\n\nAnd at the same time:\n\n```\n(item.isSelected() === true) && !(item.workflowStatusCode.toUpperCase() === \"INRV\") && (item.productStatusCode.toUpperCase() !== \"ACTV\") || (item.workflowStatusCode.toUpperCase() === \"INPR\")```\n: ```\ntrue```\n\n\nWhy the second one evaluates to true when first is false?\n\nADDITION:\n\nFrom here\n\n\n  Short-circuit evaluation\n  \n  As logical expressions are evaluated left to right, they are tested\n  for possible \"short-circuit\" evaluation using the following rules:\n  \n  false && anything is short-circuit evaluated to false.\n\n\n... it kinda implies that once first expression is evaluated to ```\nfalse```\n the rest should have been skipped... I am still not clear what the rules are behind all this.\n    ", "Answer": "\r\n```\n||```\n has lower precedence than ```\n&&```\n, so it's almost certainly the case that this is ```\ntrue```\n:\n\n```\n(item.workflowStatusCode.toUpperCase() === \"INPR\")\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit evaluation and assignment in C++\r\n                \r\nIs something like this possible in C++:\n\n```\nif (int* x = (foo() || bar()))\n{\n    // do something with x\n}\nelse\n{\n    // do something else if both foo() and bar() return nullptr\n}\n```\n\n\nI know the code will not compile (cannot convert bool to int*), but is there a valid equivalent \"shortcut\" code to be able to do this kind of shortcut? Basically, what I want is to assign to x the return value of foo() if foo() does not return a null pointer. If foo() yields a null pointer, then assign the return value of bar() to x.\n\nAssume that foo() and bar() are expensive calculations, so need to minimize the number of calls to them. If foo() does not yield a null pointer, then ideally, there should be no need to call bar().\n    ", "Answer": "\r\nWith a new C++17 feature, the following should be possible:\n\n```\nif(int* x = foo(); x = x ? x : bar())\n```\n\n\nPre-C++17 will require you to declare the x outside (below improving above by avoiding self-assignment; thanks, N00byEdge):\n\n```\nint* x;\nif(x = foo(), x ? x : (x = bar()))\n```\n\n\nBut then, probably moving the assignment outside is yet nicer:\n\n```\nint* x = foo();\nif(x ? x : (x = bar()))\n```\n\n\nIn all above cases, the compiler might warn you that you might have mixed up assignment with comparison (```\n=```\n instead of ```\n==```\n); to make the compiler aware that assignment is intended, you can place additional parentheses around the assignments...\n\nEdit: Nice solution, posted by freestyle, unfortunately only as comment (here, parentheses are required as assignment has lower precedence than logical or):\n\n```\nint* x;\nif((x = foo()) || (x = bar()))\n```\n\n\nWhich could look, assuming C++17, like this:\n\n```\nif(int* x; (x = foo()) || (x = bar()))\n```\n\n\nor refining my own answer based on:\n\n```\nif(int* x = foo(); x || (x = bar()))\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to create a short circuit evaluation in bison using mid-rules action?\r\n                \r\nI was assigned to write a calculator that, among some other things, also supports variables definition and assignments, boolean expressions and decrement/increment operations.\nMy calculator should also support the conditional (ternary) operation ```\n? :```\n, the same kind some programming languages support, which used as follows:\n\n```\ncondition ? value_if_true : value_if_false ;\n```\n\n\nOr as it defined in my grammar rules:\n\n```\nbool_expression ? int_expression : int_expression ;\n```\n\n\nThe problem is, it has to be a short circuit evaluation, meaning that if bool_expression evaluates to true, only the first int_expression should be evaluated, and otherwise, if bool_expression evaluates to false, then only the second int_expression should be evaluated.  \n\nI was told to use bison's Action in mid-rule functionality, but I fail to see how could that be of help.\n\nI also looked around online and found this to be the closest thing to what I'm trying to accomplish, but unfortunately, the answer there is not quite what I'm looking for. The answer there indeed describes what should be done, but does not state specifically how to do it (global flag is out of the question, you'll understand why when you'll see the code).\n\nHere's a very small part from what I have so far:\n\n```\n%{\n    #include<stdio.h>\n    #include<iostream>\n    #include <string>\n    #include <map>\n\n    using namespace std;\n\n    map<string, int> symbolTable;\n\n    int yylex();\n    void yyerror(const char*);\n\n%}\n\n%union{\n    int     int_val;\n    char*   string_val;\n    bool b;\n}\n\n\n%token <int_val> T_NUMBER\n%token <string_val> T_VAR\n%type  <int_val> expr\n%type  <b>bool_expression\n%nonassoc ':'\n%nonassoc T_EQUALS\n%left '+' '-'\n%left '*' '/'\n%left UMINUS\n%left '$' '~'\n\n\n\n%%\n\ncommands:   \n        /* eps rule */      {cout<<\"create commands\"<<endl;}\n        | commands command  {cout<<\"add command\"<<endl;};\n\n\ncommand:    expr '\\n'       {cout<<\"Expression value: \"<<$1<<endl;}\n    |   T_VAR '=' expr '\\n' {cout<<\"Assignment: \"<<$1<<\"=\"<<$3<<endl; symbolTable[$1] = $3;}\n    |   bool_expression '\\n'    {$1 ? cout<<\"true\"<<endl : cout<<\"false\"<<endl;}\n    ;\n\nexpr:\n        T_NUMBER        {$$ = $1;}\n    |   T_VAR           {$$ = symbolTable[$1];}\n    |   expr '+' expr       {$$ = $1 + $3;}\n    |   expr '-' expr       {$$ = $1 - $3;}\n    |   expr '*' expr       {$$ = $1 * $3;}\n    |   expr '/' expr       {if ($3 == 0) {yyerror (\"Division by zero!\"); return 1;} $$ = $1 / $3;}\n    |   '$' T_VAR       {$$ = ++symbolTable[$2]; }\n    |   '~' T_VAR       {$$ = --symbolTable[$2]; }\n    |   '-' expr %prec UMINUS   {$$=-$2;}\n    |   bool_expression '?'     {/* this is a mid-rule; what should go here... */}\n        expr ':' expr       {/* in order to evaluates only one of these two, depending on bool_expression */}\n    ;\n\nbool_expression:  expr T_EQUALS expr        {$$=($1==$3);}\n\n%%  \n\nvoid yyerror(const char* errorInfo){\n    cout<<errorInfo<<endl;\n}\n\nint main(){\n    yyparse();\n}\n```\n\n\nthe '$' operator you see there has the same meaning as the operator ++ in C, and the '~' operator has the same meaning as --.\n\nBack to my problem: the above is only the relevant code, I have a lot more rules I've omitted for the sake of readability. This also means that using some global flag is not my best choice here, since it will require its inspection in every rule in my file.\nNow, consider the input: \n\na=5\n1==1 ? $a : $a \n\nAnd the naive approach of defining the above rule as: \n\n```\n|   bool_expression '?' expr ':' expr {$1 ? $$=$3 : $$=$5 ;}\n```\n\n\nthis code results in 'a' having the value 7 instead of 6.\nSo how can 'action in mid-rule' be used here to prevent the first expr to ever be shifted/reduced if bool_expression is false, and prevent the second expr to be shifted/reduced if bool_expression is true?\n    ", "Answer": "\r\nYou need a global flag ```\neval```\n which is set (true) while parsing code that should be evaluated.  While it is false, the parser should just skip over things and not actually evaluate anything.  So your rule for assignment becomes:\n\n```\ncommand: T_VAR '=' expr '\\n' {\n    if (eval) {\n        cout << \"Assignment: \" << $1 << \"=\" << $3 << endl;\n        symbolTable[$1] = $3; } }\n```\n\n\nSimilarly for all other rules that might have side effects (for those that have no side effects, you can run unconditionally and generate a value that will be ignored, or you can similarly guard it.)\n\nThen, your conditional rule becomes:\n\n```\nexpr: expr { if ($$ = eval) eval = $1; } '?'\n      expr { if ($2) eval = !eval; } ':'\n      expr { if (eval = $2) $$ = $1 ? $4 : $7; }\n```\n\n\nThis saves the ```\neval```\n flag in the result of the first inline action, restores it in the final action and, if it was set, sets it for the expression that should be evaluated and not for the other.\n\nOne big problem with this is that error recovery becomes much harder, since you need to figure out when/where to restore the ```\neval```\n flag.\n\nedit\n\nWith what you have abouve, ```\n$```\n and ```\n~```\n don't actually do anything.  If you want them to be equivalent to ```\n++```\n and ```\n--```\n, you need:\n\n```\nexpr: `$` T_VAR { $$ = eval ? symbolTable[$2]++ : 0; }\n    | `~` T_VAR { $$ = eval ? symbolTable[$2]-- : 0; }\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "'and' (boolean) vs '&' (bitwise) - Why difference in behavior with lists vs numpy arrays?\r\n                \r\nWhat explains the difference in behavior of boolean and bitwise operations on lists vs NumPy arrays? \n\nI'm confused about the appropriate use of ```\n&```\n vs ```\nand```\n in Python, illustrated in the following examples.\n\n```\nmylist1 = [True,  True,  True, False,  True]\nmylist2 = [False, True, False,  True, False]\n\n>>> len(mylist1) == len(mylist2)\nTrue\n\n# ---- Example 1 ----\n>>> mylist1 and mylist2\n[False, True, False, True, False]\n# I would have expected [False, True, False, False, False]\n\n# ---- Example 2 ----\n>>> mylist1 & mylist2\nTypeError: unsupported operand type(s) for &: 'list' and 'list'\n# Why not just like example 1?\n\n>>> import numpy as np\n\n# ---- Example 3 ----\n>>> np.array(mylist1) and np.array(mylist2)\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n# Why not just like Example 4?\n\n# ---- Example 4 ----\n>>> np.array(mylist1) & np.array(mylist2)\narray([False,  True, False, False, False], dtype=bool)\n# This is the output I was expecting!\n```\n\n\nThis answer and this answer helped me understand that ```\nand```\n is a boolean operation but ```\n&```\n is a bitwise operation. \n\nI read about bitwise operations to better understand the concept, but I am struggling to use that information to make sense of my above 4 examples.\n\nExample 4 led me to my desired output, so that is fine, but I am still confused about when/how/why I should use ```\nand```\n vs ```\n&```\n. Why do lists and NumPy arrays behave differently with these operators? \n\nCan anyone help me understand the difference between boolean and bitwise operations to explain why they handle lists and NumPy arrays differently?  \n    ", "Answer": "\r\n```\nand```\n tests whether both expressions are logically ```\nTrue```\n while ```\n&```\n (when used with ```\nTrue```\n/```\nFalse```\n values) tests if both are ```\nTrue```\n.\nIn Python, empty built-in objects are typically treated as logically ```\nFalse```\n while non-empty built-ins are logically ```\nTrue```\n. This facilitates the common use case where you want to do something if a list is empty and something else if the list is not. Note that this means that the list [False] is logically ```\nTrue```\n:\n```\n>>> if [False]:\n...    print('True')\n...\nTrue\n```\n\nSo in Example 1, the first list is non-empty and therefore logically ```\nTrue```\n, so the truth value of the ```\nand```\n is the same as that of the second list. (In our case, the second list is non-empty and therefore logically ```\nTrue```\n, but identifying that would require an unnecessary step of calculation.)\nFor example 2, lists cannot meaningfully be combined in a bitwise fashion because they can contain arbitrary unlike elements. Things that can be combined bitwise include: Trues and Falses, integers.\nNumPy objects, by contrast, support vectorized calculations. That is, they let you perform the same operations on multiple pieces of data.\nExample 3 fails because NumPy arrays (of length > 1) have no truth value as this prevents vector-based logic confusion.\nExample 4 is simply a vectorized bit ```\nand```\n operation.\nBottom Line\n\nIf you are not dealing with arrays and are not performing math manipulations of integers, you probably want ```\nand```\n.\n\nIf you have vectors of truth values that you wish to combine, use ```\nnumpy```\n with ```\n&```\n.\n\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Where are the ampersand and vertical bar characters used in Python?\r\n                \r\nIn the Wikipedia page describing short-circuit evaluation, ```\n&```\n and ```\n|```\n are listed as eager operators in Python. What does this mean and when are they used in the language? \n    ", "Answer": "\r\nThe wikipedia page is wrong, I've corrected it. ```\n|```\n and ```\n&```\n are not boolean operators, even though they are eager operators, which just means that they are not short circuit operators. As you probably know, here's how the python ```\nand```\n and ```\nor```\n operators work:\n\n```\n>>> def talk(x):\n...     print \"Evaluating: \", bool(x)\n...     return x\n... \n>>> talk(1 == 1) or talk(2 == 1)   # 2 == 1 is not evaluated\nEvaluating:  True\nTrue\n>>> talk(1 == 1) and talk(2 == 1)\nEvaluating:  True\nEvaluating:  False\nFalse\n>>> talk(1 == 2) and talk(1 == 3)  # 1 == 3 is not evaluated\nEvaluating:  False\nFalse\n```\n\n\nAs far as I know, python has no eager boolean operators, they would have to be explicitly coded, for instance like this:\n\n```\n>>> def eager_or(a, b):\n...    return a or b\n...\n>>> eager_or(talk(1 == 1), talk(2 == 1))\nEvaluating:  True\nEvaluating:  False\nTrue\n```\n\n\nNow ```\na```\n and ```\nb```\n are automatically evaluated when the function is called, even though ```\nor```\n still short circuits.\n\nAs for the usage of ```\n|```\n and ```\n&```\n, when used with numbers, they are binary operators:\n\n```\n>>> bin(0b11110000 & 0b10101010)\n'0b10100000'\n>>> bin(0b11110000 | 0b10101010)\n'0b11111010'\n```\n\n\nYou're most likely to use ```\n|```\n this way with python bindings to libraries that uses flags, like wxWidgets:\n\n```\n>>> frame = wx.Frame(title=\"My Frame\", style=wx.MAXIMIZE | wx.STAY_ON_TOP)\n>>> bin(wx.MAXIMIZE)\n'0b10000000000000'\n>>> bin(wx.STAY_ON_TOP)\n'0b1000000000000000'\n>>> bin(wx.MAXIMIZE | wx.STAY_ON_TOP)\n'0b1010000000000000'\n```\n\n\nWhen used with sets, they do the intersection and union operations, respectively:\n\n```\n>>> set(\"abcd\") & set(\"cdef\")\nset(['c', 'd'])\n>>> set(\"abcd\") | set(\"cdef\")\nset(['a', 'c', 'b', 'e', 'd', 'f'])\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Java: short circuit evaluation in boolean expressions [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI was wondering what happens if a variable is null, and within a boolean condition, a method is called on that null variable. will it throw an exception?\n\n```\nMyObj chair = null\nchair = getSpecialMethod();\nif(chair != null && chair.size()){\n  ....\n}\n```\n\n\nWhat happens to the case if ```\nchair```\n is null, will an exception be  thrown, even though it is checked for a null value before ```\nchair.size()```\n is called?\n    ", "Answer": "\r\nNo, the second part of the condition is not evaluated as the first is ```\nfalse```\n, when ```\nchair```\n is ```\nnull```\n, so a ```\nNullPointerException```\n is not thrown.\n\nFrom section 15.23. Conditional-And Operator && in the Java Language Specification:\n\n\n  The conditional-and operator && is like & (§15.22.2), but evaluates its right-hand operand only if the value of its left-hand operand is true.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is it guaranteed that bitwise \"and\" for bool does not short circuit?\r\n                \r\nI recently came across a code snippet that looked like this:\n\n```\nbool MyClass::do_work()\n{\n    bool success = true;\n    for (auto const& worker : m_workers)\n    {\n        success &= worker.do_work();  // worker.do_work() returns a bool\n    }\n    return success;\n}\n```\n\n\nIf I understand it correctly, the function returns ```\ntrue```\n if all workers return ```\ntrue```\n and it returns ```\nfalse```\n if any worker returns false. However, it always evaluates all workers (which is desired). There is no short-circuit evaluation involved, since the bitwise operator ```\n&=```\n was used and not the logical operator ```\n&&```\n.\n\nIs this behavior guaranteed? To be exact, is it guaranteed that bitwise ```\n&```\n always evaluates both operands, even if they are of type ```\nbool```\n? I came across many SO answers regarding guaranteed short-circuit evaluation for ```\n&&```\n, but none of them state that there is guaranteed non-short-circuit evaluation for ```\n&```\n.\n\nIf this behavior is guaranteed, is this a good programming style? It took me more than a quick glance to understand the function, because I have not seen this style before, and at first I was confused whether short-circuit evaluation was involved or not.\n\nIs there a better alternative than the following?\n\n```\nbool MyClass::do_work()\n{\n    bool success = true;\n    for (auto const& worker : m_workers)\n    {\n        if (!worker.do_work())\n        {\n            success = false;\n        }\n    }\n    return success;\n}\n```\n\n    ", "Answer": "\r\nUnless explicitly specified by the standard, all  operands of an operator are evaluated and unsequenced1 in C++:\n\n\n  [intro.execution]\n  \n  Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.\n  [...]\n  The value computations of the operands of an operator are sequenced before the value computation of the result of the operator. [...]\n\n\nThe only three exceptions that come to my mind are the ```\n&&```\n, ```\n||```\n and ```\n?:```\n operators2.\n\nThe standard even mentions for ```\n&&```\n3 that:\n\n\n  [expr.log.and]\n  \n  Unlike ```\n&```\n, ```\n&&```\n guarantees left-to-right evaluation: the second operand is not evaluated if the first operand is ```\nfalse```\n.\n\n\nAs for if this is good programming style, this is opinion-based. \n\n\n\n1 Unsequenced basically means that if you have ```\nA @ B```\n (where ```\n@```\n is an operator), ```\nB```\n (and its side effects) can be evaluated before ```\nA```\n, which is why construct such as ```\ni++ + ++i```\n are undefined behavior.\n\n2 Note that for overloaded ```\n&&```\n and ```\n||```\n operator, this is not true anymore since both operands are evaluated. ```\n?:```\n cannot be overloaded.\n\n3 There is a similar note for ```\n|```\n within [expr.log.or].\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Conditional breakpoints and watch window do not short-circuit expression evaluation\r\n                \r\n[EDIT - changed example to avoid confusion about the root issue]\n\nWhile trying to work out why my conditional breakpoints keep generating errors in Visual Studio, I've stumbled across a behaviour I did not expect.\n\nIn the watch window, immediate window, or as the condition of a breakpoint, Visual Studio does not appear to short-circuit expression evaluation.\n\nFor example, stopping at a breakpoint on the line after this:\n\n```\nstring obj = \"hello\";\n```\n\n\nand evaluating the following in the watch window\n\n```\nobj is int && ((int)obj) == 1\n```\n\n\nshould give the result\n\n```\nfalse\n```\n\n\nbut instead gives \n\n\n  CS0030: Cannot convert type 'string' to 'int' \n\n\nThis prevents me from doing things like checking the type of an object, and then casting to that type and checking a property in my conditional breakpoints, which seriously reduces their usefulness.\n\nDo other people see this behaviour, and does anyone know how to make conditional breakpoints/watch window short-circuit?\n\nThe one less-than-ideal workaround that I've come up with is to wrap the expression in a method in your code, and evaluate this from the watch window. However, this involves changing code and recompiling, instead of being able to dynamically change conditions while debugging.\n    ", "Answer": "\r\nActually this statement wouldn't work in the immediate window or in code either because the compiler knows ```\nobj```\n will never be castable to ```\nint```\n.\n\nIf you had defined obj as an ```\nobject```\n it would work as expected.\n\n```\nobject obj = \"hello\";\nbool result = obj is int && ((int)obj) == 1;\n```\n\n\nThe code above will compile and work as a breakpoint condition.\n\nAs leppie mentioned you could re-cast your object (```\n(int)(object) obj```\n) to avoid this, but that should always be a measure of last resort.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is short-circuit evaluation safe in my case?\r\n                \r\nI have a simple condition that looks like this :\n\n```\nif (k==0 && f())\n```\n\n\nf has side effects and must not be called if k is different from 0. Can I rely on boolean short-circuits so that the compiler never calls f ? Of course, I could haved moved the if to the outside to guarantee f is never called when k != 0, but this is shorter.\n    ", "Answer": "\r\n\n  8.14 Logical AND operator [expr.log.and]\n  \n  \n  The && operator groups left-to-right. The operands are both contextually converted to bool (Clause 7). The result is true if both operands are true and false otherwise. Unlike &, && guarantees left-to-right evaluation: the second operand is not evaluated if the first operand is false.\n  \n\n\nSo, if ```\nk```\n is not equal to ```\n0```\n, a conformant compiler will not call ```\nf```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit evaluation via the AND operator in PHP\r\n                \r\nI'm trying to improve my coding ninja h4x skills, and I'm currently looking at different frameworks, and I have found sample code that's pretty hard to google.\n\nI am looking at the FUEL framework used in a project. \n\nThe sample I don't understand is \n\n```\n$data and $this->template->set_global($data);\n```\n\n\nWhat is the and keyword doing in this line of code? It is used many places in the framework and it's the first that I have found that uses it.\n    ", "Answer": "\r\nThis is a type of \"short circuit evaluation\". The ```\nand/&&```\n implies that both sides of the comparison must evaluate to ```\nTRUE```\n. \n\nThe item on the left of the ```\nand/&&```\n is evaluated to ```\nTRUE/FALSE```\n and if ```\nTRUE```\n, the item on the right is executed and evaluated. If the left item is ```\nFALSE```\n, execution halts and the right side isn't evaluated.\n\n```\n$data = FALSE;\n// $this->template->set_global($data) doesn't get evaluated!\n$data and $this->template->set_global($data);\n\n$data = TRUE;\n// $this->template->set_global($data) gets evaluated\n$data and $this->template->set_global($data);\n```\n\n\nNote these don't have to be actual boolean ```\nTRUE/FALSE```\n, but can also be truthy/falsy values according to PHP's evaluation rules. See the PHP boolean docs for more info on evaluation rules.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit logic evaluation in 'if' statement\r\n                \r\nI'm looking to add a short-circuit to an if statement. The idea is that if both refEndDate and the last item in endDateList are NA, don't perform the second operation but still return true. Currently, both sides of the ```\n&&```\n gets run which can result in an error if refEndDate or the last entry in endDateList are NA.\n\n```\nendDateList <- c('2018-01-01', '2018-01-03', NA)\nrefEndDate <- NA\n\n\n(is.na(endDateList[length(endDateList)]) & is.na(refEndDate))\n[1] TRUE\n```\n\n\nThis returns TRUE as expected.\n\n```\n(endDateList[length(endDateList)] != refEndDate)\n[1] NA\n```\n\n\nThis returns NA as expected as both are NA.\n\n```\n((is.na(endDateList[length(endDateList)]) & is.na(refEndDate)) &&\n    (endDateList[length(endDateList)] != refEndDate))\n[1] NA\n```\n\n\nHow do I get the above to return TRUE?\n    ", "Answer": "\r\nYou just need to use an or instead of an and.\n\n```\n((is.na(endDateList[length(endDateList)]) & is.na(refEndDate)) || \n       (endDateList[length(endDateList)] != refEndDate))\n[1] TRUE\n```\n\n\nYou should understand what an logical ```\nNA```\n means.  ```\nNA```\n means that the value isn't known, but it still needs to be ```\nTRUE```\n or ```\nFALSE```\n.  In other words, if a statement always evaluates one way regardless of the status of the ```\nNA```\n value, it will not return ```\nNA```\n.  \n\nFor example, consider the following cases:\n\n```\n> TRUE || NA\n[1] TRUE\n\n> FALSE || NA\n[1] NA\n\n> TRUE && NA\n[1] NA\n\n> FALSE && NA\n[1] FALSE\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is relying on short-circuit evaluation good design? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nAre there alternatives that would be more preferred?\n    ", "Answer": "\r\nShort-circuit evaluation is a crucial feature of most modern programming languages and there's no reason to avoid relying on it. Without it pointer-related tests would be (unnecessarily) much more complicated and less readable.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Lazy Evaluation on condition variables\r\n                \r\nIn the following code snippet, would compiler do lazy evaluation on condition variables and also do short circuit evaluation?\n```\nconst bool condition1 = calcCondition1(...);\nconst bool condition2 = calcCondition2(...);\nconst bool condition3 = calcCondition3(...);\n\nif (condition1 && condition2 && condition3)\n  return true;\nreturn false\n```\n\nSuch that the actual flow would be something like the following?\n```\nif(!calcCondition1(...))\n  return false;\nif(!calcCondition2(...))\n  return false;\nif(!calcCondition3(...))\n  return false;\nreturn true;\n```\n\nThank you!\n    ", "Answer": "\r\nYes, if compiler is sure that such a optimization does not change any visible semantic of the program (see ```\n__attribute__((pure))```\n example below).\nNo in other cases. Note that function bodies from different compilation units (different ```\n.cpp```\n file) are unknown: they are linked into binary after compilation process.\nThe compiler must assume worst-case scenarios such as ```\ncalcCondition1```\n throws an exception or executes ```\nexit()```\n. Or mutate some global state. And in such cases, the semantics must be preserved and everything must be invoked in the written order\nThat code\n```\nbool calcCondition1();\nbool calcCondition2();\nbool calcCondition3();\n\nbool foo() {\n    const bool condition1 = calcCondition1();\n    const bool condition2 = calcCondition2();\n    const bool condition3 = calcCondition3();\n\n    if (condition1 && condition2 && condition3) return true;\n    return false;\n}\n```\n\nand example assembly output:\n```\nfoo():                                # @foo()\n        push    rbp\n        push    rbx\n        push    rax\n        call    calcCondition1()@PLT\n        mov     ebp, eax\n        call    calcCondition2()@PLT\n        mov     ebx, eax\n        call    calcCondition3()@PLT\n        and     bl, bpl\n        and     al, bl\n        add     rsp, 8\n        pop     rbx\n        pop     rbp\n        ret\n```\n\nNotice that all functions are called one by one\nIf compiler is sure that it is not a case (I am using a gcc extension):\n```\n__attribute__((pure)) bool calcCondition1();\n__attribute__((pure)) bool calcCondition2();\n__attribute__((pure)) bool calcCondition3();\n\nbool foo() {\n    const bool condition1 = calcCondition1();\n    const bool condition2 = calcCondition2();\n    const bool condition3 = calcCondition3();\n\n    if (condition1 && condition2 && condition3) return true;\n    return false;\n}\n```\n\nThen the generated code use the short circuit evaluation\n```\nfoo():                                # @foo()\n        push    rbx\n        call    calcCondition1()@PLT\n        test    al, al\n        je      .LBB0_4\n        call    calcCondition3()@PLT\n        mov     ebx, eax\n        call    calcCondition2()@PLT\n        test    bl, bl\n        je      .LBB0_4\n        mov     ecx, eax\n        mov     al, 1\n        test    cl, cl\n        je      .LBB0_4\n        pop     rbx\n        ret\n.LBB0_4:\n        xor     eax, eax\n        pop     rbx\n        ret\n```\n\n, because compiler is sure that functions are pure, so there is a more rooms for optimizations.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "how to go about with this Short circuit evaluation?\r\n                \r\nI want to add PictureAlbums along with iframe. Basically, I'm trying to write like this: if timerStates is complete then render  ```\n<iframe>```\n and also PictureAlbum component.\n\nWith the code below I'm able to render only ```\n<PictureAlbums />```\n and not iframe. How do I solve this?\n\n```\nimport React from 'react';\nimport PictureAlbums from './PictureAlbums';\nimport * as timerStates from './TimerState';\n\n\nconst lp = (val) => {\n  if (val < 10) return `0${val}`;\n  return `${val}`;\n}\n\nconst TimerDisplay = (props) => (\n  <div>\n    <div>\n      {\n        (props.timerState === timerStates.COMPLETE)\n         && <iframe  src=\"https://www.youtube.com/\"></iframe> \n         && <PictureAlbums />\n      }\n    </div>\n    <div>\n      <h2>{`${lp(props.currentTime.get('hours'))}:${lp(props.currentTime.get('minutes'))}:${lp(props.currentTime.get('seconds'))}`}</h2>\n    </div>\n </div>\n);\n```\n\n    ", "Answer": "\r\nYou can use a ```\nReact.Fragment```\n for that to give both elements a common parent without inserting an extra element in the DOM.\n\n```\n{props.timerState === timerStates.COMPLETE && (\n  <React.Fragment>\n    <iframe src=\"https://www.youtube.com/\"></iframe> \n    <PictureAlbums />\n  </React.Fragment>\n)}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "poisoned null-reference and short-circuit expression evaluation bug or UB?\r\n                \r\nI have come across a strange C++ crash recently after upgrading to gcc 7.2 which can be demonstrated using the following simple complete c++11 program:\n\n```\n#include <cassert>\n#include <cstdio>\n\nstruct MyObject\n{\n    static MyObject & null_obj()\n        { return *static_cast<MyObject*>    (nullptr); }\n\n    operator bool()\n    {\n        return value != 0;\n    }\n\n    int value = 0;\n};\n\nint foo(MyObject & obj = MyObject::null_obj())\n{\n    if (&obj != &MyObject::null_obj() && obj)\n        return 1;\n\n    return 0;\n}\n\nint main(int argc, char * argv[])\n{\n    int result;\n\n    if (argc == 1)\n    {\n        result = foo();\n    }\n    else\n    {\n        MyObject obj;\n        obj.value = 1;\n\n        result = foo(obj);\n    }\n\n    printf(\"%d\", result);\n}\n```\n\n\nThe program can be built using: g++ -std=c++11 -O2\n\nWhen executed with no arguments - program takes the top branch and crashes when built with gcc6.1 or later. When build with gcc 5.5 it does not crash.\n\nWhen adding a dummy parameter - program takes second branch and does not crash as expected. The program also does not crash in any case when build without compiler optimizations.\n\nThe crash appear to happen when the conditional in foo() is evaluated.\nAccordingly to short-circuit evaluation rules, the second condition in this code path should not be executed when first part of the expression is false.\n\nWhen using a newer compiler, such as gcc 6.1 or later, assembler generated for foo looks like this:\n\n```\nfoo(MyObject&):\n  mov edx, DWORD PTR [rdi]\n  xor eax, eax\n  test edx, edx\n  setne al\n  ret\n```\n\n\nThe crash culprit is the mov instructions at the top of the function.\nThe assembler for gcc 5.5 looks a bit different:\n\n```\nfoo(MyObject&):\n  test rdi, rdi\n  je .L3\n  mov edx, DWORD PTR [rdi]\n  xor eax, eax\n  test edx, edx\n  setne al\n  ret\n.L3:\n  xor eax, eax\n  ret\n```\n\n\nThe check on top of the function skips over the invalid read (as expected)\n\nOne can argue that using null reference in this manner is a fairly dodgy practice and I am tempted to agree even though I don't know exactly why. However I came across the same idiom in a boost::error_code class which uses boost::throws() : docs, source.\n\nI am aware that short-circuit eval does not apply to types that overload || and && operators but this is clearly not the case here.\n\nIs this UB? (user error), compiler bug or something else?\n\nUpdate:\n\nMy original reference to boost::error_code was for the version 1.65.1. This implementation was first introduced into boost version 1.40. I have since discovered that in latest version of boost the function was modified presumably to avoid the UB, but it is curious that it was permitted to stand unchallenged for so long. The new function uses non-zero integer constant:\n\n```\nnamespace detail\n{\n    //  Misuse of the error_code object is turned into a noisy failure by\n    //  poisoning the reference. This particular implementation doesn't\n    //  produce warnings or errors from popular compilers, is very  efficient\n    //  (as determined by inspecting generated code), and does not suffer\n    //  from order of initialization problems. In practice, it also seems\n    //  cause user function error handling implementation errors to be detected\n    //  very early in the development cycle.\n    inline system::error_code* throws()\n    {\n      // See github.com/boostorg/system/pull/12 by visigoth for why the return\n      // is poisoned with (1) rather than (0). A test, test_throws_usage(), has\n      // been added to error_code_test.cpp, and as visigoth mentioned it fails\n      // on clang for release builds with a return of 0 but works fine with (1).\n      return reinterpret_cast<system::error_code*>(1);\n    }\n}\n\ninline system::error_code& throws() { return *detail::throws(); }\n```\n\n    ", "Answer": "\r\nWell this is undefined behavior:\n\n```\n    { return *static_cast<MyObject*>    (nullptr); }\n```\n\n\nYou are not allowed to convert a ```\nnullptr```\n to a reference. It also breaks all the assumptions anybody that has a reference has.\n\nNote: Undefined behavior means anything can happen (including a crash or not crashing).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "If condition and Short circuit evaluation in rails - DRY\r\n                \r\nI m doing an app and I need to add multiple condition if. I want to know if an solution exist to DRY.\n\nI m tried something like this but that dont work, it's like https://en.m.wikipedia.org/wiki/Short-circuit_evaluation\n\n```\n  <% @camping.situations.each do |situation| %>\n    <%if situation.plage == \"oui\" || situation.etang == \"oui\" || situation.lac == \"oui\" %>\n    Do that\n    <%else%>\n    Do this\n    <%end%>\n<%end%>\n```\n\n\nFor my app to test more than 30 conditions so i dont want to repeat myself with multiple IF.\n\nExample : Plage = oui / etang = Non / lac = oui\nI want to display in my view :\n\n```\nDo that\nDo this\nDo that\n```\n\n\nDo you have any suggestions ?\n\nEDIT\n\nI m sorry i think my message wasn't clear. So for each entries I have 3 possible value 1) OUI 2) NON 3) EMPTY. User add the value of his object.\n\nSo in my view i display like this\n\n```\n<% @camping.caracteristiquetests.each do |caracteristiquetest| %>\n          <%if caracteristiquetest.animaux ==\"oui\"%>animaux<%else%><s>animaux</s><%end%>\n      <%if caracteristiquetest.barbecue==\"oui\"%>barbecue<%else%><s>barbecue</s><%end%>\n      <%if caracteristiquetest.handicap ==\"oui\"%>handicap<%else%><s>handicap</s><%end%>\n      <%if caracteristiquetest.piscine==\"oui\"%>piscine<%else%><s>piscine</s><%end%>\n      <%if caracteristiquetest.jeux ==\"oui\"%>jeux<%else%><s>jeux</s><%end%>\n      <%if caracteristiquetest.loisir==\"oui\"%>loisir<%else%><s>loisir</s><%end%>\n\n    <%end%>\n    <!--Affiche les parametres de la table situation-->\n    <% @camping.situations.each do |situation| %>\n      <%if situation.plage ==\"oui\"%>plage<%else%><s>plage</s><%end%>\n      <%if situation.etang ==\"oui\"%>etang<%else%><s>etang</s><%end%>\n      <%if situation.montagne ==\"oui\"%>montagne<%else%><s>montagne</s><%end%>\n      <%if situation.riviere ==\"oui\"%>riviere<%else%><s>riviere</s><%end%>\n      <%if situation.foret==\"oui\"%>foret<%else%><s>foret</s><%end%>\n    <%end%>\n```\n\n\nIf value is different to \"oui\" my view show Strikethrough.\n\nI have more entries but it's always the same condition. As you can see i have lot of \"IF\". So i just wanna know if it's possible to DRY this ?\n    ", "Answer": "\r\nYou could do it as follows.\nThe code ```\nsituation.members.any?{|m| situation.send(m) == 'oui'}```\n enumerates the members (attributes) of your situation object and compares the value of them each by doing a send of the membername against the string 'oui', if any of them contains it the whole expression is true.\nThe ternary statement ? evaluates this and puts the \"Do that\" if true and the \"Do this\" else.\n\n```\nsituation = Struct.new(:plage, :etang, :lac)\nsituations = []\nsituations << situation.new('non','oui','non')\nsituations << situation.new('non','non','non')\n\nsituations.each do |situation| \n  puts situation.members.any?{|m| situation.send(m) == 'oui'} ? \"Do that\" : \"Do this\"\nend\n\n# gives\n# Do that\n# Do this\n```\n\n\nIf I understand your last edit correct, this would become\n\n```\nsituations.each do |situation| \n  situation.members.each{|member| puts situation.send(member) == 'oui' ? \"Do that\" : \"Do this\"}\nend\n```\n\n\nYou really should make your question more clear next time.\nBased on your last edit, my last attempt, you just need to go one level deeper.\nWe just give you the methods how to do something, the rest is up to you.\nMore Dry than this it won't become..\n\n```\ncamping = Struct.new(:situation, :caracteristiquetest)\ncampings = []\n\nsituation           = Struct.new(:plage, :etang, :lac, :montagne, :riviere, :foret)\ncaracteristiquetest = Struct.new(:animaux, :barbecue, :handicap, :piscine, :jeux, :loisir)\n\ncampings << \n  camping.new(situation.new('non','oui','non','non','oui','non'),\n  caracteristiquetest.new('non','oui','non','non','oui','non'))\n\ncampings << \n  camping.new(situation.new('oui','oui','non','non','oui','non'),\n  caracteristiquetest.new('non','oui','non','non','non','non'))\n\ncampings.each do |camping|\n  camping.members.each do |camping_attr| \n    camping.send(camping_attr).members.each{|member| \n      puts camping.send(camping_attr).send(member) == 'oui' ? member : \"<s>#{member}</s>\"\n    }\n  end\nend\n```\n\n\nWhich gives\n\n```\n<s>plage</s>\netang\n<s>lac</s>\n<s>montagne</s>\nriviere\n<s>foret</s>\n<s>animaux</s>\nbarbecue\n<s>handicap</s>\n<s>piscine</s>\njeux\n<s>loisir</s>\nplage\netang\n<s>lac</s>\n<s>montagne</s>\nriviere\n<s>foret</s>\n<s>animaux</s>\nbarbecue\n<s>handicap</s>\n<s>piscine</s>\n<s>jeux</s>\n<s>loisir</s>\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What is the best practice concerning C# short-circuit evaluation?\r\n                \r\nAn answer and subsequent debate in the comments in another thread prompted me to ask:\n\nIn C# || and && are the short-circuited versions of the logical operators | and & respectively.\n\nExample usage:\n\n```\nif (String.IsNullOrEmpty(text1) | String.IsNullOrEmpty(text2) | String.IsNullOrEmpty(text3))\n{\n    //...\n}\n```\n\n\nversus:\n\n```\nif (String.IsNullOrEmpty(text1) || String.IsNullOrEmpty(text2) || String.IsNullOrEmpty(text3))\n{\n    //...\n}\n```\n\n\nIn terms of coding practice which is the better to use and why?\n\nNote: I do realize this question is similar to this question but I believe it warrants a language specific discussion.\n    ", "Answer": "\r\n\n  In terms of coding practice which is the better to use and why?\n\n\nSimple answer: always use the short-circuited versions. There’s simply no reason not to. Additionally, you make your code clearer because you express your intent: logical evaluation. Using the bitwise (logical) operations implies that you want just that: bit operations, not logical evaluation (even though the MSDN calls them “logical operators” as well, when applied to boolean values).\n\nAdditionally, since short-circuiting only evaluates what needs evaluating, it’s often faster, and it allows to write such code as\n\n```\nbool nullorempty = str == null || str.Length == 0;\n```\n\n\n(Notice that to solve this particular problem a better function already exists, namely ```\nstring.IsNullOrEmpty```\n which you also used in your question.) This code wouldn’t be possible with the bitwise logical operations because even if ```\nstr```\n were ```\nnull```\n, the second expression would get evaluated, resulting in a ```\nNullReferenceException```\n.\n\nEDIT: If you want side-effects to occur in a logical context please still don’t use bitwise operations. This is a typical example of being too clever. The next maintainer of the code (or even yourself, after a few weeks) wo sees this code will think “hmm, this code can be cleared up to use conditional operators,” thus inadvertedly breaking the code. I pity whoever is in charge of fixing this bug.\n\nInstead, if you have to rely on side, effects, make them explicit:\n\n```\nbool hasBuzzed = checkMakeBuzz();\nbool isFrobbed = checkMakeFrob();\nbool result = hasBuzzed || isFrobbed;\n```\n\n\nGranted, three lines instead of one. But a much clearer code as a result.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does LINQ do short-circuit evaluation in VB.NET?\r\n                \r\nWe had a ```\nNullable object must have a value```\n error today on this line of code:\n\n```\nlist = From x In Me Where x.FooDate.HasValue AndAlso x.FooDate.Value.Date >= barDate\n```\n\n\nFunny thing is that I feel sure this used to work fine (and there has always been a sprinkling of null values in the underlying data). And logically it looks fine to me. The check for ```\nHasValue```\n and the ```\nAndAlso```\n look as if they're going to shield us from any Null danger.\n\nBut it seems suddenly they're not. Am I missing something?\n\nOK, we can correct it to this, which eliminates the error:\n\n```\nlist = From x In Me Where If(x.FooDate.HasValue, x.FooDate.Value.Date >= barDate,False)\n```\n\n\nBut this looks to me less readable. Any thoughts?\n\nUpdate ... and Confession:\nIn simplifying the above code to shorten the line I left out a crucial chunk of the code. The original problem should have read something like:\n\n```\nlist = From x In Me Where x.FooDate.HasValue AndAlso x.FooDate.Value.Date >= fromDate And x.FooDate.Value.Date <= toDate\n```\n\n\nBecause of the rules of shortcircuiting and operator precedence (as outlined in an answer to a long ago question of my own) I needed to add brackets round the second part of the instruction in order to stop LINQ evaluating the second ```\nx.FooDate.Value.Date```\n:\n\n```\nlist = From x In Me Where x.FooDate.HasValue AndAlso (x.FooDate.Value.Date >= fromDate and x.FooDate.Value.Date <= toDate)\n```\n\n\nThanks to both answers for throwing up quick test code to verify that LINQ really does obey AndAlso and force me to look more closely at the original problem.\n    ", "Answer": "\r\nI'm pretty sure that your query is safe, at least following sample code is:\n\n```\nDim dateList As New List(Of Nullable(Of Date))\nFor i As Int32 = 0 To 12\n    If (i Mod 3 = 0) Then\n        dateList.Add(Nothing)\n    Else\n        dateList.Add(New Date(2012, i, 1))\n    End If\nNext\nDim july = New Date(2012, 7, 1)\nDim fromJuly = (From m In dateList\n      Where m.HasValue AndAlso m.Value.Date >= july).ToList\n```\n\n\n Note: If i would replace ```\nAndAlso```\n with ```\nAnd```\n i would get your exception.\n\nSo the problem must be somewhere else. Show us more of your class please.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do Google Sheets logical operators short circuit?\r\n                \r\nBasically the title. Making a big Analytics based spreadsheet that tests for a lot of date conditions. I would like to know if the AND operator supports short-circuit evaluation.\n    ", "Answer": "\r\n\"short-circuit evaluation\" is basically nesting of ```\nIF```\n functions:\n\n```\n=IF(A1=1, TRUE,\n IF(A1=2, TRUE))\n```\n\n\nfor multi-criteria it would be:\n\n```\n=IF(AND(A1=1, B1=1), TRUE,\n IF(AND(A1=2, B1=2), TRUE))\n```\n\n\nwhen it comes to arrays/ranges it will be like this:\n\n```\n=ARRAYFORMULA(IF((A1:A=1) * (B1:B=1), TRUE,\n              IF((A1:A=2) * (B1:B=2), TRUE)))\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "One-line short-circuit evaluation with && || in JavaScript\r\n                \r\n```\nvar prefix = options && options.prefix || '';\n```\n\nIn JavaScipt in my case. Can someone explain what kind of statement or condition is this? Or at the end what's the value of prefix variable?\nI know about (ternary operator):\n```\ncondition ? expr1 : expr2\n```\n\nbut this was different.\n    ", "Answer": "\r\nThis one-liner is the equivalent of saying:\n\n```\nvar prefix;\nif(options && options.prefix){\n  prefix = options.prefix;\n} else{\n  prefix = '';\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to use short-circuit evaluation in vue method?\r\n                \r\nI'm using vue-cli and vuex and I'm trying to achieve something like this:\n```\nmethods: {\nfiltered() { \n  let vol = this.$store.state.data[1].data.filter(i => i.type === 'vol')[0].measure || 0;\n  let weight = this.$store.state.data[1].data.filter(i => i.type === 'weight')[0].measure || 0;\n }\n}\n```\n\nmy current data contains a vol ```\ntype```\n but not a weight so I'd like ```\nlet weight```\n to ```\n= 0```\n\nbut I'm getting an error that ```\nCannot read property 'measure' of undefined```\n.\nAny ideas would be great, thanks so much!\n    ", "Answer": "\r\nInstead of ```\nfilter()```\n, use ```\nfind()```\n and store it in a variable. Then check whether the variable contains anything.\n```\nmethods: {\n    filtered() {\n      let volobj = this.$store.state.data[1].data.find(i => i.type === 'vol')\n      let vol = volobj ? volobj.measure : 0;\n      let weightobj = this.$store.state.data[1].data.find(i => i.type === 'weight')\n      let weight = weightobj ? weightobj.measure : 0;\n    }\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is MS-SQL AND/OR conditional (perform short-circuit evaluation)?\r\n                \r\nI'm creating an stored procedure as this (simplified)\n\n```\ncreate procedure sp_mysp @p1 bit AS\nif (@p1 = 1 AND EXISTS(select  * from mytable1))\nBEGIN....END\nELSE IF (@p = 0 AMD EXISTS(select * from mytable2))\nBEGIN....END\n```\n\n\nSo the question is, will SQL always check for data in mytable1 or will it only check for data in mytable1 if @p1 equals to 1\n\n(something like && in c#)\n    ", "Answer": "\r\nThere is no guarantee of this behaviour.\n\nAn example of short circuiting evaluation not happening with ```\nexpr1 AND expr2```\n is\n\n```\nSET STATISTICS IO ON\n\nIF EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=2)  \nAND EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)=1)\nPRINT 'Y'\n```\n\n\nThe ```\nEXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=2)```\n is ```\nfalse```\n (meaning the ```\nAnd```\n-ed expression must be ```\nFalse```\n) but the IO results show the second condition was still evaluated.\n\n```\nTable 'spt_values'. Scan count 1, logical reads 14, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.\nTable 'spt_monitor'. Scan count 1, logical reads 1, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.\n```\n\n\nSQL Server can do this though. I see this in my test \n\n```\nSET STATISTICS IO ON\n\nDECLARE @p1 BIT = NULL\n\nIF ( @p1 = 1\n     AND EXISTS(SELECT *\n                FROM   master..spt_values) )\n  PRINT '1'\n\nELSE IF ( @p1 = 0\n     AND EXISTS(SELECT *\n                FROM   master..spt_values) )\n  PRINT '2'\n```\n\n\nThe output is \n\n```\nTable 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.\n\n(1 row(s) affected)\nTable 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.\n\n(1 row(s) affected)\n```\n\n\nShowing ```\nspt_values```\n was never accessed.\n\nThis is implemented by a pass through predicate condition in the execution plan. There is some information about those here.\n\n\n  If the passthru predicate evaluates to true, the join returns the row\n  ....  If the passthru\n  predicate evaluates to false, the join proceeds normally\n\n\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does XPath do short-circuit evaluation of logical expressions?\r\n                \r\nMy question is regarding the order of execution in XPath.\n\nI have an expression such as:\n\n```\n//person[@created and customFunction(.)]\n```\n\n\nMy problem is that my custom function is quite compute heavy and I only wish for it to run on nodes that have the created attribute set. Will ```\n@created```\n always be evaluated before ```\ncustomFunction```\n? I could cook up a program to test this, but in reality the success of such an experiment is no guarantee, at least not in the long term.\n\nIf this is a matter of XPath implementation i am using .NET 4.0. \n    ", "Answer": "\r\nXPath 1.0 does short-circuit evaluation, in XPath 2.0 and XPath 3.0 it is implementation-dependant.\n\nAccording to XPath 1.0 specs, section 3.4: booleans:\n\n\n  An or expression [...] The right operand is not evaluated if the left operand\n  evaluates to true.\n  \n  An and expression [...] The right operand is not evaluated if the left operand\n  evaluates to false.\n\n\nAccording to XPath 2.0 specs, section 3.6: Logical Expressions and XPath 3.0 specs, section 3.8: Logical Expressions:\n\n\n  If XPath 1.0 compatibility mode is true [...] it is defined that when there is no need to evaluate the second operand in order to determine the result, then no\n  error can occur as a result of evaluating the second operand.\n  \n  If XPath 1.0 compatibility mode is false, the order in which the\n  operands of a logical expression are evaluated is\n  implementation-dependent. In this case, an or-expression can return\n  true if the first expression evaluated is true, and it can raise an\n  error if evaluation of the first expression raises an error.\n  Similarly, an and-expression can return false if the first expression\n  evaluated is false, and it can raise an error if evaluation of the\n  first expression raises an error. As a result of these rules, a\n  logical expression is not deterministic in the presence of errors, as\n  illustrated in the examples below.\n\n\nWhen using XPath 2.0 or XPath 3.0 you can find out whether the current implementation does short-circuit evaluation by evaluating the following example expression:\n\n```\ntrue() or name(1234)\n```\n\n\nThe function ```\nname```\n returns the name of the node parameter, or it raises an error if you pass it for example a number, so:\n\n\nIf it returns true without rising an error then the implementation does short-circuit evaluation.\nIf an error is raised the implementation doesn't do short-circuit evaluation (as it has evaluated the right operand which was not neccessary).\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "In Scheme, does `or` and `and` short circuit?\r\n                \r\nDo ```\nand```\n and ```\nor```\n short circuit in Scheme?\nThe following are two implementation of ```\nlat?```\n (list of atoms). One uses ```\ncond```\n … ```\nelse```\n and the other uses ```\nor```\n and ```\nand```\n. I was wondering if they are equivalent and the answer to that hinges on whether ```\nor```\n and ```\nand```\n have short circuit evaluation in Scheme.\n```\n(define lat?\n  (lambda (l)\n    (cond\n         ((null? l) #t)\n         ((atom? (car l)) (lat? (cdr l)))\n         (else #f))))\n```\n\n\nuses ```\ncond```\n and ```\nelse```\n\n\n\n```\n(define lat?\n  (lambda (l)\n    (or (null? l)\n        (and (atom? (car l))\n             (lat? (cdr l))))))\n```\n\n\nuses ```\nor```\n and ```\nand```\n\n\nI think ```\nor```\n short-circuits. Why? I know ```\n(car ())```\n and ```\n(cdr ())```\n each produce ```\nError: Attempt to apply…```\n. If ```\nor```\n didn’t short-circuit, then ```\n(lat? ())```\n would eventually evaluate ```\n(car ())```\n and produce the error. However, ```\n(lat? ())```\n does not produce the error, therefore (via Modus Tollens) ```\nor```\n short-circuits. Is this correct? And does ```\nand```\n short-circuit?\n    ", "Answer": "\r\nYes, they both short-circuit per r6rs specification (didn't find  html version of r7rs online but here a link to the pdf version of r7rs specification, see section 4.2):\n\nIf there are no ```\n<test>s```\n, ```\n#t```\n is returned. Otherwise, the  expressions are evaluated from left to right until a ```\n<test>```\n returns #f or the last ```\n<test>```\n is reached. In the former case, the and expression returns ```\n#f```\n without evaluating the remaining expressions. In the latter case, the last expression is evaluated and its values are returned.\n\n```\nand```\n & ```\nor```\n is subsequently defined in terms of ```\ntest```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Any/All python short-circuit: Why doesn't the following work? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Does Python's `all` function use short circuit evaluation?\r\n                            \r\n                                (4 answers)\r\n                            \r\n                    \r\n                Closed 12 months ago.\r\n        \r\n\r\n\r\n    \r\n\r\nBased on what I've seen on other stackoverflow pages:\n\nDoes Python's `all` function use short circuit evaluation?\nDo all() and any() always short-circuit in order?\nIs the shortcircuit behaviour of Python's any/all explicit?\n\nthe following code should short circuit:\n```\nany([True, 2+2, False, 2/0])\nall([True, 2+2, False, 2/0])\n```\n\nbut for every one of them I get a ```\nZeroDivisionError: division by zero```\n.\nAm I missing something? Why does it error?\n    ", "Answer": "\r\nYour code errors because the expressions have to be evaluated before being passed into the function.\nIn this context, short-circuiting actually means that as soon as they find a different value, they return and don't bother checking the remaining values. It's not the same kind of short-circuiting that ```\nand```\n and ```\nor```\n do, which can actually avoid evaluating expressions.\nTo illustrate, let's use an iterator, which will get consumed:\n```\n>>> a = iter([1, 0, 2, 3])\n>>> all(a)  # Search until a falsy value\nFalse\n>>> list(a)  # Show what's left in the iterator\n[2, 3]\n```\n\nYou can see that it consumed ```\n1```\n and ```\n0```\n, returning on ```\n0```\n because it's falsy.\n\nNow, if you did want to do lazy evaluation with ```\nany```\n and ```\nall```\n, you could call lambdas in a generator expression:\n```\n>>> any(e() for e in [lambda: 1, lambda: 0, lambda: 2/0])\nTrue\n>>> all(e() for e in [lambda: 1, lambda: 0, lambda: 2/0])\nFalse\n```\n\n(Thanks to this question for inspiring this bit.)\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuiting statement evaluation -- is this guaranteed? [C#]\r\n                \r\nQuick question here about short-circuiting statements in C#.  With an if statement like this:\n\n```\nif (MyObject.MyArray.Count == 0 || MyObject.MyArray[0].SomeValue == 0)\n{\n\n//....\n}\n```\n\n\nIs it guaranteed that evaluation will stop after the \"MyArray.Count\" portion, provided that portion is true?  Otherwise I'll get a null exception in the second part.  \n    ", "Answer": "\r\nYes, this is guaranteed.\n\nC# Language Specification - 7.11 Conditional logical operators:\n\n\n  The ```\n&&```\n and ```\n||```\n operators are called the conditional logical operators. They are also called the \"short-circuiting\" logical operators. \n\n\nTherefore they will support logical short-circuiting by definition - you can rely on this behavior.\n\nNow it is important to make a distinction between a conditional operator and a logical operator:\n\n\nOnly conditional operators support short-circuiting, logical operators do not.\nC#'s logical operators look just like their conditional counterparts but with one less character so a logical OR is ```\n|```\n and a logical AND is ```\n&```\n.\nLogical operators can be overloaded but conditional operators cannot (this is a bit of an technicality as conditional operator evaluation does involve overload resolution and this overload resolution can resolve to a custom overload of the type's logical operator, so you can work around this limitation to a certain extent).\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why \"0\" is rendered on short-circuit evaluation of `array.length && ...`\r\n                \r\nCurrently, I see behavior like this:\n\n```\nrender() {\n   const list = [];\n   return (\n      <div>\n         { list.length && <div>List rendered</div> }\n      </div>\n   )\n}\n```\n\n\nMy expected is nothing rendered with that condition, but string \"0\" rendered (string \"0\" is ```\nlist.length```\n). I don't know why. Anybody can help me explain this case to React? \n    ", "Answer": "\r\nThat's basically the way, short-circuit evaluation is designed:\n\nAs logical expressions are evaluated left to right, they are tested\nfor possible \"short-circuit\" evaluation using the following rules:\n(some falsy expression) && expr is short-circuit evaluated to the\nfalsy expression\n\nThus, 0 is returned with the line ```\n{ list.length && <div>List rendered</div> }```\n.\nWhile it is also evaluated as falsy it is not ignored on render as opposed to ```\nfalse```\n, ```\nnull```\n, ```\nundefined```\n or ```\ntrue```\n.\nSo, if you want your short-circuit expression to return one of ignored values, you may do it this way:\n```\n{ list.length>0 && <div>List rendered</div> }\n```\n\nOr cast ```\n0```\n to ```\nfalse```\n, like that:\n```\n{ !!list.length && <div>List rendered</div> }\n```\n\nFollowing is a quick demo as a proof of concept:\n\r\n\r\n```\nconst { render } = ReactDOM\n\nconst Component = () => {\n  const list = []\n  return (\n      <div>\n         <div>Rendered on <code>{`list.length && <div>List rendered</div>`}</code>:{ list.length && <div>List rendered</div> }</div>\n         <div>Rendered on <code>{`list.length>0 && <div>List rendered</div>`}</code>:{ list.length>0 && <div>List rendered</div> }</div>\n         <div>Rendered on <code>{`!!list.length && <div>List rendered</div>`}</code>:{ !!list.length && <div>List rendered</div> }</div>\n      </div>\n   )\n}\n\nrender (<Component />, document.getElementById('root'))```\n\r\n```\ncode {background-color: grey; color:white;}```\n\r\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.12.0/umd/react.production.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.11.0/umd/react-dom.production.min.js\"></script><div id=\"root\"></div>```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why use short-circuit code?\r\n                \r\nRelated Questions: Benefits of using short-circuit evaluation, Why would a language NOT use Short-circuit evaluation?, Can someone explain this line of code please? (Logic & Assignment operators)\n\nThere are questions about the benefits of a language using short-circuit code, but I'm wondering what are the benefits for a programmer? Is it just that it can make code a little more concise? Or are there performance reasons?\n\nI'm not asking about situations where two entities need to be evaluated anyway, for example:\n\n```\nif($user->auth() AND $model->valid()){\n  $model->save();\n}\n```\n\n\nTo me the reasoning there is clear - since both need to be true, you can skip the more costly model validation if the user can't save the data.\n\nThis also has a (to me) obvious purpose:\n\n```\nif(is_string($userid) AND strlen($userid) > 10){\n  //do something\n};\n```\n\n\nBecause it wouldn't be wise to call ```\nstrlen()```\n with a non-string value.\n\nWhat I'm wondering about is the use of short-circuit code when it doesn't effect any other statements. For example, from the Zend Application default index page:\n\n```\ndefined('APPLICATION_PATH')\n || define('APPLICATION_PATH', realpath(dirname(__FILE__) . '/../application'));\n```\n\n\nThis could have been:\n\n```\nif(!defined('APPLICATION_PATH')){\n  define('APPLICATION_PATH', realpath(dirname(__FILE__) . '/../application'));\n}\n```\n\n\nOr even as a single statement:\n\n```\nif(!defined('APPLICATION_PATH'))\n  define('APPLICATION_PATH', realpath(dirname(__FILE__) . '/../application'));\n```\n\n\nSo why use the short-circuit code? Just for the 'coolness' factor of using logic operators in place of control structures? To consolidate nested if statements? Because it's faster?\n    ", "Answer": "\r\nFor programmers, the benefit of a less verbose syntax over another more verbose syntax can be:\n\n\nless to type, therefore higher coding efficiency\nless to read, therefore better maintainability.\n\n\nNow I'm only talking about when the less verbose syntax is not tricky or clever in any way, just the same recognized way of doing, but in fewer characters.\n\nIt's often when you see specific constructs in one language that you wish the language you use could have, but didn't even necessarily realize it before. Some examples off the top of my head:\n\n\nanonymous inner classes in Java instead of passing a pointer to a function (way more lines of code).\nin Ruby, the ||= operator, to evaluate an expression and assign to it if it evaluates to false or is null. Sure, you can achieve the same thing by 3 lines of code, but why?\nand many more...\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do we have short circuit logical operators in C shell script?\r\n                \r\nI thought C shell script will behave like C and use short circuit evaluation for logical operators.\n\n```\nif ((! -e $cache ) || (\"`find $monitor -newer $cache`\" != \"\")) then\n...\nendif\n```\n\n\nBut in the if statement, even if the first condition is true, the second is checked giving me errors.\n\nDo we have a short circuit logical OR in C shell script?\n    ", "Answer": "\r\nYes, ```\n&&```\n and ```\n||```\n are short-circuit operators in tcsh (just as they are in C).  And there are two distinct forms, one that works on commands (as in ```\nfalse && echo foo```\n), and one that works on expression (as in ```\nif (-e $file1 && -e $file2)```\n).\n\nI'm not entirely sure what's going on here, except that csh and tcsh are notorious for ill-defined syntax.  A bit of experimentation shows that saving the output of ```\nfind```\n in a variable avoids the error:\n\n```\nset s = \"`find $monitor -newer $cache`\"\nif ((! -e $cache) || (\"$s\" != \"\")) then\n    echo ok\nendif\n```\n\n\n(Note that the extra parentheses aren't really necessary, but they don't hurt anything.)\n\nBut more improvement is possible.  Storing the entire output of the find command in a variable isn't really necessary.  Instead, you can invoke find and use its returned status to tell you whether it found anything:\n\nI just tried this:\n\n```\nif (! -e $cache || { find $monitor -newer $cache >& /dev/null } ) then\n    echo ok\nendif\n```\n\n\nand it worked -- except that the ```\n>& /dev/null```\n redirection seems to be ignored within the braces.\n\nInstead, you can execute the \"find\" command separately, and then examine the resulting $status.  Which means that you lose the benefit of the short-circuit ```\n||```\n operator; you'll have to resort to nested ```\nif```\n statements and/or temporary variables.\n\nPerhaps the real lesson is this: I've been using csh and tcsh for more years than I care to admit, and the only way I was able to figure out a lot of this stuff was by trial and error.  You can do this using tcsh or csh, but you're probably better of using a different scripting language.  For example, in Bourne shell, this is fairly straightforward:\n\n```\nif [ ! -e $cache ] || find $monitor -newer $cache >/dev/null 2>&1 ; then\n    ...\nfi\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does C# use short-circuit evaluation in conditional statements?\r\n                \r\nIs the following code a good style. Can we always assume that the second predicate will not be executed if the object is null ?\n\n```\nif(someObject == null || someObject.Count == 0)\n{\n    //do something\n}\n```\n\n    ", "Answer": "\r\nYes. ```\n||```\n is known as a short circuiting operator, meaning if it knows enough to return true (that its first operand is true) then it will not evaluate the second operand and immediately return true.\n\n```\n&&```\n is similar - if its first operand returns false, it immediately returns false without checking the second.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "if evaluation in vba , vb.net\r\n                \r\nIn C or other languages ```\nif```\n evaluated using short-circuiting evaluation.\nBut in VB ,VB.Net I see that ```\nif```\n doesn't stop evaluation after get 100% result.\nThis code is fine\n```\ndim str as string\nstr=\"\"\nIf Len(str) = 0 Then\n    Console.WriteLine(\"yes\")\nend if\n```\n\nBut this gives error,\n```\ndim str as string\nstr=\"\"\nIf Len(str) = 0 Or CInt(str) > 0 Then  'Error System.InvalidCastException:\n    Console.WriteLine(\"yes\")\nend if\n```\n\nObviously null string doesn't covert to integer .the ```\nif```\n check ```\nLen(str) = 0```\n get ```\ntrue```\n and should stop but it again evaluate next .\nWhy it is like this???\nBut in Short-Circuit listed vb, vba, vb.net as supported.\nAnother example,\n```\ndim str as integer\nstr=10\nIf str=10 and str=\"\" Then  'Error\n    Console.WriteLine(\"yes\")\nend if\n```\n\n    ", "Answer": "\r\n\nBut in Short-Circuit listed vb, vba, vb.net as supported.\n\nI think you misunderstood the source. It lists .NET and VBA but for\n\nVisual Basic .NET\n\nEager operators: ```\nAnd```\n, ```\nOr```\n\nShort-circuit operators: ```\nAndAlso```\n, ```\nOrElse```\n\n\n\nVisual Basic, Visual Basic for Applications (VBA)\n\nEager operators: ```\nAnd```\n, ```\nOr```\n\nShort-circuit operators: ```\nSelect Case```\n\n\n\n\nSo it actually says .NET supports short-circuits only for the operators ```\nAndAlso```\n, ```\nOrElse```\n and VBA supports short-circuits only for the operator ```\nSelect Case```\n.\nBut your example is using ```\nAnd```\n, ```\nOr```\n which are listed as eager operators.\n\nSo this code in VB.NET\n```\nDim str As String\nstr = \"\"\nIf Len(str) = 0 Or CInt(str) > 0 Then  'Error System.InvalidCastException:\n    Console.WriteLine(\"yes\")\nEnd If\n```\n\nCan be rewritten as\n```\nDim str As String\nstr = \"\"\nIf Len(str) = 0 OrElse CInt(str) > 0 Then \n    Console.WriteLine(\"yes\")\nEnd If\n```\n\nor as nested statment\n```\nDim str As String\nstr = \"\"\nIf Not Len(str) = 0 Then\n    If CInt(str) > 0 Then \n        Console.WriteLine(\"yes\")\n    End If\nElse \n    Console.WriteLine(\"yes\")\nEnd If\n```\n\nor\n```\nDim str As String\nstr = \"\"\nIf Len(str) = 0 Then\n    Console.WriteLine(\"yes\")\nElseIf CInt(str) > 0 Then \n    Console.WriteLine(\"yes\")\nEnd If\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is it possible short circuit evaluation happens in the following case\r\n                \r\n```\npublic class JavaApplication11 {\n\n    static boolean fun() {\n        System.out.println(\"fun\");\n        return true;\n    }\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        boolean status = false;\n        status = status & fun();\n        status = fun() & status;\n    }\n}\n```\n\n\nWill Java thought, since ```\nstatus```\n is already false, it will not executed ```\nfun```\n method? I tested, in both case, ```\nfun```\n will be executed. But, is it guarantee across Java spec?\n    ", "Answer": "\r\nShort circuit evaluation does not happen here because you are using the bitwise and operation (```\n&```\n) instead of the logical and operation (```\n&&```\n).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What is the meaning of this C code? [short-circuit evaluation]\r\n                \r\nJeffrey Stedfast offered several functions that calculates the nearest power of 2. One of the functions has code as follows:\n\n```\nstatic uint32_t\nnearest_pow (uint32_t num)\n{\n  uint32_t j, k;\n  (j = num & 0xFFFF0000) || (j = num); // What is this?\n  ...\n}\n```\n\n\nTo fully understand the code, I tried changing the line to:\n\n```\n  j = num & 0xFFFF0000;\n  j = j | (j = num);\n```\n\n\nAccidentally, I got a correct result. However, when I applied such transformation to the next lines (not included in my quotation), I got a wrong result. It turned out that I misunderstood the meaning of the code.\n\nWhat is the meaning of ```\n(j = num & 0xFFFF0000) || (j = num);```\n?\n\nActually, I need to convert the function to other programming languages.\n    ", "Answer": "\r\n```\n||```\n is the logical or -operator. It has a short-circuiting behaviour such that if the left side is true, the right side is not evaluated (because the result of the logical or is known to be true already from the true left side).\n\nIn this case it is used in a roundabout way to provide a fallback assignment ```\nj = num```\n if the first assignment ```\nj = num & 0xFFFF0000```\n is zero (“false”). So, first the upper two bytes (mask ```\n0xFFFF0000```\n) of ```\nnum```\n are assigned to ```\nj```\n. If this is zero (“false”), i.e., the upper two bytes didn't have any 1-bits, then ```\nnum```\n is assigned to ```\nj```\n.\n\nEffectively this means “assign to ```\nj```\n the upper two bytes of ```\nnum```\n if they are non-zero, otherwise assign to ```\nj```\n the lower two bytes of ```\nnum```\n”.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does SQL short-circuit the evaluation of an OR in the WHERE CLAUSE? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to Short-Circuit SQL Where Clause\r\n                            \r\n                                (5 answers)\r\n                            \r\n                    \r\n                    \r\n                        Is the SQL WHERE clause short-circuit evaluated?\r\n                            \r\n                                (15 answers)\r\n                            \r\n                    \r\n                Closed 6 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nLooking at other questions here on SO and google seems to indicate MS Sql Server does not guarantee to short circuit the expressions in the WHERE clause.\n\nDoes that mean that a WHERE expression like this this one cannot be trusted to work...?\n\n```\n... WHERE (@include_voided = 1 OR mytable.void = 0) AND ... \n```\n\n\nI frequently use this kind of expression in my stored procedures.  Having researched short-circuiting for another reason I am now wondering if this should be replaced with ...\n\n```\n... WHERE mytable.void = case when @include_voided=1 then mytable.void else 0 END\n```\n\n\n...as all of the articles seem to indicate that CASE statements are the only ones guaranteed to short-circuit.\n\nI am hoping that the first expression is fine just because it is more readable and easier to type.\n    ", "Answer": "\r\nWhether or not SQL Server short circuits your particular expression isn't relevant here, it will generate the correct result either way. In this case, short circuiting is merely an optimization.\n\nAnd as for optimizations, it's up to how your index is built. These are (ideally) index seeks.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why does short-circuit evaluation work when operator precedence says it shouldn't?\r\n                \r\nIn JavaScript and Java, the equals operator (```\n==```\n or ```\n===```\n) has a higher precedence than the OR operator (```\n||```\n). Yet both languages (JS, Java) support short-circuiting in ```\nif```\n statements:\n\nWhen we have ```\nif(true || anything())```\n, ```\nanything()```\n isn't evaluated.\n\nYou can also have the following expression: ```\ntrue || foo == getValue())```\n - for example in an output statement such as ```\nconsole.log(...);```\n, or in an assignment.\n\nNow, according to operator precedence, short-circuiting shouldn't happen, as ```\n===```\n = ```\n==```\n > ```\n||```\n in terms of precedence. (In other words, the comparison should happen first, for which ```\ngetValue()```\n ought to be called, as the equality check has a higher precedence that the OR comparison.) But it does. ```\ngetValue()```\n isn't called (as can easily be checked by putting an output statement into its body). \n\nWhy (does short circuiting work when the operator precedence says it shouldn't)?\n Or am I confusing matters?\n    ", "Answer": "\r\n\n  Or am I confusing matters?\n\n\nYou are. I think it's much simpler to think about precedence as grouping than ordering. It affects the order of evaluation, but only because it changes the grouping.\n\nI don't know about Javascript for sure, but in Java operands are always evaluated in left-to-right order. The fact that ```\n==```\n has higher precedence than ```\n||```\n just means that\n\n```\ntrue || foo == getValue()\n```\n\n\nis evaluated as\n\n```\ntrue || (foo == getValue())\n```\n\n\nrather than\n\n```\n(true || foo) == getValue()\n```\n\n\nIf you just think about precedence in that way, and then consider that evaluation is always left-to-right (so the left operand of ```\n||```\n is always evaluated before the right operand, for example) then everything's simple - and ```\ngetValue()```\n is never evaluated due to short-circuiting. \n\nTo remove short-circuiting from the equation, consider this example instead:\n\n```\nA + B * C\n```\n\n\n... where ```\nA```\n, ```\nB```\n and ```\nC```\n could just be variables, or they could be other expressions such as method calls. In Java, this is guaranteed to be evaluated as:\n\n\nEvaluate ```\nA```\n (and remember it for later)\nEvaluate ```\nB```\n\nEvaluate ```\nC```\n\nMultiply the results of evaluating ```\nB```\n and ```\nC```\n\nAdd the result of evaluating ```\nA```\n with the result of the multiplication\n\n\nNote how even though ```\n*```\n has higher precedence than ```\n+```\n, ```\nA```\n is still evaluated before either ```\nB```\n or ```\nC```\n. If you want to think of precedence in terms of ordering, note how the multiplication still happens before the addition - but it still fulfills the left-to-right evaluation order too.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to prevent Oracle to use short circuit in PL/SQL\r\n                \r\nThe following PL/SQL code shows the function ```\nensure(...)```\n and how I will use it in Oracle 11g.\n\n```\ndeclare\nvalid boolean;\nfunction ensure(b boolean, failure_message varchar) return boolean is begin\n  if not b then\n    dbms_output.put_line(failure_message);\n    return false;\n  else\n    return true;\n  end if;\nend ensure;\nbegin\n  valid := true;\n  valid := valid \n        and ensure(1=1, 'condition 1 failed') \n        and ensure(1=2, 'condition 2 failed') \n        and ensure(2=3, 'condition 3 failed');\n\n  if not valid then\n    dbms_output.put_line('some conditions failed, terminate the program');\n    return;\n  end if;\n\n  dbms_output.put_line('do the work');\nend;\n/\n```\n\n\nI want to use ```\nensure(...)```\n to pre-validate a set of conditions, the program is allowed to do the work only if all conditions pass.\n\nI want the program to evaluate every ```\nensure(...)```\n even if the preceding ```\nensure(...)```\n return false, so that the ```\nfailure_message```\n will be printed for every conditions that fails.\n\nThe problem is Oracle uses short-circuit evaluation and ignore the rest conditions that come after the one that return false. For example, the above program prints the following message.\n\n```\ncondition 2 failed\nsome conditions failed, terminate the program\n```\n\n\nHow to tell Oracle to not use short-circuit evaluation so that the above program print the following message.\n\n```\ncondition 2 failed\ncondition 3 failed\nsome conditions failed, terminate the program\n```\n\n    ", "Answer": "\r\nTry:\n\n```\ndeclare\nvalid boolean;\ncon1 boolean;\ncon2 boolean;\ncon3 boolean;\nfunction ensure(b boolean, failure_message varchar) return boolean is begin\n  if not b then\n    dbms_output.put_line(failure_message);\n    return false;\n  else\n    return true;\n  end if;\nend ensure;\nbegin\n  valid := true;\n  con1 := ensure(1=1, 'condition 1 failed') ;\n  con2 := ensure(1=2, 'condition 2 failed') ;\n  con3 := ensure(2=3, 'condition 3 failed');\n  valid := con1 AND con2 AND con3;\n  if not valid then\n    dbms_output.put_line('some conditions failed, terminate the program');\n    return;\n  end if;\n\n  dbms_output.put_line('do the work');\nend;\n/\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Boolean expressions + short-circuit\r\n                \r\nI want to print a message with Boolean expressions + short-circuit evaluation (i am not allowed to use if/while/for ) but in C-Lion everything works fine but in other compiler it says:\n\n```\nhw2q1.c: In function 'decision':\nhw2q1.c:38:55: error: value computed is not used [-Werror=unused-value]\n|\n^\nS\n```\n\n\n\n  how can i solve this warning ? \n\n\nI tried in C-Lion but no problem seems to appear.\n\n```\nvoid decision(int DragonA,int DragonB,int DragonC) {\n\n         (DragonA == 1 && print_dragonX_sent('A') )   ||\n         (DragonB == 1 && print_dragonX_sent('B') )   ||\n         (DragonC == 1 && print_dragonX_sent('C') )   ||\n         (print_no_dragon());\n}\n```\n\n    ", "Answer": "\r\nYour function is basically fine.  I would expect a conforming C compiler to accept it.\n\nIt appears, however, that you are using compiler options that reject code that elicits a diagnostic of any kind, even one that would normally be a mere non-fatal warning.  The particular problem it is diagnosing is that you compute a value and then let it go unused.  C allows that, but sometimes it arises by mistake, and hence may warrant a warning.\n\nCompilers that warn about that particular issue can often be satisfied by casting the value in question to type ```\nvoid```\n.  This can be viewed as telling the compiler that you really do mean to ignore the value.  For example:\n\n```\n    (void) (\n        (DragonA == 1 && print_dragonX_sent('A')) ||\n        (DragonB == 1 && print_dragonX_sent('B')) ||\n        (DragonC == 1 && print_dragonX_sent('C')) ||\n        print_no_dragon()\n    );\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does SQL Server 2005 use short-circuit evaluation in constraints?\r\n                \r\nIf I have that constraint on a table,\n\n```\n (field1 is null and field2 is not null and dbo.expensivefunction(field2) = field3)\n```\n\n\nIf my field2 is null, is the function will be called anyway?\n\nIs \"and\" equal the meaning of (andalso, &&) in .Net in a constraint on sql server 2005?\n    ", "Answer": "\r\nSQL Server does short circuit operations, but the order of the operations depends on the optimizer so the answer is maybe.  See this blog entry.   In practice, I've used statements such as yours without problems -- probably because the optimizer puts the simpler checks first, though there isn't a guarantee.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why does Perl short circuit evaluation result in checking rvalue?\r\n                \r\nI don't understand why the following:\n\n```\nmy $err = undef;\n\nwhile(1){\n  if($err && ($err->code == 502)) {\n    [...]\n  }\n  [...]\n  eval {...}\n  $err = $@;\n}\n```\n\n\nresults in ```\nCan't call method \"code\" on an undefined value at ./filename.pl line 74.```\n in perl v5.8.8.\nIn other words: why does perl execute the second boolean expresion, even if the ```\nOP1 && OP2```\n construct cannot become true because the first operand is false (undef).\n\neven the more verbose version ```\nif( (defined $err) && ($err->code == 502))```\n produces the same result.\n\nThanks in advance :)\n    ", "Answer": "\r\nFor information, when I run your code as follows on a Perl 5.10.1 interpreter, I get no error message at all.  (This is really more a comment than an answer, only it does not fit in the comment column.  It needs no upvote.)\n\n```\n#!/usr/bin/perl\nuse warnings;\nuse strict;\nuse integer;\n\nmy $err = undef;\n\nwhile(1){\n  if($err && ($err->code == 502)) {\n    warn;\n  }\n  eval {1};\n  $err = $@;\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does the AND operator in MyBatis test expressions short-circuit during evaluation?\r\n                \r\nIs the AND keyword in test expressions in MyBatis implemented using a short-circuit? For example, I have written the following:\n\n```\n<when test=\"pagingInstruction != null\n            and pagingInstruction.direction.toString() == 'FORWARD'\">\n...\n</when>\n```\n\n\nIf the first operand resolves to false, will the second operand be ignored? (I'm using MyBatis v3.0.4.)\n    ", "Answer": "\r\nAlthough it is not stated in the reference doc that the test attribute of the when element short circuits, the reference doc includes an example that only works if the test attribute of the when element short circuits.\n\nThe example is similar to yours; here it is:\n\n... stuff\n<when test=\"author != null and author.name != null\">\n\n\nThe easiest way to resolve your question might be to create some simple unit tests to determine how myBatis treats the \"and\".\n\nAlso, you may need to test that ```\npageInstruction.direction```\n is not null before calling ```\npageInstruction.direction.toString()```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Cleanest way to assign with short circuit evaluation on multiple conditions\r\n                \r\nI am trying to build a JSON object based on data that the client has on hand.\nIdeally, it would select address data if available, then cart data if not available, otherwise null.\nHere the data is retrieved from localStorage, but I run into issues, ```\naddresses```\n and ```\ncart```\n resolve the following errors when ```\nnull```\n.\n\nCannot read property 'length' of null\nCannot read property 'idShipTo' of undefined\n\n```\nlet cart = JSON.parse(localStorage.getItem('shopping-cart'));\nlet addresses = JSON.parse(localStorage.getItem('customer-address'));\n\nthis.request = {\n  address: {\n    shipToAddLine: addresses[0].shipToAddLine || cart.shipToAddLine || null,\n    shipToCityStZip: addresses[0].shipToCityStZip || cart.shipToCityStZip || null\n  }\n}\n```\n\nI'd like to use something like the ternary operator, but use more than one if / else value.\n```\nthis.request = {\n  address: {\n    shipToAddLine: (addresses) ? addresses[0].shipToAddLine || (cart) ? cart.shipToAddLine || null,\n    shipToCityStZip: (addresses) ? addresses[0].shipToCityStZip || (cart) ? cart.shipToCityStZip || null\n  }\n}\n```\n\nIs this possible using a clean (one-line) syntax in JS, or do I have to put the assignments in if / else  blocks?\n```\nlet shipToAddLine;\nif (addresses) shipToAddLine = addresses[0].shipToAddLine;\nelse if (cart) shipToAddLine = cart.shipToCityStZip;\nelse shipToAddLine = null;\n```\n\netc...\n    ", "Answer": "\r\nYou can chain ternary operators \n\n```\n    shipToAddLine: addresses ? addresses[0].shipToAddLine : (cart ? cart.shipToAddLine : null),\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to achieve the equivalent of \"short-circuit evaluation\" in T-sql\r\n                \r\nI have this select scenario:\n\nI would like to return exact matches first, then only check for partial matches progressively, using a simple T-sql query.\n\n```\nselect * from accounts where \n   mobile = @mobile or  \n   mobile like @mobile +'%' or \n   mobile like '%'+@mobile or \n   mobile like '%'+@mobile +'%'\n```\n\n\nI understand that ```\nT-sql```\n performs All-At-Once Operations.\n\nHow best can this be achieved?\n    ", "Answer": "\r\nYou could evaluate in a CASE and provide a ranking value:\n\n```\nselect\n  mobile,\n  case \n    when mobile = @mobile             then 1  \n    when mobile like @mobile +'%'     then 2 \n    when mobile like '%'+@mobile      then 3 \n    when mobile like '%'+@mobile +'%' then 4\n  end as [Rank]\nfrom accounts where \n   mobile = @mobile or  \n   mobile like @mobile +'%' or \n   mobile like '%'+@mobile or \n   mobile like '%'+@mobile +'%'\norder by [Rank]\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit evaluation evaluating if( (a = 4) || (b = 6) || (c = 7) || (d = 8) )\r\n                \r\nThe program is posted below:\n\n```\n#include <stdio.h>\n\nint main(void)\n{\n    int a, b, c, d;\n\n    printf(\"a = %d, b = %d, c = %d, d = %d\\n\", a, b, c, d);\n\n    if( (a = 4) || (b = 6) || (c = 7) || (d = 8) )\n        printf(\"a = %d, b = %d, c = %d, d = %d\\n\", a, b, c, d);\n}\n```\n\n\nI understand the first printf statement but in the 2nd if statement I do not understand what it would evaluate when there is only one equal sign instead of two. \n\nThe output is :\n\n```\n        a = 0, b = 0, c = 32767, d = -341260496\n        a = 4, b = 0, c = 32767, d = -341260496\n```\n\n\nSo the 2nd if statement ended up being true but how?\nI thought one equal sign would be assigning a value to the variables.\n    ", "Answer": "\r\n\n  I do not understand what if would evaluate when there is only one equal sign instead of two.\n\n\nOne equal sign makes it an assignment. Hence, ```\na=4```\n evaluates to ```\n4```\n, which is interpreted as \"true\" by the logical \"OR\" operator ```\n||```\n. At this point no further evaluation is happening due to short-circuiting, so the remaining variables retain the values that they have prior to the ```\nif```\n statement.\n\nNote: Printing unassigned variables causes undefined behavior. You should change the declaration line as follows:\n\n```\nint a = 0, b = 0, c = 0, d = 0;\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit of overloaded operator && and || in C++17\r\n                \r\nI read in http://en.cppreference.com/w/cpp/language/operators:\n\n\n  The boolean logic operators, operator && and operator ||\n  \n  Unlike the\n  built-in versions, the overloads do not sequence their left operand\n  before the right one, and (until C++17) cannot implement short-circuit\n  evaluation.\n\n\n(My emphasis).\n\nCouldn't find any resource or code example for C++17 supporting short-circuit\nfor operator&& and operator||.\nIs it related to C++17 parameter pack fold expression? tried to play with it but couldn't create short circuit behavior for overloaded operator && and || with C++17 fold expression.\n\nCode:\n\n```\nclass A {\n    bool val;\npublic:\n    A(bool b) : val(b) { cout << \"A born as \" << boolalpha << val << endl;}\n    template<typename ...Args>\n    bool operator&&(Args&&... args) {\n        return (val && ... && args.val);\n    }    \n};\n\nint main() {\n    cout << boolalpha;\n    cout << ( A{false} && A{true} ) << endl;\n    cout << ( A{true} && A{false} ) << endl;\n    cout << ( A{false} && A{false} ) << endl;\n}\n```\n\n\nOutput:\n\n```\nA born as true\nA born as false\nfalse\nA born as false\nA born as true\nfalse\nA born as false\nA born as false\nfalse\n```\n\n\nhttp://coliru.stacked-crooked.com/a/f0b5325899c2fe6b\n\nNote: the sequence of left to right is also not happening in current gcc version, compiled with C++17 flag.\n    ", "Answer": "\r\nThat statement is not about short-circuit evaluation. It's about the order of evaluating the operands.\n\nPre-C++17, the order for evaluating the operands of overloaded && and || was compiler-defined. C++17 defines an explicit order of evaluation of left-to-right for && and ||, whether they are overloaded or not.\n\nShort circuit evaluation still only applies to the built-in operators.\n\nNote that on the actual page you cited, the part that is highlighted is what is applied to a specific version. That part is about the sequencing order, not the part about short-circuit evaluation.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Non lazy evaluation in while loop\r\n                \r\nHere's a snippit of code I am working with:\n\n```\nwhile(($response = $responses->fetchObject()) || ($mapping = $mappings->fetchObject())) {\n    $mapping = $mapping ? array('data' => array('#type'=>'link','#title' =>$mapping->title, '#href' => 'node/' . $mapping->nid)) : '';        \n    $response = $response ? array('data' => array('#type'=>'link','#title' =>$response->title, '#href' => 'node/' . $response->nid)) : '';  \n}\n```\n\n\nBecause PHP does short circuit evaluation, $mapping doesn't get assigned anything if $response does.\n\nHow can I write this so that both $response and $mapping are assigned something in the while loop?\n    ", "Answer": "\r\nThis is my solution right now:\n\n```\nwhile(true) {\n    $response = $responses->fetchObject();\n    $mapping = $mappings->fetchObject();\n\n    if(!$response && !$mapping) {\n        break;\n    }\n}\n```\n\n\nBut I feel there must be a nicer way?\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How is js logical AND short-circuit evaluated?\r\n                \r\nI find this code from https://www.google-analytics.com/analytics.js\n\n```\n(O.gaData = O.gaData || {}).expId && a.set(Nc, (O.gaData = O.gaData || {}).expId);\n(O.gaData = O.gaData || {}).expVar && a.set(Oc, (O.gaData = O.gaData || {}).expVar);\n```\n\n\nWith my common sense, the left part will be evaluated first and only if it's true, then the right part will be evaluated. So ```\nO.gaData```\n will always be ready on the right part.\n\nAm I missing something?\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit operator for JSF(P) EL\r\n                \r\nAre there short circuit operators for Expression Language used in JSF, JSP?\n\nI mean  ```\n&&```\n,```\n||```\n Java analog,when if it's obvious that further evaluation of boolean has no sense, that evaluation is stopped.\n\nI observed usage of ```\nand```\n, ```\nor```\n operators  and looks like they're not short circuit.\n    ", "Answer": "\r\nIt are definitely short circuit operators. \n\n```\n#{bean.left or bean.right}\n```\n\n\nThe right hand won't be evaluated when the left hand evaluates true.\n\n```\n#{bean.left and bean.right}\n```\n\n\nThe right hand won't be evaluated when the left hand evaluates false.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why short circuit logical operator is supposed to be faster\r\n                \r\nThis question is not about optimizing code, but its a technical question about performance difference of short circuit logical operators and normal logical operators which may go down to how they are performed on hardware level.\n\nBasically logical ```\nAND```\n and ```\nOR```\n takes one cycle whereas short circuit evaluation uses branching and can take various amount of cycles. Now I know that branch predictors can make this evaluation efficient but I don't see how its faster than 1 cycle?\n\nYes, if right operand is something expensive then trying to not evaluate it is beneficial. but for simple conditions like ```\nX & (Y | Z)```\n, assuming these are atomic variables, non short circuit logical operators would perform likely faster. Am I right?\n\n\n\nI assumed that short circuit logical operators use branching (no official source, just self thought), because how else you make those jumps while executing instructions in order?\n    ", "Answer": "\r\nThis is very late but since this hasn't been answered yet (...), I'm going to have a go at it.\nYou already pointed out the branch prediction, which is inherently true.\nThere are also other hardware related issues on modern hardware, which are mostly related to instruction level parallelism and operational interdependencies.\nA short circuit operator requires A and THEN B to be evaluated and B not to be evaluated in case a is false. This leads us back to branches and CPU pipeline flushes due to speculative execution. This can get/gets more costly the more conditions need to be checked in succession. On the other hand, this can get cheaper with non-short circuit operations, since CPUs can evalutate \"many\" instructions in the same clock cycle, thanks to multiple physical ALUs/FPUs/AGUs etc. being present.\nAnd to drive this point home lets look at the simplest case in Assembly:\n```\na && b: \n\ncmp    a, 0\njne    LABEL_A\n---more code---\nLABEL_A:\ncmp    b, 0\njne    RETURN_LABEL\n ---more code--- \n```\n\nas opposed to... (assuming instructions like setb were used to clamp to [0, 1])\n```\na & b \n\nand   a, a, b\ncmp   a, 0\njne   RETURN_LABEL\n---more code---\n```\n\nThis should be self-evident in the resulting assembly itself.\nBut yes, you are right in saying that you should definitely use short-circuiting to avoid expensive calculation B in case A is false. But even then the CPU might speculatively execute the test for B anyway. So basically, very simply said, you can \"only make things worse by using short circuiting operators(sic!!!!!)\".\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does PostgreSQL short-circuit its BOOL_OR() evaluation?\r\n                \r\n```\nEXISTS```\n is faster than ```\nCOUNT(*)```\n because it can be short-circuited\n\nA lot of times, I like to check for existence of things in SQL. For instance, I do:\n\n```\n-- PostgreSQL syntax, SQL standard syntax:\nSELECT EXISTS (SELECT .. FROM some_table WHERE some_boolean_expression)\n\n-- Oracle syntax\nSELECT CASE \n  WHEN EXISTS (SELECT .. FROM some_table WHERE some_boolean_expression) THEN 1 \n  ELSE 0 \nEND\nFROM dual\n```\n\n\nIn most databases, ```\nEXISTS```\n is \"short-circuited\", i.e. the database can stop looking for rows in the table as soon as it has found one row. This is usually much faster than comparing ```\nCOUNT(*) >= 1```\n as can be seen in this blog post.\n\nUsing ```\nEXISTS```\n with ```\nGROUP BY```\n\n\nSometimes, I'd like to do this for each group in a ```\nGROUP BY```\n query, i.e. I'd like to \"aggregate\" the existence value. There's no ```\nEXISTS```\n aggregate function, but PostgreSQL luckily supports the ```\nBOOL_OR()```\n aggregate function, like in this statement:\n\n```\nSELECT something, bool_or (some_boolean_expression)\nFROM some_table\nGROUP BY something\n```\n\n\nThe documentation mentions something about ```\nCOUNT(*)```\n being slow because of the obvious sequential scan needed to calculate the count. But unfortunately, it doesn't say anything about ```\nBOOL_OR()```\n being short-circuited. Is it the case? Does ```\nBOOL_OR()```\n stop aggregating new values as soon as it encounters the first ```\nTRUE```\n value?\n    ", "Answer": "\r\nIf you want to check for existence, I'm generally using a ```\nLIMIT```\n/```\nFETCH FIRST 1 ROW ONLY```\n query:\n\n```\nSELECT .. FROM some_table WHERE some_boolean_expression\nFETCH FIRST 1 ROW ONLY\n```\n\n\nThis generally stops execution after the first hit.\n\nThe same technique can be applied using ```\nLATERAL```\n for each row (group) from another table.\n\n```\nSELECT * \n  FROM (SELECT something\n          FROM some_table\n         GROUP BY something\n       ) t1\n  LEFT JOIN LATERAL (SELECT ...\n                        FROM ...\n                       WHERE ...\n                       FETCH FIRST 1 ROW ONLY) t2\n    ON (true)\n```\n\n\nIn ```\nt2```\n you can use a ```\nWHERE```\n clause that matches any row for the group. It's executed only once per group and aborted as soon as the first hit was found. However, whether this performs better or worse depends on your search predicates and indexing, of course.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short Circuit of If Statement - How to evaluate\r\n                \r\nUpdate:  This was all a wild goose chase.  After I made the changes based on a suggested answer, it worked.  However, when I tried it a bit later, it didn't work again.  What I've come to realize is it was all in how I was using the debugger.  I had a breakpoint inside areSameColor.  I assumed areUniqueColors wasn't being executed when I was stepping through the code.  However, I was stepping over the second condition and I assumed it was short-circuiting.  In the end, it was correctly evaluating with both options below.  I chose to stick with my 2nd example as it seemed more readable.  Thanks for everyone's time.\n\nI'm confused at how the following if statement is evaluating...\n\n```\n    if(![self areSameColor:setCards] && ![self areUniqueColors:setCards]){\n    match = NO;\n}\n```\n\n\nin my test case [self areSameColor:setCards] evaluates to NO...so using ! I would expect it to evaluate the 2nd condition.  When watching the debugger, it seems to be shortcutting into a TRUE result.\n\nI also tried with this:\n\n```\nif(!([self areSameColor:setCards] || [self areUniqueColors:setCards])){\n    match = NO;\n}\n```\n\n\nIn both cases it's not evaluating the 2nd condition.  areSameColor and areUniqueColor return BOOL.\n\nMy expected evaluation...\n\n```\nareSameColor | areUniqueColor | MATCH\nNO | NO | match = NO\nYES | NO | match UNCHANGED\nNO | YES | match UNCHANGED\n```\n\n\nHow am I thinking of this wrong?\n    ", "Answer": "\r\nFor this \"areSameColor == NO and areUniqueColor == NO\"\ntry this way\n\n```\nif( (![self areSameColor:setCards]) && (![self areUniqueColors:setCards]) )\n{\n    match = NO;\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to avoid short-circuited evaluation in JavaScript?\r\n                \r\nI need to execute both sides of an ```\n&&```\n statement, but this won't happen if the first part returns ```\nfalse```\n. Example:\n\n```\nfunction doSomething(x) {\n    console.log(x);\n}\n\nfunction checkSomething(x) {\n    var not1 = x !== 1;\n    if (not1) doSomething(x);\n\n    return not1;\n}\n\nfunction checkAll() {\n    return checkSomething(1)\n        && checkSomething(3)\n        && checkSomething(6)\n}\n\nvar allValid = checkAll(); // Logs nothing, returns false\n```\n\n\nThe problem here is that ```\ndoSomething(x)```\n should log 3 and 6, but because ```\ncheckSomething(1)```\n returns ```\nfalse```\n, the other checks won't be called. What is the easiest way to run all the checks and return the result?\n\nI know I could save all the values in variables and check those subsequently, but that does not look very clean when I have a lot of checks. I am looking for alternatives.\n    ", "Answer": "\r\nUse a single &.  That is a bitwise operator.  It will execute all conditions and then return a bitwise sum of the results. \n\n```\n function checkAll() {\n    return checkSomething(1)\n      & checkSomething(2)\n      & checkSomething(3)\n }\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Can I rely on short-circuit evaluation to check vector bounds in C++?\r\n                \r\nIs the following code acceptable?\n\n```\nif(vector.size() > 0 && vector[0] == 3) {\n}\n```\n\n\nOr is there a chance that it will crash when the vector is empty? I haven't noticed this happening, but I'm worried that it's still possible.\n    ", "Answer": "\r\nYes, you can rely on the builtin operator ```\n&&```\n to short-circuit. That's part of its specification.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Oracle CASE short-circuit not working in group by\r\n                \r\nI've found in the documentation of case statment that it uses short-circuit:\n\n\n  Oracle Database uses short-circuit evaluation. That is, for a simple\n  CASE expression, the database evaluates each comparison_expr value\n  only before comparing it to expr, rather than evaluating all\n  comparison_expr values before comparing any of them with expr.\n  Consequently, Oracle never evaluates a comparison_expr if a previous\n  comparison_expr is equal to expr. For a searched CASE expression, the\n  database evaluates each condition to determine whether it is true, and\n  never evaluates a condition if the previous condition was true.\n\n\nBut the following SQL is returning ```\ndivisor is equal to zero```\n:\n\n```\nWITH data AS (SELECT 1 AS cond, 10 AS num, 0 AS div FROM DUAL)\nSELECT\n  CASE WHEN cond = 2 THEN (CASE WHEN MAX(div) = 0 THEN 0 ELSE SUM(num / div) END)\n       ELSE -1\n  END AS result\nFROM data\nGROUP BY cond\n```\n\n\nAny solution to avoid ```\ndivisor is equal to zero```\n error?\n\nEDIT\n\nThis query works fine:\n\n```\nWITH data AS (SELECT 1 AS cond, 10 AS num, 0 AS div FROM DUAL)\nSELECT\n  CASE WHEN cond = 2 THEN (CASE WHEN MAX(div) = 0 THEN 0 ELSE 1 END)\n       ELSE -1\n  END AS result\nFROM data\nGROUP BY cond\n```\n\n    ", "Answer": "\r\nUse\n\n```\nCASE WHEN cond = 2 \n     THEN SUM(case when div = 0 then 0 else num / div end)\n     ELSE -1\nEND\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What's the AHK equivalent of one-line logical OR short-circuit evaluation?\r\n                \r\nFor example, in JavaScript, the following code would log ```\nfoo```\n:\n```\nfalse || console.log('foo')\n```\n\nHow to achieve the same logic in one line in AutoHotkey?\n    ", "Answer": "\r\nThe same is possible in ahk.\nI'm guessing a problem you might be facing is if you tried to use normal commands with it. It's not possible you'd have to be calling functions.\nIf the thing you want to call is a command you might need to make a custom function to wrap it and be able to use it as function.\n(Ahk v2 would be more comfortable to use in this regard but it's still in beta.)\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C++ 'AND' evaluation - standard guaranteed? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Safety concerns about short circuit evaluation  \n\n\n\n\nWhat does the standard say about evaluating ```\n&&```\n expressions - does it guarantee that evaluation of parameters will stop at the first ```\nfalse```\n?\n\nE.g.:\n\n```\nFoo* p;\n//....\nif ( p && p->f() )\n{\n    //do something\n}\n```\n\n\nis the ```\nf()```\n guaranteed not to be called if ```\np == NULL```\n?\n\nAlso, is the order of evaluation guaranteed to be the order of appearence in the clause?\n\nMight the optimizer change something like:\n\n```\nint x;\nFoo* p;\n//...\nif ( p->doSomethingReallyExpensive() && x == 3 )\n{\n    //....\n}\n```\n\n\nto a form where it evaluates ```\nx==3```\n first? Or will it always execute the really expensive function first?\n\nI know that on most compilers (probably all) evaluation stops after the first ```\nfalse```\n is encountered, but what does the standard say about it?\n    ", "Answer": "\r\n\n  What does the standard say about evaluating && expressions - does it guarantee that evaluation of parameters will stop at the first false?\n\n\nYes. That is called short-circuiting. \n\n\n  Also, is the order of evaluation guaranteed to be the order of appearence in the clause?\n\n\nYes. From left to right. The operand before which the expression short-circuited doesn't get evaluated.\n\n```\nint a = 0;\nint b = 10;\nif ( a != 0 && (b=100)) {}\n\ncout << b << endl; //prints 10, not 100\n```\n\n\nIn fact, the above two points are the keypoint in my solution here:\n\n\nFind maximum of three number in C without using conditional statement and ternary operator\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Can Oracle PL/SQL evaluate an integer as a boolean value?\r\n                \r\nGiven ```\nv_ssn_ind INTEGER := IF TRIM(p_ssn) IS NULL THEN 0 ELSE 1 END IF;```\n\n\nI know I can do this:  ```\nIF v_ssn_ind=1 THEN…```\n\n\nBut can I do short-circuit evaluation, ie: ```\nIF v_ssn_ind THEN…```\n ?\n    ", "Answer": "\r\nFirst off, what you are talking about does not appear to have anything to do with short-circuit evaluation.  Short-circuit evaluation would be when code like\n\n```\nIF( quick_condition AND slow_condition )\nTHEN\n  <<do something>>\nEND IF;\n```\n\n\nevaluates the second slow condition if and only if the initial quick condition evaluates to TRUE.\n\nSecond, your assignment of a value to ```\nv_ssn_ind```\n is not syntactically valid.\n\nThird, no, you cannot say\n\n```\nIF <<integer variable>>\nTHEN\n```\n\n\nbecause that would not make sense.  What value would evaluate to TRUE and what value would evaluate to FALSE?  If 0 is FALSE and 1 is TRUE, for example, what would 17 translate to?\n\nIf you are declaring some sort of indicator variable, it would generally make sense to use a ```\nBOOLEAN```\n data type rather than an integer.  If you use a boolean, then you can do \n\n```\nIF <<boolean variable>>\nTHEN\n```\n\n\nbecause that eliminates the ambiguity.  This won't be any faster than adding the ```\n= TRUE```\n to your IF condition however.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Can C/C++ optimizers decide to lazily evaluate values that are only used in a short-circuit evaluation?\r\n                \r\nI like to refactor complicated conditionals like this:\n\n```\nif (foo(blah) || (bar(param1, param2, param3) && !obj.longMethodName())) ...\n```\n\n\ninto this:\n\n```\nbool foo_true = foo(blah);\nbool bar_true = bar(param1, param2, param3);\nbool long_true = obj.longMethodName();\n\nif (foo_true || (bar_true && !long_true)) ...\n```\n\n\nI think this makes the code a lot easier to understand, and it helps with debugging because you can see the intermediate results used to compute the final condition.\n\nBut: in the original code, due to short circuiting, ```\nbar```\n will only be evaluated if ```\nfoo```\n returns ```\ntrue```\n, and ```\nlongMethodName```\n only if ```\nbar```\n returns ```\ntrue```\n.\n\nAssume that functions are \"pure\", methods are ```\nconst```\n, and the compiler can see the function bodies of everything.  Are C++ optimizers allowed to defer evaluating my intermediate values until they are needed?\n    ", "Answer": "\r\nOf course.  Provided the compiler can see enough to determine\nthat ```\nfoo```\n, ```\nbar```\n and ```\nobj.longMethodName()```\n don't have any\nother impact on the observable behavior of your code.\n\nWhether any compilers do is another question.  I rather doubt\nit; it would require some very special logic, which isn't in the\nusual list of optimization techniques, for something that\npractically nobody does.  (I suspect that most programmers would\nfind the original version, formatted correctly, to be more\nreadable than the one with a lot of extra variables.)  \n\nEDIT:\n\nI wonder if it's worth pointing out that the compiler is allowed\nto call all three functions even if the if is written:\n\n```\nif ( foo( blah ) || (bar( p1, p2, p3 ) && ! obj.lMN() ) )\n```\n\n\n(Although I can't imagine one that would.)  The standard makes\nno requirements with regards to which functions are called when;\nit only requires that the observable behavior be the same (same\nvalues and in the same order---no guarantees with regards to\ntime) \"as if\" the formal semantics of the program were followed.\nAnd the only things that count as observable behavior is IO\n(in some form) and accesses to volatile objects.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why do `any` and `all` not appear to use short-circuit evaluation here?\r\n                \r\nDoes ```\nall()```\n return False right after finding a False in a sequence?\nTry to run this code:\n```\ndef return_true():\n    print('I have just been printed')\n    return True\n\nprint(all((False, return_true())))\n```\n\nAs you can see, ```\nI have just been printed```\n is printed even though there is False before it.\nAnother example:\n```\ndef return_false():\n    print('I have just been printed')\n    return False\n\nprint(any((True, return_false())))\n```\n\nIn this case, ```\nI have just been printed```\n is printed in this code even though there is True before.\n    ", "Answer": "\r\nYes, ```\nall()```\n and ```\nany()```\n both short circuit the way you describe. ```\nall()```\n will return early if any item is false-y, and ```\nany()```\n will if any item is truthy.\nThe reason you're seeing the printouts is because ```\nreturn_true()```\n and ```\nreturn_false()```\n are being called before ```\nall```\n and ```\nany```\n are even invoked. They must be. A function's arguments have to be evaluated before the function is called, after all.\nThis:\n\n```\nprint(all((False, return_true())))\n```\n\n\nis equivalent to:\n```\nx = return_true()\nprint(all((False, x)))\n```\n\ni.e. ```\nreturn_true()```\n is evaluated unconditionally.\nTo get the desired short-circuiting behavior, the sequence itself needs to be evaluated lazily. One simple way to do this is to make an iterable, not of the values we want to test, but of things we can call to get those values; and then use a generator expression to create a sequence that lazily calls them. See also.\nHere, that might look like:\n```\nprint(all(\n    x()\n    for x in (lambda: False, return_true)\n))\n\nprint(any(\n    x()\n    for x in (lambda: True, return_false)\n))\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C++ Variadic template AND and OR\r\n                \r\nCan you use C++11 variadic templates to complete ```\n/* ??? */```\n in:\n\n```\ntemplate<bool...v> struct var_and { static bool constexpr value = /* ??? */; };\n```\n\n\nso that ```\nvar_and<v...>::value```\n provides ```\n&&```\n over the boolean pack ```\nv```\n at compile-time?\n\nCan you do the same for ```\nstruct var_or<v...>```\n for ```\n||```\n?\n\nCan you use short-circuit evaluation (in both cases)?\n\nEdit: An update to the accepted answer added that C++17 fold expressions enable\n\n```\ntemplate<bool... v> constexpr bool var_and = (v && ...);\ntemplate<bool... v> constexpr bool var_or  = (v || ...);\n```\n\n\nIt seems that, for parameter pack-based approaches, only a restricted type of \"short-circuit evaluation\" is possible: while instantiating ```\nvar_or<true,foo(),bar()>```\n only calls ```\n||```\n once, it also calls both ```\nfoo```\n and ```\nbar```\n.\n    ", "Answer": "\r\nYou don't want ```\nvalue```\n to be a typedef.\n\n```\ntemplate<bool head, bool... tail>\nstruct var_and {\n    static constexpr bool value = head && var_and<tail...>::value;\n};\n\ntemplate<bool b> struct var_and<b> {\n    static constexpr bool value = b;\n};\n```\n\n\nObviously the same can be done for ```\n||```\n.\n\nShort circuit evaluation doesn't matter because this only deals with constant expressions which won't have any side effects.\n\nHere's another method which stops recursively generating types as soon as it find a false value, emulating a kind of short circuiting:\n\n```\ntemplate<bool head, bool... tail>\nstruct var_and { static constexpr bool value = false; };\n\ntemplate<bool... tail> struct var_and<true,tail...> {\n    static constexpr bool value = var_and<tail...>::value;\n};\n\ntemplate<> struct var_and<true> {\n    static constexpr bool value = true;\n};\n```\n\n\n\n\nUpdate for C++17: Using a fold expression makes this much simpler.\n\n```\ntemplate<bool...v> struct var_and {\n    static constexpr bool value = (v && ...);\n};\n```\n\n\nOr also using a template variable as enobayram suggests:\n\n```\ntemplate<bool... b> constexpr bool var_and = (b && ...);\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Misordered find query on mongo DB native javascript driver leads to degraded short-circuit evaluation performance\r\n                \r\nI encountered a problem on MongoDB javascript native driver.\nWhen I use the $and operator, the evaluation order is not as the same as I expected, even if I explicitly specify it.\nThe $and evaluation order is important because I have one filter which is easy to evaluate, and another much more difficult to evaluate, I want the easier one to be executed first to narrow down the search.\nConsider the query below:\n```\ncollection.find({\n    c: false,\n    $or: [{ a: \"1\" }, { b: \"1\" }],\n});\n```\n\nwhen I call explain():\n```\n        \"parsedQuery\": {\n        \"$and\": [\n            {\n                \"$or\": [\n                    {\n                        \"a\": {\n                            \"$eq\": \"1\"\n                        }\n                    },\n                    {\n                        \"b\": {\n                            \"$eq\": \"1\"\n                        }\n                    }\n                ]\n            },\n            {\n                \"c\": {\n                    \"$eq\": false\n                }\n            }\n        ]\n    }\n```\n\nI wanted the {c: false} filter to be executed first, but { $or: [{ a: \"1\" }, { b: \"1\" }]} is executed first instead.\nI think this is because javascript dictionary doesn't preserve order, so I tried the second time to explicitly give it an array under the $and operator:\n```\ncollection.find({\n    $and: [{ c: false }, { $or: [{ a: \"1\" }, { b: \"1\" }] }],\n});\n```\n\nand call explain():\n```\n        \"parsedQuery\": {\n        \"$and\": [\n            {\n                \"$or\": [\n                    {\n                        \"a\": {\n                            \"$eq\": \"1\"\n                        }\n                    },\n                    {\n                        \"b\": {\n                            \"$eq\": \"1\"\n                        }\n                    }\n                ]\n            },\n            {\n                \"c\": {\n                    \"$eq\": false\n                }\n            }\n        ]\n    }\n```\n\nThe result is the same, {c: false} is still evaluated after {$or: [{ a: \"1\" }, { b: \"1\" }]}\nI tried to input my query directly into Mongo Compass and it doesn't have this problem. So I guess it's the MongoDB javascript driver doing this rearrangement.\nAny idea on this issue?\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Reason for the existence of non-short-circuit logical operators\r\n                \r\nWhen used with ```\nboolean```\n operands, ```\n&```\n and ```\n|```\n become logical operators per Section 15.22.2 of the JLS. Unlike ```\n&&```\n and ```\n||```\n, however, these don't short-circuit; they always evaluate both sides. I have a silly question: Why are the less-efficient non-short-circuit logical operators (```\n&```\n, ```\n|```\n) still there, when we have the more-efficient short-circuit logical operators (```\n&&```\n, ```\n||```\n)? I mean, what is the real usage of the non-short-circuit logical operators, as opposed to with the short-circuit logical operators? In other words, what is the usage of always evaluating both sides by using the non-short-circuit logical operators?\n    ", "Answer": "\r\nUpdated answer:\n\nApologies, I missed the word \"logical\" in your question even though it is there. (I've taken the liberty of emphasizing it a bit with an edit.)\n\nConsider the case where you want any side-effects to always occur, regardless of whether the left-hand expression evaluates ```\ntrue```\n or ```\nfalse```\n. E.g., contrast:\n\n```\nif (foo() & bar()) {\n    // Only call this if both operations returned true\n}\n```\n\n\nwith\n\n```\nif (foo() && bar()) {\n    // Only call this if both operations returned true\n}\n```\n\n\nLet's assume both ```\nfoo```\n and ```\nbar```\n have effects that we want to have happen regardless of whether ```\nfoo```\n returns ```\ntrue```\n or ```\nfalse```\n. In the first one above, I know that ```\nbar```\n will always get called and have its effect. In the latter, of course, ```\nbar```\n may or may not get called. If we didn't have the non-short-circuit version, we'd have to use temporary variables:\n\n```\nboolean fooResult, barResult;\nfooResult = foo();\nbarResult = bar();\nif (fooResult && barResult) {\n    // ...\n}\n```\n\n\nYou might argue (I probably would) that you should do that anyway, because it's way too easy to misread ```\nif (foo() & bar())```\n, but there we go, a pragmatic reason for having non-short-circuit versions.\n\nOriginal answer:\n\nHow would you propose ```\n&```\n (or ```\n|```\n) be a short-circuited operator? With ```\n&&```\n and ```\n||```\n, it makes sense because you're dealing with boolean conditions: They can be true or false, there are no shades of grey. But ```\n&```\n and ```\n|```\n deal with bits, not booleans. The result is a number. I mean, I guess ```\n&```\n could not evaluate the right-hand side if the left-hand side were ```\n0```\n, and similarly ```\n|```\n could not evaluate it if the left-hand side were all-bits-on for whatever the type was, but I don't see much point to making the one edge case of each operator significant (as compared to the 254 or more other cases).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Python precedence rules for boolean operators [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Priority of the logical operators (order of operations) for NOT, AND, OR in Python\r\n                            \r\n                                (8 answers)\r\n                            \r\n                    \r\n                Closed 6 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nWhen I evaluate the following expression:\n\n1 or (1/0) and 1\n\nWhat are the rules (precedence, short-circuit evaluation etc) are followed to get the answer\n    ", "Answer": "\r\n```\nb or anything_else```\n is defined to return b if b is true-ish, without evaluating anything_else. Since your first 1 is true-ish, your 1/0 never gets evaluated, hence no error. By \"true-ish\" I mean any value that Python considers true, not only the ```\nTrue```\n boolean value. Try your expression with True or [2] in place of the first 1 to see what I mean.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Precendence in C++ if-statements [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Is Short Circuit Evaluation guaranteed In C++ as it is in Java?\n  How does C++ handle &&? (Short-circuit evaluation)  \n\n\n\n\nI have the following struct definition and a particular use case:\n\n```\nstruct foo\n{\n   bool boo;\n};\n\nint main()\n{\n  foo* f = 0;\n   .\n   .\n   .\n  if ((f) && (f->boo)) // <--- point of contention\n   return 0\n  else\n   return 1;\n}\n```\n\n\nDoes the standard guarantee that the first set of braces in the if-statement above will always be evaluated before the second?\n\nIf it doesn't what is the best what to rewrite the above bit of code? \n\nCurrently I have the following mess:\n\n```\nif (f)\n{\n   if (f->boo)\n      return 0;\n   else\n      return 1;\n}\nelse\n   return 1;\n```\n\n    ", "Answer": "\r\nIt may be a matter of style but you could say:\n\n```\nreturn (f && f->boo);\n```\n\n\n...or to be slightly more explicit:\n\n```\nreturn ((f && f->boo) ? 1 : 0);\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do Kusto Queries Support Short-Circuit (McCarthy) Evaluation\r\n                \r\nI am trying to use the following query fragment to allow for variable regex filter inputs.\n```\n| where isempty(\"[[HttpStatusCode]]\") or tostring(httpStatus_d) matches regex \"[[HttpStatusCode]]\"\n```\n\nThe query is being executed in Azure Log Analytics from within Grafana. I have variables on the Grafana dashboard that allow the user to input a regex expression that feeds into the query. When the filter is empty, I expect no filtering to be applied. I was thinking the Kusto queries may support short-circuiting and when ```\nisempty(..)```\n evaluated as true, then the remainder of the expression would be ignored and the ```\nmatches regex```\n portion would not execute nor throw an error.\nThe error message I get when the string is empty is \"Relop semantic error: 'matches regex' has the following semantic error: SEM0031: matches regex: argument 2 must be a constant non empty string value.\"\n    ", "Answer": "\r\nKusto does not have the short-circuit feature. But you can try the workaround below.\nFirst, you need to check if ```\n[[HttpStatusCode]]```\n is empty or not. If it's empty, you can assign a dummy value to it(Note, please make sure the dummy value cannot be matched by ```\nmatches regex```\n operator in the where cluase). As a result, it will not throw any error when input an empty value.\nSample query:\n```\ntable_name \n| extend tempvalue= iff(isempty(\"[[HttpStatusCode]]\"),\"a dummy value\",\"[[HttpStatusCode]]\")\n| where isempty(\"[[HttpStatusCode]]\") or tostring(httpStatus_d) matches regex tempvalue\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why does this short circuit evaluation return undefined if first value is false?\r\n                \r\nI have an example similar to this where the first expression evaluates to false and the second is undefined but the overall expression returns undefined into valueResult, shouldn't the first false value terminate the check and return false?\n```\nvalueResult = false && 10 === 5 ? 'match' : undefined\n```\n\nI have added console log statements and a debugger and this is what is happening, however when I do false && undefined on the browser console, it returns false.\n    ", "Answer": "\r\nIn your updated example, the logical AND ```\n… && …```\n has a higher order of precedence (5) than the evaluation of the ternary ```\n… ? … : …```\n (3).\nCheck out the table on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to chain multiple \"or\" or \"and\" statements in ramda and preserve short-circuit evaluation?\r\n                \r\nI would like to filter an array of posts against a user defined text. Each post has an ```\nid```\n and a ```\ntext```\n property which should be searched. If the search-text is an empty string all posts should obviously be displayed - no need to check if the other predicates resolve to true. Currently I'm doing something like this:\n\r\n\r\n```\nconst hasText = R.curry((text, post) => R.reduce(R.or, false, [\n    R.equals(\"\", text),\n    R.includes(text, post.text),\n    R.includes(text, post.id.toString())\n]))\n\nconst posts = [{id: 1, text: \"a\"},{id: 2, text: \"b\"},{id: 3, text: \"c\"}]\n\nconsole.log(R.filter(hasText(\"b\"), posts));```\n\r\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/ramda/0.27.1/ramda.min.js\"></script>```\n\r\n\r\n\r\n\nThe problem here is that all of the predicates are evaluated upfront even though that is unneccessary.\nIs it possible to achieve the same effect as using plain ```\n||```\n in a more functional way using ramda?\n    ", "Answer": "\r\nIf the text is an empty string, you don't need to filter the array at all. To check if any of the predicates is truthy, you can use R.any:\n\r\n\r\n```\nconst { curry, pipe, prop, toString, includes, filter, anyPass, isEmpty } = R\n\n// check if prop includes text\nconst propIncludes = curry((key, text) => pipe(prop(key), toString, includes(text)))\n\n// filter an array of posts, and check if any of the prop contains the text\nconst hasText = curry((text, posts) => filter(anyPass([\n  propIncludes('text', text),\n  propIncludes('id', text),\n]))(posts))\n\n// skips filtering if text is empty\nconst checkText = curry((text, posts) => isEmpty(text) ? posts : hasText(text, posts))\n\nconst posts = [{id: 1, text: \"a\"},{id: 2, text: \"b\"},{id: 3, text: \"c\"}]\n\nconst result = checkText('b', posts)\n\nconsole.log(result);```\n\r\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/ramda/0.27.1/ramda.min.js\"></script>```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "JavaScript Short-Circuit Variable Assignment with Commas\r\n                \r\nI am reviewing some code for a JavaScript widget that I downloaded and there is a variable assignment similar to the following: \n\n```\nvar a = a.something || a.somethingElse, c, d, e, f, g;\n```\n\n\nWhat I am wondering is if this is equivalent to this:\n\n```\nvar a = a.something || a.somethingElse;\nvar c, d, e, f, g;\n```\n\n\nor this:\n\n```\nvar a = a.something || a.somethingElse || c || d || e || f || g;\n```\n\n\nI have been reading up on short-circuit evaluation and assignments, and I understand that the first part is saying: \n\n```\nif ( a.something != (null or 0 or false)) {\n    a = a.something;\n} else {\n    a = a.somethingElse;\n}\n```\n\n\nbut I cannot seem to find any resources that use an example like this one. \n\n\nThanks, for your help!\n    ", "Answer": "\r\nYour understanding is correct. A comma seperated list in a var statement is treated like individual Ines.\n\nAs for the boolean OR statement: If the first expression is falsy, the second will be used. You can add more, as in your third example.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Can the compiler/JIT optimize away short-circuit evaluation if there are no side-effects?\r\n                \r\nI have a test which goes:\n\n```\nif(variable==SOME_CONSTANT || variable==OTHER_CONSTANT)\n```\n\n\nIn this circumstances, on a platform where branching over the second test would take more cycles than simply doing it, would the optimizer be allowed to treat the ```\n||```\n as a simple ```\n|```\n?\n    ", "Answer": "\r\n\n  In this circumstances, on a platform where branching over the second test would take more cycles than simply doing it, would the optimizer be allowed to treat the || as a simple |?\n\n\nYes, that is permitted, and in fact the C# compiler will perform this optimization in some cases on ```\n&&```\n and ```\n||```\n, reducing them to ```\n&```\n and ```\n|```\n. As you note, there must be no side effects of evaluating the right side. \n\nConsult the compiler source code for the exact details of when the optimization is generated.\n\nThe compiler will also perform that optimization when the logical operation involves lifted-to-nullable operands. Consider for example\n\n```\nint? z = x + y;\n```\n\n\nwhere x and y are also nullable ints; this will be generated as\n\n```\nint? z;\nint? temp1 = x;\nint? temp2 = y;\nz = temp1.HasValue & temp2.HasValue ? \n  new int?(temp1.GetValueOrDefault() + temp2.GetValueOrDefault()) :\n  new int?();\n```\n\n\nNote that it's ```\n&```\n and not ```\n&&```\n. I knew that it is so fast to call ```\nHasValue```\n that it would not be worth the extra branching logic to avoid it.\n\nIf you're interested in how I wrote the nullable arithmetic optimizer, I've written a detailed explanation of it here: https://ericlippert.com/2012/12/20/nullable-micro-optimizations-part-one/\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "how to conditionally assign variable - nunjucks\r\n                \r\nI want to assign the variable that's exists and not ```\nundefined```\n like how the short-circuit evaluation is done in Javascript\n\n```\n<label for=\"dummy-xyz\">{{ data.dummy.id || dummy.id }}</label>\n```\n\n\nI'm unable to do it with the ```\n||```\n operator however\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does SQL Server short-circuit IF statements?\r\n                \r\nI am working on optimizing some heavily used stored procedures and ran across a scenario that raised a question that I couldn't find any answers for: when evaluating TSQL in a stored procedure, does SQL Server short-circuit the ```\nIF```\n statement?\n\nFor example, assume a stored procedure has code similar to:\n\n```\nIF @condition1 = 1\nOR EXISTS(SELECT 1 FROM table1 WHERE column1 = @value1)\n...\n```\n\n\nIn this scenario does SQL Server short-circuit the evaluation such that the ```\nEXISTS```\n statement is never executed when the preceding clause evaluates to true? \n\nIf it never or only sometimes does, then we have some rewriting ahead of us.\n    ", "Answer": "\r\nEven if it appears to work, it should not be relied upon. The CASE statement is the only thing that the documentation states as being short-circuiting, but even that isn't (or at least wasn't) always the case (hee hee). Here is one bug that was fortunately fixed as of SQL Server 2012 (see the comments).\n\nIn addition to the rabbit hole (an interesting one, for sure) of links in comments from the comment posted by @Martin on the question, you should also check out this article:\n\nUnderstanding T-SQL Expression Short-Circuiting\n\nand the discussion forum related to that article.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Assign value if previous is empty in PowerShell\r\n                \r\nIs there a way in PowerShell to do a simple short-circuit evaluation for a variable to take first value or second, if first is empty ?\nLike in JS:\n```\nlet x = '';\nlet y = '1';\nlet z = x || y; // '1'\n```\n\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "ARMAssembly short-circuit program\r\n                \r\nI am attempting to write a program in ARMAssembly language and I am having difficulties right from the beginning. I am trying to write a program that will do a short-circuit evaluation of the following complex conditional:\nif ((x > y && y > z) || (y < z && y < x)). I understand that I to put x, y, and z into r1, r2, and r3 but I am getting confused by syntax and everything else. Assistance would be much appreciated. \n    ", "Answer": "\r\nThe way to solve these sorts of problems is to rewrite your C input such that each C statement corresponds to a single assembler instruction.\n\nHere's the original C code:\n\n```\n if ((x > y && y > z) || (y < z && y < x)) {\n   true-action;\n } else {\n   false-action;\n }\n```\n\n\nHere's the re-written C code:\n\n```\n   bool xgty = x > y;\n   if (xgty) goto L1;\n   bool ygtz = y > z;\n   if (!ygtz) goto false-action;\nL1:\n   bool yltz = y < z;\n   if (!yltz) goto false-action;\n   bool yltx = y < x;\n   if (!yltx) goto false-action;\ntrue-action:\n   ...\n   goto done;\nfalse-action:\n   ...\ndone:\n```\n\n\nTranslating this into assembler should be trivial.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why is false && false || true evaluated to true?\r\n                \r\nI understood that in short-circuit valuation if the initial value is ```\nfalse```\n followed by an ```\n&&```\n then the expression short-circuits and the expression is evaluated to ```\nfalse```\n.\n\nSurely the statement ```\nfalse && false || true```\n should evaluate to ```\nfalse```\n, but in it always evaluates to ```\ntrue```\n. I would have thought that the ```\nfalse &&```\n would be enough to know that the expression is ```\nfalse```\n.\n\nI understand why the logic evaluates to ```\ntrue```\n. What I do not understand is how this still satisfies short-circuit evaluation.\n    ", "Answer": "\r\nSee the section under \"Programming Languages\" for this article on order of operations: https://en.wikipedia.org/wiki/Order_of_operation\n\nEssentially, the ```\n&&```\n operators execute first, before evaluating ```\n||```\n. In your case, it doesn't matter what booleans you put in your ```\nx && y```\n because the ```\n|| true```\n will always make it true.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Partial short circuit boolean evaluation in Javascript or C#\r\n                \r\nIs there a way, in JavaScript or C#, to determine the outcome of a logical expression before the \nvalues of all variables have been retrieved?\n\nOr to put it differently; can an expression be evaluated such that it returns either 'true', 'false', or 'maybe'? Wherein 'maybe' indicates that more data is needed.\n\nTo explain: I have a process in which it takes some time to retrieve data from the database backend and I would like to see if we can skip retrieving certain data if not necessary. But the logical expressions have been predetermined and can not be changed or taken apart.\n\nFor instance, consider the following expression:\n\n```\n((a = 1) and (b = 2)) or (c = 3)\n```\n\n\nThere are several possibilities:\nIf ```\na```\n and ```\nb```\n have been retrieved but ```\nc```\n has not yet been retrieved:\n\n\nIf ```\na=1```\n and ```\nb=2```\n then the expression will always return true and I can skip retrieving the value for ```\nc```\n\nIf ```\na=0```\n and ```\nb=2```\n then the first part will be false, and I need to retrieve the value for ```\nc```\n in order to being able to determine the outcome\n\n\nIf ```\nc```\n has been retrieved, but and ```\na```\n and ```\nb```\n have not yet been retrieved.\n\n\nIf ```\nc=3```\n then the expression will always return true and I can skip retrieving the value for ```\na```\n and ```\nb```\n.\nIf ```\nc=2```\n then the first part will be false, and I need to retrieve the value for ```\na```\n and ```\nb```\n in order to being able to determine the outcome\n\n\nIn these situations, just knowing that an outcome is already determined, or that more data is needed can significantly speed up a process.\n\nDoes anybody have an idea? A process, function, algorithm? \n    ", "Answer": "\r\nSo to cover your very specific code, you can simply use the following:\n\n```\nif(CHasValue())\n    return (c == 3) or ((a == 1) and (b == 2))\nelse\n    return ((a == 1) and (b == 2)) or (c == 3)\n```\n\n\nshort circuiting of operators will take care of the rest.\n\nThis doesn't scale very well with more complex expressions though.  In order to really cover any arbitrary boolean expression you really need to create your own new type, and corresponding boolean operators.\n\nWe'll start out with an interface defining a boolean value that may or may not have computed its value yet:\n\n```\npublic interface IComputableBoolean\n{\n    public bool Value { get; }\n    public bool ValueComputed { get; }\n}\n```\n\n\nThe first implementation is the easy one; it's a computable boolean representing a value that we already know:\n\n```\npublic class ComputedBoolean : IComputableBoolean\n{\n    public ComputedBoolean(bool value)\n    {\n        Value = value;\n    }\n    public bool Value { get; private set; }\n    public bool ValueComputed { get { return true; } }\n}\n```\n\n\nThen there's the slightly more complex case, the boolean value that is generated based on a function (presumably something that is potentially long running, or that has side effects).  It will take a delegate that computes the expression, evaluate it the first time the value is requested, and return a cached value (and indicate that it has computed its value) from then on.\n\n```\npublic class DeferredBoolean : IComputableBoolean\n{\n    private Func<bool> generator;\n    private bool? value = null;\n    public DeferredBoolean(Func<bool> generator)\n    {\n        this.generator = generator;\n    }\n    public bool Value\n    {\n        get\n        {\n            if (value != null)\n                return value.Value;\n            else\n            {\n                value = generator();\n                return value.Value;\n            }\n\n        }\n    }\n    public bool ValueComputed { get { return value != null; } }\n}\n```\n\n\nNow we just need to create ```\nAnd```\n, ```\nOr```\n, and ```\nNot```\n methods that apply to this interface.  They should first check to see if enough values are computed to allow it to short circuit, and if not, they should create a deferred boolean representing the computation of the value.  This propagation of deferred values is important, because it allows complex boolean expressions to be composed and still properly short circuit with the minimal amount of needed computation.\n\n```\npublic static IComputableBoolean And(\n    this IComputableBoolean first,\n    IComputableBoolean second)\n{\n    if (first.ValueComputed && !first.Value ||\n        second.ValueComputed && !second.Value)\n        return new ComputedBoolean(false);\n    else\n        return new DeferredBoolean(() => first.Value && second.Value);\n}\n\npublic static IComputableBoolean Or(\n    this IComputableBoolean first,\n    IComputableBoolean second)\n{\n    if (first.ValueComputed && first.Value ||\n        second.ValueComputed && second.Value)\n        return new ComputedBoolean(true);\n    else\n        return new DeferredBoolean(() => first.Value && second.Value);\n}\n```\n\n\nThe ```\nNot```\n operation is a bit different in that it can't short circuit at all, but it's still important to have in that it continues to defer evaluation of the given boolean expression, because it may end up not being needed.\n\n```\npublic static IComputableBoolean Not(\n    this IComputableBoolean boolean)\n{\n    if (boolean.ValueComputed)\n        return new ComputedBoolean(boolean.Value);\n    else\n        return new DeferredBoolean(() => boolean.Value);\n}\n```\n\n\nWe can now represent the expression that you have like so (using actual long running operations to compute ```\na```\n, ```\nb```\n, and/or ```\nc```\n as needed):\n\n```\nvar a = new DeferredBoolean(() => false);\nvar b = new DeferredBoolean(() => true);\nvar c = new DeferredBoolean(() => false);\n\nvar expression = a.And(b).Or(c);\nbool result = expression.Value;\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Unexpected short circuit evaluation when used more than one logical operators in C\r\n                \r\nIn a C program:\n```\n1 || 0 && 0```\n results in ```\n1```\n. I thought this behavior as the OR operator has short-circuited rest of the right side (```\n0 && 0```\n) because of ```\n1```\n on the left side.\nBut\n```\n0 && 0 || 1```\n also results in ```\n1```\n. I am confused why ```\n0```\n on the left side of AND operator has not short circuited ```\n0 || 1```\n and the answer is not ```\n0```\n.\nPlease guide me!\n    ", "Answer": "\r\nThis has to do with operator precedence.\nThe logical AND operator has higher precedence than the logical OR operator ||.  So this:\n```\n1 || 0 && 0\n```\n\nParses as:\n```\n1 || (0 && 0)\n```\n\nAnd this:\n```\n0 && 0 || 1\n```\n\nParses as:\n```\n(0 && 0) || 1\n```\n\nSo in the latter case, first ```\n0 && 0```\n is evaluated.  This results in the value 0, so now you have ```\n0 || 1```\n.  The left side of the OR is false so this causes the right side to be evaluated, causing the ```\n||```\n operator to result in 1.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "short circuit in java\r\n                \r\nI thought I understood that using short circuit operators that the order of precedence is important however I am having difficulty in understanding why the following code occurs:\n```\nline 3. false && true || true   // this returns true\nline 4. false && true |  true  //  this returns false\n```\n\nI am correct in stating that the code on line 4 will return false because the evaluation is from right to left. However if line 3 has the left to right evaluation, why does it return a true? Using just two short circuit operators is fine but using three, I am somewhat stuck on the logic. No pun intended.\n    ", "Answer": "\r\nRemember operator precedence in Java. ```\n|```\n is evaluated before ```\n&&```\n, but ```\n||```\n is evaluated after ```\n&&```\n. Therefore, the first one would evaluate as ```\n(false && true) || true```\n which would equal ```\ntrue```\n, while the second one would evaluate as ```\nfalse && (true | true)```\n, which evaluates to false.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is reading one-past-the-end pointer allowed in a constant expression when short-circuit disable its evaluation\r\n                \r\nConsider example:\n\n```\ntemplate <char>\nstruct foo { };\n\nint main() {\n    foo<\"\"[0]?\"\"[1]:'\\0'>{};\n}\n```\n\n\nThe code compiles in both [gcc] and [clang], but should it really? I know the expression ```\n\"\"[1]```\n doesn't need to be evaluated as it was short-circuited. But standard isn't very clear if the expression can actually qualify as a core constant expression. Relevant [expr.const]/2 and especially part:\n\n\n  If e satisfies the constraints of a core constant expression, but\n  evaluation of e would evaluate an operation that has undefined\n  behavior as specified in [library] through [thread] of this document,\n  it is unspecified whether e is a core constant expression.\n\n\nraises my doubts...\n    ", "Answer": "\r\nI believe the extract actually covers that:\n\n\n  If ```\ne```\n satisfies the constraints of a core constant expression, but evaluation of e would evaluate an operation that has undefined behaviour as specified in ```\n[library]```\n through ```\n[thread]```\n of this document, it is unspecified whether ```\ne```\n is a core constant expression.\n\n\nThere is actually no undefined behaviour in the expression ```\n\"\"[0]?\"\"[1]:'\\0'```\n because the only problematic bit ```\n\"\"[1]```\n is never actually executed. In fact, the entire expression can simply be optimised to ```\n'\\0'```\n without adverse effects.\n\nThe reason it's not executed comes from the standard itself (e.g., ```\nC++11 5.16 Conditional operator [expr.cond] /1```\n:\n\n\n  Conditional expressions group right-to-left. The first expression is contextually converted to ```\nbool```\n (Clause 4). It is evaluated and if it is true, the result of the conditional expression is the value of the second expression,\n  otherwise that of the third expression. Only one of the second and third expressions is evaluated.\n\n\nSince ```\n\"\"[0]```\n will always evaluate to false in the boolean context, the second sub-expression is never executed. It's really no conceptually different from the expression:\n\n```\nfalse ? (1/0) : 42\n```\n\n\nin that you'll never actually have to worry about the possibility of divide-by-zero.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to perform short-circuit evaluation in Java on two parallel threads that return boolean values?\r\n                \r\nI'm looking for guidance for a problem logically equivalent to the following:\n\n```\npublic boolean parallelOR() {\n    ExecutorService executor = Executors.newFixedThreadPool(2);\n    Future<Boolean> taskA = executor.submit( new SlowTaskA() );\n    Future<Boolean> taskB = executor.submit( new SlowTaskB() );\n\n    return taskA.get() || taskB.get(); // This is not what I want\n    // Exception handling omitted for clarity\n }\n```\n\n\nThe above construction gives the correct result but always waits for taskA to complete\neven if the result is already known since taskB has completed.\n\nIs there a better construction which will allow a value to be returned\nif either of the threads returns true without waiting for the second thread to complete?\n\n(The platform involved is Android, if that affects the result).\n    ", "Answer": "\r\ntry Using ExecutorCompletionService ... something like\n\n```\n    ExecutorService pool = Executors.newFixedThreadPool(2);\n    ExecutorCompletionService<Result> completionService = new ExecutorCompletionService<Result>(pool);\ncompletionService.submit(new SlowTaskA());\ncompletionService.submit(new SlowTaskB());\n    Future<Result> future;\n            try {\n                future = completionService.take();\n                Result currentResult=null;\n                try {\n                    currentResult = future.get();\n                } catch (ExecutionException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n                // got the 1st result in obj currentResult, return true or obj\n                return true;\n            } catch (InterruptedException e1) {\n                e1.printStackTrace();\n            }\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why does short-circuit evaluation work when operator precedence says it shouldn't?\r\n                \r\nIn JavaScript and Java, the equals operator (```\n==```\n or ```\n===```\n) has a higher precedence than the OR operator (```\n||```\n). Yet both languages (JS, Java) support short-circuiting in ```\nif```\n statements:\n\nWhen we have ```\nif(true || anything())```\n, ```\nanything()```\n isn't evaluated.\n\nYou can also have the following expression: ```\ntrue || foo == getValue())```\n - for example in an output statement such as ```\nconsole.log(...);```\n, or in an assignment.\n\nNow, according to operator precedence, short-circuiting shouldn't happen, as ```\n===```\n = ```\n==```\n > ```\n||```\n in terms of precedence. (In other words, the comparison should happen first, for which ```\ngetValue()```\n ought to be called, as the equality check has a higher precedence that the OR comparison.) But it does. ```\ngetValue()```\n isn't called (as can easily be checked by putting an output statement into its body). \n\nWhy (does short circuiting work when the operator precedence says it shouldn't)?\n Or am I confusing matters?\n    ", "Answer": "\r\n\n  Or am I confusing matters?\n\n\nYou are. I think it's much simpler to think about precedence as grouping than ordering. It affects the order of evaluation, but only because it changes the grouping.\n\nI don't know about Javascript for sure, but in Java operands are always evaluated in left-to-right order. The fact that ```\n==```\n has higher precedence than ```\n||```\n just means that\n\n```\ntrue || foo == getValue()\n```\n\n\nis evaluated as\n\n```\ntrue || (foo == getValue())\n```\n\n\nrather than\n\n```\n(true || foo) == getValue()\n```\n\n\nIf you just think about precedence in that way, and then consider that evaluation is always left-to-right (so the left operand of ```\n||```\n is always evaluated before the right operand, for example) then everything's simple - and ```\ngetValue()```\n is never evaluated due to short-circuiting. \n\nTo remove short-circuiting from the equation, consider this example instead:\n\n```\nA + B * C\n```\n\n\n... where ```\nA```\n, ```\nB```\n and ```\nC```\n could just be variables, or they could be other expressions such as method calls. In Java, this is guaranteed to be evaluated as:\n\n\nEvaluate ```\nA```\n (and remember it for later)\nEvaluate ```\nB```\n\nEvaluate ```\nC```\n\nMultiply the results of evaluating ```\nB```\n and ```\nC```\n\nAdd the result of evaluating ```\nA```\n with the result of the multiplication\n\n\nNote how even though ```\n*```\n has higher precedence than ```\n+```\n, ```\nA```\n is still evaluated before either ```\nB```\n or ```\nC```\n. If you want to think of precedence in terms of ordering, note how the multiplication still happens before the addition - but it still fulfills the left-to-right evaluation order too.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Java Logical 'AND' vs 'OR' Short-Circuiting Consistency [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Difference in & and &&  \n\n\n\n\nI've read several tutorials and answer regarding short circuit operations in java and I'm still not quite understanding the difference in how java handles short circuiting for a double vertical pipe vs a double ampersand. For instance ...\n\n\n  Why does the logical AND short circuit evaluation fail?\n\n\nCiting the JSL 15.23. Conditional-And Operator &&\n\n\n  ```\nThe conditional-and operator && is like & (§15.22.2), but evaluates its right-hand operand only if the value of its left-hand operand is true.```\n\n\n\n```\npublic static void main( String... args ) {\n\n\n    int a = 1;\n\n    int b = 2;\n\n    // Okay. Prints\n    if( a == 1 | b == 3 ) {\n\n        System.out.println( \"Comparison via |\" + \"\\na is \" + a + \"\\nb is \" + b );\n\n    }\n\n    // Okay. Prints\n    if( a == 1 || b == 3 ) {\n\n        System.out.println( \"Comparison via ||\" + \"\\na is \" + a + \"\\nb is \" + b );\n\n    }\n\n    // Okay. Does not print\n    if( a == 1 & b == 3 ) {\n\n        System.out.println( \"Comparison via &\" + \"\\na is \" + a + \"\\nb is \" + b );\n\n    }\n\n    // I don't understand. Shouldn't the Short Circuit succeed since the left side of the equation equals 1?\n    if( a == 1 && b == 3 ) {\n\n        System.out.println( \"Comparison via &&\" + \"\\na is \" + a + \"\\nb is \" + b );\n\n    }\n\n}\n```\n\n    ", "Answer": "\r\n\nI don't understand. Shouldn't the Short Circuit succeed since the left side of the equation equals 1?\n\nNo, absolutely not. The point of ```\n&&```\n is that the result is only ```\ntrue```\n if the left and the right operands are ```\ntrue```\n; the short-circuiting means that the right operand isn't evaluated if the left operand is ```\nfalse```\n, because the answer is known at that point.\nYou should read sections 15.23 and 15.24 of the JLS for more details:\n\nThe conditional-and operator && is like & (§15.22.2), but evaluates its right-hand operand only if the value of its left-hand operand is true.\nThe conditional-or operator || operator is like | (§15.22.2), but evaluates its right-hand operand only if the value of its left-hand operand is false.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why am I getting this warning with Travis-CI about module being undefined?\r\n                \r\nFind the Travis-CI page here\n\n```\n         } else if (typeof module === 'object' && module.exports) {\n                                                      ^ 'module' is not defined.\n           module.exports = function( root, jQuery ) {\n               ^ 'module' is not defined.\n>> 2 errors in 1 file\nWarning: Task \"jshint:main\" failed. Use --force to continue.\nAborted due to warnings.\n```\n\n\nIt's clearly that both of those occurrences are module are protected by an if statement or short-circuit evaluation. This is perfectly valid, why would it generate a warning?\n    ", "Answer": "\r\nYou need to declare variables before you use them to make JSLint happy. So you need a\n\n```\nvar module;\n```\n\n\ndeclaration before the code in question.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why doesn't this program short circuit?\r\n                \r\nRunning gnu awk I get a div/0 error. Mawk does not have the same error.\n```\n>>> awk 'BEGIN { print (0 && (4/0)) }'\nawk: cmd. line:1: error: division by zero attempted\n>>> mawk ''BEGIN { print (0 && (4/0)) }'\n0\n```\n\nIf I add parenthesis around the 4 it behaves the same\n```\n>>> awk \"BEGIN { print (0 && ((4)/0)) }\"\n0\n>>> mawk \"BEGIN { print (0 && ((4)/0)) }\"\n0\n```\n\nWhich seems like it should not matter.\nLooking through the posix standard I can't actually find the words short circuiting, so are both correct? Just mawk?\nGNU awk does say this\n\nThe ‘&&’ and ‘||’ operators are called short-circuit operators because of the way they work. Evaluation of the full expression is “short-circuited” if the result can be determined partway through its evaluation.\n\n    ", "Answer": "\r\nBy default, gawk optimises code with constant-folding.\nThis happens before the program is run.\nIt can be turned off with ```\n-s```\n:\n```\n$ gawk 'BEGIN { 0 && 4/0; print \"ok\" }'\ngawk: cmd. line:1: error: division by zero attempted\n$ gawk -s 'BEGIN { 0 && 4/0; print \"ok\" }'\nok\n$\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why is this version of logical AND in C not showing short-circuit behavior?\r\n                \r\nYes, this is a homework question, but I've done my research and a fair amount of deep thought on the topic and can't figure this out. The question states that this piece of code does NOT exhibit short-circuit behavior and asks why. But it looks to me like it does exhibit short-circuit behavior, so can someone explain why it doesn't?\n\nIn C:\n\n```\nint sc_and(int a, int b) {\n    return a ? b : 0;\n}\n```\n\n\nIt looks to me that in the case that ```\na```\n is false, the program will not try to evaluate ```\nb```\n at all, but I must be wrong. Why does the program even touch ```\nb```\n in this case, when it doesn't have to?\n    ", "Answer": "\r\nThis is a trick question. ```\nb```\n is an input argument to the ```\nsc_and```\n method, and so will always be evaluated. In other-words ```\nsc_and(a(), b())```\n will call ```\na()```\n and call ```\nb()```\n (order not guaranteed), then call ```\nsc_and```\n with the results of ```\na(), b()```\n which passes to ```\na?b:0```\n. It has nothing to do with the ternary operator itself, which would absolutely short-circuit.\n\nUPDATE\n\nWith regards to why I called this a 'trick question': It's because of the lack of well-defined context for where to consider 'short circuiting' (at least as reproduced by the OP). Many persons, when given just a function definition, assume that the context of the question is asking about the body of the function; they often do not consider the function as an expression in and of itself. This is the 'trick' of the question; To remind you that in programming in general, but especially in languages like C-likes that often have many exceptions to rules, you can't do that. Example, if the question was asked as such:\n\n\n  Consider the following code. Will sc_and exibit short-circuit behavior when called from main:\n\n\n```\nint sc_and(int a, int b){\n    return a?b:0;\n}\n\nint a(){\n    cout<<\"called a!\"<<endl;\n    return 0;\n}\n\nint b(){\n    cout<<\"called b!\"<<endl;\n    return 1;\n}\n\nint main(char* argc, char** argv){\n    int x = sc_and(a(), b());\n    return 0;\n}\n```\n\n\nIt would be immediately clear that you're supposed to be thinking of ```\nsc_and```\n as an operator in and of itself in your own domain-specific language, and evaluating if the call to ```\nsc_and```\n exhibits short-circuit behavior like a regular ```\n&&```\n would. I would not consider that to be a trick question at all, because it's clear you're not supposed to focus on the ternary operator, and are instead supposed to focus on C/C++'s function-call mechanics (and, I would guess, lead nicely into a follow-up question to write an ```\nsc_and```\n that does short-circuit, which would involve using a ```\n#define```\n rather than a function).\n\nWhether or not you call what the ternary operator itself does short-circuiting (or something else, like 'conditional evaluation') depends on your definition of short-circuiting, and you can read the various comments for thoughts on that. By mine it does, but it's not terribly relevant to the actual question or why I called it a 'trick'.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do Swift Switch short circuit?\r\n                \r\nDo switch statements with more than one evaluations short circuit?\n\nIt probably doesn't matter, but I am curious.\n\n\n\nHere's a simple example:\n\n```\nlet one = 1\nlet two = true\nlet three = false\n\n\nswitch (one, two, three) {\ncase let (0, b, c) where b==c:\n    break\n\ncase (0, true, true):\n    break\n\ndefault:\n    break\n}\n```\n\n\nIn the first case statement, will the 'where' evaluation even happen?\n\nIn the second case statement, will the 'two' == true happen?\n    ", "Answer": "\r\n@J.beenie s answer treats your first question nicely (and convincingly). ```\nb == c```\n will not be called since your initial ```\none```\n does not match ```\n0```\n, a classical ```\nAND```\n short circuit.\n\nYour second question depends on the implementation of ```\n==```\n for tuples. According to a comment to this question this has been part of the Swift-language since 2.2.1 and the standard implementation would of course short circuit since it is the fastest thing to do. So in your second case the second element would not be compared. \n\nBtw: You do not need to ```\nbreak```\n in a Swift ```\nswitch```\n statement, instead you would ```\nfallthrough```\n if you desire otherwise.\n\nCorrection:\nMy guess proved to be only half correct. Pattern matching in ```\nswitch```\n statements seems to do more than I expected. I tried to hijack ```\n==```\n using my own ```\nBool```\n enum (roughly following this post (and adjusting for Swift 3)) and got some surprising results:\n\n```\nimport Cocoa\n\nlet one = 1\nlet two:MyBool = .myTrue\nlet three:MyBool = .myFalse\ntypealias ThreeTuple = (o:Int, tw:MyBool, th:MyBool)\nlet tuple:ThreeTuple\ntuple  = (one, two, three)\n\nswitch tuple {\ncase let (1, b, c) where b == c:\n   print(\"first case\")    \ncase (1, .myTrue, .myFalse):\n    print(\"second case\")\n default:\n    print(\"default\")\n}\n\nenum MyBool : ExpressibleByBooleanLiteral, Equatable  {\n    case myTrue, myFalse\n    public init() { self = .myFalse }\n    public init(booleanLiteral value: BooleanLiteralType) {\n        self=value ? .myTrue : .myFalse\n    }\n}\n\nfunc ==(lhs: MyBool, rhs: MyBool) -> Bool {\n    print(\"evaluate ==\")\n    switch (lhs, rhs) {\n    case (.myTrue,.myTrue), (.myFalse,.myFalse):\n        return true\n    default:\n        return false\n    }\n}\n```\n\n\nwhich yields\n\n```\nevaluate ==\nsecond case\n```\n\n\nat which point I was majorly surprised. The sole evaluation of ```\n==```\n for ```\nMyBool```\n values originates from the ```\nwhere b == c```\n clause in the first ```\ncase```\n and all the tuple \"comparisons\" do not use the ```\nMyBool```\n ```\n==```\n function at all!! I suspected the optimiser was interfering so I turned the ```\nswitch```\n into a ```\nfunc```\n as\n\n```\nfunc match(_ tuple:ThreeTuple) {\n    switch tuple {\n     case let (1, b, c) where b == c:\n        print(\"first case\")\n     case (1, .myTrue, .myFalse):\n        print(\"second case\")\n     default:\n        print(\"default\")\n    }\n}\n```\n\n\nwhich should preclude excessive optimisation at compile time, but when I now ask for\n\n```\nmatch((1, .myTrue, .myTrue))\nmatch((1, .myTrue, .myFalse))\nmatch((0, .myTrue, .myFalse))\n```\n\n\nI get\n\n```\nevaluate ==\nfirst case\nevaluate ==\nsecond case\ndefault\n```\n\n\nwhere the ```\nevaluate ==```\n still originate only from the first ```\ncase```\n. So the only reasonable conclusion seems to be that there is \"some other magic\" going on during pattern matching in ```\nswitch```\n statements. I tried to google if I could figure out what that was, but to no avail so far. In any way, there seems to be way more short circuiting than I would have expected.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Call-by-name in Scala vs lazy evaluation in Haskell?\r\n                \r\nHaskell's lazy evaluation will never take more evaluation steps than the eager evaluation.\n\nOn the other hand, Scala's call-by-name evaluation may require more evaluation steps than call-by-value (if the short-circuit benefits are more than offset by the cost of repeated calculations).\n\nI thought call-by-name is roughly equivalent to lazy evaluation. Why then such a difference in the time guarantee? \n\nI am guessing that maybe Haskell language specifies that memoization must be used during evaluation; but in that case, why doesn't Scala do the same?\n    ", "Answer": "\r\nThere is some breadth in the names given to the evaluation strategies, but they come down to roughly this:\n\n\ncall by name an argument is pretty much just substituted into the function body in whatever (unevaluated) form it was in when the function was called. That means it may need to be evaluated multiple times in the body.\n\nIn Scala, you write this as:\n\n```\nscala> def f(x:=> Int): Int = x + x\nscala> f({ println(\"evaluated\"); 1 })\nevaluated\nevaluated\n2\n```\n\n\nIn Haskell you have no built in way of doing this, but you could always represent call-by-name values as functions of type ```\n() -> a```\n. This is a bit more blurry though, because of referential transparency - you won't be able to test this out the way you would with Scala (and the compiler might optimize away the \"by name\" part of your call).\ncall by need (lazy... sort of) an argument is not evaluated when the function is called, but on the first time is is needed. At that moment, it is also cached. Afterwards, whenever the argument is needed again, the cached value is looked up.\n\nIn Scala, you don't declare your function arguments to be lazy, you make a declaration lazy:\n\n```\nscala> lazy x: Int = { println(\"evaluated\"); 1 }\nscala> x + x\nevaluated\n2\n```\n\n\nIn Haskell this is how all functions work by default.\ncall by value (eager, what almost every language does) arguments are evaluated when the function is called, even if the function doesn't end up using those arguments.\n\nIn Scala this is how functions work by default.\n\n```\nscala> def f(x: Int): Int = x + x\nscala> f({ println(\"evaluated\"); 1 })\nevaluated\n2\n```\n\n\nIn Haskell, you can force this behaviour with bang patterns on function arguments:\n\n```\nghci> :{\nghci> f :: Int -> Int\nghci> f !x = x\nghci> :}\n```\n\n\n\nSo if call by need (lazy) does as much or less evaluation (as either of the other strategies), why use anything else?\n\nLazy evaluation is tough to reason about unless you have referential transparency, because then you need to figure out exactly when your lazy value was evaluated. Since Scala is built to interoperate with Java, it needs to support imperative, side-effectful programming. As a consequence, it is in many cases not a good idea to use ```\nlazy```\n in Scala.\n\nFurthermore, ```\nlazy```\n has a performance overhead: you need to have an extra indirection to check if the value has been already evaluated or not. In Scala, that translates to a bunch more objects, which puts an even greater strain on the garbage collector.\n\nFinally, there are cases where having lazy evaluation leaves \"space\" leaks. For example, in Haskell, folding a large list of numbers from the right by adding them together is a bad idea because Haskell will build up this gigantic series of lazy calls to ```\n(+)```\n before evaluating them (when in reality you just need it to have an accumulator. A famous example of space issues you get even in simple contexts is ```\nfoldr```\n vs ```\nfoldl```\n vs ```\nfoldl'```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Hierarchical vs. Short-Circuit assignment in SQL?\r\n                \r\nDoes SQL have both a short-circuit and a hierarchical multi-evaluation syntax?\n\nExample of short-circuit assignment.  Here ```\ndecision```\n gets the FIRST *** clause when ... is true:\n\nShort-circuit\n\n```\n   case  \n     when (...) then (***) \n     when (...) then (***)\n     when (...) then (***)\n     else (...)\n   end as decision\n```\n\n\nExample of hierarchical assignment.  Here ```\ndecision```\n gets LAST *** expression when ... is true.\n\nHierarchical\n\n```\n    if (...) then (decision = ***) end\n    if (...) then (decision = ***) end\n    if (...) then (decision = ***) end\n```\n\n\nInter-Conversion\n\nIt is clear that reversing the ordering of the expressions switches between hierarchical and short-circuit. I'm wondering whether SQL also has a construct that would assign the LAST tr expression?\n\nTest Case:\n\nThe following gives a very simple toy example:\n\n```\nselect \n  flag1, flag2, flag3,\n  case\n     when flag1=1 and flag2=0 then 'LEFT'\n     when flag1=0 and flag2=0 then 'NONE'\n     when flag2=0 and flag3=1 then 'RIGHT'\n  end as decision \nFROM \n( select \n  1 as flag1, 0 as flag2, 1 as flag3\n  -- from dual                               -- if you use Oracle\n) tmp ;\n```\n\n\nShort-circuit SQL would return 'LEFT' \n\nAn hierarchical assignment would return 'RIGHT'.\n\nEdit: You can run this example in SQL-Fiddle by clicking on the link.  (Thanks to ypercube for pointing out that useful site! (+1))\n    ", "Answer": "\r\nThere is no expression that would do the Hierarchal assignment in one select but it can be achieved just like any other programming language through multiple if statements\n\n```\nDECLARE @flag1 BIT = 1, @flag2 BIT = 0, @flag3 BIT = 1, @decision VARCHAR(50)\n\nIF @flag1 = 1 AND @flag2 = 0\n    SET @decision = 'LEFT'\n\nIF @flag1 = 0 AND @flag2 = 0\n    SET @decision = 'NONE'\n\nIF @flag2 = 0 AND @flag3 = 1\n    SET @decision = 'RIGHT'\n\nSELECT @decision\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit on |= and &= assignment operators in C#\r\n                \r\nI know that ```\n||```\n and ```\n&&```\n are defined as short-circuit operators in C#, and such behaviour is guaranteed by the language specification, but do ```\n|=```\n and ```\n&=```\n short-circuit too?\n\nFor example:\n\n```\nprivate bool IsEven(int n)\n{\n    return n % 2 == 0;\n}\n\nprivate void Main()\n{\n    var numbers = new int[] { 2, 4, 6, 8, 9, 10, 14, 16, 17, 18, 20 };\n\n    bool allEven = true;\n    bool anyOdd = false;\n\n    for (int i = 0; i < numbers.Length; i++)\n    {\n        allEven &= IsEven(numbers[i]);\n        anyOdd |= !IsEven(numbers[i]);\n    }\n}\n```\n\n\nWhen the 9 entry is hit, ```\nallEven```\n becomes false, meaning that all subsequent entries are irrelevant - the value of ```\nallEven```\n is guaranteed to be false for all future calls to that expression. The same goes for ```\nanyOdd```\n, which is set to true when it sees 9, and will remain true for all subsequent calls to that expression.\n\nSo, do ```\n&=```\n and ```\n|=```\n shortcut, or is ```\nIsEven```\n guaranteed to be called on every iteration? Is there any defined behaviour in the language specification for this case? Are there any corner-cases where such short circuiting would be problematic?\n    ", "Answer": "\r\nThe C# specification guarantees that both sides are evaluated exactly once from left-to-right and that no short-circuiting occurs.\n\n5.3.3.21 General rules for expressions with embedded expressions\nThe following rules apply to these kinds of expressions: parenthesized expressions (§7.6.3), element access expressions (§7.6.6), base access expressions with indexing (§7.6.8), increment and decrement expressions (§7.6.9, §7.7.5), cast expressions (§7.7.6), unary +, -, ~, * expressions, binary +, -, *, /, %, <<, >>, <, <=, >, >=, ==, !=, is, as, &, |, ^ expressions (§7.8, §7.9, §7.10, §7.11), compound assignment expressions (§7.17.2), checked and unchecked expressions (§7.6.12), plus array and delegate creation expressions (§7.6.10).\nEach of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.\n\nThe C# specification for compound operators says:\n\n7.17.2 Compound assignment\n...\nAn operation of the form ```\nx op= y```\n is processed by applying binary operator overload resolution (§7.3.4) as if the operation was written ```\nx op y```\n. Then,\n\nIf the return type of the selected operator is implicitly convertible to the type of ```\nx```\n, the operation is evaluated as ```\nx = x op y```\n, except that ```\nx```\n is evaluated only once.\n\nOtherwise, if the selected operator is a predefined operator, if the return type of the selected operator is explicitly convertible to the type of ```\nx```\n, and if ```\ny```\n is implicitly convertible to the type of ```\nx```\n or the operator is a shift operator, then the operation is evaluated as ```\nx = (T)(x op y)```\n, where T is the type of ```\nx```\n, except that ```\nx```\n is evaluated only once.\n\n\n...\n\nIn your case ```\nop```\n is ```\n&```\n or ```\n|```\n. The short circuiting behavior mirrors that of ```\n&```\n/```\n|```\n and not ```\n&&```\n/```\n||```\n.\n\nNote that this only refers to behavior visible in a single threaded scenario. So if the right hand side has no side-effects that are observable in such a scenario, the compiler or JITter is still free to omit the evaluation.\nIn your example the compiler is free to terminate the loop once it knows the result, since there are no such side-effects. But it's not required to do so.\nIn particular timing does not count as such a side-effect, and you thus can't rely on your code having constant runtime. This can be problematic in a security context, since it can introduce a timing side-channel.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Clarification on code regarding compilers Order of Evaluation\r\n                \r\nFrom the information online I have gathered that order of evaluation is evaluating the left side of the operand before the right. However when looking online this is also similar to short circuiting, as that is also evaluating the left before the right. Below my code represents short circuiting however would like it to show order of evaluation. Would anyone know what would need to be changed within the code below to show the code in terms of order of evaluation as opposed to what its currently being shown as a short circuit when running within my compiler. Compiler uses Minijava. \n\n```\nclass ImpFact{\n    public static void main(String[] a){\n    System.out.println(new Fac().ComputeFac(10));\n    }\n}\n\nclass Fac {\n\n    public int ComputeFac(int num){\n    boolean a;\n    boolean b;\n    int result;\n\n    a = false;\n    b = false;\n\n    if (a || b) {\n    result = 3;\n    }\n    else {\n    result = 7;\n}\n    return result;\n}\n\n}\n```\n\n    ", "Answer": "\r\nI'm not sure that I understand what you are expecting as a response to the question.\n\nBut it's easy to characterise the difference between short-circuit evaluation and strict order of evaluation.\n\nConsider the statement:\n\n```\nb = f(a) + g(a)\n```\n\n\nIn a language which guarantees strict left-to-right evaluation order (such as Java), then function ```\nf```\n will be called before the function ```\ng```\n, but *both functions will always be called.\n\nOn the other hand, with the expression\n\n```\nb = f(a) || g(a)\n```\n\n\n```\nf```\n will be called first, but it is quite possible that ```\ng```\n will not be called. The evaluation can stop after ```\nf```\n returns, if it returns a true value.\n\nThere are also languages, like C, that don't guarantee left-to-right evaluation. In those languages, when ```\nf(a) + g(a)```\n is evaluated, it is possible that ```\ng```\n is called before ```\nf```\n. But short-circuit evaluation (with boolean operators) works the same because short-circuit evaluation must be strictly ordered.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "In JavaScript, how can I conditionally assign value to object with destructuring and short circuit evaluation?\r\n                \r\nLet's say I have this set up:\n```\nconst objA = { name: \"Jacob\", email: \"jacob@email.com\" };\nconst objB = { lastName: \"Smith\" };\n```\n\nWhy can I do this:\n```\nconst lastName = objA.lastName || objB.lastName;\n```\n\nBut not this?\n```\nconst { lastName } = objA || objB;\n```\n\nWas able to re-create above example in dev tools.\nMy real world application: I have \"normal\" and \"legacy\" account roles, and after querying both types of roles, I'd like to be able to do:\n```\nconst { schoolAdmin } = account || legacyAccount;\n```\n\n... but instead have to do:\n```\nconst schoolAdmin = account.schoolAdmin || legacyAccount.schoolAdmin;\n```\n\nWhich is admittedly not a big deal, but I feel like there's something I'm missing and that I could use destructuring here. Jr dev, sorry if this is a dummy question!\n(Sometimes there is no account, and sometimes there is an account that doesn't have the schoolAdmin role! Likewise with legacyAccount.)\n    ", "Answer": "\r\nYour expression is trying to assign ```\nlastName```\n from a property in the object returned from the sub-expression on the right side of the ```\n=```\n assignment operator.  That right side sub-expression, ```\nobjA || objB```\n evaluates to ```\nobjA```\n, which has no ```\nlastName```\n property, so your ```\nlastName```\n variable receives a value of ```\nundefined```\n.\nYou could either just use ```\nobjA```\n, and provide a default value from ```\nobjB```\n, if the property doesn't exist in ```\nobjA```\n:\n```\nconst { lastName = objB.lastName } = objA;\n```\n\nOr, you can spread ```\nobjA```\n and ```\nobjB```\n into a single object, and destructure from that:\n```\nconst { lastName } = { ...objB, ...objA };\n```\n\nWhen spreading, reverse the order.  The last object spread overwrites values from the first object.  So, if you want to prefer the value from ```\nobjA```\n, list ```\nobjA```\n last.\nThis spreading option provides a satisfying symmetry, but is likely to be less efficient. From a performance perspective, the first option is better.  But, for me, personally, I think the code you don't like provides better clarity with performance as good as you can get:\n```\nconst lastName = objA.lastName || objB.lastName;\n```\n\nThis is completely unambiguous and performs no unnecessary operations.\nIt should also be pointed out that neither of my solutions is strictly equivalent to the non-destructuring approach.  If ```\nobjA.lastName```\n is a falsy value besides ```\nundefined```\n, (```\n\"\"```\n, ```\nnull```\n, ```\n0```\n, or ```\nfalse```\n), then ```\nobjB.lastName```\n would be used, whereas in both of my solutions, the falsey ```\nobjA.lastName```\n would be used.  Thanks to VLAZ for mentioning this in the comments.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why is a Boolean expression (with side effects) not enough as a statement?\r\n                \r\n```\nfunction A: Boolean;\nfunction B: Boolean;\n```\n\n\nI (accidently) wrote this:\n\n```\nA or B;\n```\n\n\nInstead of that:\n\n```\nif not A then\n  B;\n```\n\n\nThe compiler rejects the first form, I am curious why?\n\nWith short circuit evaluation they would both do the same thing, would they not?\n\nClarification: I was wondering why the language was not designed to allow my expression as a statement.\n    ", "Answer": "\r\nThe first is an expression. Expressions are evaluated. Expressions have no visible side effects (like read or write a variable). Both operands of the expression are functions and those can have side effects, but in order to have side effects, a statement must be executed.\n\nThe second is a statement. It compares the result of an expression and based on the evaluation calls another function. \n\nThe confusing part, is that in this case, Delphi allows us to disregard the result of a function and execute it as a function. So you expect the same for ```\nA or B```\n. But that is not allowed. Which is great because the behaviour is ambiguous.  For example, if yo have lazy evaluation enabled. And A evaluates to true, is B called yes or no.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuit AND within IO Monad\r\n                \r\nI know the question has been asked there but I can't believe there is no straight answer.\n\nI understand it's not good to hide side-effect inside a (&&) but in my case the side-effect are just checking something in the outstide world (existence of a file, check modification time etc, ask user a yes/no quistion).\n\nSo what is the haskell way to something like this, so that cond2 is not executed if cond1 is false.\n\n```\ncond1, cond2 :: IO bool\n\n\nmain = do\n   cond <- liftM2 (&&) con1 con2\n   if cond\n   then   result1\n   else   result2\n```\n\n\nI was expecting something like ```\ncond <- all [con1, con2]```\n or equivalent, but I can't find anything.\n\nUpdate\n\nI can see lots of manual solution. I'm still puzzled that this function doesn't exists somewhere.\nOne advantage of lazzy evaluation is it doesn't only short-circuit for hard-coded ```\n&&```\n like in C. It is really strange that when in imperative mode, Haskell can't even short-circuit ```\n&&```\n.\nAlthough, all solution use somehow and if to short-circuit the evaluation. Is there not a way to make a generic lazzy ```\nliftM2```\n ?\n    ", "Answer": "\r\nThis is what ```\nPipes.Prelude.and```\n does, going over a lazy stream of effectfully-generated conditionals and short-circuiting if any of them are ```\nFalse```\n:\n\n```\nimport Pipes (each)\nimport qualified Pipes.Prelude as Pipes\n\nconds :: [IO Bool]\nconds = ...\n\nmain = do\n    cond <- Pipes.and (each conds >-> Pipes.sequence)\n    print cond\n```\n\n\nRelevant links:\n\n\nand\nPipes tutorial\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is condition_a or condition_b and condition_c always equivalent to (condition_a or condition_b) and condition_c?\r\n                \r\nIs ```\ncondition_a or condition_b and condition_c```\n always equivalent to ```\n(condition_a or condition_b) and condition_c```\n?\n\nSome of the people around me said they work samely but the others didn't agree because short-circuit happens in some cases. For example, if ```\ncondition_a```\n is True, ```\ncondition_a```\n is evaluated as True and the first one terminates but the second one doesn't.\n\nThen, I experimented with them.\n\n```\n>>> (False or True) and True\nTrue\n>>> False or True and True\nTrue\n```\n\n\nIt seems like they work samely. If the short-circuit works, the second one should be False. I guess anyway the short-circuit evaluation works only between two conditions at once, so it means they are equivalent as ```\nFalse or True```\n is evaluated first then the result of ```\nFalse or True```\n and True is evaluated. Does it sound correct?\n    ", "Answer": "\r\nNo, ```\nand```\n has higher precedence than ```\nor```\n. For example, \n\n```\n>>> True or False and False\nTrue\n>>> (True or False) and False\nFalse\n```\n\n\nSection 6.17 of https://docs.python.org/3/reference/expressions.html#operator-precedence\nshows then precendence of operators.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What is IIF in C#? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  iif equivalent in c#  \n\n\n\n\nI have several lines of code using ```\nIIf```\n in VB and I am trying to convert this code to C#.\n\nHere's an example where I need help:\n\n```\nintCurrency = IIf(or.Fields(\"Currency\").Value = \"USD\", 100, 0)\n```\n\n\nHow do I change the above line of code to C#? Is there a short-circuit evaluation operator in C#?\n    ", "Answer": "\r\nIt is close to the C# ternary / conditional operator as several people have suggested but it is not an exact replacement.  The C# ternary operator does short circuit evaluation meaning that only the side effect of the evaluated clause occurs.  In VB.Net the ```\nIif```\n function does not implement short circuiting and will evaluate both side effects.\n\nAdditionally the ```\nIif```\n function in VB.Net is weakly typed.  It accepts and returns values typed as ```\nObject```\n.  The C# ternary operator is strongly typed.  \n\nThe closest equivalent you can write is the following.  Putting the values into the arguments forces the evaluation of their side effects.\n\n```\npublic static object Iif(bool cond, object left, object right) {\n  return cond ? left : right;\n}\n```\n\n\nOr slightly more usable\n\n```\npublic static T Iif<T>(bool cond, T left, T right) {\n  return cond ? left : right;\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Type-checking the result of operator statements\r\n                \r\n```\na = 'A';\nb = null;\n\nconst w = a === b;\nconst x = a && a.length;\nconst y = b && b.length;\nconst z = (a && a.length) || (b && b.length);\nconst u = (a && a.length) && (b && b.length);\n\nconsole.log(typeof w); // boolean\nconsole.log(typeof x); // number \nconsole.log(typeof y); // object\nconsole.log(typeof z); // number \nconsole.log(typeof u); // object\n```\n\n\nI was expecting all of them to be boolean! Can you please help me understand why some of them are not boolean ?\n\nIt is not obvious to me why short-circuit evaluation results in different z and u types.\n    ", "Answer": "\r\n```\nx, y, z, u```\n are short circuit evaluations and not conditions.\n\n```\nconst x = a && a.length;\n```\n\n\nWhat that means is assign ```\na.length```\n to ```\nx```\n is ```\na```\n exists and so on. Hence a ```\nnumber```\n.\n\nWhereas if you were to put them inside an if condition they would be implicitly type casted to ```\nboolean```\n\n\n\r\n\r\n```\nconst a = null || \"works!\"\r\nconsole.log(a)```\n\r\n\r\n\r\n\n\nIf you run the above snippet you will realise how  ```\n||```\n works. If the value on the left of || evaluates to false then value on right is returned otherwise left value.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "JavaScript OR (||) Short Circuit Strange Behavior\r\n                \r\nI am writing a small function that takes in a parameter and attempts to call ```\nparseInt(value) || value.toUpperCase()```\n but it is failing to work as expected with certain values.  \n\n```\nfunction convert(value)\n{\n    return parseInt(value) || value.toUpperCase();\n}\n```\n\n\nSome example outputs are\n```\nconvert(\"asdf\") -> \"ASDF\"```\n\n```\nconvert(\"Car\")  -> \"CAR\"```\n\n```\nconvert(\"1\")    -> 1```\n\n```\nconvert(\"52\")   -> 52```\n\n\nBut for some reason when I input \"0\" I am getting \"0\" back out.  I've attempted to call ```\nparseInt(\"0\")```\n and it is correctly parsing ```\n0```\n out, but when coupled with the ```\n|| \"0\".toUpperCase()```\n it is always returning the string ```\n\"0\"```\n.\n\nThe only excuse I can come up with is that ```\n0 || \"0\"```\n always resolved to ```\n\"0\"```\n because it is treating ```\n0```\n as undefined or null (which my understanding was that the short-circuit evaluation of JavaScript was only short-circuited with ```\nundefined```\n, ```\nnull```\n, or ```\nfalse```\n values).\n\n\nI hope someone could provide me a little bit of clarity regarding this issue.\n    ", "Answer": "\r\n```\n0```\n is falsy, so the other expression in the logical ```\n||```\n will be evaluated. That is why you are getting ```\n\"0\"```\n. You can confirm that like this\n\n```\n1 || console.log(\"First\");\n0 || console.log(\"Second\");\n# Second\n```\n\n\nSince ```\n1```\n is truthy, it short circuits and doesn't execute the ```\nconsole.log(\"First\")```\n, but ```\n0```\n is falsy so it goes ahead and executes ```\nconsole.log(\"Second\")```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Explain the following output? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nPlease explain the output:\n\n```\n#include<iostream.h>\nint main()\n{\n    int i= -3, j=2, k=0, m;\n    m = ++i || ++j && ++k;\n    cout<< i <<\" \" << j << \" \" << k <<\" \"<<m;\n    return 0;\n}\n```\n\n\nOUTPUT : \n-2 2 0 1\n\nHere's what I thought:\n(++i || ++j) && (++k) //Considering the precedence order\n++i becomes -2 so first part of OR true, so it won't check 2nd part.\n(Thanks  Joachim Pileborg for telling me the short circuit evaluation)\n\nSo overall, first part of AND is true.\nBut that is not enough for statement to be true, 2nd part must be true to.\nSo ++k makes k = 1\nHere's where I get it wrong. Why is k not increasing?\n\nwhereas, in this case:\n\n```\n#include<iostream.h>\nint main()\n{\n    int i= -1, j=2, k=0, m;\n    m = ++i || ++j && ++k;\n    cout<< i <<\" \" << j << \" \" << k <<\" \"<<m;\n    return 0;\n}\n```\n\n\nOUTPUT:\n0 3 1 1\n\nI got this one too considering short circuit evaluation.\n    ", "Answer": "\r\nLet's start with this code snippet\n\n```\n#include<iostream.h>\nint main()\n{\n    int i= -3, j=2, k=0, m;\n    m = ++i || ++j && ++k;\n    cout<< i <<\" \" << j << \" \" << k <<\" \"<<m;\n    return 0;\n}\n```\n\n\nIt is obvious that ```\nm```\n will be have a boolean value converted to int. As ```\n++i```\n is equal to -2 that is unequal to zero then all other expressions will not be evaluated because it is already known that the whole expression is equal to ```\ntrue```\n. So after statement\n\n```\n    m = ++i || ++j && ++k;\n```\n\n\n```\nm```\n is equal to 1 and ```\ni```\n is equal to -2 All other variables were not changed.\n\nIn this code snippet\n\n```\n#include<iostream.h>\nint main()\n{\n    int i= -1, j=2, k=0, m;\n    m = ++i || ++j && ++k;\n    cout<< i <<\" \" << j << \" \" << k <<\" \"<<m;\n    return 0;\n}\n```\n\n\n```\n++i```\n will be equal to 0. So the right operand of ```\noperator ||```\n will be evaluated. This operand is\n\n```\n++j && ++k\n```\n\n\nAs ```\n++j```\n will be equal to 3 and is not equal to 0 then ```\n++k```\n also will be evaluated and will be equal to 1. As the both operands of ```\noperator &&```\n is not equal to zero then the result is equal to ```\ntrue```\n\n\nThus you will get i == 0, j == 3, k == 1, m == 1.\n\nFrom the C++ Standard\n\n5.14 Logical AND operator\n\n\n  1 The && operator groups left-to-right. The operands are both\n  contextually converted to bool (Clause 4). The result is true if both\n  operands are true and false otherwise. Unlike &, && guarantees\n  left-to-right evaluation: the second operand is not evaluated if the\n  first operand is false.\n\n\n5.15 Logical OR operator\n\n\n  1 The || operator groups left-to-right. The operands are both\n  contextually converted to bool (Clause 4). It returns true if either\n  of its operands is true, and false otherwise. Unlike |, ||\n  guarantees left-to-right evaluation; moreover, the second operand is\n  not evaluated if the first operand evaluates to true.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why does this if-statement based on short-circuited evaluation not work?\r\n                \r\nIn the ```\nfun```\n function, I want to return 1 if the boolean expression is true.\n\n```\nfunction fun() {\n    (1 == 1) && return 1;\n}\n\nalert(fun());\n```\n\n\n​Of course, I can easily do this with ```\nif (1 == 1) return 1```\n. However, I am wondering why the above code does not work. It triggers a \"Uncaught SyntaxError: Unexpected token return\" error in the console in Chrome.\n\nShouldn't ```\nreturn 1```\n only run if ```\n(1 == 1)```\n is true? Why does this not work?\n    ", "Answer": "\r\nIt doesn't work because the ```\n&&```\n operator needs ```\nexpressions```\n for both of its operands.  E.g.,\n\n\n  expr1 && expr2\n\n\n```\nreturn```\n statements, however, are not (grammatically speaking) ```\nexpressions```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "SQL / T-SQL short-circuit\r\n                \r\nI have a table in SQL Server 2012 which has these values (they are all integers).\n\n```\n     a      b\n     1      1\n     1      0\n    -1      1\n     2      1\n```\n\n\nThis query works OK.\n\n```\nselect * from T1 \nwhere\nb <> 0 and a / b > 0\n```\n\n\nThis query is failing.\n\n```\nselect * from T1 \nwhere\nb * b * b <> 0 and a / b > 0\n```\n\n\nI think I have a slight idea why but still... Why? Could you clearly explain (or point me to some official docs) what does SQL Server short-circuit and what not?   \n\nI find statements saying that T-SQL does support short-circuit but if the evaluation order is not guaranteed then... isn't the short-circuiting process ambiguous or let's say not well defined? \n\nI am kind of confused on this.\n    ", "Answer": "\r\nI had learn this problem from book - Inside Microsoft SQL Server : T-SQL Querying. I copy book content and post it here. Your question is answered after the \nfirst example.\n\nKey concept - All-At-Once Operations\n\nSQL supports a concept called all-at-once operations, which means that all expressions that appear in the same logical query processing phase are evaluated as if at the same point in time.\n\nThis concept explains why, for example, you cannot refer to column aliases assigned in the SELECT clause within the same SELECT clause, even if it seems intuitively that you should be able to. Consider the following query:\n\n```\nSELECT\n  orderid,\n  YEAR(orderdate) AS orderyear,\n  orderyear + 1 AS nextyear\nFROM Sales.Orders;\n```\n\n\nThe reference to the column alias orderyear is invalid in the third expression in the SELECT list, even though the referencing expression appears \"after\" the one where the alias is assigned. The reason is that logically there is no order of evaluation of the expressions in the SELECT list—it’s a set of expressions. At the logical level all expressions in the SELECT list are evaluated at the same point in time. Therefore this query generates the following error:\n\n```\nMsg 207, Level 16, State 1, Line 4\nInvalid column name 'orderyear'.\n```\n\n\nHere’s another example of the relevance of all-at-once operations: Suppose you had a table called T1 with two integer columns called col1 and col2, and you wanted to return all rows where col2/col1 is greater than 2. Because there may be rows in the table where col1 is equal to 0, you need to ensure that the division doesn’t take place in those cases—otherwise, the query fails because of a divide-by-zero error. So if you write a query using the following format:\n\n```\nSELECT col1, col2\nFROM dbo.T1\nWHERE col1 <> 0 AND col2/col1 > 2;\n```\n\n\nYou assume that SQL Server evaluates the expressions from left to right, and that if the expression col1 <> 0 evaluates to FALSE, SQL Server will short-circuit; that is, it doesn’t bother to evaluate the expression 10/col1 > 2 because at this point it is known that the whole expression is FALSE. So you might think that this query never produces a divide-by-zero error.\n\nSQL Server does support short circuits, but because of the all-at-once operations concept in ANSI SQL, SQL Server is free to process the expressions in the WHERE clause in any order that it likes. SQL Server usually makes decisions like this based on cost estimations, meaning that typically the expression that is cheaper to evaluate is evaluated first. You can see that if SQL Server decides to process the expression 10/col1 > 2 first, this query might fail because of a divide-by-zero error.\n\nYou have several ways to try and avoid a failure here. For example, the order in which the WHEN clauses of a CASE expression are evaluated is guaranteed. So you could revise the query as follows:\n\n```\nSELECT col1, col2\nFROM dbo.T1\nWHERE\n  CASE\n    WHEN col1 = 0 THEN 'no' – or 'yes' if row should be returned\n    WHEN col2/col1 > 2 THEN 'yes'\n    ELSE 'no'\n  END = 'yes';\n```\n\n\nIn rows where col1 is equal to zero, the first WHEN clause evaluates to TRUE and the CASE expression returns the string ‘no’ (replace with ‘yes’ if you want to return the row when col1 is equal to zero). Only if the first CASE expression does not evaluate to TRUE—meaning that col1 is not 0—does the second WHEN clause check whether the expression 10/col1 > 2 evaluates to TRUE. If it does, the CASE expression returns the string ‘yes.’ In all other cases, the CASE expression returns the string ‘no.’ The predicate in the WHERE clause returns TRUE only when the result of the CASE expression is equal to the string ‘yes.’ This means that there will never be an attempt here to divide by zero.\n\nThis workaround turned out to be quite convoluted, and in this particular case we can use a simpler mathematical workaround that avoids division altogether:\n\n```\nSELECT col1, col2\nFROM dbo.T1\nWHERE col1 <> 0 and col2 > 2*col1;\n```\n\n\nI included this example to explain the unique and important all-at-once operations concept, and the fact that SQL Server guarantees the processing order of the WHEN \nclauses in a CASE expression.\n\nThere is more in this link - http://social.technet.microsoft.com/wiki/contents/articles/20724.all-at-once-operations-in-t-sql.aspx\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Slow equality evaluation for identical objects (x == x)\r\n                \r\nIs there any reason ```\nx == x```\n is not evaluated quickly? I was hoping ```\n__eq__```\n would check if its two arguments are identical, and if so return True instantly. But it doesn't do it:\n\n```\ns = set(range(100000000))\ns == s # this doesn't short-circuit, so takes ~1 sec\n```\n\n\nFor built-ins, ```\nx == x```\n always returns True I think? For user-defined classes, I guess someone could define ```\n__eq__```\n that doesn't satisfy this property, but is there any reasonable use case for that?\n\nThe reason I want ```\nx == x```\n to be evaluated quickly is because it's a huge performance hit when memoizing functions with very large arguments:\n\n```\nfrom functools import lru_cache\n@lru_cache()\ndef f(s):\n    return sum(s)\nlarge_obj = frozenset(range(50000000))\nf(large_obj) # this takes >1 sec every time\n```\n\n\nNote that the reason @lru_cache is repeatedly slow for large objects is not because it needs to calculate ```\n__hash__```\n (this is only done once and is then hard-cached as pointed out by @jsbueno), but because the dictionary's hash table needs to execute ```\n__eq__```\n every time to make sure it found the right object in the bucket (equality of hashes is obviously insufficient).\n\nUPDATE:\n\nIt seems it's worth considering this question separately for three situations.\n\n1) User-defined types (i.e., not built-in / standard library).\n\nAs @donkopotamus pointed out, there are cases where ```\nx == x```\n should not evaluate to True. For example, for ```\nnumpy.array```\n and ```\npandas.Series```\n types, the result is intentionally not convertible to boolean because it's unclear what the natural semantics should be (does False mean the container is empty, or does it mean all items in it are False?).\n\nBut here, there's no need for python to do anything, since the users can always short-circuit ```\nx == x```\n comparison themselves if it's appropriate:\n\n```\ndef __eq__(self, other):\n  if self is other:\n    return True\n  # continue normal evaluation\n```\n\n\n2) Python built-in / standard library types.\n\na) Non-containers.\n\nFor all I know the short-circuit may already be implemented for this case - I can't tell since either way it's super fast.\n\nb) Containers (including ```\nstr```\n).\n\nAs @Karl Knechtel commented, adding short-circuit may hurt total performance if the savings from short-circuit are outweighed by the extra overhead in cases where ```\nself is not other```\n. While theoretically possible, even in that case the overhead is a small in relative terms (container comparison is never super-fast). And of course, in cases where short-circuit helps, the savings can be dramatic.\n\nBTW, it turns out that ```\nstr```\n does short-circuit: comparing huge identical strings is instant.\n    ", "Answer": "\r\nAs you say, someone could quite easily define an ```\n__eq__```\n that you personally don't happen to approve of ... for example, the Institute of Electrical and Electronics Engineers might be so foolish as to do that:\n```\n>>> float(\"NaN\") == float(\"NaN\")\nFalse\n```\n\nAnother \"unreasonable use case\":\n```\n>>> bool(numpy.ma.masked == numpy.ma.masked)\nFalse\n```\n\nOr even:\n```\n>>> numpy.arange(10) == numpy.arange(10)\narray([ True,  True,  True,  True,  True,  True,  True,  True,  True,  True], dtype=bool)\n```\n\nwhich has the audacity to not even be convertible to ```\nbool```\n!\nSo there is certainly practical scope for ```\nx == x```\n to not automagically be short-circuited to be true.\nGoing Off Course\nHowever the following is perhaps a good question:\n\nWhy doesn't ```\nset.__eq__```\n check for instance identity?\n\nWell, one might think ... because a set ```\nS```\n might contain ```\nNaN```\n and since ```\nNaN```\n cannot equal itself then surely such a set ```\nS```\n cannot equal itself?  Investigating:\n```\n>>> s = set([float(\"NaN\")])\n>>> s == s\nTrue\n```\n\nHmm, that's interesting, especially since:\n```\n>>> {float(\"NaN\")} == {float(\"NaN\")}\nFalse\n```\n\nThis behaviour is due to Python's desire for sequences to be reflexive.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is there a gcc warning flag for when short-circuit evaluation may result in a function not being called?\r\n                \r\nFor example, in the code:\n\n```\nbool foo = bar || baz();\n```\n\n\nthe function ```\nbaz()```\n may not be called. I've found that this is a common source of bugs for me and I'm wondering if there's a way for GCC to print a warning.\n    ", "Answer": "\r\nThere is not a warning flag for this, it would generate a warning for too many common conditions (```\nif(condition) bar();```\n, ```\nif(foo && foo->bar) baz();```\n, etc).\n\nInstead, do something similar to this:\n\n```\nbool foo = baz() || bar;\n```\n\n\nor this:\n\n```\nbool foo = bar | baz();\n```\n\n\nThese unconditionally call ```\nbaz()```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "A syntax for custom lazy-evaluation/short-circuiting of function parameters\r\n                \r\nOracle defines several structures that make use of what looks like lazy evaluation but what's actually short-circuiting.\n\nFor example:\n\n```\nx := case when 1 = 2 then count_all_prime_numbers_below(100000000)\n          else 2*2\n     end;\n```\n\n\nThe function count_all(...) will never be called.\n\nHowever, what I'm more interested in is the syntax that looks like regular function call:\n\n```\nx := coalesce(null, 42, hundreth_digit_of_pi());\n```\n\n\nHundreth_digit_of_pi() will not be called since coalesce is not a regular function, but a syntax sugar that looks like one - for regular ones parameters get evaluated when the function is called.\n\nThe question is:\nis it possible do define in plsql a custom procedure/function that would behave in the same way?\n\nIf you're not convinced I'll give an example when that could be useful:\n\nWe use ''framework'' for logging.\nTo trace something you call a procedure:\n\n```\ntrace_something('A text to be saved somewhere');\n```\n\n\nTrace_something is 'pragma autonomous transaction' procedure that does the following steps:\n1. See, if any tracing methods (for example file / db table) are enabled\n2. For every enabled method use that method to save parameter somewhere.\n3. If it was saved to DB, commit.\n\nA problem occurs when building the actual string to be traced might take noticable amount of time, and we wouldn't want to have to spend it, if tracing isn't even enabled in the first place.\n\nThe objective would be, in pseudocode:\n\n```\nprocedure lazily_trace_something(some_text lazily_eval_type) {\n    if do_i_have_to_trace() = TRUE then\n        trace_something(evaluate(some_text));\n    else\n        NULL; -- in which case, some_text doesn't get evaluated     \n    end if;\n}\n\n\n/*\n\n*/\n\nlazily_trace_something(first_50_paragraphs_of_lorem_ipsum(a_rowtype_variable));\n```\n\n\nIs it possible to be done in plsql?\n    ", "Answer": "\r\nLazy evaluation can be (partially) implemented using ref cursors, conditional compilation, or execute immediate.  The ANYDATA type can be used to pass generic data.\n\nRef Cursor\n\nRef cursors can be opened with a static SQL statement, passed as arguments, and will not execute until needed.\n\nWhile this literally answers your question about lazy evaluation I'm not sure if it's truly practical.  This isn't the intended use of ref cursors.  And it may not be convenient to have to add SQL to everything.\n\nFirst, to prove that the slow function is running, create a function that simply sleeps for a few seconds:\n\n```\ngrant execute on sys.dbms_lock to <your_user>;\n\ncreate or replace function sleep(seconds number) return number is\nbegin\n    dbms_lock.sleep(seconds);\n    return 1;\nend;\n/\n```\n\n\nCreate a function to determine whether evaltuation is necessary:\n\n```\ncreate or replace function do_i_have_to_trace return boolean is\nbegin\n    return true;\nend;\n/\n```\n\n\nThis function may perform the work by executing the SQL statement.  The SQL statement must return something, even though you may not want a return value.\n\n```\ncreate or replace procedure trace_something(p_cursor sys_refcursor) is\n    v_dummy varchar2(1);\nbegin\n    if do_i_have_to_trace then\n        fetch p_cursor into v_dummy;\n    end if;\nend;\n/\n```\n\n\nNow create the procedure that will always call trace but will not necessarily spend time evaluating the arguments.\n\n```\ncreate or replace procedure lazily_trace_something(some_number in number) is\n    v_cursor sys_refcursor;\nbegin\n    open v_cursor for select sleep(some_number) from dual;\n    trace_something(v_cursor);\nend;\n/\n```\n\n\nBy default it's doing the work and is slow:\n\n```\n--Takes 2 seconds to run:\nbegin\n    lazily_trace_something(2);\nend;\n/\n```\n\n\nBut when you change ```\nDO_I_HAVE_TO_TRACE```\n to return false the procedure is fast, even though it's passing a slow argument.\n\n```\ncreate or replace function do_i_have_to_trace return boolean is\nbegin\n    return false;\nend;\n/\n\n--Runs in 0 seconds.\nbegin\n    lazily_trace_something(2);\nend;\n/\n```\n\n\nOther Options\n\nConditional compilation is more traditionally used to enable or disable instrumentation.  For example:\n\n```\ncreate or replace package constants is\n    c_is_trace_enabled constant boolean := false;\nend;\n/\n\ndeclare\n    v_dummy number;\nbegin\n    $if constants.c_is_trace_enabled $then\n        v_dummy := sleep(1);\n        This line of code does not even need to be valid!\n        (Until you change the constant anyway)\n    $else\n        null;\n    $end\nend;\n/\n```\n\n\nYou may also want to re-consider dynamic SQL.  Programming style and some syntactic sugar can make a big difference here.  In short, the alternative quote syntax and simple templates can make dynamic SQL much more readable.  For more details see my post here.\n\nPassing Generic Data\n\nThe ANY types can be use to store and pass any imaginable data type.  Unfortunately there's no native data type for each row type.  You'll need to create a TYPE for each table.  Those custom types are very simple so that step can be automated if necessary.\n\n```\ncreate table some_table(a number, b number);\ncreate or replace type some_table_type is object(a number, b number);\n\ndeclare\n    a_rowtype_variable some_table_type;\n    v_anydata anydata;\n    v_cursor sys_refcursor;\nbegin\n    a_rowtype_variable := some_table_type(1,2);\n    v_anydata := anydata.ConvertObject(a_rowtype_variable);\n    open v_cursor for select v_anydata from dual;\n    trace_something(v_cursor);\nend;\n/\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C++ Language Parsing and Logical Operators's Short-Circuit\r\n                \r\nWhen it comes to the short-circuit of the logical operators, according to the Standard in 7.6.14 e 7.6.15 (N4868).\n\n7.6.14 Logical AND operator\n[...] the second operand is not evaluated if the first operand is false.\n\n\n7.6.15 Logical OR operator\n[...] the second operand is not evaluated if the first operand evaluates to true.\n\nWhen this implementation is discussed in Logical Operators Chaining as (Cond1 && Cond2 && Cond3), in my interpretation, the presented is different from my current mental model on how the c++ code parsing/operator binding occurs in compiler-time.\nFor something as\n```\nif (cond1 && cond2 && cond3) {\n   //something\n}\n```\n\nIt is understood as \"if cond1 is false, so occurs short-circuit, cond2 and cond3 are not evaluated and the expression is false\".\nFor me, even if you have the same result, a more accurate expression about how the parsing should works is \"The first 'AND' operation is an sub-expression of the second. If cond1 is false, so occurs short-circuit, cond2 is not evaluated and the sub-expression is evaluated to false. Then in the second operation occurs short-circuit, cond3 is not evaluated and this expression is also evaluted to false\".\nLike:\n\n(cond1 && cond2) && cond3 : evaluation of cond1 and short-circuit of\nsub-expression to false (cond2 is not evaluated)\nfalse && cond3 : short-circuit of the full-expression to false (cond3 is not evaluated)\n\n\nI am worrying about the model in an high level language like C ++ and not the implementation in runtime (the implementations of the compilers seem to be exactly the same as the first expression I showed, if cond1 is false occurs a jump).\nThe interpretation I did is accurate, pedantic or is incorrect and is inappropriate in this context (It is overthinking)?\n    ", "Answer": "\r\nYou are correct as far as compiler's \"mental model\" and whoever wrote \"if ```\ncond1```\n is false, so the full-expression is ```\nfalse```\n\" is correct as far as CPU's \"mental model\" in this specific case.\nOn the compiler side, parsing ```\ncond1 && cond2 && cond3```\n results in (using clang ```\n-ast-dump```\n)\n```\n`-BinaryOperator 0x557a79f02230 <col:1, col:19> 'bool' '&&'\n  |-BinaryOperator 0x557a79f021d8 <col:1, col:10> 'bool' '&&'\n  | |-ImplicitCastExpr 0x557a79f021a8 <col:1> 'bool' <LValueToRValue>\n  | | `-DeclRefExpr 0x557a79f02168 <col:1> 'bool' lvalue Var 0x557a79f01da0 'cond1' 'bool'\n  | `-ImplicitCastExpr 0x557a79f021c0 <col:10> 'bool' <LValueToRValue>\n  |   `-DeclRefExpr 0x557a79f02188 <col:10> 'bool' lvalue Var 0x557a79f01ec8 'cond2' 'bool'\n  `-ImplicitCastExpr 0x557a79f02218 <col:19> 'bool' <LValueToRValue>\n    `-DeclRefExpr 0x557a79f021f8 <col:19> 'bool' lvalue Var 0x557a79f01fa8 'cond3' 'bool'\n```\n\nevaluation of this tree starts at the root ```\n&&```\n at column 19, which must first evaluate its lhs: so it walks down to the ```\n&&```\n at column 10, which must first evaluate its lhs too: so it walks down to ```\ncond1```\n. If that returned ```\nfalse```\n, the col:10 ```\n&&```\n returns ```\nfalse```\n also, without visiting the rhs branch, and then the col:19 ```\n&&```\n also returns ```\nfalse```\n without visiting the rhs branch.\nBoth gcc and clang as I just tested produced runtime code that is the equivalent of\n```\nif (cond1 == false) goto done;\nif (cond2 == false) goto done;\nif (cond3 == false) goto done;\n return true;\ndone:\n return false;\n```\n\nSo this evaluation is an example of a (very simple) compiler optimization\nsee https://godbolt.org/z/rYc11PvPb for the AST and the compiled code\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Use logical operator if either method result or variable is set\r\n                \r\nUsing Codeigniter I want to check if form validation is false or if my other variable is set:\n\n```\nif (isset($answer_error) || $this->form_validation->run() == false)\n{\n    //Do stuff\n}\n```\n\n\nBut for some reason I can't check both in one conditional statement, why is that?\n\nEDIT: What was I dealing with is called a \"short circuit evaluation\" How can I have PHP avoid lazy evaluation?\n\nFixed it by first evaluationg each term\n\n```\n$validation = $this->form_validation->run();\n$my_validation = isset($answer_error);\n\nif ($my_validation || $validation == false) \n{} \n```\n\n    ", "Answer": "\r\nUse the ```\n|```\n operator instead. This will set the condition, while still cheking the rest of the instructions\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Are there benefits to quick-exiting a method or constructor?\r\n                \r\nI believe this to be related partially to short-circuiting logic, but I couldn't find any questions that directly answered my question.  Possible related questions: Benefits of using short-circuit evaluation, Why use short-circuit code?\n\nConsider the following two code blocks, both of which are possible constructors for a class\n\n```\npublic MyClass(OtherClass other){\n    if (other != null) {\n       //do something with other, possibly default values in this object\n    }\n}\n```\n\n\nand this\n\n```\npublic MyClass(OtherClass other){\n    if (other == null)  return;\n\n    //do something with other, possibly default values in this object\n}\n```\n\n\nIs there any benefit to doing the latter over the former?  There is no other code that follows in the constructor, just code that uses the ```\nother```\n object to construct this one.\n    ", "Answer": "\r\nThis a case where you should do what is the most readable to you and your coworkers.  There is unlikely any perceivable speed difference between the two approaches.  \n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short-circuiting and readability\r\n                \r\nIn this line\n\n```\nif ((last_search == NULL) || (last_search != NULL && total_results != 0))```\n\n\nI know that C's short-circuit evaluation rules say that only if ```\nlast_search```\n is not null will it try and evaluate the right-hand side of ```\n||```\n, hence it's equivalent to writing\n\n```\nif ((last_search == NULL) || (total_results != 0))```\n\n\nand I was advised to use the later by someone, but still isn't the former more readable? Also won't the compiler optimize out the redundant ```\nlast_search != NULL```\n?\n    ", "Answer": "\r\nThis is subjective, but no, the first variant is not more readable because there's more to read. The most readable code (and the least buggy!) is that which does not exist. Just think what would happen if you wanted to check 3 or 4 conditions at once.\n\nAnd here's another counterexample: would you write code like this?\n\n```\nif (number < 0) {\n}\nelse if(number >= 0) {\n    // why not just \"else\"?\n}\n```\n\n\nAs for performance: the compiler would probably optimize the redundant call away, but undoing the performance degradation does not help with the readability degradation.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What is the Most Rly Way for Lazy Conditional Evaluation\r\n                \r\nThe case. I have a part of code like this: ```\nif (exists(\"mybooleanvar\") & mybooleanvar) {statement1} else {statement2}```\n. I expect that if the conditions are lazily (short-circuit) evaluated a```\nstatement1```\n will be run if ```\nmybooleanvar```\n is not assigned and ```\nstatement2```\n will be called if ```\nmybooleanvar```\n does not exist or equals ```\nFALSE```\n.\nBut in practice I am getting a runtime error showing that the value of ```\nmybooleanvar```\n is acessed and compared to ```\nTRUE```\n if ```\nexists(\"mybooleanvar\") == FALSE```\n. So the complete boolean evaluation takes place.\nOf course the issue can be solved by enclosed if statements with outer ones evaluating ```\nexists()```\n and inner ones - booleans. But I wonder what is the most Rly way to properly avoid evaluation of n'th members of conditional statement if the result becomes known despite the values of further statements.\nFor example ```\nstatement1 & statement2```\n will be ```\nFALSE```\n if ```\nstatement1 == FALSE```\n. ```\nstatement1 | statement2```\n is ```\nTRUE```\n if ```\nstatement1 == TRUE```\n and ```\nstatement2```\n needs not to be checked (or at least this check can be switched off by something like compiler directive ```\n{$B-)```\n in Delphi).\n    ", "Answer": "\r\nHere I would use ```\n&&```\n instead of ```\n&```\n. They differ in two ways (cf. ```\n?\"&&\"```\n):\n\nThe shorter form performs elementwise comparisons ...\n\nand:\n\nThe longer form evaluates left to right examining only the first element of each vector. Evaluation proceeds only until the result is determined. The longer form is appropriate for programming control-flow and typically preferred in if clauses.\n\nExample:\n```\nfoo <- function()\n  if (exists(\"x\") && (x)) cat(\"is TRUE\\n\") else cat(\"not existing or FALSE\\n\")\n\nx <- TRUE\nfoo()\n\nx <- FALSE\nfoo()\n\nrm(x)\nfoo()\n```\n\nMore can be found in this post.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Undefined .data section for ASM\r\n                \r\nI got an error when I tried to complier this ASM\n\n```\nWrite an assembly program to implement the following. \nwhile X > 0\nif  X != 3 AND (X > A OR X <B)\nX = X –2\nelse\nX = X –1\nend while\n```\n\n\nUse short-circuit evaluation-Assume that A, B, and X are 16-bit signed integers variables-Assume that A=9, B=8, and X=11\n\nI got .code area but am I missing .data?\n\n```\n.386\n.model flat,stdcall\n.stack 4096\nExitProcess proto,dwExitCode:dword\n\n.data\n     ; declare variables here\n     X WORD ?\n\n.code\nmain proc\n     ; write your code here\n     mov eax, X\n     beginwhile:\n     cmp eax, 0\n     jng endwhile\n     mov ebx,A\n     mov ecx,B\n     cmp X,3\n     jne L1\n     jmp L3\n     jmp endwhile\nL1:  \n    cmp X, ebx\n    jl L2\n    cmp X,ecx\n    jg L2\n    jmp L3\n    jmp endwhile\nL2:\n    mov X, X-2\n    jmp endwhile\nL3:\n    mov X, X-1\n    jmp endwhile\n    endwhile:\n    mov X, eax\n\n    invoke ExitProcess,0\nmain endp\nend main\n```\n\n    ", "Answer": "\r\nSince this is tagged with Visual Studio, I would assume MASM (ML.EXE) is being used, in which case the dot directives could be used, but I'm not sure this would be the goal of the assignment. The dot directive operators need to be translatable to actual instructions, so memory to memory compares aren't allowed.\n\nHowever, the title and the question asks about uninitialized data section, which is .data?, and shown in this example.\n\n```\n        .data?\n;                   ;for signed word, use sword instead of word\nA       word    ?\nB       word    ?\nX       word    ?\n\n        .code\n;       ...    \n        mov     ax,A\n        mov     bx,B\n        .while  (X > 0)\n          .if     (X != 3) && (X > ax || X < bx)\n            sub     X,2\n          .else\n            sub     X,1\n          .endif\n        .endw\n;       ...    \n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Cheap() && Expensive()\r\n                \r\nThis comment was made on a question i asked about optimisation. \"Note that cheap() && expensive() is not an optimisation of expensive () && cheap() in a language with short-circuit evaluation unless you can guarantee that both expensive() and cheap() are side effect free\"\n\nwhat does this mean?\n    ", "Answer": "\r\nDue to short circuit evaluation, when the expression ```\nexpensive () && cheap()```\n runs, ```\ncheap()```\n will only run if ```\nexpensive()```\n returns true. In the case where both methods are side effect free, which means they are just returning a boolean and not making any changes application state, then the expressions can be reversed to ```\ncheap() && expensive()```\n, which will be faster assuming ```\ncheap()```\n is not always true. \n\nHowever, in the case where either method modifies the state of the application then the reversed expression may not be functionally equivalent.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is shortcircuit evaluation a good practice to replace if statements that seem trivial?\r\n                \r\nLet's say for example that you have a code that checks if a \"boolean\" flag is true to run some procedure, like this:\n```\nif( my_flag ){\n doStuff();\n}\n```\n\nI could write it using a short-circuit evaluation, this is taking in account that the result from the evaluation has no value to the rest of the code, it could be written like:\n```\nmy_flag && doStuff();\n```\n\nI have seen professional code written like this, from my perspective it improves readability removing innecesary syntax, but I have no idea if this is a good practice or not because I have also seen a lot of code written using the ```\nif```\n statement.\nI would like to know if theres something that I'm not taking in account or arguments against its use in trivial cases.\n    ", "Answer": "\r\n\nIs shortcircuit evaluation a good practice to replace if statements that seem trivial?\n\n\nNot an option when ```\ndoStuff();```\n returns ```\nvoid```\n.\n\nObliges ```\ndoStuff();```\n to return a value now and in the future.\n\n\nWhen competing options exist, code for maintenance and clarity.\nWinner here:\n```\nif (my_flag) {\n  doStuff();\n}\n```\n\nIf the ```\nif```\n statement is short, optionally omit the braces\n```\nif (my_flag)\n  doStuff();\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Logical Operations not as expected in C\r\n                \r\nCan someone explain how the following code functions\n```\n#include <stdio.h>\n\nvoid main() {\n    int a = 2, b = -1, c = 0, d;\n    d = a-- || b++ && c++;\n    printf(\"%d%d%d%d\", a, b, c, d);\n}\n```\n\nI was expecting the value to be ```\n1010```\n since I have read that ```\n&&```\n has more priority than ```\n||```\n, hence it should be evaluated first. But the answer seems to be ```\n1-101```\n. Could someone explain why? I know about the short circuit evaluation rule, but just don't understand why ```\nb++ && c++```\n isn't performed first?\n    ", "Answer": "\r\nOperator precedence dictates how operands are grouped, not how they are evaluated.\nSince ```\n&&```\n has higher precedence than ```\n||```\n, this:\n```\nd = a-- || b++ && c++;\n```\n\nIs the same as this:\n```\nd = (a--) || ((b++) && (c++));\n```\n\nNow looking at this, we can see that the left operand of ```\n||```\n is ```\na--```\n and the right operand is ```\nb++ && c++```\n.  So ```\na--```\n is evaluated first, and since the value of ```\na```\n is 2 this expression evaluates to 2.  This makes the left side of ```\n||```\n true, meaning that the right side, i.e. ```\nb++ && c++```\n, is not evaluated.  So because the left operand of ```\n||```\n is nonzero, the result of the ```\n||```\n operator 1.\nSo ```\na```\n is decremented to 1, ```\nd```\n is assigned 1 because since that is the result of the ```\n||```\n operator, and ```\nb```\n and ```\nc```\n are unchanged.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to output multiple error messages when using && operator\r\n                \r\n```\nif(isValid(id) && isValid(id2)) {\n    //do sth..\n}\n```\n\n\nI want to check if id and id2 are valid, if they are not, it will output err messages and return false.\n\nThe problem with short-circuit evaluation is that only one err message will be outputted if it is false.\n\nAny ways to output two error messages if they are both false??\n    ", "Answer": "\r\nExecute them all by hand and count the errors:\n\n```\nvar errors = 0;\nif(!isValid(id)) {\n    ++errors;\n}\nif(!isValid(id2)) {\n    ++errors;\n}\nif(errors > 0) {\n    // complain and return\n}\n// Do whatever needs to be done when everything is valid\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why is this boolean expression false?\r\n                \r\nWhen I run\n```\nboolean a = false;\nboolean b = false;\nboolean result = (a && (b || !a)) == a && b;\nSystem.out.println(result);\n```\n\nI get false in Java. Why? This is equivalent to false == false, which is true. This is not Java specific, I get the same result in other languages, too. Is this because of short circuit evaluation? It seems like the left and right would/should still get compared.\n    ", "Answer": "\r\nThe comment was the answer. ```\n==```\n has the highest precedence and will be evaluated first, with the left being ```\na && (b || !a)```\n and the right being ```\na```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Can b&&0 be optimized\r\n                \r\nI know that C/C++ uses the short-circuit evaluation to evaluate the expression of boolean. For example, C/C++ will definitely evaluate the operand ```\na```\n before the operand ```\nb```\n in the expression ```\na && b```\n, if ```\na```\n is false, ```\nb```\n won't be evaluated.\nBesides, I know that things like ```\n5==6```\n may be totally ignored by the compiler because it is a constant expression, which can be evaluated at compile time.\nBut I don't know if ```\nb && 0```\n can be optimized by compiler? Can compiler say: OK, the evaluation of ```\n0```\n is much easier than the evaluation of ```\nb```\n, and ```\nb```\n hasn't any side effect, so I decide to change ```\nb && 0```\n into ```\n0 && b```\n to evaluate ```\n0```\n first.\n    ", "Answer": "\r\nThere are two independent problems involved in your question. The first is that when a compiler \"sees\" that the ```\nif```\n condition is always ```\nfalse```\n (due to ```\n&& 0```\n), it can completely throw away the corresponding branch. Example translation unit:\n```\nbool f(int);\n\nint main()\n{\n  if (f(1) && 0)\n    return 1;\n}\n```\n\nWith enabled optimizations, there will be very likely no machine code generated for the branch. However, the ```\nf(1)```\n expression must be still evaluated at runtime, since the compiler cannot prove that the ```\nf(1)```\n call has no observable behavior.\nMachine code: https://godbolt.org/z/sEMrfh\nOn the contrary, if the compiler could prove that ```\nf(1)```\n had no observable behavior, it could eliminate its call away. This has nothing to do with the order of evaluation, but with the as-if rule instead. Demo translation unit:\n```\nstatic bool f(int i)\n{\n  int j = i + 1;\n  return true;\n}\n\nint main()\n{\n  if (f(1) && 0)\n    return 1;\n}\n```\n\nMachine code: https://godbolt.org/z/scs3je\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Execution order of conditions in C# If statement\r\n                \r\nThere are two if statements below that have multiple conditions using logical operators. Logically both are same but the order of check differs. The first one works and the second one fails.\n\nI referred MSDN for checking whether the order of execution of the conditions defined; but I could not find.\n\nConsider a multiple check condition that has ```\n&&```\n as the logical operator. Is it guaranteed that it will always check the first condition and if that is not satisfied the second condition will not be checked?\n\nI used to use approach 1 and it works well. Looking for an MSDN reference substantiaing the use.\n\nUPDATE\n\nRefer \"short-circuit\" evaluation\n\nCODE\n\n```\n  List<string> employees = null;  \n\n  if (employees != null && employees.Count > 0)\n  {\n        string theEmployee = employees[0];\n  }\n\n  if (employees.Count > 0 && employees != null)\n  {\n        string theEmployee = employees[0];\n  }\n```\n\n    ", "Answer": "\r\nThe && and || operators short-circuit. That is:\n\n1) If && evaluates its first operand as false, it does not evaluate its second operand.\n\n2) If || evaluates its first operand as true, it does not evaluate its second operand.\n\nThis lets you do null check && do something with object, as if it is not null the second operand is not evaluated.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does .NET's LINQ Keyword 'TAKE' short circuit?\r\n                \r\nDoes the TAKE keyword used in a linq query cause the execution of that linq query to short circuit when evaluated or does that .Any method cause the short circuit?\n\n```\nvalue = (From DataRow In MyDataTable Where DataRow.Item(\"MyColumn\").ToString = \"Y\" Take 1).Any\n```\n\n    ", "Answer": "\r\nBoth. Take will take only the first 1 record, and then the any will short circuit as soon as it finds one that matches (but there is only a maximum of 1 because of the take). You can safely remove the Take 1 and have the same performance.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Parentheses and logical operators\r\n                \r\nconsider this code (C++) :\n\n```\nint x = -4 , y = 5 ;\nbool result = x > 0 && y++ < 10 ;\n```\n\n\nthe expression (x > 0) will be evaluated first , and because (x > 0 = false) and due to short-circuit evaluation , the other expression (y++ < 10) won't be evaluated and the value of y will remain 5 .\n\nnow consider the following code :\n\n```\nint x = -4 , y = 5 ;\nbool result = (x > 0) && (y++ < 10) ;\n```\n\n\nit is expected that the expressions in parentheses will be evaluated first so that before the logical AND is performed , the expression (y++ < 10) would have been evaluated and the value of y has became 6 \n , but the reality is that the value of y remains 5 . which means that even with the parentheses the evaluation is short-circuited and the expression (y++ < 10) is ignored .\n\nWhat is the explanation for this case ?! \n    ", "Answer": "\r\nThe explanation is in the question - short-circuiting.\n\nIn C++, evaluation of ```\n&&```\n (and ```\n||```\n for that matter) is guaranteed to be left-to-right, and as soon as a ```\nfalse```\n is encountered (respectively ```\ntrue```\n for ```\n||```\n), evaluation is guaranteed to stop.\n\nSimilar for Java I guess.\n\nThe parenthesis are redundant and not relevant in this case - it has nothing to do with operator precedence. It simply has to do with how ```\n&&```\n works:\n\nIn fact, the two versions \n\n```\nx > 0 && y++ < 10\n(x > 0) && (y++ < 10)\n```\n\n\nare equivalent, because ```\n++```\n has the highest precedence, followed by ```\n<,>```\n, and finally ```\n&&```\n. Pedantically, you should have written it as:\n\n```\n(x > 0) && ((y++) < 10)\n```\n\n\n5.14 Logical AND operator [expr.log.and]\n\n\n  1 The ```\n&&```\n operator groups left-to-right. The operands are both implicitly converted to type bool (clause 4). The result\n  is true if both operands are ```\ntrue```\n and ```\nfalse```\n otherwise. Unlike &, && guarantees left-to-right evaluation: the second\n  operand is not evaluated if the first operand is ```\nfalse```\n. (emphasis mine)\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Unexpected behavior when assigning multiple variables in if() block\r\n                \r\nIn the spirit of seeing Short-circuit evaluation like Python's \"and\" while storing results of checks I decided to see how this could be best solved in PHP but I've run into an issue.\n\nunexpected\n\n```\n<?php\nfunction check_a()\n{\n    return 'A';\n}\nfunction check_b()\n{\n    return 'B';\n}\nfunction check_c()\n{\n    return 'C';\n}\n\nif($a = check_a() && $b = check_b() && $c = check_c())\n{\n    var_dump($a);\n    var_dump($b);\n    var_dump($c);\n}\n```\n\n\nResults in:\n\n```\nbool(true)\nbool(true)\nstring(1) \"C\"\n```\n\n\n\n\ncode for what I wanted to happen\n\n```\n<?php\nfunction check_a()\n{\n    return 'A';\n}\nfunction check_b()\n{\n    return 'B';\n}\nfunction check_c()\n{\n    return 'C';\n}\n\n// if(($a = check_a()) && ($b = check_b()) && $c = check_c()) // equivalent to line below\nif(($a = check_a()) && ($b = check_b()) && ($c = check_c()))\n{\n    var_dump($a);\n    var_dump($b);\n    var_dump($c);\n}\n```\n\n\nResults in:\n\n```\nstring(1) \"A\"\nstring(1) \"B\"\nstring(1) \"C\"\n```\n\n\n\n\nWhy does the unexpected example act in this way?\n    ", "Answer": "\r\nThis is a question of operator precedence. An assignment expression returns the assigned value, so you would expect to get ```\nA```\n and ```\nB```\n for the first two operations. The reason you're getting boolean ```\ntrue```\n instead is that the ```\n&&```\n operator has a higher precedence than the assignment operator, so in the original expression\n\n```\n$a = check_a() && $b = check_b() && $c = check_c()\n```\n\n\n```\n$a```\n gets the value of ```\ncheck_a() && $b = check_b() && $c = check_c()```\n,\n\n```\n$b```\n gets the value of ```\ncheck_b() && $c = check_c()```\n,\n\nand ```\n$c```\n gets the value of ```\ncheck_c()```\n.\n\nThe expressions ```\ncheck_a() && $b = check_b() && $c = check_c()```\n, and ```\ncheck_b() && $c = check_c()```\n return boolean ```\ntrue```\n, because the use of the ```\n&&```\n operator causes the expressions to be evaluated as booleans, and all components of the expressions joined by ```\n&&```\n evaluate to ```\ntrue```\n.\n\nTo get the results you expect, you can add parentheses as you did, or you can use the ```\nand```\n logical operator instead of ```\n&&```\n, because it has a lower precedence than the assignment operator.\n\n```\nif($a = check_a() and $b = check_b() and $c = check_c()) {\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does c# ?? operator short circuit?\r\n                \r\nWhen using the ```\n??```\n operator in C#, does it short circuit if the value being tested is not null?\n\nExample:\n\n```\nstring test = null;\nstring test2 = test ?? \"Default\";\n\nstring test3 = test2 ?? test.ToLower();\n```\n\n\nDoes the test3 line succeed or throw a null reference exception?\n\nSo another way to phrase the question: Will the right hand expression of the ?? operator get evaluated if the left hand is not null?\n    ", "Answer": "\r\nYes, it says so in the C# Language Specification (highlighting by me):\n\n\n  A null coalescing expression of the form ```\na ?? b```\n requires ```\na```\n to be of a nullable type or reference type. If ```\na```\n is non-null, the result of ```\na ?? b```\n is ```\na```\n; otherwise, the result is ```\nb```\n. The operation evaluates ```\nb```\n only if ```\na```\n is null.\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Use of logical AND/OR without conditional/branching\r\n                \r\nI am trying to write a function that counts some bit flags while avoiding the use of branching or conditionals:\n\n```\nuint8_t count_descriptors(uint8_t n)\n{\n    return \n    ((n & 2)   && !(n & 1))   +\n    ((n & 4)   && !(n & 1))   +\n    ((n & 8)   && !(n & 1))   +\n    ((n & 16)  && !(n & 1))   +\n    ((n & 32)  && 1       )   +\n    ((n & 64)  || (n & 128))  ;\n}\n```\n\n\nBit zero is not directly counted, but bits 1-4 are only considered if bit 0 is not set, bit 5 is considered unconditionally, bit 6-7 can only counted once.\n\nHowever, I understand that the boolean && and || use short-circuit evaluation. This means that their use creates a conditional branch, as you would see in such examples: ```\nif( ptr != nullptr && ptr->predicate())```\n that guarantees code in the second sub-expression is not executed if the result is short-circuit evaluated from the first sub-expression.\n\nThe first part of the question: do I need to do anything? Since these are purely arithmetic operations with no side-effects, will the compiler create conditional branches? \n\nSecond part: I understand that bitwise boolean operators do not short-circuit evaluate, but the only problem the bits do not line up. The result of masking the nth bit is either 2^n or zero.\n\nWhat is the best way to make an expression such as (n & 16) evaluate to 1 or 0?\n    ", "Answer": "\r\nI assume with \"bit 6-7 can only counted once\" you mean only one of them is being counted\n\nIn this case something like this should work\n\n```\nuint8_t count_descriptors(uint8_t n)\n{\n    uint8_t retVar;\n\n    retVar = (n&1)*(n&2 >> 1) + \n             (n&1)*(n&4 >> 2) + \n             (n&1)*(n&8 >> 3) +\n             (n&1)*(n&16 >> 4) + \n             (n&32 >> 5) + \n             (int)((n&64 >> 6) + (n&128 >> 7) >= 1)\n\n    return retVar;\n\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Lazy GString evaluation while being executed by Eval or GroovyShell\r\n                \r\nFor a monitoring system, I need to evaluate custom checks which are represented by boolean expressions. For example, I have a simple pseudocode condition (they can be more complex):\n\n```\nif (webservice is unavailable) and (there are no emails about planned downtime)\n```\n\n\nIf possible, I'd like to use short-circuit evaluation here, so that if webservice is available (and the first condition is ```\nfalse```\n), the second part won't be evaluated, as the overall result will be ```\nfalse```\n anyway. Due to this, I can avoid connecting to mail server (and other time-consuming operations) when it's unnecessary.\n\nHere is an example of what I'm trying to achieve:\n\n```\nclass WebserviceDownCheck {\n  boolean check() { \n    println 'Checking webservice'\n    return false \n  }\n}\n\nclass NoDowntimeEmailCheck {\n  boolean check() { //shouldn't be executed\n    println 'Checking emails'\n    return true \n  }\n}\n//using string evaluation, because conditions are constructed during runtime\nEval.me(\"${new WebserviceDownCheck().check()} && ${new NoDowntimeEmailCheck().check()}\")\n```\n\n\nThe output is:\n\n```\nChecking webservice\nChecking emails //shouldn't be there\nResult: false\n```\n\n\n```\nNoDowntimeEmailCheck().check()```\n shouldn't be executed, because the first condition is already ```\nfalse```\n.\nI've tried:\n\n\nusing ```\nGroovyShell```\n instead of ```\nEval```\n \nchanging ```\ncheck()```\n methods to fields and applying ```\n@Lazy```\n transformation\nchanging ```\n${new WebserviceDownCheck().check()}```\n to ```\n${ -> new WebserviceDownCheck().check()}```\n (saw it here)\n\n\nSeems that I need some lazy mechanism which will allow me to initialize ```\nGString```\n while ```\nEval```\n (or ```\nGroovyShell```\n) is already executing it. Maybe something like lazy ```\nBinding```\n for ```\nGroovyShell```\n. \n\nI wonder, is it somehow possible without writing custom string evaluation logic?\n    ", "Answer": "\r\nCombine it into one expression, like this:\n\n```\nEval.me(\"${new WebserviceDownCheck().check() && new NoDowntimeEmailCheck().check()}\")\n```\n\n\nand only the first will be evaluated if the result is false.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is the &= operator a short circuit operator in Java? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Do &= and |= short-circuit in Java?\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nIn Java, the ```\n&&```\n and ```\n||```\n are short circuit. Thus, they do not evaluate their second operand if not necessary (e.g. ```\nfalse && a```\n, ```\ntrue || b```\n).\n\nWhat about the ```\n&=```\n operator? Is it short circuit as well?\n    ", "Answer": "\r\nNo, ```\n&=```\n is not a boolean operator and as such it does not short-circuit anything, it's a bitwise assignment operator. \n\nIt essentially implies assigning first operand with bitwise ```\n&```\n of first and second operands. \n\nQuick demo\n\n```\nint i = 01;\nint ii = 10;\nSystem.out.println(i &= ii); // assigns i with i & ii and sends i to print stream\ni = 01;\nii = 11;\nSystem.out.println(i &= ii);\n```\n\n\nOutput\n\n```\n0\n1\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does C# 6 Elvis operator (null propagation) short circuit\r\n                \r\nWhy this c# code throws a null exception?\n\n```\nbool boolResult = SomeClass?.NullableProperty.ItsOkProperty ?? false;\n```\n\n\nIsn´t elvis operator supposed to stop evaluation (short circuit) once the NullableProperty evaluates to null?\n\nIn my understanding the line of code above is a shortcut for:\n\n```\nbool boolResult \nif(SomeClass != null)\n    if(SomeClass.NullableProperty != null)\n        boolResult = SomeClass.NullableProperty.ItsOkProperty;\n    else\n        boolResult = false;\nelse\n    boolResult = false;\n```\n\n\nDid I assume wrong?\n\nEDIT: Now I understand why I get it wrong, The line of code actually translates to something similar to:\n\n```\nbool boolResult \nif(SomeClass != null)\n    boolResult = SomeClass.NullableProperty.ItsOkProperty;\nelse\n    boolResult = false;\n```\n\n\nAnd throws because NullableProperty is null...\n    ", "Answer": "\r\nYou need to chain, since the NRE is on the second reference:\n\n```\nbool boolResult = SomeClass?.NullableProperty?.ItsOkProperty ?? false;\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit logical or statement, combined with an inline ternary\r\n                \r\nI understand how short-circuit evaluation works when using the logical or operator in JavaScript, but I've run into what seems to be a weird edge case I don't fully understand.\n\nSo, this snippet works the way I would expect:\n\n```\nconst a = 'a' || 'b';```\n\n\nwith ```\na```\n having a value of ```\n'a'```\n.\n\nAnd of course, this also works the way I would expect:\n\n```\nconst a = false || 'b';```\n\n\nwith ```\na```\n having a value of ```\n'b'```\n.\n\nHowever, I've run into this weird situation with an expression like this:\n\n```\nconst a = true || true || true ? 'a' : 'b';```\n\n\nwhere ```\na```\n now has a value of ```\n'a'```\n. I've tried other combinations, such as:\n\n```\nconst a = true || false || true ? 'a' : 'b';```\n\n\nand ```\na```\n still has a value of ```\n'a'```\n.\n\nAnother thing to try is something like this:\n\n```\nconst fn = () => true ? 'a' : 'b';\nconst a = true || fn();\n```\n\n\nand of course ```\na```\n has a value of ```\ntrue```\n, and ```\nfn```\n is never called.\n\nWhat's going on here?\n    ", "Answer": "\r\nA logical OR ```\n||```\n is evaluated from left to right and the first value that evaluates to a truthy value is returned, or the last one if none of them evaluates to ```\ntrue```\n.\n\nIn this case, the first ```\ntrue```\n trivially evaluates to ```\ntrue```\n, thus the whole condition returns ```\ntrue```\n:\n\n```\ntrue || true || false\n```\n\n\nAs a result, the first expression of the ternary operator is evaluated, in this case ```\n'a'```\n:\n\n```\nconst a = true || true || true ? 'a' : 'b';\n```\n\n\nFor this reason, ```\na```\n equals ```\n'a'```\n.\n\nThe same logic applies to the other cases you listed.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How does short-circuit work for Java 8 Streams?\r\n                \r\nReading up a bit on Java 8, I got to this blog post explaining a bit about streams and reduction of them, and when it would be possible to short-circuit the reduction. At the bottom it states:\n\nNote in the case of ```\nfindFirst```\n or ```\nfindAny```\n we only need the first value which matches the predicate (although ```\nfindAny```\n is not guaranteed to return the first). However if the stream has no ordering then we’d expect ```\nfindFirst```\n to behave like ```\nfindAny```\n. The operations ```\nallMatch```\n, ```\nnoneMatch```\n and ```\nanyMatch```\n may not short-circuit the stream at all since it may take evaluating all the values to determine whether the operator is ```\ntrue```\n or ```\nfalse```\n. Thus an infinite stream using these may not terminate.\n\nI get that ```\nfindFirst```\n or ```\nfindAny```\n may short-circuit the reduction, because as soon as you find an element, you do not need to process any further.\nBut why would this not be possible for ```\nallMatch```\n, ```\nnoneMatch```\n and ```\nanyMatch```\n? For ```\nallMatch```\n, if you find one which doesn't match the predicate, you can stop processing. Same for none. And ```\nanyMatch```\n especially doesn't make sense to me, as it it pretty much equal to ```\nfindAny```\n (except for what is returned)?\nSaying that these three may not short-circuit, because it may take evaluating all the values, could also be said for ```\nfindFirst/Any```\n.\nIs there some fundamental difference I'm missing? Am I not really understanding what is going on?\n    ", "Answer": "\r\nThere's a subtle difference, because ```\nanyMatch```\n family uses a predicate, while ```\nfindAny```\n family does not. Technically ```\nfindAny()```\n looks like ```\nanyMatch(x -> true)```\n and ```\nanyMatch(pred)```\n looks like ```\nfilter(pred).findAny()```\n. So here we have another issue. Consider we have a simple infinite stream:\n\n```\nStream<Integer> s = Stream.generate(() -> 1);\n```\n\n\nSo it's true that applying ```\nfindAny()```\n to such stream will always short-circuit and finish while applying ```\nanyMatch(pred)```\n depends on the predicate. However let's filter our infinite stream:\n\n```\nStream<Integer> s = Stream.generate(() -> 1).filter(x -> x < 0);\n```\n\n\nIs the resulting stream infinite as well? That's a tricky question. It actually contains no elements, but to determine this (for example, using ```\n.iterator().hasNext()```\n) we have to check the infinite number of underlying stream elements, so this operation will never finish. I would call such stream an infinite as well. However using such stream both ```\nanyMatch```\n and ```\nfindAny```\n will never finish:\n\n```\nStream.generate(() -> 1).filter(x -> x < 0).anyMatch(x -> true);\nStream.generate(() -> 1).filter(x -> x < 0).findAny();\n```\n\n\nSo ```\nfindAny()```\n is not guaranteed to finish either, it depends on the previous intermediate stream operations.\n\nTo conclude I would rate that blog-post as very misleading. In my opinion infinity stream behavior is better explained in official JavaDoc.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Java logical operator short-circuiting\r\n                \r\nWhich set is short-circuiting, and what exactly does it mean that the complex conditional expression is short-circuiting?\n\n```\npublic static void main(String[] args) {\n  int x, y, z;\n\n  x = 10;\n  y = 20;\n  z = 30;\n\n  // T T\n  // T F\n  // F T\n  // F F\n\n  //SET A\n  boolean a = (x < z) && (x == x);\n  boolean b = (x < z) && (x == z);\n  boolean c = (x == z) && (x < z);\n  boolean d = (x == z) && (x > z);\n  //SET B    \n  boolean aa = (x < z) & (x == x);\n  boolean bb = (x < z) & (x == z);\n  boolean cc = (x == z) & (x < z);\n  boolean dd = (x == z) & (x > z);\n\n}\n```\n\n    ", "Answer": "\r\nThe ```\n&&```\n and ```\n||```\n operators \"short-circuit\", meaning they don't evaluate the right-hand side if it isn't necessary.\n\nThe ```\n&```\n and ```\n|```\n operators, when used as logical operators, always evaluate both sides.\n\nThere is only one case of short-circuiting for each operator, and they are:\n\n\n```\nfalse && ...```\n - it is not necessary to know what the right-hand side is because the result can only be ```\nfalse```\n regardless of the value there\n```\ntrue || ...```\n - it is not necessary to know what the right-hand side is because the result can only be ```\ntrue```\n regardless of the value there\n\n\nLet's compare the behaviour in a simple example:\n\n```\npublic boolean longerThan(String input, int length) {\n    return input != null && input.length() > length;\n}\n\npublic boolean longerThan(String input, int length) {\n    return input != null & input.length() > length;\n}\n```\n\n\nThe 2nd version uses the non-short-circuiting operator ```\n&```\n and will throw a ```\nNullPointerException```\n if ```\ninput```\n is ```\nnull```\n, but the 1st version will return ```\nfalse```\n without an exception.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Precedence between multiple different operators Order of evaluation\r\n                \r\nI have some problems with how an expression Order of evaluation is executed.\n```\n    int x = 1;\n    int y = 2;\n\n    int z = ++x || y++; // how this expression actually executed?\n\n    cout << x << \" \" << y << \" \" << z;\n```\n\noutput: 2 2 1\nI know if started from left to right with ```\n++x```\n it was evaluated and a short circuit will be done.\nBut why we didn't evaluate from ```\ny++```\n which has higher precedence than any other operator here and then do ```\n++x```\n which has less precedence and finally do ```\n||```\n between them?\n    ", "Answer": "\r\nOrder of evaluation and operator precedence are not the same thing.\nOperator precedence here tells us that the expression ```\n++x || y++```\n is equivalent to ```\n(++x) || (y++)```\n rather than some other placement of parentheses, but that still doesn't tell us in which order the subexpressions are evaluated and operator precedence is not relevant for that (aside from the grouping of expressions).\nBy-default there are no guarantees for this ordering in C++. It is not guaranteed to be left-to-right and evaluations of different branches of the expression tree can interleave. The value computations and side effects of subexpressions are said to be unsequenced.\nHowever some expressions enforce some sequencing rules. In particular the built-in ```\n||```\n and ```\n&&```\n are special in that they will conditionally evaluate only their left-hand operand at all.\n```\n||```\n will always sequence the value computation and all side effects of the left-hand side before those of the right-hand operand (if it is evaluated at all). And if the left-hand operand's value is ```\ntrue```\n it will not evaluate the right-hand operand. This is known as short-circuit evaluation. What operators are used in the expressions in the left- and right-hand operands is irrelevant.\nSo ```\n++x```\n is evaluated first, resulting in a value ```\n2```\n which converted to ```\nbool```\n is ```\ntrue```\n. Therefore ```\ny++```\n is never evaluated. Whether or not the pre-increment or post-increment has higher operator precedence is completely irrelevant at this stage.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Table access vs function call + conditional determination: which is faster?\r\n                \r\nI need to check if a particular string is one of a set of predetermined strings.\n\nTwo methods to do it came to my mind: setting up a table to return true on a particular value\n\n```\nlocal isParticular = {\n    [string1] = true,\n    [string2] = true\n}\n\nprint(isParticular[string1]) -- true\nprint(isParticular[randomString]) -- nil -> false\n```\n\n\nOr setting a function to check it with a conditional determination\n\n```\nfunction isParticular(s)\n    return s == string1 or s == string2\nend\n\nprint(isParticular(string1)) -- true\nprint(isParticular(randomString)) -- false\n```\n\n\nFrom what I understand the table method would take the same time for both any of the particular strings and for different strings, while the function call because of short-circuit evaluation will take less time for ```\nstring1```\n and more time for ```\nstring2```\n and ```\nrandomString```\n.\n\nAlso, both the function call and the table access are known for causing a little overhead, but maybe the short-circuit evaluation can make the difference (in being slower I think, especially considered I have more than 2 particular strings and that most of the times the string won't match any of them).\n\nSo what method should I use?\n    ", "Answer": "\r\nA hash-table lookup would outperform your functional lookup for a large dataset. So, go with the first method:\n\n```\nlocal isParticular = {\n    string1 = true,\n    string2 = true\n}\n\nprint(isParticular[string1]) -- true\nprint(isParticular[randomString]) -- nil -> false\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does an 'if' statement always evaluate all conditions? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Does Objective-C use short-circuit evaluation?  \n\n\n\n\nIf an object is of a certain type, and a property of that object has a certain value, I want to do something.\n\nCan I use:\n\n```\nif (objectIsOfType:x && object.property == y)\n```\n\n\nor do I need to nest these? Assume that asking for object.property will through an error if the object is not of type x.\n    ", "Answer": "\r\nNo. Objective C (as C and many other languages) uses short circuit evaluation.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is there a short-circuit OR in PHP that returns the left-most value?\r\n                \r\nIn some languages, you can do\n\n```\n$a = $b OR $c OR die(\"no value\");```\n\n\nThat is, the OR will short-circuit, only evaluating values from left to right until it finds a true value. But in addition, it returns the actual value that was evaluated, as opposed to just ```\ntrue```\n.\n\nIn the above example, in PHP, ```\n$a```\n will be the value ```\n1```\n if either ```\n$a```\n or ```\n$b```\n are non-false values, or it will ```\ndie```\n.\n\nSo wrote a function ```\nfirst```\n, to be used as\n\n```\n$a = first($a, $b, die(\"no value\"));```\n\n\nwhich returns the value of either ```\n$a```\n or ```\n$b```\n. But, it does not short-circuit - it will always ```\ndie```\n.\n\nIs there a short-circuit ```\nOR```\n in PHP that returns the actual value?\n\nEdit:\nSome good answers for the example I gave, but I guess my example isn't exactly what I meant. Let me clarify.\n\n```\n$a = func1() OR func2() OR func3();```\n\n\nWhere each of those functions does a really really intense computation, so I only want to evaluate each expression once at most. And for the first to return a true value, I want the actual value to be stored in ```\n$a```\n. \n\nI think we can rule out writing a function, because it won't short-circuit. And the conditional operator answer will evaluate each expression twice.\n    ", "Answer": "\r\nNo, there isn't, and this is, in my opinion, one of the bad decisions that Rasmus Lerdorf made in designing PHP that most hobbles competent developers for the sake of coddling incompetent ones.\n\nEdit: In PHP 5.3 and up, you can write ```\n$a = $b ?: $c```\n, and even ```\n$a = $b ?: $c ?: $d```\n.  Still not as good as non-brain-damaged logical operators, but it's something.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How do I apply \"or\" to a list in elisp\r\n                \r\nIn elisp I can evaluate or as a function just like +.\n\n```\n(or nil 0 nil) ==> 0\n\n(+ 1 0 1) ==> 2\n```\n\n\nI can use apply to apply + to a list\n\n```\n(apply '+ '(1 0 1)) ==> 2\n```\n\n\nSo, I would think or would work the same way, but it doesn't.\n\n```\n(apply 'or '(nil 0 nil)) ==> error: (invalid-function or)\n```\n\n\nI imagine this comes from some internal magic used to implement the short-circuit evaluation.  How can I use apply to execute the or operation over a list?\n\n\n\nP.S. my desired application is to find out whether any elements on the command line match a particular pattern, so the important part of what I am writing is:\n\n```\n(apply 'or (mapcar (lambda (x) (string-match-p \"pattern\" x)) command-line-args))\n```\n\n\nBut it doesn't work\n    ", "Answer": "\r\nThe problem is that ```\nor```\n is a macro (which is the \"internal magic\" in question), and you're right that that's done so it can do short-circuiting.  If ```\nor```\n was a function, then calling it would need to follow the usual rules for evaluating a function call: all the arguments would need to get evaluated before the call is made.\n\nSee also this question -- it's about Scheme but it's the exact same issue.\n\nAs for a solution, you should probably use ```\nsome```\n, as in:\n\n```\n(some (lambda (x) (string-match-p \"pattern\" x)) command-line-args)\n```\n\n\nNote: this uses common lisp that is not included in emacs by default. Just use ```\n(require 'cl)```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does comparing to Math.Min or Math.Max short-circuit?\r\n                \r\nWhen comparing to a minimum or maximum of two numbers/functions, does C# short-circuit if the case is true for the first one and would imply truth for the second? Specific examples of these cases are\n\n```\nif(x < Math.Max(y, z()))\n```\n\n\nand\n\n```\nif(x > Math.Min(y, z()))\n```\n\n\nSince ```\nMath.Max(y, z())```\n will return a value at least as large as y, if x < y then there is no need to evaluate z(), which could take a while. Similar situation with ```\nMath.Min```\n.\n\nI realize that these could both be rewritten along the lines of\n\n```\nif(x < y || x < z())\n```\n\n\nin order to short-circuit, but I think it's more clear what the comparison is without rewriting. Does this short-circuit?\n    ", "Answer": "\r\nAs others have pointed out, the compiler knows nothing about the semantics of Min or Max that would allow it to break the rule that arguments are evaluated before the method is called.\n\nIf you wanted to write your own, you could do so easily enough:\n\n```\nstatic bool LazyLessThan(int x, int y, Func<int> z)\n{\n    return x < y || x < z();\n}\n```\n\n\nand then call it\n\n```\nif (LazyLessThan(x, y, z))\n```\n\n\nor\n\n```\nif (LazyLessThan(x, y, ()=>z()))\n```\n\n\nOr for that matter:\n\n```\nstatic bool LazyRelation<T>(T x, T y, Func<T> z, Func<T, T, bool> relation)\n{\n    return relation(x, y) || relation(x, z());\n}\n...\nif (LazyRelation(x, y, ()=>z, (a,b)=> a < b))) \n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Mixing short-circuit operators with other operators\r\n                \r\nAssume the following expression:\n```\npublic class OperatorTest {\n\npublic static void main(String[] args) {\n    int x = 0;\n    int y = 0;\n\n    if(0 == 0 || ++y == 1) {\n        // Some other logic here\n    }\n\n    System.out.println(y);\n}\n```\n\n}\nThe output is 0. I understand short-circuit operators, in that the right-hand side of || would not execute because the left-hand side evaluates to true. However, ++ takes precedence over short-circuit logical operators, so shouldn't the ++ operator evaluate before the logical operator is evaluated? Note: I probably would not need to do this in the real-world; this is for a certification exam that I'm studying for.\n    ", "Answer": "\r\nThe short-circuiting logical operators don't even evaluate the right side when short-circuiting.  This is covered by the JLS, Section 15.24, which covers the ```\n||```\n operator.\n\nAt run time, the left-hand operand expression is evaluated first; if the result has type ```\nBoolean```\n, it is subjected to unboxing conversion (§5.1.8).\nIf the resulting value is ```\ntrue```\n, the value of the conditional-or expression is ```\ntrue```\n and the right-hand operand expression is not evaluated.\n\n(bold emphasis mine)\nSo, the ```\n++y```\n is never evaluated, and ```\ny```\n remains ```\n0```\n.\nThe same short-circuiting behavior exists for the ```\n&&```\n operator when the left side evaluates to ```\nfalse```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why is there no first(iterable) built-in function in Python?\r\n                \r\nI'm wondering if there's a reason that there's no ```\nfirst(iterable)```\n in the Python built-in functions, somewhat similar to ```\nany(iterable)```\n and ```\nall(iterable)```\n (it may be tucked in a stdlib module somewhere, but I don't see it in ```\nitertools```\n). ```\nfirst```\n would perform a short-circuit generator evaluation so that unnecessary (and a potentially infinite number of) operations can be avoided; i.e.\n\n```\ndef identity(item):\n    return item\n\ndef first(iterable, predicate=identity):\n    for item in iterable:\n        if predicate(item):\n            return item\n    raise ValueError('No satisfactory value found')\n```\n\n\nThis way you can express things like:\n\n```\ndenominators = (2, 3, 4, 5)\nlcd = first(i for i in itertools.count(1)\n    if all(i % denominators == 0 for denominator in denominators))\n```\n\n\nClearly you can't do ```\nlist(generator)[0]```\n in that case, since the generator doesn't terminate.\n\nOr if you have a bunch of regexes to match against (useful when they all have the same ```\ngroupdict```\n interface):\n\n```\nmatch = first(regex.match(big_text) for regex in regexes)\n```\n\n\nYou save a lot of unnecessary processing by avoiding ```\nlist(generator)[0]```\n and short-circuiting on a positive match.\n    ", "Answer": "\r\nIn Python 2, if you have an iterator, you can just call its ```\nnext```\n method. Something like:\n```\n>>> (5*x for x in xrange(2,4)).next()\n10\n```\n\nIn Python 3, you can use the ```\nnext```\n built-in with an iterator:\n```\n>>> next(5*x for x in range(2,4))\n10\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "short circuit operators give me different result [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        What is wrong with the short circuit logic in this Java code?\r\n                            \r\n                                (9 answers)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nWhile using the short-circuit operators ```\n&&```\n and ```\n||```\n, I'm getting unexpected results.\n\n```\n    if(false && false || true) {\n        System.out.println(\"true\");\n    } else {\n        System.out.println(\"false\");\n    }\n```\n\n\nIt gives me ```\ntrue```\n but according to short-circuit rule if the first operand is ```\nfalse```\n then it is not necessary to evaluate the second operand. Can anyone explain it where I'm missing something.\n    ", "Answer": "\r\n```\n(false && false) || true\n```\n\n\nis evaluated first. Short-circuit gives ```\nfalse```\n and thus the ```\n||```\n cannot be short-circuited, and is thus fully evaluated,\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Python: Lazy Function Evaluation in any() / all()\r\n                \r\nLogical operators in Python are lazy. With the following definition:\n```\ndef func(s):\n    print(s)\n    return True\n```\n\ncalling the ```\nor```\n operator\n```\n>>> func('s') or func('t')\n's'\n```\n\nonly evaluates the first function call, because ```\nor```\n recognizes that the expression evaluates to\n```\nTrue```\n, irregardless of the return value of the second function call. ```\nand```\n does behave analogously.\nHowever, when using ```\nany()```\n (analogously: ```\nall()```\n) in the following way:\n```\n>>> any([func('s'), func('t')])\n's'\n't'\n```\n\nall function calls are evaluated, because the inner list is constructed first, before ```\nany```\n starts to iterate over the boolean values of its items. The same happens when we omit the list construction and just write\n```\n>>> any(func('s'), func('t'))\n's'\n't'\n```\n\nThat way we lose the power of ```\nany```\n being short-circuit, which means that it breaks as soon as the first element of the iterable is truish. If the function calls are expensive, evaluating all the functions up front is a big loss and is a waste of this ability of ```\nany```\n. In some sense, one could call this a Python gotcha, because it might be unexpected for users trying to leverage this feature of ```\nany```\n, and because ```\nany```\n is often thought as being just another syntactic way of chaining a sequence of ```\nor```\n statements. But ```\nany```\n is just short-circuit, not lazy, and that is a difference here.\n```\nany```\n is accepting an iterable. So, there should be a way of creating an iterator which does not evaluate its elements up front but pass them unevaluated to ```\nany```\n and lets them evaluate inside of ```\nany```\n only, in order to achieve a fully lazy evaluation.\nSo, the question is: How can we use ```\nany```\n with truly lazy function evaluation? That means: How can we make an iterator of function calls which ```\nany```\n can consume, without evaluating all the function calls in advance?\n    ", "Answer": "\r\nWe can use a generator expression, passing the functions and their arguments separately and evaluating only in the generator like so:\n```\n>>> any(func(arg) for arg in ('s', 't'))\n's'\n```\n\nFor different functions with different signatures, this could look like the following:\n```\nany(\n    f(*args)\n    for f, args in [(func1, ('s',)), (func2, (1, 't'))]\n)\n```\n\nThat way, ```\nany```\n will stop calling the ```\nnext()```\n element in the generator as soon as one function call in the generator evaluates to ```\nTrue```\n, and that means that the function evaluation is fully lazy.\nAnother neat way to postpone the function evaluation was mentioned by wjandrea in a comment: We can also to use lambda expressions, like so:\n```\n>>> any(f() for f in [lambda: func('s'), lambda: func('t')]\n's'\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit behavior of logical expressions in C in this example\r\n                \r\nPROGRAM\n\n```\n#include <stdio.h>\n\nint main(void)\n{\n    int i, j, k;\n\n    i = 1; j = 1; k = 1;\n\n    printf(\"%d \", ++i || ++j && ++k);\n    printf(\"%d %d %d\", i, j, k);\n\n  return 0;\n}\n```\n\n\nOUTCOME\n\n```\n1 2 1 1\n```\n\n\nI was expecting 1 1 2 2. Why? Because the && has precedence over ||. So I followed these steps:\n1) j added 1, so j now values 2...\n 2) k added 1, so k now values 2...\n 3) 2 && 2, evaluates to 1...\n 4) No need of further evaluation as the right operand of || is true, so the whole expression must be true because of short circuit behavior of logical expressions...\n\nWhy am I wrong?\n    ", "Answer": "\r\nPrecedence affects only the grouping. ```\n&&```\n has a higher precedence than ```\n||```\n means:\n\n```\n++i || ++j && ++k\n```\n\n\nis equivalent to:\n\n```\n++i || (++j && ++k)\n```\n\n\nBut that doesn't mean ```\n++j && ++k```\n is evaluated first. It's still evaluated left to right, and according to the short circuit rule of ```\n||```\n, ```\n++i```\n is true, so ```\n++j && ++k```\n is never evaluated.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Conditional execution based on short-circuit logical operation\r\n                \r\nAs the evaluation of logical operators ```\n&&```\n and ```\n||```\n are defined as \"short circuit\", I am assuming the following two pieces of code are equivalent:\n\n```\np = c || do_something();\n```\n\n\nand\n\n```\nif (c) {\n   p = true;\n}\nelse {\n   p = do_something();\n}\n```\n\n\ngiven ```\np```\n and ```\nc```\n are ```\nbool```\n, and ```\ndo_something()```\n is a function returning ```\nbool```\n and possibly having side effects. According to the C standard, can one rely on the assumption the snippets are equivalent? In particular, having the first snippet, is it promised that if ```\nc```\n is true, the function won't be executed, and no side effects of it will take place? \n    ", "Answer": "\r\nAfter some search I will answer my question myself referencing the standard:\nThe C99 standard, section 6.5.14 Logical OR operator is stating:\n\n\n  Unlike the bitwise | operator, the || operator guarantees\n  left-to-right evaluation; there is a sequence point after the\n  evaluation of the first operand. If the first operand compares unequal\n  to 0, the second operand is not evaluated.\n\n\nAnd a similar section about ```\n&&```\n.\nSo the answer is yes, the code can be safely considered equivalent.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is there any nicer way to write successive \"or\" statements in Python?\r\n                \r\nSimple question to which I can't find any \"nice\" answer by myself:\n\nLet's say I have the following condition:\n\n```\nif 'foo' in mystring or 'bar' in mystring or 'hello' in mystring:\n    # Do something\n    pass\n```\n\n\nWhere the number of ```\nor```\n statement can be quite longer depending on the situation.\n\nIs there a \"nicer\" (more Pythonic) way of writing this, without sacrificing performance ?\n\nIf thought of using ```\nany()```\n but it takes a list of boolean-like elements, so I would have to build that list first (giving-up short circuit evaluation in the process), so I guess it's less efficient.\n\nThank you very much.\n    ", "Answer": "\r\nA way could be\n\n```\nif any(s in mystring for s in ('foo', 'bar', 'hello')):\n    pass\n```\n\n\nThe thing you iterate over is a tuple, which is built upon compilation of the function, so it shouldn't be inferior to your original version.\n\nIf you fear that the tuple will become too long, you could do\n\n```\ndef mystringlist():\n    yield 'foo'\n    yield 'bar'\n    yield 'hello'\nif any(s in mystring for s in mystringlist()):\n    pass\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "OrientDB OR evaluation\r\n                \r\nI'd like to take advantage of short circuiting the OR in an Orient's SQL query I'm writing. Does Orient's OR short circuit and does it evaluate its terms from left to right or right to left?\n    ", "Answer": "\r\nOrientDB WHERE condition evaluation is not completely executed as it's written, so  you cannot rely 100% on OR operations short circuit. \n\nIn V 2.2 the execution planner tries to do some simple assumptions and evaluate indexed conditions first, then it will evaluate expressions from left to right.\n\nIn next V 3.0 the execution planner is much more complex and can do a complete rewriting of the WHERE condition to make the query more efficient, so you should not rely on short circuit in general\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is there any guarantee about the evaluation order within a pattern match?\r\n                \r\nThe following\n\n```\n(&&) :: Bool -> Bool -> Bool\nFalse && _ = False\nTrue && False = False\nTrue && True = True\n```\n\n\nhas the desired short-circuit property ```\nFalse && undefined ≡ False```\n. The first clause, which is non-strict in the right argument, is guaranteed to be checked before anything else is tried.\n\nApparently, it still works if I change the order and even uncurry the function\n\n```\nboth :: (Bool,Bool) -> Bool\nboth (True,False) = False\nboth (True, True) = True\nboth (False, _) = False\n\nPrelude> both (False, undefined)\nFalse\n```\n\n\nbut is this actually guaranteed by the standard? Unlike with the order of clauses, the order of evaluation of the patterns is not so clear here. Can I actually be sure that matching ```\n(True,False)```\n will be aborted as soon as ```\n(False,_)```\n is determined, before the snd element is evaluated at all?\n    ", "Answer": "\r\nYes, it is guaranteed that evaluating the expression ```\nboth (False, undefined)```\n will not diverge since matching on data constructors is guaranteed to match left-to-right against the components of the constructor and the pattern fails as soon as some sub-pattern fails. Since the first element of the tuple is ```\nFalse```\n, the pattern will fail for both ```\n(True, ...)```\n branches as soon as the first element fails to match. \n\nPer the Haskell 2010 Report, section 3.17.2, which gives an informal semantics of pattern matching:\n\n\n  \n  Matching the pattern con pat1 … patn against a value, where con is a constructor defined by data, depends on the value:\n  \n  \n  If the value is of the form con v1 … vn, sub-patterns are matched left-to-right against the components of the data value; if all matches succeed, the overall match succeeds; the first to fail or diverge causes the overall match to fail or diverge, respectively.\n  If the value is of the form con′ v1 … vm, where con is a different constructor to con′, the match fails.\n  If the value is ⊥, the match diverges.\n  \n  \n\n\nSince the tuple syntax is just a special-case syntactic sugar for a data constructor, the above applies.\n\nFor a fuller treatment of pattern matching, see section 3.17.3 of the Haskell 2010 Report, which gives a formal semantics of pattern matching (specifically, figure 3.2 pertains to this question).\n\nAnother resource of interest is the paper Pattern-driven Reduction in Haskell which specifies the semantics as an interpreter (written in Haskell) of an abstract syntax representation of Haskell's concrete syntax (the function ```\nmP```\n in figure 3, page 7 is relevant to the question).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C#: using OR (short circuited version) for assignment\r\n                \r\nIn Lua there is a nice feature for quickly checking if the result of a statement is ```\nnil```\n or not and using short circuited version of or to react to the situation; something such as:\n\n```\ntext = GetTextFromUser() or \"default text\"\n```\n\n\nwhich translates as assign the return value of ```\nGetTextFromUser()```\n to ```\ntext```\n and if ```\nGetTextFromUser()```\n returned ```\nnil```\n, then assign ```\n\"default text\"```\n to ```\ntext```\n\n\nwhich basically is nice trick to use short circuit evaluation of ```\nor```\n operator for assignment.\n\nI'm wondering if c# ```\n||```\n operators also has such capabilities or not. If no, what is the shortest way to achieve the same behavior? ternary operator? if statement?\n    ", "Answer": "\r\nMaybe the null-coalescing operator? https://msdn.microsoft.com/en-ie/library/ms173224.aspx\n\n```\nstring a;\nstring b = a ?? \"default value\";\n```\n\n\nSo your example would become:\n\n```\nstring text = GetTextFromUser() ?? \"default text\"\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Julia Control Flow Booleans not Working as Expected\r\n                \r\nI'm getting results that don't match my expectations when using short-circuit evaluation control flow. This is what I want to do:\n\n```\nif var1 || var2 && var3\n do something cool\nend\n```\n\n\ninstead I get this:\n\n```\nif var1 || var2 \n do something that I don't want\nend\n```\n\n\nthis seems to only evaluate var1 || var2 and skips the && part. I think this should work so, what am I missing? \n\nlink to control-flow:\nhttp://julia.readthedocs.org/en/latest/manual/control-flow/\n\nThanks\n\nThe solution, as provided below, shows that I should've used parenthesis to get what I want:\n\n```\n  if (var1 || var2) && var3\n     do something cool\n    end\n```\n\n    ", "Answer": "\r\nThe ```\n&&```\n operator has higher precedence than ```\n||```\n which means your test is equivalent to ```\nvar1 || (var2 && var3)```\n rather than ```\n(var1 || var2) && var3```\n which may be what you expect. This precedence is standard in many languages, including C, Java, Perl, and Ruby.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why can't Typescript detect that an object is defined when using && short-circuit evaluation of multiple levels of keys in the object?\r\n                \r\nWhy is the code below problematic, I am testing that an object which has multiple nested keys, is in fact not undefined at each level before I test the next, yet TS says that the object is possibly undefined.\n\nThe relevant test is:\n\n```\nchartAnnotations[ts] && chartAnnotations[ts][side] && chartAnnotations[ts][side][type]\n```\n\n\n```\ninterface Transaction {\n  prop1: string;\n  prop2: number\n}\n\ntype ChartTransaction = Pick<Transaction, 'prop2'>\n\nexport type Order = {\n  status: string;\n  type: string;\n}\nexport interface ChartExecutionData {\n  submitted?: Order[];\n  open?: Order[];\n  executed?: Order[];\n  canceled?: Order[];\n  partiallyExecuted?: Order[];\n  transaction?: ChartTransaction;\n}\ntype AnnotationObjectByType = { [type in keyof ChartExecutionData]: string };\n\ninterface ChartAnnotationsBySide {\n  buy?: AnnotationObjectByType;\n  sell?: AnnotationObjectByType;\n}\n\ninterface ChartAnnotations {\n  [timestamp: number]: ChartAnnotationsBySide;\n}\n\nconst chartAnnotations: ChartAnnotations = {}\n\ntype SidesArr = Array<keyof ChartAnnotationsBySide>\n\nconst sides: SidesArr = ['buy', 'sell']\n\ntype TypesArr = Array<keyof ChartExecutionData>\n\nconst types: TypesArr = ['submitted']\n\nconst ts: number = 433242\nsides.forEach(side => {\n  types.forEach(type => {\n    if (chartAnnotations[ts] && chartAnnotations[ts][side] && chartAnnotations[ts][side][type]) {\n\n    }\n  })\n})\n```\n\n    ", "Answer": "\r\nThis is a known bug in TypeScript.  For whatever reason, reading a non-literal property on an object type with an index signature doesn't act as a type guard on that property.  It looks like this is being tracked in the following GitHub issues:\n\n\nmicrosoft/TypeScript#17960 \"property accesses on string index signatures should narrow\"\nmicrosoft/TypeScript#29042 \"```\nthis[variable]```\n and ```\nthis[stringLiteral]```\n have different behavior\"\n\n\nYou might want to go to those issues and give them a 👍 if you want to see them maybe come out of the backlog.\n\nIn the meantime, workarounds:\n\n\n\nYou could save the result of the property access to a new variable, and then check it.  This should trigger the type guarding you expect.  For example:\n\n```\nlet cAts: AnnotationObjectByType | undefined;\nif (chartAnnotations[ts] && (cAts = chartAnnotations[ts][side]) && cAts[type]) {\n\n}\n```\n\n\n\n\nOr, if you're using TypeScript 3.7+ (currently in beta) you can use the optional chaining operator ```\n?.```\n, which will most likely eventually be added to JavaScript.  This is a less verbose syntax to do the kind of safe nested indexing you want, and luckily it doesn't run afoul of the same bug:\n\n```\nconst cAtst = chartAnnotations?.[ts]?.[side]?.[type]; // string | undefined\n```\n\n\n\n\nOr, if you just want to silence the error and go about your day, you can use the non-null assertion operator ```\n!```\n:\n\n```\nif (chartAnnotations[ts] && chartAnnotations[ts][side] && chartAnnotations[ts][side]![type]) { }\n```\n\n\nThis is less safe than the previous two workarounds, but changes your code the least.\n\n\n\nOkay, hope that helps.  Good luck!\n\nLink to code\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Vaadin CheckBox object becomes null\r\n                \r\nI have this Vaadin object:\n\n```\nCheckBox mycb = new CheckBox(\"caption\");\n```\n\n\nLater on the value of this checkbox is updated from the database like this:\n\n```\nmycb.setValue(dbvalue);\n```\n\n\n```\ndbvalue```\n is actually NULL in the database. ```\nmycb```\n was not null before this line, and is null after this line. Shouldn't its value remain the same, only ```\nmycb.getValue()```\n returning null?\n\nFurthermore, trying to avoid a NullPointerException with short-circuit evaluation:\n\n```\nif (mycb != null && mycb.getValue() == true) \n...\n```\n\n\nThat produces a NullPointerException anyway. Is this normal behavior or there is something I'm doing wrong?\n    ", "Answer": "\r\nYou said yourself mycb doesn't actually become null. That's great.\n\n```\nif (mycb != null && mycb.getValue() == true) \n```\n\n\nThis throws a ```\nNullPointerException```\n because Java tries to cast the result of ```\nmycb.getValue()```\n to a ```\nboolean```\n. But because ```\nmycb.getValue()```\n returns ```\nnull```\n, it throws a ```\nNullPointerException```\n.\n\nChange it to:\n\n```\nif (mycb.getValue() != null && mycb.getValue() == true)\n```\n\n\nOr something similar\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Operator with Ternary Return and Short-Circuit\r\n                \r\nI want an operator capable of short-circuiting an evaluation on ```\ntrue```\n or ```\nfalse```\n but also having a return that indicates continued testing is needed.\n\n\n\nFor example, lexicographic string comparison between two strings ```\nfirst```\n and ```\nsecond```\n:\n\n\nif ```\nfirst[0] < second[0]```\n, we can end the comparison by returning ```\ntrue```\n\notherwise, if ```\nfirst[0] > second[0]```\n, we can end the comparison by returning ```\nfalse```\n\notherwise, ```\nfirst[0] == second[0]```\n holds, and we need to continue with the second character of both strings.\n\n\nThe trivial solution requires two comparisons:\n\n```\nbool firstIsEarlier(std::string first, std::string second){\n    if(first[0] < second[0]){\n        return true;\n    }else if(first[0] > second[0]){\n        return false;\n    }\n    // first[0] == second[0] holds\n    // continue with second character..\n}\n```\n\n\nMy hack solution has been to use ```\nif```\n-```\nelse if```\n blocks and an ```\nint```\n which will give me a positive number for ```\ntrue```\n or a negative number for ```\nfalse```\n, a ```\n0```\n indicates continue testing.\n\n```\nbool firstIsEarlier(std::string first, std::string second){\n    if(int i = first[0] - second[0]){\n        return i < 0;\n    }\n    else if(i = first[1] - second[1]){\n        return i < 0;\n    }\n    else if(i = first[2] - second[2]){\n        return i < 0;\n    }\n    return false;\n}\n```\n\n\nSo as you can see the only way for me to force the short-circuit is to list each condition in an ```\nelse if```\n. A good solution would be a way for me to do this all on one line and preserve the short circuit. A great solution would be if there was an ```\noperator#```\n to do something like this:\n\n```\nbool firstIsEarlier(std::string first, std::string second){\n    return first[0] # second[0] ## first[1] # second[1] ## first[2] < second[2];\n}\n```\n\n    ", "Answer": "\r\nYou probably should achieve this with\n\n```\nbool firstIsEarlier(std::string first, std::string second) {\n    return first < second;\n}\n```\n\n\nor more generally with ```\nstd::lexicographical_compare```\n.\n\nYou can do exactly what you ask with expression templates though, and I'll show you how.\n\nThere are a few limitations though:\n\n\nyou can't create new operators, so you have to choose two operators you want to overload: one for the leaf comparisons, and one for the short-circuit combination.\n\n(You could use a single operator if you really wanted, but it'd be (even more) confusing and would require lots of parentheses)\nyou can't really do this when both operands are primitives. If you could, your code would look like:\n\n```\nbool firstIsEarlier(std::string first, std::string second){\n    return first[0]^second[0] <<= first[1]^second[1] <<= first[2]^second[2];\n}\n```\n\n\nbut actually you'd need to wrap your ```\nchar```\ns in some value container for it to work.\n\n\n\n\nFirst, we need a simple tri-state type. We can just enumerate it:\n\n```\nenum class TriState {\n    True = -1,\n    Maybe = 0,\n    False = 1\n};\n```\n\n\nNext, we need some thing to represent our ```\nfirst[0]^second[0]```\n leaf expression, which evaluates to our tri-state type:\n\n```\ntemplate <typename LHS, typename RHS>\nstruct TriStateExpr {\n    LHS const &lhs_;\n    RHS const &rhs_;\n\n    TriStateExpr(LHS const &lhs, RHS const &rhs) : lhs_(lhs), rhs_(rhs) {}\n\n    operator bool () const { return lhs_ < rhs_; }    \n    operator TriState () const {\n        return (lhs_ < rhs_ ? TriState::True :\n                (rhs_ < lhs_ ? TriState::False : TriState::Maybe)\n               );\n    }\n};\n```\n\n\nNote that we're just requiring a working ```\noperator<```\n for our types - we could generalize this to use an explicit comparator if necessary.\n\nNow, we need the non-leaf part of the expression tree. I'm forcing it to a right-to-left expression tree, so the left-hand expression is always a leaf, and the right-hand expression can be a leaf or a complete sub-tree.\n\n```\ntemplate <typename LLHS, typename LRHS, typename RHS>\nstruct TriStateShortCircuitExpr {\n    TriStateExpr<LLHS, LRHS> const &lhs_;\n    RHS const &rhs_;\n\n    TriStateShortCircuitExpr(TriStateExpr<LLHS, LRHS> const &lhs, RHS const &rhs)\n        : lhs_(lhs), rhs_(rhs)\n    {}\n\n    operator TriState () const {\n        TriState ts(lhs_);\n        switch (ts) {\n        case TriState::True:\n        case TriState::False:\n            return ts;\n        case TriState::Maybe:\n            return TriState(rhs_);\n        }\n    }\n\n    operator bool () const {\n        switch (TriState(lhs_)) {\n        case TriState::True:\n            return true;\n        case TriState::False:\n            return false;\n        case TriState::Maybe:\n            return bool(rhs_);\n        }\n    }\n};\n```\n\n\nNow, you want some syntactic sugar, so we have to choose which operators to overload. I'll use ```\n^```\n for the leaves (on the grounds that it's like ```\n<```\n rotated 90 degrees clockwise):\n\n```\ntemplate <typename LHS, typename RHS>\nTriStateExpr<LHS, RHS> operator^ (LHS const &l, RHS const &r) {\n    return TriStateExpr<LHS, RHS>(l,r);\n}\n```\n\n\nand ```\n<<=```\n for the non-leaves:\n\n```\ntemplate <typename LLHS, typename LRHS, typename RLHS, typename RRHS>\nTriStateShortCircuitExpr<LLHS, LRHS, TriStateExpr<RLHS, RRHS>>\n    operator<<= (TriStateExpr<LLHS, LRHS> const &l,\n                 TriStateExpr<RLHS, RRHS> const &r) {\n    return TriStateShortCircuitExpr<LLHS, LRHS, TriStateExpr<RLHS, RRHS>>(l, r);\n}\n\ntemplate <typename LLHS, typename LRHS, typename... RARGS>\nTriStateShortCircuitExpr<LLHS, LRHS, TriStateShortCircuitExpr<RARGS...>>\n    operator<<= (TriStateExpr<LLHS, LRHS> const &l,\n                 TriStateShortCircuitExpr<RARGS...> const &r) {\n    return TriStateShortCircuitExpr<LLHS, LRHS,\n                                    TriStateShortCircuitExpr<RARGS...>>(l, r);\n}\n```\n\n\nThe main considerations are that the leaf operator should ideally have higher precedence, and the non-leaf operator should associate right-to-left. If you used a left-to-right associative operator instead, ```\nTriStateShortCircuitExpr::operator```\n would recurse down the left-hand-side subtree, which seems inelegant for this application.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is MySQL logic evaluation lazy/short-circuiting in JOIN clause?\r\n                \r\nTake the following expression: ```\nFALSE AND (expression)```\n\n\nWill MySQL evaluate the expression or just move on as soon as it sees ```\nFALSE```\n?\n\nSome background context-- I wanted to speed up a query by doing:\n\n```\nJOIN... ON (indexed_column1=indexed_column2 AND non_indexed_column_a=non_indexed_column_b)```\n \n\nFor background on why I'm doing this query see this answer\n\nIf it's going to always evaluate ```\nnon_indexed_column_a=non_indexed_column_b```\n then no time is saved with that.\n    ", "Answer": "\r\nThe MySQL query optimizer uses indexes whenever possible and to use the most restrictive index in order to eliminate as many rows as possible. \n\nSo in case of your query it will always filter the records based on first indexes columns and then filter the records from non-index columns.\n\nAlso before query execution, MySQL eliminates the code which is always going to be false (Dead Code) .\n\nFor more details see: http://www.informit.com/articles/article.aspx?p=377652&seqNum=2\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Python `or`, `and` operator precedence example\r\n                \r\nI cannot produce example in Python which shows Boolean operator precedence rules combined with short circuit evaluation. I can show operator precedence using:\n\n```\nprint(1 or 0 and 0)  # Returns 1 because `or` is evaluated 2nd.\n```\n\n\nBut the issue with short circuiting shows up when I change it to this:\n\n```\ndef yay(): print('yay'); return True\ndef nay(): print('nay')\ndef nope(): print('nope')\nprint(yay() or nay() and nope())  # Prints \"yay\\nTrue\"\n```\n\n\nFor each of 4 possibilities when expression before ```\nor```\n is ```\nTrue```\n it is the only evaluated expression. If operator precedence works this should print ```\n\"nay\\nnope\\nyay\\nTrue\"```\n or ```\n\"nay\\nyay\\nTrue\"```\n, with short circuiting, because ```\nand```\n should be evaluated 1st.\n\nWhat comes to mind from this example is that Python reads boolean expression from left to right and ends it when result is known regardless of operator precedence.\n\nWhere is my error or what am I missing? Please give an example where it's visible that ```\nand```\n is evaluated 1st and it isn't due to code being interpreted from left to right.\n    ", "Answer": "\r\nYou are confusing operator precedence and evaluation order.\n\nThe expression ```\nr = x or y and z```\n is not evaluated as ```\ntmp = y and z; r = x or tmp```\n, but just as ```\nr = x or (y and z)```\n. This expression is evaluated from left to right, and if the result of the ```\nor```\n is already decided, then ```\n(y and z)```\n will not be evaluated at all.\n\nNote that it would be different if ```\nor```\n and ```\nand```\n were functions; in this case, the parameters of the functions would be evaluated before the function itself is called. Hence, ```\noperator.or_(yay(), operator.and_(nay(), nope()))```\n prints ```\nyay```\n, ```\nnay```\n and ```\nnope```\n i.e. it prints all three, but still in order from left to right.\n\nYou can generalize this to other operators, too. The following two expressions will yield different results due to the different operator precedence (both implicit and explicit by using ```\n(...)```\n), but the functions are called from left to right both times.\n\n```\n>>> def f(x): print(x); return x\n>>> f(1) + f(2) * f(3) / f(4) ** f(5) - f(6)         # 1 2 3 4 5 6 -> -4.99\n>>> (f(1) + f(2)) * (((f(3) / f(4)) ** f(5)) - f(6)) # 1 2 3 4 5 6 -> -17.29\n```\n\n\nAs pointed out in comments, while the terms in between operations are evaluated from left to right, the actual operations are evaluated according to their precedence.\n\n```\nclass F:\n    def __init__(self,x): self.x = x\n    def __add__(self, other): print(f\"add({self},{other})\"); return F(self.x+other.x)\n    def __mul__(self, other): print(f\"mul({self},{other})\"); return F(self.x*other.x)\n    def __pow__(self, other): print(f\"pow({self},{other})\"); return F(self.x**other.x)\n    def __repr__(self): return str(self.x)\ndef f(x): print(x); return F(x)\n```\n\n\nThis way, the expression ```\nf(1) + f(2) ** f(3) * f(4)```\n is evaluated as ```\n1```\n, ```\n2```\n, ```\n3```\n, ```\npow(2,3)```\n, ```\n4```\n, ```\nmul(8,4)```\n, ```\nadd(1,32)```\n, i.e. terms are evaluated left-to-right (and pushed on a stack) and expressions are evaluated as soon as their parameters are evaluated.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Non-strict Evaluation of Option[Boolean]\r\n                \r\nGiven a ```\nList[Foo]```\n, I apply a function ```\nf```\n.\n\n```\ndef f(foo: Foo): Option[Boolean]```\n\n\nI wrote this function body to see if any Foo evaluates to ```\nSome(true)```\n.\n\n```\nval optFalse: Option[Boolean] = Some(false)\nval foos: List[Foo] = ... \n\nfoos.foldLeft(optFalse){ \n     (acc: Option[Boolean], elem: Foo) => {\n        val isMatch: Option[Boolean] = f(elem)\n        optionOr(acc)(match) // takes 2 Option[Boolean] and `or`'s them.\n     }\n}\n```\n\n\nHowever, the ```\nf```\n method could be an expensive operation. I'd prefer to \"short-circuit\":\n\n```\nfoos.foldLeft(optFalse){ \n     (acc: Option[Boolean], elem: Foo) => {\n        if( isTrueOption(acc) ) acc\n        else {\n         val isMatch: Option[Boolean] = f(elem)\n         isMatch\n        }        \n     }\n}\n```\n\n\nIs there a non-strict way to fold over the entire ```\nList[Foo]```\n, but stop evaluation once one of the ```\nOption[Boolean]```\n equals ```\nSome(true)```\n without my changed code? Perhaps using the ```\n=>```\n operator?\n\nIf so, I'm thinking that there's a \"space\" cost, but I'm not entirely understanding it. Please include that topic as well in your answer (if there is one).\n    ", "Answer": "\r\nIt's unclear what role ```\nOption```\n is playing in your code. If you just want to find out whether there's any value for which ```\nf```\n returns ```\nSome(true)```\n, that sounds like a good use case for ```\nexists```\n, which is short-circuit:\n\n```\nfoos.exists{x => Some(true) == f(x)}\n```\n\n\nIf you need to know whether any ```\nf```\n returns ```\nNone```\n, then clearly you'll need to evaluate the whole list (at least in the case where they're actually all ```\nSome```\n, which is presumably the interesting case).\n\nIf it has to be a ```\nfold```\n, then ```\nfold```\n is strict (it would be possible to write a non-strict fold, but that wouldn't be the standard ```\nfold```\n). You could use @Peter's solution in a more structured way by using ```\nbreakable```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Evaluate condition irrespective of first outcome\r\n                \r\nI know this is probably a newbie question, however I need to get a recommendation for the design of this.\n\nI need to evaluate the result of a set of conditions and they must be evaluated irrespective of the outcome of a preceding condition. This brings the case of using regular OR(|) or short-circuit evaluation using ||.\n\nBelow is the code that I need to make a design decision about, however the end goal is to be able to evaluate or condition regardless.\n\n```\nprivate bool checkExistingBPNInSession()\n{\n    var exDirectors = (List<ViewModels.NewContact>)Session[\"NewDirectorDetails\"];\n    var exTaxConsultant=(List<ViewModels.NewContact>)Session[Resources.Global.NewTaxConsultantDetails];\n    var exTaRep = (List<ViewModels.NewContact>)Session[\"NewTaxRepresentativeDetails\"];\n    if (exDirectors.Count() != 0 || exTaRep.Count() != 0 || exTaxConsultant.Count() != 0)\n    {\n        var QueryCheckDir = (from x in exDirectors where x.BPN==txtBusinessPartnerIdNumber.Text select x.BPN).ToList();\n        var QueryCheckTaxConsultant = (from x in exTaxConsultant where x.BPN == txtBusinessPartnerIdNumber.Text select x.BPN).ToList();\n        var QueryCheckTaxRep = (from x in exTaRep where x.BPN == txtBusinessPartnerIdNumber.Text select x.BPN).ToList();\n        if (QueryCheckDir.Count() > 0 || QueryCheckTaxConsultant.Count() > 0 || QueryCheckTaxRep.Count() > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return false;\n}\n```\n\n\nThese parts here have to be evaluated:\n\n```\nexDirectors.Count() != 0 || exTaRep.Count() != 0 || exTaxConsultant.Count() != 0```\n \nand this also \n\n```\nQueryCheckDir.Count() > 0 || QueryCheckTaxConsultant.Count() > 0 || QueryCheckTaxRep.Count() > 0\n```\n\n\nPlease, I am seeking the best recommendations.\n\nThanks guys.\n    ", "Answer": "\r\nIf you want an evaluation done, no matter what, you should use the\n\n```\n|-operator```\n - this will evaluate every condition even if the outcome of the final expression would not change (contrary to ```\n||-operator```\n)\n\nHere is a simple demo using dotnetfiddle\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "java short circuit operators\r\n                \r\nMy doubt is about the precedence of short circuit operators.\n\nClassic example of short circuit operator is below.\n\nif(denom != 0 && num/denom > 10 ) \n\nHere usage of shorthand operator allows us to prevent division by zero error because num/denom is never executed.\n\nNow My question is Java says '/' operator has higher precedence than '&&' , then how come left side of '&&' is evaluated before '/'.?\n    ", "Answer": "\r\n```\n/```\n has higher precedence than ```\n>```\n, which has a higher precedence than ```\n&&```\n. So, the expression\n\n```\na && b / c > 0\n```\n\n\nis the same as\n\n```\na && (b / c) > 0\n```\n\n\nwhich is the same as \n\n```\na && ((b / c) > 0)\n```\n\n\nThe expression is then evaluated from left to right. \n\nIf ```\na```\n is false, then the entire expression is false, without even evaluating the second term.\n\nIf ```\na```\n is true, then ```\nb / c```\n is first evaluated, and the result is compared to 0.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "IronPython and DynamicObject that overrides TryUnaryOperation\r\n                \r\nIronPython (2.7.3) seems to not check the TryUnaryOperation with ExpressionType.IsFalse and ExpressionType.IsTrue for performing short-circuit evaluation of the logical AND and OR operations. \n\nHere's an example that uses a class that inherits from DynamicObject. In C#, it works perfectly, but produces a wrong result if used in an IronPython expression. Is that behavior expected or a bug? How can i get IronPython to behave the same way as C#?\n\nThe class:\n\n```\npublic class Dyn : DynamicObject\n{\n    private readonly string text;\n\n    public Dyn(string text)\n    {\n        this.text = text;\n    }\n\n    public override string ToString()\n    {\n        return this.text;\n    }\n\n    public override bool TryBinaryOperation(BinaryOperationBinder binder, object arg, out object result)\n    {\n        result = new Dyn(this + \" \" + binder.Operation + \" \" + arg);\n        return true;\n    }\n\n    public override bool TryUnaryOperation(UnaryOperationBinder binder, out object result)\n    {\n        switch (binder.Operation)\n        {\n            case ExpressionType.IsFalse:\n            case ExpressionType.IsTrue:\n                result = false;\n                return true;\n        }\n\n        return base.TryUnaryOperation(binder, out result);\n    }\n}\n```\n\n\nThe usage:\n\n```\ndynamic a = new Dyn(\"a\");\ndynamic b = new Dyn(\"b\");\ndynamic c = new Dyn(\"c\");\n\nvar correct = a && b || c;\n\nvar engine = Python.CreateEngine();\nvar scope = engine.CreateScope();\nscope.SetVariable(\"a\", a);\nscope.SetVariable(\"b\", b);\nscope.SetVariable(\"c\", c);\nvar incorrect = engine.Execute(\"a and b or c\", scope);\n\nConsole.WriteLine(\"Correct: \" + correct);\nConsole.WriteLine(\"Incorrect: \" + incorrect);\n```\n\n\nPrints:\n\n```\nCorrect: a And b Or c\nIncorrect: b\n```\n\n    ", "Answer": "\r\nThe exact behavior that you desire can not be achieved, but there are some tricks.\nSanity check\nFirst, lets observe, that overridden methods are actually being called and we have correct implementation of ```\nDynamicObject```\n. I have modified your ```\nTryUnaryOperation```\n:\n```\npublic override bool TryUnaryOperation(UnaryOperationBinder binder, out object result)\n{\n    Console.WriteLine(\"TryUnaryOperation was called with operation: {0}\", binder.Operation);\n\n    return base.TryUnaryOperation(binder, out result);\n}\n```\n\nAfter creating ```\nDyn```\n object and passing it into scope like this:\n```\ndynamic a = new Dyn(\"a\");\n\nvar engine = Python.CreateEngine();\nvar scope = engine.CreateScope();\nscope.SetVariable(\"a\", a);\nvar result = engine.Execute(\"not a\", scope);\nConsole.WriteLine(result);\n```\n\nPrints as expected:\n```\nTryUnaryOperation was called with: Not\n```\n\nMotivation\nAfter overriding ```\nTryInvoke```\n, ```\nTryInvokeMember```\n, ```\nTryConvert```\n we can observe, that none of them are called. After surfing I found, that short-circuit operators ```\nand```\n ```\nor```\n cannot be overriden, because:\n\nthey are more like control flow tools than operators and overriding them would be more like overriding if\n\nConsider this question on StackOverflow Any way to override the and operator in Python?\nClose solution\nBut there exist a way to override logical operators ```\n&```\nand ```\n|```\n. Source code for your ```\nDyn```\n is given below\n```\npublic class Dyn : DynamicObject\n{\n    private readonly string text;\n\n    \n    public Dyn(string text)\n    {\n        this.text = text;\n    }\n\n    public override string ToString()\n    {\n        return this.text;\n    }\n\n    public object __and__(Dyn other)\n    {\n        return new Dyn(this + \" and \" + other);\n    }\n\n    public object __or__(Dyn other)\n    {\n        return new Dyn(this + \" or \" + other);\n    }\n}\n```\n\nThen after calling next code it successfully prints ```\na and b or c```\n\n```\ndynamic a = new Dyn(\"a\");\ndynamic b = new Dyn(\"b\");\ndynamic c = new Dyn(\"c\");\n\nvar engine = Python.CreateEngine();\nvar scope = engine.CreateScope();\n\nscope.SetVariable(\"a\", a);\nscope.SetVariable(\"b\", b);\nscope.SetVariable(\"c\", c); \n\nvar correct = engine.Execute(\"a & b | c\", scope);\nConsole.WriteLine(correct);\n```\n\nNote: even if you override ```\nTryGetMember```\n - it still won't be called in ```\na & b```\n expressions. It is completely safe to expect it will be called with ```\na.Name```\n expressions or even ```\na.Name()```\n. You can verify it with next code\n```\npublic override bool TryGetMember(GetMemberBinder binder, out object result)\n{\n    result = \"test\";\n    return true;\n}\n```\n\nAnd call it like ```\na.Name```\n or ```\na.Name()```\n. Later call would result `str is not callable' message error.\nHope this helped you a bit.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "assignment in bash short circuit one-liner\r\n                \r\nCan I assign a variable in a short circuit expression in bash?\n\n```\nx=''\ny='aaa'\n( [ ! -z \"$x\"  ]  && (echo \"using SGE ID\" >&2;  num=\"$x\") ) ||  ( [ ! -z \"$y\" ] && (num=\"z$y\" && echo \"trying y\" ) )\necho \"num : $num : $y\"\nexit 0\n```\n\n\nreturns:\n\n```\ntrying y\nnum :  : aaa\n```\n\n\nSeemingly the point of assignment is reached, but it is not evaluated, or is it in a wrong scope?\n    ", "Answer": "\r\nYou can, but parentheses are not for grouping in the traditional sense. The commands inside parentheses run in a subshell, and any variable assignments in a subshell are local to that shell, invisible outside it.\n\nUse braces instead; note that you need a semicolon to terminate the command before a closing brace if it appears on the same line.\n\n```\nx=''\ny='aaa'\n{ [ ! -z \"$x\"  ]  && { echo \"using SGE ID\" >&2;  num=\"$x\"; }; } ||\n  { [ ! -z \"$y\" ] && { num=\"z$y\" && echo \"trying y\"; }; }\necho \"num : $num : $y\"\nexit 0\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Boolean shortcircuit evaluation in Linq lambda expression\r\n                \r\nI have the following Linq lambda expression:\n\n```\nprivate IEnumerable<SubjectSelectorSubjectGroup> GetSubjectList()\n{\n    User user = db.Users.Find(WebSecurity.CurrentUserId);\n    return db.RequiredSubjects.Where(r => !r.Subject.Name.Contains(\"Home\"))\n                              .GroupBy(r => r.Subject)\n                              .OrderByDescending(r => r.Count())\n                              .Select(r => new SubjectSelectorSubjectGroup()\n                              {\n                                  SubjectId = r.Key.SubjectId,\n                                  SubjectName = r.Key.Name,\n                                  IsInFavourites = HttpContext.Current.Request.IsAuthenticated &&\n                                                  (user.Elective1 != null && user.Elective1.SubjectId == r.Key.SubjectId ||\n                                                   user.Elective2 != null && user.Elective2.SubjectId == r.Key.SubjectId ||\n                                                   user.Elective3 != null && user.Elective3.SubjectId == r.Key.SubjectId),\n                                  Occurrences = r.Count()\n                              });\n}\n```\n\n\nWhen the user is not logged in then the ```\nuser```\n variable in this function is null. This should not be a problem becuase short-circuit boolean evaluation should deal with this. The problem is, it doesn't! Instead, a ```\nSystem.NullReferenceException```\n is thrown.\n\nWhen the user is null ```\nHttpContext.Current.Request.IsAuthenticated```\n returns false. I have checked this by commenting out the bracketed section that references the ```\nuser```\n variable, and then expression evaluates correctly.\n\nDoes anyone know why ```\nLinq to Sql```\n tries to dereference the ```\nuser```\n variable in this situation when it shouldn't actually be necessary? Does anyone have a work around for this issue?\n    ", "Answer": "\r\nThe entire expression is translated to and evaluated as SQL, which means that the ```\n&&```\n operator is not short circuited as expected.\n\nYou can solve the problem by building a list or array of the ```\nElectiveX.SubjectId```\n that you want to search for and then use ```\ntmpList.Contains(r.Key.SubjectId)```\n in the query. That will be translated into a ```\nWHERE IN (...)```\n SQL expression.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Conjunction and multiple return values\r\n                \r\nI have validation methods that return a two-element array of ```\ntrue```\n/```\nfalse```\n and a string. An example is:\n\n```\ndef check_length(name)\n  if(name.length > 50)\n    return false, \"Length more than 50\"\n  else\n    return true, \"\"\n  end\nend\n```\n\n\nI'm trying to check for multiple methods of this kind. I wrote a code like the following:\n\n```\ndef validate\n  value, message =\n  check_length(name) &&\n  is_valid(id) &&\n  is_any_mismatch(name,id) &&\n  is_valid(name) &&\n  ...\nend\n```\n\n\nI expect ```\nvalue```\n to take the ```\ntrue```\n/```\nfalse```\n and ```\nmessage```\n the string value. If ```\ncheck_length```\n returns ```\nfalse```\n, the second method ```\nis_valid```\n should not be evaluated.\n\nBut for the code above, even if ```\ncheck_length```\n returns ```\nfalse```\n, ```\nis_valid```\n is evaluated, and ```\nvalue```\n is overridden by the return value of ```\nis_valid```\n.\n\nHow can we break execution if the first condition is ```\nfalse```\n, and return from ```\nvalidate```\n function? i.e short circuit evaluation should work with two return values.\n    ", "Answer": "\r\nThe return value is an array, so it is never going to be falsy (even if its first element if ```\nfalse```\n). This means that you have to construct the logic the other way using disjunction, not conjunction. A detected error would return an array (i.e., truthy value), and lack of error would be ```\nnil```\n. Then finally, you return an array as a default that has ```\ntrue```\n.\n\n```\ndef check_length(name)\n  if(name.length > 50)\n    return false, \"Length more than 50\"\n  else\n    return nil\n  end\nend\n\ndef validate\n  check_length(name) ||\n  is_valid(id) ||\n  is_any_mismatch(name,id) ||\n  is_valid(name) ||\n  ... ||\n  [true, \"\"]\nend\n```\n\n\nThis will return a two-element array that has ```\ntrue```\n/```\nfalse```\n as the first element and the message as the second.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Ternary to Short-Circuit\r\n                \r\nI'm trying to become more concise with my code and one of the things I never really understood was Short-Circuit Eval. I think it's because when I research the question it doesn't click because usually the examples are pseudo code and I can't wrap my head around it. \n\nThe below code is a pull from an AJAX script I wrote. What would be an equivalent Short Circuit Expression? And if you can, please explain in layman's terms how it's evaluating.\n\n```\nvar xhr; (XMLHttpRequest) ? \nxhr = new XMLHttpRequest : \nxhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n```\n\n    ", "Answer": "\r\nI think the example you've posted isn't a great way to illustrate short-circuiting. I know you say you've seen other examples, but maybe one more will do the trick.\n\nIf you had something like this using a ternary:\n\n```\nvar fruit = apple ? apple : banana;\n```\n\n\nThe intent of this code is \"If apple is truthy, I want fruit to equal apple. Otherwise, fruit should equal banana.\"\n\nThe equivalent way to do it using short-circuiting would look like this:\n\n```\nvar fruit = apple || banana\n```\n\n\nThis code does the same thing because of the way boolean logic works. The ```\n||```\n operator means OR. You probably already know that. But if you think about it, as long as one side of the ```\n||```\n operator is true, the whole statement is true. So if the first item in the expression is true it doesn't even bother checking the second half of it. There would be no point, it would be true either way, why not save some runtime?\n\nAnd the assignment works because of instead of coercing (apple || banana) to a boolean, it just returns the first truthy value and any time you use it in a conditional statement it will be coerced anyways.\n\nHere are some more examples of short circuiting\n\n```\n(1 || 2) // 1\n(0 || 5) // 5 (0 is falsey)\n(false || 0) // If the first value is falsey, the expression evaluates to the second item, whether its truthy or falsey.\n(5 || 0) // 5\n```\n\n\nEDIT:\n\nAnd just to drive home why its called short-circuiting\n\n```\nfunction doWork(){\n    console.log('Hello!');\n}\n\n(true || doWork())\n```\n\n\nNothing would be printed in the console, the ```\ndoWork```\n function would never run. Because to the computer the second half of this expression might as well not exist.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why does `a.is_a? Array && !a.empty?` raise NoMethodError?\r\n                \r\nI'm a Python developer and I just started learning Rails, so this might be a noobish question. I found some surprising behavior in my code:\n\n```\n<!-- render flash message array if set -->\n<% if flash[:notice].is_a? Array && !flash[:notice].empty? %>\n```\n\n\nThis results in the following error: ```\nundefined method `empty?' for nil:NilClass```\n\n\nIt seems like Ruby should not be calling ```\n.empty?```\n in the second part of this clause. I confirmed that short-circuit evaluation works in other cases:\n\n```\n# this is more what I expected\n[3] pry(main)> a = nil\n=> nil\n[5] pry(main)> !a.nil? && a.empty?\n=> false\n...\n[6] pry(main)> a = 1\n=> 1\n[7] pry(main)> !a.nil? && a.empty?\nNoMethodError: undefined method `empty?' for 1:Integer\nfrom (pry):7:in `__pry__'\n```\n\n\nAnyone know why this behavior is happening? Seems to only trigger when I use ```\nis_a?```\n and not the other operators.\n    ", "Answer": "\r\nThis is happening because you are using space and not brackets for the parameters of ```\nis_a?```\n function so rails is trying to send the whole thing as a parameter. Try it like this\n\n```\n<% if flash[:notice].is_a?(Array) && !flash[:notice].empty? %>\n```\n\n\nExplanation:\n\nwhen you write ```\nflash[:notice].is_a? Array && !flash[:notice].empty?```\n rails interpret it like ```\nflash[:notice].is_a?(Array && !flash[:notice].empty?)```\n so ```\nArray```\n is evaluated as ```\ntrue```\n and ```\n!flash[:notice].empty?```\n is evaluated which raises the exception.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to UNPIVOT a table without a UNPIVOT operator?\r\n                \r\nGiven this example:\nPivoted Table\n\nAnd the desired output is the following:\nDesired Result\n\nSo my question is. I'm running a proprietary server which I cannot mention here and this server does not support UNPIVOT operator. I have tried so far the following:\n\n```\nSELECT week,\n       day,\n       username,\n       CASE\n           WHEN main_cat_1 = \"cars\" THEN \"cars\"\n           WHEN main_cat_2 = \"vans\" THEN \"vans\"\n       ELSE null END AS main_cat,\n       CASE\n           WHEN sub_cat_1.1 = \"dirty\" THEN \"dirty\"\n           WHEN sub_cat_1.2 = \"stalled\" THEN \"stalled\"\n       ELSE null END AS sub_cat\n       FROM table1\n```\n\n\nThe issue with this approach is that because of short-circuit evaluation after the first TRUE valueit does not seem to work properly and does not return the expected values.\n    ", "Answer": "\r\n```\nSELECT week,\n    day,\n    username,\n    main_cat_1 as category,\n    sub_cat_1.1 as subcategory\nFROM table1\nUNION\nSELECT week,\n    day,\n    username,\n    main_cat_1,\n    sub_cat_1.2\nFROM table1\nUNION\n...etc.   \n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What (in the specs) warrants that 'non short circuit logical operators will in fact not short circuit?\r\n                \r\nThis is directly inspired by this question.  \nThere are numerous references/statements that bitwise operators, when applied to booleans, will not short circuit. So in other words ```\nboolean a = f() & g()```\n, where ```\nf()```\n and ```\ng()```\n both return boolean, both always will be evaluated.  \nHowever, JLS says only: \n\n\n  15.22.2 Boolean Logical Operators &, ^, and | \n  When both operands of a &, ^, or | operator are of type boolean or Boolean, then the type of\n  the bitwise operator expression is boolean. In all cases, the operands\n  are subject to unboxing conversion (§5.1.8) as necessary.\n  \n  For &, the result value is true if both operand values are true;\n  otherwise, the result is false.\n  \n  For ^, the result value is true if the operand values are different;\n  otherwise, the result is false.\n  \n  For |, the result value is false if both operand values are false;\n  otherwise, the result is true.\n\n\nHow this warrants that both operands are actually evaluated? Apart from ```\nxor```\n, you are still able to break and return result if one of arguments (and it may be second/right being first to be evaluated) violates condition. \nEg. ```\na & b```\n would need only to evaluate ```\nb```\n to be false to evaluate the expression to false.\nPlease note: I'm not asking if it is implemented this way (does not short circuit) -it certainly is. \n\nI'm asking: \n\n\n  Would implementing it with short circuit violate language\n  standard?\n\n    ", "Answer": "\r\nSee JLS 15.7.2 Evaluate Operands before Operation\n\n\n  The Java programming language also guarantees that every operand of an operator (except the conditional operators &&, ||, and ? :) appears to be fully evaluated before any part of the operation itself is performed.\n\n\nSo if you have the operator ```\n&```\n, both operands need to be evaluated before the final result is computed.\n\nAdditionally, the section before that one explicitly requests that the left operand of any binary operator needs to be evaluated first.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Ruby 1.9.2 Object.respond_to? :hello && Object.hello gives error, why?\r\n                \r\nWhile stepping through code today, I noticed something unexpected.  This statement:\n\nif Object.respond_to? :hello && Object.hello\n  #stuff\n\ngives an undefined method error.  But why?  Obviously hello is not a valid method of Object, however given the short-circuit evaluation, shouldn't Object.hello be ignored whenever Object.respond_to? :hello is false?\n\nI noticed this while playing with Authlogic, trying to figure out exactly why the UserSession class must define persisted? in Rails 3.\n\nThanks\n    ", "Answer": "\r\nThe lack of parentheses is leading to a precedence issue:\n\n```\n>> Object.respond_to? :hello && Object.hello\nNoMethodError: undefined method `hello' for Object:Class\n    from (irb):2\n    from /Users/john/.rvm/rubies/ruby-1.9.2-p136/bin/irb:16:in `<main>'\n>> Object.respond_to?(:hello) && Object.hello\n=> false\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What (in the specs) warrants that 'non short circuit logical operators will in fact not short circuit?\r\n                \r\nThis is directly inspired by this question.  \nThere are numerous references/statements that bitwise operators, when applied to booleans, will not short circuit. So in other words ```\nboolean a = f() & g()```\n, where ```\nf()```\n and ```\ng()```\n both return boolean, both always will be evaluated.  \nHowever, JLS says only: \n\n\n  15.22.2 Boolean Logical Operators &, ^, and | \n  When both operands of a &, ^, or | operator are of type boolean or Boolean, then the type of\n  the bitwise operator expression is boolean. In all cases, the operands\n  are subject to unboxing conversion (§5.1.8) as necessary.\n  \n  For &, the result value is true if both operand values are true;\n  otherwise, the result is false.\n  \n  For ^, the result value is true if the operand values are different;\n  otherwise, the result is false.\n  \n  For |, the result value is false if both operand values are false;\n  otherwise, the result is true.\n\n\nHow this warrants that both operands are actually evaluated? Apart from ```\nxor```\n, you are still able to break and return result if one of arguments (and it may be second/right being first to be evaluated) violates condition. \nEg. ```\na & b```\n would need only to evaluate ```\nb```\n to be false to evaluate the expression to false.\nPlease note: I'm not asking if it is implemented this way (does not short circuit) -it certainly is. \n\nI'm asking: \n\n\n  Would implementing it with short circuit violate language\n  standard?\n\n    ", "Answer": "\r\nSee JLS 15.7.2 Evaluate Operands before Operation\n\n\n  The Java programming language also guarantees that every operand of an operator (except the conditional operators &&, ||, and ? :) appears to be fully evaluated before any part of the operation itself is performed.\n\n\nSo if you have the operator ```\n&```\n, both operands need to be evaluated before the final result is computed.\n\nAdditionally, the section before that one explicitly requests that the left operand of any binary operator needs to be evaluated first.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why doesn't the bitwise & operator short-circuit?\r\n                \r\nWe all know that the logical ```\n&&```\n operator short circuits if the left operand is ```\nfalse```\n, because we know that if one operand is ```\nfalse```\n, then the result is also ```\nfalse```\n.\n\nWhy doesn't the bitwise ```\n&```\n operator also short-circuit? If the left operand is ```\n0```\n, then we know that the result is also ```\n0```\n. Every language I've tested this in (C, Javascript, C#) evaluates both operands instead of stopping after the first.\n\nIs there any reason why it would be a bad idea the let the ```\n&```\n operator short-circuit? If not, why don't most languages make it short-cicuit? It seems like an obvious optimization.\n    ", "Answer": "\r\nI'd guess it's because a bitwise ```\nand```\n in the source language typically gets translated fairly directly to a bitwise ```\nand```\n instruction to be executed by the processor. That, in turn, is implemented as a group of the proper number of ```\nand```\n gates in the hardware.\n\nI don't see this as optimizing much of anything in most cases. Evaluating the second operand will normally cost less than testing to see whether you should evaluate it.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Which C++ fold idiom is preferred, short circuit comma or nested lambda? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 6 months ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nFirst option technically has less cognitive load because you don't need to be concerned with ```\n||```\n or ```\n,```\n operators. It is unfortunate that two nested lambdas are required to first get ```\nIs```\n, and then to fold on the inner lambda. See cppreference fold expression examples and StackOverflow fold over pack.\n```\n// option 1\ntemplate<size_t N, typename... Ts> using nth =\n    typename std::tuple_element<N, std::tuple<Ts...>>::type;\n\ntemplate <typename... Ts>\nclass type_list {\n    // ...\npublic:\n    template <typename T>\n    constexpr auto locate()\n    {\n        std::size_t idx{sizeof...(Ts)};\n        [&idx]<std::size_t... Is>(std::index_sequence<Is...>) {\n            ([&idx]() {\n                if (std::is_same_v<T, nth<Is, Ts...>>) {\n                    idx = Is;\n                }\n            }(), ...);\n        } (std::make_index_sequence<sizeof...(Ts)>{});\n        return idx;\n    }\n};\n```\n\nSecond option is shorter and benefits from short circuit evaluation. It feels easier to read - but perhaps deceptively, because the mechanism itself is more complicated. See DevTut fold over comma and StackOverflow fold over comma.\n```\n// option 2\ntemplate <typename... Ts>\nclass type_list {\n    // ...\npublic:\n    template <typename T>\n    constexpr auto locate() {\n        return [] <std::size_t... Is> (std::index_sequence<Is...>) {\n            std::size_t idx{sizeof...(Ts)};\n            ((idx = Is, std::is_same_v<T, Ts>) || ...);\n            return idx;\n        } (std::make_index_sequence<sizeof...(Ts)>{});\n    }\n};\n```\n\nIn C++26, we will hopefully get ```\nfor...```\n and until then, what is considered more idiomatic?\nOkay, maybe \"idiomatic\" isn't the right word. Which of these compile time compatible looping structures is least offensive, in place of first class language support for parameter packs and folding on control flow, to perform basic variadic template metaprogramming in C++20?\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Boolean short circuit\r\n                \r\nJexl already supports boolean short circuiting\nExpression = A || B\nif A = True, B doesn't have to be set.\n\nHowever if A = False and B is not set, the evaluation throws JexlException exception - undefined variable B.\n\nThe use case is to lazily evaluate B.\nIs there a clean way to find out if the expression can be short circuited with what variables value we know currently?\nIs handling JexlException and then proceeding to evaluate B right way?\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Java Optimization\r\n                \r\nI want to know if java optimize this code?\nDoes it use Short-circuit (http://en.wikipedia.org/wiki/Short-circuit_evaluation) evaluation?\n\n```\nboolean c5 = A || B\nboolean c4 = C && D\nboolean c3 = E || F\nboolean c2 = G && H\n\nif ((c5) && (c4) && (c3) && (c2)){\n  //execute operation\n}\n```\n\n    ", "Answer": "\r\nYes. It does use Short-circuit evaluation (represented by ```\n&&```\n and ```\n||```\n operators). Your condition \n\n```\n(c5) && (c4) && (c3) && (c2)\n```\n\n\nis essentially same as \n\n```\n(A || B) && (C && D) && (E || F) && (G && H)\n```\n\n\nwhich is same as \n\n```\n(A || B) &&  C && D  && (E || F) &&  G && H\n```\n\n\nso \n\n\nif ```\nA```\n will be evaluated as ```\ntrue```\n then ```\nB```\n will not be tested. \nif ```\nA```\n and ```\nB```\n will be ```\nfalse```\n then entire expression will be equal to \n\n```\nfalse && C && D && (E || F) && G && H\n```\n\n\nwhich is always ```\nfalse```\n (because ```\nfalse && whatever```\n is always ```\nfalse```\n) so ```\nC && D && (E || F) && G && H```\n will not be evaluated\n\n\nand so on, and on...\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Resilience4j circuit breaker used with reactive Flux never changes to OPEN on errors\r\n                \r\nI am evaluating resilience4j to include it in our reactive APIs, so far I am using mock Fluxes.\n\nThe service below always fails as I want to test if the circuit OPENs on multiple errors:\n\n```\n@Service\nclass GamesRepositoryImpl : GamesRepository {\n\n    override fun findAll(): Flux<Game> {\n        return if (Math.random() <= 1.0) {\n            Flux.error(RuntimeException(\"fail\"))\n        } else {\n            Flux.just(\n                    Game(\"The Secret of Monkey Island\"),\n                    Game(\"Loom\"),\n                    Game(\"Maniac Mansion\"),\n                    Game(\"Day of the Tentacle\")).log()\n        }\n    }\n}\n```\n\n\nThis is the handler that uses the repository, printing the state of the circuit:\n\n```\n@Component\nclass ApiHandlers(private val gamesRepository: GamesRepository) {\n\n    var circuitBreaker : CircuitBreaker = CircuitBreaker.ofDefaults(\"gamesCircuitBreaker\")\n\n    fun getGames(serverRequest: ServerRequest) : Mono<ServerResponse> {\n        println(\"*********${circuitBreaker.state}\")\n        return ok().body(gamesRepository.findAll().transform(CircuitBreakerOperator.of(circuitBreaker)), Game::class.java)\n    }\n}\n```\n\n\nI invoke the API endpoint many times, always getting this stacktrace:\n\n```\n*********CLOSED\n2018-03-14 12:02:28.153 ERROR 1658 --- [ctor-http-nio-3] .a.w.r.e.DefaultErrorWebExceptionHandler : Failed to handle request [GET http://localhost:8081/api/v1/games]\n\njava.lang.RuntimeException: FAIL\n    at com.codependent.reactivegames.repository.GamesRepositoryImpl.findAll(GamesRepositoryImpl.kt:12) ~[classes/:na]\n    at com.codependent.reactivegames.web.handler.ApiHandlers.getGames(ApiHandlers.kt:20) ~[classes/:na]\n    ...\n\n2018-03-14 12:05:48.973 DEBUG 1671 --- [ctor-http-nio-2] i.g.r.c.i.CircuitBreakerStateMachine     : No Consumers: Event ERROR not published\n2018-03-14 12:05:48.975 ERROR 1671 --- [ctor-http-nio-2] .a.w.r.e.DefaultErrorWebExceptionHandler : Failed to handle request [GET http://localhost:8081/api/v1/games]\n\njava.lang.RuntimeException: fail\n    at com.codependent.reactivegames.repository.GamesRepositoryImpl.findAll(GamesRepositoryImpl.kt:12) ~[classes/:na]\n    at com.codependent.reactivegames.web.handler.ApiHandlers.getGames(ApiHandlers.kt:20) ~[classes/:na]\n    at com.codependent.reactivegames.web.route.ApiRoutes$apiRouter$1$1$1.invoke(ApiRoutes.kt:14) ~[classes/:na]\n```\n\n\nAs you see the circuit is always CLOSED. I don't know if it has anything to do but notice this message ```\nNo Consumers: Event ERROR not published```\n.\n\nWhy isn't this working?\n\n\n    ", "Answer": "\r\nThe problem was the default ```\nringBufferSizeInClosedState```\n which is 100 requests and I never made so many manual requests.\n\nI setup my own ```\nCircuitBreakerConfig```\n for my tests and now the circuit opens right away:\n\n```\nval circuitBreakerConfig : CircuitBreakerConfig = CircuitBreakerConfig.custom()\n        .failureRateThreshold(50f)\n        .waitDurationInOpenState(Duration.ofMillis(10000))\n        .ringBufferSizeInHalfOpenState(5)\n        .ringBufferSizeInClosedState(5)\n        .build()\nvar circuitBreaker: CircuitBreaker = CircuitBreaker.of(\"gamesCircuitBreaker\", circuitBreakerConfig)\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Short circuit error handling in C\r\n                \r\nI was wondering if there was a better way of handling the case in C where you want to exit a function as soon as you encounter an error in a series of expressions.  (in this case, its a function that returns a NULL on error)\n\ne.g. in some C code where they tried to short circuit error handling by combining a series of statements with AND (&&).\n\n```\nreturn doSomething() && \n     doSomething2() && \n     doSomething3() && ... ;\n```\n\n\nThis irritates me since we're cramming so much on one line in one statement.  But I guess the alternative is\n\n```\nif (!(value = doSomething()))\n    return NULL;\nif (!(value = doSomething2()))\n    return NULL;\netc\nreturn value;\n```\n\n\nBut what about short circuit error evaluation that I've seen in perl and bash scripts..\n\n```\nint die(int retvalue) {\n    exit(retvalue);\n}\n.....\n(value = doSomething()) || die(1);\n(value = doSomething2()) || die(2);\n(value = doSomething3()) || die(3);\nreturn value;\n```\n\n\nThe main problem with this is that the RHS has to be an expression so you can't really goto or return from the function.  Would anyone find this of value or is it too limited?\n\nedit: I guess I should have meant to include newlines in the first example.  The problem is that you need to be careful if you decide to add another expression in the middle.\n    ", "Answer": "\r\nI've seen the use of GOTOs in C for this exact purpose.\n\nBecause there isn't a 'finally' construct in C, a method was needed to free all your memory even if you were exiting a function early. \n\nSo it's essentially as follows \n(could someone correct my C syntax if I'm wrong, I'm a bit rusty)\n\n```\nint foo()\n{\n    /* Do Stuff */\n    if(!DoSomething())\n        GOTO Failure;\n\n    if(!DoSomething2())\n        GOTO Failure;\n\n    if(!DoSomething3())\n        GOTO Failure;\n\n    /* return success */\n    return true; \n\n    Failure:\n    /* release allocated resources */\n    /* print to log if necessary */\n    return false;\n}\n```\n\n\nImportant note\nDo not use GOTOs for execution flow. They should only be used on error, and only to go to the end of the current function. If you use them for anything else, you're creating spaghetti code that could possibly destroy the fabric of reality. Just don't do it.\n\nEDIT\n\nAs one of the posters noted, using Exit(x) will kill your entire program, which keeps that solution reserved for fatal errors. However your original proposed solution (DS() && DS2() && DS3()) all on one line poses a problem for error handling. \n\nIf you wanted to wrap the functions in some sort of function specific error handling, there is no way to do it when you wrap the function calls all in one line. So, at the very least you could do something like\n\n```\nint result1 = 0;\nint result2 = 0;\nint result3 = 0;\n\nresult1 = DoSomething();\n\nif(result1)\n    result2 = DoSomething2();\n\nif(result2)\n    result3 = DoSomething3();\n\nreturn result1 && result2 && result3;\n```\n\n\nBecause this method would not preclude error handling.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Does MySQL short-circuit the ORDER BY clause?\r\n                \r\nGiven this SQL:\n\n```\nSELECT * FROM mytable ORDER BY mycolumn, RAND()\n```\n\n\nAssuming that ```\nmycolumn```\n happens to only contain unique values (and hence, contains enough information to perform the ```\nORDER BY```\n), does MySQL short-circuit the operation and skip evaluating the rest?\n    ", "Answer": "\r\nI think this is the answer. Mysql uses different plans and can't perform lazy evaluation (o \"hort-circuit\").\n\n```\nmysql> explain select * from avatar  order by id;\n+----+-------------+--------+-------+---------------+---------+---------+------+-------+-------+\n| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows  | Extra |\n+----+-------------+--------+-------+---------------+---------+---------+------+-------+-------+\n|  1 | SIMPLE      | avatar | index | NULL          | PRIMARY | 8       | NULL | 28777 |       |\n+----+-------------+--------+-------+---------------+---------+---------+------+-------+-------+\n1 row in set (0.00 sec)\n\nmysql> explain select * from avatar  order by id, name;\n+----+-------------+--------+------+---------------+------+---------+------+-------+----------------+\n| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows  | Extra          |\n+----+-------------+--------+------+---------------+------+---------+------+-------+----------------+\n|  1 | SIMPLE      | avatar | ALL  | NULL          | NULL | NULL    | NULL | 28777 | Using filesort |\n+----+-------------+--------+------+---------------+------+---------+------+-------+----------------+\n1 row in set (0.00 sec)\nmysql> explain select * from avatar  order by id, RAND();\n+----+-------------+--------+------+---------------+------+---------+------+-------+---------------------------------+\n| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows  | Extra                           |\n+----+-------------+--------+------+---------------+------+---------+------+-------+---------------------------------+\n|  1 | SIMPLE      | avatar | ALL  | NULL          | NULL | NULL    | NULL | 28782 | Using temporary; Using filesort |\n+----+-------------+--------+------+---------------+------+---------+------+-------+---------------------------------+\n1 row in set (0.00 sec)\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to do non short circuit condition in Typescript?\r\n                \r\nHow to evaluate condition in non short circuit way in typescript?\nTypescript does not allow ```\n&```\n or ```\n|```\n for boolean type.\nThe reason why I need a non short circuit checking is I call showErrors in function ```\nisValueValid```\n.\n\nGiven this function\n\n```\nfunction isValue1Valid(){\n  if(value1 === 0) return true;    \n  showErrors1();\n  return false;\n}\n\nfunction isValue2Valid(){\n  if(value2 === 0) return true;    \n  showErrors2();\n  return false;\n}\n```\n\n\nThen in my condition\n\n```\nif(isValue2Valid() & isValue2Valid()){\n//Submit data\n}\n```\n\n\nAlthough I can do it like this one\n\n```\nif(isValue2Valid() & isValue2Valid()){\n//Submit data \n   return;\n}\nshowErrors1()\nshowErrors2()\n```\n\n\nBut I feel to call it inside isValueValid function. In reality I always think to call show errors by default whenever there's an error.\n    ", "Answer": "\r\nTo answer your question, you could do\n\n```\nif ([isValue2Valid(), isValue2Valid()].every(Boolean)) {\n    //Submit data\n}\n```\n\n\nto evaluate all function calls and then combine their values. But you really shouldn't have ```\nisValueValid```\n call ```\nshowError```\n in the first place. Instead, make your test functions ```\nreturn```\n the error messages, and then if there are any, show them:\n\n```\nfunction getValue1Error() {\n    if (value1 === 0) return null;\n    else return \"error1\";\n}\n\nfunction getValue2Error() {\n    if (value2 === 0) return null; \n    else return \"error2\";\n}\n\n// then:\nconst errors = [getValue1Error(), getValue2Error()] // or even better, just a loop over your fields\nif (errors.some(Boolean)) {\n    for (let error of errors)\n        showError(error);\n} else {\n    // Submit data\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is it possible to have a recursive function computed at compile-time in Rust?\r\n                \r\nI want to compute the factorial of a ```\nconst```\n:\n```\nconst N: usize = 4;\nconst N_PERMUTATIONS = factorial(N);\n```\n\nThe solutions I've thought of that don't work in Rust 1.18 are:\n\n```\nconst fn```\n — conditional statements are not allowed (or at least not implemented) in ```\nconst fn```\n, so neither of these will compile:\n```\nconst fn factorial(n: usize) -> usize {\n    match n {\n        0 => 1,\n        _ => n * factorial(n-1)\n    }\n}\n```\n\n```\nconst fn factorial(n: usize) -> usize {\n    if n == 0 {\n        1\n    } else {\n        n * factorial(n-1)\n    }\n}\n```\n\n\nmacros — evaluation of expressions is performed after all macro expansion.  This macro will never reach the base case, since after four iterations the argument is ```\n4-1-1-1-1```\n, which is not matched by ```\n0```\n:\n```\nmacro_rules!factorial {\n    (0) => (1);\n    ($n:expr) => ($n * factorial($n-1));\n}\n```\n\n\n\nI also tried the following, which would work if ```\n*```\n had short-circuit evaluation, but as-is has unconditional recursion which yields a stack overflow:\n```\nconst fn factorial(n: usize) -> usize {\n    ((n == 0) as usize) + ((n != 0) as usize) * n * factorial(n-1)\n}\n```\n\nAs Matthieu M. pointed out, we can avoid integer underflow (but not stack overflow) by using ```\nfactorial(n - ((n != 0) as usize))```\n.\nFor now I've resorted to manually computing the factorial.\n    ", "Answer": "\r\nSince your original question, Rust has been updated and now supports conditionals in ```\nconst fn```\n, so the first two solutions work. See the Const functions section in the Rust Reference\nwhich states that you can have \"Calls to other safe const functions (whether by function call or method call)\" in const functions.\nFor your particular factorial example, you have (at least) a couple options. Here is a factorial function that I have successfully compiled:\n```\nconst fn factorial(n: u64) -> u64 {\n    match n {\n        0u64 | 1u64 => 1,\n        2u64..=20u64 => factorial(n - 1u64) * n,\n        _ => 0,\n    }\n}\n```\n\nNote, n! where n > 20 will overflow a ```\nu64```\n, so I decided to return 0 in that case. Also, since ```\nusize```\n could be a 32-bit value, I explicitly use the 64-bit ```\nu64```\n in this case. Handling the ```\nu64```\n overflow case also prevents the stack overflow. This could return an ```\nOption<u64>```\n instead:\n```\nconst fn factorial(n: u64) -> Option<u64> {\n    match n {\n        0u64 | 1u64 => Some(1),\n        2u64..=20u64 => match factorial(n - 1u64) {\n            Some(x) => Some(n * x),\n            None => None,\n        },\n        _ => None,\n    }\n}\n```\n\nIn my case, returning an ```\nOption<u64>```\n limited how I could use the function, so I found it more useful to just return a ```\nu64```\n with 0 as the analogue to ```\nNone```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "What are the possible ways the following expression is actually evaluated?\r\n                \r\nNote - Assume the code is in JAVA\nSuppose I have a function -\n```\npublic boolean Helper(){\nboolean a = ...;\nboolean b = ...;\nboolean c = ...;\nboolean d = ...;\nreturn a || b && c || d;\n}\n```\n\nI want to understand what are the possible ways in which the expression is actually evaluated. I am not talking about the logic table where we fill up ones and zeroes.\nFor example - To my understanding, if a is true, it won't matter what values the rest of the variables hold.( As there will be short circuit evaluation)\nCan someone please help me in listing down all such conclusions? This boolean expression is very confusing to me\n    ", "Answer": "\r\nAll you need to know is three things:\n\nPrecedence rules. That is evaluated either as ```\n(a || b) && (c || d)```\n, or as ```\na || (b && c) || d```\n or as ```\n((a || b) && c) || d```\n. A simple matter of searching the web for 'java operators precedence' will get you your answer.\n\nAwareness that in java, the doubled up versions of the or and and operator (```\n||```\n and ```\n&&```\n, being used here) 'short circuit'. ```\na && b```\n will not eval b if ```\na```\n is false, as the result is already known.\n\nbasic logic tables.\n\n\nAll this stuff is trivially found. I think the homework exercise partly involves you actually looking all this up :)\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "C++ inline String formatting and numeric conversion\r\n                \r\nC# has a nice static method \n\n```\nString.Format(string, params string[]);\n```\n\n\nthat returns a new string with the formatting and values that are provided.  Is there an equivalent in C++?\n\nThe reason is because I'm using log4cxx and want to take advantage of the macros like\n\n```\nLOG4CXX_DEBUG( logger, expr );\n```\n\n\nthat uses short-circuit evaluation so that expr is never evaluated if the log level DEBUG is not enabled.\n\nCurrently, in C++, I do it like this:\n\n```\nCString msg;\nmsg.Format( formatString, values... );\n\nLOG4CXX_INFO( _logger, msg );\n```\n\n\nwhich is defeating the purpose since I have to allocate and format the string first so there isn't nearly as efficiency coming out of the short-circuit logic.\n\nThere's a similar problem when trying to do simple logging with numerical values.  This, won't compile:\n\n```\nLOG4CXX_DEBUG( _logger, \"the price is \" + _some-double_);\n```\n\n\nSo I end up having to write something like this:\n\n```\nCString asStr;\nasStr.Format( \"%d\", _some-double_ );\nLOG4CXX_DEBUG( _logger, \"the price is \" + asStr );\n```\n\n\nwhich again defeats the purpose.\n\nI'm not at all a C++ expert so I'm hoping more knowledgeable people can help.\n    ", "Answer": "\r\nlog4cxx accepts stream like parameters, so you can write, for example:\n\n```\nLOG4CXX_DEBUG( _logger, \"the price is \" << price );\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Conjuction template doesn't short circuit\r\n                \r\nI want to be able to evaluate whether a function accepts one argument of type int, and whether it returns void. To that end I used ```\nstd::conjunction```\n since I believed it was supposed to short-circuit and not evaluate the second ill-formed expression in case the function is not callable with one argument of type int, but for some reason I get a compiler error:\n\n```\n#include <iostream>\n#include <type_traits>\ntemplate<typename Function>\nstruct oneArgVoid\n{\n    static constexpr bool value = std::conjunction_v<std::is_invocable<Function, int>, std::is_void<std::invoke_result_t<Function, int>>>;\n};\n\nint main()\n{\n    auto l1 = [](auto x) {};\n    std::cout << oneArgVoid<decltype(l1)>::value << \"\\n\";\n    auto l2 = [](auto x) {return 1; };\n    std::cout << oneArgVoid<decltype(l2)>::value << \"\\n\";\n    auto l3 = [](auto x, auto y) {};\n    std::cout << oneArgVoid<decltype(l3)>::value << \"\\n\";\n    return 0;\n}\n```\n\n\nNote that if ```\noneArgVoid```\n is not called on ```\nl3```\n the code compiles. Live demo: https://godbolt.org/z/8BUfpT\n\nI do not use boost, so I cannot use ```\nmpl::eval_if```\n. But I thought that ```\nstd::conjunction```\n was supposed to short circuit here, am I wrong?\n\nConsidering HolyBlackCat's suggestion, here's something even stranger: https://godbolt.org/z/2SUij-\n    ", "Answer": "\r\nIt seems like ```\nstd::conjunction```\n short-circuits only on the values of the types, the types themselves still have to be well-formed. So this: ```\nstd::is_void<std::invoke_result_t<Function, int>>```\n is actually rightfully illegal here. Due to that with the modification:\n\n```\ntemplate<typename Function>\nstruct argVoid\n{\n    static constexpr bool value = std::is_void_v<std::invoke_result_t<Function, int>>;\n};\n\ntemplate<typename Function>\nstruct oneArgVoid\n{\n    static constexpr bool value = std::conjunction_v<std::is_invocable<Function, int>, argVoid<Function>>;\n};\n```\n\n\nIt works, since the ill-formed expression is now in the value variable, which means it doesn't get evaluated due to the short-circuit.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Spring form validation optimization (short-circuiting)\r\n                \r\nI'm trying to optimize a Spring form validation by skipping as many database hits as possible. Here's an example validator that I have:\n\n```\nimport org.springframework.validation.Errors;\nimport org.springframework.validation.ValidationUtils;\nimport org.springframework.validation.Validator;\n\nimport com.my.Car;\n\npublic class CarValidator implements Validator {\n    @Override\n    public boolean supports(Class<?> c) {\n        return c.equals(Car.class);\n    }\n\n    @Override\n    public void validate(Object car, Errors result) {\n        ValidationUtils.rejectIfEmptyOrWhitespace(result, \"seats\", \"NotEmpty.car.seats\");\n        ValidationUtils.rejectIfEmptyOrWhitespace(result, \"colour\", \"NotEmpty.car.colour\");\n\n        // hitting the database here\n    }\n\n}\n```\n\n\nI don't want to access the database if some of the first two validations have failed. If the seats or colour fields are empty, stop processing the validation and return to the controller. But if all validations have passed, hit the db and then do the rest. Like the  short-circuit evaluation of AND in most languages.\n    ", "Answer": "\r\nSurround your db call with a check for the number of errors found:\n\n```\nif (result.getErrorCount() == 0) {\n    //do the DB checks\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How does non-strict and lazy differ?\r\n                \r\nI often read that lazy is not the same as non-strict but I find it hard to understand the difference. They seem to be used interchangeably but I understand that they have different meanings. I would appreciate some help understanding the difference.\nI have a few questions which are scattered about this post. I will summarize those questions at the end of this post. I have a few example snippets, I did not test them, I only presented them as concepts. I have added quotes to save you from looking them up. Maybe it will help someone later on with the same question.\nNon-Strict Def:\n\nA function f is said to be strict if, when applied to a nonterminating\nexpression, it also fails to terminate. In other words, f is strict\niff the value of f bot is |. For most programming languages, all\nfunctions are strict. But this is not so in Haskell. As a simple\nexample, consider const1, the constant 1 function, defined by:\nconst1 x                = 1\nThe value of const1 bot in Haskell is 1. Operationally speaking, since\nconst1 does not \"need\" the value of its argument, it never attempts to\nevaluate it, and thus never gets caught in a nonterminating\ncomputation. For this reason, non-strict functions are also called\n\"lazy functions\", and are said to evaluate their arguments \"lazily\",\nor \"by need\".\n\n-A Gentle Introduction To Haskell: Functions\nI really like this definition. It seems the best one I could find for understanding strict. Is ```\nconst1 x = 1```\n lazy as well?\n\nNon-strictness means that reduction (the mathematical term for\nevaluation) proceeds from the outside in,\nso if you have (a+(bc)) then first you reduce the +, then you reduce\nthe inner (bc).\n\n-Haskell Wiki: Lazy vs non-strict\nThe Haskell Wiki really confuses me. I understand what they are saying about order but I fail to see how ```\n(a+(b*c))```\n would evaluate non-strictly if it was pass ```\n_|_```\n?\n\nIn non-strict evaluation, arguments to a function are not evaluated\nunless they are actually used in the evaluation of the function body.\nUnder Church encoding, lazy evaluation of operators maps to non-strict\nevaluation of functions; for this reason, non-strict evaluation is\noften referred to as \"lazy\". Boolean expressions in many languages use\na form of non-strict evaluation called short-circuit evaluation, where\nevaluation returns as soon as it can be determined that an unambiguous\nBoolean will result — for example, in a disjunctive expression where\ntrue is encountered, or in a conjunctive expression where false is\nencountered, and so forth. Conditional expressions also usually use\nlazy evaluation, where evaluation returns as soon as an unambiguous\nbranch will result.\n\n-Wikipedia: Evaluation Strategy\nLazy Def:\n\nLazy evaluation, on the other hand, means only evaluating an\nexpression when its results are needed (note the shift from\n\"reduction\" to \"evaluation\"). So when the evaluation engine sees an\nexpression it builds a thunk data structure containing whatever values\nare needed to evaluate the expression, plus a pointer to the\nexpression itself. When the result is actually needed the evaluation\nengine calls the expression and then replaces the thunk with the\nresult for future reference.\n...\nObviously there is a strong correspondence between a thunk and a\npartly-evaluated expression. Hence in most cases the terms \"lazy\" and\n\"non-strict\" are synonyms. But not quite.\n\n-Haskell Wiki: Lazy vs non-strict\nThis seems like a Haskell specific answer. I take that lazy means thunks and non-strict means partial evaluation. Is that comparison too simplified? Does lazy always mean thunks and non-strict always mean partial evaluation.\n\nIn programming language theory, lazy evaluation or call-by-need1 is\nan evaluation strategy which delays the evaluation of an expression\nuntil its value is actually required (non-strict evaluation) and also\navoid repeated evaluations (sharing).\n\n-Wikipedia: Lazy Evaluation\nImperative Examples\nI know most people say forget imperative programming when learning a functional language. However, I would like to know if these qualify as non-strict, lazy, both or neither? At the very least it would provide something familiar.\nShort Circuiting\n```\nf1() || f2()\n```\n\nC#, Python and other languages with \"yield\"\n```\npublic static IEnumerable Power(int number, int exponent)\n{\n    int counter = 0;\n    int result = 1;\n    while (counter++ < exponent)\n    {\n        result = result * number;\n        yield return result;\n    }\n}\n```\n\n-MSDN: yield (c#)\nCallbacks\n```\nint f1() { return 1;}\nint f2() { return 2;}\n\nint lazy(int (*cb1)(), int (*cb2)() , int x) {\n    if (x == 0)\n        return cb1();\n    else\n        return cb2();\n}\n\nint eager(int e1, int e2, int x) {\n    if (x == 0)\n         return e1;\n    else\n         return e2;\n}\n\nlazy(f1, f2, x);\neager(f1(), f2(), x);\n```\n\nQuestions\nI know the answer is right in front of me with all those resources, but I can't grasp it. It all seems like the definition is too easily dismissed as implied or obvious.\nI know I have a lot of questions. Feel free to answer whatever questions you feel are relevant. I added those questions for discussion.\n\nIs ```\nconst1 x = 1```\n also lazy?\nHow is evaluating from \"inward\" non-strict? Is it because inward allows reductions of unnecessary expressions, like in ```\nconst1 x = 1```\n? Reductions seem to fit the definition of lazy.\nDoes lazy always mean thunks and non-strict always mean partial evaluation? Is this just a generalization?\nAre the following imperative concepts Lazy, Non-Strict, Both or Neither?\n\nShort Circuiting\nUsing yield\nPassing Callbacks to delay or avoid execution\n\n\nIs lazy a subset of non-strict or vice versa, or are they mutually exclusive. For example is it possible to be non-strict without being lazy, or lazy without being non-strict?\nIs Haskell's non-strictness achieved by laziness?\n\nThank you SO!\n    ", "Answer": "\r\nNon-strict and lazy, while informally interchangeable, apply to different domains of discussion.  \n\nNon-strict refers to semantics: the mathematical meaning of an expression.  The world to which non-strict applies has no concept of the running time of a function, memory consumption, or even a computer. It simply talks about what kinds of values in the domain map to which kinds of values in the codomain.  In particular, a strict function must map the value ⊥ (\"bottom\" -- see the semantics link above for more about this) to ⊥; a non strict function is allowed not to do this.\n\nLazy refers to operational behavior: the way code is executed on a real computer.  Most programmers think of programs operationally, so this is probably what you are thinking.  Lazy evaluation refers to implementation using thunks -- pointers to code which are replaced with a value the first time they are executed.  Notice the non-semantic words here: \"pointer\", \"first time\", \"executed\".\n\nLazy evaluation gives rise to non-strict semantics, which is why the concepts seem so close  together.  But as FUZxxl points out, laziness is not the only way to implement non-strict semantics.\n\nIf you are interested in learning more about this distinction, I highly recommend the link above.  Reading it was a turning point in my conception of the meaning of computer programs.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Test coverage for if statement with logical or (||) - with Java's short circuiting, what's the forth condition JaCoCo wants me to cover?\r\n                \r\nThis is probably a rather simple question, but I'm at a loss...\n\nI have an if statement like the following:\n\n```\nif(TheEnum.A.equals(myEnum) || TheEnum.B.equals(myEnum))\n```\n\n\n```\nTheEnum```\n can be ```\nA```\n, ```\nB```\n, ```\nC```\n, ... ```\nG```\n (more than just 4 options).\n\nJaCoCo (SONAR) tells me that there are four conditions I can cover here.\nWhich ones are those?\nIsn't the entire set I can test for in this instance essentially\n\n```\nif(true || not_evaluated) => true\nif(false || true) => true\nif(false || false) => false\n```\n\n\nI'm pretty sure I can't specifically test for\n```\nif(true || true)```\n or\n```\nif(true || false)```\n,\nas short circuit evaluation won't get that far...?\n\nIf so, what is the forth option JaCoCo/Sonar wants me to test for?\n    ", "Answer": "\r\nYou are right, this code is short-circuiting. It's compiled into bytecode roughly like this (assuming Java has goto):\n\n```\nif(TheEnum.A.equals(myEnum)) goto ok;\nif(!TheEnum.B.equals(myEnum)) goto end;\nok:\n   // body of if statement\nend:\n```\n\n\nSo as JaCoCo analyzes the bytecode, from its point of view you have the two independent checks: first ```\nif```\n and second ```\nif```\n, which generate four possible branches. You may consider this as a JaCoCo bug, but I guess it's not very easy to fix this robustly and it is not very disturbing, so you can live with it.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Use $geowithin on multiple boxes - mongoDB\r\n                \r\nI need to search all the Points lying in boxes. So I am using following query in mongoDB \n\n\n\n```\ndb.places.find({ \n    \"loc\" : { \n        \"$geoWithin\" : { \n            \"$box\": [ \n                [ 0 , 0 ] ,\n                [ 100 , 100 ]\n             ] \n         }\n     } \n})\n```\n\n\nNow I have multiple boxes to be searched within and I want to get all the Points that lie in any of the boxes. I want something like \n\n```\ndb.places.find({ \n    \"loc\": { \n        \"$geoWithin\": { \n            \"$box\":[ [ 0 , 0 ], [ 25 , 25 ] ],\n                [ [ 40 , 40 ] , [ 75 , 75 ] ],\n                [ [ 90 , 90 ] , [ 100 , 100 ] ] \n         }\n     }\n})\n```\n\n\nI can't use ```\n$or```\n as its does Short-Circuit evaluation. I can't also use aggregation as only ```\n$geonear```\n is supported in aggregation. I don't want to hit one seperate query for each box. Please suggest.  \n    ", "Answer": "\r\nThere are some \"shortcut\" type operators available for \"geo\" type queries that are pre-defined such as ```\n$box```\n. But for anything more advanced you are actually going to want to formally declare the GeoJSON structure and use the ```\n$geometry```\n operator instead:\n\nSo if you consider the following documents:\n\n\n\n```\n{ \"loc\" : { \"type\" : \"Point\", \"coordinates\" : [ 3, 6 ] } }\n{ \"loc\" : { \"type\" : \"Point\", \"coordinates\" : [ 9, 12 ] } }\n{ \"loc\" : { \"type\" : \"Point\", \"coordinates\" : [ 45, 45 ] } }\n{ \"loc\" : { \"type\" : \"Point\", \"coordinates\" : [ 30, 30 ] } }\n{ \"loc\" : { \"type\" : \"Point\", \"coordinates\" : [ 76, 76 ] } }\n```\n\n\nWith then the following query:\n\n```\ndb.geo.find({\n    \"loc\": {\n        \"$geoWithin\": {\n            \"$geometry\":{\n                \"type\": \"MultiPolygon\",\n                \"coordinates\": [\n                    [[ [ 0, 0 ], [ 0, 25 ], [ 25, 25 ], [ 25, 0 ], [ 0, 0 ] ]],\n                    [[ [ 40, 40 ], [ 40, 75 ], [ 75, 75 ], [ 75, 40 ], [ 40, 40 ] ]],\n                    [[ [ 80, 80 ], [ 80, 90 ], [ 90, 90 ], [ 90, 80 ], [ 80, 80 ] ]]\n                ]\n            }\n        }\n    }\n})\n```\n\n\nYou would get the returned result:\n\n```\n{ \"loc\" : { \"type\" : \"Point\", \"coordinates\" : [ 3, 6 ] } }\n{ \"loc\" : { \"type\" : \"Point\", \"coordinates\" : [ 9, 12 ] } }\n{ \"loc\" : { \"type\" : \"Point\", \"coordinates\" : [ 45, 45 ] } }\n```\n\n\nSo the full support for GeoJSON geometry is what you need for this type of query.\n\nThis definitely works with MongoDB 2.6 and should also be the case with 2.4.10. The extended GeoJSON types are available for indexes as of these releases, but (untried) possibly do work as a query form in earlier 2.4 versions.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Ansible undefined variables in check mode\r\n                \r\nConsider this playbook:\n```\n---\n- name: test\n  hosts: localhost\n  gather_facts: no\n  tasks:\n\n  - name: foo\n    shell: echo foo                             # skipped when running in check mode\n    register: result\n\n  - debug: msg=\"foo\"\n    when: (result is defined)\n          and (result.stdout == 'foo')\n```\n\nI thought the ```\nis defined```\n would result in short circuit evaluation as in other languages, but it doesn't.\nIf this is run in check mode, I get:\n\nfatal: [localhost]: FAILED! => {\"msg\": \"The task includes an option with an undefined variable. The error was: 'dict object' has no attribute 'stdout'\n\nI know I can ignore the error with ```\nignore_errors: \"{{ansible_check_mode}}\"```\n, but I want to learn how to fix this problem.\nHow do I rewrite the ```\nwhen```\n clause to prevent referencing undefined variables?\n    ", "Answer": "\r\nActually, if you debug the var without a condition, you will see it is defined. It simply does not contain a ```\nstdout```\n key since the task was skipped. The correct ways to work arround this (non exhaustive list):\n```\n- debug: msg=\"{{ result.stdout | default('no value') }}\n  when: result.stdout | default('') == 'foo'\n```\n\n```\n- debug: msg=\"foo\"\n  when:\n    - result is not skipped\n    - result.stdout == 'foo'\n```\n\nNote that since your above shell example is not changing anything on the remote target you can also decide to play it even when running in check mode:\n```\n  - name: foo\n    shell: echo foo\n    check_mode: false\n    changed_when: false\n    register: result\n\n  - debug: msg=\"foo\"\n    when: result.stdout == 'foo'\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Null check with logical operator 'and' throws error while '&&' doesn't in Kotlin\r\n                \r\nThe difference between ```\n&&```\n and ```\nand```\n and the difference between ```\n||```\n and ```\nor```\n:\n\n```\n&&```\n and ```\n||```\n use short-circuit evaluation while\n```\nand```\n and ```\nor```\n always evaluate every condition\n\nKotlin doc for \"and\"\nBut apart from that, I get different behaviour for the following example:\nUsing ```\n&&```\n, this snippet perfectly works:\n```\nvar str1: String? = \"Good Morning\"\nvar str2: String? = \"How's it going\"\n\nif (str1 != null && str2 != null) {\n    println(str1.length + str2.length)\n}\n```\n\nWhen I replace the ```\n&&```\n with ```\nand```\n I have to add parenthesis around both conditions, otherwise the compiler seems to get confused because I get the error: ```\nOperator '!=' cannot be applied to 'String?' and 'BigInteger'```\n\nUsing ```\nand```\n and adding parenthesis:\n```\nvar str1: String? = \"Good Morning\"\nvar str2: String? = \"How's it going\"\n\nif ((str1 != null) and (str2 != null)) {\n    println(str1.length + str2.length)\n}\n```\n\nBut this last snippet throws:\n```\nOnly safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?\n```\n\nShouldn't both expressions do precisely the same? Evaluate both conditions and only execute the ```\nprintln```\n when both ```\nString```\n values are ```\nnon-null```\n? What is the difference?\n    ", "Answer": "\r\n```\n&&```\n is different from ```\nand```\n in an additional way in that it introduces a smart cast from ```\nString?```\n to ```\nString```\n, allowing you to access ```\nlength```\n by saying ```\nstr1.length```\n and ```\nstr2.length```\n, rather than using ```\nstr1?.length```\n and ```\nstr2?.length```\n.\nFrom the Kotlin language specification:\n\nSmart casts are introduced by the following Kotlin constructions.\n\nConditional expressions (```\nif```\n)\nWhen expressions (```\nwhen```\n);\nElvis operator (operator ```\n?:```\n);\nSafe navigation operator (operator ```\n?.```\n);\nLogical conjunction expressions (operator ```\n&&```\n);\nLogical disjunction expressions (operator ```\n||```\n);\nNot-null assertion expressions (operator ```\n!!```\n);\nCast expressions (operator ```\nas```\n);\nType-checking expressions (operator ```\nis```\n);\nSimple assignments;\nPlatform-specific cases: different platforms may add other kinds of expressions which introduce additional smart cast sources.\n\n\nYou need the extra parenthesis because ```\nand```\n, being an infix function, has a higher precedence than ```\n&&```\n, which is not an infix function. See all the precedences here.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do ML family compilers do any sophisticated optimization for tail calls?\r\n                \r\nI (believe) the following function definition is tail-recursive:\n\n```\nfun is_sorted [] = true\n  | is_sorted [x] = true\n  | is_sorted (x::(y::xs)) =\n    if x > y\n       then false\n       else is_sorted (y::xs)\n```\n\n\nTrivially, it's equivalent to the following declaration\n\n```\nfun is_sorted [] = true\n  | is_sorted [x] = true\n  | is_sorted (x::(y::xs)) = \n    (x <= y) andalso (is_sorted (y::xs))\n```\n\n\nYet in this version the last step is to apply the 'andalso', so its not tail-recursive. Or it would seem so, except that since (at least Standard) ML (of NJ) uses short-circuit evaluation, the andalso is in fact /not/ the last step. So would this function have tail-call optimization?\n Or there any other interesting instances where an ML function that does not obviously use tail-recursion in fact gets optimized?\n    ", "Answer": "\r\nNote that\n\n```\nA andalso B\n```\n\n\nis equivalent to\n\n```\nif A then B else false\n```\n\n\nThe SML language definition even defines it that way. Consequently, B is in tail position. No fancy optimisation necessary.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Operator Precedence vs Order of Evaluation\r\n                \r\nThe terms 'operator precedence' and 'order of evaluation' are very commonly used terms in programming and extremely important for a programmer to know. And, as far as I understand them, the two concepts are tightly bound; one cannot do without the other when talking about expressions.\n\nLet us take a simple example:\n\n```\nint a=1;  // Line 1\na = a++ + ++a;  // Line 2\nprintf(\"%d\",a);  // Line 3\n```\n\n\nNow, it is evident that ```\nLine 2```\n leads to Undefined Behavior, since Sequence points in C and C++ include:\n\n\n  \n  Between evaluation of the left and right operands of the && (logical\n  AND), || (logical OR), and comma\n  operators. For example, in the\n  expression ```\n*p++ != 0 && *q++ != 0```\n, all\n  side effects of the sub-expression\n  ```\n*p++ != 0```\n are completed before any attempt to access ```\nq```\n.\n  Between the evaluation of the first operand of the ternary\n  \"question-mark\" operator and the\n  second or third operand. For example,\n  in the expression ```\na = (*p++) ? (*p++)\n  : 0```\n there is a sequence point after\n  the first ```\n*p++```\n, meaning it has already\n  been incremented by the time the\n  second instance is executed.\n  At the end of a full expression. This category includes expression\n  statements (such as the assignment\n  ```\na=b;```\n), return statements, the\n  controlling expressions of if, switch,\n  while, or do-while statements, and all\n  three expressions in a for statement.\n  Before a function is entered in a function call. The order in which\n  the arguments are evaluated is not\n  specified, but this sequence point\n  means that all of their side effects\n  are complete before the function is\n  entered. In the expression ```\nf(i++) + g(j++) + h(k++)```\n,\n  ```\nf```\n is called with a\n  parameter of the original value of ```\ni```\n,\n  but ```\ni```\n is incremented before entering\n  the body of ```\nf```\n. Similarly, ```\nj```\n and ```\nk```\n are\n  updated before entering ```\ng```\n and ```\nh```\n\n  respectively. However, it is not\n  specified in which order ```\nf()```\n, ```\ng()```\n, ```\nh()```\n\n  are executed, nor in which order ```\ni```\n, ```\nj```\n,\n  ```\nk```\n are incremented. The values of ```\nj```\n and\n  ```\nk```\n in the body of ```\nf```\n are therefore\n  undefined.3 Note that a function\n  call ```\nf(a,b,c)```\n is not a use of the\n  comma operator and the order of\n  evaluation for ```\na```\n, ```\nb```\n, and ```\nc```\n is\n  unspecified.\n  At a function return, after the return value is copied into the\n  calling context. (This sequence point\n  is only specified in the C++ standard;\n  it is present only implicitly in\n  C.)\n  At the end of an initializer; for example, after the evaluation of 5\n  in the declaration ```\nint a = 5;```\n.\n  \n\n\nThus, going by Point # 3:\n\nAt the end of a full expression. This category includes expression statements (such as the assignment a=b;), return statements, the controlling expressions of if, switch, while, or do-while statements, and all three expressions in a for statement.\n\n```\nLine 2```\n clearly leads to Undefined Behavior. This shows how Undefined Behaviour is tightly coupled with Sequence Points.\n\nNow let us take another example:\n\n```\nint x=10,y=1,z=2; // Line 4\nint result = x<y<z; // Line 5\n```\n\n\nNow its evident that ```\nLine 5```\n will make the variable ```\nresult```\n store ```\n1```\n.\n\nNow the expression ```\nx<y<z```\n in ```\nLine 5```\n can be evaluated as either:\n\n```\nx<(y<z)```\n or ```\n(x<y)<z```\n. In the first case the value of ```\nresult```\n will be ```\n0```\n and in the second case ```\nresult```\n will be ```\n1```\n. But we know, when the ```\nOperator Precedence```\n is ```\nEqual/Same```\n - ```\nAssociativity```\n comes into play, hence, is evaluated as ```\n(x<y)<z```\n.\n\nThis is what is said in this MSDN Article:\n\nThe precedence and associativity of C operators affect the grouping and evaluation of operands in expressions. An operator's precedence is meaningful only if other operators with higher or lower precedence are present. Expressions with higher-precedence operators are evaluated first. Precedence can also be described by the word \"binding.\" Operators with a higher precedence are said to have tighter binding.\n\nNow, about the above article:\n\nIt mentions \"Expressions with higher-precedence operators are evaluated first.\"\n\nIt may sound incorrect. But, I think the article is not saying something wrong if we consider that ```\n()```\n is also an operator ```\nx<y<z```\n is same as ```\n(x<y)<z```\n. My reasoning is if associativity does not come into play, then the complete expressions evaluation would become ambiguous since ```\n<```\n is not a Sequence Point.\n\nAlso, another link I found says this on Operator Precedence and Associativity:\n\nThis page lists C operators in order of precedence (highest to lowest). Their associativity indicates in what order operators of equal precedence in an expression are applied.\n\nSo taking, the second example of ```\nint result=x<y<z```\n, we can see here that there are in all 3 expressions, ```\nx```\n, ```\ny```\n and ```\nz```\n, since, the simplest form of an expression consists of a single literal constant or object. Hence the result of the expressions ```\nx```\n, ```\ny```\n, ```\nz```\n would be there rvalues, i.e., ```\n10```\n, ```\n1```\n and ```\n2```\n respectively. Hence, now we may interpret ```\nx<y<z```\n as ```\n10<1<2```\n. \n\nNow, doesn't Associativity come into play since now we have 2 expressions to be evaluated, either ```\n10<1```\n or ```\n1<2```\n and since the precedence of operator is same, they are evaluated from left to right?\n\nTaking this last example as my argument:\n\n```\nint myval = ( printf(\"Operator\\n\"), printf(\"Precedence\\n\"), printf(\"vs\\n\"),\nprintf(\"Order of Evaluation\\n\") );\n```\n\n\nNow in the above example, since the ```\ncomma```\n operator has same precedence, the expressions are evaluated ```\nleft-to-right```\n and the return value of the last ```\nprintf()```\n is stored in ```\nmyval```\n.\n\nIn SO/IEC 9899:201x under J.1 Unspecified behavior it mentions:\n\nThe order in which subexpressions are evaluated and the order in which side effects\ntake place, except as specified for the function-call (), &&, ||, ?:, and comma\noperators (6.5).\n\nNow I would like to know, would it be wrong to say:\n\nOrder of Evaluation depends on the precedence of operators, leaving cases of Unspecified Behavior.\n\nI would like to be corrected if any mistakes were made in something I said in my question.\nThe reason I posted this question is because of the confusion created in my mind by the MSDN Article. Is it in Error or not?\n    ", "Answer": "\r\nYes, the MSDN article is in error, at least with respect to standard C and C++1.\n\nHaving said that, let me start with a note about terminology: in the C++ standard, they (mostly--there are a few slip-ups) use \"evaluation\" to refer to evaluating an operand, and \"value computation\" to refer to carrying out an operation. So, when (for example) you do ```\na + b```\n, each of ```\na```\n and ```\nb```\n is evaluated, then the value computation is carried out to determine the result.\n\nIt's clear that the order of value computations is (mostly) controlled by precedence and associativity--controlling value computations is basically the definition of what precedence and associativity are. The remainder of this answer uses \"evaluation\" to refer to evaluation of operands, not to value computations.\n\nNow, as to evaluation order being determined by precedence, no it's not! It's as simple as that. Just for example, let's consider your example of ```\nx<y<z```\n. According to the associativity rules, this parses as ```\n(x<y)<z```\n. Now, consider evaluating this expression on a stack machine. It's perfectly allowable for it to do something like this:\n\n```\n push(z);    // Evaluates its argument and pushes value on stack\n push(y);\n push(x);\n test_less();  // compares TOS to TOS(1), pushes result on stack\n test_less();\n```\n\n\nThis evaluates ```\nz```\n before ```\nx```\n or ```\ny```\n, but still evaluates ```\n(x<y)```\n, then compares the result of that comparison to ```\nz```\n, just as it's supposed to.\n\nSummary: Order of evaluation is independent of associativity.\n\nPrecedence is the same way. We can change the expression to ```\nx*y+z```\n, and still evaluate ```\nz```\n before ```\nx```\n or ```\ny```\n:\n\n```\npush(z);\npush(y);\npush(x);\nmul();\nadd();\n```\n\n\nSummary: Order of evaluation is independent of precedence.\n\nWhen/if we add in side effects, this remains the same. I think it's educational to think of side effects as being carried out by a separate thread of execution, with a ```\njoin```\n at the next sequence point (e.g., the end of the expression). So something like ```\na=b++ + ++c;```\n could be executed something like this:\n\n```\npush(a);\npush(b);\npush(c+1);\nside_effects_thread.queue(inc, b);\nside_effects_thread.queue(inc, c);\nadd();\nassign();\njoin(side_effects_thread);\n```\n\n\nThis also shows why an apparent dependency doesn't necessarily affect order of evaluation either. Even though ```\na```\n is the target of the assignment, this still evaluates ```\na```\n before evaluating either ```\nb```\n or ```\nc```\n. Also note that although I've written it as \"thread\" above, this could also just as well be a pool of threads, all executing in parallel, so you don't get any guarantee about the order of one increment versus another either.\n\nUnless the hardware had direct (and cheap) support for thread-safe queuing, this probably wouldn't be used in in a real implementation (and even then it's not very likely). Putting something into a thread-safe queue will normally have quite a bit more overhead than doing a single increment, so it's hard to imagine anybody ever doing this in reality. Conceptually, however, the idea is fits the requirements of the standard: when you use a pre/post increment/decrement operation, you're specifying an operation that will happen sometime after that part of the expression is evaluated, and will be complete at the next sequence point.\n\nEdit: though it's not exactly threading, some architectures do allow such parallel execution. For a couple of examples, the Intel Itanium and VLIW processors such as some DSPs, allow a compiler to designate a number of instructions to be executed in parallel. Most VLIW machines have a specific instruction \"packet\" size that limits the number of instructions executed in parallel. The Itanium also uses packets of instructions, but designates a bit in an instruction packet to say that the instructions in the current packet can be executed in parallel with those in the next packet. Using mechanisms like this, you get instructions executing in parallel, just like if you used multiple threads on architectures with which most of us are more familiar.\n\nSummary: Order of evaluation is independent of apparent dependencies\n\nAny attempt at using the value before the next sequence point gives undefined behavior -- in particular, the \"other thread\" is (potentially) modifying that data during that time, and you have no way of synchronizing access with the other thread. Any attempt at using it leads to undefined behavior.\n\nJust for a (admittedly, now rather far-fetched) example, think of your code running on a 64-bit virtual machine, but the real hardware is an 8-bit processor. When you increment a 64-bit variable, it executes a sequence something like:\n\n```\nload variable[0]\nincrement\nstore variable[0]\nfor (int i=1; i<8; i++) {\n    load variable[i]\n    add_with_carry 0\n    store variable[i]\n}\n```\n\n\nIf you read the value somewhere in the middle of that sequence, you could get something with only some of the bytes modified, so what you get is neither the old value nor the new one.\n\nThis exact example may be pretty far-fetched, but a less extreme version (e.g., a 64-bit variable on a 32-bit machine) is actually fairly common.\n\nConclusion\n\nOrder of evaluation does not depend on precedence, associativity, or (necessarily) on apparent dependencies. Attempting to use a variable to which a pre/post increment/decrement has been applied in any other part of an expression really does give completely undefined behavior. While an actual crash is unlikely, you're definitely not guaranteed to get either the old value or the new one -- you could get something else entirely.\n\n\n\n1 I haven't checked this particular article, but quite a few MSDN articles talk about Microsoft's Managed C++ and/or C++/CLI (or are specific to their implementation of C++) but do little or nothing to point out that they don't apply to standard C or C++. This can give the false appearance that they're claiming the rules they have decided to apply to their own languages actually apply to the standard languages. In these cases, the articles aren't technically false -- they just don't have anything to do with standard C or C++. If you attempt to apply those statements to standard C or C++, the result is false.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "PostgreSQL, Spring Data JPA: Integer null interpreted as bytea\r\n                \r\nIn PostgreSQL I have the table\n\n```\nCREATE TABLE public.my_table\n(\n    id integer NOT NULL,\n    ...\n```\n\n\nI want to perform the query: Show me the rows with a given id. If id is null, show me all rows.\n\nI tried it with\n\n```\npublic interface MyRepository extends JpaRepository<MyTable, Integer> {\n\n    @Query(value = \"SELECT * FROM my_table WHERE (?1 IS NULL OR id = ?1)\", nativeQuery = true)\n    List<MyTable> findAll(Integer id);\n```\n\n\nIf ```\nid != null```\n, everything is fine. But if ```\nid == null```\n, I will receive the error\n\n```\norg.springframework.dao.InvalidDataAccessResourceUsageException: could not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet\n    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:261) ~[spring-orm-4.3.13.RELEASE.jar:4.3.13.RELEASE]\n...\nCaused by: org.hibernate.exception.SQLGrammarException: could not extract ResultSet\n    at org.hibernate.exception.internal.SQLStateConversionDelegate.convert(SQLStateConversionDelegate.java:106) ~[hibernate-core-5.0.12.Final.jar:5.0.12.Final]\n...\nCaused by: org.postgresql.util.PSQLException: ERROR: operator does not exist: integer = bytea\n  Hint: No operator matches the given name and argument type(s). You might need to add explicit type casts.\n    at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2440) ~[postgresql-42.2.5.jar:42.2.5]\n...\n```\n\n\nObviously short circuit evaluation does not work and ```\nnull```\n is transformed into ```\nbytea```\n.\n\nAs a workaround I have changed the query value into\n\n```\nSELECT * FROM my_table WHERE (?1 IS NULL OR id = (CAST (CAST(?1 AS character varying) AS integer)))\n```\n\n\nBut this is not nice, because the int is cast to string and to int again. Do you have a better solution, e.g. a better cast or sql query?\n    ", "Answer": "\r\nAnother workaround for this is to create the query manually from the EntityManager (```\nem```\n in the example) and call ```\nsetParameter```\n on it once with a non-null value, then again with the real value.\n\n```\nprivate static final Integer exampleInt = 1;\n\nList<MyTable> findAll(Integer id) {\n    return em.createNativeQuery(\"SELECT * FROM my_table WHERE (:id IS NULL OR id = :id)\", MyTable.class)\n            .setParameter(\"id\", exampleInt)\n            .setParameter(\"id\", id)\n            .resultList();\n}\n```\n\n\nThis ensures that Hibernate knows the type of value the next second time it's called, even if it's null.\n\nThe fault is in the PostgreSQL server, and not in Hibernate, but they have refused to fix it, because it works as intended. You just have a few hundred types of SQL NULL on the server and they're mostly incompatible with each-other, even though it's supposed to be one singular special value.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How Precedence of Relational Operator handled in C++\r\n                \r\nAccording to precedence rules ```\n<, >, <=, >=```\n has precedence over ```\n!=, ==```\n\nI am so confused that how the following statement will be executed\n```\nint a=3, b=3;\ncout<< (a != b || a <= b);\n```\n\nI know short circuit evaluation and according to precedence rules I guess that compiler will execute ```\na <= b```\n first as it has precedence over ```\n!=```\n but it is not doing so.\nI did little experiment with above statement by changing ```\na <= b--```\n and changing order of above conditions and it seems that ```\n<=```\n and ```\n!=```\n have same precedence as compiler execute whichever occurred first. Or I am missing something?\n    ", "Answer": "\r\nPrecedence of operators is only relevant to how expressions are bound, not to how they're executed. Execution order is dependent on the \"happens-before\" relationship and otherwise subject to arbitrary reordering by the compiler.\nRelative precedence of two operators also only matters if they are directly adjacent. In ```\na == b <= c```\n, you get ```\na == (b <= c)```\n, not ```\n(a == b) <= c```\n. In ```\na == b || c <= d```\n, the adjacent pairs are ```\n==```\n and ```\n||```\n and ```\n||```\n and ```\n<=```\n. In both cases the comparison operators bind more strongly, so you get ```\n(a == b) || (c <= d)```\n, making the relative precedence of ```\n==```\n and ```\n<=```\n irrelevant. If you have ```\na == b + c <= d```\n instead, you first get ```\na == (b + c) <= d```\n, and now you need to compare ```\n==```\n and ```\n<=```\n again, getting you ```\na == ((b + c) <= d)```\n.\nAs for order of evaluation, ```\n||```\n has a rule that its left side is sequenced before its right side (assuming it's not overloaded), because the right side might not get evaluated at all. So the ```\n==```\n is executed first. But precedence plays no part at all in this. If you instead had written the non-short-circuiting ```\na != b | a <= b```\n, both sides would eventually get executed (with caveats, see below), but there are no guarantees which side gets evaluated first; precedence does not play a part here.\nCaveat: the compiler can still just optimize your code and realize that ```\na != b || a <= b```\n is tautological, and simply replace the entire thing with ```\ntrue```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "SQL Server performance tip [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Is the SQL WHERE clause short-circuit evaluated?  \n\n\n\n\nI have the following question regarding this query:\n\n```\nselect * from sometable \nwhere 1=1 or (select count(*) from table2 > 0)\n```\n\n\nIf the first condition is true (```\n1=1```\n), does SQL Server still do the inner select? \nOr does it stop when the first condition is true (like C)\n    ", "Answer": "\r\nIt stops when the (1=1) is true. You can check easily using Ctrl-M then Ctrl-E\n\nConsider this query\n\n```\nselect * from master..spt_values\nwhere 1=1 or (select count(*) from master..sysobjects) > 0\n```\n\n\nThe execution plan only shows a scan in ```\nmaster..spt_values```\n and no activity in ```\nsysobjects```\n.\n\nContrary to C, it does not stop when the LEFTMOST condition is true, instead the query optimizer works out independently of order presented which is the least cost to evaluate. In the case of the constants ```\n1 vs 1```\n the winner is clear.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "MongoDB performance with $and operator\r\n                \r\nI'm running differents queries:\n\nFiltering by geoJsonExtent, it is a polygon with 5 points.\n\n```\ndb.Zone.find({ \n    \"geoJsonExtent\": { \"$geoIntersects\": { \"$geometry\": { \"type\": \"Point\", \"coordinates\": [ -103.342280, 20.671379 ] } } }  \n}).explain(\"executionStats\");\n\n\"executionSuccess\" : true,\n\"executionTimeMillis\" : 0,\n\"nReturned\" : 7,\n\"totalDocsExamined\" : 10,\n\"totalKeysExamined\" : 19\n```\n\n\nFiltering by geoJson, it is a multipolygon with n points (hundreds).\n\n```\ndb.Zone.find({ \n    \"geoJson\": { \"$geoIntersects\": { \"$geometry\": { \"type\": \"Point\", \"coordinates\": [ -103.342280, 20.671379 ] } } }, \n}).explain(\"executionStats\");\n\n\"executionSuccess\" : true,\n\"executionTimeMillis\" : 2,\n\"nReturned\" : 4,\n\"totalDocsExamined\" : 6,\n\"totalKeysExamined\" : 16\n```\n\n\nFiltering with and operator with both queries.\n\n```\ndb.Zone.find({ \n    \"geoJsonExtent\": { \"$geoIntersects\": { \"$geometry\": { \"type\": \"Point\", \"coordinates\": [ -103.342280, 20.671379 ] } } },\n    \"geoJson\": { \"$geoIntersects\": { \"$geometry\": { \"type\": \"Point\", \"coordinates\": [ -103.342280, 20.671379 ] } } }, \n}).explain(\"executionStats\");\n\n\"executionSuccess\" : true,\n\"executionTimeMillis\" : 22,\n\"nReturned\" : 4,\n\"totalDocsExamined\" : 6,\n\"totalKeysExamined\" : 16\n```\n\n\nI have 2dsphere indexes for geoJson and geoJsonExtent.\n\nThe last query is the slowest (22ms), but $and operator uses short-circuit evaluation so the last one query must be faster than the second one, because de first one is almost immediate.\n\nSomeone has any idea why is happening this?\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "In swift, why true && false = 16? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Corrupted stack/heap under debugger when simulating?\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 8 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n\nI have seen the Swift spec, it says \n\n\n  The logical AND operator (```\na && b```\n) creates logical expressions where\n  both values must be true for the overall expression to also be true.\n\n\nIf either value is false, the overall expression will also be false. In fact, if the first value is false, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to true. This is known as short-circuit evaluation.\n\nThis example considers two Bool values and only allows access if both values are true:\n\n```\nlet enteredDoorCode = true\nlet passedRetinaScan = false\nif enteredDoorCode && passedRetinaScan {\n    println(\"Welcome!\")\n} else {\n    println(\"ACCESS DENIED\")\n}\n// prints \"ACCESS DENIED\"\n```\n\n\nIt has nothing about this problem, is this a bug ?\n    ", "Answer": "\r\nYou probably hit the breakpoint before this line was actually evaluated (at least your screenshot suggests so). Go one step further down and you'll see ```\nc```\n become ```\nfalse```\n as expected.\n\nAt this point in time, ```\nc```\n only points to a random location in memory which happens to be interpreted as ```\n16```\n by the debugger.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "evaluating symbolic string calling server matlab\r\n                \r\nI'm trying to use some matlab code put out to help in circuit evaluation.  The code is SCAM from Eric cheever of Swarthmore.  The code runs fine until it reaches the eval function:\n\n```\neval(SymbolicString);\n```\n\n\nFor some reason eval is calling up the server from the original code.  Should it be doing this?  Do I need to create an evaluation function of my own to run this code?  I can't see where it is calling the server from.  This is the error function being thrown:\n\n```\n    Error in syms (line 56)\n    assignin('caller',varargin{i},sym(varargin{i}));\n\n    Error in scam (line 263)\n    eval(SymbolicString);\n\n\n    Error using sym (line 198)\n    Error using maplemex\n    License server machine is down or not responding.\n```\n\n\nI would think that the server was actually down, except that I actually can't see where it is being called and their website server was updated and put back up yesterday.\n    ", "Answer": "\r\nIt might be checking for a license for the symbolic toolbox.  MathWorks really likes it when you pay them money.  If you, for whatever reason, don't have enough money to pay them then you might consider a tool like \"R\" or \"Sage\".  Mathworks is not the only tool that has symbolic algebra AND numeric methods.\n\nif you have\n\n```\na=1\nb=2\nx=sym('a+b^2')\neval(x)\n```\n\n\nthen you might also consider: \n\n\nusing other commands like subs or subs(char(...),...)\nyou might convert it to char, use fprintf to write it into a function, then call that function\ntry to evaluate it using fplot or fplot(char(...),...) with only a single output value\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Do all() and any() always short-circuit in order? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Does Python's `all` function use short circuit evaluation?\r\n                            \r\n                                (4 answers)\r\n                            \r\n                    \r\n                Closed 12 months ago.\r\n        \r\n\r\n\r\n    \r\n\r\nAs per https://stackoverflow.com/a/17246413/2687324, ```\nall()```\n and ```\nany()```\n short-circuits. Is the order of evaluation guaranteed?\n\nUsing the example from the linked answer:\n\n```\n>>> def test():\n...     yield True\n...     print('one')\n...     yield False\n...     print('two')\n...     yield True\n...     print('three')\n...\n>>> all(test())\none\nFalse\n```\n\n\nWill the result always be ```\none```\n and ```\nFalse```\n?\n    ", "Answer": "\r\nAccording to the python documentation :\n\nall(iterable)\nReturn ```\nTrue```\n if all elements of the iterable are true (or if the iterable is empty). Equivalent to:\n```\ndef all(iterable):\n    for element in iterable:\n        if not element:\n            return False\n    return True\n```\n\n\nSo as said in the comments the answer is yes, if the order of your iterable is stable.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why does command after `||` execute even if prior command succeeds?\r\n                \r\nI am using short-circuit evaluation (with ```\n&&```\n and ```\n||```\n) in a bash function,\nand I don't understand the behavior I'm seeing.  I want the function to return\nif the first number is not greater than the second:\n\n```\n[[ 5 > 2 ]] && echo true || echo false && return\n\n#    ^             ^                   ^\n# true so       do this        not this && this\n\n\n[[ 5 > 8 ]] && echo true || echo false && return\n\n#    ^             ^                   ^ \n# false so   don't do this      do this && this\n```\n\n\nbut the function returns in either case. \nWhy does the ```\nreturn```\n command execute regardless of the first command's status? \n\nInstead of ```\nreturn```\n I have tried ```\nbreak```\n,\nbut it doesn't work due to not being within a loop.\n\n\nWhy does ```\nreturn```\n seem to execute in both these cases?\nHow else can I end a running function?\n\n    ", "Answer": "\r\n    stmt1  &&  stmt2    ||  stmt3    &&  stmt4\n\nis evaluated as\n\n( ( stmt1  &&  stmt2 )  ||  stmt3 )  &&  stmt4\n\ni.e., left to right.\n\nSo the logic is\n\n\nExecute stmt1\nIf it succeeds,\nthen\n    execute stmt2\nendif\nIf stmt1 succeeds and stmt2 succeeds,\nthen\n    (do nothing here)\nelse                    # i.e., if stmt1 fails,  OR  stmt1 succeeds and then stmt2 fails\n    execute stmt3\nendif\nIf stmt1 succeeds and stmt2 succeeds,\n                  OR  stmt3 succeeds,\nthen\n    execute stmt4\nendif\n\n\nSince ```\nstmt2```\n and ```\nstmt3```\n\nare both ```\necho```\n statements, they both always succeed,\nand so ```\nstmt4```\n (the ```\nreturn```\n statement)\nis always executed.\n\nI suspect you were expecting\n\n( stmt1  &&  stmt2 )  ||  ( stmt3  &&  stmt4 )\n\nand you can get that behavior (in general) by typing parentheses,\njust like that:\n\n ( [[ 5 > N ]] && echo true )  ||  ( echo false && return )         # No, don’t do this\n\nor braces: \n\n{ [[ 5 > N ]] && echo true; }  ||  { echo false && return; }\n\nNote that you must have whitespace after a ```\n{```\n\nand a semicolon before a ```\n}```\n.\n\nNote also that, with parentheses, the commands run in subshells,\nwhereas with braces, they don’t (they run in the main shell context). \nIn your specific code example, you must use braces\n(at least for the part after the ```\n||```\n),\nbecause ```\nreturn```\n doesn’t have any effect if it’s run in a subshell.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Update columns when value is numeric in tsql\r\n                \r\nI want to normalize date fields from an old badly designed db dump. I now need to update every row, where the datefield only contains the year.\n\n```\nupdate table set date = '01.01.' + date\nwhere date like '____' and isnumeric(date) = 1 and date >= 1950\n```\n\n\nBut this will not work, because sql does not do short circuit evaluation of boolean expressions. Thus I get an error \"error converting nvarchar '01.07.1989' to int\"\n\nIs there a way to work around this? The column also contains strings with a length of 4, which are not numbers (```\n????```\n, ```\n5/96```\n, ```\n70/8```\n, etc.) the table only has 60000 rows\n    ", "Answer": "\r\nYou could always do a subquery\n\n```\nupdate table set date = '01.01.' + date\nwhere id in(\n\n   select id from table\n   where date like '____' and isnumeric(date)\n\n)\nand convert(int, date) >= 1950\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Implementing a Simulate function for a Boolean Circuit using an unordered map\r\n                \r\nI've been building a program which simulates a Boolean Circuit using a Graph. Each node in the graph has an ID, type of logical node (from a typedef that defined each node as Primary Input, And, Or, Not) as well as a vector for the nodes in and nodes out. I'll include the code for the header below:\n\n```\n#ifndef BOOLEAN_CIRCUIT_HH_\n#define BOOLEAN_CIRCUIT_HH_\n#include <string>\n#include <vector>\n\nenum class NodeType{PI, AND, OR, NOT};\n\nclass Node {\npublic:\n    Node(unsigned id ,NodeType type);\n    void addFanIn(Node * node);\n    void addFanOut(Node * node);\n    void printNode();\n\nprivate:\n    //bool flag;\n    NodeType type;\n    unsigned id;\n    std::vector<Node*> fanIn;\n    std::vector<Node*> fanOut;\n};\n\nclass Boolean_Circuit{\npublic:\n    Boolean_Circuit();\n    Boolean_Circuit(std::string filename);\n    ~Boolean_Circuit();\n    void addNode( unsigned id, NodeType type, std::vector<unsigned> fanIn);\n    //bool satisfy();\n    bool simulate(std::vector<bool> inputs);\n    int randomSuccessCount();\n    int countLogicalNodes();\n    void printCircuit();\n\nprotected:\n\nprivate:\n    bool evaluate(Node * node);\n    std::vector<Node *> nodeList;\n    std::string toString();//loop through nodelist\n};\n#endif // BOOLEAN_CIRCUIT_HH_\n```\n\n\nCurrently I have the circuit building correctly and printing out as desired, now I just need to finish the evaluate and simulate methods in the Boolean_Circuit class. My suggested implementation by a professor was to use an unordered map to store the logical values for each node as simulate runs its inputs through the circuit. Current implementation:\n\n```\n#include <unordered_map>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <stdexcept>\n#include \"BooleanCircuit.hh\"\n\nNode::Node(unsigned idIn, NodeType typeIn){\n    id = idIn;\n    type = typeIn;\n}\n\nBoolean_Circuit::Boolean_Circuit(){}\n\nBoolean_Circuit::Boolean_Circuit(std::string filename){\n   std::ifstream in(filename);\n   if(in.is_open()){\n        std::string line;\n        while(getline(in, line)){\n            std::stringstream is(line);\n            unsigned id;\n            is>>id;\n            std::string tag;\n            is>>tag;\n            NodeType type;\n            if(tag == std::string(\"PI\")) type = NodeType::PI;\n            else if(tag == std::string(\"AND\")) type = NodeType::AND;\n            else if(tag == std::string(\"OR\")) type = NodeType::OR;\n            else if(tag == std::string(\"NOT\")) type = NodeType::NOT;\n            else{\n                throw std::invalid_argument(\"Incorrect Inputs1\");\n            }\n            std::vector<unsigned> fanIns;\n            unsigned i;\n            while(!is.eof()){\n                is>>i;\n                fanIns.push_back(i);\n            }\n            addNode(id, type, fanIns);\n\n        }\n   }\n}\n\nvoid Boolean_Circuit::addNode(unsigned id, NodeType type, std::vector<unsigned> fanIn){\n    if (id != nodeList.size()){\n        std::cout<< \"ID = \" << id << \"NodeList Size = \" << nodeList.size()<< std::endl;\n        throw std::invalid_argument(\"Incorrect Inputs8\");\n    }\n\n    if (type == NodeType::PI && fanIn.size()>0) throw std::invalid_argument(\"Incorrect Inputs2\");\n    else if (type == NodeType::AND && fanIn.size()<1) throw std::invalid_argument(\"Incorrect Inputs3\");\n    else if (type == NodeType::OR && fanIn.size()<1) throw std::invalid_argument(\"Incorrect Inputs4\");\n    else if (type == NodeType::NOT && fanIn.size()!=1) throw std::invalid_argument(\"Incorrect Inputs5\");\n\n    Node *newNode = new Node(id, type);\n    for(size_t i = 0; i<fanIn.size(); i++){\n        if(i>=id) throw std::invalid_argument(\"Incorrect Inputs6\");\n        newNode->addFanIn(nodeList[fanIn[i]]);\n        nodeList[fanIn[i]]->addFanOut(newNode);\n    }\n    nodeList.push_back(newNode);\n\n}\n\nBoolean_Circuit::~Boolean_Circuit(){\n    for(size_t i =0; i< nodeList.size();i++){\n        delete(nodeList[i]);\n     }\n   nodeList.clear();\n}\n\n\nvoid Boolean_Circuit::printCircuit(){\n    std::cout<< \"Full circuit in order:\"<<std::endl;\n    for(size_t i = 0; i<nodeList.size(); i++){\n        nodeList[i]->printNode();\n    }\n}\n\nvoid Node::printNode(){\n    std::string typeString;\n    if(type == NodeType::PI) typeString = \"PI\";\n    else if(type == NodeType::AND) typeString = \"AND\";\n    else if(type == NodeType::OR) typeString = \"OR\";\n    else if(type == NodeType::NOT) typeString = \"NOT\";\n    else{\n        throw std::invalid_argument(\"Incorrect Inputs7\");\n    }\n    std::cout<< id << \" \" << typeString<< \" In: \";\n    for(size_t i=0; i<fanIn.size(); i++){\n        std::cout<<fanIn[i]->id<<\" \";\n    }\n    std::cout<<\"Out: \";\n    for(size_t i=0; i<fanOut.size(); i++){\n        std::cout<<fanOut[i]->id<<\" \";\n    }\n    std::cout<< \"\" << std::endl;\n}\n\n/*bool Boolean_Circuit::evaluate(Node node){ \n    if (!node) return 0;\n    else if (node.type == NodeType::AND){\n        for (int i=0; i<node.incoming.size(); i++){\n            if(!node.incoming[i].status??) return 0; //relies on incoming returning bools\n        }\n        return 1;\n    }\n\n    else if(node.type == NodeType::OR){\n       for (int i=0; i<node.incoming.size(); i++){\n            if(node.incoming[i].status??) return 1; //relies on incoming returning bools\n        }\n        return 0;\n    }\n\n    else if (node.type == NodeType::NOT){\n        //only ideas for this function rely on statuses\n    }\n}*/\n\nbool Boolean_Circuit::simulate(std::vector<bool> inputs){\n    std::unordered_map<unsigned, bool> mymap; //the unsigned is the node id, bool is the status of the node based of of inputs.\n    return false;\n}\n\n\nvoid Node::addFanIn(Node * soloFan){\n    fanIn.push_back(soloFan);\n}\n\nvoid Node::addFanOut(Node * soloFan){\n    fanOut.push_back(soloFan);\n}\n```\n\n\nCurrent main as well:\n\n```\n#include \"BooleanCircuit.hh\"\n#include <iostream>\n\nint main(int argc, char *argv[]){\n   if (argc >2){\n    std::cout << \"Too many arguments\"<< std::endl;\n    return -1;\n   }\n   else if (argc == 2){\n       Boolean_Circuit circuit(argv[1]);\n   }\n   else{\n       std::cout << \"File name not provided\" << std::endl;\n       Boolean_Circuit circuit;\n       circuit.addNode(0, NodeType::PI, {});\n       circuit.addNode(1, NodeType::PI, {});\n       circuit.addNode(2, NodeType::NOT, {0});\n       circuit.addNode(3, NodeType::NOT, {1});\n       circuit.addNode(4, NodeType::OR, {0,1});\n       circuit.addNode(5, NodeType::OR, {0,3});\n       circuit.addNode(6, NodeType::OR, {2,1});\n       circuit.addNode(7, NodeType::OR, {2,3});\n       circuit.addNode(8, NodeType::AND, {4,5,6,7});\n       circuit.printCircuit();\n\n   }\n    return 0;\n}\n```\n\n\nI'm unsure of how to implement the simulate and evaluate functions with the map as the structure is very new to me. Some help would be much appreciated. My desired functions should work as a pair, with evaluate helping to solve each node logically as simulate walks its inputs (given as a boolean vector) through the circuit. Using the unordered map as reference for status, how should I go about implementing?\n\nIf more details are needed as to design intentions let me know.\n    ", "Answer": "", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Performance of OR? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  SQL Server - Query Short-Circuiting?\n  Is the SQL WHERE clause short-circuit evaluated?  \n\n\n\n\nI have a question regarding performance of logical OR operators in T-SQL (SQL Server 2005).\n\nI have searched around a little but I couldn't find anything on the subject.\n\nIf you have the following query:\n\n```\nSELECT * FROM Table WHERE (randomboolean OR HeavyToEvaluateCondition)\n```\n\n\nWouldn't the procedure interpreter go as far as the ```\nrandomboolean```\n and skip evaluation of the heavy condition in order to save performance given that the first condition is true?\n\nSince one of the values in an OR statement is true it would be unnecessary to evaluate the second condition since we already know that the first condition is met!\n\nI know it works like this in C# but I want to know if I can count on it in T-SQL too.\n    ", "Answer": "\r\nYou can't count on short circuit evaluation in TSQL. \n\nThe optimiser is free to evaluate the conditions in which ever order it sees fit and may in some circumstances evaluate both parts of an expression even when the second evaluation cannot change the result of the expression (Example).\n\nThat is not to say it never does short circuit evaluation however. You may well get a start up predicate on the expensive condition so it is only executed when required.\n\nAdditionally the presence of the ```\nOR```\n in your query can convert a sargable search condition into an unsargable one meaning that indexes are not used optimally. Especially in SQL Server 2005 (In 2008 ```\nOPTION (RECOMPILE)```\n can help here).\n\nFor example compare the plans for the following. The version with ```\nOR```\n ends up doing a full index scan rather than an index seek to the specific values.\n\n```\nDECLARE @number INT;\nSET number  = 0;\n\nSELECT COUNT(*)\nFROM master..spt_values\nWHERE @number IS NULL OR number = 0\n\nSELECT COUNT(*)\nFROM master..spt_values\nWHERE  number = 0\n```\n\n\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Using Logical AND 1 when setting a variable in C\r\n                \r\nWhile looking through some code today, I came across an interesting(unecessary?) method for setting a variable:  Adding a logical AND to the value.\n\n```\nLED_GRN = (ivLEDGrnSequence & ivLEDSlot) && 1;\n```\n\n\nI looked around a bit more for some of these occurrences and found them throughout the code, but in different forms:\n\nAs an argument for a function:\n\n```\nisoAgCmdHideShow(iObjectID,( (ecu.l & sVar->mask) && 1), (uint8_t *)TxMsg.buf);\n```\n\n\nIn a conditional:\n\n```\nif( (usbQueue.selection & USB_SELECTION_CAN_1) && 1 ) {return TRUE;}\n```\n\n\nDoes this extra logical AND actually change anything about the code, or is it just superfluous?  I tried searching for this online, but the closest I found to an answer is Short-Circuit Evaluation which doesn't seem to apply in these situations because short-circuiting a 1 is useless.\n\nIn short, what does Logical AND 1 do for variable declaration?\n    ", "Answer": "\r\nThis appears to be a trick to force any non-zero number to ```\n1```\n, while keeping zeros - alongside a more common ```\n!!(expr)```\n idiomatic construct.\n\nThe idea is to set ```\nLED_GRN```\n to ```\n1```\n or ```\n0```\n based on the value of ```\nivLEDGrnSequence & ivLEDSlot```\n.\n\nOther ways to do the same thing are as follows:\n\n```\nLED_GRN = !!(ivLEDGrnSequence & ivLEDSlot);\nLED_GRN = (ivLEDGrnSequence & ivLEDSlot) != 0;\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Boolean expressions optimizations in Java\r\n                \r\nConsider the following method in Java:\n\n```\npublic static boolean expensiveComputation() {\n    for (int i = 0; i < Integer.MAX_VALUE; ++i);\n    return false;\n}\n```\n\n\nAnd the following main method:\n\n```\npublic static void main(String[] args) {\n    boolean b = false;\n    if (expensiveComputation() && b) {\n    }\n}\n```\n\n\nLogical conjunction (same as &&) is a commutative operation. So why the compiler doesn't optimize the if-statement code to the equivalent:\n\n```\nif (b && expensiveComputation()) {\n}\n```\n\n\nwhich has the benefits of using short-circuit evaluation?\n\nMoreover, does the compiler try to make other logic simplifications or permutation of booleans in order to generate faster code? If not, why? Surely some optimizations would be very difficult, but my example isn't simple? Calling a method should always be slower than reading a boolean, right?\n\nThank you in advance.\n    ", "Answer": "\r\nIt doesn't do that because expensiveComputation() may have side effects which change the state of the program.  This means that the order in which the expressions in the boolean statements are evaluated (expensiveComputation() and b) matters.  You wouldn't want the compiler optimizing a bug into your compiled program, would you?\n\nFor example, what if the code was like this\n\n```\npublic static boolean expensiveComputation() {\n        for (int i = 0; i < Integer.MAX_VALUE; ++i);\n        b = false;\n        return false;\n}\n\npublic static boolean b = true;\npublic static void main(String[] args) {\n        if (expensiveComputation() || b) {\n        // do stuff\n        }\n}\n```\n\n\nHere, if the compiler performed your optimization, then the ```\n//do stuff```\n would run when you wouldn't expect it to by looking at the code (because the b, which is originally true, is evaluated first).\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why does `false && true || true` evaluate to true?\r\n                \r\nAccording to MDN Logical Operators page:\n\n\n  false && anything is short-circuit evaluated to false.\n\n\nGiven this information, I would expect ```\nfalse && true || true```\n to evaluate to false. However, this is not the case. The expected result (```\nfalse```\n) is only given when the statement is written like:\n\n```\nfalse && (true || true)\n```\n\n\nA coworker and I have tried to work this out and the closest thing we could come up with is that the statement is being evaluated by order of precedence. According to the MDN Operator Precedence ```\nlogical-and```\n has a higher precidence over ```\nlogical-or```\n, suggesting that the condition is evaluated as if ```\nfalse && true```\n were a single statement, which then moves on to determine the boolean condition of ```\nfalse || true```\n which is then ```\ntrue```\n. Written out, this would be:\n\n```\n(false && true) || true\n```\n\n\nSomething is wrong here. It's either the documentation, the JavaScript parsing logic, or my interpretation.\n\nEdit:\n\nI've added a bounty because none of the answers given truly understand the question. As stated above: the MDN Logical Operators page states exactly: \"false && anything is short-circuit evaluated to false.\"\n\n\"anything\" means \"anything\"!\n    ", "Answer": "\r\nYour confusion all comes down to a misunderstanding of precedence.\n\nA mathematical analogue would be \"Zero multiplied by anything equals zero.\"  Consider the following expression:\n\n```\n0 x 100 + 5\n```\n\n\nIn any programming language, or a decent calculator, this evaluates to 5.  The \"zero times anything\" axiom is true - but the \"anything\" in this case is ```\n100```\n, NOT ```\n100 + 5```\n!  To see why, compare it to this:\n\n```\n5 + 0 x 100\n```\n\n\nIt doesn't matter whether you add the 5 at the beginning or the end - the operator precedence rules remove ambiguity from the statement.\n\nIn JavaScript boolean logic, ```\n&&```\n has higher precedence than ```\n||```\n.  Since each operator is commutative, writing\n\n```\nfalse && true || true\n```\n\n\nis exactly the same as writing\n\n```\ntrue || false && true\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Wix UI conditionals best practices\r\n                \r\nI have a fairly complicated installer that I'm writing in Wix that has a lot of custom dialog options based on which components you're installing.  Generally, defaults are fine, and thus an unattended install would succeed, but having this customization helps things.\n\nWhat I'm wondering is, what are best practices in Wix for doing UI conditionals?  I've noticed that Wix evaluates all ```\n<Publish>```\n tags, regardless of whether or not the last one evaluated to true, which is leading to a lot of code like this:\n\n```\n<Publish Dialog=\"Questions\" Control=\"Next\" Event=\"NewDialog\" Value=\"Component1Questions\" Order=\"1\">INSTALLCOMPONENT1</Publish>\n<Publish Dialog=\"Questions\" Control=\"Next\" Event=\"NewDialog\" Value=\"Component2Questions\" Order=\"2\">NOT INSTALLCOMPONENT1 AND INSTALLCOMPONENT2</Publish>\n<Publish Dialog=\"Questions\" Control=\"Next\" Event=\"NewDialog\" Value=\"Component3Questions\" Order=\"3\">NOT INSTALLCOMPONENT1  AND NOT INSTALLCOMPONENT2 AND INSTALLCOMPONENT3</Publish>\n<Publish Dialog=\"Questions\" Control=\"Next\" Event=\"NewDialog\" Value=\"VerifyReadyDlg\" Order=\"4\">NOT INSTALLCOMPONENT1  AND NOT INSTALLCOMPONENT2 AND NOT INSTALLCOMPONENT3</Publish>\n```\n\n\nAnd similarly on the \"back' sections for each dialog.  Is this best practice for this?  Is there a way to short circuit evaluation of Publish elements and take the first one that returns true?\n    ", "Answer": "\r\nYou're already using the Publish/@Order element to simplify the code, however I would advise being as explicit as possible.\n\nYou can simplify the logic anyway and not worry about the Order value...\n\n```\n<Publish ... Value=\"Component1Questions\">CMP1 And Not (CMP2 Or CMP3)</Publish>\n<Publish ... Value=\"Component2Questions\">CMP2 And Not (CMP1 Or CMP3)</Publish>\n<Publish ... Value=\"Component3Questions\">CMP3 And Not (CMP1 Or CMP2)</Publish>\n<Publish ... Value=\"VerifyReadyDlg\">Not (CMP1 Or CMP2 Or CMP3)</Publish>\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Collection comparison is reflexive, yet does not short circuit. Why?\r\n                \r\nIn python, the built in collections compare elements with the explicit assumption that they are reflexive:\n\n\n  In enforcing reflexivity of elements, the comparison of collections assumes that for a collection element x, x == x is always true. Based on that assumption, element identity is compared first, and element comparison is performed only for distinct elements. \n\n\nLogically, this means that for any list ```\nL```\n, ```\nL == L```\n must be ```\nTrue```\n.  Given this, why doesn't the implementation check for identity to short circuit the evaluation?\n\n```\nIn [1]: x = list(range(10000000))\nIn [2]: y = list(range(int(len(x)) // 10))\nIn [3]: z = [1]\n\n# evaluation time likes O(N)\nIn [4]: %timeit x == x\n10 loops, best of 3: 21.8 ms per loop\nIn [5]: %timeit y == y\n100 loops, best of 3: 2.2 ms per loop\nIn [6]: %timeit z == z\n10000000 loops, best of 3: 36.4 ns per loop\n```\n\n\nClearly, child classes could choose to make an identity check, and clearly an identity check would add a very small overhead to every such comparison.  \n\nWas a historical decision explicitly made not to make such a check in the built in sequences to avoid this expense?\n    ", "Answer": "\r\nWhile I'm not privy to the developers' thinking, my guess is that they might have felt comparing ```\nL == L```\n does not happen often enough to warrant a special check, and moreover, the user can always use ```\n(L is L) or (L==L)```\n to build a\nshort-circuiting check himself if he deems that advantageous.\n\n```\nIn [128]: %timeit (x is x) or (x == x)\n10000000 loops, best of 3: 36.1 ns per loop\n\nIn [129]: %timeit (y is y) or (y == y)\n10000000 loops, best of 3: 34.8 ns per loop\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Java operator precendece confusion && and ++\r\n                \r\n```\n&&```\n is a short-circuit operator evaluated from left to right, so if the operand on the left side of ```\n&&```\n operator is evaluated to false, evaluation should not continue. BUT I expected that the ```\n++```\n should be evaluated before ```\n&&```\n because it has higher precedence, and (from the link):\n\n\n  Operators with higher precedence are evaluated before operators with relatively lower precedence.\n\n\nIn that case, why doesn't ```\ncount```\n increment in the third line of this code?\n\n```\nint mask = 2;\nint count = 0;\nif( !(mask > 1) && ++count > 1) { mask += 100; }\nSystem.out.println(mask + \" \" + count);\n```\n\n    ", "Answer": "\r\nNo, the way the expression is evaluated goes from left to right, while taking operator precedence into account. So once in  ```\na && b```\n the ```\na```\n gets false, ```\nb```\n is not evaluated anymore.\n\nJLS §15.23. Conditional-And Operator && says:\n\n\n  The conditional-and operator ```\n&&```\n is like ```\n&```\n (§15.22.2), but evaluates its right-hand operand only if the value of its left-hand operand is true.\n\n\n\n\nHere is a detailed step by step evaluation of how this works:\n\nThis is because, when you parse an expression as a human being, you start with the lowest precedence operators first. In this case ```\n&&```\n has lower precedence then ```\n++```\n.\n\n```\n++a < 0 && foo\n        ^^\n       start\n```\n\n\nIn order to compute the result of ```\n&&```\n, you should know the left operand:\n\n```\n++a < 0 && ++b\n^^^^^^^\nso compute this\n```\n\n\nNow, when you want to know the result of ```\n++a < 0```\n, take a look at the lowest precedence operator first, which is ```\n<```\n:\n\n```\n++a < 0\n    ^\n   evaluate this\n```\n\n\nIn order to do that, you will need both left and right operand. So compute them:\n\n```\n++a\n0\n```\n\n\nThis is the moment were ```\n++a```\n gets increased.\n\nSo, now we are at the bottom. Let's make our way back to the top:\n\n```\nfalse && foo\n```\n\n\nAnd this is where the fact that && is short circuit comes in. Left operand is false, so the right operand expression ```\nfoo```\n is not evaluated anymore. Which becomes:\n\n```\nfalse\n```\n\n\nwithout the evaluation of the right operand.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Python: any() unexpected performance\r\n                \r\nI am comparing the performance of the ```\nany()```\n built-in function with the actual implementation the docs suggest:\n\nI am looking for an element greater than 0 in the following list:\n\n```\nlst = [0 for _ in range(1000000)] + [1]\n```\n\n\nThis is the supposedly equivalent function:\n\n```\ndef gt_0(lst):\n    for elm in lst:\n        if elm > 0:\n            return True\n    return False\n```\n\n\nAnd these are the results of the performance tests:\n\n```\n>> %timeit any(elm > 0 for elm in lst)\n>> 10 loops, best of 3: 35.9 ms per loop\n\n>> %timeit gt_0(lst)\n>> 100 loops, best of 3: 16 ms per loop\n```\n\n\nI would expect both of the to have the exact same performance, however ```\nany()```\n if two times slower. Why?\n    ", "Answer": "\r\nThe reason is that you've passed a generator expression to the ```\nany()```\n function. Python needs to convert your generator expression to a generator function and that's why it performs slower. Because a generator function needs to call the ```\n__next__()```\n method each time for generating the item and passing it to the ```\nany```\n. This is while in a manual defined function you are passing the whole list to your function which has all the items prepared already.\n\nYou can see the difference better by using a list comprehension rather than a generator expression:\n\n```\nIn [4]: %timeit any(elm > 0 for elm in lst)\n10 loops, best of 3: 66.8 ms per loop\n\nIn [6]: test_list = [elm > 0 for elm in lst]\n\nIn [7]: %timeit any(test_list)\n100 loops, best of 3: 4.93 ms per loop\n```\n\n\nAlso another bottleneck in your code which has more cost than extra calls on ```\nnext```\n is the way you do the comparison. As mentioned in comment the better equivalent of your manual function is:\n\n```\nany(True for elm in lst if elm > 0)\n```\n\n\nIn this case you're doing the comparison with the generator expression and it'll perform almost in an equal time as your manual defined function (the slightest difference is because of the generator, I guess.) For a deeper understanding of the underlying reasons read the Ashwini's answer.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Common term for the \"value-based\" OR operator\r\n                \r\nJust a quick question\n\n```\n printf(\"%d\", 99 || 44) prints \"1\" in C\n print 99 || 44 prints \"99\" in perl\n```\n\n\nThere are two different kinds of evaluation.  Does each one have a name?\n\nedit: i'm interested to know how this Perl evaluation is commonly called when compared to C. When you say \"C example is X, and perl example is not X, but Y\" which words would you use for X and Y. \"short circuit\" is not what i'm looking for.\n    ", "Answer": "\r\nRead here.\n\nBinary || performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.\nIn Perl the || and && operators differ from C's in that, rather than returning 0 or 1, they return the last value evaluated.\n\n\n\nprintf(\"%d\", 99 || 44) prints \"1\" in C\n\nThat is because ```\n99||44```\n returns true(only 99(which is non-zero) is evaluated due to the short-circuiting action of ```\n||```\n ) whose equivalent is ```\n1```\n hence ```\nprintf()```\n prints ```\n1```\n.\n\nprint 99 || 44 prints \"99\" in perl\n\n..rather than returning 0 or 1, the last value evaluated(```\n99```\n here) is returned.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Common term for the \"value-based\" OR operator\r\n                \r\nJust a quick question\n\n```\n printf(\"%d\", 99 || 44) prints \"1\" in C\n print 99 || 44 prints \"99\" in perl\n```\n\n\nThere are two different kinds of evaluation.  Does each one have a name?\n\nedit: i'm interested to know how this Perl evaluation is commonly called when compared to C. When you say \"C example is X, and perl example is not X, but Y\" which words would you use for X and Y. \"short circuit\" is not what i'm looking for.\n    ", "Answer": "\r\nRead here.\n\nBinary || performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.\nIn Perl the || and && operators differ from C's in that, rather than returning 0 or 1, they return the last value evaluated.\n\n\n\nprintf(\"%d\", 99 || 44) prints \"1\" in C\n\nThat is because ```\n99||44```\n returns true(only 99(which is non-zero) is evaluated due to the short-circuiting action of ```\n||```\n ) whose equivalent is ```\n1```\n hence ```\nprintf()```\n prints ```\n1```\n.\n\nprint 99 || 44 prints \"99\" in perl\n\n..rather than returning 0 or 1, the last value evaluated(```\n99```\n here) is returned.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "VBScript conditional short-circuiting workaround\r\n                \r\nI have a large classic ASP app that I have to maintain, and I repeatedly find myself thwarted by the lack of short-circuit evaluation capability.  E.g., VBScript won't let you get away with:\n\n```\nif not isNull(Rs(\"myField\")) and Rs(\"myField\") <> 0 then\n...\n```\n\n\n...because if Rs(\"myField\") is null, you get an error in the second condition, comparing null to 0.  So I'll typically end up doing this instead:\n\n```\ndim myField\nif isNull(Rs(\"myField\")) then \n    myField = 0\nelse\n    myField = Rs(\"myField\")\nend if\n\nif myField <> 0 then\n...\n```\n\n\nObviously, the verboseness is pretty appalling.  Looking around this large code base, the best workaround I've found is to use a function the original programmer wrote, called TernaryOp, which basically grafts in ternary operator-like functionality, but I'm still stuck using a temporary variable that would not be necessary in a more full-featured language.  Is there a better way?  Some super-secret way that short-circuiting really does exist in VBScript?\n    ", "Answer": "\r\nNested IFs (only slightly less verbose):\n\n```\nif not isNull(Rs(\"myField\")) Then\n   if Rs(\"myField\") <> 0 then\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Lambda expression - OR Operator evaluating both sides\r\n                \r\nI've got the following code which matches an exact culture, or a wildcard version of the culture.\n\nUsing a culture of 'en-TH' the string returned should be 'en-**' as this has been matched by a wildcard. A culture of 'en-US' will return 'en-US' and a culture of 'ar-AK' will return null.\n\nHowever, with the code below, a culture of 'en-US' returns two strings:\n\n```\n\"en-US\"\n\"en-**\"\n```\n\n\nI am wondering if this is because the OR operator is NOT doing \"short-circuit\" evaluation in this context?  I.E. I don't want 'en-**' to be returned in this instance\n\n```\nstring cultureToMatch = \"en-TH\";\nIEnumerable<string> cultures = new string[] { \"en-US\", \"en-**\", \"fr-**\", \"en-KH\", \"ar-AR\" };\n\nfor (int i = 0; i < cultureToMatch.Length; i++)\n{\n    char searchChar = cultureToMatch[i];\n    cultures = cultures.Where(w => w.IndexOf(searchChar, i, 1) >= 0 ||\n                                   w.IndexOf('*', i, 1) >= 0)\n                                    .ToList();\n}\n```\n\n    ", "Answer": "\r\nTry the following instead.  It will try to filter on the actual character first and only if there are no matches will it try to filter using the wildcard.\n\n```\nstring cultureToMatch = \"en-US\";\nIEnumerable<string> cultures = new string[] { \"en-US\", \"en-**\", \"fr-**\", \"en-KH\", \"ar-AR\" };\n\nfor (int i = 0; i < cultureToMatch.Length; i++)\n{\n    char searchChar = cultureToMatch[i];\n    var tempFilter = cultures.Where(w => w.IndexOf(searchChar, i, 1) >= 0);\n    if (!tempFilter.Any())\n        tempFilter = cultures.Where(w => w.IndexOf('*', i, 1) >= 0);\n    cultures = tempFilter.ToList();\n}\n```\n\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Why does multiplication only short circuit on one side\r\n                \r\nI was messing around with ```\nfix```\n and after messing around with it I came across some weird behavior, namely that ```\n0 * undefined```\n is ```\n*** Exception: Prelude.undefined```\n and ```\nundefined * 0```\n is ```\n0```\n. Which also means that ```\nfix (0 *)```\n is ```\n*** Exception: <<loop>>```\n and ```\nfix (* 0)```\n is ```\n0```\n.\n\nAfter playing around with it it seems like the reason is because it is non-trivial to make it short circuit in both directions, as that doesn't really make much sense, without some sort of weird parallel computation and start with the first non-bottom returned.\n\nIs this kind of thing seen in other places (reflexive functions that aren't reflexive for bottom values), and is it something I can safely rely on? Also is there a practical way to make both ```\n(0 *)```\n and ```\n(* 0)```\n evaluate to zero regardless of the value passed in.\n    ", "Answer": "\r\nYour reasoning is correct. There is an ```\nunamb```\n package providing tools for the sort of parallel computation you refer to. In fact, it offers ```\nData.Unamb.pmult```\n, which tries, in parallel, to check whether each operand is 1 or 0, and if so immediately produces a result. This parallel approach is likely to be much slower in most cases for simple arithmetic!\n\nThe short-circuiting of ```\n(*)```\n occurs only in GHC version 7.10. It came about as a result of changes to the implementation of the ```\nInteger```\n type in that GHC version. That extra laziness was generally seen as a performance bug (as it interferes with strictness analysis and can even lead to space leaks in theory), so it will be removed in GHC 8.0.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Concise way to print empty string fallback if optionally-chained variable is undefined in string literal\r\n                \r\nLet's say I have this string literal use case:\n```\nfunction getClassNames(props){\n    my_classNames = `class-nameA class-nameB ${props?.one} ${props?.two} class-nameC`;\n    return my_classNames;\n}\n\nconsole.log(getClassNames({one: 'class-name-one', two: 'class-name-two'}))\n  // prints: class-nameA class-nameB class-name-one class-name-two class-nameC\nconsole.log(getClassNames({two: 'class-name-two'}))\n  // prints: class-nameA class-nameB undefined class-name-two class-nameC\nconsole.log(getClassNames())\n  // prints: class-nameA class-nameB undefined undefined class-nameC\n```\n\nThe problem is when any of props' keys is undefined, it prints undefined. I want it to print empty string instead.\nOne solution to this is to use short-circuit OR evaluation like this:\n```\nfunction getClassNames(props){\n    my_classNames = `class-nameA class-nameB ${props?.one || ''} ${props?.two || ''} class-nameC`;\n    return my_classNames;\n}\n\nconsole.log(getClassNames())\n  // prints: class-nameA class-nameB   class-nameC\n```\n\nOr a better solution (to avoid extra spaces), to use previous solution with short-circuit AND evaluation like this:\n```\nfunction getClassNames(props){\n    my_classNames = `class-nameA class-nameB${props?.one && ' '+props?.one || ''}${props?.two && ' '+props?.two || ''}class-nameC`;\n    return my_classNames;\n}\n\nconsole.log(getClassNames())\n  // prints: class-nameA class-nameB class-nameC\n```\n\nTo make it more concise, I can wrap duplicates/repetitions in previous solution to a function:\n```\nfunction getClassNames(props){\n    my_classNames = `class-nameA class-nameB${concatWithSpace(props?.one)}${concatWithSpace(props?.two)}class-nameC`;\n    return my_classNames;\n}\n\nfunction concatWithSpace(str){\n    return str && ' '+str || '';\n}\n\nconsole.log(getClassNames())\n  // prints: class-nameA class-nameB class-nameC\n```\n\nIs there a more concise built-in way (syntax) to print empty string (instead of ```\nundefined```\n) for optionally-chained variables without using the previous \"not-so concise\" solutions I mentioned?\n    ", "Answer": "\r\nDon't use a template string, but an array and do some processing on it:\n```\nfunction getClassNames(props){\n    const my_classNames = ['class-nameA', 'class-nameB', props?.one, props?.two, 'class-nameC'];\n    return my_classNames.filter(Boolean).join(' ');\n}\n```\n\nThis also works properly with optional parts at the begin or end, or an empty array.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Is &= operator short-circuited in Objective-C?\r\n                \r\nConsider:\n\n```\nBOOL ok = somethingOrOther() ;\n\nok = ok && somethingElse() ;\n```\n\n\nvs:\n\n```\nBOOL ok = somethingOrOther() ;\n\nok &= somethingElse() ;\n```\n\n\nIn both cases, the intention is for ```\nsomethingElse()```\n to not be evaluated if ```\nok```\n is already ```\nNO```\n. This is because C does short-circuit boolean evaluation\n\nI wish I could have written:\n\n```\nok &&= somethingElse() ;\n```\n\n\ninstead. But that seems illegal.\n\nMy hunch is that ```\n&=```\n will evaluate ```\nsomethingElse()```\n whereas ```\n&&=```\n (had it been legal) would have not.\n\nAnyone knows?\n    ", "Answer": "\r\n& isn't a boolean evaluation, but rather a bitwise AND operation (http://en.wikipedia.org/wiki/Bitwise_operation#AND), so I would expect ```\na &= b```\n to always evaluate ```\nb```\n.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "Examples of non-trivial fexpr usage\r\n                \r\nI'm looking for (real world) uses of fexprs, where they are used in a way different to what can be accomplished with lazy evaluation.\n\nMost examples that I could find use fexprs only to implement conditional evaluation, like for a short circuit \"and\" operative (Evaluate first argument, if false, don't evaluate second and directly return false).\n\nI'm looking for \"useful\" uses, that is where using fexpr leads to code that is \"better\" (cleaner) than what could be done without fexprs.\n    ", "Answer": "\r\nThere are two main reasons you would want to use fexprs.\n\nThe first one is because they allow you to evaluate the arguments an arbitrary number of times. This makes it possible to implement operators that evaluate their arguments lazily like you suggested. Constructs built this way are also capable of evaluating their arguments more than once. This makes it possible to implement loops through fexprs! \n\nThe other case is for transformation. Transforming code is basically a way of writing a compiler on top of your existing Lisp. Although it uses macros and not fexprs, cl-who is a great example of the kind of transformations that can be made.\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
{"Question": "How to evaluate all expressions in a condition?\r\n                \r\nI know PHP uses lazy-evaluation / short-circuit operators. But say I wanted to evaluate all the expressions in a condition, for example:\n\n```\n$a = \"Apple\";\n$b = \"Banana\";\n$c = \"Cherry\";\n\nfunction check($fruit) {\n    if ($fruit != \"Banana\") {\n        echo \"$fruit is good.\\n\";\n        return true;\n    } else {\n        echo \"$fruit is bad.\\n\";\n        return false;\n    }\n}\n\nif (check($a) && check($b) && check($c)) {\n    echo \"Yummy!\\n\";\n}\n```\n\n\nBecause of lazy-evaluation, this will only output:\n\n```\nApple is good.\nBanana is bad.\n```\n\n\nRather than the desired output of:\n\n```\nApple is good.\nBanana is bad.\nCherry is good.\n```\n\n\nThis is useful in form validation for instance.\n\nSo my question: Is there any way to force all expressions in a condition to be evaluated in PHP, and if not, what would be the best/quickest way to get the desired result in the example above?\n    ", "Answer": "\r\nYou can use bitwise AND (single ampersand: ```\n&```\n)\n\n```\n$a = \"Apple\";\n$b = \"Banana\";\n$c = \"Cherry\";\n\nfunction check($fruit) {\n    echo ($fruit != \"Banana\") ? \"$fruit is good.\\n\" : \"$fruit is bad.\\n\";\n}\n\nif (check($a) & check($b) & check($c)) {\n    echo \"Yummy!\\n\";\n}\n```\n\n\nPrints:\n\n\n  Apple is good. \n  \n  Banana is bad. \n  \n  Cherry is good.\n\n\nExample: http://sandbox.onlinephpfunctions.com/code/07092a9d6636ae8ddafce024d7cc74643e311e9c\n    ", "Knowledge_point": "Circuit Evaluation", "Tag": "算法分析"}
