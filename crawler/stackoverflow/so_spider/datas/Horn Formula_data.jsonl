{"Question": "Check if a formula is a horn clause\r\n                \r\nI made a program in prolog with the operators ~(not), v(or) and ^(and). How can I check if a formula is a horn clause?\n\nFor example:\n\n```\n?- hclause((A ^ ~B) v (~A ^ C))\ntrue.\n```\n\n\nThanks in advance!\n    ", "Answer": "\r\nNot sure to understand but... if you define ```\n^```\n and ```\nv```\n as binary operators and ```\n~```\n as unary operator, by example\n\n```\n:- op(400,  fx, ~).\n:- op(500, xfy, ^).\n:- op(600, xfy, v).\n```\n\n\nthe check of a correct formula should be automatic (giving error otherwise).\n\nTake in count that operator definition is only \"Syntactic sugar\" and that, by example, ```\nA ^ B```\n is an alternative version for ```\n^(A, B)```\n.\n\nIf you want to see the real meaning of ```\n(A ^ ~B) v (~A ^ C)```\n (with this definition for ```\nv```\n, ```\n^```\n and ```\n~```\n), you can use ```\nwrite_canonical/1```\n, so with\n\n```\nwrite_canonical((A ^ ~B) v (~A ^ C)),\n```\n\n\nI obtain\n\n```\nv(^(_4,~(_7)),^(~(_4),_15))\n```\n\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "CNF vs Horn Satisfiability\r\n                \r\nI know that it's easier to prove if a horn-formula is satisfiable. My Question is: Why is it easier with a horn formula rather than a normal CNF?\n    ", "Answer": "\r\nPresence or absence of Horn satisfiability can be shown in linear time. Here is a good introduction with some examples. The solution can be found by unit propagation without backtracking.\n\nPseudocode from a UC Berkeley lecture note:\n\n\n\nSatisfiability for general CNF expressions is a classic NP-complete problem. No polynomial time algorithms are known for CNF satisfiability (except if P=NP).\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Horn SAT algorithm using graphs\r\n                \r\nFor some restricted classes of logical formulae, the satisfiability problem can be solved efficiently in polynomial time or even linear. One such class is that of Horn formulae, which consist only of Horn clauses with at most one positive literal. I've heard that it is possible to solve Horn SAT in linear time using graphs, but couldn't find any implementation of such solution. Now I'm really interested whether it is possible and if it is, how would algorithm look like?\n    ", "Answer": "\r\nIf you're familiar with Davis–Putnam–Logemann–Loveland, Horn clauses are a class of formulae that can be solved using one round of unit propagation, with no backtracking.\nIn graph terms, we do the obvious thing and set up a bipartite graph with variables on one side, clauses on the other, and edges to represent a variable appearing as a negative literal in a clause. We also have a work queue of clauses consisting of a single positive literal. While the work queue is not empty, pop any element, identify the node corresponding to the variable, and delete it and its neighbors. For each clause vertex that now has degree zero, one of two things happens. If that clause has a positive literal, then we add it to the work queue. Otherwise, we've proved that the formula is unsatisfiable. If we reach the end of the work queue without finding such a clause, then the formula is satisfiable, and one satisfying assignment is to set all variables that entered the work queue to true, and all others to false.\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "How to write it in skolem form?(Prolog)\r\n                \r\nTranslate the following formula into a horn formula in Skolem form:\n\n∀w¬∀x∃z(H(w)∧(¬G(x,x)∨¬H(z)))\n\nit's translated from german to english, how to write it in horn form and then in skolem form, i didn't find anything on internet...plz help me\n    ", "Answer": "\r\nI will always use the satisfiability preserving version of skolemization, i.e. the one where those are replaced which would become existential quantifiers when moved to the head of the formula.\n\nTo make life a bit simpler, let's push the negations to the atoms. We can also see that w doesn't occur in ¬G(x,x)∨¬H(z) and that x,z don't occur in H(w), allowing us to distribute the quantifiers a bit inside.\n\nThen we obtain the formula ∀w¬H(w) ∨ ∃x∀z (G(x,x)∧ H(z)) .\n\n\nIf we want to refute the formula:\n\n\nWe skolemize ∃x and delete ∀w, ∀z and obtain:\n\n¬H(w) ∨ (G(c,c)∧ H(z))\n\nafter CNF transformation, we have:\n\n(¬H(w) ∨ G(c,c)) ∧ (¬H(w) ∨ H(z))\n\nboth clauses have exactly one positive literal, so they are horn clauses. Translated to Prolog syntax we get:\n\n```\ng(c,c) :- h(W).\nh(Z) :- h(W).\n```\n\n\n\nIf we want to prove the formula:\n\n\nWe have to negate before we skolemize, leading to:\n\n∃w H(w) ∧ ∀x∃z (¬G(x,x) ∨ ¬H(z))\n\nafter skolemizing ∃w and ∃z, deleting ∀x and CNF transformation, we obtain:\n\nH(c) ∧ (¬G(x,x) ∨ ¬H(f(x)))\n\nThat could be interpreted as a fact ```\nh(c)```\n and a query ```\n?- g(X,X), h(f(X)).```\n\n\nTo be honest, both variants don't make much sense - the first does not terminate for any input and in the second version, the query will fail because ```\ng/2```\n is not defined.\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "why z3 horn solver result is unknown and why this is the unknown reason\r\n                \r\nI am using z3 to do equivalence check. I try to use z3 horn solver to accelerate z3 solving time, and I met the following problem: \n\nI would like to check whether two programs are the same or not. The logic of two programs is\nP1: a2 = a1 + 2, where a1 is the input, a2 is the output\nP2: b2 = b1 + 2, where b1 is the input, b2 is the output\nType of a1, a2, b1, b2 is bit-vector 64.\nThe formula is that forall (a1, b1), (a1 == b1) && (a2 == a1 + 2) && (b2 == b1 + 2) => (a2 == b2)\n\nIf I use a bv solver, the result is ```\nsat```\n. However if I use a horn solver, the solve result is ```\nunknown```\n, and the reason is\n\n```\nunknown\nUninterpreted 'a2' in <null>:\nquery!0(#1,#0) :- \n (= a2 (bvadd (:var 1) #x0000000000000002)),\n (not (= a2 b2)),\n (= b2 (bvadd (:var 0) #x0000000000000002)),\n (= (:var 1) (:var 0)).\n```\n\n\nwhy these two solvers have different results? And why the result of the horn solver is unknown?\n\nHere is the source code:\n\n```\n#include \"z3++.h\"\nusing namespace std;\n\nint main() {\n  z3::context ctx;\n  z3::expr a1 = ctx.bv_const(\"a1\", 64);\n  z3::expr a2 = ctx.bv_const(\"a2\", 64);\n  z3::expr b1 = ctx.bv_const(\"b1\", 64);\n  z3::expr b2 = ctx.bv_const(\"b2\", 64);\n\n  z3::expr p1 = (a2 == a1 + 2);\n  z3::expr p2 = (b2 == b1 + 2);\n  z3::expr p_same_input = (a1 == b1);\n  z3::expr p_post = (a2 == b2);\n  z3::expr f = z3::implies(p_same_input && p1 && p2, p_post);\n\n  z3::expr smt = z3::forall(a1, b1, f);\n  z3::solver s(ctx, \"HORN\");  // set the solver as a horn solver\n  s.add(smt);\n  cout << s.check() << endl;\n  cout << s.reason_unknown() << endl;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Restricted boolean formulas for avoiding NP-completeness\r\n                \r\nI have boolean formulas A and B and want to check if \"A -> B\" (A implies B) is true in polynomial time.\n\nFor fully general formulas A and B, this is NP-complete because \"\"A -> B\" is true\" is the same as \"not (A -> B)\" is not satisfiable.\n\nMy goal is to find useful restrictions such that polynomial time verification is possible. I would also be interested in finding O(n) or O(n log n) restrictions (n is some kind of length |A| or |B|). I would prefer to restrict B rather than A.\n\nIn general, I know of the following classes of \"easier\" boolean formulas:\n\n\n(renamable) Horn formulas can be solved in linear time (they are in CNF form with at most one positive variable).\nAll formulas in DNF form are trivial to check\n2-SAT are CNF formulas with at most 2 variables per clause, solvable in linear time.\nXOR-SAT are CNF formulas with XOR instead of OR. They can be solved via Gaussian elimination in O(n^3)\n\n\nThe main problem is that I have the formula \"A -> B\" aka \"(not A) or B\", which quickly becomes non-CNF and non-DNF for non-trivial A/B.\n\nIf I understand the Tseytin transformation correctly, then I can transform any formula X into CNF Y with O(|X|) = O(|Y|), thus I can assume - if I want - that I have my formula in CNF.\n\nThere is some low-hanging fruit:\n\n\nif |B| is constant and small, I could enumerate all solutions to B and check if they are produce a true A.\nsimilarly, if |A| is constant and small, I could enumerate all solutions to A and check if they produce a false B\n\n\nMore interestingly:\n\n\nif B is in DNF then I can convert A to CNF, which will make \"(not A) or B\" DNF which is solvable in linear time.\nFor general B, if |B| is in O(log |A|), I could convert B to DNF and solve it that way\n\n\nHowever, I'm not sure how I can use the other easier classes or if it is possible at all.\n\nDue to distributivity, an A or B in CNF will almost certainly blow up exponentially when trying to bring \"(not A) or B\" back to CNF - if I'm not mistaken.\n\nNote: my use case probably has more complex/longer A than B formulas.\n\nSo my questions boils down to: Are there useful classes of boolean formulas A and B such that \"A -> B\" can be proven in polynomial (preferably linear) time? - apart from the 4 cases that I already mentioned.\n\nEDIT: A different take on this: Under what conditions of A and B is \"A -> B\" in one of the following classes:\n\n\nin DNF\nin CNF and a Horn formula (Horn-SAT)\nin CNF and a binary formula (2-SAT)\nin CNF and a arithmetic formula (CNF of XOR)\n\n    ", "Answer": "", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Z3 get-answer returns unsupported\r\n                \r\nI'm using the fixedpoint engine in Z3 to encode several universal horn formulas. The query turns out to be unsat. In Z3Py, using get_answer() returns the valuations to the uninterpreted relations. However, in the SMTLIB2 format, get-answer returns ```\nunsupported```\n. Here's my program:\n\n```\n(declare-var x Int)\n(declare-var y Int)\n\n(declare-rel I (Int) interval_relation)\n(declare-rel I1 (Int) interval_relation)\n(declare-rel err (Int) interval_relation)\n\n(rule (=> (= x 0) (I x) ))\n(rule (=> (and (= y (+ x 1)) (I x) ) (I1 y) ))\n(rule (=> (and (> y 2) (I1 y)) (err y) ))\n\n(query (err y)\n    :engine pdr\n:use-farkas true\n:print-answer true\n)\n(get-answer)\n```\n\n\nThe output I am getting using Z3 ```\nversion 4.3.2```\n is:\n\n```\nunsat\nunsupported\n; get-answer\n```\n\n\nIn Z3Py, creating a fixedpoint context ```\nfp=Fixedpoint()```\n, and then executing ```\nprint fp.get_answer()```\n would return the valuations to ```\nI```\n, ```\nI1```\n and ```\nerr```\n. Is there a way of obtaining the same in SMTLIB2 format? \nThanks.\n    ", "Answer": "\r\nThe comment section essentially answers the question.\nThe SMT-LIB2 extension for \"query\" takes attributes like your example illustrates.\nIn fact :print-answer amounts to getting the answer.\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Recording a macro is hardcoding the number of rows into a formula, how to replace with LRow or equivalent to make macro dynamically reusable?\r\n                \r\nI'm trying to create an Excel VBA Macro that will replicate the following steps:\n\n\nInsert a blank column in F:F- Success!\nLabel F1 \"Enrollments\" - Success!\nInsert the following code into F2: ```\n=IF(E2=\"\",\"\",IF(COUNTIF(E2:E15735,E2)=1,E2,\"\"))```\n\n(This formula makes it so that duplicate enrollments only show once in the column, allowing for cleanly pivoting the data (after first clearing the formula from the blank cells... I'm not that far in the VBA script yet...))\nCopy the contents down (double-click on the small black cross at the bottom right of F2)\n\n\nThis generates the following VBA code (which can possibly be cleaned up or trimmed, I haven't looked at that yet):\n\n```\nColumns(\"F:F\").Select\n    Selection.Insert Shift:=xlToRight, CopyOrigin:=xlFormatFromLeftOrAbove\n    Range(\"F1\").Select\n    ActiveCell.FormulaR1C1 = \"Enrollments\"\n    Range(\"F2\").Select\n    ActiveCell.FormulaR1C1 = _\n        \"=IF(RC[-1]=\"\"\"\",\"\"\"\",IF(COUNTIF(RC[-1]:R[15733]C[-1],RC[-1])=1,RC[-1],\"\"\"\"))\"\n    Range(\"F3\").Select\n    Range(\"F2\").Select\n    Selection.AutoFill Destination:=Range(\"F2:F15735\")\n    Range(\"F2:F15735\").Select\n```\n\n\nThe question I have is this: I want to reuse this code every time we pull a new enrollment report. To that end, I don't need it to go to row 15733 every time, I need it to dynamically compare to the last row (which I've seen as ```\n\"F\" & LRow```\n but I can't figure out how to insert that into the IF(COUNTIF) statement without throwing an immediate error in the debugger... which (to my untrained eyes) isn't giving me any real feedback on how to fix whatever error I'm creating trying to shoe-horn LRow into the formula. \n    ", "Answer": "\r\nAdd:\n\n```\nDim sht As Worksheet\nDim lastrow as Long\nSet sht = ThisWorkbook.Worksheets(\"Sheet1\")\nlastrow = sht.Cells(sht.Rows.Count, \"F\").End(xlUp).Row\n```\n\n\nThen switch out ```\n15735```\n for ```\nlastrow```\n:\n\n```\nColumns(\"F:F\").Select\n    Selection.Insert Shift:=xlToRight, CopyOrigin:=xlFormatFromLeftOrAbove\n    Range(\"F1\").Select\n    ActiveCell.FormulaR1C1 = \"Enrollments\"\n    Range(\"F2\").Select\n    ActiveCell.FormulaR1C1 = _\n        \"=IF(RC[-1]=\"\"\"\",\"\"\"\",IF(COUNTIF(RC[-1]:R[\" & lastrow & \"]C[-1],RC[-1])=1,RC[-1],\"\"\"\"))\"\n    Range(\"F2\").Select\n    Selection.AutoFill Destination:=Range(\"F2:F\" & lastrow)\n    Range(\"F2:F5\" & lastrow).Select\n```\n\n\nAlso, try to avoid using ```\nSelect```\n when you can. See here\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Google Sheets: Check if any values exist in another column for each row\r\n                \r\nI have a column list of \"Priority\" customers:\n\n\n\n\nPriority\n\n\n\n\nA\n\n\nB\n\n\nC\n\n\nD\n\n\n\n\nSeparately, I have a range of products that various customers buy.\n\n\n\n\nProduct\nEvaluate\nCustomer 1\nCustomer 2\n...\nCustomer n\n\n\n\n\nDrum\nTRUE\nC\nS\n...\n\n\n\nBell\nFALSE\nT\nU\n...\nZ\n\n\nHorn\nTRUE\nA\n\n...\n\n\n\n\n\nI would like to use an ArrayFormula to compute column \"Evaluate\" which checks whether a customer in column \"Priority\" exists for each row in range Customer 1 - Customer n.\nCurrently, I am using SEARCH for each row for each customer:\n```\n=IF(A2=\"\",\"\",IF(IFERROR(search('Priority'!$A$2,G2),0)\n+IFERROR(search('Priority'!$A$3,G2),0)\n+IFERROR(search('Priority'!$A$4,G2),0)\n+IFERROR(search('Priority'!$A$5,G2),0)\n...\n```\n\nWhere G2 is a single cell in a row for my product table with comma-separated values for the customer (A, T, U...) and $A$3, $A$4, $A$5... are my priority customers in a separate column. I am dragging this formula down to evaluate each row. I'd like help coming up with a more efficient formula that doesn't require dragging down to the bottom (arrayformula would be ideal).\nHopefully that's clear - thanks!\n    ", "Answer": "\r\nTry this (assuming your Priority column is on sheet Priority!A:A):\n```\n=arrayformula({\"Evaluate\";if(A2:A<>\"\",regexmatch(query(Priority!A2:A,\"\",9^9),regexreplace(trim(flatten(query(transpose(C2:E),\"\",9^9))),\" \",\"|\")),)})\n```\n\n\nIncrease the range ```\nD2:F```\n depending on how many customer columns you have.\nThe likelihood is that you'll have customer names with spaces so to avoid partial regex matches, you could try:\n```\n=arrayformula({\"Evaluate\";if(A2:A<>\"\",regexmatch(char(9998)&regexreplace(regexreplace(trim(query(regexreplace(Priority!A2:A,\" \",char(9999)),\"\",9^9)),\" \",char(9998)),char(9999),\" \")&char(9998),char(9998)&regexreplace(regexreplace(trim(flatten(query(transpose(regexreplace(C2:E,\" \",char(9999))),\"\",9^9))),\" \",char(9998)&\"|\"&char(9998)),char(9999),\" \")&char(9998)),)})\n```\n\n\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Formula for Calculating a Final Score\r\n                \r\nI'm stuck on one final piece of a calculation puzzle below. I know how to  generate a percentage score of correct parts from total correct possible parts ((correctNumPartsOnBoard / totalPossibleCorrectParts)*100) but I want to the final percentage score to factor in the number the incorrect parts on the board as well. (even if all the right parts are on the board you still won't get 100% if there are also incorrect parts). Right now my current formula ```\npercentCorrectParts = ((correctNumPartsOnBoard / totalPossibleCorrectParts) / totalNumPartsOnBoard) * 100);```\n is wrong and I'm having trouble pinpointing the correct calculation. \n\nSo, the way the calc would need to work is: a user needs to match one of the six possible animals, each animal has around 15 correct parts, but users can also drag incorrect parts onto the board (parts from the other animals are still visible so they could drag a different set of legs or horns on a lizard head, they could make frankenstein type creatures as well this way). So the total number of parts available would be 6*15. But seeing as how they're not all correct they would influence the score as well by bringing the overall score average of pieces on the board down.\n\nWhat's the correct formula for this? \n\n```\n// Scoring System\n\nusing UnityEngine;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ScoreManager : MonoBehaviour\n{\n    public List<string> totalBuildBoardParts;       // Running list of all parts on board (by Tag)\n    public int numCorrectPartsOnBoard;\n    public int numIncorrectPartsOnBoard;\n    public int totalPossibleCorrectParts;\n    public float percentCorrectParts;\n\n    void Start()\n    {\n        GameObject gameController = GameObject.FindGameObjectWithTag(\"gc\");\n        GameSetup gameSetup = gameController.GetComponent<GameSetup>();\n\n        totalPossibleCorrectParts = gameSetup.totalPossibleCorrectParts;\n        Debug.Log(\"TOTAL POSSIBLE CORRECT PARTS ARE: \" + totalPossibleCorrectParts);\n    }\n\n    public void AddAnimalPartByTag(string tag)\n    {\n        // Add object tag to List\n        totalBuildBoardParts.Add(tag);\n\n        Debug.Log (\"Added an object tagged as: \" + tag);\n\n        GameObject gameController = GameObject.FindGameObjectWithTag(\"gc\");\n        GameSetup gameSetup = gameController.GetComponent<GameSetup>();\n\n        if (tag == gameSetup.activeTag)\n        {\n            numCorrectPartsOnBoard ++;\n\n            Debug.Log (\"There are \" + numCorrectPartsOnBoard + \" correct parts on the board\");\n        } else {\n            numIncorrectPartsOnBoard ++;\n        }\n\n        CalculateScore();\n    }\n\n    public void RemoveAnimalPartByTag(string tag)\n    {\n        // Add object tag to List\n        totalBuildBoardParts.Remove(tag);\n\n        Debug.Log (\"Removed an object tagged as: \" + tag);\n\n        GameObject gameController = GameObject.FindGameObjectWithTag(\"gc\");\n        GameSetup gameSetup = gameController.GetComponent<GameSetup>();\n\n        if (tag == gameSetup.activeTag)\n        {\n            numCorrectPartsOnBoard --;\n\n            Debug.Log (\"There are \" + numCorrectPartsOnBoard + \" correct parts on the board\");\n        } else {\n            numIncorrectPartsOnBoard --;\n        }\n\n        CalculateScore();\n    }\n\n    public void CalculateScore()\n    {\n        float totalNumPartsOnBoard = totalBuildBoardParts.Count();\n        float correctNumPartsOnBoard = numCorrectPartsOnBoard; \n        percentCorrectParts = ((correctNumPartsOnBoard / totalPossibleCorrectParts) / totalNumPartsOnBoard) * 100);\n        Debug.Log (\"Your current score is: \" + percentCorrectParts);\n    }\n}\n```\n\n    ", "Answer": "\r\nYour formula is probably correct. However, your datatypes are not.\n\nYou are currently doing an integer division, which results in an ```\nint```\n too. So let's say that ```\ncorrectNumPartsOnBoard```\n is 3 and ```\ntotalPossibleCorrectParts```\n is 5, ```\n3/5```\n gives ```\n0```\n because an ```\nint```\n does not have any decimals.\n\nYou need to cast one of the two operands in the division as a datatype with decimals ( ```\nfloat```\n, ```\ndouble```\n or ```\ndecimal```\n for example):\n\n```\npercentCorrectParts = ((correctNumPartsOnBoard / (float)totalPossibleCorrectParts) / totalNumPartsOnBoard) * 100);\n```\n\n\nBy setting denominator ```\ntotalPossibleCorrectParts```\n as a float, the first division will return a ```\nfloat```\n. That ```\nfloat```\n is then used in the second division, also returning correctly a ```\nfloat```\n.\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "pixel correspondence in optical flow\r\n                \r\nI am somehow new to the concept of optical flow in video sequences and I've read the basics about optical flow and I'm familiar with Horn & Shunck method or Lucas & Kanade's method.\n\nI realized that in these methods we are calculating some vectors which represent the movements of pixels in an image, of course there are some constraints about these pixels (brightness constancy, smoothness and ....)\n\nMy question:\n\nAccording to the formula ```\nfx*u + fy *v = -ft```\n\nhow can we exactly establish a correspondence between one pixel in frame ```\nt```\n , to another pixel in frame ```\nt + 1```\n?\n\nI mean how can we be sure that it is the same pixel in frame ```\nt```\n which we have found in frame ```\nt + 1```\n, I don't know in which part of their algorithm we are finding these pixels and establishing a correspondence between pixels in frame ```\nt```\n and frame ```\nt + 1```\n!\nI know that we can find the pixels which have moved, but I don't know how did we find the relations between the pixels in frame ```\nt```\n and frame ```\nt + 1```\n.\n\nI hope that you understand my question :o)(o:\n\nIf it's possible answer as formulated as you can.\n\nMerci beaucoup\n    ", "Answer": "\r\nActually the methods of Horn, Schunk and Lucas, Kanade deal in different ways with the equation:\n\n```\nFx*U + Fy*V = -Ft\n```\n\n\nAs you see this equation is an underdetermined system of equations. So Horn and Schunk proposed to integrate a secound assumption. The smoothness constrain that the deviation of ```\nU```\n and ```\nV```\n should be small. This is integrated into a least square framework where you have:\n\n```\n(Fx*U + Fy*V + Ft)² + lambda * (gradient(U)² + gradient(V)² = E\nE -> min\n```\n\n\nwith that equation it is possible to solve ```\nU```\n and ```\nV```\n by setting the deviation of ```\nE```\n to ```\n0```\n. Consequently the solutions of the motion vectors are connected via the gradient operator of ```\nU```\n and ```\nV```\n.\n\nLucas and Kanade proposed to that in a defined region the Lucas Kanade window only one motion vector is computed (or a region has the only one motion / motion constancy constrain) and put it into a least square framework:\n\n```\nsum(Fx*U + Fy*V + Ft)² = E\nE->min\n```\n\n\nThe summation is done for each pixel in the defined region. And ```\nU```\n and ```\nV```\n could also be easily computed be the deviation of ```\nE```\n set to ```\n0```\n.\n\nWith these two equations you see that the pixel correspondences are found by using the temporal (```\nFt```\n) and spatial image gradients (```\nFx```\n, ```\nFy```\n). There is a nice picture in the origin Lucas and Kanade paper, that shows this correlation graphically. However there are some points to consider:\n\n\nthese kind of methods are only able to compute motion vectors, if the image contains texture (aperture problem)\n```\nFx*U + Fy*V + Ft```\n is a first order Taylor approximation of ```\nF(x, y, t) = F(x + U, y + V, t + 1)```\n. That means your image signal needs to be linear. In consequence you are just able to compute motions up to a few pixels. That's why image pyramids are used to deliver linearity. \nMotion constancy or smoothness constrains prevent sharp motion boundaries. This could be important in some application.\nThe framework does not prevent you from classical correspondence problem. \n\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Trying to add a non-linear positive trend line in ggplot\r\n                \r\nI'm currently in the process of trying to add a non-linear positive curve to my log-log graph, based off a quadratic model between variables y and x. I always receive the following message, even after attempting to change log mass(x).\n\n\n  \"Warning messages:\n  1: Removed 29 rows containing non-finite values (stat_smooth). \n  2: Computation failed in ```\nstat_smooth()```\n:\n  variable lengths differ (found for '(weights)') \n  3: Removed 29 rows containing missing values (geom_point).\"\n\n\n```\nggplot(species,aes(x=BodyMass,y= MaleHornLength))+\n  geom_point()+geom_smooth(mapping = aes(loglength,logbody),\n  data = species, stat = \"smooth\",method = \"lm\", \n  formula = species$loglength ~ species$logbody +Time8,    \n  se = TRUE,  na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)+\n  scale_x_continuous(trans='log',breaks = c(0,5,10,20,50,100,200,300,500))+\n  scale_y_continuous(trans='log',breaks = c(0,5,10,20,50,100))+\n  labs(x=\"Male Body Mass (kg)\", y=\"Male Horn Length (cm)\")+\n  theme(axis.line = element_line(colour = \"black\"),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        panel.border = element_blank(),\n        panel.background = element_blank(),\n        axis.text=element_text(size=12, colour = \"black\"), \n        axis.title=element_text(size=14))\n```\n\n\nI would greatly appreciate any help regarding the matter. Thank you for your time. \n    ", "Answer": "\r\nRegarding warning number 2: The ```\nformula```\n argument in ```\ngeom_smooth```\n can only have ```\ny```\n as the LHS variable and ```\nx```\n as the RHS variable. Default is ```\ny ~ x```\n, but you can do, for example ```\ny ~ poly(x, 2)```\n or ```\ny ~ splines::bs(x, df=4)```\n. The formula is generic and will use the x and y columns specified in ```\naes```\n.\n\nA few other things:\n\n\nYou don't need ```\ndata=species```\n in ```\ngeom_smooth```\n, since you've already provided ```\ndata=species```\n in the main ggplot call.\nIn your main ggplot call you have x=BodyMass and y=MaleHornLength, but in ```\ngeom_smooth```\n you have x=loglength and y=logbody. I can't see your data, so I can't be certain, but doesn't this reverse the x and y axis mappings between ```\ngeom_point```\n and ```\ngeom_smooth```\n?\nOnce again, I can't be certain without seeing your data, but does it make sense to plot points that are not log transformed and then overlay a regression curve based data that are log transformed? Also, it seems strange to log transform both the data and the axes.\n\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Should I use a relational database or write my own search tree\r\n                \r\nbasically my whole career is based on reading question here but now I'm stuck since I even do not know how to ask this correctly.\n\nI'm designing a SQLITE database which is meant for the construction of data sheets out of existing data sheets. People like reusing stuff and I want to manage this with a DB and an interface. A data sheet has reusable elements like pictures, text, formulas, sections, lists, frontpages and variables. Sections can contain elements -> This can be coped with recursive CTEs - thanks \"mu is too short\" for that hint. Texts, Formulas, lists etc. can contain variables. At the end I want to be able to manage variables which must be unique per data sheet, manage elements which are an ordered list making up the data sheet. So selecting a data sheet I must know which elements are contained and what variables within the elements are used. I must be able to create a new data sheet by re-using elements and/or creating new ones if desired. \n\nI came so far to have (see also link to screen shot at the bottom)\n\na list of variables\n\nwhich (several of them) can be contained in elements\n\na list of elements\n\nelements make up the \n\na list of data sheets\n\nReading examples like \n\nStore array in SQLite that is referenced in another table \n\nHow to store a list in a column of a database table \n\ngive me already helpful hints like that I need to create for each data sheet a new atomic list containing the elements and the position of them. Same for the variables which are referenced by each element. But the troubles start when I want to have it consistent and actually how to query it. \n\nHow do I connect the the variables which are contained within elements and the elements that are contained within the data sheets. How do I check when one element or variable is being modified, which data sheets need to be recompiled since they are using the same variables and/or elements?\n\nThe more I think about this, the more it sounds like I need to write my own search tree based on an object oriented inheritance class structure and must not use data bases. Can somebody convince me that a data base is the right tool for my issue?\n\nI learned data bases once but this is quite some time ago and to be honest the university was not giving good lectures since we never created a database by our own but only worked on existing ones.\n\nTo be more specific, my knowledge leads to this solution so far without knowing how to correctly query for a list of data sheets when changing the content of one value since the reference is a text containing the name of a  table:\n\nscreen shot since I'm a greenhorn\n\nUpdate:\n\nI think I have to search for unique connections, so it would end up in many-to-many tables. Not perfectly happy with it but I think I can go on with it.\n\nstill a green horn, how are you guys using correct high lightning for sql?\n    ", "Answer": "", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "How to read .cnf file (Conjunctive Normal Form) in C?\r\n                \r\nThe file is shown below. I need to read them and store them in a data structure(may be a adjacency list). But I don't know how to ignore the the useless annotation and begin reading after 'p cnf'.\n\n```\nc This Formula is generated by mcnf\nc\nc horn? no\nc forced? no\nc mixed sat? no\nc clause length = 3\nc\np cnf 20 91\n4 -18 19 0\n3 18 -5 0\n-5 -8 -15 0\n-20 7 -16 0\n10 -13 -7 0\n...\n```\n\n\nThat's my code, it may only work when there's no letters in the file.\n\n```\n    // It would be the following code if the file starts with integers, but how could I change it if you were considering comments? I haven't debugged it yet so it might go wrong, I'll do it later.)\n\ntypedef struct LiteralNode {\n    int linum; \n    int tag;    //When the variable is true, it is 1, else it is -1.\n    struct LiteralNode *next;\n} LiteralNode;\n\ntypedef struct ClauseNode {\n    struct ClauseNode *next;\n    int No;\n    struct LiteralNode *info;\n} ClauseNode;\n\ntypedef struct Clause {\n    int literal_num;\n    int clause_num;\n    ClauseNode *root;\n} Clause;\n   Status CreateClause(Clause *cl, char *filename)\n{\n    int m, i = 0;\n    ClauseNode *p, *q;\n    q = (ClauseNode*)malloc(sizeof(ClauseNode));\n    p = (ClauseNode*)malloc(sizeof(ClauseNode));\n    LiteralNode *l1,*l2;\n    p = cl -> root;\n    l1 = (LiteralNode*)malloc(sizeof(LiteralNode));\n    l2 = (LiteralNode*)malloc(sizeof(LiteralNode));\n    FILE *fp = fopen(filename, \"rb\");\n    if (fp == NULL) {\n        return ERROR;\n    }\n    fscanf(fp,\"%d\", &cl -> clause_num);\n    fscanf(fp, \"%d\",&cl -> literal_num);\n    while(fscanf(fp, \"%d\", &m) != EOF){\n        i++;\n        q -> No = i;\n        q -> next = NULL;\n        l1 -> linum = m;\n        l1 -> next = NULL;\n        q -> info = l1;\n        p -> next = q;\n        p = q;\n        fscanf(fp, \"%d\", &m);\n        while (m != 0) {\n            l2 -> linum = m;\n            l2 -> tag = 0;\n            l2 -> next = NULL;\n            l1 -> next = l2;\n            l1 = l2;\n            fscanf(fp, \"%d\", &m);\n        }\n    }\n    return OK;\n}\n```\n\n\ndata structureThe image is about the data structure I use to store the CNF.\n    ", "Answer": "\r\nYou can iterate the lines: if a line begins with ```\nc```\n or is empty: discard it. If it begins with ```\np```\n: parse the problem definition. If it begins with a number: switch to clause mode, and parse clauses without regard for line endings. C standard library facilitates it well.\n\nNow, this is C, and C doesn't really come with good support for any complex data structures. Implementing data structures takes a lot of care! We'll start by implementing a \"simple\" dynamically-sized ```\nClause```\n type: something that, in C++, would be solved with ```\nstd::vector<ClauseLiteral>```\n. We need to pay lots of attention to error handling - otherwise the behavior of the program will be undefined, and we don't want that at all. We catch any arithmetic overflows ahead of time!\n\n```\n#include <assert.h>\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef int ClauseLiteral;\nstatic const int ClauseLiteralMax = INT_MAX;\n\ntypedef struct Clause {\n  size_t size;\n  size_t capacity; // does not include the terminating zero\n  ClauseLiteral literals[1];\n};\n\n// Maximum capacity that doesn't overflow SIZE_MAX\nstatic inline size_t Clause_max_capacity(void) {\n  return (SIZE_MAX-sizeof(Clause))/sizeof(ClauseLiteral);\n}\n\nstatic size_t Clause_size_for_(size_t const count_of_literals) {\n  assert(count_of_literals);\n  if (count_of_literals > Clause_max_capacity()) return 0;\n  return sizeof(Clause) + count_of_literals*sizeof(ClauseLiteral);\n}\n\nstatic size_t Clause_next_capacity_(size_t const capacity) {\n  assert(capacity);\n  const size_t growth_factor = 2;\n  if (capacity > Clause_max_capacity()/growth_factor) {\n    if (capacity < Clause_max_capacity()) return Clause_max_capacity();\n    return 0;\n  }\n  return capacity * growth_factor;\n}\n\nstatic Clause *new_Clause_impl_(size_t const capacity) {\n  size_t const alloc_size = Clause_size_for_(capacity);\n  assert(alloc_size);\n  Clause *const clause = calloc(alloc_size); // is zero-terminated\n  if (!clause) return NULL;\n  clause->size = 0;\n  clause->capacity = capacity;\n  return clause;\n}\n\nClause *new_Clause(void) { return new_Clause_impl_(4); }\n\nvoid free_Clause(Clause *clause) { free(clause); }\n\n/** Assures that the clause exists and has room for at least by items */\nbool Clause_grow(Clause **const clause_ptr, size_t by) {\n  assert(clause_ptr);\n  if (!*clause_ptr) return (*clause_ptr = new_Clause_impl_(by));\n  Clause *const clause = *clause_ptr;\n  assert(clause->size <= clause->capacity);\n  if (clause->size > (SIZE_MAX - by)) return false; // overflow\n  if (by > Clause_max_capacity()) return false; // won't fit\n  if (clause->size > (Clause_max_capacity() - by)) return false; // won't fit\n  size_t const new_size = clause->size + by;\n  assert(new_size <= Clause_max_capacity());\n  if (new_size > clause->capacity) {\n    size_t new_capacity = clause->capacity;\n    while (new_capacity && new_capacity < new_size)\n      new_capacity = Clause_next_capacity_(new_capacity);\n    if (!new_capacity) return false;\n    Clause *const new_clause = realloc(clause, Clause_size_for_(new_capacity));\n    if (!new_clause) return false;\n    *clause_ptr = new_clause;\n  }\n  *clause_ptr->literals[new_size] = 0; // zero-terminate\n  return true;\n}\n\nbool Clause_push_back(Clause **clause_ptr, ClauseLiteral literal) {\n  assert(clause_ptr);\n  assert(literal); // zero literals are not allowed within a clause\n  if (!Clause_grow(clause_ptr, 1)) return false;\n  (*clause_ptr)->literals[(*clause_ptr)->size++] = literal;\n  return true;\n}\n```\n\n\nWe now have a means of growing the clauses as we read them. Let's read, then!\n\n```\n#include <stdio.h>\n\ntypedef struct CNF {\n  size_t variable_count;\n  size_t clause_count;\n  Clause *clauses[1];\n};\n\nstatic inline size_t CNF_max_clause_count() {\n  return (SIZE_MAX-sizeof(CNF))/sizeof(Clause*);\n}\n\nstatic size_t CNF_size_for_(size_t const clause_count) {\n  if (clause_count >= CNF_max_clause_count()) return 0;\n  return sizeof(CNF) + clause_count * sizeof(Clause*);\n}\n\nstatic CNF *new_CNF(size_t variable_count, size_t clause_count) {\n  assert(variable_count <= ClauseLiteralMax);\n  size_t const cnf_size = CNF_size_fir(clause_count);\n  CNF *cnf = calloc(cnf_size);\n  if (!cnf) return NULL;\n  cnf->variable_count = variable_count;\n  cnf->clause_count = clause_count;\n  return cnf;\n}\n\nstatic void free_CNF(CNF *const cnf) {\n  if (!cnf) return;\n  for (Clause **clause_ptr = &cnf->clauses[0]; *clause_ptr && clause+ptr < &cnf->clauses[clause_count]; clause_ptr++)\n    free_Clause(*clause_ptr);\n  free(cnf);\n}\n\nstatic CNF *read_p_line(FILE *file) {\n  assert(file);\n  size_t variable_count, clause_count;\n  int match_count = fscanf(file, \"p cnf %zd %zd\", &variable_count, &clause_count);\n  if (match_count != 2) return NULL;\n  if (variable_count > ClauseLiteralMax) return NULL;\n  return new_CNF(variable_count, clause_count);\n}\n\nstatic bool read_c_line(FILE *file) {\n  assert(file);\n  char c = fgetc(file);\n  if (c != 'c') return false;\n  while ((c = fgetc(file)) != EOF)\n    if (c == '\\n') return true;\n  return false;\n}  \n\nstatic bool read_clauses(FILE *file, CNF *cnf) {\n  assert(file);\n  if (!cnf) return false;\n  size_t const variable_count = cnf->variable_count;\n  for (Clause **clause_ptr = &cnf->clauses[0]; clause_ptr < &cnf->clauses[clause_count];) {\n    int literal;\n    int match_count = fscanf(file, \"%d\", &literal);\n    if (match_count != 1) return false;\n    if (literal == 0) {\n      if (!*clause_ptr) return false; // We disallow empty clauses.\n      clause_ptr++;\n    } \n    else if (literal >= -variable_count && literal <= variable_count) {\n      if (!Clause_push_back(clause_ptr, literal)) return false;\n    }\n    else return false;\n  }\n  return true;\n}\n\nCNF *read_CNF(FILE *file) {\n  assert(file);\n  CNF *cnf = NULL;\n  for (;;) {\n    char const c = fgetc(file);\n    if (c == EOF) goto error;\n    if (isspace(c)) continue; // skip leading whitespace\n    if (ungetc(c, file) == EOF) goto error;\n    if (c == 'p' && !(cnf = read_p_line(file))) goto error;\n    else if (c == 'c' && !read_c_line(file)) goto error;\n    else if (isdigit(c)) break;\n    goto error;\n  }\n  if (!read_clauses(file, cnf)) goto error;\n  return cnf;\nerror:\n  free_CNF(cnf);\n  return NULL;\n}\n```\n\n\nAs you can see, the code is far from trivial, because it's library code that needs to be resilient and not have any undefined behavior at all. \"Simple\" things can be quite complicated in C. That's why, hopefully, you'd rather do this work in C++ if you can.\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Moon illumination and phaseangle or direction\r\n                \r\n\nCalculating the phase of the Moon is pretty straightforward.  I'm not asking that.  The moon actually changes its phase-angle and illumination because of librations and other factors.  (see here for the moon phases for 2011: https://www.youtube.com/watch?v=3f_21N3wcX8)\nMeeus in Astronomical Algorithms (pgs. 98-99 Ch. 14 and pgs. 345-357, chs. 48-50), gives formulae for the phase, illumination, phase-angle and and the parallactic angle to show the position and illumination of the moon.  The problem I have is implementation in php.  How to translate angles in order to achieve the relevant filled-in arc, together with a dark circle to create the appearance of the moon correctly as it would appear in the night sky.  \nI am aware of imagearc ( resource $image , int $cx , int $cy , int $width , int $height , int $start , int $end , int $color) which obviously creates the arc, with the relevant angle.\n\n\nTo create the horns, or the illusion of a crescent, can one superimpose two arcs on top of each other?  The other question is can this be used in tandem with a blur, shadow and actual moon image to make it more realistic?  Or am I better off implementing this in CSS?  Are there any implementations in code that draws the actual moon as determined by the Phase and Paralletic angles?\n    ", "Answer": "", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
{"Question": "Java Scanner not scanning everything from Standard Input in Ubuntu\r\n                \r\n```\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.io.*;\npublic class main {\n    \n    public static void main(String[] args) {\n            Scanner myObj = new Scanner(System.in);\n            String lit = myObj.nextLine();\n            System.out.println(\"<>\");\n            System.out.print(lit);\n    }\n}\n```\n\nI am trying to compute, Horn's formula and I need to pass to the stdin the following input:\n(~y | ~m | ~g | ~S | V | ~K | ~T | ~J | ~v | ~U | ~L | ~t | ~D | ~o | ~k | ~s | ~o | ~C | ~A | ~D | ~H | ~C | ~n | ~H | ~o | ~U | ~a | ~Q) & (~y | ~u | ~y | ~B | ~d | ~H | ~n | ~Y | ~i | ~E | ~z | ~b | ~n | ~n | ~V | ~K | ~v | ~w | ~k | ~i | ~J | ~z | ~m | ~C | ~w | ~U | ~H | ~m | ~K | ~w | ~G | ~l | ~u | ~T | ~y | ~V | ~R | ~Y | ~F | ~g | ~A | ~Q | ~M | ~z | ~e | ~X | ~X | ~n | ~j | ~s | ~q) & (~t | ~d | ~o | ~c | ~S | ~y | ~L | ~M | ~h | ~S | ~H | ~Y | ~h | ~l | ~a | ~C | ~w | ~L | ~Y | ~f | ~c | ~v | ~v | ~T | ~s | ~h) & (~D | ~V | ~c | ~X | ~R | Y | ~X | ~q | ~S | ~d | ~P | ~J | ~K | ~I | ~u | ~v | ~Z | ~o | ~M | ~X | ~i | ~z | ~k | ~g | ~J | ~C | ~w | ~C) & (~v | ~S | ~j | ~s | ~x | ~e | ~R | ~G | ~Q | ~E | ~O | ~k | ~f | ~D | ~Z | ~S | ~y | ~X | ~G | ~w | ~M | ~j | U | ~k | ~m | ~V | ~b | ~a | ~a | ~E | ~b | ~N) & (~X | ~e | ~Q | ~X | ~T | ~R | ~c | ~K | ~A | ~u | ~u | ~n | ~c | ~k | ~H | ~k | ~A | ~S | ~x | ~X | ~R | ~Z | ~u | ~C | ~G | ~c | ~t | ~X | ~w | ~S | ~c | ~o | ~Q | ~E | ~X | ~U) & (~B | ~W | ~O | ~i | ~m | ~c | ~c | ~U | ~q | ~O | ~d | ~p | ~k | ~J | ~I | ~M | ~f | ~V | ~S | ~e | ~U | ~P | ~k | ~B | ~G | ~j | ~K | ~G | ~n) & (~R | ~x | ~O | ~D | ~e | ~u | ~B | ~n | ~L | ~W | ~q | ~T | ~y | ~Y | ~b | ~z | ~c | ~F | ~R | ~i | ~s | ~D | ~I | ~x | ~h | ~h | ~F | ~V | ~T | ~D | ~N | ~l | ~u | ~e | ~p | ~V) & (~t | ~v | ~P | ~W | ~X | ~B | ~G | ~i | ~B | k | ~M | ~q | ~G | ~r | ~b | ~C) & (~U | ~O | ~s | ~I | ~n | ~E | ~i | ~e | ~P | ~x | ~w | ~B | ~s | ~t | ~y | ~U | ~D | ~R | ~Y | ~o | ~M | ~e | ~d | ~p | ~J | ~k | ~p | ~g | ~H | ~v | ~J | ~A | ~j | ~Y | ~s | ~q | ~D | ~k | ~d | ~N | ~A | ~W) & (~R | U | ~z | ~M | ~C | ~B | ~K | ~J | ~F | ~D | ~J | ~e | ~n | ~l | ~E | ~Z | ~O | ~t | ~Y | ~f | ~x) & (~A | ~q | ~M | ~B | ~m | ~D | ~N | ~r | ~w | ~t | ~l | v) & (~n | ~x | ~Q | v | ~d | ~A | ~T | ~P | ~J | ~h) & (~k | ~i | ~J | ~Q | ~v) & (~t | ~c | ~q | ~x) & (~I | ~v | ~M | ~g | ~g | ~E | ~O | ~n | ~M | ~T | ~h | ~v | ~X | ~D | ~B | ~R | ~U | ~A | ~g | ~h | ~o | ~j | ~i | ~o | ~p | ~W | ~h | ~X | ~H | ~X | ~K | ~w | ~h | ~x | ~q | ~j | ~v | ~n | ~N | ~d | ~e | ~n | ~k | ~s | ~C | ~V | ~l | ~b | ~S | ~m | ~r) & (~e) & (~J | ~P | ~t | ~x | ~m | ~h | ~D | ~W | ~t | ~n | ~r | ~p | ~O | ~p | ~u | ~H | k | ~u | ~z | ~O | ~I | ~t | ~d | ~f | ~Y | ~U | ~S | ~N | ~u | ~K | ~N | ~H | ~t | ~D | ~V | ~a | ~b | ~d | ~P | ~M | ~A | ~s | ~m | ~q | ~U | ~a | ~y) & (~s | ~p | ~B | ~O | ~A | ~P | ~L | ~h | ~g | ~I | ~I | ~j | ~n | ~v | ~U | ~S | ~u | ~V | ~c | ~f | ~E | ~V | ~S | ~h | ~y | ~G) & (~b | ~S | ~O | ~V | ~s | ~A | ~e | ~C | ~S | ~M | ~I | ~M | ~C | ~X | ~Q | ~Q | ~I | ~q | ~e | ~K | ~n | ~a | ~I | ~u | ~U | ~J | ~y | ~E | ~M | ~F | ~J | ~H | ~N | ~U | ~G | ~A | ~o | ~j | ~m | ~Z | ~K | ~G | ~M) & (~U | ~R | ~T | ~q | ~C | ~i | ~m | ~H | ~E | ~q | ~z | ~E | ~l) & (~u | ~o | ~k | ~h | ~v | ~k | ~M | ~z | ~X | ~s | ~v | ~s | ~t | ~Q | ~g | ~Z | ~Y | ~E | ~S | ~S | ~m | ~G | ~U | ~u | ~H | ~k | ~m | ~o | ~d | ~Y | ~q | ~I | ~W | ~b | ~B | ~a | ~p | ~R | ~K | ~X | ~s | ~y | ~X | ~R | ~O | ~t | ~I | ~G | ~O) & (~x | W | ~U | ~S | ~j | ~Q | ~l | ~P) & (~D | ~G | ~d | ~t | ~i | ~G | ~P | ~f | ~q | ~k | ~T | ~w | ~D | ~v | ~I | ~u | ~i | ~O | ~R | ~W | ~Q | ~h | ~t | ~t | ~D | ~S | ~A | ~V | ~R | ~f | ~J | ~U | ~s | ~h | ~E | ~c | ~h | ~M | ~W | ~U | ~C | ~Q | ~w | ~G | ~S | ~L | ~y | ~Q | ~D | ~t | ~o) & (~K | ~G | ~Y | ~l | ~S | ~D | ~x | ~Q | ~R | ~M | ~K | ~c | ~R | ~G | ~n | ~P | ~Q | ~b | ~q | ~t | ~S | ~P | ~L | ~W | ~y | ~h | ~Y | ~P | ~K | ~N | ~M | ~L | ~H | ~H | ~w | ~c | ~M | ~T | ~U | ~I | ~o | ~S | ~v | ~Q) & (~S | ~z | G | ~v | ~S | ~R | ~t | ~i | ~R | ~G | ~u | ~b | ~w | ~a | ~e | ~M | ~w | ~R | ~Z | ~V) & (~T | ~B | ~d | ~Q | ~j | ~R | ~E | ~L | ~v | ~C | ~D | ~H | ~S | ~R | ~A | ~S | ~P | ~s) & (~I | ~W | ~J | ~s | ~w | ~O | ~M | ~J | p | ~X | ~Q | ~M | ~b | ~D | ~z | ~s | ~s | ~B | ~a | ~y | ~j | ~b | ~L) & (~s | ~D | ~I | ~J | ~l | ~W | ~C | ~Z | ~R | ~G | ~K | ~H | ~E | ~V | ~H | ~F | ~J | p | ~A) & (~Z | ~N | ~l | ~b | ~k | ~I | ~y | ~x | ~N | ~B | ~X | ~k | ~S | ~j | ~t | ~E | ~Y | ~g | ~g | ~v | ~U | ~l | ~i | ~z | ~l | ~Y | ~v | ~H | ~D | ~m | ~q | ~a | y | ~L | ~u | ~h | ~L) & (~R | ~b | ~k | k | ~n | ~E | ~G | ~s | ~L | ~P | ~b) & (~i | ~F | ~f | ~R | ~I | ~g | P | ~o | ~T | ~s | ~N | ~h | ~n | ~P | ~J | ~G | ~e | ~D | ~j | ~r | ~R | ~D | ~b | ~i | ~o | ~U | ~G | ~r | ~L | ~y | ~z | ~c | ~z | ~V) & (~r | ~r | ~j | ~m | ~a | ~E | ~a | ~f | ~Q | ~B | ~O | ~Y | X | ~L | ~g | ~y | ~t | ~V) & (~b | ~Z | ~H | ~j | ~i | ~q | ~F | O | ~B | ~h | ~Q | ~k | ~P | ~Z | ~m | ~Y | ~V | ~K | ~p | ~j | ~D) & (~V | ~W | ~s | ~T | ~D | ~M | ~l | ~l | ~Y | t | ~s | ~I | ~w | ~K | ~w | ~D | ~W | ~P | ~n | ~w | ~Q | ~t | ~D | ~N | ~A | ~G | ~g) & (~x | ~v | ~F | ~Y | ~K | ~U | ~N | ~e | ~b | ~k | ~v | ~l | ~C | ~w | ~b | ~V | ~v | ~G | ~L | ~e | ~t | ~I | ~U | ~A | ~T | ~z | ~T | ~X | ~l | ~C | ~I | ~X | ~M | ~k | ~y | ~p | ~w | ~z | ~r | ~k | ~I | ~J | ~U | ~V | ~K) & (~c | ~c | ~s | ~O | ~m | ~a | ~G | ~A | ~H | C | ~L | ~T | ~T | ~a | ~y | ~A | ~F | ~U | ~X | ~s | ~u | ~z | ~t | ~H | ~i | ~F | ~I | ~i | ~S | ~e | ~Y | ~l | ~v | ~q | ~Q | ~y | ~F | ~g | ~X | ~I | ~I | ~l | ~p) & (~L | ~P | ~t | ~z | ~o | ~S | ~x | ~O | ~g | ~M | ~D | ~W | ~x | ~K | ~f | ~D | ~v | ~z | ~k | ~V | ~T | ~P | ~B | ~T | ~i | ~I) & (~S | ~I | ~V | ~X | ~P | ~d | ~o | ~x | ~o | ~p | ~I | ~n | ~h | ~P | ~F | ~T | ~w | ~n | ~h | ~m | ~X | ~k | ~T | ~x | ~p | ~Y | ~u | ~M | ~x | ~X | ~q | ~F | ~U | ~P | ~G | ~H | ~i | ~C | ~i | ~f | ~Z | ~T | ~e | ~Y | ~T | ~y | ~e | ~h | ~d | ~i | ~i) & (~H | ~X | ~l | ~s | ~w | ~p | ~S | ~Z | ~S | ~H | ~D | ~E | ~Z | ~g | ~L | ~D | Y | ~t | ~z | ~D | ~U | ~V | ~i | ~Z | ~S | ~i | ~g | ~H | ~f | ~y | ~o | ~B | ~j | ~H | ~v | ~L | ~S | ~k) & (~A | ~N | ~d | ~u | ~X | ~q | ~k | ~w | ~E | ~x | ~w | ~l | ~u | ~x | ~B | ~O | ~v | ~w | ~R | ~S | ~B | ~q | ~O | ~y | ~o | ~D | ~n | ~q | ~o | ~l | ~d | ~M | ~S | ~j | ~T | ~p | ~U | ~X | ~a | ~M | ~P | ~L | ~k | ~N | ~f) & (~H | ~p | ~N | ~t | ~B | ~F | ~U | ~L | ~O | ~s | ~P | ~O | ~b | ~T | ~T | ~e | ~u | ~L | ~w | ~l | ~w | ~o | ~m | ~x | ~C | ~M | ~x | ~X | ~C | ~o | ~Z | ~E | ~c | ~a | ~S | ~t | ~w | ~Y | ~Z | ~U | ~m | ~O | ~g | ~n | ~a | ~L | ~H | ~G) & (~m | ~s | ~V | ~o | ~R | ~K | ~F | ~Q | ~z | ~u | ~k | ~r | ~i | ~N | ~Z | ~W | ~o | ~t | ~u | ~M | ~T | ~A | ~c) & (~n | ~h | ~N | ~F | ~h | ~O | ~i | ~F | ~e | ~n | ~y | ~B | ~j | ~U | ~h | ~e | ~r | ~T | ~d | ~N | ~A | ~t | ~X | ~l | ~h | ~N | ~P | ~D | ~s | ~q | ~k | ~w | ~x | ~f | ~y | ~H | ~B | ~b | ~C | ~u | ~Q | ~l | ~h | ~m | ~l | ~K | ~S | ~g | ~s | ~L | ~Z | ~T) & (~i | ~o | e | ~z | ~e | ~n | ~x | ~I | ~L | ~m | ~H | ~O | ~s | ~y | ~g | ~e | ~u | ~e | ~W) & (~W | ~O | ~p | ~o | ~a | ~e | ~J | ~L | ~p | ~l | ~K | ~D | ~R | ~Q | ~Q | ~x | ~K | ~r | ~e | ~d | ~S | ~W | ~c | ~q | ~D | ~D | ~E | ~a | ~n | ~d | ~b | ~l | ~x | ~Q | ~P | ~L | ~H | ~n | ~a | ~x | ~x | ~Y | ~K | ~A | ~q | ~B | ~m | ~q | ~k | ~R | ~f | ~h) & (~a | ~n | ~Z | ~A | ~W | ~S | ~O | ~V | ~g | ~G | ~K | ~d | ~Z | ~u | ~j | ~S | ~H | ~v | ~a | ~V | ~g | ~G | ~F | ~D | ~n | ~w | ~W | ~W | ~q | ~u | ~C | ~Y | ~C | ~p | ~r | ~v | ~z | ~A | ~P | ~Y | ~s | ~C | ~u | ~g | ~X | ~y | ~Z | ~K | ~N | ~C) & (~h | ~G | ~d | ~g | ~o | ~j | ~B | ~X | ~w | ~h | ~U | ~W | ~T | ~H | ~E | ~J | ~y | ~j | ~Y | ~y | ~u | ~O | ~j | ~b | ~B | ~D | ~M | ~S | ~k | ~Z | ~E | ~m | ~j | ~R | ~G | ~M | ~W | ~g | ~Q | ~A | ~O | ~Y | ~u | ~P | ~H | ~A | ~a) & (~p | ~N | ~w | ~Q | ~y | ~I | ~z | ~s | ~l | ~e | ~x | ~c | ~O | ~L | ~M | ~h | ~D | ~O | ~d | ~D | G | ~I | ~l | ~a | ~J | ~q | ~L | ~O | ~N | ~M | ~Q | ~h | ~o | ~A | ~d | ~a | ~O | ~H) & (~g | ~W | ~G | ~n | H | ~J | ~h | ~g | ~k) & (~y | ~M | ~J | ~F | ~D | ~f | H | ~m | ~h | ~y | ~N | ~o | ~H | ~v | ~B | ~r | ~W | ~b | ~a) & (~H | ~K | ~m | ~u | ~x | ~H | ~l | ~R | ~W | ~b | ~m | ~F | ~L | ~q | ~p | ~Y | ~l | ~z | ~M | ~X | ~X | ~O | ~F | ~s | ~i | ~G | ~H | ~K | ~A | ~y | ~O | ~y | ~p | ~w | ~V | ~b) & (~h | ~X | ~N | ~Q | ~A | ~Y | ~X | ~L | ~C | ~B | ~P | ~T | ~l | ~I | ~V | ~z | ~u | ~M | ~G | ~l) & (~W | ~r | ~d | ~y | ~F | ~T | C | ~k | ~N | ~z | ~G | ~E | ~y | ~i | ~c | ~J | ~u | ~X | ~Z | ~V | ~W | ~Z | ~O | ~y | ~d | ~o | ~p | ~s | ~z | ~e | ~R | ~I | ~Q | ~X | ~E | ~B | ~i | ~M | ~E | ~q | ~H | ~I | ~Y | ~p | ~M) & (~G | ~j | ~b | ~j | ~X | ~s | ~K | ~V | ~D | ~w | ~U | ~L | ~E | ~P | ~U | ~g | ~e | ~O | ~i | ~x | ~t | ~m | ~P | ~t | ~p | ~B | ~E | ~S | ~L | ~Y | ~M | ~A | ~H) & (~U | ~c | ~Q | ~d | ~z | ~K | ~t | ~g | ~x | ~o | ~r | ~J | ~n | ~D | ~O | ~l | ~O | ~Q | ~K | ~r | ~Q | ~z | ~G | ~O | ~e | ~Z | ~o | ~D | ~O) & (~K | ~U | ~U | ~s | ~J | ~w | ~B | ~r | ~R | ~q | ~q | ~D | ~N | ~b | ~J | ~t | ~F | ~D | ~H | ~N | ~a | ~z | ~c | ~Z | ~Z | ~g | ~a | ~g | ~n | ~d | ~d | ~M | ~G) & (~W | ~Q | ~k | ~m | ~K | ~z | ~o | ~o | ~z | ~k | ~x | ~T | ~p | ~S | ~C | ~l | ~S | ~X | ~n | ~j | ~D | ~W | ~w | ~W | ~X | ~w | ~W | ~M | ~a | ~F | ~y | ~W | ~T | ~G | ~k | ~B | ~d | ~m | ~i | ~H | ~C | ~k | ~P | ~W | ~D | ~m) & (~p | ~T | ~t | ~P | ~n | ~k | ~A | ~n | ~Z | ~i | ~l | ~W | ~b | ~O | ~l | ~e | ~f | ~B | T | ~D | ~j | ~q | ~X) & (~c | ~V | ~a | ~E | ~i | ~G | ~X | ~L) & (~f | ~A | ~P | ~F | ~n | ~S | ~p | ~e | ~L | ~K | ~E | ~Y | ~h | ~M | ~b | ~u | ~y | ~a | ~E | ~o | ~k | ~B | ~X | ~k | ~V | ~O | ~R | ~e | ~X | ~h | ~K | ~g | ~W | ~f | ~w) & (~f | ~c | ~Z | ~Y | ~p | ~n | ~i | ~e | ~N | ~a | ~y | ~d | ~v | ~z | ~p | ~H | ~f | ~S | ~E | ~Z | ~S | ~Z | ~w | ~V | ~U | ~T | ~g | ~y | ~B | ~H) & (~I | ~w | ~p | ~P | ~p | ~r | ~m | ~O | ~q | ~r | ~u | ~G | ~u | ~t | ~C | ~B | ~L | ~k | ~x | ~S | ~Q | ~a | ~X | ~o | ~v | ~t | ~O | ~M | ~m | ~M | ~Y | ~E | ~P | ~D | ~m | ~U | ~V | ~y | ~z | ~f | ~I) & (~H | ~k | ~N | ~R | ~H | ~s | ~U | ~T | ~O | ~W | ~M | ~t | ~p | ~e | ~p | ~k | ~s | ~r | ~P | ~e | ~o | ~C | ~Y) & (~w | ~f | ~e | ~c | ~n | ~N | ~A | ~U | ~z | ~p | ~D | ~r | ~d | ~B | ~V | ~J | ~h | ~A | ~b | ~R | ~S | ~T | ~b | ~b | ~p | ~x | ~H | ~r | ~E | ~B | ~l | ~S) & (~L | ~x | ~b | ~i | ~S | ~C | ~s | Y | ~Q | ~A | ~V | ~t | ~f | ~g | ~l | ~G | ~u | ~z | ~P | ~s | ~Y | ~s | ~m | ~b | ~h | ~O | ~Q | ~p | ~e | ~i | ~P | ~G | ~I | ~F) & (~h | ~c | ~t | ~x | ~k | ~X | ~h | ~k | ~y | ~c | ~z | ~j | ~h | ~p | ~S | ~X | ~P | ~y) & (~E | ~Q | ~e | ~O | ~G | ~n | ~o | ~K | ~K | ~E | ~Z | ~H | ~i | ~j | ~U | ~r | ~w | ~E | ~Y | ~L | ~Q | ~v | ~y | ~z | ~R | ~K | ~i | ~D | ~d | ~j | ~C | ~q | ~J | ~u | ~F | ~q) & (~W | ~q | ~n | ~L | ~d | ~Z | ~E | ~b | ~I | ~c | ~a | ~y | ~a | ~b | ~D | ~e | ~a | ~u) & (~J | ~E | ~j | ~k | ~d | ~M | ~i | ~t | ~c | ~U | ~r | ~p | ~Y | ~x | ~c | ~L | ~c | ~a | ~x | ~N | ~H) & (~J | ~x | ~I | ~m | ~B | ~p | ~V | ~B | ~C | ~r | ~t | ~W | ~u | ~M | ~K | ~y | ~s | ~f | ~z | ~m | ~R | ~D | ~Z | ~e | ~n | ~y | ~U | ~t | ~g | ~y | ~U | ~j | ~h | ~z | ~v | ~q | ~s | ~F | ~n | ~r | ~e | ~w | ~Y | ~w) & (e)\nBut whenever I print it, it does not print everything\nOutput:\n(~y | ~m | ~g | ~S | V | ~K | ~T | ~J | ~v | ~U | ~L | ~t | ~D | ~o | ~k | ~s | ~o | ~C | ~A | ~D | ~H | ~C | ~n | ~H | ~o | ~U | ~a | ~Q) & (~y | ~u | ~y | ~B | ~d | ~H | ~n | ~Y | ~i | ~E | ~z | ~b | ~n | ~n | ~V | ~K | ~v | ~w | ~k | ~i | ~J | ~z | ~m | ~C | ~w | ~U | ~H | ~m | ~K | ~w | ~G | ~l | ~u | ~T | ~y | ~V | ~R | ~Y | ~F | ~g | ~A | ~Q | ~M | ~z | ~e | ~X | ~X | ~n | ~j | ~s | ~q) & (~t | ~d | ~o | ~c | ~S | ~y | ~L | ~M | ~h | ~S | ~H | ~Y | ~h | ~l | ~a | ~C | ~w | ~L | ~Y | ~f | ~c | ~v | ~v | ~T | ~s | ~h) & (~D | ~V | ~c | ~X | ~R | Y | ~X | ~q | ~S | ~d | ~P | ~J | ~K | ~I | ~u | ~v | ~Z | ~o | ~M | ~X | ~i | ~z | ~k | ~g | ~J | ~C | ~w | ~C) & (~v | ~S | ~j | ~s | ~x | ~e | ~R | ~G | ~Q | ~E | ~O | ~k | ~f | ~D | ~Z | ~S | ~y | ~X | ~G | ~w | ~M | ~j | U | ~k | ~m | ~V | ~b | ~a | ~a | ~E | ~b | ~N) & (~X | ~e | ~Q | ~X | ~T | ~R | ~c | ~K | ~A | ~u | ~u | ~n | ~c | ~k | ~H | ~k | ~A | ~S | ~x | ~X | ~R | ~Z | ~u | ~C | ~G | ~c | ~t | ~X | ~w | ~S | ~c | ~o | ~Q | ~E | ~X | ~U) & (~B | ~W | ~O | ~i | ~m | ~c | ~c | ~U | ~q | ~O | ~d | ~p | ~k | ~J | ~I | ~M | ~f | ~V | ~S | ~e | ~U | ~P | ~k | ~B | ~G | ~j | ~K | ~G | ~n) & (~R | ~x | ~O | ~D | ~e | ~u | ~B | ~n | ~L | ~W | ~q | ~T | ~y | ~Y | ~b | ~z | ~c | ~F | ~R | ~i | ~s | ~D | ~I | ~x | ~h | ~h | ~F | ~V | ~T | ~D | ~N | ~l | ~u | ~e | ~p | ~V) & (~t | ~v | ~P | ~W | ~X | ~B | ~G | ~i | ~B | k | ~M | ~q | ~G | ~r | ~b | ~C) & (~U | ~O | ~s | ~I | ~n | ~E | ~i | ~e | ~P | ~x | ~w | ~B | ~s | ~t | ~y | ~U | ~D | ~R | ~Y | ~o | ~M | ~e | ~d | ~p | ~J | ~k | ~p | ~g | ~H | ~v | ~J | ~A | ~j | ~Y | ~s | ~q | ~D | ~k | ~d | ~N | ~A | ~W) & (~R | U | ~z | ~M | ~C | ~B | ~K | ~J | ~F | ~D | ~J | ~e | ~n | ~l | ~E | ~Z | ~O | ~t | ~Y | ~f | ~x) & (~A | ~q | ~M | ~B | ~m | ~D | ~N | ~r | ~w | ~t | ~l | v) & (~n | ~x | ~Q | v | ~d | ~A | ~T | ~P | ~J | ~h) & (~k | ~i | ~J | ~Q | ~v) & (~t | ~c | ~q | ~x) & (~I | ~v | ~M | ~g | ~g | ~E | ~O | ~n | ~M | ~T | ~h | ~v | ~X | ~D | ~B | ~R | ~U | ~A | ~g | ~h | ~o | ~j | ~i | ~o | ~p | ~W | ~h | ~X | ~H | ~X | ~K | ~w | ~h | ~x | ~q | ~j | ~v | ~n | ~N | ~d | ~e | ~n | ~k | ~s | ~C | ~V | ~l | ~b | ~S | ~m | ~r) & (~e) & (~J | ~P | ~t | ~x | ~m | ~h | ~D | ~W | ~t | ~n | ~r | ~p | ~O | ~p | ~u | ~H | k | ~u | ~z | ~O | ~I | ~t | ~d | ~f | ~Y | ~U | ~S | ~N | ~u | ~K | ~N | ~H | ~t | ~D | ~V | ~a | ~b | ~d | ~P | ~M | ~A | ~s | ~m | ~q | ~U | ~a | ~y) & (~s | ~p | ~B | ~O | ~A | ~P | ~L | ~h | ~g | ~I | ~I | ~j | ~n | ~v | ~U | ~S | ~u | ~V | ~c | ~f | ~E | ~V | ~S | ~h | ~y | ~G) & (~b | ~S | ~O | ~V | ~s | ~A | ~e | ~C | ~S | ~M | ~I | ~M | ~C | ~X | ~Q | ~Q | ~I | ~q | ~e | ~K | ~n | ~a | ~I | ~u | ~U | ~J | ~y | ~E | ~M | ~F | ~J | ~H | ~N | ~U | ~G | ~A | ~o | ~j | ~m | ~Z | ~K | ~G | ~M) & (~U | ~R | ~T | ~q | ~C | ~i | ~m | ~H | ~E | ~q | ~z | ~E | ~l) & (~u | ~o | ~k | ~h | ~v | ~k | ~M | ~z | ~X | ~s | ~v | ~s | ~t | ~Q | ~g | ~Z | ~Y | ~E | ~S | ~S | ~m | ~G | ~U | ~u | ~H | ~k | ~m | ~o | ~d | ~Y | ~q | ~I | ~W | ~b | ~B | ~a | ~p | ~R | ~K | ~X | ~s | ~y | ~X | ~R | ~O | ~t | ~I | ~G | ~O) & (~x | W | ~U | ~S | ~j | ~Q | ~l | ~P) & (~D | ~G | ~d | ~t | ~i | ~G | ~P | ~f | ~q | ~k | ~T | ~w | ~D | ~v | ~I | ~u | ~i | ~O | ~R | ~W | ~Q | ~h | ~t | ~t | ~D | ~S | ~A | ~V | ~R | ~f | ~J | ~U | ~s | ~h | ~E | ~c | ~h | ~M | ~W | ~U | ~C | ~Q | ~w | ~G | ~S | ~L | ~y | ~Q | ~D | ~t | ~o) & (~K | ~G | ~Y | ~l | ~S | ~D | ~x | ~Q | ~R | ~M | ~K | ~c | ~R | ~G | ~n | ~P | ~Q | ~b | ~q | ~t | ~S | ~P | ~L | ~W | ~y | ~h | ~Y | ~P | ~K | ~N | ~M | ~L | ~H | ~H | ~w | ~c | ~M | ~T | ~U | ~I | ~o | ~S | ~v | ~Q) & (~S | ~z | G | ~v | ~S | ~R | ~t | ~i | ~R | ~G | ~u | ~b | ~w | ~a | ~e | ~M | ~w | ~R | ~Z | ~V) & (~T | ~B | ~d | ~Q | ~j | ~R | ~E | ~L | ~v | ~C | ~D | ~H | ~S | ~R | ~A | ~S | ~P | ~s) & (~I | ~W | ~J | ~s | ~w | ~O | ~M | ~J | p | ~X | ~Q | ~M | ~b | ~D | ~z | ~s | ~s | ~B | ~a | ~y | ~j | ~b | ~L) & (~s | ~D | ~I | ~J | ~l | ~W | ~C | ~Z | ~R | ~G | ~K | ~H | ~E | ~V | ~H | ~F | ~J | p | ~A) & (~Z | ~N | ~l | ~b | ~k | ~I | ~y | ~x | ~N | ~B | ~X | ~k | ~S | ~j | ~t | ~E | ~Y | ~g | ~g | ~v | ~U\nMy java version:\nopenjdk version \"11.0.11\" 2021-04-20\nOpenJDK Runtime Environment (build 11.0.11+9-Ubuntu-0ubuntu2.20.04)\nOpenJDK 64-Bit Server VM (build 11.0.11+9-Ubuntu-0ubuntu2.20.04, mixed mode, sharing)\n    ", "Answer": "\r\nTry making a file ```\ntest.txt```\n and writing input in it and the output will be printed in ```\ntestout.txt```\n\n```\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.io.*;\npublic class Main {\n    \n    public static void main(String[] args) {\n        String lit=\"\";\n        try{\n            FileReader fr=new FileReader(\"test.txt\");    \n            int i;    \n            while((i=fr.read())!=-1)    \n                lit=lit+(char)(i);   \n            fr.close();    \n        }\n        catch(Exception e){\n            System.out.println(\"failed to read file test.txt\");\n        }\n        \n        try{    \n            FileWriter fw=new FileWriter(\"testout.txt\");    \n            fw.write(lit);    \n            fw.close();   \n            System.out.println(\"out put is in textout.txt\");   \n        }catch(Exception e){\n            System.out.println(e);\n        }    \n                 \n    }    \n}\n```\n\nthe output will be in textout.txt file.\n    ", "Knowledge_point": "Horn Formula", "Tag": "算法分析"}
