{"Question": "Analyze audio using Fast Fourier Transform\r\n                \r\nI am trying to create a graphical spectrum analyzer in python.\n\nI am currently reading 1024 bytes of a 16 bit dual channel 44,100 Hz sample rate audio stream and averaging the amplitude of the 2 channels together.  So now I have an array of 256 signed shorts.  I now want to preform a fft on that array, using a module like numpy, and use the result to create the graphical spectrum analyzer, which, to start will just be 32 bars.\n\nI have read the wikipedia articles on Fast Fourier Transform and Discrete Fourier Transform but I am still unclear of what the resulting array represents.  This is what the array looks like after I preform an fft on my array using numpy:\n\n```\n   [ -3.37260500e+05 +0.00000000e+00j   7.11787022e+05 +1.70667403e+04j\n   4.10040193e+05 +3.28653370e+05j   9.90933073e+04 +1.60555003e+05j\n   2.28787050e+05 +3.24141951e+05j   2.09781047e+04 +2.31063376e+05j\n  -2.15941453e+05 +1.63773851e+05j  -7.07833051e+04 +1.52467334e+05j\n  -1.37440802e+05 +6.28107674e+04j  -7.07536614e+03 +5.55634993e+03j\n  -4.31009964e+04 -1.74891657e+05j   1.39384348e+05 +1.95956947e+04j\n   1.73613033e+05 +1.16883207e+05j   1.15610357e+05 -2.62619884e+04j\n  -2.05469722e+05 +1.71343186e+05j  -1.56779748e+04 +1.51258101e+05j\n  -2.08639913e+05 +6.07372799e+04j  -2.90623668e+05 -2.79550838e+05j\n  -1.68112214e+05 +4.47877871e+04j  -1.21289916e+03 +1.18397979e+05j\n  -1.55779104e+05 +5.06852464e+04j   1.95309737e+05 +1.93876325e+04j\n  -2.80400414e+05 +6.90079265e+04j   1.25892113e+04 -1.39293422e+05j\n   3.10709174e+04 -1.35248953e+05j   1.31003438e+05 +1.90799303e+05j...\n```\n\n\nI am wondering what exactly these numbers represent and how I would convert these numbers into a percentage of a height for each of the 32 bars.  Also, should I be averaging the 2 channels together?\n    ", "Answer": "\r\nThe array you are showing is the Fourier Transform coefficients of the audio signal. These coefficients can be used to get the frequency content of the audio. The FFT is defined for complex valued input functions, so the coefficients you get out will be imaginary numbers even though your input is all real values. In order to get the amount of power in each frequency, you need to calculate the magnitude of the FFT coefficient for each frequency. This is not just the real component of the coefficient, you need to calculate the square root of the sum of the square of its real and imaginary components. That is, if your coefficient is a + b*j, then its magnitude is sqrt(a^2 + b^2).\n\nOnce you have calculated the magnitude of each FFT coefficient, you need to figure out which audio frequency each FFT coefficient belongs to. An N point FFT will give you the frequency content of your signal at N equally spaced frequencies, starting at 0. Because your sampling frequency is 44100 samples / sec. and the number of points in your FFT is 256, your frequency spacing is 44100 / 256 = 172 Hz (approximately)\n\nThe first coefficient in your array will be the 0 frequency coefficient. That is basically the average power level for all frequencies. The rest of your coefficients will count up from 0 in multiples of 172 Hz until you get to 128. In an FFT, you only can measure frequencies up to half your sample points. Read these links on the Nyquist Frequency and Nyquist-Shannon Sampling Theorem if you are a glutton for punishment and need to know why, but the basic result is that your lower frequencies are going to be replicated or aliased in the higher frequency buckets. So the frequencies will start from 0, increase by 172 Hz for each coefficient up to the N/2 coefficient, then decrease by 172 Hz until the N - 1 coefficient.\n\nThat should be enough information to get you started. If you would like a much more approachable introduction to FFTs than is given on Wikipedia, you could try Understanding Digital Signal Processing: 2nd Ed.. It was very helpful for me.\n\nSo that is what those numbers represent. Converting to a percentage of height could be done by scaling each frequency component magnitude by the sum of all component magnitudes. Although, that would only give you a representation of the relative frequency distribution, and not the actual power for each frequency. You could try scaling by the maximum magnitude possible for a frequency component, but I'm not sure that that would display very well. The quickest way to find a workable scaling factor would be to experiment on loud and soft audio signals to find the right setting.\n\nFinally, you should be averaging the two channels together if you want to show the frequency content of the entire audio signal as a whole. You are mixing the stereo audio into mono audio and showing the combined frequencies. If you want two separate displays for right and left frequencies, then you will need to perform the Fourier Transform on each channel separately.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in C# [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Fast fourier transform in c#  \n\n\n\n\nI am looking for an example of performing a real time FFT (Fast Fourier Transform) of line in or mic audio data in C#. My goal is to determine in real time if a particular note is present in the audio data. Any examples appreciated.\n    ", "Answer": "\r\nAForge.NET is an open-source library with Fast Fourier Transform support.\nExocortexDSP is also another option.\n\nExocortexDSP example would look something like this:\n\n```\n   Exocortex.DSP.ComplexF[] complexData = new Exocortex.DSP.ComplexF[512];\n   for (int i = 0; i < 512; ++i)\n   {\n      // Fill the complex data\n      complexData[i].Re = 1; // Add your real part here\n      complexData[i].Im = 2; // Add your imaginary part here\n   }\n\n   // FFT the time domain data to get frequency domain data\n   Exocortex.DSP.Fourier.FFT(complexData, Exocortex.DSP.FourierDirection.Forward);\n\n   float[] mag_dat_buffer = new float[complexData.Length];\n   // Loop through FFT'ed data and do something with it\n   for (int i = 0; i < complexData.Length; ++i)\n   {\n      // Calculate magnitude or do something with the new complex data\n      mag_data_buffer[i] = ImaginaryNumberMagnitude(complexData[i].Im, complexData[i].Re);\n   }\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "When calculating the fast Fourier transform..?\r\n                \r\nIf we get the sound from microphone with two channels, to calculate the frequency spectrum we:\n\n\ncalculate the fast fourier transform of all the data input?\ncalculate the fast fourier transform of each left and right channel and then make a average of both?\ncalculate the fast fourier transform of each left and right channel and get the biggest values of both?\ncalculate in a different way?\n\n    ", "Answer": "\r\nI assume your two-channel microphone has inputs that are physically separate - typically, opposite sides of a lecture hall or theater. In this case, the Fourier transform of each channel shows you the frequency content at the physical location of that channel's input - you can't just average them or add them together and get any meaningful result.\n\nIf you're trying to get the spectrum at the midpoint between the channel inputs, averaging might make sense, but anything else would require some big assumptions (reflection not a factor, etc) and interpolation. \n\nAny meaningful analysis of this data is going to have to take into account the physical geometry of the space where the sound is sampled. Clarify what you're looking for. \n\nOh, and tag your posts as homework.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in R\r\n                \r\nI have a dataset with the number of hourly visits an animal made during a period of 12 months. I want to use the Fast Fourier Transform to examine cyclical patterns and periodicity. In the past, I have used Statistica for this this; however, I would like to use R to get a plot of the spectral density vs. period. Is there an easy way to do this in R? I would like to identify 12 and 24 hr peak in activity if possible.\n    ", "Answer": "\r\nYou may consider the following functions.\n\n\n```\nperiodogram```\n from ```\nTSA```\n package immediately plots a periodogram.\n```\nperiodogram```\n from ```\nGeneCycle```\n returns a list of frequencies and estimated power spectral densities. It is a wrapper function for ```\nstats::spectrum```\n with some special options set.\n```\nspectrum```\n from ```\nstats```\n allows you to choose the method used to estimate the spectral density: either periodogram or using autoregressive process.\n```\ncpgram```\n from ```\nstats```\n plots a cumulative periodogram along with a confidence interval.\n\n\nSee, e.g., ```\n?cpgram```\n or ```\n?spectrum```\n for all the details and keep in mind that it is, e.g., ```\nTSA::periodogram```\n and ```\nGeneCycle::periodogram```\n when names of the functions coincide.\n\nThere are also plenty of examples and tutorials online on how to use those functions. See here for the usage of ```\nfft```\n and here for an even more extensive tutorial.\n\nAlso, as you probably already know, a given time series must be detrended. Hence, use, e.g., ```\ndiff(x)```\n instead of ```\nx```\n. And finally, the length of your time series must be divisible by 12 as to be able to identify 12 and 24 hours frequencies, it can be achieved by, e.g., ```\nx[-(1:(length(x) %% 12))]```\n, where ```\nx```\n is a detrended time series.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform in Erlang\r\n                \r\nI am looking for an example of using FFT (Fast Fourier Transform) in Erlang. Can show me an example of code?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform of a signal\r\n                \r\nI have an excel file which has time and magnitute columns of a signal. The signal is overlap of 4 different signals. It has 100 data points for a second and continues for 10 mins. How can I take Fast Fourier Transform of this signal?\nI have searched what Fast Fourier Transform is but I couldn't find any way to implement it.\nenter image description here\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transformation in Java [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Reliable and fast FFT in Java  \n\n\n\n\ni want to implement a fast fourier transformation calculation in java. Is there any library in java to do calculation in fourier transform and i also want to know about the audio libraries in java.\n    ", "Answer": "\r\nMay be a duplicate, but you're probably going to have a challenge making a JNI/NDK setup work. Consider a full java solution with JTransforms\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Plotting a fast Fourier transform in Python\r\n                \r\nI have access to NumPy and SciPy and want to create a simple FFT of a data set. I have two lists, one that is ```\ny```\n values and the other is timestamps for those ```\ny```\n values.\nWhat is the simplest way to feed these lists into a SciPy or NumPy method and plot the resulting FFT?\nI have looked up examples, but they all rely on creating a set of fake data with some certain number of data points, and frequency, etc. and don't really show how to do it with just a set of data and the corresponding timestamps.\nI have tried the following example:\n```\nfrom scipy.fftpack import fft\n\n# Number of samplepoints\nN = 600\n\n# Sample spacing\nT = 1.0 / 800.0\nx = np.linspace(0.0, N*T, N)\ny = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x)\nyf = fft(y)\nxf = np.linspace(0.0, 1.0/(2.0*T), N/2)\nimport matplotlib.pyplot as plt\nplt.plot(xf, 2.0/N * np.abs(yf[0:N/2]))\nplt.grid()\nplt.show()\n```\n\nBut when I change the argument of ```\nfft```\n to my data set and plot it, I get extremely odd results, and it appears the scaling for the frequency may be off. I am unsure.\nHere is a pastebin of the data I am attempting to FFT\nhttp://pastebin.com/0WhjjMkb\nhttp://pastebin.com/ksM4FvZS\nWhen I use ```\nfft()```\n on the whole thing it just has a huge spike at zero and nothing else.\nHere is my code:\n```\n## Perform FFT with SciPy\nsignalFFT = fft(yInterp)\n\n## Get power spectral density\nsignalPSD = np.abs(signalFFT) ** 2\n\n## Get frequencies corresponding to signal PSD\nfftFreq = fftfreq(len(signalPSD), spacing)\n\n## Get positive half of frequencies\ni = fftfreq>0\n\n##\nplt.figurefigsize = (8, 4)\nplt.plot(fftFreq[i], 10*np.log10(signalPSD[i]));\n#plt.xlim(0, 100);\nplt.xlabel('Frequency [Hz]');\nplt.ylabel('PSD [dB]')\n```\n\nSpacing is just equal to ```\nxInterp[1]-xInterp[0]```\n.\n    ", "Answer": "\r\nSo I run a functionally equivalent form of your code in an IPython notebook:\n```\n%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fftpack\n\n# Number of samplepoints\nN = 600\n# sample spacing\nT = 1.0 / 800.0\nx = np.linspace(0.0, N*T, N)\ny = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x)\nyf = scipy.fftpack.fft(y)\nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\n\nfig, ax = plt.subplots()\nax.plot(xf, 2.0/N * np.abs(yf[:N//2]))\nplt.show()\n```\n\nI get what I believe to be very reasonable output.\n\nIt's been longer than I care to admit since I was in engineering school thinking about signal processing, but spikes at 50 and 80 are exactly what I would expect. So what's the issue?\nIn response to the raw data and comments being posted\nThe problem here is that you don't have periodic data. You should always inspect the data that you feed into any algorithm to make sure that it's appropriate.\n```\nimport pandas\nimport matplotlib.pyplot as plt\n#import seaborn\n%matplotlib inline\n\n# the OP's data\nx = pandas.read_csv('http://pastebin.com/raw.php?i=ksM4FvZS', skiprows=2, header=None).values\ny = pandas.read_csv('http://pastebin.com/raw.php?i=0WhjjMkb', skiprows=2, header=None).values\nfig, ax = plt.subplots()\nax.plot(x, y)\n```\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Symmetric Fast Fourier Transform\r\n                \r\nI have vector ```\ns```\n in R with values. I just used the function ```\nfft(s)```\n to calculate the Fast Fourier Transform. Then I printed the values into\n\nwhere x is simple ```\n1,...length(fft(s))```\n. I see a strong symmetry here - why is that? I expected something like\n\nWhat am I doing wrong?\n\nHere is a MWE for the first plot:\n\n```\ndf <- structure(list(value = c(3, 1537.68157138987, 531.727745627154, \n8.50387522397935, 5.40309722205537, 2.30232661295167, 0.420000953675226, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4.73469069995451, -829.997919240523, \n-3919.09161844073, -6460.79922752307, -6507.49592868557, -4849.27485532219, \n-1674.36434175734, -83.1428571428571, -2.55813257187214, -261.182084182236, \n-2915.2762208206, -5668.7235841082, -6990.36364128962, -6997.7273121356, \n-6211.86050115633, -4378.77236521268, -1421.9056880109, -30.3635181412285, \n-3.58181865471396, -2408.88296333223, -3106.95655095245, -6482.32762645408, \n-6111.41765122797, -1821.04333977064, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 41.499896933588, 998.907991416867, 3778.2752099702, \n6543, 7005.95412518948, 6995.72726353206, 6293.82005765438, 3269.99904633924, \n592.910420911179, 2, 1378.82116693398, 4391.17937491872, 6822.45459767001, \n6220.908446583, 3447.42762806772, 581, 10.2727745627154, 873.056274992053, \n3248.72737676457, 3776.64174236464, 3779.59937375451, 2711.30950879224\n)), .Names = \"value\", row.names = c(NA, -182L), class = \"data.frame\")\nfft_res <- fft(df$value)\nggplot(data.frame(x = 1:length(fft_res), value = Mod(fft_res)), aes(x,value)) + geom_line()\n```\n\n    ", "Answer": "\r\nSymmetry is a fundamental property of an FFT applied\nto real-valued data (```\nfft()```\n returns the values for both positive and negative frequencies). For example,\n\n```\nx = 1:8\nfft(x)\n## [1] 36+0.000000i -4+9.656854i -4+4.000000i -4+1.656854i -4+0.000000i\n## [6] -4-1.656854i -4-4.000000i -4-9.656854i\n\nMod(fft(x))\n## [1] 36.000000 10.452504  5.656854  4.329569\n## [5]  4.000000  4.329569  5.656854 10.452504\n```\n\n\nHere are the corresponding frequencies\n(there's probably a simpler way ...)\n\n```\nfreqs = seq(0,1/2,by=1/8)\nfreqs = c(freqs,-rev(freqs[-c(1,5)]))\n## [1]  0.000  0.125  0.250  0.375  0.500\n## [6] -0.375 -0.250 -0.125\n```\n\n\nSo for real-valued input you only need to keep the\nfirst half of the output. There are more\nefficient FFT algorithms for real-valued\ninput, but I don't know offhand if there are any\nR packages that implement them.\n\nSymmetry no longer holds for complex-valued input:\n\n```\nset.seed(101); fft(x+rnorm(8)*1i)\n# [1] 36.000000+ 1.756632i\n# [2] -5.501913+ 8.349288i\n# [3] -2.375197+ 4.040887i\n# [4] -2.914446+ 1.690809i\n# [5] -4.000000- 1.899475i\n# [6] -5.085554- 1.622900i\n# [7] -5.624803- 3.959113i\n# [8] -2.498087-10.964420i\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "GSL Fast-Fourier Transform - Nonsense Output\r\n                \r\nThe Fourier transform of a gaussian is a gaussian, but for some reason the fast Fourier transform library from GSL (GNU scientific library) doesn't give this at all. I've included the code I've used to generate the (attempted) Fourier transform, and two relevant plots right after it. Could help me identify what I've messed up?\n\n```\n#include <gsl/gsl_fft_complex.h>\n#include <fstream>\n\n#define REAL(z,i) ((z)[2*(i)]) //complex arrays stored as    \n#define IMAG(z,i) ((z)[2*(i)+1])\n\nusing namespace std;\n\nint main(){\n\ndouble N = pow(2,9); //power of 2 for Cooley-Tukey algorithm\nint n = (int) N;\n\ndouble f[2*n];\ndouble dx = 10./N;\ndouble x = -5.;\nofstream fileo(\"out.txt\");\n\nfor (int i=0; i<n; ++i){      //initialize gaussian\n    REAL(f,i)=exp(-0.5*x*x);  \n    IMAG(f,i)=0.;\n    x+=dx;\n   }\n\n   gsl_fft_complex_radix2_forward(f, 1, n);  //Fourier transform\n\n   for (int i=0; i<n; ++i){\n        fileo<<i<<\" \"<<REAL(f,i)<<'\\n';  //plot frequency distribution\n   }\n\n   fileo.close();\n}\n```\n\n\n\n\n\n\n\n\nEDIT: Solved!\n\nAs stated in @roadrunner66's answer, the width of the original Gaussian was very broad, leading to a ridiculously narrow Gaussian in Fourier space. Moreover, my plot looked funky because, as suggested in @n.m's (now removed) comment, the Fourier transform returns the DFT with projections onto k-values indexed as k=0,1,...,N/2,-N/2,...-2,-1.\n\n\n    ", "Answer": "\r\nIt looks good to me. Shift the output vector by N/2 and plot the absolute value of the output, rather than the real part. \n\nAlso note that your input Gaussian is rather wide, which makes it's spectrum very narrow. Check the analytical solution for that case for comparison.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform algorithm implementation with MapReduce\r\n                \r\nI want to implement a Fast Fourier Transform algorithm with MapReduce. I know of a recursive-FFT algorithm but I need your guideline in order to implement it using a Map/Reduce approach. \n\nAny suggestions/references?\n    ", "Answer": "\r\nThe basic idea that we can use some theorems to divide problem into subproblems. \n\nIn case of Fourier Transfom, problem is standard definition of FT:\n\n\n\nAfter applying Cooley–Tukey FFT algorithm we can split it to two subproblems:\n\n\n\nMoving forward with that transfomation, theoretically it could be solved with parallel programming.\n\nMaybe, you'll find following links useful:\n\n\nSchönhage-Strassen Algorithm with MapReduce\nfor Multiplying Terabit Integers\nFFT with MapReduce\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for images\r\n                \r\nI have a problem that is associated with Fast Fourier Transform of an image. I've made an application with some filters for an images. It's a program with ```\nJLabel```\ns for displaying images before and after filtration and ```\nJButton```\ns for filters. So, my problem is with FFT for an image. I've seen examples for that transformation, but I really don't know how to use that in my program. I don't know how to start that.\n    ", "Answer": "\r\nIf you have obtained the 2-D FFT code and just need to apply the function, you can read the prototype of the FFT function, i.e., the data structure of the inputs and outputs, and then prepare the data to call the function.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transformation in WinForms [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI write an application on VS-2008 (WinForms, C++) \nNeed a Fast Fourier transformation Library. \nCan anybody advise a good one?\n    ", "Answer": "\r\nI strongly recommend FFTW over anything else.  It is fast, reliable, widely used, portable.  Yes, you will have to call from managed code into unmanaged code.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "implementing Fast Fourier Transform in MSP430 microcontroller\r\n                \r\nI am trying to perform image processing operations in msp430 microcontrollers.\nIs it possible to implement 2d fast fourier transform in MSP430 microcontrollers?\nAnd im looking for an fft library for msp430. Where can i find it?\n    ", "Answer": "\r\nFinally i solved it using 2 pass 1D FFT algorithm:\nCode:\nhttps://github.com/dhyandeep/skynet\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform FFT for Lua?\r\n                \r\nDoes anyone have an implementation of the Fast Fourier Transform, that works with Lua ?\n\nI want to use it on a sound sample, which I've loaded into Lua as an array of 16 bit signed ints. I wish to FFT the data and plot the freq spectrum.\n\nI need an implementation that will work with Ansca Corona's version of Lua (loadstring not supported, which is used by complex.lua)\n    ", "Answer": "\r\nYou should have a look at LuaFFT. It's MIT licensed, so it should be fairly flexible to use.\n\nEDIT : You could also take a look at NumLua. Here is its github site. It depends on BLAS/LAPACK, FFTW, and HDF5. You may be able to get this to work since it implements its own complex number data-type. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Spike centered on zero in fast Fourier transform\r\n                \r\nI have time associated data that I would like to perform a Fourier transform on. Data is located at http://pastebin.com/2i0UGJW9. The problem is that the data is not uniformly spaced. To solve this, I attempted to interpolate the data and then perform the Fast Fourier Transform.\n\n```\nimport numpy as np\nfrom scipy.fftpack import fft, fftfreq, fftshift \nfrom scipy.interpolate import interp1d \nimport matplotlib.pyplot as plt\n\nx = np.linspace(min(times), max(times), len(times))\ny = interp1d(times, data)(x)\nyf = fft(y)\nxf = fftfreq(len(times), (max(times)-min(times))/len(times))\nxf = fftshift(xf)\nyplot = fftshift(yf)\nplt.figure()\nplt.plot(xf, 1.0/len(times) * np.abs(yplot))\nplt.grid()\nplt.show()\n```\n\n\nHowever, this gives a single spike centered on zero instead of an expected frequency graph. How can I get this to give accurate results?\n    ", "Answer": "\r\nAs I don't have enough reputation to post a comment, I'll post my suggestions as an answer and hope one of them does lead to answer.\n\nInterpolation\n\nIt's probably wiser to interpolate onto a grid that is quite a bit finer than what you are doing. Otherwise your interpolation will smooth the noisy data in an unpredictable fashion. If you want to smooth the data, you'd better do this via the FFT (this might be the whole point of the exercise...) \n\nThe time data has a minimum interval of 24, you should probably use an interpolation grid of about half that. Better still, the time intervals are not constant, but they are very regular. After typing ```\nprint times % 24```\n it seems a good grid to use would be ```\nnp.arange(min(times), max(times)+1, 24)```\n. Note that the ```\n+1```\n is just to include the last time too.\n\nNon-periodic data\n\nYour data is not periodic, but the FFT treats it as if it were. This means it sees a large jump between the first and last data points. You should look at the FFT documentation on how to tell it to perform an expansion of the data.\n\nAnd of course\n\nThe spike at frequency zero is just a consequence of the fact that your signal does not have mean zero. \n\nHope this was of help.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "The Fast Fourier Transform Transform of Image Processing\r\n                \r\nI am learning FFT for processing images with Matlab. I have already know some basic stuff but for the product of the results of two FFT, I do not quite understand. \n\nSo I want to know what will happen after we multiply the results of the Fast Fourier Transform. Can someone provide me with the example?\n    ", "Answer": "\r\nMultiplication in the frequency domain is equivalent to convolution in the spatial domain.\n\nThis is typically exploited when you have a large filter kernel and an image that you want to convolve with this filter. Instead of performing the convolution directly (which can be computationally expensive for large kernels) the FFT of the image and the (padded) filter kernel is taken, the two are multiplied and an inverse FFT is applied to the product.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Applying CNN to Fast time Fourier Transform?\r\n                \r\nI have data that fast time fourier transform is applied.\n(amplitudes at specific Hzs)\nThere are solutions on internet that CNN is applied to mel spectrogram, however, I see no solution that CNN is applied to Fast Fourier Transformed signal.\nIs it possible that CNN is applied to Fast Fourier Transformed signals?\nOr is it not possible because CNN is considering temporal attribute?\nThanks!\n    ", "Answer": "\r\nI'm assuming each row of your spreadsheet is IID, e.g. it wouldn't change the problem to re-order the rows in that spreadsheet.\nIn this case you have a pretty typical ML problem. The fact that the FFT has already been applied and specific frequency responses (columns) have been extracted is a process called \"feature engineering\". Prior to the common use of neural networks, this was a standard step in all machine learning problems and remains common to a great many domains.\nWith data that has been feature engineered, you should look to traditional ML algorithms. Random Forests, XGBoost, and Linear Regression come to mind. A fully connected neural network is also appropriate, but I would typically expect it to under-perform other ML methods.\nThe hallmark of a CNN is that it operates on an ordered sequence of data. In your case the raw data, from which your dataset was derived, would be appropriate for a CNN. In a sound file you have a 1D sequence of information. You could not re-order the data in the time dimension without fundamentally changing its meaning.\nA 2D CNN operates over an image where the pixel order in X and Y cannot be changed. Again the sequential order of the data matters. The same applies for 3D CNNs.\nBe aware that the application of a FFT has fundamentally biased your solution by representing it only in a limited set of frequency responses. All feature engineering is fundamentally biasing the problem, presumably in a well thoughout-out way. However, it's entirely possible that other useful signals in the data exist, which aren't expressed by the FFT @ 10, 20, 30 Hz, etc. The CNN has the capacity to learn its own version of an FFT as well as other non cyclic patterns. Typically, the lack of a feature engineering step is the key differentiator between the CNN and traditional ML algorithms.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Frequency computation and fast fourier transform in Matlab\r\n                \r\nI have a question related to Fast Fourier transform. I want to calculate the phase and make FFT to draw power spectral density. However when I calculate the frequency ```\nf```\n, there are some errors. This is my program code:\n\n```\nn = 1:32768;\n\nT = 0.2*10^-9; % Sampling period\n\nFs = 1/T; % Sampling frequency\n\nFn = Fs/2; % Nyquist frequency\n\nomega = 2*pi*200*10^6; % Carrier frequency\n\nL = 32768; % % Length of signal\n\nt = (0:L-1)*T; % Time vector\n\nx_signal(n) = cos(omega*T*n + 0.1*randn(size(n))); % Additive phase noise (random)\n\ny_signal(n) = sin(omega*T*n + 0.1*randn(size(n))); % Additive phase noise (random)\n\ntheta(n) = atan(y_signal(n)/x_signal(n));\n\nf = (theta(n)-theta(n-1))/(2*pi)\n\nY = fft(f,t);\n\nPSD = Y.*conj(Y); % Power Spectral Density\n\n%Fv = linspace(0, 1, fix(L/2)+1)*Fn; % Frequency Vector\n```\n\n    ", "Answer": "\r\nAs posted, you would get the error \n\n\n```\nerror: subscript indices must be either positive integers less than 2^31 or logicals\n```\n\n\n\nwhich refers to the operation ```\ntheta(n-1)```\n when ```\nn=1```\n which results in an index of 0 (which is out of bounds since Matlab uses 1-based indexing). To avoid that could use a subset of indices in ```\nn```\n:\n\n```\nf = (theta(n(2:end))-theta(n(1:end-1)))/(2*pi);\n```\n\n\nThat said, if you are doing this to try to obtain an instantaneous measure of the frequency, then you will have a few more issues to deal with. The most trivial one is that you should also divide by ```\nT```\n. Not as obvious is the fact that as given, ```\ntheta```\n is a scalar due to the use of the ```\n/```\n operator (see Matlab's ```\nmrdivide```\n) rather than the ```\n./```\n operator which performs element-wise division. So a better expression would be:\n\n```\ntheta(n) = atan(y_signal(n)./x_signal(n));\n```\n\n\nNow, the next problem you might notice is that you are actually losing some phase information since the result of ```\natan```\n is ```\n[-pi/2,pi/2]```\n instead of the full ```\n[-pi,pi]```\n range. To avoid this you should instead be using ```\natan2```\n:\n\n```\ntheta(n) = atan2(y_signal(n), x_signal(n));\n```\n\n\nEven with this, you are likely to notice that the estimated frequency regularly has spikes whenever the phase jumps between near ```\n-pi```\n and near ```\npi```\n. This can be avoided by computing the phase difference modulo ```\n2*pi```\n:\n\n```\nf = mod(theta(n(2:end))-theta(n(1:end-1)),2*pi)/(2*pi*T);\n```\n\n\nA final thing to note: when calling the ```\nfft```\n, you should not be passing in a time variable (the input is implicitly assumed to be sampled at regular time intervals). You may however specify the desired length of the FFT. So, you would thus compute ```\nY```\n as follow:\n\n```\nY = fft(f, L);\n```\n\n\nAnd you could then plot the resulting ```\nPSD```\n using:\n\n```\nFv = linspace(0, 1, fix(L/2)+1)*Fn; % Frequency Vector\nplot(Fv, abs(PSD(1:L/2+1)));\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Apodization Mask for Fast Fourier Transforms in Python\r\n                \r\nI need to do a Fourier transform of a map in Python. Fast Fourier Transforms expect periodic boundary conditions, but the input map is not periodic. So I need to apply an input filter/weight slowly tapering the map toward zero at the edges. Are there libraries for doing this in python? \n    ", "Answer": "\r\nMy favorite function to apodize a map is the generalized Gaussian (also called 'Super-Gaussian' which is a Gaussian whose exponent is raised to a power P.  By setting P to, say, 4 or 6 you get a flat-top pulse which falls off smoothly, which is good for FFT applications where sharp edges always create ripples in conjugate space. \n\nThe generalized Gaussian is available on Scipy. Here is a minimal code (Python 3) to apodize a 2D array with a generalized Gaussian. As noted in previous comments, there are dozens of functions which would work just as well. \n\n```\nimport numpy as np\nfrom scipy.signal import general_gaussian\n\n# A 128x128 array\narray =  np.random.rand(128,128)\n# Define a general Gaussian in 2D as outer product of the function with itself\nwindow = np.outer(general_gaussian(128,6,50),general_gaussian(128,6,50))\n# Multiply\nap_array = window*array\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Comparative analysis of Fast Fourier Transform (FFT) algorithms on Android? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nHas anyone done a comparative analysis of Fast Fourier Transform (FFT) algorithms on Android platform? \n\nWhich implementation is the fastest so far?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fast fourier transform of csv data\r\n                \r\nI have a csv file that contains time and torque data.  https://pastebin.com/MAT2rG3U  This data set is truncated because size limit.\nI am trying to find the FFT of the data to find the frequency of a vibration.\nHere is my code (here is the example I used Fast Fourier Transform in Python ), it does not produce any results. I've researched many online resources and can not find my error\n```\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\ndata = pd.read_csv('data.csv',index_col=0)\ndata = data['Torque'].astype(float).values\nprint(data)\n\nN = data.shape[0] #number of elements\nt = np.linspace(0, 300, N) \n#t=np.arange(N)\ns = data\n\nfft = np.fft.fft(s)\nfftfreq = np.fft.fftfreq(len(s))\n\nT = t[1] - t[0]\nprint(T)\n\nf = np.linspace(0, 1 / T, N)\nplt.ylabel(\"Amplitude\")\nplt.xlabel(\"Frequency [Hz]\")\nplt.plot(fftfreq,fft)\n#plt.xlim(0,100)\n\nplt.show()\n```\n\n    ", "Answer": "\r\nWhat you've posted works for me, but your data isn't valid for an FFT because the timesteps aren't consistent.  That is, you don't have a well defined sample rate.\n```\ndata = pd.read_csv('torque_data.txt',index_col=0)\ndata = data['Torque'].astype(float).values\nprint(data)\n\nN = data.shape[0] #number of elements\nt = np.linspace(0, 300, N) \n#t=np.arange(N)\ns = data\n\nfft = np.fft.fft(s)\nfftfreq = np.fft.fftfreq(len(s))\n\nT = t[1] - t[0]\nprint(T)\n\nf = np.linspace(0, 1 / T, N)\nplt.ylabel(\"Amplitude\")\nplt.xlabel(\"Frequency [Hz]\")\nplt.plot(fftfreq, np.absolute(fft))\n#plt.xlim(0,100)\n```\n\n\nThere's probably something wrong with the data that you didn't include in the sample that's giving you the NaNs.\nStill, in the data you provided, the sample rate isn't consistent, which is required for an FFT.  To see this, plot a histogram of the time steps:\n```\n# read in the data like this to get the times\ndata = pd.read_csv('torque_data.txt')\ntime = data['Seconds'].astype(float).values\ndata = data['Torque'].astype(float).values\n\n# now look at the timesteps\nfig, axs = plt.subplots()\ntime_deltas = t[1:]-t[:-1]\nh = axs.hist(time_deltas, bins=50)\n```\n\n\nBecause so many of the timesteps have different values, I'd be worried about trusting the FFT.  (When I first looked at your data, most of the earlier points seemed to have the 0.004s timestep, so I wonder if your data collection is changing over time and not just randomly, but whatever, you need to sort this out too.)  There are solutions to this, like interpolation/resampling, or down-sampling, but one can't reliably trust the FFT results without a fix.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What is the Fast Fourier Transform? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI was asked an interview question where I needed to use it but I have no idea what it is.\nSo in plain english what is the Fast Fourier Transform and how can I use it to find the derivative of a function given its (x, y) values as input?  \n\nHow would you implement it?  \n\nEDIT:\nI am asking this because given a sequence of (x, y) values I needed to calculate how the function looks like, derive it and find the number of times it is constantly changing (that is, (0, 1), (1, 2) is counted as one) or does not change at all (0, 5), (1, 5) is also counted as one change).\n    ", "Answer": "\r\nAs for the first part of the question, a former Physics professor, Bartosz Milewski, has a very nice explanation, what FFT is and how it works.\n\nAlso, Mastering The Fourier Transform in One Day is worth reading as well.\n\nIn English (?)\n\nSay you have a sound coming from the speaker.\n\nYou then set up, let's get a nice round number here, 1024 harmonic oscillators that resonate to specific frequency ranges.\n\nPlay the sound for, say, a second.\n\nOscillators begin to resonate to the sound coming from the speaker. After the said second you read how much every oscillator is resonating. As a result you get a discrete fourier transform, meaning you get a chart of how much each of the frequency ranges contributed to the sound coming from the speaker.\n\nInstead of visualising the sound as amount of air pressure caused by the waveform, changing in time slots, you visualized it as a series of intensities of the frequency ranges.\n\nOf course in explaining the DFT, the speakers part is not really appropriate since you have to work on sampled input. So in this case the 1024 digital \"oscillators\" should actually be measured after 1/44th of a second, given the audio is sampled at the rate of 44kHz.\n\nFast Fourier Transform is an algorithm to perform a Discrete Fourier Transform that's pretty easy for computers to run on an incoming signal. It imposes some constraints you have to work with in your implementation (e.g. the number of samples has to be a power of 2), because it uses some clever tricks to drastically reduce the amount of calculation performed on the sample buffer.\n\nThere is really no need to go deeper, since the two links I gave provide a pretty clear explanation. And note that it's impossible to go from theory to implementation without knowing the math behind it.\n\nI hope this introduction makes some sense!\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for non log 2\r\n                \r\nI want to implement Fast Fourier Transform in Java for chord recognition, but I don't really get it. It says that the number of samples should be a power of 2, so what should we do for a song that doesn't have number of samples equal to a power of 2? Also I would like to know about the STFT.\n    ", "Answer": "\r\nYou normally generate an STFT over a sliding window throughout your file. The size of the window is chosen to give a reasonable time period over which the characteristics of the sound do not change greatly. Typically a window might be around 10 ms, so if your sample rate is 44.1kHz for example, then you might use a window size N = 512, so that you get the required duration and a power of 2 in size. You then take successive chunks of size N samples through the file, and generate the FFT for each N point chunk. (Note: in most cases you actually want the magnitude of the FFT output, in order to get an estimate of the power spectrum.) For increased resolution the chunks can overlap, e.g. by 50%, but this increases the processing load of course. The end result is a succession of short term spectra, so in effect you have a 3D matrix (amplitude v frequency v time) which describes the contents of the sound in the frequency domain.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to convert image in fast fourier transform signal?\r\n                \r\nI am trying to convert image into fast fourier transform signal and used the following peace of code:\n```\nfake_A1 = tf.signal.fft2d(fake_A1)\n```\n\nwhere input image type is: <class 'numpy.ndarray'> but I am getting following error:\n```\ntensorflow.python.framework.errors_impl.InvalidArgumentError: Value for attr 'Tcomplex' of float is not in the list of allowed values: complex64, complex128\n; NodeDef: {{node FFT2D}}; Op<name=FFT2D; signature=input:Tcomplex -> output:Tcomplex; attr=Tcomplex:type,default=DT_COMPLEX64,allowed=[DT_COMPLEX64, DT_COMPLEX128]> [Op:FFT2D]\n```\n\nHow may I make it solve?\n    ", "Answer": "\r\nP.S.: If you want to make edits then do it on your question, not as an answer.\nNow coming to the topic: 2D FFT of an image. Firstly an image is of shape:\n```\nimage.shape = (3,rows,columns)\n```\n\nWhere 3 stands for 3 matrices which are of 2 dimensions, corresponding to RGB. Hence to carry out 2D FFT, we first need to flatten this by converting it to grayscale. I found a useful tutorial here on ThePythonCodingBook. Ill add the code here for TL:DR purposes.\n```\nimport matplotlib.pyplot as plt\nimage_filename = \"Earth.png\"\n# Read and process image\nimage = plt.imread(image_filename)\nimage = image[:, :, :3].mean(axis=2)  # Convert to grayscale\nprint(image.shape)\nplt.set_cmap(\"gray\")\nplt.imshow(image)\nplt.axis(\"off\")\nplt.show()\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimage_filename = \"Earth.png\"\ndef calculate_2dft(input):\n    ft = np.fft.ifftshift(input)\n    ft = np.fft.fft2(ft)\n    return np.fft.fftshift(ft)\n# Read and process image\nimage = plt.imread(image_filename)\nimage = image[:, :, :3].mean(axis=2)  # Convert to grayscale\nplt.set_cmap(\"gray\")\nft = calculate_2dft(image)\nplt.subplot(121)\nplt.imshow(image)\nplt.title('Grayscale Image')\nplt.axis(\"off\")\nplt.subplot(122)\nplt.imshow(np.log(abs(ft)))\nplt.title(\"2D FFT\")\nplt.axis(\"off\")\nplt.show()\n```\n\nI'll add the grayscale and FFT plots as well.\n\nHope this helps.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Generating correlated random potential using fast Fourier transform\r\n                \r\nI would like to generate a random potential in 1D or 2D spaces with a specified autocorrelation function, and according to some mathematical derivations including the Wiener-Khinchin theorem and properties of the Fourier transforms, it turns out that this can be done using the following equation:\n\nwhere ```\nphi(k)```\n is uniformly distributed in interval [0, 1). And this function satisfies , which is to ensure that the potential generated is always real. \nThe autocorrelation function should not affect what I am doing here, and I take a simple Gaussian distribution . \n\nThe choice of the phase term and the condition of ```\nphi(k)```\n is based on the following properties\n\n\nThe phase term must have a modulus of 1 (by Wiener-Khinchin theorem, i.e. the Fourier transform of the autocorrelation of a function equals the modulus of the Fourier transform of that function);\nThe Fourier transform of a real function must satisfy  (by directly inspecting the definition of Fourier transform in integral form). \nBoth the generated potential and the autocorrelation are real.\n\n\nBy combining these three properties, this term can only take the form as stated above. \n\nFor the relevant mathematics, you may refer to p.16 of the following pdf:\nhttps://d-nb.info/1007346671/34\n\nI randomly generated a numpy array using uniform distribution and concatenated the negative of the array with the original array, such that it satisfies the condition of ```\nphi(k)```\n stated above. And then I performed the numpy (inverse) fast Fourier transform. \n\nI have tried both 1D and 2D cases, and only the 1D case is shown below. \n\n```\nimport numpy as np\nfrom numpy.fft import fft, ifft\nimport matplotlib.pyplot as plt\n\n## The Gaussian autocorrelation function \ndef c(x, V0, rho):\n    return V0**2 * np.exp(-x**2/rho**2) \n\nx_min, x_max, interval_x = -10, 10, 10000\nx = np.linspace(x_min, x_max, interval_x, endpoint=False)\n\nV0 = 1\n## the correlation length\nrho = 1 \n\n## (Uniformly) randomly generated array for k>0\nphi1 = np.random.rand(int(interval_x)/2)\nphi = np.concatenate((-1*phi1[::-1], phi1))\nphase = np.exp(2j*np.pi*phi)\n\nC = c(x, V0, rho) \nV = ifft(np.power(fft(C), 0.5)*phase)\nplt.plot(x, V.real)\nplt.plot(x, V.imag)\nplt.show()\n```\n\n\nAnd the plot is similar to what is shown as follows:\n.\n\nHowever, the generated potential turns out to be complex, and the imaginary parts are of the same order of magnitude as that of the real parts, which is not expected. I have checked the math many times, but I couldn't spot any problems. So I am thinking whether it's related to the implementation problems, for example whether the data points are dense enough for Fast Fourier Transform, etc.\n    ", "Answer": "\r\nYou have a few misunderstandings about how ```\nfft```\n (more correctly, DFT) operates. \nFirst note that DFT assumes that the samples of the sequence are indexed as ```\n0, 1, ..., N-1```\n, where ```\nN```\n are the number of samples. Instead, you generate a sequence corresponding to indices ```\n-10000, ..., 10000```\n. Second, note that the DFT of a real sequence will generate real values for the \"frequencies\" corresponding to ```\n0```\n and ```\nN/2```\n. You also seem to not take this into account. \n\nI won't go into further details as this is out of the scope of this stackexchange site. \n\nJust for a sanity check, the code below generates a sequence that has the properties expected for the DFT (FFT) of a real-valued sequence:\n\n\nconjugate symmetry of positive and negative frequencies,\nreal-valued elements corresponding to frequencies ```\n0```\n and ```\nN/2```\n\nsequence assumed to correspond to indices ```\n0```\n to ```\nN-1```\n\n\n\nAs you can see, the ```\nifft```\n of this sequence indeed generates a real-valued sequence\n\n```\nfrom scipy.fftpack import ifft\n\nN = 32 # number of samples\nn_range = np.arange(N) # indices over which the sequence is defined\nn_range_positive = np.arange(int(N/2)+1) # the \"positive frequencies\" sample indices\nn_range_negative = np.arange(int(N/2)+1, N) # the \"negative frequencies\" sample indices\n\n# generate a complex-valued sequence with the properties expected for the DFT of a real-valued sequence\nabs_FFT_positive = np.exp(-n_range_positive**2/100)\nphase_FFT_positive =  np.r_[0, np.random.uniform(0, 2*np.pi, int(N/2)-1), 0] # note last frequency has zero phase\nFFT_positive = abs_FFT_positive * np.exp(1j * phase_FFT_positive)\nFFT_negative = np.conj(np.flip(FFT_positive[1:-1]))\nFFT = np.r_[FFT_positive, FFT_negative] # this is the final FFT sequence\n\n# compute the IFFT of the above sequence\nIFFT = ifft(FFT)\n\n#plot the results\n\nplt.plot(np.abs(FFT), '-o', label = 'FFT sequence (abs. value)')\nplt.plot(np.real(IFFT), '-s', label = 'IFFT (real part)')\nplt.plot(np.imag(IFFT), '-x', label = 'IFFT (imag. part)')\nplt.legend()\n```\n\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how to apply Fast Fourier Transform using multiple .csv files\r\n                \r\nI am a beginner in python and i need help. I have a vibration data of 5 different pumps in .csv format each csv file  have 4 columns(time, ax, ay, and az) and multiple rows. Can anyone help me how to apply fast Fourier transform  and plot them and also how to plot them before applying fast fourier transform.\ni try to plot them but could get the required and clear results. Thanks\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fftpack import fft, ifft\nimport pandas as pd\nfrom pandas import DataFrame\n\n# Import csv file\ndata = pd.read_csv(\"dry pump_6h data_acceleration.csv\")\nprint(data.head()) \n# plot data\ndf.plot(linestyle = '', marker = '*', color='r')\nplt.show()\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform using NumPy: why it looks like this?\r\n                \r\nFast Fourier Transform is fast method of Discrete Fourier Transformation calculation, as far as I understood.\n\nI've been playing with NumPy math library, as so has such plot with this code:\n\n```\nimport numpy as np\nfrom numpy.fft import fft, fftfreq\nimport matplotlib.pyplot as plt\n\nt = np.arange(0, 10, step=0.001)\nsignal = np.sin(t) + np.sin(10*t)\nsp = fft(signal)\nfreq = fftfreq(signal.size, d=0.001)\nplt.plot(freq, sp)\nplt.show()\n```\n\n\nIt seems to me, that must look just like d(x-1) + d(x-10) ... // d is delta-function\n\n(Discrete Fourier Transformation must look like simple Fourier Transformation, but with sloping edges, as far as I understand)\n\nBut it doesn't. it looks like \"d(x-0.1) + d(x-1.5) ...\" and I wonder why. Problems with fftfreq?\n    ", "Answer": "\r\nIt's been many a year  since I studied this ...\n\nYou're expecting to see peaks at 1 and 10 Hz (cycles/sec)?\nThen you need to change the arguments of the sin functions.\nsin takes radians for arg. 1 Hz is 2*pi radians/sec and 10 Hz is 10*2*pi rad/sec\n\nChange your signal =np.sin(2*np.pi*t) + np.sin(10*2*np.pi*t) # optimize math as desired.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Dataflow Diagram or Pseudo Code for Fast Fourier Transform?\r\n                \r\nI have an ArrayList that has ```\nDouble```\n elements. I want to implement ```\nFFT```\n(Fast Fourier Transform) on it. However I don't want to take a Java code somewhere else and copy it. How can I find the understandable ```\ndataflow diagram or pseudo code```\n of FFT algorithm?\n\nPS: My ArrayList variable is a one-dimensional List.\n    ", "Answer": "\r\nWould diagram in this article satisfy you: http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm ?\n\nI built a Pascal program that was using this method almost 20 years ago.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Using Excel's VBA\r\n                \r\nI'm trying to implement a Fast Fourier Transform (Radix-2) in MS's Excel VBA. The code I'm using pulls data from a range in the worksheet, does the calculations, then dumps the results in the adjacent columns. What I'm having trouble with is 1) know what to do with the resulting X[k] arrays, and 2) matching these results with the results from Excel's built in FFT (they do not currently match). The code is shown below. Thanks in advance for your help. \n\n```\nSub Enforce_DecimationInTime()\n\nOn Error GoTo ERROR_HANDLING\nDim SubName As String\nSubName = \"Enforce_DecimationInTime()\"\n\nDim WS As Worksheet\nDim n As Long, v As Long, LR As Long, x As Long\n\nSet WS = Worksheets(\"FFT\")\nLR = WS.Range(\"A\" & Rows.Count).End(xlUp).Row\nn = LR - 1\nDo Until 2 ^ x <= n And 2 ^ (x + 1) > n     'locates largest power of 2 from size of input array\n    x = x + 1\nLoop\nn = n - (n - 2 ^ x) 'calculates n using the largest power of 2\nIf n + 1 <> WS.Range(\"A\" & Rows.Count).End(xlUp).Row Then\n    WS.Range(\"A\" & 2 ^ x + 2 & \":A\" & LR).Delete xlUp   'deletes extra input data\nEnd If\nv = WorksheetFunction.Log(n, 2)     'calculates number of decimations necessary\n\nApplication.ScreenUpdating = False\nFor x = 1 To v\n    Call Called_Core.DecimationInTime(WS, n, 2 ^ x, x)  'calls decimation in time subroutine\nNext x\nApplication.ScreenUpdating = True\n\nExit Sub\nERROR_HANDLING:\n    MsgBox \"Error encountered in \" & SubName & \": exiting subroutine.\" _\n    & vbNewLine _\n    & vbNewLine & \"Error description: \" & Err.Description _\n    & vbNewLine & \"Error number: \" & Err.Number, vbCritical, Title:=\"Error!\"\n    End\n\nEnd Sub\n```\n\n\nThe above subroutine calls the below subroutine through a For/Next loop to the count of \"v\".\n\n```\nSub DecimationInTime(WS As Worksheet, n As Long, Factor As Integer, x As Long)\n\nOn Error GoTo ERROR_HANDLING\nDim SubName As String\nSubName = \"DecimationInTime()\"\n\nDim f_1() As Single, f_2() As Single\nDim i As Long, m As Long, k As Long\nDim TFactor_N1 As String, TFactor_N2 As String, X_k() As String\nDim G_1() As Variant, G_2() As Variant\n\nReDim f_1(0 To n / Factor - 1) As Single\nReDim f_2(0 To n / Factor - 1) As Single\nReDim G_1(0 To n / 1 - 1) As Variant\nReDim G_2(0 To n / 1 - 1) As Variant\nReDim X_k(0 To n - 1) As String\n\nTFactor_N1 = WorksheetFunction.Complex(0, -2 * WorksheetFunction.Pi / (n / 1))  'twiddle factor for N\nTFactor_N2 = WorksheetFunction.Complex(0, -2 * WorksheetFunction.Pi / (n / 2))  'twiddle factor for N/2\n\nFor i = 0 To n / Factor - 1\n    f_1(i) = WS.Range(\"A\" & 2 * i + 2).Value    'assign input data\n    f_2(i) = WS.Range(\"A\" & 2 * i + 3).Value    'assign input data\nNext i\n\nWS.Cells(1, 1 + x).Value = \"X[\" & x & \"]\"   'labels X[k] column with k number\nFor k = 0 To n / 2 - 1\n    For m = 0 To n / Factor - 1\n        G_1(m) = WorksheetFunction.ImProduct(WorksheetFunction.ImPower(TFactor_N2, k * m), WorksheetFunction.Complex(f_1(m), 0))    'defines G_1[m]\n        G_2(m) = WorksheetFunction.ImProduct(WorksheetFunction.ImPower(TFactor_N2, k * m), WorksheetFunction.Complex(f_2(m), 0))    'defines G_2[m]\n    Next m\n    X_k(k) = WorksheetFunction.ImSum(WorksheetFunction.ImSum(G_1), WorksheetFunction.ImProduct(WorksheetFunction.ImSum(G_2), WorksheetFunction.ImPower(TFactor_N1, k)))  'defines X[k] for k\n    If k <= n / 2 Then X_k(k + n / 2) = WorksheetFunction.ImSum(WorksheetFunction.ImSum(G_1), WorksheetFunction.ImProduct(WorksheetFunction.ImSum(G_2), WorksheetFunction.ImPower(TFactor_N1, k), WorksheetFunction.Complex(-1, 0)))  'defines X[k] for k + n/2\n    WS.Cells(k + 2, 1 + x).Value = X_k(k)\n    WS.Cells(k + 2 + n / 2, 1 + x).Value = X_k(k + n / 2)\nNext k\n\nExit Sub\nERROR_HANDLING:\n    MsgBox \"Error encountered in \" & SubName & \": exiting subroutine.\" _\n    & vbNewLine _\n    & vbNewLine & \"Error description: \" & Err.Description _\n    & vbNewLine & \"Error number: \" & Err.Number, vbCritical, Title:=\"Error!\"\n    End\n\nEnd Sub\n```\n\n    ", "Answer": "\r\nI went back through the process and determined my problem was that I had assigned the wrong values to the twiddle factors, TFactor_N1 and TFactor_N2. After fixing this problem and adjusting which values are displayed, I was able to get the same results as Excel's built in FFT. The fixed code is show below.\n\n```\nSub Enforce_DecimationInTime()\n\nOn Error GoTo ERROR_HANDLING\nDim SubName As String\nSubName = \"Enforce_DecimationInTime()\"\n\nDim WS As Worksheet\nDim n As Long, v As Long, LR As Long, x As Long\nDim TFactor_N1 As String, TFactor_N2 As String\n\nSet WS = Worksheets(\"FFT\")\nLR = WS.Range(\"A\" & Rows.Count).End(xlUp).Row\nn = LR - 1\nDo Until 2 ^ x <= n And 2 ^ (x + 1) > n                                                                     'locates largest power of 2 from size of input array\n    x = x + 1\nLoop\nn = n - (n - 2 ^ x)                                                                                         'calculates n using the largest power of 2\nIf n + 1 <> WS.Range(\"A\" & Rows.Count).End(xlUp).Row Then\n    WS.Range(\"A\" & 2 ^ x + 2 & \":A\" & LR).Delete xlUp                                                       'deletes extra input data\nEnd If\nv = WorksheetFunction.Log(n, 2)                                                                             'calculates number of decimations necessary\n\nTFactor_N1 = WorksheetFunction.ImExp(WorksheetFunction.Complex(0, -2 * WorksheetFunction.Pi / (n / 1)))     'twiddle factor for N\nTFactor_N2 = WorksheetFunction.ImExp(WorksheetFunction.Complex(0, -2 * WorksheetFunction.Pi / (n / 2)))     'twiddle factor for N/2\n\nApplication.ScreenUpdating = False\nFor x = 1 To v\n    Call Called_Core.DecimationInTime(WS, n, 2 ^ x, x, TFactor_N1, TFactor_N2)                              'calls decimation in time subroutine\nNext x\nApplication.ScreenUpdating = True\n\nExit Sub\nERROR_HANDLING:\n    MsgBox \"Error encountered in \" & SubName & \": exiting subroutine.\" _\n    & vbNewLine _\n    & vbNewLine & \"Error description: \" & Err.Description _\n    & vbNewLine & \"Error number: \" & Err.Number, vbCritical, Title:=\"Error!\"\n    End\n\nEnd Sub\n\n\nSub DecimationInTime(WS As Worksheet, n As Long, Factor As Integer, x As Long, TFactor_N1 As String, TFactor_N2 As String)\n\nOn Error GoTo ERROR_HANDLING\nDim SubName As String\nSubName = \"DecimationInTime()\"\n\nDim f_1() As String, f_2() As String\nDim i As Long, m As Long, k As Long\nDim X_k() As String\nDim G_1() As Variant, G_2() As Variant\n\nReDim f_1(0 To n / Factor - 1) As String\nReDim f_2(0 To n / Factor - 1) As String\nReDim G_1(0 To n / 1 - 1) As Variant\nReDim G_2(0 To n / 1 - 1) As Variant\nReDim X_k(0 To n - 1) As String\n\nFor i = 0 To n / Factor - 1\n    f_1(i) = WS.Cells(2 * i + 2, 1).Value                                                                   'assign input data\n    f_2(i) = WS.Cells(2 * i + 3, 1).Value                                                                   'assign input data\nNext i\nFor k = 0 To n / 2 - 1\n    For m = 0 To n / Factor - 1                                                                             'defines G_1[m] and G_2[m]\n        G_1(m) = WorksheetFunction.ImProduct(WorksheetFunction.ImPower(TFactor_N2, k * m), f_1(m))\n        G_2(m) = WorksheetFunction.ImProduct(WorksheetFunction.ImPower(TFactor_N2, k * m), f_2(m))\n    Next m                                                                                                  'defines X[k] for k and k + n/2\n    X_k(k) = WorksheetFunction.ImSum(WorksheetFunction.ImSum(G_1), WorksheetFunction.ImProduct(WorksheetFunction.ImSum(G_2), WorksheetFunction.ImPower(TFactor_N1, k)))\n    If k <= n / 2 Then X_k(k + n / 2) = WorksheetFunction.ImSub(WorksheetFunction.ImSum(G_1), WorksheetFunction.ImProduct(WorksheetFunction.ImSum(G_2), WorksheetFunction.ImPower(TFactor_N1, k)))\n    If x = 1 Then\n        WS.Cells(k + 2, 1 + x).Value = X_k(k)\n        WS.Cells(k + 2 + n / 2, 1 + x).Value = X_k(k + n / 2)\n    End If\nNext k\n\nExit Sub\nERROR_HANDLING:\n    MsgBox \"Error encountered in \" & SubName & \": exiting subroutine.\" _\n    & vbNewLine _\n    & vbNewLine & \"Error description: \" & Err.Description _\n    & vbNewLine & \"Error number: \" & Err.Number, vbCritical, Title:=\"Error!\"\n    End\n\nEnd Sub\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Denoising Python\r\n                \r\nI want to denoise my Swat dataset. In this dataset actuator_columns have 0-1 values. Sensors columns have numeric values. I used OneHotEncoding for actuators, and Standardscaler for sensors. 72 columns\nThen I tried to implement Fast Fourier Transform for denoising.\nMy code is:\n```\nsignals=df.to_numpy() \ndef filter_signal(signal, threshold=1e8):\nfourier = rfft(signal)\nfrequencies = rfftfreq(signal.size, d=20e-3/signal.size)\nfourier[frequencies > threshold] = 0\nreturn irfft(fourier)\nfiltered = filter_signal(signals[0, 0 :], threshold=1e3)\nplt.figure(figsize=(15, 10))\nplt.xlabel('Frequencies')\nplt.ylabel('Amplitude')\nplt.plot(signals[0, 0 :], label='Raw')\nplt.plot(filtered, label='Filtered')\nplt.legend()\nplt.title(\"FFT Denoising with threshold = 1e3\", size=15)\nplt.show()\n```\n\nAfter this code I have denoısed filtered array with 72 size.\nAfter denoising part I want to implement IsolatonForest for anomaly detection.\nSo I need dataframe for using in IsolatıonForest model. I tried\n```\npd.DataFrame(filtered)\n```\n\nbut had 1 column with 72 rows. So I cant use this for my model.\nHow can I get dataframe after denoising part? How can I solve this problem?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Matlab Fast Fourier Transform / fft for time and speed\r\n                \r\nI have a 2 column vector with times and speeds of a subset of data, like so:\n\n```\n5 40\n10 37\n15 34\n20 39\n```\n\n\nAnd so on. I want to get the fourier transform of speeds to get a frequency. How would I go about doing this with a fast fourier transform (fft)?\n\nIf my vector name is sampleData, I have tried\n\n```\nfft(sampleData);\n```\n\n\nbut that gives me a vector of real and imaginary numbers. To be able to get sensible data to plot, how would I go about doing this?\n    ", "Answer": "\r\nFourier Transform will yield a complex vector, when you fft you get a vector of frequencies, each has a spectral phase. These phases can be extremely important! (they contain most of the information of the time-domain signal, you won't see interference effects without them etc...).  If you want to plot the power spectrum, you can\n\n```\nplot(abs(fft(sampleData)));\n```\n\n\nTo complete the story, you'll probably need to fftshift, and also produce a frequency vector. Here's a more elaborate code:\n\n```\n% Assuming 'time' is the 1st col, and 'sampleData' is the 2nd col: \nN=length(sampleData);  \nf=window(@hamming,N)';\ndt=mean(diff(time)); \ndf=1/(N*dt); % the frequency resolution (df=1/max_T)\nif mod(N,2)==0\n    f_vec= df*((1:N)-1-N/2); % frequency vector for EVEN length vector\n    else\n    f_vec= df*((1:N)-0.5-N/2); \nend\n\nfft_data= fftshift(fft(fftshift(sampleData.*f))) ;\n\nplot(f_vec,abs(fft_data))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to compute fast fourier transform aka fft using Ffmpeg\r\n                \r\nHow can i compute fast Fourier transform of an audio signal using Ffmpeg. I know there is a library in Ffmpeg for doing that but no sure how.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How do you do a Fast Fourier Transform in maxima (the computer algebra system)?\r\n                \r\nI get the basic idea of a continuous Fourier transform and I am a little fuzzy with a discrete Fourier transform and hazier still on the fast Fourier transform. I want to know how to compute and interpret the fast Fourier transform (FFT) of some function in maxima. For example, how would I compute the FFT of sin(x)? I know how to do this in MATLAB, but I am not sure how to do it in maxima.\n    ", "Answer": "\r\nWell, there is a built-in fast Fourier transform function: see 'fft'.\n\n'fft' is only for numerical data. Maybe you want a function which works for symbolic data as well. It is easy to write an ordinary (not fast) discrete Fourier transform as a summation, something like: ```\n(1/n) sum(y[k]*exp(2*%pi*%i*j*k/n)```\n for the ```\nj```\n-th element. (Formula may be wrong, I am working from memory.)\n\nIf you want a fast Fourier transform for symbolic data, you will need to work from a published algorithm. (There are many books which have FFT algorithms in them.) Just write the algorithm in Maxima and operations will automatically be symbolic.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How can I convert Arduino signal from Python to Fast Fourier transform?\r\n                \r\nI'm now trying to convert the signal into a Fast Fourier transform in Python and draw a graph. I have a problem with Len here. How can I fix this? And does anyone have any other ideas about converting  Fast Fourier transform?\n\nException has occurred: TypeError\n\nobject of type 'method' has no len()\n\nThat is my problem.\n\n```\nfrom PyQt5.QtWidgets import*\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\nfrom matplotlib.figure import Figure\nimport matplotlib.pyplot as plt\nimport random\nfrom PyQt5 import QtCore, QtGui, QtWidgets\nimport datetime\nimport serial\nimport time\nimport random\nimport numpy as np\nfrom matplotlib import animation\nfrom collections import deque\nimport threading\n\n\nx = 0\nvalue = [0]\n\nser = serial.Serial('com5', 9600)\n\nclass scope : \n\n    def data(self) :\n        if ser.readable() :\n            time.sleep(0.01)\n            reciving = ser.readline(ser.inWaiting())           \n            str = reciving.decode()\n            if len(str) > 0  :         \n                if str[:1] == 'X' :\n                    value[0] = str[1:]\n                    #print(float(value[5]))\n                    time.sleep(0.5)\n                    x = float(value[0])\n        return x\n\ns = scope()\n\nn = len(s.data)\n\nTs = 0.01\nFs = 1/Ts                     \n                    # length of the signal\nk = np.arange(n)\nT = n/Fs\nfreq = k/T                  # two sides frequency range\nfreq = freq[range(int(n/2))]            # one side frequency range\n\nY = np.fft.fft(x)/n                 # fft computing and normalization\nY = Y[range(int(n/2))]\n\nfig, ax = plt.subplots(2, 1)\n\nax.plot(freq, abs(Y), 'r', linestyle=' ', marker='^') \nax.set_xlabel('Freq (Hz)')\nax.set_ylabel('|Y(freq)|')\n#3ax.vlines(freq, [0], abs(Y))\nax.grid(True)\n\nt = threading.Thread(target= s.data)\nt.daemon = True\nt.start()\n\nplt.show()\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Blur a matrix using Fast Fourier Transforms\r\n                \r\nI want to blur values in matrix, so that in neighboring elements we'll not have sharp transitions.\n\nFrom the Wikipedia page Gaussian Blur I've found some info on Gaussian blurring. I've tried it with the most simple algorithm, and, hence the run-time was too long. Frankly, I'm not sure if my implementation is correct, as on boundary tiles sharp transition still exists.\n\nI've noticed that this blurring could be done with discrete Fourier transforms which is much faster, but I couldn't figure it out.\n\nSo, the idea is that we can get blurred matrix with the formulas below:\n\n```\nblurredMatrix = IFFT[FFT[initialMatrix]FFT[weightingFunction]]\n```\n\n\nWhere FFT/IFFT are Fast Fourier Transform/Inverse Fast Fourier Transform.\n\nCurrently I'm trying to do some testing on Wolfram Mathematica to make sure that this kind of approximation with Fourier transforms is correct.\n\nI'm using ```\nGaussianMatrix```\n as weightingFunction.\n\nI need 2d blurring, so I've created Gaussian matrix as below:\n\nSuppose our initial matrix has nxn sizes, where n = 2k+1\n\n```\nG = Chop[GaussianMatrix[k] GaussianMatrix[k], 10^6]\n```\n\n\nAnd, then, I've tried to create blurredMatrix as below:\n\n```\nblurredMatrix = Chop[FourierDCT[(FourierDCT[G]) (FourierDCT[initialMatrix]), 3], 10^-6]\n```\n\n\nBut I'm getting zeros as a result.\n\nSeems I'm doing it all wrong.\n\nAlso, I've tried another approach:\n\n```\nf[xi_, yj_] := 1/(2 \\[Pi] \\[Sigma]^2) Exp[-(((xi^2) + (yj^2) )/(2 \\[Sigma]^2))];<br/>\n[Sigma] = 3;<br/>\nG = Chop[N[Table[f[i, j], {i, 1, 100}, {j, 1, 100}]]]; <br/>\nTavg = Chop[ 1000 InverseFourier[(Fourier[G]) (Fourier[T]) ], 10^-6]; <br/>\n```\n\n\nWith this approach the picture looks fine (the image is blurred), but there is big difference between between values of blurredMatrix and initialMatrix.\n\nSeems there are some normalization or other problems.\n\nI need to write the code in C/C++, there is a library FFTW library in C which supports discrete Fourier transforms.\n\nPlease let me know if this is a wrong way of blurring and there are other possibilities to do what I want.\n    ", "Answer": "\r\nUsing FFT to do convolutions is only efficient when you have very large convolution kernels. In most blurring applications the kernel is much much smaller than the image, e.g. 3x3, so FFT would be significantly slower. \n\nThere are many implementations for doing small-kernel convolutions.\nMost modern hardware supports such intrinsic operations (MMX, SSE, GPUs...).\nFFT is probably not the way to go in your case.\n\nIn C++, OpenCV supports both cross-platform and hardware accelerated image convolutions. Convolutions really are one of (if not) the most foundational operation of any image and signal processing package. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to output a spectrum Fast Fourier Transform on C++\r\n                \r\nI'm using this code to compute the Discrete Fourier Transform (DFT) efficiently using the Fast Fourier Transform (FFT) algorithm, I'm new to this topic and I don't really understand what do I need to do after getting the output from the fft which are basically 8 points that are describing each wave.\nMy end goal is to show a spectrum according to the sample points I wrote\nAgain, I'm no expert and I can really use example or articles because all that data I found online doesn't tell me what do I do with these points to compute the spectrum.\nFFT code:\n```\n#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iterator>\n\nusing namespace std;\n\nunsigned int bitReverse(unsigned int x, int log2n) {\n    int n = 0;\n    int mask = 0x1;\n    for (int i = 0; i < log2n; i++) {\n        n <<= 1;\n        n |= (x & 1);\n        x >>= 1;\n    }\n    return n;\n}\n\nconst double PI = 3.1415926536;\n\ntemplate<class Iter_T>\nvoid fft(Iter_T a, Iter_T b, int log2n)\n{\n    typedef typename iterator_traits<Iter_T>::value_type complex;\n    const complex J(0, 1);\n    int n = 1 << log2n;\n    for (unsigned int i = 0; i < n; ++i) {\n        b[bitReverse(i, log2n)] = a[i];\n    }\n    for (int s = 1; s <= log2n; ++s) {\n        int m = 1 << s;\n        int m2 = m >> 1;\n        complex w(1, 0);\n        complex wm = exp(-J * (PI / m2));\n        for (int j = 0; j < m2; ++j) {\n            for (int k = j; k < n; k += m) {\n                complex t = w * b[k + m2];\n                complex u = b[k];\n                b[k] = u + t;\n                b[k + m2] = u - t;\n            }\n            w *= wm;\n        }\n    }\n}\n\nint main() {\n    typedef complex<double> cx;\n    cx a[] = { cx(1,0), cx(3,0), cx(5,0), cx(7,0),\n      cx(9, 0), cx(11, 0), cx(13,0), cx(15,0) };\n    cx b[8];\n    fft(a, b, 3);\n    for (int i = 0; i < 8; ++i)\n        cout << b[i] << \"\\n\";\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What is the recommended Python module for fast Fourier transforms (FFT)?\r\n                \r\nTaking speed as an issue it may be better to choose another language, but what is your library/module/implementation of choice for doing a 1D fast Fourier transform (FFT) in Python?\n    ", "Answer": "\r\nI would recommend numpy library, I not sure if it's the fastest implementation that exist but but surely it's one of best scientific module on the \"market\". \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform using a Vandermonde Matrix - Evaluation of Co-efficients?\r\n                \r\nSay i'm trying to evaluate the Polynomial:\n\n```\nx^2 + 1\n```\n\n\nUsing the Fast Fourier transform method for evaluating co-efficients. Now i can change this into matrix/vector form using the co-effcient as inputs for the fast fourier transform:\n\nso:\n\n```\nx^2 + 1 = <1, 0, 1, 0>\n```\n\n\nThis is done by using the coefficient value e.g 1 = 1, 0x^1 = 0, X^2 = 1 and so on\n\nNow we get to the bit where i'm totally confused. I'm meant to use the vandermonde matrix :Vandermonde matrix ~ Wiki to evaluate these values into FFT Form using the matrix:\n\n```\n1 1 1 1  \n1 i-1-i\n1-1 1-i\n1-i 1 i\n```\n\n\nThe output of\n\n```\nfft(1,0,1,0)\n```\n\n\nis\n\n```\n(2,0,2,0)\n```\n\n\nNow thats the step i don't quite understand, how did we use that matrix to get (2,0,2,0)?\n    ", "Answer": "\r\nFirst, your Vandermonde matrix is incorrect.  The (4,3) entry should be -1, not 1, since the fourth row should be (-i)0, (-i)1, (-i)2, (-i)3.  Note in particular that \n\n(-i)*(-i) = (-1)2 * i2 = i2 = -1.\n\nWith this correction, the result follows from multiplying the Vandermonde matrix by the column vector (1,0,1,0).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform of 1D and 3D arrays\r\n                \r\nI'm doing N-body calculations using pyopencl and I need to have my data to be 1D array as input and as output of some kernel. So if I have 2D problem, I do something like this: 1D_arr=numpy.reshape(3D_arr,(LxLy)), where LxLy number of all particles.\nHow to perform a fast fourier transform(fft) of 1D array(If it is possible!), which corresponds to fft of 3D array (and ifft after)? These 2 arrays are connected by reshape transformation in real space.\n\n```\nimport numpy as np\nfrom scipy.fftpack import fftn, fft\n\n\nLx = 10 \nLy = 9\nLz = 1\nL = Lx * Ly * Lz\nLspec = (2 * Lx - 1) * (2 * Ly - 1) * (2 * Lz - 1)\n\nM1 = np.zeros(L).astype(np.float32)\nfor i in range(L):\n    M1[i] = np.random.random()\nM3 = np.zeros((Lx, Ly, Lz))\nfor z in range(Lz):\n    for y in range(Ly):\n        for x in range(Lx):\n            i = x + Lx * y\n            M3[x, y, z] = i\n            M1[i] = i\n            print(M3[x,y,z], M1[i])\n\n\nprint(\"________________________\")\n\n\nFM3 = fftn(M3)\nFM1 = fftn(M1)\n\nfor z in range(Lz):\n    for y in range(Ly):\n        for x in range(Lx):\n            i = x + Lx * y\n            i2 = y + Ly * x\n            print(FM3[x,y,z], FM1[i2])\n```\n\n\nI expect to see all ellements of FM1 and FM3 equal, but I don't know how to manage it.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How exactly do you compute the Fast Fourier Transform?\r\n                \r\nI've been reading a lot about Fast Fourier Transform and am trying to understand the low-level aspect of it. Unfortunately, Google and Wikipedia are not helping much at all.. and I have like 5 different algorithm books open that aren't helping much either. \n\nI'm trying to find the FFT of something simple like a vector [1,0,0,0]. Sure I could just plug it into Matlab but that won't help me understand what's going on underneath. Also, when I say I want to find the FFT of a vector, is that the same as saying I want to find the DFT of a vector just with a more efficient algorithm? \n    ", "Answer": "\r\nYou're right, \"the\" Fast Fourier transform is just a name for any algorithm that computes the discrete Fourier transform in O(n log n) time, and there are several such algorithms.\n\nHere's the simplest explanation of the DFT and FFT as I think of them, and also examples for small N, which may help. (Note that there are alternative interpretations, and other algorithms.)\n\nDiscrete Fourier transform\n\nGiven ```\nN```\n numbers f0, f1, f2, …, fN-1, the DFT gives a different set of ```\nN```\n numbers. \n\nSpecifically: Let ω be a primitive Nth root of 1 (either in the complex numbers or in some finite field), which means that ωN=1 but no smaller power is 1. You can think of the fk's as the coefficients of a polynomial P(x) = ∑fkxk. The N new numbers F0, F1, …, FN-1 that the DFT gives are the results of evaluating the polynomial at powers of ω. That is, for each n from 0 to N-1, the new number Fn is P(ωn) = ∑0≤k≤N-1 fkωnk.\n\n\n\n[The reason for choosing ω is that the inverse DFT has a nice form, very similar to the DFT itself.]\n\nNote that finding these F's naively takes O(N2) operations. But we can exploit the special structure that comes from the ω's we chose, and that allows us to do it in O(N log N). Any such algorithm is called the fast Fourier transform.\n\nFast Fourier Transform\n\nSo here's one way of doing the FFT. I'll replace N with 2N to simplify notation. We have f0, f1, f2, …, f2N-1, and we want to compute P(ω0), P(ω1), … P(ω2N-1) where we can write \n\n\n  P(x) = Q(x) + ωNR(x) with   \n  \n  Q(x) = f0 + f1x + … + fN-1xN-1  \n  \n  R(x) = fN + fN+1x + … + f2N-1x2N-1\n\n\nNow here's the beauty of the thing. Observe that the value at ωk+N is very simply related to the value at ωk:\nP(ωk+N) = ωN(Q(ωk) + ωNR(ωk)) = R(ωk) + ωNQ(ωk). So the evaluations of Q and R at ω0 to ωN-1 are enough.\n\nThis means that your original problem — of evaluating the 2N-term polynomial P at 2N points ω0 to ω2N-1 — has been reduced to the two problems of evaluating the N-term polynomials Q and R at the N points ω0 to ωN-1. So the running time T(2N) = 2T(N) + O(N) and all that, which gives T(N) = O(N log N).\n\nExamples of DFT\n\nNote that other definitions put factors of 1/N or 1/√N.\n\nFor N=2, ω=-1, and the Fourier transform of (a,b) is (a+b, a-b).\n\nFor N=3, ω is the complex cube root of 1, and the Fourier transform of (a,b,c) is (a+b+c, a+bω+cω2, a+bω2+cω). (Since ω4=ω.)\n\nFor N=4 and ω=i, and the Fourier transform of (a,b,c,d) is (a+b+c+d, a+bi-c-di, a-b+c-d, a-bi-c+di). In particular, the example in your question: the DFT on (1,0,0,0) gives (1,1,1,1), not very illuminating perhaps.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier coefficients for NFFT - non uniform fast Fourier transform?\r\n                \r\nI am trying to use the package pynfft in python 2.7 to do the non-uniform fast Fourier transform (nfft). I have learnt python for only two months, so I have some difficulties.\n\nThis is my code:\n\n```\nimport numpy as np\nfrom pynfft.nfft import NFFT\n\n#loading data, 104 lines\nt_diff, x_diff = np.loadtxt('data/analysis/amplitudes.dat', unpack = True)\n\nN = [13,8]\nM = 52\n\n#fourier coefficients\nf_hat = np.fft.fft(x_diff)/(2*M)\n\n#instantiation\nplan = NFFT(N,M)\n\n#precomputation\nx = t_diff\nplan.x = x\nplan.precompute()\n\n# vector of non uniform samples\nf = x_diff[0:M]\n\n#execution\nplan.f = f\nplan.f_hat = f_hat\nf = plan.trafo()\n```\n\n\nI am basically following the instructions I found in the pynfft tutorial (http://pythonhosted.org/pyNFFT/tutorial.html).\n\nI need the nfft because the time intervals in which my data are taken are not constant (I mean, the first measure is taken at t, the second after dt, the third after dt+dt' with dt' different from dt and so on).\n\nThe pynfft package wants the vector of the fourier coefficients (\"f_hat\") before execution, so I calculated it using numpy.fft, but I am not sure this procedure is correct. Is there another way to do it (maybe with the nfft)?\n\nI would like also to calculate the frquencies; I know that with numpy.fft there is a command: is ther anything like that also for pynfft? I did not find anything in the tutorial.\n\nThank you for any advice you can give me.\n    ", "Answer": "\r\nHere is a working example, taken from here:\n\nFirst we define the function we want to reconstruct, which is the sum of four harmonics:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(12345)\n\n%pylab inline --no-import-all\n\n# function we want to reconstruct\nk=[1,5,10,30] # modulating coefficients\ndef myf(x,k): \n    return sum(np.sin(x*k0*(2*np.pi)) for k0 in k)\n\nx=np.linspace(-0.5,0.5,1000)   # 'continuous' time/spatial domain; -0.5<x<+0.5\ny=myf(x,k)                     # 'true' underlying trigonometric function\n\nfig=plt.figure(1,(20,5))\nax =fig.add_subplot(111)\n\nax.plot(x,y,'red')\nax.plot(x,y,'r.')\n\n                        # we should sample at a rate of >2*~max(k)\nM=256                   # number of nodes\nN=128                   # number of Fourier coefficients\n\nnodes =np.random.rand(M)-0.5 # non-uniform oversampling\nvalues=myf(nodes,k)     # nodes&values will be used below to reconstruct \n                        # original function using the Solver\n\nax.plot(nodes,values,'bo')\n\nax.set_xlim(-0.5,+0.5)\n```\n\n\nThe we initialize and run the Solver:\n\n```\nfrom pynfft import NFFT, Solver\n\nf     = np.empty(M,     dtype=np.complex128)\nf_hat = np.empty([N,N], dtype=np.complex128)\n\nthis_nfft = NFFT(N=[N,N], M=M)\nthis_nfft.x = np.array([[node_i,0.] for node_i in nodes])\nthis_nfft.precompute()\n\nthis_nfft.f = f\nret2=this_nfft.adjoint()\n\nprint this_nfft.M  # number of nodes, complex typed\nprint this_nfft.N  # number of Fourier coefficients, complex typed\n#print this_nfft.x # nodes in [-0.5, 0.5), float typed\n\n\nthis_solver = Solver(this_nfft)\nthis_solver.y = values          # '''right hand side, samples.'''\n\n#this_solver.f_hat_iter = f_hat # assign arbitrary initial solution guess, default is 0\n\nthis_solver.before_loop()       # initialize solver internals\n\nwhile not np.all(this_solver.r_iter < 1e-2):\nthis_solver.loop_one_step()\n```\n\n\nFinally, we display the frequencies:\n\n```\nimport matplotlib.pyplot as plt\n\nfig=plt.figure(1,(20,5))\nax =fig.add_subplot(111)\n\n\nfoo=[ np.abs( this_solver.f_hat_iter[i][0])**2 for i in range(len(this_solver.f_hat_iter) ) ]\n\nax.plot(np.abs(np.arange(-N/2,+N/2,1)),foo)\n```\n\n\ncheers\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier function for image transformation Problems\r\n                \r\nI have coded the following function to apply fast fourier transform on input image. I have got null pointer exception in line \"F[2*k]= F[2*k].plus(w_ux.mul(f_even));\".\n\n\nWould anyone give any advice to me, please? [solved]\nIt takes quite a long time to finish running the transform, the time is similar to normal fourier transform. and the result image is not as expected. \n\n\n```\nprivate Complex[] fft(byte[] img, int width, int height) {\n    // M - height  N - width , u - height v - width\n    Complex[] F = new Complex[width*height];  // one single point\n    Complex w;\n    int size = F.length;\n    double w_ux_exp, w_u_exp;\n    double f_even, f_odd;\n    for (int u=0; u<size/2;u++){\n        for (int k=0; k<size/2; k++){\n            f_even = (double)(img[2*k]&0xFF)*Math.pow(-1, k);  // f(x) for even, centering\n            f_odd = (double)(img[2*k+1]&0xFF)*Math.pow(-1, k);  // f(x) for odd, centering\n            w_u_exp =-2.0 * Math.PI*2*(img[u]&0xFF) / size;\n            w_ux_exp =-2.0 * Math.PI*(2*k)*(img[u]&0xFF) / size;  //even\n            Complex w_ux = Complex.fromPolar(1, w_ux_exp);\n            Complex w_u = Complex.fromPolar(1, w_u_exp);\n            F[2*u]= F[2*u].plus(w_ux.mul(f_even)); \n            F[2*u+1]=F[2*u+1].plus(w_u.mul(f_odd));\n        }\n    }\n\n    return F;\n} \n```\n\n\nThank you very much for your help.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for Harmonic Analysis\r\n                \r\nI'm analyzing the harmonics present in the wave motion as a function of where along the string the pluck occurs.  I hope to obtain a plot like those exhibited on this page: https://softwaredevelopmentperestroika.wordpress.com/2013/12/10/fast-fourier-transforms-with-python-the-noise-and-the-signal/.  To do this, I've written code modelling an asymmetric triangle and implemented numpy's fft.  The data being output, however, is not what I expect, and it's peaked about a frequency of 0 Hz.  Here is my code and its output:\n\n```\nfrom numpy.fft import fft as npfft, fftfreq as npfftfreq\n#triangular pulse\ndef triangular_pulse(x, xmean, sigma):\n    for i in x:\n        if x[i]<=xmean:\n            y[i] = x[i]*(sigma/xmean)\n        else :\n            y[i] = sigma-(x[i]-xmean)*(sigma/(200-xmean))\n    return y\n\nN_masses = 200\nT  = 0.0669264714\nmu = .03937\ncSq = T/mu\nc  = np.sqrt(cSq)\ndx = 1.0\n\ndt = dx/c\nprint dt\n\n#Initialize some arrays\nx0  = np.arange(N_masses)*dx\ny   = np.zeros(N_masses)\nvy  = np.zeros(N_masses)\nay  = np.zeros(N_masses)\n\n#Set Initial conditions (pluck)\n# # half-pluck\n# y = 30*gaussian_pulse(x0,x0[N_masses/2],2)\n\n# quarter-pluck\ny = triangular_pulse(x0,x0[N_masses/4],1)\n\nrhat=npfft(y)\nfreaq=npfftfreq(len(y),dt)\nplt.plot(freaq,np.abs(rhat)/len(rhat))\nplt.show()\n```\n\n\nPlease let me know if you spot the source of my problem.  Thanks!\n\nUpdate\n\nAdded\n    y = triangular_pulse(x0,x0[N_masses/40],1)\n    y-=np.mean(y)\nwith the result of a broader non-zero band; peak is still centered around \"0\", however.\n    ", "Answer": "\r\nJust subtract the mean of the signal before running the frequency analysis, i.e. after calling ```\ntriangular_pulse```\n:\n\n```\ny-=y.mean()\n```\n\n\nand you will obtain the peak at a non-zero frequency. This is because the signal has a mean component that is not zero, that will show up as the component at zero frequency.\n\nEDIT: as a comment, you can rewrite the triangular pulse function using numpy where:\n\n```\ndef triangular_pulse2(x,xmean,sigma):\n    return where(x<xmean,x*sigma/xmean,sigma-(x-xmean)*(sigma/(200-xmean)))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Is Fast Fourier transform algorithm appropriate for image gradient computation?\r\n                \r\nI've a matrix of size ```\nmXn```\n and a filter ```\n[-1 0 1]```\n on which I need to perform convolution. I'm able to do this in O(n^2) steps, but on further googling fast fourier transform keeps on popping up everywhere. I would like to know if FFT is appropriate for this problem. The matrix has random integers only. But if I were to have floating values, will it make a difference? Is FFT meant for a problem like this?\n    ", "Answer": "\r\nIf your filter has only two nonzero elements, computing the convolution by definition will only take ```\nO(n*m)```\n steps (which is the size of your data). FFT isn't gonna help you in that case: a 2D FFT would take something like ```\nO(n*m*(log n+log m))```\n.\n\nTo sum up: when you have a simple, localized filter, the best way to perform convolution is computing the sum directly. When you need to compute convolutions or correlations with bigger data (think correlation with another image) or perform complex operations, FFT can help you.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "scale and rotation Template matching\r\n                \r\nI'm using the method of match template with ```\nCV_TM_CCORR_NORMED```\n to compare two images ... I want to make to make this rotation and scale invariant .. any ideas?\n\nI tried to use the same method on the fourier transform of the image and the template , but still the result after rotation is different\n    ", "Answer": "\r\nTemplate matching with ```\nmatchTemplate```\n is not good when your object is rotated or scaled in scene.\n\nYou should try openCV function from ```\nFeatures2D```\n Framework. For example ```\nSIFT```\n or ```\nSURF```\n descriptors, and ```\nFLANN```\n matcher. Also, you will need ```\nfindHomography```\n method.\n\nHere is a good example of finding rotated object in scene.\n\nUpdate:\n\nIn short, algorithm is this:\n\n\nFinding keypoints of your object image\n1.1. Extracting descriptors from those keypoints\nFinding keypoints of your scene image\n2.1 Extracting descriptors from keypoints\nMatch descriptors by matcher\nAnalyze your matches\n\n\nThere are different classes of FeatureDetectors, DescriptorExtractors, and DescriptorMatches, you may read about them and choose those, that fit good for your tasks.\n\n\nopenCV FeatureDetector    (steps 1 and 2 in algorithm above)\nopenCV DescriptorExtractor ( steps 1.1 and 2.1 in algorithm\nabove ) \nopenCV DescriptorMatcher ( step 3 in algorithm above )\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Window function after Fast Fourier Transform\r\n                \r\nHi this is open for discussion since I am doing a capstone project. So I am working with a Raspberry Pi4 and we have a piezoelectric sensor hooked up and and LCD screen as well. My team is recording voltages after a playing an instrument and we used the guitar for this. So I have data that we recorded. My question is... do i need to perform a fast Fourier transform on that data first and then do a window function or can i just simply use a window function if i want my data to have better noise measurements? Our project is coded in python and I've been looking at python code for FFT and window functions.\nJust been looking online sources for this and I am not sure how i can apply this to my application since I've never done this before.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Optimization - How To Pre Calculate Exponential?\r\n                \r\nActually, I think that I get the discrete Fourier transform some basics. And now I have some problems with the fast Fourier transform algorithm.\nI don't want to share all the functions so as not to complicate the problem. But if you don't understand some parts I can edit the question.\nSlow Fourier transform:\n```\nvoid slowft (float *x, COMPLEX *y, int n)\n{\n    COMPLEX tmp, z1, z2, z3, z4;\n    int m, k;\n\n/* Constant factor -2 pi */\n    cmplx (0.0, (float)(atan (1.0)/n * -8.0), &tmp);\n    \n    printf (\" constant factor -2 pi %f \", (float)(atan (1.0)/n * -8.0));\n    for (m = 0; m<=n; m++)\n    {\n      \n      cmplx (x[0], 0.0, &(y[m]));\n      for (k=1; k<=n-1; k++)\n      {\n/* Exp (tmp*k*m) */\n        cmplx ((float)k, 0.0, &z2);\n        cmult (tmp, z2, &z3);\n        cmplx ((float)m, 0.0, &z2);\n        cmult (z2, z3, &z4);\n        cexp (z4, &z2);\n/* *x[k] */\n        cmplx (x[k], 0.0, &z3);\n        cmult (z2, z3, &z4);\n/* + y[m] */\n        csum (y[m], z4, &z2);\n        y[m].real = z2.real; y[m].imag = z2.imag;\n      }\n    }\n}\n```\n\nto make clear:\ncmplx is creating a complete number, cmult is complex multiplication and cexp is taking exponent. that's all.\nAnd some optimizations:\n```\nvoid newslowft (double *x, COMPLEX *y, int n)\n{\n    COMPLEX tmp, z1, z2, z3, z4, *pre;\n    long  m, k, i, p;\n\n    pre = (COMPLEX *)malloc(sizeof(struct cpx)*1024);\n\n/* Constant factor -2 pi */\n    cmplx (0.0, atan (1.0)/n * -8.0, &z1);  \n    cexp (z1, &tmp);\n\n/* Pre-compute most of the exponential */\n    cmplx (1.0, 0.0, &z1);          /* Z1 = 1.0; */\n    //n=1024\n    for (i=0; i<n; i++)\n    {\n      cmplx (z1.real, z1.imag, &(pre[i]));\n      cmult (z1, tmp, &z3);\n      cmplx (z3.real, z3.imag, &z1);\n    }\n\n/* Double loop to compute all Y entries */\n    for (m = 0; m<n; m++)\n    {\n      cmplx (x[0], 0.0, &(y[m]));\n      for (k=1; k<=n-1; k++)\n      {\n/* Exp (tmp*k*m) */\n        p = (k*m % n);\n\n/* *x[k] */\n        cmplx (x[k], 0.0, &z3);\n        cmult (z3, pre[p], &z4);\n/* + y[m] */\n        csum (y[m], z4, &z2);\n        y[m].real = z2.real; \n        y[m].imag = z2.imag;\n      }\n    }\n}\n```\n\nThe problem: The first step of the optimization:\n\"precalculating some exponential inside the loop\".\nSo this is actually what I ask. How does this algorithm calculate the all exponential?\nI think we are calculating the following exponentials: e^0 e^1 e^2.... e^1023  So where are the other exponentials?\nI mean, in the first algorithm, inside the for loops we are using m (m=0; m<=1024; m  ) and k(k=0; k<1023-1; k  ) but, where is the e^1000*900?\nAs far as I understand, the second algorithm takes the mode according to n. I think this is the key point right? But I didn't get how to work?\nThanks in advance masters.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform\r\n                \r\nI need to multiply two polynomials each having small integral coefficients. I need a fast FFT routine in C/C++ which can convolve them. I have seen several libraries but they seem to be too large spread over multiple files. What is important is I need code which is not too long and can be very easily used and compiled in a single ```\n.c/.cpp```\n file. \n\n\nFFT should be optimized for real inputs at least if not small integers.\nRadix 4 implementation if available would be fine too. \nCompiling it should take no special compilation flags as compilation of program has to be done in external environment which I can't control.\n\n\nOne that very well matches my needs is here. But I need something twice as fast.\n    ", "Answer": "\r\nFor a straightforward and easy to use FFT implementation try KissFFT. If you need absolute maximum performance though, and don't mind a little complexity, then it has to be FFTW.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "numpy's fast Fourier transform yields unexpected results\r\n                \r\nI am struggling with ```\nnumpy```\n's implementation of the fast Fourier transform. My signal is not of periodic nature and therefore certainly not an ideal candidate, the result of the FFT however is far from what I was expecting. It is the same signal, simply stretched by some factor. I plotted a sinus curve, approximating my signal next to it which should illustrate, that I use the FFT function correctly: \n\n```\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nsignal = array([[ 0.], [ 0.1667557 ], [ 0.31103874], [ 0.44339886], [ 0.50747922],\n    [ 0.47848347], [ 0.64544846], [ 0.67861755], [ 0.69268326], [ 0.71581176],\n    [ 0.726552  ], [ 0.75032795], [ 0.77133769], [ 0.77379966], [ 0.80519187],\n    [ 0.78756476], [ 0.84179849], [ 0.85406538], [ 0.82852684], [ 0.87172407],\n    [ 0.9055542 ], [ 0.90563205], [ 0.92073452], [ 0.91178145], [ 0.8795554 ],\n    [ 0.89155587], [ 0.87965686], [ 0.91819571], [ 0.95774404], [ 0.95432073],\n    [ 0.96326252], [ 0.99480947], [ 0.94754962], [ 0.9818627 ], [ 0.9804966 ],\n    [ 1.], [ 0.99919711], [ 0.97202208], [ 0.99065786], [ 0.90567128],\n    [ 0.94300558], [ 0.89839004], [ 0.87312245], [ 0.86288378], [ 0.87301008],\n    [ 0.78184963], [ 0.73774451], [ 0.7450479 ], [ 0.67291666], [ 0.63518575],\n    [ 0.57036157], [ 0.5709147 ], [ 0.63079811], [ 0.61821523], [ 0.49526048],\n    [ 0.4434457 ], [ 0.29746173], [ 0.13024641], [ 0.17631683], [ 0.08590552]])\n\nsinus = np.sin(np.linspace(0, np.pi, 60))\n\nplt.plot(signal)\nplt.plot(sinus)\n```\n\n\nThe blue line is my signal, the green line is the sinus.\n\n\n\n```\ntransformed_signal = abs(np.fft.fft(signal)[:30] / len(signal))\ntransformed_sinus = abs(np.fft.fft(sinus)[:30] / len(sinus))\n\nplt.plot(transformed_signal)\nplt.plot(transformed_sinus)\n```\n\n\nThe blue line is ```\ntransformed_signal```\n, the green line is the ```\ntransformed_sinus```\n.\n\n\n\nPlotting only ```\ntransformed_signal```\n illustrates the behavior described above:\n\n\n\nCan someone explain to me what's going on here?\n\nUPDATE\n\nI was indeed a problem of calling the FFT. This is the correct call and the correct result:\n\n```\ntransformed_signal = abs(np.fft.fft(signal,axis=0)[:30] / len(signal))\n```\n\n\n\n    ", "Answer": "\r\nNumpy's ```\nfft```\n is by default applied over rows. Since your ```\nsignal```\n variable is a column vector, ```\nfft```\n is applied over the rows consisting of one element and returns the one-point FFT of each element. \n\nUse the axis option of ```\nfft```\n to specify that you want FFT applied over the columns of ```\nsignal```\n, i.e., \n\n```\ntransformed_signal = abs(np.fft.fft(signal,axis=0)[:30] / len(signal))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "I want to find the time-displacement curve through inverse fast Fourier transform\r\n                \r\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN=1000; T=10; dt=T/N\nt=np.arange(0,N*dt,dt)\n\n#system properties\nwn = 4 * np.pi\nw=0.2*wn\nTn = 2*np.pi/wn\nfn = 1/Tn\n\nm = 1\nZ = 0.05\nk = wn*wn * m\nc = 2*m*wn*Z\n######################################################\nP = np.sin(wn * t)\n\n#Frequency response\nL = len(P)\na = np.arange(L)\nfreq = a * (1/dt) / L\nfreq = freq[range(int(L/2))]\n\nPf = np.fft.fft(P)/L\nPf = Pf[range(int(L/2))]\nFFT = 2*abs(Pf)\n#########################################################\n# transfer function\nH=(1/k)*(1/(1+(w/wn)**2)+1j*(2*Z*(w/wn)))\n\nUf=2*Pf*H\n\n# for i in range(0,int(N/2)):\n#     Uf[N-i-1] = np.conjugate(Uf[i+1])\n\nut= np.real(np.fft.ifft(Uf)*(1/dt))\n\nplt.plot(t, ut)\nplt.show()\n```\n\ni don't know this ValueError\nValueError: x and y must have same first dimension, but have shapes (1000,) and (500,)\nI want to find the time-displacement curve through inverse fast Fourier transform\n    ", "Answer": "\r\nThe ```\nplt.plot()```\n function is just complaining that ```\nt```\n and ```\nut```\n do not have the same length.\nThis line ```\nPf = Pf[range(int(L/2))]```\n takes ```\nPf```\n from an array of length ```\nN```\n to ```\nN/2```\n. This affects ```\nUf```\n and consequently ```\nut```\n, and that is why you get the error message. Im not sure what you are trying to do in this command... are you trying to filter out certain frequencies? Either way, taking another look at this command might give you what you want.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform (fft) with Time Associated Data Python\r\n                \r\nI have data and a time 'value' associated with it (Tx and X).\n\nHow can I perform a fast Fourier transform on my data.\n\nTx is an array I have and X is another array I have. The length of both arrays are of course the same and they are associated by Tx[i] with X[i] , where i goes from 0 to len(X).\n\nHow can I perform a fft on such data to ultimately achieve a Power Spectral Density plot frequency against |fft|^2.\n    ", "Answer": "\r\nIf the data is not uniformly sampled (i.e. Tx[i]-Tx[i-1] is constant), then you cannot do an FFT on it.\n\nHere's an idea:\nIf you have a pretty good idea of the bandwidth of the signal, then you could create a resampled version of the DFT basis vectors R.  I.e. the complex sinusoids evaluated at the Tx times.  Then solve the linear system x = A*z: where x is your observation, z is the unknown frequency content of the signal, and A is the resamapled DFT basis. Note that A may not actually be a basis depending on the severity of the non-uniformity.  It will almost certainly not be an orthogonal basis like the DFT.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Incorrect data length when invoking Fast Fourier Transform in AForge\r\n                \r\nI'm working on a FFT (fast fourier transform) function in C#. \nI've found AForge library but when using it I keep getting the error message:\n\n\n  Incorrect data length.\n\n\nThe data I'm putting in is a list of doubles and the size can vary, depending on the signal I'm sending in.\n\nWhat to do about this?\n\nThis is what my function looks like so far\n\n```\nprivate void FastFoulierMethod(ISignal signal, List<IMarker> markers)\n{\n    AForge.Math.Complex[] complex = new AForge.Math.Complex[samples.Count];\n    for (int i = 0; i < samples.Count-1; i++)\n    {\n         complex[i] = new AForge.Math.Complex(samples[i].GetTimeInSec(),0);\n    }\n    AForge.Math.Complex[] complex2 = complex;\n    FourierTransform.DFT(complex, FourierTransform.Direction.Backward);\n    FourierTransform.FFT(complex2, FourierTransform.Direction.Backward);\n}\n```\n\n    ", "Answer": "\r\nAs per AForge documentation:\n\n\n  The method accepts data array of 2n size only, where n may vary in the [1, 14] range\n\n\nSo you would need to make sure the input size is correctly padded to a length that is a power of 2, and in the specified range:\n\n```\ndouble logLength    = Math.Ceiling(Math.Log((double)sample.Count, 2.0));\nint    paddedLength = (int) Math.Pow(2.0, Math.Min(Math.Max(1.0, logLength), 14.0));\nAForge.Math.Complex[] complex = new AForge.Math.Complex[paddedLength];\n\n// copy all input samples\nint i = 0;\nfor (; i < sample.Count; i++)\n{\n    complex[i] = new AForge.Math.Complex(samples[i].GetTimeInSec(),0);\n}\n// pad with zeros\nfor (; i < paddedLength; i++)\n{\n    complex[i] = new AForge.Math.Complex(0,0);\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Evaluating the fast Fourier transform of Gaussian function in FORTRAN using FFTW3 library\r\n                \r\nI am trying to write a FORTRAN code to evaluate the fast Fourier transform of the Gaussian function ```\nf(r)=exp(-(r^2))```\n using ```\nFFTW3```\n library. As everyone knows, the Fourier transform of the Gaussian function is another Gaussian function. \n\nI consider evaluating the Fourier-transform integral of the Gaussian function in the spherical coordinate.\n\nHence the resulting integral can be simplified to be integral of ```\n[r*exp(-(r^2))*sin(kr)]dr```\n.\n\nI wrote the following FORTRAN code to evaluate the discrete SINE transform DST which is the discrete Fourier transform DFT using a PURELY real input array. DST is performed by ```\nC_FFTW_RODFT00```\n existing in ```\nFFTW3```\n, taking into account that the discrete values in position space are r=i*delta (i=1,2,...,1024), and the input array for DST is the function ```\nr*exp(-(r^2))```\n NOT the Gaussian. The sine function in the integral of ```\n[r*exp(-(r^2))*sin(kr)]dr```\n resulting from the INTEGRATION over the SPHERICAL coordinates, and it is NOT the imaginary part of ```\nexp(ik.r)```\n that appears when taking the analytic Fourier transform in general.\n\nHowever, the result is not a Gaussian function in the momentum space.  \n\n```\nModule FFTW3\n use, intrinsic :: iso_c_binding\ninclude 'fftw3.f03'\nend module  \n\nprogram sine_FFT_transform\nuse FFTW3\nimplicit none\ninteger, parameter :: dp=selected_real_kind(8)\n\nreal(kind=dp), parameter :: pi=acos(-1.0_dp)\ninteger, parameter :: n=1024 \nreal(kind=dp) :: delta, k\nreal(kind=dp) :: numerical_F_transform\ninteger :: i\ntype(C_PTR) ::  my_plan\nreal(C_DOUBLE), dimension(1024) :: y\nreal(C_DOUBLE), dimension(1024) :: yy, yk\ninteger(C_FFTW_R2R_KIND) :: C_FFTW_RODFT00\n\nmy_plan= fftw_plan_r2r_1d(1024,y,yy,FFTW_FORWARD, FFTW_ESTIMATE)\n\ndelta=0.0125_dp\ndo i=1, n        !inserting the input one-dimension position function\ny(i)= 2*(delta)*(i-1)*exp(-((i-1)*delta)**2) \n! I multiplied by 2 due to the definition of C_FFTW_RODFT00 in FFTW3\nend do\n\ncall fftw_execute_r2r(my_plan, y,yy)   \ndo i=2, n\nk = (i-1)*pi/n/delta \nyk(i) = 4*pi*delta*yy(i)/2  !I divide by 2 due to the definition of \n                            !C_FFTW_RODFT00\nnumerical_F_transform=yk(i)/k\nwrite(11,*) i,k,numerical_F_transform\nend do\ncall fftw_destroy_plan(my_plan)\n\nend program \n```\n\n\nExecuting the previous code gives the following plot which is not for Gaussian function. \n\nCan anyone help me understand what the problem is? I guess the problem is mainly due to ```\nFFTW3```\n. Maybe I did not use it properly especially concerning the boundary conditions.    \n    ", "Answer": "\r\nLooking at the related pages in the FFTW site (Real-to-Real Transforms, transform kinds, Real-odd DFT (DST)) and the header file for Fortran, it seems that FFTW expects ```\nFFTW_RODFT00```\n etc rather than ```\nFFTW_FORWARD```\n for specifying the kind of \nreal-to-real transform. For example,\n\n```\n! my_plan= fftw_plan_r2r_1d( n, y, yy, FFTW_FORWARD, FFTW_ESTIMATE )\nmy_plan= fftw_plan_r2r_1d( n, y, yy, FFTW_RODFT00, FFTW_ESTIMATE )\n```\n\n\nperforms the \"type-I\" discrete sine transform (DST-I) shown in the above page. This modification seems to fix the problem (i.e., makes the Fourier transform a Gaussian with positive values).\n\n\n\nThe following is a slightly modified version of OP's code to experiment the above modification:\n\n```\n! ... only the modified part is shown...\nreal(dp) :: delta, k, r, fftw, num, ana\ninteger :: i, j, n\ntype(C_PTR) ::  my_plan\nreal(C_DOUBLE), allocatable :: y(:), yy(:)\n\ndelta = 0.0125_dp ; n = 1024   ! rmax = 12.8\n! delta = 0.1_dp    ; n = 128    ! rmax = 12.8\n! delta = 0.2_dp    ; n = 64    ! rmax = 12.8\n! delta = 0.4_dp    ; n = 32    ! rmax = 12.8\n\nallocate( y( n ), yy( n ) )\n\n! my_plan= fftw_plan_r2r_1d( n, y, yy, FFTW_FORWARD, FFTW_ESTIMATE )\nmy_plan= fftw_plan_r2r_1d( n, y, yy, FFTW_RODFT00, FFTW_ESTIMATE )\n\n! Loop over r-grid\ndo i = 1, n\n    r = i * delta              ! (2-a)\n    y( i )= r * exp( -r**2 )\nend do\n\ncall fftw_execute_r2r( my_plan, y, yy )\n\n! Loop over k-grid\ndo i = 1, n\n\n    ! Result of FFTW\n    k = i * pi / ((n + 1) * delta)    ! (2-b)\n    fftw = 4 * pi * delta * yy( i ) / k / 2   ! the last 2 due to RODFT00\n\n    ! Numerical result via quadrature\n    num = 0\n    do j = 1, n\n        r = j * delta\n        num = num + r * exp( -r**2 ) * sin( k * r )\n    enddo\n    num = num * 4 * pi * delta / k\n\n    ! Analytical result\n    ana = sqrt( pi )**3 * exp( -k**2 / 4 )\n\n    ! Output\n    write(10,*) k, fftw\n    write(20,*) k, num\n    write(30,*) k, ana\nend do\n```\n\n\nCompile (with gfortran-8.2 + FFTW3.3.8 + OSX10.11):\n\n```\n$ gfortran -fcheck=all -Wall sine.f90 -I/usr/local/Cellar/fftw/3.3.8/include -L/usr/local/Cellar/fftw/3.3.8/lib -lfftw3\n```\n\n\nIf we use ```\nFFTW_FORWARD```\n as in the original code, we get\n\n\n\nwhich has a negative lobe (where fort.10, fort.20, and fort.30 correspond to FFTW, quadrature, and analytical results). Modifying the code to use ```\nFFTW_RODFT00```\n changes the result as below, so the modification seems to be working (but please see below for the grid definition).\n\n\n\n\n\nAdditional notes\n\n\nI have slightly modified the grid definition for r and k in my code (Lines (2-a) and (2-b)), which is found to improve the accuracy. But I'm still not sure whether the above definition matches the definition used by FFTW, so please read the manual for details...\nThe ```\nfftw3.f03```\n header file gives the interface for ```\nfftw_plan_r2r_1d```\n\n\n```\ntype(C_PTR) function fftw_plan_r2r_1d(n,in,out,kind,flags) bind(C, name='fftw_plan_r2r_1d')\n  import\n  integer(C_INT), value :: n\n  real(C_DOUBLE), dimension(*), intent(out) :: in\n  real(C_DOUBLE), dimension(*), intent(out) :: out\n  integer(C_FFTW_R2R_KIND), value :: kind\n  integer(C_INT), value :: flags\nend function fftw_plan_r2r_1d\n```\n\n(Because of no Tex support, this part is very ugly...) The integral of ```\n4 pi r^2 * exp(-r^2) * sin(kr)/(kr)```\n for r = 0 -> infinite is ```\npi^(3/2) * exp(-k^2 / 4)```\n (obtained from Wolfram Alpha or by noting that this is actually a 3-D Fourier transform of exp(-(x^2 + y^2 + z^2)) by exp(-i*(k1 x + k2 y + k3 z)) with k =(k1,k2,k3)). So, although a bit counter-intuitive, the result becomes a positive Gaussian.\nI guess the r-grid can be chosen much coarser (e.g. ```\ndelta```\n up to 0.4), which gives almost the same accuracy as long as it covers the frequency domain of the transformed function (here ```\nexp(-r^2)```\n).\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Implementation of own fast fourier transform algorithm does not work\r\n                \r\nI have found and customized algorithm for fast fourier transform. The algorithm is below:\n\n```\nfunction X = myFFT(x)\n   %only works if N = 2^k\n   N = numel(x);\n   xp = x(1:2:end);\n   xpp = x(2:2:end);\n   if N>=8\n      Xp = myFFT(xp);\n      Xpp = myFFT(xpp);\n      X = zeros(N,1);\n      Wn = exp(-1i*2*pi.*((0:N/2-1)')/N);\n      tmp = Wn .* Xpp;\n      X = [(Xp + tmp);(Xp -tmp)];\n   else\n     switch N\n       case 2\n          X = [1 1;1 -1]*x;\n       case 4\n          X = [1 0 1 0; 0 1 0 -1i; 1 0 -1 0;0 1 0 1i]*[1 0 1 0;1 0 -1 0;0 1 0 1;0 1 0 -1]*x;\n       otherwise\n          error('N not correct.');\n     end\n   end\nend\n```\n\n\nThe algorithm above is stored in an .m file named myFFT.\n\nI want to use the code for two subsequent signals:\nh1=sin(t2) and for time t2=0:1:255;\n\nI recall the myFFT function in another .m file in this way:\n\n```\nx=h1;\nX11 = myFFT(x);\n```\n\n\nBut it gives me this error:\n\n```\nError using  * \nInner matrix dimensions must agree.\n\nError in myFFT (line 18)\n           X = [1 0 1 0; 0 1 0 -1i; 1 0 -1 0;0 1 0 1i]*[1 0 1 0;1 0 -1 0;0 1 0 1;0 1 0 -1]*x;\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n```\n\n\nHonestly, I have no idea how to fix it. Could you please help me?\nThank you very much in advance!\n    ", "Answer": "\r\nThe issue is the multiplication of a 4x4 to a 1x4 matrix. The variable ```\nx```\n need to be transposed. \n\n```\n   function X = myFFT(x)\n       %only works if N = 2^k\n       N = numel(x);\n       xp = x(1:2:end);\n       xpp = x(2:2:end);\n       if N>=8\n          Xp = myFFT(xp);\n          Xpp = myFFT(xpp);\n          X = zeros(N,1);\n          Wn = exp(-1i*2*pi.*((0:N/2-1)')/N);\n          tmp = Wn .* Xpp;\n          X = [(Xp + tmp);(Xp -tmp)];\n       else\n         switch N\n           case 2\n              X = [1 1;1 -1]*x';\n           case 4\n              X = [1 0 1 0; 0 1 0 -1i; 1 0 -1 0;0 1 0 1i]*[1 0 1 0;1 0 -1 0;0 1 0 1;0 1 0 -1]*x';\n           otherwise\n              error('N not correct.');\n         end\n       end\n    end\n```\n\n\nthen test it with\n\n```\nt2 = 0:1:255;\nmyFFT(sin(t2));\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to perform a 2D Fast Fourier Transform in c++ [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI saw there was a post about this topic, but without any reply.\nHow to write a function that performs the 2D Fast Fourier Transform for a given image f?\nIt is possible to assume that the width = 2^m, height = 2^n for some integers m and n, and the input image is already properly padded.\nInput: f - An 2D Image represented in Complex Numbers\nOutput: F - The transformed coefficients, also represented in Complex Numbers\n\n```\nvoid FFT2D(Complex<double> *f, Complex<double> *F, int width, int height)\n{\n\n}\n```\n\n\nFor everyone who think I want you to program it for me:\nI don't. Just want some theoretical explanation of how this should work\n    ", "Answer": "\r\nYou can use the FFTW library to perform this: \n\n```\n#include <fftw.h>\n\nvoid FFT2D(Complex<double> *f, Complex<double> *F, int width, int height){   \n  fftw_plan p = fftw_plan_dft_2d(width, height, f, F, FFTW_FORWARD, FFTW_ESTIMATE);            \n  fftw_execute(p); \n  fftw_destroy_plan(p);\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Quaternion Fourier Transform of color image in Python\r\n                \r\nI'm working on a research project concerning image watermarking. The main part of it is the actual watermark embedding scheme, which I have chosen to be the  robust blind color image watermarking in quaternion Fourier transform domain. I have started the implementation using OpenCV python interface and got stuck on the step where I have to do the quaternion Fourier transform. The description in the article doesn't help a lot. My code is very basic:\n\n```\nimg = cv2.imread(\"jurassic_world.jpg\", cv2.IMREAD_COLOR)\n```\n\n\nhere image is being split into 8x8 blocks.\n\n```\nfft = np.fft.fft(img)\nreturn map(lambda row: map(lambda pix:(sum(pix.real), pix[0].imag, pix[1].imag, pix[2].imag), row) , fft)\n```\n\n\nFrom the article: \n\n\n  Jiang et al. (2008) introduced the fast algorithms of the 2D quaternion Fourier transform by using the traditional complex fast Fourier transforms, in which each part Fourier transform is calculated by FFT algorithm by means of separating a quaternion into a real part and other imaginary parts. The fast quaternion Fourier transform of color image f(m,n) can be represented as:\n  \n  F(u,v) = i(Real(Rrft) + μImag(Rrft)) +\n             j(Real(Grft) + μImag(Grft)) +\n             k(Real(Brft) + μ*Imag(Brft))\n\n\nwhere Real(x) denotes the real part of complex number x, Imag(x) denotes the imaginary part of complex number x, and Rrft is the real Fourier transform of array R.\n\nCan someone explain what I'm doing wrong, and show me the right way?\n\nUpdate 1\n\nI have updated the code to compute separate fft for each color channel. Then I sum the real parts and append imagine ones to form a quaternion. \n\n```\ndef computeBlockQFFT(block):\n\n  fft0 = np.fft.fft(block[:,:,0])\n  fft1 = np.fft.fft(block[:,:,1])\n  fft2 = np.fft.fft(block[:,:,2])\n\n  res =  np.empty([block.shape[0],block.shape[1],block.shape[2]+1])\n\n  res[:,:,0] = fft0[:,:].real + fft1[:,:].real + fft2[:,:].real\n  res[:,:,1] = fft0[:,:].imag\n  res[:,:,2] = fft1[:,:].imag\n  res[:,:,3] = fft2[:,:].imag\n  return res\n```\n\n\nNow when I plot one color imagine component I get this picture and the data has a form of -764.882831772. The plot looks somewhere similar, however it doesn't match the one from article even though the same Lenna images were used. Can the reason be in the missing μ in my implementation? Also I'm struggling with the inverse transform. There are four components in the inverse formula:\n\n\n  f(u,v) = (Real(Airft) + μImag(Airft)) +\n             i(Real(Cirft) + μImag(Cirft)) +\n             j(Real(Dirft) + μImag(Dirft)) +\n             k(Real(Eirft) + μImag(Eirft)) \n\n\nHow can I map them to 3 color channels? Leave out the first one?\n    ", "Answer": "\r\nThe formula you quoted:\n\n\n  F(u,v) = i(Real(Rrft) + μImag(Rrft)) + j(Real(Grft) + μImag(Grft)) +\n  k(Real(Brft) + μ*Imag(Brft))\n\n\nFirst thing: ```\ni,j,k```\n are the imaginary axis. ```\nmu```\n is a quaternion and the direction used for the quaternion fourier transform.\n\nWhen we calculate ```\ni*mu```\n, ```\nj```\nmu```\nand```\nk*mu```\n, this will give us quaterions again.\nWe map real to 0,```\ni```\nto 1```\nj```\nto 2 and```\nk` to 3.\n\nThe formula tells us:\n\nlet ```\ni*mu*fft0.imag = a0+b0*i+c0*j+d0*k```\n , ```\nj*mu*fft1.imag = a1+b1*i+c1*j+d1*k```\n and ```\nk*mu*fft2.imag = a2+b2*i+c2*j+d2*k```\n.\n\n```\nres[0] = a0+a1+a2\nres[1] = fft0.real + b0+b1+b2\nres[2] = fft1.real + c0+c1+c2\nres[3] = fft2.real + d0+d1+d2\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Android audio recording, applying Fast Fourier transform\r\n                \r\nCurrently I'm recording audio using ```\nAudioRecord```\n, more precisely - using it's ```\nread```\n method overloads that is fed with short buffer (can't use ```\nfloat[]```\n one because of min API constraints).\n\nI want to apply Fast Fourier transform to the data I get during recording. Firstly I convert a received ```\nshort[]```\n to ```\nfloat[]```\n using such a conversion:\n\n```\npublic static float[] convertShortToFloat(short[] array) {\n    float[] data = new float[array.length];\n    for (int i = 0; i < array.length; i++) {\n        data[i] = 1.f * array[i] / Short.MAX_VALUE;\n    }\n    return data;\n}\n```\n\n\nThen I just provide the resulting ```\nfloat[]```\n to the ```\nFFT```\n instance and get the result using ```\ngetRealPart()```\n method (the implementation of this class I have is actually a bit different, but I believe that it works almost the same as this).\n\nAs far as I understand, now I should convert the data I got after transformation back to ```\nshort[]```\n form (convert back to a primal signal domain), and then submit to a muxer. I created a ```\nshort[]```\n-```\nfloat[]```\n array conversion just to be the opposite to the one I've shown earlier, but I just get noise when I play the recording.\n\nWhat's wrong with the implementation? \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transforms on GPU on iOS\r\n                \r\nI am implementing compute intensive applications for iOS (i.e., iPhone or iPad) that heavily use fast Fourier transforms (and some signal processing operations such as interpolations and resampling). What are the best libraries and API that allows for running FFTs on iOS? \n\nI have briefly looked into Apple Metal as well as Apple vDSP. I wasn't sure that vDSP utilizes GPUs although it seems to be highly parallelized and utilizes SIMD. Metal seems to allow to access GPU for compute intensive apps, but I am not able to find libraries for FFT and basic signal processing operations (something like AMD's clFFT). Does Apple provide such libraries?\n\nAre there other APIs and libraries utilizing GPUs for iOS that are suitable for compute intensive apps?   \n\nThanks.\n    ", "Answer": "\r\nvDSP actually uses the builtin (from iPhone 3GS onward) NEON vector arithmetic processor, which is, as you already said a SIMD engine and is really fast for certain tasks, including FFT.\n\nI have no experience with computing an FFT on the GPU but i doubt it will be faster as the NEON instructions in vDSP, as its only purpose are these media and signal processing related tasks.\n\nvDSP uses Arm NEON instructions under the hood and makes using them really easy. If you want to get down and dirty you could also use the NEON instruction set manually, but i think even getting on par with vDSP runtime wise will be a challenge, especially if you only need out of the box functions like FFT.\n\nIf you want to test the NEON engine yourself there is a great benchmark as APK for Android devices which tests regular vs NEON computation. The only thing you have to notice is, that if your data is larger than the L1 Cache the L2 Cache accessing becomes the limiting factor and if you even exceed this, there wont be a noticable runtime advantage.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Getting correct frequencies using a fast Fourier transform\r\n                \r\nI am trying to take understand the frequencies of a dataset and am having issues in getting the fast Fourier transform to work. The main problem is that I cannot figure out how to get the correct frequencies on the x-axis.\nBackground\nI have a dataset with many columns but the columns of interest are TOF(time of flight) and dE/dx. I have attached the CSV file containing the data. Here is how I access it.\n```\nimport pandas as pd\nfile = 'np_15us.csv'\ndataset = pd.read_csv(file,skiprows=8)\ndf = dataset[:-1] #necesssary because last row of the dataset is null for some reason\nx = df['TOF'] #TOF is in micro-seconds\ny= df['dE/dx']\n```\n\nNow, when you plot ```\nx vs. y```\n it's roughly a sinusoid. I can eyeball the frequency to be roughly 116kHz. I want to get the exact frequencies by using a fast Fourier transform because I expect other datasets to be imperfect sinusoids.\n\nProblem\nWhen I try to take the ```\nfft```\n of the data set using this code:\n```\nimport numpy as np\nx_new = np.arange(0,14, dt)\ny_new = func_1(x_new)\nfs = len(y_new)\n\nfig = plt.figure(2)\nplt.subplot(2,1,1)\nplt.plot(x_new, y_new)\nplt.xlabel('time (usec)')\nplt.ylabel('E (V/mm)')\nplt.subplot(2,1,2)\nfft = np.fft.fft(y)/len(y)\nfft = fft[range(int(len(y)/2))]\ntpCount = len(fft)\nvalues = np.arange(int(tpCount))\ntimePeriod = tpCount/samp\nfrequencies = (values/(2*timePeriod))*10**6 #followed some tutorial to get here\nplt.plot(frequencies[:100], abs(fft)[:100]) #zooming in to one of the peaks \nfig.tight_layout()\nplt.show()\n```\n\nI get,\n\nThis has a frequency of roughly 260kHz which is an overestimate. I can run the same script using ```\nnp.fft.fftfreq```\n to get\n```\nfunc_1 = interpolate.interp1d(x, y)\nsamp = 100\ndt = 1/samp\nx_new = np.arange(0,14, dt)\ny_new = func_1(x_new)\nfs = len(y_new)\nfig = plt.figure(2)\nplt.subplot(2,1,1)\nplt.plot(x_new, y_new)\nplt.xlabel('time (usec)')\nplt.ylabel('E (V/mm)')\nplt.subplot(2,1,2)\nfft = np.fft.fft(y)/len(y)\nfreqs = np.fft.fftfreq(len(fft),dt)\nfft_shift = np.fft.fftshift(fft)\nfreqs = np.fft.fftshift(freqs)\nplt.plot(freqs[int(len(freqs)/2):int(len(freqs))-300], abs(fft_shift[int(len(fft_shift)/2):int(len(freqs))-300]) #now I don't understand the frequnecies\nfig.tight_layout()\nplt.show()\n```\n\n\nWhichever way I use, I get incorrect frequencies. So, I am definitely doing something wrong. I don't really understand how the frequencies are calculated using np.fft.fftfreq.\nI don't exactly know the sampling frequency of the dataset which is why I am interpolating to get more control over that. I am not sure if I am supposed to be doing that. I would like to use ```\nnp.fft.fftfreq```\n since the code for that seems cleaner.\nThank you for your help. Please let me know if you have any questions.\nPlease note - in this case dE/dx in the dataset should actually be dV/dx like shown in the first plot. The CSV file just has is named incorrectly.\nlink to CSV file - https://drive.google.com/file/d/1LNcue82K2y4ZgKr8cPIgp7VCC2vFk_J9/view?usp=sharing\n    ", "Answer": "\r\nIf your data is very close to a sinusoid like this, and you generally have at least one period I think you will get a much better estimate in the time domain.  FFTs have energy in bins and it just picking the top bin will not give you the best result.\nI would measure the distance between zero crossings of the dE/dx value.  (Do a linear interpolation to get a more exact zero crossing location).  Without even doing the interpolation I got a value of 117.9kHz.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how can i calculate bits perminute using Fast Fourier transform\r\n                \r\ni am getting  signals as given bellow this data capture for just 10 second  (due to limited space here) now i want to write a code which shows bits per minute and i m considering the value 3.00 as a bit \n\nWhat i did: \n\nI just used a threshold value to print data to count bits per minute \n\nas \n\n```\nthreshold  = 2.8     # Threshold to do something if value is more than to that. \nif signal >= 2.8:\n    print signal              \n    counter  = counter +1 # to count how many times we get value more than 2.8 or (near by 3)\n    bits_per_mint = counterx6 # captured for 10 second so converted it to minute \nprint bits_per_mint   \n\ndata out put in 10 second  \n\n1.7646050347\n1.6970572917\n1.6774392361\n0\n3.486762153\n1.6310026042\n1.6582465278\n1.6384114583\n1.6501171875\n1.6769661458\n3.9909898997\n0\n1.6688020833\n1.6627473958\n1.6689800347\n1.6756423611\n1.6579513889\n0\n1.6809592014\n1.6504774306\n3.7684857685\n1.6463671875\n1.67640625\n0\n1.6509635417\n1.6736501736\n3.5653423434\n1.6581206597\n1.6516666667\n0\n1.6449348958\n1.6630338542\n1.6605772569\n1.6500824653\n3.4554564564\n0\n1.6839409722\n1.6495399306\n1.6393663194\n1.6684244792\n------------\n--------- so on \n```\n\n\nHow can i do this  using Fast Fourier transform\n\nthanks \n    ", "Answer": "\r\nTry this and let me know if it helped you. You can use ```\ntime```\n module to introduce the delay in seconds in an outer ```\nwhile```\n loop and then check for the condition if the signal is greater than the threshold if yes then print it and also append it to a list ```\nbits_per_min```\n. Example code shown below.\n\n```\nimport time\nthreshold  = 2.8     # Threshold to do something if value is more than to that. \nseconds = 0\ncounter = 0\n\nwhile seconds != 60:\n    bits_per_min = []    # this part of code runs for one min duration\n    if signal >= threshold:   # to compare if signal is greater than the threshold value\n        print signal\n        bits_per_min.append(signal)\n        counter += 1\n    time.sleep(1)\n    seconds += 1\nprint bits_per_min\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Do I need to resize the image to 2^a x 2^b before performing a fast fourier transform?\r\n                \r\nDo I need to resize the image to 2^a x 2^b before performing a fast fourier transform?\n    ", "Answer": "\r\nFor the cases where you do need to use a power of 2, rather than resizing, you should pad with zeros.\n\nIn some cases, even if the algorithm you are using is not limited to powers of 2, it may be more efficient to pad to that size anyway (particularly if your image is just slightly smaller than the next power of 2).  Also, if your image is not square, you can pad to a square image of 2^a before taking the fft.  Some algorithms will do this behind the scenes anyway - pad your image to square, take the fft, then crop back to the original size.\n\nZero padding is also sometimes used to increase the number of points in the output - a higher frequency \"resolution\", although since you're not adding any more data it's more like an interpolation.\n\nWhether you need to do this will depend on what fft library you are using.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Passing GpuMat directly to cufftExecC2C function for doing fast fourier transform\r\n                \r\nI am trying to optimize my code using opencv with cuda and cufft library. Everytime I have do fast fourier transform, I have to download cv::Mat from GpuMat and then do cufft. (Please see the code below) and again download the result of the fft. Is there any way I can optimize this ? I wanted to know if there is any way I could directly pass GpuMat without having to download it. \n\n```\nstd::vector<cv::cuda::GpuMat> ReconClass::FFT2(std::vector<cv::cuda::GpuMat>& mat, int height, int width)\n{\n    cufftHandle plan;\n    cufftComplex* data, * datao, * devdata, * devdatao;\n\n    size_t arraySize = sizeof(cufftComplex) * mat[0].size().area();\n    cudaMallocHost((void**)& data, arraySize);\n    cudaMallocHost((void**)& datao, arraySize);\n\n    cudaMalloc((void**)& devdata, arraySize);\n    cudaMalloc((void**)& devdatao, arraySize);\n\n    cv::Mat iReal;\n    cv::Mat iImag;\n    mat[0].download(iReal);\n    mat[1].download(iImag);\n\n    for (int i = 0; i < height; i++)\n    {\n        for (int j = 0; j < width; j++)\n        {\n            data[i * width + j].x = iReal.at<float>(i, j);\n            data[i * width + j].y = iImag.at<float>(i, j);\n        }\n    }\n    cudaMemcpy(devdata, data, arraySize, cudaMemcpyHostToDevice);\n\n    cufftPlan2d(&plan, height, width, CUFFT_C2C);\n\n    if (!plan)\n        std::cout << \"the cufftPlan2d plan returned is null\" << std::endl;\n\n    cufftExecC2C(plan, (cufftComplex*)devdata, (cufftComplex*)devdatao, CUFFT_FORWARD);\n\n    cudaMemcpy(datao, devdatao, arraySize, cudaMemcpyDeviceToHost);\n\n    cv::Mat realRecon(height, width, CV_32F);\n    cv::Mat imagRecon(height, width, CV_32F);\n\n    for (int i = 0; i < height; i++)\n    {\n        for (int j = 0; j < width; j++)\n        {\n            realRecon.at<float>(i, j) = datao[i * width + j].x;\n            imagRecon.at<float>(i, j) = datao[i * width + j].y;\n        }\n    }\n\n    cv::cuda::GpuMat mat1, mat2;\n    mat1.upload(realRecon);\n    mat2.upload(imagRecon);\n\n    std::vector<cv::cuda::GpuMat> re = { mat1 , mat2 };\n\n    cufftDestroy(plan);\n    cudaFreeHost(data);\n    cudaFreeHost(datao);\n    cudaFree(devdata);\n    cudaFree(devdatao);\n\n    return re;\n}\n```\n\n    ", "Answer": "\r\nI was able to avoid copy to the CPU and back copy to the device. Also doing inplace FFT helped improve performance. I have pasted my code below. \n\n```\nvoid Dataransfer2Cuda(const cv::InputArray _dReal, const cv::InputArray _dImag, float2* zCufftcomplex)\n{\n    const cv::cuda::GpuMat Real = _dReal.getGpuMat();\n    const cv::cuda::GpuMat Imag = _dImag.getGpuMat();\n\n    dim3 cthreads(32, 32);\n    dim3 cblocks(\n        static_cast<int>(std::ceil(Real.size().width /\n            static_cast<double>(cthreads.x))),\n        static_cast<int>(std::ceil(Real.size().height /\n            static_cast<double>(cthreads.y))));\n\n    Kernel_DataTransfer2Cuda << <cblocks, cthreads >> > (Real, Imag, zCufftcomplex);\n\n    if (cudaSuccess != cudaGetLastError())\n        std::cout << \"Dataransfer2Cuda(): gave an error\" << std::endl;\n\n    return;\n}\n\nvoid DataransferFromCuda(const float2* zCufftcomplex, cv::OutputArray _outputReal, cv::OutputArray _outputImag, std::size_t iWidth, std::size_t iHeight)\n{\n\n    _outputReal.create(iHeight, iWidth, CV_32F);\n    _outputImag.create(iHeight, iWidth, CV_32F);\n\n    cv::cuda::GpuMat outputReal = _outputReal.getGpuMat();\n    cv::cuda::GpuMat outputImag = _outputImag.getGpuMat();\n\n\n    dim3 cthreads(32, 32);\n    dim3 cblocks(\n        static_cast<int>(std::ceil(outputReal.size().width /\n            static_cast<double>(cthreads.x))),\n        static_cast<int>(std::ceil(outputReal.size().height /\n            static_cast<double>(cthreads.y))));\n\n    Kernel_DataTransferFromCuda << <cblocks, cthreads >> > (zCufftcomplex, outputReal, outputImag);\n\n    if (cudaSuccess != cudaGetLastError())\n        std::cout << \"DataransferFromCuda(): gave an error\" << std::endl;\n\n    return;\n}\n\nstd::vector<cv::cuda::GpuMat> ReconClass::FFT2(std::vector<cv::cuda::GpuMat>& mat, int height, int width)\n{\n    cufftHandle plan;\n    cufftComplex* devdata;\n\n    size_t arraySize = sizeof(cufftComplex) * mat[0].size().area();\n\n    cudaMalloc((void**)& devdata, arraySize);\n\n    Dataransfer2Cuda(mat[0], mat[1], devdata);\n\n    cufftPlan2d(&plan, height, width, CUFFT_C2C);\n\n    if (!plan)\n        std::cout << \"the cufftPlan2d plan returned is null\" << std::endl;\n\n    cufftExecC2C(plan, (cufftComplex*)devdata, (cufftComplex*)devdata, CUFFT_FORWARD);\n\n    cv::cuda::GpuMat mat1, mat2;\n    DataransferFromCuda(devdata, mat1, mat2, width, height);\n    std::vector<cv::cuda::GpuMat> re = { mat1 , mat2 };\n\n    cufftDestroy(plan);\n    cudaFree(devdata);\n\n    return re;\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Determining the amplitude for a specific cycle (frequency) using a fast fourier transform\r\n                \r\nI have been set an assignment using a dataset obtained from remote sensing on sea surface height anomaly. Before starting the question I'm having trouble with, I have loaded the data into matlab, filtered it so that it only contains data within the desired geographic location and plotted the data as a function of time. \n\nThe question I'm struggling with specifically is: \n\n\"Determine the amplitude of the annual cycle in the SSHA data at 36°, 21°W\nusing fast Fourier transform.\"\n\nwhere SSHA is the sea surface height anomaly data. \n\nAs I said above, I have filtered the data. I have also used the fast fourier transform command on the filtered data; fft(sshaFiltered) \n\nand plotted the absolute data; abs(sshaFilteredFft); plot(sshaFilteredAbs). \n\nThis has enabled me to plot the data as a function of it's frequency (I believe). I just don't understand how to determine the amplitude of it's annual cycle. \n\nAny response is greatly appreciated, thank you.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "An implementation of the fast Fourier transform (FFT) in C# [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhere can I find a free, very quick, and reliable implementation of FFT in C#?\n\nThat can be used in a product? Or are there any restrictions?\n    ", "Answer": "\r\nThe guy that did AForge did a fairly good job but it's not commercial quality.  It's great to learn from but you can tell he was learning too so he has some pretty serious mistakes like assuming the size of an image instead of using the correct bits per pixel.\n\nI'm not knocking the guy, I respect the heck out of him for learning all that and show us how to do it. I think he's a Ph.D now or at least he's about to be so he's really smart it's just not a commercially usable library.\n\nThe Math.Net library has its own weirdness when working with Fourier transforms and complex images/numbers. Like, if I'm not mistaken, it outputs the Fourier transform in human viewable format which is nice for humans if you want to look at a picture of the transform but it's not so good when you are expecting the data to be in a certain format (the normal format). I could be mistaken about that but I just remember there was some weirdness so I actually went to the original code they used for the Fourier stuff and it worked much better. (ExocortexDSP v1.2 http://www.exocortex.org/dsp/)\n\nMath.net also had some other funkyness I didn't like when dealing with the data from the FFT, I can't remember what it was I just know it was much easier to get what I wanted out of the ExoCortex DSP library. I'm not a mathematician or engineer though; to those guys it might make perfect sense.\n\nSo! I use the FFT code yanked from ExoCortex, which Math.Net is based on, without anything else and it works great.\n\nAnd finally, I know it's not C#, but I've started looking at using FFTW (http://www.fftw.org/).  And this guy already made a C# wrapper so I was going to check it out but haven't actually used it yet. (http://www.sdss.jhu.edu/~tamas/bytes/fftwcsharp.html)\n\nOH! I don't know if you are doing this for school or work but either way there is a GREAT free lecture series given by a Stanford professor on iTunes University.  \n\nhttps://podcasts.apple.com/us/podcast/the-fourier-transforms-and-its-applications/id384232849\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Extract amplitude and phase using scipy fft (fast fourier transform)\r\n                \r\nI am trying to use a Fast Fourier Transform to extract the amplitude and phase shift of two sinusoidal waves. By experimenting, I found out that transform returned from the FFT had an amplitude that was actually an N/2 times multiple of my actual signal (where N is the number of samples in the wave). So, to extract and plot the actual transform, I had to multiply the gain by 2/N.\nThe portion of the code showing this is attached below:\n```\nfrom scipy.fft import fft, rfft\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 600  # number of sample points\nd = 1.0  # time domain\nf = 50   # frequency\nu = 0.1  # mean inlet velocity\ndu = 0.1  # velocity perturbation rate\nT = 1.0 / f  # period\ns = d/N  # sample spacing\n\n# 1st sine wave\nx1 = np.linspace(0.0, d, N)\ny1 = u*du* np.sin(f * 2.0*np.pi*x1)\nyf1 = rfft(y1)\nxf1 = np.linspace(0.0, 1.0/(2.0*s), N//2)\n\n# 2nd sine wave\nq = 0.08  \ndq = 0.1  \nphi = np.pi / 2 # phase delay (rad)\n\nx2 = np.linspace(0.0, d, N)\ny2 = q*dq* np.sin(f * 2.0*np.pi*x2 - phi)\nyf2 = fft(y2)\nxf2 = np.linspace(0.0, 1.0/(2.0*s), N//2)\n\n#plt.plot(x,y)\nplt.plot(xf1, 2.0/N * np.abs(yf1[0:N//2]))\nplt.plot(xf2, 2.0/N * np.abs(yf2[0:N//2]))\nplt.grid()\nplt.show()\n```\n\nI cannot figure out why the FFT returns this amplitude multiplied by N/2.\nA secondary problem I face is how to extract the phase shift (phi) from the 2 transformed waves. Any help would be appreciated.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform algorithm wrong by a single minus sign\r\n                \r\nSo after watching this video on the fast fourier transform https://www.youtube.com/watch?v=h7apO7q16V0\nI analysed the pseudocode and implemented it in python to find out that it was producing a different output to that of many fft calculator sites. My values seem to be all there its just odd, as the order is out of place, anyone know why. Is it a different kind of algorithm implementation or something.\n```\n\nimport cmath\nimport math\ndef FFT(P):\n    n= len(P)\n\n    if n == 1:\n        return P\n\n    omega = cmath.exp((2 * cmath.pi * 1j)/n)\n\n    p_even = P[::2]\n    p_odd = P[1::2]\n\n    y_even = FFT(p_even)\n    y_odd = FFT(p_odd)\n\n    y = [0] * n\n\n    \n    for i in range(n//2):\n        y[i] = y_even[i] + omega**i*y_odd[i]\n        y[i+n//2] = y_even[i] - omega**i*y_odd[i]\n    return y\n\n    \npoly = [0,1,2,3]\nprint(FFT([0,1,2,3]))\n```\n\nThe site I tested it against was https://tonysader.github.io/FFT_Calculator/?\nand I input into this site 0,1,2,3 and obtained: 6, -2+2J, -2, -2+-2J\nwhilst my python program output : 6, -2-2J, -2, -2+2J\nThe pseudocode I followed:\n\n    ", "Answer": "\r\nI think the program you're running is executing the inverse FFT.  Try\n```\nomega = cmath.exp((-2 * cmath.pi * 1j)/n)```\n.  Note the minus sign.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to use the FFT (Fast Fourier Transform) in Matlab\r\n                \r\nI'm just learning Matlab and the fast fourier transform algorithm.\n\nAs a first step I tried to duplicate this example: https://en.wikipedia.org/wiki/Fourier_transform#Example\n\nI use the following code:\n\n```\nt = -6:0.01:6;\ns = cos(2 * pi * 3 * t) .* exp(-pi * t.^2);\nfigure(1);\nplot(t, s);\nxlim([-2 2]);\nr = fft(s);\nfigure(2);\nplot(t, abs(r));\n```\n\n\nAnd I obtained the following picture:\n\nFigure 2:\n\n\n\nFigure 1 is OK, but Figure 2 is not. I see one of the problem is that in Figure 2 I should plot vector r against frequency, not against time. Another problem in Figure 2 is the scale in the Y-axis.\n\nThus, I have 2 questions in order to duplicate the example:\n\n\nHow can I obtain the frequency domain (X-axis in Figure 2)?\nHow should I scale vector r (Y-axis in Figure 2)?\n\n    ", "Answer": "\r\nYour issue is that you aren't actually creating a frequency vector to plot the ```\nfft```\n against. The reason that the fft is plotted against time is because that is what you specified in your plot command.\n\nHere is a working fft outline:\n\n```\nN=length(t);\nindex=0:N-1;\nFrequencyResolution=SamplingRate/N;\nFrequency=index.*FrequencyResolution;\ndata_fft=fft(detrend(data)); \n%the detrend isn't necessary but it does look nicer because it focuses the plot on changes around the mean of the data\ndata_FFTmagnitude=abs(data_fft);\nplot(Frequency, data_FFTmagnitude)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform difference in result between wolframalpha and commons-math\r\n                \r\nI have a question related with Fast Fourier Transform. \nI downloaded \"Math Commons 3.2\" library where is FFT. But the result is different than I expected.   \n\nFor instance, for data like, real: ```\n1,0,0,0,0,0,0,0,0```\n imaginary: ```\n0,0,0,0,0,0,0,0,0```\n \nI've got, real:```\n1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0```\n imaginary:```\n0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0```\n\nthe same result I've got when I used this code\n(in \"public static main\" section this example exist as a \"test\")\nbut in wolframalpha the real values are all 1/3 rather than 1.0.\n\nThe question:\nWhere/What is a difference and how can I get the same result like in wolframalpha\nBest regards\nDawid D\n    ", "Answer": "\r\nIdeally, the Discrete Fourier Transform is an orthonormal transformation. It just rotates the coordinate system to give a different set of coordinates for the same point in space.\n\nMany implementations of the DFT are not normal; they change the magnitude of the vector simply for computational convenience. Essentially, all the additions they do multiply the vector length by the number of elements in it, and the implementations never multiply or divide to compensate for that.\n\nObserve that the length of the vector WolframAlpha returned to you is 1, the same as the length of the input vector. (The length is the square root of the sum of the squares of the elements. The length of the input vector is sqrt(1+0+0+0+0+0+0+0+0) = 1. The length of the output vector is sqrt(1/9+1/9+1/9+1/9+1/9+1/9+1/9+1/9) = 1.)\n\nIt is a common convention for DFT implementations to ignore the normalization and return scaled results. This works because most operations used on the transform results do not care about the absolute magnitude. Additionally, a common process is to compute one or more DFTs, combine or process the results, and compute an inverse DFT. If the scaling is part of the DFTs, then it must be performed in each DFT and each inverse DFT. If you leave the scaling out of the DFTs, then the application can combine all of the scales that are involved into a single scaling operation at the end. It is better for computing performance to do a scaling once than many times, so this is preferred.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Is there any way to use Youtube API stream to do fast fourier transform with C# application\r\n                \r\nSay you link to a video on Youtube with a C# application using Youtube API.\nIs there any way to deal with the video Flash so it's look like doing fast fourier transform on realtime?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Computational complexity of an n-dimensional Fast Fourier Transform? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Computational complexity of the FFT in n dimensions\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm trying to write a bit of code that will predict the time taken to perform a discrete Fourier transform on a given n-dimensional array, but I'm struggling to get my head around the computational complexity of n-dimensional FFTs.\n\nAs I understand it:\n\n\nThe 1D FFT of a vector of length ```\nN```\n should take ```\nk*(N*log(N))```\n where ```\nk```\n is some timing constant\nFor an ```\nM*N```\n matrix, the 2D FFT should take:\n\n```\nN*(k*M*log(M)) + M*(k*N*log(N)) = k*M*N*(log(M)+log(N))```\n\n\nsince it requires taking 1D FFTs in each row and column\n\n\nHow does this generalize to the ND case? Does it follow that it should be ```\nk*prod(dimensions)*sum(log(dimensions))```\n?\n    ", "Answer": "\r\nIf we take your derivation of 2D a bit further, it becomes clear:\n\n```\nN*(k*M*log(M)) + M*(k*N*log(N)) = k*M*N*(log(M)+log(N))\n```\n\n\nbecomes:\n\n```\n                                = k*M*N*(log(M*N))\n```\n\n\nFor N dimensions (A,B,C, etc...), the complexity is:\n\n```\nO( A*B*C*... * log(A*B*C*...) )\n```\n\n\nMathematically speaking, an N-Dimensional FFT is the same as a 1-D FFT with the size of the product of the dimensions, except that the twiddle factors are different. So it naturally follows that the computational complexity is the same.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to calculate a sum of products of array elements using a fast Fourier transform?\r\n                \r\nI have some binary array. For example, let my array is:\n\n```\nint a[] = {1, 0, 0, 0, 1, 0, 1, 0, 1}\n```\n\n\nI want to calculate the values based on this formula:\n\n\n\nHow to calculate this function, using a fast Fourier transform? I have a large array and I have to calculate this function many times. So, I want to be able to calculate this function quick.\n    ", "Answer": "\r\nThe calculation you are making is basically a convolution and convolution in the time domain is simply multiplication in the frequency domain.So just get the FFT of ```\na```\n and multiply it with itself, then perform an IFFT to return to the time domain.So in short, you can calculate b by\n\n```\nb(2*i) = IFFT( FFT(a[0:2*i)]).FFT(a[0:2*i]) ) \n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Implementing a Fast Fourier Transform for Option Pricing\r\n                \r\nI'm in need of some tips regarding a small project I'm doing. My goal is an implementation of a Fast Fourier Transform algorithm (FFT) which can be applied to the pricing of options.\n\nFirst concern: which FFT?\n\nThere are a lot of different FFT algorithms, the most famous one being Cooley-Tukey. My thoughts on this: I prefer the most simple one, since this is no thesis or big project, just a course on Algorithms. But it has to be compatible with option pricing (in contrast with the most - well in our general literature- referenced application of images/sound processing). So it depends on the form of input that is provided (on which I need some advice). I'm familiar with the several improvements, like a Fractional FFT, mixed-radix FFT etc. But these seem pretty complex and optimization/performance driven, which is not relevant for my project.\n\nSecond concern: which pricing model?\n\nI Guess Black-Scholes (BS) is a bit too 'flat' and I am aware of the several models that emerged after BS. So, with the same objectives as stated above, I'd initially prefer the Heston model.\n\nThere are a lot of considerations, and the truth is that I just can't see the wood for the trees.\n\nSome background info:\n\nMy background is a B.Sc in Mathematics (Theoretical), so I have some understanding of Fourier transforms. \n\nThe goal is a working FFT implementation for calculating option pricing. It does not have to be the fastest (no extreme optimization). The goals are trying to understand the chosen FFT and having a real-world working application. \n\nSo could you give some advice on the choices?\n\nI've read a lot of papers on FFT + Option pricing, say all the decent hits on googles first few pages. But those studies were written with a much 'higher' cause.\n    ", "Answer": "\r\nIf your goal is to make some use of the FFT, then your choices are poor: only affine models give you enough information to obtain the Fourier transform of the spot density. In practice, this means Black-Scholes, or Heston. Perhaps a few more, but none of the \"useful\" models.\n\nHeston's model has peculiar features (pertaining to its implied vol dynamics) which makes it quite useless as a stochastic vol model. I suppose it is popular precisely because of the fact that you can price vanilla options in semi-closed form, through Fourier transforms. With modern technology, this is no longer a real asset.\n\nIf you are interested in option pricing, I'd therefore suggest you don't try too hard with FFT, and turn to PDE or Monte-Carlo methods: the range of models you can play with are much more interesting (and much more valuable on the job market, in case you're interested).\n\nFor the FFT part of your question, implementing Cooley-Tukey from scratch is not hard, and you can start there. Of course, in production code, you are better using a canned package (like FFTW).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform results: frequency axis scale?\r\n                \r\nI successfully implemented code that takes array data and runs a fast fourier transform on it, using Apple's Accelerate Framework (performed on iOS device).\n\nMy question now is what is the scale of the frequency axis?  The results have peaks as expected in certain frequency ranges, but I'm not sure what the frequency should be.  The Accelerate Framework's FFT functions take in an array and spit out an array with the same (or more) number of data points.  Does it assume that all those points are equally spaced in time?  It doesn't take the sampling frequency or time variable as input.  Is the scale of the frequency axis (i.e. frequency increment on each point) just the sampling period divided by 2*Pi (or something similar to that?)  I couldn't find a lot of information in the documentation on this.  I've been looking for similar questions online and haven't found anything.\n\nThis is in some ways a math question, although it depends heavily on the Accelerate Framework implementation.\n\nThanks\n\nEDIT\nI asked a follow-up question here but no one has answered it yet.  Please take a look!\n    ", "Answer": "\r\nThe FFT gives you linearly spaced frequency bins up to the sampling frequency. This means that the spacing between the bins is (sample frequency) / (number of bins).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Image processing and Fast Fourier Transformation\r\n                \r\nI am developing an application which does image processing in real time to get the y-sum and time between each frame. They are stored in 2 double arrays and for further implementations i need to run Fast Fourier Transformation on these values.\n\nI have seen several fft algorithms in other questions such as\n\n\nStack Overflow Question 1\nStack Overflow Question 2\n\n\nI have also read topics where they suggesting using JTransform library\n\nHowever, Since I have very very limited knowledge about FFT, I am not sure how to implement it into my code.\n\nMy MainActivity is this\n\n```\npublic class MainActivity extends AppCompatActivity implements CameraView.PreviewReadyCallback {\nprivate static Camera camera = null;\nprivate CameraView image = null;\nButton fftButton;\n\nprivate LineChart bp_graph;\nprivate int img_Y_Avg, img_U_Avg, img_V_Avg;\nprivate long end = 0, begin = 0;\nHandler handler;\nprivate int readingRemaining = 1200;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n    bp_graph = (LineChart)findViewById(R.id.graph);\n    fftButton = (Button)findViewById(R.id.runFFT);\n\n    graph_features();\n\n    //open camera\n    try {\n        camera = Camera.open();\n\n        handler = new Handler();\n        final Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                camera.stopPreview();\n                camera.release();\n                fftButton.setVisibility(View.VISIBLE);\n            }\n        };\n        handler.postDelayed(runnable, 30000);\n\n    } catch (Exception e) {\n        Log.d(\"ERROR\", \"Failed to get camera: \" + e.getMessage());\n    }\n\n    if (camera != null) {\n        image = new CameraView(this, camera);\n        FrameLayout camera_view = (FrameLayout) findViewById(R.id.camera_view);\n        camera_view.addView(image);\n        image.setOnPreviewReady(this);\n    }\n}\n\n\n@Override\nprotected void onResume(){\n    super.onResume();\n}\n\n@Override\nprotected void onPause() {\n    super.onPause();\n}\n\n@Override\npublic void onPreviewFrame(long startTime, int ySum, int uSum, int vSum, long endTime) {\n    begin = startTime;\n    img_Y_Avg = ySum;\n    img_U_Avg = uSum;\n    img_V_Avg = vSum;\n    end = endTime;\n\n   showResults(begin, img_Y_Avg, img_U_Avg, img_V_Avg, end);\n}\n\nprivate void showResults(long startTime, int ySum, int uSum, int vSum, long endTime){\n\n    //set value of Y on the text view\n    TextView valueOfY = (TextView)findViewById(R.id.valueY);\n    //valueY = img_Y_Avg;\n    valueOfY.setText(String.valueOf(img_Y_Avg));\n\n    //start time in milliseconds\n    long StartDurationInMs = TimeUnit.MILLISECONDS.convert(begin, TimeUnit.MILLISECONDS);\n    ArrayList<Long> startOfTime = new ArrayList<>();\n    startOfTime.add(StartDurationInMs);\n\n    //store value to array list\n    ArrayList<Integer> yAverage = new ArrayList<>();\n    yAverage.add(img_Y_Avg);\n\n    ArrayList<Long> getValues = new ArrayList<>();\n\n    for(int i = 0; i < yAverage.size(); i++) {\n        getValues.add(startOfTime.get(i));\n        getValues.add((long)(yAverage.get(i)));\n    }\n\n    storeCsv(yAverage, getValues);\n    Log.d(\"MyEntryData\", String.valueOf(getValues));\n\n}\n\n/**\n * method to store raw time and y-sum data into CSV file**/\npublic void storeCsv(ArrayList<Integer>yAverage, ArrayList<Long>getValues){\n\n    String filename = \"temporary.csv\";\n\n    //File directoryDownload = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    String path = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/bpReader\";\n    //File logDir = new File (directoryDownload, \"bpReader\"); //Creates a new folder in DOWNLOAD directory\n    File logDir = new File(path);\n    logDir.mkdirs();\n    File file = new File(logDir, filename);\n\n\n    FileOutputStream outputStream = null;\n       try {\n           file.createNewFile();\n           outputStream = new FileOutputStream(file, true);\n           //outputStream = openFileOutput(filename, Context.MODE_PRIVATE);\n           for (int i = 0; i < yAverage.size(); i += 2) {\n               outputStream.write((getValues.get(i) + \",\").getBytes());\n               outputStream.write((getValues.get(i + 1) + \"\\n\").getBytes());\n               //outputStream.write((getValues.get(i + 2) + \",\").getBytes());\n               //outputStream.write((getValues.get(i + 3) + \"\\n\").getBytes());\n           }\n           outputStream.flush();\n           outputStream.close();\n       } catch (Exception e) {\n           e.printStackTrace();\n       }\n\n}\n\n//Method for button which appears after the reading is done and the data is saved into csv file\npublic void readFile(View view){\n    readCsv();\n}\n//Method to read the data from the csv and get the time and y-sum value\npublic void readCsv(){\n    String getPath = Environment.getExternalStorageDirectory() + \"/bpReader\";\n    String csvFile = \"temporary.csv\";\n    String path = getPath+ \"/\" + csvFile;\n\n\n    int length = 500;\n    double[] xCoords = new double[length];\n    double[] yCoords = new double[length];\n    double[] newXcord = new double[length];\n\n    CSVReader reader;\n\n    try {\n        File myFile = new File (path);\n        reader = new CSVReader(new FileReader(myFile));\n        String[] line;\n        int i;\n        for (i = 0; i < xCoords.length; i ++){\n            if ((line = reader.readNext()) != null){\n                xCoords[i] = Double.parseDouble(line[0]);\n                yCoords[i] = Double.parseDouble(line[1]);\n            }\n        }\n\n        for (i = 0; i < xCoords.length ; i++){\n            if (xCoords[i]!=0) {\n                newXcord[i] = xCoords[i] - xCoords[0];\n\n                Log.d(\"read:: \", \"Time: \" + String.valueOf(newXcord[i]) + \" Y-Sum \" + String.valueOf(yCoords[i]));\n            }\n        }\n        myFile.delete();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n}\n}\n```\n\n\nAfter I have read the CSV file in ```\nreadCsv()```\n method, i get data like this\n\n```\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 0.0 Y-Sum 570194.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 50.0 Y-Sum 405504.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 118.0 Y-Sum 405504.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 168.0 Y-Sum 405504.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 234.0 Y-Sum 429242.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 301.0 Y-Sum 1217635.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 368.0 Y-Sum 1516666.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 418.0 Y-Sum 1495037.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 486.0 Y-Sum 1514453.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 553.0 Y-Sum 1507075.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 625.0 Y-Sum 1511241.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 678.0 Y-Sum 1476090.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 749.0 Y-Sum 1476961.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 815.0 Y-Sum 1470232.0\n```\n\n\nMy FFT class is this which i got from some of the suggestions in other stack overflow questions.\n\n```\npublic class FFT {\n\n/**\n * The Fast Fourier Transform (generic version, with NO optimizations).\n *\n * @param inputReal\n *            an array of length n, the real part\n * @param inputImag\n *            an array of length n, the imaginary part\n * @param DIRECT\n *            TRUE = direct transform, FALSE = inverse transform\n * @return a new array of length 2n\n */\npublic static double[] fft(final double[] inputReal, double[] inputImag,\n                           boolean DIRECT) {\n    // - n is the dimension of the problem\n    // - nu is its logarithm in base e\n    int n = inputReal.length;\n\n    // If n is a power of 2, then ld is an integer (_without_ decimals)\n    double ld = Math.log(n) / Math.log(2.0);\n\n    // Here I check if n is a power of 2. If exist decimals in ld, I quit\n    // from the function returning null.\n    if (((int) ld) - ld != 0) {\n        System.out.println(\"The number of elements is not a power of 2.\");\n        return null;\n    }\n\n    // Declaration and initialization of the variables\n    // ld should be an integer, actually, so I don't lose any information in\n    // the cast\n    int nu = (int) ld;\n    int n2 = n / 2;\n    int nu1 = nu - 1;\n    double[] xReal = new double[n];\n    double[] xImag = new double[n];\n    double tReal, tImag, p, arg, c, s;\n\n    // Here I check if I'm going to do the direct transform or the inverse\n    // transform.\n    double constant;\n    if (DIRECT)\n        constant = -2 * Math.PI;\n    else\n        constant = 2 * Math.PI;\n\n    // I don't want to overwrite the input arrays, so here I copy them. This\n    // choice adds \\Theta(2n) to the complexity.\n    for (int i = 0; i < n; i++) {\n        xReal[i] = inputReal[i];\n        xImag[i] = inputImag[i];\n    }\n\n    // First phase - calculation\n    int k = 0;\n    for (int l = 1; l <= nu; l++) {\n        while (k < n) {\n            for (int i = 1; i <= n2; i++) {\n                p = bitReverseReference(k >> nu1, nu);\n                // direct FFT or inverse FFT\n                arg = constant * p / n;\n                c = Math.cos(arg);\n                s = Math.sin(arg);\n                tReal = xReal[k + n2] * c + xImag[k + n2] * s;\n                tImag = xImag[k + n2] * c - xReal[k + n2] * s;\n                xReal[k + n2] = xReal[k] - tReal;\n                xImag[k + n2] = xImag[k] - tImag;\n                xReal[k] += tReal;\n                xImag[k] += tImag;\n                k++;\n            }\n            k += n2;\n        }\n        k = 0;\n        nu1--;\n        n2 /= 2;\n    }\n\n    // Second phase - recombination\n    k = 0;\n    int r;\n    while (k < n) {\n        r = bitReverseReference(k, nu);\n        if (r > k) {\n            tReal = xReal[k];\n            tImag = xImag[k];\n            xReal[k] = xReal[r];\n            xImag[k] = xImag[r];\n            xReal[r] = tReal;\n            xImag[r] = tImag;\n        }\n        k++;\n    }\n\n    // Here I have to mix xReal and xImag to have an array (yes, it should\n    // be possible to do this stuff in the earlier parts of the code, but\n    // it's here to readibility).\n    double[] newArray = new double[xReal.length * 2];\n    double radice = 1 / Math.sqrt(n);\n    for (int i = 0; i < newArray.length; i += 2) {\n        int i2 = i / 2;\n        // I used Stephen Wolfram's Mathematica as a reference so I'm going\n        // to normalize the output while I'm copying the elements.\n        newArray[i] = xReal[i2] * radice;\n        newArray[i + 1] = xImag[i2] * radice;\n    }\n    return newArray;\n}\n\n/**\n * The reference bitreverse function.\n */\nprivate static int bitReverseReference(int j, int nu) {\n    int j2;\n    int j1 = j;\n    int k = 0;\n    for (int i = 1; i <= nu; i++) {\n        j2 = j1 / 2;\n        k = 2 * k + j1 - 2 * j2;\n        j1 = j2;\n    }\n    return k;\n}\n}\n```\n\n\nMy Question is\n\n\nCan I implement this FFT class in my code.\nIf, yes can anyone direct me on how to do it? I guess i have to perform the fft inside the ```\nreadCsv```\n method and use the values as input once have read all the values. \n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast fourier transform for deasonalizing data in MATLAB\r\n                \r\nI'm very much a novice at signal processing techniques, but I am trying to apply the fast fourier transform to a daily time series to remove the seasonality present in the data. The example I am working with is from here: \nhttp://www.mathworks.com/help/signal/ug/frequency-domain-linear-regression.html\n\nWhile I understand how to implement the code as it is written in the example, I am having a hard time adapting it to my specific application. What I am trying to do is create a preprocessing function which deseasonalizes the training data using similar code to the above example. Then, using the same estimated coefficients from the in-sample data, deseasonalize the out-of-sample data to preserve its independence from the in-sample data. Basically, once the coefficients are estimated, I will normalize each new data point using the same coefficients. I suspect this is akin to estimating a linear trend, then removing it from the in-sample data, and then using the same linear model on unseen data to detrend it i the same manner. \n\nObviously, when I estimate the fourier coefficients, the vector I get out is equal to the length of the in-sample data. The out-of-sample data is comprised of much fewer observations, so directly applying them is impossible. \n\nIs this sort of analysis possible using this technique or am I going down a dead end road? How should I approach that using the code in the example above?\n    ", "Answer": "\r\nWhat you want to do is certainly possible, you are on the right track, but you seem to misunderstand a few points in the example. First, it is shown in the example that the technique is the equivalent of linear regression in the time domain, exploiting the FFT to perform in the frequency domain an operation with the same effect. Second, the trend that is removed is not linear, it is equal to a sum of sinusoids, which is why ```\nFFT```\n is used to identify particular frequency components in a relatively tidy way. \n\nIn your case it seems you are interested in the residuals. The initial approach is therefore to proceed as in the example as follows:\n\n(1) Perform a rough \"detrending\" by removing the DC component (the mean of the time-domain data)\n\n(2) FFT and inspect the data, choose frequency channels that contain most of the signal. \n\nYou can then use those channels to generate a trend in the time domain and subtract that from the original data to obtain the residuals. You need not proceed by using ```\nIFFT```\n, however. Instead you can explicitly sum over the cosine and sine components. You do this in a way similar to the last step of the example, which explains how to find the amplitudes via time-domain regression, but substituting the amplitudes obtained from the FFT.\n\nThe following code shows how you can do this:\n\n```\ntim = (time - time0)/timestep;  % <-- acquisition times for your *new* data, normalized\nNFpick = [2 7 13]; % <-- channels you picked to build the detrending baseline\n\n% Compute the trend\nmu = mean(ts);\ntsdft = fft(ts-mu);\nNchannels = length(ts);      % <-- size of time domain data\nMpick = 2*length(NFpick);\nX(:,1:2:Mpick) = cos(2*pi*(NFpick-1)'/Nchannels*tim)';\nX(:,2:2:Mpick) = sin(-2*pi*(NFpick-1)'/Nchannels*tim)';\n\n% Generate beta vector \"bet\" containing scaled amplitudes from the spectrum\nbet = 2*tsdft(NFpick)/Nchannels;\nbet = reshape([real(bet) imag(bet)].', numel(bet)*2,1)\ntrend = X*bet + mu;\n```\n\n\nTo remove the trend just do\n\n```\ndetrended = dat - trend; \n```\n\n\nwhere ```\ndat```\n is your new data acquired at times ```\ntim```\n. Make sure you define the time origin consistently. In addition this assumes the data is real (not complex), as in the example linked to. You'll have to examine the code to make it work for complex data.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform on .wav file gives weird results\r\n                \r\nI'm writing a frequency visualizer for .wav files. I'm using SDL to extract data from the file so i could do a Fast Fourier Transform to calculate the magnitude of each frequency.\n\nAs far as I can tell everything I give the FFT is correct, but the function is spitting weird results and I can't figure out why.\n\nWhen I don't do a windowing function before the Fourier transform I get a right result and then ~5 not right results which are close to 20000Hz and are seemingly random, so i can't predict what they were supposed to mean. I suspected this could be because of spectral leakage so i tried and ran a windowing function  before the transform but after that I get the same wrong frequency every iteration.\n\nNOTE: THIS IS WITHOUT A WINDOWING FUNCTION\n\nHere is a test when I run it with this audio https://www.youtube.com/watch?v=qNf9nzvnd1k:\n\n30 20480 20480 20470 20490 20480 20480 20470 x 20470 20480 20480 20480 20480 20480 20480 20480 20490 x 20480 20480 20480 20480 20480 20480 x x 20490 20480 20480 x x 20470 20480 x x 20480 20470 x 20480 x 20480 10 20480 20490 20480 x 20480 x 20480 20480 x 20480 x 20470 x\n\nThe x here would be the correct value which changes according to what is expected of it throughout the clip.\n\nMy problem is that I need a correct value every iteration, otherwise i get a sloppy animation.\n\nmain.cpp:\n\n```\n#include \"visualization.h\"\n#define FILE_PATH \"audiosamples/test.wav\" //https://www.youtube.com/watch?v=qNf9nzvnd1k\n#define PI 3.14159265359\n\n/*\nfreq = i * Fs / N;      (1)\nwhere,\nfreq = frequency in Hertz,\ni = index (position of DFT output or can also think of it as representing the number of cycles)\nFs = sampling rate of audio,\nN = size of FFT buffer or array.\n\nTo explain further, lets say that:\n\nN = 4096          //a buffer that holds 4096 audio data samples\nFs = 44100       //a common sample rate [frames per sec] for audio signals: 44.1 kHz\n\nThe spectral bin numbers aka frequency bins using equation (1) from above would be:\n\n    bin:      i      Fs         N            freq\n     0  :     0  *  44100 /  2048  =        0.0 Hz\n     1  :     1  *  44100 /  2048  =        21.5 Hz\n     2  :     2  *  44100 /  2048  =        43 Hz\n     3  :     3  *  44100 /  2048  =        64.5 Hz\n     4  :     ...\n     5  :     ...\n\n   1024 :    1024 * 44100 /  2048  =        22.05 kHz\n*/\n\nSDL *visualization = nullptr;\n\nUint8* sampData;\nSDL_AudioSpec wavSpec;\nSDL_AudioSpec obtained;\nUint8* wavStart;\nUint32 wavLength;\nSDL_AudioDeviceID aDevice;\ndouble arrSamples[4096];\ndouble max_magnitude_index;\n\n\nstruct AudioData {\n    Uint8* filePosition;\n    Uint32 fileLength;\n};\n\nvoid PlayAudioCallback(void* userData, Uint8* stream, int streamLength) {\n    AudioData* audio = (AudioData*)userData;\n    sampData = (Uint8*)stream;\n    double magnitude[4096];\n    fftw_complex x[4096], y[4096];\n    double max_magnitude = 0;\n\n    if (audio->fileLength == 0) {\n        return;\n    }\n\n    Uint32 length = (Uint32)streamLength;\n    length = (length > audio->fileLength ? audio->fileLength : length);\n    std::vector<double> samples (stream, stream + length);\n\n    for( int i = 0; i < 4095; i ++ ){\n        double multiplier = 0.5 * (1 - cos((2*PI*i)/4095));\n    //  x[i][REAL] = multiplier * (double)samples[i];\n        x[i][REAL] = (double)samples[i];\n        x[i][IMAG] = 0.0;\n    //  std::cout << i << \" - \" << x[i][REAL] << std::endl << std::flush;\n    }\n\n    fftw_plan plan = fftw_plan_dft_1d( 4096, x, y,  FFTW_FORWARD, FFTW_ESTIMATE );\n    fftw_execute(plan);\n\n    for( int i = 0; i < 4095; i ++ ){\n        if( y[i][IMAG] < 0 ){\n            magnitude[i] = sqrt( y[i][REAL] * y[i][REAL] + y[i][IMAG] * y[i][IMAG] );\n        }\n        else{\n            magnitude[i] = sqrt( y[i][REAL] * y[i][REAL] + y[i][IMAG] * y[i][IMAG] );\n        }\n    }\n    for( int i = 1; i < 4095; i ++ ){\n        if( magnitude[i] > max_magnitude ){\n            max_magnitude = magnitude[i];\n            max_magnitude_index = i;\n        }\n    }\n    int freq = max_magnitude_index * ( 44100 / 4096 );\n    if ( freq < 20000 ){\n        std::cout << freq << std::endl << std::flush;\n    }\n\n//  SDL_memcpy(&in, sampData, sizeof(sampData));\n    SDL_memcpy(stream, audio->filePosition, length);\n\n\n    audio->filePosition += length;\n    audio->fileLength -= length;\n\n}\n\nint main() {\n    int cnt = 0;\n\n    visualization = new SDL();\n    visualization -> init( \"asd\", 100, 0, 800, 400, false );\n    SDL_Init(SDL_INIT_AUDIO);\n\n    if (SDL_LoadWAV(FILE_PATH, &wavSpec, &wavStart, &wavLength) == NULL) {\n        std::cerr << \"Couldnt load file: \" << FILE_PATH << std::endl;\n        getchar();\n    }\n    std::cout << \"Loaded \" << FILE_PATH << std::endl;\n\n    AudioData audio;\n    audio.filePosition = wavStart;\n    audio.fileLength = wavLength;\n    wavSpec.samples = 4096;\n\n    wavSpec.callback = PlayAudioCallback;\n    wavSpec.userdata = &audio;\n\n\n    aDevice = SDL_OpenAudioDevice( NULL, 0, &wavSpec, &obtained, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE);\n    if (aDevice == 0) {\n        std::cerr << \"Audio Device connection failed: \" << SDL_GetError() << std::endl;\n        getchar();\n    }\n    SDL_PauseAudioDevice(aDevice, 0);\n\n    std::cout << obtained.samples << std::endl << std::flush;\n\n    while( visualization -> running () ){\n        visualization -> handleEvents();\n        visualization -> render();\n        cnt ++;\n        visualization -> update(max_magnitude_index, cnt);\n    }\n\n    visualization->clean();\n\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python Numpy FFT fast fourier transform - weird results\r\n                \r\nI am trying to get the phase distribution of a 2D aperture using FFT.\nThe input is a circle, where everything inside the circle has value 1, outside it has value 0.\nIn order to make a good transform, I use an input array that is 200x as large as the radius of the circle, and make a 5000x5000 grid out of it. This ensures that the circle is actually circular and there is enough room around in order that no Nyquist things happen.\n\nI need to 2D Fourier transform the aperture and then calculate the phase of the Fourier transform at every point.\nThe function I use for creating the input (aperture):\ncreating the input aperture\n\nNext do the numpy fft2 2D fourier transform:\nFourier transforming aperture\n\nAnd the result of this is a 2D complex array (as expected!), BUT with the imaginary parts so much much much smaller than the real parts (17 orders of magnitude difference imaginary parts ~10E-17).\nThis is not expected and most probably wrong. What went wrong?\n    ", "Answer": "\r\nThe FFT phase result of a perfectly symmetric input is zero, e.g. a strictly real result, thus atan2(Im,Re) == 0 , (imaginary components all zero, except for rounding noise).\n\n(even symmetry with respect to (0,0) circularly, or to (n/2,n/2))\n\nThe phase will become non-zero (thus a non-zero imaginary component in the FFT result) when the input is moved off center or otherwise made non-symmetric.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Create equally spaced data from sensor data to apply Fast Fourier Transform\r\n                \r\nI have the following sensor sample data:\n\n```\nTime(milliseconds)            Data\n------------------    -------------------\n0                     0.30865225195884705   \n60                    0.14355185627937317   \n100                  -0.16846869885921478   \n156                  -0.2458019256591797    \n198                  -0.19664153456687927\n258                   0.27148059010505676   \n305                  -0.16949564218521118   \n350                  -0.227480947971344 \n397                   0.23532353341579437   \n458                   0.20740140974521637\n```\n\n\nWhich means at time ```\n0```\n I have the value ```\n0.30865225195884705```\n and at time ```\n60```\n I have the value ```\n0.14355185627937317```\n and so on.\n\nAs it is observed, data are not equally spaced which means I have data at different time stamps. I need this because I will apply Fast Fourier Transform to this signals.\n\nAre there any methods or implementations so that I can create equally spaced data from my sensor data? (using MATLAB)\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Output Manipulation in Ruby\r\n                \r\nI am building a visual equalizer for audio and am confused what the output to my FFT is. My end goal is to send a simplified array of 6 numbers (1 bass, 4 mid-tones, and 1 treble) to an Arduino equipped with bluetooth.  The numbers will denote how many LEDs to light up in each column (1 column for bass, 1 column for treble, etc).\n\nThe first step is to change an audio signal into numerical representations.\nIn order to do that I want to combine certain frequencies into discrete buckets at regular time intervals, i.e. one for Bass that's 60 to 250 Hz.\n\nI've obtained a 300Hz wav file that I am trying to deconvolute using the ruby ```\nFFTW3```\n gem.  I would expect one sine wave that completes 300 periods over the course of a 1 second sample. When I pass in a 1s sample of a 300 Hz tone, the ```\nfft.length = 1024```\n and ```\nfft[0] = 22528```\n.  \n\nI have been using these conversations Audio Equalizer in Ruby, and Extract Fast Fourier Transform data from file as my main points of reference as the documentation for the ruby gem is confusing.\n\nHere's my code:\n\n```\nrequire \"ruby-audio\"\nrequire \"fftw3\"\nrequire \"narray\"\n\n# Audio sample rate and block size:\nSAMPLE_RATE = 44100\n# break the audio into chunks (called windows, or frames)\n# pass them sequentially to the FFT.\n# gives a frequency profile that changes over time\n# e.g. 1024, 2048, 4096, 8192, etc..\nWINDOW = 2048\n# samplerate/window => 44100/2048 = 10.7\n# Updates about 11 times/second\n# RESOLUTION = (1.0*SAMPLE_RATE/WINDOW)\n\nfilename = ARGV[0]\n\nwave = Array.new # length is window size/2\nfft = Array.new(WINDOW/2,[])\n\nbegin\n  # extracting audio from wav with ruby-audio\n  buf = RubyAudio::Buffer.float(WINDOW)\n  RubyAudio::Sound.open(filename) do |snd|\n    while snd.read(buf) != 0\n      wave.concat(buf.to_a)\n      na = NArray.to_na(buf.to_a)\n      fft_slice = FFTW3.fft(na).to_a[0, WINDOW/2]\\\n      # na = array to be transformed\n      j=0\n      fft_slice.each do |x|\n        # getting the real part of the complex number\n        x = x.abs\n        fft[j] << x; j+=1\n      end\n    end\n  end\n\nrescue => err\n    # log.error \"error reading audio file: \" + err\n    puts 'There was an error, exiting!'\n    exit\nend\n```\n\n\nAre the inner-most arrays denoting frequencies, and the outer representing time passing, or is it the other way around.  How do I know which array index represents a specific frequency? \n\nI am unsure of how to test this to see if it has accurately created the proper frequency. Is there a good way to look at the data that I've missed, visually or otherwise?\n\nThanks for any pointers!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for varying period (Order analysis)\r\n                \r\nI am trying to do a fast Fourier transformation on accelerometer data from a shaft rotating at varying speed. \n\nWhat I have done so far: \n\n1: The original plot was in the time domain, and I therefore did a order analysis (resampled), and got the following plot:\n\n\nThis plot shows the angular rotation plotted against amplitude.\n\n2: Now, an FFT was done with this code:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nclass FastFourierTransform:\n    # Amplitudes is a row vector\n    def __init__(self, amplitudes, t):\n        self.s = amplitudes\n        self.t = t\n\n    # Plotting in the input domain before fft\n    def plot_input(self):\n        plt.ylabel(\"Amplitude\")\n        plt.xlabel(\"Shaft angle [Radians]\")\n        plt.plot(self.t, self.s)\n        plt.margins(0)\n        plt.show()\n\n        '''\n        The second half of this array of fft sequence have similar frequencies\n        since the frequency is the absolute value of this value.\n        '''\n    def fft_transform(self):\n        mean_amplitude = np.mean(self.s)\n        self.s = self.s - mean_amplitude # Centering around 0\n        fft = np.fft.fft(self.s)\n\n        # We now have the fft for every timestep in out plot.\n\n        # T is the sample frequency in the data set\n        T = self.t[1] - self.t[0] # This is true when the period between each sample in the time waveform is equal\n        N = self.s.size  # size of the amplitude vector\n        f = np.linspace(0, 1 / T, N, )  # start, stop, number of. 1 / T = frequency is the bigges freq\n        plt.ylabel(\"Amplitude\")\n        plt.xlabel(\"Frequency [Hz]\")\n        y = np.abs(fft)[:N // 2] * 1 /N\n\n        # Cutting away half of the fft frequencies.\n\n        sns.lineplot(f[:N // 2], y) # N // 2 is normalizing it\n        plt.margins(0)\n        plt.show()\n        time = f[:N // 2]\n        return fft, time\n```\n\n\n3. Result, with the normalized amplitudes plotted:\n\n\nQuestions:\n\n\nDoes this thought process look correct?\nIs it correct to say that the final fft plot is in the frequency domain? From this link, http://zone.ni.com/reference/en-XX/help/372416L-01/svtconcepts/svcompfftorder/, it looks like the final plot domain should be in the order domain, but I am not sure since the fft was \ndone from the radian domain.\n\n\nVibration- Based Condition Monitoring of Wind Turbines by Tomasz Barszcz has this image \n\nThanks in advance.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Interpolation via Fast Discrete Fourier Transform with Chebyshev extreme points\r\n                \r\nI'm trying to interpolate a function at arbitrary points and I have the function values at Chebyshev extreme points. I use the real values from Fast Fourier Transform to compute the Chebyshev coefficients. Then I scale them with 2/N and then I use the polynomial library to evaluate the series of chebyshev polynomials at a set of points. This produces the wrong function approximation. Where am I going wrong?\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the number of \n# Chebyshev extreme points\nN = 10\n\n# Define the function to be \n# approximated\ndef f(x):\n   return x**2\n\n# Evaluate the function at the \n# Chebyshev extreme points\nx = np.cos(np.arange(N) * np.pi / N)\ny = f(x)\n\n# Compute the discrete Fourier \n# transform (DFT) of the function \n# values using the FFT algorithm\nDFT = np.fft.fft(y).real\n\n# Compute the correct scaling \n# factor\nscaling_factor = 2/N\n\n# Scale the DFT coefficients by \n# the correct scaling factor\nchebyshev_coefficients = scaling_factor * DFT\n\n# Use Chebval to \n# evaluate the approximated \n# polynomial at a set of points\nx_eval = np.linspace(-1, 1, 100)\ny_approx =  np.polynomial.chebyshev.chebval(x_eval, chebyshev_coefficients[::-1])\n\n# Plot the original function \n# and the approximated function\nplt.plot(x, y, 'o', \nlabel='Original function')\nplt.plot(x_eval, y_approx, '-', \nlabel='Approximated function')\nplt.legend()\nplt.show()\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "GSL Fast-Fourier Transform - Non-zero Imaginary for Transformed Gaussian?\r\n                \r\nAs an extension to this question that I asked. The Fourier transform of a real Gaussian is a real Gaussian. Now of course a DFT of a set of points that only resemble a Gaussian will not always be a perfect Gaussian, but it should certainly be close. In the code below I'm taking this [discrete] Fourier transform using GSL. Aside from the issue of the returned/transformed real components (outlined in linked question), I'm getting a weird result for the imaginary component (which should be identically zero). Granted, it's very small in magnitude, but its still weird. What is the cause for this asymmetric & funky output?\n\n```\n#include <gsl/gsl_fft_complex.h>\n#include <gsl/gsl_errno.h>\n#include <fstream>\n#include <iostream>\n#include <iomanip> \n\n#define REAL(z,i) ((z)[2*(i)]) //complex arrays stored as    [Re(z0),Im(z0),Re(z1),Im(z1),...]\n#define IMAG(z,i) ((z)[2*(i)+1])\n#define MODU(z,i) ((z)[2*(i)])*((z)[2*(i)])+((z)[2*(i)+1])*((z)[2*(i)+1])\n#define PI 3.14159265359\n\nusing namespace std;\n\nint main(){\n\n    int n = pow(2,9);\n    double data[2*n];\n    double N = (double) n;\n\n    ofstream file_out(\"out.txt\");\n\n    double xmin=-10.;\n    double xmax=10.;\n    double dx=(xmax-xmin)/N;\n    double x=xmin;\n\n    for (int i=0; i<n; ++i){\n        REAL(data,i)=exp(-100.*x*x);\n        IMAG(data,i)=0.;\n        x+=dx;\n    }\n\n    gsl_fft_complex_radix2_forward(data, 1, n); \n\n    for (int i=0; i<n; ++i){\n        file_out<<(i-n/2)<<\"    \"<<IMAG(data,((i+n/2)%n))<<'\\n';\n    }\n\n    file_out.close();\n}\n```\n\n\n\n    ", "Answer": "\r\nYour result for the imaginary part is correct and expected. \n\nThe difference to zero (10^-15) is less than accuracy that you give to pi (12 digits, pi is used in the FFT, but I'm can't know whether you are overriding the pi inside the routine). \n\nThe FFT of a real function is not in general  a real function. When you do the math analytically you integrate over the following expression: \n\n```\nf(t) e^{i w t} = f(t) cos wt  + i f(t) sin wt, \n```\n\n\nso only if the function f(t) is ```\nreal and even```\n will the imaginary part (which is otherwise odd) vanish during integration. This has little meaning though, since the real part and imaginary part have physical meaning only in special cases.\n\nDirect physical meaning is in the abs value (```\nmagnitude spectrum```\n), the abs. value squared (```\nintensity spectrum```\n) and the phase or angle (```\nphase spectrum```\n).  \n\nA more significant offset from zero in the imaginary part would happen if it wasn't centered at the center of your time vector. Try shifting the ```\nx```\n vector by some fraction of ```\ndx```\n. \n\nSee below how the shift of the input by dx/2 (right column) affects the imaginary part, but not the magnitude (example written in Python, Numpy).\n\n\n\n```\nfrom __future__ import division\nimport numpy as np\nimport matplotlib.pyplot as p\n%matplotlib inline\n\nn=512    # number of samples 2**9\nx0,x1=-10,10\ndx=(x1-x0)/n\n\nx= np.arange(-10,10,dx)  # even number, asymmetric range [-10, 10-dx]   \n\n#make signal\ns1= np.exp(-100*x**2) \ns2= np.exp(-100*(x+dx/2 )**2)\n\n#make ffts\nf1=np.fft.fftshift(np.fft.fft(s1))\nf2=np.fft.fftshift(np.fft.fft(s2))\n\n#plots\np.figure(figsize=(16,12))\np.subplot(421)\np.title('gaussian (just ctr shown)')\np.plot(s1[250:262])\np.subplot(422)\np.title('same, shifted by dx/2')\np.plot(s2[250:262])\n\np.subplot(423)\np.plot(np.imag(f1))\np.title('imaginary part of FFT')\np.subplot(424)\np.plot(np.imag(f2))\n\np.subplot(425)\np.plot(np.real(f1))\np.title('real part of FFT')\np.subplot(426)\np.plot(np.real(f2))\n\np.subplot(427)\np.plot(np.abs(f1))\np.title('abs. value of FFT')\np.subplot(428)\np.plot(np.abs(f2))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier cosine transform for poisson equation with all zero Neumann boundary condition\r\n                \r\nI am trying to solve Poisson equation in rectangular domain by using Fast Fourier Cosine transform with FFTW3 library.\n\nThe boundary condition of four sides is zero Neumann boundary condition.\n\n\nThe equation ```\nd^u/dx^2+d^2u/dy^2=-f```\n\nwith ```\nf=cos(x)+cos(y)```\n, domain ```\n[-pi pi,-pi pi]```\n\nexact solution is ```\nu=f```\n.\nfunction ```\nf```\n satisfy Neumann boundary condition.\nDrive the equation by using Fourier transform, we have:\n```\nU=F/(lamda(i)+lamda(j))```\n\nhere ```\nlamda(k)=2*(1-cos(i/(n0-1)))```\n\nand ```\nU```\n is invert transformed to get small ```\nu```\n.\n\n\nHowever, i still get wrong result compared with exact solution.\n\nCould you please help me? Thank you so much.\n\nHere is my code\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fftw3.h>\n#include <iostream>\n\nusing namespace std;\nint main() {\n\n    int n0=64;\n    int n1=64;\n\n    int N=n0*n1;\n\n    double pi = 3.14159265359;\n    double L  = 2.*pi;\n   double dx = L/(n0);\n\n    double *in1=new double [N];\n    double *in2=new double [N];\n    double *out1=new double [N];\n    double *out2=new double [N];\n    double *X=new double [N];\n    double *Y=new double [N];\n\n\n    fftw_plan p, q;\n    int i,j;\n    p = fftw_plan_r2r_2d(n0,n1, in1, out1, FFTW_REDFT00, FFTW_REDFT00, FFTW_ESTIMATE);\n    q = fftw_plan_r2r_2d(n0,n1, in2, out2, FFTW_REDFT00, FFTW_REDFT00, FFTW_ESTIMATE);\n\n    for(i = 0;i <n0;i++){\n        X[i] =-pi+i*dx ;\n        for(j = 0;j<n1;j++){\n            Y[j] = -pi+j*dx ;\n            in1[i*n0 + j]= cos(X[i]) + cos(Y[j]) ; // row major ordering\n        }\n    }\n\n    fftw_execute(p);\n\n    double *lamda=new double [n0];\n\n    for (i=0;i<n0;i++){\n        lamda[i]=cos(pi*i/(n0-1));\n    }\n\n    for ( i= 0; i< n0; i++){   // f = g / ( lamda(ii)+lamda(jj) )  \n        for( j = 0; j < n1; j++){\n\n            double fact=0;\n            in2[i*n0 + j]=0;\n\n            fact=2*(2-lamda[i]-lamda[j]);\n\n            if(fact!=0){\n                in2[i*n0 + j] = out1[i*n0 + j]/fact;\n            }else{\n                in2[i*n0 + j] =0;\n            }\n\n        }\n    }\n\n    fftw_execute(q);\n\n    double erl1 = 0.;\n    for ( i = 0; i < n0; i++) {\n        for( j = 0; j < n1; j++){\n\n            cout<< i <<\" \"<< j<<\" \"<< cos(X[i])+cos(Y[j])<<\" \"<<  dx*dx*out2[i*n0+j]/(2.*(double)(n0-1))/(2.0*(double)(n1-1)) <<\" \"<< endl; \n\n        }\n    }\n\n    fftw_destroy_plan(p); fftw_destroy_plan(q); fftw_cleanup();\n    delete [] in1;\n    delete [] in2;\n    delete [] out1;\n    delete [] out2;\n    delete [] X;\n    delete [] Y;\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform and Clustering of Time Series\r\n                \r\nI'm making a project connected with identifying dynamic of sales. That's how the piece of my database looks like http://imagizer.imageshack.us/a/img854/1958/zlco.jpg. There are three columns:\n\nProduct - present the group of product \n\nWeek - time since launch the product (week), first 26 weeks \n\nSales_gain - how the sales of product change by week\n\nIn the database there is 3302 observations = 127 time series\n\nMy aim is to cluster time series in groups which are going to show me different dynamic of sales. Before clustering I want to use Fast Fourier Transform to change time series on vectors and take into consideration amplitude etc and then use a distance algorithm and group products. \n\nIt's my first time I deal with FFT and clustering, so I would be grateful if anybody would point steps, which I have to do before/after using FFT to group dynamics of sales. I want to do all steps in R, so it would be wonderful if somebody type which procedures should I use to do all steps.\n\nThat's how my time series look like now http://imageshack.com/a/img703/6726/sru7.jpg \n\nPlease note that I am relatively new to time series analysis (that's why I cannot put here my code) so any clarity you could provide in R or any package you could recommend that would accomplish this task efficiently would be appreciated.\n\nP.S. Instead of FFT I found the code for DWT here -> www.rdatamining.com/examples/time-series-clustering-classification but cannot use it on my data base and time series (suggest R to analyze new time series after 26 weeks). Can sb explain it to me?\n    ", "Answer": "\r\nYou may have too little data for FFT/DWT to make sense. DTW may be better, but I also don't think it makes sense for sales data - why would there be a x-week temporal offset from one location to another? It's not as if the data were captured at unknown starting weeks.\n\nFFT and DWT are good when your data will have interesting repetitive patterns, and you have A) a good temporal resolution (for audio data, e.g. 16000 Hz - I am talking about thousands of data points!) and B) you have no idea of what frequencies to expect. If you know e.g. you will have weekly patterns (e.g. no sales on sundays) then you should filter them with other algorithms instead.\n\nDTW (dynamic time-warping) is good when you don't know when the event starts and how they align. Say you are capturing heart measurements. You cannot expect to have the hearts of two subjects to beat in synchronization. DTW will try to align this data, and may (or may not) succeed in matching e.g. an anomaly in the heart beat of two subjects. In theory...\n\nMaybe you don't need specialized time methods here at all.\n\nA) your data has too low temporal resolution\n\nB) your data is already perfectly aligned\n\nMaybe all you need is spend more time in preprocessing your data, in particular normalization, to be able to capture similarity.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in Python\r\n                \r\nI am new to the fourier theory and I've seen very good tutorials on how to apply fft to a signal and plot it in order to see the frequencies it contains. Somehow, all of them create a mix of sines as their data and i am having trouble adapting it to my real problem. \n\nI have 242 hourly observations with a daily periodicity, meaning that my period is 24. So I expect to have a peak around 24 on my fft plot.\n\nA sample of my data.csv is here:\nhttps://pastebin.com/1srKFpJQ\n\nData plotted:\n\n\n\nMy code:\n\n```\ndata = pd.read_csv('data.csv',index_col=0)\ndata.index = pd.to_datetime(data.index)\ndata = data['max_open_files'].astype(float).values\n\nN = data.shape[0] #number of elements\nt = np.linspace(0, N * 3600, N) #converting hours to seconds\ns = data\n\nfft = np.fft.fft(s)\nT = t[1] - t[0]\n\nf = np.linspace(0, 1 / T, N)\nplt.ylabel(\"Amplitude\")\nplt.xlabel(\"Frequency [Hz]\")\nplt.bar(f[:N // 2], np.abs(fft)[:N // 2] * 1 / N, width=1.5)  # 1 / N is a normalization factor\nplt.show()\n\n```\n\n\nThis outputs a very weird result where it seems I am getting the same value for every frequency.\n\n\n\nI suppose that the problems comes with the definition of N, t and T but I cannot find anything online that has helped me understand this clearly. Please help :)\n\nEDIT1:\n\nWith the code provided by charles answer I have a spike around 0 that seems very weird. I have used ```\nrfft```\n and ```\nrfftfreq```\n instead to avoid having too much frequencies.\n\n\n\nI have read that this might be because of the DC component of the series, so after substracting the mean i get:\n\n\n\nI am having trouble interpreting this, the spikes seem to happen periodically but the values in Hz don't let me obtain my 24 value (the overall frequency). Anybody knows how to interpret this ? What am I missing ?\n    ", "Answer": "\r\nThe problem you're seeing is because the bars are too wide, and you're only seeing one bar. You will have to change the width of the bars to 0.00001 or smaller to see them show up.\n\nInstead of using a bar chart, make your x axis using ```\nfftfreq = np.fft.fftfreq(len(s))```\n and then use the plot function, ```\nplt.plot(fftfreq, fft)```\n:\n\n```\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\ndata = pd.read_csv('data.csv',index_col=0)\ndata.index = pd.to_datetime(data.index)\ndata = data['max_open_files'].astype(float).values\n\nN = data.shape[0] #number of elements\nt = np.linspace(0, N * 3600, N) #converting hours to seconds\ns = data\n\nfft = np.fft.fft(s)\nfftfreq = np.fft.fftfreq(len(s))\n\nT = t[1] - t[0]\n\nf = np.linspace(0, 1 / T, N)\nplt.ylabel(\"Amplitude\")\nplt.xlabel(\"Frequency [Hz]\")\nplt.plot(fftfreq,fft)\nplt.show()\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "python scipy.fft huge y scale of Fast Fourier Transform\r\n                \r\nI have a working python script for Fast Fourier Transform (fft) signal which plots the graph and fft correctly, I am fetching data from postgre so I ommited that code.\nAnd due to limit of paste i pasted shorter version of signal, but the signal is preatty much the similar on longer timeframe.\nThe x scale of fft is fine, but what i get is a large y scale which i do not understand.\nI have an fft processed by machine directly that looks correct and i have another measurement done by hand held machine. The ffts look almost identical on x scale and relative sizes on y scale, but the actual calculated y scale differ a lot.\ndata\nplot from python\nfrom device\nIn script data_step is in micro second between two timestamps.\nThe n and datastep cant be wrong since the x axis is fine.\nFrom the data i get:\n```\nMin of signal(value_points_sensor1): -0.057881687\n\nMax of signal: 0.07810274\n\nMax of fft y: 5522.93\n```\n\nShouldnt the  size  of fft be similar to size of amplitude of signal? Also arent the unit of amplitude on fft and signal on y axis the same?\n```\nimport matplotlib.pyplot as plt\nfrom scipy.fft import rfft, rfftfreq, irfft\nimport numpy as np\n\nfigure, axis = plt.subplots(2, 1)\nplt.subplots_adjust(hspace=1)\n    \ntime_points_sensor1 = np.array(row[4])\nvalue_points_sensor1 = np.array(row[3])\n    \naxis[0].plot(time_points_sensor1, value_points_sensor1)\n\n   \nn  = len(row[2])\ndata_step = (abs((int(row[2][-2] - row[2][-1]))) / 1000000)\n\nyf = rfft(value_points_sensor1)\nxf = rfftfreq(n,data_step)\n\naxis[1].plot(xf,abs(yf))\n    \nplt.show()\n```\n\n    ", "Answer": "\r\nThe value of rfft is proportional both to the magnitude of the data and the number of points.  So you should expect the values in ```\nyf```\n to be large.\nCompare:\n```\n# One cycle of a cosine curve\nx = rfft(np.cos(np.linspace(0, 2 * np.pi, 1000)))\nmax(abs(x))\n500.2493021844711\n\n# Two cycles of a cosine curve, again 1000 points per cycle\nx = rfft(np.cos(np.linspace(0, 4 * np.pi, 2000)))\nmax(abs(x))\n1000.2484171710441\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "correct ordering of array for numpy fast Fourier transform\r\n                \r\nI am trying to implement a simple version of the immersed boundary method for fluid-structure interactions in a periodic domain using the fast Fourier transform. This is done by first setting a force on the fluid, taking its FFT, solving a series of matrix equations, and taking the inverse FFT to recover the solution to the matrix system in the real domain. I am currently getting very strange results, and I think it might be because the solutions in Fourier space (u_hat, v_hat, p_hat) are not ordered correctly for the numpy ifft2 function, but I don't know how to fix that. I'd appreciate any help!\nEdit: the idea is that given f, g, we want to find u, v, p. The algorithm is to take the fft in 2D of f and g, use that to compute the fft of u, v, and p, and then take the inverse fft to recover the real u, v, p. I've added the specific function relating f_hat, g_hat and u_hat, v_hat, p_hat.\nEdit2: what I'd really like to know is how to order an arbitrary array so that it can be passed to the numpy ifft2 function, which requires the following: input should have the term for zero frequency in the low-order corner of the two axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of both axes, in order of decreasingly negative frequency.\n```\n   N = 20   # Number of cartesian grid points\n   l = 1.0     # Length of domain\n   dx = l / N     # Grid step size\n   mu = 8.9 * 10**(-4) \n\n   f_hat = np.fft.fft2(f)    # Fourier transform of x component of the force\n   g_hat = np.fft.fft2(g)    # Fourier transform of y component of the force \n\n   u_hat = np.zeros((N, N), dtype=np.complex)\n   v_hat = np.zeros((N, N), dtype=np.complex)\n   p_hat = np.zeros((N, N), dtype=np.complex)\n   \n   for k in range(0, N):\n       for m in range(0, N):\n           if k == 0 and m == 0:\n               u_hat[k,m] = 0.0\n               v_hat[k,m] = 0.0 \n               p_hat[k,m] = 0.0\n           else:\n               u_hat[k,m], v_hat[k,m], p_hat[k,m] = fluid_system(k, m, N, dx, mu, f_hat[k,m], g_hat[k,m])\n   \n   # Take inverse Fourier transform to get u and p  \n   u = np.real((np.fft.ifft2(u_hat))).reshape((len(x),1))\n   v = np.real((np.fft.ifft2(v_hat))).reshape((len(x),1))\n   p = np.real(np.fft.ifft2(p_hat))\n\ndef fluid_system(l, m, N, h, mu, fft_f, fft_g):\n   L = - 4.0 / (h**2) * ((np.sin(np.pi * l / N))**2 + (np.sin(np.pi * m / N))**2)\n   D_l = - 1j / h * np.sin(2.0 * np.pi * l / N)\n   D_m = - 1j / h * np.sin(2.0 * np.pi * m / N)\n   A = np.zeros((3,3), dtype=np.complex)\n   A[0,0] = mu * L\n   A[0,2] = - D_l\n   A[1,1] = mu * L\n   A[1,2] = - D_m\n   A[2,0] = D_l\n   A[2,1] = D_m\n   b = np.zeros((3,1), dtype=np.complex)\n   b[0] = fft_f\n   b[1] = fft_g\n   res = (np.linalg.solve(A, b)).ravel()\n   return res \n\n\n\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to get pitches from a wav buffer in JAVA - Fast Fourier Transform\r\n                \r\nI am new to signal processing and am trying to detect the pitches in a wav file. I generated a 2-channel wav file that plays 3 distinct notes in 1 second. I was able to read the wave using a class a java and have a double array: \n\n```\n-0.12847900390625\n-0.161651611328125\n-0.161651611328125\n-0.1907958984375\n-0.1907958984375\n-0.215179443359375\n-0.215179443359375\n       .\n       .\n       .\n```\n\n\nI was to get the notes that are being played in the double array. I have googled around and believe a Fast Fourier Transform is the way to go. However, I am a bit unsure what this Transformation does. \n\nDoes FFT return the frequency at a given time period? \n\nAny help is appreciated. Thankyou \n    ", "Answer": "\r\nThe Discrete Fourier Transform is used to map any discrete time-domain signal into frequency domain to reduce computation while performing operations like  convolution, co-relation etc since it is easier to compute in frequency domain and take the inverse transform and convert back into time domain compared to direct operation in time domain.\nFFT is the simpler algorithmic implementation of DFT with reduced time complexity of  ```\nO(nlogn)```\ncompared to time complexity of DFT ```\nO(n^2)```\n.\n\nYou can find more details here:\n\nhttp://www.dspguide.com/ch12/2.htm\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Picking up high frequency in fast fourier transform and inverse fourier transforms\r\n                \r\nGiven a function f(t) and its second derivative, ddf(t)==g(t), I am interested in how their Fourier transforms relate. Mathematically speaking, noting F(w) and G(w) the transforms of f(t) and g(t) respectively, we should have\nG(w) = -w^2F(w)\nI wanted to investigate this numerically in Python and I am hitting the common roadblocks that I never completely understood in the Gibbs effect, and ringing effects when handling discrete fourier transforms. Below is the mwe python code snippet I was working with.\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, ifft\nt=np.linspace(-5,5,100)\ndt=t[1]-t[0]\nw=fftfreq(len(t),dt)\na=3.0\n\n#some sigmoid function\nf=1/(1+np.exp(-a*t))\nplt.plot(f)\nFw=fft(f) #its fourier transform\n\nplt.plot(np.real(4*np.pi*np.pi*ifft(-Fw*w*w))) #The ifft/fft way of computing the     second derivative\nplt.plot(np.gradient(np.gradient(f))/dt**2) #the finite difference way of computing     the second derivative\n\nplt.ylim(-2,2)\nplt.legend(['f(t)',r'ifft(fft(-$\\omega^2$F[$\\omega$]))]','ddf(t)'], fontsize=15)\n```\n\nThis is the result of this code snippet\nComputing the second derivative as the inverse transform of -F[w]*w^2 should in principle yield the second derivative of f(t). But I am picking up extremely large weights at either end of my time scale, and there is a high frequency ringing on top of my signal.\nI am aware this might originate from rounding issues in frequency space or improperly binned frequencies, but I do not know how to correct these issues and do not fully understand them. The results do not depend on how fine-grained the time axis is.\nAny help appreciated\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "GSL Fast-Fourier Transform - Double-Valued Gaussian?\r\n                \r\nAll I want to do is evaluate the Fourier transform of a Gaussian (as a test of course), but I'm getting what looks like a double-valued function, as can be seen in the plot below. When you look closely at the tails of the Gaussian, you can see that the FFT returned values are actually oscillating between positive and negative, making the DFT look \"double-valued\". Why is this happening? Is there a way to fix this (without just plotting the complex modulus of course)?\n\n```\n#include <gsl/gsl_fft_complex.h>\n#include <gsl/gsl_errno.h>\n#include <fstream>\n#include <iostream>\n#include <iomanip> \n\n#define REAL(z,i) ((z)[2*(i)]) //complex arrays stored as    [Re(z0),Im(z0),Re(z1),Im(z1),...]\n#define IMAG(z,i) ((z)[2*(i)+1])\n#define MODU(z,i) ((z)[2*(i)])*((z)[2*(i)])+((z)[2*(i)+1])*((z)[2*(i)+1])\n#define PI 3.14159265359\n\nusing namespace std;\n\nint main(){\n\n    int n = pow(2,9);\n    double data[2*n];\n    double N = (double) n;\n\n    ofstream file_out(\"out.txt\");\n\n    double xmin=-10.;\n    double xmax=10.;\n    double dx=(xmax-xmin)/N;\n    double x=xmin;\n\n    for (int i=0; i<n; ++i){\n        REAL(data,i)=exp(-100.*x*x);\n        IMAG(data,i)=0.;\n        x+=dx;\n    }\n\n    gsl_fft_complex_radix2_forward(data, 1, n); \n\n    for (int i=0; i<n; ++i){\n        file_out<<(i-n/2)<<\"    \"<<REAL(data,((i+n/2)%n))<<'\\n';\n    }\n\n    file_out.close();\n}\n```\n\n\n\n    ", "Answer": "\r\nYou are plotting just the real component, e.g. the even or cosine component.  Note that a cosine wave of integer frequency N toggles between being -1 in the middle and to being 1 in the middle, as N increases from an odd number to an even number.  Thus any noise in the middle of the input to a DFT window can cause various real components in the DFT result to toggle (unless that noise is exactly orthogonal to all those DFT basis vectors) .\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "OpenCV / C++ - Convert image to vector of doubles for FFT (Fast Fourier Transform)\r\n                \r\nI'm trying to compute the FFT (Fast Fourier Transform) of an image to use the frequencies to determine whether or not the image is blurry.\n\nI need to use a custom FFT algorithm that we already have in our codebase. The FFT algorithm requires a standard 1D vector of ```\ndoubles```\n or ```\nints```\n. I need a way to read in an image and then convert it to a vector of doubles so that I can compute the FFT of the image. \n\nI have tried the following:\n\n```\ncv::Mat inputImage = cv::imread(\"testImage.png\");\ncv::Mat fImage; \n\ninputImage.convertTo(fImage, CV_32F); \nstd::vector<double> actualImage = fImage.clone();\n```\n\n\nHowever, I am getting the error:\n\n\n  \n    OpenCV Error: Assertion failed (channels() == CV_MAT_CN(dtype)) in copyTo,\n  \n\n\nAny ideas to how I can achieve this? \n    ", "Answer": "\r\n```\nCV_32F```\n means ```\nfloat```\n, not ```\ndouble```\n. You should use ```\nCV_64F```\n instead.\n\nYou also need to specify the number of channels. This example is for 1 channel image (grayscale), and probably what you need:\n\n```\n// Load the image\ncv::Mat inputImage = cv::imread(\"testImage.png\");\n// Convert to single channel (grayscale)\ncv::cvtColor(inputImage, inputImage, cv::COLOR_BGR2GRAY);\n\n// Or directly load as grayscale    \n// cv::Mat inputImage = cv::imread(\"testImage.png\", cv::IMREAD_GRAYSCALE);\n\n// Convert to double\ncv::Mat fImage; \ninputImage.convertTo(fImage, CV_64F); \n\n// Initialize the vector with the image content\nstd::vector<double> actualImage(fImage.begin<double>(), fImage.end<double>());\n```\n\n\nFor 3 channels you can do:\n\n```\ncv::Mat inputImage = cv::imread(\"testImage.png\");\ncv::Mat fImage; \n\ninputImage.convertTo(fImage, CV_64F); \nfImage = fImage.reshape(1); // You need to reshape to single channel\nstd::vector<double> actualImage(fImage.begin<double>(), fImage.end<double>());\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how to execute a fast fourier transform in a loss function for neural network training\r\n                \r\nI'm currently working on a fully convolutional neural network (image in, image out) and i'm trying to implement a loss function that does the fast fourier transform of the 2 images before doing some operation on them, the code is like this\n```\ndef fourierLoss2(y_actual,y_pred):\n  actual_fft = tf.signal.rfft3d(y_actual)\n  pred_fft = tf.signal.rfft3d(y_pred)\n  lossV=tf.math.real(tf.math.reduce_mean(tf.math.square(actual_fft-pred_fft)))\n  return lossV\n\nwith strategy.scope():\n  model = hd_unet_model(INPUT_SIZE)\n  model.compile(optimizer=Adam(lr=0.1),\n                loss= fourierLoss2,\n                metrics=tf.keras.metrics.MeanSquaredError())\n```\n\nthe 2 tensors (y_actual,y_pred) have type float.\nbut if i try to train the model i get the following error\n```\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:806 train_function  *\n        return step_function(self, iterator)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:796 step_function  **\n        outputs = model.distribute_strategy.run(run_step, args=(data,))\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/distribute_lib.py:1211 run\n        return self._extended.call_for_each_replica(fn, args=args, kwargs=kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/distribute_lib.py:2585 call_for_each_replica\n        return self._call_for_each_replica(fn, args, kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/mirrored_strategy.py:585 _call_for_each_replica\n        self._container_strategy(), fn, args, kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/mirrored_run.py:96 call_for_each_replica\n        return _call_for_each_replica(strategy, fn, args, kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/mirrored_run.py:237 _call_for_each_replica\n        coord.join(threads)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/training/coordinator.py:389 join\n        six.reraise(*self._exc_info_to_raise)\n    /usr/local/lib/python3.6/dist-packages/six.py:703 reraise\n        raise value\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/training/coordinator.py:297 stop_on_exception\n        yield\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/mirrored_run.py:323 run\n        self.main_result = self.main_fn(*self.main_args, **self.main_kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:789 run_step  **\n        outputs = model.train_step(data)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:757 train_step\n        self.trainable_variables)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:2722 _minimize\n        gradients = tape.gradient(loss, trainable_variables)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/eager/backprop.py:1073 gradient\n        unconnected_gradients=unconnected_gradients)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/eager/imperative_grad.py:77 imperative_grad\n        compat.as_str(unconnected_gradients.value))\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/eager/backprop.py:151 _gradient_function\n        grad_fn = ops._gradient_registry.lookup(op_name)  # pylint: disable=protected-access\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/framework/registry.py:97 lookup\n        \"%s registry has no entry for: %s\" % (self._name, name))\n\n    LookupError: gradient registry has no entry for: RFFT3D\n```\n\nAfter some research i understood that the problem is that the operation tf.signal.rfft3d does not have a registered gradient function.\nDoes anybody know a way to get around this problem?\n    ", "Answer": "\r\nI have found out a solution to the problem, instead of using ```\ntf.signal.rfft3d```\n i had to use ```\ntf.signal.fft3d```\n, this function has an entry for the gradient and works in a loss function, the downside is that now i had to convert the float tensors to complex type before the fourier trasform\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in processing of an input signal from Arduino\r\n                \r\nI have been trying to get audio signal from an arduino microphone. First I setup my arduino in Free Running Mode, and then I wait for a message from Processing that is a capital A. When Processing sends the serial signal, my arduino should send back 16 audio amplitude samples. Then, processing should take those 16 audio samples and pass them by the Fast Fourier Transform in orden to get a real time frequency spectrum. However, it seems that my Arduino never detects the capital A, and also, if I try to send the samples from my Arduino without waiting for the capital A, when Processing gets the samples it seems something went wrong with the serial communication. I tried with many arduinos and different serial cables to be sure it was no the problem. Here you are the arduino code: \n\n```\n// Arrays to save our results in\n\nint values[16];\n\n\n// Define various ADC prescaler\nconst unsigned char PS_16 = (1 << ADPS2);\nconst unsigned char PS_32 = (1 << ADPS2) | (1 << ADPS0);\nconst unsigned char PS_64 = (1 << ADPS2) | (1 << ADPS1);\nconst unsigned char PS_128 = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);\n\n// Setup the serial port and pin 2\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(2, INPUT);\n\n  // set up the ADC\n  ADCSRA &= ~PS_128;  // remove bits set by Arduino library\n\n  // you can choose a prescaler from above.\n  // PS_16, PS_32, PS_64 or PS_128\n  ADCSRA |= PS_64;    // set our own prescaler to 64 \n\n}\n\n\nvoid loop() {  \n  unsigned int i;\n\n  for(i=0;i<16;i++) {\n      values[i] = analogRead(2);\n\n  }\n\n  if(Serial.available() > 0) {\n\n    char c = Serial.read();\n    if(c == 'A') { \n      for(i=0;i<16;i++) {\n        Serial.println(values[i]);\n      }\n    }\n  }\n  delay(10);\n}\n```\n\n\nHere you are the processing code: \n\n```\nimport processing.serial.*;\nimport ddf.minim.analysis.*;\nFFT fft;\n\nSerial myPort;  // Create object from Serial class\n\nvoid setup() \n{\n\n  String portName = Serial.list()[0];\n  myPort = new Serial(this, portName, 115200);\n  size(800, 600);\n  background(255);\n  fft = new FFT(16, 16000);\n\n\n}\n\n\nString mensaje;\n\nfloat[] magnitudes = new float[16];\nint contador = 0;\nbyte request = true;\nvoid draw()\n{\n\n  if(request) {\n     myPort.write('A');//Solicita nuevos datos.\n     request = false;\n  } \n  while(!request) { \n    if(myPort.available()>0) {\n       mensaje = myPort.readStringUntil(13);\n       print(\" mensaje: \"+mensaje);\n       if(mensaje != null){\n         magnitudes[contador++] = int(mensaje);\n       }\n    }\n    if(contador >= 15) {\n      contador=0;\n      fft.forward(magnitudes);\n      request = true; \n      fill(100);\n      rect(0,0,800,800);\n      for (int i = 0; i < 15; i++) { \n         fill(200);\n         rect(i*30+10, 0, 10, fft.getBand(i) * 0.1);\n      }\n    }\n  }\n}\n```\n\n\nThank you a lot for your attention!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform(FFT) - problem with fourier resolution\r\n                \r\nI have been working quite a bit with fourier transforms in python the last couple of days.\nI have discovered that in order to accurately capture known periods of incoming data, the resolution or spacing of the x-axis (1/n_samples) has to be sufficiently small. Typically this is done by zero-padding the incoming data. (I have also tried windowing, but with no additional effect)\nI have an issue related to this: I have specified that i have a period of 128 in a dataseries of 500. I.e. a frequency of 0.0078125. In order to find the correct peak at 0.0078125 in my fft, i need a resolution that is <<0.0078125, which I have made sure of. I am however missing my peak of 0.0078125 by quite a bit. And in the period-axis, the result is even more obvious. Is there anyone who can help me understand why?\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Flat lines in Fast Fourier Transform using numpy\r\n                \r\nI have data of 500 years with data point for every year.\nThe data in numpy array is here\n\nLooking at the data there is a clear signal of 100 years, however, when I'm doing the Fourier transform I get two flat lines in the plot which I can't understand why they are there.\n\nThe plot looks like that:\n\n\n\nThe code I'm using is:\n\n```\nimport numpy as np\nfrom scipy.fftpack import fft, rfft, fftfreq\nimport pylab as plt\n\nsig = np.load('fft.npy')\nsig = sig.squeeze()/(80*60) # Grid scaling\nx = np.arange(1,501,1)\n\nW = fftfreq(sig.size, d=(x[1]-x[0]))\n\nplt.figure(figsize=(7,3.5))\nplt.subplot(2,1,1)\nplt.plot(x,sig)\nplt.xlabel('Time (years)')\n\nf_sig = fft(sig)\nplt.subplot(2,1,2)\nplt.plot(W, abs(f_sig)**2)\nplt.xlabel('Frequency (1/year)')\n\nplt.xscale('log')\nplt.yscale('log')\nplt.xlim(10**(-3), 1)\nplt.show()\n```\n\n\nWhy there are two flat lines on the frequency plot? Why don't I see clearly the 100 yr frequency?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to apply data parallelim on haskell Fast Fourier Transformation?\r\n                \r\nI have a haskell code to resolve a Fast Fourier Transformation, and i want to apply data parallelism on it. However, every strategy that i use generate too many sparks and most of them are being overflowed.\n\nDoes anyone have any idea on how to apply a good data parallelism strategy on the following algorithm:\n\n```\n-- radix 2 Cooley-Tukey FFT\n\nfft::[Complex Float] -> [Complex Float]\nfft [a] = [a]\nfft as = interleave ls rs\n  where\n    (cs,ds) = bflyS as\n    ls = fft cs\n    rs = fft ds\n\ninterleave [] bs = bs\ninterleave (a:as) bs = a : interleave bs as\n\nbflyS :: [Complex Float] -> ([Complex Float], [Complex Float])\nbflyS as = (los,rts)\n  where\n    (ls,rs) = halve as\n    los = zipWith (+) ls rs\n    ros = zipWith (-) ls rs\n    rts = zipWith (*) ros [tw (length as) i | i <- [0..(length ros) - 1]]\n\nhalve as = splitAt n' as\n  where\n    n' = div (length as + 1) 2\n\n-- twiddle factors\ntw :: Int -> Int -> Complex Float\ntw n k = cis (-2 * pi * fromIntegral k / fromIntegral n)\n```\n\n\nPAR MONAD\n\nThe answer from leftaroundabout helped me a lot about understanging on how to apply data parallelism on the code. However, i have studied the par monad and tried to apply task parallelism to it. The problem is that it is running way slower than the original bflyS. I think the code i developed is way to expensive to create threads comparing to the relative work I am doing. Does anyone know how to use the par monad in a better way ?\n\n```\n--New Task Parallelism bflyS\n\nbflySTask :: [Complex Float] -> ([Complex Float], [Complex Float])\nbflySTask as = runPar $ do\n    let (ls, rs) = halve as\n    v1<-new\n    v2<-new\n    let ros = DATA.zipWith (-) ls rs\n    let aux = DATA.map  (tw n) [0..n-1]\n    fork $ put v1 (DATA.zipWith (+) ls rs)\n    fork $ put v2 (DATA.zipWith (*) ros aux)\n    los <- get v1\n    rts <- get v2   \n    return (los, rts)\n        where\n                n = DATA.length as\n```\n\n    ", "Answer": "\r\nFirst off: there's a lot of optimisation to be done here before I'd start to think about parallelism:\n\n\nLists rock, but their non-consecutive memory model means they just can't allow for traversals nearly as fast as what you can achieve with tight arrays such as ```\nData.Vector```\n, because you inevitably end up with lots of cache misses. Indeed I've seldom seen a list-based algorithm to gain much from parallelisation, because they're bound by memory- rather than CPU performance.\nYour twiddle factors are computed over and over again, you can obviously gain a lot through memoisation here.\nYou keep on calling ```\nlength```\n, but that's an extremely wasteful function (O (n) for something that could be O (1)). Use some container that probably handles length; lists aren't meant to (we like to keep their ability to be infinite).\n\n\nThe parallelisation itself will be pretty simple; I'd check on the length as suggested by John L, indeed I'd rather require a pretty large size before sparking a thread, at least something like 256: as the performance probably becomes crucial only at sizes of several thousands, this should sill be enough threads to keep your cores busy.\n\n```\nimport Data.Vector.Unboxed as UBV\nimport Control.Parallel.Strategies\n\ntype ℂ = Complex Float\n\nfft' :: UBV.Vector ℂ -> UBV.Vector ℂ\nfft' aₓs = interleave lᵥs rᵥs\n where (lᵥs, rᵥs) = (fft lₓs, fft rₓs)\n                     `using` if UBV.length aₓs > 256 then parTuple2 else r0\n       (lₓs, rₓs) = byflyS aₓs\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "scipy Fast fourier transform doesn't recognize the signal\r\n                \r\ni'm trying to get the frequency of a signal via fourier transform but it's not able to recognize it (sets the peak to f=0). Maybe something is wrong in my code (FULL reprudible code at the end of the page):\n```\nPF = fft.fft(Y[0,:])/Npoints #/Npoints to get the true amplitudes\nZF = fft.fft(Y[1,:])/Npoints\nfreq = fft.fftfreq(Npoints,deltaT)\nPF = fft.fftshift(PF) #change of ordering so that the frequencies are increasing\nZF = fft.fftshift(ZF)\nfreq = fft.fftshift(freq)\nplt.plot(freq, np.abs(PF))\nplt.show()\nplt.plot(T,Y[0,:])\nplt.show()\n```\n\nwhere Npoints is the number of intervals (points) and deltaT is the time spacing of the intervals. You can see that the peak is at f=0\n\nI show also a plot of Y[0,:] (my signal) over time where it's clear that the signal has a characteristic frequency\n\nFULL REPRUDICIBLE CODE\n```\nimport numpy as np \nimport matplotlib.pyplot as plt\n#numerical integration\nfrom scipy.integrate import solve_ivp\nimport scipy.fft as fft\n\nr=0.5\ng=0.4\ne=0.6\nH=0.6\nm=0.15\n#define a vector of K between 0 and 4 with 50 componets\nK=np.arange(0.1,4,0.4)\n\ntsteps=np.arange(7200,10000,5)\nNpoints=len(tsteps)\ndeltaT=2800/Npoints #sample spacing\nfor k in K :\n    i=0\n    def RmAmodel(t,y):\n        return [r*y[0]*(1-y[0]/k)-g*y[0]/(y[0]+H)*y[1], e*g*y[0]/(y[1]+H)*y[1]-m*y[1]]\n\n    sol = solve_ivp(RmAmodel, [0,10000], [3,3], t_eval=tsteps) #t_eval specify the points where the solution is desired\n    T=sol.t\n    Y=sol.y\n    vk=[]\n    for i in range(Npoints):\n        vk.append(k)\n    XYZ=[vk,Y[0,:],Y[1,:]]\n    #check periodicity over P and Z with fourier transform\n\n    \n    \n#try Fourier analysis just for the last value of K        \n    PF = fft.fft(Y[0,:])/Npoints #/Npoints to get the true amplitudes\n    ZF = fft.fft(Y[1,:])/Npoints\n    freq = fft.fftfreq(Npoints,deltaT)\n    PF = fft.fftshift(PF) #change of ordering so that the frequencies are increasing\n    ZF = fft.fftshift(ZF)\n    freq = fft.fftshift(freq)\n    plt.plot(T,Y[0,:])\n    plt.show()\n    plt.plot(freq, np.abs(PF))\n    plt.show()\n```\n\n    ", "Answer": "\r\nI can't pinpoint where the problem is. It looks like there is some problem in the ```\nfft```\n code. Anyway, I have little time so I will just put a sample code I made before. You can use it as reference or copy-paste it. It should work.\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq\n\nfs = 1000   #sampling frequency\nT = 1/fs    #sampling period\nN = int((1 / T) + 1) #number of sample points for 1 second\nt = np.linspace(0, 1, N) #time array\npi = np.pi\n\nsig1 = 1 * np.sin(2*pi*10*t)\nsig2 = 2 * np.sin(2*pi*30*t)\nsig3 = 3 * np.sin(2*pi*50*t)\n#generate signal\nsignal = sig1 + sig2 + sig3\n#plot signal\nplt.plot(t, signal)\nplt.show()\n\nsignal_fft = fft(signal)    #getting fft\nf2 = np.abs(signal_fft / N) #full spectrum\nf1 = f2[:N//2]              #half spectrum\nf1[1:] = 2*f1[1:]           #actual amplitude\n\nfreq = fs * np.linspace(0,N/2,int(N/2)) / N     #frequency array\n#plot fft result\nplt.plot(freq, f1)\nplt.xlim(0,100)\nplt.show()\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for tensor product spaces in Julia\r\n                \r\nRight now I use the package FFTW in order to get some Fourier Transforms I am interested in. However, I'm wondering if there is already a package of FFT that can do the transformation in a vector space which is of the form ```\nkron(C2, Rn)```\n, where ```\nC2```\n means a 2x2 system and ```\nRn```\n represents the \"spatial\" subspace in which one is interested in getting the Fourier Transform. In other words, does it exist a routine that implements:\n```\nkron(Id2x2, FFT)[kron(C2, Rn)] = kron(C2, FFT(Rn))\n```\n\nOf course the real problem I am interested is in the \"two particle case\" where the vector space (Hilbert space) is ```\nkron(kron(C2, Rn),kron(C2, Rn))```\n, so in this case the routine would need an operator like ```\nkron(kron(Id2x2, FFT), kron(Id2x2, FFT))```\n.\nNote 1: I haven't tried to do the problem taking partial traces, but in my case this option simply may not work because the states are sparse, i.e. it might be ineficient.\nNote 2: Note that (unless I'm mistaken) for ```\nkron(C2, Rn)```\n one could do \"twice\" the fft (one in each sector of ```\nC2```\n). However this might also be ineficient for large vector spaces.\n    ", "Answer": "\r\nHere's an example of what I think you are asking. ```\nres```\n is computed by FFT from  ```\nmat = kron(C2, Rn)```\n, and this is (as you say) a wasteful way of doing ```\nkron(C2, fft(Rn))```\n since it the FFT along the ```\nk```\n dimension is re-done for each of the 2×2 other dimensions. But the point, presumably, is to do this for \"entangled\" states in the product space -- a generic ```\nlikemat = rand(8,2)```\n cannot be decomposed into factors ```\nkron(likeC2, likeRn)```\n.\n(If instead you are really only interested in \"un-entangled\" product states, then you should probably just work with their components. Combining with ```\nkron```\n will then always be wasteful. The package Kronecker.jl may help for some things, but I don't think it knows about ```\nfft```\n.)\nThis uses my package to handle ```\nkron```\n-like operations; you could just write out the necessary ```\nreshape```\ns yourself, too.\n```\njulia> C2 = [1 2; 3 4]; Rn = [1,10,0,0];\n\njulia> mat = kron(C2,Rn)\n8×2 Matrix{Int64}:\n  1   2\n 10  20\n  0   0\n  0   0\n  3   4\n 30  40\n  0   0\n  0   0\n\njulia> using TensorCast, FFTW\n\n# notation: kron is a reshape of a tensor product, to combine i & k\n\njulia> kron(C2,Rn) == @cast out[(k,i),j] := C2[i,j] * Rn[k]\ntrue\n\n# reshape mat to put the index from Rn in its own dimension:\n\njulia> @cast tri[k,i,j] := mat[(k,i),j]  (i in 1:2);\n\njulia> summary(tri)\n\"4×2×2 Array{Int64, 3}\"\n\n# then fft(tri, 1) is the FFT along only that, reshape back:\n\njulia> @cast res[(ktil,i),j] := fft(tri, 1)[ktil,i,j]\n8×2 Matrix{ComplexF64}:\n  11.0+0.0im    22.0+0.0im\n   1.0-10.0im    2.0-20.0im\n  -9.0+0.0im   -18.0+0.0im\n   1.0+10.0im    2.0+20.0im\n  33.0+0.0im    44.0+0.0im\n   3.0-30.0im    4.0-40.0im\n -27.0+0.0im   -36.0+0.0im\n   3.0+30.0im    4.0+40.0im\n\njulia> res ≈ kron(C2, fft(Rn))\ntrue\n\njulia> res ≈ fft(mat, 1)\nfalse\n\njulia> fft(Rn)\n4-element Vector{ComplexF64}:\n 11.0 + 0.0im\n  1.0 - 10.0im\n -9.0 + 0.0im\n  1.0 + 10.0im\n\n# if fft() understood the dims keyword, it could be tidier:\n\njulia> _fft(x; dims) = fft(x, dims);\n\njulia> @cast _res[(k,i),j] := _fft(k) mat[(k,i),j]  (i in 1:2);\n\njulia> _res ≈ res\ntrue\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Inverse fast fourier transform in MATLAB\r\n                \r\nMy MATLAB code for ```\nfft```\n and ```\nifft```\n below has a problem with the inverse Fourier signal ```\ny```\n not matching the in put signal ```\nx```\n. Is there any solution to resolve this?\n\n```\nN = 1000;\nt0 = 1e-13;\ntau = 2*1e-14;\nn = [0:t0/40:2*1e-13-t0/40];\nf0 = 3*1e8/(150*1e-9);\n\nx = cos(2*pi*f0*n);\nx = x.*exp((-(n-t0).^2)./(tau^2));\nX = abs(fft(x,N));\nF = [-N/2 : N/2 - 1]/N;\nX = fftshift(X);\ny=ifft(X,80);\n\nfigure(3)\nplot(n,y)\n```\n\n    ", "Answer": "\r\nI see a number of issues here:\n\n```\nN = 1000;\nt0 = 1e-13;\ntau = 2*1e-14;\nn = [0:t0/40:2*1e-13-t0/40];\nf0 = 3*1e8/(150*1e-9);\n\nx = cos(2*pi*f0*n);\nx = x.*exp((-(n-t0).^2)./(tau^2));\n%  X = abs(fft(x,N));  <-- Not seen this technique before, and why N=1000?\n% try something more like:\nX = fft(x);\n\nF = [-N/2 : N/2 - 1]/N;\n% this is fine to shift and plot the function\nXshifted = fftshift(X);\nplot( abs( Xshifted ) )\n% now you're taking the inverse of the shifted function, not what you want\n% y=ifft(X,80);  also not sure about the 80\ny = ifft(X);\n\nfigure(3)\nplot(n,y)\nfigure(4)\nplot( n, x ); hold on; plot( n, y, 'o' )\n```\n\n\n\n\nThat's all I see at first. HTH!\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Using GEKKO with Fast Fourier Transform\r\n                \r\nI am actually trying to use the IPOPT Optimisor available on GEKKO in order to optimise a large non-convex and non-linear problem.In order to do that I need to use the Fast Fourrier Transform with scipy.First,lets fix our sample data(for simplicity):\n```\nimport numpy as np\nimport pandas as pd\nimport math\nfrom scipy import *\nfrom scipy.integrate import quad\nimport scipy.stats as ss\nimport scipy.optimize as scpo\nfrom scipy import sparse\nfrom scipy.fftpack import ifft\nfrom scipy.interpolate import interp1d\nfrom scipy.optimize import fsolve\nfrom functools import partial\n\nr,prices, strikes, spreads,s0,T  = 0,array([1532.45 , 1507.55 , 1482.65 , 1457.8  , 1432.95 , 1408.1  ,\n        1383.25 , 1358.45 , 1333.6  , 1308.8  , 1284.   , 1259.2  ,\n        1234.45 , 1209.7  , 1037.15 , 1012.55 ,  988.05 ,  963.35 ,\n         938.9  ,  914.3  ,  889.8  ,  865.5  ,  841.   ,  816.65 ,\n         792.45 ,  768.1  ,  743.95 ,  719.85 ,  695.85 ,  672.   ,\n         648.1  ,  624.5  ,  600.9  ,  577.5  ,  554.2  ,  531.   ,\n         508.15 ,  485.35 ,  462.9  ,  440.65 ,  418.65 ,  396.85 ,\n         375.55 ,  354.5  ,  333.9  ,  313.65 ,  293.85 ,  255.75 ,\n         237.55 ,  219.8  ,  202.8  ,  186.35 ,  170.55 ,  155.4  ,\n         141.05 ,  127.4  ,  113.5  ,  101.35 ,   90.1  ,   79.65 ,\n          70.   ,   61.3  ,   53.4  ,   46.35 ,   34.5  ,   29.6  ,\n          25.35 ,   18.55 ,   15.85 ,   13.55 ,   11.55 ,    9.9  ,\n           7.35 ,    5.45 ,    3.075,    2.7  ]),array([12500., 12525., 12550., 12575., 12600., 12625., 12650., 12675.,\n        12700., 12725., 12750., 12775., 12800., 12825., 13000., 13025.,\n        13050., 13075., 13100., 13125., 13150., 13175., 13200., 13225.,\n        13250., 13275., 13300., 13325., 13350., 13375., 13400., 13425.,\n        13450., 13475., 13500., 13525., 13550., 13575., 13600., 13625.,\n        13650., 13675., 13700., 13725., 13750., 13775., 13800., 13850.,\n        13875., 13900., 13925., 13950., 13975., 14000., 14025., 14050.,\n        14075., 14100., 14125., 14150., 14175., 14200., 14225., 14250.,\n        14300., 14325., 14350., 14400., 14425., 14450., 14475., 14500.,\n        14550., 14600., 14700., 14725.]),array([29.7 , 29.7 , 29.7 , 29.8 , 29.7 , 29.8 , 29.7 , 29.7 , 29.8 ,\n        29.8 , 29.8 , 29.8 , 29.7 , 29.8 , 10.3 , 10.3 , 10.5 , 10.3 ,\n        10.6 , 10.4 , 10.4 , 10.6 , 10.4 , 10.5 , 10.7 , 10.4 , 10.5 ,\n        10.5 , 10.5 , 10.8 , 10.6 , 10.8 , 10.6 , 10.8 , 10.6 , 10.6 ,\n        10.9 , 10.5 , 10.8 , 10.7 , 10.7 , 10.3 , 10.5 , 10.4 , 10.2 ,\n        10.1 ,  9.9 ,  9.5 ,  9.3 ,  9.  ,  8.8 ,  8.5 ,  8.3 ,  8.2 ,\n         7.9 ,  7.6 ,  3.8 ,  3.7 ,  3.6 ,  3.5 ,  3.4 ,  3.2 ,  3.2 ,\n         3.1 ,  2.8 ,  2.6 ,  2.5 ,  2.3 ,  2.1 ,  2.1 ,  1.9 ,  1.8 ,\n         1.7 ,  1.5 ,  1.25,  1.2 ]),14000,0.05\n```\n\nthen the fourrier functions:\n```\nclass Heston_pricer():\n\n    def __init__(self, Option_info, Process_info ):\n        \"\"\"\n        Process_info: a instance of \"Heston_process.\", which contains (mu, rho, sigma, theta, kappa)\n        Option_info: of type Option_param, which contains (S0,K,T)\n        \"\"\"\n        self.r = Process_info.mu              # interest rate\n        self.sigma = Process_info.sigma       # Heston parameters\n        self.theta = Process_info.theta       \n        self.kappa = Process_info.kappa       \n        self.rho = Process_info.rho           \n\n        self.S0 = Option_info.S0          # current price\n        self.v0 = Option_info.v0          # spot variance\n        self.K = Option_info.K            # strike\n        self.T = Option_info.T            # maturity(in years)\n        self.exercise = Option_info.exercise\n        self.payoff = Option_info.payoff\n\n    # payoff function\n    def payoff_f(self, S):\n        if self.payoff == \"call\":\n            Payoff = np.maximum( S - self.K, 0 )\n        elif self.payoff == \"put\":    \n            Payoff = np.maximum( self.K - S, 0 )  \n        return Payoff\n\n    # FFT method. It returns a vector of prices.\n    def FFT(self, K): # K: strikes\n        K = np.array(K)\n\n        # Heston characteristic function (proposed by Schoutens 2004)\n        def cf_Heston_good(u, t, v0, mu, kappa, theta, sigma, rho):\n            xi = kappa - sigma*rho*u*1j\n            d = m.sqrt( xi**2 + sigma**2 * (u**2 + 1j*u) ) \n            g1 = (xi+d)/(xi-d)  \n            g2 = 1/g1\n            cf = m.exp( 1j*u*mu*t + (kappa*theta)/(sigma**2) * ( (xi-d)*t - 2*m.log( (1-g2*m.exp(-d*t))/(1-g2) ))\\\n                      + (v0/sigma**2)*(xi-d) * (1-m.exp(-d*t))/(1-g2*m.exp(-d*t))) \n            return cf\n\n        cf_H_b_good = partial(cf_Heston_good, t=self.T, v0=self.v0, mu=self.r, theta=self.theta, \n                                  sigma=self.sigma, kappa=self.kappa, rho=self.rho)\n        if self.payoff == \"call\":\n            return fft_(K, self.S0, self.r, self.T, cf_H_b_good)\n        elif self.payoff == \"put\":        # put-call parity\n            return fft_(K, self.S0, self.r, self.T, cf_H_b_good) - self.S0 + K*m.exp(-self.r*self.T)\n\nclass Heston_process():\n  def __init__(self, mu=0, rho=0, sigma=0.00001, theta=0.4, kappa=.00001):\n            \"\"\"\n            r: risk free constant rate\n            rho: correlation between stock noise and variance noise (|rho| must be <=1)\n            theta: long term mean of the variance process(positive)\n            sigma: volatility coefficient(positive)\n            kappa: mean reversion coefficient for the variance process(positive)\n            \"\"\"\n            self.mu, self.rho, self.theta, self.sigma, self.kappa = mu, rho, theta, sigma, kappa\n\ndef fft_(K, S0, r, T, cf): # interp support cubic \n    \"\"\" \n    K = vector of strike\n    S0 = spot price scalar\n    cf = characteristic function\n    \"\"\"\n    N=2**15                         # FFT more efficient for N power of 2\n    B = 500                         # integration limit \n\n    dx = B/N\n    x = np.arange(N) * dx\n\n    weight = 3 + (-1)**(np.arange(N)+1) # Simpson weights\n    weight[0] = 1; weight[N-1]=1\n\n    dk = 2*np.pi/B\n    b = N * dk /2\n    ks = -b + dk * np.arange(N)\n\n    integrand = m.exp(- 1j * b *(np.arange(N))*dx) * cf(x - 0.5j) * 1/(x**2 + 0.25) * weight * dx/3\n    integral_value = np.real(ifft(integrand)*N)\n    spline_cub = interp1d(ks, integral_value, kind=\"cubic\") # cubic will fit better than linear\n    prices = S0 - m.sqrt(S0 * K) * m.exp(-r*T)/np.pi * spline_cub( m.log(S0/K) )\n    return prices\n\n# A class that stores option parameters (in order to write BS/Heston class neatly)\nclass Option_param():  \n    def __init__(self, S0=10000, K=10000, T=.1, v0=0.04, payoff=\"call\", exercise=\"European\"):\n        \"\"\"\n        S0: current stock price\n        K: Strike price\n        T: time to maturity\n        v0: (optional) spot variance \n        exercise: European or American\n        \"\"\"\n        self.S0, self.v0, self.K, self.T, self.exercise, self.payoff = S0, v0, K, T, exercise, payoff\n```\n\nNow let's use GEKKO:\n```\n#Initialize Model\nm = GEKKO()\n\n#define parameter\neq = m.Param(value=5)\n\n#initialize variables\nx1,x2,x3,x4,x5 = [m.Var(lb=-1, ub=1),m.Var(lb=1e-3, ub=1),m.Var(lb=1e-3, ub=1),m.Var(lb=1e-3, ub=20),m.Var(lb=1e-3, ub=1)]\n\n#initial values\nx1.value = 0\nx2.value = 0.5\nx3.value = 0.5\nx4.value = 0.5\nx5.value = 0.5\n\nX = [x1,x2,x3,x4,x5]\n\n#Equations,Feller Condition\nm.Equation(2*x3*x4 - x2*x2 >=0)\n\ndef least_sq(x):\n    \"\"\" Objective function \"\"\"\n    Heston_param = Heston_process(mu=0, rho=X[0], sigma=X[1], theta=X[2], kappa=X[3])\n    m = 1/(spreads**2)\n    if len(m) == 1:\n      l = 1\n    else:\n      l = (m - np.min(m))/(np.max(m)-np.min(m))\n    opt_param = Option_param(S0=s0, K=strikes, T=T, v0=X[4], exercise=\"European\", payoff=\"call\" )\n    Hest = Heston_pricer(opt_param, Heston_param)\n    prices_calib = Hest.FFT(strikes)\n    results = (l * (prices_calib-prices)**2)/len(prices)\n    return results\n\nm.Obj(m.sum(least_sq(X)))\n#Set global options\nm.options.IMODE = 3 #steady state optimization\n\n#Solve simulation\nm.solve()\n\n#Results\nprint('')\nprint('Results')\nprint('x1: ' + str(x1.value))\nprint('x2: ' + str(x2.value))\nprint('x3: ' + str(x3.value))\nprint('x4: ' + str(x4.value))\nprint('x5: ' + str(x5.value))\n```\n\nThe problem here is the ifft scipy function that doesn't work because of the different type of variable given by GEKKO.The problem is I don't see how I can replace or avoid it.\nThe error is such :\n```\n<ipython-input-16-305a2bb0769b> in fft_(K, S0, r, T, cf)\n     78 \n     79     integrand = m.exp(- 1j * b *m.CV(np.arange(N))*dx) * cf(x - 0.5j) * 1/(x**2 + 0.25) * weight * dx/3\n---> 80     integral_value = np.real(ifft(integrand)*N)\n     81     spline_cub = interp1d(ks, integral_value, kind=\"cubic\") # cubic will fit better than linear\n     82     prices = S0 - m.sqrt(S0 * K) * m.exp(-r*T)/np.pi * spline_cub( m.log(S0/K) )\n\n/usr/local/lib/python3.7/dist-packages/scipy/_lib/deprecation.py in call(*args, **kwargs)\n     18             warnings.warn(msg, category=DeprecationWarning,\n     19                           stacklevel=stacklevel)\n---> 20             return fun(*args, **kwargs)\n     21         call.__doc__ = msg\n     22         return call\n\n<__array_function__ internals> in ifft(*args, **kwargs)\n\n/usr/local/lib/python3.7/dist-packages/numpy/fft/_pocketfft.py in ifft(a, n, axis, norm)\n    274     a = asarray(a)\n    275     if n is None:\n--> 276         n = a.shape[axis]\n    277     if norm is not None and _unitary(norm):\n    278         inv_norm = sqrt(max(n, 1))\n\nIndexError: tuple index out of range\n```\n\nCould someone help me debugging this.Thank you\n    ", "Answer": "\r\nGekko requires that expressions are not black box but are able to be expressed with special types of variables (Gekko type) for automatic differentiation and sparsity detection. This may be better solved with a solver such as Scipy.optimize.minimize. Here is a comparison of the two on a simple problem.\nScipy\n```\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef objective(x):\n    return x[0]*x[3]*(x[0]+x[1]+x[2])+x[2]\n\ndef constraint1(x):\n    return x[0]*x[1]*x[2]*x[3]-25.0\n\ndef constraint2(x):\n    sum_eq = 40.0\n    for i in range(4):\n        sum_eq = sum_eq - x[i]**2\n    return sum_eq\n\n# initial guesses\nn = 4\nx0 = np.zeros(n)\nx0[0] = 1.0\nx0[1] = 5.0\nx0[2] = 5.0\nx0[3] = 1.0\n\n# show initial objective\nprint('Initial Objective: ' + str(objective(x0)))\n\n# optimize\nb = (1.0,5.0)\nbnds = (b, b, b, b)\ncon1 = {'type': 'ineq', 'fun': constraint1} \ncon2 = {'type': 'eq', 'fun': constraint2}\ncons = ([con1,con2])\nsolution = minimize(objective,x0,method='SLSQP',\\\n                    bounds=bnds,constraints=cons)\nx = solution.x\n\n# show final objective\nprint('Final Objective: ' + str(objective(x)))\n\n# print solution\nprint('Solution')\nprint('x1 = ' + str(x[0]))\nprint('x2 = ' + str(x[1]))\nprint('x3 = ' + str(x[2]))\nprint('x4 = ' + str(x[3]))\n```\n\nGekko\n```\nfrom gekko import GEKKO    \n\nm = GEKKO()\n\n#initialize variables\nx1,x2,x3,x4 = [m.Var(lb=1,ub=5) for i in range(4)]\nx1.value = 1; x2.value = 5; x3.value = 5; x4.value = 1\n\nm.Equation(x1*x2*x3*x4>=25)\nm.Equation(x1**2+x2**2+x3**2+x4**2==40)\n\nm.Minimize(x1*x4*(x1+x2+x3)+x3)\n\nm.solve()\n\nprint('x1: ' + str(x1.value))\nprint('x2: ' + str(x2.value))\nprint('x3: ' + str(x3.value))\nprint('x4: ' + str(x4.value))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why does my own implementation of Fast Fourier Transform in N dimensions give different results than NumPy's?\r\n                \r\nI've written the following code for the N-dimensional Fast Fourier Transform but it doesn't give me the same result as numpy's function.\n```\ndef nffourier(f, direct):\n    dim = f.ndim  \n    N = f.shape\n    G = np.zeros(f.shape, dtype=complex)\n    G = f\n    \n    for k in range(dim):\n        for i in range(N[k]):\n            aux = G[(slice(None),) * (k) + (i,)]\n            trans = ffourier(aux, direct)\n            G[(slice(None),) * (k) + (i,)] = trans\n            \n    return G\n```\n\nMy code for calculating FFT in 1d is the following:\n```\ndef ffourier(f, direct):\n    N = len(f)\n    \n    M = int(m.log(N)/m.log(2))\n        \n    G = []\n    order = []\n    \n    for i in range(N):\n        order.append(int(bin(i)[2:]))\n    \n    digitos = len(aux)\n    for i in range(N):\n        contenido_aux = str(int(order[i]))\n        aux = len(str(order[i]))\n        if(aux<digitos):\n            añadir=digitos-aux\n            for k in range(añadir):\n                contenido_aux = '0'+contenido_aux\n        G.append(contenido_aux)\n    for i in range(len(G)):\n        G[i] = G[i][::-1]\n    \n\n    for i in range(len(G)):\n        G[i] = int(G[i], 2)\n    for i in range(len(G)):\n        G[i] = f[G[i]]\n    \n\n    \n   \n    if direct == False:\n        signo = 1\n    else:\n        signo = -1\n\n\n    kmax = 1\n    kmax = int(kmax)\n    for alfa in range(1,M+1):\n        w1 = np.exp(signo*1j*2*m.pi/(2**alfa))\n        kmax = int(2*kmax)\n        W = 1\n        for k in range(0, int(kmax/2)-1+1):\n            for s in range(0, N-1+1, int(kmax)):\n                T0 = G[s+k]\n                T1 = G[s+k+int(kmax/2)]*W\n                G[s+k]=T0+T1\n                G[s+k+int(kmax/2)]=T0-T1\n            W=W*w1\n    cte = 1/m.sqrt(N)\n    for i in range(0, N-1+1):\n        G[i] = G[i]*cte \n    return G\n```\n\nThe fundamentals of it is quite hard to explain, it's based on bit inversion, but I've checked it works properly, so the problem is with the N dimensional code.\n    ", "Answer": "\r\nYour indexing ```\nG[(slice(None),) * (k) + (i,)]```\n works in 2D but not in higher dimensions. Let’s see what it does:\nSay ```\nG```\n is 2D. Now when ```\nk=0```\n, your indexing is the same as ```\nG[i]```\n, which is the same as ```\nG[i,:]```\n. You are selecting rows. When ```\nk=1```\n, then that indexing is ```\nG[:,i]```\n. You are selecting columns.\nBut now say ```\nG```\n is 3D. Now when ```\nk=0```\n, you get ```\nG[i]```\n again, which now is equivalent to ```\nG[i,:,:]```\n. You are selecting a 2D subarray! What you need is a 1D subarray. You need to get ```\nG[i,j,:]```\n for all ```\ni```\n and all ```\nj```\n. And then ```\nG[i,:,j]```\n, and then ```\nG[:,i,j]```\n.\nLikewise, for a 5D array, you want ```\nG[i,j,k,l,:]```\n, etc. That is to say, you want to loop over all dimensions minus one.\nTo loop over all ```\ni```\n and ```\nj```\n, you could do a double loop, but then you have specific 3D code. It is possible to write a loop over an arbitrary number of dimensions, but it’s not pretty. So we’ll look for an alternative.\nI think the simplest way to get this to work is to flatten those N-1 dimensions, turning a MxNxOxPxQ array into a 2D (```\nN*M*O*P```\n)xQ array. Now you can do a 1D loop over the first dimension.\nNow you need to loop over the dimensions, it’s a different dimension that we leave out every time. We can simplify this problem by “rolling” the dimensions, make a different dimension the last one every time, then apply that same flattening code. Now it’s easy to write a loop (not tested):\n```\ndef nffourier(f, direct):\n    dim = f.ndim  \n    G = f.astype(complex)\n    \n    for k in range(dim):\n        G = np.moveaxis(G, 0, -1)  # shifts the dimensions by one to the left\n        shape = G.shape\n        m = shape[-1]\n        G = np.reshape(G, (-1, m))  # flattens all but last dimension\n        m = G.shape[0]\n        for i in range(m):          # loop over first dimension\n            G[i, :] = ffourier(G[i, :], direct)  # apply over last dimension\n        G = np.reshape(G, shape)    # return to original shape\n    \n    # After applying moveaxis dim times, G should have the same dimension order it had at the start\n    return G\n```\n\n(Note also, as we already discussed in the comments, that the ```\nG = f```\n line causes the output array ```\nG```\n to be of the same type as ```\nf```\n, likely not complex, and so will cause errors also.)\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "simultaneous inverse fast fourier transform of two real functions\r\n                \r\nI'm trying to calculate the inverse Fourier Transform of two real functions with a single IFFT. The best and most straightforward explanation I've found so far is here, where it says:\n\n\n  Use the fact that the FFT is linear and form the sum of the first transform plus i times the second.\n  You have two vectors, x1 and x2, with\n  discrete Fourier Transforms X1 and X2\n  respectively. Then\n  \n  x1 = Re[ IDFT[ X1 + i X2 ] ]\n  \n  and\n  \n  x2 = Im[ IDFT[ X1 + i X2 ] ].\n\n\nThe problem is that I don't get where the 'i' parameter comes from.\nAny hint on this would be much appreciated.\n\nThanks in advance.\n\nEDIT:\n\nAfter doing some experiments I finally made it work, but now I'm more confused than before as it didn't work as I expected and had to use some imagination to figure out the correct formulas.\n\nI just made up a new complex array where:\n\n```\nRe[n] = X1Re[n] - X2Im[n]\nIm[n] = X2Re[n] + X1Im[n]\n```\n\n\nAfter doing an IFFT on it x1 = Re and x2 = Im, so wouldn't it be correct to express it like this?\n\n```\nx1 = Re[ IDFT[ X1 - i X2 ] ]\nx2 = Im[ IDFT[ X2 + i X1 ] ].\n```\n\n    ", "Answer": "\r\nAre you wondering what the 'i' represents?  In this case, I believe 'i' is referring to sqrt(-1), the imaginary unit vector.\n\nThen:\n\n```\nRe[ IDFT[ X1 + i X2 ] ]\n```\n\n\nwill be the 'real' part of that transform (anything without an 'i') and \n\n```\nIm[ IDFT[ X1 + i X2 ] ]\n```\n\n\nwill be the 'imaginary' part of that transform (anything multiplied by an 'i').\n\nIt is possible I've misunderstood your question and this answer is much too simplistic; if it is, no insult was intended to your intelligence, I just misunderstood you.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Output array after performing fast fast fourier transform of a data set\r\n                \r\nI'm trying to perform a fourier transform of a data set that I have and subsequently writing its real and imaginary parts separately.\n\nThis is my code:\n\n```\nimport sys,string\nimport numpy as np\nfrom math import *\nimport fileinput\nfrom scipy.fftpack import fft, ifft\n\ntemparray = []\n\nfor i in range(200000):\n    line = sys.stdin.readline() ## reads data from a text file\n    fields = map(float,line.split())\n    temparray.append(fields)\nacf = sum(temparray,[]) ## I need to do this as the appended array from above is nested\ny = np.fft.fft(acf)\nz = (y.real,y.imag)\nprint z\n```\n\n\nThe output that I get is as follows:\n\n```\n(array([ 2600.36368107, 2439.50426935, 1617.52631545, ..., 1575.78483016, 1617.52631545, 2439.50426935]), array([ 0. , -767.19967198, -743.75183367, ..., 726.45052092, 743.75183367, 767.19967198]))\n```\n\n\nIt looks like its only printing the first few and last few values, completely skipping everything in between. Can anybody please tell me why this is happening?\n\nThanks\n    ", "Answer": "\r\nAs others have indicated, include a modified version of \n\n```\n>>> np.set_printoptions(edgeitems=5,linewidth=80,precision=2,suppress=True,threshold=10) \n>>> a = np.arange(0,100.)\n>>> \n>>> a\narray([  0.,   1.,   2.,   3.,   4., ...,  95.,  96.,  97.,  98.,  99.])\n>>> np.set_printoptions(edgeitems=5,linewidth=80,precision=2,suppress=True,threshold=100) \n>>> a\narray([  0.,   1.,   2.,   3.,   4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.,\n        12.,  13.,  14.,  15.,  16.,  17.,  18.,  19.,  20.,  21.,  22.,  23.,\n        24.,  25.,  26.,  27.,  28.,  29.,  30.,  31.,  32.,  33.,  34.,  35.,\n        36.,  37.,  38.,  39.,  40.,  41.,  42.,  43.,  44.,  45.,  46.,  47.,\n        48.,  49.,  50.,  51.,  52.,  53.,  54.,  55.,  56.,  57.,  58.,  59.,\n        60.,  61.,  62.,  63.,  64.,  65.,  66.,  67.,  68.,  69.,  70.,  71.,\n        72.,  73.,  74.,  75.,  76.,  77.,  78.,  79.,  80.,  81.,  82.,  83.,\n        84.,  85.,  86.,  87.,  88.,  89.,  90.,  91.,  92.,  93.,  94.,  95.,\n        96.,  97.,  98.,  99.])\n\nnp.set_printoptions(edgeitems=3,linewidth=80,precision=2,suppress=True,threshold=5)\n```\n\n\nperhaps setting threshold to some very large number. \n\nAddendum\n\nI would be remiss if I didn't state that the simplest solution to the above is to simple use\n\n```\n>>> list(a)\n```\n\n\nshould you not care whether an array is visually returned or not.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Computational complexity of n-dimensional Discrete Fourier Transform?\r\n                \r\nThe computational complexity of n-dimensional Fast Fourier Transform was discussed here and (as the former's duplicate) here.\n\nThe computational complexity of a 1-dimensional Discrete Fourier Transform is ```\nO(N^2)```\n, ```\nN```\n is the data set size.\n\nCould you please tell us what is the computational complexity of the n-dimensional Discrete Fourier Transform consisting {N1, N2 ... Nn} points along each dimension?\n    ", "Answer": "\r\nThe FFT itself is also a DFT (with some constraints). Will assume that you mean the naive summation method.\n\nRe-writing the 1D DFT in integral form (the continuous version):\n\n\n\nA particular value of ```\nf```\n-tilde is equivalent to a single element in your DFT array. When the integral is discretized (i.e. converted a finite sum), there are ```\nN```\n terms in the sum. This gives ```\nO(N)```\n for each element and hence ```\nO(N^2)```\n overall.\n\nIn case you were wondering, writing in this form allows for more compact notation for a general ```\nn```\n-D DFT:\n\n\n\nWhen this is discretized, we can see that for each element there are ```\nn```\n sums, each over one of the dimensions and of length ```\nN```\n. There are ```\nN ^ n```\n values in the input \"array\", so the complexity is:\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast fourier transform went wrong\r\n                \r\nI tried to implement FFT using this code: Rosetta Code FFT\n\nHere's a screenshot of the result I got:\nFFT gone wrong\n\nHere's my code where I used the above FFT on an image:\n\n```\nfunction fastFourier(img){\n\nlet height=img.rows;\nlet width=img.cols;\nlet tmp=createArray(height,width);\nlet temp=createArray(height,width);\nlet rows=createArray(height,width);\nlet prettypls=img.clone();\n\n//new complex array\nfor(i=0;i<height;i++){\n  for(j=0;j<width;j++){\n  rows[i][j]=new Complex(0, 0);\n    }\n}\n\n//put pixel values in complex array\nif(height%2==0&&width%2==0){\n  for ( y = 0; y < height; y++) {\n    for ( x = 0; x < width; x++) {\n    let pixel = img.ucharPtr(y,x);\n    rows[y][x].re=pixel[0];\n  }\n}\n\n//perform fft\nfor(y=0;y<height;y++){\n  tmp[y]=cfft(rows[y]);\n}\n\n//take the magnitudes\nfor(i=0;i<height;i++){\n  for(j=0;j<width;j++){\n    temp[i][j]=Math.round(tmp[i][j].re);\n  }\n}\n\n//do a log transform\ntemp=logTransform(temp,height,width);\n\n//put the real values into Mat\nfor(i=0;i<height;i++){\n  for(j=0;j<width;j++){\n    let pixel = prettypls.ucharPtr(i,j);\n    pixel[0]=Math.round(temp[i][j]);\n  }\n}\ncv.imshow('fourierTransform', prettypls);\nrows=[];temp=[];tmp=[];prettypls.delete();\n}\nelse alert('Image size must be a power of 2.');\n}\n```\n\n\nI did the log transform based on this description of FFT. Here's my log transform code:\n\n```\nfunction logTransform(img,h,w){\n//https://homepages.inf.ed.ac.uk/rbf/HIPR2/pixlog.htm\nlet max=findMax2d(img,h,w);\nlet c=255/(Math.log(1+max));\nfor(i=0;i<h;i++){\n  for(j=0;j<w;j++){\n    img[i][j]=c*Math.log(1+Math.abs(img[i][j]));\n  }\n}\nreturn img;\n}\n```\n\n\nI have no idea what I did wrong. The FFT results are fine when it's just a normal array, but using it with images returns the above results.\n    ", "Answer": "\r\nYou're getting exactly what you asked for: for each row in the image, an analysis of the intensity frequencies in that row. Your code treats each row as an individual array of samples, and takes the FFT of that.\n\nWhat you probably want is a two-dimensional FFT as described here: http://www.robots.ox.ac.uk/~az/lectures/ia/lect2.pdf\n\nRight now, you are just calculating a series of one-dimensional FFTs, which is not the same.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "1D Fast Fourier Transform\r\n                \r\nWhat algorithm is the following?\n\nWhat I understand from the following source code is:\n\n\n```\ndir```\n is the direction of FFT: forward=1, inverse=-1.\n```\nx```\n is the real part\n```\ny```\n is the imaginary part\n\n\nWhat is ```\nm```\n here?\n\nIf ```\nx```\n = {1, 1, 1, 1, 0, 0, 0, 0}, and, ```\ny```\n = {0,0,0,0,0,0,0,0,0}, what would be the value of ```\nm```\n?\n\n```\n        //Inplace 1D FFT\n        public static void FFT1D(int dir, int m, ref double[] x, ref double[] y)\n        {\n            long nn, i, i1, j, k, i2, l, l1, l2;\n            double c1, c2, tx, ty, t1, t2, u1, u2, z;\n            /* Calculate the number of points */\n            nn = 1;\n            for (i = 0; i < m; i++)\n                nn *= 2;\n            /* Do the bit reversal */\n            i2 = nn >> 1;\n            j = 0;\n            for (i = 0; i < nn - 1; i++)\n            {\n                if (i < j)\n                {\n                    tx = x[i];\n                    ty = y[i];\n                    x[i] = x[j];\n                    y[i] = y[j];\n                    x[j] = tx;\n                    y[j] = ty;\n                }\n                k = i2;\n                while (k <= j)\n                {\n                    j -= k;\n                    k >>= 1;\n                }\n                j += k;\n            }\n            /* Compute the FFT */\n            c1 = -1.0;\n            c2 = 0.0;\n            l2 = 1;\n            for (l = 0; l < m; l++)\n            {\n                l1 = l2;\n                l2 <<= 1;\n                u1 = 1.0;\n                u2 = 0.0;\n                for (j = 0; j < l1; j++)\n                {\n                    for (i = j; i < nn; i += l2)\n                    {\n                        i1 = i + l1;\n                        t1 = u1 * x[i1] - u2 * y[i1];\n                        t2 = u1 * y[i1] + u2 * x[i1];\n                        x[i1] = x[i] - t1;\n                        y[i1] = y[i] - t2;\n                        x[i] += t1;\n                        y[i] += t2;\n                    }\n                    z = u1 * c1 - u2 * c2;\n                    u2 = u1 * c2 + u2 * c1;\n                    u1 = z;\n                }\n                c2 = Math.Sqrt((1.0 - c1) / 2.0);\n                if (dir == 1)\n                    c2 = -c2;\n                c1 = Math.Sqrt((1.0 + c1) / 2.0);\n            }\n            /* Scaling for forward transform */\n            if (dir == 1)\n            {\n                for (i = 0; i < nn; i++)\n                {\n                    x[i] /= (double)nn;\n                    y[i] /= (double)nn;\n                }\n            }\n        }\n```\n\n    ", "Answer": "\r\nThe implementation of the FFT you have posted is limited to inputs of size 2```\nm```\n. Here ```\nm```\n thus indirectly specify the size of the FFT block size. So, for your example with ```\nx = {1,1,1,1,0,0,0,0}```\n and ```\ny={1,1,1,1,0,0,0,0}```\n being arrays of size 8=23, ```\nm```\n would be equal to 3.\n\nNote that there are no additional checks for the size of the arrays ```\nx```\n and ```\ny```\n so make sure they are at least that size. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Pseudocode?\r\n                \r\nThe purpose of the following code is to convert a polynomial from coefficient representation into value representation by dividing it into its odd and even powers and then recursing on the smaller polynomials.\n\n```\nfunction FFT(A, w)\n\nInput: Coefficient representation of a polynomials A(x) of degree ≤ n-1, where n \nis a power of 2w, an nth root of unity.\n\nOutput: Value representation A(w^0),...,A(w^(n-1))\n\nif w = 1; return A(1)\nexpress A(x) in the form A_e(x^2) and xA_o(x^2) /*where A_e are the even powers and A_o  \nthe odd.*/\ncall FFT(A_e,w^2) to evaluate A_e at even of powers of w\ncall FFT(A_o,w^2) to evaluate A_o at even powers of w\nfor j = 0 to n-1;\n    compute A(w^j) = A_e(w^(2j))+w^j(A_o(w^(2j)))\n\nreturn A(w^0),...,A(w^(n-1))\n```\n\n\n\nWhat is the for loop being used for?\nWhy is the pseudocode only adding the smaller polynomials, doesn't it need to subtract them too? (to calculate A(-x)). Isn't that what the algorithm completely based on? Adding and subtracting the smaller polynomials to reduce the points in half?*\nWhy are powers of \"w\" being evaluated as opposed to \"x\"?\n\n\nI am not a too sure if this belongs here, since the question is quite mathematical. If you feel this question is off-topic, I would appreciate it if you moved it to a site where you felt this question would be more appropriate, rather that just closing it.\n\n*Psuedocode was gotten from Algorithms by S. Dasgupta. Page 71.\n    ", "Answer": "\r\n\nThe loop is for recursion.\nNo need to add for negative x; the FFT transforms from time to frequency space.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Changing the inverse fast Fourier transform (ifft) to use an arbitrary waveform instead of sine waves to create a new signal\r\n                \r\nI know that an inverse fast Fourier transform (ifft) sums multiple sine waves together from data obtain from doing an fft on a signal. Is there a way to create a signal using a new type of inverse fast Fourier transform (ifft) using an arbitrary waveform instead of just using sine waves?\n\nI'm not trying to re-create the original signal. I'm trying to create a new signal using a new type of inverse fast Fourier transform (ifft) using a given arbitrary waveform based on the (frequency, amplitude, phase) data calculated from the fft   from the source signal.\n\nThe arbitrary waveform is a sampled signal that will replace one period of the sine wave used in the fft. That is, the signal is to be scaled, repeated, and shifted according to the values given by the fft.\n\nSee simple example below: the signals I will be applying FFT to are human audio signals about 60 seconds long at 44100 samples (large arrays) so I'm trying to see if I can use / alter the ifft command in some way to create a new signal using / based on an arbitrary waveform. \n\nPS: I'm using Octave 4.0 which is similar to Matlab and the arbitrary waveform signal used to create a new signal will be changed to create different signals.\n\n```\nclear all,clf reset, clc,tic\n\nfs=44100 % Sampling frequency\nlen_of_sig=2; %length of signal in seconds\nt=linspace(0,2*pi*len_of_sig,fs*len_of_sig);\nafp=[.5,2.43,pi/9;.3,3,pi/2;.3,4.3,pi/3];  %represents Amplitude,frequency,phase data array\n\n%1 create source signal\nya=0;\nfor zz=1:size(afp,1)\n  ya = ya+afp(zz,1)*sin(afp(zz,2)*t+afp(zz,3));\nend\n\n%2 create source frequency domain data\nya_fft = fft(ya);\n\n%3 rebuild original source signal\nmag = abs(ya_fft);\nphase = unwrap(angle(ya_fft));\nya_newifft=ifft(mag.*exp(i*phase));\nifft_sig_combined_L1=ifft(mag.*exp(i*phase),length(ya_newifft)); \n\n%4 %%%-----begin create arbitrary waveform to use ---- \ngauss = @(t, t0, g) exp(-((t-t0)/g).^2); % a simple gaussian\n\nt_arbitrary=0:1:44100; % sampling\nt_arbitrary_1 = 10000; % pulses peak positions (s)\nt_arbitrary_2 = 30000; % pulses peak positions (s)\n\ng = 2000; % pulses width (at 1/e^2) (s)\n\nlilly = gauss(t_arbitrary, t_arbitrary_1, g) - (.57*gauss(t_arbitrary, t_arbitrary_2, g)); %different amplitude peaks\n%%%%-----End arbitrary waveform to use---- \n\n%5 plot\nt_sec=t./(2*pi); %converts time in radians to seconds\nt_arbitrary_sec=t_arbitrary./length(lilly); %converts time in radians to seconds\n\nsubplot(4,1,1);\nplot(t_sec,ya,'r')\ntitle('1) source signal')\n\nsubplot(4,1,2);\nplot(t_sec,ifft_sig_combined_L1)\ntitle('2) rebuilt source signal using ifft')\n\nsubplot(4,1,3);\nplot(t_arbitrary_sec,lilly,'r')\ntitle('3) arbitrary waveform used to create new signal')\n```\n\n\n\n\nAdded a work-flow chart below with simple signals to see if that explains it better:\n\n```\nSection 1) The audio signal is read into an array\nSection 2) FFT is done on the signal\nSection 3 Red) Normally Inverse FFT uses sin waves to rebuild the signal see signal in red\nSection 3 Blue) I want to use an arbitrary signal wave instead to rebuild the signal using the FFT data calculated in (Section 2)\nSection 4) New signals created using a new type of Inverse FFT (Section 3).\nPlease note the new type of Inverse FFT final signal (in blue ) must use the FFT data taken from the original signal.\nThe signal Sample rate tested should be 44100 and the length of the signal in seconds should be 57.3 seconds long.  I use these numbers to test that the array can handle large amounts and that the code can handle non even numbers in seconds.\n```\n\n\n\n    ", "Answer": "\r\nLet's start with a function ```\nlilly```\n that takes a frequency, an amplitude and a phase (all scalars), as well as a signal length ```\nN```\n, and computes a sine wave as expected for the inverse DFT (see note 2 below):\n\n```\nfunction out = lilly(N,periods,amp,phase)\npersistent t\npersistent oneperiod\nif numel(t)~=N\n   disp('recomputung \"oneperiod\"');\n   t = 0:N-1;\n   oneperiod = cos(t * 2 * pi / N);\nend\np = round(t * periods + phase/(2*pi)*N);\np = mod(p,N) + 1;\nout = amp * oneperiod(p);\n```\n\n\nI have written this function such that it uses a sampled signal representing a single period of the since wave.\n\nThe following function uses the ```\nlilly```\n function to compute an inverse DFT (see note 1 below):\n\n```\nfunction out = pseudoifft(ft)\nN = length(ft);\nhalf = ceil((N+1)/2);\nout = abs(ft(1)) + abs(ft(half)) * ones(1,N);\nfor k=2:half-1\n   out = out + lilly(N,k-1,2*abs(ft(k)),angle(ft(k)));\nend\nout = out/N;\n```\n\n\nNow I test to verify that it actually computes the inverse DFT:\n\n```\n>> a=randn(1,256);\n>> b=fft(a);\n>> c=pseudoifft(b);\nrecomputung \"oneperiod\"\n>> max(abs(a-c))\nans =  0.059656\n>> subplot(2,1,1);plot(a)\n>> subplot(2,1,2);plot(c)\n```\n\n\n\n\nThe error is relatively large, due to the ```\nround```\n function: we're subsampling the signal instead of interpolating. If you need more precision (not likely I think) you should use ```\ninterp1```\n instead of indexing using ```\nround(p)```\n.\n\nNext, we replace the sine in the ```\nlilly```\n function with your example signal:\n\n```\nfunction out = lilly(N,periods,amp,phase)\npersistent t\npersistent oneperiod\nif numel(t)~=N\n   disp('recomputung \"oneperiod\"');\n   t = 0:N-1;\n   %oneperiod = cos(t * 2 * pi / N);\n   gauss = @(t,t0,g) exp(-((t-t0)/g).^2); % a simple gaussian\n   t1 = N/4;   % pulses peak positions (s)\n   t2 = 3*N/4; % pulses peak positions (s)\n   g = N/20;   % pulses width (at 1/e^2) (s)\n   oneperiod = gauss(t,t1,g) - (.57*gauss(t,t2,g)); %different amplitude peaks\n   oneperiod = circshift(oneperiod,[1,-round(N/4)]); % this will make it look more like cos\nend\np = round(t * periods + phase/(2*pi)*N);\np = mod(p,N) + 1;\nout = amp * oneperiod(p);\n```\n\n\nThe function ```\npseudoifft```\n now creates a function composed of your basis:\n\n```\n>> c=pseudoifft(b);\nrecomputung \"oneperiod\"\n>> subplot(2,1,2);plot(c)\n```\n\n\n\n\nLet's look at a simpler input:\n\n```\n>> z=zeros(size(a));\n>> z(10)=1;\n>> subplot(2,1,1);plot(pseudoifft(z))\n>> z(19)=0.2;\n>> subplot(2,1,2);plot(pseudoifft(z))\n```\n\n\n\n\n\n\nNote 1: In your question you specifically ask to use the FFT. The FFT is simply a every efficient way of computing the forward and inverse DFT. The code above computes the inverse DFT in O(n^2), the FFT would compute the same result in O(n log n). Unfortunately, the FFT is an algorithm built on the properties of the complex exponential used in the DFT, and the same algorithm would not be possible if one were to replace that complex exponential with any other function.\n\nNote 2: I use a cosine function in the inverse DFT. It should of course be a complex exponential. But I'm just taking a shortcut assuming that the data being inverse-transformed is conjugate symmetric. This is always the case if the input to the forward transform is real (the output of the inverse transform must be real too, the complex components of two frequencies cancel out because of the conjugate symmetry).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Javascript\r\n                \r\nI need a FFT function like the FFT in ```\nnumpy```\n (python) that takes only ONE list( length doesnt necessarily need to be power of 2).\n\nI used ```\ndsp.js```\n but it needs the Buffer size and buffer size must be power of 2 but my data length is 500.\n\nis there any library that isnt audio exclusive ? \nor should I add ```\n0```\n to end of array ?\n    ", "Answer": "\r\nYou absolutely can pad with zeros to reach the desired size.  See this reference: http://www.bitweenie.com/listings/fft-zero-padding/\n\nA quote straight from the article:\n\n\n  There are a few reasons why you might want to zero pad time-domain data. The most common reason is to make a waveform have a power-of-two number of samples. When the time-domain length of a waveform is a power of two, radix-2 FFT algorithms, which are extremely efficient, can be used to speed up processing time. FFT algorithms made for FPGAs also typically only work on lengths of power two.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to plot fast-fourier transform data as a function of frequencies in Python?\r\n                \r\nI am new to Scipy and still learning about structuring data in the NumPy array. Can someone please help me resolve the following :\nMy data array consists of 10 columns and 110 rows. I am unable to get the right number of freq points.\nI want to:\n\nMatch the array shapes to ultimately plot frequency points using scipy's ```\nrfftfreq```\n\nPad zeros to my data before computing th fast fourier transform\n\nHere is my code:\nI am converting the dataframe to numpy array and extracting ```\nx```\n and ```\ny```\n data\n```\nxdata=np.array(combine.iloc[:,0:20:2])          #both x and y data shapes are (110,10) #the data corresponds to positions in mm \nydata=np.array(combine.iloc[:,1:20:2])\n```\n\nI compute the fft:\n```\nfftdata=fft(ydata)                             # array of 110 by 10 \nfftlen = len(fftdata)                          # size is 1 and value 110\ntime = (2*fftlen*xdata*0.0075e-3)/c/1e-12      # the numbers are constants #time axis is generated from x data with different delay position of the laser beam\ntimestep=abs(xdata[fftlen-1]-xdata[0])/(fftlen-1)/0.1499 #sampling rate\n\nsample_size=fftdata.size                        # size is 1 and value of 1100\n\nfreq = rfftfreq(sample_size, d=timestep)        \n# shape is (551,) - (N/2)nyquist points \n\nplt.plot(freq,fftdata[0:(fftlen//2+1)])\n\n```\n\nBut, I am getting this error\n```\nError : x and y must have same first dimension, but have shapes (551,) and (56, 10)\n```\n\nI understand that these cannot be plotted due to different shapes. But I would like to apply FFT to the whole of my array (110,10) instead of loading individual files to different NumPy arrays. I would very much appreciate it if anyone could also help me with padding zeros to ```\nxdata```\n and ```\nydata```\n before computing the FFT to improve the frequency domain resolution.\n    ", "Answer": "\r\nThe example in numpy documentation is all you need :\n```\nimport numpy as np\n\n# Let's say here is your signal\nsignal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)\n\nfourier = np.fft.rfft(signal)\nn = signal.size\nsample_rate = 100\nfreq = np.fft.fftfreq(n, d=1./sample_rate)\n```\n\n```\n>> freq\n array([  0.,  10.,  20., ..., -30., -20., -10.])\n```\n\nbut when you apply ```\nrfftfreq```\n, you get only positive frequencies:\n```\nfreq = np.fft.rfftfreq(n, d=1./sample_rate)\n```\n\nSo if you want to plot something you take only the corresponding half of values (in the fourier transform magnitude for example).\n```\n>> freq\n array([  0.,  10.,  20., 40., 50.])\n```\n\nTo perform zero-padding, you can just use ```\nnp.pad```\n\n```\nnp.pad(signal, (2,2), 'constant', constant_values=(0,0))\n\n```\n\nThis added 2 zero values in the beginning and the end of the array. Multiple options are possible. Check this https://numpy.org/doc/stable/reference/generated/numpy.pad.html\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "react native how to use fast fourier Transform with my data\r\n                \r\nMy team want to evaluate and check micro current through a sensor and bluetooth to react-native app when someone workout.\nI have a list of voltage powers from workout.\nexample) list = [1023,300,200,500,...]\nXaxis is index(This will change to time).\nYaxis is voltage.\nMy Maximum size is 1023(max is 1024-1)\n\nI want to make this data into frequency and amplitude graph(linear graph that I can know I am doing good on my workout)\nMy mentor said me to use the fast fourier transform.\nBut it doesn't matter if I use different algorithm or just integral to make the list data to frequency and amplitude  linear graph.\n\nThere was no react-native library, I have searched some npm library such as fft-js, fft.js, dsp.js\nfrom here https://npm.io/search/keyword%3Afft/1\nBut I don't know how to use them. I really don't understand where to put my data when I use the library.\nfor instance, https://npm.io/package/fft.js\n```\nconst FFT = require('fft.js');\nconst f = new FFT(4096);\n// what is the size meaning? It means my voltage maximum height? which is 1024?\nconst input = new Array(4096);\ninput.fill(0);\nconst out = f.createComplexArray();\n\n//where to put my data to realInput variable??\nconst realInput = new Array(f.size);\nf.realTransform(out, realInput);\n```\n\nIf there is an example GitHub code, it would be really helpful..\nIf someone made it, would you please help me?\n    ", "Answer": "\r\nI have found out signal data should be power of 2. It worked well.I used fft-js npm library\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Strange artefact in my Fourier transform\r\n                \r\nI have performed an fft (fast fourier transform) on a time series waveform in Matlab, but I seem to have a weird wave actually in the fourier transform plot, although there are spikes this wave looks like something I'd expect to see only in the time domain. Is there any programming reason why this could happen?\n    ", "Answer": "\r\nThe Fourier transform is quite similar to the Inverse Fourier Transform. A spike in one is a wave in the other. Hence, if you have one outlier datapoint in your series, you'll have a wave component in the frequency domain. \n\nA possible programming-related issue could be an uninitialized data point, e.g. providing 1023 datapoints to a 1024-point FFT. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast fourier transformation in python using scipy\r\n                \r\nI am using scipy.fft module for calculating Fourier transformation of an array. Now using the module I got the transformation. But my question is how do I know the elements in the transformed array corresponds to which frequency.\nIn short, the module scipy.fft.fft takes an array as input, how it knows that at which frequencies transformation has to be determined.\n    ", "Answer": "\r\nThe ```\nscipy.fft.fftfreq()```\n helper function calculates the frequencies corresponding to the discrete values in the array returned by ```\nscipy.fft.fft()```\n.\nAs an example, assume that you have a signal sampled every 0.25 seconds and it is 10 samples long:\n```\nfrom scipy import fft\n\nn = 10  # number of samples\nd = 0.25  # sample spacing\n\nfrequencies = fft.fftfreq(n, d)\nprint(frequencies)\n```\n\nwhich outputs:\n```\n[ 0.   0.4  0.8  1.2  1.6 -2.  -1.6 -1.2 -0.8 -0.4]\n```\n\nThese correspond to the center frequencies of the bins in your transformed array.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier Transform of experimental Data\r\n                \r\nI've tried to do a fast fourier transform in Matlab of some data taken from an experiment in the windtunnel trying to show the frequency of the velocity variation in a flow, but somehow I keep on getting 0Hz as the main frequency. Anyone has encountered this problem before and knows how to solve it or can explain me a bit better how to do the frequency transform.\n\nPs: It seems to be doing the fast fourier transform alright, the problem might be when converting the data from imaginary to real values\n\nHelp me please!\n\nThank you!\n    ", "Answer": "\r\nThis is a pretty normal thing to encounter. The 0 Hz component (often referred to as the DC component in analogy to the electrical equivalent) is the constant, non-time-varying component of the data -- it's equivalent to the mean of the data. If you have data that does not have a mean of zero, this is a very normal thing to see.\n\nIf you want to, you can calculate the mean and then subtract it from your data series, but this is not really necessary, since it will only change that DC component of the FFT. If you're not interested in the DC component for your purposes, you can simply ignore it.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform in MATLAB\r\n                \r\nI have found a bit of code in MATLAB:\n```\ny = fft(y, nfft);\n```\n\nWhere y is a 512x443 two-dimensional array and nfft = 512.\nI thought that fft is for a one-dimensional array and for a two-dimensional array there should be fft2, but fft is working. How is that possible?\n    ", "Answer": "\r\nFrom the documentation (emphasis mine):\n\nY = fft(x) returns the discrete Fourier transform (DFT) of vector x, computed with a fast Fourier transform (FFT) algorithm.\nIf the input X is a matrix, Y = fft(X) returns the Fourier transform of each column of the matrix.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why the need for a mask when performing Fast Fourier Transform?\r\n                \r\nI'm trying to find out the peak frequencies hidden in my data using the fft() method in R. While preparing the data, a more experienced user recommends to create a \"mask\" (more after explaining the details), that does give me the exact diagram I'm looking for. The problem is, I don't understand what it does or why it's needed.\n\nTo give some context, I'm working with .txt files with around 12000 entries each. It's voltage vs. time information, and the expected result is just a sinusoidal wave with a clear peak frequency that should be close to 1-2 Hz. This is an example of what one of those files look like:\n\n\n\nI've been trying to use the Fast Fourier Transform method fft() implemented in R to find the peak frequencies and get a diagram that reflected them clearly. At first, I calculate some things that I understand are going to be useful, like the Nyquist frequency and the range of frequencies I'll show in the final graph:\n\n```\n    n = length(variable)\ndt = time[5]-time[4] \ndf = 1/(max(time))  #Find out the \"unit\" frequency\nfnyquist = 1/(2*dt) #The Nyquist frequency\n    f = seq(-fnyquist, fnyquist-df, by=df) #These are the frequencies I'll plot\n```\n\n\nBut when I plot the absolute value of what fft(data) calculates vs. the range of frequencies, I get this:\n\n\n\nThe peak frequency seems to be close to 50 Hz, but I know that's not the case. It should be close to 1 Hz. I'm a complete newbie in R and in Fourier analysis, so after researching a little, I found in a Swiss page that this can be solved by creating a \"mask\", which is actually just a vector with a repeatting patern (1, -1, 1, -1...) with the same length as my data vector itself:\n\n```\n    mask=rep(c(1, -1),length.out=n)\n```\n\n\nThen if I multiply my data vector by this mask and plot the results:\n\n```\n    results = mask*data\n    plot(f,abs(fft(results)),type=\"h\")\n```\n\n\nI get what I was looking for. (This is the graph after limiting the x-axis to a reasonable scale).\n\n\nSo, what's the mask actually doing? I undestand it's changing my data point signs in an alternate manner, but I don't get why it would take the infered peak frequencies from ~50 Hz to the correct result of ~1 Hz.\n\nThanks in advance!\n    ", "Answer": "\r\nYour \"mask\" is one of two methods of performing an fftshift, which is commonly done to center the 0 Hz output of an FFT in the middle of a graph or plot (instead of at the left edge, with the negative frequencies wrapping around to the right edge).\n\nTo perform an fftshift, you can hetrodyne or modulate your data (by Fs/2) before the FFT, or simply do a circular shift by 50% after the FFT.  Both produce the same result.  They are the same due to the shift property of the DFT.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in Android\r\n                \r\nWhere can I find a free, very quick, and reliable implementation of FFT in Android? Only I have left to do a porting of the FFT of Matlab in Android to finish the Proyect of the end of career. Thank you for all!\n    ", "Answer": "\r\ncheck this out: FFT library in android Sdk\n\nI personally am using JFFT pack which runs smoothly at analysing audio with an fft window size of 2048.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Understanding the Spectrum obtained after Fast Fourier Transform application or analyse data\r\n                \r\nI have obtained, data by performing some long task and then tried to obtain the Fast fourier transform of it using below code in python. I have attached two file named RK4_step_Gradient_EF_0.01_Harmonics_Data_0.out.npz and RK4_step_Gradient_EF_0.01_Harmonics_Data_1.out.npz on link given below, I used this to obtain the FFT by loading it in the python.\nBut, the spectrum obtained is different from one another. As in figure the blue graph corresponding to data\"RK4_step_Gradient_EF_0.01_Harmonics_Data_0.out.npz\" shows less harmonics, while orange graph with data - \"RK4_step_Gradient_EF_0.01_Harmonics_Data_1.out.npz\" shows many harmonics.\nI want to understand or see how is the data in orange is different from blue. Why does orange curve shows many harmonics as compared to blue curve Or Which part of data in orange curve contributes to so many harmonics. As this is very important for me to analyse. I have tried a lot but cannot understand which data of orange produces so many harmonics. Hence I request if someone can help me to analyse the data or spectrum.\nIn one way I am trying to do reverse process like using spectrum and data, I am trying to see which part of data led to this many harmonics in orange curve as compared to blue curve.\nI humbly request to please please help.\nThank you so much for reading my post.\nHarmonics with Blue and Orange curve\nData Link\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.fftpack import fft, fftfreq, fftshift\nimport matplotlib.pyplot as plt\nfrom numpy import zeros\nimport math\nfrom matplotlib.ticker import ScalarFormatter\nimport plotly.tools as tls\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, iplot\nimport plotly.graph_objects as go\nimport matplotlib as mpl\nfrom mpl_toolkits.mplot3d import axes3d\nsns.set(style=\"whitegrid\")\nimport plotly.io as pio\npio.templates.default = \"simple_white\"\n\nf_name = 'RK4_step_Gradient_EF_0.01_Harmonics_Data_0.out.npz'\n    \ndat_article     = np.load(f_name)\n\n\nAcceleration_x     = dat_article['ax_listG']\nAcceleration_y     = dat_article['ay_listG']\n\n#Fast Fourier Transform\n\nN = 200000\naf_y = fft(Acceleration_y)\naf_x = fft(Acceleration_x)\n\nayf = (af_x**2 + af_y**2)\nay = fftshift(ayf)\n\nxf = fftfreq(N,0.001e-15)\nxf_1 = fftshift(xf)/(37.5e13)\n\nfig = go.Figure()\n\nfig.add_trace(\ngo.Scatter(x=xf_1,y=(1.0/N * np.abs(ay))) )\nfig.update_xaxes(range=[0, 50])\n\nfig.update_layout(yaxis_type=\"log\", title=\"Velocity & Position equal to 0,  Gradient = 0, -1/1e-9\",\n          xaxis_title=\"Harmonic order(ω/ω0)\",\n          yaxis_title=\"FFT of acceleration\",\n          font=dict(family=\"Arial\",size=14,color=\"RebeccaPurple\")) \n\n\nfig.update_layout(legend=dict(\n                                orientation=\"h\",\n                                yanchor=\"bottom\",\n                                y=1.02,\n                                xanchor=\"right\",\n                                x=1\n                            ))\nfig.update_layout(\n    xaxis = dict(\n        tickmode = 'linear',\n        tick0 = 1,\n        dtick = 1\n    )\n)\nfig.write_html(\"Harmonic.html\")\n\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform: using templated derived classes 'undefined reference' error even though header and .cpp file match\r\n                \r\nI'm coding a Fast Fourier Transform algorithm that does the Cooley Tukey method recursively using complex vectors.  The header file and the .cpp file match in parameter name and syntax, but I get the 'undefined reference' error still.  Due to the \"extra\" allocator parameter being mentioned in the error.  I think this might have something to do with using a template for our abstract base class and derived Cooley-tukey class.  All of the problems have come from the FFF_REC function that recursively divides up the input.\n\nGithub: https://github.com/ProgrammerB/Fourier-Transform-Terminal-/blob/master/classes/cooley-tukey.h \n\nI've already tried to change my parameters to references and add a private member into the cooley-tukey class, but I get the same error.  \n\nCooley-Tukey Class:\n\n```\ntemplate<typename T>\nclass Cooley_tukey: protected Fourier<T>{\npublic:\n    Cooley_tukey();\n    Cooley_tukey(std::string file_name, double frequency, double, \n      frequency_step, std::string output_name);\n    //~Cooley_tukey();\n\n    void FFT(const std::vector<T> &index, const std::vector<T> &value);\n\n    std::vector<complex<T>> FFT_REC(std::vector<complex<T>> &temp, int \n      total_time); //recursion function for FFT\n\nprivate:\n    int total_time;\n```\n\n\n};\n\nPart of the error:\n\n```\nclasses\\cooley-tukey.cpp:91:10: error: no matching function for call to \n'Cooley_tukey<double>::FFT_REC(std::vector<std::complex<double>, \nstd::allocator<std::complex<double> > > [(total_time / 2)], int, \nstd::vector<std::complex<double>, std::allocator<std::complex<double> > \n>&)'FFT_REC(odd, total_time/2, result);\n```\n\n\nFFT-Recursion function(source of errors):\n\n```\n    template<typename T>\n    std::vector<complex<T>> Cooley_tukey<T>::FFT_REC(std::vector<complex<T>>& temp, int total_time)\n    {\n        // Check if it is split up enough\n        if (total_time >= 2)\n        {\n\n            // Split even and odds up\n            std::vector<complex<T>> odd[total_time/2];\n            std::vector<complex<T>> even[total_time/2];\n            for (int i = 0; i < total_time / 2; i++)\n            {\n                even->at(i) = temp.at(i*2);\n                odd->at(i)  = temp.at(i*2+1);\n            }\n\n            // Split up tasks through FFT recursion method\n            FFT_REC(even, total_time/2);\n            FFT_REC(odd, total_time/2);\n\n\n            // DFT portion of FFT - calculates after everything has been split up through FFT_REC\n            for (int frequency = 0; frequency < total_time / 2; frequency += this->frequency_step)\n            {\n                std::complex<T> t = exp(std::complex<T>(0, -2 * M_PI * frequency / total_time)) * odd->at(frequency);\n\n                //Result of Cooley-Tukey algorithm:\n                    //*This gives us the frequency values at certain times\n                temp.at(frequency) = even->at(frequency) + t;\n                temp.at(total_time / 2 + frequency) = even->at(frequency) - t;\n\n            }\n        }\n        return temp;\n    }\n\n    template class Cooley_tukey<double>;\n```\n\n    ", "Answer": "\r\nYou’re creating an array of vectors as ```\neven```\n/```\nodd```\n whereas you should just have a vector. The error says there isn’t a method that takes an array of vectors. \n\nI assume you mean:\n\n```\n// Split even and odds up\nstd::vector<complex<T>> odd;\nstd::vector<complex<T>> even;\nodd.reserve(total_time/2);\neven.reserve(total_time/2);\nfor (int i = 0; i < total_time / 2; i++)\n{\n    even.push_back(temp.at(i*2));\n    odd.push_back(temp.at(i*2+1));\n}\n```\n\n\nYou were also trying to use the ```\nat()```\n to set values into empty vectors which would’ve caused errors. Vectors may not have any storage allocated and if you try to index them with ```\nat()```\n you’ll get an exception when it goes out of bounds. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform: using templated derived classes 'undefined reference' error even though header and .cpp file match\r\n                \r\nI'm coding a Fast Fourier Transform algorithm that does the Cooley Tukey method recursively using complex vectors.  The header file and the .cpp file match in parameter name and syntax, but I get the 'undefined reference' error still.  Due to the \"extra\" allocator parameter being mentioned in the error.  I think this might have something to do with using a template for our abstract base class and derived Cooley-tukey class.  All of the problems have come from the FFF_REC function that recursively divides up the input.\n\nGithub: https://github.com/ProgrammerB/Fourier-Transform-Terminal-/blob/master/classes/cooley-tukey.h \n\nI've already tried to change my parameters to references and add a private member into the cooley-tukey class, but I get the same error.  \n\nCooley-Tukey Class:\n\n```\ntemplate<typename T>\nclass Cooley_tukey: protected Fourier<T>{\npublic:\n    Cooley_tukey();\n    Cooley_tukey(std::string file_name, double frequency, double, \n      frequency_step, std::string output_name);\n    //~Cooley_tukey();\n\n    void FFT(const std::vector<T> &index, const std::vector<T> &value);\n\n    std::vector<complex<T>> FFT_REC(std::vector<complex<T>> &temp, int \n      total_time); //recursion function for FFT\n\nprivate:\n    int total_time;\n```\n\n\n};\n\nPart of the error:\n\n```\nclasses\\cooley-tukey.cpp:91:10: error: no matching function for call to \n'Cooley_tukey<double>::FFT_REC(std::vector<std::complex<double>, \nstd::allocator<std::complex<double> > > [(total_time / 2)], int, \nstd::vector<std::complex<double>, std::allocator<std::complex<double> > \n>&)'FFT_REC(odd, total_time/2, result);\n```\n\n\nFFT-Recursion function(source of errors):\n\n```\n    template<typename T>\n    std::vector<complex<T>> Cooley_tukey<T>::FFT_REC(std::vector<complex<T>>& temp, int total_time)\n    {\n        // Check if it is split up enough\n        if (total_time >= 2)\n        {\n\n            // Split even and odds up\n            std::vector<complex<T>> odd[total_time/2];\n            std::vector<complex<T>> even[total_time/2];\n            for (int i = 0; i < total_time / 2; i++)\n            {\n                even->at(i) = temp.at(i*2);\n                odd->at(i)  = temp.at(i*2+1);\n            }\n\n            // Split up tasks through FFT recursion method\n            FFT_REC(even, total_time/2);\n            FFT_REC(odd, total_time/2);\n\n\n            // DFT portion of FFT - calculates after everything has been split up through FFT_REC\n            for (int frequency = 0; frequency < total_time / 2; frequency += this->frequency_step)\n            {\n                std::complex<T> t = exp(std::complex<T>(0, -2 * M_PI * frequency / total_time)) * odd->at(frequency);\n\n                //Result of Cooley-Tukey algorithm:\n                    //*This gives us the frequency values at certain times\n                temp.at(frequency) = even->at(frequency) + t;\n                temp.at(total_time / 2 + frequency) = even->at(frequency) - t;\n\n            }\n        }\n        return temp;\n    }\n\n    template class Cooley_tukey<double>;\n```\n\n    ", "Answer": "\r\nYou’re creating an array of vectors as ```\neven```\n/```\nodd```\n whereas you should just have a vector. The error says there isn’t a method that takes an array of vectors. \n\nI assume you mean:\n\n```\n// Split even and odds up\nstd::vector<complex<T>> odd;\nstd::vector<complex<T>> even;\nodd.reserve(total_time/2);\neven.reserve(total_time/2);\nfor (int i = 0; i < total_time / 2; i++)\n{\n    even.push_back(temp.at(i*2));\n    odd.push_back(temp.at(i*2+1));\n}\n```\n\n\nYou were also trying to use the ```\nat()```\n to set values into empty vectors which would’ve caused errors. Vectors may not have any storage allocated and if you try to index them with ```\nat()```\n you’ll get an exception when it goes out of bounds. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform on Python\r\n                \r\nI would like some guidance on the proper way to compute a FFT on python for a real, non-periodic signal. I am relatively new to coding and signal analysis, so this post will contain questions relatives to both domains.\nTo give some context, here is a graphical representation of my signal (time domain):\n\nand this is the data I am working from:\n```\nt_norm  acc_norm\n1   0.000000  0.000000\n2   0.031918  2.336610\n3   0.063340  1.817758\n4   0.095058  0.544868\n5   0.126293 -0.953833\n6   0.157302  0.217959\n7   0.188844 -1.331151\n8   0.219892 -1.548037\n9   0.251234  2.288458\n10  0.282859  2.837413\n11  0.314361  1.835081\n12  0.345838  1.659622\n13  0.376913  1.309823\n14  0.408362  1.035765\n15  0.439503  0.771576\n16  0.470980  1.235591\n17  0.502364  2.456847\n18  0.533518  1.668552\n19  0.564633  1.076637\n20  0.595747  1.377580\n21  0.626756  0.673881\n22  0.658192  0.529822\n23  0.689240  0.483709\n24  0.720207  1.354278\n25  0.751281  2.072109\n26  0.782463  1.027122\n27  0.813699  0.333459\n28  0.844841  0.406036\n29  0.875902  0.401840\n30  0.906883  0.044780\n31  0.937957  0.557944\n32  0.968992  1.962894\n33  1.000000  1.446186\n```\n\nNote that the device used to record the signal use a variable rate sampling with cross detection to capture data points. It limits (down samples) this to a maximum of 50 points per seconde (50Hz). I have made an histogram to show the distribution of the time intervals between measurements of all my datas :\n\nMETHODOLOGICAL QUESTIONS:\n\nIn regards to the overall shape of my signal (Fig 1), should I detrend it before doing the FFT (I am only interested in the high frequencies) ?\n\nDoes the FFT necessarily require to resample the datas if the rate of sampling is not uniform, even if the distribution of the time intervals between measurements is not really spread out (Fig 2) ?\n\n\nTECHNICAL QUESTIONS (PYTHON):\n\nAll the examples I have seen on internet on how to compute a FFT works from a synthetic signals (directly made in python). I have tried to reproduce the methodology used and adapt it to fit for my signal derived from 'real world' data. The first steps seems to be to calculate some characteristics of the signal, and then to compute the FFT.\nSignal characteristics\nspl_nbr =    # number of sample of the signal\nd_fs =       # sampling frequency, hertz\ni_ns = (2*d_fs)\nd_time = np.linspace(0, (i_ns-1), i_ns)/d_fs # Time series, seconds\nd_f_sig =    # signal freqeuncy, hertz\nd_sig =      # signal itself\nCompute the FFT\ncx_y = rfft(d_sig)/float(i_ns/2.)\nd_ws = rfftfreq(i_ns,1./d_fs)\n\n\nTherefore, I would like to know how to calculate each elements from my datas. I know I can use ```\n.count()```\n function to calculate the number of sample of the signal, but that is pretty much all I can do for now. I am especially wondering on how I should pass the signal information (d_sig) to python.\nThank you in advance for your contributions, and feel free to comment on things that I could be missing in my approach !\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "MemoryError during Fast Fourier Transform on an image using NumPy arrays under Windows\r\n                \r\nThe code could compute Fourier transform from a ```\n.tiff```\n image on my Ubuntu 11.04. On Windows XP it produces memory error. What to change? Thank you.\n\n```\ndef fouriertransform(result):     #function for Fourier transform computation\n    for filename in glob.iglob ('*.tif')\n        imgfourier = scipy.misc.imread(filename) #read the image\n        arrayfourier = numpy.array([imgfourier])#make an array \n        # Take the fourier transform of the image.\n        F1 = fftpack.fft2(arrayfourier)\n        # Now shift so that low spatial frequencies are in the center.\n        F2 = fftpack.fftshift(F1)\n        # the 2D power spectrum is:\n        psd2D = np.abs(F2)**2\n        L = psd2D\n        np.set_printoptions(threshold=3)\n        #np.set_printoptions(precision = 3, threshold = None, edgeitems = None, linewidth = 3, suppress = True, nanstr = None, infstr = None, formatter = None)\n        for subarray in L:\n            for array in subarray:\n                for array in subarray:\n                    for elem in array:\n                        print '%3.10f\\n' % elem\n```\n\n\nThe error output is:\n\n```\nTraceback (most recent call last):\n  File \"C:\\Documents and Settings\\HrenMudak\\Мои документы\\Моя музыка\\fourier.py\", line 27, in <module>\n    F1 = fftpack.fft2(arrayfourier)\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 571, in fft2\n    return fftn(x,shape,axes,overwrite_x)\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 521, in fftn\n    return _raw_fftn_dispatch(x, shape, axes, overwrite_x, 1)\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 535, in _raw_fftn_dispatch\n    return _raw_fftnd(tmp,shape,axes,direction,overwrite_x,work_function)\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 463, in _raw_fftnd\n    x, copy_made = _fix_shape(x, s[i], waxes[i])\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 134, in _fix_shape\n    z = zeros(s,x.dtype.char)\nMemoryError\n```\n\n    ", "Answer": "\r\nI've tried to run your code, except that I replaced the ```\nmahotas.imread```\n with the ```\nscipy.misc.imread```\n function, because I don't have that library, and I could not reproduce your error.\n\nSome further remarks:\n\n\ncan you try to use the ```\nscipy.misc.imread```\n function instead of the ```\nmahotas```\n function? I suppose the issue could be there\nwhat is the actual exception that is thrown? (+other output?)\nwhat are the dimensions of your image? Gray-scale / RGB? Printing all values for a large image could indeed take up quite some memory, so it might be better to visualize the results with e.g. matplotlibs ```\nimshow```\n function.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to create the complex representation from magnitude and phase information to perform an inverse fast fourier transform(IFFT)? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        FFT Images and its Inverse\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have a problem with converting amplitude and phase data into the complex form, which is required to perform an IFFT. (inverse fast fourier transform). This is the only data I have. \n\nMy frequency range goes from 0.1 to 2.6 and, with 200 samples. I would like to use IFFT to obtain a time signal. How do I convert this magnitude and phase dataset into the complex plane?\n\nI have never used IFFT (Or fft) before, so some helpful insights would be very helpful!\n    ", "Answer": "\r\nAssuming you want the complex representation like this:\n\n```\na = 3+4i; \nmagnitude = abs(a);\nphase = angle(a);\n```\n\n\nyou should have magnitude = 5, and theta = 0.9273 \n\nNow to inverse and obtain back your complex representation, use the formula:\n\n```\n z = magnitude*exp(i*phase)\n```\n\n\nif all goes correctly, you should have the complex representation back.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Inverse Fast Fourier Transform Implementation\r\n                \r\nI'm trying to program a FFT algorithm in Python and I've got the initial transform working. It takes in a polynomial in vector form and spits out the evaluation of that vector at the complex roots of unity. The issue arises in my Inverse FFT. This is supposed to take in the evaluation of a function at the complex roots and return the polynomial that passes through those points. This second half is nearly identical to the first, but it uses the inverse of the complex roots. The output of this is scaled by the number of input points, so each coefficient is divided by that number.\nMy code looks like:\n```\nimport math\n\nfrom cmath import sqrt\n\n\ndef getNthRoots(n):\n    # Determines how many roots are needed. Only works for powers of two.\n\n    targetLength = math.pow(2, math.ceil(math.log(n, 2)))\n    newOutput = [1.0 + 0j]\n\n    # Starting with just 1, it takes the sqrt of each term and appends it. Then it appends a negative copy of the list.\n\n    while len(newOutput) < targetLength:\n        previous = newOutput\n        newOutput = []\n\n        for item in range(len(previous)):\n            newOutput.append(sqrt(previous[item]))\n\n        for item in range(len(newOutput)):\n            newOutput.append(newOutput[item] * -1)\n\n    return newOutput\n```\n\nThis works excellently.\n```\ndef FFT(inputList, rootsOfUnity):\n    # End case for the loop\n\n    if len(inputList) == 1:\n        return [inputList[0]]\n\n    # Splits the input list into two parts, one even and one odd\n\n    evenList = [inputList[2 * x] for x in range((len(inputList) // 2))]\n\n    oddList = [inputList[(2 * x) + 1] for x in range(len(inputList) // 2)]\n\n    # Takes the \"square\" of the roots of unity. This is the same as just taking every other entry.\n\n    newRootsOfU = [rootsOfUnity[2 * x] for x in range((len(rootsOfUnity) // 2))]\n\n    # Calls itself with the even and odd halves and the shortened roots of unity\n\n    evenTransform = FFT(evenList, newRootsOfU)\n\n    oddTransform = FFT(oddList, newRootsOfU)\n\n    outputs = []\n\n    # Calculates the output for each root of unity\n\n    for x in range(len(rootsOfUnity)):\n        outputs.append(evenTransform[x % (int(len(rootsOfUnity) / 2))] + rootsOfUnity[x] * oddTransform[\n            x % (int(len(rootsOfUnity) / 2))])\n\n    return outputs\n\nPolyVec1 = [1, 5, 3, 2]\n\n# addZeros just attaches zeros until the length of the list is a power of two\nPolyVec1 = addZeros(PolyVec1)\n\n# Converts PolyVec1 into point form\nrootsOfUnity = getNthRoots(len(PolyVec1))\n\nPolyPoint1 = FFT(PolyVec1, rootsOfUnity)\ntoBeInverted = getNthRoots(len(PolyVec1))\nInvertedRoots = [1 / i for i in toBeInverted]\nreversedFFT1 = FFT(PolyPoint1, InvertedRoots)\nprint(reversedFFT1)\nreversedFFT1Final = [abs(i) / len(reversedFFT1) for i in reversedFFT1]\nprint(reversedFFT1Final)\n```\n\nThis code works fine for converting a polynomial into a series of points. However, when I try and use it to find the inverse it doesn't work for polynomials of a degree greater than 3.\nAny idea why?\nEdit:\nI've had some new insights. The output for any polynomial\n[a, b, c, d, e, f, g, h]\nis\n[a, y, c, z, e, y, g, z]\na, c, e, and g are all consistently interpolated, but b, d, f, and h are not. b and f are replaced by the same value and d and h are replaced by a different value. As long as b and f are identical and d and h are identical, the output will be correct.\nEdit:\nMore insight. It has something to do with complex numbers. No matter the input, a, c, e, g always have no complex component and when b and f or d and h are identical, the output has no complex component. When there is a complex component, the output is incorrect.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "C++ Image 2D Fast Fourier Transform\r\n                \r\nI have to implement 2D FFT transform on the image (I cannot use library to do it for me - part of the course). I use ```\nCImg```\n to load and save images. I have made the following code:\n\n```\nCImg<Complex> FastFourier(CImg<unsigned char> &originalImage)\n{\n    //check size in the main.cpp\n    CImg<Complex> resultantImage = TransformToComplex(originalImage);\n    vector< vector< vector< Complex > > > vectorImage = imageToVector(resultantImage);\n    //cout << \"Transform to complex\" << endl;\n    int size = originalImage.width();\n\n    for(int i = 0; i < size; i++)\n        FastFourier1D(vectorImage[i], false);\n\n    vectorImage = rotateVector(vectorImage);\n\n    for(int i = 0; i < size; i++)\n       FastFourier1D(vectorImage[i], false);\n\n    vectorImage = rotateVector(vectorImage);\n\n    resultantImage = vectorToImage(vectorImage);\n\n    return resultantImage;\n}\n```\n\n\nAnd:\n\n```\nvoid FastFourier1D(vector< vector< Complex > > &input, bool inverse)\n{\n    int size = input.size();\n    double angle;\n\n    if(size <= 1)\n        return;\n\n    int channels = input[0].size();\n    vector< vector< Complex > > even;\n    vector< vector< Complex > > odd;\n\n    for(int i = 0; i < size; i+=2)\n    {\n        vector< Complex > tempEven;\n        vector< Complex > tempOdd;\n        for(int channelIterator = 0; channelIterator < channels; channelIterator++)\n        {\n            tempEven.push_back(input[i][channelIterator]);\n            tempOdd.push_back(input[i + 1][channelIterator]);\n        }\n\n        even.push_back(tempEven);\n        odd.push_back(tempOdd);\n    }\n\n    FastFourier1D(even, inverse);\n    FastFourier1D(odd, inverse);\n\n    for(int channelIterator = 0; channelIterator < channels; channelIterator++)\n    {\n        for(int i = 0; i < size / 2; i++)\n        {\n           if(inverse == false)\n               angle = -2.0 * (double)PI * (double)i / (double)size;\n           else\n               angle = 2.0 * (double)PI * (double)i / (double)size;\n\n           double real = cos(angle);\n           double imaginary = sin(angle);\n\n           Complex W;\n           W.setRP(real);\n           W.setIP(imaginary);\n\n           W = W * odd[i][channelIterator];\n\n           input[i][channelIterator] = even[i][channelIterator] + W;\n           input[(size / 2) + i][channelIterator] = even[i][channelIterator] - W;\n       }\n    }\n}\n```\n\n\nHowever the results are not good. Input image:\n\n\nFFT (without any transform):\n\n\nInverse FFT:\n\n\n\nAs you can see, it has colors of lena, but does not look like lena. Could you help me? Is there any mistake?\n    ", "Answer": "\r\nI found out that the answer was an incorrect implementation of multiplication operator in my ```\nComplex```\n class.\n\n```\nComplex Complex::operator*(const Complex& a)\n{\n    Complex number;\n    double RP = realPart * a.getRP() - imaginaryPart * a.getIP(); // this line was wrong\n    double IP = realPart * a.getIP() + imaginaryPart * a.getRP();\n    number.setRP(RP);\n    number.setIP(IP);\n    return number;\n}\n```\n\n\nIn ```\nreal part```\n, I forgot about ```\nminus```\n. Now the whole implementation is working and fourier successfully converts an image into frequency domain and makes inverse into spatial domain as well.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform polynomial multiplication?\r\n                \r\nI am using the FFT to evaluate a polynomial at certain points so that it can be represented using value representation. (representation as a number of points equal to its degree)\n\nHowever to multiply two polynomials of degree d, I need to evaluate both at 2d + 1 points. However using the FFT for evaluation (multiplying by the dth roots of unity) only evaluates the polynomial at d points. Therefore how can the FFT be used for evaluation for polynomial evaluation if it only evaluates a polynomial at d points? (as opposed to 2d + 1)\n    ", "Answer": "\r\nYou get to choose which n-th roots of -1 you evaluate at. If you need 2d-1 points (as I suspect you do) just use the (2d-1)-th roots of -1. In fact, you would normally use the 2^k-th roots of -1, where 2^k is the first power of 2 >= 2d-1, because it is much easier to get fast FFT for powers of 2. The complexity is still O(d log d) because the definition of O allows for constant factors.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform adjust scaling\r\n                \r\nI'm trying to show trends of my data by doing a FFT. The data I want to perform a FFT on looks like this:\n\n\n\nWithin every year we see a clear trend almost like a sin wave and I thought this should be visible after a FFT transformation but I got this:\n\n\n\nOn the x-axis is hours and on the y-axis the detrended data also in W/m^2. Originally every data point was taken every 16 day within the same year. However, this is not necessarily the case between transitions of two years.\n\nFor the FFT I used this code and the detrended data ```\ndata_plot_multi_year1[\"y\"]-mean(data_plot_multi_year1[\"y\"]```\n can be found here:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nhann = np.hanning(len(data_plot_multi_year1[\"y\"]))\n\nY = np.fft.fft(hann*(data_plot_multi_year1[\"y\"]-mean(data_plot_multi_year1[\"y\"])))\nN = len(Y)/2+1\nfa = 1.0 / (16.0*24*60.0* 60.0)  # every 16th day\nprint('fa=%.7fHz (Frequency)' % fa)\n\nX = np.linspace(0, fa/2, N, endpoint=True)\nXp = 1.0/X                 # in seconds\nXph = Xp /(60.0*60.0*24)   # in days\n\nplt.figure()\nplt.plot(Xph, 2.0 * np.abs(Y[:N]) / N)\nplt.show()\n```\n\n\nSince this is my first time doing something like this, does it need to look like this or how can I make the trends more visible?\n\nThe original data is here: y values and x values.\n    ", "Answer": "\r\nLooking at the original data, I see a very different plot than if I look at the detrended data that you (and the other answers) have used to compute the FFT from.\n\nSo, starting with this original data:\n\n```\nimport numpy as np\nimport matplotlib.pyplt as pp\n\n# Data\ny = np.array([4.9163581574416115, 4.5232489635722359, 5.1418668265986014, 4.7243929349211378, 5.0922668745097237, 3.2505877068809528, 5.266713471351407, 3.2593612955944398, 6.0329599566748149, 5.501028641922999, 3.6033946768899154, 4.0640736190761837, 3.9015401707437629, 4.5497509491042667, 3.7227800407604765, 3.3294036636861795, 3.2400339075816058, 3.4354831362560447, 5.0721090065474757, 4.2898468699869312, 3.9352309911472898, 4.6544147503812772, 3.5076460922078962, 4.8823458504641311, 3.006733596435486, 3.3404353221374912, 4.2604198197171943, 3.5110363901532828, 4.7495904044204913, 4.4755614380567836, 2.8255977501087353, 4.0147937265525631, 4.6982506962329369, 4.1073988606130554, 4.3779635559151062, 3.8455643143910585, 2.8446707334831589, 3.8864340895006602, 5.407473632935444, 3.7776659978957676, 3.7474804428857103, 4.4231421808719968, 4.1145572839087201, 3.4407172122286807, 5.7068484749384503, 3.3175924030243089, 2.8563413179332078, 3.520760038353695, 3.9712227784619754, 5.0318859983482076, 3.7642574784532088, 3.4828932021013372, 3.2259745458147786, 5.032377633970162, 5.2464640619126435, 4.9482379500988491, 3.798306221105471, 3.3672821755011646, 4.8054046257516898, 4.5758461857175972, 4.4079132488332275, 3.5862463276840586, 5.0281771086563696, 3.9038881511201029, 3.5464781504503957, 3.752348181547787, 3.1520445958602115, 4.370394739799015, 3.896389496115487, 4.118225887215103, 4.802537302837913, 4.1800322086907791, 3.9270327778098264, 2.9892139644432794, 3.5412442495098522, 4.9353516122953636, 3.6311330623837823, 3.4788493170853205, 3.4571475745293054, 5.3964493189396956, 4.0166801210413112, 3.184902965087919, 4.3231987474246907, 3.821044625315142, 3.2501749085457448, 4.1218393070599149, 3.4907498564324784, 3.7048147909485549, 4.4067985127175193, 3.2628048471339661, 3.4299356612804384, 3.054687769820104, 3.4394826446333515, 3.8926147692854536, 3.5274891297329392, 5.1600491179626147, 5.1267218406912436, 4.9196604682508616, 3.288844643645831, 5.0123334575721739, 5.8837792219610296, 3.6525485317948769, 5.2655629050160382, 4.5940509381861077, 3.5326474318629821, 4.7549446018611174, 5.5400627941766389, 4.2340183526794908, 3.833235556736899, 4.1055923866919404, 3.9041368756551273, 2.8355474432294439, 5.0365898742249708, 5.558027054794378, 3.0385703101397779, 4.1301188661365806, 3.4824265559683489, 3.9319218096961523, 3.0332372505317466, 4.0506899500473681, 5.298987852183183, 3.2070084334136282, 3.4802868005912773, 3.2223945502453342, 3.6057387919024859, 4.1135183367430654, 5.4774825204501179, 3.7504701089542696, 3.3997275593227916, 4.0280467030451277, 5.1921516666697185, 4.1662957219173871, 4.9276361137412961, 4.3055659900345269, 4.2160192742975298, 4.5582352743558525, 3.5779282232857184, 3.3303571863388153, 4.7062814020334001, 3.763690626719586, 4.020276538555315, 3.2952422897541718, 4.3944836078620826, 5.0651527836251846, 3.2736433168588834, 4.0164274892409875, 4.6926928415631961, 3.5439697283257536, 4.8170195490454715, 5.1717553137007295, 4.47489761280195, 4.2721415529277245, 3.7722293780212186, 4.6163723178866256, 3.4852465925030596, 3.5081857100611429, 4.9526591274218141, 2.7418823869877671, 5.2309064498443112, 2.9584799885836368, 5.9208165893988971, 3.7266204734555268, 3.9696836775155155, 3.0817605147405351, 5.3501874894485368, 4.823298910487158, 4.094371587882315, 3.666534185013655, 4.3613972464934943, 3.5253937700241282, 3.5114759216562974, 3.7387872601144321, 3.2428544820295313, 4.3174760573045647, 3.8153701553661081, 5.3510324878858881, 5.887473202470229, 5.2483141940171967, 3.6730647722321899, 3.2527108096051762, 5.087119161099805, 5.4376786692500971, 5.1985667958007626, 4.0776721320121245, 4.0746559030897966, 5.3838863415603209, 2.9772622863398106, 4.4371692352610923, 4.824375079864156, 5.1574523180746281, 3.6417281403335027, 3.7353723232513896, 4.8786928981111108, 3.1549797688883685, 4.9273350311811477, 4.8909872856262631, 5.0733312023802286, 4.7195548768733193, 3.2117711403989326, 4.0607353048756289, 3.2068686273897913, 3.8104210279601221, 4.0764549403056849, 5.1905644211359325, 4.9059727970323124, 4.3312408753376159, 4.495834529789291, 3.7017758002769088, 3.8928592560408886, 3.3590820111611572, 5.6800192429325946, 5.2801982921123018, 3.4971867534798688, 4.1434397763487363, 5.0320214435810486, 3.2572048463905596, 3.5708589225079157, 5.5420277180979705, 4.816537191178262, 4.7123032533220774, 4.6276901989665546, 3.3033314780041207, 3.7031834923679217, 4.9531169434719784, 3.9520303484745076, 4.7069324020275154, 3.3485205880519819, 3.578929442922882, 5.0416858356367751, 3.2471486950110151, 4.8036517687546469, 2.9564023409041931, 4.370824090704172, 3.3111933909292781, 5.4693269793385397, 5.9471091984264612, 5.5997609124508001, 3.253791264246908, 5.5589687791680173, 4.0347612835986313, 5.0860759232647048, 3.8236359577497381, 4.2502050750154163, 5.3804473886648889, 3.0777806788604702, 4.3119059095678196, 3.6076909731506221, 3.6675311219295414, 4.5761803934468732, 4.1294871300142644, 3.6827073669759471, 3.9918347122796098, 3.4194166080890587, 5.3442479778374041, 3.325200562869143, 5.4364117543671719, 2.7691861112204053, 3.2431028421965107, 5.7997059152735284, 5.1396423172415746, 3.8341163596077106, 4.6158592382839672, 5.2991510313934427, 4.2613846468512486, 3.3747692135915655, 3.7002229064232939, 3.1618285314537342, 5.3066215213431933, 3.4764287458899688, 4.2664404462781276, 3.7020536806298709, 4.4920788644955021, 4.7765300011524729, 3.6234351180642332, 4.2676647387441031, 3.1419131638878253, 5.0149070978243522, 3.6335404191164362, 5.6667351882464283, 3.4029057890404824, 4.1230483413169239, 4.8245272024467116, 3.65830252796454, 4.4813334423826712, 3.6740443622552865, 4.1977102616532935, 4.1320785201142503, 3.1085193591271505, 5.0012055352868723, 4.0428697712217607, 5.201396550122233, 5.5110799401116326, 3.2437611839952023, 4.8397817377344712, 5.4850675142216154, 3.627247179469125, 4.0577205671254726, 2.5798969377153802, 4.6359100698702171, 4.7640011574006191, 5.8635971341249009, 3.6510638760009013, 3.2845760628978011, 5.1435067636186025, 3.8973081092150159, 3.1445177808730125, 3.5112954060023718, 5.5052935046977147, 4.0618208001814811, 5.2828398404225272, 4.8693030005934981, 3.413421242301824, 5.7045184220496115, 5.3221412413004741, 4.3631763041559992, 4.188513180452488, 3.9197228949008855, 4.2780523472142535, 3.695429486781181, 4.8294238192705237, 5.264103644882745, 5.0998049360010391, 5.5094161509890887, 4.3214874721201451, 3.6102609731613162, 5.2723061570113243, 3.8298642965515364, 4.8098072099418445, 3.632970055942816, 3.5542517670129983, 4.9124440128270983, 5.0786806222541223, 5.0248576192789542, 5.0029379966378063, 3.1383857221712161, 5.4119593837374813, 5.2071519069366392, 4.81942138782507, 5.4131759970726518, 4.9823428242283274, 4.0704364655939997, 3.6092965241074735, 4.7229918731679614, 4.7586642729235562, 3.9002260395078925])\nx = np.array([2817, 1960, 3500, 1357, 183, 1482, 1642, 372, 2008, 1626, 2641, 5228, 2865, 4277, 1437, 3612, 359, 752, 5276, 1578, 1754, 1341, 2212, 1261, 4402, 2593, 3054, 4021, 5008, 3420, 676, 3324, 2340, 2136, 4149, 3278, 71, 1024, 4944, 3752, 1181, 628, 2657, 3736, 4594, 3976, 4738, 5132, 5452, 532, 3372, 1546, 2913, 5260, 2753, 2769, 311, 1072, 5340, 3198, 5372, 2625, 1690, 4482, 2990, 4309, 4373, 848, 3356, 295, 1706, 2308, 39, 2244, 4450, 1213, 1149, 4085, 2926, 2372, 3388, 708, 5056, 4816, 5180, 103, 4690, 4706, 2468, 4466, 452, 3720, 1880, 2184, 4752, 2705, 215, 1610, 4008, 3864, 1658, 468, 199, 5388, 3596, 516, 3150, 1738, 5212, 5404, 2881, 1848, 2420, 5308, 4418, 4514, 768, 4053, 2577, 5104, 4960, 3308, 4101, 816, 4784, 1117, 2356, 3656, 4117, 3262, 3118, 644, 1245, 5072, 3784, 2673, 5196, 3960, 3532, 5436, 5040, 4722, 4642, 960, 420, 484, 4880, 5148, 2088, 4229, 1594, 1944, 327, 3912, 784, 1088, 247, 388, 1992, 1466, 3086, 1802, 2484, 4325, 3468, 3166, 1421, 3628, 2452, 2958, 2532, 4386, 23, 1197, 5088, 4546, 2388, 596, 4832, 4357, 1293, 1309, 4992, 4848, 119, 3848, 55, 1008, 3816, 612, 2168, 4768, 5324, 2276, 1976, 2801, 4610, 3516, 3688, 1040, 3992, 4674, 3944, 2056, 4261, 5244, 1722, 4341, 3580, 736, 896, 2785, 3644, 279, 5292, 4037, 1770, 4197, 3038, 976, 3214, 2609, 2500, 3436, 1405, 1229, 1133, 2260, 151, 1896, 3800, 4069, 4133, 4434, 564, 4578, 3102, 2196, 912, 3564, 4896, 5420, 4658, 2721, 87, 2104, 5116, 1928, 2833, 2120, 1056, 3928, 1832, 231, 1498, 2024, 404, 1818, 1674, 3070, 3340, 864, 3484, 4293, 2974, 2548, 343, 2404, 1453, 1389, 1562, 5356, 4165, 2228, 1373, 2561, 4530, 2942, 1277, 692, 1514, 5024, 2516, 4864, 1912, 4800, 2152, 3672, 992, 3246, 3832, 4928, 1165, 2324, 2040, 1864, 3768, 3704, 3880, 2689, 944, 1530, 5164, 2072, 5468, 436, 2897, 4245, 1101, 3134, 3896, 800, 2737, 167, 263, 3404, 3022, 4498, 1786, 1325, 3452, 3182, 880, 2849, 3292, 4976, 832, 2436, 7, 2292, 4562, 548, 4181, 580, 724, 928, 4213, 4626, 4912, 3548, 660, 3230, 135, 500, 3006])\n```\n\n\nWe first notice that the x-values are not sorted. Let's sort the data:\n\n```\n# Sort data on x values\nindex = np.argsort(x)\ny = y[index]\nx = x[index]\n```\n\n\nNext, we notice that the x locations are not evenly spaced. The FFT expects even-spaced data. Let's resample the data to make it evenly spaced:\n\n```\n# Interpolate data so it is regularly sampled\nn = len(x)\nnewx = np.linspace(x[0], x[-1], n)\ny = np.interp(newx, x, y)\nx = newx\n```\n\n\nNow we can confidently compute the FFT and plot, just like in the question:\n\n```\n# Compute FFT and plot\nY = np.fft.fft(y - np.mean(y))\nfa = 365.0 / (x[1] - x[0]) # samples/year\nN = n//2+1\nX = np.linspace(0, fa/2, N)\n\npp.figure()\npp.plot(X, abs(Y[:N])) # I'm ignoring all that scaling here, it's irrelevant...\npp.show()\n```\n\n\n\n\nWe now clearly see a peak at 1 cycle/year, as expected!\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform - Multiplying Polynomials?\r\n                \r\ni just don't understand how to perform a FFT on two polynomials such as X^2+1 and X+1...can anyone step by step go through the process with me?\n\nThanks very much\n    ", "Answer": "\r\nJust use your polynomial coefficients as input for fft:\n\n```\noctave:16> poly1=[1 0 1 0]\npoly1 =\n\n   1   0   1   0\n```\n\n\nNote: this means x^2+1\n\n```\noctave:17> poly2=[1 1 0 0]\npoly2 =\n\n   1   1   0   0\n\noctave:18> ifft( fft(poly1).*fft(poly2))\nans =\n\n   1   1   1   1\n```\n\n\nThis is the result. Interpret as x^3+x^2+x+1, which is the product of the two polynomials.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Magnitude Values within Fast Fourier Transformation FFT are different by constant input signal?\r\n                \r\nWithin my Beat-Detection, I'm using a Fast Fourier Transformation to detect the bass within an audio Signal. Im recording a solo basedrum, not moving the sound or volume. After plotting the values over time. I get non constant values. They differ very strong. Maybe you got an idea why this happens?\nI can only guess but maybe Im not using the right Buffersize or WindowSize for the FFT?\n\nDown a plotted graphic and the source code\n\nprivate class RecordingThread extends Thread {\n\n```\n    private boolean mShallContinue = true;\n\n    @Override\n    public void run() {\n// Compute the minimum required audio buffer size and allocate the\n    // buffer.\n    mBufferSize = 4096;// AudioRecord.getMinBufferSize(SAMPLING_RATE,\n                        // //4096;//\n                        // AudioFormat.CHANNEL_IN_MONO,\n\n    mAudioBuffer = new short[1024];// [mBufferSize / 2];\n    bufferDouble2 = new int[mBufferSize / 2];\n    bufferDouble = new int[(blockSize - 1) * 2];\n    camera = Camera.open();\n\n}\n        AudioRecord record = new AudioRecord(\n                MediaRecorder.AudioSource.DEFAULT, SAMPLING_RATE,\n                AudioFormat.CHANNEL_IN_MONO,\n                AudioFormat.ENCODING_PCM_16BIT, mBufferSize);\n\n        short[] buffer = new short[blockSize];\n        double[] audioDataDoubles = new double[(blockSize * 2)];\n        double[] re = new double[blockSize];\n        double[] im = new double[blockSize];\n        double[] magnitude = new double[blockSize];\n\n        // start collecting data\n        record.startRecording();\n\n        DoubleFFT_1D fft = new DoubleFFT_1D(blockSize);\n        synchronized (this) {\n            while (shallContinue()) {\n\n                /** decibels */\n                record.read(mAudioBuffer, 0, 1024);\n                // updateDecibelLevel();\n\n                /** frequency */\n                // /windowing!?\n                for (int i = 0; i < mAudioBuffer.length; i++) {\n                    bufferDouble2[i] = (int) mAudioBuffer[i];\n                }\n\n                for (int i = 0; i < blockSize - 1; i++) {\n                    double x = -Math.PI + 2 * i * (Math.PI / blockSize);\n                    double winValue = (1 + Math.cos(x)) / 2.0;\n                    bufferDouble[i] = (int) (bufferDouble2[i] * winValue);\n                }\n\n                int bufferReadResult = record.read(buffer, 0, blockSize);\n\n                // Read in the data from the mic to the array\n                for (int i = 0; i < blockSize && i < bufferReadResult; i++) {\n                    audioDataDoubles[2 * i] = (double) buffer[i] / 32768.0; // signed\n                                                                            // 16\n                                                                            // bit\n                    audioDataDoubles[(2 * i) + 1] = 0.0;\n                }\n\n                // audiodataDoubles now holds data to work with\n                fft.complexForward(audioDataDoubles); // complexForward\n\n                for (int i = 0; i < blockSize; i++) {\n\n                    // real is stored in first part of array\n                    re[i] = audioDataDoubles[i * 2];\n                    // imaginary is stored in the sequential part\n                    im[i] = audioDataDoubles[(i * 2) + 1];\n\n                    // magnitude is calculated by the square root of\n                    // (imaginary^2 + real^2)\n                    magnitude[i] = Math.sqrt((re[i] * re[i])\n                            + (im[i] * im[i]));\n                }\n                magnitude[0] = 0.0;\n\n                magnitude2 = magnitude[2];\n                magnitude3 = magnitude[3];\n                magnitude4 = magnitude[4];\n\n                updateShortBuffer();\n                bufferCount++;\n                updateLongBuffer();\n\n                // if (detectedRoomRMS == 200)\n                updateFrequency();\n                System.out.println(System.currentTimeMillis() + \" M2: \"\n                        + magnitude2 + \" M3: \" + magnitude3 + \" M4: \"\n                        + magnitude4 + \" M5: \" + magnitude[5] + \" M10: \"\n                        + magnitude[10] + \" M20: \" + magnitude[20] + \" M24: \"\n                        + magnitude[24] + \" M48: \" + magnitude[48] + \" LONG20: \"\n                        + rms_Long_Buffer_five + \" LONNG: \"\n                        + rms_Long_Buffer);\n            }\n            record.stop(); // stop recording please.\n            record.release(); // Destroy the recording, PLEASE!\n        }\n    }\n\n    /**\n     * true if the thread should continue running or false if it should stop\n     */\n    private synchronized boolean shallContinue() {\n        return mShallContinue;\n    }\n\n    /**\n     * Notifies the thread that it should stop running at the next\n     * opportunity.\n     */\n    private synchronized void stopRunning() {\n        mShallContinue = false;\n    }\n\n}\n\n// / post the output frequency to TextView\nprivate void updateFrequency() {\n    tvfreq.post(new Runnable() {\n\n        String RoomRMS;\n        String s;\n\n        public void run() {\n\n            if (RMSMessureDone == false) {\n                String l = \"..\";\n                String KK = \"...\";\n                tvfreq.setTextColor(Color.WHITE);\n                if ((rmsCounter > 10))\n                    tvfreq.setText(KK); //\n                else\n                    tvfreq.setText(l);\n            } else {\n                BPM = round(BPM, 1);\n                s = Double.toString(BPM);\n                s = s + \" bpm\";\n                tvfreq.setTextColor(Color.WHITE);\n                tvfreq.setText((s));\n\n                RoomRMS = Double.toString(detectedRoomRMS);\n                tvdb.setText(RoomRMS);\n            }\n        }\n\n    });\n\n}\n```\n\n    ", "Answer": "\r\nI imagine the discrepancies you see have to do with the relationship of the onset with the window used for the FFT.\n\nFundamentally, the approach you are using is the wrong one for this problem:\n\n1: The nature of the signal: The signal from a bass drum (and by this I assume you probably mean a kick drum?), features a sharp onset (it's just been hit hard), with a rapid decay. The initial peak is incoherent with a wide bandwidth; it's essentially white noise.  Whilst there will be plenty of low frequency content in there, it won't dominate.  After the initial attack, the drum skin vibrates at its natural frequency, with much lower output than the initial peak. \n\n2: Looking through the square window: You're currently applying a square window function to your samples. This is not a winning choice as it splatters energy into places you don't want it. The Hamming and Blackman windows are common choices with FFTs.  \n\n3: Resolution: The fundamental flaw with using an FFT is that it is windowed. The results of an DFT is simply contribution of each frequency bin over the period of the window.  The window period limits your temporal resolution (you only know that an event with in the range of frequencies occurred somewhere with in the window).   On the other hand, if you want meaningful results from the low frequency bins of the FFT, Nyquist's theory applies with respect to the frequency of the window relative to the signal measured.   Let's say you sample at 44.1kHz, this means you need a 2048 point DFT if you want meaningful results at, say, 50Hz.  Each window now has a period of 0.047s (or about 1/20s). This is your margin of error on each temporal measurement.  \n\nThere are a variety of time-domain onset-detection algorithms out there that are commonly used for beat-detection.  You might use a frequency-domain approach in tandem if you wanted to detect the likely source of a signal.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transformation - Rounding Errors\r\n                \r\nI am transforming an image to a frequency spectrum, convolving it with a kernel, then inverse-transforming it back.\n\nI wanted to ask how I can handle the rounding errors which occur during the transformation. Like when I transform an image, then immediately transform it back I have an average PSNR of 127. (I transform the pixels in float format between 0.0 and 1.0.)\n\nIs it possible to calculate the errors and correct them?\n    ", "Answer": "\r\nShort answer: If you want less rounding error, then you need a more accurate number format. Also, you cannot calculate the error.\n\nMore accurate floating-point formats include:\n\n\nx87 80-bit extended precision (long double)\nFixed point with BigInteger\nBigDecimal\n\n\nAlso, isn't a PSNR of 127 dB very good already?\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to compute the gradient of a multidimensional array using numpy's fast Fourier transform\r\n                \r\nI wrote this short and simple python method the other day\n```\ndef dFFT_1D(f):\n    k = 2*np.pi * np.fft.fftfreq(f.shape[0])\n    return np.fft.ifft(1j*k * np.fft.fft(f)).real\n```\n\nwhich takes a one-dimensional array containing samples of a scalar function (step size is taken as unity) as input argument and returns the derivative using numpy's fast Fourier transform.\nMy goal is to generalize this method; so that it will take a multidimensional array and return the gradient/derivative along any of its axis.\n```\ndef dFFT(f, axis):\n    k = 2*np.pi * np.fft.fftfreq(f.shape[axis])\n    return np.fft.ifftn( 1j*k * np.fft.fftn(f) ).real\n```\n\nfor the sake of simplicity, let us take f to be two-dimensional array with shape (m,n) and say I wish to compute its derivative along its first axis (i.e. axis=0) using the above method. Then, my problem simply is that k has shape (m,) and therefor can't be broadcasted together with a (m,n) array. I have so far been able to come up with to different attempts at resolving this. My first attempt is simply to expand the dimension of k by\n```\nk = np.expand_dims(k, axis).T\n```\n\nwhich ensure that k has shape (n,1). My second attempt is to begin by swapping the axis of f\n```\nf = np.swapaxes(f, 0, axis)\n```\n\nHowever, both of these approaches doesn't seem elegant (as in efficiency and readability). I am also afraid that they don't really extend beyond the two-dimensionally case. I have tried reaching for a solution online, so far unsuccessfully.\nCheers!.\n    ", "Answer": "\r\nYou should be able to do\n```\n1j * k[:, None] * np.fft.fftn(f)\n```\n\nto line up dimensions.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to get data from a notepad file and use fft (fast fourier transform on it)\r\n                \r\nI am a bit of a novice with programming as we are being made to do it in our physics degree. I am using Python 2.\n\nI've been given a txt file with two columns of data, the first few lines look like this:\n\n```\n0.000000000000000000e+00 7.335686114232199684e-02 \n1.999999999999999909e-07 7.571960558042964973e-01\n3.999999999999999819e-07 9.909475704320810374e-01\n5.999999999999999728e-07 3.412754086075696081e-01\n7.999999999999999638e-07 -5.558766000866324219e-01\n9.999999999999999547e-07 -9.810046985453722002e-01\n1.199999999999999946e-06 -5.436864816312496629e-01\n1.399999999999999937e-06 2.645021165628647641e-01\n1.599999999999999928e-06 9.667259209284312371e-01\n1.799999999999999919e-06 7.395753817164774091e-01\n1.999999999999999909e-06 7.289488801158025555e-02\n2.200000000000000112e-06 -7.925906572709742193e-01\n2.399999999999999891e-06 -9.727702002847055107e-01\n2.599999999999999671e-06 -1.772398644968510018e-01\n2.799999999999999873e-06 6.627909312992285029e-01\n3.000000000000000076e-06 1.022032186188189362e+00\n3.199999999999999855e-06 5.531242183135693935e-01\n```\n\n\nand on it goes for many hundreds of lines.\n\nThe question asks:\nThis week you have been provided with a file which consists of a simulated NMR time domain response following an external impulse. This free induction decay (FID) is characterized by a frequency, an initial amplitude and a decay constant. The data has a single \noscillation frequency and the second contains a mixture of two frequencies.\nWrite a program to evaluate the Fast Fourier transform of both signals and plot them\nin the frequency domain.\n\nCould someone give me an example of how I might go about doing this? Unfortunately we are not given much guidance in the lab, just some online tutorials and otherwise told to google stuff.\n    ", "Answer": "\r\nI'll turn my comment into an answer:\n\nIt is actually very easy. Load your data using numpy.genfromtxt() into a numpy array, and then you can choose some form of FFT from numpy.fft.\n\nAs this is your exercise I won't write down exact code but that basically sums it.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Can't plot results of matlab 2D fast fourier transform\r\n                \r\nI conducted a 2D fourier transform on a 4436413x3 matrix using the matlab fft2 command (this one: https://www.mathworks.com/help/matlab/ref/fft2.html). The product is a 4436413x3 matrix containing complex values. When I try to plot the data, I end up with a graph that is all one color or an error message that references the complex values in my data.\nI have tried interpolating to create a 2D set of values using the griddata() function, however, when applied to my 3D dataset, this returns a 1D vector equal to the z-column in my original 3D dataset. My 3D dataset consists of x, y, and z points, and in my attempt to interpolate I used vq = griddata(x,y,z,x,y). I had also tried to create a 4436412x3 meshgrid for my query points (using [xq, yq] = meshgrid(4436412, 3), and then using xq and yq as my query points), but this was returning NaN.\nWhen I run\nY = fft2(x);\nimagesc(abs(fftshift(Y)))\nI get a single purple box.\nWhen I run\nY = fft2(x);\nimagesc(Y)\nI get the following error message:\n```\nError using image\nComplex values are not supported. Specify the color data as numeric or logical values.\n\nError in imagesc (line 52)\n    hh = image(varargin{:}, 'CDataMapping', 'scaled');\n```\n\n    ", "Answer": "\r\nTo apply the FFT, you need data to be sampled on a regular grid. Your data represents (x,y,z) coordinates of points. Here's how to use ```\ngriddata```\n to resample these coordinates onto a regular (x,y) grid:\n```\n% Generate example data, let's say x and y are in the range [-3,3]:\nn = 62500;\nx = rand(n, 1) * 6 - 3;\ny = rand(n, 1) * 6 - 3;\nz = sin(4*x) + cos(2*y); % an example function\ndata = [x,y,z]; % This is a 4436413x3 array with (x,y,z) coordinates\n\n% Interpolate z values onto a regular (x,y) grid:\n[xq, yq] = meshgrid(linspace(min(x), max(x), sqrt(n)), ...\n                    linspace(min(y), max(y), sqrt(n)));\nzq = griddata(x, y, z, xq, yq);\n\n% griddata doesn't extrapolate, writes NaN instead. Let's fill those\n% in with zeros (maybe a different value is more meaningful in your\n% application).\nzq(isnan(zq)) = 0;\n\n% Now you can apply a 2D Fourier transform:\nZ = fft2(zq);\nimshow(log(abs(fftshift(Z))), []);\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Inverse fast fourier transform algorithm on Android\r\n                \r\nI use AudioRecord on Android to record audio,read into the buffer and use FFT algorithm to transform to frequencies blocks.Now Can I use inverse FFT algorithm to recover the data and playback the sound i have recorded?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how to calculate and plot the fast fourier transform of sla data (3 d matrix) in matlab?\r\n                \r\nI want to check for the existent dominant peaks in sla data(3 d matrix lon, lat ,time) from which I can delineate what period to choose so that I can filter this data and look for waves propagating in the region. My data is for all lat and lon(global data). However, I want to average over a lon range of 70E to 100E and after that average over 10S to 10N. This average will give a a vector only in time dimension over which I can perform fast fourier transform. Then I want to plot this with time as the x axis. I'm new to matlab, any help is appreciated. Also if anyone has done this before it would be nice if you told  me if my logic is correct or not. \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how fft (fast Fourier transform) works\r\n                \r\nI am a learner of python and developing a small project related to image analysis, to learn the concept I tried to understand various python codes, but this time I sucked and can any one explain this code ? Especially the FFT part ? \n\n```\nclass HeartMonitor(object):\n\n    def __init__(self, window_duration, fps = 30, min_bpm = 50, max_bpm = 200):\n        \"\"\"\n        Class which detects heart-beats in a sequence of image colour samples.\n        @param window_duration The number of seconds of samples to use\n        @param fps             The nominal sample rate\n        @param min_bpm         Minimum cut-off for possible heartrates\n        @param max_bpm         Maximum cut-off for possible heartrates\n        \"\"\"\n\n        self.min_bpm = min_bpm\n        self.max_bpm = max_bpm\n\n        # The maximum number of samples to buffer\n        self.buf_size = int(window_duration*fps)\n\n        # Buffer of (timestamp, value) tuples\n        self.buf = []\n\n\n    @property\n    def fps(self):\n        \"\"\"\n        The average framerate/samplerate of the buffer\n        \"\"\"\n        return float(len(self.buf)) / (self.buf[-1][0] - self.buf[0][0])\n\n\n    def get_fft(self):\n        \"\"\"\n        Perform an Fast-Fourier-Transform on the buffer and return (magnitude,\n        phase) tuples for each of the bins.\n        \"\"\"\n        # Get the \"ideal\" evenly spaced times\n        even_times = numpy.linspace(self.buf[0][0], self.buf[-1][0], len(self.buf))\n\n        # Interpolate the data to generate evenly temporally spaced samples\n        interpolated = numpy.interp(even_times, *zip(*self.buf))\n\n        # Perform the FFT\n        fft = numpy.fft.rfft(interpolated)\n        return zip(numpy.abs(fft), numpy.angle(fft))\n```\n\n    ", "Answer": "\r\n```\nnumpy.fft.rfft```\n is a library function that computes an fft from real data\n\nThe samples need to be evenly spaced in the time domain.\n\nSince some samples may not be evenly spaced in ```\nbuf```\n they are interpolated using ```\nnumpy.interp```\n\n\n```\nself.buf[0]```\n is the first item of ```\nbuf```\n\n```\nself.buf[-1]```\n is the last item of ```\nbuf```\n\n```\nlen(self.buf)```\n is the number of items in ```\nbuf```\n\n\nSo you end up with the same number of samples, but moved along the time axis so they are evenly spaced (stored in the variable ```\ninterpolated```\n).\n\nNow ```\ninterpolated```\n can be passed to ```\nnumpy.fft.rfft```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to calculate Frequency with Fast Fourier Transformation\r\n                \r\ni am working on a pulse sensor project. I get data from the sensor like this:\n\n\nNow i would like to use this code:\n\n```\n  #include <complex>\n#include <iostream>\n#include <valarray>\n\nconst double PI = 3.141592653589793238460;\n\ntypedef std::complex<double> Complex;\ntypedef std::valarray<Complex> CArray;\n\n// Cooley–Tukey FFT (in-place, divide-and-conquer)\n// Higher memory requirements and redundancy although more intuitive\nvoid fft(CArray& x)\n{\n    const size_t N = x.size();\n    if (N <= 1) return;\n\n    // divide\n    CArray even = x[std::slice(0, N/2, 2)];\n    CArray  odd = x[std::slice(1, N/2, 2)];\n\n    // conquer\n    fft(even);\n    fft(odd);\n\n    // combine\n    for (size_t k = 0; k < N/2; ++k)\n    {\n        Complex t = std::polar(1.0, -2 * PI * k / N) * odd[k];\n        x[k    ] = even[k] + t;\n        x[k+N/2] = even[k] - t;\n    }\n}\n\n// Cooley-Tukey FFT (in-place, breadth-first, decimation-in-frequency)\n// Better optimized but less intuitive\n// !!! Warning : in some cases this code make result different from not optimased version above (need to fix bug)\n// The bug is now fixed @2017/05/30 \nvoid fft(CArray &x)\n{\n    // DFT\n    unsigned int N = x.size(), k = N, n;\n    double thetaT = 3.14159265358979323846264338328L / N;\n    Complex phiT = Complex(cos(thetaT), -sin(thetaT)), T;\n    while (k > 1)\n    {\n        n = k;\n        k >>= 1;\n        phiT = phiT * phiT;\n        T = 1.0L;\n        for (unsigned int l = 0; l < k; l++)\n        {\n            for (unsigned int a = l; a < N; a += n)\n            {\n                unsigned int b = a + k;\n                Complex t = x[a] - x[b];\n                x[a] += x[b];\n                x[b] = t * T;\n            }\n            T *= phiT;\n        }\n    }\n    // Decimate\n    unsigned int m = (unsigned int)log2(N);\n    for (unsigned int a = 0; a < N; a++)\n    {\n        unsigned int b = a;\n        // Reverse bits\n        b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n        b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n        b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n        b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n        b = ((b >> 16) | (b << 16)) >> (32 - m);\n        if (b > a)\n        {\n            Complex t = x[a];\n            x[a] = x[b];\n            x[b] = t;\n        }\n    }\n    //// Normalize (This section make it not working correctly)\n    //Complex f = 1.0 / sqrt(N);\n    //for (unsigned int i = 0; i < N; i++)\n    //  x[i] *= f;\n}\n\n\nint main()\n{\n    const Complex test[] = { 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 };\n    CArray data(test, 8);\n\n    // forward fft\n    fft(data);\n\n    std::cout << \"fft\" << std::endl;\n    for (int i = 0; i < 8; ++i)\n    {\n        std::cout << data[i] << std::endl;\n    }\n\n    }\n    return 0;\n}\n```\n\n\nTo calculate the frequency of my heartbeat. The problem i have right now is making sense of the output i get:\nfft\n(4,0)\n(1,-2.41421)\n(0,0)\n(1,-0.414214)\n(0,0)\n(1,0.414214)\n(0,0)\n(1,2.41421)\n\nWhat is this? I think it is the Amplitude and the phase, but i dont know how to calculate from that the frequency. \n\nThe frequency of a pulse is around 0.33 Hz to 3 Hz. Is the resolution of this code good enough? I never had to work with fourier transformation\n\nThanks for the help. I look forward to your answers. \n    ", "Answer": "\r\nThe complex numbers that are outputs of the FFT are the coefficients that the component sine waves are multiplied by. Essentially they are rectangular coordinates, and the equivalent polar coordinates of magnitude and angle would give you the amplitude and phase.\n\nThe frequency is determined by position in the array. The element at index i is for the sampling frequency multiplied by i/N, where N is the number of elements in the FFT.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Using Fast Fourier Transform on matlab?\r\n                \r\nI am having some difficulty in solving a simple 2D Poisson equation in Matlab using spectral methods in one direction on finite difference in the other.\n\nI am obtaining a scaled version of the correct answer but can't work out why although I think it has something to do with the wavenumber.\n\nAny help would be greatly appreciated, the code can be seen below.\n\n```\nN = 32;\nx = ((0:N-1)/N)*2*pi;\ny = ((0:N-1)/N)*2*pi;\ndx = 2*pi/N;\nk  =  fftshift(-N/2:N/2-1);\n[X,Y] = meshgrid(x,y);\nf = (-2)*cos(X).*sin(Y);\nf_comparison = cos(X).*sin(Y);\nchecker = 10;\nu = zeros(N,N);\nu_new = zeros(N,N);\nf_hat = fftn(f);\nwhile checker > 1*10^(-7);\n    u_new_hat = fftn(u_new);\n    for aa = 1:N\n        for a = 1:N\n            q1 = a+1;\n            q2 = a-1;\n            if q2 == 0\n                q2 = N;\n            end\n            if q1 == N+1\n                q1 = 1;\n            end\n            denom = ((dx^2)*((k(aa))^2))+2;\n            u_new_hat(a,aa) = (1/denom)*((u_new_hat(q1,aa))+(u_new_hat(q2,aa))-((f_hat(a,aa))*(dx^2)));\n        end\n    end\n    u_new = real(ifftn(u_new_hat));\n    for aa = 1:N\n        for a = 1:N\n            u_checker(a,aa) = abs(u_new(a,aa)-u(a,aa));\n        end\n    end\n    compare = max(u_checker);\n    checker = max(compare);\n    for aa = 1:N\n        for a = 1:N\n            u(a,aa) = u_new(a,aa);\n        end\n    end\nend\n%calculate scaling discrepency\nddd = f_comparison./u;\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform with negative amplitude\r\n                \r\nUsing wavesurfer to analyse bird songs data and getting negative amplitudes with the FFT analysis that I can not find the reason why.\n\nI have been using wavesurfer for analysing my paper data on birds song. I open my data with the spectrogram and then in spectrum section is possible to find frequency and amplitude (using FFT analysis). My amplitude is negative but I can not find a way to justify that. I dont know why is that and I have significant results on my data, meaning that everything needs to be justified. The forum of the software does not work and there is literally no answer to my question on the internet. I have even emailed the creators asking for help. Find a screen attached to the windows.\n\n\n    ", "Answer": "\r\ndB are on a logarithmic scale.  The log of a small enough positive FFT magnitude can be negative.\ne.g. 20*log10(0.1) = -20\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Help with EXCEL Fast Fourier Transform\r\n                \r\nI am trying to use Excel's (2007) built in FFT feature, however, it requires that I have 2^n data points - which I do not have.\n\nI have tried two things, both give different results:\n\n\nPad the data values by zeros so that N (the number of data points) reach the closest power of 2 \nUse a divide-and-conquer approach i.e. if I have 112 data points, then I do a FFT for 64, then 32, then 16 (112=64+32+16)\n\n\nWhich is the better approach? I am comfortable writing VBA macros but I am looking for an algorithm which does not require the constraint of N being power of 2. Can anyone help?\n    ", "Answer": "\r\nSplitting your data into smaller bits will result in erroneous output, especially for smaller numbers of data points.\n\nPadding with zeroes is a much better idea, and the general approach for FFTs. If you are interested in an alternative way of doing the FFT, octave will do it for you, and most of the Matlab documentation applies so you should have no trouble with it.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fast fourier transform with complex numbers from a file\r\n                \r\nMy code let a user to introduce an array of numbers  that will be transformed with Fourier. But I want to read this array from a file . How can I do this? I just started to learn python ..\n\n```\nimport cmath\nfrom scipy.fftpack import fft\nf=open(\"complex.txt\",\"r+\")\nc=[]\nfor line in f:\n    line=line.split()\n    if line:\n        line=[complex(i.replace('i','j')) for i in line]\n        c.append(line)\n\ndef omega(p, q):\n    return cmath.exp((2.0 * cmath.pi * 1j * q) / p)\n\ndef fft(signal):\n    n = len(signal)\n    if n == 1:\n        return signal\n    else:\n        Feven = fft([signal[i] for i in xrange(0, n, 2)])\n        Fodd = fft([signal[i] for i in xrange(1, n, 2)])\n        combined = [0] * n\n        for m in xrange(n/2):\n            combined[m] = Feven[m] + omega(n, -m) * Fodd[m]\n            combined[m + n/2] = Feven[m] - omega(n, -m) * Fodd[m]\n\n    return combined\n```\n\n    ", "Answer": "\r\nIt turns out (see comments above) that Mady's actual difficulty was in calling a function in Python, rather than in reading data from a file or Fourier-transforming it. So:\n\nTo apply a function ```\nf```\n to arguments ```\na```\n,```\nb```\n,```\nc```\n, you say\n\n```\nf(a,b,c)\n```\n\n\nand if you want to put the result in a variable called ```\nd```\n, you say\n\n```\nd = f(a,b,c)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform performance in Python\r\n                \r\nSo I wrote a short Python program to estimate the accuracy of the Python's FFT method.\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#Aufgabe 1\nx0=0\na=2.5\nk0=3\nX=np.linspace(-4,4,100)\ntimestep=0.1\nk=np.fft.fftfreq(X.size,d=timestep)\npsi_analytical=[(2/(np.pi*a**2))**(1/4)*np.exp(-((i-x0)**2)/a**2)*np.exp(1j*k0*(i-x0)) for i in X]\npsi_tilde_numerical=np.fft.fft(psi_analytical)\npsi_tilde_analytical=[(2/(np.pi*a**2))**(1/4)*(a/2)*np.exp(-(a*(i-k0))**2/4)*np.exp(-1j*i*x0) for i in k]\npsi_numerical=np.fft.ifft(psi_tilde_analytical)\n\n\n#plt.plot(k,np.abs(psi_tilde_numerical),label='numerical psi tilde')\n#plt.plot(k,np.abs(psi_tilde_analytical),'--',color='tab:orange', label='analytical psi tilde')\n\nplt.plot(X,np.abs(psi_analytical),label='analytical psi, real')\nplt.plot(X,np.abs(psi_numerical),'--',color='tab:orange',label='numerical psi, real')\nplt.legend()\nplt.show()\n```\n\nThe analytical function is as follows:\n\nTo my surprise, the numerical and analytical functions are totally different. However, I'm not sure why this is the case.\nThe normalisation constant ```\nN```\n is ```\n(2/(np.pi*a**2))**(1/4)```\n\n    ", "Answer": "\r\nDoing a bit more research, I think I might have an answer for you.\nDiscrete Fourier Transform (```\nDFT```\n), which is computed efficiently using the Fast Fourier Transform algorithm (```\nFFT```\n), operates on discrete time domain signals. The Fourier Transform (```\nFT```\n) operates on function in continuous time domain.\n```\nDFT```\n will approximate the ```\nFT```\n under certain condition. One of those conditions is that the signal has to be band limited. This means that the ```\nFT```\n for the function has to be zero for all frequencies above a certain frequency threshold ```\nα```\n and the DFT has to have a sample rate that is at least ```\n2*α```\n This goes back to Nyquist-Shannon sampling theorem.\nIn your case, you are trying to approximate a Gaussian function ```\nexp(-x²)```\n which is not band limited. This is because as you can see from your formulas, ```\nFT```\n of a Gaussian is also a Gaussian. This means that it has negligible but non-zero components for frequencies all the way to infinity. As a result, you won't be able to approximate the ```\nFT```\n using a ```\nDFT```\n since you would need to have infinite sampling rate.\nIn conclusion, its important to realize that the ```\nDFT```\n and ```\nFT```\n are vastly different transforms and thus can not just be compared.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier cosine transform in two dimension by using FFTW3 library\r\n                \r\nPlease help me this problem.\nI am trying to use fast fourier cosine transform in two dimensional by using FFTW3 library . In my case, i really need to transform with a lot of point. When i set number of points in x and y direction equal to n0*n1=512*512, my program run correctly. However, i set number of points equal to n0*n1=1024*1024, i got the message \"segmentation fault\". The problem, may be, come from memory with three arrays double in[N], in2[N], out[N](here N=n0*n1), which are built.    \n\nSo i have tried to replace arrays by vector but it seems to be not suitable for FFTW3 library.\nMy program is run on laptop with RAM 4GB and core i3.\n\nCould you give for me a advice for my case?\n\nI appreciate with any your ideal.\nThank you so much.\n\nHere is my program\n\n```\nenter code here\n#include <stdio.h>\n#include <math.h>\n#include <fftw3.h>\n\nusing namespace std;\nint main() {\n\n    int n0=1024;\n    int n1=1024;\n\n    int N=n0*n1;\n\n    double in[N], in2[N], out[N];\n\n    fftw_plan p, q;\n    int i,j;\n    p = fftw_plan_r2r_2d(n0,n1, in, out, FFTW_REDFT00, FFTW_REDFT00, FFTW_ESTIMATE);\n\n    for (i =0;i <n0;i++){\n        for (j=0;j<n1;j++)\n        { \n            in[i*n0+j] = cos(2.0*M_PI*(double)i/(n0 - 1))+cos(2.0*M_PI*(double)j/(n1 - 1)); \n        }\n    }\n\n    fftw_execute(p);\n    q = fftw_plan_r2r_2d(n0,n1, out, in2, FFTW_REDFT00, FFTW_REDFT00, FFTW_ESTIMATE);\n    fftw_execute(q);\n\n    for (i =0;i<n0;i++){\n        for (j=0;j<n1;j++)\n        {\n            printf(\"%3d %9.5f %9.5f\\n\", i*n0+j, in[i*n0+j], in2[i*n0+j]/(2.0*(double)(n0 - 1))/(2.0*(double)(n1 - 1)));\n        }\n    }\n  fftw_destroy_plan(p); fftw_destroy_plan(q); fftw_cleanup();\n  return 0;\n}\n```\n\n    ", "Answer": "\r\n\nVariable length arrays are forbidden by C++ standard. Some compilers do support them, but it is not a good idea to use them because it makes your program not portable(that is, ```\nN```\n must be a compile time constant if you create an array of size ```\nN```\n on stack).\n```\nin```\n, ```\nin2```\n and ```\nout```\n arrays are allocated on stack. The default stack size varies for different OS, but it is usually a few megabytes(8 MB on Linux). It is not enough to hold them. That's why you get a SEGFAULT.\nTo fix this problem, you can allocate arrays dynamically:\n\n```\ndouble* in = new double[N];\ndouble* in2 = new double[N];\ndouble* out = new double[N];\n```\n\nDo not forget to delete them when they are not needed anymore(at the end of the program in this case) to avoid memory leaks:\n\n```\ndelete[] in;\ndelete[] in2;\ndelete[] out;\n```\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform and Hamming Window\r\n                \r\nI need help with implementing FFT in hamming window to search peak on the graph/chart (determination of the spectral phase function). At this moment I know how to mark all the peaks on my chart, and also how to load all the file from folder on one chart. And now the most important thing is to find a peak by FFT hamming window. For now the most important thing for me is just to implement this to my script or show me how to do this. When I understand this, I can modify it to search for the peak I want. \n\nMy code:\n\n```\nfolder = 'C:\\Users\\an\\Desktop\\Materialy\\';\n\nfiles = dir(fullfile(folder,'*.dat'));\nfiles_len = numel(files);\n\nif (files_len == 0)\nreturn;\nend\n\nfigure(1);\n\nfile = fullfile(folder,files(1).name);\n[lam,I] = read_spectrum(file);\nlam = lam * 1e-3;\nplot(lam,I);\n\nif (files_len > 1)\nhold on;\n\nfor i = 2:files_len\n    file = fullfile(folder,files(i).name);\n    [lam,I] = read_spectrum(file);\n    lam = lam * 1e-3;\n    plot(lam,I);\nend\n\nhold off;\nend\n```\n\n    ", "Answer": "\r\nSteps for you: \n\ncalculate Hamming window weights for your array size\n\nmultiply data by Hamming weights\n\nmake FFT\n\nIn general-purpose language I use HW in such way (N is array size):\n\n```\n  Re[i] := Re[i] * (0.54-0.46*cos(2*Pi*i/N));\n```\n\n\nBut seems that in Matlab you have ready function\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Open Code in c++ [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have been looking up an open c++ code about FFT. I wanna process an image with FFT and I wrote a code but the code which is mine is not fast even so slow. \nI wrote it using four for loop that's way it is not efficient. The point is, is there is anyone can help me. I searched the internet fully, but i couldn't find any document or code file in c++. I do NOT wanna have a pre-written code by any lib. That's way please show me a site and I can write my code.\nMy code is here;\n\n```\nvoid NaiveDFT::Apply( Image & img )\n{\n\n     complex<double> dft[512][512];    \n\n    for(unsigned u = 0; u < img.rows; ++u)\n    {\n        for(unsigned v = 0; v < img.cols; ++v)\n        {\n            std::complex<double> sum = 0;\n            for(unsigned x = 0; x < img.rows; ++x)\n            {\n                for(unsigned y = 0; y < img.cols; ++y)\n                {\n                    std::complex<double> i = sqrt(std::complex<double>(-1));\n                    std::complex<double> theta = 2 * M_PI * (((u * x) / img.GetWidth()) + ((v * y) / img.cols));\n                    sum += std::complex<double>(img.at<uchar>(i, j)[0]) * cos(theta) + (-i * sin(theta));\n                    //sum += std::complex<double>(std::complex<double>(imgData[x][y]._red) * pow(EULER, -i * theta));\n\n                }\n            }\n            dftData[u][v] = (sum.imag() / (img.GetWidth() * img.GetHeight()));\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nKISSFFT is BSD-licensed:\n\nhttp://kissfft.sourceforge.net\n\nFFTW is GPL-licensed:\n\nhttp://www.fftw.org\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Processing Audio Data using Fourier Transforms in Java\r\n                \r\nI'm trying to process audio data. I'm working with Java.\nI've extracted the audio data to an array. Now I should pass N data samples to a function that calculates the Discrete Fourier Transform (or Fast Fourier Transform, which is more efficient). I've read documentation but I'm getting more and more confused. What I'm trying to calculate is the magnitude spectrum (|X(k)|). \nCan anyone help me? Thanks\n    ", "Answer": "\r\nRichard G. Baldwin has a number of very good articles on Fast Fourier Transform algorithms in Java on the Developer.com website.  In particular, the following articles should prove to be useful:\n\nFun with Java, Understanding the Fast Fourier Transform (FFT) Algorithm\nhttp://www.developer.com/java/other/article.php/3457251/Fun-with-Java-Understanding-the-Fast-Fourier-Transform-FFT-Algorithm.htm\n\nSpectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT Algorithm\nhttp://www.developer.com/java/other/article.php/3380031/Spectrum-Analysis-using-Java-Sampling-Frequency-Folding-Frequency-and-the-FFT-Algorithm.htm\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How can I see Fast Fourier Transform makes sense by an easy example\r\n                \r\nLets assume the the theory of fourier analysis is clear.\nI only want to see that the fast fourier transfom give me somehow, what I would expect from the theory.\nFor the example below, I would expect in a plot (amplitude over frequency) somehow a peak of 0.5 over 2 and a peak of 1 over 5. How I could see this point? Or where I am running in the wrong direction?\n```\nfrom scipy.fftpack import fft\n\nN = 100\nx = np.linspace(0.0, 1, N)\ny = np.sin(5 * 2.0*np.pi*x) + 0.5*np.sin(2 * 2.0*np.pi*x)\nyf = fft(y)*(x[1]-x[0])\nfreq = scipy.fftpack.rfftfreq(N, x[1]-x[0])\n\nplt.plot(freq, np.abs(yf))\n```\n\nThanks to the suggestion from Ammon, I corrected the typo and added a scaling of the step size. But still I don't find a peak of 0.5 over 2 and a peak of 1 over 5.\n    ", "Answer": "\r\nIf you want just to see peaks, you need to plot fft, not input data in meaning yf, not y:\n```\nplt.plot(freq, np.abs(yf))\n```\n\nHave you tried this tutorial:\nhttps://docs.scipy.org/doc/scipy/reference/tutorial/fft.html\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "NumPy Fast Fourier transform (FFT) does not work on sine wave generated in Audacity\r\n                \r\nI am trying to use the NumPy library for Python to do some frequency analysis. I have two .wav files that both contain a 440 Hz sine wave. One of them I generated with the NumPy sine function, and the other I generated in Audacity. The FFT works on the Python-generated one, but does nothing on the Audacity one.\n\nHere are links to the two files:\n\nThe non-working file: 440_audacity.wav\n\nThe working file: 440_gen.wav\n\nThis is the code I am using to do the Fourier transform:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wave\n\ninfile = \"440_gen.wav\"\nrate, data = wave.read(infile)\n\ndata = np.array(data)\n\ndata_fft = np.fft.fft(data)\nfrequencies = np.abs(data_fft)\n\nplt.subplot(2,1,1)\nplt.plot(data[:800])\nplt.title(\"Original wave: \" + infile)\n\nplt.subplot(2,1,2)\nplt.plot(frequencies)\nplt.title(\"Fourier transform results\")\n\nplt.xlim(0, 1000)\n\nplt.tight_layout()\n\nplt.show()\n```\n\n\nI have two 16-bit PCM .wav files, one from Audacity and one created with the NumPy sine function. The NumPy-generated one gives the following (correct) result, with the spike at 440Hz:\n\n\nThe one I created with Audacity, although the waveform appears identical, does not give any result on the Fourier transform:\n\n\nI admit I am at a loss here. The two files should contain in effect the same data. They are encoded the same way, and the wave forms appear identical on the upper graph.\n\nHere is the code used to generate the working file:\n\n```\nimport numpy as np\nimport wave\nimport struct\nimport matplotlib.pyplot as plt\nfrom operator import add\n\nfreq_one = 440.0\nnum_samples = 44100\nsample_rate = 44100.0\namplitude = 12800\n\nfile = \"440_gen.wav\"\n\ns1 = [np.sin(2 * np.pi * freq_one * x/sample_rate) * amplitude for x in range(num_samples)]\n\nsine_one = np.array(s1)\n\nnframes = num_samples\ncomptype = \"NONE\"\ncompname=\"not compressed\"\nnchannels = 1\nsampwidth = 2\n\nwav_file = wave.open(file, 'w')\nwav_file.setparams((nchannels, sampwidth, int(sample_rate), nframes, comptype, compname))\n\nfor s in sine_one:\n    wav_file.writeframes(struct.pack('h', int(s)))\n```\n\n    ", "Answer": "\r\nLet me explain why your code doesn't work. And why it works with ```\n[:44100]```\n.\nFirst of all, you have different files:\n```\n440_gen.wav      = 1 sec and 44100  samples (counts)        \n440_audacity.wav = 5 sec and 220500 samples (counts)\n```\n\nSince for ```\n440_gen.wav```\n in FFT you use the number of reference points N=44100 and the sample rate 44100, your frequency resolution is 1 Hz (bins are followed in 1 Hz increments).\nTherefore, on the graph, each FFT sample corresponds to a delta equal to 1 Hz.\n```\nplt.xlim(0, 1000)```\n just corresponds to the range 0-1000 Hz.\nHowever, for ```\n440_audacity.wav```\n in FFT, you use the number of reference points N=220500 and the sample rate 44100. Your frequency resolution is 0.2 Hz (bins follow in 0.2 Hz increments) - on the graph, each FFT sample corresponds to a frequency in 0.2 Hz increments (min-max = +(-) 22500 Hz).\n```\nplt.xlim(0, 1000)```\n just corresponds to the range 1000x0.2 = 0-200 Hz.\nThat is why the result is not visible - it does not fall within this range.\n```\nplt.xlim (0, 5000)```\n will correct your situation and extend the range to 0-1000 Hz.\nThe solution ```\n[:44100]```\n that jwalton brought in really only forces the FFT to use N = 44100. And this repeats the situation with the calculation for 440_gen.wav\nA more correct solution to your problem is to use the ```\nN (Windows Size)```\n parameter in the code and the ```\nnp.fft.fftfreq()```\n function.\nSample code below.\nI also recommend an excellent article https://realpython.com/python-scipy-fft/\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wave\n\nN = 44100 # added\n\ninfile = \"440_audacity.wav\"\nrate, data = wave.read(infile)\n\ndata = np.array(data)\n\ndata_fft = np.fft.fft(data, N)  # added N\nfrequencies = np.abs(data_fft)\nx_freq = np.fft.fftfreq(N, 1/44100)  # added\n\nplt.subplot(2,1,1)\nplt.plot(data[:800])\nplt.title(\"Original wave: \" + infile)\n\nplt.subplot(2,1,2)\nplt.plot(x_freq, frequencies)  # added x_freq \nplt.title(\"Fourier transform results\")\n\nplt.xlim(0, 1000)\nplt.tight_layout()\nplt.show()\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform library from Exocortex.DSP\r\n                \r\nI am trying to use the FFT library from Exocortex.DSP.\n\nThe calling function is:\n\n```\nExocortex.DSP.Fourier.FFT(float[], int, Exocortex.DSP.FourierDirection)\n```\n\n\nMy line of code to use this function is:\n\n```\nFourier.FFT(floatArray, arraycount, FourierDirection.Forward);\n```\n\n\nMy program compiles, but why does it break at this line?\n\n**The breaking window says:\n\n```\nAn unhandled exception of type 'System.MissingMethodException' occurred in Exocortex.DSP.v1.dll\nAdditional information: Method not found: Log System.Math.\"*\n```\n\n    ", "Answer": "\r\nThese sorts of errors happen when you compile your code against a library but then run against a different version, or if you compile only a sub-set of your solution's projects. What happens then is that the code attempts to call methods that don't exist or have a different signature in the assembly used at run-time.\n\nThings I would check are:\n\n\nIn the Build Configuration dialog, whether all the boxes are ticked/checked.\nWhether your projects are building to the directories you think they are.\nWhether you are actually running the built code or whether, somehow, you could be running old code from a different directory.\nWhether the library you are using is getting copied to the executable project's target directory correctly (if it's not it could suggest a dodgy reference somewhere in the solution).\n\n\nFinally, it's possible that the library itself has been compiled against different versions of the libraries it uses. You may want to set up a small test project to make sure the library works correctly in a very simple test case before investigating why your existing project is not working.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Inverse fast fourier transform: different phases\r\n                \r\nRosettaCode gives a simple implementation of the Cooley–Tukey FFT algorithm here. The question is the following and is from a mathematical and programming point of view. Suppose that an input of a program is the spectrum of a signal, and we want to generate a signal which has such a spectrum. If am correct, we need to take the inverse FFT of the input spectrum.\n\nThe code given by RosettaCode is the following:\n\n```\n// inverse fft (in-place)\nvoid ifft(CArray& x)\n{\n    // conjugate the complex numbers\n    x = x.apply(std::conj);\n\n    // forward fft\n    fft( x );\n\n    // conjugate the complex numbers again\n    x = x.apply(std::conj);\n\n    // scale the numbers\n    x /= x.size();\n}\n```\n\n\nBut this can only generate one signal. But several signals can have the same spectrum. So how to add a parameter to be able to generate these different signals?\n    ", "Answer": "\r\nNo, different signals have different Fourier transforms; it is invertible. N complex numbers in, N complex numbers out; the discrete Fourier transform amounts to multiplying a vector of samples by a nonsingular matrix, getting a vector of the same size.\n\nYou might be confusing an actual Fourier transform with a \"spectrum\" obtained taking the magnitude of the Fourier transform or with the result of other information-destroying operations.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast fourier transform in ruby on rails\r\n                \r\nI'm now developing a project in ruby on rails.\n\nIs there anyway to calculate fft in ruby on rails?\nSay retrieve some time domain raw data from database and do fft then out put the freq domain graph in web page.\n\nIs there any gem support this calculation?\n\nif not,is it possible to use ruby write calculate fft code? Or is there any other way of implementing this?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Performing 2D fast fourier transform in R\r\n                \r\nI want to know how to perform 2D fft in R. I can see the function ```\nfft```\n only but I want to do that in 2D. Is there a function available like ```\nfft2```\n in matlab?\n    ", "Answer": "\r\nAs pointed out in the comments, ```\nfft```\n can handle single or multi-dimensional input. From the docs:\n\n\n  When z is a vector, the value computed and returned by fft is the\n  unnormalized univariate Fourier transform of the sequence of values in\n  z. When z contains an array, fft computes and returns the multivariate\n  (spatial) transform.\n\n\nI think this documentation is confusing the terms (since an R array can have 1, 2, or more dimensions), but what they are trying to say is fairly clear.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to perform FFT2D (Fast Fourier Transform 2D) R, G, B color component\r\n                \r\nI am new in fast fourier transform (FFT) and does not have much idea, how it calculate in programming language such as C++.  Here is method of FFT2D\n\n```\nvoid FFT2D(Complex<double> *f, Complex<double> *F, int width, int height);\nIt takes an input image f of size width * height and output the transformed \ncoefficients into F.\n```\n\n\nHints: Image pixels are stored as three separate image color (R, G, B) planes, with each of them being represented by a 1D array of complex numbers. Suppose an image is of size width W and height H, then the color component values (R, G and B) of the pixels at image location (m, n) can be found as R[m + n * W], G(m + n * W) and B[m + n * W], where R, G, B are the three arrays of complex numbers.\nThe 1D array for the transformed coefficients is also represents in the same manner.\n\nWhat I need to implement the processing for one color component only and the programming template will process the R, G, B separately based on implemented functions. The template will also pad the image with zeros so that each input image is of size 2m * 2n. \n\n```\nIf I called from another class, I have to pass R, G, B separately\nSuppose: \nComplex<double> *R = new Complex<double>[width * height];\nLet, width = 4096 and height 4096\nFFT2D(R, output F, width, height) for compute “R” color component;\nFFT2D(G, output F, width, height) for compute “G” color component;\nFFT2D(B, output F, width, height) for compute “B” color component;\n\nWe have template of calculated FFT1D function:\nvoid FFT1D(Complex<double> *fx, Complex<double> *Fu, int twoK, int stride)\nHint: it outputs the frequency coefficients in the array Fu.\n```\n\n\nFFT1D is calling from inside a function of FFT2D. I found several different type of code in C, C++, and Java and C #of FFT2D. Most of them have implemented using 2D array structure; they assign real and imaginary part to 2D array structure in loop of rows and columns. However, in my case is 1D array structure of color component.\n\nLet's, do some code and this is inside FFT2D function:\n\n```\nComplex<double> *outPutMap = new Complex<double>[width * height];\n for (int i = 0; i < height; i++){\n #  for(int j = 0; j < width; j++){\n #     outPutMap[i + j * width] = f[i + j * width];\n #      I don’t understand how to implement in here for color component and how \n #      it assign a value for real and imaginary part\n #   }\n  }\n```\n\n\nBefore, calling a FFTID, it also required calculate a value of twoK as in book, M = 2K\n\nIf you have any idea or any reference please let me know.\n\nThank you\n\nRegards\nIchiro\n    ", "Answer": "\r\nI would suggest you get hold of a book such as [Numerical Recipes][1] . \n\nhttp://www.amazon.com/Numerical-Recipes-Art-Scientific-Computing/dp/0521750334\n\nFFT, Simpsons Rule, Fouriers Algorith should all be there. I had read from an author named Rajaram .. it was in C.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Extract Fast Fourier Transform data from file\r\n                \r\n\nI am building a tool which is supposed to run on a server and analyze sound files. I want to do this in Ruby as all my other tools are written in Ruby as well. But I am having trouble finding a good way of accomplishing this.\n\nA lot of the examples I've found has been doing visualizers and graphical stuff. I just need the FFT data, nothing more. I need to both get the audio data, and do a FFT on it. My end goal is to calculate some stuff like the mean/median/mode, 25th-percentile, and 75th-percentile over all frequencies (weighted amplitude), the BPM, and perhaps some other good characteristic to later be able to cluster similar sounds together.\n\nFirst I tried to use ruby-audio and fftw3 but I never go the two to really work together. The documentation wasn't good either so I really didn't know what data was being shuffled around.\nNext I tried to use bplay / brec and limit my Ruby script to just use STDIN and perform an FFT on that (still using fftw3). But I couldn't get bplay/brec to work since the server doesn't have a sound card and I didn't manage to just get the audio directly to STDOUT without going to an audio device first.\n\nHere's the closest I've gotten:\n\n```\n# extracting audio from wav with ruby-audio\nbuf = RubyAudio::Buffer.float(1024)\nRubyAudio::Sound.open(fname) do |snd|\n    while snd.read(buf) != 0\n        # ???\n    end\nend\n\n# performing FFT on audio\ndef get_fft(input, window_size)\n    data = input.read(window_size).unpack(\"s*\")\n    na = NArray.to_na(data)\n    fft = FFTW3.fft(na).to_a[0, window_size/2]\n    return fft\nend\n```\n\n\nSo now I'm stuck and can't find any more good results on Google. So perhaps you SO guys can help me out?\n\nThanks!\n    ", "Answer": "\r\nI think there are two problems here. One is getting the samples, the other is performing the FFT.\n\nTo get the samples, there are two main steps: decoding and downmixing. To decode wav files, you just need to parse the header so you can know how to interpret the samples. For mp3 files, you'll need to do a full decode. Once the audio has been decoded, if you are not interested in processing the stereo channels separately, you may need to downmix it into mono, since the FFT expects a single channel as input. If you don't mind venturing outside of Ruby, the sox tool makes this easy. For example ```\nsox song.mp3 -b 16 song.raw channels 1```\n should convert an mp3 to a mono file of pure PCM samples (i.e. 16-bit integers). BTW, a quick search revealed the ruby/audio library (perhaps it is the one mentioned in your post). It looks pretty good, especially since it wraps libsndfile.\n\nTo perform the FFT, I see three options. One is to use this snippet of code that performs an FFT. I'm no Ruby expert, but it looks like it might be OK. The second option is to use NArray. It has a ton of mathematical methods, including FFTW, available in a separate module, a tarball for which is linked in the middle of the NArray page. The third option is to write your own FFT code. It's not an especially complicated algorithm, and could give you great experience with numerical processing in Ruby (if you need that).\n\nYou are probably aware of this, but the FFT expects complex input and generates complex output. Audio signals are real, of course, so the imaginary component of the input should always be zero (```\na + 0*i```\n). Since your input is real, the output will be symmetrical about the midpoint of the output array. You can safely ignore the upper half. If you want the energy in a particular frequency bin (they are spaced linearly up to half the sample rate), you'll need to compute the magnitude of the complex value (```\nsqrt(real*real + imag*imag)```\n).\n\nOne more thing: Because frequency zero (the DC offset of the signal) and the Nyquist frequency (half the sample rate) have no phase components, some FFT implementations put them together into the same complex bin (one in the real component, one in the imaginary component, typically of the first bin). You can create some simple signals (all 1s for just a DC signal,  and alternating +1, -1 for a Nyquist signal) and see what the FFT output looks like.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform - Plot looks strange\r\n                \r\nThe beginning of my fft plot looks strange. Any ideas why?\nThe data were recorded at 400 HZ.\nThe plot shows only the first 400 datapoints.\nWhen I change it to e.g. y = df['Vibra0_X'][800:1200].values, the beginning of the plot looks the same:\n```\nimport scipy.fftpack\nfrom scipy.fft import fft, fftfreq\n\n# sample spacing\nT = 1.0 / 800.0\n\ny = df['Vibra0_X'].head(400).values\n\nN = len(y)\nx = np.linspace(0.0, N*T, N)\nyf = scipy.fftpack.fft(y)\nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\n\nfig, ax = plt.subplots()\nax.plot(xf, 2.0/N * np.abs(yf[:N//2]),linestyle='-', color='blue' )\n\nplt.ylabel('Amplitude')\nplt.xlabel('Frequency [Hz]')\nplt.title(\"Frequency domain of the signal\", fontsize=16)\n\n\nplt.show()\n\n```\n\n\nIs T correctly defined (assuming the data was recorded at 400 Hz)?\nOr is the plot correct and just implies noise?\nI have uploaded the datapoints (1 second, 400 datapoints) to https://pastebin.com/QCCnbugL\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform in OpenGL Compute Shader\r\n                \r\nI'm trying to implement FFT in OpenGL Compute Shaders in educational purposes (that's why I do not want to use CUDA and OpenCL), but I think that some approaches for parallel programming used in OpenCL, for example, are similar to OpenGL Compute Shaders. I've found several code examples of FFT in OpenCL: one of them is Eric Bainville's article. Sample source code from it is following:\n\n```\n__kernel void fft_radix2(__global const float2 * x,__global float2 * y,int p)\n\n{\n\n  int i = get_global_id(0); // number of threads\n\n  int t = get_global_size(0); // current thread\n\n  int k = i & (p-1); // index in input sequence, in 0..P-1\n\n  x += i; // input offset\n\n  y += (i<<1) - k; // output offset\n\n  float4 u = dft2( (float4)(x[0], mul_1(exp_alpha_1(-M_PI*(float)k/(float)p),x[t]) ));\n\n  y[0] = u.lo;\n\n  y[p] = u.hi;\n\n}\n```\n\n\nHere ```\nx```\n is input and ```\ny```\n is output for each step in FFT.After that, he says that \"This kernel must be called for ```\np = 1```\n, then ```\np = 2```\n, etc. until ```\np = N/2```\n. The number of threads at each call is ```\nN/2```\n, and the work group size WG doesn't matter since all threads are independent.\" Here ```\nN```\n is size of input (should be power of 2).\nSo, my question is about parameter ```\np```\n. How can I push that parameter in compute shader, so the latter will be invoked for ```\np = 1```\n, then ```\np = 2```\n, etc. until ```\np = N/2```\n?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Strange result from Fast Fourier transform signal reconstruction\r\n                \r\nI have some data which is shown in the below figure and am interested in finding some of its Fourier series coefficients.\n\n```\nr = np.array([119.80601628, 119.84629291, 119.85290735, 119.45778804,\n   115.64497439, 105.58519852, 100.72765819, 100.04327702,\n   100.08590518, 100.35824977, 101.58424993, 105.47976376,\n   112.27556007, 117.07679226, 118.99998888, 119.60458086,\n   119.78624424, 119.83022022, 119.36116943, 115.72323767,\n   106.58946834, 101.19479124, 100.11537349, 100.13313755,\n   100.41846106, 101.42255377, 104.33650237, 109.73625492,\n   115.14763728, 118.24665037, 119.35359999, 119.68061835])\n\nz = np.array([-411.42980545, -384.98596279, -358.13032372, -330.89578468,\n   -303.39129113, -275.76248957, -248.24478443, -221.07069838,\n   -194.33260984, -168.05271807, -142.19357982, -116.62090103,\n    -91.15354178,  -65.56745626,  -39.65284757,  -13.29632162,\n     13.54374939,   40.84929432,   68.50496394,   96.33720787,\n    124.08525182,  151.36802193,  177.98791952,  204.0805317 ,\n    229.85399128,  255.44727674,  281.02166554,  306.75399703,\n    332.74638285,  359.05528646,  385.74336711,  412.8189858 ])\n\nplt.plot(z, r, label='data')\nplt.legend()\n```\n\n\n\nThen I calculate the average sampling period, since it is not constant as seen in the Z variable:\n\n```\nl = []\nfor i in range(32-1):\n    l.append(z[i]-z[i+1])\nTs = np.mean(l)\n```\n\n\nThen I calculate the fft:\n    from scipy.fftpack import fft\n\n```\nrf = scipy.fftpack.fft(r)\n```\n\n\nFor reconstruction of the signal then:\n\n```\nfs = 1/Ts\n\namp = np.abs(rf)/r.shape[0]\nn = r.shape[0]\ns = 0\nfor i in range(n//2):\n\n    phi = np.angle(rf[i], deg=False)\n    a   = amp[i]\n    k   = i*fs/n\n\n    s += a*np.cos(2*np.pi*k  *(z)  +phi)\n\nplt.plot(z, s, label='fft result')\nplt.plot(z, r, label='data')\nplt.legend()\n```\n\n\n\n\nThe result is strange however both in terms of amplitude and frequency.\n    ", "Answer": "\r\nThe complex spectrum is a symmetric spectrum with the range of (-fMax/2, ..., +fMax/2).\nYou only used the right hand positive part of the spectrum. This means, your reconstructed signal contains only half of the spectrums frequencies.\nBecause the spectrum is symmetric, all you have to do is to double the calculated absolute values. However, there is an important exception. The DC value amplitude[0] must not be doubled.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Calculating frequency present in Fast Fourier Transform\r\n                \r\nI have signal output values recorded by a Software-defined radio whose center frequency was 162.550 MHz & sample rate of 1,000,000. Now to analyse the data in frequency domain I calculated FFT which was straight forward. \n\n```\n#Calculating FFT of signal \nfourier=np.fft.fft(RadioData)\n```\n\n\nSince for Amplitude vs Frequency plot I need to calculate frequencies present in the signal too. I used Numpy fftfreq for that.\n\n```\nfreq=np.fft.fftfreq(fourier.shape[0])\n```\n\n\nThe output was in the range of [-0.5 0.4999995]. I am confused how to interpret this result or alternatively how to calculate frequencies present in the data ?\n    ", "Answer": "\r\nWhen SDR samples are baseband IQ (or complex, or cosine/sine), then the bandwidth is equal to the IQ sample rate.  This is because baseband IQ samples (unlike single_channel strictly real samples) can contain both positive and negative frequency spectrum, independently, half the bandwidth above and half the bandwidth below an RTL-SDR's (et.al.) tuned RF frequency setting (unless a frequency offset is selected).\n\nThus, the frequency range of the FFT of IQ data will be from Fcenter - (indicated_bandwidth/2) to almost Fcenter + (indicated_bandwidth/2).  Or for your example: 162.050 to (a bit below) 163.050 MHz. (the \"bit below\" value depends on the FFT size.)  The step size, dF, with be the IQ sample rate divided by the FFT length.\n\n(Note that the data rate in scalar samples is twice the IQ sample rate because each IQ sample contains two samples (real and imaginary components, or cosine and sine mixer outputs).  Thus, because each IQ sample contains more information, the information bandwidth can be greater.  But SDR apps usually indicate the IQ sample rate, not the higher raw data rate.)\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for an accelerometer in Python\r\n                \r\nI have data from the accelerometer in m/s2 (Y-axis) for a time period  in seconds (X-axis). I would like to convert this data real-time so that I get the value of an acceleration related to the frequency in Hz. I know that, for example, there is an FFT function in numpy, but I have no idea at all how to use it. I would appreciate, if somebody could provide an example code to convert the raw data (Y: m/s2, X: s) to the desired data (Y: m/s2, X: Hz). It should not be necessarily exactly this function. Thanks!\n    ", "Answer": "\r\nFirst, let's create a time-domain signal.\nFor simplicity, I will create a sine wave with frequency components ```\n12Hz```\n and ```\n24Hz```\n and you can assume the unit of the values are ```\nm/s^2```\n:\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# This would be the actual sample rate of your signal\n# since you didn't provide that, I just picked one\n# big enough to make our graphs look pretty\nsample_rate = 22050\n\n# To produce a 1-second wave\nlength = 1\n\n# The x-axis of your time-domain signal\nt = np.linspace(0, length, sample_rate * length)\n\n# A signal with 2 frequency components\n# - 12Hz and 24Hz\ny = np.sin(12 * (2 * np.pi) * t) + 0.5*np.sin(24 * (2 * np.pi) * t) \n\n# Plot time domain signal\nplt.plot(t, y)\nplt.xlabel(\"Time (s)\")\nplt.show()\n```\n\nThis will output:\n\nNow, we continue on with the script by taking the Fourier transform of our original time-domain signal and then creating the magnitude spectrum (since that gives us a better way to visualize how each component is contributing than the phase spectrum):\n```\n# This returns the fourier transform coeficients as complex numbers\ntransformed_y = np.fft.fft(y)\n\n# Take the absolute value of the complex numbers for magnitude spectrum\nfreqs_magnitude = np.abs(transformed_y)\n\n# Create frequency x-axis that will span up to sample_rate\nfreq_axis = np.linspace(0, sample_rate, len(freqs_magnitude))\n\n# Plot frequency domain\nplt.plot(freq_axis, freqs_magnitude)\nplt.xlabel(\"Frequency (Hz)\")\nplt.xlim(0, 100)\nplt.show()\n```\n\nSo now we can visualize the frequency-domain:\n\nNotice how the magnitude of the ```\n24Hz```\n component is about half of the ```\n12Hz```\n component. That is because I purposely timed the ```\n24Hz```\n component by ```\n0.5```\n on the time-domain signal, so the ```\n24Hz```\n component 'contributes' less to the overall signal, hence we get this halved spike for that component.\nNote, also, that the y-axis of our output signal is not really in ```\nm/s^2 per Hz```\n as you wanted. But you could compute the actual ```\nm/s^2```\n values by taking the integral over your desired frequency band.\nI'll leave the jupyter notebook I created available here, feel free to use it and open issues if you have any problems with it.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fast fourier transform apply window and overlap\r\n                \r\nThis may be a naive question, but I didn't find exact details in searching.\n\nIn FFT with window overlapping, after we've applied window functions to sequences of data set with overlapping and got the FFT results, how do we combine those FFT results for overlapping sequence? \n\nDo we just add them together, treating those frequency domain results as non-overlapping parts?\n\nAre magnitudes of these results in complex numbers frequency magnitudes?\n\nThank you. \n    ", "Answer": "\r\nFor each FFT you typically calculate the magnitude of each complex output bin - this gives you a spectrum (magnitude versus frequency) for one window. The sequence of magnitude spectra for all time windows is effectively a 3D data set or graph - magnitude versus frequency versus time - which is typically plotted as a a spectrogram, waterfall or time varying 2D spectrum. \n\nIn the specific case where the data is statistically stationary and you just want to reduce the variance you can average the successive magnitude spectra - this is called ensemble averaging. Normally though for time-varying signals such as speech or music you would not want to do this.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "DM Script, why does the fourier transform of gaussian-kenel needs modulus\r\n                \r\nRecently I learn DM_Script for TEM image processing\nI needed Gaussian blur process and I found one whose name is 'Gaussian Blur' in http://www.dmscripting.com/recent_updates.html\n\nThis code implements Gaussian blur algorithm by multiplying the fast fourier transform(FFT) of source image by the FFT of Gaussian-kernel image and finally doing inverse fourier transform of it.\n\nHere is the part of the code,\n\n```\n// Carry out the convolution in Fourier space\n\ncompleximage fftkernelimg:=realFFT(kernelimg) (-> FFT of Gaussian-kernel image)\ncompleximage FFTSource:=realfft(warpimg) (-> FFT of source image)\ncompleximage FFTProduct:=FFTSource*fftkernelimg.modulus().sqrt()\nrealimage invFFT:=realIFFT(FFTProduct)\n```\n\n\nThe point I want to ask is this\n    compleximage FFTProduct:=FFTSource*fftkernelimg.modulus().sqrt()\n\nWhy does the FFT of Gaussian-kernel need '.modulus().sqrt()' for the convolution?\n\nIt is related to the fact that the fourier transform of a Gaussian function becomes another Gaussian function?\nOr It is related to a sort of limitation of discrete fourier transform?\n\nPlease answer me\nThanks\n    ", "Answer": "\r\nThis is related to the general precision limitation of any floating point numeric computing. (see f.e. here, or more in depth here)\n\nA rotational (real-valued) Gaussian of stand.dev. sigma should be transformed into a 100% real-values rotational Gaussioan of 1/sigma. However, doing this numerically will show you deviations: Just try the following:\n\n```\nnumber sigma = 30\nnumber A0 = 1\nrealimage first := RealImage( \"First\", 8, 256, 256 )\nfirst = A0 * exp( - (iradius**2/(2*sigma*sigma) ))\nfirst.showimage()\ncomplexImage second := FFT(first)\nsecond.Showimage()\n\nimage nonZeroImaginaryMask = ( 0 != second.Imaginary() )\nnonZeroImaginaryMask.Showimage()\nnonZeroImaginaryMask.SetLimits(0,1)\n```\n\n\nWhen you then multiply these complex images (before back-transferring) you are introducing even more errors. By using modulus, one ensures that the forward transformed kernel is purely real and hence a better \"damping\" curve.\n\nA better implementation of a FFT filtering code would actually create the FFT(Gaussian) directly with a std.dev of 1/sigma, as this is the analytically correct result. Doing a FFT of the kernel only makes sense if the kernel (or its FFT) is not analytically known.\n\nIn general: When implementing any \"maths\" into a program code, it can pay hugely to think it through with numerical computation limits in the back of your head. Reduce actual computation whenever possible (i.e. compute analytically and use the result instead of relying on brute force numerical computation) and try to \"reshape\" equations when possible, f.e. avoid large sums over many small numbers, be careful about checks against exact numeric values, try to avoid expressions which are very sensitive on small numerica errors  etc. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to use Fast Fourier Transform to execute convolution of matrix?\r\n                \r\nI need to add many big 3D arrays (with a shape of 500x500x500) together and want to speed up the process by using multiplication in the Fourier space. The problem is that I don't get the same answer when multiplying in the Fourier space compared to simply adding the matrix.\n\nTo test it out, I wrote a minimal example trying to make it work but the answer is not what I expected. Either my math knowledge is wrong or I am not using the function correctly.\n\nBelow is the simplest code showing what I am trying to do:\n\n```\nimport numpy as np\n\nc = np.asarray(((1,2),(2,3)))\nd = np.asarray(((1,4),(1,5)))\n\nprint(\"Transform\")\nNc = np.fft.rfft2(c)\nNd = np.fft.rfft2(d)\n\nprint(\"Inverse\")\nNnc = np.fft.irfft2(Nc)\nNnd = np.fft.irfft2(Nd)\n\nprint(\"Somme\")\nS = np.dot(Nc, Nd)\nprint(np.fft.irfft2(S))\n```\n\n\nWhen I print S, I get the result:\n\n```\n[[6, 28],[10,46]]\n```\n\n\nBut from what I understood about the Fourier space, multiplication would mean addition outside of the Fourier space so I should get ```\nS = c + d```\n?\n\nAm I doing something wrong using the FFT function or is my assumption that S should equal c plus d wrong?\n    ", "Answer": "\r\nThere is a little misunderstanding here: \n\nMultiplication in Fourier space corresponds to convolution in the spatial domain and not to addition.\n\nThere is no way to speed up addition in that way.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform With Microphone Input Data in AS3\r\n                \r\nIs it possible to get the source of adobes ```\nflash.media.SoundMixer```\n class ?\n\nIf it is, where can i find / get it ?\n\nI waht to \"clone\" the ```\n.computeSpectrum()```\n function to transform a raw sound wave ( byteArray ) from Microphone input into a frequency spectrum.\n\nI've found a couple of examples like this one -> http://pierrickpluchon.fr/blog/as3-how-to-plug-your-microphone-with-a-soundspectrum-in-flash-player-10-1/\n\nAll other methos i've found are pretty much the same.\n\nThe problem is that there is always a ```\nSound()```\n playing, what i DON'T want. ( I don't want any loopback )\n\nBut if i'm not playing a sound, i can't use the ```\nSoundMixer.computeSpectrum()```\n function to transform my ByteArray that comes from the ```\nMicrophone```\n to a frequency spectrum by turning the FFTMode to true ( ```\ncomputeSpectrum(myByteArray,true)```\n )\n\nAlso if you know any other method to get the Frequency Spectrum from the Raw Sound Wave, please let me know.\n\nUPDATE\n\nmy code:\n\n```\nvar bytes:ByteArray = new ByteArray();\n\nvar mic:Microphone = Microphone.getMicrophone();\nmic.rate = 44;\n// mic.gain = 100; // gain\nmic.addEventListener(SampleDataEvent.SAMPLE_DATA, onSampleData);\n\nfunction onSampleData( event:SampleDataEvent ):void {\n    graphics.clear();\n    graphics.lineStyle(1, 0xFF0000);\n    for( var i:uint = 0; i < 256; i++ ) {\n        var num:Number = event.data.readFloat() * 100 + 100; // -Math.abs( )\n        if( i == 0 ) {\n            graphics.moveTo( i, num );\n        } else {\n            graphics.lineTo( i, num );\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\n\n  \"..Also if you know any other method to get the Frequency Spectrum from the Raw Sound Wave, please let me know.\"\n\n\nWell Joe Beuckman beat me to it and gave you the link to Gerry Beauregard's FFT code. That's the best AS3 one I've seen so far since I found it two years ago. From the comments I see you were wondering how to implement... Well to see implementation code you need to see another page on his blog:\n\nhttp://gerrybeauregard.wordpress.com/2010/08/06/real-time-spectrum-analysis/\n\n\nTo test that code yourself you first have to save the classes shown in the link here: http://gerrybeauregard.wordpress.com/2010/08/03/an-even-faster-as3-fft/\nSave each package's code respectively as FFT2.as and FFTElement.as\nNow in your document class put the code from:  http://gerrybeauregard.wordpress.com/2010/08/06/real-time-spectrum-analysis/  \n\n\nHowever in that code you must also add some lines importing the other saved .as classes \n\n```\nimport __AS3__.vec.Vector;\nimport flash.display.Sprite;\nimport flash.events.*;\nimport flash.media.Microphone;\nimport flash.text.*;\nimport flash.utils.*;\n\nimport FFT2;\nimport FFTElement;\n```\n\n\nNow it should run without errors and show the same thing as screenshot on his blog. The online demo used to work for me but not today so I say screenshot just so you know what to expect when it works fine.\n\nHope it helps. VC:One\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Would multithreading help a Fast Fourier Transform?\r\n                \r\nI have to get performance out of an application by multi-threading it for a project. So far I attempted to make a Task that would be created to handle a 2048 segment of audio, and that task would be created for each segment to run independently. However, this configuration means making several thousands of tasks which causes more performance problems then worth, not to mention I couldn't find a way to convert the existing recursive FFT into an iterative one to maintain that 1:1 on segments to tasks.\nWould there be any benefit to continuing to attempt this? or should I look more to optimizing the application else where.\n    ", "Answer": "\r\nLook at your core usage on your computer when running the transformation as a serial process. Have you maxed out your CPU?\nIf not, then the parallel library can help you access more computing power.\nI would recommend reading up on tutorials and theory on the parallel library (assembly) in C#.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Algorithm and Technical Analysis\r\n                \r\nMy Mini Practice Project requires me to do:\n\n\nDownload stock prices.\nDetrend stock prices.\nSmooth detrended stock prices. \nApply FFT algorithm.\n\n\nThe Mini Practice Project Python code can be seen below:\n\n```\n#Python code: Download the Daily Stock Prices from Yahoo Finance \nfrom matplotlib.finance \nimport quotes_historical_yahoo \nfrom pylab\nimport * import numpy as np import\nscipy.signal as sc import\nmatplotlib.pyplot as plt \nimport pandas as pd\nticker='AAPL' begdate=(2013,12,6) enddate=(2015,12,20)\ndata = quotes_historical_yahoo(ticker, begdate, enddate,asobject=True, adjusted=True)\naapl=data.aclose[1:]\nnp.count_nonzero(aapl)\nplt.plot(aapl)\nplt.title(‘Apple stock price movement’)\n\n#Python code: Detrend stock prices\ndetrend=sc.detrend(aapl)\nplt.plot(detrend)\nplt.title(‘Apple stock detrended prices’) \n\n#Python code: Smooth Detrended Apple Stock Prices \nw=np.blackman(20) \n\n#we selected 20 the parameter of the blackman window function \ny=np.convolve(w/w.sum(),detrend,mode='same')\nplt.plot(y) plt.title(‘Blackman window function for detrended Apple stock\nprice’) \n\n#Python code: Apply FFT Algorithm \nfft=abs(rfft(y)) plt.plot(fft)\nplt.title(‘FFT Algorithm applied to Apple stock price’)\n```\n\n\nWhen I type >>> fft, the result should be:\narray([ 31.29635197, 2706.46455209, 1093.11797192, 904.02261366, 582.27538238, 282.87694269, 244.95336969, 501.27771573, 247.04690328, 554.24978967, 115.67400179, 270.14245787, 194.51970654, 179.0406388, 302.98350318, 170.32131932, 51.39420044, 87.25308608, 87.15654977, 39.34619432])\n\nI keep getting a code error: from matplotlib.finance is an invalid syntax. How do I fix this?\n    ", "Answer": "\r\n```\nfrom matplotlib.finance \nimport quotes_historical_yahoo \n```\n\n\nshould be on the same line like so:\n\n```\nfrom matplotlib.finance import quotes_historical_yahoo\n```\n\n\nAlternatively, you can break lines:\n\n```\nfrom matplotlib.finance \\\nimport quotes_historical_yahoo \n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Analytical Fourier transform vs FFT of functions in Matlab\r\n                \r\nI have adapted the code in Comparing FFT of Function to Analytical FT Solution in Matlab for this question. I am trying to do FFTs and comparing the result with analytical expressions in the Wikipedia tables.\n\nMy code is:\n\n```\na = 1.223;\nfs = 1e5; %sampling frequency\ndt = 1/fs;\nt = 0:dt:30-dt;     %time vector\nL = length(t); % no. sample points\nt = t - 0.5*max(t); %center around t=0\n\ny = ; % original function in time\nY = dt*fftshift(abs(fft(y))); %numerical soln\n\nfreq = (-L/2:L/2-1)*fs/L; %freq vector\nw = 2*pi*freq; % angular freq\n\nF = ; %analytical solution\n\nfigure; subplot(1,2,1); hold on\nplot(w,real(Y),'.')\nplot(w,real(F),'-')\nxlabel('Frequency, w')\ntitle('real')\nlegend('numerical','analytic')\nxlim([-5,5])\nsubplot(1,2,2); hold on;\nplot(w,imag(Y),'.')\nplot(w,imag(F),'-')\nxlabel('Frequency, w')\ntitle('imag')\nlegend('numerical','analytic')\nxlim([-5,5])\n```\n\n\nIf I study the Gaussian function and let\n\n```\ny = exp(-a*t.^2); % original function in time\n\nF = exp(-w.^2/(4*a))*sqrt(pi/a); %analytical solution\n```\n\n\nin the above code, looks like there is good agreement when the real and imaginary parts of the function are plotted:\n\n\n\nBut if I study a decaying exponential multiplied with a Heaviside function:\n\n```\nH = @(x)1*(x>0); % Heaviside function\ny = exp(-a*t).*H(t);\n\nF = 1./(a+1j*w); %analytical solution\n```\n\n\nthen\n\n\n\nWhy is there a discrepancy? I suspect it's related to the line ```\nY =```\n but I'm not sure why or how.\n\nEdit: I changed the ```\nifftshift```\n to ```\nfftshift```\n in ```\nY = dt*fftshift(abs(fft(y)));```\n. Then I also removed the ```\nabs```\n. The second graph now looks like:\n\n\n\nWhat is the mathematical reason behind the 'mirrored' graph and how can I remove it?\n    ", "Answer": "\r\nThe plots at the bottom of the question are not mirrored. If you plot those using lines instead of dots you'll see the numeric results have very high frequencies. The absolute component matches, but the phase doesn't. When this happens, it's almost certainly a case of a shift in the time domain.\n\nAnd indeed, you define the time domain function with the origin in the middle. The FFT expects the origin to be at the first (leftmost) sample. This is what ```\nifftshift```\n is for:\n\n```\nY = dt*fftshift(fft(ifftshift(y)));\n```\n\n\n```\nifftshift```\n moves the origin to the first sample, in preparation for the ```\nfft```\n call, and ```\nfftshift```\n moves the origin of the result to the middle, for display.\n\n\n\nEdit\n\nYour ```\nt```\n does not have a 0:\n\n```\n>> t(L/2+(-1:2))\nans =\n  -1.5000e-05  -5.0000e-06   5.0000e-06   1.5000e-05\n```\n\n\nThe sample at ```\nt(floor(L/2)+1)```\n needs to be 0. That is the sample that ```\nifftshift```\n moves to the leftmost sample. (I use ```\nfloor```\n there in case ```\nL```\n is odd in size, not the case here.)\n\nTo generate a correct ```\nt```\n do as follows:\n\n```\nfs = 1e5; % sampling frequency\nL = 30 * fs;\nt = -floor(L/2):floor((L-1)/2);\nt = t / fs;\n```\n\n\nI first generate an integer ```\nt```\n axis of the right length, with 0 at the correct location (```\nt(floor(L/2)+1)==0```\n). Then I convert that to seconds by dividing by the sampling frequency.\n\nWith this ```\nt```\n, the ```\nY```\n as I suggest above, and the rest of your code as-is, I see this for the Gaussian example:\n\n```\n>> max(abs(F-Y))\nans =    4.5254e-16\n```\n\n\nFor the other function I see larger differences, in the order of 6e-6. This is due to the inability to sample the Heaviside function. You need t=0 in your sampled function, but H doesn't have a value at 0. I noticed that the real component has an offset of similar magnitude, which is caused by the sample at t=0.\n\nTypically, the sampled Heaviside function is set to 0.5 for t=0. If I do that, the offset is removed completely, and max difference for the real component is reduced by 3 orders of magnitude (largest errors happen for values very close to 0, where I see a zig-zag pattern). For the imaginary component, the max error is reduced to 3e-6, still quite large, and is maximal at high frequencies. I attribute these errors to the difference between the ideal and sampled Heaviside functions.\n\nYou should probably limit yourself to band-limited functions (or nearly-band-limited ones such as the Gaussian). You might want to try to replace the Heaviside function with an error function (integral of Gaussian) with a small sigma (```\nsigma = 0.8 * fs```\n is the smallest sigma I would consider for proper sampling). Its Fourier transform is known.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "inverse fast fourier transform for frequency range\r\n                \r\nMy problem is to obtain original signal from amplitude spectrum (fft) based on inverse fft but only for some frequency range ex. 8-12 Hz. Could anyone help me? I try to used: \n\n```\nxdft=fft(x); \nixdft=ifft(xdft(a:b)), %where xdft(a:b) is |Y(f)| for freq 8-12 Hz.\n```\n\n\nBut it doesn't want to work.\n    ", "Answer": "\r\nYou can set all the values of ```\nxdft```\n to zero except those you want, i.e.,\n\n```\nxdft = fft(x);\nxdft = xdft(1:ceil(length(xdft) / 2));\nxdft(1:a) = 0;\nxdft(b+1:end) = 0;\nixdft = ifft(xdft, 'symmetric');\n```\n\n\nThe reason I have taken only half of the original FFT'd data is that your result will be symmetric about Fs / 2 (where Fs is the sample rate), and if you don't do the same thing to the frequencies either side of the centre, you will get a complex signal out. Instead of doing the same thing to both sides manually, I've just taken one side, modified it, and told ```\nifft```\n that it has to reconstruct the data for the full frequency range by appending a mirror image of what you pass it; this by done by calling it with the ```\n'symmetric'```\n option.\n\nIf you need to figure out what ```\na```\n and ```\nb```\n should be for some frequency, you can first create a vector of the frequencies at which you've performed the FFT, then find those frequencies that are within your range, like so:\n\n```\nxdft = fft(x);\nxdft = xdft(1:ceil(length(xdft) / 2));\nf = linspace(0, Fs / 2, length(xdft));\nkeepInd = f >= 8 & f <= 12; % Keep frequencies between 8 and 12 Hz\nxdft(~keepInd) = 0;\n```\n\n\nNote that I've actually omitted the use of the two variables ```\na```\n and ```\nb```\n altogether in this example and opted for logical indexing, and that ```\nFs```\n is the sample rate.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "\"Tree\" for Fast Fourier Transform polynomial evaluation?\r\n                \r\nI am trying to evaluate polynomial A(x) through a divide and conquer algorithm using the FFT. I basically break the polynomial into its odd roots and even roots and then recurse on the two smaller polynomials.(allowing me to evaluate twice the number values per recursion).\n\nTo visualize this, I am trying to create a tree to show the polynomial's path through the algorithm. I am not exactly sure how to get started- could someone just start me off? I am not expecting a complete tree just a brief example to get me on the right path.\n    ", "Answer": "\r\nHere is a simple example from Chapter 2 of Algorithms:\n\n```\nA(x) = 3 + 4x + 6x^2 + 2x^3 + x^4 + 10x^5\n     = (3 + 6x^2 + x^4) + x(4 + 2x^2 + 10x^4)\n     = E(x^2) + x*O(x^2)\n```\n\n\nwhere\n\n```\nE(x) = 3 + 6x + x^2\nO(x) = 4 + 2x + 10x^2\n```\n\n\nNotice how the size of the polynomial has shrunk by a factor of 2? Also, we can recycle an evaluation at ```\nx```\n since ```\n-x```\n will result in a similar value.\n\n```\nA(x) = E(x^2) + x*O(x^2)\nA(-x) = E(x^2) - x*O(x^2)\n```\n\n\nI hope you can see how this recursive process becomes a tree.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "3d vibration data with Fast Fourier Transform\r\n                \r\nI'm trying to use FFT method in python to convert 3d vibration data collected from accelerometer. We set the frequency to 50 hz. \n\nWhen I was trying to plot the data, I got a weird graph. Can someone please tell me why? \n\n```\nimport scipy.fftpack\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nY = pd.read_excel(r'/Users/0000/Documents/0000/data/accelData1.xls')\n\n\ny1 = Y['X'].values\ny2 = Y['Y'].values\ny3 = Y['Z'].values\n\ny = y1 + y2 +y3\n\nN = 1280\nT = 0.01\nx = np.linspace(0.0, N*T, N)\n\nyf = np.abs(scipy.fft(y))\nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\n\n\nplt.plot(yf[0:N//2], xf, label = 'signal')\n\n```\n\n\nfft plot\n\n\n    ", "Answer": "\r\nYour graph is upside down, you inverted x and y when plotting\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Dividing fourier transform by factor n\r\n                \r\nI have a problem with the fast fourier transform in python. I would like to extract the low and high frequency power of a signal. I have seen the following example:\n\n```\nY = np.fft.fft(signal)/n #Calculate FFT\nY = Y[range(n/2)] #Return one side of the FFT\nlf = np.trapz(abs(Y[(frq>=0.04) & (frq<=0.15)]))\nhf = np.trapz(abs(Y[(frq>=0.16) & (frq<=0.5)])) #Do the same for 0.16-0.5Hz (HF)\n```\n\n\n```\nsignal```\n is just a an array of values (Let's say 10000 values).\n\nThe problem here is that I don't see what ```\nn```\n should be. Should ```\nn```\n just be the length of ```\nsignal```\n?\n    ", "Answer": "\r\nNo, n should not always be the length of the signal.  n is the length of the FFT, which is determined by the frequency resolution and time localization required, which may also depend on the stationarity and/or other characteristics of the signal, as well as whether any windowing or zero-padding is to be used.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Is there a package in R that gives -normalized- inverse FFT?\r\n                \r\nHas anyone written a fast Fourier transform extension for R that modifies R's native fft() function so that when you call for the inverse fast Fourier transform you don't have to divide by the length of the fast Fourier transform output? I'm doing a lot of FFTs and inverse FFTs and having to do this every time is getting annoying.\n    ", "Answer": "\r\nYou could write your own:\n\n```\nfftinv <- function( x ) { fft( x, inverse=TRUE ) / length( x ) }\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Calculating W for NTT (Integer Fast Fourier Transform)\r\n                \r\nI'm attempting to implement an NTT (Number Theoretic Transform) in Objective C, however the abstract mathematical documents posted online are missing crucial details.  I've found the following existing Question on Stack Overflow which purports to include a working (albeit non-optimal) implementation of NTT:\nModular arithmetics and NTT (finite field DFT) optimizations\n\nMy question is regarding the computation of \"W\".  \"p\" is obviously a chosen prime number.  However this implementation computes \"W=(2^L) mod p\".  \"L\" is a predefined constant equal to \"0x30000000\", which is most definitely not a power of base 2.  This directly contradicts several different mathematical abstracts I've found which seem to indicate that \"L\" should not only be the number of elements in the source array (and thus a power of base 2), but also variable to boot!  Obviously I'm missing something important here.  Can someone please resolve this contradiction.  How was the value of \"L\" chosen here?  More importantly, given a different prime number how would one go about determining the corresponding value of \"L\"?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast-fourier transform for low-frequency signals in the WebAudio API / javascript\r\n                \r\nI have a single-channel wave coming in at an 8000 Hz sampling rate.\n\nI need to analyze frequencies that are between 5 Hz and 300 Hz in real-time, with emphasis on signals from 10 to 60 Hz.\n\nMy thought initially is to run the 8000 Hz sample into a buffer, collecting about 32000 samples. Then, run a 32000 window-sized fourier transform on it. \n\nThe reasoning here is that for lower-frequency signals, you need a larger window size (right?)\n\nHowever, if I'm trying to display this signal in real-time, it seems like the AudioAnalyserNode might not be a good choice here. I know the WebAudio API would allow me to get the raw data, but ideally the AudioAnalyserNode would be able to run a new fft based on the previous 32000 samples, even if a smaller amount of samples have become newly available. At this point, it seems like the fft data is only updating once every four seconds.\n\nDo I have to create a special \"running bin\" so that the display updates more frequently than once every 4 seconds? Or, what's the smallest window size I can use to still get reasonable values in this range? Is 32000 a large enough window size? \n\nI am using the WebAudio API analyser node in javascript, but if I have to get the raw data, I'm also willing to change libraries to another one in javascript.\n    ", "Answer": "\r\nUsing an AnalyserNode, you can call ```\ngetFloatFrequencyData```\n as often as you like.  This will return the FFT of the last ```\nfftSize```\n samples.  These get smoothed together.  For full details, see AnalyserNode Interface\n\nAlso, the WebAudio spec allows you to construct an ```\nAudioContext```\n with a user-selectable sample rate.  You could set your sample rate to 8000 Hz.  Then your FFTs can have finer resolution with less complexity.\n\nHowever, I don't think any browser has implemented this capability yet.\n\nAn alternative would be to get a supported audio card that allows a sample rate of 8000 Hz and set up your system to use that as the default audio output device,  Then the audio context will have a sample rate of 8000 Hz.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for radial forces in Python\r\n                \r\nFirst of all I want to say that I am very new in this and some help it would be welcome. I want to calculate fft for radial forces and something I'm missing. Until now I have something like this:\n\n```\nt=np.arange(145)\nsp=np.fft.fft(radial_force)\nfreq=np.fft.fftfreq(t.shape[-1])\npl.plot(freq, radial_force.real, freq,radial_force.imag)\npl.show()\n```\n\n\nI get really big values and I don't know why. Any hint would be helpful.\nThank you in advance !\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to use fast Fourier transform for the complex values in MATLAB\r\n                \r\nI solved a differential equation and the solutions of that are the complex values in the time domain. I have to transform it to the frequency domain with FFT. I have used FFT in MATLAB, but the answers are not correct. How can I choose my interval of frequency?\nThe time domain is between -10 and 60 and the number of steps is 1000.\n```\nfunction r = fur()\n    clc\n    clear\n    format long\n    a = -10;          % tmin\n    b = 60;           % tmax\n    m = 1000;         % Number of steps\n    t = zeros(1, m);\n    y = zeros(1, m);\n\n    t(1) = a;         % Boundary condition\n    y(1) = 0;         % Boundary condition\n    t0 = 0.01;\n    h = (b-a)/m;\n\n    for j=1:m\n        T = t(j); Y = y(j);\n        k1 = h*Fun(T, Y);\n        k2 = h*Fun(T + h/2, Y + k1/2);\n        k3 = h*Fun(T + h/2, Y + k2/2);\n        k4 = h*Fun(T + h, Y + k3);\n        y(j+1) = Y + (k1 + 2*k2 + 2*k3 + k4)/6;\n        t(j+1) = a + h*(j);\n    end\n\n    % real_y = real(y);\n    % imag_y = imag(y);\n    y;\n\n    %% Fast Fourier transformation for P(W)\n\n    NFFT = length(y);\n    fs = 2*pi/h;\n    X = fftshift(fft(y, NFFT));\n    fVals = (0:NFFT-1)*fs/NFFT;\n\n    figure(1)\n    plot(fVals, abs(X), '-b');\n    title('Fast Fourier transform');\n    xlabel('Frequency (THz)')\n    ylabel('p(w)');\n\n    hold on\n\n\n    %% Fast Fourier transformation for E(W)\n\n    NFFT = length(y);\n\n    fs = 2*pi/h;\n    Z = fftshift(fft(Et(t, t0), NFFT));\n    fVals = (0:NFFT-1)*fs/NFFT;\n\n    figure (2)\n    plot(fVals, abs(Z), '-r');\n    title('Fast Fourier Transform');\n    xlabel('Frequency (THz)')\n    ylabel('E(w)');\n    hold on\n\n    %% Linear susceptibility\n\n    f = X./Z;\n    f_imag = imag(f);\n    f_real = real(f);\n    fVal = (0:NFFT-1)*fs/NFFT;\n\n    figure(3)\n    plot(fVal, f_real, '-r');\n    title('total part of susceptibility');\n    xlabel('Frequency (THz)')\n    ylabel('Kappa(w)');\n    hold on\n\n    figure(4);\n    plot(fVals, f_imag, '-r');\n    title('imaginary part of susceptibility');\n    xlabel('Frequency (THz)')\n    ylabel('kappa(w)');\n    hold on\n```\n\nAnd this is the Fun.m file:\n```\nfunction F = Fun(t, y)\n    format long\n    E_g = 1.52; % Binding energy for GaAs\n    gamma = 0.1*E_g;\n    t0 = 0.01; % This is a damping operator\n    k = 1;\n    F = -i*((((k^2)-i*gamma)*y)-Et(t, t0)); % F = -i*((-i*gamma)*y-1/2);;\n```\n\nAnd this is the Et.m file:\n```\nfunction e = Et(t, t0)\n    format long\n    t0 = 0.1;\n    e = (1/2)*(exp(-(t/t0).^2));\nend\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform of subset of vibration dataset\r\n                \r\nI am new at signal processing. I am trying to compute and plot FFT of a given dataset. The dataset corresponds to vibration signals captured using accelerometer. Dataset contains amplitude in x, y and z direction along with time.\nThe problem that I am facing is when I try to take a subset of the data, the FFT gives a straight line, I cannot see the frequencies and amplitude in those. Below is the code that I am using:\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.fftpack import fft\nfrom scipy import signal\nimport tkinter as tk\nfrom tkinter import filedialog\nimport time\n\n#Prompt user for file\nroot = tk.Tk()\nroot.withdraw()\nfile_path = filedialog.askopenfilename(filetypes=[(\"Two Column CSV\",\"*.csv\")])\nprint(file_path)\ntitle = input(\"Enter Experiment Name: \")\n\n#Load Data (assumes two column array\ntic = time.process_time()\nx, y, z, t = np.genfromtxt(file_path,delimiter=',', unpack=True)\nprint(t)\ntoc = time.process_time()\nprint(\"Load Time:\",toc-tic)\n\n#Determine variables\nN = np.int(np.prod(t.shape))#length of the array\nFs = 1/((t[1]-t[0])/10**9)  #sample rate (Hz)\ntotal_duration = (t[-1] - t[0])/10**9\nT = 1/Fs\nt_sec = [(t[i+1] - t[0])/10**9 for i in range(0,len(t)-1)]\nprint('Total Duration: ', total_duration)\nprint(\"# Samples:\",N)\nprint('Sampling rate: ',Fs)\n\ntic = time.process_time()\nfig_fft, host_fft = plt.subplots()\nfig_fft.set_size_inches(16,9)\nplt.figure(3)  \nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\nyf = fft(x)\nplt.plot(xf, 2.0/N * np.abs(yf[0:np.int(N/2)]))\nplt.grid()\nplt.xlabel('Frequency (Hz)', fontsize=14)\nplt.ylabel('Acc (m/$sec^2$)', fontsize=14)\nplt.title('FFT (X)- ' + title, fontsize=18)\nplt.savefig('FFT (X) {}'.format(title), dpi=300, bbox_inches='tight')\nplt.show()\n```\n\nhere is the link to main dataset\nhere is the link to 10sec data extracted from above dataset\n\n\nplease let me know how to fix this problem.\nThank you\n    ", "Answer": "\r\nI frequently had this problem. The zeroth entry of the Fourier transform contains the integral (or the sum) of the signal. If your signal is not centered around zero, this entry will be always very large.\nThere are two easy ways to get around this: Either center the measured data around zero (but maybe you want to keep that information of the center for something else)\n```\nx = x - np.mean(x)\n```\n\nAlternatively, simply set the zeroth component to zero:\n```\nyf[0] = 0\n```\n\nA third way would be not to plot the zeroth entry of the array.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to transform a FFT (Fast Fourier Transform) into a Polar Transformation with Python?\r\n                \r\nI was able to create a FFT Transformation from my image but I don't know how to continue...\n\nI am using this to solve my problem: Align text for OCR\n\nThis code was all that worked for me until now:\n\n```\nimport cv2\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n%matplotlib inline\n\nimg = cv2.imread(r'test.jpg', cv2.IMREAD_GRAYSCALE)\n\nf = np.fft.fft2(img)\nfshift = np.fft.fftshift(f)\nmagnitude_spectrum = 20 * np.log(np.abs(fshift))\n\nplt.subplot(121), plt.imshow(img, cmap='gray')\nplt.title('Input Image'), plt.xticks([]), plt.yticks([])\n\nplt.subplot(122), plt.imshow(magnitude_spectrum, cmap='gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\n\nplt.show()\n```\n\n\nI need the mean value generated from a Polar Transformation, but I don't know how to transform a FFT to a Polar Transformation in Python.\n    ", "Answer": "\r\nThis is roughly solution to you problem; It was tested on one sample image, and the result looks credible. \n\n```\n# your code goes here... \n\ndef transform_data(m):\n    dpix, dpiy = m.shape\n    x_c, y_c = np.unravel_index(np.argmax(m), m.shape)\n    angles = np.linspace(0, np.pi*2, min(dpix, dpiy))\n    mrc = min(abs(x_c - dpix), abs(y_c - dpiy), x_c, y_c)\n    radiuses = np.linspace(0, mrc, max(dpix, dpiy))\n    A, R = np.meshgrid(angles, radiuses)\n    X = R * np.cos(A)\n    Y = R * np.sin(A)\n    return A, R, m[X.astype(int) + mrc - 1, Y.astype(int) + mrc - 1]\n\n    angles, radiuses, m = transform_data(magnitude_spectrum)\n\n    plt.contourf(angles, radiuses, m)\n```\n\n\n\n\nFinally, we can get the angle we want to turn the original image:\n\n```\nsample_angles = np.linspace(0,  2 * np.pi, len(c.sum(axis=0))) / np.pi*180\nturn_angle_in_degrees = 90 - sample_angles[np.argmax(c.sum(axis=0))]\n```\n\n\nFor my sample image I got: \n\n```\nturn_angle_in_degrees = 3.2015810276679844 degrees.\n```\n\n\nAlso, we can plot projected spectrum magnitude: \n\n```\nplt.plot(sample_angles, c.sum(axis=0))\n```\n\n\n\n\nHope that helps... \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Impact of data intervals in fast fourier transform\r\n                \r\nI have sampled sensor data for 1 minute with 5kHz sampling.\nSo, one sampled data file includes 5,000 x 60 = 300,000 data points.\nNote that the sensor measures periodic data such as 60Hz AC current.\n\nNow, I would like to apply FFT (using python numpy.rfft function) to the one data file.\nAs I know, the number of FFT results is half of the number of input data, i.e., 150,000 FFT results in the case of 300,000 data points.\nHowever, the number of FFT results is too large to analyze them.\n\nSo, I would like to reduce the number of FFT results.\nRegarding that, my question is that the following method valid given the one sampled data file?\n\n\nSegment the one sampled data file into M segments\nApply FFT to each segment\nAverage the M FFT results to get one averaged FFT result\nUse the average FFT result as FFT result of the given one sampled data file\n\n\nThank you in advance.\n    ", "Answer": "\r\nIt depends on your purposes. \n\nIf source signal is sampled with 5 kHz, then frequency of max output element will corresponds to 2.5 kHz. So for 150K output length frequency resolution will about 0.017 Hz. If you apply transform to 3000 data points, you'll get freq.resolution 1.7 Hz. \n\nIs this important for you? Do you need to register  all possible frequency components of AC current? \n\nAC quality (magnitude, frequency, noise) might vary during one-minute interval. Do you need to register such instability? \n\nPerhaps, high freq. resolution and short-range temporal stability is not necessary for AC control, in this case you approach is quite well.\n\nEdit: Longer interval also diminishes finite-duration signal windowing effect that gives false peaks\n\nP.S. Note that fast Fourier transform usually (not always, I don't see such directions in rfft description) works with ```\ninterval length = 2^N```\n, so here output might contain 256K \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "plotstft() plotting short time fast fourier transform\r\n                \r\nHere is my code:\n\n```\n>  from scipy.fftpack import fft \n>  import matplotlib.pyplot as plt \n>  from numpy.lib import stride_tricks \n>  import matplotlib.pyplot as plt\n>  plotstft(sound_files[\"jazz\"][\"wavedata\"],sound_files[\"jazz\"][\"samplerate\"])\n```\n\n\nAnd it gives an error : \"NameError: name 'plotstft' is not defined\". How can I fix it? I am using python2.7 on ubuntu\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform of Frequency Analysis in Labview\r\n                \r\nI'm currently measuring the signal from 3 direction vibration sensor. I wan to convert my signal to a FFT form to determine the frequency analysis of it. Anyone got idea how I do it in Labview?\n    ", "Answer": "\r\nThere is an FFT VI under Signal Processing >> Transforms on the Functions Palette that should do what you're asking. Probably not a bad place to start.\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Assume pixel is circular in Fast Fourier Transform\r\n                \r\nI'm trying to calculate holograms through an iterative algorithm that applies FFT. Holograms are calculated though based on square signals(pixels). I want to calculate FFT from  a signal ( a pixel ) but i want its FFT to be the FFT of a circular \"pixel\".\n\nWhat ive tried os far is to take a 64x64 pixels hologram, enlarge it by 31 times (1984x1984) and create a circle with central point the pixel.\n\nI want to avoid that rescaling.\n Although the smaller the size of the rescaled image the less accurate the circle is.\n\n```\nI=imread('MM.bmp'); I=imresize(I,[64 64 ],'Method', 'nearest');\nI=I./max(max(I)); \navg1=mean(mean(I));\nI1=I;\nph=rand([size(I,1),size(I,2)]);\nU=I1.*exp(1j*ph);\n\nfor n=1:700\n        n1=n1+1;\nU1= fftshift(fft2(fftshift(U)));\nU2=fftshift(ifft2(fftshift(exp(1j*angle(U1)))));\navg2=mean(mean(abs(U2)));\nU3=(U2./avg2).*avg1;\nU=I.*exp(1j.*angle(U3));\nend\nimwrite(angle(U1), 'HOLOGRAM.jpg')\n```\n\n\nwhen i will use the fft on a pixel signal, i want to get the fft of a circle not the sinc function from the square signal.`\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Land masking and Fast Fourier transformation\r\n                \r\nI want to create a land masking for a netcdf file I have that contains information about the horizontal velocity on the Gulf Stream. So I want to have only oceanic points. I am attaching info for the nc file down here. Any ideas about the land masking?enter image description here\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in Objective-C doesn't work fine\r\n                \r\nI have a method in ```\nObjective-C```\n that receives an ```\narray of doubles```\n and then it uses the ```\nFast Fourier Transform```\n, however the exit of the ```\nFFT```\n doesn't match to what I want. \n\nCan someone help me, I don't know what I'm doing wrong?\n\nThis is my method where ```\nfftLength```\n is 4096:\n\n```\n-(double(*)) doFFT:(double(*))data{\n    double (*fft) = malloc((fftLength * 2) * sizeof(double));\n\n    FFTSetupD fft_weights = vDSP_create_fftsetupD((log2((double)(fftLength))), kFFTRadix2);\n\n    DSPDoubleSplitComplex fftData;\n    //fftData.imagp = fftMagnitudes;\n\n    fftData.imagp = (double*)malloc(fftLength * sizeof(double));\n    fftData.realp = (double*)malloc(fftLength * sizeof(double));\n\n    for (int i=0; i< fftLength; i++) {\n        fftData.realp[i] = (double)data[i];\n        fftData.imagp[i] = (double)0.0;\n\n    }\n\n    vDSP_fft_zipD(fft_weights, &fftData, 1, log2((double)(fftLength)), FFT_FORWARD);\n\n    for(int i = 0;i<fftLength * 2;i++){\n        fft[i] = fftData.realp[i];\n        fft[i+1] = fftData.imagp[i];\n    }\n\n    return fft;\n}\n```\n\n\nAnd this is part of my input data:\n\n```\n[0.0,2.092731423889438E-4, 8.858534436404497E-4,0.0013714427743574675,0.0012678166431137061,-9.650789019044481E-4,-0.002852548808273958,-0.005176802258252122,-0.007281581949909022,-0.00575977878132905,…]\n```\n\n\nAnd the result should be:\n\n```\n[21478.183372382526,0.0,-10190.412374839314,…]\n```\n\n\nBut I'm not getting this.\n    ", "Answer": "\r\nThis loop is wrong:\n\n```\nfor(int i = 0;i<fftLength * 2;i++){\n    fft[i] = fftData.realp[i];\n    fft[i+1] = fftData.imagp[i];\n}\n```\n\n\nAssuming you want interleaved real/complex output data then it should be:\n\n```\nfor(int i = 0; i < fftLength; i++) {\n    fft[i * 2] = fftData.realp[i];\n    fft[i * 2 + 1] = fftData.imagp[i];\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Result in fast fourier transform in python is different\r\n                \r\nAlthough it a lot of topic about this but I dont really understanding when look up for exactly what in this problems.When I see some implementation FFT2 and apply them to Guassian kernel it has the diffirence from the numpy.fft.fft2 that also I apply them into its, specifically I have kernel like this:\n```\nkernel = np.fft.fft2(kernel)\nreturn kernel\n\n#KERNEL\n[[0.07511361 0.1238414  0.07511361]\n\n [0.1238414  0.20417996 0.1238414 ]\n\n [0.07511361 0.1238414  0.07511361]]\n```\n\nIn python:\n```\n#Results\n\n[[-0.01580538-2.73757188e-02j -0.08889707+1.53974244e-01j\n   0.03161076-3.46944695e-18j]\n [-0.08889707+1.53974244e-01j  1.        +0.00000000e+00j\n  -0.08889707-1.53974244e-01j]\n [ 0.03161076+3.46944695e-18j -0.08889707-1.53974244e-01j\n  -0.01580538+2.73757188e-02j]]\n```\n\nIn the implementation java:\n```\n0.6666666666666667 + 0.6666666666666667i   -0.059264713333333344 + -0.059264713333333344i    -0.05926471333333333 + -0.05926471333333333i \n\n-0.05926471333333333 + -0.05926471333333333i   -0.010536923333333337 + -0.010536923333333337i      0.021073846666666618 + 0.021073846666666618i \n\n-0.05926471333333332 + -0.05926471333333332i    0.021073846666666625 + 0.021073846666666625i    -0.010536923333333283 + -0.010536923333333283i \n```\n\nAnd the code when apply is:\n```\npublic static double[][] FFT2D(double[][] inputData,\n                      double[][] realOut,\n                      double[][] imagOut,\n                      double[][] amplitudeOut){\n    int height = inputData.length;\n    int width = inputData[0].length;\n   \n    System.out.println(\"height = \" + height);\n    System.out.println(\"width = \" + width);\n    for(int yWave = 0;yWave < height;yWave++){\n      for(int xWave = 0;xWave < width;xWave++){\n        for(int ySpace = 0;ySpace < height;\n                                       ySpace++){\n          for(int xSpace = 0;xSpace < width;\n                                       xSpace++){\n      realOut[yWave][xWave] += (inputData[ySpace][xSpace]*Math.cos(2*Math.PI*((1.0*\n                             xWave*xSpace/width)+(1.0*yWave*ySpace/height))))\n                              /Math.sqrt(width*height);\n       imagOut[yWave][xWave ] -= (inputData[ySpace][xSpace]*Math.sin(2*Math.PI*((1.0*xWave*\n                               xSpace/width) + (1.0*yWave*ySpace/height))))\n                             /Math.sqrt(width*height);\n \n       amplitudeOut[yWave][xWave] =  Math.sqrt( realOut[yWave][xWave] * realOut[yWave][xWave] +\n                   imagOut[yWave][xWave] * imagOut[yWave][xWave]);\n          }\n        }\n      }\n    }\n     //return realOut and imagOut;\n}\npublic static void main(String[] args){\n\n int rows = 3;\n    int cols = 3;\n    \n    double[][] spatialData = \n[[0.07511361 0.1238414  0.07511361]\n\n [0.1238414  0.20417996 0.1238414 ]\n\n [0.07511361 0.1238414  0.07511361]];\n                                    \n    double[][] realSpect=new double[rows][cols];\n    double[][] imagSpect = new double[rows][cols];\n    double[][] amplitudeSpect = new double[rows][cols];\n    //Now perform the transform\n    realSpect = FFT2D(spatialData,realSpect,\n                       imagSpect,amplitudeSpect);\n    imagSpect = FFT2D(spatialData,realSpect,\n                       imagSpect,amplitudeSpect);\n                       \n    for(int i=0;i<rows;i++){\n        for(int j=0;j < cols;j++){\n            System.out.printf(realSpect[i][j] +\" + \" +imagSpect[i][j]+\"i    \");\n        }\n        System.out.println(\"\\n\");\n    }\n    }\n}\n```\n\nIs it wrong when apply in java like these? Thank you all for helping me!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Build sample data for apache commons Fast Fourier Transform algorithm\r\n                \r\nI wanted to use Apache math commons implementation for FFT (FastFourierTransformer class) to process some dummy data whose 8 data samples are contributing to one complete sinusoidal wave. The maximum being amplitude 230. The code snippet that I tried is below :\n\n```\nprivate double[] transform() \n{   \n    double [] input = new double[8];\n    input[0] = 0.0;\n    input[1] = 162.6345596729059;\n    input[2] = 230.0;\n    input[3] = 162.63455967290594;\n    input[4] = 2.8166876380389125E-14;\n    input[5] = -162.6345596729059;\n    input[6] = -230.0;\n    input[7] = -162.63455967290597;\n\n    double[] tempConversion = new double[input.length];\n\n    FastFourierTransformer transformer = new FastFourierTransformer();\n    try {           \n        Complex[] complx = transformer.transform(input);\n\n        for (int i = 0; i < complx.length; i++) {               \n            double rr = (complx[i].getReal());\n            double ri = (complx[i].getImaginary());\n\n            tempConversion[i] = Math.sqrt((rr * rr) + (ri * ri));\n        }\n\n    } catch (IllegalArgumentException e) {\n        System.out.println(e);\n    }\n\n    return tempConversion;\n}\n```\n\n\n1) Now the data returned by method transform is an array of complex number. Does that array contains the frequency component information about input data? or the tempConversion array that I created will contain the frequency information? The values in tempConversion array is :\n\n```\n 2.5483305001488234E-16\n 920.0\n 4.0014578493024757E-14\n 2.2914314707516465E-13\n 5.658858581079313E-14\n 2.2914314707516465E-13\n 4.0014578493024757E-14\n 920.0\n```\n\n\n2) I searched a lot but at most of the places there is no clear documentation on what format of data algorithm expects (in terms of sample code to understand better) and how do I use the array of results to calculate the frequencies contained in the signal?\n    ", "Answer": "\r\nYour output data looks correct. You've calculated the magnitude of the complex FFT output at each frequency bin which corresponds to the energy in the input signal at the corresponding frequency for that bin. Since your input is purely real, the output is complex conjugate symmetric, and the last 3 output values are redundant.\n\nSo you have:\n\n```\nBin     Freq        Magnitude\n  0     0 (DC)        2.5483305001488234E-16\n  1     Fs/8        920.0\n  2     Fs/4          4.0014578493024757E-14\n  3     3Fs/8         2.2914314707516465E-13\n  4     Fs/2 (Nyq)    5.658858581079313E-14\n  5     3Fs/8         2.2914314707516465E-13  # redundant - mirror image of bin 3\n  6     Fs/4          4.0014578493024757E-14  # redundant - mirror image of bin 2\n  7     Fs/8        920.0                     # redundant - mirror image of bin 1\n```\n\n\nAll the values are effectively 0 apart from bin 1 (and bin 6) which corresponds to a frequency of ```\nFs/8```\n as expected.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Optimizing Fourier transformed signal length\r\n                \r\nI recently stumbled on an interessting problem, when computing the fourier transform of a signal with ```\nnp.fft.fft```\n. The reproduced problem is:\n\n```\n%timeit np.fft.fft(np.random.rand(59601))    \n1 loops, best of 3: 1.34 s per loop\n```\n\n\nI found that the amount of time is unexpectedly long. For instance lets look at some other fft's, but with a slightly longer/shorter signal:\n\n```\n%timeit np.fft.fft(np.random.rand(59600))\n100 loops, best of 3: 6.18 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59602))\n10 loops, best of 3: 61.3 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59603))\n10 loops, best of 3: 113 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59604))\n1 loops, best of 3: 182 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59605))\n100 loops, best of 3: 6.53 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59606))\n1 loops, best of 3: 2.17 s per loop\n\n%timeit np.fft.fft(np.random.rand(59607))\n100 loops, best of 3: 8.14 ms per loop\n```\n\n\nWe can observe that the times are now in miliseconds, except for ```\nnp.random.rand(59606)```\n, which lasts 2.17 s.\n\nNote, the numpy documentation states:\n\n\n  FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform (DFT) can be calculated efficiently, by using symmetries in the calculated terms. The symmetry is highest when n is a power of 2, and the transform is therefore most efficient for these sizes.\n\n\nHowever these vectors do not have the length of a power of 2. Could someone explain how to avoid/predict cases, when computation times are considerably higher?\n    ", "Answer": "\r\nAs some comments have pointed, the prime factor decomposition allows you to predict the time to calculate the FFT. The following graphs show your results. Remark the logarithmic scale!\n\n\nThis image is generated with the following code:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef prime_factors(n):\n    \"\"\"Returns all the prime factors of a positive integer\"\"\"\n    #from http://stackoverflow.com/questions/23287/largest-prime-factor-of-a-number/412942#412942\n    factors = []\n    d = 2\n    while n > 1:\n        while n % d == 0:\n            factors.append(d)\n            n /= d\n        d = d + 1\n\n    return factors\n\n\ntimes = []\ndecomp = []\nfor i in range(59600, 59613):\n    print(i)\n    t= %timeit -o np.fft.fft(np.random.rand(i))\n    times.append(t.best)\n    decomp.append(max(prime_factors(i)))\n\nplt.loglog(decomp, times, 'o')\nplt.ylabel(\"best time\")\nplt.xlabel(\"largest prime in prime factor decomposition\")\nplt.title(\"FFT timings\")\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "run fft(fast fourier transform in splash2 benchmark)\r\n                \r\nhi i want to run fft code(following code) in Ubuntu.\nfor run it i installed m4 in my Ubuntu then after going to the fft directory and make i got many error?\nwhy? anyone can help me?\nand in the top of code i see some command line? what should i do with this commands?how should i use them?\n\nhere is the fft code:\n\n```\n                                                                   */\n/*  Command line options:                                                */\n/*                                                                       */\n/*  -mM : M = even integer; 2**M total complex data points transformed.  */\n/*  -pP : P = number of processors; Must be a power of 2.                */\n/*  -nN : N = number of cache lines.                                     */\n/*  -lL : L = Log base 2 of cache line length in bytes.                  */\n/*  -s  : Print individual processor timing statistics.                  */\n/*  -t  : Perform FFT and inverse FFT.  Test output by comparing the     */\n/*        integral of the original data to the integral of the data      */\n/*        that results from performing the FFT and inverse FFT.          */\n/*  -o  : Print out complex data points.                                 */\n/*  -h  : Print out command line options.                                */\n/*                                                                       */\n/*  Note: This version works under both the FORK and SPROC models        */\n/*                                                                       */\n/*************************************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#define PAGE_SIZE               4096\n#define NUM_CACHE_LINES        65536 \n#define LOG2_LINE_SIZE             4\n#define PI                         3.1416\n#define DEFAULT_M                 10\n#define DEFAULT_P                  1\n\nMAIN_ENV\n\n#define SWAP_VALS(a,b) {double tmp; tmp=a; a=b; b=tmp;}\n\nstruct GlobalMemory {\n  long id;\n  LOCKDEC(idlock)\n  BARDEC(start)\n  long *transtimes;\n  long *totaltimes;\n  unsigned long starttime;\n  unsigned long finishtime;\n  unsigned long initdonetime;\n} *Global;\n\n\nlong P = DEFAULT_P;\nlong M = DEFAULT_M;\nlong N;                  /* N = 2^M                                */\nlong rootN;              /* rootN = N^1/2                          */\ndouble *x;              /* x is the original time-domain data     */\ndouble *trans;          /* trans is used as scratch space         */\ndouble *umain;          /* umain is roots of unity for 1D FFTs    */\ndouble *umain2;         /* umain2 is entire roots of unity matrix */\nlong test_result = 0;\nlong doprint = 0;\nlong dostats = 0;\nlong transtime = 0;\nlong transtime2 = 0;\nlong avgtranstime = 0;\nlong avgcomptime = 0;\nunsigned long transstart = 0;\nunsigned long transend = 0;\nlong maxtotal=0;\nlong mintotal=0;\ndouble maxfrac=0;\ndouble minfrac=0;\ndouble avgfractime=0;\nlong orig_num_lines = NUM_CACHE_LINES;     /* number of cache lines */\nlong num_cache_lines = NUM_CACHE_LINES;    /* number of cache lines */\nlong log2_line_size = LOG2_LINE_SIZE;\nlong line_size;\nlong rowsperproc;\ndouble ck1;\ndouble ck3;                        /* checksums for testing answer */\nlong pad_length;\n\nvoid SlaveStart(void);\ndouble TouchArray(double *x, double *scratch, double *u, double *upriv, long MyFirst, long MyLast);\ndouble CheckSum(double *x);\nvoid InitX(double *x);\nvoid InitU(long N, double *u);\nvoid InitU2(long N, double *u, long n1);\nlong BitReverse(long M, long k);\nvoid FFT1D(long direction, long M, long N, double *x, double *scratch, double *upriv, double *umain2,\n       long MyNum, long *l_transtime, long MyFirst, long MyLast, long pad_length, long test_result, long dostats);\nvoid TwiddleOneCol(long direction, long n1, long j, double *u, double *x, long pad_length);\nvoid Scale(long n1, long N, double *x);\nvoid Transpose(long n1, double *src, double *dest, long MyNum, long MyFirst, long MyLast, long pad_length);\nvoid CopyColumn(long n1, double *src, double *dest);\nvoid Reverse(long N, long M, double *x);\nvoid FFT1DOnce(long direction, long M, long N, double *u, double *x);\nvoid PrintArray(long N, double *x);\nvoid printerr(char *s);\nlong log_2(long number);\n\nvoid srand48(long int seedval);\ndouble drand48(void);\n\nint main(int argc, char *argv[])\n{\n  long i; \n  long c;\n  extern char *optarg;\n  long m1;\n  long factor;\n  long pages;\n  unsigned long start;\n\n  CLOCK(start);\n\n  while ((c = getopt(argc, argv, \"p:m:n:l:stoh\")) != -1) {\n    switch(c) {\n      case 'p': P = atoi(optarg); \n                if (P < 1) {\n                  printerr(\"P must be >= 1\\n\");\n                  exit(-1);\n                }\n                if (log_2(P) == -1) {\n                  printerr(\"P must be a power of 2\\n\");\n                  exit(-1);\n                }\n            break;  \n      case 'm': M = atoi(optarg); \n                m1 = M/2;\n                if (2*m1 != M) {\n                  printerr(\"M must be even\\n\");\n                  exit(-1);\n                }\n            break;  \n      case 'n': num_cache_lines = atoi(optarg); \n                orig_num_lines = num_cache_lines;\n                if (num_cache_lines < 1) {\n                  printerr(\"Number of cache lines must be >= 1\\n\");\n                  exit(-1);\n                }\n            break;  \n      case 'l': log2_line_size = atoi(optarg); \n                if (log2_line_size < 0) {\n                  printerr(\"Log base 2 of cache line length in bytes must be >= 0\\n\");\n                  exit(-1);\n                }\n            break;  \n      case 's': dostats = !dostats; \n            break;\n      case 't': test_result = !test_result; \n            break;\n      case 'o': doprint = !doprint; \n            break;\n      case 'h': printf(\"Usage: FFT <options>\\n\\n\");\n                printf(\"options:\\n\");\n                printf(\"  -mM : M = even integer; 2**M total complex data points transformed.\\n\");\n                printf(\"  -pP : P = number of processors; Must be a power of 2.\\n\");\n                printf(\"  -nN : N = number of cache lines.\\n\");\n                printf(\"  -lL : L = Log base 2 of cache line length in bytes.\\n\");\n                printf(\"  -s  : Print individual processor timing statistics.\\n\");\n                printf(\"  -t  : Perform FFT and inverse FFT.  Test output by comparing the\\n\");\n                printf(\"        integral of the original data to the integral of the data that\\n\");\n                printf(\"        results from performing the FFT and inverse FFT.\\n\");\n                printf(\"  -o  : Print out complex data points.\\n\");\n                printf(\"  -h  : Print out command line options.\\n\\n\");\n                printf(\"Default: FFT -m%1d -p%1d -n%1d -l%1d\\n\",\n                       DEFAULT_M,DEFAULT_P,NUM_CACHE_LINES,LOG2_LINE_SIZE);\n        exit(0);\n            break;\n    }\n  }\n\n  MAIN_INITENV(,80000000);\n\n  N = 1<<M;\n  rootN = 1<<(M/2);\n  rowsperproc = rootN/P;\n  if (rowsperproc == 0) {\n    printerr(\"Matrix not large enough. 2**(M/2) must be >= P\\n\");\n    exit(-1);\n  }\n\n  line_size = 1 << log2_line_size;\n  if (line_size < 2*sizeof(double)) {\n    printf(\"WARNING: Each element is a complex double (%ld bytes)\\n\",2*sizeof(double));\n    printf(\"  => Less than one element per cache line\\n\");\n    printf(\"     Computing transpose blocking factor\\n\");\n    factor = (2*sizeof(double)) / line_size;\n    num_cache_lines = orig_num_lines / factor;\n  }  \n  if (line_size <= 2*sizeof(double)) {\n    pad_length = 1;\n  } else {\n    pad_length = line_size / (2*sizeof(double));\n  }\n\n  if (rowsperproc * rootN * 2 * sizeof(double) >= PAGE_SIZE) {\n    pages = (2 * pad_length * sizeof(double) * rowsperproc) / PAGE_SIZE;\n    if (pages * PAGE_SIZE != 2 * pad_length * sizeof(double) * rowsperproc) {\n      pages ++;\n    }\n    pad_length = (pages * PAGE_SIZE) / (2 * sizeof(double) * rowsperproc);\n  } else {\n    pad_length = (PAGE_SIZE - (rowsperproc * rootN * 2 * sizeof(double))) /\n\n                 (2 * sizeof(double) * rowsperproc);\n    if (pad_length * (2 * sizeof(double) * rowsperproc) !=\n        (PAGE_SIZE - (rowsperproc * rootN * 2 * sizeof(double)))) {\n      printerr(\"Padding algorithm unsuccessful\\n\");\n      exit(-1);\n    }\n  }\n\n  Global = (struct GlobalMemory *) G_MALLOC(sizeof(struct GlobalMemory));\n  x = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n  trans = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n  umain = (double *) G_MALLOC(2*rootN*sizeof(double));  \n  umain2 = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n\n  Global->transtimes = (long *) G_MALLOC(P*sizeof(long));  \n  Global->totaltimes = (long *) G_MALLOC(P*sizeof(long));  \n  if (Global == NULL) {\n    printerr(\"Could not malloc memory for Global\\n\");\n    exit(-1);\n  } else if (x == NULL) {\n    printerr(\"Could not malloc memory for x\\n\");\n    exit(-1);\n  } else if (trans == NULL) {\n    printerr(\"Could not malloc memory for trans\\n\");\n    exit(-1);\n  } else if (umain == NULL) {\n    printerr(\"Could not malloc memory for umain\\n\");\n    exit(-1);\n  } else if (umain2 == NULL) {\n    printerr(\"Could not malloc memory for umain2\\n\");\n    exit(-1);\n  }\n\n  x = (double *) (((unsigned long) x) + PAGE_SIZE - ((unsigned long) x) % PAGE_SIZE);\n  trans = (double *) (((unsigned long) trans) + PAGE_SIZE - ((unsigned long) trans) % PAGE_SIZE);\n  umain2 = (double *) (((unsigned long) umain2) + PAGE_SIZE - ((unsigned long) umain2) % PAGE_SIZE);\n\n/* In order to optimize data distribution, the data structures x, trans, \n   and umain2 have been aligned so that each begins on a page boundary. \n   This ensures that the amount of padding calculated by the program is \n   such that each processor's partition ends on a page boundary, thus \n   ensuring that all data from these structures that are needed by a \n   processor can be allocated to its local memory */\n\n/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the x,\n   trans, and umain2 data structures across physically distributed \n   memories as desired.\n\n   One way to place data is as follows:\n\n   double *base;\n   long i;\n\n   i = ((N/P)+(rootN/P)*pad_length)*2;\n   base = &(x[0]);\n   for (j=0;j<P;j++) {\n    Place all addresses x such that (base <= x < base+i) on node j\n    base += i;\n   }\n\n   The trans and umain2 data structures can be placed in a similar manner.\n\n   */\n\n  printf(\"\\n\");\n  printf(\"FFT with Blocking Transpose\\n\");\n  printf(\"   %ld Complex Doubles\\n\",N);\n  printf(\"   %ld Processors\\n\",P);\n  if (num_cache_lines != orig_num_lines) {\n    printf(\"   %ld Cache lines\\n\",orig_num_lines);\n    printf(\"   %ld Cache lines for blocking transpose\\n\",num_cache_lines);\n  } else {\n    printf(\"   %ld Cache lines\\n\",num_cache_lines);\n  }\n  printf(\"   %d Byte line size\\n\",(1 << log2_line_size));\n  printf(\"   %d Bytes per page\\n\",PAGE_SIZE);\n  printf(\"\\n\");\n\n  BARINIT(Global->start, P);\n  LOCKINIT(Global->idlock);\n  Global->id = 0;\n  InitX(x);                  /* place random values in x */\n\n  if (test_result) {\n    ck1 = CheckSum(x);\n  }\n  if (doprint) {\n    printf(\"Original data values:\\n\");\n    PrintArray(N, x);\n  }\n\n  InitU(N,umain);               /* initialize u arrays*/\n  InitU2(N,umain2,rootN);\n\n  /* fire off P processes */\n\n  CREATE(SlaveStart, P);\n  WAIT_FOR_END(P);\n\n  if (doprint) {\n    if (test_result) {\n      printf(\"Data values after inverse FFT:\\n\");\n    } else {\n      printf(\"Data values after FFT:\\n\");\n    }\n    PrintArray(N, x);\n  }\n\n  transtime = Global->transtimes[0];\n  printf(\"\\n\");\n  printf(\"                 PROCESS STATISTICS\\n\");\n  printf(\"            Computation      Transpose     Transpose\\n\");\n  printf(\" Proc          Time            Time        Fraction\\n\");\n  printf(\"    0        %10ld     %10ld      %8.5f\\n\",\n         Global->totaltimes[0],Global->transtimes[0],\n         ((double)Global->transtimes[0])/Global->totaltimes[0]);\n  if (dostats) {\n    transtime2 = Global->transtimes[0];\n    avgtranstime = Global->transtimes[0];\n    avgcomptime = Global->totaltimes[0];\n    maxtotal = Global->totaltimes[0];\n    mintotal = Global->totaltimes[0];\n    maxfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n    minfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n    avgfractime = ((double)Global->transtimes[0])/Global->totaltimes[0];\n    for (i=1;i<P;i++) {\n      if (Global->transtimes[i] > transtime) {\n        transtime = Global->transtimes[i];\n      }\n      if (Global->transtimes[i] < transtime2) {\n        transtime2 = Global->transtimes[i];\n      }\n      if (Global->totaltimes[i] > maxtotal) {\n        maxtotal = Global->totaltimes[i];\n      }\n      if (Global->totaltimes[i] < mintotal) {\n        mintotal = Global->totaltimes[i];\n      }\n      if (((double)Global->transtimes[i])/Global->totaltimes[i] > maxfrac) {\n        maxfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n      }\n      if (((double)Global->transtimes[i])/Global->totaltimes[i] < minfrac) {\n        minfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n      }\n      printf(\"  %3ld        %10ld     %10ld      %8.5f\\n\",\n             i,Global->totaltimes[i],Global->transtimes[i],\n             ((double)Global->transtimes[i])/Global->totaltimes[i]);\n      avgtranstime += Global->transtimes[i];\n      avgcomptime += Global->totaltimes[i];\n      avgfractime += ((double)Global->transtimes[i])/Global->totaltimes[i];\n    }\n    printf(\"  Avg        %10.0f     %10.0f      %8.5f\\n\",\n           ((double) avgcomptime)/P,((double) avgtranstime)/P,avgfractime/P);\n    printf(\"  Max        %10ld     %10ld      %8.5f\\n\",\n       maxtotal,transtime,maxfrac);\n    printf(\"  Min        %10ld     %10ld      %8.5f\\n\",\n       mintotal,transtime2,minfrac);\n  }\n  Global->starttime = start;\n  printf(\"\\n\");\n  printf(\"                 TIMING INFORMATION\\n\");\n  printf(\"Start time                        : %16lu\\n\",\n      Global->starttime);\n  printf(\"Initialization finish time        : %16lu\\n\",\n      Global->initdonetime);\n  printf(\"Overall finish time               : %16lu\\n\",\n      Global->finishtime);\n  printf(\"Total time with initialization    : %16lu\\n\",\n      Global->finishtime-Global->starttime);\n  printf(\"Total time without initialization : %16lu\\n\",\n      Global->finishtime-Global->initdonetime);\n  printf(\"Overall transpose time            : %16ld\\n\",\n         transtime);\n  printf(\"Overall transpose fraction        : %16.5f\\n\",\n         ((double) transtime)/(Global->finishtime-Global->initdonetime));\n  printf(\"\\n\");\n\n  if (test_result) {\n    ck3 = CheckSum(x);\n    printf(\"              INVERSE FFT TEST RESULTS\\n\");\n    printf(\"Checksum difference is %.3f (%.3f, %.3f)\\n\",\n       ck1-ck3, ck1, ck3);\n    if (fabs(ck1-ck3) < 0.001) {\n      printf(\"TEST PASSED\\n\");\n    } else {\n      printf(\"TEST FAILED\\n\");\n    }\n  }\n\n  MAIN_END;\n}\n\n\nvoid SlaveStart()\n{\n  long i;\n  long MyNum;\n  double *upriv;\n  long initdone; \n  long finish; \n  long l_transtime=0;\n  long MyFirst; \n  long MyLast;\n\n  LOCK(Global->idlock);\n    MyNum = Global->id;\n    Global->id++;\n  UNLOCK(Global->idlock); \n\n  BARINCLUDE(Global->start);\n\n/* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to\n   processors to avoid migration */\n\n  BARRIER(Global->start, P);\n\n  upriv = (double *) malloc(2*(rootN-1)*sizeof(double));  \n  if (upriv == NULL) {\n    fprintf(stderr,\"Proc %ld could not malloc memory for upriv\\n\",MyNum);\n    exit(-1);\n  }\n  for (i=0;i<2*(rootN-1);i++) {\n    upriv[i] = umain[i];\n  }   \n\n  MyFirst = rootN*MyNum/P;\n  MyLast = rootN*(MyNum+1)/P;\n\n  TouchArray(x, trans, umain2, upriv, MyFirst, MyLast);\n\n  BARRIER(Global->start, P);\n\n/* POSSIBLE ENHANCEMENT:  Here is where one might reset the\n   statistics that one is measuring about the parallel execution */\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(initdone);\n  }\n\n  /* perform forward FFT */\n  FFT1D(1, M, N, x, trans, upriv, umain2, MyNum, &l_transtime, MyFirst, \n    MyLast, pad_length, test_result, dostats);\n\n  /* perform backward FFT */\n  if (test_result) {\n    FFT1D(-1, M, N, x, trans, upriv, umain2, MyNum, &l_transtime, MyFirst, \n      MyLast, pad_length, test_result, dostats);\n  }  \n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(finish);\n    Global->transtimes[MyNum] = l_transtime;\n    Global->totaltimes[MyNum] = finish-initdone;\n  }\n  if (MyNum == 0) {\n    Global->finishtime = finish;\n    Global->initdonetime = initdone;\n  }\n}\n\n\ndouble TouchArray(double *x, double *scratch, double *u, double *upriv, long MyFirst, long MyLast)\n{\n  long i,j,k;\n  double tot = 0.0;\n\n  /* touch my data */\n  for (j=0;j<2*(rootN-1);j++) {\n    tot += upriv[j];\n  }   \n  for (j=MyFirst; j<MyLast; j++) {\n    k = j * (rootN + pad_length);\n    for (i=0;i<rootN;i++) {\n      tot += x[2*(k+i)] + x[2*(k+i)+1] + \n             scratch[2*(k+i)] + scratch[2*(k+i)+1] +\n         u[2*(k+i)] + u[2*(k+i)+1];\n    }\n  }  \n  return tot;\n}\n\n\ndouble CheckSum(double *x)\n{\n  long i,j,k;\n  double cks;\n\n  cks = 0.0;\n  for (j=0; j<rootN; j++) {\n    k = j * (rootN + pad_length);\n    for (i=0;i<rootN;i++) {\n      cks += x[2*(k+i)] + x[2*(k+i)+1];\n    }\n  }\n\n  return(cks);\n}\n\n\nvoid InitX(double *x)\n{\n  long i,j,k;\n\n  srand48(0);\n  for (j=0; j<rootN; j++) {\n    k = j * (rootN + pad_length);\n    for (i=0;i<rootN;i++) {\n      x[2*(k+i)] = drand48();\n      x[2*(k+i)+1] = drand48();\n    }\n  }\n}\n\n\nvoid InitU(long N, double *u)\n{\n  long q; \n  long j; \n  long base; \n  long n1;\n\n  for (q=0; 1<<q<N; q++) {  \n    n1 = 1<<q;\n    base = n1-1;\n    for (j=0; j<n1; j++) {\n      if (base+j > rootN-1) { \n    return;\n      }\n      u[2*(base+j)] = cos(2.0*PI*j/(2*n1));\n      u[2*(base+j)+1] = -sin(2.0*PI*j/(2*n1));\n    }\n  }\n}\n\n\nvoid InitU2(long N, double *u, long n1)\n{\n  long i,j,k; \n\n  for (j=0; j<n1; j++) {  \n    k = j*(rootN+pad_length);\n    for (i=0; i<n1; i++) {  \n      u[2*(k+i)] = cos(2.0*PI*i*j/(N));\n      u[2*(k+i)+1] = -sin(2.0*PI*i*j/(N));\n    }\n  }\n}\n\n\nlong BitReverse(long M, long k)\n{\n  long i; \n  long j; \n  long tmp;\n\n  j = 0;\n  tmp = k;\n  for (i=0; i<M; i++) {\n    j = 2*j + (tmp&0x1);\n    tmp = tmp>>1;\n  }\n  return(j);\n}\n\n\nvoid FFT1D(long direction, long M, long N, double *x, double *scratch, double *upriv, double *umain2,\n           long MyNum, long *l_transtime, long MyFirst, long MyLast, long pad_length, long test_result, long dostats)\n{\n  long j;\n  long m1; \n  long n1;\n  unsigned long clocktime1;\n  unsigned long clocktime2;\n\n  m1 = M/2;\n  n1 = 1<<m1;\n\n  BARRIER(Global->start, P);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime1);\n  }\n\n  /* transpose from x into scratch */\n  Transpose(n1, x, scratch, MyNum, MyFirst, MyLast, pad_length);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime2);\n    *l_transtime += (clocktime2-clocktime1);\n  }\n\n  /* do n1 1D FFTs on columns */\n  for (j=MyFirst; j<MyLast; j++) {\n    FFT1DOnce(direction, m1, n1, upriv, &scratch[2*j*(n1+pad_length)]);\n    TwiddleOneCol(direction, n1, j, umain2, &scratch[2*j*(n1+pad_length)], pad_length);\n  }  \n\n  BARRIER(Global->start, P);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime1);\n  }\n  /* transpose */\n  Transpose(n1, scratch, x, MyNum, MyFirst, MyLast, pad_length);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime2);\n    *l_transtime += (clocktime2-clocktime1);\n  }\n\n  /* do n1 1D FFTs on columns again */\n  for (j=MyFirst; j<MyLast; j++) {\n    FFT1DOnce(direction, m1, n1, upriv, &x[2*j*(n1+pad_length)]);\n    if (direction == -1)\n      Scale(n1, N, &x[2*j*(n1+pad_length)]);\n  }\n\n  BARRIER(Global->start, P);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime1);\n  }\n\n  /* transpose back */\n  Transpose(n1, x, scratch, MyNum, MyFirst, MyLast, pad_length);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime2);\n    *l_transtime += (clocktime2-clocktime1);\n  }\n\n  BARRIER(Global->start, P);\n\n  /* copy columns from scratch to x */\n  if ((test_result) || (doprint)) {  \n    for (j=MyFirst; j<MyLast; j++) {\n      CopyColumn(n1, &scratch[2*j*(n1+pad_length)], &x[2*j*(n1+pad_length)]); \n    }  \n  }  \n\n  BARRIER(Global->start, P);\n}\n\n\nvoid TwiddleOneCol(long direction, long n1, long j, double *u, double *x, long pad_length)\n{\n  long i;\n  double omega_r; \n  double omega_c; \n  double x_r; \n  double x_c;\n\n  for (i=0; i<n1; i++) {\n    omega_r = u[2*(j*(n1+pad_length)+i)];\n    omega_c = direction*u[2*(j*(n1+pad_length)+i)+1];  \n    x_r = x[2*i]; \n    x_c = x[2*i+1];\n    x[2*i] = omega_r*x_r - omega_c*x_c;\n    x[2*i+1] = omega_r*x_c + omega_c*x_r;\n  }\n}\n\n\nvoid Scale(long n1, long N, double *x)\n{\n  long i;\n\n  for (i=0; i<n1; i++) {\n    x[2*i] /= N;\n    x[2*i+1] /= N;\n  }\n}\n\n\nvoid Transpose(long n1, double *src, double *dest, long MyNum, long MyFirst, long MyLast, long pad_length)\n{\n  long i; \n  long j; \n  long k; \n  long l; \n  long m;\n  long blksize;\n  long numblks;\n  long firstfirst;\n  long h_off;\n  long v_off;\n  long v;\n  long h;\n  long n1p;\n  long row_count;\n\n  blksize = MyLast-MyFirst;\n  numblks = (2*blksize)/num_cache_lines;\n  if (numblks * num_cache_lines != 2 * blksize) {\n    numblks ++;\n  }\n  blksize = blksize / numblks;\n  firstfirst = MyFirst;\n  row_count = n1/P;\n  n1p = n1+pad_length;\n  for (l=MyNum+1;l<P;l++) {\n    v_off = l*row_count;\n    for (k=0; k<numblks; k++) {\n      h_off = firstfirst;\n      for (m=0; m<numblks; m++) {\n        for (i=0; i<blksize; i++) {\n      v = v_off + i;\n          for (j=0; j<blksize; j++) {\n        h = h_off + j;\n            dest[2*(h*n1p+v)] = src[2*(v*n1p+h)];\n            dest[2*(h*n1p+v)+1] = src[2*(v*n1p+h)+1];\n          }\n        }\n    h_off += blksize;\n      }\n      v_off+=blksize;\n    }\n  }\n\n  for (l=0;l<MyNum;l++) {\n    v_off = l*row_count;\n    for (k=0; k<numblks; k++) {\n      h_off = firstfirst;\n      for (m=0; m<numblks; m++) {\n        for (i=0; i<blksize; i++) {\n      v = v_off + i;\n          for (j=0; j<blksize; j++) {\n            h = h_off + j;\n            dest[2*(h*n1p+v)] = src[2*(v*n1p+h)];\n            dest[2*(h*n1p+v)+1] = src[2*(v*n1p+h)+1];\n          }\n        }\n    h_off += blksize;\n      }\n      v_off+=blksize;\n    }\n  }\n\n  v_off = MyNum*row_count;\n  for (k=0; k<numblks; k++) {\n    h_off = firstfirst;\n    for (m=0; m<numblks; m++) {\n      for (i=0; i<blksize; i++) {\n        v = v_off + i;\n        for (j=0; j<blksize; j++) {\n          h = h_off + j;\n          dest[2*(h*n1p+v)] = src[2*(v*n1p+h)];\n          dest[2*(h*n1p+v)+1] = src[2*(v*n1p+h)+1];\n    }\n      }\n      h_off += blksize;\n    }\n    v_off+=blksize;\n  }\n}\n\n\nvoid CopyColumn(long n1, double *src, double *dest)\n{\n  long i;\n\n  for (i=0; i<n1; i++) {\n    dest[2*i] = src[2*i];\n    dest[2*i+1] = src[2*i+1];\n  }\n}\n\n\nvoid Reverse(long N, long M, double *x)\n{\n  long j, k;\n\n  for (k=0; k<N; k++) {\n    j = BitReverse(M, k);\n    if (j > k) {\n      SWAP_VALS(x[2*j], x[2*k]);\n      SWAP_VALS(x[2*j+1], x[2*k+1]);\n    }\n  }\n}\n\n\nvoid FFT1DOnce(long direction, long M, long N, double *u, double *x)\n{\n  long j; \n  long k; \n  long q; \n  long L; \n  long r; \n  long Lstar;\n  double *u1; \n  double *x1; \n  double *x2;\n  double omega_r; \n  double omega_c; \n  double tau_r; \n  double tau_c; \n  double x_r; \n  double x_c;\n\n  Reverse(N, M, x);\n\n  for (q=1; q<=M; q++) {\n    L = 1<<q; r = N/L; Lstar = L/2;\n    u1 = &u[2*(Lstar-1)];\n    for (k=0; k<r; k++) {\n      x1 = &x[2*(k*L)];\n      x2 = &x[2*(k*L+Lstar)];\n      for (j=0; j<Lstar; j++) {\n    omega_r = u1[2*j]; \n        omega_c = direction*u1[2*j+1];\n    x_r = x2[2*j]; \n        x_c = x2[2*j+1];\n    tau_r = omega_r*x_r - omega_c*x_c;\n    tau_c = omega_r*x_c + omega_c*x_r;\n    x_r = x1[2*j]; \n        x_c = x1[2*j+1];\n    x2[2*j] = x_r - tau_r;\n    x2[2*j+1] = x_c - tau_c;\n    x1[2*j] = x_r + tau_r;\n    x1[2*j+1] = x_c + tau_c;\n      }\n    }\n  }\n}\n\n\nvoid PrintArray(long N, double *x)\n{\n  long i, j, k;\n\n  for (i=0; i<rootN; i++) {\n    k = i*(rootN+pad_length);\n    for (j=0; j<rootN; j++) {\n      printf(\" %4.2f %4.2f\", x[2*(k+j)], x[2*(k+j)+1]);\n      if (i*rootN+j != N-1) {\n        printf(\",\");\n      }\n      if ((i*rootN+j+1) % 8 == 0) {\n        printf(\"\\n\");\n      }\n    }\n  }\n  printf(\"\\n\");\n  printf(\"\\n\");\n}\n\n\nvoid printerr(char *s)\n{\n  fprintf(stderr,\"ERROR: %s\\n\",s);\n}\n\n\nlong log_2(long number)\n{\n  long cumulative = 1, out = 0, done = 0;\n\n  while ((cumulative < number) && (!done) && (out < 50)) {\n    if (cumulative == number) {\n      done = 1;\n    } else {\n      cumulative = cumulative * 2;\n      out ++;\n    }\n  }\n\n  if (cumulative == number) {\n    return(out);\n  } else {\n    return(-1);\n  }\n}\n```\n\n\nThese are some of the errors I get:\n\n```\nfft.C: In function ‘FFT1D’:\nfft.C:603:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:623:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:643:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:657:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:666:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C: In function ‘main’:\nfft.C:416:1: warning: control reaches end of non-void function [-Wreturn-type]\n }\n ^\n../../Makefile.config:30: recipe for target 'fft.o' failed\nmake: *** [fft.o] Error 1\n```\n\n    ", "Answer": "\r\n~/Desktop/splash2/codes/kernels/fft$ make\n\n```\ngcc -c -O3 -pthread -D_POSIX_C_SOURCE=200112 -Wall -W -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls -Wdisabled-optimization -Wpadded -Winline -Wpointer-arith -Wsign-compare -Wendif-labels fft.c\nfft.C:59:1: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘struct’\n struct GlobalMemory {\n ^\nfft.C: In function ‘main’:\nfft.C:134:3: warning: implicit declaration of function ‘CLOCK’ [-Wimplicit-function-declaration]\n   CLOCK(start);\n   ^\nfft.C:136:3: warning: implicit declaration of function ‘getopt’ [-Wimplicit-function-declaration]\n   while ((c = getopt(argc, argv, \"p:m:n:l:stoh\")) != -1) {\n   ^\nfft.C:138:7: warning: implicit declaration of function ‘atoi’ [-Wimplicit-function-declaration]\n       case 'p': P = atoi(optarg); \n       ^\nfft.C:141:19: warning: implicit declaration of function ‘exit’ [-Wimplicit-function-declaration]\n                   exit(-1);\n                   ^\nfft.C:141:19: warning: incompatible implicit declaration of built-in function ‘exit’\nfft.C:145:19: warning: incompatible implicit declaration of built-in function ‘exit’\n                   exit(-1);\n                   ^\nfft.C:152:19: warning: incompatible implicit declaration of built-in function ‘exit’\n                   exit(-1);\n                   ^\nfft.C:159:19: warning: incompatible implicit declaration of built-in function ‘exit’\n                   exit(-1);\n                   ^\nfft.C:165:19: warning: incompatible implicit declaration of built-in function ‘exit’\n                   exit(-1);\n                   ^\nfft.C:188:3: warning: incompatible implicit declaration of built-in function ‘exit’\n   exit(0);\n   ^\nfft.C:193:3: warning: implicit declaration of function ‘MAIN_INITENV’ [-Wimplicit-function-declaration]\n   MAIN_INITENV(,80000000);\n   ^\nfft.C:193:16: error: expected expression before ‘,’ token\n   MAIN_INITENV(,80000000);\n                ^\nfft.C:200:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:204:17: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]\n   if (line_size < 2*sizeof(double)) {\n                 ^\nfft.C:211:17: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]\n   if (line_size <= 2*sizeof(double)) {\n                 ^\nfft.C:219:27: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]\n     if (pages * PAGE_SIZE != 2 * pad_length * sizeof(double) * rowsperproc) {\n                           ^\nfft.C:230:7: warning: incompatible implicit declaration of built-in function ‘exit’\n       exit(-1);\n       ^\nfft.C:234:20: warning: implicit declaration of function ‘G_MALLOC’ [-Wimplicit-function-declaration]\n   Global = (struct GlobalMemory *) G_MALLOC(sizeof(struct GlobalMemory));\n                    ^\nfft.C:234:12: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   Global = (struct GlobalMemory *) G_MALLOC(sizeof(struct GlobalMemory));\n            ^\nfft.C:235:7: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   x = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n       ^\nfft.C:236:11: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   trans = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n           ^\nfft.C:237:11: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   umain = (double *) G_MALLOC(2*rootN*sizeof(double));  \n           ^\nfft.C:238:12: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   umain2 = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n            ^\nfft.C:240:9: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n   Global->transtimes = (long *) G_MALLOC(P*sizeof(long));  \n         ^\nfft.C:240:24: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   Global->transtimes = (long *) G_MALLOC(P*sizeof(long));  \n                        ^\nfft.C:241:9: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n   Global->totaltimes = (long *) G_MALLOC(P*sizeof(long));  \n         ^\nfft.C:241:24: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   Global->totaltimes = (long *) G_MALLOC(P*sizeof(long));  \n                        ^\nfft.C:244:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:247:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:250:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:253:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:256:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:304:3: warning: implicit declaration of function ‘BARINIT’ [-Wimplicit-function-declaration]\n   BARINIT(Global->start, P);\n   ^\nfft.C:304:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARINIT(Global->start, P);\n                 ^\nfft.C:305:3: warning: implicit declaration of function ‘LOCKINIT’ [-Wimplicit-function-declaration]\n   LOCKINIT(Global->idlock);\n   ^\nfft.C:305:18: error: ‘struct GlobalMemory’ has no member named ‘idlock’\n   LOCKINIT(Global->idlock);\n                  ^\nfft.C:306:9: error: ‘struct GlobalMemory’ has no member named ‘id’\n   Global->id = 0;\n         ^\nfft.C:322:3: warning: implicit declaration of function ‘CREATE’ [-Wimplicit-function-declaration]\n   CREATE(SlaveStart, P);\n   ^\nfft.C:323:3: warning: implicit declaration of function ‘WAIT_FOR_END’ [-Wimplicit-function-declaration]\n   WAIT_FOR_END(P);\n   ^\nfft.C:334:21: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n   transtime = Global->transtimes[0];\n                     ^\nfft.C:340:16: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n          Global->totaltimes[0],Global->transtimes[0],\n                ^\nfft.C:340:38: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n          Global->totaltimes[0],Global->transtimes[0],\n                                      ^\nfft.C:341:25: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n          ((double)Global->transtimes[0])/Global->totaltimes[0]);\n                         ^\nfft.C:341:48: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n          ((double)Global->transtimes[0])/Global->totaltimes[0]);\n                                                ^\nfft.C:343:24: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     transtime2 = Global->transtimes[0];\n                        ^\nfft.C:344:26: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     avgtranstime = Global->transtimes[0];\n                          ^\nfft.C:345:25: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     avgcomptime = Global->totaltimes[0];\n                         ^\nfft.C:346:22: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     maxtotal = Global->totaltimes[0];\n                      ^\nfft.C:347:22: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     mintotal = Global->totaltimes[0];\n                      ^\nfft.C:348:30: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     maxfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                              ^\nfft.C:348:53: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     maxfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                                                     ^\nfft.C:349:30: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     minfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                              ^\nfft.C:349:53: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     minfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                                                     ^\nfft.C:350:34: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     avgfractime = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                                  ^\nfft.C:350:57: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     avgfractime = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                                                         ^\nfft.C:352:17: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       if (Global->transtimes[i] > transtime) {\n                 ^\nfft.C:353:27: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n         transtime = Global->transtimes[i];\n                           ^\nfft.C:355:17: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       if (Global->transtimes[i] < transtime2) {\n                 ^\nfft.C:356:28: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n         transtime2 = Global->transtimes[i];\n                            ^\nfft.C:358:17: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       if (Global->totaltimes[i] > maxtotal) {\n                 ^\nfft.C:359:26: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n         maxtotal = Global->totaltimes[i];\n                          ^\nfft.C:361:17: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       if (Global->totaltimes[i] < mintotal) {\n                 ^\nfft.C:362:26: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n         mintotal = Global->totaltimes[i];\n                          ^\nfft.C:364:26: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       if (((double)Global->transtimes[i])/Global->totaltimes[i] > maxfrac) {\n                          ^\nfft.C:364:49: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       if (((double)Global->transtimes[i])/Global->totaltimes[i] > maxfrac) {\n                                                 ^\nfft.C:365:34: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n         maxfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                  ^\nfft.C:365:57: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n         maxfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                                         ^\nfft.C:367:26: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       if (((double)Global->transtimes[i])/Global->totaltimes[i] < minfrac) {\n                          ^\nfft.C:367:49: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       if (((double)Global->transtimes[i])/Global->totaltimes[i] < minfrac) {\n                                                 ^\nfft.C:368:34: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n         minfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                  ^\nfft.C:368:57: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n         minfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                                         ^\nfft.C:371:22: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n              i,Global->totaltimes[i],Global->transtimes[i],\n                      ^\nfft.C:371:44: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n              i,Global->totaltimes[i],Global->transtimes[i],\n                                            ^\nfft.C:372:29: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n              ((double)Global->transtimes[i])/Global->totaltimes[i]);\n                             ^\nfft.C:372:52: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n              ((double)Global->transtimes[i])/Global->totaltimes[i]);\n                                                    ^\nfft.C:373:29: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       avgtranstime += Global->transtimes[i];\n                             ^\nfft.C:374:28: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       avgcomptime += Global->totaltimes[i];\n                            ^\nfft.C:375:37: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       avgfractime += ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                     ^\nfft.C:375:60: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       avgfractime += ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                                            ^\nfft.C:384:9: error: ‘struct GlobalMemory’ has no member named ‘starttime’\n   Global->starttime = start;\n         ^\nfft.C:388:10: error: ‘struct GlobalMemory’ has no member named ‘starttime’\n    Global->starttime);\n          ^\nfft.C:390:10: error: ‘struct GlobalMemory’ has no member named ‘initdonetime’\n    Global->initdonetime);\n          ^\nfft.C:392:10: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n    Global->finishtime);\n          ^\nfft.C:394:10: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n    Global->finishtime-Global->starttime);\n          ^\nfft.C:394:29: error: ‘struct GlobalMemory’ has no member named ‘starttime’\n    Global->finishtime-Global->starttime);\n                             ^\nfft.C:396:10: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n    Global->finishtime-Global->initdonetime);\n          ^\nfft.C:396:29: error: ‘struct GlobalMemory’ has no member named ‘initdonetime’\n    Global->finishtime-Global->initdonetime);\n                             ^\nfft.C:400:38: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n          ((double) transtime)/(Global->finishtime-Global->initdonetime));\n                                      ^\nfft.C:400:57: error: ‘struct GlobalMemory’ has no member named ‘initdonetime’\n          ((double) transtime)/(Global->finishtime-Global->initdonetime));\n                                                         ^\nfft.C:415:3: error: ‘MAIN_END’ undeclared (first use in this function)\n   MAIN_END;\n   ^\nfft.C:415:3: note: each undeclared identifier is reported only once for each function it appears in\nfft.C: In function ‘SlaveStart’:\nfft.C:430:3: warning: implicit declaration of function ‘LOCK’ [-Wimplicit-function-declaration]\n   LOCK(Global->idlock);\n   ^\nfft.C:430:14: error: ‘struct GlobalMemory’ has no member named ‘idlock’\n   LOCK(Global->idlock);\n              ^\nfft.C:431:19: error: ‘struct GlobalMemory’ has no member named ‘id’\n     MyNum = Global->id;\n                   ^\nfft.C:432:11: error: ‘struct GlobalMemory’ has no member named ‘id’\n     Global->id++;\n           ^\nfft.C:433:3: warning: implicit declaration of function ‘UNLOCK’ [-Wimplicit-function-declaration]\n   UNLOCK(Global->idlock); \n   ^\nfft.C:433:16: error: ‘struct GlobalMemory’ has no member named ‘idlock’\n   UNLOCK(Global->idlock); \n                ^\nfft.C:435:3: warning: implicit declaration of function ‘BARINCLUDE’ [-Wimplicit-function-declaration]\n   BARINCLUDE(Global->start);\n   ^\nfft.C:435:20: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARINCLUDE(Global->start);\n                    ^\nfft.C:440:3: warning: implicit declaration of function ‘BARRIER’ [-Wimplicit-function-declaration]\n   BARRIER(Global->start, P);\n   ^\nfft.C:440:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:442:3: warning: implicit declaration of function ‘malloc’ [-Wimplicit-function-declaration]\n   upriv = (double *) malloc(2*(rootN-1)*sizeof(double));  \n   ^\nfft.C:442:22: warning: incompatible implicit declaration of built-in function ‘malloc’\n   upriv = (double *) malloc(2*(rootN-1)*sizeof(double));  \n                      ^\nfft.C:445:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:456:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:477:11: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     Global->transtimes[MyNum] = l_transtime;\n           ^\nfft.C:478:11: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     Global->totaltimes[MyNum] = finish-initdone;\n           ^\nfft.C:481:11: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n     Global->finishtime = finish;\n           ^\nfft.C:482:11: error: ‘struct GlobalMemory’ has no member named ‘initdonetime’\n     Global->initdonetime = initdone;\n           ^\nfft.C: In function ‘FFT1D’:\nfft.C:603:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:623:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:643:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:657:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:666:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C: In function ‘main’:\nfft.C:416:1: warning: control reaches end of non-void function [-Wreturn-type]\n }\n ^\n../../Makefile.config:30: recipe for target 'fft.o' failed\nmake: *** [fft.o] Error 1\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to find period of signal (autocorrelation vs fast fourier transform vs power spectral density)?\r\n                \r\nSuppose one wanted to find the period of a given sinusoidal wave signal. From what I have read online, it appears that the two main approaches employ either fourier analysis or autocorrelation. I am trying to automate the process using python and my usage case is to apply this concept to similar signals that come from the time-series of positions (or speeds or accelerations) of simulated bodies orbiting a star. \n\nFor simple-examples-sake, consider ```\nx = sin(t)```\n for ```\n0 ≤ t ≤ 10 pi```\n.\n\n```\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\n\n## sample data\nt = np.linspace(0, 10 * np.pi, 100)\nx = np.sin(t)\nfig, ax = plt.subplots()\nax.plot(t, x, color='b', marker='o')\nax.grid(color='k', alpha=0.3, linestyle=':')\nplt.show()\nplt.close(fig)\n```\n\n\n\n\nGiven a sine-wave of the form ```\nx = a sin(b(t+c)) + d```\n, the period of the sine-wave is obtained as ```\n2 * pi / b```\n. Since ```\nb=1```\n (or by visual inspection), the period of our sine wave is ```\n2 * pi```\n. I can check the results obtained from other methods against this baseline.\n\nAttempt 1: Autocorrelation\n\nAs I understand it (please correct me if I'm wrong), correlation can be used to see if one signal is a time-lagged copy of another signal (similar to how cosine and sine differ by a phase difference). So autocorrelation is testing a signal against itself to measure the times at which the time-lag repeats said signal. Using the example posted here:\n\n```\nresult = np.correlate(x, x, mode='full')\n```\n\n\nSince ```\nx```\n and ```\nt```\n each consist of ```\n100```\n elements and ```\nresult```\n consists of ```\n199```\n elements, I am not sure why I should arbitrarily select the last ```\n100```\n elements.\n\n```\nprint(\"\\n autocorrelation (shape={}):\\n{}\\n\".format(result.shape, result))  \n\n autocorrelation (shape=(199,)):\n[ 0.00000000e+00 -3.82130761e-16 -9.73648712e-02 -3.70014208e-01\n -8.59889695e-01 -1.56185995e+00 -2.41986054e+00 -3.33109112e+00\n -4.15799070e+00 -4.74662427e+00 -4.94918053e+00 -4.64762251e+00\n -3.77524157e+00 -2.33298717e+00 -3.97976240e-01  1.87752669e+00\n  4.27722402e+00  6.54129270e+00  8.39434617e+00  9.57785701e+00\n  9.88331103e+00  9.18204933e+00  7.44791758e+00  4.76948221e+00\n  1.34963425e+00 -2.50822289e+00 -6.42666652e+00 -9.99116299e+00\n -1.27937834e+01 -1.44791297e+01 -1.47873668e+01 -1.35893098e+01\n -1.09091510e+01 -6.93157447e+00 -1.99159756e+00  3.45267493e+00\n  8.86228186e+00  1.36707567e+01  1.73433176e+01  1.94357232e+01\n  1.96463736e+01  1.78556800e+01  1.41478477e+01  8.81191526e+00\n  2.32100171e+00 -4.70897483e+00 -1.15775811e+01 -1.75696560e+01\n -2.20296487e+01 -2.44327920e+01 -2.44454330e+01 -2.19677060e+01\n -1.71533510e+01 -1.04037163e+01 -2.33560966e+00  6.27458308e+00\n  1.45655029e+01  2.16769872e+01  2.68391837e+01  2.94553896e+01\n  2.91697473e+01  2.59122266e+01  1.99154591e+01  1.17007613e+01\n  2.03381596e+00 -8.14633251e+00 -1.78184255e+01 -2.59814393e+01\n -3.17580589e+01 -3.44884934e+01 -3.38046447e+01 -2.96763956e+01\n -2.24244433e+01 -1.26974172e+01 -1.41464998e+00  1.03204331e+01\n  2.13281784e+01  3.04712823e+01  3.67721634e+01  3.95170295e+01\n  3.83356037e+01  3.32477037e+01  2.46710643e+01  1.33886439e+01\n  4.77778141e-01 -1.27924775e+01 -2.50860560e+01 -3.51343866e+01\n -4.18671622e+01 -4.45258983e+01 -4.27482779e+01 -3.66140001e+01\n -2.66465884e+01 -1.37700036e+01  7.76494745e-01  1.55574483e+01\n  2.90828312e+01  3.99582426e+01  4.70285203e+01  4.95000000e+01\n  4.70285203e+01  3.99582426e+01  2.90828312e+01  1.55574483e+01\n  7.76494745e-01 -1.37700036e+01 -2.66465884e+01 -3.66140001e+01\n -4.27482779e+01 -4.45258983e+01 -4.18671622e+01 -3.51343866e+01\n -2.50860560e+01 -1.27924775e+01  4.77778141e-01  1.33886439e+01\n  2.46710643e+01  3.32477037e+01  3.83356037e+01  3.95170295e+01\n  3.67721634e+01  3.04712823e+01  2.13281784e+01  1.03204331e+01\n -1.41464998e+00 -1.26974172e+01 -2.24244433e+01 -2.96763956e+01\n -3.38046447e+01 -3.44884934e+01 -3.17580589e+01 -2.59814393e+01\n -1.78184255e+01 -8.14633251e+00  2.03381596e+00  1.17007613e+01\n  1.99154591e+01  2.59122266e+01  2.91697473e+01  2.94553896e+01\n  2.68391837e+01  2.16769872e+01  1.45655029e+01  6.27458308e+00\n -2.33560966e+00 -1.04037163e+01 -1.71533510e+01 -2.19677060e+01\n -2.44454330e+01 -2.44327920e+01 -2.20296487e+01 -1.75696560e+01\n -1.15775811e+01 -4.70897483e+00  2.32100171e+00  8.81191526e+00\n  1.41478477e+01  1.78556800e+01  1.96463736e+01  1.94357232e+01\n  1.73433176e+01  1.36707567e+01  8.86228186e+00  3.45267493e+00\n -1.99159756e+00 -6.93157447e+00 -1.09091510e+01 -1.35893098e+01\n -1.47873668e+01 -1.44791297e+01 -1.27937834e+01 -9.99116299e+00\n -6.42666652e+00 -2.50822289e+00  1.34963425e+00  4.76948221e+00\n  7.44791758e+00  9.18204933e+00  9.88331103e+00  9.57785701e+00\n  8.39434617e+00  6.54129270e+00  4.27722402e+00  1.87752669e+00\n -3.97976240e-01 -2.33298717e+00 -3.77524157e+00 -4.64762251e+00\n -4.94918053e+00 -4.74662427e+00 -4.15799070e+00 -3.33109112e+00\n -2.41986054e+00 -1.56185995e+00 -8.59889695e-01 -3.70014208e-01\n -9.73648712e-02 -3.82130761e-16  0.00000000e+00]\n```\n\n\nAttempt 2: Fourier\n\nSince I am not sure where to go from the last attempt, I sought a new attempt. To my understanding, Fourier analysis basically shifts a signal from/to the time-domain (```\nx(t) vs t```\n) to/from the frequency domain (```\nx(t) vs f=1/t```\n); the signal in frequency-space should appear as a sinusoidal wave that dampens over time. The period is obtained from the most observed frequency since this is the location of the peak of the distribution of frequencies. \n\nSince my values are all real-valued, applying the Fourier transform should mean my output values are all complex-valued. I wouldn't think this is a problem, except for the fact that scipy has methods for real-values. I do not fully understand the differences between all of the different scipy methods. That makes following the algorithm proposed in this posted solution hard for me to follow (ie, how/why is the threshold value picked?). \n\n```\nomega = np.fft.fft(x)\nfreq = np.fft.fftfreq(x.size, 1)\nthreshold = 0\nidx = np.where(abs(omega)>threshold)[0][-1]\nmax_f = abs(freq[idx])\nprint(max_f)\n```\n\n\nThis outputs ```\n0.01```\n, meaning the period is ```\n1/0.01 = 100```\n. This doesn't make sense either.\n\nAttempt 3: Power Spectral Density\n\nAccording to the scipy docs, I should be able to estimate the power spectral density (psd) of the signal using a periodogram (which, according to wikipedia, is the fourier transform of the autocorrelation function). By selecting the dominant frequency ```\nfmax```\n at which the signal peaks, the period of the signal can be obtained as ```\n1 / fmax```\n.\n\n```\nfreq, pdensity = signal.periodogram(x)\n\nfig, ax = plt.subplots()\nax.plot(freq, pdensity, color='r')\nax.grid(color='k', alpha=0.3, linestyle=':')\nplt.show()\nplt.close(fig)\n```\n\n\nThe periodogram shown below peaks at ```\n49.076...```\n at a frequency of ```\nfmax = 0.05```\n. So, ```\nperiod = 1/fmax = 20```\n. This doesn't make sense to me. I have a feeling it has something to do with the sampling rate, but don't know enough to confirm or progress further.\n\nI realize I am missing some fundamental gaps in understanding how these things work. There are a lot of resources online, but it's hard to find this needle in the haystack. Can someone help me learn more about this?\n\n\n    ", "Answer": "\r\nLet's first look at your signal (I've added ```\nendpoint=False```\n to make the division even):\n\n```\nt = np.linspace(0, 10*np.pi, 100, endpoint=False)\nx = np.sin(t)\n```\n\n\nLet's divide out the radians (essentially by taking ```\nt /= 2*np.pi```\n) and create the same signal by relating to frequencies:\n\n```\nfs = 20 # Sampling rate of 100/5 = 20 (e.g. Hz)\nf = 1 # Signal frequency of 1 (e.g. Hz)\nt = np.linspace(0, 5, 5*fs, endpoint=False)\nx = np.sin(2*np.pi*f*t)\n```\n\n\nThis makes it more salient that ```\nf/fs == 1/20 == 0.05```\n (i.e. the periodicity of the signal is exactly 20 samples). Frequencies in a digital signal always relate to its sampling rate, as you have already guessed. Note that the actual signal is exactly the same no matter what the values of ```\nf```\n and ```\nfs```\n are, as long as their ratio is the same:\n\n```\nfs = 1 # Natural units\nf = 0.05\nt = np.linspace(0, 100, 100*fs, endpoint=False)\nx = np.sin(2*np.pi*f*t)\n```\n\n\nIn the following I'll use these natural units (```\nfs = 1```\n). The only difference will be in ```\nt```\n and hence the generated frequency axes.\n\nAutocorrelation\n\nYour understanding of what the autocorrelation function does is correct. It detects the correlation of a signal with a time-lagged version of itself. It does this by sliding the signal over itself as seen in the right column here (from Wikipedia):\n\n\n\nNote that as both inputs to the correlation function are the same, the resulting signal is necessarily symmetric. That is why the output of ```\nnp.correlate```\n is usually sliced from the middle:\n\n```\nacf = np.correlate(x, x, 'full')[-len(x):]\n```\n\n\nNow index 0 corresponds to 0 delay between the two copies of the signal.\n\nNext you'll want to find the index or delay that presents the largest correlation. Due to the shrinking overlap this will by default also be index 0, so the following won't work:\n\n```\nacf.argmax() # Always returns 0\n```\n\n\nInstead I recommend to find the largest peak instead, where a peak is defined to be any index with a larger value than both its direct neighbours:\n\n```\ninflection = np.diff(np.sign(np.diff(acf))) # Find the second-order differences\npeaks = (inflection < 0).nonzero()[0] + 1 # Find where they are negative\ndelay = peaks[acf[peaks].argmax()] # Of those, find the index with the maximum value\n```\n\n\nNow ```\ndelay == 20```\n, which tells you that the signal has a frequency of ```\n1/20```\n of its sampling rate:\n\n```\nsignal_freq = fs/delay # Gives 0.05\n```\n\n\nFourier transform\n\nYou used the following to calculate the FFT:\n\n```\nomega = np.fft.fft(x)\nfreq = np.fft.fftfreq(x.size, 1)\n```\n\n\nThhese functions re designed for complex-valued signals. They will work for real-valued signals, but you'll get a symmetric output as the negative frequency components will be identical to the positive frequency components. NumPy provides separate functions for real-valued signals:\n\n```\nft = np.fft.rfft(x)\nfreqs = np.fft.rfftfreq(len(x), t[1]-t[0]) # Get frequency axis from the time axis\nmags = abs(ft) # We don't care about the phase information here\n```\n\n\nLet's have a look:\n\n```\nplt.plot(freqs, mags)\nplt.show()\n```\n\n\n\n\nNote two things: the peak is at frequency 0.05, and the maximum frequency on the axis is 0.5 (the Nyquist frequency, which is exactly half the sampling rate). If we had picked ```\nfs = 20```\n, this would be 10.\n\nNow let's find the maximum. The thresholding method you have tried can work, but the target frequency bin is selected blindly and so this method would suffer in the presence of other signals. We could just select the maximum value:\n\n```\nsignal_freq = freqs[mags.argmax()] # Gives 0.05\n```\n\n\nHowever, this would fail if, e.g., we have a large DC offset (and hence a large component in index 0). In that case we could just select the highest peak again, to make it more robust:\n\n```\ninflection = np.diff(np.sign(np.diff(mags)))\npeaks = (inflection < 0).nonzero()[0] + 1\npeak = peaks[mags[peaks].argmax()]\nsignal_freq = freqs[peak] # Gives 0.05\n```\n\n\nIf we had picked ```\nfs = 20```\n, this would have given ```\nsignal_freq == 1.0```\n due to the different time axis from which the frequency axis was generated.\n\nPeriodogram\n\nThe method here is essentially the same. The autocorrelation function of ```\nx```\n has the same time axis and period as ```\nx```\n, so we can use the FFT as above to find the signal frequency:\n\n```\npdg = np.fft.rfft(acf)\nfreqs = np.fft.rfftfreq(len(x), t[1]-t[0])\n\nplt.plot(freqs, abs(pdg))\nplt.show()\n```\n\n\n\n\nThis curve obviously has slightly different characteristics from the direct FFT on ```\nx```\n, but the main takeaways are the same: the frequency axis ranges from ```\n0```\n to ```\n0.5*fs```\n, and we find a peak at the same signal frequency as before: ```\nfreqs[abs(pdg).argmax()] == 0.05```\n.\n\nEdit:\n\nTo measure the actual periodicity of ```\nnp.sin```\n, we can just use the \"angle axis\" that we passed to ```\nnp.sin```\n instead of the time axis when generating the frequency axis:\n\n```\nfreqs = np.fft.rfftfreq(len(x), 2*np.pi*f*(t[1]-t[0]))\nrad_period = 1/freqs[mags.argmax()] # 6.283185307179586\n```\n\n\nThough that seems pointless, right? We pass in ```\n2*np.pi```\n and we get ```\n2*np.pi```\n. However, we can do the same with any regular time axis, without presupposing ```\npi```\n at any point:\n\n```\nfs = 10\nt = np.arange(1000)/fs\nx = np.sin(t)\nrad_period = 1/np.fft.rfftfreq(len(x), 1/fs)[abs(np.fft.rfft(x)).argmax()] # 6.25\n```\n\n\nNaturally, the true value now lies in between two bins. That's where interpolation comes in and the associated need to choose a suitable window function.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in R. What am I doing wrong?\r\n                \r\nI am a non-expert in Fourier analysis and quite don't get what R's function fft() does. Even after crossreading a lot I couldnt figure it out. \nI built an example.\n\n```\nrequire(ggplot2)\n\nfreq <- 200  #sample frequency in Hz \nduration <- 3 # length of signal in seconds\n\n#arbitrary sine wave \nx <- seq(-4*pi,4*pi, length.out = freq*duration)\ny <- sin(0.25*x) + sin(0.5*x) + sin(x)\n```\n\n\nwhich looks like:\n\n\n\n```\nfourier <- fft(y)\n\n#frequency \"amounts\" and associated frequencies\n\namo <- Mod(fft(y))\n\nfreqvec <- 1:length(amo) \n```\n\n\nI ASSUME that fft expects a vector recorded over a timespan of 1 second, so I divide by the timespan\n\n```\nfreqvec <- freqvec/duration \n\n#and put this into a data.frame\n\ndf <- data.frame(freq = freqvec, ammount = amo)\n```\n\n\nNow I ASSUMABLY can/have to omit the second half of the data.frame since the frequency \"amounts\" are only significant to half of the sampling rate due to Nyquist.\n\n```\ndf <- df[(1:as.integer(0.5*freq*duration)),]\n```\n\n\nFor plotting I discretize a bit\n\n```\ndf.disc <- data.frame(freq = 1:100)\ncum.amo <- numeric(100)\nfor (i in 1:100){\n  cum.amo[i] <- sum(df$ammount[c(3*i-2,3*i-1,3*i)])\n}\ndf.disc$ammount <- cum.amo\n```\n\n\nThe plot function for the first 20 frequencies: \n\n```\ndf.disc$freq <- as.factor(df.disc$freq)\n\nggplot(df.disc[1:20,], aes(x=freq, y=ammount)) + geom_bar(stat = \"identity\")\n```\n\n\nThe result:\n\n\n\nIs this really a correct spectrogram of the above function? Are my two assumptions correct? Where is my mistake? If there is no, what does this plot now tell me?\n\nEDIT:\nHere is a picture without discretization:\n\n\n\nTHANKS to all of you,\n\nMicha.\n    ", "Answer": "\r\nOkay, okay. Due to the generally inferior nature of my mistake the solution is quite trivial.\nI wrote freq = 200 and duration = 3. But the real duration is from -4pi to 4 pi, hence 8pi resulting in a \"real\" sample frequency of  1/ ((8*pi)/600) = 23.87324 which does not equal 200. \nReplacing the respective lines in the example code by \n\n```\nfreq <- 200  #sample frequency in Hz\nduration <- 6 # length of signal in seconds\nx <- seq(0,duration, length.out = freq*duration) \ny <- sin(4*pi*x) + sin(6*pi*x) + sin(8*pi*x)\n```\n\n\n(with a more illustrative function) yields the correct frequencies as demonstrated by the following plot (restricted to the important part of the frequency domain):\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Applying Fast Fourier transform with a specific product function\r\n                \r\nProblem: Given ```\n2N```\n degree polynomials as ```\na0+a1x+a2x2..+aNxN```\n and\n```\nb0+b1x+b2x2..+bNxN```\n. Assume no 2 coefficient are the same in the 2 polynomials.\n\nFind the product of the polynomials, the catch is that the product(*) operator between the coefficients is defined differently:\n\n```\nf(i,j) := ai * bj := 1/abs(ai-bj)```\n\n\nThat means, find the following polynomial:\n\n```\nc0+c1x+c2x2..+c2Nx2N```\n,\n\nwhere\n\n```\nck := Σi=0..N f(i,k-i)```\n\n\nI know that with FFT, 2 polynomials can be multiplied in ```\nO(n lg n)```\n time with normal product operator between the coefficients but don't have any idea for this kind of problem.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Forward and Backward Fast Fourier Transform, shuift by half period\r\n                \r\nI have a simple problem that i'm not managing to solve.\nI am simply taking the dft of a periodical sequence of numbers (using the fftw3 in fortran), and I noticed that, when taking the inverse transform, the output is the initial sequence, but shifted by exactly one half of the period. Can someone tell me what is the problem? I think I am missing something in the functioning of the fftw3\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform on motor vibration signal in python\r\n                \r\nI collected some data(178,432) of motor vibration signal, and the unit was g(Acceleration). The Sampling rate of signal is 25000/sec, motor speed is 1500rpm(25hz). But while I try to do the FFT using python, the picture isn't right. Can anyone help me with it? \n\nmy data : https://drive.google.com/file/d/12V8H3h6ved4lBflVxoHo2Qv5rfVZqXf0/view?usp=sharing\n\nHere is my code:\n\n```\nimport scipy.fftpack\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nnor = pd.read_csv('normal.csv', header=1)\n\nN = nor.size # data size\nT = 1.0 / 25000.0 # inverse of sampling rate\nx = np.linspace(0.0, N*T, N)\ny = nor.values\nyf = np.abs(scipy.fft(y))\nxf = scipy.fftpack.fftfreq(nor.size, d=T)\n\nfig, ax = plt.subplots()\nax.plot(np.abs(xf), np.abs(yf))\nplt.show()\n```\n\n\nmy FFT plot:\n\n\n    ", "Answer": "\r\nWhen you access the ```\nvalues```\n of a ```\nDataFrame```\n you get an array of arrays, or a 2D array:\n\n```\nIn [23]: pd.read_csv('../Downloads/normal.csv', header=1).values\nOut[23]: \narray([[ 0.006038 ],\n       [ 0.0040734],\n       [ 0.0031316],\n       ..., \n       [-0.0103366],\n       [-0.0025845],\n       [ 0.0012779]])\n```\n\n\nAnd so the result of ```\nscipy.fft(y)```\n is an array of ```\nnor.size```\n separate 1-dimensional 1-item DFFT result arrays, in other words the original signal:\n\n```\nIn [42]: scipy.fft(y)\nOut[42]: \narray([[ 0.0060380+0.j],\n       [ 0.0040734+0.j],\n       [ 0.0031316+0.j],\n       ..., \n       [-0.0103366+0.j],\n       [-0.0025845+0.j],\n       [ 0.0012779+0.j]])\n```\n\n\nYou then proceeded to plot the absolute value of the original signal, against the FFT freqs. Instead you'll want to perform a single DFFT against a vector:\n\n```\nIn [49]: yf = scipy.fft(nor['Channel_0  '].values)  # column/series values\n\nIn [50]: yf\nOut[50]: \narray([ 1.58282430+0.j        , -3.61766030-1.86904326j,\n       -0.50666930+4.24825582j, ...,  4.54241118-0.97200708j,\n       -0.50666930-4.24825582j, -3.61766030+1.86904326j])\n\nIn [51]: x = scipy.fftpack.fftfreq(yf.size, 1 / 25e3)\n\nIn [56]: plot(x[:x.size//2], abs(yf)[:yf.size//2])  # omit fold\nOut[56]: [<matplotlib.lines.Line2D at 0x7f2f39f01cf8>]\n```\n\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python fast Fourier transform for very noisy data\r\n                \r\nI have a file with velocity magnitude data and vorticity magnitude data from a fluid simulation. \n\nI want to find out what is the frequency for these two data sets. \n\nmy code:\n\n```\n# -*- coding: utf-8 -*-\n\"\"\"\nSpyder Editor\n\nThis is a temporary script file.\n\"\"\"\nimport re\nimport math\nimport matplotlib.pyplot as plt\n\nimport numpy as np\n\n\nprobeU1 = []\nprobeV1 = []\n# this creates an array containig all the timesteps, cutting of the first 180, because the system has to stabelize.\nnumber = [ round(x * 0.1, 1) for x in range(180, 301)] \n\n# this function loops over the different time directories, and reads the velocity file.\nfor i in range(len(number)):\n    filenamepath = \"/Refinement/Vorticity4/probes/\" +str(number[i]) + \"/U\"\n    data= open(filenamepath,\"r\")\n    temparray = []\n    #removes all the formatting around the data\n    for line in data:\n        if line.startswith('#'):\n            continue\n    else:\n        line = re.sub('[()]', \"\", line)\n        values = line.split()\n        #print values[1], values[2]\n        xco = values[1::3]\n        yco = values[2::3]        \n        #here it extracts all the velocity data from all the different probes\n        for i in range(len(xco)):\n\n            floatx = float(xco[i])\n            floaty = float(yco[i])\n            temp1 = math.pow(floatx,2)\n            temp2 = math.pow(floaty,2)\n            #print temp2, temp1\n            temp3 = temp1+temp2\n            temp4 = math.sqrt(temp3)\n            #takes the magnitude of the velocity\n            #print temp4\n            temparray.append(temp4)\n        probeU1.append(temparray)\n\n#        \n#print probeU1[0]  \n#print len(probeU1[0])     \n#        \n\n# this function loops over the different time directories, and reads the vorticity file.\nfor i in range(len(number)):\n    filenamepath = \"/Refinement/Vorticity4/probes/\" +str(number[i]) + \"/vorticity\"\n    data= open(filenamepath,\"r\")\n#    print data.read()\n    temparray1 = []\n\n    for line in data:\n        if line.startswith('#'):\n            continue\n    else:\n        line = re.sub('[()]', \"\", line)\n        values = line.split()\n        zco = values[3::3]\n        #because the 2 dimensionallity the z-component of the vorticity is already the magnitude\n        for i in range(len(zco)):  \n            abso = float(zco[i])\n            add = np.abs(abso)\n\n            temparray1.append(add)\n\n    probeV1.append(temparray1)\n\n#Old code block to display the data and check that it made a wave pattern(which it did) \n##Printing all probe data from 180-300 in one graph(unintelligible)\n#for i in range(len(probeU1[1])):\n#    B=[]\n#    for l in probeU1:\n#      B.append(l[i])\n##    print 'B=', B\n##    print i\n#    plt.plot(number,B)\n#\n#\n#plt.ylabel('magnitude of velocity')\n#plt.show()  \n#\n##Printing all probe data from 180-300 in one graph(unintelligible)\n#for i in range(len(probeV1[1])):\n#    R=[]\n#    for l in probeV1:\n#      R.append(l[i])\n##    print 'R=', R\n##    print i\n#    plt.plot(number,R)\n#\n#\n#plt.ylabel('magnitude of vorticity')\n#plt.show()  \n\n#Here is where the magic happens, (i hope)\nans=[]\nfor i in range(len(probeU1[1])):\n    b=[]\n   #probeU1 is a nested list, because there are 117 different probes, wich all have the data from timestep 180-301\n    for l in probeU1:\n      b.append(l[i])\n      #the freqeuncy was not oscillating around 0, so moved it there by substracting the mean\n      B=b-np.mean(b)\n      #here the fft happens\n      u    = np.fft.fft(B)\n      #This should calculate the frequencies?\n      freq = np.fft.fftfreq(len(B), d= (number[1] - number[0]))\n      # If im not mistakes this finds the peak frequency for 1 probe and passes it another list\n      val = np.argmax(np.abs(u))\n      ans.append(np.abs(freq[val]))    \n\n      plt.plot(freq, np.abs(u))\n\n#print np.mean(ans)\nplt.xlabel('frequency?')\nplt.savefig('velocitiy frequency')\nplt.show()\n\n# just duplicate to the one above it\nans1=[]\nfor i in range(len(probeV1[1])):\n    c=[]\n\n    for l in probeU1:\n      c.append(l[i])\n      C=c-np.mean(c)\n      y    = np.fft.fft(C)\n      freq1 = np.fft.fftfreq(len(C), d= (number[1] - number[0]))\n      val = np.argmax(np.abs(y))\n      ans1.append(np.abs(freq1[val]))    \n\n      plt.plot(freq1, np.abs(y))\n\n#print np.mean(ans1)\nplt.ylabel('frequency?')\nplt.savefig('vorticity frequency')\nplt.show()     \n\n\n\ndata.close()\n```\n\n\nMy data contains 117 probes each having their own 121 point of velocity magnitude data. \n\nMy aim is to find the dominate frequency for each probe and then collect all those and plot them in a histogram. \n\nMy question is about the part where it says this is where the magic happens. I believe the fft is already working correctly\n\n```\n  y    = np.fft.fft(C)\n          freq1 = np.fft.fftfreq(len(C), d= (number[1] - number[0]))\n```\n\n\nAnd if I'm not mistaken the freq1 list should contain all the frequencies for a given probe. I've checked this list visually and the amount of different frequencies is very high(20+) so the signal is probably very noisy.\n\n```\n# If im not mistakes this finds the peak frequency for 1 probe and passes it another list\n      val = np.argmax(np.abs(u))\n      ans.append(np.abs(freq1[val]))    \n```\n\n\nThat this part should in theory take the biggest signal from one probe and than put in the \"ans\" list. But I'm a bit confused as to how i can no correctly identify the right frequency. As there should i theory be one main frequency. How can I correctly estimate the \"main\" frequency from all this data from all the noise\n\nFor reference I'm modeling an Von Karmann vortex street and I'm looking for the frequency of vortex shedding. https://en.wikipedia.org/wiki/K%C3%A1rm%C3%A1n_vortex_street\n\nCan anyone help me on how to solve this?\n    ", "Answer": "\r\nThe line\n\n```\nfreq1 = np.fft.fftfreq(len(C), d= (number[1] - number[0]))\n```\n\n\nOnly generates an index going from \n\n```\nfreq1 = [0, 1, ...,   len(C)/2-1,     -len(C)/2, ..., -1] / (d*len(C))\n```\n\n\nWhich is useful to compute your frequencies array as\n\n```\nfreq[i] = freq1[i]*alpha\n```\n\n\nWhere ```\nalpha```\n is your basic wavenumber computed as\n\n```\nalpha = 1/Ts\n```\n\n\nBeing ```\nTs```\n your sampling period. I think that because ```\nfreq1```\n is not scaled you array of frequencies is so high.\n\nNote that if you are sampling your data using different time steps you will need to interpolate it at in a evenly space domain using ```\nnumpy.interp```\n (for example).\n\nTo estimate the main frequency just find the index where the fft-transformed variable is higher and relate that index to ```\nfreq[i]```\n.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Bi-dimensional Fast Fourier Transformation Problem\r\n                \r\nI am new to image processing and in need of some help here. I refer to Fig.10 of the paper by Z. Yang, M. Krishnamurthy and I. P. Brown, \"Electromagnetic and vibrational characteristic of IPM over full torque-speed range\" \n\nAccording to the authors, a 2d-FFT was performed to change the figure on the left to that on the right. However, it did not work out for me. Applied fft2(Matlab) to  and got this .\n\nPlease tell me what am I missing.\n\nThank you in advance.\n\nTony\n    ", "Answer": "\r\nIt looks like the authors used artistic license to cut off the coefficients below some chosen intensity threshold close to zero, and not color them at all. This helps presentation if the order of magnitude of the coefficients is close to the numeric noise floor, i.e. in a clean data set.\n\nExclude the DC value in your upper left from the dynamic range (color bar range) calculations. It tends to be the largest value and not central to the purpose of the plot.\n\nTo account for the different position of your spectral peaks, consider the differences in your data set which has a higher base frequency along both axis (assuming the units are the same.)\n\nAnother difference are the axis meanings. The paper plots frequencies as harmonics to some base frequency.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Bi-dimensional Fast Fourier Transformation Problem\r\n                \r\nI am new to image processing and in need of some help here. I refer to Fig.10 of the paper by Z. Yang, M. Krishnamurthy and I. P. Brown, \"Electromagnetic and vibrational characteristic of IPM over full torque-speed range\" \n\nAccording to the authors, a 2d-FFT was performed to change the figure on the left to that on the right. However, it did not work out for me. Applied fft2(Matlab) to  and got this .\n\nPlease tell me what am I missing.\n\nThank you in advance.\n\nTony\n    ", "Answer": "\r\nIt looks like the authors used artistic license to cut off the coefficients below some chosen intensity threshold close to zero, and not color them at all. This helps presentation if the order of magnitude of the coefficients is close to the numeric noise floor, i.e. in a clean data set.\n\nExclude the DC value in your upper left from the dynamic range (color bar range) calculations. It tends to be the largest value and not central to the purpose of the plot.\n\nTo account for the different position of your spectral peaks, consider the differences in your data set which has a higher base frequency along both axis (assuming the units are the same.)\n\nAnother difference are the axis meanings. The paper plots frequencies as harmonics to some base frequency.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Car vibration evaluated by Fast Fourier Transform in Octave\r\n                \r\nI must evaluate vibration of a car. For this trial I used accelerometer. Collected data are depended on the time.\n\nI need to convert the data from time domain to frequency domain by FFT. Unfortunately, I am not familiar with coding and FTT very well, however I found and used the code below.\n\nWhat is strange for me, that maximum high point has 0Hz. Please, see attached image.\nAnyway, is there a way how to do a graph more obvious? For example, cut a series in x-axis and shows only data under 200Hz.\n\n\n\n```\nclc\nA=xlsread('50_dirt_road.xlsx');\nt=A(:,9);\ns=A(:,8);\nTs = mean(diff(t));                                     % Sampling Interval\nFs = 1/Ts;                                              % Sampling Frequency\nFn = Fs/2;                                              % Nyquist Frequency\nL = numel(t);                                           % Signal Length\nsm = s - mean(s);                                       % Mean-Corrected Signal (Eliminates 0 Hz Offset)\nFTs = fft(sm)/L;                                        % Fourier Transform\nFv = linspace(0, 1, fix(L/2)+1)*Fn;                     % Frequency Vector\nIv = 1:numel(Fv);                                       % Index Vector\n[MaxV,idx] = max(abs(FTs(Iv))*2);                       % Maximum V & Index\nFreq = Fv(idx);                                         % Frequency Of Maximum V\nfigure\nplot(Fv, abs(FTs(Iv))*2)\ngrid\ntext(Freq, MaxV, sprintf('\\\\leftarrow %.4f G, %.0f Hz', MaxV, Freq), 'HorizontalAlignment','left')\nxlabel('Frequency (Hz)')\nylabel('Amplitude')\n```\n\n\nCould you double check it, please? My variables are defined as follows:\n\n\n```\ns```\n: measured \"G\" value. In total 3395 measured values.\n```\nt```\n: time. Every single value was recorded after 0.001s, in total 3.395s.\n\n    ", "Answer": "\r\nThe maximum high point you are referring to is normal.  Without having frequency cut offs, the beginning, (nearest zero), of your fourier transform will always have the most spectral energy because it is resolving sampling rates tending towards zero which as you can imagine would have a ton of representation in the time series.  Obviously 0 hz is impossible, so you should choose a lower bound frequency that makes sense in the domain of car vibrations.  So I recommend a band pass filter, one that does forward and backward filtering (filt filt) to preserve the original time series and then running the result through this analysis.  I would start with a butterworth filter and experiment with othes if desired:\n\nhttps://octave.sourceforge.io/signal/function/butter.html\n\nEDIT:\n\nI was using t but the signal is in s.  Here is the whole thing:\n\n```\nclc\nA=xlsread('50_dirt_road.xlsx');\nt=A(:,9);\ns=A(:,8);\nTs = mean(diff(t));                                     % Sampling Interval\nFs = 1/Ts;                                              % Sampling Frequency\nFn = Fs/2;                                              % Nyquist Frequency\nL = numel(t);                                           % Signal Length\n\n%1st order butterworth filter with a band pass of 1hz to 200hz in radians\n%forward and reverse filtered\n[b,a] = butter(1, [1/(L/2), 200/(L/2)]);\nfiltered_s = filtfilt(b,a,s);\n\nsm = filtered_s - mean(filtered_s);                     % Mean-Corrected Signal (Eliminates 0 Hz Offset)\nFTs = fft(sm)/L;                                        % Fourier Transform\nFv = linspace(0, 1, fix(L/2)+1)*Fn;                     % Frequency Vector\nIv = 1:numel(Fv);                                       % Index Vector\n[MaxV,idx] = max(abs(FTs(Iv))*2);                       % Maximum V & Index\nFreq = Fv(idx);                                         % Frequency Of Maximum V\nfigure\nplot(Fv, abs(FTs(Iv))*2)\ngrid\ntext(Freq, MaxV, sprintf('\\\\leftarrow %.4f G, %.0f Hz', MaxV, Freq), 'HorizontalAlignment','left')\nxlabel('Frequency (Hz)')\nylabel('Amplitude')\n```\n\n\nLAST EDIT:\n\nOkay, so I think I got you an intro in to the world of filtering when I think all you were looking to do is constrain the axis of your FFT.  Same arguments for the band pass filter above, 1hz and 200hz.  The above code should work but the following code is probably what you were looking for originally:\n\n```\nclc\nA=xlsread('50_dirt_road.xlsx');\nt=A(:,9);\ns=A(:,8);\nTs = mean(diff(t));                                     % Sampling Interval\nFs = 1/Ts;                                              % Sampling Frequency\nFn = Fs/2;                                              % Nyquist Frequency\nL = numel(t);                                           % Signal Length\n\nsm = s - mean(s);                     % Mean-Corrected Signal (Eliminates 0 Hz Offset)\nFTs = fft(sm)/L;                                        % Fourier Transform\nFv = linspace(0, 1, fix(L/2)+1)*Fn;                     % Frequency Vector\nfreqMask = (Fv > 1) & (Fv < 200);\nFv = Fv(freqMask);\nFTs = FTs(freqMask);\nIv = 1:numel(Fv);                                       % Index Vector\n[MaxV,idx] = max(abs(FTs(Iv))*2);                       % Maximum V & Index\nFreq = Fv(idx);                                         % Frequency Of Maximum V\nfigure\nplot(Fv, abs(FTs(Iv))*2)\ngrid\ntext(Freq, MaxV, sprintf('\\\\leftarrow %.4f G, %.0f Hz', MaxV, Freq), 'HorizontalAlignment','left')\nxlabel('Frequency (Hz)')\nylabel('Amplitude')\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Casting complex values discards imaginary part on fast fourier algorithm\r\n                \r\nI was making the fast fourier transformation algorithm, based on cooley-tukey method. The code looks fine to me, but I keep getting numpy error like: \n\n```\nCasting complex values to real discards the imaginary part\n```\n\n\nI am not sure how to change the assignments in the iterrations. The algorithm is described here: \n\n```\ndef fast_fourier_transformation(data):\n    N = len(data)\n    if N > 1:\n        Wn = math.e ** (2 * math.pi * 1j / N)\n        W = 1\n        A_even = data[::2]\n        A_odd = data[1::2]\n        B_even = fast_fourier_transformation(A_even)\n        B_odd = fast_fourier_transformation(A_odd)\n        for k in range(0, N // 2):\n            data[k] = B_even[k] + W * B_odd[k]\n            data[k + N // 2] = B_even[k] - W * B_odd[k]\n            W = W * Wn\n    return data\n```\n\n    ", "Answer": "\r\nYour data variable needs to be declared as complex (set the imaginary component to zero for strictly real input), since the output of your function needs to be complex, and you are using \"data\" for both the input parameter and the return value (output).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Help with FFT(Fast Fourier Transforms) and/or DSP\r\n                \r\nIm trying to do a screen-flashing application, that flashes the screen according to the music(which will be frequencies, such as healing frequencies, etc...).\nI already made the player and know how will I make the screen flash, but I need to make the screen flash super fast according to the music, for example if the music speeds up, the screen-flash will flash faster. I understand that I would achieve this by FFT or DSP(as I only need to know when the frequency raises from some Hz, lets say 20 to change the color, making the screen-flash). \n\nBut I've found that I understand NOTHING, even less try to implement it to my application. \n\nCan somebody help me out to learn whichever both of them? My email is sismetic_chaos@hotmail.com. I really need help, I've been stucked for like 3 days not coding or doing anything at all, trying to understand, but I dont.\n\nPS:My application is written in C++ and Qt.\n\nPS:Thanks for taking the time to read this and the willingness to help.\n\nEdit: Thanks to all for the answers, the problem is in no way solved yet, but I appreciate all the answers, I didnt thought I would get so many answers and info. Thanks to you all.\n    ", "Answer": "\r\nThis is a difficult problem, requiring more than an FFT. I'll briefly describe how I implemented beat detection when I was writing software for professional DJ equipment.\n\nFirst of all, you'll need to cut down the amount of data you're dealing with, since there are only two or three beats per second, but tens of thousands of samples. You'll also need to look at different frequency ranges, since some types of music carry the tempo in the bassline, and others in percussion or other instruments. So pass the signal through several band-pass filters (I chose 8 filters, each covering one octave, from low bass to high treble), and then downsample each band by averaging the power over a few hundred samples.\n\nEvery few seconds, you'll have a thousand or so samples in each band. Your next tool is an autocorrelation, to identify repetitive patterns in the music. The peaks of the autocorrelation tell you what the beat is more or less likely to be; but you'll need to make up some heuristics to compare all the frequency bands to find a beat that you can be confident in, and to avoid misleading syncopations. If you can manage that, then you'll have a reasonable guess at the tempo, but no idea of the phase (i.e. exactly when to flash the screen).\n\nNow you can look at the a smoothed version of the audio data for peaks, some of which are likely to correspond to beats. Initially, look for the strongest peak over the course of a few seconds and take that as a downbeat. In conjunction with the tempo you estimated in the first stage, you can predict when the next beat is due, and measure where you actually saw something like a beat, and adjust your estimate to more closely match the data. You can also maintain a confidence level based on how well the predicted beats match the measured peaks; if that drops too low, then restart the beat detection from scratch.\n\nThere are a lot of fiddly details to this, and it took me some weeks to get it working nicely. It is a difficult problem.\n\nOr for a simple visualisation effect, you could simply detect peaks and flash the screen for each one; it will probably look good enough.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Understanding the output from the fast Fourier transform method\r\n                \r\nI'm trying to make sense of the output produced by the python FFT library. \n\nI have a sqlite database where I have logged several series of ADC values. Each series consist of 1024 samples taken with a frequency of 1 ms.\n\nAfter importing a dataseries, I normalize it and run int through the ```\nfft```\n method. I've included a few plots of the original signal compared to the FFT output.\n\n```\nimport sqlite3\nimport struct\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport math\n\nconn = sqlite3.connect(r\"C:\\my_test_data.sqlite\")\nc = conn.cursor()\n\nc.execute('SELECT ID, time, data_blob FROM log_tbl')\n\n\nfor row in c:\n    data_raw = bytes(row[2])\n    data_raw_floats = struct.unpack('f'*1024, data_raw)\n    data_np = np.asarray(data_raw_floats)\n\n    data_normalized = (data_np - data_np.mean()) / (data_np.max() - data_np.min())\n\n    fft = np.fft.fft(data_normalized)\n    N = data_normalized .size\n\n    plt.figure(1)\n    plt.subplot(211)\n    plt.plot(data_normalized )\n\n    plt.subplot(212)\n    plt.plot(np.abs(fft)[:N // 2] * 1 / N)\n    plt.show()\n\n    plt.clf()\n```\n\n\n\n\n\n\n\n\nThe signal clearly contains some frequencies, and I was expecting them to be visible from the FFT output.\n\nWhat am I doing wrong?\n    ", "Answer": "\r\nYou need to make sure that your data is evenly spaced when using ```\nnp.fft.fft```\n, otherwise the output will not be accurate. If they are not evenly spaced, you can use LS periodograms for example: http://docs.astropy.org/en/stable/stats/lombscargle.html.\nOr look up non-uniform fft.\n\nAbout the plots:\nI don't think that you are doing something obviously wrong. Your signal consists a signal with period in the order of magnitude ```\n100```\n, so you can expect a strong frequency signal around ```\n1/period=0.01```\n. This is what is visible on your graphs. The time-domain signals are not that sinusoidal, so your peak in the frequency domain will be blurry, as seen on your graphs.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Any Open Source Fast Fourier Transform C implementation? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking us to recommend or find a book, tool, software library, tutorial or other off-site resource are off-topic for Stack Overflow as they tend to attract opinionated answers and spam. Instead, describe the problem and what has been done so far to solve it.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm trying to find the fundamental frequency of a recorded sound using FFT in C. Would anyone know a open source implementation in C that I can modify and use?\n\nThanks!\n    ", "Answer": "\r\nFFTW is probably what you are looking for.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python discrete fourier transformation\r\n                \r\nI write my own version of 2d DFT with NumPy, however, it is extremely slow and gives a different result from np.fft.fft2. Is the np fft.fft2 basing on the fast Fourier transformation? Is there anything wrong with my code?\n```\ndef gray_DFT(spatial_img, centerlize = False):\n    M,N = spatial_img.shape\n    frequency_img = np.zeros(spatial_img.shape)\n    for u in range(0,M):\n        for v in range(0,N):\n            print(u,v)\n            mesh_x, mesh_y = np.meshgrid(np.arange(M),np.arange(N), indexing = 'ij')\n            matrix = u * mesh_x / M + v * mesh_y / N\n            complex_matrix = -2j*np.pi*matrix\n            exp_matrix = np.exp(complex_matrix)\n            if centerlize:\n                transform_matrix = np.power((-np.ones((M,N))), mesh_x + mesh_y)\n                frequency_img[u,v] = np.sum(spatial_img*transform_matrix*exp_matrix)\n            else:    \n                frequency_img[u,v] = np.sum(spatial_img*exp_matrix)\n    return frequency_img\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Doubling input array when using numpy for fast fourier transforms\r\n                \r\nI wrote a function that returns the real component of the fast four transform of a grid. \n\n```\ndef take_FFT(x):\n    # some arbitrary field for a 1D grid\n    y = abs(1.0/x)\n    # compute FFT (in general multi-dimensional) array of real numbers\n    y_k = np.fft.rfftn(y)\n\n    #compute the inverse FFT\n    y_invk = np.fft.irfftn(y_k)\n    return y,y_k, y_invk # return fourier transform and inv transform\n\n# initialize sample x\nx_test = np.arange(-5,5,0.001)\n\nfield,FFT_test, inv_test = take_FFT(x_test)\n```\n\n\nHow do I make an appropriate new \"x array\" to plot against the FFT? It is not clear to me how to make an array of length = (n/2)+1, like the one that np.fft.irfftn returns \n    ", "Answer": "\r\nWelcome to StackOverflow, @Messier!\n\nIf I understand your question correctly, you want to ```\nslice```\n a ```\nnumpy.array```\n.\n\nSuppose we have a ```\nnumpy.array```\n ```\narr```\n that has length ```\nN```\n. Then to slice up to length ```\nM```\n (such that ```\nM<=N```\n) or up to ```\n(N/2)+1```\n:\n\n```\nsliced_arr = arr[:M]\nslice_half = arr[:N//2+1]\n```\n\n\nwhere in ```\npython```\n versions ```\n3```\n or greater, ```\nN//2```\n does integer division.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Does R have inverse fast fourier transform function?\r\n                \r\nI believe R has ifft function, but whenever I enter ```\n?ifft```\n it returns this message:\n```\nNo documentation for ‘ifft’ in specified packages and libraries:\nyou could try ‘??ifft’\n```\n\nWhat is the package for ifft?\n    ", "Answer": "\r\nTry ```\nsignal```\n library. For further information you may use this resource: https://www.rdocumentation.org/packages/signal/versions/0.7-6/topics/ifft\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Frequency resolution(or increment) of FFT(Fast fourier transform)\r\n                \r\nI tried to use ```\nfft```\n function in Matlab. I could understand why 'dt(sampling time interval) = 1/fs(sampling frequency). But I couldn't understand why 'df(frequency resolution(increment) = fs/N(length of data or Tmax)'. Why is df variable decided by using fs/N?\n    ", "Answer": "\r\nA discrete signal of length N can be decomposed into (shifted) sine waves with periods of N, N/2, N/3, N/4, etc., plus a constant (DC) term. This is the decomposition that the DFT computes. Each bin in the DFT thus represents a frequency corresponding to a wavelength (period) that is an integer fraction of the signal length.\nConsequently, the smallest frequency in the decomposition is 1/N (corresponding to 1/(dt N) Hz if dt is in seconds).\nThe next frequency component is 2/N, then 3/N, etc.\nThe largest frequency component is 1 (corresponding to 1/dt), though that frequency is aliased.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Scipy Fourier Transform KeyError: 'ALIGNED'?\r\n                \r\nI'm trying to run a fast fourier transform on a pandas dataframe that I have. I am using the Kepler exoplanet dataset, here, and a specific notebook for it, here. I recreate the code in cells 27-30 (Note that the code in cell 29 is executed elsewhere, thus both dataframes have the same shape as the original notebook), which looks as follows:\n```\nimport scipy\n\ndef spectrum_getter(X):\n    Spectrum = scipy.fft.fft(X, n=X.size)\n    return np.abs(Spectrum)\n\nx_train_OS_FT = x_train_OS.apply(spectrum_getter, axis=1)\nx_test_FT = x_test.apply(spectrum_getter, axis=1)\n```\n\nBoth x_train_OS and x_test are ```\npandas.core.frame.DataFrame```\n. Running this produces:\n```\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nInput In [245], in <module>\n----> 1 x_train_OS_FT = x_train_OS.apply(spectrum_getter, axis=1)\n      2 x_test_FT = x_test.apply(spectrum_getter, axis=1)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\frame.py:8827, in DataFrame.apply(self, func, axis, raw, result_type, args, **kwargs)\n   8816 from pandas.core.apply import frame_apply\n   8818 op = frame_apply(\n   8819     self,\n   8820     func=func,\n   (...)\n   8825     kwargs=kwargs,\n   8826 )\n-> 8827 return op.apply().__finalize__(self, method=\"apply\")\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\apply.py:727, in FrameApply.apply(self)\n    724 elif self.raw:\n    725     return self.apply_raw()\n--> 727 return self.apply_standard()\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\apply.py:851, in FrameApply.apply_standard(self)\n    850 def apply_standard(self):\n--> 851     results, res_index = self.apply_series_generator()\n    853     # wrap results\n    854     return self.wrap_results(results, res_index)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\apply.py:867, in FrameApply.apply_series_generator(self)\n    864 with option_context(\"mode.chained_assignment\", None):\n    865     for i, v in enumerate(series_gen):\n    866         # ignore SettingWithCopy here in case the user mutates\n--> 867         results[i] = self.f(v)\n    868         if isinstance(results[i], ABCSeries):\n    869             # If we have a view on v, we need to make a copy because\n    870             #  series_generator will swap out the underlying data\n    871             results[i] = results[i].copy(deep=False)\n\nInput In [244], in spectrum_getter(X)\n      3 def spectrum_getter(X):\n----> 4     Spectrum = scipy.fft.fft(X, n=X.size)\n      5     return np.abs(Spectrum)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\scipy\\fft\\_backend.py:22, in _ScipyBackend.__ua_function__(method, args, kwargs)\n     20 if fn is None:\n     21     return NotImplemented\n---> 22 return fn(*args, **kwargs)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\scipy\\fft\\_pocketfft\\basic.py:17, in c2c(forward, x, n, axis, norm, overwrite_x, workers, plan)\n     14 if plan is not None:\n     15     raise NotImplementedError('Passing a precomputed plan is not yet '\n     16                               'supported by scipy.fft functions')\n---> 17 tmp = _asfarray(x)\n     18 overwrite_x = overwrite_x or _datacopied(tmp, x)\n     19 norm = _normalization(norm, forward)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\scipy\\fft\\_pocketfft\\helper.py:97, in _asfarray(x)\n     95 dtype = x.dtype.newbyteorder('=')\n     96 # Always align input\n---> 97 copy = not x.flags['ALIGNED']\n     98 return np.array(x, dtype=dtype, copy=copy)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\flags.py:98, in Flags.__getitem__(self, key)\n     96 def __getitem__(self, key):\n     97     if key not in self._keys:\n---> 98         raise KeyError(key)\n    100     return getattr(self, key)\n\nKeyError: 'ALIGNED'\n```\n\nI attempted to convert the dataframe to a numpy array, but ran into other issues. What am I doing wrong here?\n    ", "Answer": "\r\nI ran to the same error so I converted my datatype to dataframe and it solved my problem.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why Fast Fourier Convolution does not work in set parameter : ratio_gin and ratio_gout:0.5?\r\n                \r\nI am studying about the Fourier Transform and Fast Fourier Convolution.\nI would like to use FFC but having trouble getting it to work.\nFast Fourier Convolution\nFast Fourier Convolution NeurIPS 2020\noriginal implementation https://github.com/pkumivision/FFC/blob/main/model_zoo/ffc.py\npaper https://proceedings.neurips.cc/paper/2020/file/2fd5d41ec6cfab47e32164d5624269b1-Paper.pdf\n\n\nThe above imgs refer to pages 3 and 4 of the paper\n##FFC code is\nreference:\nhttps://github.com/pkumivision/FFC/blob/main/model_zoo/ffc.py\n```\n\nclass FFC(nn.Module):\n\n    def __init__(self, in_channels, out_channels, kernel_size,\n                 ratio_gin, ratio_gout, stride=1, padding=0,\n                 dilation=1, groups=1, bias=False, enable_lfu=True):\n        super(FFC, self).__init__()\n\n        assert stride == 1 or stride == 2, \"Stride should be 1 or 2.\"\n        self.stride = stride\n\n        in_cg = int(in_channels * ratio_gin)\n        in_cl = in_channels - in_cg\n        out_cg = int(out_channels * ratio_gout)\n        out_cl = out_channels - out_cg\n        #groups_g = 1 if groups == 1 else int(groups * ratio_gout)\n        #groups_l = 1 if groups == 1 else groups - groups_g\n\n        self.ratio_gin = ratio_gin\n        self.ratio_gout = ratio_gout\n\n        module = nn.Identity if in_cl == 0 or out_cl == 0 else nn.Conv2d\n        self.convl2l = module(in_cl, out_cl, kernel_size,\n                              stride, padding, dilation, groups, bias)\n        module = nn.Identity if in_cl == 0 or out_cg == 0 else nn.Conv2d\n        self.convl2g = module(in_cl, out_cg, kernel_size,\n                              stride, padding, dilation, groups, bias)\n        module = nn.Identity if in_cg == 0 or out_cl == 0 else nn.Conv2d\n        self.convg2l = module(in_cg, out_cl, kernel_size,\n                              stride, padding, dilation, groups, bias)\n        module = nn.Identity if in_cg == 0 or out_cg == 0 else SpectralTransform\n        self.convg2g = module(\n            in_cg, out_cg, stride, 1 if groups == 1 else groups // 2, enable_lfu)\n\n    def forward(self, x):\n        x_l, x_g = x if type(x) is tuple else (x, 0)\n        out_xl, out_xg = 0, 0\n\n        if self.ratio_gout != 1:\n            out_xl = self.convl2l(x_l) + self.convg2l(x_g)\n        if self.ratio_gout != 0:\n            out_xg = self.convl2g(x_l) + self.convg2g(x_g)\n\n        return out_xl, out_xg\n```\n\nBelow is my test code using this above .py file.\nIf ratio_gout is set to 0.5 each as 　α parameter in the paper, it will result in ERROR.\n```\n\n#1.gray schale:\n\nffc_m=FFC(in_channels=1,out_channels=10,kernel_size=1,\n         ratio_gin=0.5,ratio_gout=0.5,padding=\"same\",groups=1)\n\n#gray schale sample\ngray_img=torch.randn(1,1,32,32).float()\n\nout1,out2=ffc_m(temp_img)\nprint(out1.shape)\nprint(out2.shape)\n\n#>>>torch.Size([1, 5, 32, 32])\n#>>>torch.Size([1, 5, 32, 32])\n\n2.like RGB schale :\nffc_m=FFC(in_channels=3,out_channels=10,kernel_size=1,\n         ratio_gin=0.5,ratio_gout=0.5,padding=\"same\",groups=1)\n\n#3channels\ntemp_img=torch.randn(1,3,32,32).float()\n\nout=ffc_m(temp_img)\n#>>>output error is below\n#RuntimeError: Given groups=1, weight of size [5, 2, 1, 1], expected input[1, 3, 32, 32] to have 2 channels, but got 3 channels instead\n\n#but works for the following parameters: ratio_gin=0. ratio_gout=1\nffc_m=FFC(in_channels=3,out_channels=10,kernel_size=1,\n         ratio_gin=0,ratio_gout=1.,padding=\"same\",groups=1)\n\ntemp_img=torch.randn(1,3,32,32).float()\nout1,out2=ffc_m(temp_img)\n#out1:0.\n#out2.shape:torch.Size([1, 10, 32, 32])\n\n```\n\nI just couldn't figure out Why this FFC module does not work for 3 channel img tensor with ratio_gin:0.5 and ratio_gout:0.5 each parameter.\nThe parameter of [αin,αout] in this reference is not equal　 FFC module`s ratio_gin and ratio_gout?\nSorry for the confusing explanation.\nI would appreciate any advice you could give me. Best regards.Thank you.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform and Time-Series Forecasting in R\r\n                \r\nAfter reviewing the literature available for FFT,  I saw very little documentation of employing FFT for macroeconomic data. Can you please give sources to utilize FFT using time-series data in R? Thank you for your time. \n    ", "Answer": "\r\nDon't waste your time with applying FFT's to macroeconomic data. If there are cycles in the data, then the only things to find is the fundamental frequency and probably a second harmonic. All else is noise.\n\nAn autocorrelation function is the (much) better tool here.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform: The first element is correct, but the rest are not\r\n                \r\nI'm implementing FFT, and my solution can consistently solve the first element of the transform, but can't do the rest.\n\nHere is the code:\n\n```\nvector<complex<double>> FFT(vector<complex<double>> a, complex<double> w)\n{\n    if (a.size() == 1) {\n        return a;\n    }\n    vector<complex<double>> even;\n    vector<complex<double>> odd;\n    for (int i = 0; i < a.size(); i ++) {\n        if (i % 2 == 0) {\n            even.push_back(a[i]);\n        }\n        else {\n             odd.push_back(a[i]);\n        }\n    }\n    vector<complex<double>> FFTeven = FFT(even, nthRoot(a.size() / 2));\n    vector<complex<double>> FFTodd = FFT(odd, nthRoot(a.size() / 2));\n\n    vector<complex<double>> ret;\n    for (int i = 0; i < a.size(); i++) {\n    ret.push_back(0);\n    }\n    for (int i = 0; i <= (a.size() / 2) - 1; i++) {\n        ret[i] = FFTeven[i] + pow(w, i) * FFTodd[i];\n        ret[i + a.size() / 2] = FFTeven[i] - pow(w, i) * FFTodd[i];\n    }\n    return ret;\n}\n```\n\n\nmain code:\n\n```\nint n = 4;\nvector <complex<double>> a;\nvector<complex<double>> b;\nfor (int i = 1; i < 9; i++) {\n    if (i < 5) {\n        a.push_back((complex<double>) i);\n    }\n    else {\n        b.push_back((complex<double>) i);\n    }\n}\nfor (int i = 0; i < n; i++) {\n    a.push_back(0);\n    b.push_back(0);\n}\ncomplex<double> w = nthRoot(a.size());\n\na = FFT(a, w);\nb = FFT(b, w);\nfor (int i = 0; i < a.size() - 1; i++) {\n    cout << a[i].real() << \", \";\n}\ncout << a.back().real() << \">\\n\";\nfor (int i = 0; i < b.size() - 1; i++) {\n    cout << b[i].real() << \", \";\n}\ncout << b.back().real() << \">\\n\";\n```\n\n\nnthRoot:\n\n```\ncomplex<double> nthRoot(int n)\n{\n    return (cos(2 * M_PI / n) + i * sin(2 * M_PI / n));\n}\n```\n\n\ni globally declared:\n\n```\nconst complex<double> i = (0.0, 1.0);\n```\n\n\nexample input:\n\n\n  a = <5, 6, 7, 8, 0, 0, 0, 0>\n\n\nexample output:\n\n\n  ret = <26, 31.799, -6, -7.65685, -2, -7.79899, 2, 3.65685>\n\n\nexpected output:\n\n\n  ret = <26, 3.5858, -2, 6.4142, -2, 6.4142, -2, 3.5858>\n\n\nThis FFT is being used to find a convolution, hence the padded zeros at the end of the input vector. Any help would be appeciated.\n    ", "Answer": "\r\nWell I got your expected output by running your code. The only difference is when I ```\npushback```\n 0s, I have to use ```\npush_back(complex<double>(0))```\n. I don't think that matters.\n\nDid you messed up with expected result and example result?\n\nIn case someone is interested in this FFT example, I put the \"copy-paste-run\" version below: \n\n```\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <complex>\n\nusing namespace std;\n\ncomplex<double> nthRoot(int n)\n{\n    return complex<double>(cos(2 * M_PI / n), sin(2 * M_PI / n));\n}\n\nvector<complex<double> > FFT(vector<complex<double> > a, complex<double> w)\n{\n    if (a.size() == 1) {\n        return a;\n    }\n    vector<complex<double> > even;\n    vector<complex<double> > odd;\n    for (int i = 0; i < a.size(); i ++) {\n        if (i % 2 == 0) {\n            even.push_back(a[i]);\n        }\n        else {\n             odd.push_back(a[i]);\n        }\n    }\n    vector<complex<double> > FFTeven = FFT(even, nthRoot(a.size() / 2));\n    vector<complex<double> > FFTodd = FFT(odd, nthRoot(a.size() / 2));\n\n    vector<complex<double> > ret;\n    for (size_t i = 0; i < a.size(); i++) {\n        ret.push_back(complex<double>(0));\n    }\n    for (size_t i = 0; i <= (a.size() / 2) - 1; i++) {\n        ret[i] = FFTeven[i] + pow(w, i) * FFTodd[i];\n        ret[i + a.size() / 2] = FFTeven[i] - pow(w, i) * FFTodd[i];\n    }\n    return ret;\n}\n\nint main(void) {\n\n  int n = 4;\n  vector<complex<double> > a;\n  vector<complex<double> > b;\n  for (int i = 1; i < 9; i++) {\n      if (i < 5) {\n          a.push_back((complex<double>) i);\n      }\n      else {\n          b.push_back((complex<double>) i);\n      }\n  }\n  for (int i = 0; i < n; i++) {\n      a.push_back(complex<double>(0));\n      b.push_back(complex<double>(0));\n  }\n  complex<double> w = nthRoot(a.size());\n\n  a = FFT(a, w);\n  b = FFT(b, w);\n  for (int i = 0; i < a.size() - 1; i++) {\n      cout << a[i].real() << \", \";\n  }\n  cout << a.back().real() << \">\\n\";\n  for (int i = 0; i < b.size() - 1; i++) {\n      cout << b[i].real() << \", \";\n  }\n  cout << b.back().real() << \">\\n\";\n}\n```\n\n\nThe output is\n\n\n  10, -0.414214, -2, 2.41421, -2, 2.41421, -2, -0.414214>\n  \n  26, 3.58579, -2, 6.41421, -2, 6.41421, -2, 3.58579>\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "On the fly calculation of Fourier transformation in Java\r\n                \r\nI want to write a program in Java that uses fast Fourier transformation.\nThe program reads data every 5 milliseconds seconds from sensors and is supposed to do something with the data every 200 milliseconds based on the data from the last five seconds.\n\nIs there a good library in Java that provides a way to do Fourier transformation without recalculating all five seconds every time?\n    ", "Answer": "\r\nHard real time problems are not the proper application of Java. There are too many variables such as Garbage collection and Threads not guaranteed to happen within a given interval to make this possible. If close enough is acceptable it will work. The performance of your software as far as timing will also depend on the OS and hardware you are using and what other programs are also running on that box.  \n\nThere is a Real Time Java, that does have a special API for the issues I mention above. You do not indicate that you are using that. It is also a different animal in a lot of respects than plain Java.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform of the recorded wav file in Android\r\n                \r\nThere is a wav file on SD card. First, I connect to a file and reads the byte:\n\n```\nFile file = null;file = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + \"/202.wav\");\n       byte[] byteData = new byte[(int) file.length()];\n       FileInputStream in = null;\n       try {\n       in = new FileInputStream( file );\n       in.read( byteData );\n       in.close();}\n```\n\n\nI then use the transformation of data from a byte type in type double, because the FFT procedure does not work with byte type:\n\n```\ndouble[] transformed = new double[(int) file.length()];\n      for (int j=1;j<8194;j++) {\n              transformed[j] = (double)byteData[j]; }\n```\n\n\nAnd then the procedure of FFT processing this data:\n\n```\npublic void spektr(double[] x, double[] y, int Dim, int D, double[] xx, double[] yy) {\n\n     int I,J,N,L,K,LE,LE1,IP,NV2,NM1;\n     double Arg,U1,U2,U3,C,S,T1,T2,T3,T4;\n\n\n     N = (int) Math.pow(2,Dim);\n     Log.v(\"N\", \"N \"+N);\n     for (L = 1; L < Dim; L++){\n      LE = (int) Math.pow(2,Dim+1-L);\n      LE1 = LE/2;\n      U1 = (double)1.0;\n      U2 = (double)0.0;\n      Arg = (double)Math.PI/LE1;\n      C = (double)Math.cos(Arg);\n      S = D*(double)Math.sin(Arg);\n      for(J = 1; J < LE1; J++){\n       I = J;\n       do{\n            IP = I+LE1;\n            T1 = x[I] + x[IP];\n            T2 = y[I] + y[IP];\n            T3 = x[I] - x[IP];\n            T4 = y[I] - y[IP];\n            x[IP] = T3*U1 - T4*U2;\n            y[IP] = T4*U1 + T3*U2;\n            x[I] = T1;\n            y[I] = T2;\n            I = I + LE;\n       }while(I <= N);\n       U3 = U1*C - U2*S;\n       U2 = U2*C - U1*S;\n       U1 = U3;\n      }\n\n     }\n\n     NV2 = N / 2;\n     Log.v(\"NV2\", \"NV2 \"+NV2);\n     NM1 = N-1;\n     Log.v(\"NM1\", \"NM1 \"+NM1);\n     J = 1;\n     for(I = 1; I < NM1; I++){\n      if (I < J){\n       T1 = x[J];\n       T2 = y[J];\n       x[J] = x[I];\n       y[J] = y[I];\n       x[I] = T1;\n       y[I] = T2;\n      }\n      K = NV2;\n      while (K < J){\n       J = J - K;\n       K = K / 2;\n      };\n\n      J = J + K;\n     }\n\n     for(I = 1; I < N; I++){\n      x[I] = x[I] / N*2;\n      y[I] = y[I] / N*2;\n\n     }\n        for(I = 1; I < N; I++){\n\n      xx[I] = x[I];\n      yy[I] = y[I];\n\n     }\n\n     xx[1] = (double)0.0;\n    }\n```\n\n\nReads the file successfully, but the processing procedure of the FFT is not working.\nHow to find the FFT procedure, or give the code to check the FFT result?\n    ", "Answer": "\r\nhere is some free library to do FFT in java.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Sine wave Generation in Flutter using FFT ( Fast Fourier Transform)\r\n                \r\nHello stackoverflow ive been trying to implement a Fast Fourire tranform for about a week now but i dont seem to get any clooser to my souloution and im pretty sure its not supposed to be this diffucult i just dont know what im doing wrong and any help would be greatly aprichiated.\nbasickly what im trying to do is to create a sine wave on 2 hertz and a samplerate of 100 over 1024 samples and doing an FFT of this just to check if my implementation of the FFT is working, but this is proving rather difficult.\n```\nimport 'dart:math';\nimport 'package:complex/complex.dart';\nimport 'dart:typed_data';\nimport 'package:fftea/fftea.dart';\n\nvoid calculatefft() {\nfinal signal = generateMockSignal();\nfinal fft = performFFT(signal);\nconst sampleRate = 100.0; // Sampling rate in Hz\n\nprint(\"Input signal: $signal\");\n\n\n// Calculate the frequency resolution in Hz\nfinal freqResolution = sampleRate / (fft.length - 1);\n\n// Calculate the frequency values of the FFT bins in Hz\nfinal freqValues = List.generate(fft.length, (i) => i * freqResolution);\n\n\nprint(\"FFT Amplitude Spectrum: ${fft.map((c) => 'Re=${c.real.toStringAsFixed(2)},     \nIm=${c.imaginary.toStringAsFixed(2)}, Mag=${c.abs().toStringAsFixed(2)}').toList().join(',     \n')}\");\n\n\n\n}\n\nList<Complex> generateMockSignal() {\n  const int sampleRate = 100; // Sample rate (in samples per second)\nconst double duration = 10; // Duration of the signal (in seconds)\nconst double frequency = 2; // Frequency of the signal (in Hz)\nconst double amplitude = 5; // Amplitude of the signal\nconst int desiredNumSamples = 1024; // Desired number of samples\n\n// Find the nearest power of two greater than or equal to the desired number of samples\nfinal int numSamples = pow(2, (log(desiredNumSamples) / log(2)).ceil()).toInt();\n\nfinal List<Complex> signal = List.generate(numSamples, (i) {\n  final double t = i.toDouble() / sampleRate; // Time for each sample\n  return Complex(amplitude * sin(2 * pi * frequency * t), 0);\n});\n\nreturn signal;\n}\n\n\nList <Complex> performFFT(List<Complex> signal) {\nvar nSamplesLog2 =\n  log(signal.length.toDouble()) / log(2).toDouble();\nif ((nSamplesLog2 - nSamplesLog2.floor()) != .0) {\n  throw ArgumentError(\n      \"The number of samples must be a power of two.\");\n}\nvar output = Float64List(signal.length * 2);\nfor(var i=0;i<signal.length;i++) {\n  output[i*2]=signal[i].real;\n  output[i*2+1]=signal[i].imaginary;\n}\nvar fftTransformer = FFT(nSamplesLog2.toInt());\nfftTransformer.realFft(output);\nvar result=<Complex>[];\nfor(var i=0;i<signal.length;i++) {\n  result.add(Complex(output[i*2],output[i*2+1]));\n}\nreturn result;\n}\n\n\n//Another way i have made my code is a bit more simple with the sample libraries but the signal \n//generation and perform FFT is different \n\nList<double> generateMockSignal() {\n// Generate a 10-second sinusoidal signal with a frequency of 1Hz sampled at 100Hz.\nconst int sampleRate = 100;\nconst double duration = 10; // IN SEC\nconst double frequency = 1;\nconst signalAmplitude = 5;\nfinal int numSamples = (sampleRate * duration).round();\nfinal List<double> signal = List.generate(\n  numSamples, (i) => sin( signalAmplitude * pi * frequency * i / sampleRate),\n);\n\nreturn signal;\n\n\n}\n\nList<Complex> performFFT(List<double> signal) {\nfinal fft = FFT(signal.length);\nfinal freq = fft.realFft(signal);\nfinal complexFreq = freq.map((f) => Complex(f.x, 0)).toList();\n\nreturn complexFreq;\n}\n```\n\nit feels like im going in circkles and have tried it all i hope some of you will be able to help thank you so much in advance\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to properly scale frequency axis in Fast Fourier Transform?\r\n                \r\nI am trying some sample code taking the FFT of a simple sinusoidal function. Below is the code\n\n```\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nN = 1024\nlimit = 10\nx = np.linspace(-limit, limit, N)\ndx = x[1] - x[0]\ny = np.sin(2 * np.pi * 5 * x) + np.sin(2 * np.pi * x)\nY = np.abs(np.fft.fft(y) ** 2)\nz = fft.fftshift(np.fft.fftfreq(N, dx))\nplt.plot(z[int(N/2):], Y[int(N/2):])\nplt.show()\n```\n\n\nFrom the function that is given, , it is clear there should be two spikes at frequencies 1 and 5. However, when I run this code, I get the following plot.\n\n             \n             \n             \n\nClearly the spikes are not where they should be. Additionally, I have noticed that the frequency scaling is sensitive to the number of points ```\nN```\n as well as the interval limits that I make ```\nlimit```\n. As an example, setting ```\nN = 2048```\n gives the following plot.\n\n             \n             \n             \n\nAs you can see, the locations of the spikes have changed. Now keeping ```\nN = 1024```\n and setting ```\nlimit = 100```\n also changes the result.\n\n             \n             \n             \n\nHow can I make it so the frequency axis is properly scaled at all times?\n    ", "Answer": "\r\n```\nfftfreq```\n returns the frequency range in the following order: the positive frequencies from lowest to highest, then the negative frequencies in reverse order of absolute value. (You usually only want to plot one half, as you do in your code.) Note how the function actually needs to know very little about the data: just the number of samples and their spacing in the time domain.\n```\nfft```\n performs the actual (Fast) Fourier transformation. It makes the same assumption about the input sampling, that it's equidistant, and outputs the Fourier components in the same order as ```\nfftfreq```\n. It doesn't care about the actual frequency values: the sampling interval is not passed in as a parameter.\nIt does however accept complex numbers as input. In practice, this is rare. Input is usually samples of real numbers, as in the above example. In that case, the Fourier transform has a special property: it's symmetric in the frequency domain, i.e. has the same value for ```\nf```\n and ```\n−f```\n. For that reason, it often doesn't make sense to plot both halves of the spectrum, as they contain the same information.\nThere is one frequency that stands out: ```\nf = 0```\n. It's a measure of the average value of the signal, its offset from zero. In the spectrum returned by ```\nfft```\n and the frequency range from ```\nfftfreq```\n, it's at the very first array index. If plotting both halves, it may make sense to shift the frequency spectrum around, so that the negative half is to the left of the zero-component, the positive half to its right, meaning all values are in ascending order and ready to be plotted.\n```\nfftshift```\n does exactly that. However, if you plot only half of the spectrum anyway, then you may as well not bother doing this at all. Though if you do, you must shift both arrays: the frequencies and the Fourier components. In your code, you only shifted the frequencies. That's how the peaks ended up on the wrong side of the spectrum: You plotted the Fourier components referring to the positive half of the frequencies with respect to the negative half, so the peaks on the right are actually meant to be close to zero, not at the far end.\nYou don't really need to rely on any of those functions operating on the frequencies. It is straightforward to generate their range based on the documentation of ```\nfftfreq```\n alone:\n```\nfrom numpy.fft import fft\nfrom numpy import arange, linspace, sin, pi as π\nfrom matplotlib import pyplot\n\ndef FFT(t, y):\n    n = len(t)\n    Δ = (max(t) - min(t)) / (n-1)\n    k = int(n/2)\n    f = arange(k) / (n*Δ)\n    Y = abs(fft(y))[:k]\n    return (f, Y)\n\nt = linspace(-10, +10, num=1024)\ny = sin(2*π * 5*t) + sin(2*π * t)\n(f, Y) = FFT(t, y)\npyplot.plot(f, Y)\npyplot.show()\n```\n\nNote that NumPy also offers dedicated functions, ```\nrfft```\n and ```\nrfftfreq```\n, for the common use case of real-valued data.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform (fft) aggregation on Spark Dataframe groupby\r\n                \r\nI am trying to get the fft over a window using numpy fft with spark dataframe like this:\n```\nimport numpy as np\n\ndf_grouped = df.groupBy(\n    \"id\",\n    \"type\",\n    \"mode\",\n    func.window(\"timestamp\", \"10 seconds\", \"5 seconds\"),\n).agg(\n    percentile_approx(\"value\", 0.25).alias(\"quantile_1(value)\"),\n    percentile_approx(\"magnitude\", 0.25).alias(\"quantile_1(magnitude)\"),\n    percentile_approx(\"value\", 0.5).alias(\"quantile_2(value)\"),\n    percentile_approx(\"magnitude\", 0.5).alias(\"quantile_2(magnitude)\"),\n    percentile_approx(\"value\", 0.75).alias(\"quantile_3(value)\"),\n    percentile_approx(\"magnitude\", 0.75).alias(\"quantile_3(magnitude)\"),\n    avg(\"value\"),\n    avg(\"magnitude\"),\n    min(\"value\"),\n    min(\"magnitude\"),\n    max(\"value\"),\n    max(\"magnitude\"),\n    kurtosis(\"value\"),\n    kurtosis(\"magnitude\"),\n    var_samp(\"value\"),\n    var_samp(\"magnitude\"),\n    stddev_samp(\"value\"),\n    stddev_samp(\"magnitude\"),\n    np.fft.fft(\"value\"),\n    np.fft.fft(\"magnitude\"),\n    np.fft.rfft(\"value\"),\n    np.fft.rfft(\"magnitude\"),\n)\n```\n\nEvery aggregation function works fine, however for the fft I get:\n```\ntuple index out of range\n```\n\nand I don't understand why. Do I need to do anything particular to the values in order for numpy fft to work? The values are all floats. When I ```\nprint```\n the column it looks like this:\n```\n[Row(value_0=6.247499942779541), Row(value_0=63.0), Row(value_0=54.54375076293945), Row(value_0=0.7088077664375305), Row(value_0=51.431251525878906), Row(value_0=0.09377499669790268), Row(value_0=0.09707500040531158), Row(value_0=6.308750152587891), Row(value_0=8.503950119018555), Row(value_0=295.8463134765625), Row(value_0=7.938048839569092), Row(value_0=8.503950119018555), Row(value_0=0.7090428471565247), Row(value_0=0.7169944643974304), Row(value_0=0.5659012794494629)]\n```\n\nI am guessing the spark row might be an issue, but I am unsure of how to convert it in this context.\n    ", "Answer": "\r\n```\nnp.fft.fft```\n is a numpy function, not a pyspark function. Therefore, you cannot apply it directly to a dataframe.\nMoreover, it takes as entry an array. ```\n\"value\"```\n is a string. The function ```\nfft```\n cannot infer that as being the aggregated list of the values of the column ```\n\"value\"```\n. You have to do it manually.\n```\nfrom pyspark.sql import functions as F, types as T\n\ndf_grouped = df.groupBy(\n    \"id\",\n    \"type\",\n    \"mode\",\n    func.window(\"timestamp\", \"10 seconds\", \"5 seconds\"),\n).agg(\n    F.percentile_approx(\"value\", 0.25).alias(\"quantile_1(value)\"),\n    ...,\n    F.stddev_samp(\"magnitude\"), # I replace the np.fft.fft with a collect_list\n    F.collect_list(\"value\").alias(\"values\"),\n    F.collect_list(\"magnitude\").alias(\"magnitudes\"),\n)\n\n\n#  Definition of the UDF fft. Do the same for rfft\n@F.udf(T.ArrayType(T.FloatType()))\ndef fft_udf(array):\n    return [float(x) for x in np.fft.fft(array)]\n\n# Do that for all your columns.\ndf_grouped.withColumn(\"ftt_values\", fft_udf(F.col(\"values\")))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How plot the Riemann zeta zero spectrum with the Fourier transform in Mathematica?\r\n                \r\nIn the paper \"The Riemann Hypothesis\" by J. Brian Conrey in figure 6 there is a plot of the Fourier transform of the error term in the prime number theorem. See the plot to the left in the image below:\n\n\n\nIn a blog post called Primes out of Thin Air written by Chris King there is a Matlab program that plots the spectrum. See the plot to the right at the beginning of the post. A translation into Mathematica is possible:\n\nMathematica:\n\n```\n scale = 10^6;\n start = 1;\n fin = 50;\n its = 490;\n xres = 600;\n y = N[Accumulate[Table[MangoldtLambda[i], {i, 1, scale}]], 10];\n x = scale;\n a = 1;\n myspan = 800;\n xres = 4000;\n xx = N[Range[a, myspan, (myspan - a)/(xres - 1)]];\n stpval = 10^4;\n F = Range[1, xres]*0;\n\nFor[t = 1, t <= xres, t++,\n For[yy=0, yy<=Log[x], yy+=1/stpval,\n F[[t]] =\n F[[t]] +\n Sin[t*myspan/xres*yy]*(y[[Floor[Exp[yy]]]] - Exp[yy])/Exp[yy/2];\n ]\n ]\n F = F/Log[x];\n ListLinePlot[F]\n```\n\n\nHowever, this is as I understand it the matrix formulation of the Fourier sine transform and it is therefore very costly to compute. I do NOT recommend running it because it already crashed my computer once.\n\nIs there a way in Mathematica utilising the Fast Fourier Transform, to plot the spectrum with spikes at x-values equal to imaginary part of Riemann zeta zeros?\n\nI have tried the commands ```\nFourierDST```\n and ```\nFourier```\n without success. The problem seems to be that the variable ```\nyy```\n in the code is included in both ```\nSin[t*myspan/xres*yy]```\n and ```\n(y[[Floor[Exp[yy]]]] - Exp[yy])/Exp[yy/2]```\n.\n\nEDIT: 20.1.2012, I changed the line:\n\n```\nFor[yy = 0, yy <= Log[x], 1/stpval++,```\n\n\ninto the following:\n\n```\nFor[yy = 0, yy/stpval <= Log[x], yy++,```\n\n\nEDIT: 22.1.2012, From Heike's comment, changed:\n\n```\nFor[yy = 0, yy/stpval <= Log[x], yy++,```\n\n\ninto:\n\n```\nFor[yy=0, yy<=Log[x], yy+=1/stpval,```\n\n    ", "Answer": "\r\nWhat about this? I've rewritten the sine transform slightly using the identity ```\nExp[a Log[x]]==x^a```\n\n\n```\nClear[f]\nscale = 1000000;\nf = ConstantArray[0, scale];\nf[[1]] = N@MangoldtLambda[1];\nMonitor[Do[f[[i]] = N@MangoldtLambda[i] + f[[i - 1]], {i, 2, scale}], i]\n\nxres = .002;\nxlist = Exp[Range[0, Log[scale], xres]];\ntmax = 60;\ntres = .015;\nMonitor[errList = Table[(xlist^(-1/2 + I t).(f[[Floor[xlist]]] - xlist)), \n  {t, Range[0, 60, tres]}];, t]\n\nListLinePlot[Im[errList]/Length[xlist], DataRange -> {0, 60}, \n  PlotRange -> {-.09, .02}, Frame -> True, Axes -> False]\n```\n\n\nwhich produces \n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Guitar Chord Recognition Algorithm?\r\n                \r\nWhats a good digital signal processing algorithm that is good on guitar chords? Since Fast Fourier Transform I think only is accurate on single notes played on the guitar but not notes that are played simultaenously (i.e. chords).\n\nThanks!\n    ", "Answer": "\r\nThe short answer is that you need much more than one algorithm. Good chord recognition methods could more aptly be described as \"systems\", but usually they are indeed based on an initial transform to the frequency domain (most often DFT).\n\nIf you want a chord representaton of the song similar to this\n\n```\nC G Am F7 F6 C ...\n```\n\n\nthen this is actually a problem that is slightly removed from recognising the notes in a piece of audio. In fact, there are two problems (roughly speaking):\n\n\nfinding which pitches are present at any time\ngrouping these pitches over time so as to be able to assign a chord label to a time interval.\n\n\nIt turns out that the way you transform from the time domain (normal audio) to the frequency domain (spectral representation) is only of limited importance. It's very important what you do afterwards, and often sophisticated probabilistic models (similar to those in speech recognition: HMMs, DBNs, ...) are used to tackle this problem.\n\nTry google scholar \"chord transcription\", or \"chord detection\", or \"chord labelling\" for advanced research in this area.\n\nMost of these approaches use a discrete Fourier transform (DFT) to create the initial spectrogram. During further processing, too, they tend to differ only slightly, though different time-series smoothing techniques have been used: hidden Markov models, dynamic Bayesian networks, support vector machines (SVMstruct), and conditional random fields -- among others. \nThe most advanced transcribers use automatic tuning, key information, bass note information, and information of the metric position to improve the results. My thesis (Chapter 2) gives a nice overview.\n\nOpen source chord detection algorithms:\n\n\nChordino at http://isophonics.net/nnls-chroma\nChordata at http://clam-project.org/\nLabROSA Chord Recognition http://labrosa.ee.columbia.edu/projects/chords/\n\n\nHope this helps.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Numpy FFT (Fast Fourier Transformation) of 1-dimensional array\r\n                \r\nI have a simple one-dimensional array like ```\n[0,0,0,0,0,1,1,1,1,1,0,0,0,0,0]```\n which describes a square impulse. I would like to transform this impulse to the frequency domain and plot its magnitude spectrum by using the code below (I got it from OpenCV Python Tutorials):\n\n```\nsquareimpulse = np.array([0,0,0,0,0,1,1,1,1,1,0,0,0,0,0])\n\nimg = (squareimpulse)\nf = np.fft.fft(img)\nfshift = np.fft.fftshift(f)\nmagnitude_spectrum = 20*np.log(np.abs(fshift))\n\nplt.subplot(121),plt.imshow(img, cmap = 'gray')\nplt.title('Input Image'), plt.xticks([]), plt.yticks([])\nplt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\nplt.show()\n```\n\n\nThe script works fine for two-dimensional arrays with ```\nf = np.fft.fft2(img)```\n but not for my case where I only got one dimension.\n\nHope we can figure this out.\n    ", "Answer": "\r\n```\nplt.magnitude_spectrum(img)\nplt.show()\n```\n\n\nWell, seriously, the ```\nimshow```\n function doesn't accept just a list of values. See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.imshow\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python - Fourier transform wrong frequency\r\n                \r\nI am trying to find the frequency of an array of numbers taken from a wav file using Fast Fourier Transform and numpy, however I am receiving an output of the wrong frequency.\n\nHere is my code:\n\n```\nfrom pydub import AudioSegment\nimport numpy as np\n\nnp.set_printoptions(threshold=np.inf)\n\nsound = AudioSegment.from_mp3(\"500Hz.wav\")\n\nraw_data = sound.raw_data\nraw_data = np.fromstring(raw_data, dtype=np.int16)\n\nprint(raw_data[:2000:21])\n\nwave = raw_data \nfft = np.fft.rfft(wave)\nfft = np.abs(fft)\n\nprint(max(list(fft)))\nprint(list(fft).index(max(list(fft))))\n\nfft = np.array([int(i) for i in fft])\n```\n\n\nThe 500Hz.wav file is a 500Hz audio wave for 3 seconds created using Audacity. \n\nThe code returns the following:\n\n```\n[     0  26138   3906 -25559  -7727  24402  11370 -22702 -14767  20496\n  17830 -17830 -20498  14763  22701 -11374 -24400   7728  25557  -3907\n -26140      0  26141   3905 -25555  -7728  24404  11373 -22704 -14767\n  20496  17831 -17829 -20493  14765  22698 -11375 -24404   7725  25553\n  -3906 -26138     -1  26141   3907 -25559  -7726  24402  11375 -22702\n -14765  20497  17830 -17831 -20498  14762  22700 -11374 -24401   7726\n  25557  -3906 -26141      2  26139   3912 -25556  -7728  24401  11376\n -22702 -14767  20499  17830 -17830 -20496  14766  22704 -11372 -24405\n   7725  25559  -3906 -26141     -1  26139   3906 -25556  -7725  24404\n  11373 -22702 -14769  20495  17831 -17832]\n2046217405.9084692\n1770\n```\n\n\nThis shows that the peak is at 1770Hz and not at 500Hz and I am unsure what is causing this.\nIf I am missing any information, please let me know so I can add it to the question!\n\nEdit: The file is available at https://ufile.io/nk7j9\n    ", "Answer": "\r\nThe frequency corresponding to the index 1770 depends on the duration of the frame. For instance, if the frame lasts ```\n3```\n seconds, the frequency of index ```\ni```\n is ```\ni/3```\n Hz. The zero-frequency corresponds to the average, or DC component of the signal: it is presently null. It the index 1770 corresponds to 500Hz, the duration of the frame is likely about 3.22 seconds. Since the file is read using pydub, this duration can be retreived in miliseconds using ```\nlen(sound)```\n\n\nEven if the signal is a sine wave, the peak of the discrete Fourier transform (DFT) may span over multiple frequencies. It occurs whenever the length of the frame is not a multiple of the period of the sine wave and it is called spectral leakage. It can be tempered by applying a window before the DFT. \n\nFinally, the period of the sine wave used as input is likely different from the dicrete frequencies of the DFT. Hence, estimating the frequency of the sine wave using the index of the highest amplitude can be slightly erroneous. To correct that, the actual freqency of a peak of DFT amplitude can be estimated as its mean frequency wih respect to power density See Why are frequency values rounded in signal using FFT?\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to Fourier transform an Interferogramm to an IR Spectrum using R?\r\n                \r\nHello people of the Internet, I have an Interferogramm (time domain) and want to to Fourier transform it into a IR Spectrum (frequency domain) to obtain the peaks of the functional groups in the molecule. FTIR (Fourier Transformation Infrared Spectroscopy) is a advanced method to determine functional groups in a molecule. The so-called interferometer is build like this:\n\n\n\nAn interferogram plots the signal intensity in Volt vs. the mirror position in nanometers, as in this script:\n\n```\npar(family=\"mono\", font.axis=1)\ndata <- read.table(\"D13-4-aminobenzoic_acid_interferogram.asc\")\nx <- data[,1]\ny <- data[,2]\n\nplot(x,y, \n     type=\"l\", \n     xlab=\"Mirror position [mm]\", \n     ylab=\"Signal intensity [V]\",\n     axes=F,\n     )\naxis(1)\naxis(2)\n```\n\n\nHere is the Link to the ```\n.asc```\n file with the measured data. After the Fourier Transformation the spectrum should look like this:\n\n\n\nMy question is: How do I make a fast discrete Fourier transformation in R using ```\nfft()```\n from the Interferogram to the IR spectrum? Is the reverse transformation from the spectrum to the Interferogram possible in R and if yes how is it done.\nCheers, \nKris\n    ", "Answer": "\r\nTry this solution:\n\n```\nd <- read.table('D13-4-aminobenzoic_acid_interferogram.asc')\nf <- fft(d[,2])\n# do fft(f,inverse=T) to get the unnormalized inverse\n\nf2 <- sqrt(Re(f)^2 + Im(f)^2)\n\nc <- 2.9979e8 # speed of light\nlambda.laser <- 632.8e-9 # (nm) HeNe\nnu.Nyquist <- 1e-2/lambda.laser # upper limit of the wavenumber\ndelta.nu <- nu.Nyquist/nrow(d) # wavenumber spacing\n\ni.nu <- 1:floor(length(f2)/2) # show plot up to the Nyquist limit\nplot((i.nu-1)*delta.nu,f2[i.nu],type='l')\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to convert from Inverse Fast Fourier Transform to .wav?\r\n                \r\nI used made a fft to make a band pass filter.\nAfter that I made the ifft to inverse it and pass it to time domain.\n\nMy ifft has the same length of the fft.\n\nThe ifft must be longer or is there a way to make it longer?\nHow do I pass this ifft to .wav?\n    ", "Answer": "\r\nThe WAV file format is documented pretty well (see below). It's basically some header information followed by the raw sample data. \n\nfirst result with Google:\nhttps://ccrma.stanford.edu/courses/422/projects/WaveFormat/\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "C# library to do fft and ifft? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nis there a free c# library to do the fast fourier transform and its inverse?\n    ", "Answer": "\r\nBoth Math.NET and Aforce are based on the Exocortex.DSP library.  http://www.exocortex.org/dsp\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why does python use Karatsuba algorithm for its multiplication? Isn't FFT faster? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWill there be some issues using multiplication with FFT(fast fourier transform)? I am curious. Thanks.\n    ", "Answer": "\r\nI assume by \"FFT\" you're referring to something like Schönhage–Strassen. The answer is likely that this algorithm, while asymptotically faster than Karatsuba, is more complicated and only achieves this advantage on very large numbers due to larger constant factors (Wikipedia quotes multiple sources that cut over to this algorithm only when the multiplicands have tens of thousands of digits).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fft (fast Fourier transform) to speed up opencv in python?\r\n                \r\ni have a raspberry pi with opencv and python installed. I want is to do a simple frontal face haarcascade using opencv. It works however i only have about 2 fps. So i searched through the internet and found this: ```\nhttps://www.raspberrypi.org/blog/accelerating-fourier-transforms-using-the-gpu/```\n\n\nI think it's quiet interesting, but how do i implement it into python?\n\nCan you help me?\n    ", "Answer": "\r\nYou can highly improve the performance of the classification when you specify the parameters correctly.\nJust set the min,max frame size to reasonable values and maybe set a scale factor.\n\nFor the fft there are already some python packages available for that.\nI would not recommend to write your own fft function, since the library functions a mostly optimized and you will unlikely be able to write a faster version yourself.\nThere is another issue posted for that topic:\nhttps://github.com/numpy/numpy/issues/5348\n\nThey linked a github repo for this as well:\nhttps://github.com/raspberrypi/userland/tree/master/host_applications/linux/apps/hello_pi/hello_fft\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "2-Dimensional Fast Fourier Transform 3-D plot in Matlab\r\n                \r\nWe want to plot in Matlab using mesh function the FFT2 of an image (we have applied ```\nfftshift```\n, ```\nabs```\n, and ```\nlog```\n).\n\nSo how do we do that?\n\n```\nimageB=imread('pic2', 'jpg');\n\nfigure, imshow(imageB)\n\nfftB=fft2(double(imageB));\n\nF1=fftshift(fftB);\n\nF2=abs(F1);\n\nF3=log(F2+1);\n\nmesh(F3)\n```\n\n\nWe want a 3-D plot of the FFT.\n    ", "Answer": "\r\nAn option using ```\nsurf```\n:\n\n```\nimageB=rgb2gray(imread('http://upload.wikimedia.org/wikipedia/commons/d/db/Patern_test.jpg'));\n```\n\n\nNote that the original image is a RGB image, thus the FFT will also be a 3-channel array. Either convert to grayscale or access one channel with ```\nF1(:,:,1)```\n\n\n```\nfftB=fft2(double(imageB));\nF1=log(abs(fftshift(fftB)));\n\nsurf(F1), shading flat;\n```\n\n\nResult:\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier Transform and Fourier Descriptors to extract shapes features on Java\r\n                \r\nI am trying to build a simple system to recognize simple shapes using Fourier descriptors: \nI am using this implementation of Fast fourier transform on my program: (link below) \nhttp://www.wikijava.org/wiki/The_Fast_Fourier_Transform_in_Java_%28part_1%29\n\n```\nfft(double[] inputReal, double[] inputImag, boolean direction)\n```\n\n\ninputs are: real and imag part (which are essentially x,y coordinates of boundary parameter I have)\nand outputs are the transformed real and imag numbers.\n\nquestion: How can i use the output (transformed real,imag ) as a invariant descriptors of my simple shapes? \n\nThis was what I thought : \n\n\ncalculate ```\nR = sqrt( real^2 + imag^2 )```\n for each N steps.  \ndivide each ```\nR```\n by ```\nR[1]```\n = the normalization factor to make it invariant. \n\n\nThe problem is I get very different R values for slightly different images (such as slight rotations applied, etc) \n\nIn other words : \nMy descriptors are not invariant... I think I am doing something wrong with getting the R value.\n    ", "Answer": "\r\nThere is some theory you need to know first about Fourier Descriptors: it's an extremely interesting technique, but should be devised correctly. What you want is invariance; invariance for rotation, translation, maybe even affine transforms. To allow good comparison with other sets of Fourier descriptors you should take following things in consideration:\n\n\nif you want invariance to translation, do not use the DC-term, that is the first element in your resulting array of Fourier coefficients\nif you want invariance to scaling, make the comparison ratio-like, for example by dividing every Fourier coefficient by the DC-coefficient. f*[1] = f[1]/f[0], f*[2]/f[0], and so on.\nif you want invariance to the start point of your contour, only use absolute values of the resulting Fourier coefficients.\nOnly the first 5 to 8 Fourier coefficients are useful when comparing the coefficients of two different objects; higher coefficients only go into the details of your contour which mostly isn't very useful information. (it's the global form that matters)\nLet's say you have 2 objects, and their Fourier descriptors. The resulting array of Fourier coefficients can be of a different size, meaning that the 'frequency interval' of the resulting frequency content is different for both shapes. You can't compare apples with pears. Zero-pad your shortest contour to match the size of the longest contour, and then calculate the Fourier descriptors. Now you have analogy between coefficients and a good comparison.\n\n\nHope this helps. Btw, user-made FFT solutions are not to be trusted in my opinion. Go for the solutions libraries reach out. If working with images, OpenCV provides Fourier transform utilities.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why is Matlab Function fft() not working for certain equations\r\n                \r\nI am trying to get the Fourier transform of a sinc function but I don't know why ```\nfft()```\n (fast Fourier transform) is not working as it works for a basic sine function.\nHere is my code, the plot produced is empty:\n```\nfunction fourier_transform\n\nTs= 1/50000;\nt = 0:Ts:.5-Ts;\n% p = sin(40*t);\nm = sin(100*t)./(100*t);\n\nf = fft(m);\nplot(t,abs(f));\n\nend \n```\n\n    ", "Answer": "\r\n```\nm(1)```\n is computed by ```\nsin(0)/0```\n, which equals ```\nNaN```\n.\n```\nNaN```\n means \"Not a Number\", and indicates an error situation. Any computation you do with ```\nNaN```\n will propagate that ```\nNaN```\n, to warn you that there was an error somewhere along the way when computing. For example, ```\nsum(m)```\n equals ```\nNaN```\n. Since each output element of the FFT involves computations with each input of ```\nm```\n, all of those output elements will be ```\nNaN```\n as well.\nYour ```\nf```\n is all ```\nNaN```\n, and ```\nplot```\n will just skip the ```\nNaN```\n points, and so produces no output.\nYou can fix your computation in one of two ways:\n\nAvoid the division by zero by dividing by ```\n100*t + 1e-9```\n, the very small value added will prevent a zero but otherwise not affect other results.\n```\n m = sin(100*t)./(100*t + 1e-9);\n```\n\n\nKnow that ```\nm(1)```\n involves a division by zero and fix it.\n```\n m = sin(100*t)./(100*t);\n m(1) = 1;\n```\n\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "C++ FFTW (fast fourier transforms) with complex numbers\r\n                \r\nI am trying to use FFT with complex numbers in C++. The problem is that I cannot make inner products, or sums of complex vectors with a common sintax, when using fftw_complex numbers.\n\nHere is a reduced simple program:\n\n```\n#include <complex.h>\n#include <fftw3.h>\n\n\nint main(void){\n\nint n=1024;\n    fftw_complex *in, *out;\n    fftw_plan p;\n\n    in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * n);\n    out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * n);\n//  out = 1*in;   /!\\\n//  out = in+0;  / ! \\\n\n    p = fftw_plan_dft_1d(n, in, out, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    fftw_execute(p); /* repeat as needed */\n\n    fftw_destroy_plan(p);\n    fftw_free(in); fftw_free(out);\n\n    return 0;\n}\n```\n\n\nThe two lines that are commented do not work:\n\ni) the 1st one gives, when compiling:\n\n```\ntest.cpp:13:10: error: invalid operands of types ‘int’ and ‘fftw_complex* {aka __complex__ double*}’ to binary ‘operator*’\n```\n\n\nii) the 2nd one gives, during the execution:\n\n```\n*** glibc detected *** ./prog: corrupted double-linked list: 0x09350030 ***\n```\n\n\nAccordingly to the documentation of fftw.org [link], standard sintax for manipulating fftw_complex should be accepted. Why not with vectors of fftw_complex?\n\nFor instance, I want to compute:\n\n```\nr = i*gamma_p*w/w0*m*exp(-l*z);\n```\n\n\nwhere i is the imaginary number; gamma_p, w0, and z are real numbers; w, m, and l are vectors of complex numbers.\n\nI tried:\n\n```\n    fftw_complex* i_NUMBER = (fftw_complex*) fftw_malloc(1*sizeof(fftw_complex));\nmemset(i_NUMBER, 0, n*sizeof(fftw_complex));\n    i_NUMBER[0][0]=0;\n    i_NUMBER[0][1]=1;   //#real(i_NUMBER)=0; imag(i_NUMBER)=1; i.e. i_NUMBER=i;\nfftw_complex* r = (fftw_complex*) fftw_malloc(n*sizeof(fftw_complex));\n\nfor (int i=0; i<n; i++){\n    r[i] = i_NUMBER[0]*gamma_p*w[i]/w0*m[i]*pow(e_NUMBER, -l[i]*z);\n}\n```\n\n\nbut the compiler gives errors about the types of operands and operations.\n\n```\ngnlse.h:58:22: error: invalid operands of types ‘fftw_complex {aka double [2]}’ and ‘double’ to binary ‘operator*’\ngnlse.h:58:61: error: wrong type argument to unary minus\n```\n\n\nAny help is welcome, thanks!\n    ", "Answer": "\r\nYou have to write explicit loops to works with vectors.\n\nLine ```\nout = in+0;```\n will produce two pointer pointing to the same location. When you deallocation it twice, you'll get corrupted heap\n\nUPDATE\n\nI think I know what problem might be. Default FFTW mode is C89. Automatic computations with complex numbers pretty much require either C99 mode or C++ using ```\n<complex>```\n header. I would guess you picked some example, modified it and wondering why it doesn't work.\n\nIn C89 mode fftw_complex is just a double[2]. So any expression in C89 mode requires pretty much manual handling of the real and imag part, just what I proposed. Cannot mix in expression coerced-to-pointer complex and doubles, functions and expect automatic handling.\n\nIn C99 mode you could get native complex which makes working with them in expression a real treat wrt C89.\n\nC++ native complex should work as well.\n\nSee http://www.fftw.org/doc/Complex-numbers.html for a detailed description.\n\nMy guess you're now effectively in C89 mode. You have to compile the example either with C99 (typically on linux /usr/bin/c99), or move to C++ and use C++ native complex along the line\n\n```\n#include <complex>\n\n...\n\nstd::complex<double>* in  = new std::complex<double>[n];\nstd::complex<double>* out = new std::complex<double>[n];\n...\np = fftw_plan_dft_1d(n,\n                     reinterpret_cast<fftw_complex*>(in),\n                     reinterpret_cast<fftw_complex*>(out),\n                     FFTW_FORWARD, FFTW_ESTIMATE);\n...\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "SciPy Fast Fourier Transform returning 0 Hz at infinite amplitude?\r\n                \r\nI've run thousands of signals through this function:\n```\ndef decompose_signal(x, time):\n    # Calculate the Fourier Transform\n    fft_vals = fft(x)\n    \n    # Calculate the frequencies corresponding to the Fourier Transform\n    n = len(x)\n    timestep = time[1] - time[0]\n    freq_resolution = 1 / (n * timestep)\n    frequencies = fftfreq(n, d=timestep)[:n//2]\n    \n    # Filter frequencies and FFT values to range from 0 to 3 Hz\n    mask = (frequencies >= 0) & (frequencies <= 3)\n    frequencies = frequencies[mask]\n    fft_vals = fft_vals[:n//2][mask]\n    \n    # Generate higher resolution frequencies\n    higher_resolution_frequencies = np.linspace(0, 3, 5000)\n    \n    # Interpolate the FFT values to match the higher resolution frequencies\n    interpolated_fft_vals = np.interp(higher_resolution_frequencies, frequencies, fft_vals)\n    \n    return higher_resolution_frequencies, np.abs(interpolated_fft_vals)**\n```\n\nFor many signals, this works just fine and the function returns the expected power spectrum. But for some, it assigns enormous power to 0 Hz and the power spectrum has a vertical asymptote on the left.\nThe signals are time series for variables in an oscillatory system. They are generate with Runge-Kutta integration (also from SciPy), and I've tried changing the integration method (RK23 vs RK45 vs DOP853 in ```\nscipy.solve_ivp```\n). This occasionally works, but rarely. Generally, if only one method removes the asymptote, it is RK23.\n\"Proper\" power spectrum:\n\nProblem power spectrum:\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier transformation Algorithms\r\n                \r\nPlease do bear with me if you find my query a little stupid. But I am currently doing a high school research project on how Fourier transformation can be used in recognizing human speech(similar to how Shazam works). But I need to  two different Fast Fourier Transformation algorithms for this project. One of the algorithms I am using would definitely be the Cooley-Tukey FTT algorithm. However, I am unsure of another FTT algorithm I should use. Thus, what would be a good algorithm to use and is there any pseudo code/source code for that particular algorithm? I was only able to find algorithms for Cooley-Tukey thus far.\n\nThanks!\n    ", "Answer": "\r\nIf you don't need speed (due to some performance constraints), then a DFT (straight matrix multiply) should produce very similar results (differing due to rounding noise) using a very different algorithm.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Shift in inverse Fourier Transform\r\n                \r\nI have written a little script (MATLAB) using fast Fourier transform  in order to filter messy time series. \n\nGiven a signal S(t) my function filter the n biggest amplitude components from the FFT transformation of S(t) and return's the filtered signal by inverse FFT.\n\nThe problem is that when I use a test signal the filtered signal is somehow shifted by approx. -1 in amplitude. I have tried to change the windowing but it doesn't appear to help (but the shift is moved toward +1). \n\nHere is a sample code of my script:\n\n```\n% test Signal\n\nt=0:0.1:1000;\nf1=1/50; f2=1/300; f3=1/20;\nSignal=100*sin(f1*2*pi*t)6x1+8*sin(f2*2*pi*t)+x3+x4+65*sin(f3*2*pi*t);\n\n[FiltredSignal]=Filter(data,5,0); % call Filter function\n\nfigure\nplot(t,real(a)*2,t,data) \n\nfigure\nplot(t,real(a)*2-data) % ???? shift of -1 in ifft ????\n\n\nfunction [FiltredSignal]=Filter(Signal,n)   \n% n= nbr of \"most significative spectra components\"\n\ntimelen=length(Signal);\n\nFT=fft(Signal); % fast fourrier transform\n\nFTcopy=FT/timelen; % Copy for spectral analysis\nFTcopy(floor(timelen/2+1):end)=[]; % cut at nyquist point\nFTcopy(1,1)=0; \n\n\n% sort FT2 in descending amplitude order\nsortedFT=sort(abs(FTcopy),'descend');\n\n% spectral selection --> n biggest amplitudes\nFiltredFT=zeros(1,timelen); \nfor i=1:n\n  freq=find(abs(FTcopy)==sortedFT(i));      \n  FiltredFT(freq)=FT(1,freq);\n  %FiltredFT(freq-1)=FT(1,freq-1); % windowing\n  %FiltredFT(freq+1)=FT(1,freq+1); % windowing\nend\n\nFiltredData=ifft(FiltredFT); % return filtred signal time serie\n\n% END\n```\n\n\nCould someone explain what is happening? \n\nI surely miss some theoretical facts of FFT (I am self learning so everything is not that clear).\n    ", "Answer": "\r\nHere is a revised version of the function above that is working, thanks to Paul R remarks.\n\n```\nfunction [FiltredSignal]=Filter(Signal,n)   \n\"% n= nbr of spectral components to keep \"\n\ntimelen=length(Signal);\n\nFT=fft(Signal); \"% fast fourrier transform\"\n\nFTcopy=FT/timelen; \"% Copy for spectral analysis\"\nFTcopy(floor(timelen/2+1):end)=[]; \"% cut at nyquist point\"\n\n\n\"% sort FT2 in descending amplitude order\"\nsortedFT=sort(abs(FTcopy),'descend');\n\n\"% spectral selection --> n biggest amplitudes\"\n\nFiltredFT=zeros(1,timelen); \n\nfor i=1:n\n  freq=find(abs(FTcopy)==sortedFT(i));      \n  FiltredFT(freq)=FT(1,freq);\nend\n\n\"% return filtred signal time serie with complex conjugate reconstruction\"\nFiltredData=ifft(FiltredFT,'symmetric'); \n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Can somebody explain how to model seasonality in timeseries, via Fast Fourier Transform, FFT?\r\n                \r\nA series, yt, can be decomposed and modeled thus:\n```\nyt = drift(or trend) + seasonality + noise```\n, which is in tandem with Parseval's theorem.\nOne of the techniques used to model a series's seasonality is the application of the FFT algorithm. I have read few texts about it(FFT) and I understand what it does but how do I incorporate it back into the model, before modeling for noise?\nI suppose FFT transforms a signal into a linear combination of sine and cosine functions of frequencies that makes up the signal. How then do I incorporate it back into the model? I have read few examples I haven't understood properly, or should I say my curiosity isn't satisfied yet.\nFor example, consider the series yt:\n```\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeature\nfrom sklearn.pipeline import Pipeline, FeatureUnion\nfrom sklearn.model_selection import train_test_split\n\n\n# data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)\n\n# estimators\nlinear_model = LinearRegression()\npoly_feat = PolynomialFeatures(degree=3)\n\n# modeling trend\npipe = Pipeline([ ('poly_trans', poly_feat), ('regressor', linear_model) ])\npipe.fit(X_train, y_train).score(X_test, y_test) # 0.76\n```\n\nNow suppose I am to model the seasonality in this series, where I get employ FFT, I think I would attempt to use a FeatureUnion to combine the trend and seasonal effect thus:\n```\nfrom scipy.fftpack import fft\n\npoly_fft_union = FeatureUnion([ ('poly_trans', poly_feat), ('fft', fft) ])\n```\n\nThis is where I am stuck. fft transformation returns complex numbers. I do not want to share more information because I don't want folks around to make assumptions that I know some aspects of this. Examples I have studied online either avoided using the fft or wrote a custom Estimator that applied the sin/cosine Fourier transformation formula directly.\nIf I weren't stuck, then I would model the trend and seasonality thus\n```\npipe = Pipeline([ ('union', poly_fft_union), ('regressor', linear_model)\npipe.fit(X_train, y_train)\n```\n\nI need to feed my curiosity here. Please, anyone?!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how to apply band pass filter using fast Fourier transform\r\n                \r\nI'm trying to make a band-pass filer using ftt in order to  build an audio  equalizer, I successfully  realize the low-pass and high-pass filter of a signal ```\ny```\n with sample rate ```\nsr```\n:\n```\ndef lowpass(y,sr):\n    S = librosa.stft(y)\n    f = np.arange(S.shape[0])\n    t = np.arange(S.shape[1])\n    A = np.exp(-t[None, :]*f[:, None]/(100*S.shape[1]))\n    SNew = S*A\n    p_bas= librosa.istft(SNew)\n```\n\n```\ndef higyhpass(y,sr):\n    S = librosa.stft(y)\n    f = np.arange(S.shape[0])\n    t = np.arange(S.shape[1])\n    A = np.exp(t[None, :]*f[:, None]/(100*S.shape[1]))\n    SNew = S*A\n    p_bas= librosa.istft(SNew)\n```\n\nI get stuck on how to implement the low-cut and high-cut  frequency using the same algorithm of low-pass and high-pass\n```\ndef band_pass(data, lowcut, highcut, fs, order=5):\n    nyq = 0.5 * fs\n    low = lowcut / nyq\n    high = highcut / nyq\n    b, a = butter(order, [low, high], btype='bandpass')\n    filtered = lfilter(b, a, data)\n    return filtered\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to use aubio framework in iOS?\r\n                \r\nI am trying to detect beat, pitch, onset, and fast Fourier Transform (FFT) of audio file in iOS and I found that aubio provides these features and iOS framework also available.\n\nSo far, I am using The Amazing Audio Engine to receive audio data in terms of ```\nCore Audio```\n's ```\nAudioBufferList```\n like this:\n\n```\nid<AEAudioReceiver> receiver = [AEBlockAudioReceiver audioReceiverWithBlock:\n                               ^(void                     *source,\n                                 const AudioTimeStamp     *time,\n                                 UInt32                    frames,\n                                 AudioBufferList          *audio) {\n    // I don't know how to use audio library.\n}];\n```\n\n\nCan I detect beat, pitch, onset, and fast Fourier Transform (FFT) using aubio from this ```\nAudioBufferList```\n and how?\nIf I am on the wrong track, please give me any suggestion?\n    ", "Answer": "\r\nLook at the aubio download page, I believe they've compiled it into framework for iOS and you can import to your Xcode directly.\n\nReference : http://aubio.org/download#ios\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to manage a 2D Fourier Transform(FFT) on a 3D numpy masked array?\r\n                \r\nI am having problems with doing 2D Fast Fourier Transforms on a 3D array. They are of a mathematical nature and of an 'understanding python/numpy' nature. \n\nEDIT: For clarification, the core questions are:\nHow does numpy.fft deal with masked arrays?\nCan I average over an axis and then do an fft and get the same result as doing an fft and then averaging over the axes that was not involved in the fft?\n\nThe array consists of a carbon dioxide flux value (in 'units') between the atmosphere and the ocean for each degree of latitude and longitude (in a certain domain). The shape of the array is (730, 50, 182) corresponding to (time, latitude, longitude). The land values are masked using:\n\n```\nimport numpy as np\nfrom numpy import ma\ncarbon_flux = ma.masked_values(carbon_flux, 1e+20)\n```\n\n\nI would like to show the log of the variance of the 2D Fourier Transform of carbon_flux averaged over longitude. I average the array over the last axis (longitude) and then do the Fourier Transform like this:\n\n```\nft_type_1 = np.log(np.abs(np.fft.fft2(ma.mean(cflux, 2)))\n```\n\n\nThis gives me an acceptable looking result. However, I was told to do the averaging first:\n\n```\nft_type_2 = np.log(np.mean(np.abs(np.fft.fft2(carbon_flux, axes=(0, 1))),axis=2)\n```\n\n\nThis results in the masked values being used to calculate the fft (I can tell by the first value of the fft being to the order of 10e19). \n\nFrom what I understand, the result of doing the averaging before the fft will differ to doing the averaging after the fft. Am I correct in the assumption or does it make no difference in what order I perform these functions?\n\nDoes the fft use the masked values? Can I avoid this?\n\nLastly, I have calculated the log of the 2D Fourier Transform of carbon_flux averaged over latitude. I fail to understand how to calculate the log of the VARIANCE of the 2D Fourier Transform averaged in latitude. Does the value of my resultant fft image simply need to be squared to become the variance? \n\nThis seems to have come across as a very complicated series of questions but any help in any department would be appreciated. Thank you.\n    ", "Answer": "\r\nAfter looking at the documentation briefly, I think ```\nnumpy.fft```\n may just ignore the mask. I would try using the ```\nma.filled()```\n function to put some other value in all the masked entries.\n\nSomething like this (taken from your example code):\n\n```\nft_type_1 = np.log(np.abs(np.fft.fft2(ma.mean(carbon_flux.filled(cflux_fill_value), 2)))\nft_type_2 = np.log(np.mean(np.abs(np.fft.fft2(carbon_flux.filled(cflux_fill_value), axes=(0, 1))),axis=2)\n```\n\n\nwhere ```\ncflux_fill_value```\n is some reasonable guess to substitute for the masked values. The fill value can also be set in another step (it is stored as part of a masked array) and then you could use ```\ncarbon_flux.filled()```\n without an argument.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Matlab FFT (Fast Fourier Transform) function of non log-base2 numbers\r\n                \r\nI have an app that I am developing that utalizes Apple's Accelerate Framework FFT function and I am trying to make it mimic the functionality of Matlab's FFT function.  I have my current code set up to output exactly the same way as I am doing so in matlab.  The only time that it doesn't output identically is when the number of elements in the data array are != a logarithm of base 2 (technically necessary for an FFT).  I was wondering if anyone knew how the Matlab Function handled this case.  If I do it using the apple code, it produces different results. \n\nNote:  I am not simply calling fft(x).  I also FFT shift and take the absolute value and square it.  I also mirror these in the apple code because they aren't directly affected by the FFT.  They are called after the fact.\n\nExample 1 - 16 Elements (Log base 2):  Similar Output\n\nMatlab Call: \n\n```\nx = 1:16;\nFxx = abs(fftshift(fft(x))).^2;\n\nFxx =\n\n  Columns 1 through 7\n\n64    66.5322    74.9807    92.5736    128    207.3490    437.0193\n\n Columns 8 through 14\n\n1681.5451    18496    1682.5451    437.0193    207.3490    128    92.5736\n\n  Columns 15 through 16\n\n74.9807    66.5322\n```\n\n\n*Apple code omitted due to length\n\nApple Output:\n\n```\nFxx[0] = 64.000000\nFxx[1] = 66.532232\nFxx[2] = 74.980664\nFxx[3] = 92.573612\nFxx[4] = 128.000000\nFxx[5] = 207.349044\nFxx[6] = 437.019336\nFxx[7] = 1681.545112\nFxx[8] = 18496.000000\nFxx[9] = 1681.545112\nFxx[10] = 437.019336\nFxx[11] = 207.349044\nFxx[12] = 128.000000\nFxx[13] = 92.573612\nFxx[14] = 74.980664\nFxx[15] = 66.532232\n```\n\n\nExample 2 - 10 Elements (NOT Log base 2): Different Output\n\nMatlab Call:\n\n```\nx = 1:10;\nFxx = abs(fftshift(fft(x))).^2;\n\nFxx = \n\nColumns 1 through 7\n\n25    27.6393    38.1966    72.3607    261.8034    3025    261.8034\n\nColumns 8 through 10\n\n72.3607    38.1966    27.6393\n```\n\n\n*Apple code omitted due to length\n\nApple Output:\n\n```\nFxx[0] = 16.000000\nFxx[1] = 45.250000\nFxx[2] = 18.745166\nFxx[3] = 32.000000\nFxx[4] = 109.254834\nFxx[5] = 1296.000000\nFxx[6] = 109.254834\nFxx[7] = 32.000000\nFxx[8] = 18.745166\nFxx[9] = 45.250000\n```\n\n\nAs you can see, they clearly produce the same output in the first example vs the second.  I have tested with both positive and negative inputs and the only time they are different is when they are NOT log base 2.  Does anyone know how Matlab handles this problem?  Perhaps it fills the array with 0's until its a log base 2 number and then do the average of certain points?  I have done lots of searching and cannot figure out what they do to obtain their output in this special case.  \n    ", "Answer": "\r\nFrom the official MATLAB documentation:\n\nThe FFT functions (fft, fft2, fftn, ifft, ifft2, ifftn) are based on a library called FFTW.\nTo compute an N-point DFT when N is composite (that is, when N = N1N2), the FFTW library decomposes the problem using the Cooley-Tukey algorithm, which first computes N1 transforms of size N2, and then computes N2 transforms of size N1.\nWhen N is a prime number, the FFTW library first decomposes an N-point problem into three (N – 1)-point problems using Rader's algorithm. It then uses the Cooley-Tukey decomposition described above to compute the (N – 1)-point DFTs.\n\n\nI'm not sure how Apple's Accelerate Framework computes such FFTs, but I'm favouring MATLAB here to produce correct results.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transforms on existing dataframe is showing unexpexted results\r\n                \r\nI have a ```\n.csv```\n file with voltage data, when I plot the data with time I can see that it is a sinusoidal wave with ```\n60hz```\n frequency.\n\nNow when I try to perform ```\nfft```\n using the ```\nscipy/numpy fft```\n modules, I get a spike at near ```\n0```\n frequency while logically it should be at ```\n60```\n. (shown below)\n\nWhen I tried it with a sin wave created in python I get proper results but I'm not getting it with my actual data.\nI'm sharing my code below, please let me know if I am doing something wrong. Thanks in advance.\n```\nimport csv\nfrom matplotlib import pyplot as plt\nimport pandas as pd\nimport numpy as np\nfrom scipy.fftpack import fft\nfrom scipy.fftpack import fftfreq\n\ndf = pd.read_csv('Va_data.csv')\n\nprint(df.head())\n\nN = df.shape[0]\nfrequency = np.linspace(0.0,100, int(N/2))\nfreq_data = fft(df['Va'])\ny = (2/N)*np.abs(freq_data[0:np.int(N/2)])\n\nplt.plot(frequency, y)\nplt.title('Frequency Domain Signal')\nplt.xlabel('Frequency in Hz')\nplt.ylabel('Amplitude')\nplt.show()\n\n```\n\nVoltage data\n    ", "Answer": "\r\nData should be fine and FFT calculation (upto a constant) is fine too. It is about how the the results are plotted. To make the x-axis values represent the frequency information in terms of Hertz, you need\n```\nfrequency = np.arange(N) / N * sampling_rate\n```\n\nand then you can crop the half of it\n```\nfrequency = frequency[:N//2]\n```\n\nand give it to ```\nplt.plot(frequency, y)```\n. The equation for ```\nfrequency```\n above comes from the fact that each DFT coefficient ```\nX(k)```\n for ```\nk = 0, .., N-1```\n has a ```\nexp(-j 2pi kn/N)```\n in it where ```\nk/N```\n gives you the normalized frequency. Multiplying by sampling rate recovers the frequency corresponding to the continous domain.\nA sample:\n```\n# sample x data\nxs = np.linspace(0, 4, 1_000)\n\n# sampling rate in this case\nfs = 1 / np.diff(xs)[0]\n\n# sine of it\nys = np.sin(2 * np.pi * 60 * xs)\n\n# taking FFT\ndft = np.fft.fft(ys)\n\n# getting x-axis values to represent freq in Hz\nN = len(xs)\nx_as_freq = np.arange(N) / N * fs\n\n# now plotting it\nplt.plot(x_as_freq, np.abs(dft))\nplt.xlabel(\"Frequency (Hz)\")\nplt.ylabel(\"DFT magnitude\")\n\n# to see that peak is indeed at 60Hz\nplt.xticks(np.arange(0, 250, 20))\n```\n\nwhich gives\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "TypeError: src data type = 15 is not supported\r\n                \r\nI want to use Fast Fourier Transform but already trying a simple back and forth transformation doesn't work. The code is\n\n```\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('Picture.bmp',0)\nf = np.fft.fft2(img)\nfshift = np.fft.fftshift(f)\nf_ishift = np.fft.ifftshift(fshift)\nimg_back = cv2.idft(f_ishift)\nimg_back = cv2.magnitude(img_back[:,:,0],img_back[:,:,1])\n```\n\n\nand the error is\n\n```\nTraceback (most recent call last):\n  File \"test.py\", line 8, in <module>\n    img_back = cv2.idft(f_ishift)\nTypeError: src data type = 15 is not supported\n```\n\n\nHow can this be fixed?\n    ", "Answer": "\r\nI think I figured it out. cv2.idft() wants the complex numbers in a different format. I had to extract the real and imaginary part separately and write them in the third dimension:\n\n```\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('Bild.bmp',0)\nf = np.fft.fft2(img)\nfshift = np.fft.fftshift(f)\nf_ishift = np.fft.ifftshift(fshift)\nd_shift = np.array(np.dstack([f_ishift.real,f_ishift.imag]))\nimg_back = cv2.idft(d_shift)\nimg = cv2.magnitude(img_back[:,:,0],img_back[:,:,1])\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to calculate 95% confidence level of Fourier transform in Python?\r\n                \r\nAfter calculating the Fast Fourier Transform (FFT) of a time series in Python/Scipy, I am trying to plot the 95% confidence level that for which the power spectrum is different from red or white noise, but haven't found a straightforward way to do so. I tried following this thread: Power spectrum in python - significance levels\nand wrote the following code to test for a sine function with random noise:\n```\nimport numpy as np\nfrom scipy.stats import chi2\nfrom scipy.fft import rfft, rfftfreq\n\nx=np.linspace(0,10,500)\n\ndata = np.sin(20*np.pi*x)+np.random.rand(500) - 0.5\n\nyf = rfft(data)\nxf = rfftfreq(len(data), 1) \nn=len(data)\n\nvar=np.var(data)\n\n### degrees of freedom\nM=n/2\nphi=(2*(n-1)-M/2.)/M       \n###values of chi-squared\nchi_val_99 = chi2.isf(q=0.01/2, df=phi) #/2 for two-sided test\nchi_val_95 = chi2.isf(q=0.05/2, df=phi)\n\n\n\n### normalization of power spectrum with 1/n\nplt.figure(figsize=(5,5))\nplt.plot(xf,np.abs(yf)/n, color='k')  \nplt.axhline(y=(var/n)*(chi_val_95/phi),color='r',linestyle='--') \n```\n\nBut the resulting line lies below all of the power spectrum, as in Fig. 1. What am I doing wrong? Is there another way to get the significance of the FFT power spectrum ?\n\n    ", "Answer": "\r\nBackground considerations\nI did not read the entire references included in the answer you linked to (and in particular Pankofsky et. al.), but couldn't find an explicit derivation of the formula and exactly under which conditions the results applied. On the other hand I've found a few other references where a derivation could more readily be confirmed.\nBased on the answer to this question on dsp.stackexchange.com, if you only had white gaussian noise with unit variance, the squared-amplitude of each Fourier coefficients would have Chi-squared distribution with degree of freedom asymptotically 2 (sum of 2 Gaussians, one for each of the real and imaginary parts of the complex Fourier coefficient, when ```\nn >> 1```\n). When the noise does not have unit variance, it follows a more general Gamma distribution (although in this case you can simply think of it as scaling the survival function). For noise with a uniform distribution in the ```\n[-0.5,0.5]```\n range, and a sufficiently large number of samples, the distribution can also be approximated by a Gamma distribution thanks to the Central Limit Theorem.\nTo illustrate and better understand these distribution, we can go through gradually more complex cases.\nFrequency domain distribution of random noise\nFor sake of comparing with the later case of uniformly distributed data we will use a gaussian noise with a matching variance. Since the variance of uniformly distributed data is in the range ```\n[-0.5,0.5]```\n is ```\n1/12```\n, this gives us the following data:\n```\ndata = np.sqrt(1.0/12)*np.random.randn(500)\n```\n\nNow let us check the statistics on the power spectrum. As indicated earlier, the squared magnitude of each frequency coefficient is a random variable with an approximately Gamma distribution. The shape parameter is half the degrees of freedom of a Chi-Squared distribution that could have been used for a unit-variance case (so 1 in this case), and the scale parameter corresponds to the square of the scaling of the time-domain (from linearity the variate ```\nyf```\n scales as ```\ndata```\n, such that ```\nnp.abs(yf)**2```\n scales as the square of ```\ndata```\n).\nWe can validate this by plotting the histogram of the ```\ndata```\n against the probability density function:\n```\nyf = rfft(data)\nspectrum = np.abs(yf)**2/len(data)\nplt.figure(figsize=(5,5))\nplt.hist(spectrum, bins=100, density=True, label='data')\nz = np.linspace(0, np.max(spectrum), 100)\nplt.plot(z, gamma.pdf(z, 1, scale=1.0/12), 'k', label='$\\Gamma(1,{:.3f})$'.format(1.0/12))\n```\n\nAs you can see the values are in pretty good agreement:\n\nGoing back to the spectrum plot:\n```\n# degrees of freedom\nphi = 2\n###values of chi-squared\nchi_val_95 = chi2.isf(q=0.05/2, df=phi) #/2 for two-sided test\n\n### normalization of power spectrum with 1/n\nplt.figure(figsize=(5,5))\nplt.plot(xf,np.abs(yf)**2/n, color='k')\n# the following two lines should overlap\nplt.axhline(y=var*(chi_val_95/phi),color='r',linestyle='--')\nplt.axhline(y=gamma.isf(q=0.05/2, a=1, scale=var),color='b')\n```\n\n\nJust changing the ```\ndata```\n to use a uniform distribution in the ```\n[-0.5,0.5]```\n range (with ```\ndata = np.random.rand(500) - 0.5```\n) gives an almost identical plot, with the confidence level remaining unchanged.\nFrequency domain distribution of signal with noise\nTo get a single threshold value corresponding to a 95% confidence interval where the noise part would fall if you could separate it from the ```\ndata```\n containing a sinusoidal component and noise (or otherwise stated as the 95% confidence interval of the null-hypothesis that the ```\ndata```\n is white noise), you would need the variance of the noise. While trying to estimate this variance you may quickly realize that the sinusoidal contributes a non-negligible portion of the overall ```\ndata```\n's variance. To remove this contribution we could take advantage of the fact that sinusoidal signals are more readily separated in the frequency-domain.\nSo we could simply discard the x% largest values of the spectrum, under the assumption that those are mostly contributed by spike of the sinusoidal component in the frequency-domain. Note that 95 percentile choice below for the outliers is somewhat arbitrary:\n```\n# remove outliers\nthreshold = np.percentile(np.abs(yf)**2, 95) \nfiltered = [x for x in np.abs(yf)**2 if x <= threshold]\n```\n\nThen we can get the time-domain variance using Parseval's theorem:\n```\n# estimate variance\n# In time-domain variance ~ np.sum(data**2)/len(data))\n# In frequency-domain, using Parseval's theorem we get np.sum(data**2)/len(data) = np.mean(np.abs(spectrum)**2)/len(data)\nvar = np.mean(filtered)/len(data)\n```\n\nNote that due to the dynamic range of values across the spectrum, you may prefer to visualize the results on a logarithmic scale:\n```\nplt.figure(figsize=(5,5))\nplt.plot(xf,10*np.log10(np.abs(yf)**2/n), color='k')  \nplt.axhline(y=10*np.log10(gamma.isf(q=0.05/2, a=1, scale=var)),color='r',linestyle='--')\n```\n\n\nIf on the other hand you are trying to obtain a frequency-dependent 95% confidence interval, then you'd need to consider the contribution of the sinusoidal component at each frequency. For sake of simplicity we will assume here that the amplitude of the sinusoidal component and the variance of the noise are known (otherwise we'd first need to estimate these). In this case the distribution gets shifted by the sinusoidal component's contribution:\n```\nsignal = np.sin(20*np.pi*x)\ndata = signal + np.random.rand(500) - 0.5\nSf   = rfft(signal)  # Assuming perfect knowledge of the sinusoidal component\nyf   = rfft(data)\n\nnoiseVar = 1.0/12    # Assuming perfect knowledge of the noise variance\nthreshold95 = np.abs(Sf)**2/n + gamma.isf(q=0.05/2, a=1, scale=noiseVar)\nplt.figure(figsize=(5,5))\nplt.plot(xf, 10*np.log10(np.abs(yf)**2/n), color='k')  \nplt.plot(xf, 10*np.log10(threshold95), color='r',linestyle='--')\n```\n\n\nFinally, while I kept the final plots in squared-amplitude units, nothing prevents you from taking the square root and view the corresponding thresholds in amplitude units.\n\nEdit : I've used a ```\ngamma(1,s)```\n distribution which is an asymptotically good distribution for data with sufficient number of samples ```\nn```\n. For really small data sizes the distribution more closely match a ```\ngamma(0.5*(n/(n//2+1)),s)```\n (due to the DC and Nyquist coefficients being purely real, thus having 1 degree of freedom unlike all other coefficients).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Plot a fourier transform of a sin wav with matplotlib\r\n                \r\nI am trying to plot a fourier transform of a sign wave based on the scipy documentation\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fft\n\ndef sinWav(amp, freq, time, phase=0):\n    return amp * np.sin(2 * np.pi * (freq * time - phase))\n\ndef plotFFT(f, speriod, time):\n    \"\"\"Plots a fast fourier transform\n\n    Args:\n        f (np.arr): A signal wave\n        speriod (int): Number of samples per second\n        time ([type]): total seconds in wave\n    \"\"\"\n\n    N = speriod * time\n    # sample spacing\n    T = 1.0 / 800.0\n    x = np.linspace(0.0, N*T, N, endpoint=False)\n\n    yf = scipy.fft.fft(f)\n    xf = scipy.fft.fftfreq(N, T)[:N//2]\n    plt.plot(xf, 2.0/N * np.abs(yf[0:N//2]))\n    plt.grid()\n    plt.xlim([1,3])\n    plt.show()\n\n\nsperiod = 1000\ntime  = {\n    0: np.arange(0, 4, 1/speriod),\n    1: np.arange(4, 8, 1/speriod),\n    2: np.arange(8, 12, 1/speriod)\n}\n\nsignal = np.concatenate([\n    sinWav(amp=0.25, freq=2, time=time[0]),\n    sinWav(amp=1, freq=2, time=time[1]),\n    sinWav(amp=0.5, freq=2, time=time[2])\n])   # generate signal\n\nplotFFT(signal, speriod, 12)\n```\n\n\nDesired output\nI want to be getting a fourier transform graph which looks like this\n\nCurrent output\nBut instead it looks like this\n\n\nExtra\nThis is the sin wave I am working with\n\n    ", "Answer": "\r\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fft\n\ndef sinWav(amp, freq, time, phase=0):\n    return amp * np.sin(2 * np.pi * (freq * time - phase))\n\ndef plotFFT(f, speriod, time):\n    \"\"\"Plots a fast fourier transform\n\n    Args:\n        f (np.arr): A signal wave\n        speriod (int): Number of samples per second\n        time ([type]): total seconds in wave\n    \"\"\"\n\n    N = speriod * time\n    # sample spacing\n    T = 1.0 / 800.0\n    x = np.linspace(0.0, N*T, N, endpoint=False)\n\n    yf = scipy.fft.fft(f)\n    xf = scipy.fft.fftfreq(N, T)[:N//2]\n\n    amplitudes = 1/speriod* np.abs(yf[:N//2])\n  \n    plt.plot(xf, amplitudes)\n    plt.grid()\n    plt.xlim([1,3])\n    plt.show()\n\n\nsperiod = 800\ntime  = {\n    0: np.arange(0, 4, 1/speriod),\n    1: np.arange(4, 8, 1/speriod),\n    2: np.arange(8, 12, 1/speriod)\n}\n\nsignal = np.concatenate([\n    sinWav(amp=0.25, freq=2, time=time[0]),\n    sinWav(amp=1, freq=2, time=time[1]),\n    sinWav(amp=0.5, freq=2, time=time[2])\n])   # generate signal\n\nplotFFT(signal, speriod, 12)\n```\n\nYou should have what you want. Your amplitudes were not properly computed, as your resolution and speriod were inconsistent.\n\nLonger data acquisition:\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fft\n\ndef sinWav(amp, freq, time, phase=0):\n    return amp * np.sin(2 * np.pi * (freq * time - phase))\n\ndef plotFFT(f, speriod, time):\n    \"\"\"Plots a fast fourier transform\n\n    Args:\n        f (np.arr): A signal wave\n        speriod (int): Number of samples per second\n        time ([type]): total seconds in wave\n    \"\"\"\n\n    N = speriod * time\n    # sample spacing\n    T = 1.0 / 800.0\n    x = np.linspace(0.0, N*T, N, endpoint=False)\n\n    yf = scipy.fft.fft(f)\n    xf = scipy.fft.fftfreq(N, T)[:N//2]\n\n    amplitudes = 1/(speriod*4)* np.abs(yf[:N//2])\n  \n    plt.plot(xf, amplitudes)\n    plt.grid()\n    plt.xlim([1,3])\n    plt.show()\n\n\nsperiod = 800\ntime  = {\n    0: np.arange(0, 4*4, 1/speriod),\n    1: np.arange(4*4, 8*4, 1/speriod),\n    2: np.arange(8*4, 12*4, 1/speriod)\n}\n\nsignal = np.concatenate([\n    sinWav(amp=0.25, freq=2, time=time[0]),\n    sinWav(amp=1, freq=2, time=time[1]),\n    sinWav(amp=0.5, freq=2, time=time[2])\n])   # generate signal\n\nplotFFT(signal, speriod, 48)\n```\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how to convert tensorflow tensor to numpy array from given example?\r\n                \r\nI am trying to compute Fast Fourier Transform (fft2d) but the following code provides the error:\n```\nprint(\"type(pred[2]): \", type(pred[2]))\npred[2] = tf.make_ndarray(pred[2])\nfft2_pre = np.fft.fft2(pred[2])\n```\n\nThe error and output:\n```\ntype(pred[2]):  <class 'tensorflow.python.framework.ops.Tensor'>\nAttributeError: 'Tensor' object has no attribute 'tensor_shape'\n```\n\nhow it could be solved?\n    ", "Answer": "\r\n```\ntemp = tf.cast(pred[2], dtype=tf.complex64)\ntemp = tf.signal.fft(temp)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "I did FFT(Fast Fourier Transform), but i can't understand...(python)\r\n                \r\nI got a acceleration data from rotating machine on field. so, I want to know about frequency components. so, did FFT on python (np.fft.fft).\nQ) When i got a acceleration data that scale is -20~20 m/s^2. but, after fft, scale was converted 0~1(unit: i don't know....)\nI want to understand Why scale was converted after FFT? and How can I set a unit that after FFT?\n```\nFs = 51200                             \nT = 1/Fs  \nL = len(data1)         \nt = np.arange(0,L-1)*T      \nY = np.fft.fft(data1)\nP2 = abs(Y/L)\nP1 = P2[0:int(L/2+1)]\nP1[1:-1] = 2*P1[1:-1]\nf = Fs*np.arange(0,L/2+1)/L\n```\n\nBefore FFT(Original Acceleration data)\n\nAfter FFT(Don't know abscissa's unit)\n\n    ", "Answer": "\r\nThe Fourier transform is decomposing your signal in harmonic waves (linear combination of sines and cosines), watch this if you need more details.\nThe FFT will put, for ```\ni in range(-(N+1)//2, N//2)```\n  at the index ```\ni```\n the coefficient of a complex exponential of frequency ```\ni * N / Fs```\n, so the abscissa of your plot is Frequency.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how fft points should be rescaled to get the same results as the analytical solution?\r\n                \r\nI want to work with fast fourier transform using the numpy fft package, and then  I am trying to compare the results between the analytical solution and the fast fourier transform, and although I can see with the plots I have done that the curves are similar, it is pretty obvious that the scales are different.  \n\nI have tried several different versions of the frequency (angular frequency, frequency and wave number), but all my tries did not work, and in the numpy documentation, it is not clear how the fast fourier transform is exactly defined. For example, I want to work with the fourier transform of the exponential function in time into the angular frequency domain, f(t)=Exp(-a|t|), F(w)=a/pi*(a²+w²) (there are multiple versions of this analytical solution depending on which frequency space we are considering) \n\n```\n\ndef e(t):\n    return np.exp(-0.5*abs(t))\ndef F(w):\n    return 0.5/(np.pi)*(1/(((0.5)**2)+((w)**2)))\n\nt=np.linspace(0,100,1000)\n\nw=np.fft.fftfreq(len(t))\nplt.plot(w,F(w),'o',label='F(w)')\nplt.legend()\nplt.show()\n\nfourier=np.fft.fft(e(t))\nplt.plot(w,fourier,'o')\nplt.show()\n```\n\n\nI have tried multiple different variants of the above code specially for the frequency, but I am still not getting to the point where the fft and the analytical solution are similar. could anyone please help me out?\n    ", "Answer": "\r\nThe Fourier transform can be applied to integrable functions such as ```\nnp.exp(-0.5*abs(t))```\n. But the Discrete Fourier Transform computes the Fourier transform of periodic signals. See https://dsp.stackexchange.com/questions/26884/about-fourier-transform-of-periodic-signal and  What FFTW Really Computes.\n\nHence, the DFT of a frame of length T corresponds to the Fourier transform  of the periodized frame. Since the frame starts at 0, the Fourier transform of the periodic right sided exponential decay is computed:\n\nAs you can see, half of the function ```\nnp.exp(-0.5*abs(t))```\n is not displayed. Let's correct it and add the periodized increasing part of the two sided exponential decay.\nI used frequency as a parameter:\n\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef e(t):\n    return np.exp(-0.5*abs(t))\ndef F(w):\n    return 0.5/(np.pi)*(1/(((0.5)**2)+((w)**2)))\n\ndef Fc(xi):\n    #ok , that's sourced from https://en.wikipedia.org/wiki/Fourier_transform ... Square-integrable functions, one-dimensional, line 207\n    return 2*0.5/(((0.5)**2)+(4*(np.pi*xi)**2))\n\n\nframelength=100.\nnbsample=1000\ndef ep(t):\n    #the periodized negative part is added at the end of the frame.\n    return np.maximum(np.exp(-0.5*abs(t)),np.exp(-0.5*abs(t-framelength)))\n\nt=np.linspace(0,framelength,nbsample, endpoint=False)\n\n#plotting the periodized signal, to see what's happening\nein=ep(t)\ntp=np.linspace(0,10*framelength,10*nbsample, endpoint=False)\nperiodized=np.zeros(10*nbsample)\nfor i in range(10):\n    for j in range(nbsample):\n       periodized[i*nbsample+j]=ein[j]\n\nplt.plot(tp,periodized,'k-',label='periodized frame')\nplt.legend()\nplt.show()\n\nfourier=np.fft.fft(ep(t))/np.size(ep(t))*framelength\n\n#comparing the mean is useful to check the overall scaling\nprint np.mean(ep(t))*framelength\nprint fourier[0]\nprint Fc(0)\n\n#the frenquencies of the DFT of a frame of length T are 1/T, 2/T ... and negative for the second part of the array.\nxi=np.fft.fftfreq(len(t), framelength/len(t))\n\n# comparison between analytical Fourier transform and dft.\nplt.plot(xi,Fc(xi),'o',label='F(xi)')\nplt.plot(xi,np.real(fourier),'k-', lw=3, color='red', label='DTF')\nplt.legend()\nplt.show()\n```\n\n\nAnd here goes the result:\n\n\n\nFor an experimental non-periodic signal, an artificial discontinuity appears as the frame is periodized. It induces spectral leakage and windows are applied to attenuate the discontinuity and its effects. One of the potential windows, named a Poisson window, is a two sided exponential decay! \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Trying to implement Fast Fourier transform for vectors of length power of 2\r\n                \r\nIf correctly done it is supposed to have running time O(n log n).\n\n```\nfunction d = ffTU(f)\n\nn = [size(f)](1);\n\nif n==1\n  d = f;\n  return;\n\nelse\n\n  even=ffTU(f(2:2:end,:));\n  odd =ffTU(f(1:2:end,:));\n\n  for k=0:(n/2)-1\n    T(k+1)= exp(-2i*pi*k/n)*odd(k+1);\n\n  end\n\n  for k=0:(n/2)-1\n    d(k+1) = even(k+1) + T(k+1) + even(k+1) - T(k+1);\n  end\n\nend\n```\n\n\nI keep getting these errors:\n\n```\nerror: ffTU: A(I): index out of bounds; value 2 out of bound 1\nerror: called from\n    ffTU at line 16 column 11\n```\n\n\nI know that I have to adjust the indices of the functions but I think that I fixed that.\n    ", "Answer": "\r\nPreallocate ```\nT```\n before the loop:\n\n```\nT = zeros(n/2,1);\n```\n\n\nOr better yet, compute it without the loop:\n\n```\nk = (0:(n/2)-1).';\nT = exp(-2i*pi*k/n).*odd(:);\n```\n\n\nYou should do similarly for ```\nd```\n.\n\nYou also need to test that the input is even-sized.\n\nInstead of\n\n```\nn = [size(f)](1);\n```\n\n\ndo\n\n```\nn = size(f,1);\n```\n\n\nBut if your input is not a column vector this goes bad. Fix it with\n\n```\nf = f(:);\nn = size(f,1);\n```\n\n\nAnd there's an error in your computation of ```\nd```\n because you set it to ```\n2*even```\n, ```\nT```\n is not used (as in ```\nT-T==0```\n.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Performing FFT to find fundamental frequencies of a polyphonic audio sample\r\n                \r\nI am using the Accelerate Framework in Swift to perform FFT on an audio file. I am trying to find the fundamental frequencies of a polyphonic audio file using a Fast Fourier Transform. \n\nI have performed a fast fourier transform on the audio file (correctly I think, but correct me if i'm wrong); although, I'm not sure where to go from here. Here is the code i'm using to perform the FFT:\n\n```\nlet log2n = UInt(round(log2(Double(frameCount))))\n\nlet bufferSizePOT = Int(1 << log2n)\n\n// Set up the transform\nlet fftSetup = vDSP_create_fftsetup(log2n, Int32(kFFTRadix2))\n\n// create packed real input\nvar realp = [Float](count: bufferSizePOT/2, repeatedValue: 0)\nvar imagp = [Float](count: bufferSizePOT/2, repeatedValue: 0)\nvar output = DSPSplitComplex(realp: &realp, imagp: &imagp)\n\nvDSP_ctoz(UnsafePointer<DSPComplex>(buffer.floatChannelData.memory), 2, &output, 1, UInt(bufferSizePOT / 2))\n\n// Do the fast Fourier forward transform, packed input to packed output\nvDSP_fft_zrip(fftSetup, &output, 1, log2n, Int32(FFT_FORWARD))\n\nvar fft = [Float](count:Int(bufferSizePOT / 2), repeatedValue:0.0)\nlet bufferOver2: vDSP_Length = vDSP_Length(bufferSizePOT / 2)\n\nvDSP_zvmags(&output, 1, &fft, 1, bufferOver2)\n\n// Release the setup\nvDSP_destroy_fftsetup(fftSetup)\n```\n\n\nHow do I find the fundamental frequencies from here? Thanks.\n\nEDIT:  From the research i've done, it seems like autocorrelation would be the best method for this task. Any ideas on how to perform an autocorrelation with this code?\n    ", "Answer": "\r\nAn FFT (alone) will not find just fundamental pitch frequencies within most polyphonic music.  Instead, it will find all the overtones and harmonic frequencies as well, which may well dominate over any fundamental pitch frequencies.  It may even miss some fundamental pitch frequencies buried in low frequency noise.\n\nFor algorithms more suitable than a bare FFT, there are many polyphonic pitch estimation research papers over on the MIREX forum:   http://www.music-ir.org/mirex/wiki/2015:Multiple_Fundamental_Frequency_Estimation_%26_Tracking\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "convert an image into an Fourier image in Python 3\r\n                \r\nFirst time here, and was hoping that someone would be able to help with an issue I’ve been dealing with. I performed the 2D fast Fourier transform on an image data, but got an error of the line norm_fourier_img all time, I want to know how I can correctly write that line and be able to obtain the Fourier image?\n\n```\nfrom PIL import Image\nfrom array import array\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom numpy.linalg import norm, det\n\n#load the image data into a numpy array\nimg = Image.open(\"1-z2-ex1250-p20-ch1hv100t0001.tif\")\nimg_data = np.asarray(img)\n\n#perform the 2D fast Fourier transform on the image data and...\nfourier = np.fft.fft2(img_data)\nfourier = np.fft.fftshift(fourier)\nfourier = abs(fourier)\nfourier = np.log10(fourier)\n\n#calculate the original contrast range\nlowest = np.nanmin(fourier[np.isfinite(fourier)])\nhighest = np.nanmax(fourier[np.isfinite(fourier)])\noriginal_range = highest - lowest\n\n#convert the normalized data into an image\nnorm_fourier = (highest - lowest) / original_range * 255\nnorm_fourier_img = Image.fromarray(norm_fourier)\n\n#display the original image and the Fourier image\nfig = plt.figure()\nax1 = fig.add_subplot(121)\nax2 = fig.add_subplot(122)\nax1.imshow(img, cmap = \"gray\")\nax2.imshow(norm_fourier_img)\nax1.title.set_text(\"Original Image\")\nax2.title.set_text(\"Fourier Image\")\nplt.show()\n\n#show the normalized Fourier image\nnorm_fourier_img.show()\n\n#convert the output image to 8-bit pixels (grayscale) and save it\nnorm_fourier_img.convert(\"L\").save(\"test.bnp\")\n```\n\n\nenter image description here errors information\n\nenter image description here\nthis is the original image needed to be converted to Fourier image, but can't see anything come up in the Fourier side.\n\nIndexError                                Traceback (most recent call last)\n in ()\n     26 norm_fourier = (highest - lowest) / original_range * 255\n     27 ##convert the normalized data into an image\n---> 28 norm_fourier_img = Image.fromarray(norm_fourier)\n     29 \n     30 # display the original image and the Fourier image\n\n~\\Anaconda3\\lib\\site-packages\\PIL\\Image.py in fromarray(obj, mode)\n   2441         raise ValueError(\"Too many dimensions: %d > %d.\" % (ndim, ndmax))\n   2442 \n-> 2443     size = shape1, shape[0]\n   2444     if strides is not None:\n   2445         if hasattr(obj, 'tobytes'):\n\nIndexError: tuple index out of range\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform (np.fft.fft), how to mask/ignore some indices in array\r\n                \r\nI have input array:\n```\nx=np.array( [ [5,3,4,2,1,4,0,0],\n              [2,3,4,2,1,0,0,0],\n              [8,3,4,0,0,0,0,0],\n              [1,3,4,2,3,1,2,0] ] )\n```\n\nInstead of zero , there can be any value. I want to ignore those indices.\nI want to do np.fft.fft( x, axis = -1 ) .\nHow can I apply mask so it calculates ignoring zero values or until some indices ? Should I use zeros or any other value or other solution ?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "python fast fourier coefficients filtering and thresholding deciding\r\n                \r\nI am trying to analyze a long period sequence of float numbers. I would like to conduct fast fourier transformation on the numbers and then remove low coefficient one. There are two questions:\n\n1  how to set these noise coefficient efficients less than threshold to 0 in an efficient way.\ne.g   Arr=[100, 2, 50, 4, 15, 7],  threshold = 5, return = [ 100, 0,50,0,15,7]. I suspect I should use lambda related trick, but I am still newbie to Python\n\n2   Is there a thumb rule to decide the threshold, guys experienced with FFT or with signal processing please help.\n\nThanks\n    ", "Answer": "\r\nA numpy solution to the threshold will be faster than list comprehensions or lambdas, and easier to write and read, and you'll probably be using numpy for the FFT anyway:\n\n```\nimport numpy as np\nArr=np.array([100, 2, 50, 4, 15, 7])\n\nArr[Arr<8] = 0  \n# array([100, 0, 50, 0, 15, 0])\n```\n\n\nThere is also ```\nscipy.stats.threshold```\n, but it just basically does what's above.\n\nFor the question about the threshold, it depends entirely on the nature of the signal and the noise, so there's no good rule of thumb.  For example, if you have a part of the sample that you know is just noise, then it's fairly obvious what to do; and if you don't and your signal is exactly like the noise, then you shouldn't threshold at all.  It depends on the details.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to plot FFT of a function defined in terms of an integral in MATLAB?\r\n                \r\nI want to plot the Fourier transform, using MATLAB, of data which is plotted with the following code:\n\n```\nx = -2:0.01:2; % position vector\ns = @(x)heaviside(x+1).*heaviside(-x)+heaviside(x).*heaviside(1-x); % Step    \nfunction between -1 and 1\nphi = @(x) exp(-1./(1-x.^2)).*s(x); % Test function\nd = @(t) integral(@(x)phi(x),0,t); % Data\nfplot(d,[0,1])\n```\n\n\nHowever, none of the MATLAB tutorials seem to be useful in plotting a fast Fourier transform of d, which is defined in terms of a variable integral.\n\nIf I try with\n\n```\nFs = 1000;            % Sampling frequency\nT = 1/Fs;             % Sampling period\nL = 1000;             % Length of signal\nt = (0:L-1)*T;        % Time vector\ns = @(x)heaviside(x+1).*heaviside(-x)+heaviside(x).*heaviside(1-x); % Step     \nfunction\nphi = @(x) exp(-1./(1-x.^2)).*s(x); % Test function\nd = @(t) integral(@(x)phi(x),0,t); %Data\nplot(1000*t(1:50),d(1:50))\n```\n\n\nThen I get the following error:\n\n```\nError using integral\nA and B must be floating-point scalars.\n\nError in @(t)integral(@(x)phi(x),0,t)\n```\n\n\nI don't know how to fix this though.\n    ", "Answer": "\r\nThe error happens because ```\nintegrate```\n's second and third arguments (the lower and upper bounds for the integration) must be scalars. To get a vector of values, with which to compute the ```\nfft```\n you need to compute the element's values in a ```\nfor```\n loop\n\n```\nd = zeros(size(t));\nfor i = 1:length(t)\n    d(i) = integral(phi,0,t(i));\nend\n```\n\n\nThen, you will be able to plot ```\nt```\n versus ```\nd```\n and also compute the ```\nfft```\n of ```\nd```\n by calling\n\n```\ny = fft(d);\n```\n\n\nCheckout the examples in the docs to see how to plot the results that ```\nfft```\n returns.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fft algorithm implementation with hadoop\r\n                \r\nI want to implement Fast Fourier Transform algorithm with Hadoop. I know recursive-fft algorithm but I need your guideline in order to implement it Map/Reduce approach. Any suggestions?\n\nThanks.\n    ", "Answer": "\r\nI have a tentative solution here:\n\nhttp://blog.jierenchen.com/2010/08/fft-with-mapreduce.html\n\nI haven't tried coding this up so I'm not 100% sure it works. Lemme know if I made any booboos.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Compute FFT in PHP for array of numbers\r\n                \r\nI have a set of array of numbers shown in the codes below. What I wanted to do is that to compute FFT in PHP on each number in the array. I followed some examples in the web http://www.phpclasses.org/package/6193-PHP-Compute-the-Fast-Fourier-Transform-of-sampled-data.html and http://www.jasonbailey.net/stuff/php-fast-fourier-transform-fft-brighton-php-october-2013/ as part of my FFT computation codes.\n\n```\n    $result_data = array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\n    for ($index = 0; $index < $arrayCount; $index++)\n    {   \n            $nfft = 256; // n point FFT\n\n            // initiate FFT\n            $fft = new FFT($nfft);\n            // Calculate the FFT of the function $f\n            $w = $fft->fft($result_data);\n            $power = $fft->getAbsFFT($w); //ABS value of real and complex data\n\n            echo json_encode($power);\n            echo (\"\\n\");\n        }       \n\n    }   \n```\n\n\nBut it returns me the following block of numbers that seemed to be repeated 20 times. Anyone knows how to solve this?\n\n```\n[210,208.53525574236,204.18989508213,197.10896668339,187.52910862495,175.77129358889,162.23150701411,147.3702286466,131.70187234164,115.78556186989,100.21844753863,85.631056295302,72.677748658381,61.998470581045,54.103020393308,49.148739721174,46.740037447983,46.012499351762,45.994703056701,45.92155254764,45.333151076301,44.039448549754,42.052284866333,39.525751338284,36.709391389415,33.906333247199,31.424750102821,29.513942535491,28.29366310998,27.7131610516,27.576916611977,27.6253720222,27.618541561269,27.386265448914,26.844382258082,25.99086533894,24.892934386868,23.669400662346,22.46779309482,21.434317125714,20.678014755774,20.239047255644,20.077463933306,20.091065003015,20.15230314329,20.144810323036,19.987323887149,19.643895245903,19.124273021326,18.477928096736,17.783092203984,17.130707467578,16.603640507275,16.254692449065,16.091219222815,16.074353807967,16.133714979787,16.189832387664,16.174592641358,16.044515093534,15.786512758993,15.417729244569,14.980757544263,14.534680096924,14.142135623731,13.853829187667,13.694445050864,13.655658992898,13.69986932928,13.772808720243,13.819111934091,13.795344425854,13.678051366229,13.466834348967,13.183232698382,12.865933801679,12.562524220338,12.318385729813,12.164783192548,12.10994731181,12.137035762934,12.2100245488,12.284706160539,12.320296086784,12.288354057811,12.177842128102,11.996445141301,11.768549806494,11.530104072448,11.320631072721,11.173436386132,11.10644553079,11.117041385459,11.183244299697,11.270684904022,11.342295041292,11.367328711198,11.327706227833,11.221132399844,11.061124138288,10.87413792719,10.693937046176,10.553691043927,10.47728962383,10.472517527795,10.528852113515,10.620900961901,10.715911149236,10.782373459958,10.797208691204,10.750328899821,10.646342223011,10.503496734715,10.349943817846,10.217518662194,10.13386179962,10.114800937014,10.159682185456,10.251666138297,10.362853752103,10.462042810414,10.522413342999,10.527325386443,10.473531752002,10.371721260981,10.244426297884,10.121338391339,10.032409410072,10,10.032409410072,10.121338391339,10.244426297884,10.371721260981,10.473531752002,10.527325386443,10.522413342999,10.462042810414,10.362853752103,10.251666138297,10.159682185456,10.114800937014,10.13386179962,10.217518662194,10.349943817846,10.503496734715,10.646342223011,10.75032889982,10.797208691204,10.782373459958,10.715911149236,10.620900961901,10.528852113515,10.472517527795,10.47728962383,10.553691043927,10.693937046176,10.87413792719,11.061124138288,11.221132399844,11.327706227834,11.367328711198,11.342295041291,11.270684904022,11.183244299697,11.117041385459,11.10644553079,11.173436386132,11.320631072721,11.530104072448,11.768549806494,11.996445141301,12.177842128102,12.288354057811,12.320296086784,12.284706160539,12.2100245488,12.137035762934,12.10994731181,12.164783192548,12.318385729813,12.562524220338,12.865933801679,13.183232698382,13.466834348967,13.678051366229,13.795344425854,13.819111934091,13.772808720243,13.69986932928,13.655658992898,13.694445050864,13.853829187667,14.142135623731,14.534680096924,14.980757544263,15.417729244569,15.786512758993,16.044515093534,16.174592641358,16.189832387664,16.133714979787,16.074353807967,16.091219222815,16.254692449065,16.603640507275,17.130707467578,17.783092203984,18.477928096736,19.124273021326,19.643895245903,19.987323887149,20.144810323036,20.15230314329,20.091065003015,20.077463933306,20.239047255643,20.678014755773,21.434317125714,22.46779309482,23.669400662346,24.892934386868,25.990865338941,26.844382258082,27.386265448915,27.61854156127,27.6253720222,27.576916611977,27.7131610516,28.29366310998,29.513942535491,31.424750102821,33.906333247199,36.709391389415,39.525751338284,42.052284866333,44.039448549755,45.333151076301,45.921552547641,45.994703056702,46.012499351763,46.740037447984,49.148739721174,54.103020393308,61.998470581045,72.677748658382,85.631056295303,100.21844753863,115.7855618699,131.70187234164,147.3702286466,162.23150701411,175.77129358889,187.52910862495,197.1089666834,204.18989508213,208.53525574236]\n[210,208.53525574236,204.18989508213,197.10896668339,187.52910862495,175.77129358889,162.23150701411,147.3702286466,131.70187234164,115.78556186989,100.21844753863,85.631056295302,72.677748658381,61.998470581045,54.103020393308,49.148739721174,46.740037447983,46.012499351762,45.994703056701,45.92155254764,45.333151076301,44.039448549754,42.052284866333,39.525751338284,36.709391389415,33.906333247199,31.424750102821,29.513942535491,28.29366310998,27.7131610516,27.576916611977,27.6253720222,27.618541561269,27.386265448914,26.844382258082,25.99086533894,24.892934386868,23.669400662346,22.46779309482,21.434317125714,20.678014755774,20.239047255644,20.077463933306,20.091065003015,20.15230314329,20.144810323036,19.987323887149,19.643895245903,19.124273021326,18.477928096736,17.783092203984,17.130707467578,16.603640507275,16.254692449065,16.091219222815,16.074353807967,16.133714979787,16.189832387664,16.174592641358,16.044515093534,15.786512758993,15.417729244569,14.980757544263,14.534680096924,14.142135623731,13.853829187667,13.694445050864,13.655658992898,13.69986932928,13.772808720243,13.819111934091,13.795344425854,13.678051366229,13.466834348967,13.183232698382,12.865933801679,12.562524220338,12.318385729813,12.164783192548,12.10994731181,12.137035762934,12.2100245488,12.284706160539,12.320296086784,12.288354057811,12.177842128102,11.996445141301,11.768549806494,11.530104072448,11.320631072721,11.173436386132,11.10644553079,11.117041385459,11.183244299697,11.270684904022,11.342295041292,11.367328711198,11.327706227833,11.221132399844,11.061124138288,10.87413792719,10.693937046176,10.553691043927,10.47728962383,10.472517527795,10.528852113515,10.620900961901,10.715911149236,10.782373459958,10.797208691204,10.750328899821,10.646342223011,10.503496734715,10.349943817846,10.217518662194,10.13386179962,10.114800937014,10.159682185456,10.251666138297,10.362853752103,10.462042810414,10.522413342999,10.527325386443,10.473531752002,10.371721260981,10.244426297884,10.121338391339,10.032409410072,10,10.032409410072,10.121338391339,10.244426297884,10.371721260981,10.473531752002,10.527325386443,10.522413342999,10.462042810414,10.362853752103,10.251666138297,10.159682185456,10.114800937014,10.13386179962,10.217518662194,10.349943817846,10.503496734715,10.646342223011,10.75032889982,10.797208691204,10.782373459958,10.715911149236,10.620900961901,10.528852113515,10.472517527795,10.47728962383,10.553691043927,10.693937046176,10.87413792719,11.061124138288,11.221132399844,11.327706227834,11.367328711198,11.342295041291,11.270684904022,11.183244299697,11.117041385459,11.10644553079,11.173436386132,11.320631072721,11.530104072448,11.768549806494,11.996445141301,12.177842128102,12.288354057811,12.320296086784,12.284706160539,12.2100245488,12.137035762934,12.10994731181,12.164783192548,12.318385729813,12.562524220338,12.865933801679,13.183232698382,13.466834348967,13.678051366229,13.795344425854,13.819111934091,13.772808720243,13.69986932928,13.655658992898,13.694445050864,13.853829187667,14.142135623731,14.534680096924,14.980757544263,15.417729244569,15.786512758993,16.044515093534,16.174592641358,16.189832387664,16.133714979787,16.074353807967,16.091219222815,16.254692449065,16.603640507275,17.130707467578,17.783092203984,18.477928096736,19.124273021326,19.643895245903,19.987323887149,20.144810323036,20.15230314329,20.091065003015,20.077463933306,20.239047255643,20.678014755773,21.434317125714,22.46779309482,23.669400662346,24.892934386868,25.990865338941,26.844382258082,27.386265448915,27.61854156127,27.6253720222,27.576916611977,27.7131610516,28.29366310998,29.513942535491,31.424750102821,33.906333247199,36.709391389415,39.525751338284,42.052284866333,44.039448549755,45.333151076301,45.921552547641,45.994703056702,46.012499351763,46.740037447984,49.148739721174,54.103020393308,61.998470581045,72.677748658382,85.631056295303,100.21844753863,115.7855618699,131.70187234164,147.3702286466,162.23150701411,175.77129358889,187.52910862495,197.1089666834,204.18989508213,208.53525574236]\n ....\n ....\n```\n\n    ", "Answer": "\r\nYou didn't use ```\n$index```\n.\n```\n$w = $fft->fft($result_data);```\n\nShould be replaced with:\n```\n$w = $fft->fft($result_data[$index]);```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Given all roots, how do I find the coefficients of a polynomial in time faster than O(n^2)?\r\n                \r\nGiven all the roots of a polynomial, I have to figure out an algorithm that generates the coefficients faster than O(n^2). I'm having trouble approaching this problem. I'm pretty sure I'm supposed to use the concept of a Fast Fourier Transform or Inverse Fourier Transform, but I don't know how to modify the input to not be the nth roots of unity. Can anyone point me in the right direction?\n    ", "Answer": "\r\nHere is an O(n * (log n)^2) solution:\n\n\nThe base case: for one root a, the answer is just x - a.\nLet's assume that we have a list of more than one root. We can solve the problem recursively for the first and the second half of the list and then multiply the results using Fast Fourier Transform.\n\n\nThe time complexity is obtained from the equation T(n) = 2 * T(n / 2) + O(n log n), which is O(n * (log n)^2) according to the Master theorem.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How can I use FFT (Fast Fourier Transform) with P5.js in React?\r\n                \r\nFollowing this tutorial, I tried to reproduce it in React JS to get an audio visualizer as in picture below.\n\nHere is my try, for this project I used ```\nreact-p5```\n and ```\np5.sound```\n:\n```\nimport Sketch from 'react-p5';\nimport 'p5/lib/addons/p5.sound';\n```\n\nLooking at the official repo documentation, everything seems correct to me:\n```\nthis.fft = new window.p5.FFT();\nvar wave = this.fft.waveform();\nconsole.log('wave ', wave);\n```\n\nSo why my variable ```\nwave```\n returns in console an array of 1024 elements of the same value (```\n0.0039215686274509665```\n)?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transformation Algorithm/Library for Motion Data in Processing? (REPOST)\r\n                \r\nI posted earlier about using Processing combined with the Leap Motion https://www.leapmotion.com/ in order to build an application that could detect hand tremor. I believe I will need to perform a FFT for this to work. Only one I know of in Processing is Minim but that is for sound data. I am fairly ignorant on this topic as of now (I have been watching youtube tutorials explaining how FFTs work all day I swear I'll be dreaming about it http://www.youtube.com/watch?v=TsMXQfnmOiQtonight) but from what I know so far I don't think Minim will work for my motion data.\n\nSo far I have used the Leap Motion api to record the following data into a csv file:\n\n\npalmVelocity — The speed of the palm in millimeters per second.\npalmPosition — The center of the palm measured in millimeters from\nthe Leap origin.\npalmNormal — A vector perpendicular to the plane formed by the palm\nof the hand. The vector points downward out of the palm.\ndirection — A vector pointing from the center of the palm toward the\nfingers.\nTime - in milliseconds\n\n\nFrom the little I have gained from the FFT tutorials and lurking stackoverflow, I believe this is all the data I need to do analysis (there are a bunch of other hand position data I could get too but I think these are all I need for this problem). So my specific questions are as follows:\n\n\nDo I need to do FFT in order to measure the changing hand movements\nto detect tremor (involuntary muscles movements usually caused by\nphysical disabilities). Please explain why.\nThe only FFT library in Processing is Minin that I know of, its\ndesigned for sound, so it will not work for my situation right?\nRecommend a library that could work for my situation.\n\n\nSomeone mentioned to me about Kiss FFT which is not audio-specific, but it's written in C which I would like to avoid at all cost lol (I'm already confused enough as it is).\n\nThanks in advance\n    ", "Answer": "\r\n\nI'm not sure if you have to run a FFT to detect tremor. Fourier transforms and autocorrelation functions are intimately related. You can get the same info about frequencies by looking at the autocorrelation function of your data, but I'm not sure that would be easier. Maybe - you wouldn't need to deal with complex numbers.\nI don't know.\nHave you looked into Apache Commons? I recommend the 2.2 library. I've heard the more recent version isn't as stable. I think after I downloaded the library to the libraries folder in Processing I had to rename it changing the dashes and dots to underscores and then create a folder titled \"Library\" within it, and then put the commons jar file in that.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT Example for J2me\r\n                \r\nAnybody can please provide me example or tutorial of FFT(Fast Fourier Transformation) for fetching audio frequency.\n    ", "Answer": "\r\nsplMeter has used FFT for fetchine audio frequency.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Access violation while trying to compute FFT (fast Fourier transform) of 2 images\r\n                \r\nI am trying to take FFT of two raw images. But I am getting ```\nunhandled exception (access violation)```\n - I could not figure out why. I am using fftw library.\nFirst I am reading two images, then I calculate FFT. But before it starts calculating, it produces access violation error.\n\n```\n#include \"stdafx.h\"\n#include <iostream>\n#include <conio.h>\n#include \"fftw3.h\"\n\n#define Width 2280\n#define Height 170\n\nunsigned char im2[170*2280];\nunsigned char im1[170*2280];\nfloat image1[170*2280];\nfloat image2[170*2280];\n\nusing namespace std;\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\n    FILE* fp1, *fp2;\n\n    //Read two images\n\n    fp1 = fopen (\"image1.raw\" , \"r\");\n    fread(im1, sizeof(unsigned char), Width* Height, fp1);\n\n    fp2 = fopen (\"image2.raw\" , \"r\");\n    fread(im2, sizeof(unsigned char), Width* Height, fp2);\n\n\n    fclose(fp2);\n    fclose(fp1);\n\n    //Typecasting two images into float\n\n    for (int i = 0; i < Width* Height; i++)\n    {       \n        image1[i]= (float)im1[i];\n        image2[i] = (float)im2[i];\n\n    }\n\n    fftwf_plan fplan1, fplan2;\n    fftwf_complex fft1[((Width/2)+1)*2];\n    fftwf_complex fft2[((Width/2)+1)*2];\n\n    fplan1 = fftwf_plan_dft_r2c_2d(Height, Width, (float*)image1, fft1, FFTW_ESTIMATE);\n    fftwf_execute(fplan1);\n    fftwf_destroy_plan(fplan1);\n\n    fplan2 = fftwf_plan_dft_r2c_2d(Height,Width, image2, (fftwf_complex*)fft2, FFTW_ESTIMATE);\n    fftwf_execute(fplan2);\n    fftwf_destroy_plan(fplan2);\n\n    _getch();\n    return 0;\n}\n```\n\n    ", "Answer": "\r\n```\nfft1```\n and ```\nfft2```\n are only large enough to hold one output row - you need ```\nHeight```\n rows. You'll probably want to allocate them dynamically too, as they will most likely be too large for the stack once you have the correct size, e.g.\n\n```\nfftwf_complex *fft1 = new fftwf_complex[((Width/2)+1)*2*Height];\nfftwf_complex *fft2 = new fftwf_complex[((Width/2)+1)*2*Height];\n```\n\n\nNB: don't forget to call ```\ndelete []```\n to free these later.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform (FFT) input and output to analyse the frequency of audio files in Java?\r\n                \r\nI have to use FFT to analyse the frequency of an audio file. But I don't know what the input and output is. \n\nDo I have to use 1-dimension, 2-dimension or 3-dimension array if I want to draw the spectrum's audio file? And can someone suggest me library for FFT on J2ME?\n    ", "Answer": "\r\n@thongcaoloi,\n\nThe simple answer regarding the dimensionality of your input data is: you need 1D data. Now I'll explain what that means.\n\nBecause you want to analyze audio data, your input to the discrete Fourier transform (DFT or FFT), is a 1-dimensional sequence of real numbers, which represents the changing voltage of the audio signal over time, and your audio file is a digital representation of that changing voltage over time. \n\nYour audio file was produced by sampling the voltage of a continuous audio signal at a fixed sampling rate (also known as the sampling frequency), typically 44.1 KHz for CD quality audio. \n\nBut your data file could have been sampled at a much lower frequency, so try to find out the sampling frequency of your data before you do an FFT on that data.\n\nSo now you have to extract the individual samples from your audio file.  If your file is stereo, it will have two separate sample sequences, one for the right channel and one for the left channel.  If the file is mono, it will have only one sample sequence.\n\nIf your file is stereo, or any other multi-channel audio format such as 5.1 or 7.1, you could FFT each channel separately, or you could combine any number of channels together using voltage addition. That's up to you, and depends on what you're trying to do with your FFT results.\n\nThe output of the DFT or FFT is a sequence of complex numbers. Each complex number is a pair consisting of a real-part and an imaginary-part, typically shown as a pair (re,im).\n\nIf you want to graph the power spectral density of your audio file, which is what most people want from the FFT, you'll graph 20*log10( sqrt( re^2 + im^2 ) ), using the first N/2 complex numbers of the FFT output, where N is the number of input samples to the FFT.\n\nYou can try to build your own spectrum analyzer software program, but I suggest using something that's already built and tested.\n\nThese two FFT spectrum analyzers give results instantly, and have built-in IFFT synthesis, meaning that you can inverse Fourier transform the frequency-domain spectral data to reconstruct the original signal in the time-domain.\n\nhttp://www.mathworks.com/help/techdoc/ref/fft.html\n\nhttp://www.sooeet.com/math/fft.php\n\nThere's a lot more to this topic, and to the subject of digital signal processing in general, but this brief introduction, should get you started.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Where to start with Fourier Analysis\r\n                \r\nI'm reading data from the microphone and want to perform some analysis on it. I'm attempting to generate a spectrum analyser something like this:\n\n\n\nWhat I have at the moment is this:\n\n\n\nMy understanding is that I need to perform a Fourier analysis - a Fast Fourier Transform ? - to extract the component frequencies and their amplitudes.\n\nCan someone confirm my understanding is correct and exactly what type of Fourier transform I need to apply? \n\nAt the moment, I'm getting frames containing 4k samples from the mic (using NAudio). The buffer I've got is 16bits/sample (Signed Short). For reference, the above plot shows approx half a frame\n\nI'm coding in VB so any .Net libraries/examples (preferably on NuGet) would be of most use. I believe implementations vary considerably so the less I have to massage my data, the better.\n    ", "Answer": "\r\nThe top plot is that of a spectrograph, where each vertical time line is colored based on the magnitudes of the result from an FFT (likely windowed) of a slice in time (possibly overlapped) of the input waveform.  The number of vertical points to plot (the frequency resolution) is related to the length of the FFT.  Almost any FFT will do.  If you use the most common complex-to-complex FFT, just set the imaginary portion of each complex input sample to zero, copy a slice in time of samples of your input waveform to the \"real\" part, FFT, and take the magnitude or log magnitude of each complex result bin, then map these values to colors per your preference.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fftw and online DFT calculator get different results\r\n                \r\nI calculated the FFT of array {1,2,3,4,5,6} with fftw/C++ and an online calculator (http://calculator-fx.com/calculator/fast-fourier-transform-calculator-fft/1d-discrete-fourier-transform). And the results seemed to be a bit different.\n\nfftw output:\n\n\n```\n0     21.000000      0.000000\n1     -3.000000      5.196152\n2     -3.000000      1.732051\n3     -3.000000      0.000000\n4      0.000000      0.000000\n5      0.000000      0.000000\n```\n\n\n\nOnline calculator output:\n\n\n```\n 21 + 0j\n -3 + 5.196152j\n -3 + 1.732051j\n -3 + 0j\n -3 - 1.732051j\n -3 - 5.196152j\n```\n\n\n\nAs is shown above, the latter two results of fftw turned to be zero.\nCan't figure out why. Could anybody help me out? Thanks.\n\n[EDITED]\ncpp code:\n\n```\nint main()\n{\n    fftw_complex *out;\n    fftw_plan plan;\n\n    double arr[]={1,2,3,4,5,6};\n    int n = sizeof(arr)/sizeof(double);\n\n    out = (fftw_complex*)fftw_malloc ( sizeof ( fftw_complex ) * n );\n    plan = fftw_plan_dft_r2c_1d ( n, arr, out, FFTW_ESTIMATE );\n    fftw_execute ( plan );\n\n    for (int i = 0; i < n; i++ )\n    {\n        printf ( \"  %3d  %12lf  %12lf\\n\", i, out[i][0], out[i][1] );\n    }\n\n    fftw_free(out);\n    fftw_destroy_plan(plan);\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nOh, you're using the R2C mode (don't know why I didn't think of that before).  That only writes n/2 + 1 results, because of the symmetry.\n\nThis behaviour is documented: http://www.fftw.org/doc/One_002dDimensional-DFTs-of-Real-Data.html.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Acoustic signal processing using Python\r\n                \r\nI am new to python & its libraries and need some guide. I have measured time domain signals (volts) and need to upload this data to python and do a a fast fourier transform \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "C++ and C# Array and Void Conversion\r\n                \r\nI'm converting C++ code to C# code, it happens to be the Fast Fourier Transform on an image in the Frequency Domain. Just to give some context.\n\nHere is a link to the C++ Code : fft.cc\n\nI have this function called Step, its signature is this in C++:\n\n```\nvoid step ( int n, int mj, float a[], float b[], float c[], float d[], float w[], float sgn );\n```\n\n\nand is called like this:\n\n```\nstep ( n, mj, &x[0*2+0], &x[(n/2)*2+0], &y[0*2+0], &y[mj*2+0], w, sgn );\n```\n\n\nI want to convert it to C#, now this function operates on either Y or X arrays depending on whether its a Forward Fast Fourier Transform or a Backward Fast Fourier Transform. (More context)\n\nWhat I don't understand, is that in C#, doing ```\nx[0*2+0]```\n does nothing.... firstly putting an integer in the square brackets actually calls for a variable at a position in that array.\n\nBut what is it doing in C++, I know that the ```\n&```\n is equiv to the ```\nref```\n C# keyword, it is saying get the contents from the array that is being pointed too, but I feel that in this context it means more than just that.\n\nSo how would you call that function in C#, obviously this fails:\n\n```\nstep(n, mj, x[0 * 2 + 0], x[(n / 2) * 2 + 0], y[0 * 2 + 0], y[mj * 2 + 0], w, sgn);\n```\n\n    ", "Answer": "\r\nIn C++, this is passing the address of an entry of the array to the function. This doesn't work in C#, because you cannot take the address of an entry of an array. I suggest rewriting the declaration to pass the indices only and pass the array separately. Or make the x and y array a member of the containing class. \n\nUh, or if you're only interested in the single element, you could pass the element instead. Remember that float b[] in C++ is the same as float* b, so if skip only accesses b[0] (and not [b+1]), then that would probably be the easier solution).\n\nWhen we have a C++ declaration like\n\n```\nvoid step (float a[]) \n```\n\n\nwhich is the same as \n\n```\nvoid step (float* a)\n```\n\n\nAnd we call it with \n\n```\nstep(&x[2]);\n```\n\n\nThe function step sees an array of float that starts at the second entry of x. So, inside step\n\n```\nfloat f = a[0];\n```\n\n\nwould refer to the element at x[2];\n\nOf course, one could also address ```\na[27]```\n, but that's prone for errors, since we do not know the (remaining) length of x.\n\nTo help finding the optimal solution in this case, one needs to know what step does with the arguments. Would it be possible to post the step function or parts of it?\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "building a shared library using android studio ( regarding FFMPEG/Libav Fast Fourier Transform)\r\n                \r\nI'm building some software for android and I'm desperately in need of a faster FFT function than I am currently using.\n\nAfter researching I found that libav/FFMPEG have really good FFT functions tailored for the ARM architecture.\n\n1) What is the most straight forward way to build either libraries as a .SO?\n(There's so much info out there I'm overwhelmed)\n\n2) Since I ONLY need access to the FFT, would it be possible to simple build that c class, license permitting? Last I checked there was some ARM code so that may complicate it.\n\nAny help is greatly appreciated! \n    ", "Answer": "\r\nYou can use a FFT lib to improve your software performance. The fastest libs right now are fftw  and Ne10. Ne10 is easier to compile. You can find the compile guide in Ne10 page building.md\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Understanding Matlab FFT example\r\n                \r\nI am new to matlab and FFT and want to understand the Matlab FFT example.\nFor now I have two main questions:\n\n1) Why does the x-axis (frequency) end at 500? How do I know that there aren't more frequencies or are they just ignored?\n\n2) How do I know the frequencies are between 0 and 500? Shouldn't the FFT tell me, in which limits the frequencies are? Does the FFT only return the amplitude value without the frequency?\n\nThanks for any hint!\n\n\n\nExample in question:\n\nConsider data sampled at 1000 Hz. Form a signal containing a 50 Hz sinusoid of amplitude 0.7 and 120 Hz sinusoid of amplitude 1 and corrupt it with some zero-mean random noise:\n\n```\nFs = 1000;                    % Sampling frequency\nT = 1/Fs;                     % Sample time\nL = 1000;                     % Length of signal\nt = (0:L-1)*T;                % Time vector\n% Sum of a 50 Hz sinusoid and a 120 Hz sinusoid\nx = 0.7*sin(2*pi*50*t) + sin(2*pi*120*t); \ny = x + 2*randn(size(t));     % Sinusoids plus noise\nplot(Fs*t(1:50),y(1:50))\ntitle('Signal Corrupted with Zero-Mean Random Noise')\nxlabel('time (milliseconds)')\n```\n\n\n\n\nConverting to the frequency domain, the discrete Fourier transform of the noisy signal y is found by taking the fast Fourier transform (FFT):\n\n```\nNFFT = 2^nextpow2(L); % Next power of 2 from length of y\nY = fft(y,NFFT)/L;\nf = Fs/2*linspace(0,1,NFFT/2+1);\n\n% Plot single-sided amplitude spectrum.\nplot(f,2*abs(Y(1:NFFT/2+1))) \ntitle('Single-Sided Amplitude Spectrum of y(t)')\nxlabel('Frequency (Hz)')\nylabel('|Y(f)|')\n```\n\n\n\n    ", "Answer": "\r\n\n  1) Why does the x-axis (frequency) end at 500? How do I know that there aren't more frequencies or are they just ignored?\n\n\nIt ends at 500Hz because that is the Nyquist frequency of the signal when sampled at 1000Hz. Look at this line in the Mathworks example:\n\n```\nf = Fs/2*linspace(0,1,NFFT/2+1);\n```\n\n\nThe frequency axis of the second plot goes from 0 to Fs/2, or half the sampling frequency.\nThe Nyquist frequency is always half the sampling frequency, because above that, aliasing occurs:  \n\nThe signal would \"fold\" back on itself, and appear to be some frequency at or below 500Hz.\n\n\n  2) How do I know the frequencies are between 0 and 500? Shouldn't the FFT tell me, in which limits the frequencies are? \n\n\nDue to \"folding\" described above (the Nyquist frequency is also commonly known as the \"folding frequency\"), it is physically impossible for frequencies above 500Hz to appear in the FFT; higher frequencies will \"fold\" back and appear as lower frequencies.\n\n\n  Does the FFT only return the amplitude value without the frequency?\n\n\nYes, the MATLAB FFT function only returns one vector of amplitudes. However, they map to the frequency points you pass to it.\n\nLet me know what needs clarification so I can help you further.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Use Digital Signal Processors to accelerate calculations in the same fashion than GPUs\r\n                \r\nI read that several DSP cards that process audio, can calculate very fast Fourier Transforms and some other functions involved in Sound processing and others. There are some scientific problems (not many), like Quantum mechanics, that involver Fourier Transform calculations. I wonder if DSP could be used to accelerate calculations in this fashion, like GPUs do in some other cases, and if you know succcessful examples.\n\nThanks\n    ", "Answer": "\r\nAny linear operations are easier and faster to do on DSP chips. Their architecture allows you to perform a linear operation (take two numbers, multiply each of them by a constant and add the results) in a single clock cycle. This is one of the reasons FFT can be calculated so quickly on a DSP chip. This is also a reason many other linear operations can be accelerated with their use. I guess I have three main points to make concerning performance and code optimization for such processors.\n\n1) Perhaps less relevant, but I'd like to mention it nonetheless. In order to take full advantage of DSP processor's architecture, you have to code in Assembly. I'm pretty sure that regular C code will not be fully optimized by the compiler to do what you want. You literally have to specify each register, etc. It does pay off, however. The same way, you are able to make use of circular buffers and other DSP-specific things. Circular buffers are also very useful for calculating the FFT and FFT-based (circular) convolution.\n\n2) FFT can be found in solutions to many problems, such as heat flow (Fourier himself actually came up with the solution back in the 1800s), analysis of mechanical oscillations (or any linear oscillators for that matter, including oscillators in quantum physics), analysis of brain waves (EEG), seismic activity, planetary motion and many other things. Any mathematical problem that involves convolution can be easily solved via the Fourier transform, analog or discrete.\n\n3) For some of the applications listed above, including audio processing, other transforms other than FFT are constantly being invented, discovered, and applied to processing, such as Mel-Cepstrum (e.g. MPEG codecs), wavelet transform (e.g. JPEG2000 codecs), discrete cosine transform (e.g. JPEG codecs) and many others. In quantum physics, however, the Fourier Transform is inherent in the equation of angular momentum. It arises naturally, not just for the purposes of analysis or easy of calculations. For this reason, I would not necessarily put the reasons to use Fourier Transform in audio processing and quantum mechanics into the same category. For signal processing, it's a tool; for quantum physics, it's in the nature of the phenomenon.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Improving the speed of FFT Implementation\r\n                \r\nI'm a beginner in programming and am currently trying to work on a project requiring Fast Fourier Transform implementation.\n\nI have so far managed to implement the following:\n\nDoes anyone have any alternatives and suggestions to improve the speed of the program without losing out on accuracy.\n\n```\nshort FFTMethod::FFTcalc(short int dir,long m,double *x,double *y)\n{\nlong n,i,i1,j,k,i2,l,l1,l2;\ndouble c1,c2,tx,ty,t1,t2,u1,u2,z;\n\n/* Calculate the number of points */\nn = 1;\nfor (i=0;i<m;i++) \n    n *= 2;\n\n/* Do the bit reversal */\ni2 = n >> 1;\nj = 0;\nfor (i=0;i<n-1;i++) {\n  if (i < j) {\n     tx = x[i];\n     ty = y[i];\n     x[i] = x[j];\n     y[i] = y[j];\n     x[j] = tx;\n     y[j] = ty;\n  }\n  k = i2;\n  while (k <= j) {\n     j -= k;\n     k >>= 1;\n  }\n  j += k;\n}\n\n/* Compute the FFT */\nc1 = -1.0; \nc2 = 0.0;\nl2 = 1;\nfor (l=0;l<m;l++) {\n   l1 = l2;\n   l2 <<= 1;\n   u1 = 1.0; \n   u2 = 0.0;\n   for (j=0;j<l1;j++) {\n     for (i=j;i<n;i+=l2) {\n        i1 = i + l1;\n        t1 = u1 * x[i1] - u2 * y[i1];\n        t2 = u1 * y[i1] + u2 * x[i1];\n        x[i1] = x[i] - t1; \n        y[i1] = y[i] - t2;\n        x[i] += t1;\n        y[i] += t2;\n     }\n     z =  u1 * c1 - u2 * c2;\n     u2 = u1 * c2 + u2 * c1;\n     u1 = z;\n   }\n   c2 = sqrt((1.0 - c1) / 2.0);\n   if (dir == 1) \n     c2 = -c2;\n     c1 = sqrt((1.0 + c1) / 2.0);\n  }\n\n/* Scaling for forward transform */\nif (dir == 1) {\n   for (i=0;i<n;i++) {\n      x[i] /= n;\n      y[i] /= n;\n   }\n } \n\n\n   return(1);\n}\n```\n\n    ", "Answer": "\r\nI recently found this excellent PDF on the Construction of a high performance FFTs by Eric Postpischil. Having developed several FFTs myself I know how hard it is to compete with commercial libraries. Believe me you're doing well if your FFT is only 4x slower than Intel or FFTW, not 40x! You can however compete, and here's how. \n\nTo summarise that article, the author states that Radix2 FFTs are simple but inefficient, the most efficient construct is the radix4 FFT. An even more efficient method is the Radix8 however this often does not fit into the registers on a CPU so Radix4 is preferred. \n\nFFTs can be constructed in stages, so to compute a 1024 point FFT you could perform 10 stages of the Radix2 FFT (as 2^10 - 1024), or 5 stages of the Radix4 FFT (4^5 = 1024). You could even compute a 1024 point FFT in stages of 8*4*4*4*2 if you so choose. Fewer stages means fewer reads and writes to memory (the bottleneck for FFT performance is memory bandwidth) hence dynamically choosing radix 4, 8 or higher is a must. The Radix4 stage is particulary efficient as all weights are 1+0i, 0+1i, -1+0i, 0-1i and Radix4 butterfly code can be written to fit entirely in the cache. \n\nSecondly, each stage in the FFT is not the same. The first stage the weights are all equal to 1+0i. there is no point computing this weight and even multiplying by it as it is a complex multiply by 1, so the first stage may be performed without weights. The final stage may also be treated differently and can be used to perform the Decimation in Time (bit reversal). Eric Postpischil's document covers all this. \n\nThe weights may be precomputed and stored in a table. Sin/cos calculations take around 100-150 cycles each on x86 hardware so precomputing these can save 10-20% of the overall compute time as memory access is in this case faster than CPU calculations. Using fast algorithms to compute sincos in one go is particularly beneficial (Note that cos is equal to sqrt(1.0 - sine*sine), or using table lookups, cos is just a phase shift of sine). \n\nFinally once you have your super streamlined FFT implementation you can utilise SIMD vectorization to compute 4x floating point or 2x double floating point operations per cycle inside the butterfly routine for another 100-300% speed improvement. Taking all of the above you'd have yourself a pretty slick and fast FFT!\n\nTo go further you can perform optimisation on the fly by providing different implementations of the FFT stages targeted to specific processor architectures. Cache size, register count, SSE/SSE2/3/4 instruction sets etc differ per machine so choosing a one size fits all approach is often beaten by targeted routines. In FFTW for instance many smaller size FFTs are highly optimised unrolled (no loops) implementations targeted for a specific architecture. By combining these smaller constructs (such as RadixN routines) you can choose the fastest and best routine for the task at hand. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "\"invalid expression\" running gnuplot in bash script\r\n                \r\nI am running this program SCRIPT.sh,\n```\n#!/bin/bash \nFFT_FILE=\"$(find . -type f -iname \"HR*.fft\")\" \nFFT_FILE1=$FFT_FILE\".GNUPLOT\" \nod -f -v -w8 $FFT_FILE > $FFT_FILE1 \ngnuplot -persist <<-EOFMarker \n    reset \n    set term postscript enh \n    set out 'FFT_1.ps' \n    set xlabel 'Frequency (Hz)' \n    set key box \n    filename=\"$FFT_FILE1\" \n    stats filename nooutput\n    max_row = STATS_records \n    plot [(1000.0/4880.0):(1000.0/59.0)] filename u ($0/(max_row*81.92e-6)):(sqrt(($2*$2)+($3*$3))) w l lw 3 title \"FFT\"\n    reset\nEOFMarker\n```\n\nbut the output comes as\n```\ngnuplot> plot [(1000.0/4880.0):(1000.0/59.0)] filename u (./SCRIPT.sh/(max_row*81.92e-6)):(sqrt((*)+(*))) w l lw 3 title \"FFT\"\n                                                           ^\n    line 0: invalid expression\n```\n\nMay I request for detailed explanation and help regarding this situation?\nThe \"HR*.fft\" file contains the results of Fast Fourier Transform from PRESTO in binary.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Java how do I convert a byte[] containing multiple doubles into a double[]\r\n                \r\nI have a sound file that I am practicing phase vocoding on. I have converted the bytes of the file into a double[] and manipulated the wave form of that file through a Fast Fourier Transform and inverse Fast Fourier Transform. The issue is now I need to convert the byte[] back into a double. Here are some useful code fragments:\n\nHow I converted the data in the first place:\n\n```\n/**\n * Converts bytes from a TargetDataLine into a double[] allowing the information to be read.\n * NOTE: One byte is lost in the conversion so don't expect the arrays to be the same length!\n * @param bufferData The buffer read in from the target Data Line\n * @return the double[] that the buffer has been converted into.\n */\n   private static double[] bytesToDoubleArray(byte[] bufferData){\n    final int bytesRecorded = bufferData.length;\n    final int bytesPerSample = getAudioFormat().getSampleSizeInBits()/8; \n    final double amplification = 100.0; // choose a number as you like\n    double[] micBufferData = new double[bytesRecorded - bytesPerSample + 1];\n    for (int index = 0, floatIndex = 0; index < bytesRecorded - bytesPerSample + 1; index += bytesPerSample, floatIndex++) {\n        double sample = 0;\n        for (int b = 0; b < bytesPerSample; b++) {\n            int v = bufferData[index + b];\n            if (b < bytesPerSample - 1 || bytesPerSample == 1) {\n                v &= 0xFF;\n            }\n            sample += v << (b * 8);\n        }\n        double sample32 = amplification * (sample / 32768.0);\n        micBufferData[floatIndex] = sample32;\n\n    }\n    return micBufferData;\n}\n```\n\n\nand what I am doing to the data:\n\n```\npublic static byte[] shift(byte[] data, int factor){\n    double[] audioData = bytesToDoubleArray(data);\n    audioData = Arrays.copyOf(audioData, roundToPowerOf2(audioData.length));\n    Complex[] transformed = FFT.fft(doubleToComplex(audioData));\n    transformed = shiftArray(transformed, 3);\n    Complex[] reverted = FFT.ifft(transformed);\n    for(int i = 0; i<reverted.length; i++){\n        audioData[i] = reverted[i].re();\n    }\n    return null;//How do I convert audioData[] back into a byte[]????\n}\n```\n\n\nAny ideas on how to remedy this problem? Any solutions would be greatly appreciated. Also any Java libraries that already implement phase vocoding would be awesome as well. \n    ", "Answer": "\r\nHere it is, approximately.  I'm sure I've screwed something up.  scaleFactor would presumably be 327.68, to reverse the scaling above.  The above code appears to be big endian.  Whether you want fullNormalize is up to you.\n\n```\npublic byte[] doubleArrayToByteArray(double[] input, int bytesPerSample, double scaleFactor, boolean fullNormalize, boolean bigEndian) {\n    byte[] result = new byte[input.length * bytesPerSample];\n    performNormalization(input, scaleFactor, fullNormalize);\n    for (int i = 0; i < input.length; i++) {\n        long sourceVal = (long)(input[i] * scaleFactor);\n        sourceVal = sourceVal >> 8 * (8 - bytesPerSample);\n        for (int j = 0; j < bytesPerSample; j++) {\n            int index = i * bytesPerSample;\n            if (bigEndian) {\n                index += (bytesPerSample - j);\n            }\n            else {\n                index += j;\n            }\n            result[index] = (byte) sourceVal;\n            sourceVal = sourceVal >> 8;\n        }\n    }\n    return result;\n}\n\npublic void performNormalization(double[] input, double scaleFactor, boolean fullNormalize) {\n    double maxVal = 0.0;\n    for (int i = 0; i < input.length; i++) {\n        double val = Math.abs(input[i]) * scaleFactor;\n        if (val > maxVal) {\n            maxVal = val;\n        }\n    }\n    if (fullNormalize || maxVal > Long.MAX_VALUE) {\n        double normalizeFactor = (double)(Long.MAX_VALUE) / maxVal;\n        for (int i = 0; i < input.length; i++) {\n            input[i] *= normalizeFactor;\n        }\n    }\n}\n```\n\n\nUpdated: Realized that I needed to account for scaleFactor in normalization.  And you'd not normally specify both a ```\nscaleFactor```\n that was not 1.0 and ```\nfullNormalize = true```\n.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python - Memory Error whilst loading values to get a fourier transform\r\n                \r\nI'm loading in a 500000 kb (0.5Gb) text file of a single column which consists of a series of voltages read in via a daq card.\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy as sp\nimport scipy.fftpack as spf\n\nFile = np.loadtxt('testinghpython.txt')\n\nvolt = File[:]\n\nFFTX = abs(sp.fft(volt))\nfreqx = spf.fftfreq(len(volt),dt)\n\nplt.figure(2)\nplt.grid()\nplt.title('Fast fourier Transform of Voltage')\nplt.xlabel('Frequency')\nplt.ylabel('Amplitude')\nplt.plot(freqx,10*np.log10(FFTX))\nplt.clf\n\nplt.show()\n```\n\n\nHowever I'm getting the error\n\n```\n    X.append(items)\nMemoryError\n```\n\n\nI assume this is because it's a large dataset.\n\nIs there anyway to go ahead and calculate the fourier transform without reading them all into memory? Or does this require me reading in the entire text file into memory? This pc has about 8gb of RAM so I'm not entirely sure as to how to get it to use the rest of the available memory. I think I'm on 32 bit spyder, will I have to switch to 64 bit?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Pass WAVE PCM byte array to FFT for pitch detection\r\n                \r\nI did the code up to finding the PCM Data from a audio file. How should i apply these data to the Fast Fourier Transform Algorithm? Are there more things to consider before applying the byte array to FFT algorithm. \n\n```\npublic static void main(String[] args) throws FileNotFoundException, IOException {\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(\"adios.wav\"));\n\n    int read;\n    byte[] buff = new byte[1024];\n        while ((read = in.read(buff)) > 0)\n        {\n            out.write(buff, 0, read);\n        }\n        out.flush();\n        byte[] audioBytes = out.toByteArray();\n\n        for(int i=0; i<audioBytes.length;i++){\n            System.out.println(audioBytes[i]);\n        }\n}\n```\n\n    ", "Answer": "\r\nYou need to skip the wav header and transform the PCM samples to float values between -1 and 1. For example for a byte array with PCM wav with 16 bits per sample and little endian the following conversion is needed (from ```\ncom.sun.media.sound.AudioFloatConverter```\n):\n\n```\npublic float[] toFloatArray(byte[] in_buff, int in_offset,\n  float[] out_buff, int out_offset, int out_len) {\n        int ix = in_offset;\n        int len = out_offset + out_len;\n        for (int ox = out_offset; ox < len; ox++) {\n            out_buff[ox] = ((short) ((in_buff[ix++] & 0xFF) | \n                       (in_buff[ix++] << 8))) * (1.0f / 32767.0f);\n        }\n        return out_buff;\n    }\n```\n\n\nAfter this call you end up with a ```\nfloat[]```\n that can be used for an FFT analysis. \n\nTo make this more easy the JVM includes the ```\nAudioSystem```\n and ```\nAudioInputStream```\n classes.\n\nThe source code of TarsosDSP, a Java audio processing library, is full of examples. The TarosDSP manual explains the relation between PCM data and workable samples.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Setting up a spectrum analyser in iPhone using Accelerate framework\r\n                \r\nHow to set up a spectrum analyser for an audio file? \n\nI understand that i must get the data, and then apply a FFT and then show the spectrum analyser for the frequencies.\n\nBut how to get the data? of the playing audio file? Should I use the AudioQueue service to get the data via the call back ? And then use the data from the obtained call back to apply Fast Fourier transform? how to apply fast Fourier transform in a simple way to suit my needs\n\nI read this post Using the Apple FFT and Accelerate Framework\n\nbut still require lot of clarifications, and cannot find any documentation clear enough\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Speeding up Berlekamp Welch algorithm using FFT for Shamir Secret Share\r\n                \r\nI believe the Berlekamp Welch algorithm can be used to correctly construct the secret using Shamir Secret Share as long as $t<n/3$. How can we speed up the BW algorithm implementation using Fast Fourier transform?\n    ", "Answer": "\r\nBerlekamp Welch is used to correct errors for the original encoding scheme for Reed Solomon code, where there is a fixed set of data points known to encoder and decoder, and a polynomial based on the message to be transmitted, unknown to the decoder. This approach was mostly replaced by switching to a BCH type code where a fixed polynomial known to both encoder and decoder is used instead.\nBerlekamp Welch inverts a matrix with time complexity O(n^3). Gao improved on this, reducing time complexity to O(n^2) based on extended Euclid algorithm. Note that the R[-1] product series is pre-computed based on the fixed set of data points, in order to achieve the O(n^2) time complexity. Link to the Wiki section on \"original view\" decoders.\nhttps://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Reed_Solomon_original_view_decoders\nDiscreet Fourier essentially is the same as the encoding process, except there is a constraint on the fixed data points for encoding (they need to be successive powers of the field primitive) in order for the inverse transform to work. The inverse transform only works if the received data is error free. Lagrange interpolation doesn't have the constraint on the data points, and doesn't require the received data to be error free. Wiki has a section on this also:\nhttps://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Discrete_Fourier_transform_and_its_inverse\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Given MP3, is it possible to break out different instruments using Fast Fourier transform (FFT)?\r\n                \r\nI am working on a music visualizer and I'd like to display a different visual element for each instrument.  For example, blue bar representing vocal, red bar representing guitar, yellow bar representing drums, etc.\n\nIs there a way to analyze the results of FFT to get this information?\n\nThanks.\n    ", "Answer": "\r\nThis is a challenge that's an active area of research in music technology.\n\nIt's possible, to an extent, but it's certainly not easy. It will be especially difficult using mp3 as a lot of important information is lost in compression.\n\nWhat you're trying to do is known as Audio Source Separation, or Sound Source Separation. It pursues the separation of an audio recording into its constituent elements. \n\nThese elements could be speech (several people talking at the same time - the 'cocktail party problem') or instruments (separating one instrument from another in a recording 'blind demixing').\n\nThere's various approaches you could take, some of these are based on the frequency domain characteristics of sound and others are based on spatial properties.\n\nThe frequency domain approach might appear fairly straightforward if you're trying to separate a bass drum and a flute (i.e. the low frequency bins of your FFT would be the bass drum and the higher frequency bins assigned to the flute) however in reality sounds are rarely neatly segregated into useful frequency regions. The bass drum for example will have harmonic content right the way up the frequency spectrum. These types of solutions are hence very mathematically complicated and often involves statistical modeling. Heavy stuff.\n\nSeparation based on spatial properties of sound often relies on some prior knowledge of where each source was before recording (this is 'non-blind'). It's often necessary to have more than one microphone (stereo recording at least). Using some clever maths it's possible to approach separating the sources based on a knowledge of where the source is in space, based on the relationship of the signals at each microphone. This is also the basis for a technique called beamforming, by which the position of a source can be determined using an array of microphones.\n\nSo, back on track. People are trying to do it, but it's complicated, and using mp3 will make your life difficult!\n\nI'm afraid I don't really know enough to explain the approaches better, but I can find a few references to get you started:\n\nhttp://www.cs.tut.fi/~tuomasv/demopage.html \n\nhttp://www.cs.northwestern.edu/~pardo/courses/eecs352/lectures/source%20separation.pdf (pdf warning!)\n\nGood luck!\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Graphing the pitch (frequency) of a sound\r\n                \r\nI want to plot the pitch of a sound into a graph.\n\nCurrently I can plot the amplitude. The graph below is created by the data returned by ```\ngetUnscaledAmplitude()```\n:\n\n\n\n```\nAudioInputStream audioInputStream = AudioSystem.getAudioInputStream(new BufferedInputStream(new FileInputStream(file)));\nbyte[] bytes = new byte[(int) (audioInputStream.getFrameLength()) * (audioInputStream.getFormat().getFrameSize())];\naudioInputStream.read(bytes);\n\n// Get amplitude values for each audio channel in an array.\ngraphData = type.getUnscaledAmplitude(bytes, 1);\n\n\npublic int[][] getUnscaledAmplitude(byte[] eightBitByteArray, int nbChannels)\n{\n    int[][] toReturn = new int[nbChannels][eightBitByteArray.length / (2 * nbChannels)];\n    int index = 0;\n\n    for (int audioByte = 0; audioByte < eightBitByteArray.length;)\n    {\n        for (int channel = 0; channel < nbChannels; channel++)\n        {\n            // Do the byte to sample conversion.\n            int low = (int) eightBitByteArray[audioByte];\n            audioByte++;\n            int high = (int) eightBitByteArray[audioByte];\n            audioByte++;\n            int sample = (high << 8) + (low & 0x00ff);\n\n            toReturn[channel][index] = sample;\n        }\n        index++;\n    }\n\n    return toReturn;\n}\n```\n\n\nBut I need to show the audio's pitch, not amplitude. Fast Fourier transform appears to get the pitch, but it needs to know more variables than the raw bytes I have, and is very complex and mathematical.\n\nIs there a way I can do this?\n    ", "Answer": "\r\nFrequency (an objective metric) is not the same as pitch (a subjective quantity). In general, pitch detection is a very tricky problem.\n\nAssuming you just want to graph the frequency response for now, you have little choice but to use the FFT, as it is THE method to obtain the frequency response of time-domain data.  (Well, there are other methods, such as the discrete cosine transform, but they're just as tricky to implement, and more tricky to interpret).\n\nIf you're struggling with the implementation of the FFT, note that it's really just an efficient algorithm for calculating the discrete Fourier transform (DFT); see http://en.wikipedia.org/wiki/Discrete_Fourier_transform.  The basic DFT algorithm is much easier (just two nested loops), but runs a lot slower (O(N^2) rather than O(N log N)).\n\nIf you wish to do anything more complex than simply plotting frequency content (like pitch detection, or windowing (as others have suggested)), I'm afraid you are going to have learn what the maths means.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fft division for fast polynomial division\r\n                \r\nI'm trying to implement fast polynomial division using Fast Fourier Transform (fft).\n\nHere is what I have got so far:\n\n```\nfrom numpy.fft import fft, ifft\ndef fft_div(C1, C2):\n    # fft expects right-most for significant coefficients\n    C1 = C1[::-1]\n    C2 = C2[::-1]\n    d = len(C1)+len(C2)-1\n    c1 = fft(list(C1) + [0] * (d-len(C1)))\n    c2 = fft(list(C2) + [0] * (d-len(C2)))\n    res = list(ifft(c1-c2)[:d].real)\n    # Reorder back to left-most and round to integer\n    return [int(round(x)) for x in res[::-1]]\n```\n\n\nThis works well for polynomials of same length, but if length is different then the result is wrong (I benchmark against RosettaCode's ```\nextended_synthetic_division()```\n function):\n\n```\n# Most signficant coefficient is left\nN = [1, -11, 0, -22, 1]\nD = [1, -3, 0, 1, 2]\n# OK case, same length for both polynomials\nfft_div(N, D)\n>> [0, 0, 0, 0, 0, -8, 0, -23, -1]\nextended_synthetic_division(N, D)\n>> ([1], [-8, 0, -23, -1])\n\n# NOT OK case, D is longer than N (also happens if shorter)\nD = [1, -3, 0, 1, 2, 20]\nfft_div(N, D)\n>> [0, 0, 0, 0, -1, 4, -11, -1, -24, -19]\nextended_synthetic_division(N, D)\n>> ([], [1, -11, 0, -22, 1])\n```\n\n\nWhat is weird is that it seems it's very close, but still a bit off. What did I do wrong? In other words: how to generalize fast polynomial division (using FFT) to vectors of different sizes.\n\nAlso bonus if you can tell me how to compute the division quotient (currently I only have the remainder).\n    ", "Answer": "\r\nHere's a direct implementation of a fast polynomial division algorithm found in these lecture notes.\nThe division is based on the fast/FFT multiplication of dividend with the divisor's reciprocal. My implementation below strictly follows the algorithm proven to have ```\nO(n*log(n))```\n time complexity (for polynomials with degrees of the same order of magnitude), but it's written with emphasis on readability, not efficiency.\n```\nfrom math import ceil, log\nfrom numpy.fft import fft, ifft\n\ndef poly_deg(p):\n    return len(p) - 1\n\n\ndef poly_scale(p, n):\n    \"\"\"Multiply polynomial ``p(x)`` with ``x^n``.\n    If n is negative, poly ``p(x)`` is divided with ``x^n``, and remainder is\n    discarded (truncated division).\n    \"\"\"\n    if n >= 0:\n        return list(p) + [0] * n\n    else:\n        return list(p)[:n]\n\n\ndef poly_scalar_mul(a, p):\n    \"\"\"Multiply polynomial ``p(x)`` with scalar (constant) ``a``.\"\"\"\n    return [a*pi for pi in p]\n\n\ndef poly_extend(p, d):\n    \"\"\"Extend list ``p`` representing a polynomial ``p(x)`` to\n    match polynomials of degree ``d-1``.\n    \"\"\"\n    return [0] * (d-len(p)) + list(p)\n\n\ndef poly_norm(p):\n    \"\"\"Normalize the polynomial ``p(x)`` to have a non-zero most significant\n    coefficient.\n    \"\"\"\n    for i,a in enumerate(p):\n        if a != 0:\n            return p[i:]\n    return []\n\n\ndef poly_add(u, v):\n    \"\"\"Add polynomials ``u(x)`` and ``v(x)``.\"\"\"\n    d = max(len(u), len(v))\n    return [a+b for a,b in zip(poly_extend(u, d), poly_extend(v, d))]\n\n\ndef poly_sub(u, v):\n    \"\"\"Subtract polynomials ``u(x)`` and ``v(x)``.\"\"\"\n    d = max(len(u), len(v))\n    return poly_norm([a-b for a,b in zip(poly_extend(u, d), poly_extend(v, d))])\n\n\ndef poly_mul(u, v):\n    \"\"\"Multiply polynomials ``u(x)`` and ``v(x)`` with FFT.\"\"\"\n    if not u or not v:\n        return []\n    d = poly_deg(u) + poly_deg(v) + 1\n    U = fft(poly_extend(u, d)[::-1])\n    V = fft(poly_extend(v, d)[::-1])\n    res = list(ifft(U*V).real)\n    return [int(round(x)) for x in res[::-1]]\n\n\ndef poly_recip(p):\n    \"\"\"Calculate the reciprocal of polynomial ``p(x)`` with degree ``k-1``,\n    defined as: ``x^(2k-2) / p(x)``, where ``k`` is a power of 2.\n    \"\"\"\n    k = poly_deg(p) + 1\n    assert k>0 and p[0] != 0 and 2**round(log(k,2)) == k\n\n    if k == 1:\n        return [1 / p[0]]\n    \n    q = poly_recip(p[:k/2])\n    r = poly_sub(poly_scale(poly_scalar_mul(2, q), 3*k/2-2),\n                 poly_mul(poly_mul(q, q), p))\n\n    return poly_scale(r, -k+2)\n\n\ndef poly_divmod(u, v):\n    \"\"\"Fast polynomial division ``u(x)`` / ``v(x)`` of polynomials with degrees\n    m and n. Time complexity is ``O(n*log(n))`` if ``m`` is of the same order\n    as ``n``.\n    \"\"\"\n    if not u or not v:\n        return []\n    m = poly_deg(u)\n    n = poly_deg(v)\n    \n    # ensure deg(v) is one less than some power of 2\n    # by extending v -> ve, u -> ue (mult by x^nd)\n    nd = int(2**ceil(log(n+1, 2))) - 1 - n\n    ue = poly_scale(u, nd)\n    ve = poly_scale(v, nd)\n    me = m + nd\n    ne = n + nd\n\n    s = poly_recip(ve)\n    q = poly_scale(poly_mul(ue, s), -2*ne)\n\n    # handle the case when m>2n\n    if me > 2*ne:\n        # t = x^2n - s*v\n        t = poly_sub(poly_scale([1], 2*ne), poly_mul(s, ve))\n        q2, r2 = poly_divmod(poly_scale(poly_mul(ue, t), -2*ne), ve)\n        q = poly_add(q, q2)\n    \n    # remainder, r = u - v*q\n    r = poly_sub(u, poly_mul(v, q))\n\n    return q, r\n```\n\nThe ```\npoly_divmod(u, v)```\n function returns a ```\n(quotient, remainder)```\n tuple for polynomials ```\nu```\n and ```\nv```\n (like Python's standard ```\ndivmod```\n for numbers).\nFor example:\n```\n>>> print poly_divmod([1,0,-1], [1,-1])\n([1, 1], [])\n>>> print poly_divmod([3,-5,10,8], [1,2,-3])\n([3, -11], [41, -25])\n>>> print poly_divmod([1, -11, 0, -22, 1], [1, -3, 0, 1, 2])\n([1], [-8, 0, -23, -1])\n>>> print poly_divmod([1, -11, 0, -22, 1], [1, -3, 0, 1, 2, 20])\n([], [1, -11, 0, -22, 1])\n```\n\nI.e:\n\n```\n(x^2 - 1) / (x - 1) == x + 1```\n\n```\n(2x^3 - 5x^2 + 10x + 8) / (x^2 + 2x -3) == 3x - 11```\n, with remainder ```\n41x - 25```\n\netc. (Last two examples are yours.)\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT; Why is the frequency bin resolution dependent on Time?\r\n                \r\nI'm looking into Fast Fourier TRansform (FFT) to create a discrete Fourier transform (DFT) of a part of a song.\n\nI found https://www.youtube.com/watch?v=YEwIjyOKFQ4 and http://www.bitweenie.com/listings/fft-zero-padding/ to be especially helpful to answer most of my questions. \n\nStill I'm left with one question. Why is the frequency bin size dependent on time? Is this an property of the FFT-algorithm? Or is it not possible to see the difference between the frequencies in one bin?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Asymptotically optimal way to find the sum of three elements of an array closest to a given number\r\n                \r\nIn his answer to this question, John Feminella says:\n\n\n  It's possible to do this sub-quadratically if you get really fancy, by\n  representing each integer as a bit vector and performing a fast\n  Fourier transform, but that's beyond the scope of this answer.\n\n\nWhat is the asymptotically optimal way of solving the problem described in that question?\n    ", "Answer": "\r\nSuppose we have an array ```\n1 2 4```\n. We represent this array as a polynomial ```\nf(x) = x^1 + x^2 + x^4```\n. Let's look at ```\nf(x)^2```\n, which is\n\n```\nx^2 + 2 x^3 + x^4 + 2 x^5 + 2 x^6 + x^8\n```\n\n\nThe number of ways to write ```\nn```\n as the sum of two elements of the array is the coefficient of ```\nx^n```\n, and this is true in general. FFT gives us a way to multiply polynomials efficiently*, so basically what we do is compute ```\nf(x)^3```\n and look at the coefficient of the target number S.\n\n\nThe reason this algorithm doesn't solve the 3SUM problem is that the efficiency of an FFT multiply depends on the degree of the resulting polynomial and thus that the array values lie in a small range.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "get the code of functions in Matlab?\r\n                \r\nI am wondering if we - the Matlab users can get the code of some functions in Matlab (like fft - fast fourier transform, dwt - descrete wavelet transform, and so on.) Just in case we want to edit something to adapt with what we need. \nIs it possible in Matlab? \nand if so, how can we get the code?\nThank you.\n    ", "Answer": "\r\nType \"edit function.m\" (without quotes), where \"function\" is the name of the function with the code you wish to view. \n\nRead more: http://www.ehow.com/how_8465386_matlab-function-codes.html#ixzz2wILKOXJI\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How are FFTs different from DFTs and how would one go about implementing them in C++?\r\n                \r\nAfter some studying, I created a small app that calculates DFTs (Discrete Fourier Transformations) from some input. It works well enough, but it is quite slow.\n\nI read that FFTs (Fast Fourier Transformations) allow quicker calculations, but how are they different? And more importantly, how would I go about implementing them in C++?\n    ", "Answer": "\r\nIf you don't need to manually implement the algorithm, you could take a look at the Fastest Fourier Transform in the West\n\nEven thought it's developed in C, it officially works in C++ (from the FAQ)\n\n\n  Question 2.9. Can I call FFTW from\n  C++?\n  \n  Most definitely. FFTW should compile\n  and/or link under any C++ compiler.\n  Moreover, it is likely that the C++\n   template class is\n  bit-compatible with FFTW's\n  complex-number format (see the FFTW\n  manual for more details).\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to generate random samples of Gaussian distribution directly in the frequency domain through Python: NumPy/SciPy?\r\n                \r\nOne can easily draw (pseudo-)random samples from a normal (Gaussian) distribution by using, say, NumPy:\n\n```\nimport numpy as np\nmu, sigma = 0, 0.1 # mean and standard deviation\ns = np.random.normal(mu, sigma, 1000)\n```\n\n\nNow, consider the Fast Fourier transform of ```\ns```\n:\n\n```\nfrom scipy.fftpack import fft\nsHat = fft(s)\n```\n\n\nConsidering, presumably, generating Gaussian random numbers directly in the frequency domain might be more clever(?) (thus, efficient?) for various applications, and \"the Fourier transform of white noise is white noise\", and reportedly ```\nsHat```\n can be generated directly without the Fourier-transform of ```\ns```\n as theoretically shown herein;\n\nCould you please advice novices (like myself) on how to implement such a useful idea? Favourably, a reference to an available implementation that I could not find in the web? \n\n\n\nThe following is my attempt to code the above theoretical explanation:\n\n```\nimport numpy as np \nfrom scipy.fftpack import ifft\n\nN = 100\ngaussComplex = np.full(shape=N, dtype=complex, fill_value=0.+0.j)\n\nmu, sigma = 0, 1\ns = np.random.normal(mu, sigma, N)\n\niters = np.arange(N) # 0..N-1\n\n# 0..N/2-1\nfor i, item in enumerate(iters[:N/2]):\n    gaussComplex[i] = complex(s[i], s[i+N/2])\n\nconjugateGaussComplex = np.conjugate(gaussComplex)\n\n# N/2..N-1\nfor i, item in enumerate(iters[N/2:]):\n    gaussComplex[item] = conjugateGaussComplex[N-item]\n\nsNew = ifft(gaussComplex)\n```\n\n\nA comparison of ```\ns```\n and ```\nsNew```\n reveals the following as I expect that they would be the same:\n\n```\nplt.plot(sHat.real, 'blue')\nplt.plot(s, 'red')\n```\n\n\n\n    ", "Answer": "\r\n\n  the Fourier transform of white noise is white noise\n\n\nThis is true, but it does not mean that they are axactly the same - otherwise there would not be much point in doing the FFT. \n\nIf you plot ```\ns```\n and the real part of ```\nfft(s)```\n you will see that the transformed noise has much higher values.\n\nConversely, if you fill ```\ngaussComplex```\n with random values of standard deviation 1, the inversely transformed noise will have a much lower standard deviation. This is what you observe.\n\nTo generate the FFT of Gaussian white noise in the frequency domain you need to scale it correctly. In your case, this should do the trick: \n\n```\ngaussComplex *= np.sqrt(N/2)\n```\n\n\nYou need to scale by ```\nsqrt(N)```\n because this is the normalization factor of the FFT. Furthermore, you also need to scale by ```\n1/sqrt(2)```\n because you put noise with standard deviation of 1 in both, the real and imaginary part of the FFT. (However, the absolute value should have standard deviation of 1, hence the need to divide by ```\nsqrt(1+1)```\n.)\n\nPlotting ```\ns```\n and ```\nsNew```\n with the correct scaling applied results in something like that: \n\n\nThe result is not exactly the same (as expected), but the noise varies in the same range - both have a standard deviation of ~1.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Bandpass Filter Output & Fourier Transform\r\n                \r\nI'm trying ko eliminate noise and some other frequencies that I do not require from this waveform:\n\nAs you can see in the picture below, it has a lot of noise in it:\n\nI apply the fast fourier transform using numpy to convert this into frequency domain: (channelA and time are numpy arrays, channelA storing voltage values)\n```\nfY = np.fft.fft(channelA)\nfreq = np.fft.fftfreq(len(channelA), time[1]-time[0])\n```\n\nHere is the transform:\n\nWhen zoomed in:\n\nI apply a butterworth bandpass filter using scipy in python. Here is the code:\n```\nlow = 100 / (0.5 * 2e6)   # nyq = 1/2 * fs\nhigh = 1e3 / (0.5 * 2e6)\nsos = sp.butter(1, [low, high], btype='bandpass', output='sos')\ny = sp.sosfiltfilt(sos, channelA)\n```\n\nHere my sampling rate is 2M (2e6), and my passband frequencies are 100-1kHz.\nAfter applying the filter, the signal seems to have lost the noise but however the voltage at the start goes negative. I do not understand why. Can someone explain why this is happening?\n\nZoomed in to show no noise left:\n\nVoltage goes negative when I apply the highpass filter. If I only apply the lowpass filter, the noise gets eliminated. (highpass and lowpass filters can be applied using the same function)\nThis is the transform of the filtered signal:\n\nZoomed in:\n\nAs can be seen, frequencies less than 100Hz are still present and frequencies around 350Hz have been removed. I'm trying to get a focus on frequencies around 350-400Hz and want to eliminate the rest of the frequencies while not distorting the signal. Why is this happening and what should I do to achieve this?\nP.S. I'm sorry the post is kind of long but I don't have another way of explaining this.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT calculation from introduction to algorithm\r\n                \r\nfrom MIT books(introduction to algorithm)  here is described Fast Fourier  transform algorithm,here is my code for implementation it\n\n```\n#include <iostream>\n#include<complex>\n#include<math.h>\n#include<vector>\n#include<iterator>\n#include<complex>\nusing namespace std;\n#define E 2.718\n#define PI 3.14\n#define n 8 \nvoid FFT(vector<float>&a){\n    vector<float>::iterator it;\n        const double pi = std::acos(-1.0);\nconst std::complex<double> i(0,1);\n\ncomplex<double>  wn =std::exp((2*pi*i)/8.0);\n    vector<float>y;\n    vector<float>y0;\n    vector<float>y1;\n\n    int omega=1;\n    vector<float>a0;\n     vector<float>a1;\n      for (int i=0;i<n-1;i+=2)\n          a0[i]=a[i];\n       for (int i=1;i<n;i+=2)\n           a1[i]=a[1];\n       y0=FFT(a0);\n       y1=FFT(a1);\n\n        for (int k=0;k<n/2-1;k++){\n\n            y[0]=y0[k]+omega*y1[k];\n            y[k+n/2]=y0[k]-omega*y1[k];\n            omega=omega*imag(wn);\n\n\n        }\n        for(it=y.begin();it!=y.end();it++){\n            cout<<*it<<\"  \";\n\n        }\n\n}\n\nint main(){\n    vector<int>a;\n    a.push_back(2);\n    a.push_back(3);\n    a.push_back(5);\n    a.push_back(1);\n    a.push_back(100);\n    a.push_back(200);\n    a.push_back(300);\n    a.push_back(400);\n    cout<<FFT(a)<<endl;\n\n    return 0;\n}\n```\n\n\nbut it shows me error list\n\n```\nError   1   error C2679: binary '=' : no operator found which takes a right-hand operand of type 'void' (or there is no acceptable conversion)  c:\\users\\datuashvili\\documents\\visual studio 2010\\projects\\fft\\fft\\fft.cpp  28  1   FFT\nError   2   error C2679: binary '=' : no operator found which takes a right-hand operand of type 'void' (or there is no acceptable conversion)  c:\\users\\datuashvili\\documents\\visual studio 2010\\projects\\fft\\fft\\fft.cpp  29  1   FFT\nWarning 3   warning C4244: '=' : conversion from 'double' to 'int', possible loss of data   c:\\users\\datuashvili\\documents\\visual studio 2010\\projects\\fft\\fft\\fft.cpp  35  1   FFT\nError   4   error C2664: 'FFT' : cannot convert parameter 1 from 'std::vector<_Ty>' to 'std::vector<_Ty> &' c:\\users\\datuashvili\\documents\\visual studio 2010\\projects\\fft\\fft\\fft.cpp  56  1   FFT\n    5   IntelliSense: no operator \"=\" matches these operands    c:\\users\\datuashvili\\documents\\visual studio 2010\\projects\\fft\\fft\\fft.cpp  28  7   FFT\n    6   IntelliSense: no operator \"=\" matches these operands    c:\\users\\datuashvili\\documents\\visual studio 2010\\projects\\fft\\fft\\fft.cpp  29  7   FFT\n    7   IntelliSense: a reference of type \"std::vector<float, std::allocator<float>> &\" (not const-qualified) cannot be initialized with a value of type \"std::vector<int, std::allocator<int>>\"    c:\\users\\datuashvili\\documents\\visual studio 2010\\projects\\fft\\fft\\fft.cpp  56  12  FFT\n```\n\n\nUPDATED:\nhere is my  updated code\n\n```\n#include <iostream>\n#include<complex>\n#include<math.h>\n#include<vector>\n#include<iterator>\n#include<complex>\nusing namespace std;\n#define E 2.718\n#define PI 3.14\n#define n 8 \nvector<float>FFT(vector<double>a)\n{\n    vector<float>::iterator it;\n        const double pi = std::acos(-1.0);\nconst std::complex<double> i(0,1);\n\ncomplex<double>  wn =std::exp((2*pi*i)/8.0);\n    vector<double>y;\n    vector<double>y0;\n    vector<double>y1;\n\n    double omega=1;\n    vector<double>a0;\n     vector<double>a1;\n      for (int i=0;i<n-1;i+=2)\n          a0[i]=a[i];\n       for (int i=1;i<n;i+=2)\n           a1[i]=a[1];\n       FFT(a0);\n       y0=a0;\n       FFT(a1);\n       y1=a1;\n\n        for (int k=0;k<n/2-1;k++){\n\n            y[0]=y0[k]+omega*y1[k];\n            y[k+n/2]=y0[k]-omega*y1[k];\n            omega=omega*imag(wn);\n\n\n        }\n         return y;\n\n\n\n}\n\nint main(){\n    vector<double>a;\n    a.push_back(2);\n    a.push_back(3);\n    a.push_back(5);\n    a.push_back(1);\n    a.push_back(100);\n    a.push_back(200);\n    a.push_back(300);\n    a.push_back(400);\nFFT(a);\n\n    return 0;\n}\n```\n\n\nbut it shows me errors yet\n\n```\nError   1   error C2664: 'std::vector<_Ty>::vector(const std::vector<_Ty> &)' : cannot convert parameter 1 from 'std::vector<_Ty>' to 'const std::vector<_Ty> &'    c:\\users\\datuashvili\\documents\\visual studio 2010\\projects\\fft\\fft\\fft.cpp  42  1   FFT\n    2   IntelliSense: no suitable user-defined conversion from \"std::vector<double, std::allocator<double>>\" to \"std::vector<float, std::allocator<float>>\" exists  c:\\users\\datuashvili\\documents\\visual studio 2010\\projects\\fft\\fft\\fft.cpp  42  11  FFT\n```\n\n\nplease help me guys\n    ", "Answer": "\r\n```\ny0=FFT(a0);\n```\n\n\nYou cannot assign void to something else...\n\nAlso you can't pass a ```\nstd::vector<int>```\n to a function expecting a reference to ```\nstd::vector<float> &```\n\n\nAnd finally \n\n```\ncout<<FFT(a)<<endl;\n```\n\n\nWill fail. You can't print void\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How do I remove negative frequencies after a Fourier transform?\r\n                \r\nI use a Java library to perform a Fast Fourier Transform on some two dimensional meteorological data (longitude and time) of size nx and nt. After the transform, I get a complex array of size 2*nx and nt, where 2*nx and 2*nx+1 indices represent a complex number with real and imaginary parts. For each time frequency, there are complex numbers in the spatial frequency dimension which are complex conjugates, so the numbers from indices 1 to nx/2 are complex conjugates of the numbers from nx/2+1 to nx. I understand the complex numbers from nx/2 to nx represent negative wavenumbers.\nMy question is: how do I remove the negative wavenumbers before inverse transforming? I only want to retain waves with positive wavenumber and frequency, but if I set the complex numbers from nx/2+1 to nx to zero then transform back, I get a complex array, and I'm not sure how to interpret this or find a real array equivalent which represents only the positive frequencies and wavenumbers. Can anyone guide me on how to filter out negative wavenumbers and get something back that has physical meaning i.e. real numbers?\n    ", "Answer": "\r\nThe way to \"retain waves with positive wavenumber\" and get a strictly real result from a full complex IFFT is to make sure the array you feed the IFFT is conjugate symmetric, as the conjugate symmetry what causes all the imaginary components in the IFFT result to cancel out to zero (or very near zero with some tiny rounding \"errors\" or numerical noise).\nThere may be inverse real FFT implementations in your library that will do this for you, e.g. take a half-size complex array as input and internally synthesize the conjugate symmetry needed to output a strictly real result.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What is a circuit?\r\n                \r\nThe book Algorithms demonstrates the Fast Fourier Transform through a \"circuit\", using \"wires\" to carry data. What is a circuit? Is it simply a concept made up by the author of the book to better demonstrate the algorithm or is it a recognized computer science concept?\n    ", "Answer": "\r\nThe answer to your question is, yes, \"circuits\" are a recognized concept in theoretical computer science, drawing on the related concept from electronics.  A Boolean circuit is basically what it sounds like:  A model for computation over binary strings, consisting of boolean logic gates strung together with wires.  You can find a formal definition here, at Wikipedia.\n\nWhere they come in handy is, as you've seen, determining complexity of a particular problem.  The FFT example is fairly accessible, but probably the most famous example is Cook's definition of NP-Completeness, which turns on the proof that determining whether a given Boolean circuit is satisfiable is NP-Complete.\n\nBarrington and Maciel have a series of computation complexity lecture notes that introduce circuits in the first lecture and continue to use the concept throughout. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What does top right corner value in Fast Fourier Transformation (FFT) show?\r\n                \r\nIn case to apply ```\nfft2```\non matrix we get a matrix with sum of all matrix elements on left top corner but a number also show on top right corner.What does it show ?\n\nHere is function i applied \n\nAnd here is result it generates and the value at top right corner i am asking about\n\n    ", "Answer": "\r\nThe first row is the 1-D FFT of the sum of each column of ```\nb```\n. That is, if you do ```\nfft(sum(b))```\n you would get the first row of ```\nbf```\n.\nIf you look at the definition of DFT you can see that the ```\nN/2```\n bin is given by:  \n\n```\nX[N/2] = sum( x[n]exp(2*pi*j*N/2*n/N) ) =  sum( x[n]exp(2*pi*j/2*n) ) = sum(x[n]*(-1)^n)\n```\n\n\nSo that means that the top-right corner you marked is the sum of all odd columns of ```\nb```\n minus the sum of all even columns of ```\nb```\n.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Which input format is the best for sound recognition in recurrent neural networks?\r\n                \r\nI want to create sound or pitch recognition with recurrent deep neural network. And I'm wondering with what input will I get best results.\n\nShould I feed DNN with amplitudes or with FFT(Fast Fourier transform) result?\n\nIs there any other format that is known to produce good results and fast learning?\n    ", "Answer": "\r\nWhile MFCCs have indeed been used in music information retrieval research (for genre classification etc...), in this case (pitch detection) you may want to use  a semi-tone filterbank or constant Q transform as a first information reduction step. These transformations match better with musical pitch.\n\nBut I think it's also worth trying to use the audio samples directly with RNNs, in case you have a huge number of samples. In theory, the RNNs should be able to learn the wave patterns corresponding to particular pitches.\n\nFrom your description, it's not entirely clear what type of \"pitch recognition\" you're aiming for: monophonic instruments (constant timbre, and only 1 pitch sounding at a time)? polyphonic (constant timbre, but multiple pitches may be sounding simultaneously)? multiple instruments playing together (multiple timbres, multiple pitches)? or even a full mix with both tonal and percussive sounds? The hardness of these use cases roughly increases in the order I mentioned them, so you may want to start with monophonic pitch recognition first.\n\nTo obtain the necessary amount of training examples, you could use a physical model or a multi-sampled virtual instrument to generate the audio samples for particular pitches in a controlled way. This way, you can quickly create your training material instead of recording it and labeling it manually. But I would advise you to at least add some background noise (random noise, or very low-level sounds from different recordings) to the created audio samples, or your data may be too artificial and lead to a model that doesn't work well once you want to use it in practice.\n\nHere is a paper that might give you some ideas on the subject:\nAn End-to-End Neural Network for Polyphonic Piano Music Transcription\n(Siddharth Sigtia, Emmanouil Benetos, and Simon Dixon)\nhttps://arxiv.org/pdf/1508.01774.pdf\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Using python to convert wav file to csv file before feed the data into FFT for audio spectrum analyzer [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am working on a simple audio spectrum analyzer using FPGA. For the preprocessing part, my idea is to use python to convert wav file to csv file, and then feed the data to a fast fourier transform module. Is it possible to get it work?\n    ", "Answer": "\r\nThere are plenty of available open source modules to perform this:\nA GitHub repository for same.\nJust open github and type wav to csv and you'll find quite a lot of them.\nOr even google a bit and you can find lot of answers on same.\nOne small query though. You basically want to convert the .wav file into a time series data right?\nIn that case, I'll highly recommend to go through:\nKDNugget's post about same.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to get audio samples into form where I can analyse it?\r\n                \r\nI'm trying to develop a tone analyser for the iPhone using FFT(fast Fourier transform), but figur out how to get audio samples into a form where can analyze it. I just want an array with time and amplitude or something like that. Thanks in advance!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What is wrong with my Fourier Transformation (Convolution) in MathNet.Numerics? - C#\r\n                \r\nI am trying to do a simple Convolution between 2 audio files using the ```\nMathNet.Numerics's```\n FFT (Fast Fourier Transformation), but I get some weird background sounds, after the IFFT.\n\nI tested if it's the Convolution or the Transformations, thats causing the problem, and I found out that the problem shows already in the FFT -> IFFT (Inverze FFT) conversion. \n\nMy code for a simple FFT and IFFT:\n\n```\nfloat[] sound; //here are stored my samples\n\nComplex[] complexInput = new Complex[sound.Length];\nfor (int i = 0; i < complexInput.Length; i++)\n{\n      Complex tmp = new Complex(sound[i],0);\n      complexInput[i] = tmp;\n }\n\nMathNet.Numerics.IntegralTransforms.Fourier.Forward(complexInput);\n\n//do some stuff\n\nMathNet.Numerics.IntegralTransforms.Fourier.Inverse(complexInput);\n\nfloat[] outSamples = new float[complexInput.Length];\n\nfor (int i = 0; i < outSamples.Length; i++)\n     outSamples[i] = (float)complexInput[i].Real;\n```\n\n\nAfter this, the ```\noutSamples```\n are corrupted with some wierd background sound/noise, even though I'm not doing anything between the FFT and IFFT.\n\nWhat am I missing?\n    ", "Answer": "\r\nThe current implementation of ```\nMathNet.Numerics.IntegralTransform.Fourier```\n (see ```\nFourier.cs```\n and ```\nFourier.Bluestein.cs```\n)\nuses Bluestein's algorithm for any FFT lengths that are not powers of 2.\n\nThis algorithm involves the creation of a Bluestein sequence (which includes terms proportional to n2) which up to version 3.6.0 was using the following code:\n\n```\nstatic Complex[] BluesteinSequence(int n)\n{\n  double s = Constants.Pi/n;\n  var sequence = new Complex[n];\n\n  for (int k = 0; k < sequence.Length; k++)\n  {\n    double t = s*(k*k); // <--------------------- (k*k) 32-bit int expression\n    sequence[k] = new Complex(Math.Cos(t), Math.Sin(t));\n  }\n\n  return sequence;\n}\n```\n\n\nFor any size ```\nn```\n greater than 46341, the intermediate expression ```\n(k*k)```\n in this implementation is computed using ```\nint```\n arithmetic (a 32-bit type as per MSDN integral type reference table) which results in numeric overflows for the largest values of ```\nk```\n. As such the current implementation of ```\nMathNet.Numerics.IntegralTransfom.Fourier```\n only supports input array sizes which are either powers of 2 or non-powers of 2 up to 46341 (included).\n\nThus for large input arrays, a workaround could be to pad your input to the next power of 2.\n\nNote: this observation is based on version 3.6.0 of ```\nMathNet.Numerics```\n, although the limitation appears to have been present in earlier releases (the Bluestein sequence code has not changed significantly going as far back as version 2.1.1).\n\n\n\nUpdate 2015/04/26: \n\nAfter I posted this and a comment on an similar issue on github bugtracking, the issue was quickly fixed in ```\nMathNet.Numerics```\n. The fix should now be available in version 3.7.0. Note however that you may still want to pad to a power of two for performance reasons, especially since you already need to zero pad for the linear convolution.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How can I detect the stripe noise of images?\r\n                \r\nI try use the methods in the internet, but I can't find a good algorithm, can detect the stripe noise of images effectively. I know some methods about FFT(Fast Fourier Transform Algorithm) to solve this problem, but I don't know the specific method.\n    ", "Answer": "\r\nthese are two example images.\nstripe_image_1\nstripe_image_2\nand these are two normal images(zebra crossing and normal stripe image), I need make some distinguish of normal image. just like our eyes can do.\nnormal_image_1\nnormal_image_2\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What does the 'axis' parameter in numpy.fft.fft mean?\r\n                \r\nThe Fast Fourier Transform (```\nfft```\n; documentation) transforms 'a' into its fourier, spectral equivalent:\n\n```\nnumpy.fft.fft(a, n=None, axis=-1, norm=None) \n```\n\n\nThe parameter, ```\nn```\n represents—so far as I understand it—how many samples are in the output, where the output is either cropped if ```\nn```\n is smaller than the number of samples in ```\na```\n, or padded with zeros if ```\nn```\n is larger. \n\nWhat does ```\naxis```\n do? What does it mean exactly? I haven't been able to find any clear examples of its use.\n    ", "Answer": "\r\n```\nnp.fft.fft```\n computes the one-dimensional discrete Fourier transform. If you give a one dimensional input (a vector), it will just compute the transform for that input. However, if your input has more than one dimension, like a 2D matrix, or higher, NumPy assumes you are giving many vectors and you want to compute the transform of each of them. The ```\naxis```\n parameter indicates the dimension corresponding to those vectors, and by default it is the last one (```\n-1```\n). So, for example, for a 2D matrix ```\nm```\n, if ```\naxis=0```\n then each column ```\nm[:, 0]```\n, ```\nm[:, 1]```\n, etc. would be the vectors for which the transform is computed, while passing ```\naxis=1```\n (equivalent to the default ```\naxis=-1```\n), each row ```\nm[0, :]```\n, ```\nm[1, :]```\n, etc. would be considered a vector for the transform. If you want to compute the transform of all values in the input, regardless of the dimensions, you would have to flatten the input, for example with ```\nnp.ravel```\n.\n\nBtw, this is a very common convention in NumPy (and many other algebra packages), where a one-dimensional operation can work on multidimensional inputs by receiving an ```\naxis```\n parameter that indicates the dimension over which the operation is performed.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Numpy ifft error\r\n                \r\nI'm having a really frustrating problem using numpy's inverse fast fourier transform function. I know the fft function works well based on my other results.   Error seems to be introduced after calling ifft. The following should be printing zeros for example:\n\n```\ntemp = Eta[50:55] \nprint(temp) \nprint(temp-np.fft.fft(np.fft.ifft(temp)))\n```\n\n\nOutput:\n\n```\n[ -4.70429130e+13 -3.15161484e+12j -2.45515846e+13 +5.43230842e+12j -2.96326088e+13 -4.55029496e+12j 2.99158889e+13 -3.00718375e+13j -3.87978563e+13 +9.98287428e+12j]\n\n[ 0.00781250+0.00390625j -0.02734375+0.01757812j 0.05078125-0.02441406j 0.01171875-0.01171875j -0.01562500+0.015625j ]\n```\n\n\nPlease help!\n    ", "Answer": "\r\nYou are seeing normal floating point imprecision.  Here's what I get with your data:\n\n```\nIn [58]: temp = np.array([ -4.70429130e+13 -3.15161484e+12j, -2.45515846e+13 +5.43230842e+12j, -2.96326088e+13 -4.55029496e+12j, 2.99158889e+13 -3.00718375e+13j, -3.87978563e+13 +9.98287428e+12j])\n\nIn [59]: delta = temp - np.fft.fft(np.fft.ifft(temp))\n\nIn [60]: delta\nOut[60]: \narray([ 0.0000000+0.00390625j, -0.0312500+0.01953125j,\n        0.0390625-0.02539062j,  0.0078125-0.015625j  , -0.0156250+0.015625j  ])\n```\n\n\nRelative to the input, those values are, in fact, \"small\", and reasonable for 64 bit floating point calculations:\n\n```\nIn [61]: np.abs(delta)/np.abs(temp)\nOut[61]: \narray([  8.28501685e-17,   1.46553699e-15,   1.55401584e-15,\n         4.11837758e-16,   5.51577805e-16])\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What is the difference between the return of fft / fft2 applied to a matrix?\r\n                \r\nIn the following program, I would like to compute the fast Fourier transform of a given field given by U. what is the difference between the returned values for fft and for fft2? Any help would be appreciated! Thank you. \n\n```\nimport numpy as np\nfrom numpy import sin, cos, pi\n\nnx=3\nny=3\n\npx=2*pi\npy=2*pi\n\nqx=1.0*px/(nx-1)\nqy=1.0*py/(ny-1)\n\nx = np.linspace(0,px,nx)\ny = np.linspace(0,py,ny)\n\nX,Y = np.meshgrid(x,y)\n\nU=cos(X)*sin(Y)\n\n#compite fft's\nUh1=np.fft.fft(U)\n\nUh2=np.fft.fft2(U)\n\nprint('For fft')\nprint(Uh1)\n\nprint('For fft2')\nprint(Uh2)\n\n#What is the difference between Uh1 and Uh2? Thank you!\n```\n\n\nHere is what I get:\n\n```\nFor fft\n[[  0.00000000e+00 +0.00000000e+00j   0.00000000e+00 +0.00000000e+00j\n0.00000000e+00 +0.00000000e+00j]\n[  1.22464680e-16 +0.00000000e+00j   1.22464680e-16 +2.12115048e-16j\n1.22464680e-16 -2.12115048e-16j]\n[ -2.44929360e-16 +0.00000000e+00j  -2.44929360e-16 -4.24230095e-16j\n-2.44929360e-16 +4.24230095e-16j]]\nFor fft2\n[[ -1.22464680e-16 +0.00000000e+00j  -1.22464680e-16 -2.12115048e-16j\n-1.22464680e-16 +2.12115048e-16j]\n[  6.12323400e-17 -3.18172572e-16j   6.12323400e-16 -2.12115048e-16j\n-4.89858720e-16 -4.24230095e-16j]\n[  6.12323400e-17 +3.18172572e-16j  -4.89858720e-16 +4.24230095e-16j\n6.12323400e-16 +2.12115048e-16j]]\n```\n\n\nThank you!\n    ", "Answer": "\r\ndocstring of the np.fft module. \n\n```\nStandard FFTs\n-------------\n\n.. autosummary::\n   :toctree: generated/\n\n   fft       Discrete Fourier transform.\n   ifft      Inverse discrete Fourier transform.\n   fft2      Discrete Fourier transform in two dimensions.\n   ifft2     Inverse discrete Fourier transform in two dimensions.\n   fftn      Discrete Fourier transform in N-dimensions.\n   ifftn     Inverse discrete Fourier transform in N dimensions.\n```\n\n\nPlotting the two matricies gives this if you wan't to visualize the differences. I do not know enough about fft's to even know if it makes any sense to plot them this way. \n\n\n\n\n\n```\nplt.figure()\n\nplt.subplot(2,2,1)\nplt.plot(Uh1.real.ravel())\nplt.title(\"1 - real\")\nplt.subplot(2,2,2)\nplt.plot(Uh2.real.ravel())\nplt.title(\"2 - real\")\n\nplt.subplot(2,2,3)\nplt.plot(Uh1.imag.ravel())\nplt.title(\"1 - imaginary\")\nplt.subplot(2,2,4)\nplt.plot(Uh2.imag.ravel())\nplt.title(\"2 - imaginary\")\n\nplt.figure()\n\nplt.subplot(2,2,1)\nplt.hist(Uh1.real.ravel())\nplt.title(\"1 - real\")\nplt.subplot(2,2,2)\nplt.hist(Uh2.real.ravel())\nplt.title(\"2 - real\")\n\nplt.subplot(2,2,3)\nplt.hist(Uh1.imag.ravel())\nplt.title(\"1 - imaginary\")\nplt.subplot(2,2,4)\nplt.hist(Uh2.imag.ravel())\nplt.title(\"2 - imaginary\")\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to smoothen a plot in MATLAB?\r\n                \r\nI have some 9000 points that are plotted on a graph:\n\n[Full resolution]\n\n\n\nActually, the plot is not as smooth as I wanted it to be. Is there some way I can smoothen the graph to a required degree?\n\nOr some form of thresholding so that I can selectively smoothen out the parts that is too bumpy?\n\nI am not sure but can fast-fourier-transform help?\n    ", "Answer": "\r\nIf you have the Curve Fitting Toolbox, you can use the ```\nsmooth```\n function. The default method is a moving average of size 5 (method can be changed). An example:\n\n```\n% some noisy signal\nFs = 200; f = 5;\nt = 0:1/Fs:1-1/Fs;\ny = sin(2*pi*f*t) + 0.6*randn(size(t));\nsubplot(411)\nplot(y), title('Noisy signal')\n\n% smoothed signal\nsubplot(412)\nplot( smooth(y, 5, 'moving') ), title('smooth')\nylim([-2 2])\n```\n\n\nIf not, you can use use your own window function using the ```\nfilter```\n function from core MATLAB:\n\n```\n% equivalent to a moving average window\nwndwSize = 5;\nh = ones(1,wndwSize)/wndwSize;\nsubplot(413)\nplot( filter(h, 1, y) ), title('filter + square window')\n\n% Guassian\nh = pdf('Normal',-floor(wndwSize/2):floor(wndwSize/2),0,1);\nsubplot(414)\nplot( filter(h, 1, y) ), title('filter + Guassian window')\n```\n\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT of large data (16gB) using Matlab\r\n                \r\nI am trying to compute a fast fourier transform of a large chunk of data imported from a text file which is around 16 gB in size. I was trying to think of a way to compute its fft in matlab, but due to my computer memory (8gB) it is giving me an out of memory error. I tried using memmap, textscan, but was not able to apply to get FFT of the combined data.\nCan anyone kindly guide me as to how should I approach to get the fourier transform? I am also trying to get the fourier transform (using definition) using C++ code on a remote server, but it's taking a long time to execute. Can anyone give me a proper insight as to how should I handle this large data?\n    ", "Answer": "\r\nIt depends on the resolution of the FFT that you require. If you only need an FFT of, say, 1024 points, then you can reshape your data to, or sequentially read it as ```\nN x 1024```\n blocks. Once you have it in this format, you can then add the output of each FFT result to a 1024 point complex accumulator.\n\nIf you need the same resolution after the FFT, then you need more memory, or a special ```\nfft```\n routine that is not included in Matlab (but I'm not sure if it is even mathematically possible to do a partial FFT by buffering small chunks through for full resolution).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What is the value of fft() returned in python\r\n                \r\nI got a data set and I want to made a Fast Fourier Transform to it, I wish I can get the coefficient of the triangle form of the Fourier series.\nCoded in python:\n\n```\npx = np.fft.fft(x)\n```\n\n\nHere's what I got:\n\n```\n [  4.00700000e+03 +0.00000000e+00j   8.89140903e+02 -1.13923217e+02j\n  -1.69490182e+02 +1.20807444e-02j  -3.57263933e+01 -2.04340910e+02j\n  -3.70833524e+01 -5.11555592e+01j  -1.20336528e+02 -2.58434734e+02j\n   3.53001158e+01 -5.38317726e+01j   3.67144521e+01 -7.95005841e+01j\n   9.61841452e+00 -1.23135149e+02j   4.94584769e+01 -4.71051788e+01j\n...\n```\n\n\nSeems it is some coefficients of the Exponential form?\n\nBut I don't know what these data presents as a freshman. I do searched, but it is of little help. Any one could tell me how to use these returned data to construct the Fourier Transformed formula? Like, whether the data represents any value of the upper equations like ```\nx_n```\n or ```\na_n```\n ?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Math used in 3D (Game) Engine Programming\r\n                \r\nI'd like to get an idea what kind of math is typically necessary for 3D game engine programming? Any specific math (such as vector geometry) or calculation algorithms (such as fast fourier transforms), or is this all abstracted away with DirectX/OpenGL so that highly complex math isn't really necessary any more?\n    ", "Answer": "\r\nLinear Algebra! Lots of lots of Linear Algebra!\n\nHere are just classes and example situations where you need them\n\n\nVector - position, velocity, normals\nMatrix - transformations\nQuaternion - rotations (great for bone animations)\nRay - projectile collision detection\nPlane - projectile collision detection\nFrustum - render culling\nSphere - render culling, fast collision test\nAxis-Align Bounding Box - culling, collision tests, spacial partitioning\nOriented Bounding Box - collision tests\nConvex Hull - collision, spacial partitioning\netc.\n\n\nYou should start with Vector and Matrix as they will be used everywhere in the engine (graphics, physics, AI, etc.)\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Evaluating polynomials? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 11 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhy does evaluating polynomials with n points using the Fast Fourier Transform take O(n log n) time? I am specifically talking about implementing a divide and conquer algorithm that divides the polynomial A(x) into its even powers and odd powers and then uses recursion. \n    ", "Answer": "\r\nLet T(n) be time used by the FFT algorithm to evaluate a polynomial of degree n at n points.\n\nThe algorithm splits\n\nA(x)=xB(x^2)+C(x^2),\n\ni.e. into two polynomials: odd and even coefficients. For example: 3x^3 + 2x^2 + 9x + 7 is split into x(3x^2 + 9) + (2x^2 + 7).\n\nOriginally you wanted to compute 3x^3 + 2x^2 + 9x + 7 at points a,b,c,d.\n\nNow you want to compute 3x+9 and 2x+7 at points a2, b2, c2, d2. Later you will combine that to get values of 3x^3 + 2x^2 + 2x + 7 at a,b,c,d.\n\nThe crucial idea: since you use roots of unity, half of the values in a2, b2, c2, d2 are the same. Suppose that a2=c2 and b2=d2.\n\nSo you need to compute 3x+2 and 2x+7 at points a2, b2.\n\nThis means you reduced an instance of size N into two instances of size N/2 and O(N) postprocessing.\n\nFFT repeats this process recursively. This is the same recursion equation as for mergesort, which is O(N log N) complexity.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Threaded FFT in Enthought Python\r\n                \r\nFast Fourier Transforms (FFTs) in Numpy/SciPy are not threaded. Enthought Python is shipped with the Intel MKL numerical library, which is capable of threaded FFTs. How does one get access to these routines?\n    ", "Answer": "\r\nThe following code works for me with Enthought 7.3-1 (64-bit) on Windows 7 Ultimate 64-bit. I haven't benchmarked it but it certainly uses all cores at once rather than just one.\n\n```\nfrom ctypes import *\n\nclass Mkl_Fft:\n    c_double_p = POINTER(c_double)\n\n    def __init__(self,num_threads=8):\n        self.dfti = cdll.LoadLibrary(\"mk2_rt.dll\")\n        self.dfti.MKL_Set_Num_Threads(num_threads)\n        self.Create = self.dfti.DftiCreateDescriptor_d_md\n        self.Commit = self.dfti.DftiCommitDescriptor\n        self.ComputeForward = self.dfti.DftiComputeForward\n\n    def fft(self,a):\n        Desc_Handle = c_void_p(0)\n        dims = (c_int*2)(*a.shape)\n        DFTI_COMPLEX = c_int(32)\n        rank = 2\n\n        self.Create(byref(Desc_Handle), DFTI_COMPLEX, rank, dims )\n        self.Commit(Desc_Handle)\n        self.ComputeForward(Desc_Handle, a.ctypes.data_as(self.c_double_p) )\n```\n\n\nUsage:\n\n```\nimport numpy as np\na = np.ones( (32,32), dtype = complex128 )\nfft = Mkl_Fft()\nfft.fft(a)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to call fft with pythran\r\n                \r\nI'm using pythran to convert my python+numpy code into C++, so far everything works really well with very efficient resulting code.\nHowever, my code requires the use of numpy.ffr.rfft and irfft (Fast Fourier Transform), which pythran apparently does not support:\n\n```\nimport numpy as np\n\n# pythran export testFunc(float[])\ndef testFunc(signal):\n    X = np.fft.rfft(signal,n=1024)\n\n>pythran Foo.py\nCRITICAL I am in trouble. Your input file does not seem to match \nPythran's constraints...\nE: Attribute 'fft' unknown (Foo.py, line 5)\n```\n\n\nHow could I possibly make this happen?\nIf I call a C implementation of the fast fourier transform from the python code (I know this can be done) will pythran use that or will it complain about it?\n\nEDIT: I compiled a simple C function into an so module which I can then call from my python code. All this works fine when invoked from python, but pythran does not work on the import:\n\n```\nCRITICAL I've got a bad feeling about this...\nE: source code not available\n```\n\n\nSo it looks like pythran does not work well with compiled .so files.\n    ", "Answer": "\r\nShort answer:\n\nSupport for ```\nnumpy.fft.rfft```\n has beed added to Pythran with  commit eb9e89373b and your code should now compile properly.\n\nLong answer:\n\nAdding support for new functions / packages in Pythran means writing the C++ code for this function (possibly a wrapper to an existing function) and registering it into Pythran so that the translator knows enough about it to guide its compilation process.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Trying to solve an unknwon segmentation fault in C\r\n                \r\nI'm trying to learn how to use Fast Fourier Transform, and have copied the FFT algorithm from Numerical Recipies in C called four1. I have written a small function test that fourier transforms a simple function. But upon execution the program returns a segmentation fault. I can't find where the fault is can you help me?\n\n```\n#include <stdio.h>\n#include <math.h>\n#define SWAP(a,b) tempr=(a);(a)=(b);(b)=tempr\n\nvoid four1(float data[], unsigned long nn, int isign)\n{\n        unsigned long n,mmax,m,j,istep,i;\n        double wtemp,wr,wpr,wpi,wi,theta;\n        float tempr,tempi;\n\n        n=nn << 1;\n        j=1;\n        for (i=1;i<n;i+=2) {\n                if (j > i) {\n                        SWAP(data[j],data[i]);\n                        SWAP(data[j+1],data[i+1]);\n                }\n                m=n >> 1;\n                while (m >= 2 && j > m) {\n                        j -= m;\n                        m >>= 1;\n                }\n                j += m;\n        }\n        mmax=2;\n        while (n > mmax) {\n                istep=mmax << 1;\n                theta=isign*(6.28318530717959/mmax);\n                wtemp=sin(0.5*theta);\n                wpr = -2.0*wtemp*wtemp;\n                wpi=sin(theta);\n                wr=1.0;\n                wi=0.0;\n                for (m=1;m<mmax;m+=2) {\n                        for (i=m;i<=n;i+=istep) {\n                                j=i+mmax;\n                                tempr=wr*data[j]-wi*data[j+1];\n                                tempi=wr*data[j+1]+wi*data[j];\n                                data[j]=data[i]-tempr;\n                                data[j+1]=data[i+1]-tempi;\n                                data[i] += tempr;\n                                data[i+1] += tempi;\n                        }\n                        wr=(wtemp=wr)*wpr-wi*wpi+wr;\n                        wi=wi*wpr+wtemp*wpi+wi;\n                }\n                mmax=istep;\n        }\n}\n\nvoid fourier_transform_test (FILE* output_file)\n{\n        /* \n        This function serves as a test to see whether my implementation of the\n        fft is working or not.\n        */\n        int n = 30;             // number of samples\n        float x[n];             // array that holds all values for x            \n\n        // misc\n        int i = 0;\n\n        printf(\"Running fourier transform tests...\\n\");\n        fprintf(output_file, \"# x t\\n\"); \n\n        // fill the array x with values to be transformed\n        for (i = 0; i <= (n - 1); i++) \n                x[i] = cos((2 * 3.1415 * i) / 10);\n\n        // according to the Numerical Recipies, I have to decrement the pointer to data\n        // by one to compensate for the zero-offset\n        four1(x-1, 64, 1);\n\n        // loop through the transformed array x and print results to a file\n        for (i = 0; i <= (n - 1); i++)\n                fprintf(output_file, \"%i\\t%f\\n\", i, x[i]);\n\n        fclose(output_file);\n\n}\n\nint main (int argc, char *argv[]) \n{\n        // open data_file to write results\n        FILE* file; \n        if (argc == 1)\n                file = fopen(\"results.dat\", \"w\");\n        else\n                file = fopen(argv[1], \"w\");\n\n        fourier_transform_test(file);\n\n        return 0;\n} \n```\n\n\nI'm using latest Debian, gcc 4 (pretty sure)\n\nFor those of you who want to see the book for yourself:\nhttp://www.nrbook.com/a/bookcpdf/c12-2.pdf \n(its legit)\n    ", "Answer": "\r\nYou only have 30 values in your array but you're telling four1 that your array is 64 floats long.\n\n```\nfour1(x-1, n, 1);\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Opencv: detecting brightest line on FFT\r\n                \r\nI have a fast fourier transform of my image like this:\n\n\n\nI want to use edge detection and hough transform to get this bright horizontal line (I'm measuring the angle of rotation of the image). But Canny operator doesn't work well, because there are such small color variations. How can I detect that line?\n\nI produce the FFT like this:\n\n```\ndft = cv2.dft(frame, flags=cv2.DFT_COMPLEX_OUTPUT)\ndft = np.fft.fftshift(dft)\nspectrum = 20 * np.log(cv2.magnitude(dft[:, :, 0], dft[:, :, 1]))\n# Converting to uint8 for Canny and HoughLinesP\nspectrum = spectrum / np.max(spectrum) * 255\nspectrum = spectrum.astype(np.uint8)\n```\n\n    ", "Answer": "\r\nHere is one way in Python/OpenCV.\n\n\nRead the input\nConvert to gray and invert\nApply adaptive thresholding and invert\nApply morphology to clean the threshold and fill out the line\nApply Canny edge detection\nApply Hough line detection\nDraw the largest line\nSave results\n\n\nInput:\n\n\n\n```\nimport cv2\nimport numpy as np\n\n# read image\nimg = cv2.imread('fft.png')\n\n# convert to grayscale\ngray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\ngray = 255 - gray\n\n# threshold\nthresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 13, 3)\nthresh = 255 - thresh\n\n# apply close to connect the white areas\nkernel = np.ones((3,3), np.uint8)\nmorph = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)\nkernel = np.ones((1,9), np.uint8)\nmorph = cv2.morphologyEx(morph, cv2.MORPH_CLOSE, kernel)\n\n# apply canny edge detection\nedges = cv2.Canny(morph, 150, 200)\n\n# get hough lines\nresult = img.copy()\nlines = cv2.HoughLines(edges, 1, np.pi/180, 50)\n# Draw line on the image\nfor rho,theta in lines[0]:\n    a = np.cos(theta)\n    b = np.sin(theta)\n    x0 = a*rho\n    y0 = b*rho\n    x1 = int(x0 + 1000*(-b))\n    y1 = int(y0 + 1000*(a))\n    x2 = int(x0 - 1000*(-b))\n    y2 = int(y0 - 1000*(a))\n    cv2.line(result, (x1, y1), (x2, y2), (0, 0, 255), 1)\n\n# save resulting images\ncv2.imwrite('fft_thresh.jpg',thresh)\ncv2.imwrite('fft_morph.jpg',morph)\ncv2.imwrite('fft_edges.jpg',edges)\ncv2.imwrite('fft_line.jpg',result)\n\n# show thresh and result    \ncv2.imshow(\"thresh\", thresh)\ncv2.imshow(\"morph\", morph)\ncv2.imshow(\"edges\", edges)\ncv2.imshow(\"result\", result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n```\n\n\n\nThresholded image:\n\n\n\nMorphology cleaned image:\n\n\n\nEdge image:\n\n\n\nResulting Hough line drawn on input image:\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "library rt not found on Mac, while configuring sfft (sparse fast fourier transformation)\r\n                \r\nI'm a green hand, and apology for the following could be simple question: \nI'm trying to install the package \nsfft on my Mac (OS X YOSEMITE). \nThe configuration step halts and give an error:\n\n```\nchecking for library rt:not found```\n\n\nHow can I fix this? \n    ", "Answer": "\r\n```\nlibrt```\n is a thing on Linux but not on OS X.  You don't need it.  Try editing the ```\nwscript```\n file in the package you downloaded and remove this line:\n\n```\nconf.check_cxx(lib='rt', uselib_store='RT')\n```\n\n\nThen remove ```\nRT```\n from ```\ncommon_use```\n in the same file and try to build.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How I should create complex number from image data for Fast Fourier Transform (fft, swift)?\r\n                \r\nI have array of grayscale for example ```\n[0.0, 0.0, 0.0, 255.0, 255.0, 255.0, 130.0, 130.0, 130.0]```\n 3x3 dimension, I need create array of complex numbers for fft function. How I should convert this array? \nIm using swift 4 and it is for iOS, but I think its no matter. And also using Accelerate framework from Apple\n\nso have 3 questions\n\n\nHow I should convert this array?\nIs there any common theory how do it?\nHow should I do it for RGB when working with channels?\n\n    ", "Answer": "\r\nFill real part of complex array with you data, and imaginary part  - with zero (picture is pure real data).\n\nAfter FFT you'll have complex array (symmetrical because of pure real source). Both real and im. parts of result are important. For example, you can use both parts to calculate magnitude of spectrum, or to perform some treatment in frequency domain and make inverse FFT to get treated picture.\n\nWhat to do with RGB - depends on your needs. Sometimes one needs to perform FFT on every channel separately. Sometimes one needs to work with brightness - in this case channels are joined using some law.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "The Sum of FFT of direct and reversed signal\r\n                \r\nIs there a similarity between the Fast Fourier Transform (FFT) of a signal and the FFT of the same signal reversed in time, i.e.\n```\nFFT(Sig_direct=[1 2 3 4 5])\nFFT(Sig_reversed=[5 4 3 2 1])\n```\n\nAlso, I would like to know if the summing up of the two spectra (direct and reversed) helps to maximize the information in terms of low-frequency components?\n    ", "Answer": "\r\nFlipping the time signal flips the frequency response (around the zero frequency), see for example here for a proof.\nThus, if you signal is real-valued, then reversing it causes the sign of the imaginary component of the FFT to flip (because of the complex conjugate symmetry in the frequency domain).\nSumming up the spectra would thus cancel out the imaginary component -- with disastrous consequences. Note that summing of spectra is the same as summing the signals, because the Fourier transform is linear: F(a+b) = F(a)+F(b). What would happen to your signal if you add the reversed signal to it? The same kind of destruction happens to the frequency spectrum if you add the two. It would not at all help you get a better view of your low frequency components, if you're unlucky these components might even be completely canceled out. Here's an example of that happening: I create a signal that is two periods of the sine function. Then I compute the FFT of the signal and its reversed version. The sum of these is spectra is 0 everywhere (actually slightly different from zero due to numerical rounding errors):\n```\nt = linspace(0,4*pi,128);\nf1 = sin(t);\nf2 = flip(f1);\nF1 = fft(f1);\nF2 = fft(f2);\nk = 0:length(t)-1;\nsubplot(3,1,1)\nplot(k,abs(F1))\nset(gca,'xlim',[0,127],'ylim',[0,70])\nsubplot(3,1,2)\nplot(k,abs(F2))\nset(gca,'xlim',[0,127],'ylim',[0,70])\nsubplot(3,1,3)\nplot(k,abs(F1+F2))\nset(gca,'xlim',[0,127],'ylim',[0,70])\n```\n\nHere is the output: top two plots are the magnitudes of the two spectra (both identical), bottom plot is the magnitude of the sum (zero everywhere):\n\nHowever, adding the magnitudes of the frequency components would be possible. The result would be identical if you were to just multiply the frequency spectrum by 2 -- so no improvement is possible this way.\nReviewing the paper you linked in the comment, it seems to me that these authors are using the FFT without understanding what they are doing. What is more, their equations do not match their description of what they're doing, making me believe they are not very well versed in mathematics either. Note that Ff and Fb in their Algorithm 2 are identical: the only difference is that the summation is reversed, but the elements being summed over are identical. Since the sum is independent of the order of the summands, nothing changes by reversing the order of the summation. The equation for Fb does not represent the FFT of the reversed signal.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFTW libray: how to properly plot an output?\r\n                \r\nI'm having some problems with the FFTW libray, I'm testing the Fast Fourier Transform algorithm with a Gaussian, therefore I would expect to get another Gaussian when I do the transform, this is what I get though:\n\n \n\nThe code is the following (I am using C): \n\n\n\nCould you please help me and tell me where I am wrong?\n    ", "Answer": "\r\nThe problem is not in the calculations you have made, but in the interpretation you do of the data. It is important to consider the gaussian you have passed and how is it phased in respect to the origin.  You can expect a real gaussian ONLY if you passed an origin centered gaussian also.  You got a gaussian multiplied by ```\nexp(i*phase*omega)```\n as the original data was not most probably origin centered.  If you check the imaginary values you'll see that they are also oscillating and dephased ```\nM_PI*0.25```\n with respect to the real part.  The data for a zero centered real function should go from ```\nN/2```\n to ```\nN-1```\n for the negative values (in a complement to N fashion) and then from ```\n0```\n to ```\nN/2-1```\n for the positive samples.  Most probably you centered your gaussian around sample ```\nN/2```\n (I've just checked, and you have done precisely this :) ) and this produced the complex exponential multiplying in your output.\n\nAlso, the origin is at element ```\n0```\n, so it is properly reflected at the origin.  Just center your input gaussian to the same point and see how it doesn't show such an oscillating result.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Javascript .multiply 'function cannot be found'\r\n                \r\nI am playing around with trekhleb's javascript-algorithms repo - specifically the Fast Fourier Transformation. The code can be found here:\nhttps://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/math/fourier-transform/fastFourierTransform.js\nI am looking to understand line 57:\n```\nconst component = output[signalId + blockLength / 2].multiply(phase);\n```\n\nWhen I debug this, the operation trying to be executed is: float.multiply(object).\nWhen I run this I get 'multiply is not a function'. And this makes sense as the float is not a object of the ComplexNumber class which contains a .multiply method.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "plot an interferogram as a function of time in matlab\r\n                \r\nCan someone help me to understand how to plot an interferogram as a function of time in matlab?\nmy data are looking like that:\n\n```\nPoints  Interferogram\n0   -2.11E-04\n1   -1.16E-04\n2   -5.71E-05\n3   -7.64E-05\n4   -1.58E-04\n...\n```\n\n\nup to about 28000.\n\nI need to put it in this form to do a fast fourier transform to extract the spectrum with this code (that isn't complete):\n\n```\nclear all\nformat long \n\nreadpath='C:\\Users\\lady-\\Desktop\\CS2\\'; \nfilename1  = 'Interferogram1.txt'; \n    [pos1, I1] = textread([readpath, filename1], '%f %f', 'headerlines',1);\n\n%filename2  = 'Interferogram2.txt'; \n    %[pos2, I2] = textread([readpath, filename2], '%f %f', 'headerlines',1);\n\n%The full stage displacement is 9.166 mm \n\n\n% figure(1)\nplot(pos1,I1)\n% title('Interferogram')Assuming that the x component has units of time (s):\n%timestep = mean(diff(t));           % Timestep (s)\n%Fs = 1./timestep;                   % Sampling frequency in [Hz]    \n%n_FFT = length(t);\n%Ef_1 = fft(I1,n_FFT); \n%Ef_2 = fft(I2,n_FFT); \n\n%Keeping only the positive frequencies\n%NumUniquePts = ceil((n_FFT+1)/2); \n%Ef1 = Ef_1(1:NumUniquePts);\n%Ef2 = Ef_2(1:NumUniquePts);\n```\n\n\nThank you !\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How do you turn an audio wave represented by values into a wavetable using Fast Fourier Transform?\r\n                \r\nI've scoured a lot of articles and links and questions here but I really can't get my head around FFT's. I'm simply trying to convert an array of values that represents a waveform, [0, 0.5, 1, 0.5, 0, -0.5, -1, -0.5] for example, into a wavetable for use with Javascript's WebAudio. I've found a library (fft.js) and scoured source code of people's implementations of it but for the life of me I can't work it out! I know I need a complex array of real and imag values but I just don't know the order of the steps to get there.\nAny help much appreciated.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "is it possible to get exactly the same results from tf.signal.frame followed by tf.signal.rfft and librosa.stft?\r\n                \r\nI have calculated stft by initially framing the audio signal using tf.signal.frame and applying Real-valued fast Fourier transform over each frame using  tf.signal.rfft.\ncode look like :\n```\naudio =  'fileid_0.wav'\nsig, rate =librosa.core.load(audio, 16000,mono=True)\nblockLen = 512\nblock_shift = 128\nframes = tf.signal.frame(sig, blockLen, block_shift)\nstft_dat = tf.signal.rfft(frames)\n```\n\nThen I calculated stft using librosa\n```\nstft_librosa = librosa.stft(sig,n_fft=512, hop_length=128, win_length=512,center=False)\n```\n\nBut the results from both these approach is different. How can I make it same\n    ", "Answer": "\r\nTo make it same, there are two approaches\n\nApply ```\nhann_windows```\n to the frame before doing the rfft\n```\nw = tf.signal.hann_window(512, periodic=True) \n```\n\nor\n\nSet the ```\nwindow```\n in ```\nlibrosa.stft```\n to ```\nrect```\n\n```\nlibrosa.stft(sig,n_fft=512,hop_length=128,center=False,window='rect') \n```\n\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to get the amplitude of PSD\r\n                \r\nI share this python code that I extracted from here: Plotting a fast Fourier transform in Python. I am making a Fourier spectrum, and then I would like to 'pick' to get the value from a specific point on the plot. In the next picture you can see the 50 Hz frequency, but I would like to know the frequency value of the next peak. How could I find that?\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fftpack\n\nN = 600\n# sample spacing\nT = 1.0 / 800.0\nx = np.linspace(0.0, N*T, N)\ny = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x)\nyf = scipy.fftpack.fft(y)\nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\n\nfig, ax = plt.subplots()\nax.plot(xf, 2.0/N * np.abs(yf[:N//2]))\nplt.show()\n```\n\n    ", "Answer": "\r\nOutcome of the following code resolves peaks as 50.836120401337794\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fftpack\n\n# Set the parameters for the signal and the Fourier transform\nN = 600\nT = 1.0 / 800.0\nx = np.linspace(0.0, N*T, N)\ny = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x)\nyf = scipy.fftpack.fft(y)\nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\n\n# Find the indices of the peaks in the spectrum\npeak_indices = np.argmax(np.abs(yf[:N//2]), axis=0)\n\n# Get the corresponding frequency values from the xf array\npeaks = xf[peak_indices]\n\n# Print the frequency values of the peaks\nprint(peaks)\n\n# Generate the Fourier spectrum plot\nfig, ax = plt.subplots()\nax.plot(xf, 2.0/N * np.abs(yf[:N//2]))\nplt.show()\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Using fast Fourier transform (FFT) to create a log[x*S(x)] vs log x plot\r\n                \r\nI am attempting to make a plot of log[x*y] vs log x the issue being that x times the function (y) gives me the errors.\n\n```\nx = seq(from =0, to=18000, by = 1)\ny = fft(variable, dim(x))\ny = y*x\n\nplot(x,y,log= \"xy\")\n```\n\n\nThere are 18000 values of y so when I use 0 to 18000 I get this error:\nError in y <= 0 : invalid comparison with complex values\n\nAnd when I make my x sequence any larger than 0 I get this error:\nlonger object length is not a multiple of shorter object length\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fourier transformation with missing values\r\n                \r\ni have a time discrete signal that may contain many missing values. and i want to do a fourier transformation on it.\n\nwhat can i do to handle them properly?\n\nfollowing diagram may show the case\n\n```\nsignalpresence  x  x  x  x  x  x  x              x  x  x  x  x  x  x              x  x  x  x  x  x  x              \ntimesteps       ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^\n```\n\n\nthe missing values are periodically since they came from the frame gap of an image sensor that row frequency is higher than the actual image height.\n\nsetting the missing values to zero distorts the output.\n\nis there a library that handles time/value pairs?\n\n(of course it has to be fast, too :-) )\n    ", "Answer": "\r\nThis is actually non-trivial to solve, as it's a question of how to best educated guess about the missing data. A frequency domain optimized method of interpolation is given by the Lomb-Scargle algorithm, which is available in MATLAB via the ```\nplomb```\n function\n\nMore info:\n\n\nMartin H. Trauth: Data Voids and Spectral Analysis: Don’t Be Afraid Of Gaps!\nC. Munteanu et. al: Effect of data gaps: comparison of different spectral analysis methods\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Polynomial to the power n algorithm\r\n                \r\nWhich is the best way to do polynomial powers? Is it by following the multinomial theorem (wikipedia) which takes O(?) or by FFT (fast Fourier transformation) and then inverse FFT with O((N*log(N))^2)?\n    ", "Answer": "\r\nFFT if you need to do it frequently, or on large polynomials. The naive multiplication algorithm is O(N^2), while FFT is O(N log(N)).\n\nHere is a much better explanation with some neat applications: JeffE FFT\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Where can I find a good FFT sample implementation/tutorial? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI've been looking everywhere for a sample Fast Fourier Transform implementation/tutorial in (preferably) C#.\n\nHowever, every one I've found has been poor at explaining what's going on, and/or poorly commented; or they assume that you already know the FFT algorithm, or they're tutorials about how to USE FFTs.\n\nAnyone know of a good sample/tutorial? \n    ", "Answer": "\r\nApologies for lack of hyperlinks, I do not have permissions to add them :(\n\nYou are asking for two things here\n\n1) An explanation of the FFT\n\nVery briefly:\n\nIf you want to obtain the frequency domain representation of a signal you use the fourier transform, this is a mathematical transform which transforms a signal from the time domain to the frequency domain. When operating on digital signals we have a set of discrete samples so we must use the Discrete Fourier Transform or DFT. However this is a rather slow operation and is easily optimised, so we instead use a Fast Fourier Transform algorithm or FFT.\n\nThis is a large signal processing topic so I suggest you look for a signal processing book to use as a reference. I suggest \"Digital Signal Processing: A Practical Approach\". There is of course the ubiquitous wikipedia article as well.\n\n2) An implementation of the FFT\n\nBecause of the highly optimised nature of the FFT platforms and languages often have specific implementations, you should check headers and documentation (typically it will be found in an 'audio' section) in case it is included in a standard library.\n\nIf you want to implement the algorithm yourself I recommend finding a copy of Numerical Recipes, this contains an entire chapter on the FFT, as well as a chapter on \"Fourier and Spectral Applications\". There is well documented pseudocode which should be easy to transcribe into any language.\n\nFor a third party solution a popular choice is FFTW, a C library. I google search for \"FFT Library\" will provide you with some alternatives.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Power Spectral Density from Accelerometer data\r\n                \r\nI have an accelerometer data i.e. AccX, AccY and AccZ.\n\nI am looking for an algorithm to compute Power Spectral Density from this data. I know the following:\n\n```\nF = fft (s);\n```\n\n\nwhere \"s\" is the input signal and fft is fast fourier transform.\n\n```\nPSD = (1/length(s)) * F * conj(F);\n```\n\n\nI need to know that whether this ```\ns```\n should be acceleration-time series or position-time series?\n    ", "Answer": "\r\nIt depends on what you are interested in. If you want the power spectral density of the acceleration time-series, then ```\ns```\n must be the acceleration time-series itself and not the position time-series.\nNote however that the estimate of the PSD based on that simple algorithm you wrote (called \"periodogram\") may be insufficient in many cases, to get a realistic estimate of the real PSD.\nThe topic is huge, and literature extensive. You can start from Wikipedia or, if you want a suggestion on a good (but rather tough) book, Percival and Walden. To provide more detailed info, one would need to know much more in detail what you have to do from a physical point of view.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "In what circumstances would one use bit shifting operators in a for loops termination condition? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have been looking at some code that fills arrays with samples created using an IFFT (Inverse Fast Fourier Transform).\n\nWhen the author iterates the array he uses an if construct that looks like this:\n\n```\nint idx;\nfor (idx = 1; idx < (tableLen >> 1); idx++) {\n    freqWaveRe[idx] = 1.0 / idx;                    // sawtooth spectrum\n    freqWaveRe[tableLen - idx] = -freqWaveRe[idx];  // mirror\n}\n```\n\n\nCan you explain the terminating condition:\n\n```\nidx < (tableLen >> 1)\n```\n\n\nWhy would you do something like this and what does it mean?\n    ", "Answer": "\r\nThe bit shift operator used in this expression:\n\n```\nidx < (tableLen >> 1)\n```\n\n\nTerminates the for loop after iterating through the first half of the array. The right shift operator moves the value one bit to the right. Moving it one bit to the right divides it by two.\n\n```\n1010 in binary = 10\n```\n\n\nIf we right shift it one bit we get:\n\n```\n0101 in binary = 5\n```\n\n\nA couple more things:\n\nTony D mentioned some comments made that this 'will not work well if ```\nidx```\n is negative'. Negative numbers are represented differently. Sometimes negatives are stored with the first bit representing the sign. If you shift the sign right you will lose that information and cause a bit of a mess.\n\nTony D also said \"it was historically an optimisation when bit-shifting opcodes executed faster than division, and optimisers couldn't be trusted\"\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT on audio file in android\r\n                \r\nI have been searching for Fast Fourier Transform on a audio file but i couldn't get a proper one reg this.All i want to do is to input a audio file and do a FFT on it and give back the result.If there are any links which could serve my purpose will be much helpful.Thanks. \n    ", "Answer": "\r\nhttp://www.fftw.org/ is a C library for FFT.  You'd have to use the NDK to hook into it.\n\nThere are a gpl version for open source projects and a pay version for proprietary projects.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Is there an FFT that uses a logarithmic division of frequency?\r\n                \r\nWikipedia's Wavelet article contains this text:\n\n\n  The discrete wavelet transform is also less computationally complex, taking O(N) time as compared to O(N log N) for the fast Fourier transform. This computational advantage is not inherent to the transform, but reflects the choice of a logarithmic division of frequency, in contrast to the equally spaced frequency divisions of the FFT.\n\n\nDoes this imply that there's also an FFT-like algorithm that uses a logarithmic division of frequency instead of linear?  Is it also O(N)?  This would obviously be preferable for a lot of applications.\n    ", "Answer": "\r\nYes.  Yes.  No.\n\nIt is called the Logarithmic Fourier Transform. It has O(n) time.  However it is useful for functions which decay slowly with increasing domain/abscissa. \n\nReferring back the wikipedia article:\n\n\n  The main difference is that wavelets\n  are localized in both time and\n  frequency whereas the standard Fourier\n  transform is only localized in\n  frequency.\n\n\nSo if you can be localized only in time (or space, pick your interpretation of the abscissa) then Wavelets (or discrete cosine transform) are a reasonable approach.  But if you need to go on and on and on, then you need the fourier transform.\n\nRead more about LFT at http://homepages.dias.ie/~ajones/publications/28.pdf\n\nHere is the abstract:\n\n\n  We present  an exact and analytical expression  for the Fourier transform of  a function that has been  sampled  logarithmically.  The procedure  is  significantly more  efficient  computationally than the fast Fourier  transformation  (FFT)  for  transforming  functions or measured  responses which decay slowly with increasing  abscissa value. We illustrate  the proposed method with an example from electromagnetic geophysics, where  the scaling is often such that our logarithmic Fourier  transform  (LFT) should  be  applied.  For  the example  chosen, we  are able  to obtain results  that  agree with  those from  an FFT to within  0.5 per cent  in  a  time  that  is  a  factor of 1.0e2  shorter. Potential  applications of  our LFT in geophysics include conversion of  wide-band electromagnetic  frequency  responses  to  transient  responses,  glacial  loading  and  unloading, \n  aquifer  recharge problems,  normal mode  and earth  tide  studies in  seismology,  and  impulsive shock wave modelling.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Toeplitz Matrix-Vector multiplication in R\r\n                \r\nI have a n x n symmetrix toeplitz matrix ```\nT```\n, a vector ```\nv```\n of length n, and I would like to compute the matrix-vector product ```\nT%*%v```\n quickly. Is there a package in R that can use the fast fourier transform method of computing ```\nT%*%v```\n (or some other method if one exists)? For example, Matlab has the Toeplitzmult package. \n    ", "Answer": "\r\nThe function below works. Note that the ```\nifft()```\n function requires the ```\npracma```\n library.\n\n```\ntoepmult <- function(A,v){\n    n <- nrow(A)\n    x <- as.matrix(c(A[1,],0,A[1,][n:2]))\n    p <- c(v,rep(0,n))\n    h <- as.vector(fft(p)*fft(x))\n    out <- Re(pracma::ifft(h)[1:n])\n    return( matrix(out,n) )\n}\n```\n\n\nFor a vector/matrix of size 1000, the ```\ntoepmult```\n function takes about 18% of the time ```\nA%*%v```\n takes. \n\n```\nA <- toeplitz(runif(1000))\nv <- runif(1000)\nmicrob(A%*%v,toepmult(A,v),times=1000)\n#Unit: microseconds\n#           expr      min       lq      mean   median        uq      max neval\n#        A %*% v 1515.858 1597.345 1809.3517 1693.533 1957.4350 3868.788  1000\n# toepmult(A, v)  185.901  215.395  331.2928  298.435  347.7335 4611.285  1000\n#[[1]]\n#           [,1]      [,2]\n#median 1693.533   298.435\n#ratio     1.000     0.176\n#diff      0.000 -1395.098\n```\n\n\nFor a vector/matrix of size 10,000, the ```\ntoepmult```\n function takes about 2.5% of the time ```\nA%*%v```\n takes. \n\n```\nA <- toeplitz(runif(10000))\nv <- runif(10000)\nmicrob(A%*%v,toepmult(A,v),times=1000)\n#Unit: milliseconds\n#           expr        min         lq       mean     median         uq      max neval\n#        A %*% v 145.834304 160.395663 181.842779 170.396014 186.221449 495.2003  1000\n# toepmult(A, v)   2.802058   4.077408   4.990894   4.322707   4.911103 180.4926  1000\n#[[1]]\n#          [,1]     [,2]\n#median 170.396    4.323\n#ratio    1.000    0.025\n#diff     0.000 -166.073\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How do I find, plot, and output the peaks of a live plotted Fast Fourier Transform (FFT) in Python?\r\n                \r\nI am working with the ```\npyaudio```\n and ```\nmatplotlib```\n packages for the first time and I am attempting to plot live audio data from microphone input, transform it to frequency domain information, and then output peaks with an input distance. This project is a modification of the three-part guide to build a spectrum analyzer found here.\nCurrently the code is formatted in a class as I have alternative methods that I am applying to the audio but I am only posting the class with the relevant methods as they don't make reference to each and are self-contained. Another quirk of the program is that it calls upon a local file though it only uses input from the user microphone; this is a leftover from the original functionality of plotting a sound file's intensity while it played and is no longer integral to the code.\n```\nimport pyaudio\nimport wave\nimport struct\nimport pandas as pd\nfrom scipy.fftpack import fft\nfrom scipy.signal import find_peaks\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nclass Wave:\n    def __init__(self, file) -> None:\n        self.CHUNK = 1024 * 4\n        self.obj = wave.open(file, \"r\")\n        self.callback_output = []\n        self.data = self.obj.readframes(self.CHUNK)\n        self.rate = 44100\n\n        # Initiate an instance of PyAudio\n        self.p = pyaudio.PyAudio()\n\n        # Open a stream with the file specifications\n        self.stream = self.p.open(format = pyaudio.paInt16,\n                                  channels = self.obj.getnchannels(),\n                                  rate = self.rate,\n                                  output = True,\n                                  input = True,\n                                  frames_per_buffer = self.CHUNK)\n        \n    def fft_plot(self, distance: float):\n        x_fft = np.linspace(0, self.rate, self.CHUNK)\n        fig, ax = plt.subplots()\n        line_fft, = ax.semilogx(x_fft, np.random.rand(self.CHUNK), \"-\", lw = 2)\n\n        # Bind plot window sizes\n        ax.set_xlim(20, self.rate / 2)\n\n        plot_data = self.stream.read(self.CHUNK)\n        self.data_int = pd.DataFrame(struct.unpack(\\\n                        str(self.CHUNK * 2) + 'h', plot_data)).astype(dtype = \"b\")[::2]\n\n        y_fft = fft(self.data_int)\n        line_fft.set_ydata(np.abs(y_fft[0:self.CHUNK]) / (256 * self.CHUNK))\n\n        plt.show(block = False)\n\n        while True:\n            # Read incoming audio data\n            data = self.stream.read(self.CHUNK)\n            \n            # Convert data to bits then to array\n            self.data_int = struct.unpack(str(4 * self.CHUNK) + 'B', data)\n            \n            # Recompute FFT and update line\n            yf = fft(self.data_int)\n            line_data = np.abs(yf[0:self.CHUNK])  / (128 * self.CHUNK)\n            line_fft.set_ydata(line_data)\n\n            # Find all values above threshold\n            peaks, _ = find_peaks(line_data, distance = distance)\n\n            # Update the plot\n            plt.plot(peaks, line_data[peaks], \"x\")\n            fig.canvas.draw()\n            fig.canvas.flush_events()\n\n            # Exit program when plot window is closed\n            fig.canvas.mpl_connect('close_event', exit)\n\ntest_file = \"C:/Users/Tam/Documents/VScode/Final Project/PrismGuitars.wav\"\n\naudio_test = Wave(test_file)\naudio_test.fft_plot(2000)\n```\n\nThe code does not throw any errors and runs fine with an okay framerate and only terminates when the plot window is closed, all of which is good. The issue I'm encountering is with the determination and plotting of the peaks of ```\nline_data```\n as when I run this code the output over time looks like this matplotlib graph instance.\nIt seems that the peaks (or peak) are being found but at a lower frequency than the x of ```\nline_data```\n and as such are shifted comparatively. The other, more minor, issue is that since this is a live plot I would like to clear the previous instance of the peak marker so that it only shows the current instance and not all of the ones plotted prior.\nI have attempted in prior fixes to use the ```\nline_fft```\n in the peak detection but as it is cast to a Line2D format the peak detection algorithm isn't able to deal with the data type. I have also tried implementing a list comprehension as seen in this post but the time to cast to list is prohibitively slow and did not return any peak markers when I ran it.\nEDIT: Following Jody's input the program now returns the proper values as I was only printing an index for the x-coordinate of the peak marker. Nevertheless I would still appreciate some insight as to whether it is possible to update per marker rather than having all the previous ones constantly displayed.\nAs for the marker updating I have attempted to clear the plot in the ```\nwhile```\n loop both before and after drawing the markers (in different tests of course) but I only ever end up with a completely blank graph.\nPlease let me know if there is anything I should clarify and thank you for your time.\n    ", "Answer": "\r\nAs Jody pointed out the ```\npeaks```\n variable contains indexes for the detected peaks that then need to be retrieved from ```\nx_fft```\n and ```\nline_data```\n in order to match up with the displayed data.\nFirst we create a scatter plot:\n```\nscat = ax.scatter([], [], c = \"purple\", marker = \"x\")\n```\n\nThis data can then be stacked using a container variable in the ```\nwhile```\n loop as such:\n```\narray_peaks = np.c_[x_fft[peaks], line_data[peaks]]\n```\n\nand update the data in the ```\nwhile```\n loop with:\n```\nscat.set_offsets(array_peaks)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to record to .wav from microphone after applying fast fourier transform and a high pass filter on it?\r\n                \r\nI receive input from the microphone and I apply the fft on it.\nAfter that, I put frequencies higher than 1KHz with zero (the high pass filter).\n\nI want to know how can I record the input from microphone after I passed it to fft and after the application of the high pass filter.\n\nI'm working with c#, what do I need to do? :P\n    ", "Answer": "\r\nAfter your FFT and filter, you need to do an inverse FFT to get the data back to the time domain. Then you want to add that set of samples to your .WAV file.\n\nAs far as producing the file itself goes, the format is widely documented (Googling for \".WAV format\" should turn up more results than you have any use for), and pretty simple. It's basically a simple header (called a \"chunk\") that says it's a .WAV file (or actually a \"RIFF\" file). Then there's an \"fmt \" chunk that tells about the format of the samples (bits per sample, samples per second, number of channels, etc.) Then there's a \"data\" chunk that contains the samples themselves.\n\nSince it sounds like you're going to be doing this in real time, my advice would be to forget about doing your FFT, filter, and iFFT. An FIR filter will give essentially the same results, but generally a lot faster. The basic idea of the FIR filter is that instead of converting your data to frequency domain, filtering it, then converting back to time domain, you convert your filter coefficients to time domain, and apply them (fairly) directly to your input data. This is where DSPs earn their keep: nearly all of them have multiply-accumulate instructions, which can implement most of a FIR filter in one instruction. Even without that, however, getting a FIR filter to run in real time on a modern processor doesn't take any real trick unless you're doing really fast sampling. In any case, it's a lot easier that getting an FFT/filter/iFFT to operate at the same speed.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier transform floating point issues\r\n                \r\nI am implementing a conventional (that means not fast), separated Fourier transform for images. I know that in floating point a sum over one period of sin or cos in equally spaced samples is not perfectly zero, and that this is more a problem with the conventional transform than with the fast.\n\nThe algorithm works with 2D double arrays and is correct. The inverse is done inside (over a double sign flag and conditional check when using the asymmetric formula), not outside with conjugations. Results are nearly 100% like expected, so its a question about details:\n\nWhen I perform a forward transform, save logarithmed magnitude and angle to images, reload them, and do an inverse transform, I experience different types of rounding errors with different types of implemented formulas:\n\n\nF(u,v) = Sum(x=0->M-1) Sum(y=0->N-1) f(x,y) * e^(-i*2*pi*u*x/M) * e^(-i*2*pi*v*y/N)\n\nf(x,y) = 1/M*N * (like above)\nF(u,v) = 1/sqrt(M*N) * (like above)\n\nf(x,y) = 1/sqrt(M*N) * (like above)\n\n\nSo the first one is the asymmetric transform pair, the second one the symmetric. With the asymmetric pair, the rounding errors are more in the bright spots of the image (some pixel are rounded slightly outside value range (e.g. 256)). With the symmetric pair, the errors are more in the constant mid-range area of the image (no exceeding of value range!). In total, it seems that the symmetric pair produces a bit more rounding errors.\n\nThen, it also depends of the input: when image stored in [0,255] the rounding errors are other than when in [0,1].\n\nSo my question: how should an optimal, most accurate algorithm be implemented (theoretically, no code): asymmetric/symmetric pair? value range of input in [0,255] or [0,1]? How linearly upscaling result before saving logarithmed one to file?\n\nEdit:\n\nmy algorithm simply computes the separated asymmetric or symmetric DFT formula. Factors are decomposed into real and imaginary part using Eulers identity, then expanded and sumed up separately as real and imaginary part:\n\n```\nsum_re += f_re * cos(-mode*pi*((2.0*v*y)/N)) - // mode = 1 for forward, -1\n          f_im * sin(-mode*pi*((2.0*v*y)/N));  // for inverse transform\n// sum_im permutated in the known way and + instead of -\n```\n\n\nThis value grouping indside cos and sin should give in my eyes the lowest rounding error (compared to e.g. ```\ncos(-mode*2*pi*v*y/N)```\n), because not multiplicating/dividing significantly false rounded transcedental pi several times, but only one time. Isn't it?\n\nThe scale factor ```\n1/M*N```\n or ```\n1/sqrt(M*N)```\n is applied separately after each separation outside of the innermost sum. Better inside? Or combined completely at the end of both separations?\n\nFor some deeper analysis, I have quitted the ```\ninput->transform->save-to-file->read-from-file->transform^-1->output```\n workflow and chosen to compare directly in double-precision: ```\ninput->transform->transform^-1->output```\n.\n\nHere the results for an real life 704x528 8-bit image (delta = max absolute difference between real part of input and output):\n\n\nwith input inside [0,1] and asymmetric formula: delta = 2.6609e-13 (corresponds to 6.785295e-11 for [0,255] range).\nwith input insde [0,1] and symmetric formula: delta = 2.65232e-13 (corresponds to 6.763416e-11 for [0,255] range).\nwith input inside [0,255] and asymmetric formula: delta = 6.74731e-11.\nwith input inside [0,255] and symmetric formula: delta = 6.7871e-11.\n\n\nThese are no real significant differences, however, the full ranged input with the asymmetric transform performs best. I think the values may get worse with 16-bit input.\n\nBut in general I see, that my experienced issues are more because of scaling-before-saving-to-file (or inverse) rounding errors, than real transformation rounding errors.\n\nHowever, I am curious: what is the most used implementation of the Fourier transform: the symmetric or asymmetric? Which value range is in general used for the input: [0,1] or [0,255]? And usual shown spectra in log scale: e.g. [0,M*N] after asymmetric transform of [0,1] input is directly log-scaled to [0,255] or before linearly scaled to [0,255*M*N]?\n    ", "Answer": "\r\nThe errors you report are tiny, normal, and generally can be ignored. Simply scale your results and clamp any results outside the target interval to the endpoints.\n\nIn library implementations of FFTs (that is, FFT routines written to be used generally by diverse applications, not custom designed for a single application), little regard is given to scaling; the routine often simply returns data that has been naturally scaled by the arithmetic, with no additional multiplication operations used to adjust the scale. This is because the scale is often either irrelevant for the application (e.g., finding the frequencies with the largest energies works no matter what the scale is) or that the scale may be distributed through multiply operations and performed just once (e.g., instead of scaling in a forward transform and in an inverse transform, the application can get the same effect by explicitly scaling just once). So, since scaling is often not needed, there is no point in including it in a library routine.\n\nThe target interval that data are scaled to depends on the application.\n\nRegarding the question on what transform to use (logarithmic or linear) for showing spectra, I cannot advise; I do not work with visualizing spectra.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How do i create a node in OpenVX Framework to find the FFT(Fast fourier transform) of an image?\r\n                \r\nDoes anyone know how to create a user-node to calculate the FFT of an image or videoframe using the OpenVXFramework. I want find the FFT values form video frames to calculate the vibration in video frames.\n    ", "Answer": "\r\nYou may consider using an FFT library in OpenCL - clFFT, Open CV or Vulkan -VkFFT. Some information on interoperability is available in the OpenVX Programming Guide and also in the Khronos OpenVX tutorial.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Values after FFT\r\n                \r\nI'm trying to create an audio visualizer.\n\nI'm using the fast Fourier transform to find the frequencies.\n\n```\nmemset(_window, 0, sizeof(float)*_windowSize);\nmemset(_A.imagp, 0, nOver2 * sizeof(float));\n\nvDSP_hann_window(_window, _windowSize, vDSP_HANN_NORM);\n\nfor (int i=0; i < _windowSize; i++) {\n    if (player && ioData) {\n        _inPutBuffer[i] = ((SInt16*) ioData->mBuffers[0].mData)[i];\n    }\n}\n\nvDSP_vmul(_inPutBuffer, 1, _window, 1, _transferBuffer, 1, _windowSize);\n\nvDSP_ctoz((COMPLEX*)_transferBuffer, 2, &(_A), 1, nOver2);\n\nvDSP_fft_zrip(_fftSetup, &_A, stride, log2n, FFT_FORWARD);\n\nvDSP_vsmul(_A.realp, 1, &_scale, _A.realp, 1, nOver2);\nvDSP_vsmul(_A.imagp, 1, &_scale, _A.imagp, 1, nOver2);\n\n_A.imagp[0] = 0.0f;\n\nvDSP_zvmags(&_A, 1, _obtainedReal, 1, nOver2);\n\nfloat frequencyArray[n];\n\nfor (int i=1; i <=kIndicatorsCount; i++ ) {\n    float res = 0;\n    for (int j=0; j <=32; j++) {\n        res += _obtainedReal[i*32+j];\n    }\n    res = res / 32;\n    OutputBuff[i] = res;\n}\n```\n\n\nBut the output is very different values, for example, in one case the output values ​​can be from 0 to 1, and the other from 0 to 5.0E +6.\n\nIs it possible to bring the output values ​​to a certain range (Eg 0 to 1)?\n    ", "Answer": "\r\nThe magnitude output of the FFT is usually visualized in decibels for this very reason.  Decibels allow very small components to still be seen when large components are present.  The conversion is simple.  Since ```\nvDSP_zvmags```\n gives the squared magnitude, you can convert to dB with:\n\n```\ndbval = 10 * log10(mag2val);\n```\n\n\nor see ```\nvDSP_vdbcon```\n.\n\nThis could be normalized between 0 and 1 by dividing by the maximum value of your dB values, but you probably don't want to change this reference point dynamically since it would cause visualization of a constant magnitude to jump around. It would probably be better to just figure out what ranges are typical and normalize to that fixed value.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to correctly apply fft function to a dataframe\r\n                \r\nWhy do I get this error while applying ```\nfft```\n (Fast Fourier Transform) to a data frame? If I use the same function on each variable by itself there is no error.\n\n```\ndf<-read.table(text=\"pregnant glucose blood skin INSULIN MASS  DIAB AGE CLASS  predict_probability \n                                  1     106    70   28     135 34.2 0.142  22     0       0.15316285       \n               1      91    54   25     100 25.2 0.234  23     0       0.05613959       \n               4     136    70    0       0 31.2 1.182  22     1       0.54034794       \n               9     164    78    0       0 32.8 0.148  45     1       0.64361578       \n               3     173    78   39     185 33.8 0.970  31     1       0.79185196       \n               11     136    84   35     130 28.3 0.260  42     1       0.31927737       \n               0     141    84   26       0 32.4 0.433  22     0       0.41609308       \n               3     106    72    0       0 25.8 0.207  27     0       0.10460090       \n               9     145    80   46     130 37.9 0.637  40     1       0.67061324       \n               10     111    70   27       0 27.5 0.141  40     1       0.16152296       \n               \",header=T)\n```\n\n\nIf I write ```\nfft(df$pregnant)```\n I get the needed results but I try to use it on the whole data frame ```\nfft(df)```\n I get this error:\n\n\n  Error in fft(df) : non-numeric argument\n\n    ", "Answer": "\r\nUse only the numeric columns:\n\n```\n    apply(df,2,function(x) fft(as.numeric(x)))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to remove first three harmonics from a daily data time series?\r\n                \r\nI have the time series of a meteorological variable - Daily data for 10 years.\nTime series\n\nI would like to remove the first 3 harmonics from the time series.\nI don't come from EE background, and finding it tough to understand Fast Fourier Transform.\nHow can I proceed with this? A python or R example would be great.\n    ", "Answer": "\r\nAs @simple_code mentioned, if you don’t care about the signal components prior to and in-between the harmonics, you can just apply a high pass filter with a cut-off frequency above the 3rd harmonic.\nIf you do care about signal components prior to and in-between the 3 harmonics, then you’d want to go for 3 notch filters.   Scipy has what you need if working in Python.\nLet me know if you need more help\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How do I set up a buffer when doing an FFT using the Accelerate framework?\r\n                \r\nI'm using the Accelerate framework to perform a Fast Fourier Transform (FFT), and am trying to find a way to create a buffer for use with it that has a length of 1024.  I have access to the average peak and peak of a signal on which I want to do the FFT.\n\nCan somebody help me or give me some hints to do this?\n    ", "Answer": "\r\nApple has some examples of how to set up FFTs in their vDSP Programming Guide.  You should also check out the vDSP Examples sample application.  While for the Mac, this code should translate directly across to iOS as well.\n\nI recently needed to do a simple FFT of an 64 integer input waveform, for which I used the following code:\n\n```\nstatic FFTSetupD fft_weights;\nstatic DSPDoubleSplitComplex input;\nstatic double *magnitudes;\n\n+ (void)initialize\n{\n    /* Setup weights (twiddle factors) */\n    fft_weights = vDSP_create_fftsetupD(6, kFFTRadix2);\n\n    /* Allocate memory to store split-complex input and output data */\n    input.realp = (double *)malloc(64 * sizeof(double));\n    input.imagp = (double *)malloc(64 * sizeof(double));\n    magnitudes = (double *)malloc(64 * sizeof(double));\n}\n\n- (CGFloat)performAcceleratedFastFourierTransformAndReturnMaximumAmplitudeForArray:(NSUInteger *)waveformArray;\n{   \n    for (NSUInteger currentInputSampleIndex = 0; currentInputSampleIndex < 64; currentInputSampleIndex++)\n    {\n        input.realp[currentInputSampleIndex] = (double)waveformArray[currentInputSampleIndex];\n        input.imagp[currentInputSampleIndex] = 0.0f;\n    }\n\n    /* 1D in-place complex FFT */\n    vDSP_fft_zipD(fft_weights, &input, 1, 6, FFT_FORWARD);  \n\n    input.realp[0] = 0.0;\n    input.imagp[0] = 0.0;\n\n    // Get magnitudes\n    vDSP_zvmagsD(&input, 1, magnitudes, 1, 64);\n\n    // Extract the maximum value and its index\n    double fftMax = 0.0;\n    vDSP_maxmgvD(magnitudes, 1, &fftMax, 64);\n\n    return sqrt(fftMax);\n}\n```\n\n\nAs you can see, I only used the real values in this FFT to set up the input buffers, performed the FFT, and then read out the magnitudes.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Template Matching using FFT more efficient with gray-scale images?\r\n                \r\nIs Template Matching using FFT more efficient if the source and template images are gray-scale images?\n\nAlso, let me piggy back. Does any one know of an excellent tutorial to implement Template matching using Fast Fourier Transforms?\n\nThanks.!\n    ", "Answer": "\r\nRe excellent tutorial: J.P \"Zilla\" Lewis's paper on Fast Normalized Cross-Correlation is hard to beat. Truly a classic.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "About the fft function\r\n                \r\nDoes anyone know which algorithm is used in Julia to perform the fast Fourier transform? The documentation only says:\n\n```\n...\nA one-dimensional FFT computes the one-dimensional discrete Fourier transform (DFT) as defined by\n\n\\operatorname{DFT}(A)[k] =\n  \\sum_{n=1}^{\\operatorname{length}(A)}\n  \\exp\\left(-i\\frac{2\\pi\n  (n-1)(k-1)}{\\operatorname{length}(A)} \\right) A[n].\n...\n```\n\n\nIn particular, I have a discrepancy in my transformed data, i.e. this transformed data is \"shifted\" a phase of  I think ```\npi```\n. Is there a convention to fix this global phase?\n\nEDIT: \nPerhaps it's worth saying that if I perform the inverse fft, then the discrepancy in the phase is corrected.\n    ", "Answer": "\r\nJulia uses the FFTW library, I believe, which uses several variants of the Cooley-Tukey algorithm, as described in the reference below.\n\nhttp://www.fftw.org/fftw-paper-ieee.pdf\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Understanding Schönhage-Strassen algorithm (huge integer multiplication)\r\n                \r\nI need to multiply several 1000s digits long integers as efficiently as possible in Python. The numbers are read from a file.\n\nI am trying to implement the Schönhage-Strassen algorithm for integer multiplication, but I am stuck on understanding the definition and mathematics behind it, specially the Fast Fourier Transform.\n\nAny help to understand this algorithm, like a practical example or some pseudo-code would be highly appreciated.\n    ", "Answer": "\r\nChapter 4.3.3 of Knuth's TAOCP describes it and also has some FFT pseudocode in other chapters that could be used for this.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT time series with no change in data?\r\n                \r\ni want to calculate a Fast Fourier Transform, i want to see the rate that network packets are send over the network. For that, i count the packets being send per second.\n\nSome packets have a sending rate of 1Hz, this results in this time series data: ```\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]```\n\n\nIs there a way for perform ```\nFFT```\n on this array? I always get ```\n0Hz```\n as result. Or is this not a case for a ```\nFFT```\n?\n```\n[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1]```\n works fine..\n\nSo basically I want transform this:\n\n\n\ninto this:\n\n\n    ", "Answer": "\r\nBefore digging into the details of your problem, let's illustrate some theory using time series nomenclature.\n\nGiven a certain function ```\nf(t)```\n, this can be sampled with a certain frequency ```\nΔt```\n for a certain period of time ```\nT = n * Δt```\n called the duration (```\nn```\n being the number of samples).\nNow you can apply the Discrete Fourier Transform (DFT) to ```\nf(t)```\n and you obtain the frequency distribution ```\nF(ν)```\n, which is also a (complex) function with the same number of samples ```\nn```\n.\nI assume you are familiar with the meaning of frequency distribution, and I will not discuss this further.\nThe only property I would like to highlight here is that DFT is defined circularly, meaning that it is assumed that ```\nf(t) = f(t + T)```\n for all ```\nt```\n and analogously ```\nF(ν) = F(ν + Ν)```\n for all ```\nν```\n (```\nΝ```\n being the frequency period), i.e. that they are both periodic.\n\nThe fundamental question now is: what is the sampling ```\nΔν```\n and the duration ```\nΝ```\n of ```\nν```\n for ```\nF(ν)```\n? Of course, Wikipedia knows this. \nAs you might guess, this is related to ```\nΔt```\n and ```\nT```\n.\nIn particular: ```\nΔν = 1 / T```\n and hence ```\nΝ = n * Δν = 1 / Δt```\n.\n\nNumPy implements DFT using the Fast Fourier Transform (FFT) algorithm, which has some nice properties with regards to ```\nF(ν)```\n, most notably it always computes the 0th frequency (i.e. ```\nF(ν = 0)```\n) and in the absence of shifts this is also the first coefficient of ```\nF(ν)```\n.\nNote that because of the periodicity of ```\nF(ν)```\n the negative frequencies are actually after the positive frequencies.\nTo get ```\nF_ν```\n centered around ```\nF(ν = 0)```\n you have to use: ```\nnp.fft.fftshift()```\n.\nIf ```\nn```\n is even, ```\nF(ν = 0)```\n is the first value in the right half of ```\nF_ν```\n and extra care is required to define ```\nν_shift```\n correctly and represent ```\nF(ν)```\n with negative and positive ```\nν```\n values.\n\nTo get a feeling of what the plots should be, please refer again to Wikipedia for notable Fourier transform function pairs.\n\nJust to illustrate all this with code, here is some that computes DFT for the superposition of two sinusoidal waves:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nπ = np.pi\n\n# Number of samples\nn = 400\n\n# Time uration and sampling\nT = 80\nΔt = T / n\nprint(f'Δt = {Δt}, T = {T}')\n# Δt = 0.2, T = 80\n\n# Frequency duration and sampling\nΔν = 1 / T\nΝ = 1 / Δt # or: n * Δν\nprint(f'Δν = {Δν}, Ν = {Ν}')\n# Δν = 0.0125, Ν = 5.0\n\n# Define time and frequency (endpoint=False takes care of periodicity)\nt = np.linspace(0, T, n, endpoint=False)  \nν = np.linspace(0, Ν, n, endpoint=False)\n# Generate a certain f(t) = A₀ sin(ν₀ * 2πt) + A₁ sin(ν₁ * 2πt)\nν_ = 1, 2\nA_ = 1, 3\nf_t = A_[0] * np.sin(ν_[0] * 2 * π * t) + A_[1] * np.sin(ν_[1] * 2 * π * t)\n\n# Compute the F(ν) as the DFT(f(t))\n# F(ν) ∝ A₀ (δ(ν - ν₀) + δ(ν + ν₀)) + A₁ (δ(ν - ν₁) + δ(ν + ν₁))\n# δ is the [Dirac Delta function][3]\nF_ν = np.fft.fft(f_t)\n\n# Center F(ν) around ν = 0\nF_ν_shift = np.fft.fftshift(F_ν)\nν_shift = ν - (Ν / 2) + (Δν / 2 if n % 2 else 0)\n\n# Plot the result\nfig, axs = plt.subplots(1, 3, figsize=(16, 4), squeeze=False)\naxs[0, 0].plot(t, f_t)\naxs[0, 1].plot(ν, 2.0 / n * np.abs(F_ν))\naxs[0, 2].plot(ν_shift, 2.0 / n * np.abs(F_ν_shift))\naxs[0, 1].axvline(ν_[0], color='green')\naxs[0, 1].axvline(ν_[1], color='orange')\naxs[0, 2].axvline(ν_[0], color='green')\naxs[0, 2].axvline(ν_[1], color='orange')\nplt.show()\n```\n\n\n\n\n(You should probably play around with the above code to understand what FFT is doing).\n\nNote that in all this the sampling frequency did not show up as a peak in ```\nF(ν)```\n! It does play a role, but in effects like aliasing and spectral leakage, both related to the Shannon-Nyquist theorem.\n\n\n\nNow, to your problem, you are comparing ```\nf_t```\n when this is basically a constant -- whose Fourier transform is a Dirac Delta centered at ```\nν = 0```\n, ```\nδ(0)```\n -- and when this is an alternating function, which could be seen as ```\nsin(ν₀ * 2πt)```\n for ```\nν₀ = Ν / 2```\n -- whose Fourier transform is (as before) proportional to a sum of Dirac's deltas at ```\nν = ±ν₀ = ±Ν / 2```\n.\n\nThe code below will help you visualize what is happening:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nπ = np.pi\n\n# Number of samples\nn = 20\n\n# Time duration and sampling\nT = 20\nΔt = T / n\n\n# Frequency duration and sampling\nΔν = 1 / T\nΝ = 1 / Δt\n\n# Define time and frequency\nt = np.linspace(0, T, n, endpoint=False)\nν = np.linspace(0, Ν, n, endpoint=False)\n\n# Plot the result\nfig, axs = plt.subplots(2, 3, figsize=(16, 8), squeeze=False)\n\n# Plotting DFT for constant function\nf_t = np.array([1 for _ in range(n)])\nF_ν = np.fft.fft(f_t)\nF_ν_shift = np.fft.fftshift(F_ν)\nν_shift = ν - (Ν / 2) + (Δν / 2 if n % 2 else 0)\n\naxs[0, 0].plot(t, f_t)\naxs[0, 1].plot(ν, 2.0 / n * np.abs(F_ν))\naxs[0, 2].plot(ν_shift, 2.0 / n * np.abs(F_ν_shift))\naxs[0, 1].axvline(0, color='green')\naxs[0, 2].axvline(0, color='green')\n\n# Plotting DFT for an alternating function\nf_t = np.array([i % 2 for i in range(n)])\nF_ν = np.fft.fft(f_t)\nF_ν_shift = np.fft.fftshift(F_ν)\nν_shift = ν - (Ν / 2) + (Δν / 2 if n % 2 else 0)\n\naxs[1, 0].plot(t, f_t)\naxs[1, 1].plot(ν, 2.0 / n * np.abs(F_ν))\naxs[1, 2].plot(ν_shift, 2.0 / n * np.abs(F_ν_shift))\naxs[1, 1].axvline(0, color='green')\naxs[1, 1].axvline(Ν / 2, color='orange')\naxs[1, 2].axvline(0, color='green')\naxs[1, 2].axvline(Ν / 2, color='orange')\naxs[1, 2].axvline(-Ν / 2, color='orange')\n\nplt.show()\n```\n\n\n\n\n(Note that the peak at ```\nν = +Ν / 2```\n is not actually there because when ```\nn```\n is even, the positive frequencies are 1 sample less than the negative frequencies and the peak is EXACTLY at the edge.)\n\nWe can observe that there is a peak in the middle of the non-shifted FFT for the alternating series, that is not present for the constant one.\n\nHence, what you observe is correct, BUT your interpretation is wrong.\n\nIf we assume that the constant and the alternating ```\nf(t)```\n are obtained at the same sampling rate, we can conclude that there is no relationship between the sampling rate and the appearance of ```\nF(ν)```\n.\n\nOn the other hand, if we assume that the constant and the alternating ```\nf(t)```\n are two sampling of the same event with different sampling rate and the alternating one is obtained at a higher sampling rate (which is not the situation described in the above plots), then we can conclude that the emergence of the additional peaks at ```\nν = ±Ν / 2 = ±1 / (2 Δt)```\n is related to the insufficient sampling of ```\nf(t)```\n when the function appeared constant.\nThe position of these new peaks is a manifestation of aliasing which is related to the Shannon-Nyquist theorem mentioned earlier.\n\n\n\nFinally, if you want to observe network traffic analytics the number of packets per unit of time IS already \"the rate that network packets are send over the network\".\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Apply FFT to a both channels of a stereo signal separately?\r\n                \r\nI'm reading a wave-file and would like to apply the fast fourier transformation to it.\nHowever I've got a stereo signal and I'm wondering what to do with the left and right channel. Does the FFT need to be applied to both channels separately?\n    ", "Answer": "\r\nYes and no.\nCertainly the FFT of each channel is independent, so you want separate FFTs for each of them.\nHowever, it is possible to compute two FFTs of real data using one call to a routine for FFTs of complex data and some additional arithmetic. This is described in Numerical Recipes and here. One real signal is used as the real part of a complex signal, and the second real signal is used as the imaginary part. Their transforms can be separated in the result with the additional arithmetic.\nThis works because the FFT is a linear operation, so the real and imaginary parts of the transform are separable in a sense, and the symmetry in a real-to-complex FFT makes that separation relatively simple.\nFFT routines in published libraries are typically highly optimized. Unless the code for the additional arithmetic is also well optimized, it may be faster to make two calls to a real-to-complex FFT routine than to make one call to a complex-to-complex FFT routine supplemented with your own implementation of the additional arithmetic.\nA common use of FFTs is to transform a signal, multiply by the transform of a real impulse-response filter, and perform the inverse transform. In this case, it is not necessary to separate the two signals; the multiplication may be performed on the combined data, and the new signals will be separated by the inverse transform.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to downsample Fourier complex values?\r\n                \r\nDisclaimer: I'm not a signal processing expert.\n\nI'm writing a function that takes a 1D array and performs Fast Fourier Transform on it. Here's how it works:\n\n\nIf the array's size is not a power of two, pad it with 0s at the end so that its size becomes a power of two.\nPerform FFT on the padded array and store the results in an array ```\nx```\n.\nDownsample the complex array ```\nx```\n to match the length of the original non-padded array.\nReturn ```\nx```\n.\n\n\nI'm having trouble with step 3. If I omit step 3 and perform inverse FFT on the result of the function call, I get the initial padded array which means the function successfully performs steps 1 and 2.\n\nI tried implementing step 3 by downsampling using linear interpolation, but when I perform inverse fourier transform on the final result using MatLab, the results I got were not equivalent to the original array. The programming language I need to use is not MatLab, I'm only using MatLab to verify correctness of the results.\n\nWhat techniques can I use to perform step 3 while still being able to get back the original non-padded array after inverse FFT?\n    ", "Answer": "\r\nUse circular Sinc kernel interpolation to compute the down sampled points.  The Sinc width will that of a low-pass filter with a cut-off appropriate to anti-alias for the new lower down-sampled sample rate.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to perform the FFT to a wave-file using NAudio\r\n                \r\nI'm working with the NAudio-library and would like to perform the fast fourier transformation to a WaveStream. I saw that NAudio has already built-in the FFT but how do I use it?\n\nI heard i have to use the SampleAggregator class.\n    ", "Answer": "\r\nYou need to read this entire blog article to best understand the following code sample I lifted to ensure the sample is preserved even if the article isn't:\n\n```\nusing (WaveFileReader reader = new WaveFileReader(fileToProcess))\n{\n    IWaveProvider stream32 = new Wave16toFloatProvider(reader);\n    IWaveProvider streamEffect = new AutoTuneWaveProvider(stream32, autotuneSettings);\n    IWaveProvider stream16 = new WaveFloatTo16Provider(streamEffect);\n    using (WaveFileWriter converted = new WaveFileWriter(tempFile, stream16.WaveFormat))\n    {\n        // buffer length needs to be a power of 2 for FFT to work nicely\n        // however, make the buffer too long and pitches aren't detected fast enough\n        // successful buffer sizes: 8192, 4096, 2048, 1024\n        // (some pitch detection algorithms need at least 2048)\n        byte[] buffer = new byte[8192]; \n        int bytesRead;\n        do\n        {\n            bytesRead = stream16.Read(buffer, 0, buffer.Length);\n            converted.WriteData(buffer, 0, bytesRead);\n        } while (bytesRead != 0 && converted.Length < reader.Length);\n    }\n}\n```\n\n\nbut in short, if you get the WAV file created you can use that sample to convert it to FFT.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Using C within Python code for faster fourier transform? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 26 days ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have a function that computes the fourier transform of an incoming audio stream, and then identifies what musical notes are most dominant within the audio. Everything is working (though I'm sure my code may be janky in many ways). The main thing I'd like to fix is the speed of the function. I'm using a chunk size of 2^14, which makes the function quite accurate, but also way slower than I'd like. I was wondering if there is any way to implement a C fft function that could run faster, but still have it run within my Python code. I'm also open to any other suggestions on how to get this function to run faster.\nHere is the current function:\n```\ndef pitch_calculations(stream, CHUNK, RATE):\n    # Read mic stream and then call struct.unpack to convert from binary data back to floats\n    data = stream.read(CHUNK, exception_on_overflow=False)\n    dataInt = np.array(struct.unpack(str(CHUNK) + 'h', data))\n    \n    # Apply a window function (Hamming) to the input data\n    windowed_data = np.hamming(CHUNK) * dataInt\n\n    # Using numpy fast Fourier transform to convert mic data into frequencies\n    fft_result = np.abs(fft.fft(windowed_data, threads=6)) * 2 / (11000 * CHUNK)\n    fft_result_copy = fft_result\n    freqs = np.fft.fftfreq(len(windowed_data), d=1.0 / RATE)\n    \n    fft_result = fft_result[:int(len(fft_result)/2)]\n    freqs = freqs[:int(len(freqs)/2)]\n    \n    # Find the indices of local maxima in the frequency spectrum using scipy.signal find_peaks\n    localmax_indices = find_peaks(fft_result, height=0.04)[0]\n    \n    # Get the magnitudes of the local maxima\n    strong_freqs = fft_result[localmax_indices]\n    \n    # Sort the magnitudes in descending order\n    sorted_indices = np.argsort(strong_freqs)[::-1]\n    \n    # Calculate the pitches from the peaks, calculate how many cents sharp/flat\n    pitches = []\n    \n    for index in sorted_indices:\n        pitches.append(abs(freqs[localmax_indices[index]]))\n        \n    note_list = [calculate_tuning(pitch)[0] for pitch in pitches]\n    cent_list = [calculate_tuning(pitch)[1] for pitch in pitches]\n    note_list = order_pitches(note_list)\n    note_list = remove_duplicates(note_list)\n    \n    \n    return note_list, cent_list\n```\n\n    ", "Answer": "\r\nAs others have said, numpy already performs the underlying FFT computation with optimized native code.\nThe real problem is that a transform size of 2^14 is a nontrivial cost by any implementation. Suggestions to speed it up:\n\nReduce the audio sample rate and/or the transform size, if possible. 2^14 seems very high for determining musical note frequencies. It might be enough to downsample the audio to, say, 24 kHz (e.g. with librosa.resample) and use a transform size of 4096, for a spectrum with frequency resolution of 5.9 Hz per bin. Then use interpolation to estimate peaks with sub-bin percision.\nUse float32 instead of float64: Before the transform, use ```\nwindowed_data = windowed_data.astype(np.float32)```\n to cast to float32.\nUse real-to-complex FFTs with np.fft.rfft instead of the standard complex-to-complex transform. This might save near a factor 2 in computation time.\nProcess a batch of windows at a time, instead of one by one. Particularly, a batch of FFTs is in some cases more efficiently computed than computing FFTs individually. Use for instance ```\nnp.fft.rfft(x, axis=0)```\n with ```\nx```\n being a 2D array to compute the real-to-complex FFT of each column of ```\nx```\n.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "call matlab ifft from c\r\n                \r\nI have a short question: I would like to call the matlab fuction ifft from c code （inverse fast fourier transform）\n\nI was trying to understand the matlab api for c , but I could not  find any example on how to pass the arguments or how to call an internal fuction of matlab within c code\n\nany hint will be greatly appreciated ! \n\nJulia\n    ", "Answer": "\r\nYou can generate C code from a script using the MATLAB Coder app. That should make the ifft callable. The ugliest way to do it would be to exec() matlab and re-ingest its output. Oliver's answer is certainly the cleanest and best route though. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to find peaks of FFT graph using Python?\r\n                \r\nI am using Python to perform a Fast Fourier Transform on some data. I then need to extract the locations of the peaks in the transform in the form of the x-values. Right now I am using Scipy's fft tool to perform the transform, which seems to be working. However, when i use Scipy's find_peaks I only get the y-values, not the x-position that I need. I also get the warning:\n```\nComplexWarning: Casting complex values to real discards the imaginary part\n```\n\nIs there a better way for me to do this? Here is my code at the moment:\n```\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft\nfrom scipy.signal import find_peaks\n\nheaders = [\"X\",\"Y\"]\n\noriginal_data = pd.read_csv(\"testdata.csv\",names=headers)\n\nx = original_data[\"X\"]\ny = original_data[\"Y\"]\n\na = fft(y)\npeaks = find_peaks(a)\nprint(peaks)\n\nplt.plot(x,a)\nplt.title(\"Fast Fourier transform\")\nplt.xlabel(\"Frequency\")\nplt.ylabel(\"Amplitude\")\nplt.show()\n```\n\n    ", "Answer": "\r\nThere seem to be two points of confusion here:\n\nWhat find_peaks is returning.\nHow to interpret complex values that the FFT is returning.\n\nI will answer them separately.\nPoint #1\nfind_peaks returns the indices in \"a\" that correspond to peaks, so I believe they ARE values you seek, however you must plot them differently. You can see the first example from the documentation here. But basically \"peaks\" is the index, or x value, and a[peaks] will be the y value. So to plot all your frequencies, and mark the peaks you could do:\n```\nplt.plot(a)\nplt.plot(peaks, a[peaks])\n```\n\nPoint #2\nAs for the second point, you should probably read up more on the output of FFTs, this post is a short summary but you may need more background to understand it.\nBut basically, an FFT will return an array of complex numbers, which contains both phase and magnitude information. What you are currently doing is implicitly only looking at the real part of the solution (hence the warning that the imaginary portion is being discarded), what you probably want instead to take the magnitude of your \"a\" array, but without more information on your application it is impossible to say.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how write complex numbers to one csv file in each row?\r\n                \r\nI want to to store a complex number of each image which is generated by using Fast Fourier transform which is of type complex 128.\n the code is as follow:\n\n```\nimport cv2\nimport glob\nimport numpy as np\nbloodVessal=[]\nfor file in glob.glob('/home/raviraj/PycharmProjects/Diabetic/testing/*.jpeg'):\n    img=cv2.imread(file)\n    cv2.imshow('file',img)\n    img = cv2.resize(img, (255, 255), interpolation=cv2.INTER_CUBIC)\n\n    # split image\n    b, g, r = cv2.split(img)\n    cv2.imshow(\"green window\", g)\n\n    # creating CLAHE histogram\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n    claheImg = clahe.apply(g)\n    cv2.imshow('clahe image', claheImg)\n\n    # Edge Detection\n    edge = cv2.Canny(claheImg, 165, 40)\n    cv2.imshow('Edge detection ', edge)\n\n    # FFT\n    f = np.fft.fft2(edge)\n\n    np.savetxt('/home/raviraj/PycharmProjects/Diabetic/testing/blood vessel.csv', f, delimiter=',')\n\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n```\n\n\nthis code is creating a CSV file with 255 rows and 255 column. I want just one column and 200 rows.In which each row contain data of each image in just single line.\n    ", "Answer": "\r\nI'm assuming you want to save the list ```\nbloodVessel```\n to a plain text file. To do so with a single column, append the following after the loop:\n\n```\nnp.savetxt('data.csv',bloodVessel,delimiter=',')\n```\n\n\nThis will create a file called ```\ndata.csv```\n that looks like,\n\n```\n(0.000000000000000000e+00+1.000000000000000000e+00j)\n(5.000000000000000000e+00+3.000000000000000000e+00j)\n```\n\n\nIf you want the real and imaginary parts in separate columns (and want the comma delimiter):\n\n```\nnp.savetxt('data.csv',[np.real(bloodVessel),np.imag(bloodVessel)],delimiter=',')\n```\n\n\nwhich will instead create a file that looks like,\n\n```\n0.000000000000000000e+00,+1.000000000000000000e+00\n5.000000000000000000e+00,+3.000000000000000000e+00\n```\n\n\nI would also recommend preallocating ```\nbloodVessel```\n as a numpy array of complex type rather than appending to a list to foster good habits.\n\nIN RESPONSE TO THE COMMENT AND THE APPARENT REWRITE OF THE QUESTION\n\nBefore you were saving your Fourier coefficients in the list ```\nbloodVessel```\n by appending. At the moment, I'm not sure how you're editing your code. However, if your Fourier data is now NOT just a single complex value, then you can still do what was mentioned above, just save the coefficient that you want in the list rather than the whole array of coefficients. \n\nThat is, go from ```\nbloodVessel.append(f)```\n to ```\nbloodVessel.append(f[0])```\n, where I am assuming you want to only save the first coefficient.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Can getID3 get data of mp3 file that is input for FFT?\r\n                \r\nI want to compare two pieces of music to find similarities. But actually, I don't understand what Fast Fourier Transform is. I don't even know the parameter of the FFT function(from https://gist.github.com/mbijon/1332348). \n\nMy questions are: \n\n\nWhat are the parameters to FFT function?\nDoes getID3 function provide these parameters?\nIf not, how can I get these paramaters?\n\n\nHere is my code.\n\n```\n<?php\n    require_once('assets/getID3/getid3/getid3.php');\n    require_once('FFT.php');\n    $getID3 = new getID3;\n    $ThisFileInfo = $getID3->analyze(\"music.mp3\");\n    $bit_rate = $ThisFileInfo['audio']['bitrate'];\n    var_dump($bit_rate);\n?>\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What is the significance of the output of this FFT function?\r\n                \r\nI have the following periodic data which has a period of ~2000:\n\nI am trying to discover the period of the data and the offset of the first peak. I have the following FFT function to perform a Fourier Transform:\n\n```\ntypedef double _Complex cplx;\n\nvoid _fft(cplx buf[], cplx out[], int n, int step){\n    if (step < n) {\n        _fft(out, buf, n, step*2);\n        _fft(out+step, buf+step, n, step*2);\n\n        for(int i=0; i<n; i+=step*2) {\n            cplx t = cexp(-I * M_PI * i / n) * out[i + step];\n            buf[i / 2]     = (out[i] + t);\n            buf[(i + n)/2] = (out[i] - t);\n        }\n    }\n}\n\nvoid fft(cplx* buf, int n){\n    cplx* out = (cplx*)malloc(sizeof(cplx) * n);\n    memcpy(out, buf, sizeof(cplx)*n);\n    _fft(buf, out, n, 1);\n\n    for(int i=0; i<n; i++){ buf[i] /= n; }\n\n    free(out);\n}\n```\n\n\nWhich has been adapted from here: Fast Fourier Transformation (C) (link contains a full running example with main function and example data)\n\nI understand that a Fourier Transform converts time series data into frequency data. Each frequency has a amplitude and a phase. However, I am having a hard time understanding the output given by this function. Graphing the output gives me this:\n\nI have tried graphing the real component, the imaginary component, and the magnitude of both components. Each attempt gives a very similar-looking graph. \n\nAm I wrong to assume there should be a spike at ~2000?\nAm I miss-interpreting the output of this function?\n    ", "Answer": "\r\n\n  Am I wrong to assume there should be a spike at ~2000?\n\n\nYes, because 2000 is the period you're interested in, not the frequency. It looks like you're running a 32,768-point FFT, so you should expect to find a peak in bin #16 (16 cycles per 32k = periods of approximately 2048 samples), not bin #2000.\n\nIf you want something that reports directly in terms of number of samples, instead of frequency, you may want an autocorrelation, instead of an FFT. Your signal would have autocorrelation peaks at lags of 2000, 4000, etc.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Reconciling difference in fft output between pytorch 1.5.0 and pytorch 1.9.0\r\n                \r\nI am attempting to make some python3 code that works with pytorch 1.5.0 also work correctly on newer versions (I am currently using pytorch 1.9.0). More specifically, I am attempting to update the code which does fast fourier transforms. I am trying to replace torch.rfft() in pytorch 1.5.0 with torch.fft.fftn() and torch.view_as_real() in pytorch 1.9.0. I noticed that I am getting a slightly different output when I run the following:\nUsing PyTorch 1.5.0:\n```\nimport torch\nimport numpy as np\narr = torch.from_numpy(np.array([[1.,2.,3.,4.,5.],\n                                 [6.,7.,8.,9.,10.],\n                                 [11.,12.,13.,14.,15.],\n                                 [16.,17.,18.,19.,20.]]))\nftt_arr = torch.rfft(arr,2,onesided=False)\nprint(fft_arr)\n```\n\nUsing PyTorch 1.9.0:\n```\nimport torch\nimport numpy as np\narr = torch.from_numpy(np.array([[1.,2.,3.,4.,5.],\n                                 [6.,7.,8.,9.,10.],\n                                 [11.,12.,13.,14.,15.],\n                                 [16.,17.,18.,19.,20.]]))\nfft_arr = torch.fft.fftn(arr,norm=\"backward\")\nfft_arr = torch.view_as_real(fft_arr)\nprint(fft_arr)\n```\n\nThe outputs for the two Fast Fourier Transforms are the following:\npytorch 1.5.0:\n```\ntensor([[[211.0000,   0.0000],\n         [-10.8090,  13.1760],\n         [ -9.6910,   4.2003],\n         [ -9.6910,  -4.2003],\n         [-10.8090, -13.1760]],\n\n        [[-50.0000,  51.0000],\n         [  0.5878,  -0.8090],\n         [ -0.9511,   0.3090],\n         [  0.9511,   0.3090],\n         [ -0.5878,  -0.8090]],\n\n        [[-51.0000,   0.0000],\n         [  0.8090,   0.5878],\n         [ -0.3090,  -0.9511],\n         [ -0.3090,   0.9511],\n         [  0.8090,  -0.5878]],\n\n        [[-50.0000, -51.0000],\n         [ -0.5878,   0.8090],\n         [  0.9511,  -0.3090],\n         [ -0.9511,  -0.3090],\n         [  0.5878,   0.8090]]], dtype=torch.float64)\n```\n\npytorch 1.9.0:\n```\ntensor([[[ 2.1000e+02,  0.0000e+00],\n         [-1.0000e+01,  1.3764e+01],\n         [-1.0000e+01,  3.2492e+00],\n         [-1.0000e+01, -3.2492e+00],\n         [-1.0000e+01, -1.3764e+01]],\n\n        [[-5.0000e+01,  5.0000e+01],\n         [ 2.2204e-15,  0.0000e+00],\n         [ 1.7764e-15, -4.4409e-16],\n         [ 1.7764e-15, -4.4409e-16],\n         [ 2.2204e-15,  0.0000e+00]],\n\n        [[-5.0000e+01,  0.0000e+00],\n         [-1.7764e-15,  0.0000e+00],\n         [-8.8818e-16,  0.0000e+00],\n         [-8.8818e-16,  0.0000e+00],\n         [-1.7764e-15,  0.0000e+00]],\n\n        [[-5.0000e+01, -5.0000e+01],\n         [ 2.2204e-15,  0.0000e+00],\n         [ 1.7764e-15,  4.4409e-16],\n         [ 1.7764e-15,  4.4409e-16],\n         [ 2.2204e-15,  0.0000e+00]]], dtype=torch.float64)\n```\n\nAll the output values seem to vary by around +/- 1, which I am unable to explain or reconcile.\n    ", "Answer": "\r\nI hope the following helps\n```\nimport torch\na = torch.arange(0,4).view(1,1,2,2).float()\nprint(a)\n```\n\nNow begins code for PyTorch 1.9\n```\ndef dft_amp(img):\n    fft_im = torch.view_as_real(torch.fft.rfftn(img, dim=(2,3),norm=\"backward\"))\n    #torch.rfft( img, signal_ndim=2, onesided=False )\n    print('Pytorch FFT 1.9',fft_im)\n    fft_amp = fft_im[:,:,:,:,0]**2 + fft_im[:,:,:,:,1]**2\n    return torch.sqrt(fft_amp + 1e-10)\n\nb = dft_amp(a)\nprint('Pytorch 1.9 amp', b)\n```\n\nThe output for PyTorch 1.9 is\n```\ntensor([[[[0., 1.],\n          [2., 3.]]]])\nPytorch FFT 1.9 tensor([[[[[ 6.,  0.],\n           [-2.,  0.]],\n\n          [[-4.,  0.],\n           [ 0.,  0.]]]]])\nPytorch 1.9 amp tensor([[[[6.0000e+00, 2.0000e+00],\n          [4.0000e+00, 1.0000e-05]]]])\n```\n\nNow begins code for PyTorch 1.5\n```\ndef dft_amp(img):\n    fft_im = torch.rfft( img, signal_ndim=2, onesided=False )#torch.view_as_real(torch.fft.rfftn(a, dim=(2,3),norm=\"backward\"))\n    \n    print('Pytorch FFT 1.5',fft_im)\n    fft_amp = fft_im[:,:,:,:,0]**2 + fft_im[:,:,:,:,1]**2\n    return torch.sqrt(fft_amp + 1e-10)\n\nb = dft_amp(a)\nprint('Pytorch 1.5 amp', b)\n```\n\nThe output for PyTorch 1.5 version is\n```\ntensor([[[[0., 1.],\n          [2., 3.]]]])\nPytorch FFT 1.5 tensor([[[[[ 6.,  0.],\n           [-2.,  0.]],\n\n          [[-4.,  0.],\n           [ 0.,  0.]]]]])\n1.5 amp tensor([[[[6.0000e+00, 2.0000e+00],\n          [4.0000e+00, 1.0000e-05]]]])\n```\n\nValues in both versions match !\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "python: Fast Fourier Transform data points (0) when the vector being passed through is non zero or NaN\r\n                \r\nI am trying to set up a different numerical integration for each value of ```\nN```\n.  All my variables dependent on ```\nN```\n are returning correctly (I printed the results to make sure everything was coming back fine without NaN or all zeros).  However, I keep receiving the following error:\n\n```\nValueError: Invalid number of FFT data points (0) specified.\n```\n\n\nBut the ```\nu```\n vector has data points.\n\n```\nimport numpy as np\n\nL = 80.0\ndt = 0.0002\ntmax = 10\nnmax = int(np.floor(tmax / dt))\ndeltax = []\nerror = []\n\nfor N in [1., 2., 4., 8., 16., 32., 64., 128., 256., 512.]:\n    dx = L / N\n    deltax.append(dx)\n    x = np.arange(-L / 2.0, L / 2.0 - dx, dx)\n    k = np.hstack((np.arange(0, N / 2.0 - 1.0),\n                   np.arange(-N / 2.0, 0))).T * 2.0 * np.pi / L\n    k1 = 1j * k\n    k3 = (1j * k) ** 3\n    u = 2 * (2 / (np.exp(x + 20.0) + np.exp(-x - 20.0))) ** 2\n    udata = u\n    tdata = 0.0\n    #  integration\n    for nn in range(1, nmax + 1):\n        du1 = (-np.fft.ifft(k3 * np.fft.fft(u)) -\n               3 * np.fft.ifft(k1 * np.fft.fft(u ** 2)))\n        v = u + 0.5 * du1 * dt\n        du2 = (-np.fft.ifft(k3 * np.fft.fft(v)) -\n               3 * np.fft.ifft(k1 * np.fft.fft(v ** 2)))\n        v = u + 0.5 * du2 * dt\n        du3 = (-np.fft.ifft(k3 * np.fft.fft(v)) -\n               3 * np.fft.ifft(k1 * np.fft.fft(v ** 2)))\n        v = u + du3 * dt\n        du4 = (-np.fft.ifft(k3 * np.fft.fft(v)) -\n               3 * np.fft.ifft(k1 * np.fft.fft(v ** 2)))\n        u = u + (du1 + 2.0 * du2 + 2.0 * du3 + du4) * dt / 6.0\n        error.append(max(abs(u[:,-1] - 2. *\n                             (2. / (np.exp(x - 20) + np.exp(-x - 60))))))\n        if np.mod(nn, np.ceil(nmax / 20.0)) == 0:\n            udata = np.vstack((udata, u))\n            tdata = np.vstack((tdata, nn * dt))\n```\n\n\nSo all the vectors are being populate but I don't know what the problem is.\nIf I set ```\nN```\n to one number and remove that ```\nfor```\n loop, everything works fine but when I add the loop, it all breaks down.\nUnfortunately, I can't figure it out.\n\nIf you test the code by setting ```\nN = 64```\n or something, you then have to comment out ```\ndeltax```\n and ```\nerror.append```\n.\n    ", "Answer": "\r\nFor ```\nN = 1```\n you have ```\ndx = 80.```\n and ```\nx = numpy.arange(-40, -40, 80)```\n which gives you an array of size ```\n0```\n. Consequently, ```\nu```\n has size ```\n0```\n too, which ```\nfft```\n does not like.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to Inverse FFT in Arduino\r\n                \r\nI am trying to filter some data based on the the following code using Arduino FFT library for FFT (fast Fourier transform) \n\n```\n/*\nfft_adc_serial.pde\nguest openmusiclabs.com 7.7.14\nexample sketch for testing the fft library.\nit takes in data on ADC0 (Analog0) and processes them\nwith the fft. the data is sent out over the serial\nport at 115.2kb.\n*/\n\n#define LOG_OUT 1 // use the log output function\n#define FFT_N 256 // set to 256 point fft\n\n#include <FFT.h> // include the library\n\nvoid setup() {\n  Serial.begin(115200); // use the serial port\n  TIMSK0 = 0; // turn off timer0 for lower jitter\n  ADCSRA = 0xe5; // set the adc to free running mode\n  ADMUX = 0x40; // use adc0\n  DIDR0 = 0x01; // turn off the digital input for adc0\n}\n\nvoid loop() {\n  while(1) { // reduces jitter\n    cli();  // UDRE interrupt slows this way down on arduino1.0\n    for (int i = 0 ; i < 512 ; i += 2) { // save 256 samples\n      while(!(ADCSRA & 0x10)); // wait for adc to be ready\n      ADCSRA = 0xf5; // restart adc\n      byte m = ADCL; // fetch adc data\n      byte j = ADCH;\n      int k = (j << 8) | m; // form into an int\n\n      k -= 0x0200; // form into a signed int\n      k <<= 6; // form into a 16b signed int\n      fft_input[i] = k; // put real data into even bins\n     // Serial.print(millis());\n     // Serial.print(\"input \");\n     // Serial.print(i);\n    //  Serial.print(\" = \");\n      Serial.println(k);\n      fft_input[i+1] = 0; // set odd bins to 0\n      delay(0.1);\n    }\n    fft_window(); // window the data for better frequency response\n    fft_reorder(); // reorder the data before doing the fft\n    fft_run(); // process the data in the fft\n    fft_mag_log(); // take the output of the fft\n    sei();\n    Serial.println(\"start\");\n\n   for (byte i = 0; i < FFT_N/2; i++) {\n     if(i<10 || i>20)\n     {\n       fft_log_out[i] = 0;\n     }\n\n     Serial.println(fft_log_out[i]);\n   }    \n  }\n}\n```\n\n\nAfter applying the filter like this:\n\n```\nif(i<10 || i>20)\n     {\n       fft_log_out[i] = 0;\n     }\n```\n\n\nI then need to Inverse FFT data ```\nfft_log_out[]```\n.\n\nI looked for an Inverse FFT function (in particular in http://wiki.openmusiclabs.com/wiki/FFTFunctions) but can't find it anywhere.\n\nSo how can I get the Inverse FFT in Arduino?\n    ", "Answer": "\r\nThe inverse FFT can be obtained by making use of the forward transform:\n\n```\nfor (int i = 0 ; i < 512 ; i += 2) {\n  fft_input[i] =  (fft_input[i] >> 8);\n  fft_input[i+1] = -(fft_input[i+1] >> 8);\n}\nfft_reorder();\nfft_run();\n// For complex data, you would then need to negate the imaginary part\n// but we can skip this step since you have real data.\n```\n\n\nNote however that your filtering code has a few issues. \n\nFirst, the results of the forward FFT are complex numbers which carry both magnitude and phase information. Using ```\nfft_mag_log```\n only takes the magnitude, which alone is not sufficient for recovery of the original signal. You should thus use the complete FFT output left in ```\nfft_input```\n array as input to your filtering code.\n\nSecond, the FFT of real valued data results in a spectrum with Hermitian symmetry. To get a real valued filtered output, you must preserve that symmetry.\nSo, you should not completely zero out the values in the upper half of the spectrum:\n\n```\nfor (byte i = 0; i < FFT_N; i+=2) {\n  if (! ((i>=20 && i<=40) || (i>=FFT_N-40 && i<=FFT_N-20)))\n  {\n    fft_input[i] = 0;\n    fft_input[i+1] = 0;\n  }\n}\n```\n\n\nThird, the filtering would be applied to each block of data independently of each other, always assuming that previous inputs were zeros. This typically results in discontinuities at the block boundaries. To avoid this, you should consider using the overlap-add method.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "python: Fast Fourier Transform data points (0) when the vector being passed through is non zero or NaN\r\n                \r\nI am trying to set up a different numerical integration for each value of ```\nN```\n.  All my variables dependent on ```\nN```\n are returning correctly (I printed the results to make sure everything was coming back fine without NaN or all zeros).  However, I keep receiving the following error:\n\n```\nValueError: Invalid number of FFT data points (0) specified.\n```\n\n\nBut the ```\nu```\n vector has data points.\n\n```\nimport numpy as np\n\nL = 80.0\ndt = 0.0002\ntmax = 10\nnmax = int(np.floor(tmax / dt))\ndeltax = []\nerror = []\n\nfor N in [1., 2., 4., 8., 16., 32., 64., 128., 256., 512.]:\n    dx = L / N\n    deltax.append(dx)\n    x = np.arange(-L / 2.0, L / 2.0 - dx, dx)\n    k = np.hstack((np.arange(0, N / 2.0 - 1.0),\n                   np.arange(-N / 2.0, 0))).T * 2.0 * np.pi / L\n    k1 = 1j * k\n    k3 = (1j * k) ** 3\n    u = 2 * (2 / (np.exp(x + 20.0) + np.exp(-x - 20.0))) ** 2\n    udata = u\n    tdata = 0.0\n    #  integration\n    for nn in range(1, nmax + 1):\n        du1 = (-np.fft.ifft(k3 * np.fft.fft(u)) -\n               3 * np.fft.ifft(k1 * np.fft.fft(u ** 2)))\n        v = u + 0.5 * du1 * dt\n        du2 = (-np.fft.ifft(k3 * np.fft.fft(v)) -\n               3 * np.fft.ifft(k1 * np.fft.fft(v ** 2)))\n        v = u + 0.5 * du2 * dt\n        du3 = (-np.fft.ifft(k3 * np.fft.fft(v)) -\n               3 * np.fft.ifft(k1 * np.fft.fft(v ** 2)))\n        v = u + du3 * dt\n        du4 = (-np.fft.ifft(k3 * np.fft.fft(v)) -\n               3 * np.fft.ifft(k1 * np.fft.fft(v ** 2)))\n        u = u + (du1 + 2.0 * du2 + 2.0 * du3 + du4) * dt / 6.0\n        error.append(max(abs(u[:,-1] - 2. *\n                             (2. / (np.exp(x - 20) + np.exp(-x - 60))))))\n        if np.mod(nn, np.ceil(nmax / 20.0)) == 0:\n            udata = np.vstack((udata, u))\n            tdata = np.vstack((tdata, nn * dt))\n```\n\n\nSo all the vectors are being populate but I don't know what the problem is.\nIf I set ```\nN```\n to one number and remove that ```\nfor```\n loop, everything works fine but when I add the loop, it all breaks down.\nUnfortunately, I can't figure it out.\n\nIf you test the code by setting ```\nN = 64```\n or something, you then have to comment out ```\ndeltax```\n and ```\nerror.append```\n.\n    ", "Answer": "\r\nFor ```\nN = 1```\n you have ```\ndx = 80.```\n and ```\nx = numpy.arange(-40, -40, 80)```\n which gives you an array of size ```\n0```\n. Consequently, ```\nu```\n has size ```\n0```\n too, which ```\nfft```\n does not like.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Level out FFT graph (Processing)\r\n                \r\nI am trying to make a music visualizer in Processing, not that that part is super important, and I'm using a fast fourier transform through Minim. It's working perfectly (reading the data), but there is a large spike on the left (bass) end. What's the best way to 'level' this out?\nMy source code is here, if you want to take a look.\n\n\n\nThanks in advance,\n-tlf\n    ", "Answer": "\r\nThe spectrum you show looks fairly typical of a complex musical sound where you have a complex section at lower frequencies, but also some clear harmonics emerging from the low frequency mess.  And, actually, these harmonics are atypically clear... music in general is complicated.  Sometimes, for example, if a flute is playing a single clear note one will get a single nice peak or two, but it's much more common that transients and percussive sounds lead to a very complicated spectrum, especially at low frequencies.\n\nFor comparing directly to the video, it seems to me that the video is a bit odd.  My guess is that the spectrum they show is either a zoom in a small section of the spectrum far from zero, or that it's just a graphical algorithm that's based off the music but doesn't correspond to an actual spectrum.  That is, if you really want something to look very similar to this video, you'll need more than the spectrum, though the spectrum will likely be a good starting point.  Here are a few points to note:\n1) there is a prominent peak which occasionally appears right above the \"N\" in the word anchor.  A single dominant peak should be clear in the audio as an approximately pure tone.\n2) occasionally there's another peak that varies temporally with this peak, which would normally be a sign that the second peak is a harmonic, but many times this second peak isn't there.\n3) A good examples of odd behavior, is a 2:26.  This time just follows a little laser sound effect, and then there's basically a quite hiss.  A hiss should be a broad spectrum sound without peaks, often weighted to lower frequencies.  At 2:26, though, there's just this single large peak above the \"N\" with nothing else.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Java/Android - Distorted Audio using FFT in realtime\r\n                \r\nthis question is most relevant for users with experience using the JTransform package for Fast Fourier Transforms. I'm attempting to eventually create an equalizer as part of a larger realtime audio project. Right now I was simply attempting to apply the Fourier transform, then use the inverse method to get back the original data, then output that audio. What I'm getting is highly distorted audio. I wonder if anyone has any experience doing this sort of thing?\n\nI apply the transform in a callback method after sampling the audio input.\n\n```\npublic void onMarkerReached(AudioRecord recorder)\n double[] input = new double[buffers[ix].length];\nfor(int i=0;i<input.length;i++)\n            {\n                input[i] = (double)buffers[ix][i];\n            }\nDoubleFFT_1D ft = new DoubleFFT_1D(input.length);\n            ft.realForward(input);\n            //some filtering here\n            ft.realInverse(input, false);\n            for(int i=0;i<input.length;i++)\n            {\n                buffers[ix][i] = (short)input[i];\n            }\n\n\n                player.write(buffers[ix], 0,\n                        buffers[ix].length);\n}\n}\n```\n\n\nAm I losing part of the signal as a result of only keeping the real part of the transform? Since it's only audio data the input should be real-only, right? Not sure what I'm doing wrong here, any input would be greatly appreciated!\n    ", "Answer": "\r\nI tested your snippet, using ft.realInverse(input, true); along with proper sample size fixed the distortion for me.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to pass computer audio to a program for visualization purposes?\r\n                \r\nUsing Visual Basic, or C# - I would like to write an audio visualization program to use Fast Fourier transform - once I've got the audio stream, I can complete the program myself without help. However, I cannot find a way to input the entirety of the Windows computer's audio through the visualizer. \n\nDoes anyone know a way to do this, perhaps using the IAudioClient Interface?\n    ", "Answer": "\r\nHave a look at this post. It is using ```\nCSCore```\n.  Maybe you can use this sample for getting your audio stream.  \n\nThis library has also a inbuilt visualisation sample on its github repo -- please consider downloading and using it.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Numpy Finding complex conjugate [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Conjugate transpose operator \".H\" in numpy\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nIs there a way to compute for the complex conjugate, given an array with complex elements? \n\nI have an array consisting of imaginary elements using fast Fourier transform (fft.fft) and would like to return a list with the complex conjugate of each element.\n\nI was thinking of extracting the imaginary bits by using nparray.imag, but it creates a list without \"j\" to denote imaginary.\n\nAny help will be appreciated. \n    ", "Answer": "\r\nIf you have a numpy array of complex numbers, ```\narr```\n, you can use:\n\n```\narr.conj()\n```\n\n\nto create an array consisting of the conjugates of ```\narr```\n.  You can also use ```\narr.conjugate()```\n, which is a synonym.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to convert alphabets to numerical values with spaces and return it back to alphabets?\r\n                \r\nWant to convert the alphabet to numerical values and transform it back to alphabets using some mathematical techniques like fast Fourier transform in MATLAB.\n\nExample:\nThe following is the text saved in \"text2figure.txt\" file\n\n```\nHi how r u am fine take care of your health \nthank u very much\nam 2.0\n```\n\n\nReading it in MATLAB:\n\n```\ndata=fopen('text2figure.txt','r')\nd=fscanf(data,'%s')\ntemp = fileread( 'text2figure.txt' ) \ntemp = regexprep( temp, ' {6}', '   NaN' ) \nc=cellstr(temp(:))'\n```\n\n\nNow I wish to convert cell array with spaces to numerical values/integers:\n\n```\ncoding = 'abcdefghijklmnñopqrstuvwxyz .,;'\nstr = temp %// example text\n[~, result] = ismember(str, coding)\ny=result\n\n\nresult =\n\n  Columns 1 through 18\n\n     0     9    28     8    16    24    28    19    28    22    28     1    13    28     6     9    14     5\n\n  Columns 19 through 36\n\n    28    21     1    11     5    28     3     1    19     5    28    16     6    28    26    16    22    19\n\n  Columns 37 through 54\n\n    28     8     5     1    12    21     8    28     0     0    21     8     1    14    11    28    22    28\n\n  Columns 55 through 71\n\n    23     5    19    26    28    13    22     3     8     0     0     1    13    28     0    29     0\n```\n\n\n\n\nNow I wish to convert the numerical values back to alphabets:\n\n```\nHi how r u am fine take care of your health \nthank u very much\nam 2.0\n```\n\n\nHow to write a MATLAB code to return the numerical values in the variable ```\nresult```\n to alphabets?\n    ", "Answer": "\r\nMost of the code in the question doesn't have any useful effects. These three lines are the ones that lead to ```\nresult```\n:\n\n```\nstr = fileread('test2figure.txt');\ncoding = 'abcdefghijklmnñopqrstuvwxyz .,;';\n[~, result] = ismember(str, coding);\n```\n\n\n```\nismember```\n returns, in the second output argument, the indices into ```\ncoding```\n for each element of ```\nstr```\n. Thus, ```\nresult```\n are indices that we can use to index into ```\ncoding```\n:\n\n```\nout = coding(result);\n```\n\n\nHowever, this does not work because some elements of ```\nstr```\n do not occur in ```\ncoding```\n, and for those elements ```\nismember```\n returns 0, which is not a valid index. We can replace the zeros with a new character:\n\n```\ncoding = ['*',coding];\nout = coding(result+1);\n```\n\n\nBasically, we're shifting each code by one, adding a new code for 1.\n\nOne of the characters we're missing here is the newline character. Thus the three lines have become one line. You can add a code for the newline character by adding it to the ```\ncoding```\n table:\n\n```\nstr = fileread('test2figure.txt');\ncoding = ['abcdefghijklmnñopqrstuvwxyz .,;',char(10)]; % char(10) is the newline character\n[~, result] = ismember(str, coding);\n\ncoding = ['*',coding];\nout = coding(result+1);\n```\n\n\n\n\nAll of this is easier to achieve just using the ASCII code table:\n\n```\nstr = fileread('test2figure.txt');\nresult = double(str);\n\nout = char(result);\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "formula Amplitude using FFT\r\n                \r\nI want to ask about the formula of amplitude bellow. I am using Fast Fourier Transform. So it returns real and complex numbers. \nafter that I must search amplitude for each frequency.\n\nMy formula is \n\n```\namplitude = 10 * log (real*real + imagined*imagined)\n```\n\n\nI want to ask about this formula. What is it source? I have been search,  but I don't found any source. Can anybody tell me about that source?\n    ", "Answer": "\r\nThis is a combination of two equations:  \n\n1: Finding the magnitude of a complex number (the result of an FFT at a particular bin)  - the equation for which is \nm = ```\nsqrt(r^2 + i ^2)```\n\n\n2: Calculating relative power in decibels from an amplitude value - the equation for which is ```\np =10 * log10(A^2/Aref^2) == 20 log10(A/Aref)```\n where ```\nAref```\n is a some reference value.  \n\nBy inserting ```\nm```\n from equation 1 into ```\na```\n from equation 2 with ```\nARef = 1```\n we get:\n\n```\np = 10 log(r^2 + i ^ 2)```\n\n\nNote that this gives you a measure of relative signal power rather than amplitude.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT frequency of sound\r\n                \r\nOn microphone at some time, starts flowing sound defined frequency(500hz). How do I know when the signal began to come to the microphone? To solve this problem, I know that I need to use FFT(Fast Fourier transform). But I dont understand, how should I take after FFT frequency? I'm use NAudio on C#. And my buffer from microphone is byte array.\n    ", "Answer": "\r\nUsing an FFT for this is overkill and not particularly appropriate. A much simpler solution for this kind of problem (tone detection/onset detection) is the Goertzel filter.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Amplitude from scipy.fft\r\n                \r\nWhy is the amplitude I compute far, far away from original after fast Fourier transform (FFT)?\n\nI have a signal with 1024 points and sampling frequency of 1/120000. I apply the fast Fourier transform in Python with scipy.fftpack. I normalize the calculated magnitude by number of bins and multiply by 2 as I plot only positive values.\n\nAs my initial signal amplitude is around 64 dB, I get very low amplitude values less then 1.\n\nPlease see my code.\n\n```\nSignal = well.ReadWellData(SignalNDB)\ny, x = Signal.GetData(numpy=np)\nN = y.size      # Number of sample points 1024 ...\nT = 1/120000    # sampling frequency (sec)\nx = np.linspace(0.0, N*T, N)\n\nyf = abs(fft(y)) # Perform fft returning Magnitude\nxf = np.linspace(0.0, 1.0/(2.0*T), N//2) # Calculatel frequency bins\n\nfreqs = fftfreq(N, T)    \n\nax1=plt.subplot(211) \nax1.plot(x,y)\nplt.grid()\nax2=plt.subplot(212) \nyf2 = 2/N * np.abs(yf[0:N//2]); # Normalize Magnitude by number of bins and multiply by 2\nax2.semilogy(xf, yf2) # freq vs ampl - positive only freq    \nplt.grid()    \nax1.set_title([\"check\"]) \n#ax2.set_xlim([0,4000])\n\nplt.show()\n```\n\n\nPlease see my plot:\n\n\n\nEDIT:\n\nFinally my signal Amplitude after fft is exactly what I expected. What I did.\n\nFirst I did fft for signal in mV. Then I converted the results to dB as per the formula: 20*log10(mV)+60; where 60 represents 1 mV proveded by the tool manufacturer.Therefore dB values presented on a linear scale format @ the bottom plot rather than on the log format.\n\nPlease see the resulting plot below.\nResults\n    ", "Answer": "\r\nLooks good to me. The FFT, or the Fourier transform in general, gives you the representation of your time-domain signal in the frequencies domain.\n\nBy taking a look at your signal, you have two main components : something oscillating at around 500Hz (period of 0.002s) and an offset (which corresponds to freq = 0Hz). Looking at the result of the FFT, we can see mainly two peaks : one at 0Hz and the other one could be at 500Hz (difficult to be sure without zooming on the signal).\n\nThe only relation between the intensities is defined by the Parseval's theorem, but having a signal oscillating around 64dB doesn't mean its FFT should have values close to 64dB. I suggest you take a look here.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "order of output in scipy.fftpack.fft2\r\n                \r\nI have three columns of data I read in, so that I have an \nN by 3 array; first two columns are ```\nx```\n and ```\ny```\n, spatial, and the third\nis a value ```\ndelta```\n. I want to get the 2-dimensional Fast Fourier\nTransform of this data so, having the N by 3 array ```\ndata```\n I do, having\nimported ```\nfftpack```\n from ```\nscipy```\n, \n\n```\nf = fftpack.fft2(data)```\n \n\nI look at ```\nf```\n. Which column in ```\nf```\n, an N x 3 array, is the value of the transform,\nand which columns are k_x and k_y ? \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Capturing Sound for Analysis and Visualizing Frequencies in Android\r\n                \r\nI'm new in Android and  I'm trying to make a program which captures an audio sound  and then displays the frequencies that exist within it. I found an example that draws the graphic portion of a graphic equalizer. In this example it is used an object of type\nAudioRecord to capture audio sound. The technique used to break an audio signal down into component frequencies employs  a mathematic transformation called a discrete Fourier transform (DFT) and to perform DFT it is used a fast Fourier transform (FFT). This example use a package which implements the FFT. The package is linked here www.netlib.org/fftpack/jfftpack.tgz. \nThe problem is that after I run this example the graphic equalizer doesn't appear on the display after I press the start button.\n\nHere is the source code for the activity class: \n\n```\npackage com.audio.processing;\nimport android.app.Activity;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.media.AudioFormat;\nimport android.media.AudioRecord;\nimport android.media.MediaRecorder;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.ImageView;\n\nimport ca.uol.aig.fftpack.RealDoubleFFT;\n\npublic class AudioProcessing extends Activity implements OnClickListener{\n    int frequency = 8000;\n    int channelConfiguration = AudioFormat.CHANNEL_CONFIGURATION_MONO;\n    int audioEncoding = AudioFormat.ENCODING_PCM_16BIT;\n\n\n    private RealDoubleFFT transformer;\n    int blockSize = 256;\n    Button startStopButton;\n    boolean started = false;\n\n    RecordAudio recordTask;\n\n    ImageView imageView;\n    Bitmap bitmap;\n    Canvas canvas;\n    Paint paint;\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        startStopButton = (Button) this.findViewById(R.id.StartStopButton);\n        startStopButton.setOnClickListener(this);\n\n        transformer = new RealDoubleFFT(blockSize);\n\n        imageView = (ImageView) this.findViewById(R.id.ImageView01);\n        bitmap = Bitmap.createBitmap((int)256,(int)100,Bitmap.Config.ARGB_8888);\n        canvas = new Canvas(bitmap);\n        paint = new Paint();\n        paint.setColor(Color.GREEN);\n        imageView.setImageBitmap(bitmap);\n    }\n\n    private class RecordAudio extends AsyncTask<Void, double[], Void> {\n        @Override\n        protected Void doInBackground(Void... params) {\n        try {\n            int bufferSize = AudioRecord.getMinBufferSize(frequency,\n                    channelConfiguration, audioEncoding);\n                    AudioRecord audioRecord = new AudioRecord(\n                    MediaRecorder.AudioSource.DEFAULT, frequency,\n                    channelConfiguration, audioEncoding, bufferSize);\n\n                    short[] buffer = new short[blockSize];\n                    double[] toTransform = new double[blockSize];\n                    audioRecord.startRecording();\n                    while (started) {\n                    int bufferReadResult = audioRecord.read(buffer, 0, blockSize);\n\n                    for (int i = 0; i < blockSize && i < bufferReadResult; i++) {\n                        toTransform[i] = (double) buffer[i] / 32768.0; // signed 16 bit\n                        }\n\n                    transformer.ft(toTransform);\n                    publishProgress(toTransform);\n                    }\n                    audioRecord.stop();\n                    } catch (Throwable t) {\n                    Log.e(\"AudioRecord\", \"Recording Failed\");\n                    }\n                    return null;\n                    }\n        }\n\n    protected void onProgressUpdate(double[]... toTransform) {\n        canvas.drawColor(Color.BLACK);\n        for (int i = 0; i < toTransform[0].length; i++) {\n        int x = i;\n        int downy = (int) (100 - (toTransform[0][i] * 10));\n        int upy = 100;\n        canvas.drawLine(x, downy, x, upy, paint);\n        }\n        imageView.invalidate();\n        }\n\n        public void onClick(View v) {\n        if (started) {\n        started = false;\n        startStopButton.setText(\"Start\");\n        recordTask.cancel(true);\n        } else {\n        started = true;\n        startStopButton.setText(\"Stop\");\n        recordTask = new RecordAudio();\n        recordTask.execute();\n        }\n        }\n}\n```\n\n\nHere is the main.xml :\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:orientation=\"vertical\"\nandroid:layout_width=\"fill_parent\"\nandroid:layout_height=\"fill_parent\"\n>\n<TextView\nandroid:layout_width=\"fill_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"@string/hello\"\n/>\n<ImageView android:id=\"@+id/ImageView01\" android:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"></ImageView><Button android:text=\"Start\"\nandroid:id=\"@+id/StartStopButton\" android:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"></Button>\n</LinearLayout>\n```\n\n\nIn the AndroidManifest.xml I set the RECORD_AUDIO permission.\nThanks in advance !\n    ", "Answer": "\r\nHere is the working code. I tried it myself. It works fine.\n\n```\npackage com.example.frequencytest;\n\nimport android.app.Activity;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.media.AudioFormat;\nimport android.media.AudioRecord;\nimport android.media.MediaRecorder;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport ca.uol.aig.fftpack.RealDoubleFFT;\n\npublic class MainActivity extends Activity implements OnClickListener {\n\n    int frequency = 8000;\n    int channelConfiguration = AudioFormat.CHANNEL_CONFIGURATION_MONO;\n    int audioEncoding = AudioFormat.ENCODING_PCM_16BIT;\n    private RealDoubleFFT transformer;\n    int blockSize = 256;\n\n    Button startStopButton;\n    boolean started = false;\n\n    RecordAudio recordTask;\n\n    ImageView imageView;\n    Bitmap bitmap;\n    Canvas canvas;\n    Paint paint;\n\n    //AudioRecord audioRecord;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startStopButton = (Button) this.findViewById(R.id.start_stop_btn);\n        startStopButton.setOnClickListener(this);\n\n        transformer = new RealDoubleFFT(blockSize);\n\n        imageView = (ImageView) this.findViewById(R.id.imageView1);\n        bitmap = Bitmap.createBitmap((int) 256, (int) 100,\n                Bitmap.Config.ARGB_8888);\n        canvas = new Canvas(bitmap);\n        paint = new Paint();\n        paint.setColor(Color.GREEN);\n        imageView.setImageBitmap(bitmap);\n\n    }\n\n    public class RecordAudio extends AsyncTask<Void, double[], Void> {\n\n        @Override\n        protected Void doInBackground(Void... arg0) {\n\n            try {\n                // int bufferSize = AudioRecord.getMinBufferSize(frequency,\n                // AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT);\n                int bufferSize = AudioRecord.getMinBufferSize(frequency, \n                        channelConfiguration, audioEncoding); \n\n                AudioRecord audioRecord = new AudioRecord( \n                        MediaRecorder.AudioSource.MIC, frequency, \n                        channelConfiguration, audioEncoding, bufferSize); \n\n                short[] buffer = new short[blockSize];\n                double[] toTransform = new double[blockSize];\n\n                audioRecord.startRecording();\n\n                // started = true; hopes this should true before calling\n                // following while loop\n\n                while (started) {\n                    int bufferReadResult = audioRecord.read(buffer, 0,\n                            blockSize);\n\n                    for (int i = 0; i < blockSize && i < bufferReadResult; i++) {\n                        toTransform[i] = (double) buffer[i] / 32768.0; // signed\n                                                                        // 16\n                    }                                       // bit\n                        transformer.ft(toTransform);\n                        publishProgress(toTransform);\n\n\n\n                }\n\n                audioRecord.stop();\n\n            } catch (Throwable t) {\n                t.printStackTrace();\n                Log.e(\"AudioRecord\", \"Recording Failed\");\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(double[]... toTransform) {\n\n            canvas.drawColor(Color.BLACK);\n\n            for (int i = 0; i < toTransform[0].length; i++) {\n                int x = i;\n                int downy = (int) (100 - (toTransform[0][i] * 10));\n                int upy = 100;\n\n                canvas.drawLine(x, downy, x, upy, paint);\n            }\n\n            imageView.invalidate();\n\n            // TODO Auto-generated method stub\n            // super.onProgressUpdate(values);\n        }\n\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.activity_main, menu);\n        return true;\n    }\n\n    public void onClick(View arg0) {\n        // TODO Auto-generated method stub\n        if (started) {\n            started = false;\n            startStopButton.setText(\"Start\");\n            recordTask.cancel(true);\n        } else {\n            started = true;\n            startStopButton.setText(\"Stop\");\n            recordTask = new RecordAudio();\n            recordTask.execute();\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Can I use 3rd party libraries in Windows Phone 7.1?\r\n                \r\nI am going to do some sound frequency measurement. I have found the 3rd party library which enables performing Fast Fourier transform(FFT). Can I use them in Windows Phone 7.5(7.1SDK) application so it will not be rejected by Microsoft in the apphub?(the bold part of the question is more important)\n\nFound libraries:\n\nhttp://code.google.com/p/aforge/\n\nhttp://www.exocortex.org/dsp/\n\nhttp://www.mathdotnet.com/\n    ", "Answer": "\r\nYou can use pure managed libraries without any issues (assuming they run in a low-trusted environment and don't make any external API calls, so a math library should be okay).\n\nOthers, like AForge, will not work, because it's a native library (and the ability to run native code on WP7.1 is not guaranteed). Things are different on WP8, however.\n\nThe Exocortex DSP library looks like it might work as well.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "CUDA Graph Problem: Results not computed for the first iteration\r\n                \r\nI am trying to utilize CUDA Graphs for the computation of Fast Fourier Transform (FFT) using CUDA's cuFFT APIs.\nI modified the sample FFT code present on Github into the following FFT code using CUDA Graphs:\n```\n#include <cuda.h>\n#include \"cuda_runtime.h\"\n#include \"device_launch_parameters.h\"\n#include \"device_functions.h\"\n#include <iostream>\n#include <cufft.h>\n\n// Complex data type\ntypedef float2 Complex;\nstatic __device__  inline Complex ComplexScale(Complex, float);\nstatic __device__  inline Complex ComplexMul(Complex, Complex);\nstatic __global__ void ComplexPointwiseMulAndScale(Complex*, const Complex*, int, float);\n\n#define CUDA_CALL( call )               \\\n    {                                       \\\n    cudaError_t result = call;              \\\n    if ( cudaSuccess != result )            \\\n        std::cerr << \"CUDA error \" << result << \" in \" << __FILE__ << \":\" << __LINE__ << \": \" << cudaGetErrorString( result ) << \" (\" << #call << \")\" << std::endl;  \\\n    }\n\n#define CUDA_FFT_CALL( call )               \\\n    {                                       \\\n    cufftResult result = call;              \\\n    if ( CUFFT_SUCCESS != result )            \\\n        std::cerr << \"FFT error \" << result << \" in \" << __FILE__ << \":\" << __LINE__ << \": \" <<  result  << std::endl;  \\\n    }\n\n// The filter size is assumed to be a number smaller than the signal size\n#define SIGNAL_SIZE        10\n#define FILTER_KERNEL_SIZE  4\n\nstatic __device__ inline Complex ComplexScale(Complex a, float s)\n{\n    Complex c;\n    c.x = s * a.x;\n    c.y = s * a.y;\n    return c;\n}\n\n// Complex multiplication\nstatic __device__ inline Complex ComplexMul(Complex a, Complex b)\n{\n    Complex c;\n    c.x = a.x * b.x - a.y * b.y;\n    c.y = a.x * b.y + a.y * b.x;\n    return c;\n}\n\n// Complex pointwise multiplication\nstatic __global__ void ComplexPointwiseMulAndScale(Complex* a, const Complex* b, int size, float scale)\n{\n    const int numThreads = blockDim.x * gridDim.x;\n    const int threadID = blockIdx.x * blockDim.x + threadIdx.x;\n    for (int i = threadID; i < size; i += numThreads)\n    {\n        a[i] = ComplexScale(ComplexMul(a[i], b[i]), scale);\n    }\n}\n\nint main()\n{\n    printf(\"[simpleCUFFT] is starting...\\n\");\n\n    int minRadius = FILTER_KERNEL_SIZE / 2;\n    int maxRadius = FILTER_KERNEL_SIZE - minRadius;\n    int padded_data_size = SIGNAL_SIZE + maxRadius;\n\n    // Allocate HOST Memories \n    Complex* h_signal = (Complex*)malloc(sizeof(Complex) * SIGNAL_SIZE); //host signal\n    Complex* h_filter_kernel = (Complex*)malloc(sizeof(Complex) * FILTER_KERNEL_SIZE); //host filter    \n    Complex* h_padded_signal= (Complex*)malloc(sizeof(Complex) * padded_data_size); // host Padded signal \n    Complex* h_padded_filter_kernel = (Complex*)malloc(sizeof(Complex) * padded_data_size); // host Padded filter kernel    \n    Complex* h_convolved_signal = (Complex*)malloc(sizeof(Complex) * padded_data_size); // to store convolution RESULTS \n    memset(h_convolved_signal, 0, padded_data_size * sizeof(Complex));\n\n    //Allocate DEVICE Memories  \n    Complex* d_signal; //device signal\n    cudaMalloc((void**)&d_signal, sizeof(Complex) * padded_data_size);\n    Complex* d_filter_kernel;\n    cudaMalloc((void**)&d_filter_kernel, sizeof(Complex) * padded_data_size); //device kernel    \n\n    //CUDA GRAPH\n    bool graphCreated = false;\n    cudaGraph_t graph;\n    cudaGraphExec_t instance;\n    cudaStream_t stream;\n    cudaStreamCreate(&stream);\n\n    // CUFFT plan   \n    cufftHandle plan;\n    CUDA_FFT_CALL(cufftPlan1d(&plan, padded_data_size, CUFFT_C2C, 1));  \n    cufftSetStream(plan, stream); // bind plan to the stream\n\n    // Initalize the memory for the signal\n    for (unsigned int i = 0; i < SIGNAL_SIZE; ++i)\n    {\n        h_signal[i].x = rand() / (float)RAND_MAX;\n        h_signal[i].y = 0;\n    }\n\n    // Initalize the memory for the filter\n    for (unsigned int i = 0; i < FILTER_KERNEL_SIZE; ++i)\n    {\n        h_filter_kernel[i].x = rand() / (float)RAND_MAX;\n        h_filter_kernel[i].y = 0;\n    }\n\n    //REPEAT 3 times\n    int nRepeatationsNeeded = 3;\n    for (int repeatations = 0; repeatations < nRepeatationsNeeded; repeatations++) \n    {\n        std::cout << \"\\n\\n\" << \"Repeatation ------ \" << repeatations << std::endl;\n    \n        if (!graphCreated)\n        {\n            //Start Graph Recording --------------!!!!!!!!\n            CUDA_CALL(cudaStreamBeginCapture(stream, cudaStreamCaptureModeGlobal));\n                \n            //Pad Data                      \n            CUDA_CALL(cudaMemcpyAsync(h_padded_signal + 0, h_signal, SIGNAL_SIZE * sizeof(Complex), cudaMemcpyHostToHost, stream));\n            memset(h_padded_signal + SIGNAL_SIZE, 0, (padded_data_size - SIGNAL_SIZE) * sizeof(Complex));\n            //CUDA_CALL(cudaMemsetAsync(h_padded_signal + SIGNAL_SIZE, 0, (padded_data_size - SIGNAL_SIZE) * sizeof(Complex), stream));\n                    \n            CUDA_CALL(cudaMemcpyAsync(h_padded_filter_kernel + 0, h_filter_kernel + minRadius, maxRadius * sizeof(Complex), cudaMemcpyHostToHost, stream));\n            /*CUDA_CALL(cudaMemsetAsync(h_padded_filter_kernel + maxRadius, 0, (padded_data_size - FILTER_KERNEL_SIZE) * sizeof(Complex), stream));*/\n            memset(h_padded_filter_kernel + maxRadius, 0, (padded_data_size - FILTER_KERNEL_SIZE) * sizeof(Complex));\n            CUDA_CALL(cudaMemcpyAsync(h_padded_filter_kernel + padded_data_size - minRadius, h_filter_kernel, minRadius * sizeof(Complex), cudaMemcpyHostToHost, stream));\n        \n            // MemCpy H to D\n            CUDA_CALL(cudaMemcpyAsync(d_signal, h_padded_signal, sizeof(Complex) * padded_data_size, cudaMemcpyHostToDevice, stream)); //Signal\n            CUDA_CALL(cudaMemcpyAsync(d_filter_kernel, h_padded_filter_kernel, sizeof(Complex) * padded_data_size, cudaMemcpyHostToDevice, stream)); //Kernel\n\n            //COMPUTE FFT               \n            CUDA_FFT_CALL(cufftExecC2C(plan, (cufftComplex*)d_signal, (cufftComplex*)d_signal, CUFFT_FORWARD)); // Transform signal \n            CUDA_FFT_CALL(cufftExecC2C(plan, (cufftComplex*)d_filter_kernel, (cufftComplex*)d_filter_kernel, CUFFT_FORWARD)); // Transform kernel    \n            ComplexPointwiseMulAndScale << <64, 1, 0, stream >> > (d_signal, d_filter_kernel, padded_data_size, 1.0f / padded_data_size); // Multiply and normalize    \n            CUDA_CALL(cudaGetLastError());\n            CUDA_FFT_CALL(cufftExecC2C(plan, (cufftComplex*)d_signal, (cufftComplex*)d_signal, CUFFT_INVERSE)); // Transform signal back\n\n            // Copy device memory to host           \n            CUDA_CALL(cudaMemcpyAsync(h_convolved_signal, d_signal, sizeof(Complex) * padded_data_size, cudaMemcpyDeviceToHost, stream));\n\n            //END Graph Recording\n            CUDA_CALL(cudaStreamEndCapture(stream, &graph));\n            CUDA_CALL(cudaGraphInstantiate(&instance, graph, NULL, NULL, 0));\n            graphCreated = true;            \n        }\n        else\n        {\n            CUDA_CALL(cudaGraphLaunch(instance, stream));\n            CUDA_CALL(cudaStreamSynchronize(stream));\n        }\n        //verify results\n        for (int i = 0; i < SIGNAL_SIZE; i++)\n            std::cout << \"index: \" << i << \", fft: \" << h_convolved_signal[i].x << std::endl;\n    }\n\n    //Destroy CUFFT context\n    cufftDestroy(plan);\n\n    // cleanup memory\n    cudaStreamDestroy(stream);\n    free(h_signal);\n    free(h_filter_kernel);\n    free(h_padded_signal);\n    free(h_padded_filter_kernel);\n    cudaFree(d_signal);\n    cudaFree(d_filter_kernel);\n\n    return 0;\n}\n```\n\nPROBLEM: The Output of the above program is below, in which it can be seen that the values of the result are also ```\nZEROS```\n for the first iteration. How can I resolve this?\n\n    ", "Answer": "\r\nThe results are zero for the first iteration, because for the first iteration, the work is all issued in capture mode.\nIn capture mode, no CUDA work actually gets done.  From here:\n\nWhen a stream is being captured, work launched into the stream is not enqueued for execution.\n\nI pointed you to this same area of the documentation in a comment to your last question.  You might wish to read the entire programming guide section on graphs, and there are also blogs available.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Detect handwritten characters in boxes from a filled form using Fourier transforms\r\n                \r\nI am trying to extract handwritten characters from boxes. The scanning of the forms is not consistent, so the width and height of the boxes are also not constants.\n\nHere is a part of the form.\n\n\n\nMy current approach:\n1. Extract horizontal lines\n2. Extract vertical lines\n3. Combine both the above images\n4. Find contours ( used opencv)\n\nThis approach gives me most of the boxes. But, when the box is filled with characters like \"L\" or \"I\", the vertical line in the character is also getting extracted as a part of vertical lines extraction. Hence the contours also get messed up.\nSince the boxes are arranged periodically, is there a way to extract the boxes using Fast Fourier transforms?   \n    ", "Answer": "\r\nI recently came up with a python package that deals with this exact problem.\nI called it BoxDetect and after installing it through:\n\n```\npip install boxdetect\n```\n\n\nIt may look somewhat like this (you need to adjust parameters for different forms:\n\n```\nfrom boxdetect import config\n\nconfig.min_w, config.max_w = (20,50)\nconfig.min_h, config.max_h = (20,50)\nconfig.scaling_factors = [0.4]\nconfig.dilation_iterations = 0\nconfig.wh_ratio_range = (0.5, 2.0)\nconfig.group_size_range = (1, 100)\nconfig.horizontal_max_distance_multiplier = 2\n\n\nfrom boxdetect.pipelines import get_boxes\n\nimage_path = \"dumpster/m1nda.jpg\"\nrects, grouped_rects, org_image, output_image = get_boxes(image_path, config, plot=False)\n```\n\n\n\n\nYou might want to check below thread for more info:\nHow to detect all boxes for inputting letters in forms for a particular field?\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "MonetDb: Embedded R aggregate function with multiple output columns\r\n                \r\nI'm using MonetDB and embedded R with a huge amount of accelerometer sensor data. I created an aggregate function which calculates a Fast Fourier Transformation on the sensor data and extracts a single value.\n\n```\nCREATE AGGREGATE fft_max_s(val double) RETURNS DOUBLE LANGUAGE R{\n  sapply(split(val,aggr_group), FUN = function(d){\n   max(Mod(fft(d)))\n  })\n};\n```\n\n\nMy question: Is it possible to let this aggregate function create multiple values? \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "'Squaring a polynomial' versus 'Multiplying the polynomial with itself using FFT'\r\n                \r\nThe fastest known algorithm for polynomial multiplication is using Fast Fourier Transformation (FFT). \n\nIn a special case of multiplying a polynomial with itself, I am interested in knowing if any squaring algorithm performs better than FFT. I couldn't find any resource which deals with this aspect.\n    ", "Answer": "\r\n\nNumber Theoretic Transform (NTT) is faster than FFT\nWhy? Because you using just integer modular arithmetics on some ring instead of floating point complex numbers while the properties stays the same (as NTT is sort of form of DFT ...). So if your polynomials are integer use NTT which is faster... if they are float you need to use FFT\n\nFFT based squaring is faster than FFT based multiplying by itself\nWhy?  Because you need just 1x NTT/FFT and 1x iNTT/iFFT while multiplying needs 2xNTT/FFT and 1x iNTT/iFFT so you spare one transformation ... the rest is the same\n\nfor small enough polynomials is squaring without FFT fastest\n\n\nFor more info see:\n\nFast bignum square computation\n\nits not the same problem but very similar ... as bignum data words are similar to your polynomial coefficients. So most of it applies to your problem too\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Computing Fourier Series to represent data points\r\n                \r\nI wish to compute a function (a Fourier series) that passes through some set of given points.\nSimilar to what is going on here https://gofigure.impara.ai/ , but I wish not to animate it. I merely want the function so that I can draw the shape myself. I have read lots of math stuff describing it and code that animates it, but I am struggling with my implementation.\nMy current code is as follows [should be able to run in a python notebook alone]\n```\nimport matplotlib.pyplot as plt \nimport scipy\nimport cmath \nimport math\nimport numpy as np\nfrom matplotlib import collections  as mc\nimport pylab as pl\n\n\nmidpoints = [[305.0, 244.5], [293.5, 237.0], [274.5, 367.5], [270.5, 373.5], [229.5, 391.0], [216.0, 396.0], [302.0, 269.0], [295.0, 271.0], [60.5, 146.5], [54.0, 153.0], [52.0, 167.0], [54.0, 153.0], [52.0, 167.0], [45.0, 178.0], [75.0, 76.5], [68.5, 98.5], [75.0, 76.5], [97.0, 58.5], [283.5, 357.5], [274.5, 367.5], [309.0, 255.0], [305.0, 244.5], [309.0, 255.0], [302.0, 269.0], [299.5, 291.5], [300.0, 297.0], [300.0, 297.0], [295.0, 309.5], [62.5, 105.0], [61.0, 118.5], [62.5, 105.0], [68.5, 98.5], [58.0, 139.0], [60.5, 146.5], [241.0, 111.5], [252.0, 124.5], [256.0, 132.5], [252.0, 124.5], [283.0, 356.0], [283.5, 357.5], [300.0, 290.5], [299.5, 291.5], [300.0, 290.5], [296.0, 280.5], [296.0, 280.5], [295.0, 271.0], [158.0, 387.0], [177.0, 396.5], [197.5, 402.0], [192.5, 403.0], [189.5, 400.5], [192.5, 403.0], [197.5, 402.0], [202.5, 401.0], [214.0, 395.5], [216.0, 396.0], [202.5, 401.0], [214.0, 395.5], [233.5, 375.0], [229.5, 391.0], [233.5, 375.0], [249.0, 372.5], [282.5, 340.0], [284.5, 328.0], [284.5, 328.0], [295.0, 309.5], [45.0, 178.0], [49.5, 189.0], [57.0, 198.0], [49.5, 189.0], [238.5, 108.5], [241.0, 111.5], [162.0, 57.5], [170.0, 59.0], [239.5, 204.5], [239.0, 200.0], [293.5, 237.0], [291.0, 227.5], [265.0, 229.5], [291.0, 227.5], [239.0, 189.5], [245.5, 178.0], [239.0, 189.5], [241.0, 193.5], [241.0, 193.5], [239.0, 200.0], [55.0, 119.0], [61.0, 118.5], [53.5, 134.0], [58.0, 139.0], [50.0, 129.0], [55.0, 119.0], [50.0, 129.0], [53.5, 134.0], [107.0, 46.0], [119.5, 50.5], [97.0, 54.0], [97.0, 58.5], [107.0, 46.0], [97.0, 54.0], [150.5, 377.0], [158.0, 387.0], [257.5, 367.5], [270.5, 373.5], [249.0, 372.5], [257.5, 367.5], [280.0, 349.5], [282.5, 340.0], [280.0, 349.5], [283.0, 356.0], [239.5, 90.0], [238.5, 98.0], [238.5, 108.5], [238.5, 98.0], [130.0, 49.0], [119.5, 50.5], [189.0, 65.0], [191.0, 64.5], [189.0, 65.0], [177.0, 62.5], [170.0, 59.0], [177.0, 62.5], [256.0, 132.5], [257.5, 139.5], [128.0, 361.5], [127.5, 360.0], [136.5, 382.5], [131.5, 378.5], [126.5, 370.0], [131.5, 378.5], [128.0, 361.5], [126.5, 370.0], [105.5, 343.5], [101.0, 324.5], [105.5, 343.5], [121.5, 347.5], [126.0, 353.0], [127.5, 360.0], [121.5, 347.5], [126.0, 353.0], [191.0, 64.5], [198.5, 72.0], [237.5, 83.5], [239.5, 90.0], [145.5, 49.0], [138.5, 49.0], [159.0, 57.0], [162.0, 57.5], [145.5, 49.0], [159.0, 57.0], [265.0, 229.5], [254.5, 220.0], [253.0, 216.5], [254.5, 220.0], [253.0, 216.5], [248.0, 208.5], [248.0, 208.5], [239.5, 204.5], [245.0, 173.5], [245.5, 178.0], [250.0, 158.0], [245.0, 173.5], [257.5, 139.5], [250.0, 158.0], [177.0, 396.5], [181.0, 395.5], [181.0, 395.5], [189.5, 400.5], [147.0, 377.0], [150.5, 377.0], [140.5, 381.5], [147.0, 377.0], [140.5, 381.5], [136.5, 382.5], [92.5, 313.5], [101.0, 324.5], [99.5, 290.0], [92.5, 313.5], [98.0, 271.0], [99.5, 290.0], [134.5, 47.5], [130.0, 49.0], [134.5, 47.5], [138.5, 49.0], [73.0, 222.5], [71.0, 214.5], [107.5, 246.0], [110.5, 248.0], [104.0, 266.5], [98.0, 271.0], [69.0, 209.5], [71.0, 214.5], [226.5, 87.0], [237.5, 83.5], [226.5, 87.0], [205.5, 94.5], [205.5, 94.5], [205.5, 77.5], [198.5, 72.0], [205.5, 77.5], [96.5, 244.5], [107.5, 246.0], [109.0, 265.5], [104.0, 266.5], [108.0, 263.5], [110.5, 248.0], [109.0, 265.5], [108.0, 263.5], [65.0, 205.5], [69.0, 209.5], [57.0, 198.0], [56.0, 201.5], [65.0, 205.5], [56.0, 201.5], [90.0, 240.0], [96.5, 244.5], [83.0, 224.0], [73.0, 222.5], [90.5, 231.5], [83.0, 224.0], [90.0, 240.0], [90.5, 231.5]]\n\nx_list = [ p[0] for p in midpoints ]\ny_list = [ p[1] for p in midpoints ]\ncomplexmdpts = [ [p[0]+1j*p[1]] for p in midpoints ]\n\nplt.scatter(x_list, y_list, s=50, marker=\"x\", color='y') \n\ncoefs = np.fft.fftshift(scipy.fft.fft(complexmdpts))\nn = len(coefs)\nprint(\"coeffs[{}]:\\n{}\".format(n, coefs[:5]))\n\n#todo: sort coeffs?\n\n# function in terms of t to trace out curve\ndef f(t):\n    ftx=0\n    fty=0\n    for i in range(-int(n/2), int(n/2)+1):\n        ftx+=(coefs[i]*cmath.exp(1j*2*math.pi*i*t/n)).real.tolist()[0]\n        fty+=(coefs[i]*cmath.exp(1j*2*math.pi*i*t/n)).imag.tolist()[0]\n    return [ftx/n, fty/n]\n    \n\nlines = [] # store computed lines segments to approximate function\n\npft = f(0) # compute first point\n\nt_list = np.linspace(0, 2*math.pi, n) # compute list of dts to use when drawing\n\nfor t in t_list: \n    cft = f(t)\n#     print(\"f({}): {} \\n\".format(t, cft))\n    lines.append([cft,pft])\n    pft = cft\n\n#draw f(t) approximation\nlc = mc.LineCollection(lines)\nfig, ax = pl.subplots()\nax.add_collection(lc)\nax.autoscale()\nax.margins(0.1)\n\n```\n\nAnd here is my output:\nPoints I wish to outline\n\nMy function approximation\n\nI am not convinced that the fast fourier transform is used correctly. From what I read the fft is what I need, and I shift it because the scipy fft returns the array shifted, and I think that the rest of my code is right, assuming the coefficients are correct, which is why I am suspicious of the coefficients.\nIs there a step between the transform and the coefficients that I am missing? or is my function evaluation given the coefficients incorrect? or am I missing something else?\n    ", "Answer": "\r\nThere are actually a few issues that need to be resolved to get the expected outline. Let's go over each of those issues.\nFourier coefficient computation\nSince you are computing the FFT of the 2D array ```\ncomplexmdpts```\n (each element being an array of 1 complex value), the default behavior of ```\nscipy.fft```\n is to compute the FFT along the last axis. In this case it means that you are in fact computing ```\nn```\n FFTs of length 1 and given that FFTs of length 1 are identities, the entire computation returns the original array.\nOne solution would be to specify ```\naxis=0```\n explicitly:\n```\nscipy.fft(complexmdpts,axis=0) \n```\n\nYou could alternatively flatten the 2D array into a 1D array given that has fundamentally only one dimension, but that would result in more changes to the rest of your code that is based on this 2D structure.\nCoefficient shifting\nThere is a common confusion when trying to interpret the FFT coefficients. The coefficients in the higher indices correspond to negative frequencies after the wraparound that occurs above the Nyquist frequency.\nTo visualize these coefficients on a plot where the negative frequencies appear at their intuitive location, the coefficients in the higher indices are swapped using ```\nfftshift```\n with the coefficients in the lower indices. This way the coefficients corresponding to negative frequencies appear before the coefficients corresponding to positive frequencies.\nIn your specific case, the computations in ```\nf(t)```\n associate negative frequencies (whenever ```\ni```\n is negative, so is the argument to ```\ncmath.exp```\n) with coefficients at negative indices. Since python array indexing conveniently uses elements counting back from the end of the array for negative indices, you are correctly using coefficients corresponding to negative frequencies when indexing with negative indices.\nAll this to say that you do not need to swap the coefficients with ```\nfftshift```\n, and the coefficients are obtained directly with:\n```\ncoefs = scipy.fft(complexmdpts,axis=0)\n```\n\nSampling domain\nYou've specified ```\nt```\n to range from 0 to ```\n2*math.pi```\n. Given your implementation of ```\nf(t)```\n the domain actually ranges from 0 to ```\nn```\n (for example, when ```\ni==1```\n the argument to ```\ncmath.exp```\n goes from 0 to ```\n1j*2*math.pi```\n as ```\nt```\n goes from 0 to ```\nn```\n). To get the curve to span the entire domain, you should update your values of ```\nt```\n accordingly with:\n```\nt_list = np.linspace(0, n, n)\n```\n\nPoints ordering\nFinally, by plotting the original series of points using a scatter plot you are hiding what a line plot would look like:\n\nTrying to get a smooth function to interpolating this result in a plot with similar lines jumping from one side of the outline to the other. If you want to capture these jumps, then I guess you're done. But I suspect you likely want to capture the outline of the area. In that case you'd have to sort your original points so that they follow the outline.\nOne approach would be to iteratively append the closest point to the previously selected point. This will give something that more closely resemble the contour:\n\nFor demonstration purposes (i.e. no claim that this is the best way to do it), you could do this sorting with something like the following:\n```\ndef sort_points(points):\n  # pick a point\n  reference_point = points[0]\n  sorted = [reference_point]\n  remaining_points = range(1,len(points))\n  for i in range(1,len(points)):\n\n    # find the closest point to reference_point, \n    mindiff = np.sum(np.square(np.array(points[remaining_points[0]])-reference_point))\n    idx = 0\n    # loop over all the other remaining points\n    for j in range(1,len(remaining_points)):\n      diff = np.sum(np.square(np.array(points[remaining_points[j]])-reference_point))\n      if diff < mindiff:\n        mindiff = diff\n        idx = j        \n    # found the closest: update the selected point, and add it to the list of sorted points\n    reference_point = points[remaining_points[idx]]\n    sorted.append(reference_point )\n    remaining_points = np.delete(remaining_points, idx)\n  return sorted    \n```\n\nFor reference, here's the complete code:\n```\nimport matplotlib.pyplot as plt \nimport scipy\nimport cmath \nimport math\nimport numpy as np\nfrom matplotlib import collections  as mc\nimport pylab as pl\n\ndef sort_points(points):\n  # pick a point\n  reference_point = points[0]\n  sorted = [reference_point]\n  remaining_points = range(1,len(points))\n  for i in range(1,len(points)):\n\n    # find the closest point to reference_point, \n    mindiff = np.sum(np.square(np.array(points[remaining_points[0]])-reference_point))\n    idx = 0\n    # loop over all the other remaining points\n    for j in range(1,len(remaining_points)):\n      diff = np.sum(np.square(np.array(points[remaining_points[j]])-reference_point))\n      if diff < mindiff:\n        mindiff = diff\n        idx = j        \n    # found the closest: update the selected point, and add it to the list of sorted points\n    reference_point = points[remaining_points[idx]]\n    sorted.append(reference_point )\n    remaining_points = np.delete(remaining_points, idx)\n  return sorted    \n\n\nmidpoints = [[305.0, 244.5], [293.5, 237.0], [274.5, 367.5], [270.5, 373.5], [229.5, 391.0], [216.0, 396.0], [302.0, 269.0], [295.0, 271.0], [60.5, 146.5], [54.0, 153.0], [52.0, 167.0], [54.0, 153.0], [52.0, 167.0], [45.0, 178.0], [75.0, 76.5], [68.5, 98.5], [75.0, 76.5], [97.0, 58.5], [283.5, 357.5], [274.5, 367.5], [309.0, 255.0], [305.0, 244.5], [309.0, 255.0], [302.0, 269.0], [299.5, 291.5], [300.0, 297.0], [300.0, 297.0], [295.0, 309.5], [62.5, 105.0], [61.0, 118.5], [62.5, 105.0], [68.5, 98.5], [58.0, 139.0], [60.5, 146.5], [241.0, 111.5], [252.0, 124.5], [256.0, 132.5], [252.0, 124.5], [283.0, 356.0], [283.5, 357.5], [300.0, 290.5], [299.5, 291.5], [300.0, 290.5], [296.0, 280.5], [296.0, 280.5], [295.0, 271.0], [158.0, 387.0], [177.0, 396.5], [197.5, 402.0], [192.5, 403.0], [189.5, 400.5], [192.5, 403.0], [197.5, 402.0], [202.5, 401.0], [214.0, 395.5], [216.0, 396.0], [202.5, 401.0], [214.0, 395.5], [233.5, 375.0], [229.5, 391.0], [233.5, 375.0], [249.0, 372.5], [282.5, 340.0], [284.5, 328.0], [284.5, 328.0], [295.0, 309.5], [45.0, 178.0], [49.5, 189.0], [57.0, 198.0], [49.5, 189.0], [238.5, 108.5], [241.0, 111.5], [162.0, 57.5], [170.0, 59.0], [239.5, 204.5], [239.0, 200.0], [293.5, 237.0], [291.0, 227.5], [265.0, 229.5], [291.0, 227.5], [239.0, 189.5], [245.5, 178.0], [239.0, 189.5], [241.0, 193.5], [241.0, 193.5], [239.0, 200.0], [55.0, 119.0], [61.0, 118.5], [53.5, 134.0], [58.0, 139.0], [50.0, 129.0], [55.0, 119.0], [50.0, 129.0], [53.5, 134.0], [107.0, 46.0], [119.5, 50.5], [97.0, 54.0], [97.0, 58.5], [107.0, 46.0], [97.0, 54.0], [150.5, 377.0], [158.0, 387.0], [257.5, 367.5], [270.5, 373.5], [249.0, 372.5], [257.5, 367.5], [280.0, 349.5], [282.5, 340.0], [280.0, 349.5], [283.0, 356.0], [239.5, 90.0], [238.5, 98.0], [238.5, 108.5], [238.5, 98.0], [130.0, 49.0], [119.5, 50.5], [189.0, 65.0], [191.0, 64.5], [189.0, 65.0], [177.0, 62.5], [170.0, 59.0], [177.0, 62.5], [256.0, 132.5], [257.5, 139.5], [128.0, 361.5], [127.5, 360.0], [136.5, 382.5], [131.5, 378.5], [126.5, 370.0], [131.5, 378.5], [128.0, 361.5], [126.5, 370.0], [105.5, 343.5], [101.0, 324.5], [105.5, 343.5], [121.5, 347.5], [126.0, 353.0], [127.5, 360.0], [121.5, 347.5], [126.0, 353.0], [191.0, 64.5], [198.5, 72.0], [237.5, 83.5], [239.5, 90.0], [145.5, 49.0], [138.5, 49.0], [159.0, 57.0], [162.0, 57.5], [145.5, 49.0], [159.0, 57.0], [265.0, 229.5], [254.5, 220.0], [253.0, 216.5], [254.5, 220.0], [253.0, 216.5], [248.0, 208.5], [248.0, 208.5], [239.5, 204.5], [245.0, 173.5], [245.5, 178.0], [250.0, 158.0], [245.0, 173.5], [257.5, 139.5], [250.0, 158.0], [177.0, 396.5], [181.0, 395.5], [181.0, 395.5], [189.5, 400.5], [147.0, 377.0], [150.5, 377.0], [140.5, 381.5], [147.0, 377.0], [140.5, 381.5], [136.5, 382.5], [92.5, 313.5], [101.0, 324.5], [99.5, 290.0], [92.5, 313.5], [98.0, 271.0], [99.5, 290.0], [134.5, 47.5], [130.0, 49.0], [134.5, 47.5], [138.5, 49.0], [73.0, 222.5], [71.0, 214.5], [107.5, 246.0], [110.5, 248.0], [104.0, 266.5], [98.0, 271.0], [69.0, 209.5], [71.0, 214.5], [226.5, 87.0], [237.5, 83.5], [226.5, 87.0], [205.5, 94.5], [205.5, 94.5], [205.5, 77.5], [198.5, 72.0], [205.5, 77.5], [96.5, 244.5], [107.5, 246.0], [109.0, 265.5], [104.0, 266.5], [108.0, 263.5], [110.5, 248.0], [109.0, 265.5], [108.0, 263.5], [65.0, 205.5], [69.0, 209.5], [57.0, 198.0], [56.0, 201.5], [65.0, 205.5], [56.0, 201.5], [90.0, 240.0], [96.5, 244.5], [83.0, 224.0], [73.0, 222.5], [90.5, 231.5], [83.0, 224.0], [90.0, 240.0], [90.5, 231.5]]\nmidpoints = sort_points(midpoints)\n\nx_list = [ p[0] for p in midpoints ]\ny_list = [ p[1] for p in midpoints ]\ncomplexmdpts = [ [p[0]+1j*p[1]] for p in midpoints ]\n\nplt.scatter(x_list, y_list, s=50, marker=\"x\", color='y') \n\ncoefs = scipy.fft(complexmdpts,axis=0)\nn = len(coefs)\nprint(\"coeffs[{}]:\\n{}\".format(n, coefs[:5]))\n\n# function in terms of t to trace out curve\nm = n\ndef f(t):\n    ftx=0\n    fty=0\n    for i in range(-int(m/2), int(m/2)+1):\n        ftx+=(coefs[i]*cmath.exp(1j*2*math.pi*i*t/n)).real.tolist()[0]\n        fty+=(coefs[i]*cmath.exp(1j*2*math.pi*i*t/n)).imag.tolist()[0]\n    return [ftx/n, fty/n]\n    \n\nlines = [] # store computed lines segments to approximate function\n\npft = f(0) # compute first point\n\nt_list = np.linspace(0, n, n) # compute list of dts to use when drawing\n\nfor t in t_list: \n    cft = f(t)\n    lines.append([cft,pft])\n    pft = cft\n\n#draw f(t) approximation\nlc = mc.LineCollection(lines)\nfig, ax = pl.subplots()\nax.add_collection(lc)\nax.autoscale()\nax.margins(0.1)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Taking IFFT2 of data set and what is means\r\n                \r\nI am dealing with a data set collected from a bistatic radar system which has electric field amplitude vs frequency points.  I am trying to take the inverse fourier transform of the data set, converting from the frequency domain into the time domain. I have read in the data in the code below, created two different arrays, one for freq and one for amplitude. I correctly plot the data, but when I take the IFFT of the data I do not get what i expect.  \n\nCan someone tell me how to properly take the 2 dimensional fast fourier transform of the data set in matlab, and what exactly the IFFT in this case scenario is showing?\n\n```\n    waves = csvread('10cm.txt');\n\nA = waves(:,1);\nB = abs(waves(:,2));\n\nMatrix = [A B];\nwaves_transform = abs(ifft2(Matrix));\n\nfigure, plot(A,B), title('Frequency Domain'), xlabel('Frequency'),ylabel('amplitude');\nfigure, plot(waves_transform),title('Time Domain'), xlabel('Frequency'),ylabel('amplitude');\n%axis([0 5 0 17*10^9]);\n```\n\n\n10cm.txt DATA FILE HERE: http://pastebin.com/0t0TwVvC\ncode output\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Compute FFT in PHP language\r\n                \r\nI'm working on a project to compute Fast Fourier Transform(FFT) on every 5 numbers in an array of numbers. For instance, i've group the numbers into groups of 5 as shown below:\n\nCODE:\n\n```\n    $arrayCount = count($output);\n\n    for ($x = 0; $x < $arrayCount; $x++)\n\n    {\n\n        if($x%5==0)\n\n        {\n\n              echo (\"\\n\");\n\n\n        }\n\n        echo json_encode($output[$x]);  \n\n    }\n```\n\n\nRESULT:\n\n```\n\"671\"\"1265\"\"527\"\"854\"\"646\"\n\n\"1255\"\"601\"\"603\"\"1089\"\"543\"\n```\n\n\nHow do I compute FFT in php for each row (5 numbers)? Is there any fft library for PHP that I can use to compute them or is there any formulas that I can use?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Limitated accuracy of numpy.fft below a certain value\r\n                \r\nI'm trying to calculate Fourier Transform of some signals in Python. I want the result calculated by Fast Fourier Transform to coincide with the result calculated from definition. However, the result calculated using numpy.fft deviates from the expected value.\n\nThe signal does not reach a value below a certain number. In the graph below it is about 10^-16. For other signals these are comparable values (from 10^-9 to 10^-30). In my application I need higher accuracy.\n\n\nJust to be sure I also tested scipy.fftpack. The same error appears there, although the incorrectly calculated values are slightly different.\nThe problem does not depend on the signal parameters (length, sampling frequency, etc.).\n\nWhat is the reason of this limitation? If it's Python/Numpy accuracy how can I improve it?\n\n```\n# Fourier Transform\n\nimport numpy as np\nimport scipy.fftpack as fp\n\ndef gaussian_distribution(x,mean=0,variance=1):\n    return (1 / (np.sqrt(2*np.pi)*variance) ) * np.exp( -((x-mean)**2) / (2 * variance**2) )\n\ndef gaussian_fourier_transform(omega, mean=0, variance=1):\n    # http://mathworld.wolfram.com/FourierTransformGaussian.html\n    return np.exp(-2 * np.pi**2 * variance**2 * omega**2) * np.exp(-(2j)*np.pi*mean*omega)\n\n## signal generation\nsignal_range = [-2**4, 2**4]\nN = 2**8\nx = np.linspace(signal_range[0],signal_range[1],N, dtype='float64')\ny = gaussian_distribution(x)\n\n## calculating result\nframerate = N / (signal_range[1] - signal_range[0])\nfrequency_axis = np.linspace(0,framerate,N)\n\nnumpy_v = np.abs( np.fft.fft(y) )\nnumpy_v = numpy_v / numpy_v[0] # normalization\n\nscipy_v = np.abs( fp.fft(y) )\nscipy_v = scipy_v / scipy_v[0]\n\nsymbolical_v = gaussian_fourier_transform(frequency_axis)\n\n# ploting\n\nimport matplotlib.lines as mlines\nimport matplotlib.pyplot as plt\n\nfig = plt.figure()\nax1 = fig.add_subplot()\n\nax1.plot(frequency_axis[0: N//2], scipy_v[0: N//2], '.r')\nax1.plot(frequency_axis[0: N//2], numpy_v[0: N//2], '.b')\nax1.plot(frequency_axis[0: N//2], symbolical_v[0: N//2], 'g')\nax1.set_yscale('log')\nax1.grid(True)\n\nblue_line = mlines.Line2D([], [], color='blue', marker='.', markersize=15, label='result calculated by numpy.fft')\nred_line = mlines.Line2D([], [], color='red', marker='.', markersize=15, label='result calculated by scipy.fftpack')\ngreen_line = mlines.Line2D([], [], color='green', marker='', markersize=15, label='result calculated by definition')\nax1.legend(handles=[blue_line, red_line, green_line])\n\nfig.show()\n```\n\n    ", "Answer": "\r\nIEEE double precision floating point numbers (what your computer's CPU likely supports in hardware) have roughly 15 decimal digits of precision.  This is due to having only 53 bits of mantissa (or significand).  The FFT algorithm grows this error bound (or quantization noise) by O(N*Log(N)), where N is the FFT length.\n\nSo, to get more precision (a lower noise floor), you may have to find or write your own FFT that internally uses quad-precision or arbitrary precision arithmetic, and acquire and input your data in that format as well.\n\nFor instance, you could try coding your FFT using python's mpmath package, and choose your precision.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Faster way to go from cartesian to polar in C?\r\n                \r\nMy C code for discrete Fourier transform needs to output polar values, ```\namplitude```\n and ```\nangle```\n. I have a fast algorithm that outputs cartesian values, ```\nx```\n and ```\ny```\n. \n\nIs there a faster way of converting (f.e. 1024) cartesian values to polar than just:  \n\n```\nint x, y;\nfloat amplitude, angle;\n...\namplitude = sqrt( x*x + y*y);\nangle = atan2( y, x );\n```\n\n\n? \n    ", "Answer": "\r\nThere are two approaches:\n\n(1) Perform the common 2D FFT, and then complete the cartesian to polar conversion by yourself.\n\n(2) Use the so called \"polar FFT\" directly. Actually, the \"polar FFT\" is also based on the interpolation. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Understanding Fourier transform components on time series data [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm following a Tensorflow tutorial and I've run into the Fast Fourier Transform:\n```\nfft = tf.signal.rfft(df['T (degC)'])\nf_per_dataset = np.arange(0, len(fft))\n\nn_samples_h = len(df['T (degC)'])\nhours_per_year = 24*365.2524\nyears_per_dataset = n_samples_h/(hours_per_year)\n\nf_per_year = f_per_dataset/years_per_dataset\nplt.step(f_per_year, np.abs(fft))\nplt.xscale('log')\nplt.ylim(0, 400000)\nplt.xlim([0.1, max(plt.xlim())])\nplt.xticks([1, 365.2524], labels=['1/Year', '1/day'])\n_ = plt.xlabel('Frequency (log scale)')\n```\n\nThe dataset contains hourly temperature measures. The code performs an FFT on this, to see which components have a big impact, basically finding periodicity in the data. This yields the following plot:\n\nI don't quite understand the X axis though. I do see it's a logged scale, however, I see that '1' corresponds to a year, and '365.2524' represents the daily periodicity. Does this mean that the scale is 'n-th of a year', so 1th of 1 year is a year, and a 365.2524th of a year is a day, and with the same logic 4 would be a quarter, 2 would be a half year etc.? If so, what does the leftmost value (0) mean? There is also some periodicity in the 0th of a year - what does this mean intuitively?\nAnother one here. There are some key differences. This time the dataset is the daily volume of Amazon shares traded (so the dataset is not hourly anymore, but rather daily). Also, the dataset only contains WEEKDAY data, that's why the number of days in a year is marked as 252 (the average number of days in a year for this dataset).\n```\nfft = tf.signal.rfft(df['Volume'])\nf_per_dataset = np.arange(0, len(fft))\n\nn_samples_d = len(df['Volume'])\ndays_per_year = 252\nyears_per_dataset = n_samples_d/(days_per_year)\n\nf_per_year = f_per_dataset/years_per_dataset\nplt.step(f_per_year, np.abs(fft))\nplt.xscale('log')\nplt.xticks([1, 4, 252], labels=['1/Year', '1/quarter(???)', '1/day'])\n_ = plt.xlabel('Frequency (log scale)')\n```\n\n\nHere the periodicity is not as pronounced, however, I did find a peak at \"4\". Given that I changed the code and the data periodicity is now daily, and not hourly, does this still hold up? Does the peak at 4 mean there's a quarterly periodicity?\nAnd lastly, again, what does it mean that there's a big 'spike' around zero? The dataset has 12 years of data, does this main the main periodicity is \"every 12 years\"?\nThank you!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fft algorithm yields imprecise results\r\n                \r\nI'm trying to implement the fft (fast fourier transform) based on dft(discrete fourier transform) matrix factorization.In the following code, both fft and the straightforward method(i.e.: multiply the dft matrix directly with v) are implemented in order to test the validity of my implementation of fft.  \n\n```\nimport numpy as n\nimport cmath, math\nimport matplotlib.pyplot as plt\n\nv=n.array([1,-1,2,-3])\nw=v\nN=len(v)\nt=[0]*N\nM=n.zeros((N,N),dtype=complex)\nz=n.exp(2j*math.pi/N)\nfor a in range(N):\n    for b in range(N):\n        M[a][b]=n.exp(2j*math.pi*a*b/N)\nprint (n.dot(v,M))\nplt.plot(n.dot(v,M))\ndef f(x):\n    x=n.concatenate([x[::2],x[1::2]])\n    return x\n\nwhile (w!=f(v)).any():\n    v=f(v)\nprint(v)\na=2\nwhile a<=N:\n\n    for k in range(N/a):\n        for y in range(a/2):\n            t[y]=v[a*k+y]\n        for i in range(a/2):\n            v[a*k+i]+=v[a*k+i+a/2]*(z**i)\n            v[a*k+i+a/2]=t[i]-v[a*k+i+a/2]*(z**i)\n    a*=2    \nprint(v)\nplt.plot(v)\n\nplt.show()\n```\n\n\nI've tried this with lots of values of v, sometimes the outputs of these two methods yield exactly the same result but other times they are close to each other but not exactly the same. They haven't gone far away from each other yet after a few tests each with a different value of v.\n\nIs there anything that I'm missing that causes the imprecision of the code?\n\nEDIT:\nPlease note that the code is designed for Python 2 (because of the implicit integer divisions).\n    ", "Answer": "\r\nIt seems that the problem is not in the algorithm, but in the declaration of v (thanks @kazemakase). Try \n\n```\nv=n.array([1,-1,2,-3], dtype=complex) \n```\n\n\ninstead. At least for me the curves then appear on top of each other:\n\n\n\nEDIT\n\nThis was quite the journey. I wasn't able to figure out what's wrong with your code, but it looks like there are several errors, both with the dft and the fft. In the end I wrote my own version of the fft based on [this document] (http://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/www/notes/fourier/fourier.pdf) (pages 6 -- 9 hold all the information you need). Maybe you can go through the algorithm and figure out where your problems lie. The algorithm for the bit reversal can be found in this answer (or alternatively in this one ). I tested the code for linear vectors of different lengths -- let me know if you find any mistakes.\n\n```\nimport numpy as np\nimport cmath\n\ndef bit_reverse(x,n):\n    \"\"\"\n    Reverse the last n bits of x\n    \"\"\"\n\n    ##from https://stackoverflow.com/a/12682003/2454357\n    ##formstr = '{{:0{}b}}'.format(n)\n    ##return int(formstr.format(x)[::-1],2)\n\n    ##from https://stackoverflow.com/a/5333563/2454357\n    return sum(1<<(n-1-i) for i in range(n) if x>>i&1)\n\ndef permute_vector(v):\n    \"\"\"\n    Permute vector v such that the indices of the result\n    correspond to the bit-reversed indices of the original.\n    Returns the permuted input vector and the number of bits used.\n    \"\"\"\n    ##check that len(v) == 2**n\n    ##and at the same time find permutation length:\n    L = len(v)\n    comp = 1\n    bits = 0\n    while comp<L:\n        comp *= 2\n        bits += 1\n    if comp != L:\n        raise ValueError('permute_vector: wrong length of v -- must be 2**n')\n    rindices = [bit_reverse(i,bits)for i in range(L)]\n    return v[rindices],bits\n\ndef dft(v):\n    N = v.shape[0]\n    a,b = np.meshgrid(\n        np.linspace(0,N-1,N,dtype=np.complex128),\n        np.linspace(0,N-1,N,dtype=np.complex128),\n    )\n    M = np.exp((-2j*np.pi*a*b)/N)\n\n    return np.dot(M,v)\n\n\ndef fft(v):\n    w,bits = permute_vector(v)\n    N = w.shape[0]\n    z=np.exp(np.array(-2j,dtype=np.complex128)*np.pi/N)\n\n    ##starting fft\n    for i in range(bits): \n        dist = 2**i  ##distance between 'exchange pairs'\n        group = dist*2 ##size of sub-groups\n        for start in range(0,N,group):\n            for offset in range(group//2):\n                pos1 = start+offset\n                pos2 = pos1+dist\n                alpha1 = z**((pos1*N//group)%N)\n                alpha2 = z**((pos2*N//group)%N)\n                w[pos1],w[pos2] = w[pos1]+alpha1*w[pos2],w[pos1]+alpha2*w[pos2]\n    return w\n\nif __name__ == '__main__':\n\n    #test the fft\n    for n in [2**i for i in range(1,5)]:\n        print('-'*25+'n={}'.format(n)+'-'*25)\n        v = np.linspace(0,n-1,n, dtype=np.complex128)\n        print('v = ')\n        print(v)\n        print('fft(v) = ')\n        print(fft(v))\n        print('dft(v) = ')\n        print(dft(v))\n        print('relative error:')\n        print(abs(fft(v)-dft(v))/abs(dft(v)))\n```\n\n\nThis gives the following output:\n\n```\n-------------------------n=2-------------------------\nv = \n[ 0.+0.j  1.+0.j]\nfft(v) = \n[ 1. +0.00000000e+00j -1. -1.22464680e-16j]\ndft(v) = \n[ 1. +0.00000000e+00j -1. -1.22464680e-16j]\nrelative error:\n[ 0.  0.]\n-------------------------n=4-------------------------\nv = \n[ 0.+0.j  1.+0.j  2.+0.j  3.+0.j]\nfft(v) = \n[ 6. +0.00000000e+00j -2. +2.00000000e+00j -2. -4.89858720e-16j\n -2. -2.00000000e+00j]\ndft(v) = \n[ 6. +0.00000000e+00j -2. +2.00000000e+00j -2. -7.34788079e-16j\n -2. -2.00000000e+00j]\nrelative error:\n[  0.00000000e+00   0.00000000e+00   1.22464680e-16   3.51083347e-16]\n-------------------------n=8-------------------------\nv = \n[ 0.+0.j  1.+0.j  2.+0.j  3.+0.j  4.+0.j  5.+0.j  6.+0.j  7.+0.j]\nfft(v) = \n[ 28. +0.00000000e+00j  -4. +9.65685425e+00j  -4. +4.00000000e+00j\n  -4. +1.65685425e+00j  -4. -7.10542736e-15j  -4. -1.65685425e+00j\n  -4. -4.00000000e+00j  -4. -9.65685425e+00j]\ndft(v) = \n[ 28. +0.00000000e+00j  -4. +9.65685425e+00j  -4. +4.00000000e+00j\n  -4. +1.65685425e+00j  -4. -3.42901104e-15j  -4. -1.65685425e+00j\n  -4. -4.00000000e+00j  -4. -9.65685425e+00j]\nrelative error:\n[  0.00000000e+00   6.79782332e-16   7.40611132e-16   1.85764404e-15\n   9.19104080e-16   3.48892999e-15   3.92837008e-15   1.35490975e-15]\n-------------------------n=16-------------------------\nv = \n[  0.+0.j   1.+0.j   2.+0.j   3.+0.j   4.+0.j   5.+0.j   6.+0.j   7.+0.j\n   8.+0.j   9.+0.j  10.+0.j  11.+0.j  12.+0.j  13.+0.j  14.+0.j  15.+0.j]\nfft(v) = \n[ 120. +0.00000000e+00j   -8. +4.02187159e+01j   -8. +1.93137085e+01j\n   -8. +1.19728461e+01j   -8. +8.00000000e+00j   -8. +5.34542910e+00j\n   -8. +3.31370850e+00j   -8. +1.59129894e+00j   -8. +2.84217094e-14j\n   -8. -1.59129894e+00j   -8. -3.31370850e+00j   -8. -5.34542910e+00j\n   -8. -8.00000000e+00j   -8. -1.19728461e+01j   -8. -1.93137085e+01j\n   -8. -4.02187159e+01j]\ndft(v) = \n[ 120. +0.00000000e+00j   -8. +4.02187159e+01j   -8. +1.93137085e+01j\n   -8. +1.19728461e+01j   -8. +8.00000000e+00j   -8. +5.34542910e+00j\n   -8. +3.31370850e+00j   -8. +1.59129894e+00j   -8. -6.08810394e-14j\n   -8. -1.59129894e+00j   -8. -3.31370850e+00j   -8. -5.34542910e+00j\n   -8. -8.00000000e+00j   -8. -1.19728461e+01j   -8. -1.93137085e+01j\n   -8. -4.02187159e+01j]\nrelative error:\n[  0.00000000e+00   1.09588741e-15   1.45449990e-15   6.36716793e-15\n   8.53211992e-15   9.06818284e-15   1.30922044e-14   5.40949529e-15\n   1.11628436e-14   1.23698141e-14   1.50430426e-14   3.02428869e-14\n   2.84810617e-14   1.16373983e-14   1.10680934e-14   3.92841628e-15]\n```\n\n\nThis was quite a nice challenge -- I learned a lot! You can verify the results of the code online, for instance here.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Problems calulating FFT in Swift\r\n                \r\nI am trying to use this algorithm to give me a Fast Fourier Transform. My compiler is choking on the sqrt() function inside vDSP_vsmul() function when i copy it over.  line 41 of enter link description here\n\nThe error says cannot find overload for sqrt that accepts argument list of type '([(Float)])'. Anyone know what this part of the function is trying to do? The code appears to be trying to take the square root of an array of floats which seems very odd and I can only assume it once was able to compile prior to ios 8.4 as that Surge library is pretty heavily starred. The function looks like:\n\n```\nimport Accelerate\n\n// MARK: Fast Fourier Transform\n\npublic func fft(input: [Float]) -> [Float] {\nvar real = [Float](input)\nvar imaginary = [Float](count: input.count, repeatedValue: 0.0)\nvar splitComplex = DSPSplitComplex(realp: &real, imagp: &imaginary)\n\nlet length = vDSP_Length(floor(log2(Float(input.count))))\nlet radix = FFTRadix(kFFTRadix2)\nlet weights = vDSP_create_fftsetup(length, radix)\nvDSP_fft_zip(weights, &splitComplex, 1, length, FFTDirection(FFT_FORWARD))\n\nvar magnitudes = [Float](count: input.count, repeatedValue: 0.0)\nvDSP_zvmags(&splitComplex, 1, &magnitudes, 1, vDSP_Length(input.count))\n\nvar normalizedMagnitudes = [Float](count: input.count, repeatedValue: 0.0)\nvDSP_vsmul(sqrt(magnitudes), 1, [2.0 / Float(input.count)], &normalizedMagnitudes, 1, vDSP_Length(input.count))\n\nvDSP_destroy_fftsetup(weights)\n\nreturn normalizedMagnitudes\n}\n```\n\n    ", "Answer": "\r\n```\nMagnitudes```\n is an array ```\n[Float]```\n, but ```\nsqrt```\n accepts only single ```\nFloat```\n. If you need to run sqrt on the whole array, you need to use map or one of the Accelerate methods. \n\nUpdate: It looks like the sample code in the original post comes from a custom  framework, which has its own sqrt([Float]) -> [Float]. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Does divide-and-conquer really win against the increased memory allocation?\r\n                \r\nI've just finished coding some classical divide-and-conquer algorithms, and I came up the following question:(more for curiosity)\n\nAdmittedly, in many cases, divide-and-conquer algorithm is faster than the traditional algorithm; for examples, in Fast Fourier Transform, it improves the complexity from N^2 to Nlog2N. However, through coding, I found out that, because of \"dividing\", we have more subproblems, which means we have to create more containers and allocate more memories on the subproblem additionally. Just think about this, in merge sort, we have to create left and right array in each recursion, and in Fast Fourier Transform, we have to create odd and even array in each recursion. This means, we have to allocate more memories during the algorithm.\n\nSo, my question is, in reality, such as in C++, does algorithms like divide-and-conquer really win, when we also have to increase the complexity in memory allocation? (Or memory allocation won't take run time at all, and it's cost is zero?)\n\nThanks for helping me out!\n    ", "Answer": "\r\nAlmost everything when it comes to optimisation is a compromise between one resource vs. another - in traditional engineering it's typically \"cost vs. material\". \n\nIn computing, it's often \"time vs. memory usage\" that is the compromise. \n\nI don't think there is one simple answer to your actual question - it really depends on the algorithm - and in real life, this may lead to compromise solutions where a problem is divided into smaller pieces, but not ALL the way down to the minimal size, only \"until it's no longer efficient to divide it\". \n\nMemory allocation isn't a zero-cost operation, if we are talking about ```\nnew```\n and ```\ndelete```\n. Stack memory is near zero cost once the actual stack memory has been populated with physical memory by the OS - it's at most one extra instruction on most architectures to make some space on the stack, and sometimes one extra instruction at exit to give the memory back. \n\nThe real answer is, as nearly always when it comes to performance, to benchmark the different solutions. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Clear out the ecg signal\r\n                \r\nI have a raw ecg signal, that contains complex values (real and imaginary) in time. Now I have to clear that signal out, remove noises, and flatten the signal. \n\nThe algorithm to do this that i know of is fast fourier transformation (FFT), but it doesnt flatten the signal, instead it generates correct fourier transformation, but the signal is not flat, it has high values on both sides. How can i do that?\n\nI am doing this in java language, but I dont ask for the code, just for the hint with the idea, or an algorithm.\n\nThanks!\n    ", "Answer": "\r\nFFT doesn't flatten signal, it translates signal from time domain to frequency domain. If you signal is pure real, FT is symmetric - so you can see similar high peaks at both ends - this is very low frequency part of your signal.\n\nTo filter a signal, you can execute FT, apply some function to the result of transform - for example, lower high and very low frequency regions, and execute backward FT to return in the time domain. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How do fourier processing algorithms deal with \"data edges\"\r\n                \r\nI am doing some interesting experiments with audio and image files and Fast-Fourier Transforms (FFTs).\n\nFast Fourier Transforms are used in signal processing rather than other Fourier Transform algorithms because for large quantities of data they are the only (or one of the only) viable algorithm variants to use, as they scale as O(n log(n)), rather than n^2 as the naive implementation does.\n\nThe disadvantage is that the data must be stored in an array which has 2^n elements, for n integer.\n\nWhen processing some data which does not have 2^n elements, the simple approach is to extend the array to be length 2^n and fill the \"empty\" elements with zero. (Assuming the mean value of the input signal is zero.)\n\nI wrote a program to process some audio samples taken from WAV files. I tried implementing things such as a low-cut filter. In this case I found that my output signal (after doing the reverse transform) cuts to zero amplitude after a certain period of time. This is obviously not what one would expect of a low-pass filter.\n\nI could dump my code at this point, but that is neither useful, nor legal as the source of my algorithm is a text-book with closed source code.\n\nInstead I shall ask the following question.\n\nIs packing out the array with zeros the best possible thing to do? Could this be causing my program to produce the unexpected results I am seeing? if I understand fourier mathematics correctly, having a bunch of zeros at the end of my array will introduce a large amount of low and high-frequency content as this essentially looks like a step-function (low frequency square wave). Should I be doing something else such as implementing my band-pass filter in a different way, for example, splitting the data into smaller groups of say 1024 samples and applying the FT, filter and IFT (inverse FT) to those small groups?\n\nThis question has been tagged with theory as it is not related to any specific programming language. (I assume that is the correct tag to use?)\n\nEdit: It's now working beautifully, thanks all, I was able to pinpoint the 2 mistakes I made using the information below.\n    ", "Answer": "\r\nAll finite length DFTs and FFT multiply longer data (longer source data or wav file than the FFT) with a rectangular window, which convolves the spectrum with a (periodic) Sinc function.  Zero padding uses a shorter rectangular window, which results in the convolution of the spectrum with a wider Sinc function.\n\nFiltering by multiplication of FFTs results in circular convolution, which wraps the impulse response of the filter around the FFT/IFFT result (e.g. the end of your filtered signal will interfere with the beginning of the filtered signal within the IFFT result).  So you want to zero-pad your data before the FFT, and then see the impulse response of your filter go to zero at or before the very end of the filtered result (e.g. not wrap around).  Look up the overlap-add and overlap-save algorithms, for using short FFTs for fast convolution filtering of longer signals, which take care of the filter impulse response extending into the zero-padded portion.\n\nYou can also use FFTs that are not a power of 2 in length.  Any length that can be factored into small primes will work with most modern FFT libraries.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Are there open source libraries to build audio visualizations for iOS?\r\n                \r\nI have an equalizer view with 10 bars in OpenGL ES which can light up and down. Now I'd like to drive this equalizer view from the background music that is playing in iOS.\n\nSomeone suggested what I need is a Fast Fourier Transform to transform the audio data into something else. But since there are so many audio visualizations floating around, my hope is that there is an open source library or anything that I could start with.\n\nMaybe there are open source iOS projects which do audio visualization?\n    ", "Answer": "\r\nYes.\n\nYou can try this Objective-C library which I wrote for exactly this purpose. What it does is to give you an interface for playing files from ```\nURL```\ns and then getting real-time FFT and waveform data so that you can feed it with your OpenGL bars or whatever graphics you're using to visualise the sound. It also tries to deliver very accurate results.\n\nIf you want to do it in swift, you can take a look at this example which is cleaner and also shows how it's possible to actually draw the equalizer view.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Using scipy fft and ifft to solve ordinary differential equation numerically\r\n                \r\nI have an ```\nordinary differential equation```\n in time domain as follows: \n\n```\nC*du/dt = -g*u + I\n```\n\n\nwhere ```\nI = A*t/tau*exp^(1-t/tau)```\n\n\nin the freq domain:\n\n```\nu(w) = I(w)/(g*(1+C/g*j*w))\n```\n\n\n```\nj```\n being the complex number ```\nsqrt(-1)```\n\n\nhence i can get ```\nu(t)```\n by going into the freq domain using  fast Fourier transform (```\nfft```\n) and then back using ```\nifft```\n.\n\nthe codes:\n\n```\nt = np.linspace(0.,499.9,5000)\nI = q*t*np.exp(1-t/Tau_ca)/Tau_ca\nu1 = np.fft.ifft(np.fft.fft(I)/(G_l*(1.+1.j*(C_m/G_l)*np.fft.fftfreq(t.shape[-1]))))\n```\n\n\nHowever, when I compare this ```\nu(t)```\n obtained with other methods such as numerical integration of the differential equation or its analytical form, it is not correct. I have tried and been unsuccessful at figuring out where my mistakes are. \n\nplease enlighten.\n    ", "Answer": "\r\nThe derivative of a sinusoid, or complex exponential, is directly proportional to its frequency, and phase shifted by ```\nπ/2```\n. For a complex exponential the phase shift is equivalent to multiplying by ```\nj```\n. For example, ```\nd/dt exp(j*Ω*t)```\n ```\n== j*Ω * exp(j*Ω*t)```\n ```\n== Ω * exp(j*π/2) * exp(j*Ω*t)```\n ```\n== Ω * exp(j*(Ω*t + π/2))```\n. So if you have the Fourier transform pair ```\nu(t) <=> U(Ω)```\n, then ```\ndu/dt <=> jΩ * U(Ω)```\n. Integration is pretty much the inverse operation, but it may add an impulse if there's a DC component: ```\n∫udt <=> U(Ω) / jΩ + π*U(0)*δ(Ω)```\n\n\nTo approximate the derivative using a sampled sequence, you have to scale the discrete-time angular frequency ω (which ranges from 0 to 2π, or -π to π) by the sample rate, ```\nfs```\n. For example, say the discrete-time frequency is π/2 radians/sample, such as the sequence ```\n[1, 0, -1, 0, ...]```\n. In the original signal this corresponds to ```\nfs/4```\n. The derivative is ```\nd/dt cos(2*π*fs/4*t) == d/dt cos(π/2*fs*t)```\n ```\n== -π/2*fs*sin(π/2*fs*t)```\n ```\n== π/2*fs*cos(π/2*fs*t + π/2)```\n.\n\nYou have to sample at an ```\nfs```\n that's more than twice the bandwidth of the signal. The sampled component at exactly  ```\nfs/2```\n is unreliable. Specifically, with only 2 samples per cycle the amplitude of the ```\nfs/2```\n component alternates the sign of the first sample in the sequence. So for a real-valued signal the ```\nfs/2```\n DFT component is real valued, with a phase of either 0 or π radians, i.e. ```\na*cos(π*fs*t + {0, π})```\n. Given the latter, the derivative of the ```\nfs/2```\n component is ```\n-a*π*fs*cos(π*fs*t + {π/2, 3*π/2})```\n, which is 0 for the sample times ```\nt == n/fs```\n.\n\n(Regarding the latter, the standard trigonometric interpolation of the DFT uses a cosine, and in that case the derivative will be zero at the sample points. The isn't necessarily true if you sample the signal and its derivative simultaneously. Sampling loses the phase of the ```\nfs/2```\n component relative to the signal, but not relative to its derivative. Depending on the time you start sampling, both the ```\nfs/2```\n component and its derivative may be non-zero at the sample points. If by luck one of them is 0 at the sample times, the other will be at its peak, since they're ```\nπ/2```\n radians apart.)\n\nGiven that the ```\nfs/2```\n DFT component is always real valued for a real-valued signal, when you multiply it by ```\nj```\n in the course of computing the derivative or integral, this introduces an imaginary-valued component in the result. There's a simple workaround. If ```\nN```\n is even, just zero out the ```\nfs/2```\n component at index ```\nN/2```\n. Another problem is division by zero when dividing by ```\njΩ```\n for integration. This can be solved by adding a small value to index 0 of the ```\nΩ```\n vector (e.g. ```\nfinfo(float64).tiny```\n is the smallest double precision float). \n\nGiven ```\nΩ = fs * ω```\n, the system shown in the question has the following form in the frequency-domain:\n\n```\nH(Ω) = 1 / (g + j*Ω*C)\nU(Ω) = I(Ω) * H(Ω)\n```\n\n\nIt's a single-pole low-pass filter. The solution you derived has 2 problems. \n\n\nYou aren't scaling the frequency variable ```\nw```\n by ```\nfs```\n.  \nYou use ```\nfftfreq```\n, which uses the range -0.5 to 0.5. You need -π to π. \nActually you only need 0 to π because ```\ni(t)```\n is real-valued. In this \ncase you can use ```\nrfft```\n and ```\nirfft```\n for real-valued signals, which \nskips computing the negative frequencies.\n\n\nAll that said, you may still be disappointed with the result because the DFT uses the periodic extension of your signal. \n\nExamples\n\nFirst, here's a simple example of a 1 Hz sinusoid (plotted in red) sampled at 1024 samples/s for 2 seconds, and its derivative computed via the DFT (plotted in blue):\n\n```\nfrom pylab import *\n\nfs = 1024\nt = arange(2*fs, dtype=float64) / fs\nN = len(t) // 2 + 1    # non-negative frequencies\nw = 2 * pi / len(t) * arange(N)\nOmega = w * fs\n\nx0 = cos(2*pi*t)    # w0 == 2*pi/fs\nX0 = rfft(x0);\n# Zero the fs/2 component. It's zero here anyway.\nX0[-1] = 0  \ndx0 = irfft(X0 * 1j*Omega)\nplot(t, x0, 'r', t, dx0, 'b')\nshow()\n```\n\n\n\n\nThis is an easy case -- a periodic signal with finite bandwidth. Just make sure to sample an integer number of periods at a high enough rate to avoid aliasing.\n\nThe next example is a triangle wave, with a slope of 1 and -1, and a discontinuity in the derivative at the center and edges. Ideally, the derivative should be a square wave, but computing that perfectly would require infinite bandwidth. Instead there's Gibbs ringing around the discontinuity:\n\n```\nt2 = t[:fs]\nm = len(t) // (2*len(t2))\nx1 = hstack([t2, 1.0 - t2] * m)\nX1 = rfft(x1)\nX1[-1] = 0\ndx1 = irfft(X1 * 1j*Omega)\nplot(t, x1, 'r', t, dx1, 'b')\nshow()\n```\n\n\n\n\nThe DFT's implicit periodic extension is problematic if you're solving a non-periodic system. Here's a solution to the system in question using both ```\nodeint```\n and the DFT (```\ntau```\n is set to 0.5s; ```\ng```\n and ```\nC```\n are set for a 1 Hz corner frequency):\n\n```\nfrom scipy.integrate import odeint\n\na = 1.0; tau = 0.5\ng = 1.0; C = 1.0 / (2 * pi)\ni = lambda t: a * t / tau * exp(1 - t / tau)\nf = lambda u, t: (-g*u + i(t)) / C\n\nH = 1 / (g + 1j*Omega*C)  # system function\nI = rfft(i(t))\nI[-1] = 0\nU_DFT = I * H\nu_dft = irfft(U_DFT)\nu_ode = odeint(f, u_dft[0], t)[:,0]\n\ntd = t[:-1] + 0.5/fs\nsubplot('221'); title('odeint u(t)');\nplot(t, u_ode)\nsubplot('222'); title('DFT u(t)');\nplot(t, u_dft)\nsubplot('223'); title('odeint du/dt')\nplot(td, diff(u_ode)*fs, 'r',\n     t, (-g*u_ode + i(t)) / C, 'b')           \nsubplot('224'); title('DFT du/dt')\nplot(td, diff(u_dft)*fs, 'r',\n     t, (-g*u_dft + i(t)) / C, 'b')\nshow()\n```\n\n\n\n\nThe ```\ndu/dt```\n graphs overlay the derivative as estimated by ```\ndiff```\n (red) versus the calculated value from the differential equation (blue). They're approximately equal in both cases. I set the initial value for ```\nodeint```\n to ```\nu_dft[0]```\n in order to show that it returns the DFT solution for the same initial value. The difference is that the ```\nodeint```\n solution would continue to decay to zero, but the DFT solution is periodic with a 2s period. The DFT result will look better in this case if more of i(t) is sampled, since i(t) starts at zero and decays to zero. \n\nZero padding is used with the DFT to perform linear convolution. Specifically in this case, zero padding of the input would help to separate the transient of the Zero State Response from its steady-state. However, more commonly the Laplace or z-transform system functions are used to analyze the ZSR/ZIR. ```\nscipy.signal```\n has tools to analyze LTI systems, including mapping continuous-time to discrete-time in polynomial, zero-pole-gain, and state-space forms.\n\nJohn P. Boyd discusses a Chebyshev approximation method for non-periodic functions in Chebyshev and Fourier Spectral Methods (free online at his University of Michigan page). \n\nYou'll probably get more help with a question such as this if you ask on the Signal Processing or Mathematics Stack Exchanges.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Interpolating between two fourier transforms over time\r\n                \r\nI'm a musician and I'm making a script that takes a wave file and snaps each of its frequencies from the fourier transforms to the nearest musical harmonic. Thanks to help from another question I posted here, that part works, but what I need to do now is make it so throughout the sound wave it tunes one frequency at a time so that at the beginning of the output it sounds the same as the input, and by the end it sounds like an instrument.\n\nIf I just wanted them to fade into each other then that would be easy, I could just crossfade in audacity or take a weighted average of the original fourier transform and the output one, but what I want to do instead is tune one frequency at a time. This means that at 50% of the way through the output, 50% of the frequencies have been snapped to the nearest harmonic and the other 50% are untouched. How could I accomplish this without computing every single sample of the output individually?\n\nAlso, I was thinking of reducing the MAX_HARMONIC over time as well but it would have a similar problem.\n\nThis is the sample I'm testing with (rename it to missile.wav):\nhttps://my.mixtape.moe/iltlos.wav\n\nHere is the script so far:\n\n```\nimport struct\nimport wave\nimport numpy as np\n\n\n# import data from wave\nwav_file = wave.open(\"missile.wav\", 'r')\nnum_samples = wav_file.getnframes()\nsampling_rate = wav_file.getframerate() / 2\ndata = wav_file.readframes(num_samples)\nwav_file.close()\n\ndata = struct.unpack('{n}h'.format(n=num_samples), data)\ndata = np.array(data)\n\n# fast fourier transform makes an array of the frequencies of sine waves that comprise the sound\ndata_fft = np.fft.rfft(data)\n\n\n# the higher MAX_HARMONIC is, the more it sounds like the original, \n# the lower it is, the more it sounds like an instrument\nMAX_HARMONIC = 2\n\n# generate list of ratios that can be used for tuning (not octave reduced)\nvalid_ratios = []\nfor i in range(1, MAX_HARMONIC + 1):\n    for j in range(1, MAX_HARMONIC + 1):\n        if i % 2 != 0 and j % 2 != 0:\n            valid_ratios.append(i/float(j))\n            valid_ratios.append(j/float(i))\n\n\n# remove dupes\nvalid_ratios = list(set(valid_ratios))\n\n\n# find all the frequencies with the valid ratios\nvalid_frequencies = []\nmultiple = 2\nwhile(multiple < num_samples / 2):\n    multiple *= 2\n\n    for ratio in valid_ratios:\n        frequency = ratio * multiple\n\n        if frequency < num_samples / 2:\n            valid_frequencies.append(frequency)\n\n\n\n# remove dupes and sort and turn into a numpy array\nvalid_frequencies = np.sort(np.array(list(set(valid_frequencies))))\n\n\n# bin the data_fft into the nearest valid frequency\nvalid_frequencies = valid_frequencies.astype(np.int64)\nboundaries = np.concatenate([[0], np.round(np.sqrt(0.25 + valid_frequencies[:-1] * valid_frequencies[1:])).astype(np.int64)])\nselect = np.abs(data_fft) > 1\nfiltered_data_fft = np.zeros_like(data_fft)\nfiltered_data_fft[valid_frequencies] = np.add.reduceat(np.where(select, data_fft, 0), boundaries)\n\n\n# do the inverse fourier transform to get a sound wave back\nrecovered_signal = np.fft.irfft(filtered_data_fft)\n\n# write sound wave to wave file\ncomptype=\"NONE\"\ncompname=\"not compressed\"\nnchannels=1\nsampwidth=2\n\nwav_file=wave.open(\"missile_output.wav\", 'w')\nwav_file.setparams((nchannels, sampwidth, int(sampling_rate), num_samples, comptype, compname))\n\nfor s in recovered_signal:\n    wav_file.writeframes(struct.pack('h', s))\n\nwav_file.close()\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to perform a *Fast* DCT (Discrete Cosine Transform) in R?\r\n                \r\nUsing Rprof revealed the dct in the dtt package to be the main offender in a piece of R code that was running quite slowly. Swapping it out for fft in the stats package (which is not the same transformation, but should take the same time to compute) my run time improved dramatically. In fact 2/3 of my Rprof lines were dct calls previously and a mere 3 lines of about 600 were fft calls after making the switch.\n\nIs the dct implementation in the dtt package not done using the fast discrete fourier transform? If so, is there a package that does have one? (I know one could double ones data, then extract coefficients for the dct from those fft coefficients, but a straight fast dct would certainly be nicer, and there really ought to be one somewhere).\n    ", "Answer": "\r\nThere appears to be no fast dct, but there is an fft (fast fourier transform) in the stats package, so here is how you could go about getting the fast dct using fft.\n\nUse this at your own risk. I haven't done any serious checking of it. I checked it on a couple of vectors of different sizes and it gave the same results as function dct in package dtt on those. If anyone wants to double check me by comparing it to the output from dct then feel free to do so and post your results.\n\nTake your vector and extend it to a vector twice as long as follows: If your vector is v=(1,2,3) then double the entries to w=(1,2,3,3,2,1). Note the ordering. If your vector is v=(1,2,4,9) then double the entries to w=(1,2,4,9,9,4,2,1)\n\nLet N be the length of your ORIGINAL vector (before you doubled its length).\n\nThen the first N coefficients of \n.5 * fft(w)/exp(complex(imaginary=pi / 2 / N)*(seq(2*N)-1))\nshould agree with computing \ndct(v)\nexcept it should be dramatically faster in almost all cases.\n\nSpeed considerations. If you prime factor N then the time it takes to compute the fast dct is like the time it takes to do a slow dct for each of those prime factors. So if N is 2^K it is like doing a K different slow dct transforms on a vector of length two, so its really fast. If N is prime (worst case scenario) then there is no speed up at all. The greatest speedup is on vectors that are a power of two in length.\n\nNote: The R code above looks incredibly unfriendly, so let me say what is going on. After doubling the length in the right way, the first N coefficients of the fft you get are almost the right thing. However the coefficients need to be tweaked a bit. Let P stand for e^(pi * i / 2 / N). Leave the first coefficient alone. Divide the second coefficient by P, divide the third by P^2, divide the fourth by P^3, etc... Then divide all the coefficients by 2 (including the first one) to agree with the normalization R uses for the dct. \n\nThis should give the same thing as using the dct function in package dtt but be dramatically faster in almost all cases.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Plotting two different equations on the same graph/matlab\r\n                \r\nWhile I am able to plot my FFT( fast fourier transform) plot(X,Y), however I am unable to plot my fit line f(x) along with my FFT. The equations was gathered from the curve fitting tool, I took the ten best fit and averaged the to come up with equation f(x). \n\nwhat must I do for f(x) to be plotted with log(freq) and log(Pow)\n\ncode:\n\n```\nrow=69;\ncol=69;\n\ncolormap gray\nwhitebg('black')\n\niterations=10^3;\n\n\nNext=zeros(row,col);\nlaplacian=zeros(row,col);\ncritical=zeros(row,col);\n\nB= zeros(row,col);\nlums=zeros(1000);\n\n\nflw=0.5;\n\nu=0.1;\n\ncrit=5;\n%bns=200;\nbns=1000;\n\nfor k=1:iterations\n    B=B+(rand(row,col)-0.5);\n   Next=B;\n\nrns=5.;\nfor i=1:row\nfor j=1:col\n\nrfromns=(col+rns-j);\n        critical(i,j)=0;\n        if i<=2 left=row; else left=(i-1);end\n        if i==row right=1; else right=(i+1);end\n        if (j<=2) top=1; else top=(j-1);end\n        if (j==col) bottom=j; else bottom=(j+1);end\n        l=B(i,top)+B(left,j)+B(right,j)+B(i,bottom)+0.5*(B(left,top)+B(right,top)+B(left,bottom)+B(right,bottom));\n        l=l-6.*B(i,j);\n        laplacian(i,j)=l;\n        bfromns=bns/rfromns^3;\n        if (abs(l)/((abs(B(i,j))+bfromns)+0.01))>crit; critical(i,j)=1; end\n        %if abs(l)>crit; critical(i,j)=1; end\nend\nend\n\n\n\n            for j = 1:col\n            if (j==col) lum=0.;end\n            for i = 1:row\n\n            if (j>1) Next(i,j)=(1-flw)*B(i,j)+flw*B(i,j-1); end;\n            if (j==1) Next(i,j)=(1-flw)*B(i,j); end;\n\n            if (critical(i,j)==1)&& (j>1)   Next(i,j)=B(i,j)*(1-flw-flw*u)+flw*B(i,j-1)+(flw*u)*B(i,j)/5.; end;\n            if i<2 left=row; else left=(i-1);end\n            if i==row right=1; else right=(i+1);end\n            if (j<=2) top=1; else top=(j-1);end\n            if (j==col) bottom=j; else bottom=(j+1);end\n\n            if (critical(left,j)==1) Next(i,j)=Next(i,j)+flw*u*B(left,j)/5.;end\n            if (critical(right,j)==1) Next(i,j)=Next(i,j)+flw*u*B(right,j)/5.;end\n            if (critical(i,top)==1) Next(i,j)=Next(i,j)+flw*u*B(i,top)/5.;end\n            if (critical(i,bottom)==1) Next(i,j)=Next(i,j)+flw*u*B(i,bottom)/5.;end\n\n            if (j==col) lum=lum+u*B(i,j)*B(i,j)+abs(laplacian(i,j)); end\n            end\n            end\n\nlums(k)=lum;\n\nB=Next;                \n%Matplot(B)\n%if (k>00)\nsurf(B);\n%plot(lums)\n%view([0 90])\n%pause(0.001)\n%end\nend\n\n\nc=fft(lums(129:iterations));\npow=abs(c).^2;\npow=pow(2:(iterations-128)/2);\nfreq=(2:(iterations-128)/2);\n\nX=log(freq);\nY=log(pow);\n\n%x=length(X);\n\nx=0.6:.1:6.;\n\n%Linear model Poly2\na1 = -0.155;  \na2 = 0.2154;  \na3 = 15.1;\naf(x) = a1*x.^2 + a2*x + a3;\n\n%Linear model Poly3\nb1 = 0.01805;  \nb2 = -0.3687;  \nb3 = 0.9874;  \nb4 = 14.29; \nbf(x) = b1*x.^3 + b2*x.^2 + b3*x + b4;\n\n\n%General model Power2\nc1 = -0.09124;  \nc2 = 2.179;  \nc3 = 15.34;\ncf(x) = c1*x.^c2+c3;\n\n\n%General model Rat02\nd1 = 727.3;  \nd2 = -3.447;  \nd3 = 51.6; \ndf(x) = (d1) / (x.^2 + d2*x + d3);\n\n\n%General model Gauss1\ne1 = 15.01;  \ne2 = 1.346;  \ne3 = 8.152; \nef(x) =  e1*exp(-((x-e2)/e3).^2);\n\n\n%General model Gauss2 \nw1 =  1.737;  \nw2 =  3.46;\nw3 =  2.333;  \nw4 =  30.03;  \nw5 =  -23.14;\nw6 =  28.23;\nwf(x) =  w1*exp(-((x-w2)/w3).^2) + w4*exp(-((x-w5)/w6).^2); \n\n\n%General model Sin1\ng1 = 15.11;  \ng2 = 0.1526;  \ng3 = 1.428;  \ngf(x) =  g1*sin(g2*x+g3);\n\n\n\n%Linear model Poly4\nh1 =  0.0179;  \nh2 =  -0.252;  \nh3 =  1.047;  \nh4 =  -1.97; \nh5 =  16.23;  \nhf(x) = h1*x.^4 + h2*x.^3 + h3*x.^2 + h4*x + h5;\n\n\n%General model Fourier1\nm1 =  11.05;  \nm2 =  3.31;  \nm3 =  2.104;  \nm4 =  0.3644;  \nmf(x) =  m1 + m2*cos(x*m4) + m3*sin(x*m4);\n\n\n%Linear model\np1 =  0.815;\np2 =  0.1061;\np3 =  8.904;\npf(x) = p1*(sin(x-pi)) + p2*((x-10).^2) + p3;\n\n\nf(x)=(af(x)+bf(x)+cf(x)+df(x)+ef(x)+wf(x)+gf(x)+hf(x)+mf(x)+pf(x))/10;\n\n\n\nplot(X,Y)\nplot(f(x))\n```\n\n    ", "Answer": "\r\nMatlab/Octave therefore use the ```\nhold```\n keyword.\n\nIf you want to plot several things on one graph, you start your program with ```\nhold on```\n, then execute one or more plot command, and finalize with ```\nhold off```\n.\n\nExample:\n\n```\nhold on;\nx = -10:0.1:10;\nplot (x, sin (x));\nplot (x, cos (x));\nhold off;\n```\n\n\nDocumentation: https://www.gnu.org/software/octave/doc/interpreter/Manipulation-of-Plot-Windows.html\n\n\n\nAs the documentation describes, ```\nplot```\n will normally call the ```\nnewplot```\n command, that removes the previous plot result, with ```\nhold on;```\n such behavior is prevented.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "xamarin: Convert mp3 to pcm16 (wav) to access raw bytes\r\n                \r\nI'm working with xamarin.forms.\n\nI need to read an mp3 file and to access to raw bytes[] as I need to performa an FFT (Fast Fourier Transform).\n\nI can read an mp3 using MediaPlayer and a custom MediaDataSource reading bytes by ReadAt method.\n\nAnyway I need the raw pcm16 converted version to manage data correctly.\n\nNAudio is not available as dll are missing.\n\nI need a solution can work both fopr Android and iOS.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Extracting notes from chords in C#\r\n                \r\nAt the moment I have no code to help me, but the Fast Fourier Transform probably has something to do with my goal.\n\nI would like to take microphone input and 'extract' the notes from the chords, whether they are spoken vowels or instrumental. I want to display the values of the extracted frequencies in a list after a certain cue. The cue is not important.\n\nThanks for any help, I'll add more if needed\n    ", "Answer": "\r\nThis has been covered many times on SO already, but essentially you do this:\n\n\napply window function (e.g. Hanning)\ncalculate FFT to get complex spectrum\ncalculate magnitude (```\nsqrt(re*re+im*im)```\n) to get power spectrum\nfind peaks in power spectrum\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT on EEG signal in Android understanding the code\r\n                \r\nI've been attempting to find a library that would enable to perform FFT (Fast Fourier Transform) on some EEG signals in Android. \n\nwith help of Geobits, I've finally found the code that might help me do FFT on an EEG signal. But I am having a hard time figuring out how does the code actually work. I want to know what float array x and y are for and maybe an example that might help me a little more.\n    ", "Answer": "\r\nAn fft should return a series of complex numbers (could either be rectangular coordinates, or polar: phase and magnitude) for a specific range of frequencies...\n\nI'm still working through the expressions, but I'll bet dollars to donuts that the x and y arrays are the real (x) and imaginary (y) components of the complex numbers that are the result of the transformation.\n\nThe absolute value of the sum of the squares of these two components should be the magnitude of the harmonic component at each frequency (conversion to polar).\n\nIf the phase is important for your application, keep in mind that the the FFT (as with any phasor) can either be sine referenced or cosine referenced.  I beleive sine is the standard, however.\n\nsee:\n\nhttp://www.mathworks.com/help/matlab/ref/fft.html\n\nhttp://mathworld.wolfram.com/FastFourierTransform.html\n\nSince the FFT gives a truncated approximation to an infinite series created by a harmonic decomposition  of a periodic waveform any periodic waveform can be used to test the functionality of your code.\n\nFor an example, a square wave should be easy to replicate, and has very well known harmonic coefficients.  The resolution of the data set will determine the number of harmonics that you can calculate (most fft algorithms do best with a data set that has a length equal to a power of two, and is a number of integral wavelengths of the longest frequency that you want to use).\n\nThe square wave coefficients should be at odd multiples of the fundamental frequency and have magnitudes that vary inversely with the order of the harmonic.\n\nhttp://en.wikipedia.org/wiki/Square_wave\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Image processing for blur detection\r\n                \r\nI am trying to detect blurred images. Thanks to this post, I managed to create a script using Fast Fourier Transform and so far it worked quite well. But for some photos, I am not able to get correct results.\nWhen the background is almost as the same color than the objects from the front, I think my script is not able to give good result.\nDo you have any leads to correct this ?\n\n\n```\nimport cv2\nimport imutils\nfrom PIL import Image as pilImg\nfrom IPython.display import display\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\ndef detect_blur_fft(image, size=60, thresh=17, vis=False):\n    \"\"\"\n    Detects blur by comparing the image to a blurred version of the image\n    \n    :param image: The image to detect blur in\n    :param size: the dimension of the smaller square extracted from the image, defaults to 60 (optional)\n    :param thresh: the lower this value, the more blur is acceptable, defaults to 17 (optional)\n    :param vis: Whether or not to return a visualization of the detected blur points, defaults to False\n    (optional)\n    \"\"\"\n    # grab the dimensions of the image and use the dimensions to\n    # derive the center (x, y)-coordinates\n    (h, w) = image.shape\n    (cX, cY) = (int(w / 2.0), int(h / 2.0))\n    # compute the FFT to find the frequency transform, then shift\n    # the zero frequency component (i.e., DC component located at\n    # the top-left corner) to the center where it will be more\n    # easy to analyze\n    fft = np.fft.fft2(image)\n    fftShift = np.fft.fftshift(fft)\n    # check to see if we are visualizing our output\n    if vis:\n        # compute the magnitude spectrum of the transform\n        magnitude = 20 * np.log(np.abs(fftShift))\n        # display the original input image\n        (fig, ax) = plt.subplots(1, 2, )\n        ax[0].imshow(image, cmap=\"gray\")\n        ax[0].set_title(\"Input\")\n        ax[0].set_xticks([])\n        ax[0].set_yticks([])\n        # display the magnitude image\n        ax[1].imshow(magnitude, cmap=\"gray\")\n        ax[1].set_title(\"Magnitude Spectrum\")\n        ax[1].set_xticks([])\n        ax[1].set_yticks([])\n        # show our plots\n        plt.show()\n    # zero-out the center of the FFT shift (i.e., remove low\n    # frequencies), apply the inverse shift such that the DC\n    # component once again becomes the top-left, and then apply\n    # the inverse FFT\n    fftShift[cY - size:cY + size, cX - size:cX + size] = 0\n    fftShift = np.fft.ifftshift(fftShift)\n    recon = np.fft.ifft2(fftShift)\n    # compute the magnitude spectrum of the reconstructed image,\n    # then compute the mean of the magnitude values\n    magnitude = 20 * np.log(np.abs(recon))\n    mean = np.mean(magnitude)\n    # the image will be considered \"blurry\" if the mean value of the\n    # magnitudes is less than the threshold value\n    return (mean, mean <= thresh)\n\npathImg = \"path to the image\"\nimage = cv2.imread(pathImg)\n# Resizing the image to 500 pixels in width.\nimage = imutils.resize(image, width= 500)\n# Converting the image to gray scale.\ngray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n# Using the FFT to detect blur.\n(mean, blurry) = detect_blur_fft(gray, size=60)\nimage = np.dstack([gray] * 3)\n# This is a conditional statement that will set the color to red if the image is blurry or green\ncolor = (0, 0, 255) if blurry else (0, 255, 0)\ntext = \"Blurry ({:.4f})\" if blurry else \"Not Blurry ({:.4f})\"\ntext = text.format(mean)\n# Adding text to the image.\ncv2.putText(image, text, (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)\nprint(\"[INFO] {}\".format(text))\n# show the output image\ndisplay(pilImg.fromarray(image))\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "IFFT function in R?\r\n                \r\nIn Matlab, there is an ```\nifft```\n function (Inverse fast Fourier transform) - details.\n\nIn particular, the following:\n\n```\nifft(X,n,dim)\n```\n\n\nWhich returns the inverse DFT of ```\nX```\n across the dimension ```\ndim```\n.\n\nIn R, there is a similar function apart of the ```\nsignal```\n package - details\n\nHowever it only allows for the x input array, as follows:\n\n```\nifft(x)\n```\n\n\nQuestion:\n\nIs there any way to include the extra dimension, such as dim in the Matlab function, with R?\n\nThank you so much for taking a look at my question, very helpful.\n    ", "Answer": "\r\nAre you looking for ```\n? mvfft```\n (with ```\ninverse = TRUE```\n)?\n\n```\nmvfft```\n does the (inverse) FFT by columns, but you can reshape your data:\n\n\n```\nt```\n for matrix transpose \n```\naperm```\n for an array extension of ```\nt```\n (dimension permutation)\nyou can reshape your array to a matrix by ```\ndim<-```\n\n(package arrayhelpers has convenience functions for such conversion of an array into a matrix and back).\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How many FLOPS for FFT?\r\n                \r\nI would like to know how many ```\nFLOPS```\n a Fast Fourier Transform (FFT) performs.\n\nSo, if I have a ```\n1```\n dimensional array of ```\nN```\n float numbers and I would like to calculate the FFT of this set of numbers, how many ```\nFLOPS```\n need to be performed?\n\nI know that this depends on the used algorithm, but what about the fastest available?\n\nI also know that the scaling of a FFT is of the order of ```\nN*log(N)```\n but this would not answer my question.\n    ", "Answer": "\r\nThat depends on implementation. Fastest does not necessary mean lowest FLOP nor highest FLOPS. The speed is often achieved by exploiting HW architecture rather than lowering FLOP. There are too many implementations out there so your question without actual code and architecture is unanswerable.\n\nI like precomputed ```\nW```\n matrix implementations as I usually use FFT for single resolution matrices many times so no need to compute ```\nW```\n more then once per resolution. That can cut down FLOP per recursion layer significantly.\n\nFor example this DFFTcc has 14 FLOP per iteration using only ```\n+,-,*```\n operations. Assuming 1D FFT case ```\nN=8```\n and using basic data-type if I did not make any silly mistake:\n\n```\nFLOP = 8*14 + (4+4)*14 +(2+2+2+2+2)*14 +(1+1+1+1+1+1+1+1)*2 = 14*N*log2(N) + 2*N = 352\n```\n\n\nIf you use Real input/output you can even lower that for first/last recursion layer. But simple FLOP count is not enough as some operations are more complicated then others. And also FLOP are not the only thing that affect speed.\n\nNow to get the FLOPS just measure ```\ntime [s]```\n  the FFT takes:\n\n```\nFLOPS = FLOP/time\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How would I compile Kiss_fft to use the double data type C++?\r\n                \r\nI am looking to compile KISS_FFT (Keep it simple stupid) so that it can accept an array of double as input and output an array of doubles.\n\nKISS_FFT is a library which does a fast Fourier Transformation on a set of data and outputs the result.  By default it looks like it uses the float data type.\n    ", "Answer": "\r\nYou just need to define the makefile variable ```\nDATATYPE```\n, e.g.:\n\n```\nmake DATATYPE=double ...\n```\n\n\nThis in turn defines the macro ```\nkiss_fft_scalar```\n as ```\ndouble```\n.\n\nTo see this in action:\n\n```\ncd test\nmake DATATYPE=double test\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python: FFT parallel computing\r\n                \r\nI have a cluster of few PC's with Ubuntu and MPICH server - I use them to parallel computing with C++ and MPI. Now I want to do similar with Python. My question is - is there any easy method to make Fast Fourier Transform on many CPU cores (on many computers)? Example of usage would be nice. Here is method I use on single thread:\n\n```\nimport numpy as np\nN=1024\ntab=np.random.rand(N,N,N) #declare some matrix in 3d\na=np.random.rand(N,N,N) #declare other matrix\ntab=np.fft.ifftn(a*np.fft.fftn(tab))\n```\n\n\nIt's nice to have multithreaded solution when we have 2^30 numbers...\n    ", "Answer": "\r\nMPI4py in connection with pyFFTW.  FFTW is highly optimized and works well on multiple threads but the interface is a little different than your average FFT as it requires creating 'plans' outright.  However, this was just done to optimize out processing of any static twiddle factors and such.  Additionally, there are lots of options - forward/reverse, in/out-of-place, int, double, float, etc...  See benchmarks for more info.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT Calculating incorrectly - Swift\r\n                \r\nI am trying to take the fast Fast Fourier Transform. I am basing my calculation off of the Surge. I am having trouble getting correct results. When I take the fft of a 1000 hz sound I get something that looks like this. . When i take the same tone and use python I get something that looks way more correct. The python code looks like:\n\n```\nimport numpy as np\nimport scipy.io.wavfile\nimport numpy.fft\nimport matplotlib.pyplot as plt\n\nFILENAME = 'beep.wav'\n\nfs, data = scipy.io.wavfile.read(FILENAME)\ndata = data[:801]\nspacing = 1 / float(fs)\nfreq = numpy.fft.rfft(data)\nfreq_power = np.abs(freq)\na = 1 / (2 * spacing)\nb = (len(data) + 1) // 2\nfreq_axis = np.linspace(0, a, b)\nplt.plot(freq_axis, freq_power)\nplt.show()\n```\n\n\nThe swift code looks like\n\n```\nimport Accelerate\npublic func sqrt(x: [Float]) -> [Float] {\nvar results = [Float](count: x.count, repeatedValue: 0.0)\nvvsqrtf(&results, x, [Int32(x.count)])\n\nreturn results\n}\n\npublic func fft(input: [Float]) -> [Float] {\nvar real = [Float](input)\nvar imaginary = [Float](count: input.count, repeatedValue: 0.0)\nvar splitComplex = DSPSplitComplex(realp: &real, imagp: &imaginary)\n\nlet length = vDSP_Length(floor(log2(Float(input.count))))\nlet radix = FFTRadix(kFFTRadix2)\nlet weights = vDSP_create_fftsetup(length, radix)\nprintln(weights)\nvDSP_fft_zip(weights, &splitComplex, 1, 8, FFTDirection(FFT_FORWARD))\n\nvar magnitudes = [Float](count: input.count, repeatedValue: 0.0)\nvDSP_zvmags(&splitComplex, 1, &magnitudes, 1, vDSP_Length(input.count))\n\nvar normalizedMagnitudes = [Float](count: input.count, repeatedValue: 0.0)\nvDSP_vsmul(sqrt(magnitudes), 1, [2.0 / Float(input.count)], &normalizedMagnitudes, 1, vDSP_Length(input.count))\nvDSP_destroy_fftsetup(weights)\n\nreturn normalizedMagnitudes\n}\n```\n\n\nTo reiterate. The swift code is the code giving unexpected results. What am I doing wrong?\n    ", "Answer": "\r\nIt looks like you are using Swift Float arrays with the Accelerate framework, but you might instead need to allocate your vectors using ```\nUnsafeMutablePointer<Float>```\n types since the Accelerate framework is an Objective C framework. Here is an example how to do this.\n\n```\npublic func sqrt(x: [Float]) -> [Float] {\n    // convert swift array to C vector\n    var temp = UnsafeMutablePointer<Float>.alloc(x.count)\n    for (var i=0;i<x.count;i++) {\n        temp[i] = x[i];\n    }\n    var count = UnsafeMutablePointer<Int32>.alloc(1)\n    count[0] = Int32(x.count)\n    vvsqrtf(temp, temp, count)\n    // convert C vector to swift array\n    var results = [Float](count: x.count, repeatedValue: 0.0)\n    for (var i=0;i<x.count;i++) {\n        results[i] = temp[i];\n    }\n    // Free memory\n    count.dealloc(1)\n    temp.dealloc(x.count)\n    return results\n}\n```\n\n\nIt will work out better for performance to use the ```\nUnsafeMutablePointer<Float>```\n types throughout your code for your vectors of data rather than converting back and forth in function calls as I did for this example. Also you should save your FFT setup and reuse that as well for better performance.\n\nSince you're using the vDSP FFT you might also like the ```\nvDSP_zvabs```\n API which calculates magnitude in dB from the FFT results. \n\nFinally be sure to read this link on data packing and scaling for the Accelerate framework FFT APIs.\nhttps://developer.apple.com/library/mac/documentation/Performance/Conceptual/vDSP_Programming_Guide/UsingFourierTransforms/UsingFourierTransforms.html\n\nTo improve performance, the vDSP APIs do not output the most obvious scale values (since you will undoubtedly be scaling the data anyway somewhere else) and they pack in some extra data into a few of the FFT points.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "compare multiple signals using FFT in R\r\n                \r\nI want to analyse multiple signals using Fast fourier transform and try to group the ones with similar patterns.\n\nI'd like to know how to approach this problem.\n\nA subset of my data:\n\n```\ndf <- dput(tst1)\nstructure(list(var_1 = c(0.238942, 0.265, 0.190338, 0.245714, \n0.208872, 0.266648, 0.1909, 0.291751, 0.259681, 0.270592), var_2 = c(0.236594, \n0.262115, 0.188282, 0.243209, 0.206064, 0.26483, 0.187436, 0.289571, \n0.256675, 0.268209), var_3 = c(0.234762, 0.260603, 0.188161, \n0.240466, 0.204413, 0.262256, 0.1863, 0.288058, 0.254225, 0.266186\n), var_4 = c(0.232489, 0.258214, 0.186727, 0.238468, 0.201748, \n0.260584, 0.184533, 0.285398, 0.251934, 0.263722), var_5 = c(0.230015, \n0.255756, 0.186592, 0.235875, 0.199746, 0.258097, 0.18314, 0.283392, \n0.249769, 0.262319), var_6 = c(0.227892, 0.253624, 0.186194, \n0.233518, 0.197826, 0.255778, 0.181736, 0.281578, 0.247566, 0.260859\n), var_7 = c(0.225756, 0.251379, 0.185813, 0.231679, 0.195496, \n0.253272, 0.180961, 0.27873, 0.244901, 0.259456), var_8 = c(0.223464, \n0.249673, 0.185515, 0.229863, 0.193899, 0.251128, 0.180393, 0.276851, \n0.243248, 0.257856), var_9 = c(0.221471, 0.24726, 0.184834, 0.227454, \n0.191849, 0.248769, 0.179127, 0.273859, 0.240625, 0.255606), \n    var_10 = c(0.21952, 0.245511, 0.184278, 0.225988, 0.190593, \n    0.246434, 0.178072, 0.271144, 0.238321, 0.253885), var_11 = c(0.218228, \n    0.243789, 0.184485, 0.224337, 0.189168, 0.245093, 0.177002, \n    0.268688, 0.23696, 0.251804), var_12 = c(0.216438, 0.241876, \n    0.184569, 0.222695, 0.187973, 0.243475, 0.175195, 0.266073, \n    0.235168, 0.250305), var_13 = c(0.215116, 0.240005, 0.184283, \n    0.220832, 0.186319, 0.24159, 0.173557, 0.263756, 0.232819, \n    0.248114), var_14 = c(0.213016, 0.237224, 0.18444, 0.21831, \n    0.18518, 0.240112, 0.17209, 0.261131, 0.230609, 0.245875), \n    var_15 = c(0.211184, 0.23517, 0.18475, 0.216627, 0.183275, \n    0.238314, 0.171204, 0.258135, 0.228459, 0.243731), var_16 = c(0.208855, \n    0.232755, 0.184906, 0.215249, 0.181248, 0.236821, 0.169593, \n    0.256136, 0.226637, 0.241915), var_17 = c(0.207139, 0.230857, \n    0.185459, 0.21385, 0.180094, 0.235208, 0.168155, 0.254205, \n    0.22486, 0.240045), var_18 = c(0.205077, 0.228666, 0.185522, \n    0.211764, 0.178778, 0.233662, 0.166491, 0.251451, 0.222678, \n    0.237376), var_19 = c(0.203173, 0.226569, 0.185825, 0.209949, \n    0.176726, 0.231828, 0.165068, 0.248426, 0.220556, 0.235003\n    ), var_20 = c(0.201251, 0.224366, 0.186176, 0.207974, 0.175703, \n    0.230081, 0.163141, 0.246262, 0.218654, 0.232062), var_21 = c(0.199265, \n    0.221885, 0.186458, 0.205793, 0.174502, 0.228247, 0.161569, \n    0.24376, 0.216408, 0.229642), var_22 = c(0.197004, 0.219585, \n    0.186486, 0.203886, 0.173065, 0.226032, 0.160078, 0.241633, \n    0.214141, 0.227404), var_23 = c(0.19512, 0.216987, 0.186782, \n    0.201754, 0.171262, 0.223991, 0.158268, 0.239415, 0.212232, \n    0.225068), var_24 = c(0.193056, 0.21441, 0.186593, 0.199443, \n    0.169317, 0.221896, 0.156727, 0.237254, 0.209865, 0.222927\n    ), var_25 = c(0.190861, 0.211877, 0.186553, 0.19689, 0.168172, \n    0.219797, 0.155611, 0.235068, 0.207387, 0.220559)), row.names = c(22743L, \n6535L, 59032L, 61113L, 16944L, 60773L, 3235L, 19567L, 20560L, \n42516L), class = \"data.frame\")\n```\n\n\nEach row in the data is 1 signal and I'd like to group the signals with same patterns. \n\nFFT on this data:\n\n```\nf <- apply(df, 1, function(x){abs(fft(x))})\n```\n\n\nHow do I go about from here to finding similar patterns? Does removing the peaks and reconstructing the inverse FFT help here?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Use FFT fft() to compute a Riemann sum\r\n                \r\nI would like to calculate the Following Sum by applying Fast Fourier transforms (FFT). I want to compute the following Riemann sum approximation using FFT :\n\n\nHere is the Psy function that I'm using :\n\n```\nPsyfun<-function(u,T,r,q,sigma,lmbda,meanV,v0,rho){\n  j  <- as.complex(1i)\n  a <- lmbda*meanV\n  b <- lmbda\n  d <- sqrt((j*rho*sigma*u-b)**2+(u**2+j*u)*sigma**2)\n  g <- (b-j*rho*sigma*u-d)/(b-j*rho*sigma*u+d)\n  ret <- exp(j*u*(r-q)*T)\n  ret <- ret*exp((a/sigma**2)*((b - rho*j*sigma*u - d)*T - 2.0*log((1-g*exp(-d*T))/(1-g))))\n  return (ret*exp((v0/sigma**2)*(b - rho*j*sigma*u - d)*(1-exp(-d*T))/(1-g*exp(-d*T))))\n}\n```\n\n\nHere are the sample parameters :\n\n```\nr = 0.025 ,q= 0.01, sigma = 0.2, lmbda = 0.5, meanV = 0.5, v0 = 0.5 , rho = 0.3\n```\n\n\nI want to compute the values for  K and T equals to :  \n\nK1=172.77 and T1 = 0.197, K2= 75.63  and T2 = 0.563,  K3 = 269.54  and T3 = 0.2648\n\nI implement the following code to do it: \n\n```\n  N=2^10           # Number of subdivision in [0,a]\n  alpha=2          # alpha \n  delta= 0.25      # delta= a/N  where a is the up value of w (w in [0,a])\n  lambda=(2*pi)/(N*delta)\n  j=seq(1,N,1)\n  k=seq(1,N,1)\n  b=(lambda*N)/2\n  strike= -b+(k-1)*lambda\n  strike= exp(strike)\n  res=c()\n  for (i in 1:N){\n    w=delta*(i-1)      #  w= j*delta but from 1 to N so w=(i-1)*delta\n    w_FC=w-(alpha+1)*1i\n    phi= Psyfun(w_FC,T,r,q,sigma,lmbda,meanV,v0,rho)\n    phi=phi*exp(-r1*(T))\n    phi=phi/(alpha^2+alpha-w^2+1i*(2*alpha+1)*w)\n    phi=phi*delta*exp(1i*w*b)\n    res=rbind(res,phi)\n  }  \n  Result=Re(fft(res))*exp(-alpha*(-b+(k-1)*lambda))/pi\n```\n\n\nI obtain k numbers of values so how to get the one that correspond to K1,K2,K3.\nCan anybody recommend a procedure to implement the computation? Thanks\n\nI have no previous experience in Fast Fourier transforms (FFT) processing, so I appreciate any tips and pointers related to the mathematics / methods / Code in addition to advice on how better to approach this programmatically.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Find frequency and amplitude of a signal [Matlab]\r\n                \r\nmy signal is a vector like this:\n\nI want to find the frequency and amplitude of this signal. Any idea how can I do it using Matlab?\nFFT (Fast Fourier Transform) is giving this result:\n\nRemark: In this case I can find the peaks and extract the frequency according to the time, which is ~13Hz. But can't find the magnitude. In general I have more signals from which the frequency estimation is not as obvious as here.\nThanks!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Unable to generate coefficient matrix in MATLAB\r\n                \r\nI have the following piece of code and I am trying to calculate the coefficient matrix, ```\na_k```\n to solve the linear system to obtain ```\nh[n]```\n, the impulse response. I am using the inverse fast Fourier transform. \n\n```\nN = 9; % period is chosen to be 16\nn = 0:N-1; %vector for x must start at n = 0\nfor k = 1:9\n    y3 = zeros(1,9);\n    y3(k+1) = N/2;\n    y3(N - k + 1) = N/2;  \nend\nx3 = ifft(y3);\n\nfigure;\nsubplot(2,2,1);stem(n,real(x3));xlabel('n'); //line 52\nylabel('real(x3)');axis([0 N-1 -1 1]);\nsubplot(2,2,2);stem(n,imag(x3));xlabel('n');\nylabel('imag(x3)');axis([0 N-1 -1 1]);\nsubplot(2,2,3);stem(n,real(y3)/N);xlabel('k');\nylabel('real(a_k)');axis([0 N-1 -1 1]);\nsubplot(2,2,4);stem(n,imag(y3)/N);xlabel('k');\nylabel('imag(a_k)');axis([0 N-1 -1 1]);\n```\n\n\nHowever, when I run this code, I get the following error: \n\n```\nError using stem (line 43)\nX must be same length as Y.\n\nError in fft_examples (line 52)\nsubplot(2,2,1);stem(n,real(x3));xlabel('n');\n```\n\n\nI'm not sure where I am erring. I know that the matrix of ```\nk```\n is from 1 through 9. Hence, I did a ```\nfor```\n loop. The y values are becoming mismatched.\n    ", "Answer": "\r\n```\nsize(real(x3))  % --> 1 10\nsize(n)         % --> 1 9\n```\n\n\nSo they are not the same size. You are increasing the size of y3 in ```\ny3(k+1) = N/2;```\n \n\nAlso, why would you want to create matrix y3 in every iteration: ```\ny3 = zeros(1,9);```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT in a single C-file [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI was looking for a FFT implementation in C. However, I am not looking for a huge library (like FFTW) but for a easy to use single C-file implementation. Unfortunately I haven't been able to find anything like this. \n\nCan someone recommend a simple implementation?\n    ", "Answer": "\r\nYour best bet is KissFFT - as its name implies it's simple, but it's still quite respectably fast, and a lot more lightweight than FFTW. It's also free, wheras FFTW requires a hefty licence fee if you want to include it in a commercial product.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier Result on Time Series explained python\r\n                \r\nI have passed my time series data,which is essentially measurements from a sensor about pressure, through a Fourier transformation, similar to what is described in https://towardsdatascience.com/fourier-transform-for-time-series-292eb887b101.\nThe file used can be found here:\nhttps://docs.google.com/spreadsheets/d/1MLETSU5Trl5gLGO6pv32rxBsR8xZNkbK/edit?usp=sharing&ouid=110574180158524908052&rtpof=true&sd=true\nThe code related is this :\n```\nimport pandas as pd\nimport numpy as np\nfile='test.xlsx'\ndf=pd.read_excel(file,header=0)\n#df=pd.read_csv(file,header=0)\ndf.head()\ndf.tail()\n# drop ID\ndf=df[['JSON_TIMESTAMP','ADH_DEL_CURTAIN_DELIVERY~ADH_DEL_AVERAGE_ADH_WEIGHT_FB','ADH_DEL_CURTAIN_DELIVERY~ADH_DEL_ADH_COATWEIGHT_SP']]\n# extract year month \ndf[\"year\"] = df[\"JSON_TIMESTAMP\"].str[:4]\ndf[\"month\"] = df[\"JSON_TIMESTAMP\"].str[5:7]\ndf[\"day\"] = df[\"JSON_TIMESTAMP\"].str[8:10]\ndf= df.sort_values( ['year', 'month','day'],\n          ascending = [True, True,True])\ndf['JSON_TIMESTAMP'] = df['JSON_TIMESTAMP'].astype('datetime64[ns]')\ndf.sort_values(by='JSON_TIMESTAMP', ascending=True)\ndf1=df.copy()\ndf1 = df1.set_index('JSON_TIMESTAMP')\ndf1 = df1[[\"ADH_DEL_CURTAIN_DELIVERY~ADH_DEL_AVERAGE_ADH_WEIGHT_FB\"]]\nimport matplotlib.pyplot as plt\n#plt.figure(figsize=(15,7))\nplt.rcParams[\"figure.figsize\"] = (25,8)\ndf1.plot()\n#df.plot(style='k. ')\nplt.show()\ndf1.hist(bins=20)\n    from scipy.fft import rfft,rfftfreq\n\n## https://towardsdatascience.com/fourier-transform-for-time-series-292eb887b101\n\n# convert into x and y\nx = list(range(len(df1.index)))\ny = df1['ADH_DEL_CURTAIN_DELIVERY~ADH_DEL_AVERAGE_ADH_WEIGHT_FB']\n\n# apply fast fourier transform and take absolute values\nf=abs(np.fft.fft(df1))\n\n# get the list of frequencies\nnum=np.size(x)\nfreq = [i / num for i in list(range(num))]\n\n# get the list of spectrums\nspectrum=f.real*f.real+f.imag*f.imag\nnspectrum=spectrum/spectrum[0]\n\n# plot nspectrum per frequency, with a semilog scale on nspectrum\nplt.semilogy(freq,nspectrum)\nnspectrum\ntype(freq)\nfreq= np.array(freq)\nfreq\ntype(nspectrum)\nnspectrum = nspectrum.flatten()\n# improve the plot by adding periods in number of days rather than  frequency\nimport pandas as pd\nresults = pd.DataFrame({'freq': freq, 'nspectrum': nspectrum})\nresults['period'] = results['freq'] / (1/365)\nplt.semilogy(results['period'], results['nspectrum'])\n# improve the plot by convertint the data into grouped per day  to avoid peaks\nresults['period_round'] = results['period'].round()\ngrouped_day = results.groupby('period_round')['nspectrum'].sum()\nplt.semilogy(grouped_day.index, grouped_day)\n#plt.xticks([1, 13, 26, 39, 52])\n```\n\nMy end result is this :\nResult of Fourier Trasformation for Data\nMy question is, what does this eventually show for our data, and intuitively what does the spike at the last section mean?What can I do with such result?\nThanks in advance all!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Cropping image in matlab\r\n                \r\nI need to do the following for an image in the matlab:\n\n\nLoad the image.\ncompute FFT ( Fast Fourier Transform ) of the image.\nshift frequency components to the center.\ncrop the image like follow ( if the image res. is 1000x1000 , the needed part of the image is like the following Coordinates: 100,100,800,800. which is a smaller image. (The idea of applying filter to remove high frequencies).\ninverse shift.\ninverse fourier transform.\n\n\n.\n.\n.\n\nMy code look like this:\n\n```\nI = imread('2.jpg'); %loading\n\nID = im2double(I);\nFID = fft2(ID); %FFT\nF = fftshift(FID); %shifting\n\nF = imcrop(F,[100, 100, 800, 800]);\n\nFID = ifftshift(F); %inverse of shifting\nIFID = ifft2(FID); %inverse of FFT\n\nI8 = im2uint8(IFID);\n```\n\n\nThe problem is when i want to Crop the image, imcrop function couldn't crop an image of type \"complex double\" , as i think ..\n\nError:\n\n\n  Error using imcrop>checkCData (line 410)\n  Invalid input image.\n  \n  Error in imcrop>parseInputs (line 256)\n              checkCData(a);\n  \n  Error in imcrop (line 93)\n  [x,y,a,cm,spatial_rect,h_image,placement_cancelled] = parseInputs(varargin{:});\n\n\nِAny help ? .. also are there another function for cropping?\n    ", "Answer": "\r\nCropping a real-valued decomposition of the image (either the magnitude and phase, or the real and imaginary part) would avoid the reported error from ```\nimcrop```\n.\n\nHowever, since you indicated that your intention is to filter high frequency components, you should note that cropping will also have the side effect of reducing the resulting time-domain image.\n\nTo preserve the image size, you may consider zeroing out those frequency bins instead (short of a using a more elaborate filter design). You can achieve this by multiplying the frequency domain data with a matrix acting as a mask over the frequency component you want to keep. \n\nThe code to achieve this would look like:\n\n```\n% create a mask to zero-out high frequency components\nH = zeros(size(I));\nhalfwidth = 400;\nxmin = size(H,2)/2+1 - halfwidth;\nxmax = size(H,2)/2+1 + halfwidth;\nymin = size(H,1)/2+1 - halfwidth;\nymax = size(H,1)/2+1 + halfwidth;\nH(xmin:xmax, ymin:ymax, :) = 1;\n\n% apply mask\nF = F.*H;\n```\n\n\nWhich would give you the following overall code:\n\n```\nI = imread('2.jpg'); %loading\n\nID = im2double(I);\nFID = fft2(ID); %FFT\nF = fftshift(FID); %shifting\n\n% create a mask to zero-out high frequency components\nH = zeros(size(I));\nhalfwidth = 400;\nxmin = size(H,2)/2+1 - halfwidth;\nxmax = size(H,2)/2+1 + halfwidth;\nymin = size(H,1)/2+1 - halfwidth;\nymax = size(H,1)/2+1 + halfwidth;\nH(xmin:xmax, ymin:ymax, :) = 1;\n\n% apply mask\nF = F.*H;\n\nFID = ifftshift(F); %inverse of shifting\nIFID = real(ifft2(FID)); %inverse of FFT\n\nI8 = im2uint8(IFID);\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why does this white noise spectrum have a peak for freq=0?\r\n                \r\nFrom theory we know that the spectrum of a white noise is constant. S(w)=S0\nI have written code where I define a white noise though numpy random. Then I apply the Fast Fourier Transform to it. I would expect some sort of constant function, but I get a peak for w=0. When I apply the fft to a random input, why do I get a peak for freq=0?\nHere is my code:\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy\nfrom scipy.fft import fft, fftfreq, ifft\nfrom scipy import  signal\n#Define the time limits to create the array\ntin=0\ntfin=1\n#the code works better with power of 2 (64;128;256;512;etc.)\nNt=127\n#time span\nT=tfin-tin\n#time interval\ndt=T/Nt\n#array of time\nt=np.arange(tin,tfin, dt)\n#noise\nnoise=0.3*np.random.rand(Nt)\n#array of the function to be transformed\nx=noise\n#creating the spectrum ordinate array\ny=fft(x)\n#Obtaining the frequency array correlated to the spectrum\nfreq=fftfreq(Nt, d=dt)\n#Creating the time history from the spectrum\nxinv=ifft(y)\n#Plotting the spectrum X(w)\n#I only want the positive freq values:\nfreq=freq[:Nt//2]\ny=y[0:Nt//2]\n#I want freq in rad/s\nfreq=freq*2*np.pi\n#I want the absolute value of the spectrum\ny=abs(y)\nplt.plot(freq,y , label='Spectrum')\nplt.legend(loc='upper left')\nplt.xlabel('w[rad/s]')\nplt.ylabel('X(w)')\nplt.title('')\nplt.grid()\nplt.show()\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "C# with Xamarin Queue.Any () and Queue.Count != 0 does not prevent exception\r\n                \r\nI am writing a code which reads audio data and send the data to another thread to process fast Fourier transformation. I am using C#'s queue.\n\nBecause the queue can be empty, I wrote ```\nif (queue.Count != 0)```\n to prevent any problems. However, I had an exception saying queue was empty at ```\nqueue.Dequeue ()```\n. I tried ```\nif (queue.Any ())```\n, but there was no success.\n\nCode:\n\n```\nwhile (recording) {\n    if (queue.Any ()) {\n        AudioData data = new AudioData (queue.Dequeue ()); // Exception thrown here. It said it was empty.\n\n        // ...\n        // Display code.\n        // ...\n    }\n    else\n        Thread.Sleep (1);\n}\n```\n\n    ", "Answer": "\r\nIf you are accessing from multiple threads, which is a fair assumption as you shouldn't be getting an exception otherwise.. try using the ConcurrentQueue.\n\nMore info:\nhttps://msdn.microsoft.com/en-us/library/dd997305(v=vs.110).aspx\nhttps://msdn.microsoft.com/en-us/library/dd267265(v=vs.110).aspx\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "L-BFGS solver: how to include uncertainty when reconstructing complex valued function?\r\n                \r\nI am using  Limited-memory Broyden, Fletcher, Goldfarb, and Shanno (L-BFGS) solver from SciPy to reconstruct a complex valued function, namely the Fast Fourier Transformation of some spectrum. The loss function can be MAE (mean average error) or MSE (mean square error), for real and imaginary parts of the Fourier Spectrum. I would like to compute also the uncertainty for the reconstruction. I would appreciate any comment on how to include the uncertainty in the loss function ?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to remove repititve pattern from an image using FFT\r\n                \r\n\nI have image of skin colour with repetitive pattern (Horizontal White Lines) generated by a scanner that uses a line of sensors to perceive the photo.\n\n\n\nMy Question is how to denoise the image effectively using FFT without affecting the quality of the image much, somebody told me that I have to suppress the lines that appears in the magnitude spectrum manually, but I didn't know how to do that, can you please tell me how to do it?\n\nMy approach is to use Fast Fourier Transform(FFT) to denoise the image channel by channel.\n\nI have tried HPF, and LPF in Fourier domain, but the results were not good as you can see:\n\n\n\nMy Code:\n```\nfrom skimage.io import imread, imsave\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\nimg = imread('skin.jpg')\n\nR = img[...,2]\nG = img[...,1]\nB = img[...,0]\n\nf1 = np.fft.fft2(R)\nfshift1 = np.fft.fftshift(f1)\nphase_spectrumR = np.angle(fshift1)\nmagnitude_spectrumR = 20*np.log(np.abs(fshift1))\n\nf2 = np.fft.fft2(G)\nfshift2 = np.fft.fftshift(f2)\nphase_spectrumG = np.angle(fshift2)\nmagnitude_spectrumG = 20*np.log(np.abs(fshift2))\n\nf3 = np.fft.fft2(B)\nfshift3 = np.fft.fftshift(f3)\nphase_spectrumB = np.angle(fshift3)\nmagnitude_spectrumB = 20*np.log(np.abs(fshift2))\n\n#===============================\n# LPF # HPF\nmagR = np.zeros_like(R) #  = fshift1 # \nmagR[magR.shape[0]//4:3*magR.shape[0]//4,\n magR.shape[1]//4:3*magR.shape[1]//4] = np.abs(fshift1[magR.shape[0]//4:3*magR.shape[0]//4,\n  magR.shape[1]//4:3*magR.shape[1]//4]) # =0 #\nresR = np.abs(np.fft.ifft2(np.fft.ifftshift(magR)))\nresR = R - resR\n#===============================\nmagnitude_spectrumR\nplt.subplot(221)\nplt.imshow(R, cmap='gray')\nplt.title('Original')\n\nplt.subplot(222)\nplt.imshow(magnitude_spectrumR, cmap='gray')\nplt.title('Magnitude Spectrum')\n\nplt.subplot(223)\nplt.imshow(phase_spectrumR, cmap='gray')\nplt.title('Phase Spectrum')\n\nplt.subplot(224)\nplt.imshow(resR, cmap='gray')\nplt.title('Processed')\n\nplt.show()\n```\n\n    ", "Answer": "\r\nHere is a simple and effective linear filtering strategy to remove the horizontal line artifact:\nOutline:\n\nEstimate the frequency of the distortion by looking for a peak in the image's power spectrum in the vertical dimension. The function scipy.signal.welch is useful for this.\n\nDesign two filters: a highpass filter with cutoff just below the distortion frequency and a lowpass filter with cutoff near DC. We'll apply the highpass filter vertically and the lowpass filter horizontally to try to isolate the distortion. We'll use scipy.signal.firwin to design these filters, though there are many ways this could be done.\n\nCompute the restored image as \"image − (hpf ⊗ lpf) ∗ image\".\n\n\nCode:\n```\n# Copyright 2021 Google LLC.\n# SPDX-License-Identifier: Apache-2.0\n\nimport numpy as np\nfrom scipy.ndimage import convolve1d\nfrom scipy.signal import firwin, welch\n\ndef remove_lines(image, distortion_freq=None, num_taps=65, eps=0.025):\n  \"\"\"Removes horizontal line artifacts from scanned image.\n  Args:\n    image: 2D or 3D array.\n    distortion_freq: Float, distortion frequency in cycles/pixel, or\n      `None` to estimate from spectrum.\n    num_taps: Integer, number of filter taps to use in each dimension.\n    eps: Small positive param to adjust filters cutoffs (cycles/pixel).\n  Returns:\n    Denoised image.\n  \"\"\"\n  image = np.asarray(image, float)\n  if distortion_freq is None:\n    distortion_freq = estimate_distortion_freq(image)\n\n  hpf = firwin(num_taps, distortion_freq - eps,\n               pass_zero='highpass', fs=1)\n  lpf = firwin(num_taps, eps, pass_zero='lowpass', fs=1)\n  return image - convolve1d(convolve1d(image, hpf, axis=0), lpf, axis=1)\n\ndef estimate_distortion_freq(image, min_frequency=1/25):\n  \"\"\"Estimates distortion frequency as spectral peak in vertical dim.\"\"\"\n  f, pxx = welch(np.reshape(image, (len(image), -1), 'C').sum(axis=1))\n  pxx[f < min_frequency] = 0.0\n  return f[pxx.argmax()]\n```\n\nExamples:\nOn the portrait image, ```\nestimate_distortion_freq```\n estimates that the frequency of the distortion is 0.1094 cycles/pixel (period of 9.14 pixels). The transfer function of the filtering \"image − (hpf ⊗ lpf) ∗ image\" looks like this:\n\nHere is the filtered output from ```\nremove_lines```\n:\n\nOn the skin image, ```\nestimate_distortion_freq```\n estimates that the frequency of the distortion is 0.08333 cycles/pixel (period of 12.0 pixels). Filtered output from ```\nremove_lines```\n:\n\nThe distortion is mostly removed on both examples. It isn't perfect: on the portrait image, a couple ripples are still visible near the top and bottom borders, a typical defect when using large filters or Fourier methods. Still, it's a good improvement over the original images.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to store noise as a variable from the fourier transformation in python\r\n                \r\nI am trying to perform Fourier transformation in python. And I would like to know, how to store the ```\nnoise```\n obtained from ```\nFourier transformation```\n as a ```\nvariable```\n?\nPython code:\n```\nimport numpy as np\n\n# Create a simple signal with two frequencies\ndt = 0.001\nt = np.arange(0,1,dt)\nf = np.sin(2*np.pi*50*t) + np.sin(2*np.pi*120*t) # Sum of 2 frequencies\nf_clean = f\nnoise = 2.5*np.random.randn(len(t))\nf = f + noise              # Add some noise\n\n## Compute the Fast Fourier Transform (FFT)\n\nn = len(t)\nfhat = np.fft.fft(f,n)                     # Compute the FFT\nPSD = fhat * np.conj(fhat) / n             # Power spectrum (power per freq)\nfreq = (1/(dt*n)) * np.arange(n)           # Create x-axis of frequencies in Hz\nL = np.arange(1,np.floor(n/2),dtype='int') # Only plot the first half of freqs\n\n## Use the PSD to filter out noise\nindices = PSD > 100       # Find all freqs with large power\nPSDclean = PSD * indices  # Zero out all others\nfhat = indices * fhat     # Zero out small Fourier coeffs. in Y\nffilt = np.fft.ifft(fhat) # Inverse FFT for filtered time signal\n```\n\nI have tried using the following lines of code to store the noise values, but not sure whether it is right syntax or approach to perform this task.\n```\n## To store the noise using the PSD \n\nlow_indices = PSD < 100   # Find all freqs with small power\nPSDnoise = PSD * low_indices  # zero out larger freqs\nfhat_noise = low_indices * fhat\n\n```\n\nIs there any better approach to store these values?\n    ", "Answer": "\r\nIf you do\n```\nPSDnoise = PSD * low_indices\n```\n\nYou will have ```\n0```\n values where there was a ```\nFalse```\n in ```\nlow_indices```\n.\nIf you just want to keep the values of ```\nPSD```\n at indices where you're lower than your threshold, you can use array indexing, like so:\n```\nPSDnoise = PSD[low_indices]\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How can I visualize neurosity brainwave api data in react js\r\n                \r\nHow to visualize the brainwave API data in d3.js and react.js.\nHere is the brainwave API:\n```\nconst mind = new Notion();\nmind.brainwaves(\"psd\").subscribe((brainwaves) => {\n  console.log(brainwaves);\n});\n```\n\nThe code above will output new epochs 4 times a second. Every frequency label (e.g. alpha) contains the computed FFT (Fast Fourier transform) value per channel (see the psd property), as well as the frequency ranges (see the freqs property).\nHere's an example of 1 event that I want to visualize in d3 and react js:\n```\n{\n  label: 'psd',\n  freqs: [\n      0,   2,   4,   6,   8,  10,  12,  14,  16,  18,  20,  22,\n     24,  26,  28,  30,  32,  34,  36,  38,  40,  42,  44,  46,\n     48,  50,  52,  54,  56,  58,  60,  62,  64,  66,  68,  70,\n     72,  74,  76,  78,  80,  82,  84,  86,  88,  90,  92,  94,\n     96,  98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118,\n    120, 122, 124, 126\n  ],\n  info: {\n    notchFrequency: '60Hz',\n    samplingRate: 256,\n    startTime: 1628197298732\n  },\n  psd: [\n    [\n       98.63572869924877,  278.0499119981597,  396.9075453246308,\n      330.93307599602673,  154.4437300666471,   127.381718447909,\n      156.28589064508202,  90.27952532968459,  74.02596881179568,\n      102.68745491461037,  77.40464372151173,  65.97947493071318,\n       93.61333998578448,  70.03755439407374, 47.965913961348285,\n       72.11457749610696,  60.14793608854482,  36.43407809513316,\n        52.5321191045999, 45.400500672083176, 24.168757651016627,\n        37.1839936941784, 35.105296424441036, 14.991272333196237,\n      17.013079679743214, 22.931615422127962,   9.64319909169338,\n        6.95610789706202,  10.48806813349181,   8.77101666889275,\n        8.08687117576467,   7.88454615426007,   7.00857990702008,\n       9.129752553805993,  7.500414008219254, 6.4966183674128635,\n       7.833399187762861,  7.283708613586358,  5.616493707372124,\n       7.336663052350952,  6.859592851990316,  6.153804860755752,\n       6.618696201331677,  6.837180878389385, 5.7838083130648945,\n       6.562155335152424,  6.093398492507891,  6.073406841367065,\n      5.9593899491763205,   6.14611107916922,  5.674535238756583,\n      6.0774035077156645,  5.656938723201682,  5.892346415487732,\n        5.61605742554047,  5.842031463718972,  5.514410378848478,\n       5.803658958523979,   5.47172273287992,  5.745739449800702,\n       5.452574435173335,  5.724439426371041, 5.4273919360609035,\n       5.707772456903569\n    ],\n    [\n       705.0449351206108, 1355.4773207863375, 1795.4768676020658,\n      1480.8269991044856,  879.7073135412625,  734.4677613113015,\n       691.6145778964477,  482.9726329188916,  463.9458627254311,\n       448.9185196251005,  325.3989179173811,  356.7357077059943,\n      366.94089924861487, 288.75232488327777,  304.2605284381872,\n       301.8930577524112,  237.4042509842181,   248.189270828571,\n      244.01379638689255,  177.6237336667693, 172.43627544841166,\n      176.69895192953885, 125.52722189861495, 105.15448954029884,\n      106.56146701054848, 63.477588704077554, 33.251603187541896,\n       42.84498288204394, 23.928294234593277,  9.767390485089537,\n       15.03794181419898, 13.965161093202841, 20.844294981525614,\n      12.007423569211078, 11.126393885153014, 20.104729878667776,\n      12.319226156469027, 10.486815016962693, 17.143209506256614,\n      11.132954923524995,  10.62728760663002, 14.463591856614492,\n      10.925935011739528, 10.576245202399233, 12.869498809209984,\n      10.551373735436435,  10.90154409382562, 11.496161902596342,\n       10.59771747532043, 10.626533456022605, 10.982565808529692,\n      10.292226858572462, 10.587506870484761, 10.420838952336604,\n       10.33846013622055, 10.228524593265222, 10.333151489515492,\n      10.081149399888313,  10.23400481786508, 10.046416371678554,\n       10.14064797386651,  9.979626942208188, 10.115418833026341,\n       9.962197147976129\n    ],\n    [\n       929.0377610383296, 1793.6811181430987, 2377.6119679334947,\n      1958.9102655269323, 1162.3055283149445,  979.7382233236812,\n        921.065883147485,  640.2289218688652,  619.3532710184182,\n       597.9752360209405, 433.84218492741303, 480.63827859906377,\n       494.8759497888118,  388.5592867189369, 408.72806358233913,\n       403.8696475504568,  318.0820897599802,  335.6971387951459,\n       330.1749076377176,  240.2816149573954,  234.1828700249589,\n       238.8172342465352, 168.40453177012395, 141.41297208524767,\n       143.3763643586936,  84.85781325822384, 44.693260335642535,\n       57.99822015732011,  32.12541610045182, 13.475265334606835,\n      20.599681672533375,  19.01837044906831, 28.246044041267428,\n      16.189180127175323,  15.41587209212851,  27.05517471975363,\n      16.903913745426895,  14.33546383874818, 23.026090510272617,\n       14.87036823280212,   14.6068129622348, 19.471383549994453,\n       14.96633838574153, 14.387933483886725, 17.466586501671532,\n      14.355984995364704, 14.919336874633427, 15.536030663642576,\n      14.543171342633388, 14.399423945911408,  15.00275665739408,\n      13.982397994287624, 14.474361692225106, 14.126311107434065,\n      14.160828645624179,  13.86227555141294, 14.139642435285486,\n      13.674442534649062, 14.000882290360456, 13.623523705584073,\n      13.881719450096554, 13.533315732597867,  13.84382520692153,\n      13.508775392377734\n    ],\n    [\n       461.1411944745596,   865.879891899699, 1150.3297939965412,\n       967.6717977233337,  599.5067484775997,  487.7449557189379,\n       449.7148527252277, 324.75340665195546,  307.3960653823736,\n      289.99356448521917,  218.9307327550319,   241.757776766985,\n      249.28709256762335, 206.95217758165205,  213.8552238566172,\n      208.04287443336904, 172.16085191285578,  177.8042520513104,\n      170.76433578042244,  131.2290615556113, 127.75140879293434,\n       125.8563352501824,  94.44550500099892,  81.32600662751962,\n       76.33377477822643,  47.53219019300205, 29.403234515228505,\n      29.734512582314988,  14.48430634759893,  4.338569856695335,\n       7.956256668786119,  7.925904164095972, 12.763456529014546,\n       5.823156703304557,  7.213304914646235,  12.53665043042392,\n       6.064277734596193, 6.0142267398677225, 10.591216540020291,\n       5.491335175417487,  5.995538415704912,   8.41366666249266,\n       5.354337464315892,  5.684078918046329,  7.289586947844527,\n       5.258040775750918,  5.927892633808341,  6.209024439918837,\n      5.5308778688068525,  5.658218846438647,  5.937393602233365,\n       5.337787715362042,  5.723456582324143,  5.491309810378187,\n       5.517788579034077, 5.3995359451843115,  5.544753793342432,\n       5.291402564159946,  5.499716204904763,  5.281561955171903,\n      5.4342620388212115,  5.243854533655554,  5.426831995465968,\n        5.23668469315059\n    ],\n    [\n      485.28953220351815,  913.8215446531855, 1212.6893063853145,\n      1017.6653954348992,  629.0590135927589,  513.8401411331691,\n      473.94607162953474,  340.7794194629709,  323.4068209463424,\n       304.6140613386581,  227.9530765749002, 253.44275369319936,\n      261.96382482250846, 215.95821471824453,  223.2060790303756,\n       217.5887331092368, 180.05264499052626,  186.6722683242584,\n      178.86415942933493, 135.75616983861607,  132.7145908145038,\n       131.7205674261096,  98.13621951582651,  84.22587059556682,\n       79.69348482329639,  49.27415323250583, 29.885948066276374,\n      31.018207012950032, 15.464201551787149,  4.696597650070098,\n       8.680077668220271,  8.409519490488169, 13.587393841532371,\n       6.264695355862866,  7.572139679407593,  13.17605643990251,\n       6.652754348269858, 6.3465028991975325, 11.306345734652368,\n       5.926439990819285,  6.470051702062516,  8.904949649675096,\n        5.90150761172456,  6.060485555618185,  7.854198979433359,\n       5.663406547398727, 6.4306283909466435,  6.623721018560318,\n       6.041438452881903, 6.0442294631002795,  6.444444318919457,\n       5.721040377425073,  6.213246144964029, 5.8753004744243755,\n       6.002696003640614,  5.774903831465746,  6.026353504659674,\n       5.663944879598529,  5.975725903093066,  5.652394044025673,\n       5.907643067149823,  5.612177778683849,  5.898257253854689,\n       5.604260960707902\n    ],\n    [\n       703.9620591951088, 1348.1617601998341,  1787.817378338989,\n      1480.9682977349662,  887.8732586924484,  741.7489045127593,\n       696.4862482257432, 486.69267953812624, 464.30488178918847,\n      448.10745320129496,  329.6131727268781,  364.1234842222161,\n      375.17667115955084, 296.30580382389024,  307.6916385785675,\n       303.4585158601969,  241.4840430193035,  253.3373457325428,\n      248.14875370587004,  181.8456760420915, 176.16078095306457,\n      178.58969714768043,  126.8938114163353,  106.7131960446341,\n      106.86715498126117, 63.565099293832944,  33.94124074989405,\n       42.78261882478681, 23.418093057211088,  9.598376452708248,\n        14.8564635663729,  13.73158527388318, 20.632309203759725,\n      11.571312623082235,  11.16199944105178,  19.71697966916169,\n      12.151289348370563,  10.27332116826051,  16.93453042721219,\n      10.734196078665759, 10.578983816474802,  14.17031151713728,\n      10.741999390916682, 10.370828224990875, 12.669038407738478,\n      10.290437631963869, 10.794986602960588, 11.204752776686476,\n      10.481500894235385, 10.373479646590457, 10.845762801813153,\n       10.04623630410688, 10.466118545780976,  10.16324823810254,\n      10.225788013632457,  9.975974411529377,  10.21577779934349,\n       9.834755780463283, 10.117741157508208,  9.799067226573825,\n      10.029038431063377,  9.733625015451048, 10.002552468346979,\n        9.71630020598175\n    ],\n    [\n       753.3573854351718, 1451.3463711535637, 1925.4394750722938,\n      1592.2479396735228,  950.1320711729846,  793.4163539564408,\n        744.990261771651,  519.4611344925438,  498.6282329256233,\n       480.4651411728872,  349.9224396629356, 388.08464608248545,\n      400.41433150212987, 314.28699618071386,  328.3871848882801,\n      325.21671199729667, 257.08898576447365,  270.0756790958063,\n      265.56055695000117, 193.58422699465976,  187.3975181698473,\n       190.5723885919431,  134.7850068920377, 113.55417235960783,\n      114.65352872167782,  67.97249319078067,  36.07066166066659,\n      46.193455592634194, 25.446519462818365, 10.645647869461468,\n       16.33292205396577, 15.082694752225358, 22.479081487850554,\n      12.660457753439347, 12.331655605615103, 21.469122245638992,\n      13.259611882976637, 11.366093905761021,   18.4614508154199,\n      11.778790555694387, 11.710458297806564, 15.485077358432786,\n      11.805213571500564, 11.446226210170733, 13.887884653568616,\n      11.334007371207884, 11.881804314077982,  12.30654501069072,\n      11.528873716721828, 11.419099102496702, 11.910897138255397,\n      11.059631088502826, 11.505557872713792, 11.178885987141047,\n      11.242816922347224,  10.97697117415906, 11.227884136208706,\n      10.822693801769324, 11.121177549665633, 10.782078947654583,\n      11.024368739435461, 10.711151846144949, 10.995151378799578,\n      10.691866595209362\n    ],\n    [\n       367.4136193009799,  826.7329948628463, 1118.3539023221265,\n        890.162220791093,  436.1682590608995,  391.4382314784865,\n      417.04217210936963, 251.56740893464422,  238.5284921292077,\n       267.6000138141995,   168.617128049186, 165.98870799455165,\n      200.56943140232212, 129.37112302840023, 126.00839013852573,\n      162.39587433692205, 109.20332945126022,  87.00867663058928,\n      117.95711115144483,  83.29961985396704,  58.57022651921219,\n       86.68284556964056,  63.23057486573713, 22.615043247176825,\n       45.79353231282386,  39.94573246684187,  6.411920387449734,\n      21.964845928081306, 21.959370088243116, 16.277025835788837,\n      16.547064843486048, 15.715335138181468, 16.607457789253704,\n      17.537478155658583, 13.336615276197591, 15.835823046176726,\n      15.461292461652397, 13.730332854951738,  13.27865408978899,\n      14.709605078820157,   12.9045807988706, 13.692853045756497,\n      13.258453124525246, 13.287331440282053, 12.481768554519784,\n      13.223425784019863, 12.187280042833416, 12.738723198131671,\n      12.048047848217715,  12.49122466572343, 11.744286244430379,\n      12.342663893673903, 11.552471648965968, 12.117055516659004,\n      11.432033986591367, 11.965037193629023, 11.288502743059457,\n      11.863912386218576, 11.190384199321217, 11.771734261131785,\n      11.131137815008097,  11.71660417394918,  11.08761147894627,\n      11.686948260719255\n    ]\n  ]\n}\n```\n\nPlease Help me in this regard...\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Setting elements of an array equal to zero\r\n                \r\nlet's say I have:\n\n```\nc = array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], float)\n```\n\n\nthen I take a fast fourier transform:\n\n```\nr = rfft(c)\n```\n\n\nwhich produces the following complex array:\n\n```\nr = [ 21.+0.j ,  -3.+5.19615242j , -3.+1.73205081j , -3.+0.j ]\n```\n\n\nthe number of elements in the new array is  1/2*N + 1.\nI'm trying to tell python to change the values of SPECIFIC elements in the new array. I want to tell python to keep the FIRST 50% of the elements and to set the others equal to zero, so instead the result would look like \n\n```\nr =     r = [ 21.+0.j ,  -3.+5.19615242j , 0 , 0 ]\n```\n\n\nhow would I go about this?\n    ", "Answer": "\r\nrfft return a numpy array which helps easy manipulation of the array.\n\n```\nc = [1,2,3,4,5,6]\nr = rfft(c)\nr[r.shape[0]/2:] = 0\nr\n>> array([21.+0.j, -3.+5.1961j, 0.+0.j , 0.+0.j])\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Segfault (Core dumped)\r\n                \r\nI am fairly new to c++. For my project I tried to write a class for fast fourier transform based on the ```\nFFTW3```\n library in Ubuntu 17.04. my code is :\n\nmy *.hpp file\n\n```\n#include <iostream>\n#include <cmath>\n#include \"fftw3.h\"\n#include <complex>\n#ifndef FG_HPP\n#define FG_HPP\n\nclass myfft\n  {\n    public:\n    int n;\n    fftw_complex *x, *y;\n    fftw_plan p;\n    void setvalue() ;\n    void fftforward();\n    void fftbackward();\n    void mfree();\n    myfft(int );\n    ~myfft();\n  };\n\n #endif\n```\n\n\nmy *.cpp file:\n\n```\n#include \"fg.hpp\"\nusing namespace std;\n\n//Constructure\nmyfft::myfft(int a){\nn = a;\nx = new fftw_complex [n]; // <= allocate array\ny = new fftw_complex [n];\n\nfor (int i = 0; i<n; i++) {\n    x[i][0] = i+1;\n    x[i][1] = i+i;\n\n    //y[i][0] = i+1;\n    //y[i][1] = i+i;\n    }\n }\n\n //---------------------------------------------------   \n//setvalue\nvoid myfft::setvalue(){\n\n for (int i = 0; i<n; i++) {\n      cout<<\"Please enter real  \"<<i+1<<endl;\n      cin>> x[i][0];\n      cout<<\"Please enter image  \"<<i+1<<endl;\n      cin>> x[i][1];\n   }\n}\n\n//---------------------------------------------------   \n// forward mapping\nvoid myfft::fftforward()\n{\n    p=fftw_plan_dft_2d(n, n, x, y, FFTW_FORWARD, FFTW_ESTIMATE);\n    fftw_execute(p);\n}\n\n//-----------------------------------------------------------\n// backward mapping\nvoid myfft::fftbackward()\n{\n    p=fftw_plan_dft_2d(n, n, x, y, FFTW_BACKWARD, FFTW_ESTIMATE);\n    fftw_execute(p);\n}\n\n//-----------------------------------------------------------\n// Destructor and clean up\nmyfft::~myfft(){\n  if (x) {delete[] x;}\n  if (y) {delete[] y;}\n}\n\nvoid myfft::mfree(){fftw_destroy_plan(p); fftw_cleanup();}\n\n\n //-----------------------------------------------------------\n // Main Program\nint main(int argc, char** argv) \n{\nmyfft* g;\ng = new myfft(25);       // enter number of array as argument\n\nif (!g) {\n   cout << \"Not enough memory available or error in allocation.\\n\";\n   return(-1);\n}\n\ng->setvalue();\ng->fftforward();\ng->mfree();\n\nfor(int i=0; i<5; i++){\n    cout << g->x[i][0] \n         <<\"  \"\n         << g->x[i][1]\n         << endl;\n}\nfor(int i=0; i<5; i++){\n    cout << g->y[i][0] \n         << \"   \" \n         << g->y[i][1]\n         << endl;\n}\n\nreturn 0;\n}\n```\n\n\nWhen I tried to compile the code I faced the issue of \"```\nsegfault(core dumped)```\n\". This problem completely confused me and I can't understand which part of program produced the error .Can anybody tell me how I can fix it? Any help would be highly appreciated.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Complexity of multiplying two polynomials with different degree\r\n                \r\nI am aware that we can use the Fast Fourier Transform to multiply two polynomials of degree n in O(n log n) time. This is a big savings from the brute force approach in O(n^2) time. Is it possible to generalize this result to two polynomials of different degree? \n\nClearly, it can be done in O(n log n) where n is the larger number, but I'm looking for an answer that depends on both n and m. \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to process a wav file with an AnalyzerNode in Typescript?\r\n                \r\nI'm trying to calculate the Fast Fourier transform of a wav file in Typescript.\nI was thinking about using a dedicated npm package for this, like fft.js, but then I noticed that the standard AnalyzerNode has a built-in FFT feature. However, I've only seen AnalyzerNode used to process real-time audio streams.\nHow would you send it data loaded from a generic wav file, either loaded from the filesystem or from any other source (e.g. wav-decoder), and not the microphone?\n    ", "Answer": "\r\nFirst, note that ```\nAnalyserNode```\n only gives you the magnitude of the FFT; the phase part is not included.  However, if that works for you, then you can use an ```\nOfflineAudioContext```\n and ```\nsuspend(time)```\n to get the FFT (magnitude).  Something like:\n```\n// Let f be the file that has the wav file.\n// c is used only so we can run decodeAudioData.  There are other ways to \n// do this.\nlet c = new AudioContext();\nlet b = await fetch(f)\n  .then(response => response.arrayBuffer())\n  .then(buffer => c.decodeAudioData(buffer));\n\nlet oac = new OfflineAudioContext({\n  numberOfChannels: b.numberOfChannels,\n  length: b.length,\n  sampleRate: b.sampleRate});\n\nlet a = new AnalyserNode(oac, {fftSize: 1024});\n\n// Suspend the context every fftSize frames so we can get the FFT of \n// the previous fftSize frames.\nfor (let k = a.fftSize; k < b.length; k += a.fftSize) {\n  oac.suspend(k / b.sampleRate)\n    .then(() => {\n      a.getFloatFrequencyData(fftData);\n      // Copy fftData out or do something with it\n      });\n    .then(() => oac.resume());\n}\n\n// We can ignore the buffer that startRendering would return from the\n// resolved promise.\nawait oac.startRendering();\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "subsetting affects .view(np.float64) behaviour\r\n                \r\nI'm trying to use some sklearn estimators for classifications on the coefficients of some fast fourier transform (technically Discrete Fourier Transform). I obtain a numpy array X_c as output of np.fft.fft(X) and I want to transform it into a real numpy array X_r, with each (complex) column of the original X_c transformed into two (real/float) columns in X_r, i.e the shape goes from (r, c) to (r, 2c). So I use .view(np.float64). and it works at first.\n\nThe problem is that if I first decide to keep only some coefficients of the original complex array with X_c2 = X_c[:, range(3)] and then to do the same thing as before instead of having the number of columns doubled, I obtain the number of ranks doubled (the imaginary part of each element is put in a new row below the original).\n\nI really don't understand why this happens. \n\nTo make myself clearer, here is a toy example:\n\n```\nimport numpy as np\n\n# I create a complex array\nX_c = np.arange(8, dtype = np.complex128).reshape(2, 4)\nprint(X_c.shape) # -> (2, 4)\n\n# I use .view to transform it into something real and it works\n# the way I want it.\nX_r = X_c.view(np.float64)\nprint(X_r.shape) # -> (2, 8)\n\n# Now I subset the array.\nindices_coef = range(3)\nX_c2 = X_c[:, indices_coef]\nprint(X_c2.shape) # -> (2, 3)\nX_r2 = X_c2.view(np.float64)\n\n# In the next line I obtain (4, 3), when I was expecting (2, 6)...\nprint(X_r2.shape) # -> (4, 3)\n```\n\n\nDoes anyone see a reason for this difference of behavior?\n    ", "Answer": "\r\nI get a warning:\n\n```\nIn [5]: X_c2 = X_c[:,range(3)]\nIn [6]: X_c2\nOut[6]: \narray([[ 0.+0.j,  1.+0.j,  2.+0.j],\n       [ 4.+0.j,  5.+0.j,  6.+0.j]])\nIn [7]: X_c2.view(np.float64)\n/usr/local/bin/ipython3:1: DeprecationWarning: Changing the shape of non-C contiguous array by\ndescriptor assignment is deprecated. To maintain\nthe Fortran contiguity of a multidimensional Fortran\narray, use 'a.T.view(...).T' instead\n  #!/usr/bin/python3\nOut[7]: \narray([[ 0.,  1.,  2.],\n       [ 0.,  0.,  0.],\n       [ 4.,  5.,  6.],\n       [ 0.,  0.,  0.]])\n\n\nIn [12]: X_c2.strides\nOut[12]: (16, 32)\nIn [13]: X_c2.flags\nOut[13]: \n  C_CONTIGUOUS : False\n  F_CONTIGUOUS : True\n```\n\n\nSo this copy (or is a view?) is Fortran order.  The recommended ```\nX_c2.T.view(float).T```\n produces the same 4x3 array without the warning.\n\nAs your first view shows, a complex array has the same data layout as twice the number of floats.  \n\nI've seen funny shape behavior when trying to ```\nview```\n a structured array.  I'm wondering the ```\ncomplex```\n dtype is behaving much like a ```\ndtype('f8,f8')```\n array. \n\n\n\nIf I change your ```\nX_c2```\n so it is a copy, I get the expected behavior\n\n```\nIn [19]: X_c3 = X_c[:,range(3)].copy()\nIn [20]: X_c3.flags\nOut[20]: \n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\nIn [21]: X_c3.strides\nOut[21]: (48, 16)\nIn [22]: X_c3.view(float)\nOut[22]: \narray([[ 0.,  0.,  1.,  0.,  2.,  0.],\n       [ 4.,  0.,  5.,  0.,  6.,  0.]])\n```\n\n\nThat's reassuring.  But I'm puzzled as to why the ```\n[:, range(3)]```\n indexing creates a F order view.  That should be advance indexing.\n\nAnd indeed, a true slice does not allow this view\n\n```\nIn [28]: X_c[:,:3].view(np.float64)\n---------------------------------------------------------------------------\nValueError: new type not compatible with array.\n```\n\n\nSo the range indexing has created some sort of hybrid object.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Comparing not identical sound files\r\n                \r\nI'm developing a program for iPhone.\n\nI have read this article and I have some questions. After I get amplitude of sound file, which ranges of spectrum do I need to transform into FFT(Fast Fourier transform)? In article, man says \"40-80, 80-120, 120-180, 180-300\", how does he know which ranges? After I get FFT (using ```\nOouraFFT```\n) I have frequency spectrum, then as I understood must take control points, so how to take them?\n\nI have a few more questions, but please help me with those questions.\n    ", "Answer": "\r\n\n  in article man says \"40-80, 80-120, 120-180, 180-300\", how does he know which ranges?\n\n\nHe didn't know them - he made them up.\n\nThose ranges are very low in frequency.  Low frequency sounds tend to have the longest sustain/decay, so you're less likely to have temporal aliasing problems by using lower frequencies.  That's important in the application you're looking to implement.  The sounds vary over time, and the input samples could be at any given offset of the song/sounds, and most likely won't exactly match your window offsets.  Lower frequency parts of the sound are still susceptible to this, but much less so than higher frequency parts.\n\n\n  After I get FFT (using OouraFFT) I have frequency spectrum, then as I understood must take control points, so how to take them?\n\n\nOouraFFT is written in C, not Objective-C.  Can you link to the wrapper you are using?\n\nIf you're using this wrapper it looks to me like you're going to have to low-pass filter your data before hand, and maybe modify/additionally process the results of the library to do exactly what you're trying to accomplish.  Or find a different iPhone FFT library that wraps more high level concepts on top of FFT.\n\nThat library calls OouraFFT ```\nrdst```\n, and does so in such a way that all buckets are evenly distributed (pretty much just the raw FFT data, with no higher level concepts bolted on).  Unless you go with smaller buckets and aggregate them, you're not going to get those specific buckets described in the article you read.\n\nYou could try simply using a different evenly spaced bucket selection instead, and end up with something like ```\n40-80, 80-120, 120-160, 160-200, 200-240, 240-280, 280-320```\n.  Or you could use ```\n40-60, 60-80```\n etc, and combine/average buckets when you are done.\n\nTo get the bucket sizes you want, you'll need to do some math.  From that library's readme:\n\n\n  Say your signal has a sampling rate of 48,000 Hz, and you are computing the FFT on chunks of your signal 1024 samples long. Then, OouraFFT.spectrumData has 1024/2 = 512 frequencies in it, evenly spaced between 0 and 48,000/2 = 24,000. \n\n\nThe longer the window, the greater number of buckets, but the more likely you will have temporal issues.  So, select your window size, then low-pass filter your input data and reduce the sample rate so you can get bucket sizes (frequency ranges) that fit your need, and run the filtered data through.\n\nBTW, I am not sure about that implementation, but I read here that you have to throw out the lowest frequency bucket when using FFT.  This article has a similar notice, saying that the lowest bucket has only half the width.\n\nIf you're really wanting to get accurate results out of this project, I suggest you generate test data with those specific frequencies and window periods so you can verify that your array data is getting populated correctly, and your data isn't accidentally getting skewed (off-by-one errors, window and filter calculations incorrect, etc).  Otherwise your success will be by sheer luck and fiddling around because you won't be able to diagnose where any problems in your code lie.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Communicate with a Android Service\r\n                \r\nI need to create a service that reads sensors, do a fast fourier transform and save the results in to the db, but I need to communicate 2 values to the service when i start it (how many values to take and a string for the db). How can I communicate this to the service?\n\nIn addition I need to start the service every a time.\n\nEDIT: Here there is a good explanation -> http://www.androidcompetencycenter.com/2009/01/basics-of-android-part-iii-android-services/\n    ", "Answer": "\r\nYou can bind it and call a method on your service in onServiceConnected from the ServiceConnection \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Finding Fourier coefficients algorithm\r\n                \r\nOk, so I have been trying to code a \"naive\" method to calculate the coefficients for a standard Fourier Series in complex form. I am getting very close, I think, but there are some odd behaviors. This may be more of a math question than programming one, but I already asked on math.stackexchange and got zero answers. Here is my working code:\n\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef coefficients(fn, dx, m, L):\n    \"\"\"\n    Calculate the complex form fourier series coefficients for the first M\n    waves.\n\n    :param fn: function to sample\n    :param dx: sampling frequency\n    :param m: number of waves to compute\n    :param L: We are solving on the interval [-L, L]\n    :return: an array containing M Fourier coefficients c_m\n    \"\"\"\n\n    N = 2*L / dx\n    coeffs = np.zeros(m, dtype=np.complex_)\n    xk = np.arange(-L, L + dx, dx)\n\n    # Calculate the coefficients for each wave\n    for mi in range(m):\n        coeffs[mi] = 1/N * sum(fn(xk)*np.exp(-1j * mi * np.pi * xk / L))\n\n    return coeffs\n\n\ndef fourier_graph(range, L, c_coef, function=None, plot=True, err_plot=False):\n    \"\"\"\n    Given a range to plot and an array of complex fourier series coefficients,\n    this function plots the representation.\n\n\n    :param range: the x-axis values to plot\n    :param c_coef: the complex fourier coefficients, calculated by coefficients()\n    :param plot: Default True. Plot the fourier representation\n    :param function: For calculating relative error, provide function definition\n    :param err_plot: relative error plotted. requires a function to compare solution to\n    :return: the fourier series values for the given range\n    \"\"\"\n    # Number of coefficients to sum over\n    w = len(c_coef)\n\n    # Initialize solution array\n    s = np.zeros(len(range))\n    for i, ix in enumerate(range):\n        for iw in np.arange(w):\n            s[i] += c_coef[iw] * np.exp(1j * iw * np.pi * ix / L)\n\n    # If a plot is desired:\n    if plot:\n        plt.suptitle(\"Fourier Series Plot\")\n        plt.xlabel(r\"$t$\")\n        plt.ylabel(r\"$f(x)$\")\n        plt.plot(range, s, label=\"Fourier Series\")\n\n        if err_plot:\n            plt.plot(range, function(range), label=\"Actual Solution\")\n            plt.legend()\n\n        plt.show()\n\n    # If error plot is desired:\n    if err_plot:\n        err = abs(function(range) - s) / function(range)\n        plt.suptitle(\"Plot of Relative Error\")\n        plt.xlabel(\"Steps\")\n        plt.ylabel(\"Relative Error\")\n        plt.plot(range, err)\n        plt.show()\n\n    return s\n\n\nif __name__ == '__main__':\n\n    # Assuming the interval [-l, l] apply discrete fourier transform:\n\n    # number of waves to sum\n    wvs = 50\n\n    # step size for calculating c_m coefficients (trap rule)\n    deltax = .025 * np.pi\n\n    # length of interval for Fourier Series is 2*l\n    l = 2 * np.pi\n\n    c_m = coefficients(np.exp, deltax, wvs, l)\n\n    # The x range we would like to interpolate function values\n    x = np.arange(-l, l, .01)\n    sol = fourier_graph(x, l, c_m, np.exp, err_plot=True)\n```\n\n\nNow, there is a factor of 2/N multiplying each coefficient. However, I have a derivation of this sum in my professor's typed notes that does not include this factor of 2/N. When I derived the form myself, I arrived at a formula with a factor of 1/N that did not cancel no matter what tricks I tried. I asked over at math.stackexchange what was going on, but got no answers.\n\nWhat I did notice is that adding the 1/N decreased the difference between the actual solution and the fourier series by a massive amount, but it's still not right. so I tried 2/N and got even better results. I am really trying to figure this out so I can write a nice, clean algorithm for basic fourier series before I try to learn about Fast Fourier Transforms. \n\nSo what am I doing wrong here? \n    ", "Answer": "\r\nassuming ```\nc_n```\n is given by ```\nA_n```\n as in mathworld \n\nidem ```\nc_n = 1/T \\int_{-T/2}^{T/2}f(x)e^{-2ipinx/T}dx```\n\n\nwe can compute (trivially) the coeffs ```\nc_n```\n analytically (which is a good way to compare to your trapezoidal integral)\n\n```\nk = (1-2in)/2\nc_n = 1/(4*pi*k)*(e^{2pik} - e^{-2pik})\n```\n\n\nSo your coeffs are likely to be properly computed (the both wrong curves look alike)\n\nNow notice that when you reconstitue ```\nf```\n, you add the coeff ```\nc_0```\n up to ```\nc_m```\n\n\nBut the reconstruction should occur with ```\nc_{-m}```\n to ```\nc_m```\n\n\nSo you are missing half of the coeffs.\n\nBelow a fix with your adaptated coefficients function and the theoretical coeffs\n\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef coefficients(fn, dx, m, L):\n    \"\"\"\n    Calculate the complex form fourier series coefficients for the first M\n    waves.\n\n    :param fn: function to sample\n    :param dx: sampling frequency\n    :param m: number of waves to compute\n    :param L: We are solving on the interval [-L, L]\n    :return: an array containing M Fourier coefficients c_m\n    \"\"\"\n\n    N = 2*L / dx\n    coeffs = np.zeros(m, dtype=np.complex_)\n    xk = np.arange(-L, L + dx, dx)\n\n    # Calculate the coefficients for each wave\n    for mi in range(m):\n        n = mi - m/2\n        coeffs[mi] = 1/N * sum(fn(xk)*np.exp(-1j * n * np.pi * xk / L))\n\n    return coeffs\n\n\ndef fourier_graph(range, L, c_coef, ref, function=None, plot=True, err_plot=False):\n    \"\"\"\n    Given a range to plot and an array of complex fourier series coefficients,\n    this function plots the representation.\n\n\n    :param range: the x-axis values to plot\n    :param c_coef: the complex fourier coefficients, calculated by coefficients()\n    :param plot: Default True. Plot the fourier representation\n    :param function: For calculating relative error, provide function definition\n    :param err_plot: relative error plotted. requires a function to compare solution to\n    :return: the fourier series values for the given range\n    \"\"\"\n    # Number of coefficients to sum over\n    w = len(c_coef)\n\n    # Initialize solution array\n    s = np.zeros(len(range), dtype=complex)\n    t = np.zeros(len(range), dtype=complex)\n\n    for i, ix in enumerate(range):\n        for iw in np.arange(w):\n            n = iw - w/2\n            s[i] += c_coef[iw] * (np.exp(1j * n * ix * 2 * np.pi / L))\n            t[i] += ref[iw] * (np.exp(1j * n * ix * 2 * np.pi / L))\n\n    # If a plot is desired:\n    if plot:\n        plt.suptitle(\"Fourier Series Plot\")\n        plt.xlabel(r\"$t$\")\n        plt.ylabel(r\"$f(x)$\")\n        plt.plot(range, s, label=\"Fourier Series\")\n\n        plt.plot(range, t, label=\"expected Solution\")\n        plt.legend()\n\n        if err_plot:\n            plt.plot(range, function(range), label=\"Actual Solution\")\n            plt.legend()\n\n        plt.show()\n\n    return s\n\ndef ref_coefficients(m):\n    \"\"\"\n    Calculate the complex form fourier series coefficients for the first M\n    waves.\n\n    :param fn: function to sample\n    :param dx: sampling frequency\n    :param m: number of waves to compute\n    :param L: We are solving on the interval [-L, L]\n    :return: an array containing M Fourier coefficients c_m\n    \"\"\"\n\n    coeffs = np.zeros(m, dtype=np.complex_)\n\n    # Calculate the coefficients for each wave\n    for iw in range(m):\n        n = iw - m/2\n        k = (1-(1j*n)/2)\n        coeffs[iw] = 1/(4*np.pi*k)* (np.exp(2*np.pi*k) - np.exp(-2*np.pi*k))\n    return coeffs\n\nif __name__ == '__main__':\n\n    # Assuming the interval [-l, l] apply discrete fourier transform:\n\n    # number of waves to sum\n    wvs = 50\n\n    # step size for calculating c_m coefficients (trap rule)\n    deltax = .025 * np.pi\n\n    # length of interval for Fourier Series is 2*l\n    l = 2 * np.pi\n\n    c_m = coefficients(np.exp, deltax, wvs, l)\n\n    # The x range we would like to interpolate function values\n    x = np.arange(-l, l, .01)\n    ref = ref_coefficients(wvs)\n    sol = fourier_graph(x, 2*l, c_m, ref, np.exp, err_plot=True)\n\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Type mismatch array(VBA) in recursion function\r\n                \r\nI' m exploring VBA in Excel a little bit and try to run recursive fast fourier transform code but I get message\n\nType mismatch: array or user-defined type expected\n\nin function ```\nrecFFT(ByRef X() As Double) As Double()```\n (see line ```\nFe = recFFT(Xe())```\n).\nThis is the code:\n```\nFunction recFFT(ByRef X() As Double) As Double()\nDim n, m, i, k As Integer\nDim Xe(), Xo(), Fe(), Fo() As Double\nDim wcos As Double\n\n    n = UBound(X)\n\nIf n = 1 Then\n    recFFT = X\nElse\n    m = n / 2\n    \n    ReDim Xe(0 To m - 1)\n    ReDim Xo(0 To m - 1)\n \n    For i = 0 To m - 1\n        Xe(i) = X(2 * i)\n        Xo(i) = X(2 * i + 1)    \n    Next i\n\n    ReDim Fe(0 To m - 1)\n    Fe = recFFT(Xe())\n    \n    ReDim Fo(0 To m - 1)\n    Fo = recFFT(Xo())\n    \n    ReDim freqbins(0 To n - 1)\n    \n    For k = 0 To n / 2 - 1 \n        wcos = Cos(2 * PI * k / n) * Fo(k)\n        freqbins(k) = Fe(k) + wcos\n        freqbins(k+n/2) = Fe(k) - wcos      \n    Next k\n    \n    recFFT = freqbins()\n    \nEnd If\n    \nEnd Function\n```\n\nFunction is called from sub routine by ```\nF = ThisWorkbook.recFFT(A())```\n where ```\nF```\n and ```\nA```\n are arrays declared as Double.\nTried to find solution online but nothing helped so far.\nI am not sure if this type of recursive call is even possible in VBA script.\nThanks in advance.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Translating an FFT function from Python 2.x to Python 3.x, and computing the IFFT from it\r\n                \r\nI have an Fast Fourier Transform function in Python for versions 2.x. I want to make it in Python 3.x, but I have some problems with \"xrange\" and list identifiers(as my compiler said). I also have no idea how to compute Inversed FFT from my FFT without using of any non-standard libraries. Code is below. Thanks in advance...\n\n```\n from cmath import exp,pi\n\n def FFT(X):\n  n = len(X)\n  w = exp(-2*pi*1j/n)\n  if n > 1:\n    X = FFT(X[::2]) + FFT(X[1::2])\n    for k in xrange(n/2):\n        xk = X[k]\n        X[k] = xk + w**k*X[k+n/2]\n        X[k+n/2] = xk - w**k*X[k+n/2]\n return X \n```\n\n\nUPD: Totally reconstructed ,my FFT and constructed IFFT due to your advices.\nP.S. How to close post?\n    ", "Answer": "\r\nThere are a couple ways to convert your FFT into an IFFT.  The easiest is to get rid of the minus sign inside the parameter to your exp() function for w.  The next is to take the complex conjugate of the FFT of the complex conjugate of the input.\n\nIf you don't scale your forward FFT, then common practice is to scale your IFFT computation by 1/N (the length), so that IFFT(FFT()) results in the same total sum magnitude.  If you do scale your FFT by 1/N, then don't scale your IFFT computation.  Or scale both by 1/sqrt(N).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How do I plot the output of numpy.fft in bins?\r\n                \r\nI wrote some python code that plots the fast fourier transform of a pandas ```\nDataFrame```\n called ```\nres```\n, which contains two columns of data (\"data\" and \"filtered\"):\n\n```\nfft = pd.DataFrame(np.abs(np.fft.rfft(res[\"data\"])))\nfft.columns = [\"data\"]\nfft[\"filtered\"] = pd.DataFrame(np.abs(np.fft.rfft(res[\"filtered\"])))\n\nfft.index=np.fft.fftfreq(len(res))[0:len(fft)]\nfft.plot(logy=True, logx=True)\n```\n\n\nThe ```\nres```\n dataset contains some original randomised datapoints in the \"data\" column along with the same data after passing through a filter. The output looks reasonable to me;\n\n\n\nWhile this plot is probably correct, it's not very useful to look at. How can I organise this data into a smaller number of discrete frequency bins to make it easier to understand?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier to detect piano frequency in matlab\r\n                \r\nI have a basic knowledge of the fast Fourier and that it transforms the time domain into frequency domain to get all the frequency samples found in a signal or recorded sound ...\n\ni want to create an application that detects all the frequencies in a recorded piano piece and match them with originally detected piano notes and if it catches a match will write the piano sheet based on this concept ... i have this code but i am not sure whether it doesn't work fine ...\n\nThe C middle note has originally on a grand piano Frequency of 261.7  but when i use it the output changes over the amplitude of the voice (Ex: 261/262/270 ...etc ) \n\n```\n   [x,Fs]= readaudio('c4,wav');\n   xdft = fft(readaudio(c4.wav);\n   [~,index] = sort(abs(xdft() , 'descend'));\n   (index(1)*Fs)/length(x) - (fs/length(x));\n```\n\n\nAlso i have tried to implement such code visiting many questions and forums but i don't know how to apply it to my idea in general.(here is the code )\n\n```\n    [y,Fs] =audioread('49.wav');\n    fcuts = [430  438  442  450];             % Frequency Vector (Hz)\n    mags =   [0 1 0];        % Magnitude (Defines Passbands & Stopbands)\n    devs = [0.05  0.01  0.05];                    % Allowable Deviations\n    [n,Wn,beta,ftype] = kaiserord(fcuts,mags,devs,Fs);\n    n = n + rem(n,2);\n    hh = fir1(n,Wn,ftype,kaiser(n+1,beta),'scale');\n    figure(1)\n    freqz(hh, 1, 2^14, Fs)\n    set(subplot(2,1,1), 'XLim', [0 500])% Set Frequency Axis To Show0-500             Hz\n    set(subplot(2,1,2), 'XLim', [0 500])% Set frequency Axis To Show 0-500 Hz\n    y_filtered = fftfilt(hh, y);\n```\n\n\nBut basically i don't understand it and how to change the Frequency to catch ... but my vision to what i will do is to pass all the frequencies i got from the recorded file to all the keys filters and using if conditions if a match then will write the symbol of the key to the sheet. \n\nplease if someone can explain the code and the process to me as i never used matlab before and kind of weak in its commands\n    ", "Answer": "\r\nPitch is not the same as spectral frequency (as returned by a bare FFT magnitude).  Repeated/periodic (\"pitched\") waveforms do not have to look anything like a sine wave.\n\nIt's possible for all the frequencies returned by an FFT to be completely different from the perceived pitch (see \"psychoacoustics\" and \"missing fundamental\").  Most likely all higher harmonics, but possibly some inharmonic overtones as well.  This is especially true for stringed instruments with \"big\" strings (piano and bass guitar, etc.)\n\nSo the problem isn't with your code, but with the fact that you are not using a pitch detection/estimation algorithm, but instead a spectral frequency peak detector.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Cross-correlation between images\r\n                \r\nI'd like to compute the cross correlation using de Fast Fourier Transform, for cloud motion tracking following the steps of the image below.\n\n\n\n```\ndef roi_image(image):\n    image = cv.imread(image, 0)\n    roi = image[700:900, 1900:2100]\n    return roi\n\ndef FouTransf(image):\n    img_f32 = np.float32(image)\n    d_ft = cv.dft(img_f32, flags = cv.DFT_COMPLEX_OUTPUT)\n    d_ft_shift = np.fft.fftshift(d_ft)\n\n    rows, cols = image.shape\n    opt_rows = cv.getOptimalDFTSize(rows)\n    opt_cols = cv.getOptimalDFTSize(cols)\n    opt_img = np.zeros((opt_rows, opt_cols))\n    opt_img[:rows, :cols] = image \n    crow, ccol = opt_rows / 2 , opt_cols / 2\n    mask = np.zeros((opt_rows, opt_cols, 2), np.uint8)\n    mask[int(crow-50):int(crow+50), int(ccol-50):int(ccol+50)] = 1\n\n    f_mask = d_ft_shift*mask\n    return f_mask\n\n\ndef inv_FouTransf(image):\n\n    f_ishift = np.fft.ifftshift(image)\n    img_back = cv.idft(f_ishift)\n    img_back = cv.magnitude(img_back[:, :, 0], img_back[:, :, 1])\n\n    return img_back\n\ndef rms(sigma):\n    rms = np.std(sigma)\n    return rms\n\n# Step 1: Import images\na = roi_image(path_a)\nb = roi_image(path_b)\n\n# Step 2: Convert the image to frequency domain\nG_t0 = FouTransf(a)\nG_t0_conj = G_t0.conj()\nG_t1 = FouTransf(b)\n\n# Step 3: Compute C(m, v)\nC = G_t0_conj * G_t1\n\n# Step 4: Convert the image to space domain to obtain Cov (p, q)\nc_w = inv_FouTransf(C)\n\n# Step 5: Compute Cross correlation\nR_pq = c_w / (rms(a) * rms(b)) \n```\n\n\nI'm a little confused because I've never use that technique. ¿The application es accurate?\n\nHINT: eq (1) is : R(p,q) = Cov(p,q) / (sigma_t0 * sigma_t1). If more information is required the paper is: \"An Automated Techinique or Obtaining Cloud Motion from Geostatiory Satellite Data Using Cross Correlation\".\n\nI found this source but I don't know if does something I'm trying.\n    ", "Answer": "\r\nIf you are trying to do something similar to ```\ncv2.matchTemplate()```\n, a working python implementation of the Normalized Cross-Correlation (NCC) method can be found in this repository:\n\n```\n########################################################################################\n# Author: Ujash Joshi, University of Toronto, 2017                                     #\n# Based on Octave implementation by: Benjamin Eltzner, 2014 <b.eltzner@gmx.de>         #\n# Octave/Matlab normxcorr2 implementation in python 3.5                                #\n# Details:                                                                             #\n# Normalized cross-correlation. Similiar results upto 3 significant digits.            #\n# https://github.com/Sabrewarrior/normxcorr2-python/master/norxcorr2.py                #\n# http://lordsabre.blogspot.ca/2017/09/matlab-normxcorr2-implemented-in-python.html    #\n########################################################################################\n\nimport numpy as np\nfrom scipy.signal import fftconvolve\n\n\ndef normxcorr2(template, image, mode=\"full\"):\n    \"\"\"\n    Input arrays should be floating point numbers.\n    :param template: N-D array, of template or filter you are using for cross-correlation.\n    Must be less or equal dimensions to image.\n    Length of each dimension must be less than length of image.\n    :param image: N-D array\n    :param mode: Options, \"full\", \"valid\", \"same\"\n    full (Default): The output of fftconvolve is the full discrete linear convolution of the inputs. \n    Output size will be image size + 1/2 template size in each dimension.\n    valid: The output consists only of those elements that do not rely on the zero-padding.\n    same: The output is the same size as image, centered with respect to the ‘full’ output.\n    :return: N-D array of same dimensions as image. Size depends on mode parameter.\n    \"\"\"\n\n    # If this happens, it is probably a mistake\n    if np.ndim(template) > np.ndim(image) or \\\n            len([i for i in range(np.ndim(template)) if template.shape[i] > image.shape[i]]) > 0:\n        print(\"normxcorr2: TEMPLATE larger than IMG. Arguments may be swapped.\")\n\n    template = template - np.mean(template)\n    image = image - np.mean(image)\n\n    a1 = np.ones(template.shape)\n    # Faster to flip up down and left right then use fftconvolve instead of scipy's correlate\n    ar = np.flipud(np.fliplr(template))\n    out = fftconvolve(image, ar.conj(), mode=mode)\n\n    image = fftconvolve(np.square(image), a1, mode=mode) - \\\n            np.square(fftconvolve(image, a1, mode=mode)) / (np.prod(template.shape))\n\n    # Remove small machine precision errors after subtraction\n    image[np.where(image < 0)] = 0\n\n    template = np.sum(np.square(template))\n    out = out / np.sqrt(image * template)\n\n    # Remove any divisions by 0 or very close to 0\n    out[np.where(np.logical_not(np.isfinite(out)))] = 0\n\n    return out\n```\n\n\nThe returned object from ```\nnormxcorr2()```\n is the cross correlation matrix.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "std::complex<float> with error C2106: '=': left operand must be l-value\r\n                \r\nI performed fast Fourier transform (fft) on my ```\nsignal```\n, turning it into ```\nsignalComplex```\n; ```\nsignal```\n is a series of real float numbers and ```\nsignalComplex```\n represents a series of complex numbers:\n```\nstd::vector<std::complex<float>> signalComplex(numSamplesPerScan);   // int numSamplesPerScan\n\n    fft.fwd(signalComplex, signal);    //  std::vector<float> signal\n\n    for (int n = 1; n < numSamplesPerScan / 2; n++)   // simplified procedure to calculate HT\n    {\n        float real = signalComplex[n].real();   // positive frequency X 2\n        float imag = signalComplex[n].imag();\n\n        real *= 2;\n        imag *= 2;\n\n        signalComplex[n].real() = real;  // compiler complains here\n        signalComplex[n].imag() = imag;  // compiler complains here\n\n        signalComplex[n + numSamplesPerScan / 2].real() = 0;    // compiler complains here\n        signalComplex[n + numSamplesPerScan / 2].imag() = 0;    // compiler complains here\n    }\n```\n\nIn the for loop above, I am trying to do some simple computation on real and imaginary parts of the ```\nsignalComplex```\n. However, the compiler complains about \"error C2106: '=': left operand must be l-value\"; I am not sure how to do computation on the real imaginary parts in this case.\nAny pointer is appreciated. Some code is highly appreciated.\n    ", "Answer": "\r\nI want to thank all people here that were trying to help me.\nLike Brian pointed out, the code in the questions is modified to\n```\nstd::vector<std::complex<float>> signalComplex(numSamplesPerScan);\n\nfft.fwd(signalComplex, signal);\n\nfor (int n = 1; n < numSamplesPerScan / 2; n++)   \n{\n    signalComplex[n] = { signalComplex[n].real()*2, signalComplex[n].imag()*2 };  // following is the key part\n    signalComplex[n + numSamplesPerScan / 2] = {0, 0};\n}\n```\n\nand it compiles just fine.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Efficient Kullback–Leibler calculation\r\n                \r\nI am looking to implement KL Divergence in C++ efficiently. (CPU Only for now).\nMuch like AES or FTT (Fast Fourier transform) whereby use of a common function has lead to hardware level optimizations (Intel AES and Intel FTT).\nIs there anything similar for natural log, or slightly higher level efficiencies (ASM/C) that prevent bottlenecks of executing many Natural log functions in success (If they exist)?\nSame use case examples:\n```\n.Many parallel and independent node executions; each one performing 20~ KL calculations from localized (not shared or pointer reffed) memory.\n\n.Scheduled KL: executing in stepped-parallel where the hardware is setup expecting uses of for example tables (assuming tables are used at this lower level - AES implement ions indicated this is a high probability) .\n```\n\nI have found a possible candiate, but I'm unsure: ALTFP_LOG\n    ", "Answer": "\r\nYou can use ```\nSSE instructions```\n to calculate the logarithm of many values in parallel. But whether you can actually make use of those instructions depends heavily on how the rest of the calculations you are going to do depend on the logarithms you calculate, so it is not possible to give a more specific answer.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Error in matrix index dimension for colored noise\r\n                \r\nThe objective of the following code is to generate a colored gaussian signal from a random gaussian noise;perform Fast Fourier Transform and also generate power signal. Questions:\n\n\nI wanted to generate gaussian colored noise such that the power spectral densities is proprtional to 1/f^beta where beta=1,-1,2,0. Is the process correct?\nThe code generates error\n\n??? Error using ==> rdivide\nMatrix dimensions must agree.\n\nError in ==> expl at 9\nx = x .* 1./(f.^2);\nKindly help in solving this.Thank you\n\n    ", "Answer": "\r\n```\nf```\n has 1025 elements, and ```\nx```\n has 2001 elements. But their length needs to be equal. You should change one of them.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Are real and imaginary parts of fft ouput correlated?\r\n                \r\nI want to use model-based clustering to classify 1,225 time series (24 periods each). I have decomposed these time series using the fast Fourier transform and selected the harmonics that explain at least a threshold percentage of time series variance for all time series in the sample. I want to do model-based clustering on the real and imaginary parts for each transform element of a give time series because it would potentially save me from having to account for temporal autocorrelation in model awed clustering across periods of a time series. I know that each complex element of the fast Fourier transform is independent from other elements, but I do not know if the imaginary and real parts of the output for a given output element are independent. I would like to know because if they were, it would allow me to maintain the default assumption of the Mclust package in R for model-based clustering that the variables analyzed have a multivariate Gaussian distribution.\n\nNOTE: The full FFT is not used as I have discarded the elements at negative frequencies and converted from a two-sided to a one-sided spectrum by multiplying frequencies 1 to Nyquist by two per advice here: How do I calculate amplitude and phase angle of fft() output from real-valued input?.\n    ", "Answer": "\r\nThe real part and the imaginary part are orthogonal (due to the sin(x) and cos(x) functions being orthogonal).  This characteristic is essential to how an FFT works.\n\nPer Wolfram MathWorld:\n\n\n  A Fourier series is an expansion of a periodic function  in terms of\n  an infinite sum of sines and cosines. Fourier series make use of the\n  orthogonality relationships of the sine and cosine functions.\n\n\nThe FFT is essentially a change of basis.  That says nothing about the data itself which may or may not contain correlations between the real and imaginary parts.\n\nWith respect to the edited question, \"How do I calculate amplitude and phase angle of fft() output from real-valued input?.\"  The way to convert the real component and imaginary components to magnitude and phase angle is ```\nmagnitude = (real_part ** 2 + imaginary_part ** 2) ** 0.5```\n and ```\nangle=arctan2(imaginary_part, real_part)```\n.  It is the same as a rectangular-to-polar conversion.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Speed Up MATLAB for Fourier Series For Loop\r\n                \r\nI know this topic has been visited a number of times, so apologies in advance. I just cannot get around an inefficient for loop operation and would like your help. \n\nI am implementing a single for loop which sums time domain periodic data. I use the Fourier coefficients I obtain from a previous FFT. My issue is that I need to add additional time domain data to the periodic information so I cannot simply use an inverse FFT operation. I am basically editing the standard discrete Fourier transform (DFT) sum, which is namely:\n\n```\nfor k = 1:L\n    x = x + F(k+1)*exp(1j*(omega(k+1)*t));\nend\n```\n\n\nIn this series F are my Fourier coefficients, omega is the frequency vector and t is the time vector. I have to alter the sum so that it looks like this:\n\n```\nfor k = 1:L\n    x = x + F(k+1)*exp(1j*(omega(k+1)*t)+1j*k*xt);\nend\n```\n\n\nThe only change is that I am now including a vector which is a time domain function (for example a sine wave) which I have called xt. The problem is the time domain information must have an extremely fine resolution (a 10 second recording is approximately 5e6 long). I cannot shorten the time length because I require a high frequency resolution. This results in a single function evaluation of approximately 7 hours on my machine (which I have to admit, isn't the greatest). I need to evaluate the function in an optimisation setting, and so a 7 hour function evaluation time is not feasible.\n\nI have tried to vectorize the operation, however the matrices become too large for my computer to handle and MATLAB has been updated to handle for loops more efficiently anyway. I have tried to write my own version of the fast Fourier transform, however because I edit the frequency information in each step certain assumptions which the Cooley and Tukey algorithm require break apart. Does anyone know how I can rewrite the above sum into a more efficient format? I have preallocated the vector as well.\n    ", "Answer": "\r\nI think this may be a vectorised approach to carry out what you want, using ```\nbsxfun```\n.\n\n```\nk = 1:L;\nx = x + sum(bsxfun(@times, F(k+1), exp(1j*(bsxfun(@times, omega(k+1), permute(t, [2 1])) + bsxfun(@times, k, permute(xt, [2 1]))))), 2).';\n```\n\n\nNote: For this solution ```\nF```\n, ```\nomega```\n, ```\nk```\n, ```\nt```\n and ```\nxt```\n should all be column vectors, that is ```\n1x?```\n.\n\nExplanation\n\nThe exponential ```\nexp(1j*(omega(k+1)*t)+1j*k*xt)```\n is computed first with \n\n```\ne = exp(1j*(bsxfun(@times, omega(k+1), permute(t, [2 1])) + bsxfun(@times, k, permute(xt, [2 1]))))\n```\n\n\nwhich generates a ```\nMxL```\n matrix where ```\nM```\n is the length of ```\nt```\n and ```\nxt```\n. Next we multiply each column of this by ```\nF```\n (which is of dimension ```\n1xL```\n) with\n\n```\nFe = bsxfun(@times, F(k+1), e)\n```\n\n\nwhich is another ```\nMxL```\n matrix. Finally we sum along the 2nd dimension (```\nL```\n) to produce a ```\nMx1```\n vector\n\n```\nx = x + sum(Fe, 2).'\n```\n\n\nwhere ```\n.'```\n is used to transpose the ```\nMx1```\n vector to a ```\n1xM```\n vector.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to correctly bandpass filter in frequency with MATLAB?\r\n                \r\ni'm pretty new to matlab and signal processing, but I am working on a project and I am stuck. My goal is to do a band-pass fast Fourier transform (FFT) filter with cut-off frequencies of 0.5 Hz and 3 Hz from a real signal. My input signal is a signal sampled ad 405Hz and of around 35000 samples. My implementation looks like this:\n```\n%ZFiltered = My signal \nfiltered = bandpass(fft(zFiltered), [0.5 3], sampling_frequency);\nres = ifft(filtered);\n\nsubplot(2,1,1)\nplot(zFiltered)\n\nsubplot(2,1,2)\nplot(abs(res))\n```\n\nMy questions are: Why do I get a signal which contains also imaginary part? Why does it look like this ?\n    ", "Answer": "\r\nYour goal is unclear to me; here are three different approaches that your question hints at\n\nfilter your raw signal with a band-pass filter as your code attempts to do\nuse the ```\nfft```\n and ```\nifft```\n functions to filter your raw signal\ncalculate the coefficients of a digital filter that would act as a band-pass filter when used with the ```\nfilter```\n function\n\n\nApproach 1: filtering with ```\nbandpass```\n function\nReferring to the ```\nbandpass```\n documentation, you would use your original signal and specify the filter band and sampling frequency as in:\n```\nfiltered_signal = bandpass(zFiltered,[freq_low freq_high],sample_freq);\nplot(zFiltered); hold on;\nplot(filtered_signal);\n```\n\nwhere the inputs are the\n\n```\nzFiltered```\n : original (unfiltered signal)\n```\nfreq_low=0.5```\n : lowest frequency in Hz of the band pass range`\n```\nfreq_high=3```\n : highest frequency in Hz of the band pass range\n```\nsample_freq=405```\n : the sampling frequency in Hz\n\nYour approach using digital fast Fourier transform function ```\nfft```\n produces complex results because you are looking at the actual components computed by the transform (which by definition are complex having both real and imaginary parts). You can compute the power of the signal with:\n```\nP = abs(res/n).^2;\n```\n\nwhich gives you the power of the signal for each frequency represented in the Fourier transform (see the ```\nfft```\n function docs here for more information).\n\nApproach 2: Filtering with ```\nfft```\n ```\nifft```\n functions\nUse the Fourier transform and inverse Fourier transform functions to filter the signal. The steps here are to use ```\nfft```\n to get the signal into the frequency domain. Set the elements you want filtered to zero and then apply the inverse Fourier transform (```\nifft```\n) to get the filtered signal. Each component represents a given discrete frequencies in the range between 0Hz and ```\nF_s/2```\n that contributes to the signal. Set components of the FFT you want to suppress to zoro and apply ```\nifft```\n to get back a filter signal. Please see the ```\nfft```\n docs and ```\nifft```\n docs for information on these functions and some of the intricacies of working with signals in the frequency domain.\n\nApproach 3: Filtering with the coefficeints of the standard difference equation\nComputing the coefficients of a digital band pass filter.  This approach calculates the coefficients (vectors ```\nA```\n and ```\nB```\n) of the standard difference equation (see ```\nfilter```\n docs for details). An example of a function that does this is ```\nbutter```\n which gives the coefficients that represent a Butterworth filter of a given frequency. You could also look at the ```\ndesignfilt```\n function for more options.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to read a pdb file and perform FFT based docking using python? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nSuppose I have two PDB files (one of them is as follows)\n\n\n\n```\nATOM      1  N   MET A   1      66.104  56.583 -35.505  \nATOM      2  CA  MET A   1      66.953  57.259 -36.531  \nATOM      3  C   MET A   1      67.370  56.262 -37.627  \nATOM      4  O   MET A   1      67.105  55.079 -37.531  \nATOM      5  CB  MET A   1      68.227  57.852 -35.867  \nATOM      6  CG  MET A   1      67.848  58.995 -34.899  \nATOM      7  SD  MET A   1      66.880  58.593 -33.421  \n....      .  ..  ... .   .      ......  ......  ......\n....      .  ..  ... .   .      ......  ......  ......\n```\n\n\nThis file can be read in python using following script.\n\n\n\n```\nimport sys\nx=[];y=[];z=[]\nres=[]\nNr=0\nfor fn in sys.argv[1:]:\n   f=open(fn,'r')\n   while 1:\n      line=f.readline()\n      if not line: break\n      if line[0:6]=='ATOM  ' :\n         rx=float(line[30:38]);ry=float(line[38:46]);rz=float(line[46:54])\n         if line[21]=='A' :\n            x.append(rx); y.append(ry); z.append(rz)\n            Nr=Nr+1\n            res.append(line[17:20])\n   for i in range(1,Nr-1):\n      print fn, i, res[i], x[i], y[i], z[i]\nf.close\n```\n\n\nNow I would like to generate the grid of ```\nN*N*N```\n dimension and rotate and translate the molecule on the grid. The rotation and translation can be done by using FFT (Fast Fourier Transform). \n\nI tried to write something like follows  \n\n```\nimport numpy as np\nimport fftw as fft\n\nclass Grid3D(object):\n\n   def __init__(self, grid_dimension):\n      x = y = z = grid_dimension\n      self.grid = np.zeros([x, y, z], dtype=float)\n```\n\n\nAll this is actually to perform docking of two molecules using 3d grid and FFT. I wanted to know how to proceed further or any better way?\n    ", "Answer": "\r\nAn answer to you first question, \"How to read a pdb file\"\n\nIf you want to end up with a numpy array, you can use ```\nnumpy.genfromtxt```\n which is very nice, and much easier to implement and use than your looped reading.  It is also much more robust to spacing of the files, etc.\n\n```\nimport numpy as np\ndata = np.genfromtxt('filename.txt',\n        names = 'ATOM,index,res,MET,A,count,x,y,z',\n        dtype=['S4',int,'S2','S3','S1',int,float,float,float])\n```\n\n\nNow ```\ndata```\n is a numpy \"structured array\", which can easily be accessed as follows:\n\n```\nIn [13]: data\nOut[13]: \narray([('ATOM', 1, 'N', 'MET', 'A', 1, 66.104, 56.583, -35.505),\n       ('ATOM', 2, 'CA', 'MET', 'A', 1, 66.953, 57.259, -36.531),\n       ('ATOM', 3, 'C', 'MET', 'A', 1, 67.37, 56.262, -37.627),\n       ('ATOM', 4, 'O', 'MET', 'A', 1, 67.105, 55.079, -37.531),\n       ('ATOM', 5, 'CB', 'MET', 'A', 1, 68.227, 57.852, -35.867),\n       ('ATOM', 6, 'CG', 'MET', 'A', 1, 67.848, 58.995, -34.899),\n       ('ATOM', 7, 'SD', 'MET', 'A', 1, 66.88, 58.593, -33.421)], \n      dtype=[('ATOM', 'S4'), ('index', '<i8'), ('el', 'S2'), ('MET', 'S3'), ('A', 'S1'), ('count', '<i8'), ('x', '<f8'), ('y', '<f8'), ('z', '<f8')])\n\nIn [14]: data['x']\nOut[14]: array([ 66.104,  66.953,  67.37 ,  67.105,  68.227,  67.848,  66.88 ])\n\nIn [15]: data['y']\nOut[15]: array([ 56.583,  57.259,  56.262,  55.079,  57.852,  58.995,  58.593])\n\nIn [16]: data['index']\nOut[16]: array([1, 2, 3, 4, 5, 6, 7])\n\nIn [17]: data[3]\nOut[17]: ('ATOM', 4, 'O', 'MET', 'A', 1, 67.105, 55.079, -37.531)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Contributing to SciPy\r\n                \r\nI've never contributed to SciPy (or any other Python package, for that matter), but I have a super simple code that performs a 2-D discrete cosine transform using existing SciPy code for the 1-D discrete cosine transform. SciPy already has support for the 2-D (or N dimensional) fast fourier transform, but not for the 2-D discrete cosine transform. Looking at the SciPy code on GitHub, I see that most of the fourier-related code (everything in the fftpack module) is written in fortran, while the code I've put together is in Python (put together is an overstatement -- it's one line).\n\nMy question is this: I see this code as being pretty useful, and perhaps represents a good opportunity for me to contribute to SciPy. However, I definitely can't check all the boxes listed in the SciPy documentation regarding contributing code (e.g., I don't have \"test units\", nor do I really know what that is). How do I proceed in the process of contributing? \n\n```\ndef dct2(x):\n    \"\"\"\n    x is a 2-D numpy array\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    return fftpack.dct(fftpack.dct(x).T).T\n\ndef idct2(x):\n    x = np.asarray(x, dtype=float)\n    return fftpack.idct(fftpack.idct(x.T).T)\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why do I get a truth value error when doing an nth dimension fast fourier transformation with two arrays?\r\n                \r\nI am fairly new to coding but have been put on a project where i am using 'numpy.fft.fftn' for cross correlation. Most of this work is from translating Matlab code over. This is the part of code  that I am having trouble with:\n```\ndef rot90_3D(T):\n    T=numpy.flip(numpy.flip(numpy.flip(T,0),1),2);\n    return(T)\n\nT_size = [T.shape[0],T.shape[1],T.shape[2]]; I_size = [I.shape[0],I.shape[1],I.shape[2]];\nTI=[]\nfor i in range(0,3,1):\n    TI1=T_size[i]+I_size[i]\n    TI=numpy.append(TI,TI1)\none=numpy.ones((1,3))\noutsize = TI - one;\nFT = numpy.fft.fftn(rot90_3D(T),outsize);\n```\n\nWhen I run this cell cell with my input of T being an array of float32 which is (51,51,51) and the values are all between 0 and 1, most of them being decimals something like 0.131866.\nYet when I run the cell I get this error:\n```\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n```\n\nPlease let me know what I can do to fix this.\nEDIT:\nHere is the full error message:\n```\nTraceback (most recent call last):\n\n  File \"C:\\Users\\Grant\\OneDrive\\Desktop\\SearchParticle Test.py\", line 53, in <module>\n    FT = numpy.fft.fftn(T2,outsize);\n\n  File \"<__array_function__ internals>\", line 5, in fftn\n\n  File \"C:\\Users\\Grant\\anaconda3\\lib\\site-packages\\numpy\\fft\\_pocketfft.py\", line 813, in fftn\n    return _raw_fftnd(a, s, axes, fft, norm)\n\n  File \"C:\\Users\\Grant\\anaconda3\\lib\\site-packages\\numpy\\fft\\_pocketfft.py\", line 705, in _raw_fftnd\n    a = function(a, n=s[ii], axis=axes[ii], norm=norm)\n\n  File \"<__array_function__ internals>\", line 5, in fft\n\n  File \"C:\\Users\\Grant\\anaconda3\\lib\\site-packages\\numpy\\fft\\_pocketfft.py\", line 214, in fft\n    inv_norm = _get_forward_norm(n, norm)\n\n  File \"C:\\Users\\Grant\\anaconda3\\lib\\site-packages\\numpy\\fft\\_pocketfft.py\", line 79, in _get_forward_norm\n    if n < 1:\n\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n```\n\n    ", "Answer": "\r\n```\nIn [94]: T = np.random.rand(10,10,10)\n```\n\nA more direct way of flipping ```\nT```\n:\n```\nIn [95]: t1 = rot90_3D(T)    \nIn [96]: t2 = T[::-1,::-1,::-1]    \nIn [97]: np.allclose(t1,t2)\nOut[97]: True\n```\n\nFor your ```\noutsize```\n:\n```\nIn [98]: I = np.ones((3,3,3))     # sample\n\nIn [99]: T_size = [T.shape[0],T.shape[1],T.shape[2]]; I_size = [I.shape[0],I.shape[1],I.shape[2]];\n    ...: TI=[]\n    ...: for i in range(0,3,1):\n    ...:     TI1=T_size[i]+I_size[i]\n    ...:     TI=numpy.append(TI,TI1)\n    ...: one=numpy.ones((1,3))\n    ...: outsize = TI - one;\n\nIn [100]: outsize\nOut[100]: array([[12., 12., 12.]])\n\nIn [101]: T.shape, I.shape\nOut[101]: ((10, 10, 10), (3, 3, 3))\n```\n\nJust do:\n```\nIn [102]: np.array(T.shape)+np.array(I.shape)-1\nOut[102]: array([12, 12, 12])\n```\n\n```\nT.shape```\n is a tuple; your ```\nT_size```\n is a list version of that.  Arrays can be added without iteration.\nBut a list comprehension also does nicely:\n```\nIn [104]: [i+j-1 for i,j in zip(T.shape, I.shape)]\nOut[104]: [12, 12, 12]\n```\n\nSo far no error.   So the problem must be in the ```\nfft```\n call.\nHere's the full error that you should have shown:\n```\nIn [105]: numpy.fft.fftn(rot90_3D(T),outsize)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nInput In [105], in <cell line: 1>()\n----> 1 numpy.fft.fftn(rot90_3D(T),outsize)\n\nFile <__array_function__ internals>:5, in fftn(*args, **kwargs)\n\nFile ~\\anaconda3\\lib\\site-packages\\numpy\\fft\\_pocketfft.py:815, in fftn(a, s, axes, norm)\n    715 @array_function_dispatch(_fftn_dispatcher)\n    716 def fftn(a, s=None, axes=None, norm=None):\n    717     \"\"\"\n    718     Compute the N-dimensional discrete Fourier Transform.\n    719 \n   (...)\n    813 \n    814     \"\"\"\n--> 815     return _raw_fftnd(a, s, axes, fft, norm)\n\nFile ~\\anaconda3\\lib\\site-packages\\numpy\\fft\\_pocketfft.py:707, in _raw_fftnd(a, s, axes, function, norm)\n    705 itl.reverse()\n    706 for ii in itl:\n--> 707     a = function(a, n=s[ii], axis=axes[ii], norm=norm)\n    708 return a\n\nFile <__array_function__ internals>:5, in fft(*args, **kwargs)\n\nFile ~\\anaconda3\\lib\\site-packages\\numpy\\fft\\_pocketfft.py:214, in fft(a, n, axis, norm)\n    212 if n is None:\n    213     n = a.shape[axis]\n--> 214 inv_norm = _get_forward_norm(n, norm)\n    215 output = _raw_fft(a, n, axis, False, True, inv_norm)\n    216 return output\n\nFile ~\\anaconda3\\lib\\site-packages\\numpy\\fft\\_pocketfft.py:79, in _get_forward_norm(n, norm)\n     78 def _get_forward_norm(n, norm):\n---> 79     if n < 1:\n     80         raise ValueError(f\"Invalid number of FFT data points ({n}) specified.\")\n     82     if norm is None or norm == \"backward\":\n\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n```\n\nTracing this will take some work, but at the core it's testing ```\nn```\n.  ```\nn```\n should be a number, but for some reason it's an array.  What is that ```\nn```\n?\nI haven't used ```\nfft```\n, so am not familiar with the required arguments.\nBut if I call it with without the ```\noutsize```\n, I get a result\n```\nIn [109]: f = numpy.fft.fftn(rot90_3D(T))\nIn [110]: f.shape\nOut[110]: (10, 10, 10)\n```\n\nSo there's something wrong with the way you calculate ```\noutsize```\n.  When you got the error, did you (re)read the ```\nfftn```\n docs - to make sure you use the right arguments?\nGlancing at the docs, I deduced that ```\noutsize```\n could be a simple list of 3 numbers:\n```\nIn [111]: f = numpy.fft.fftn(rot90_3D(T), [12,12,12])\nIn [112]: f.shape\nOut[112]: (12, 12, 12)\n```\n\n```\nnp.array([12,12,12])```\n is also ok.  But a (1,3) array ```\nnp.array([[12,12,12]])```\n produces the error.\nWhen translating MATLAB code, don't try to make everything 2d.  ```\nnumpy```\n arrays can be 1d, and in some cases must be.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Multithreading for convolution calculation\r\n                \r\nI am trying to calculate the convolution product the two pictures from two cameras as fast as possible. The cameras output ~ 17 fps, each frame is ~3MB. The camera manufacturer provides some c/c++ libraries to capture the images, all I need to do is to fourier transform each image, multiply the corresponding fourier transforms and make an inverse transform. What I currently do is I create a buffer and fill it with the frames in one thread, and there are three more threads, two for fourier transforming images from each camera and one for multiplication and calculation of the inverse fourier transforms. \n\nAt certain moment it becomes hard to pair the corresponding frames. I assign unique IDs to each frame when it is created. And when a new frame arrives I check if there are any frames with the same ID from the other camera. At certain moment it becomes hard to tell if it is a new frame in sequence and I need to put it to buffer and wait for the pair, or I've lost too many frames from the other camera and I need to discard this to catch it up.\n\nWhat data types is it better to use and how to organize the data flow? \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Can somebody explain what is a spatially varying kernel?\r\n                \r\nI have performed 2D convolution on image matrix using:\nA. Matrix multiplication B. Fast Fourier Transformation.\nMy question is can I apply any of the above techniques (let's say FFT) for performing convolutions using spatially varying kernel?\nMy understanding is spatially varying kernel is applying different kernel on different parts of an image. But doesn't it violate the basic rule of convolution?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier Transform with Matlab\r\n                \r\nMy question is similar to, but more general than this post, and I think there is a mistake in there regarding normalisation, with the newest version of Matlab (2015) anyway. I hesitated to post this on CodeReview SE, if you think it would be more appropriate let me know in the comments.\n\nI would like to validate the following code of a Fourier transform using Matlab's ```\nfft```\n, because I have found conflicting sources of information on the web, including in the Matlab help itself, and I have been unable to verify Parseval's theorem with certain such \"recipes\" (including with answers coming from the MathWorks team, see below), especially those extracting single-sided spectra for real inputs. \n\nFor instance, the amplitude-doubling commonly found online to account for the symmetric spectra of real-valued signals when extracting positive frequencies only seems to be wrong (Parseval's theorem fails), and instead it seems to be necessary to use a square-root of two coefficient in Matlab (I don't know why). Some people also seem to normalise the DFT coefficients directly like ```\nY = fft(X)/L```\n, but I think this is confusing and should be discouraged; the amplitude is defined as the modulus of the complex DFT coefficient divided by the signal length, the coefficients themselves should not be divided. Once validated I intend to post this code as a gist on GitHub.\n\n```\nfunction [frq,amp,phi] = fourier_transform( time, vals )\n% FOURIER_TRANSFORM computes the Fast Fourier Transform of a given time-series.\n% \n% [freq,amp,phi] = fourier_transform(time,vals)\n%\n% Inputs:\n%\n%   time  - Nx1 column vector of equally-spaced timepoints (if not, input will be resampled).\n%   vals  - NxM matrix of real- or complex-valued observations at previous timepoints.\n%\n% Outputs:\n%\n%   frq   - column vector of frequencies in Hz\n%   amp   - corresponding matrix of amplitudes for each frequency (row) and signal (column)\n%   phi   - corresponding unwrapped phase for each frequency (row) and signal (column)\n%\n% Note:\n%   To compute the power from the output amplitude, you need to multiply by the number of timepoints:\n%       power = numel(time) * amp.^2;\n%\n% References:\n%   https://en.wikipedia.org/wiki/Discrete_Fourier_transform\n\n    % make sure input time-series is uniformly sampled\n    assert( iscolumn(time), 'Input time should be a column vector.' );\n    assert( ismatrix(vals) && size(vals,1) == numel(time), 'Input values should be a matrix with same number of rows than of timepoints.' );\n\n    if std(diff(time)) > 1e-6\n        warning('Input time-course does not appear to be uniformly sampled. Resampling before continuing.');\n        [vals,time] = resample(vals,time);\n    end\n\n    % sampling information\n    nt = numel(time);\n    dt = time(2)-time(1);\n    fs = 1/dt;\n    df = fs/nt;\n\n    % complex spectrum coefficients\n    coef = fft(vals);\n\n    % real input\n    if isreal(vals)\n\n        % extract one-sided spectrum (spectrum is symmetric)\n        nfft = floor( nt/2 + 1 ); % eg 8 -> 5, and 7 -> 4\n        coef = coef( 1:nfft, : );\n        frq  = (0:nfft-1)*df;\n\n        % correct amplitude values to account for previous extraction\n        fac = sqrt(2);\n        amp = fac*abs(coef)/nt;\n        amp(1,:) = amp(1,:)/fac; % .. except for the DC component\n        if mod(nt,2) == 0\n            amp(end,:) = amp(end,:)/fac; % .. and for the Nyquist frequency (only if nt is even)\n        end\n\n    % complex input\n    else\n\n        % shift the spectrum to center frequencies around 0\n        coef = fftshift( coef );\n        frq  = fftshift( (0:nt-1)*df );\n        amp  = abs(coef)/nt;\n\n    end\n\n    % make sure frq is a column vector and compute phases\n    frq = frq(:);\n    phi = unwrap(angle(coef));\n\nend\n```\n\n\n\n\nExample use\n\n```\n>> fs=1e3; t=transpose(0:1/fs:10); nt=numel(t); X=rand(nt,1);\n>> [frq,amp,phi] = fourier_transform( t, X ); \n>> sum( abs(X).^2 ) - nt*sum( amp.^2 ) % Parseval's theorem\n\nans =\n\n  -2.7285e-11\n```\n\n\nWrong example 1\n\nFrom Matlab's own example, and posted on SO:\n\n```\n>> Fs = 1000;                    % Sampling frequency\nT = 1/Fs;                     % Sample time\nL = 1000;                     % Length of signal\nt = (0:L-1)*T;                % Time vector\nx = 0.7*sin(2*pi*50*t) + sin(2*pi*120*t);\ny = x + 2*randn(size(t));     % Sinusoids plus noise\nNFFT = 2^nextpow2(L); % Next power of 2 from length of y\nY = fft(y,NFFT)/L;\nf = Fs/2*linspace(0,1,NFFT/2+1);\n>> sum(abs(y).^2) - NFFT*sum(abs(Y).^2) % Parseval's theorem\n\nans =\n\n -220.4804\n```\n\n\nProblem and solution: \n\nComes from the normalisation in the line ```\nY = fft(y,NFFT)/L```\n. \nThis should be instead:\n\n```\n>> Y = fft(y,NFFT);\nYa = abs(Y)/NFFT; % correctly normalised amplitudes\nsum(abs(y).^2) - NFFT*sum(Ya.^2) % Parseval's theorem\n```\n\n\nWrong example 2\n\nFrom the MathWorks team's own clarification post:\n\n```\n>> Fs = 1000;                    % Sampling frequency\nT = 1/Fs;                     % Sample time\nL = 1000;                     % Length of signal\nt = (0:L-1)*T;                % Time vector\n% Sum of a 50 Hz sinusoid and a 120 Hz sinusoid\nx = 0.7*sin(2*pi*50*t) + sin(2*pi*120*t);\ny = x + 2*randn(size(t));     % Sinusoids plus noise\n\nNFFT = 2^nextpow2(L); % Next power of 2 from length of y\nY = fft(y,NFFT)/L;\nf = Fs/2*linspace(0,1,NFFT/2+1);\n\nNumUniquePts = ceil((NFFT+1)/2);\nY=Y(1:NumUniquePts);\nMX=2*abs(Y);\nMX(1)=MX(1)/2; % DC component\nif ~rem(NFFT,2)  % when NFFT is even, Y(1+Y/2) is the Nyquist frequency component of x, and needs to make sure it is unique.\n    MX(length(MX))=MX(length(MX))/2;\nend\n\n>> sum( abs(y).^2 ) - NFFT*sum( MX.^2 )\n\nans =\n\n  -5.3812e+03\n```\n\n\nProblem and solution:\n\nNormalisation again. Replace ```\nY = fft(y,NFFT)/L;```\n by ```\nY = fft(y,NFFT)```\n, and supposedly ```\nMX=2*abs(Y);```\n by ```\nMX=2*abs(Y)/NFFT;```\n. But here the amplitude doubling problem appears; the correction factor seems to be ```\nsqrt(2)```\n and not ```\n2```\n.\n\nWrong example 3\n\nFound as an answer on MatlabCentral:\n\n```\n>> Fs = 1000;                    % Sampling frequency\nT = 1/Fs;                     % Sample time\nL = 1000;                     % Length of signal\nt = (0:L-1)*T;                % Time vector\nx = 0.7*sin(2*pi*Fs/8*t) + sin(2*pi*Fs/4*t); \nNFFT = 2^nextpow2(L); % Next power of 2 from length of y\nY = fft(x,NFFT)/L;\nf = Fs/2*linspace(0,1,NFFT/2+1);\n>> sum( abs(x).^2 ) - NFFT*sum( abs(Y).^2 )\n\nans =\n\n  -36.1891\n```\n\n\nProblem and solution:\n\nAs in the first example, normalisation problem. Write instead:\n\n```\nY  = fft(x,NFFT);\nYa = abs(Y)/NFFT;\nsum( abs(x).^2 ) - NFFT*sum( abs(Ya).^2 )\n```\n\n    ", "Answer": "\r\nTL;DR (summary)\n\nIt is very hard to find online examples of ```\nfft```\n usage with Matlab that normalise the amplitude/power values correctly (e.g. as can be verified with Parseval's theorem). This is crucial if you want to compare spectra between signals with different lengths. There is also an additional problem with real-valued signals because in that case the spectrum is often computed for positive frequency only, and therefore amplitude or power values need to be scaled to account for frequency-folding. Following the post and answers below, here is a gist which I think scales the coeffcients correctly and consistently for real- and complex-valued inputs.\n\nThe take home messages are:\n\n\nDo NOT normalise the DFT coefficients directly (eg don't write ```\nY = fft(x)/L```\n);\nIf you use an n-points transform (eg ```\nfft(x,nfft)```\n), then the normaliser is ```\nnfft```\n and not ```\nnumel(x)```\n;\nIf you extract a single-sided spectrum, you need to adjust amplitude/power values depending on which correspond to conjugate pairs DFT coefficients;\nIf you extract a single-sided spectrum, you should compute the amplitude and power separately (ie don't compute the power from the amplitudes).\n\n\n\n\nAmplitude, power and single-sided spectra\n\nAs defined and explained on Wikipedia:\n\n\nThe DFT coefficients are complex and not normalised, while the formula for the inverse DFT carries a ```\n1/N```\n factor in front of the sum. This is natural in some sense, as moving in time-to-frequency direction can be seen as a projection onto a basis of (orthogonal) waves with different frequencies, whereas moving in frequency-to-time direction can be seen as a weighted superposition of waves.\nIn that superposition, the overall magnitude should be that of the original time-point (ie, it's an inversion), and the amplitude of each wave in that weighted average is simply the magnitude of the corresponding DFT coefficient divided by the number of waves ```\n|Xk| / N```\n. Similarly, the power of each wave is ```\n|Xk|^2 / N```\n. Matlab uses that normalisation too (well, FFTW does).\nFor real-valued inputs, the DFT coefficients are conjugate pairs for corresponding positive/negative frequencies, apart from the DC component (average term, frequency 0), and for the Nyquist frequency when the number of time-points is even. In practice, most applications avoid this redundancy by extracting the DFT coefficients only for positive frequencies. This leads to complications in the discrete values of the amplitude and power.\nThe amplitudes corresponding to paired DFT coefficients (all except the first one and the Nyquist frequency when it exists) can simply be doubled and the negative frequency then discarded. Same for the power.\nSimilarly for the power, but note that it is incorrect in that case to compute the discrete power values using the adjusted amplitude values. Indeed ```\nN * amp_adjusted[k]^2 = N * (2*|Xk|/N)^2```\n is not equal to ```\n2*|Xk|^2 / N```\n (this is where the square-root of two came from in the OP). Therefore it is necessary to compute independently the amplitude and power values from the DFT coefficients (another good reason not to scale them).\n\n\nN-points Transform\n\nMany of the examples online use an explicit N-points transform: ```\nY = fft(x,NFFT)```\n where ```\nNFFT```\n is typically a power of 2, making the computation more efficient with FFTW.\n\nThe effective difference in that case (provided that ```\nNFFT >= N```\n) is that ```\nx```\n is padded with 0 at its end until it reaches the length of NFFT time-points. This means that the number of frequencies in the decomposition changes, and therefore the normalisation should be done relative to ```\nNFFT```\n wave components, and not the original ```\nN```\n time-points.\n\nHence, almost all of the examples found online are wrong in the way they normalise the coefficients. It should not be ```\nY = fft(x,NFFT)/N```\n, but ```\nY = fft(x,NFFT)/NFFT```\n -- yet another good reason to loose that habit of normalising complex coefficients. \n\nNote that this makes no difference then to Parseval's equality, because the added terms in the time-domain are all zero, and therefore their contribution to the now-larger sum is zero too. In the frequency domain though, the added discrete frequencies will have a response to the original signal in general, which gives an intuitive sense of why the obtained coefficients can be quite different indeed between the padded and unpadded transforms.\n\nCode\n\nThe code in the OP is therefore incorrect, and instead it appears to be necessary to output both the amplitude and power, as there is no general normalisation coefficient that could accommodate the complex and real cases, with even or odd number of time-points. You can find the Gist here.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier Transform with Matlab\r\n                \r\nMy question is similar to, but more general than this post, and I think there is a mistake in there regarding normalisation, with the newest version of Matlab (2015) anyway. I hesitated to post this on CodeReview SE, if you think it would be more appropriate let me know in the comments.\n\nI would like to validate the following code of a Fourier transform using Matlab's ```\nfft```\n, because I have found conflicting sources of information on the web, including in the Matlab help itself, and I have been unable to verify Parseval's theorem with certain such \"recipes\" (including with answers coming from the MathWorks team, see below), especially those extracting single-sided spectra for real inputs. \n\nFor instance, the amplitude-doubling commonly found online to account for the symmetric spectra of real-valued signals when extracting positive frequencies only seems to be wrong (Parseval's theorem fails), and instead it seems to be necessary to use a square-root of two coefficient in Matlab (I don't know why). Some people also seem to normalise the DFT coefficients directly like ```\nY = fft(X)/L```\n, but I think this is confusing and should be discouraged; the amplitude is defined as the modulus of the complex DFT coefficient divided by the signal length, the coefficients themselves should not be divided. Once validated I intend to post this code as a gist on GitHub.\n\n```\nfunction [frq,amp,phi] = fourier_transform( time, vals )\n% FOURIER_TRANSFORM computes the Fast Fourier Transform of a given time-series.\n% \n% [freq,amp,phi] = fourier_transform(time,vals)\n%\n% Inputs:\n%\n%   time  - Nx1 column vector of equally-spaced timepoints (if not, input will be resampled).\n%   vals  - NxM matrix of real- or complex-valued observations at previous timepoints.\n%\n% Outputs:\n%\n%   frq   - column vector of frequencies in Hz\n%   amp   - corresponding matrix of amplitudes for each frequency (row) and signal (column)\n%   phi   - corresponding unwrapped phase for each frequency (row) and signal (column)\n%\n% Note:\n%   To compute the power from the output amplitude, you need to multiply by the number of timepoints:\n%       power = numel(time) * amp.^2;\n%\n% References:\n%   https://en.wikipedia.org/wiki/Discrete_Fourier_transform\n\n    % make sure input time-series is uniformly sampled\n    assert( iscolumn(time), 'Input time should be a column vector.' );\n    assert( ismatrix(vals) && size(vals,1) == numel(time), 'Input values should be a matrix with same number of rows than of timepoints.' );\n\n    if std(diff(time)) > 1e-6\n        warning('Input time-course does not appear to be uniformly sampled. Resampling before continuing.');\n        [vals,time] = resample(vals,time);\n    end\n\n    % sampling information\n    nt = numel(time);\n    dt = time(2)-time(1);\n    fs = 1/dt;\n    df = fs/nt;\n\n    % complex spectrum coefficients\n    coef = fft(vals);\n\n    % real input\n    if isreal(vals)\n\n        % extract one-sided spectrum (spectrum is symmetric)\n        nfft = floor( nt/2 + 1 ); % eg 8 -> 5, and 7 -> 4\n        coef = coef( 1:nfft, : );\n        frq  = (0:nfft-1)*df;\n\n        % correct amplitude values to account for previous extraction\n        fac = sqrt(2);\n        amp = fac*abs(coef)/nt;\n        amp(1,:) = amp(1,:)/fac; % .. except for the DC component\n        if mod(nt,2) == 0\n            amp(end,:) = amp(end,:)/fac; % .. and for the Nyquist frequency (only if nt is even)\n        end\n\n    % complex input\n    else\n\n        % shift the spectrum to center frequencies around 0\n        coef = fftshift( coef );\n        frq  = fftshift( (0:nt-1)*df );\n        amp  = abs(coef)/nt;\n\n    end\n\n    % make sure frq is a column vector and compute phases\n    frq = frq(:);\n    phi = unwrap(angle(coef));\n\nend\n```\n\n\n\n\nExample use\n\n```\n>> fs=1e3; t=transpose(0:1/fs:10); nt=numel(t); X=rand(nt,1);\n>> [frq,amp,phi] = fourier_transform( t, X ); \n>> sum( abs(X).^2 ) - nt*sum( amp.^2 ) % Parseval's theorem\n\nans =\n\n  -2.7285e-11\n```\n\n\nWrong example 1\n\nFrom Matlab's own example, and posted on SO:\n\n```\n>> Fs = 1000;                    % Sampling frequency\nT = 1/Fs;                     % Sample time\nL = 1000;                     % Length of signal\nt = (0:L-1)*T;                % Time vector\nx = 0.7*sin(2*pi*50*t) + sin(2*pi*120*t);\ny = x + 2*randn(size(t));     % Sinusoids plus noise\nNFFT = 2^nextpow2(L); % Next power of 2 from length of y\nY = fft(y,NFFT)/L;\nf = Fs/2*linspace(0,1,NFFT/2+1);\n>> sum(abs(y).^2) - NFFT*sum(abs(Y).^2) % Parseval's theorem\n\nans =\n\n -220.4804\n```\n\n\nProblem and solution: \n\nComes from the normalisation in the line ```\nY = fft(y,NFFT)/L```\n. \nThis should be instead:\n\n```\n>> Y = fft(y,NFFT);\nYa = abs(Y)/NFFT; % correctly normalised amplitudes\nsum(abs(y).^2) - NFFT*sum(Ya.^2) % Parseval's theorem\n```\n\n\nWrong example 2\n\nFrom the MathWorks team's own clarification post:\n\n```\n>> Fs = 1000;                    % Sampling frequency\nT = 1/Fs;                     % Sample time\nL = 1000;                     % Length of signal\nt = (0:L-1)*T;                % Time vector\n% Sum of a 50 Hz sinusoid and a 120 Hz sinusoid\nx = 0.7*sin(2*pi*50*t) + sin(2*pi*120*t);\ny = x + 2*randn(size(t));     % Sinusoids plus noise\n\nNFFT = 2^nextpow2(L); % Next power of 2 from length of y\nY = fft(y,NFFT)/L;\nf = Fs/2*linspace(0,1,NFFT/2+1);\n\nNumUniquePts = ceil((NFFT+1)/2);\nY=Y(1:NumUniquePts);\nMX=2*abs(Y);\nMX(1)=MX(1)/2; % DC component\nif ~rem(NFFT,2)  % when NFFT is even, Y(1+Y/2) is the Nyquist frequency component of x, and needs to make sure it is unique.\n    MX(length(MX))=MX(length(MX))/2;\nend\n\n>> sum( abs(y).^2 ) - NFFT*sum( MX.^2 )\n\nans =\n\n  -5.3812e+03\n```\n\n\nProblem and solution:\n\nNormalisation again. Replace ```\nY = fft(y,NFFT)/L;```\n by ```\nY = fft(y,NFFT)```\n, and supposedly ```\nMX=2*abs(Y);```\n by ```\nMX=2*abs(Y)/NFFT;```\n. But here the amplitude doubling problem appears; the correction factor seems to be ```\nsqrt(2)```\n and not ```\n2```\n.\n\nWrong example 3\n\nFound as an answer on MatlabCentral:\n\n```\n>> Fs = 1000;                    % Sampling frequency\nT = 1/Fs;                     % Sample time\nL = 1000;                     % Length of signal\nt = (0:L-1)*T;                % Time vector\nx = 0.7*sin(2*pi*Fs/8*t) + sin(2*pi*Fs/4*t); \nNFFT = 2^nextpow2(L); % Next power of 2 from length of y\nY = fft(x,NFFT)/L;\nf = Fs/2*linspace(0,1,NFFT/2+1);\n>> sum( abs(x).^2 ) - NFFT*sum( abs(Y).^2 )\n\nans =\n\n  -36.1891\n```\n\n\nProblem and solution:\n\nAs in the first example, normalisation problem. Write instead:\n\n```\nY  = fft(x,NFFT);\nYa = abs(Y)/NFFT;\nsum( abs(x).^2 ) - NFFT*sum( abs(Ya).^2 )\n```\n\n    ", "Answer": "\r\nTL;DR (summary)\n\nIt is very hard to find online examples of ```\nfft```\n usage with Matlab that normalise the amplitude/power values correctly (e.g. as can be verified with Parseval's theorem). This is crucial if you want to compare spectra between signals with different lengths. There is also an additional problem with real-valued signals because in that case the spectrum is often computed for positive frequency only, and therefore amplitude or power values need to be scaled to account for frequency-folding. Following the post and answers below, here is a gist which I think scales the coeffcients correctly and consistently for real- and complex-valued inputs.\n\nThe take home messages are:\n\n\nDo NOT normalise the DFT coefficients directly (eg don't write ```\nY = fft(x)/L```\n);\nIf you use an n-points transform (eg ```\nfft(x,nfft)```\n), then the normaliser is ```\nnfft```\n and not ```\nnumel(x)```\n;\nIf you extract a single-sided spectrum, you need to adjust amplitude/power values depending on which correspond to conjugate pairs DFT coefficients;\nIf you extract a single-sided spectrum, you should compute the amplitude and power separately (ie don't compute the power from the amplitudes).\n\n\n\n\nAmplitude, power and single-sided spectra\n\nAs defined and explained on Wikipedia:\n\n\nThe DFT coefficients are complex and not normalised, while the formula for the inverse DFT carries a ```\n1/N```\n factor in front of the sum. This is natural in some sense, as moving in time-to-frequency direction can be seen as a projection onto a basis of (orthogonal) waves with different frequencies, whereas moving in frequency-to-time direction can be seen as a weighted superposition of waves.\nIn that superposition, the overall magnitude should be that of the original time-point (ie, it's an inversion), and the amplitude of each wave in that weighted average is simply the magnitude of the corresponding DFT coefficient divided by the number of waves ```\n|Xk| / N```\n. Similarly, the power of each wave is ```\n|Xk|^2 / N```\n. Matlab uses that normalisation too (well, FFTW does).\nFor real-valued inputs, the DFT coefficients are conjugate pairs for corresponding positive/negative frequencies, apart from the DC component (average term, frequency 0), and for the Nyquist frequency when the number of time-points is even. In practice, most applications avoid this redundancy by extracting the DFT coefficients only for positive frequencies. This leads to complications in the discrete values of the amplitude and power.\nThe amplitudes corresponding to paired DFT coefficients (all except the first one and the Nyquist frequency when it exists) can simply be doubled and the negative frequency then discarded. Same for the power.\nSimilarly for the power, but note that it is incorrect in that case to compute the discrete power values using the adjusted amplitude values. Indeed ```\nN * amp_adjusted[k]^2 = N * (2*|Xk|/N)^2```\n is not equal to ```\n2*|Xk|^2 / N```\n (this is where the square-root of two came from in the OP). Therefore it is necessary to compute independently the amplitude and power values from the DFT coefficients (another good reason not to scale them).\n\n\nN-points Transform\n\nMany of the examples online use an explicit N-points transform: ```\nY = fft(x,NFFT)```\n where ```\nNFFT```\n is typically a power of 2, making the computation more efficient with FFTW.\n\nThe effective difference in that case (provided that ```\nNFFT >= N```\n) is that ```\nx```\n is padded with 0 at its end until it reaches the length of NFFT time-points. This means that the number of frequencies in the decomposition changes, and therefore the normalisation should be done relative to ```\nNFFT```\n wave components, and not the original ```\nN```\n time-points.\n\nHence, almost all of the examples found online are wrong in the way they normalise the coefficients. It should not be ```\nY = fft(x,NFFT)/N```\n, but ```\nY = fft(x,NFFT)/NFFT```\n -- yet another good reason to loose that habit of normalising complex coefficients. \n\nNote that this makes no difference then to Parseval's equality, because the added terms in the time-domain are all zero, and therefore their contribution to the now-larger sum is zero too. In the frequency domain though, the added discrete frequencies will have a response to the original signal in general, which gives an intuitive sense of why the obtained coefficients can be quite different indeed between the padded and unpadded transforms.\n\nCode\n\nThe code in the OP is therefore incorrect, and instead it appears to be necessary to output both the amplitude and power, as there is no general normalisation coefficient that could accommodate the complex and real cases, with even or odd number of time-points. You can find the Gist here.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Extracting time at which frequencies occur\r\n                \r\nI take a song sample and perform the FFT (fast Fourier transformation) on the sample. I am able to get the frequencies of the song, but I am not able to get the time at which those frequencies occur. So, it basically becomes useless as I have to match it with different sample unless I get the information of time out of it. \n\nHow do I proceed?\n    ", "Answer": "\r\nYou need to break up the sample into multiple smaller timeslices, and FFT each slice. Each FFT result gives you the average frequency content over that slice of time. This is commonly called a Spectrogram\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Low pass signal filtering using FFT or simple infinite impulse response filter [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am currently in need for filtering accelerometer data for an Android application.\nFirst of all, I used a simple low-pass filter (simple infinite impulse response filter) as follows:\n\n```\nfor i from 1 to n\n   y[i] := y[i-1] + α * (x[i] - y[i-1])\n```\n\n\nThis helped me achieve a smoother result.\n\nThen I decided to play with FFTs. I used a fast-fourier transform to get the signal into frequency domain and then zeroed some of the high frequencies. Then using inverse fourier transform I recreated the signal. This all worked fine and I know that the FFT and IFT implementations are fine. However, the signal wasn't as smooth as the one that I got from before using the simple infinite impulse response filter. I tried zeroing some further frequencies but didn't give me as good of a result as expected.\n\nWhat is the reason behind this? I though using FFTs and IFT should technically give me a nice smooth graphs. Is this because of the sampling in FFT?\n\nThanks\n    ", "Answer": "\r\nThe problem is that you zeroed out the specter, it cannot be zeroed out completely it needs to be a smooth curve in the frequency specter in order for it to hold in the time domain. You will probably hear some kind of feedback on top of your sound and that is the time domain not cooping with the sudden stop in the frequency.\nMathematically you can see it in the fft i took of the value 1 here in wolfram.\n1 is an infinite long function in the time domain and it is always 1. \nThe fft of 1 is a dirac delta function sqrt(2*pi) and that is the same as an infinite stop in the frequency band. As you see the time domain is infinite long when the frequency is infinite short. And that is why you cannot go to a complete stop in the filter you have created.\n\nI suggest you read up on digital filter design if you want more theory. A fast fix is to accept some db ouput on the frequency you are trying to eliminate. Something like the picture here\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What are the principles behind acoustic fingerprinting?\r\n                \r\nWhat kind of API's or frameworks are used to assign a note of music a value? Like how would an application like Shazzam take in a note from the microphone and know what to do with it? \nTo me it's amazing a phones microphone and some nifty logic can compete with a tuner from a music shop! \n\nEdit 1. \n\nInteresting papers on the subject.\nShazzam the music recognition app's software\n rests on the \nprinciple of Acoustic fingerprinting and a Fast Fourier Transform \n\nHere's an example some similar code in practice\n    ", "Answer": "\r\nAcoustic fingerprinting algorithms do not try to analyze the music. That is, they do not convert audio from the microphone to notes. They are extracting some arbitrary features from the audio, that do not make much sense from musical theory perspective, but they are still useful for identifying music.\n\nNormally, you start with a spectrogram. A spectrogram is analysis of frequencies as they change over time. That's common for almost all acoustic fingerprinting algorithms. The differ in what they do with the spectrogram and what kind of features do they extract from it. Some algorithms are looking for peaks in the spectrogram, some chunk it into regular intervals. The end goal is usually to generate a bunch of hashes that you can index and  quickly search.\n\nThe original Shazam algorithm by Avery Li-Chun Wang is publicly available. You can find the details here.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "MATLAB Code Clarification\r\n                \r\nI recently visited this page in order to determine the frequency from signal data in MATLAB: \n\nDetermine frequency from signal data in MATLAB \n\nAnd in this page, an answerer responded with the following code: \n\n```\n[maxValue,indexMax] = max(abs(fft(signal-mean(signal)))); \n```\n\n\n\n\nFrom what I can see, a Fast Fourier Transform is taken on a signal named ```\nsignal```\n, its magnitude is kept by using 'abs', and the max value is computed. The max value will be in ```\nmaxValue```\n, and the ```\nindexMax```\n will contain the position of the ```\nmaxValue```\n. However, can someone explain what is meant by ```\nsignal-mean```\n, and what the purpose of it? \n    ", "Answer": "\r\nIt basically normalize the vector ```\nsignal```\n so it has mean zero (subtracts the mean from ```\nsignal```\n). So ```\nsignal```\n - ```\nmean(signal)```\n looks like ```\nsignal```\n except that is shifted on the ```\ny```\n axis so it has a zero mean. Hope it is clear.\n\nIn the example you posted in the link, the mean of the signal is around ```\n-2```\n, so by subtracting the mean you end up with a the signal shifted up around the ```\ny=0```\n axis.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How can I convert FFT results for real-world times series analysis?\r\n                \r\nI have a dataset containing the daily sum of news articles for specific topics since 1995 (for this example, I'm trying to analyze the topic \"Soccer, Football\"). I am trying to use the fast fourier transform (fft) but am not sure how to interpret the results. How am I supposed to convert the frequency to a daily scale?\n\n```\nfrom scipy.fftpack import fft\nN = 8335 # lenth of times series (days)\n# Nyquist Sampling Criteria\nT = 1/8335 # inverse of the sampling rate\nx = np.linspace(0.0, 1.0/(2.0*T), int(N/2))\n\n# FFT algorithm\nyr = fft(array) # \"raw\" FFT with both + and - frequencies\ny = 2/N * np.abs(yr[0:np.int(N/2)]) # positive freqs only\n\n# Plotting the results\nplt.plot(x, y)\nplt.figsize=(25,10)\nplt.ylim(0,.08)\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('Vibration (g)')\nplt.title('Soccer,Football');\n```\n\n\nThe results:\nSee here 3 spikes in the power spectrum but in audio frequency terms\n\nHow can I convert the three frequencies to understand the lengths of the cycles in days?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Find FFT and summation in 4D matrix\r\n                \r\nPlease, I have ```\nF(8*409600*3)```\n  matrix. I want to reshape it into ```\nB(8*512*3*800)```\n matrix (each row should divide into ```\n800```\n parts) then I have to find Fast Fourier transform```\n(FFT)```\n for each ```\n(8*512)```\n rows and multiply it by its conjugate and divide by a constant  after that I have to find summation of elements of each row in fourth dimension and average them by the number of slices within the fourth dimension ```\n(800)```\n. I mean\n\n```\n(B(1,1,1,1) +B(1,1,1,2)+B(1,1,1,3)……+B(1,1,1,800))/800\n(B(1,2,1,1) +B(1,2,1,2)+B(1,2,1,3)……+B(1,2,1,800))/800\n```\n\n\nAnd so on for each row. \n\nI used below code it seems work but does not give a correct result.\n\n```\n F=rand(8,409600,3);\n B=reshape(F,8,512,3,[]);\n C1=fft(B, [],2);\n C2=C1.*conj(C1);\n C3=C2/(3000);\n C4=sum(C3,4)/800;\n```\n\n\nThanks\n    ", "Answer": "\r\nI think you want to try ```\nB = reshape(F, 8, 512, [], 3);```\n to get 8 by 512 by 800 by 3 array.\n\nThen do ```\nC1 = abs(fft(B, [], 2)).^2;```\n to take the 512-point FFT and convert the spectrum to a power spectrum. (Note that for complex ```\nc```\n, ```\nconj(c) * c == abs(c)^2```\n to machine precision.)\n\nThen you want to average those 800 512-point PSDs: ```\nC2 = squeeze(mean(C1, 3));```\n. If you don’t use ```\nsqueeze```\n here, you’ll have 8 by 512 by 1 by 3 array, and ```\nsqueeze```\n just eliminates the 1-length dimensions, leaving ```\nC2```\n to be a 8 by 512 by 3 array.  I prefer to use ```\nmean```\n here instead of sum and divide because it’s more obvious what you’re trying to achieve.\n\nFinally, you seem to have a ```\n3000```\n factor, so: ```\nC3 = C2 / 3000;```\n.\n\n\n\nHere’s how I’m thinking about your problem. You have eight sensors (microphone, photodiode, whatever). Each sensor collects 409600 samples. You do this for three days. So you have your original ```\nF```\n matrix that’s 8 by 409600 by 3.\n\nNow, you want to see how the power spectral density changes for each sensor over the three days. So you split up each sensor/day’s 409600 samples into 800 chunks, and each chunk gets 512 samples—no overlap between chunks. In the code above, you take each 512-long chunk’s FFT and average all 800 of them. This leaves you with a 8 by 512 by 3 array, and you now have what you wanted: an estimate of each sensor’s PSD for each day.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Storing an array of references to arrays\r\n                \r\nI want to create an array of references to my arrays. The reason for this is because i want to optimise my fast Fourier transform algorithm to be branchless - or rather, less branchy.\nThe idea behind it is i have two arrays:\n```\nArray1```\n and ```\nArray2```\n\nI need to ping pong between the two in a for loop so i want to store the reference to the arrays like this:\n```\n[0] = Array1Ref\n[1] = Array2Ref\n[2] = Array1Ref\n. . .\n```\n\nIs it possible to do this in C#? If so how would you define such an array - would i need to use unsafe ?\n    ", "Answer": "\r\nIf you just want to access a different array in each iteration of the for loop without using a conditional, you can keep swapping two variables and use one of them.\n```\nvar arrayRef = Array1;\nvar theOtherArrayRef = Array2;\nfor (...) {\n    // use arrayRef in places where you would have accessed the array of array references\n    \n    ...\n\n    // C# 7 tuple syntax\n    (arrayRef, theOtherArrayRef) = (theOtherArrayRef, arrayRef);\n\n    // pre-C# 7:\n    /*\n    var temp = arrayRef;\n    arrayRef = theOtherArrayRef;\n    theOtherArrayRef = arrayRef;\n    */\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Image Enhancement using FFT in java\r\n                \r\nI am working on fingerprint image enhancement with Fast Fourier Transformation. I got the idea from this site. \n\nI have implemented the ```\nFFT```\n function using 32*32 window, and after that as the referral site suggested, I want to multiply ```\npower spectrum```\n with the ```\nFFT```\n. But I do not get,\n\nHow do I calculate Power Spectrum for an image? Or is there any ideal value for Power Spectrum ?\n\nCode for FFT:\n\n```\npublic FFT(int[] pixels, int w, int h) {\n    // progress = 0;\n    input = new TwoDArray(pixels, w, h);\n    intermediate = new TwoDArray(pixels, w, h);\n    output = new TwoDArray(pixels, w, h);\n    transform();\n}\n\n  void transform() {\n    for (int i = 0; i < input.size; i+=32) {\n        for(int j = 0; j < input.size; j+=32){\n\n            ComplexNumber[] cn = recursiveFFT(input.getWindow(i,j));\n            output.putWindow(i,j, cn);\n        }\n    }\n    for (int j = 0; j < output.values.length; ++j) {\n        for (int i = 0; i < output.values[0].length; ++i) {\n            intermediate.values[i][j] = output.values[i][j];\n            input.values[i][j] = output.values[i][j];\n        }\n    }\n}\n\nstatic ComplexNumber[] recursiveFFT(ComplexNumber[] x) {\n int N = x.length;\n    // base case\n    if (N == 1) return new ComplexNumber[] { x[0] };\n\n    // radix 2 Cooley-Tukey FFT\n    if (N % 2 != 0) { throw new RuntimeException(\"N is not a power of 2\"); }\n\n    // fft of even terms\n    ComplexNumber[] even = new ComplexNumber[N/2];\n    for (int k = 0; k < N/2; k++) {\n        even[k] = x[2*k];\n    }\n    ComplexNumber[] q = recursiveFFT(even);\n\n    // fft of odd terms\n    ComplexNumber[] odd  = even;  // reuse the array\n    for (int k = 0; k < N/2; k++) {\n        odd[k] = x[2*k + 1];\n    }\n    ComplexNumber[] r = recursiveFFT(odd);\n\n    // combine\n    ComplexNumber[] y = new ComplexNumber[N];\n    for (int k = 0; k < N/2; k++) {\n        double kth = -2 * k * Math.PI / N;\n        ComplexNumber wk = new ComplexNumber(Math.cos(kth), Math.sin(kth));\n        ComplexNumber tmp = ComplexNumber.cMult(wk, r[k]);\n        y[k] = ComplexNumber.cSum(q[k], tmp);\n\n        ComplexNumber temp = ComplexNumber.cMult(wk, r[k]);\n        y[k + N/2] = ComplexNumber.cDif(q[k], temp);\n    }\n    return y;\n}\n```\n\n    ", "Answer": "\r\nI'm thinking that the power spectrum is the square of the output of the Fourier transform.  \n\n```\npower@givenFrequency = x(x*) where x* is the complex conjugate\n```\n\n\nThe total power in the image block would then be the sum over all frequency and space.\n\nI have no idea if this helps.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Is there a method of FFT that will run inside CUDA Kernel?\r\n                \r\nI am currently converting a C++ program into CUDA code, and part of my program runs a fast Fourier transform. Originally I ran FFTW, but I saw that I couldn't call it in kernel, so I then rewrote that  part using cufft but it tells me the same thing!\n\nAre there any FFT that will run inside a CUDA kernel?\n\nCan I just add ```\n__device__```\n to the fftw library?\n\nI would like to avoid having to initialize or call the FFT in host. I want a completely on the gpu type function, if one exists.\n    ", "Answer": "\r\nLooks like you are trying to perform several FFTs at once if you are looking to incorporate it into a kernel. I would look into the batch processing features in cuFFT. What is your application? cufftPlanMany() works for batch FFTs in many different memory configurations.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Sympy Simplify eliminate imaginary numbers\r\n                \r\nI'm trying to get the cosine similarity between convolved vectors. Because I'm using fast fourier transform, I am using complex numbers. In the calculation of the cosine similarity, the final value returned should be a real number. However, my output is including imaginary parts: ```\n1.0*(-1.53283653303955 + 6.08703605256546e-17*I)/(sqrt(5.69974497311137 + 5.55111512312578e-17*I)*sqrt(14.2393958011541 - 3.46944695195361e-18*I))```\n\n\nThe imaginary portions should be zero (which they effectively are), but I can't get sympy to set the imaginary portions to zero so that I can get a real value as my output.\n\nI've included the code that leads to the output. It's as pared down as I can accomplish.\n\n```\n# import statements\nfrom sympy import *\nfrom numpy import dot,array,random\n\n# sympy initialization\na, b, c, d, e, f, g, h, i, j, k, l = symbols('a b c d e f g h i j k l')\n\n# vector initialization\nalpha = [a, b, c, d];\nbeta = [e, f, g, h];\ngamma = [i, j, k, l];\n\n# discrete fourier initialization (dft/idft)\nW = [[1, 1, 1, 1], [1, -1j, -1, 1j], [1, -1, 1, -1], [1, 1j, -1, -1j]];\nWH = [[1, 1, 1, 1], [1, 1j, -1, -1j], [1, -1, 1, -1], [1, -1j, -1, 1j]];\n\n# i/fft initialization, cosine similarity\ndef fft(a):\n    return dot(a,W)\ndef ifft(a):\n    return dot(a,WH)/4.0\ndef cosineSimilarity(a,b):\n    return dot(a,b)/(sqrt(dot(a,a)) * sqrt(dot(b,b)))\n\n# x&y initialization\nx = ifft(fft(alpha)*fft(beta)) + ifft(fft(alpha)*fft(gamma));\ny = ifft(fft(alpha)*fft(beta)/fft(gamma)) +             \nifft(fft(alpha)*fft(gamma)/fft(beta));\n\n# determine cosine similarity between x&y\nrandom.seed(39843)\ncurrent = random.rand(12)\nmymap = list(zip(params,current))\nprint(simplify(diff(cosineSimilarity(x, y), a).subs(mymap)))\n```\n\n    ", "Answer": "\r\nIf you know the imaginary part is 0 then you can just take the real part of the evaluation, else use \"chop=True\" with caution to discard relatively small imaginary parts:\n\n```\n>>> q\n(-1.53283653303955 + 6.08703605256546e-17*I)/(sqrt(5.69974497311137 + \n5.55111512312578e-17*I)*sqrt(14.2393958011541 - 3.46944695195361e-18*I))\n>>> q.n(chop=True)\n-0.170146237401735\n>>> re(q.n())\n-0.170146237401735\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Matlab: Extract Image in polar representation from Cartesian\r\n                \r\nI m trying to compute an efficient way to transform an image in cartesian coordinates into a polar representation. I know some functions such as ImToPolar are doing it and it works perfectly but takes a considerable much time for big images, especially when they require to be processed back and forth.\n\nHere´s my input image:\n\n\n\nand then I generate a polar mesh using a cartesian mesh centered at 0 and the function ```\ncart2pol()```\n. Finally, I plot my image using ```\nmesh(theta, r, Input)```\n.\n\nAnd here´s what I obtain:\n\n\n\nIts exactly the image I need and it´s the same as ```\nImToPolar```\n or maybe better.\n\nSince MATLAB knows how to compute it, does anybody know how to extract a matrix in polar representation from this output? Or maybe a fast (like in fast fourier transform) way to compute a Polar transform (and inverse) on MATLAB? \n    ", "Answer": "\r\n```\npol2cart```\n and ```\nmeshgrid```\n and ```\ninterp2```\n are sufficient to create the result:\n\n```\nI=imread('https://i.stack.imgur.com/HYSyb.png');\n[r, c,~] = size(I);\n%rgb image can be converted to indexed image to prevent excessive copmutation for each color\n[idx, mp] = rgb2ind(I,32);\n% add offset to image coordinates\nx = (1:c)-(c/2);\ny = (1:r)-(r/2);\n% create distination coordinates in polar form so value of image can be interpolated in those coordinates\n% angle ranges from 0 to 2 * pi and radius assumed that ranges from 0 to 400\n% linspace(0,2*pi, 200) leads to a stretched image try it!\n[xp yp] = meshgrid(linspace(0,2*pi), linspace(0,400));\n%translate coordinate from polar to image coordinates\n[xx , yy] = pol2cart(xp,yp);\n% interpolate pixel values for unknwon coordinates\nout = interp2(x, y, idx, xx, yy);\n% save the result to a file\nimwrite(out, mp, 'result.png')\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How can I save and reuse the results of the FFT applied on an image to calcuate the bessel potential?\r\n                \r\nPlease can you help me correcting this code? I want to save the result of the Fast Fourier Transform of each image apart so I can reuse the proper coefficients for every band of wave I get from the FFT to calculate the bessel potential of the function?\nMy code is below,\n\n```\nclc;\nclose all;\nimagefiles = dir('*.jpg'); %any jpg file found in the folder\nnfiles = length(imagefiles);    % Number of image files found\nstored_values = cell(1,nfiles); % Preallocate the array for saving the values\n\nfor ii=1:nfiles\n\n    currentfilename = imagefiles(ii).name;\n    I = imread(currentfilename);\n    myimage = rgb2gray(I);\n    Y = fft2(myimage)\n    fftMagnitude = abs(fftshift(Y))\n    stored_values{ii}=fftMagnitude %store values of fft\n\n    syms Y\n    A = [-1, pi; Y, 0];\n    J = besselj((1/2), A)\n    stored_values{ii}=J  %save the besselj result in another cell ??\n\nend\n```\n\n\nThe code runs correctly but it's not giving numbers in arrays it's just showing the dimension of the image so I think that I'm mistaking the way of saving and calling the datas again.\nCan you please help? \nThank you.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to replay recorded FFT samples?\r\n                \r\nI record FFT (\"Fast Fourier Transform\") samples from audio like this:\n\n```\n const no_samples = 100;\n\n const samples = [];\n for (let i = 0, l = no_samples; i < l; ++i) {\n     samples.push({ sample: new Uint8Array(this.sampleSize), time:-1 });\n }\n var lambdaToRemove = null;\n\n let samplesDone = 0;\n let start = -1;\n let second = 0;\n\n this.scriptProcessor.addEventListener(\"audioprocess\", lambdaToRemove =\n /**\n  * @param {AudioProcessingEvent} event\n  * */\n     (event) => {\n         // firefox provides data even before user allows acces to microphone\n         if (!this.mediaAllocated) {\n             console.log(\"Sample before media was allocated!\");\n             return;\n         }\n\n         // AudioAnalyser - https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode\n         this.analyser.getByteFrequencyData(samples[samplesDone].sample);\n         ++samplesDone;\n\n         if (samplesDone >= no_samples) {\n             this.scriptProcessor.removeEventListener(\"audioprocess\", lambdaToRemove);\n             resolve(samples);\n         }\n });\n```\n\n\nThe relevant line is:\n\n```\nthis.analyser.getByteFrequencyData(samples[samplesDone].sample);\n```\n\n\nThis call populates an ```\nUint8Array```\n with FFT data. The length is pre-set and fixed.\n\nSo now I have an array with ```\nUint8Array```\ns representing the recorded audio. How can I feed the data back to some audio stream to play it in the browser?\n\nI would like to record sound as FFT, modify it and then play it back.\n\nI tried this:\n\n```\n/** @type {{time:number, sample:Uint8Array}[]} **/\nconst samples = this.getSamples();\nthis.oscilator = this.audioContext.createOscillator();\nthis.oscilator.connect(this.audioContext.destination);\n\nlet ctime = 0;\nconst ssize = samples[0].sample.length;\nconst imaginary = new Float32Array(ssize);\nconst half255 = 255 / 2;\nthis.oscilator.start();\n\nfor (let i = 0, l = samples.length; i < l; ++i) {\n    const sample = samples[i];\n    await sleep(sample.time - ctime);\n    ctime = sample.time;\n    const real = new Float32Array(ssize);\n    // convert 0->255 to -1.0->1.0\n    for (let is = 0, ls = real.length; is < ls; ++is) {\n        real[is] = (sample.sample[is] / half255) / half255;\n    }\n\n    const wave = this.audioContext.createPeriodicWave(real, imaginary);\n    this.oscilator.setPeriodicWave(wave);\n\n}\nthis.isPlaying = false;\nthis.oscilator.stop();\n```\n\n\nBut it just sounds like a buzzer. There must be a way to transition from one wave to another.\n    ", "Answer": "\r\nYou would have to resynthesize the audio using sine waves, as that's basically what the FFT decomposition is.\n\nIn particular, you'd be implementing a kind of a vocoder.\n\nYou can picture the array of FFT values at a particular point of time as the amplitudes of sine wave oscillators at that point in time, with ```\nfft[0]```\n being a 0 hz oscillator and ```\nfft[n - 1]```\n being an oscillator tuned to half of your original sampling rate (Nyquist theorem).\n\nThe quality of the resynthesis will probably not be excellent, though; the larger the FFT array, the better frequency resolution you'll have (probably at the expense of temporal resolution).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT reordering phase\r\n                \r\nI've got some code for you guys. \nThis is the first step of the splitting algorithm for the Fast Fourier Transform.\n\nWhat the algorithm should do is reorder the array such that every element on the input will be displaced in the \"binary mirrored\" position of the output.\n\nFor example, the element X[4] will be in position X[1], since the mirrored representation of 100 is 001.  \n\nTill here, everything is clear. However, the algorithm that does such reordering is not. Atleast I have a hard time understanding.\n\nWhat does the second, inner loop do?  \n\n```\n// N is the length of the array\n// p is the number of bits needed to represent the index\n\nfor(int n=0; n<N; n++) {\n\n   int j=0; \n   int m=n;\n   for(int i=0; i<p; i++) {\n     j = 2∗j + m%2; m = m/2;\n   }\n\n   if ( j>n) { \n     complex<double> h;\n     h = X[j]; \n     X[j] = X[n]; \n     X[n] = h;\n   }\n\n}\n```\n\n    ", "Answer": "\r\nThink of an integer as being a sequence of bits.\n\n\n```\nj = 2j```\n this pops the bit on the left and pushes zero into the right\n```\nm % 2```\n this obtains the right bit\n```\nm = m / 2```\n pops the bit on the right and pushes a copy of the leftmost bit on the left\n```\nj + x```\n sets the rightmost bit of ```\nj```\n to ```\nx```\n, assuming that bit is currently zero and that ```\nx```\n is ```\n0```\n or ```\n1```\n\n\n\nso all this is doing is popping bits off of the right of ```\nm```\n and pushing them onto the right of ```\nj```\n.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Finding more than one maximum in an array\r\n                \r\nI would like to find more than one maximum value from an array using Matlab.\n\nHere is my code that returns only one max and its position:\n\n```\n[peak, pos] = max(abs(coeffs));\n```\n\n\nProblem is that I want to detect more than one max in the array. In fact, I would need to detect the first two peaks and their positions in the following array:\n\n```\n>> abs(coeffs())\n\nans =\n\n    0.5442\n    0.5465\n    0.5545\n    0.5674\n    0.5862\n    0.6115\n    0.6438\n    0.6836\n    0.7333\n    0.7941\n    0.8689\n    0.9608\n    1.0751\n    1.2188\n    1.4027\n    1.6441\n    1.9701\n    2.4299\n    3.1178\n    4.2428\n    6.3792\n   11.8611\n   53.7537\n   24.9119\n   10.8982\n    7.3470\n    5.7768\n    4.9340\n    4.4489\n    4.1772\n    4.0564\n    4.0622\n    4.1949\n    4.4801\n    4.9825\n    5.8496\n    7.4614\n   11.1087\n   25.6071\n   53.2831\n   12.0029\n    6.4743\n    4.3096\n    3.1648\n    2.4631\n    1.9918\n    1.6558\n    1.4054\n    1.2129\n    1.0608\n    0.9379\n    0.8371\n    0.7532\n    0.6827\n    0.6224\n    0.5702\n    0.5255\n    0.4861\n    0.4517\n    0.4212\n    0.3941\n    0.3698\n    0.3481\n    0.3282\n    0.3105\n    0.2946\n    0.2796\n    0.2665\n    0.2541\n    0.2429\n    0.2326\n    0.2230\n    0.2141\n    0.2057\n    0.1986\n    0.1914\n    0.1848\n    0.1787\n    0.1729\n    0.1677\n    0.1627\n    0.1579\n    0.1537\n    0.1494\n    0.1456\n    0.1420\n    0.1385\n    0.1353\n    0.1323\n    0.1293\n    0.1267\n    0.1239\n    0.1216\n    0.1192\n    0.1172\n    0.1151\n    0.1132\n    0.1113\n    0.1096\n    0.1080\n    0.1064\n    0.1048\n    0.1038\n    0.1024\n    0.1011\n    0.1000\n    0.0987\n    0.0978\n    0.0967\n    0.0961\n    0.0951\n    0.0943\n    0.0936\n    0.0930\n    0.0924\n    0.0917\n    0.0913\n    0.0908\n    0.0902\n    0.0899\n    0.0894\n    0.0892\n    0.0889\n    0.0888\n    0.0885\n    0.0883\n    0.0882\n    0.0883\n    0.0882\n    0.0883\n    0.0882\n    0.0883\n    0.0885\n    0.0888\n    0.0889\n    0.0892\n    0.0894\n    0.0899\n    0.0902\n    0.0908\n    0.0913\n    0.0917\n    0.0924\n    0.0930\n    0.0936\n    0.0943\n    0.0951\n    0.0961\n    0.0967\n    0.0978\n    0.0987\n    0.1000\n    0.1011\n    0.1024\n    0.1038\n    0.1048\n    0.1064\n    0.1080\n    0.1096\n    0.1113\n    0.1132\n    0.1151\n    0.1172\n    0.1192\n    0.1216\n    0.1239\n    0.1267\n    0.1293\n    0.1323\n    0.1353\n    0.1385\n    0.1420\n    0.1456\n    0.1494\n    0.1537\n    0.1579\n    0.1627\n    0.1677\n    0.1729\n    0.1787\n    0.1848\n    0.1914\n    0.1986\n    0.2057\n    0.2141\n    0.2230\n    0.2326\n    0.2429\n    0.2541\n    0.2665\n    0.2796\n    0.2946\n    0.3105\n    0.3282\n    0.3481\n    0.3698\n    0.3941\n    0.4212\n    0.4517\n    0.4861\n    0.5255\n    0.5702\n    0.6224\n    0.6827\n    0.7532\n    0.8371\n    0.9379\n    1.0608\n    1.2129\n    1.4054\n    1.6558\n    1.9918\n    2.4631\n    3.1648\n    4.3096\n    6.4743\n   12.0029\n   53.2831\n   25.6071\n   11.1087\n    7.4614\n    5.8496\n    4.9825\n    4.4801\n    4.1949\n    4.0622\n    4.0564\n    4.1772\n    4.4489\n    4.9340\n    5.7768\n    7.3470\n   10.8982\n   24.9119\n   53.7537\n   11.8611\n    6.3792\n    4.2428\n    3.1178\n    2.4299\n    1.9701\n    1.6441\n    1.4027\n    1.2188\n    1.0751\n    0.9608\n    0.8689\n    0.7941\n    0.7333\n    0.6836\n    0.6438\n    0.6115\n    0.5862\n    0.5674\n    0.5545\n    0.5465\n```\n\n\nThe reason I need only the two first max values is that the two last ones are reflections of the two first ones as a result of a fast fourier transform.\n    ", "Answer": "\r\nyou can use many peak finding tools to do that. Here's some of them:\n\nFindpeaks\n\nThe function ```\n[pks,locs] = findpeaks(data)```\n returns local maxima or peaks, ```\npks```\n, in the input data at locations ```\nlocs```\n (sorted from first to last found). Data requires a row or column vector with real-valued elements with a minimum length of three. ```\nfindpeaks```\n compares each element of data to its neighboring values. If an element of data is larger than both of its neighbors or equals Inf, the element is a local peak. If there are no local maxima, pks is an empty vector.\n\nFor example: \n\n```\n[pks,locs] = findpeaks(abs(coeffs))\nplot(abs(coeffs)); hold on\nplot(locs(1:2),pks(1:2),'ro'); \n```\n\n\n\n\n1D Non-derivative Peak Finder - a FEX tool that finds peaks without taking first or second derivatives, rather it uses local slope features in a given data set. \n\nPeakFinder - another peak finder from the FEX by nate yoder.\n\nand there are plenty more of these in the FEX...\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why does my ifft result in the real part of the complex number being infinite?\r\n                \r\nI am writing a script that simulates random white noise to study its behavior when shifted into its signal form.\n\nBelow is the function that I am having a problem with:\n\n```\ndef white_noise(n: int, N: int, slope: int = grad):\n    \"\"\"\n    - Creates a data set of white noise with size n, N;\n    - Filters this dataset with the corresponding slope;\n        This slope is usually equal to -5/3 or -2/3\n    - Makes sure the slope is equal to the requested slope in the double log scale.\n\n    @param n: size of random array\n    @param N: number of random arrays\n    @param slope: slope of the gradient\n    @return: white_noise, filtered white_noise and the original signal\n    \"\"\"\n    x = np.linspace(0, 1, n)\n    slope_loglog = (10 ** (slope * np.log10(x) + 1))\n\n    white_noise = rnd.rand(n, N) ** 2 # squaring the white noise to retrieve the power spectrum\n    white_noise_filtered = []\n    white_noise_signal = []\n    white_noise_retransformed = []\n\n    for k in range(N):\n        white_noise_filtered.append(white_noise[:,k] * slope_loglog)\n        white_noise_signal.append(fft.ifft(white_noise[:,k] * slope_loglog))\n\n    white_noise_filtered, white_noise_signal, white_noise_retransformed = \\\n        np.asarray((white_noise_filtered, white_noise_signal, white_noise_retransformed))\n\n    white_noise_filtered = white_noise_filtered.transpose()\n    white_noise_signal = white_noise_signal.transpose().imag\n\n\n    return white_noise, white_noise_filtered, white_noise_signal, white_noise_retransformed, slope_loglog\n```\n\n\nDuring the step where I apply the inverse fast Fourier transform (1D), my simulated noise generates a complex array (which is to be expected when dealing with Fourier transformations). What I do not understand is why the real part from all of the complex values equals 'Inf'. These should have a finite value, so what am I doing wrong?\n\n(Note: the ```\nslope_loglog```\n has to do with log-log transformed data having a gradient of -5/3.)\n\nSince I need the ifft and thereafter the fft to achieve the original noise again (or shifted), I need to understand why my script does this. Taking only the imaginary part of the array 'white_noise_signal' does not result in the original noise.\n    ", "Answer": "\r\nThis has nothing to do with FFT/IFFT\n\n```\nnp.log10(0) = -np.inf\n```\n\n\nand\n\n```\n10 ** np.inf = np.inf\n```\n\n\nSo if you use a negative slope, i.e. ```\nslope = -1```\n\n\n```\n10 ** (slope * np.log10(0)) = np.inf\n```\n\n\nMultiply that with any signal and you will get ```\ninf```\n.\n\nAlso, you can simplify your code significantly if you skip using lists inbetween:\n\n```\ndef white_noise(n: int, N: int, slope: int = -5/3):\n    \"\"\"\n    - Creates a data set of white noise with size n, N;\n    - Filters this dataset with the corresponding slope;\n        This slope is usually equal to -5/3 or -2/3\n    - Makes sure the slope is equal to the requested slope in the double log scale.\n\n    @param n: size of random array\n    @param N: number of random arrays\n    @param slope: slope of the gradient\n    @return: white_noise, filtered white_noise and the original signal\n    \"\"\"\n\n    x = np.linspace(0, 1, n)\n    slope_loglog = (10 ** (slope * np.log10(x) + 1))\n\n    white_noise = np.random.rand(n, N) ** 2 # cubing the white noise to retrieve the power spectrum\n\n    white_noise_filtered = (white_noise * slope_loglog).T\n    white_noise_signal = (np.fft.ifft(white_noise, axis=-1) * slope_loglog).T.imag\n\n    return white_noise, white_noise_filtered, white_noise_signal, slope_loglog\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Frequency Domain Signal [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nHow do I create the following graph in MATLAB :\n\n\nI have a signal which I have plotted, and I have tried to recreate the graph via Fast Fourier Transform, but I am now wondering if it is a completely different method that creates it due to not being able to replicate the image.\nMy signal is the blue line:\n\n \nI want to decompose my signal into its harmonics and plot them in a stem plot as above, with the magnitude being apparent and the harmonics been shown at their corresponding number i.e. 1, 2, 3 ....\n    ", "Answer": "\r\nThe plot you are trying to do is called ```\nstem```\n plot\nThe general syntax of the stem is\n\n```\nstem(X,Y)\n```\n\n\nwhich plots the data sequence Y at the values specified in X.\nFor example\n\n```\n>> x = 0:0.5:3;\n>> y = [11 0 4 0 10 0 4];\n>> stem(x,y)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "determining frequency in given time in java [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 11 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nDetermining a FFT(Fast Fourier Transformation) is often time-frequency trade off. If we calculate FFT over larger time(15 to 20 seconds), we can get more accurate frequencies but very less number of them. For smaller time intervals frequencies often show sharp variations.\nWhat is the best time interval in which we can have a reliable data with sufficient number of frequency points?\n    ", "Answer": "\r\nThat depends on your type of audio. Maybe you should consider using a Wavelet analysis. With this you can extract very accurate high frequencies without loosing the recognition of low frequencies.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "GPU perfomance request, what's the best solution?\r\n                \r\nI work on an audio processing project that needs to do a lot of basic computations (+, -, *) like a FFT (Fast Fourier Transform) calculation. \n\nWe're considering using a graphics card to accelerate these computations. But we don't know if this is the best solution. Our desired solution needs to be a good computation system costing less than $500.\n\nWe use Matlab programming, and we have a sound card acquisition which have to be plug in the system.\n\nDo you know a solution other than graphics card + motherboard to do lot of calculus?\n    ", "Answer": "\r\nYou can use the free Matlab CUDA library to perform the computations on the GPU. $500 will give you a very decent NVIDIA GPU. Beware that GPU's have limited video memory and will run out of memory with large data volumes even faster than Matlab.\n\nI have benchmarked an 8core intel CPU against an 8800 Nvidia GPU (128streams) with GPUMat , for 512Kb datasets the GPU spun out at the same speed as the 8 core intel at 2Ghz, including transfer times to the GPU memory. For serious GPU work I recommend a dedicated card compared to the one you are using to drive the monitor. Use the motherboard cheapie intel video to drive the monitor and pass the array computes to the Nvidia.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "help with algorithm optimisation\r\n                \r\nI would like to optimize this algorithm. Function ```\nmakeFrame```\n divides the audio signal into time frames using a Hanning window of about 37 ms. Then function ```\ndivideFreqs```\n performs the fast fourier transform on each timeframe using jtransforms library (and it is the one that is the most time consuming). How could I cut down the time of this operation as this is taking way too long. For an audio file of 5 secs it takes around 13 secs to perform the operation. I was thinking about using multi-threading but never used it before.  \n\n```\n public double[][] makeFrame(double[] audioOutput) {\n\n            int length = audioOutput.length;\n\n            //calculate a hannining window size of 37 ms\n            int window = (int) Math.round(0.37 * sampleRate);\n            int interval = (int) Math.round(0.0116 * sampleRate);\n            length = length - window;\n            int numintervals = length / interval;\n            //calculate hanning window values\n            double[] hanw = hanning(window);\n            double[][] sections = new double[numintervals + 1][25];\n\n\n            //divide the signal into timeframes using Hanning window of 37ms\n            int k = 0;\n            for (int i = 0; i < length; i += interval) {\n                double[] temp = new double[88200];\n                int t = 0;\n                int s;\n\n                s = i;\n\n                for (; s < i + window; s++) {\n                    temp[t] = audioOutput[s] * hanw[t];\n                    t++;\n                }\n                sections[k] = divideFreqs(temp, sampleRate);\n                k++;\n            }\n\n            return sections;\n        }\n\n\npublic static double[] hanning(int window) {\n\nint w = 0;\n\n        double h_wnd[] = new double[window]; //Hanning window\n\n        for (int i = 1; i < window; i++) { //calculate the hanning window\n            h_wnd[i] = 0.5 * (1 - Math.cos(2.0 * Math.PI * i / (window + 1)));\n        }\n\n        return h_wnd;\n    }\n\n public static double[] divideFreqs(double[] audioData, float fs) {\n\n        DoubleFFT_1D fft = new DoubleFFT_1D(44100);\n        int len;\n        double[] secenergy;\n\n\n        //Frequency bands in the range of 1Hz-20000Hz\n        int[][] bandsec = new int[][]{\n            {1, 100},\n            {100, 200},\n            {200, 300},\n            {300, 400},\n            {400, 510},\n            {510, 630},\n            {630, 770},\n            {770, 920},\n            {920, 1080},\n            {1080, 1270},\n            {1270, 1480},\n            {1480, 1720},\n            {1720, 2000},\n            {2000, 2320},\n            {2320, 2700},\n            {2700, 3150},\n            {3150, 3700},\n            {3700, 4400},\n            {4400, 5300},\n            {5300, 6400},\n            {6400, 7700},\n            {7700, 9500},\n            {9500, 12000},\n            {12000, 15500},\n            {15500, 20000}};\n\n\n        //perform FFT on the data\n        fft.realForwardFull(audioData);\n\n\n        //splitting real and imaginary numbers\n        double[] real = new double[22050];\n        double[] imaginary = new double[22050];\n        for (int row = 0; row < 22050; row++) {\n            real[row] = (double) Math.round(audioData[row + row] * 100000000) / 100000000;\n            imaginary[row] = (double) Math.round(audioData[row + row + 1] * 100000000) / 100000000;\n\n        }\n\n        len = bandsec.length;\n        secenergy = new double[len];\n\n        //calculate energy for each critical band\n        double[] tempReal;\n        double[] tempImag;\n        for (int i = 0; i < len; i++) {\n            int k = 0;\n            tempReal = new double[bandsec[i][1] - (bandsec[i][0] - 1)];\n            tempImag = new double[bandsec[i][1] - (bandsec[i][0] - 1)];\n\n            for (int j = bandsec[i][0] - 1; j < bandsec[i][1]; j++) {\n\n                tempReal[k] = real[j];\n                tempImag[k] = imaginary[j];\n                k++;\n            }\n            secenergy[i] = energy(tempReal, tempImag);\n\n        }\n\n        return secenergy;\n    }\n\n public static double energy(double[] real, double[] imaginary) {\n        double e = 0;\n\n        Complex sum = new Complex(0, 0);\n        ArrayList<Complex> complexList = new ArrayList<Complex>();\n\n        for (int i = 0; i < real.length; i++) {\n            Complex comp = new Complex(real[i], imaginary[i]);\n\n            complexList.add(comp.multiply(comp));\n        }\n\n        for (int i = 0; i < complexList.size(); i++) {\n            Complex comp = new Complex(complexList.get(i).getReal(), complexList.get(i).getImaginary());\n\n            sum = Complex.add(comp, sum);\n\n\n        }\n\n        e = Math.sqrt(sum.magnitude());\n        e = (double) Math.round(e * 10000) / 10000;\n        return e;\n    }\n```\n\n    ", "Answer": "\r\nUsing multiple cores will help, but often optimising your code which give you greater benefits.\n\nUsing double instead of a Complex object is 9x faster on my machine.\n\n```\nThe average time using double took 38,687 ns\nThe average time using Complex took 344,010 ns\n```\n\n\nThe test code\n\n```\npublic class EnergyTest {\n    public static void main(String... args) {\n        double[] real = new double[22050];\n        double[] imaginary = new double[22050];\n        for (int i = 0; i < real.length; i++) {\n            real[i] = Math.random() - Math.random();\n            imaginary[i] = Math.random() - Math.random();\n        }\n        {\n            int runs = 100000;\n            long start = 0;\n            double e = 0;\n            for (int i = -10000; i < runs; i++) {\n                if (i == 0) start = System.nanoTime();\n                e += energyDouble(real, imaginary);\n            }\n            assert e > 0;\n            long time = System.nanoTime() - start;\n            System.out.printf(\"The average time using double took %,d ns%n\", time / runs);\n        }\n        {\n            int runs = 10000;\n            long start = System.nanoTime();\n            double e = 0;\n            for (int i = -10000; i < runs; i++) {\n                if (i == 0) start = System.nanoTime();\n                e += energy(real, imaginary);\n            }\n            assert e > 0;\n            long time = System.nanoTime() - start;\n            System.out.printf(\"The average time using Complex took %,d ns%n\", time / runs);\n        }\n    }\n\n    public static double energyDouble(double[] real, double[] imaginary) {\n        double re_total = 0, im_total = 0;\n\n        for (int i = 0; i < real.length; i++) {\n            double re = real[i];\n            double im = imaginary[i];\n            double re2 = re * re - im * im;\n            double im2 = 2 * re * im;\n            re_total += re2;\n            im_total += im2;\n        }\n        double e = Math.sqrt(re_total * re_total + im_total * im_total);\n        e = (double) Math.round(e * 10000) / 10000;\n        return e;\n    }\n\n    public static double energy(double[] real, double[] imaginary) {\n        double e = 0;\n\n        Complex sum = new Complex(0, 0);\n        ArrayList<Complex> complexList = new ArrayList<Complex>();\n\n        for (int i = 0; i < real.length; i++) {\n            Complex comp = new Complex(real[i], imaginary[i]);\n\n            complexList.add(comp.multiply(comp));\n        }\n\n        for (int i = 0; i < complexList.size(); i++) {\n            Complex comp = new Complex(complexList.get(i).getReal(), complexList.get(i).getImaginary());\n\n            sum = Complex.add(comp, sum);\n\n\n        }\n\n        e = Math.sqrt(sum.magnitude());\n        e = (double) Math.round(e * 10000) / 10000;\n        return e;\n    }\n\n    static class Complex {\n\n        private final double re;\n        private final double im;\n\n        public Complex(double re, double im) {\n            this.re = re;\n            this.im = im;\n        }\n\n        public double getReal() {\n            return re;\n        }\n\n        public double getImaginary() {\n            return im;\n        }\n\n        public Complex multiply(Complex comp) {\n            double re2 = re * comp.re - im * comp.im;\n            double im2 = im * comp.re + re * comp.im;\n            return new Complex(re2, im2);\n        }\n\n        public static Complex add(Complex a, Complex b) {\n            return new Complex(a.re + b.re, a.im + b.im);\n        }\n\n        public double magnitude() {\n            return re * re + im * im;\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Get system audio stream\r\n                \r\nI'm trying to find a solution to return the current system audio stream in Xamarin.Forms (for iOS and Android).\nAs example: There is a new feature from Shazam since iOS14 where you can not record the microphone input but the system audio input, like a running Spotify song.\nI just want that as a stream to filter it through Fast Fourier Transform and send it to a microcontroller for some sound reactive LED effects.\nCould not find an extension or Nuget package yet, do you know any or maybe some working solution ?\nBest regards\nnflug\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Perform action on all data\r\n                \r\nI have a lot of csv files with data. I want to perform the same action on all my files, but I do not know how to do this without doing it individually for all the files.  \n\nI read in all the csv files and saved the data in my environment with the command:\n\n```\nfiles <- list.files(path=path, pattern=\"*.csv\") \nfor(file in files) {  \n    perpos <- which(strsplit(file, \"\")[[1]]==\".\")   \n    assign(gsub(\" \",\"\",substr(file, 1, perpos-1)), \n           read.csv(paste(path,file,sep=\"\")))\n}\n```\n\n\nThe action I am trying to perform is fft(x) (fast fourier transform) on a vector.  For example, if the file name is data1, I would like to do fft(data1$vector).  I would like to do this for all data. \n    ", "Answer": "\r\nThe easiest way I've found to do this is to use some utility functions from the ```\ndata.table```\n package: ```\nfread```\n (a faster file reader) and ```\nrbindlist```\n (consolidate a list into a single data table or data frame).\n\nSomething along these lines should do what you want: \n\n```\nfiles <- list.files(path = path, pattern = \"*.csv\")\n\n# Read your files into a list of data tables \n# (if you want data frames, set data.table = FALSE)\ndata <- lapply(files, fread)\n\ndata <- rbindlist(data, use.names = TRUE, fill = TRUE)\n```\n\n\nYou may need additional arguments to ```\nfread```\n depending on the specifics of your files. And you might not need to specify ```\nuse.names```\n or ```\nfill```\n. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Is there a way to split a .mp3 file into low, medium, and high notes using Python?\r\n                \r\nI have a project where I would like to split a file into separate files of low, medium, and high notes (This would be .mp3 files that are music). For example, splitting a piano song into notes on different sections of the piano.\nI've tried using Fast Fourier transform, but this splits the file into frequencies, not notes. The difference is that all notes have high and low frequencies, but the low just sound \"thicker\" and the higher frequencies sound \"tinny\". The files of the low and high frequencies still include all musical notes.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Signal division into parts on chart\r\n                \r\nI have a signal from an interferometer, which is then filtered by FFT (fast Fourier transform) the filter itself works ok.\nFor now i filter the signal in range which i choose, i can also do this in whole range, but i want cut this signal into parts and filter/analysis each parts, it can be done automaticly, or i can enter the range which i want. To cut this i must probably use some window ?\n\nThe screenshot of the program:\n\n\n\n\n\nthe link to the all files: here, here and here.\n\nMy Code:\n\n```\nclear all; \nclose all; \nclc; \nfile_name = 'W0009.dat';\n[lam, I] = read_spectrum(file_name);\nlam = lam*1e-3;\nfigure(1)\nplot(lam,I, '-k');hold on;\n\nmask = lam >= 1.6 & lam <= 1.8;\nN = sum(mask);\nw = hamming(N);\n\nif mod(N, 2) == 0\n    f = (-fix(N/2) : fix(N/2) - 1)/N; % czestotliwości dla N parzystego\nelse\n    f = (-fix(N/2) : fix(N/2))/N; % czestotliwości  dla N nieparzystego\nend\n\nF = 2*fftshift(fft(I(mask)))/N;\nW = fftshift(fft(I(mask).*w));\n\nm = abs(f) <= 0.04;\nF(not(m)) = 0;\n\nfigure(2)\nsemilogy(f, abs(F), '-k');hold on;\n% semilogy(f, abs(W), '-r');hold on;\n\nfI = -abs(N*ifft(fftshift(F))/2);\nfigure(3);\nplot(lam(mask), I(mask), '-k');hold on;\nplot(lam(mask), fI, '-r');\n\n% M = 258; b = fir1(M, 0.45);\n% I1 = I;\n% I1 = filter(b, 1, I1); I1(1 : end - floor(M/2)) = I1(floor(M/2) + 1 : end);\n% I1 = filtfilt(b, 1, I1);\n% plot(lam,I1);hold on;\n% \n% M = 38; b = fir1(M, 0.15);\n% I2 = I;\n% I2 = filter(b, 1, I2); I2(1 : end - floor(M/2)) = I2(floor(M/2) + 1 : end);\n% I2 = filtfilt(b, 1, I2);\n% plot(lam,I2);hold on;\n% \n% M = 52; b = fir1(M, 0.05);\n% I3 = I;\n% I3 = filter(b, 1, I3); I3(1 : end - floor(M/2)) = I3(floor(M/2) + 1 : end);\n% I3 = filtfilt(b, 1, I3);\n% plot(lam,I3);hold on;\n% \n% fm1 = lam < 1.8394 & lam > 1.5584;\n% Ifinal1 = I1(fm1);\n% fm2 = lam > 1.8394 & lam < 1.98138;\n% Ifinal2 = I2(fm2);\n% fm3 = lam < 2.216 & lam > 1.98138;\n% Ifinal3 = I3(fm3);\n% lamfinal = [lam(fm1);lam(fm2);lam(fm3)];\n% Ifinal = [Ifinal1;Ifinal2;Ifinal3];\n% close;\n% figure(2)\n% plot(lamfinal,Ifinal); hold on;\n% \n% nlam = linspace(lamfinal(1), lamfinal(end), 9*length(lamfinal)).';\n% nI = interp1(lamfinal, Ifinal, nlam, 'spline');\n% plot(nlam,nI);\n% \n% close;\n% figure(3)\n% [PKS1,LOCS1]= findpeaks(nI);\n% plot(nlam,nI);hold on;\n% plot(nlam(LOCS1),PKS1,'or'); hold on;\n% [PKS2,LOCS2]= findpeaks(-nI,'MinPeakWidth',25);\n% % PKS1 = [PKS1(1:73);PKS1(75:end)];\n% % LOCS1 = [LOCS1(1:73);LOCS1(75:end)];\n% % PKS2 = [PKS2(1:75);PKS2(77:end)];\n% % LOCS2 = [LOCS2(1:75);LOCS2(77:end)];\n% plot(nlam(LOCS2),-PKS2,'or');\n% axis tight;\n```\n\n    ", "Answer": "\r\nTo analyse three parameter ranges you can define these first and the process them in a loop\n\n```\n% Definition of ranges\nranges = [1.2,1.6 ; 1.6, 1.8 ; 1.8, 2.4];\n% Number of ranges defined\nnRanges = size(ranges,1);\n% loop over ranges\nfor i=1:nRanges\n  % ... some stuff from your program\n  % Define the masking area\n  mask = lam >= ranges(i,1) & lam <= ranges(i,2);\n  % ... more stuff from your program\nend\n```\n\n\nYou should be able to modify your program in this way.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Using getline in C++ to get the contain (integers) from a file and input them into array to be used as input of a C++ fft program\r\n                \r\nI'm using getline to get input from a file (myfile.txt)from my computer, the file contains following values : 1 1 1 1 0 0 0 0.\nEach of these values will be put into an array x[n] which will be used later as input of my fast fourier transform program.\nhowever,when I am running the program,the output is a bit different from the original program ie. the one which the array has values declared directly inside the program (  const Complex test[] = { 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 };)\n\n```\n    //original code\n    #include <complex>\n    #include <iostream>\n    #include <valarray>\n\n    const double PI = 3.141592653589793238460;\n\n    typedef std::complex<double> Complex;\n    typedef std::valarray<Complex> CArray;\n\n    // Cooley–Tukey FFT (in-place, divide-and-conquer)\n    // Higher memory requirements and redundancy although more intuitive\n    void fft(CArray& x)\n    {\n        const size_t N = x.size();\n        if (N <= 1) return;\n\n        // divide\n        CArray even = x[std::slice(0, N/2, 2)];\n        CArray  odd = x[std::slice(1, N/2, 2)];\n\n        // conquer\n        fft(even);\n        fft(odd);\n\n        // combine\n        for (size_t k = 0; k < N/2; ++k)\n        {\n            Complex t = std::polar(1.0, -2 * PI * k / N) * odd[k];\n            x[k    ] = even[k] + t;\n            x[k+N/2] = even[k] - t;\n        }\n    }\n\n    // Cooley-Tukey FFT (in-place, breadth-first, decimation-in-frequency)\n    // Better optimized but less intuitive\n    void fft(CArray &x)\n    {\n        // DFT\n        unsigned int N = x.size(), k = N, n;\n        double thetaT = 3.14159265358979323846264338328L / N;\n        Complex phiT = Complex(cos(thetaT), sin(thetaT)), T;\n        while (k > 1)\n        {\n            n = k;\n            k >>= 1;\n            phiT = phiT * phiT;\n            T = 1.0L;\n            for (unsigned int l = 0; l < k; l++)\n            {\n                for (unsigned int a = l; a < N; a += n)\n                {\n                    unsigned int b = a + k;\n                    Complex t = x[a] - x[b];\n                    x[a] += x[b];\n                    x[b] = t * T;\n                }\n                T *= phiT;\n            }\n        }\n        // Decimate\n        unsigned int m = (unsigned int)log2(N);\n        for (unsigned int a = 0; a < N; a++)\n        {\n            unsigned int b = a;\n            // Reverse bits\n            b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n            b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n            b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n            b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n            b = ((b >> 16) | (b << 16)) >> (32 - m);\n            if (b > a)\n            {\n                Complex t = x[a];\n                x[a] = x[b];\n                x[b] = t;\n            }\n        }\n        //// Normalize (This section make it not working correctly)\n        //Complex f = 1.0 / sqrt(N);\n        //for (unsigned int i = 0; i < N; i++)\n        //  x[i] *= f;\n    }\n\n    // inverse fft (in-place)\n    void ifft(CArray& x)\n    {\n        // conjugate the complex numbers\n        x = x.apply(std::conj);\n\n        // forward fft\n        fft( x );\n\n        // conjugate the complex numbers again\n        x = x.apply(std::conj);\n\n        // scale the numbers\n        x /= x.size();\n    }\n\n    int main()\n    {\n        const Complex test[] = { 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 };\n        CArray data(test, 8);\n\n        // forward fft\n        fft(data);`enter code here`\n\n        std::cout << \"fft\" << std::endl;\n        for (int i = 0; i < 8; ++i)\n        {\n            std::cout << data[i] << std::endl;\n        }\n\n        // inverse fft\n        ifft(data);\n\n        std::cout << std::endl << \"ifft\" << std::endl;\n        for (int i = 0; i < 8; ++i)\n        {\n            std::cout << data[i] << std::endl;\n        }\n        return 0;\n    }`  \n\n//new modified code\n#include <complex>\n#include <iostream>\n#include <valarray>\n#include <malloc.h>\n#include <string>\n#include <stdlib.h>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std; \nconst double PI = 3.141592653589793238460;\n\ntypedef std::complex<double> Complex;\ntypedef std::valarray<Complex> CArray;\n// Cooley–Tukey FFT (in-place, divide-and-conquer)\n// Higher memory requirements and redundancy although more intuitive\nvoid fft(CArray& x)\n{\n    const size_t N = x.size();\n    if (N <= 1) return;\n\n    // divide\n    CArray even = x[std::slice(0, N/2, 2)];\n    CArray  odd = x[std::slice(1, N/2, 2)];\n\n    // conquer\n    fft(even);\n    fft(odd);\n\n    // combine\n    for (size_t k = 0; k < N/2; ++k)\n    {\n        Complex t = std::polar(1.0, -2 * PI * k / N) * odd[k];\n        x[k    ] = even[k] + t;\n        x[k+N/2] = even[k] - t;\n    }\n}\n\n// Cooley-Tukey FFT (in-place, breadth-first, decimation-in-frequency)\n// Better optimized but less intuitive\n/*\nvoid fft(CArray &x)\n{\n    // DFT\n    unsigned int N = x.size(), k = N, n;\n    double thetaT = 3.14159265358979323846264338328L / N;\n    Complex phiT = Complex(cos(thetaT), sin(thetaT)), T;\n    while (k > 1)\n    {\n        n = k;\n        k >>= 1;\n        phiT = phiT * phiT;\n        T = 1.0L;\n        for (unsigned int l = 0; l < k; l++)\n        {\n            for (unsigned int a = l; a < N; a += n)\n            {\n                unsigned int b = a + k;\n                Complex t = x[a] - x[b];\n                x[a] += x[b];\n                x[b] = t * T;\n            }\n            T *= phiT;\n        }\n    }\n    // Decimate\n    unsigned int m = (unsigned int)log2(N);\n    for (unsigned int a = 0; a < N; a++)\n    {\n        unsigned int b = a;\n        // Reverse bits\n        b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n        b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n        b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n        b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n        b = ((b >> 16) | (b << 16)) >> (32 - m);\n        if (b > a)\n        {\n            Complex t = x[a];\n            x[a] = x[b];\n            x[b] = t;\n        }\n    }\n\n} */\n// inverse fft (in-place)\nvoid ifft(CArray& x)\n\n{\n    // conjugate the complex numbers\n    x = x.apply(std::conj);\n\n    // forward fft\n    fft( x );\n\n    // conjugate the complex numbers again\n    x = x.apply(std::conj);\n\n    // scale the numbers\n    x /= x.size();\n}\n\nint main()\n\n{   \n\n    int n=0;\n    int b=0;\n    int q=0;\n    int i;\n    int Nx=0;\n    //double *x;\n        double x [8];\n    /**************************************************** getting x ********************************************/\n\n        string line;\n        double Result;\n             ifstream myfile (\"myfile.txt\");\n             if (myfile.is_open())\n               {\n                 for ( i = 0 ; (i < 8) && (myfile >> x[i]) ; ++i) \n\n            cout << line << '\\n';\n                 stringstream convert(line);\n\n                 if ( !(convert >> Result) )\n                Result = 0;\n\n                 x[i]=Result;\n\n               }\n            else cout << \"Unable to open file\";\n    /****************************************************************************************************************/\n\n\n    Complex test[8];     \n    for ( i = 0 ; i < 8 ; ++i )\n    test[i] = x[i];\n\n    CArray data(test, 8);\n\n    // forward fft\n    fft(data);\n\n    std::cout << \"fft\" << std::endl;\n    for (int i = 0; i < 8; ++i)\n    {\n        cout << data[i] << endl;\n    }\n\n    // inverse fft\n    ifft(data);\n\n    std::cout << std::endl << \"ifft\" << std::endl;\n    for (int i = 0; i < 8; ++i)\n    {\n        std::cout << data[i] << std::endl;\n    }\n\n    return 0;\n}\n\n\n\nThe purpose of this task is to calculate the FFT (Fast Fourier Transform) of an input se\n```\n\n\nquence\n    ", "Answer": "\r\nThere are (at least) three points to correct in your modified code.\n\n(1) You use ```\n16```\n where (if I'm not wrong) you should use ```\n8```\n; ```\nx```\n should be ```\nnew double[8]```\n (or ```\ndouble x[8]```\n? why do you use a dynamic array?); ```\ntest```\n should be ```\nComplex test[8];```\n, ```\nCArray data(test, 16);```\n should be ```\nCArray data(test, 8);```\n\n\n(2) you don't initialize ```\ni```\n in the reading file loop; so when you write\n\n```\nx[i]=(double)Result;\n```\n\n\nthe value of ```\ni```\n is undefined. So, if ```\ni```\n is in the range [0,16[, you lose the first 7 values and the 8th value is in ```\nx[i]```\n; the other values of ```\nx```\n are undefined. If ```\ni```\n is out of the range [0,16[, the program can crash.\n\nEn passant: ```\nx[i]```\n and ```\nResult```\n are ```\ndouble```\n; so the cast is superflous.\n\nI suppose your cycle should be (remembering you have only 8 values) something like\n\n```\n  for ( i = 0 ; (i < 8) && getline(myfile, line) ; ++i )\n   {\n     cout << line << '\\n';\n     stringstream convert(line);\n\n     if ( !(convert >> Result) )\n        Result = 0;\n\n     x[i]=Result;\n   }\n```\n\n\n(3) I don't understand what should be\n\n```\nconst Complex test[16] = x[i];\n```\n\n\nI suppose your intention was\n\n```\nComplex test[8];     \nfor ( i = 0 ; i < 8 ; ++i )\n   test[i] = x[i];\n```\n\n\n---- EDIT ----\n\nCorrection: a correct way to load the file can be\n\n```\n//   double Result;\nifstream myfile (\"myfile.txt\");\nif (myfile.is_open())\n {\n   for ( i = 0 ; (i < 8) && (myfile >> x[i]) ; ++i \n    ;\n\n   // no need for myfile.close() (take care of it the destructor)\n }\nelse cout << \"Unable to open file\";\n```\n\n\nSorry.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Matlab, DFT, FFT, frequency range;\r\n                \r\nI am really having a hard time to understand how the fft-function in MATLAB works.\nAccording to:\n\nhttp://www.mathworks.de/help/matlab/math/fast-fourier-transform-fft.html\n\nfs/n is the distance between the sampled points in the Spectrum, where fs is the sampling frequency and n is the length of the signal. The code that they present, does extract the frequencies (although I do not know why), but according to the implementation of fft, that they present:\n\nhttp://www.mathworks.de/help/matlab/ref/fft.html\n\nthe distance between the points in the spectrum should rather be: 1/fs. Because instead of the index j one inserts j*T, where T = 1/fs is the sampling time and then you can calculate the distance between the points, which should not be fs/n. \n\nI would really be grateful if someone could explain me what the distance between the points in the frequency domain is and why this is so:)\n\n[EDIT]\nThis is not a Matlab-specific problem. It is more a problem about the relationship between the Fourier-Transformation and the Discrete-Fourier-Transformation and the scaling/units of the frequency-axis. A pretty good explanation can be found in this PDF-Document at page 3.\n\n[/EDIT]\n    ", "Answer": "\r\nThe distance between the frequency points on the spectrum is ```\nfs/n```\n in both cases, and that is the correct value. If we take the code in http://www.mathworks.co.uk/help/matlab/ref/fft.html, we have:\n\n```\n>> Fs = 1000;                    % Sampling frequency\n>> T = 1/Fs;                     % Sample time\n>> L = 1000;                     % Length of signal\n>> t = (0:L-1)*T;                % Time vector\n>> NFFT = 2^nextpow2(L); % Next power of 2 from length of y\n>> f = Fs/2*linspace(0,1,NFFT/2+1);\n>> f(2)-f(1)\nans =  0.97656\n>> Fs/NFFT\nans =  0.97656\n```\n\n\nYou can double-check all the other ```\nf(n+1)-f(n)```\n, they're all the same.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Compare two image in real time with predefined image with real time capture image in Opencv c++\r\n                \r\nI am doing a project of Automatic fabric defect detection. In this i developed the algorithm using the [FFT][1] (Fast Fourier Transform) and its working fine in my Ubuntu 14.04 ```\nopencv c++```\n. But now i want to develop this to real time there i have to capture image every 2s and have to process that image with my developed algorithm. I need ideas on how to capture images using webcam in ```\nopencv c++```\n and to process withat same image which is being captured. Please do help me if anyone knows of this. Thank you in advance.\n    ", "Answer": "\r\nYou can follow the guidance which has given by OpenCV - They have provided enough examples such as following sample code. Following code is provided by OpenCV Dev team as sample.\n\n```\n#include \"opencv2/opencv.hpp\"\n\nusing namespace cv;\n\nint main(int, char**)\n{\n    VideoCapture cap(0); // open the default camera\n    if(!cap.isOpened())  // check if we succeeded\n        return -1;\n   Mat edges;\n   namedWindow(\"edges\",1);\n   for(;;)\n   {\n       Mat frame;\n       cap >> frame; // get a new frame from camera\n       cvtColor(frame, edges, CV_BGR2GRAY);\n       GaussianBlur(edges, edges, Size(7,7), 1.5, 1.5);\n       Canny(edges, edges, 0, 30, 3);\n       imshow(\"edges\", edges);\n      if(waitKey(30) >= 0) break;\n   }\n   // the camera will be deinitialized automatically in VideoCapture       destructor\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Can't get Exocortex FFT to work\r\n                \r\nI'm writing an application that will analyze data from an accelerometer. One of the most important algorithms for this is obviously the FFT, and after much looking I found that Exocortexs library is one of the best for this.\n\nAnyway, when I try to implement it I get this exception:\n\n```\nAn unhandled exception of type 'System.ArgumentOutOfRangeException' occurred in Exocortex.DSP.v1.dll\n\nAdditional information: must be a power of 2\n```\n\n\nHere's the code:\n\n```\nclass FFT\n    {\n        public Exocortex.DSP.ComplexF[] FourierTransform(List<double> vector)\n        {\n            //Dictionary<string, List<double>>\n\n            int vectorLength = vector.Count;\n            Exocortex.DSP.ComplexF[] complexData = new Exocortex.DSP.ComplexF[vectorLength];\n\n            for (int i = 0; i < vectorLength; ++i)\n            {\n                complexData[i].Re = Convert.ToSingle(vector[i]); // Add your real part here\n            //    complexData[i].Im = 2; // Add your imaginary part here\n            }\n\n            Exocortex.DSP.Fourier.FFT(complexData, Exocortex.DSP.FourierDirection.Forward);\n\n            return complexData;\n```\n\n\n(This is really just a version of this example: Fast Fourier Transform in C#). \n\nThe problem might be as simple as the imaginary part of the acceleration since I assume this kind of data is only real but the answer, the FFT that is, is imaginary.\n\nThanks in advance!\n    ", "Answer": "\r\nI'm gonna go out on a limb here and suggest that your vectorLength variable is not a ```\na power of 2```\n.\n\nTry cropping your data such that its new length ```\nL = N^2, where integer N > 1.```\n\nDoes that get ride of the exception?  \n\nAre you expecting your signal to be periodic in nature? Is it attached to some mechanism rotating/shaking at fairly steady frequency? If not, what would you hope to get out of using an FFT?\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to use pyFFTW class to do a 2 d fourier transformation?\r\n                \r\nI want to use pyFFTW to create a 2d fft and ifft. However, the documentations were a bit confusing:\nhttps://pyfftw.readthedocs.io/en/latest/source/tutorial.html#the-workhorse-pyfftw-fftw-class\n\nSo, essentially, the code:\n\n```\na = pyfftw.empty_aligned(128, dtype='complex128')\nb = pyfftw.empty_aligned(128, dtype='complex128')\n\nfft_object = pyfftw.FFTW(a, b)\n```\n\n\nI didn't understand what is a fft_object, and why it needs a and b as input, or even what is a and b doing here. Are they just some empty templet to simulate data of input and output? what's the function of this process?\n\n```\nimport numpy\n\n# Generate some data\nar, ai = numpy.random.randn(2, 128)\na[:] = ar + 1j*ai\n\nfft_a = fft_object()\n```\n\n\nI also didn't understand in which way a was transformed into fft_a, there was not even function call. How did the function knew that a was the input? (I read the whole page and found a mention in the pyfftw.builders\n\n```\nfft_object = pyfftw.builders.fft(a)\n```\n\n\nStill, what is fft_object defined by pyfftw.builders.fft(a)? and what were builders doing?)\n\nAlso, if fft was\n\n```\npyfftw.FFTW(a, b, axes=(0,1))\n```\n\n\nwould the ifft be \n\n```\npyfftw.FFTW(a, b, direction='FFTW_BACKWARD', axes=(0,1))#or\npyfftw.FFTW(a, b, direction='FFTW_BACKWARD', axes=(1,0))#or\npyfftw.FFTW(b, a, direction='FFTW_BACKWARD', axes=(0,1))#or\npyfftw.FFTW(b, a, direction='FFTW_BACKWARD', axes=(1,0))\n```\n\n\n?\n\nSuppose I have a 3 by 3 matrix x=np.ones([3,3]);\n\nHow can I do a fft2(x) and ifft2(x)?\n\nFurther, how can I do a rfft2(x) and irfft2(x)?(rfft2 and irfft2 represent fast fourier transformation in real domain).\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why variables are not stored as zero in stm32cubeid?\r\n                \r\nsamples different from 0\nI am working with the stm32cubeid platform and the stm32f407ve development board, I am trying to sample a sinusoidal signal that I generate in the same compiler and apply the fast fourier transform functions. When displaying the variables after applying the fft the spaces that They should have a 0 stored, according to the code, negative or positive values close to 0 appear, this does not affect the operation of the code, but I do not understand why this happens.This is all I have written in the generated code generated with the stm32cubeid.\n```\n#include \"main.h\"\n#include \"arm_math.h\"\n#include \"arm_const_structs.h\"\n\n/* Private includes ----------------------------------------------------------*/\n/* USER CODE BEGIN Includes */\n\n/* USER CODE END Includes */\n\n/* Private typedef -----------------------------------------------------------*/\n/* USER CODE BEGIN PTD */\n#define Fs 4096;\n/* USER CODE END PTD */\n\n/* Private define ------------------------------------------------------------*/\n/* USER CODE BEGIN PD */\n/* USER CODE END PD */\n\n/* Private macro -------------------------------------------------------------*/\n/* USER CODE BEGIN PM */\n\n/* USER CODE END PM */\n\n/* Private variables ---------------------------------------------------------*/\nADC_HandleTypeDef hadc1;\n\n/* USER CODE BEGIN PV */\n\n#define SIGNAL_BUFFER_LENGTH 4096\nfloat signalBuffer[2*SIGNAL_BUFFER_LENGTH];\nfloat fftBuffer[2*SIGNAL_BUFFER_LENGTH];\nfloat magnitudes[SIGNAL_BUFFER_LENGTH];\n\n\n/* USER CODE END PV */\nuint32_t k;\nuint32_t cont1,cont2;\n\nuint32_t start;\nuint32_t stopi;\nuint32_t delta;\n\nfloat32_t maxValue;             /* Max FFT value is stored here */\nuint32_t maxIndex;\nfloat frecuencia=10.0;\nfloat32_t Ts;\nfloat tiempo;\n/* Private function prototypes -----------------------------------------------*/\nvoid SystemClock_Config(void);\nstatic void MX_GPIO_Init(void);\nstatic void MX_ADC1_Init(void);\n/* USER CODE BEGIN PFP */\n\n/* USER CODE END PFP */\n\n/* Private user code ---------------------------------------------------------*/\n/* USER CODE BEGIN 0 */\n\n/* USER CODE END 0 */\n\n/**\n  * @brief  The application entry point.\n  * @retval int\n  */\nint main(void)\n{\n  /* USER CODE BEGIN 1 */\n\n  /* USER CODE END 1 */\n\n  /* MCU Configuration--------------------------------------------------------*/\n\n  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */\n  HAL_Init();\n\n  /* USER CODE BEGIN Init */\n#define ARM_CM_DEMCR (*(uint32_t*)0xE000EDFC)\n#define ARM_CM_DWT_CTRL (*(uint32_t*)0xE0001000)\n#define ARM_CM_DWT_CYCCNT (*(uint32_t*)0xE0001004)\n\n  if(ARM_CM_DWT_CTRL !=0){\n\n      ARM_CM_DEMCR  |= 1<<24;\n      ARM_CM_DWT_CYCCNT =0;\n      ARM_CM_DWT_CTRL  |= 1<<0;\n\n\n  }\n\n  /* USER CODE END Init */\n\n  /* Configure the system clock */\n  SystemClock_Config();\n\n  /* USER CODE BEGIN SysInit */\n\n  /* USER CODE END SysInit */\n\n  /* Initialize all configured peripherals */\n  MX_GPIO_Init();\n  MX_ADC1_Init();\n  /* USER CODE BEGIN 2 */\n  Ts=1.0/(float)Fs;\n\n  for(k=0;k<2*SIGNAL_BUFFER_LENGTH;k+=2 )\n  {\n      signalBuffer[k]=10*(float)sin(2*PI*k/2*Ts*frecuencia);\n      signalBuffer[k+1]=0;\n\n  }\n\n  //k++;\n  start= ARM_CM_DWT_CYCCNT;\n  arm_cfft_f32(&arm_cfft_sR_f32_len4096,signalBuffer,0,1);\n  arm_cmplx_mag_f32(signalBuffer,magnitudes,4096);\n  arm_max_f32(magnitudes, 4096, &maxValue, &maxIndex);\n  stopi = ARM_CM_DWT_CYCCNT;\n  delta=stopi-start;\n\n  tiempo=delta/8.0E07*1000.0;\n  /* USER CODE END 2 */\n\n  /* Infinite loop */\n  /* USER CODE BEGIN WHILE */\n  while (1)\n  {\n    /* USER CODE END WHILE */\n\n    /* USER CODE BEGIN 3 */\n  }\n  /* USER CODE END 3 */\n}\n\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Benchmarking approaches for fft algorithms\r\n                \r\nI'm currently working on a library that has its own internal fft (Fast Fourier Transform) library which I would like to replace with FFTW. Now, other developers are a bit concerned about the performance issues it might cause. Also the most critical part speed-wise is  the 1D convolution algorithm which deals with half-complex reals. (I'm using fftw's fftw_plan_r2r_1d).\n\nAlso, things are a bit more complicated because internally fftw uses different algorithms depending on the size of the transform.\n\nMy current idea is to generate a bunch of different length datasets. Then read them in and modify the dataset array for each iteration in a predetermined way before doing the transformation.\n\nOr is there anything else I should know?\n    ", "Answer": "\r\nMake sure you generate an optimal plan for FFTW for each test case. The PATIENT and EXHAUSTIVE flags can result in faster plans, but they can take a significant amount of time to get there. (Obviously you shouldn't include this time in your benchmark timing as it's one off and cacheable.)\n\nIf you only need single precision input/output data then build the single precision version of the FFTW libraries - they can be quite a bit faster then the default double precision version and are plenty accurate enough for most appilcations in e.g. signal processing and image processing.\n\nAlso when building the FFTW libraries make sure you enable SIMD if appropriate for your architecture, e.g. SSE on x86 or AltiVec on PowerPC.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Spotify API Frequency Analysis JS\r\n                \r\nI'm creating a 3d terrain-like audio visualiser for a school project and I am intending to use the Spotify API to stream music files into the browser rather than  download and upload mp3 files as I think it will be a much smoother experience and will give me some more marks. If any of you are experienced with or understand the Spotify API well I'd appreciate you letting me know if you can analyse frequencies from streamed tracks, as I will be sampling frequencies at intervals to pass through a fast fourier transform. Thanks,\n\nKit\n    ", "Answer": "\r\nThis appears to not be supported.\nYou can get audio analysis from Spotify for a track, but it does not give frequency data, as seen here: https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-analysis/\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to convert 16-bit PCM audio byte-array to double or float array?\r\n                \r\nI'm trying to perform Fast Fourier Transform on a .3gpp audio file. The file contains a small 5 second recording in 44100kHz from the phones microphone.\n\nEvery Java FFT algorithm I can find only takes double[], float[] or Complex[] inputs, for obvious reasons, but I'm reading in the audio file in a byte-array, so I'm kind of confused as to where I go from here. The only thing I could find is the answer to a previous question:\n\nAndroid audio FFT to retrieve specific frequency magnitude using audiorecord\n\nBut I'm unsure as to wether or not this is the correct procedure. Anyone with any insight?\n    ", "Answer": "\r\nThere is no alternative.  You have to run a loop and cast each element of the array separately.  \n\nI do the same thing for shorts that I fft as floats:\n\n```\npublic static float[] floatMe(short[] pcms) {\n    float[] floaters = new float[pcms.length];\n    for (int i = 0; i < pcms.length; i++) {\n        floaters[i] = pcms[i];\n    }\n    return floaters;\n}\n```\n\n\nEDIT 4/26/2012 based on comments\n\nIf you really do have 16 bit PCM but have it as a byte[], then you can do this:\n\n```\npublic static short[] shortMe(byte[] bytes) {\n    short[] out = new short[bytes.length / 2]; // will drop last byte if odd number\n    ByteBuffer bb = ByteBuffer.wrap(bytes);\n    for (int i = 0; i < out.length; i++) {\n        out[i] = bb.getShort();\n    }\n    return out;\n}\n```\n\n\nthen\n\n```\nfloat[] pcmAsFloats = floatMe(shortMe(bytes));\n```\n\n\nUnless you are working with a weird and badly designed class that gave you the byte array in the first place, the designers of that class should have packed the bytes to be consistent with the way Java converts bytes (2 at a time) to shorts.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "C# Adaptive Sound Cancellation [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nAt my work the entire engineering department just got moved into a new seating arrangement that allows sound to travel a bit more than any of us care to enjoy. I wanted to try to come up with a way to solve this in a cool engineering fashion. Is it possible to create adaptive sound cancelation using:\n\n\nMicrophone Input\nFrequency Calculation\nSpeaker Playback\n\n\nIf so, what libraries would I want to look at? I am assuming something with FFT(Fast Fourier Transform) Microphone input, and frequency playback. Could anyone point me to good libraries that have these capabilities? ( If this is even possible )\n    ", "Answer": "\r\nThis would be difficult/impractical/impossible for two primary reasons:\n\n\nSpeed:  Sound cancellation must capture, calculate the cancellation and generate the cancellation very fast, probably with no more than a 1 millisecond delay.  That's going to be hard to do with managed code.\nPhase Positioning: The proper cancellation phase for any sound/noise is entirely dependent on the precise distance relationship between the microphone, the speakers and your ears.  The first two stay fixed, but your ears tend to go wherever you head goes, which your code has no way of knowing about.  (this is one big reason why noise cancellation works so well with headphones, but not for anything else).  \n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python: Problems of steganography in process of saving(cv2.imwrite) and reading(cv2.imread) using openCV\r\n                \r\nI have a steganography code that hiding image inside another image.\nI inject a watermark into the my image through this code.\nThe principle is very simple.\nI used the ```\nsource_image```\n and ```\nwatermark_images```\n for insert the watermark.\nThis will randomly distribute the ```\nwatermark_images```\n.\n\nFirst, scatter x and y of the watermark image using random seeds.\nAnd then, convert ```\nsource_image```\n to frequency area using Fast Fourier Transform.\nFinally, combine the ```\nwatermark_layer```\n with the frequency area of the ```\nsource_image```\n.\n\nThis encoding process works perfectly well. However, there is a problem in the process of decoding.\nDecoding code is collects pixels scattered by random seeds in one place on the same principle.\nThis is Result of decoing:\n\nthis problem, if i try to encoded image to save(cv2.imwrite) and recalled(cv2.imread), the decoding doesn't work.\nIf I use the encoded object as it is, there is no problem. Is the pixel damaged during the saving and recall process?\nthis is my full code:\n```\nimport cv2 as cv\nimport numpy as np\nimport random\nimport time\n\n\nclass Watermark:\n    def __init__(self):\n        self.watermark_image = cv.imread('../Watermark/google_logo.png')\n        self.result_image_path = '../Watermark/result.jpg'\n        self.random_seed = 2021\n        self.alpha = 5\n\n    def encoding(self, image_path):\n        # Code Start\n        start_time = time.time()\n\n        # Read Image\n        source_image = cv.imread(image_path)\n        source_height, source_width, _ = source_image.shape\n        watermark_height, watermark_width, _ = self.watermark_image.shape\n\n        print('source height : ', source_height, ', source_width : ', source_width)\n        print('watermark height : ', watermark_height, ', watermark width : ', watermark_width)\n\n        # Convert image to frequency area with Fast Fourier Transform (image -> frequency)\n        source_frequency = np.fft.fft2(source_image)\n\n        # Get random seed\n        y_random_indices, x_random_indices = list(range(source_height)), list(range(source_width))\n        random.seed(self.random_seed)\n        random.shuffle(x_random_indices)\n        random.shuffle(y_random_indices)\n\n        print('y random seed : ', y_random_indices)\n        print('x random seed : ', x_random_indices)\n\n        # Injection watermark\n        watermark_layer = np.zeros(source_image.shape, dtype=np.uint8)\n        for y in range(watermark_height):\n            for x in range(watermark_width):\n                watermark_layer[y_random_indices[y], x_random_indices[x]] = self.watermark_image[y, x]\n\n        # Encoding frequency area + watermark layer\n        result_frequency = source_frequency + self.alpha * watermark_layer\n\n        # Apply Inverse Fast Fourier Transform (frequency -> image)\n        result_image = np.fft.ifft2(result_frequency)\n        result_image = np.real(result_image)\n        result_image = result_image.astype(np.uint8)\n\n        # Show elapsed time\n        end_time = time.time()\n        print('Encoding elapsed time : ', end_time - start_time, '\\n')\n\n        # Visualization\n        cv.imshow('source_image', source_image)\n        cv.imshow('watermark', self.watermark_image)\n        cv.imshow('watermark_layer', watermark_layer)\n        cv.imshow('result_image', result_image)\n\n        # Save and Close\n        cv.imwrite(self.result_image_path, result_image)\n        cv.waitKey(0)\n        cv.destroyAllWindows()\n\n        return result_image\n\n    def decoding(self, source_image_path, encoded_image):\n        # Code Start\n        start_time = time.time()\n\n        # Read Image\n        source_image = cv.imread(source_image_path)\n\n        source_height, source_width, _ = source_image.shape\n        print('original_height : ', source_height)\n        print('original_width : ', source_width)\n\n        encoded_height, encoded_width, _ = encoded_image.shape\n\n        # Convert image to frequency area with Fast Fourier Transform (image -> frequency)\n        source_frequency = np.fft.fft2(source_image)\n        encoded_frequency = np.fft.fft2(encoded_image)\n\n        # Convert frequency area to image (frequency -> image)\n        watermark_layer = (source_frequency - encoded_frequency) / self.alpha\n        watermark_layer = np.real(watermark_layer).astype(np.uint8)\n\n        # Get random seed\n        y_random_indices, x_random_indices = [list(range(encoded_height)), list(range(encoded_width))]\n        random.seed(self.random_seed)\n        random.shuffle(x_random_indices)\n        random.shuffle(y_random_indices)\n\n        print('y random seed : ', y_random_indices)\n        print('x random seed : ', x_random_indices)\n\n        # Restore watermark\n        result_image = np.zeros(watermark_layer.shape, dtype=np.uint8)\n\n        for y in range(encoded_height):\n            for x in range(encoded_width):\n                result_image[y, x] = watermark_layer[y_random_indices[y], x_random_indices[x]]\n\n        # Show elapsed time\n        end_time = time.time()\n        print('Encoding elapsed time : ', end_time - start_time, '\\n')\n\n        # Visualization\n        cv.imshow('original image', source_image)\n        cv.imshow('target image', encoded_image)\n        cv.imshow('watermark layer', watermark_layer)\n        cv.imshow('result image', result_image)\n        cv.waitKey(0)\n        cv.destroyAllWindows()\n\n\nif __name__ == '__main__':\n    source_path = '../Watermark/jennie.jpg'\n\n    # good work\n    protected_image = Watermark().encoding(source_path)\n    Watermark().decoding(source_path, protected_image)\n\n    # doesn't work\n    result_path = '../Watermark/result.jpg'\n    result_image = cv.imread(result_path)\n    Watermark().decoding(source_path, result_image)\n```\n\nPlease give me some advice.\n    ", "Answer": "\r\nCarlos Melus have a good point.\nYour code is not suitable for processing jpg images.\nif you use png format, it will work out well.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT on the 8 bit PCM signal\r\n                \r\nI'm using this fast fourier transform implementation in node-js: https://www.npmjs.com/package/fft-js.\n\nI am using wav reader which reads my wav file which is encoded as 8 bit PCM and outputs data as an array of 8 bit unsigned integers. \n\nI see that fft-js expects signal values from -1 to 1 as seen in this example of it's usage:\n\n```\nvar fft = require('fft-js').fft,\n    signal = [1,0,1,0];\n\nvar phasors = fft(signal);\n\nconsole.log(phasors);\n```\n\n\nWhat should I do? Should I convert my 8 bit pcm representation of the wav file to values between -1 and 1, and if so how?\n    ", "Answer": "\r\nAccording to this article on Wikipedia, you should be able to take the 8bit uint data and map it to a number between -1 and 1 with something similar to this:\n\n```\nlet arrForFFT = uint8Array.map(num => (num - 128) / 128)\n```\n\n\nIf my ```\nuint8Array```\n looks like this:\n\n```\n[ 256, 192, 128, 64, 0]\n```\n\n\nThen ```\narrForFFT```\n would look like this:\n\n```\n[ 1, 0.5, 0, -0.5, -1]\n```\n\n\nEdit: If you're not using ES2015, the code would look like this:\n\n```\nvar arrForFFT = uint8Array.map(function(num) {\n  return (num - 128) / 128\n})\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "cross correlation javascript, sliding dot-product & sum of squared differences as the similarity metric\r\n                \r\nI need to Cross- correlate a pattern in the provided signal with a sliding dot-product and also with the sum of squared differences as the similarity metric.\nI'm working in a javascript nodejs environment and have found this formula, Corr(x,y) => fft(x) * fft(y)*\nI have also found Fast Fourier Transform functions already written in JS but don't really know how to multiply the returns arrays to derive where the cross correlation in maximized.\nI also don't know how to add the sliding dot-product and sum of squared differences similarity metric into the equation. \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to reverse byte[]<=>double[] in java\r\n                \r\nIn java.\nI had some file (*.wav) from where I extracted byte[]. After that I converted this to double[] by this code:\n\n```\nfor (int i = 0; i < bytesIn.length && idx < buffer.length; i += 2) \n         {\n           byte lowByte = bytesIn[i];\n           byte highByte = bytesIn[i+1];\n\n//Little endian\n           buffer[idx++] = (lowByte & 0xFF | highByte << 8);     \n         }\n```\n\n\nWhere bytesIn = byte[] of file\nand buffer = double[]\n\nAfter this I did some operation on buffer used fast Fourier transform and inverse. Now after inverse operation from fft I have double[] but I dont know how to get back to byte[].\n\nI found this:\n\n```\nbyte[] bytes = new byte[8];\nByteBuffer.wrap(bytes).putDouble(value);\n```\n\n\nbut bytes store different value than I expected. Changed buffer after IFFT is same as original one. Can anyone write how to reverse code from first code block? \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Implementing an FFT using vDSP\r\n                \r\nI have data regarding the redness of the user's finger that is currently quite noisy, so I'd like to run it through an FFT to reduce the noise. The data on the left side of this image is similar to my data currently. I've familiarized myself with the Apple documentation regarding vDSP, but there doesn't seem to be a clear or concise guide on how to implement a Fast Fourier Transform using Apple's vDSP and the Accelerate framework. How can I do this? \n\nI have already referred to this question, which is on a similar topic, but is significantly outdated and doesn't involve vDSP.\n    ", "Answer": "\r\nUsing vDSP for FFT calculations is pretty easy. I'm assuming you have real values on input. The only thing you need to keep in mind you need to convert your real valued array to a packed complex array that FFT algo from vDSP uses internally.\n\nYou can see a good overview in the documentation:\n\nhttps://developer.apple.com/library/content/documentation/Performance/Conceptual/vDSP_Programming_Guide/UsingFourierTransforms/UsingFourierTransforms.html\n\nHere is the smallest example of calculating real valued FFT:\n\n```\nconst int n = 1024;\nconst int log2n = 10; // 2^10 = 1024\n\nDSPSplitComplex a;\na.realp = new float[n/2];\na.imagp = new float[n/2];\n\n// prepare the fft algo (you want to reuse the setup across fft calculations)\nFFTSetup setup = vDSP_create_fftsetup(log2n, kFFTRadix2);\n\n// copy the input to the packed complex array that the fft algo uses\nvDSP_ctoz((DSPComplex *) input, 2, &a, 1, n/2);\n\n// calculate the fft\nvDSP_fft_zrip(setup, &a, 1, log2n, FFT_FORWARD);\n\n// do something with the complex spectrum\nfor (size_t i = 0; i < n/2; ++i) {\n    a.realp[i];\n    a.imagp[i];\n}\n```\n\n\nOne trick is that ```\na.realp[0]```\n is the DC offset and ```\na.imagp[0]```\n is the real valued magnitude at the Nyquist frequency.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "FFT of resampled pandas Series\r\n                \r\nI am trying to take the Fast Fourier Transform of a resampled pandas Series:\n```\nsignal = pd.Series(thick, index = pd.TimedeltaIndex(time_list_thick,unit = 's'))\nresampled_signal = signal.resample('1S').mean()\n```\n\nHowever if I simply try (using scipy) and just do:\n```\nSAMPLE_RATE = 1\nDURATION = len(resampled_signal)\nN = SAMPLE_RATE * DURATION\n\nyf = fft(resampled_signal[:,1])\nprint(yf)\nxf = fftfreq(N, 1 / SAMPLE_RATE)\n```\n\nI obtain an error ```\nValueError: Can only tuple-index with a MultiIndex```\n due to the\nway ```\nresampled_signal```\n is constructed to include the index. ```\nresampled_signal```\n looks like this for reference:\n```\n00:00:00.419175    206.080335\n00:00:01.419175    206.084340\n00:00:02.419175    206.087010\n00:00:03.419175    206.089681\n00:00:04.419175    206.095021\n.\n.\n.\n```\n\nIs there anyway this can be done? I wish to include the ```\npd.Series```\n form since my final aim is to resample two datasets such that they have the same number of data points, take the FFT of both signals, then subtract one from the other.\nMy simplified code for 1 data set is given below:\n```\nimport numpy as np\nimport pandas as pd \nfrom datetime import datetime\nfrom datetime import timedelta\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq\n\n\ndatathick = \"20210728_rig_thick.csv\" \n\nwith open(datathick) as f:\n        lines = f.readlines()\n        dates = [str(line.split(',')[0]) for line in lines]\n        thick = [float(line.split(',')[1]) for line in lines]\n        z = [float(line.split(',')[2]) for line in lines]\n\n        date_thick = [datetime.strptime(x,'%Y-%m-%dT%H:%M:%S.%f').time() for x in dates]\n\ntime_list_thick = []\nfor i in np.arange(0, len(date_thick)):\n    q = date_thick[i]\n    t = timedelta(hours= q.hour, minutes=q.minute,seconds=q.second, microseconds = q.microsecond).total_seconds()\n    time_list_thick.append(float(t))\n    \n\n#---RESCALE-----\nsignal = pd.Series(thick, index = pd.TimedeltaIndex(time_list_thick,unit = 's'))\nresampled_signal = signal.resample('1S').mean()\nresampled_signal = resampled_signal.interpolate(method='time')\n\nprint(resampled_signal.head())\n\nexit()\n#----FFT Transform of Output and Noise ----\n# Number of samples in normalized_tone\n\nSAMPLE_RATE = 1\nDURATION = len(resampled_signal)\nN = SAMPLE_RATE * DURATION\n\nyf = fft(resampled_signal[:,1])\nprint(yf)\nxf = fftfreq(N, 1 / SAMPLE_RATE)\n\n#------------------------------------------------\nfig=plt.figure(figsize=(7.,7.))\n\nax=fig.add_subplot(1,1,1)\nax.set_zorder(1)\nax.patch.set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['left'].set_visible(False)\nax.spines['bottom'].set_visible(False)\nax.set_xlabel('Frequency (Hz)')\nax.set_ylabel('Amplitude (a.u)')\nax.minorticks_on() # enable minor ticks\nax.xaxis.set_ticks_position('bottom')\nax.spines['left'].set_color('black')\nax.yaxis.label.set_color('black')\n\nplt.yscale('log')\nax.tick_params(direction='out', axis='y', which='both', pad=4, colors='black')\nax.grid(b=True, which='major', color='#eeeeee', linestyle='-', zorder=1, linewidth=0.4) # turn on major grid\nax.grid(b=True, which='minor', color='#eeeeee', linestyle='-', zorder=1, linewidth=0.4) # turn on minor grid\n\nax.plot(np.abs(xf), np.abs(yf))\n\nplt.savefig('fft.pdf', dpi=300, bbox_inches='tight', format='pdf')\nplt.savefig('fft.png', dpi=300, bbox_inches='tight', format='png')\n#----------------------------------------------\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
