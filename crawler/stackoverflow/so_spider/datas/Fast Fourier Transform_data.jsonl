{"Question": "Analyze audio using Fast Fourier Transform\r\n                \r\nI am trying to create a graphical spectrum analyzer in python.\n\nI am currently reading 1024 bytes of a 16 bit dual channel 44,100 Hz sample rate audio stream and averaging the amplitude of the 2 channels together.  So now I have an array of 256 signed shorts.  I now want to preform a fft on that array, using a module like numpy, and use the result to create the graphical spectrum analyzer, which, to start will just be 32 bars.\n\nI have read the wikipedia articles on Fast Fourier Transform and Discrete Fourier Transform but I am still unclear of what the resulting array represents.  This is what the array looks like after I preform an fft on my array using numpy:\n\n```\n   [ -3.37260500e+05 +0.00000000e+00j   7.11787022e+05 +1.70667403e+04j\n   4.10040193e+05 +3.28653370e+05j   9.90933073e+04 +1.60555003e+05j\n   2.28787050e+05 +3.24141951e+05j   2.09781047e+04 +2.31063376e+05j\n  -2.15941453e+05 +1.63773851e+05j  -7.07833051e+04 +1.52467334e+05j\n  -1.37440802e+05 +6.28107674e+04j  -7.07536614e+03 +5.55634993e+03j\n  -4.31009964e+04 -1.74891657e+05j   1.39384348e+05 +1.95956947e+04j\n   1.73613033e+05 +1.16883207e+05j   1.15610357e+05 -2.62619884e+04j\n  -2.05469722e+05 +1.71343186e+05j  -1.56779748e+04 +1.51258101e+05j\n  -2.08639913e+05 +6.07372799e+04j  -2.90623668e+05 -2.79550838e+05j\n  -1.68112214e+05 +4.47877871e+04j  -1.21289916e+03 +1.18397979e+05j\n  -1.55779104e+05 +5.06852464e+04j   1.95309737e+05 +1.93876325e+04j\n  -2.80400414e+05 +6.90079265e+04j   1.25892113e+04 -1.39293422e+05j\n   3.10709174e+04 -1.35248953e+05j   1.31003438e+05 +1.90799303e+05j...\n```\n\n\nI am wondering what exactly these numbers represent and how I would convert these numbers into a percentage of a height for each of the 32 bars.  Also, should I be averaging the 2 channels together?\n    ", "Answer": "\r\nThe array you are showing is the Fourier Transform coefficients of the audio signal. These coefficients can be used to get the frequency content of the audio. The FFT is defined for complex valued input functions, so the coefficients you get out will be imaginary numbers even though your input is all real values. In order to get the amount of power in each frequency, you need to calculate the magnitude of the FFT coefficient for each frequency. This is not just the real component of the coefficient, you need to calculate the square root of the sum of the square of its real and imaginary components. That is, if your coefficient is a + b*j, then its magnitude is sqrt(a^2 + b^2).\n\nOnce you have calculated the magnitude of each FFT coefficient, you need to figure out which audio frequency each FFT coefficient belongs to. An N point FFT will give you the frequency content of your signal at N equally spaced frequencies, starting at 0. Because your sampling frequency is 44100 samples / sec. and the number of points in your FFT is 256, your frequency spacing is 44100 / 256 = 172 Hz (approximately)\n\nThe first coefficient in your array will be the 0 frequency coefficient. That is basically the average power level for all frequencies. The rest of your coefficients will count up from 0 in multiples of 172 Hz until you get to 128. In an FFT, you only can measure frequencies up to half your sample points. Read these links on the Nyquist Frequency and Nyquist-Shannon Sampling Theorem if you are a glutton for punishment and need to know why, but the basic result is that your lower frequencies are going to be replicated or aliased in the higher frequency buckets. So the frequencies will start from 0, increase by 172 Hz for each coefficient up to the N/2 coefficient, then decrease by 172 Hz until the N - 1 coefficient.\n\nThat should be enough information to get you started. If you would like a much more approachable introduction to FFTs than is given on Wikipedia, you could try Understanding Digital Signal Processing: 2nd Ed.. It was very helpful for me.\n\nSo that is what those numbers represent. Converting to a percentage of height could be done by scaling each frequency component magnitude by the sum of all component magnitudes. Although, that would only give you a representation of the relative frequency distribution, and not the actual power for each frequency. You could try scaling by the maximum magnitude possible for a frequency component, but I'm not sure that that would display very well. The quickest way to find a workable scaling factor would be to experiment on loud and soft audio signals to find the right setting.\n\nFinally, you should be averaging the two channels together if you want to show the frequency content of the entire audio signal as a whole. You are mixing the stereo audio into mono audio and showing the combined frequencies. If you want two separate displays for right and left frequencies, then you will need to perform the Fourier Transform on each channel separately.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in C# [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Fast fourier transform in c#  \n\n\n\n\nI am looking for an example of performing a real time FFT (Fast Fourier Transform) of line in or mic audio data in C#. My goal is to determine in real time if a particular note is present in the audio data. Any examples appreciated.\n    ", "Answer": "\r\nAForge.NET is an open-source library with Fast Fourier Transform support.\nExocortexDSP is also another option.\n\nExocortexDSP example would look something like this:\n\n```\n   Exocortex.DSP.ComplexF[] complexData = new Exocortex.DSP.ComplexF[512];\n   for (int i = 0; i < 512; ++i)\n   {\n      // Fill the complex data\n      complexData[i].Re = 1; // Add your real part here\n      complexData[i].Im = 2; // Add your imaginary part here\n   }\n\n   // FFT the time domain data to get frequency domain data\n   Exocortex.DSP.Fourier.FFT(complexData, Exocortex.DSP.FourierDirection.Forward);\n\n   float[] mag_dat_buffer = new float[complexData.Length];\n   // Loop through FFT'ed data and do something with it\n   for (int i = 0; i < complexData.Length; ++i)\n   {\n      // Calculate magnitude or do something with the new complex data\n      mag_data_buffer[i] = ImaginaryNumberMagnitude(complexData[i].Im, complexData[i].Re);\n   }\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "When calculating the fast Fourier transform..?\r\n                \r\nIf we get the sound from microphone with two channels, to calculate the frequency spectrum we:\n\n\ncalculate the fast fourier transform of all the data input?\ncalculate the fast fourier transform of each left and right channel and then make a average of both?\ncalculate the fast fourier transform of each left and right channel and get the biggest values of both?\ncalculate in a different way?\n\n    ", "Answer": "\r\nI assume your two-channel microphone has inputs that are physically separate - typically, opposite sides of a lecture hall or theater. In this case, the Fourier transform of each channel shows you the frequency content at the physical location of that channel's input - you can't just average them or add them together and get any meaningful result.\n\nIf you're trying to get the spectrum at the midpoint between the channel inputs, averaging might make sense, but anything else would require some big assumptions (reflection not a factor, etc) and interpolation. \n\nAny meaningful analysis of this data is going to have to take into account the physical geometry of the space where the sound is sampled. Clarify what you're looking for. \n\nOh, and tag your posts as homework.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in R\r\n                \r\nI have a dataset with the number of hourly visits an animal made during a period of 12 months. I want to use the Fast Fourier Transform to examine cyclical patterns and periodicity. In the past, I have used Statistica for this this; however, I would like to use R to get a plot of the spectral density vs. period. Is there an easy way to do this in R? I would like to identify 12 and 24 hr peak in activity if possible.\n    ", "Answer": "\r\nYou may consider the following functions.\n\n\n```\nperiodogram```\n from ```\nTSA```\n package immediately plots a periodogram.\n```\nperiodogram```\n from ```\nGeneCycle```\n returns a list of frequencies and estimated power spectral densities. It is a wrapper function for ```\nstats::spectrum```\n with some special options set.\n```\nspectrum```\n from ```\nstats```\n allows you to choose the method used to estimate the spectral density: either periodogram or using autoregressive process.\n```\ncpgram```\n from ```\nstats```\n plots a cumulative periodogram along with a confidence interval.\n\n\nSee, e.g., ```\n?cpgram```\n or ```\n?spectrum```\n for all the details and keep in mind that it is, e.g., ```\nTSA::periodogram```\n and ```\nGeneCycle::periodogram```\n when names of the functions coincide.\n\nThere are also plenty of examples and tutorials online on how to use those functions. See here for the usage of ```\nfft```\n and here for an even more extensive tutorial.\n\nAlso, as you probably already know, a given time series must be detrended. Hence, use, e.g., ```\ndiff(x)```\n instead of ```\nx```\n. And finally, the length of your time series must be divisible by 12 as to be able to identify 12 and 24 hours frequencies, it can be achieved by, e.g., ```\nx[-(1:(length(x) %% 12))]```\n, where ```\nx```\n is a detrended time series.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform in Erlang\r\n                \r\nI am looking for an example of using FFT (Fast Fourier Transform) in Erlang. Can show me an example of code?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform of a signal\r\n                \r\nI have an excel file which has time and magnitute columns of a signal. The signal is overlap of 4 different signals. It has 100 data points for a second and continues for 10 mins. How can I take Fast Fourier Transform of this signal?\nI have searched what Fast Fourier Transform is but I couldn't find any way to implement it.\nenter image description here\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transformation in Java [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Reliable and fast FFT in Java  \n\n\n\n\ni want to implement a fast fourier transformation calculation in java. Is there any library in java to do calculation in fourier transform and i also want to know about the audio libraries in java.\n    ", "Answer": "\r\nMay be a duplicate, but you're probably going to have a challenge making a JNI/NDK setup work. Consider a full java solution with JTransforms\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Plotting a fast Fourier transform in Python\r\n                \r\nI have access to NumPy and SciPy and want to create a simple FFT of a data set. I have two lists, one that is ```\ny```\n values and the other is timestamps for those ```\ny```\n values.\nWhat is the simplest way to feed these lists into a SciPy or NumPy method and plot the resulting FFT?\nI have looked up examples, but they all rely on creating a set of fake data with some certain number of data points, and frequency, etc. and don't really show how to do it with just a set of data and the corresponding timestamps.\nI have tried the following example:\n```\nfrom scipy.fftpack import fft\n\n# Number of samplepoints\nN = 600\n\n# Sample spacing\nT = 1.0 / 800.0\nx = np.linspace(0.0, N*T, N)\ny = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x)\nyf = fft(y)\nxf = np.linspace(0.0, 1.0/(2.0*T), N/2)\nimport matplotlib.pyplot as plt\nplt.plot(xf, 2.0/N * np.abs(yf[0:N/2]))\nplt.grid()\nplt.show()\n```\n\nBut when I change the argument of ```\nfft```\n to my data set and plot it, I get extremely odd results, and it appears the scaling for the frequency may be off. I am unsure.\nHere is a pastebin of the data I am attempting to FFT\nhttp://pastebin.com/0WhjjMkb\nhttp://pastebin.com/ksM4FvZS\nWhen I use ```\nfft()```\n on the whole thing it just has a huge spike at zero and nothing else.\nHere is my code:\n```\n## Perform FFT with SciPy\nsignalFFT = fft(yInterp)\n\n## Get power spectral density\nsignalPSD = np.abs(signalFFT) ** 2\n\n## Get frequencies corresponding to signal PSD\nfftFreq = fftfreq(len(signalPSD), spacing)\n\n## Get positive half of frequencies\ni = fftfreq>0\n\n##\nplt.figurefigsize = (8, 4)\nplt.plot(fftFreq[i], 10*np.log10(signalPSD[i]));\n#plt.xlim(0, 100);\nplt.xlabel('Frequency [Hz]');\nplt.ylabel('PSD [dB]')\n```\n\nSpacing is just equal to ```\nxInterp[1]-xInterp[0]```\n.\n    ", "Answer": "\r\nSo I run a functionally equivalent form of your code in an IPython notebook:\n```\n%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fftpack\n\n# Number of samplepoints\nN = 600\n# sample spacing\nT = 1.0 / 800.0\nx = np.linspace(0.0, N*T, N)\ny = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x)\nyf = scipy.fftpack.fft(y)\nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\n\nfig, ax = plt.subplots()\nax.plot(xf, 2.0/N * np.abs(yf[:N//2]))\nplt.show()\n```\n\nI get what I believe to be very reasonable output.\n\nIt's been longer than I care to admit since I was in engineering school thinking about signal processing, but spikes at 50 and 80 are exactly what I would expect. So what's the issue?\nIn response to the raw data and comments being posted\nThe problem here is that you don't have periodic data. You should always inspect the data that you feed into any algorithm to make sure that it's appropriate.\n```\nimport pandas\nimport matplotlib.pyplot as plt\n#import seaborn\n%matplotlib inline\n\n# the OP's data\nx = pandas.read_csv('http://pastebin.com/raw.php?i=ksM4FvZS', skiprows=2, header=None).values\ny = pandas.read_csv('http://pastebin.com/raw.php?i=0WhjjMkb', skiprows=2, header=None).values\nfig, ax = plt.subplots()\nax.plot(x, y)\n```\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Symmetric Fast Fourier Transform\r\n                \r\nI have vector ```\ns```\n in R with values. I just used the function ```\nfft(s)```\n to calculate the Fast Fourier Transform. Then I printed the values into\n\nwhere x is simple ```\n1,...length(fft(s))```\n. I see a strong symmetry here - why is that? I expected something like\n\nWhat am I doing wrong?\n\nHere is a MWE for the first plot:\n\n```\ndf <- structure(list(value = c(3, 1537.68157138987, 531.727745627154, \n8.50387522397935, 5.40309722205537, 2.30232661295167, 0.420000953675226, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4.73469069995451, -829.997919240523, \n-3919.09161844073, -6460.79922752307, -6507.49592868557, -4849.27485532219, \n-1674.36434175734, -83.1428571428571, -2.55813257187214, -261.182084182236, \n-2915.2762208206, -5668.7235841082, -6990.36364128962, -6997.7273121356, \n-6211.86050115633, -4378.77236521268, -1421.9056880109, -30.3635181412285, \n-3.58181865471396, -2408.88296333223, -3106.95655095245, -6482.32762645408, \n-6111.41765122797, -1821.04333977064, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 41.499896933588, 998.907991416867, 3778.2752099702, \n6543, 7005.95412518948, 6995.72726353206, 6293.82005765438, 3269.99904633924, \n592.910420911179, 2, 1378.82116693398, 4391.17937491872, 6822.45459767001, \n6220.908446583, 3447.42762806772, 581, 10.2727745627154, 873.056274992053, \n3248.72737676457, 3776.64174236464, 3779.59937375451, 2711.30950879224\n)), .Names = \"value\", row.names = c(NA, -182L), class = \"data.frame\")\nfft_res <- fft(df$value)\nggplot(data.frame(x = 1:length(fft_res), value = Mod(fft_res)), aes(x,value)) + geom_line()\n```\n\n    ", "Answer": "\r\nSymmetry is a fundamental property of an FFT applied\nto real-valued data (```\nfft()```\n returns the values for both positive and negative frequencies). For example,\n\n```\nx = 1:8\nfft(x)\n## [1] 36+0.000000i -4+9.656854i -4+4.000000i -4+1.656854i -4+0.000000i\n## [6] -4-1.656854i -4-4.000000i -4-9.656854i\n\nMod(fft(x))\n## [1] 36.000000 10.452504  5.656854  4.329569\n## [5]  4.000000  4.329569  5.656854 10.452504\n```\n\n\nHere are the corresponding frequencies\n(there's probably a simpler way ...)\n\n```\nfreqs = seq(0,1/2,by=1/8)\nfreqs = c(freqs,-rev(freqs[-c(1,5)]))\n## [1]  0.000  0.125  0.250  0.375  0.500\n## [6] -0.375 -0.250 -0.125\n```\n\n\nSo for real-valued input you only need to keep the\nfirst half of the output. There are more\nefficient FFT algorithms for real-valued\ninput, but I don't know offhand if there are any\nR packages that implement them.\n\nSymmetry no longer holds for complex-valued input:\n\n```\nset.seed(101); fft(x+rnorm(8)*1i)\n# [1] 36.000000+ 1.756632i\n# [2] -5.501913+ 8.349288i\n# [3] -2.375197+ 4.040887i\n# [4] -2.914446+ 1.690809i\n# [5] -4.000000- 1.899475i\n# [6] -5.085554- 1.622900i\n# [7] -5.624803- 3.959113i\n# [8] -2.498087-10.964420i\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "GSL Fast-Fourier Transform - Nonsense Output\r\n                \r\nThe Fourier transform of a gaussian is a gaussian, but for some reason the fast Fourier transform library from GSL (GNU scientific library) doesn't give this at all. I've included the code I've used to generate the (attempted) Fourier transform, and two relevant plots right after it. Could help me identify what I've messed up?\n\n```\n#include <gsl/gsl_fft_complex.h>\n#include <fstream>\n\n#define REAL(z,i) ((z)[2*(i)]) //complex arrays stored as    \n#define IMAG(z,i) ((z)[2*(i)+1])\n\nusing namespace std;\n\nint main(){\n\ndouble N = pow(2,9); //power of 2 for Cooley-Tukey algorithm\nint n = (int) N;\n\ndouble f[2*n];\ndouble dx = 10./N;\ndouble x = -5.;\nofstream fileo(\"out.txt\");\n\nfor (int i=0; i<n; ++i){      //initialize gaussian\n    REAL(f,i)=exp(-0.5*x*x);  \n    IMAG(f,i)=0.;\n    x+=dx;\n   }\n\n   gsl_fft_complex_radix2_forward(f, 1, n);  //Fourier transform\n\n   for (int i=0; i<n; ++i){\n        fileo<<i<<\" \"<<REAL(f,i)<<'\\n';  //plot frequency distribution\n   }\n\n   fileo.close();\n}\n```\n\n\n\n\n\n\n\n\nEDIT: Solved!\n\nAs stated in @roadrunner66's answer, the width of the original Gaussian was very broad, leading to a ridiculously narrow Gaussian in Fourier space. Moreover, my plot looked funky because, as suggested in @n.m's (now removed) comment, the Fourier transform returns the DFT with projections onto k-values indexed as k=0,1,...,N/2,-N/2,...-2,-1.\n\n\n    ", "Answer": "\r\nIt looks good to me. Shift the output vector by N/2 and plot the absolute value of the output, rather than the real part. \n\nAlso note that your input Gaussian is rather wide, which makes it's spectrum very narrow. Check the analytical solution for that case for comparison.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform algorithm implementation with MapReduce\r\n                \r\nI want to implement a Fast Fourier Transform algorithm with MapReduce. I know of a recursive-FFT algorithm but I need your guideline in order to implement it using a Map/Reduce approach. \n\nAny suggestions/references?\n    ", "Answer": "\r\nThe basic idea that we can use some theorems to divide problem into subproblems. \n\nIn case of Fourier Transfom, problem is standard definition of FT:\n\n\n\nAfter applying Cooley–Tukey FFT algorithm we can split it to two subproblems:\n\n\n\nMoving forward with that transfomation, theoretically it could be solved with parallel programming.\n\nMaybe, you'll find following links useful:\n\n\nSchönhage-Strassen Algorithm with MapReduce\nfor Multiplying Terabit Integers\nFFT with MapReduce\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for images\r\n                \r\nI have a problem that is associated with Fast Fourier Transform of an image. I've made an application with some filters for an images. It's a program with ```\nJLabel```\ns for displaying images before and after filtration and ```\nJButton```\ns for filters. So, my problem is with FFT for an image. I've seen examples for that transformation, but I really don't know how to use that in my program. I don't know how to start that.\n    ", "Answer": "\r\nIf you have obtained the 2-D FFT code and just need to apply the function, you can read the prototype of the FFT function, i.e., the data structure of the inputs and outputs, and then prepare the data to call the function.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transformation in WinForms [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI write an application on VS-2008 (WinForms, C++) \nNeed a Fast Fourier transformation Library. \nCan anybody advise a good one?\n    ", "Answer": "\r\nI strongly recommend FFTW over anything else.  It is fast, reliable, widely used, portable.  Yes, you will have to call from managed code into unmanaged code.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "implementing Fast Fourier Transform in MSP430 microcontroller\r\n                \r\nI am trying to perform image processing operations in msp430 microcontrollers.\nIs it possible to implement 2d fast fourier transform in MSP430 microcontrollers?\nAnd im looking for an fft library for msp430. Where can i find it?\n    ", "Answer": "\r\nFinally i solved it using 2 pass 1D FFT algorithm:\nCode:\nhttps://github.com/dhyandeep/skynet\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform FFT for Lua?\r\n                \r\nDoes anyone have an implementation of the Fast Fourier Transform, that works with Lua ?\n\nI want to use it on a sound sample, which I've loaded into Lua as an array of 16 bit signed ints. I wish to FFT the data and plot the freq spectrum.\n\nI need an implementation that will work with Ansca Corona's version of Lua (loadstring not supported, which is used by complex.lua)\n    ", "Answer": "\r\nYou should have a look at LuaFFT. It's MIT licensed, so it should be fairly flexible to use.\n\nEDIT : You could also take a look at NumLua. Here is its github site. It depends on BLAS/LAPACK, FFTW, and HDF5. You may be able to get this to work since it implements its own complex number data-type. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Spike centered on zero in fast Fourier transform\r\n                \r\nI have time associated data that I would like to perform a Fourier transform on. Data is located at http://pastebin.com/2i0UGJW9. The problem is that the data is not uniformly spaced. To solve this, I attempted to interpolate the data and then perform the Fast Fourier Transform.\n\n```\nimport numpy as np\nfrom scipy.fftpack import fft, fftfreq, fftshift \nfrom scipy.interpolate import interp1d \nimport matplotlib.pyplot as plt\n\nx = np.linspace(min(times), max(times), len(times))\ny = interp1d(times, data)(x)\nyf = fft(y)\nxf = fftfreq(len(times), (max(times)-min(times))/len(times))\nxf = fftshift(xf)\nyplot = fftshift(yf)\nplt.figure()\nplt.plot(xf, 1.0/len(times) * np.abs(yplot))\nplt.grid()\nplt.show()\n```\n\n\nHowever, this gives a single spike centered on zero instead of an expected frequency graph. How can I get this to give accurate results?\n    ", "Answer": "\r\nAs I don't have enough reputation to post a comment, I'll post my suggestions as an answer and hope one of them does lead to answer.\n\nInterpolation\n\nIt's probably wiser to interpolate onto a grid that is quite a bit finer than what you are doing. Otherwise your interpolation will smooth the noisy data in an unpredictable fashion. If you want to smooth the data, you'd better do this via the FFT (this might be the whole point of the exercise...) \n\nThe time data has a minimum interval of 24, you should probably use an interpolation grid of about half that. Better still, the time intervals are not constant, but they are very regular. After typing ```\nprint times % 24```\n it seems a good grid to use would be ```\nnp.arange(min(times), max(times)+1, 24)```\n. Note that the ```\n+1```\n is just to include the last time too.\n\nNon-periodic data\n\nYour data is not periodic, but the FFT treats it as if it were. This means it sees a large jump between the first and last data points. You should look at the FFT documentation on how to tell it to perform an expansion of the data.\n\nAnd of course\n\nThe spike at frequency zero is just a consequence of the fact that your signal does not have mean zero. \n\nHope this was of help.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "The Fast Fourier Transform Transform of Image Processing\r\n                \r\nI am learning FFT for processing images with Matlab. I have already know some basic stuff but for the product of the results of two FFT, I do not quite understand. \n\nSo I want to know what will happen after we multiply the results of the Fast Fourier Transform. Can someone provide me with the example?\n    ", "Answer": "\r\nMultiplication in the frequency domain is equivalent to convolution in the spatial domain.\n\nThis is typically exploited when you have a large filter kernel and an image that you want to convolve with this filter. Instead of performing the convolution directly (which can be computationally expensive for large kernels) the FFT of the image and the (padded) filter kernel is taken, the two are multiplied and an inverse FFT is applied to the product.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Applying CNN to Fast time Fourier Transform?\r\n                \r\nI have data that fast time fourier transform is applied.\n(amplitudes at specific Hzs)\nThere are solutions on internet that CNN is applied to mel spectrogram, however, I see no solution that CNN is applied to Fast Fourier Transformed signal.\nIs it possible that CNN is applied to Fast Fourier Transformed signals?\nOr is it not possible because CNN is considering temporal attribute?\nThanks!\n    ", "Answer": "\r\nI'm assuming each row of your spreadsheet is IID, e.g. it wouldn't change the problem to re-order the rows in that spreadsheet.\nIn this case you have a pretty typical ML problem. The fact that the FFT has already been applied and specific frequency responses (columns) have been extracted is a process called \"feature engineering\". Prior to the common use of neural networks, this was a standard step in all machine learning problems and remains common to a great many domains.\nWith data that has been feature engineered, you should look to traditional ML algorithms. Random Forests, XGBoost, and Linear Regression come to mind. A fully connected neural network is also appropriate, but I would typically expect it to under-perform other ML methods.\nThe hallmark of a CNN is that it operates on an ordered sequence of data. In your case the raw data, from which your dataset was derived, would be appropriate for a CNN. In a sound file you have a 1D sequence of information. You could not re-order the data in the time dimension without fundamentally changing its meaning.\nA 2D CNN operates over an image where the pixel order in X and Y cannot be changed. Again the sequential order of the data matters. The same applies for 3D CNNs.\nBe aware that the application of a FFT has fundamentally biased your solution by representing it only in a limited set of frequency responses. All feature engineering is fundamentally biasing the problem, presumably in a well thoughout-out way. However, it's entirely possible that other useful signals in the data exist, which aren't expressed by the FFT @ 10, 20, 30 Hz, etc. The CNN has the capacity to learn its own version of an FFT as well as other non cyclic patterns. Typically, the lack of a feature engineering step is the key differentiator between the CNN and traditional ML algorithms.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Frequency computation and fast fourier transform in Matlab\r\n                \r\nI have a question related to Fast Fourier transform. I want to calculate the phase and make FFT to draw power spectral density. However when I calculate the frequency ```\nf```\n, there are some errors. This is my program code:\n\n```\nn = 1:32768;\n\nT = 0.2*10^-9; % Sampling period\n\nFs = 1/T; % Sampling frequency\n\nFn = Fs/2; % Nyquist frequency\n\nomega = 2*pi*200*10^6; % Carrier frequency\n\nL = 32768; % % Length of signal\n\nt = (0:L-1)*T; % Time vector\n\nx_signal(n) = cos(omega*T*n + 0.1*randn(size(n))); % Additive phase noise (random)\n\ny_signal(n) = sin(omega*T*n + 0.1*randn(size(n))); % Additive phase noise (random)\n\ntheta(n) = atan(y_signal(n)/x_signal(n));\n\nf = (theta(n)-theta(n-1))/(2*pi)\n\nY = fft(f,t);\n\nPSD = Y.*conj(Y); % Power Spectral Density\n\n%Fv = linspace(0, 1, fix(L/2)+1)*Fn; % Frequency Vector\n```\n\n    ", "Answer": "\r\nAs posted, you would get the error \n\n\n```\nerror: subscript indices must be either positive integers less than 2^31 or logicals\n```\n\n\n\nwhich refers to the operation ```\ntheta(n-1)```\n when ```\nn=1```\n which results in an index of 0 (which is out of bounds since Matlab uses 1-based indexing). To avoid that could use a subset of indices in ```\nn```\n:\n\n```\nf = (theta(n(2:end))-theta(n(1:end-1)))/(2*pi);\n```\n\n\nThat said, if you are doing this to try to obtain an instantaneous measure of the frequency, then you will have a few more issues to deal with. The most trivial one is that you should also divide by ```\nT```\n. Not as obvious is the fact that as given, ```\ntheta```\n is a scalar due to the use of the ```\n/```\n operator (see Matlab's ```\nmrdivide```\n) rather than the ```\n./```\n operator which performs element-wise division. So a better expression would be:\n\n```\ntheta(n) = atan(y_signal(n)./x_signal(n));\n```\n\n\nNow, the next problem you might notice is that you are actually losing some phase information since the result of ```\natan```\n is ```\n[-pi/2,pi/2]```\n instead of the full ```\n[-pi,pi]```\n range. To avoid this you should instead be using ```\natan2```\n:\n\n```\ntheta(n) = atan2(y_signal(n), x_signal(n));\n```\n\n\nEven with this, you are likely to notice that the estimated frequency regularly has spikes whenever the phase jumps between near ```\n-pi```\n and near ```\npi```\n. This can be avoided by computing the phase difference modulo ```\n2*pi```\n:\n\n```\nf = mod(theta(n(2:end))-theta(n(1:end-1)),2*pi)/(2*pi*T);\n```\n\n\nA final thing to note: when calling the ```\nfft```\n, you should not be passing in a time variable (the input is implicitly assumed to be sampled at regular time intervals). You may however specify the desired length of the FFT. So, you would thus compute ```\nY```\n as follow:\n\n```\nY = fft(f, L);\n```\n\n\nAnd you could then plot the resulting ```\nPSD```\n using:\n\n```\nFv = linspace(0, 1, fix(L/2)+1)*Fn; % Frequency Vector\nplot(Fv, abs(PSD(1:L/2+1)));\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Apodization Mask for Fast Fourier Transforms in Python\r\n                \r\nI need to do a Fourier transform of a map in Python. Fast Fourier Transforms expect periodic boundary conditions, but the input map is not periodic. So I need to apply an input filter/weight slowly tapering the map toward zero at the edges. Are there libraries for doing this in python? \n    ", "Answer": "\r\nMy favorite function to apodize a map is the generalized Gaussian (also called 'Super-Gaussian' which is a Gaussian whose exponent is raised to a power P.  By setting P to, say, 4 or 6 you get a flat-top pulse which falls off smoothly, which is good for FFT applications where sharp edges always create ripples in conjugate space. \n\nThe generalized Gaussian is available on Scipy. Here is a minimal code (Python 3) to apodize a 2D array with a generalized Gaussian. As noted in previous comments, there are dozens of functions which would work just as well. \n\n```\nimport numpy as np\nfrom scipy.signal import general_gaussian\n\n# A 128x128 array\narray =  np.random.rand(128,128)\n# Define a general Gaussian in 2D as outer product of the function with itself\nwindow = np.outer(general_gaussian(128,6,50),general_gaussian(128,6,50))\n# Multiply\nap_array = window*array\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Comparative analysis of Fast Fourier Transform (FFT) algorithms on Android? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nHas anyone done a comparative analysis of Fast Fourier Transform (FFT) algorithms on Android platform? \n\nWhich implementation is the fastest so far?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fast fourier transform of csv data\r\n                \r\nI have a csv file that contains time and torque data.  https://pastebin.com/MAT2rG3U  This data set is truncated because size limit.\nI am trying to find the FFT of the data to find the frequency of a vibration.\nHere is my code (here is the example I used Fast Fourier Transform in Python ), it does not produce any results. I've researched many online resources and can not find my error\n```\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\ndata = pd.read_csv('data.csv',index_col=0)\ndata = data['Torque'].astype(float).values\nprint(data)\n\nN = data.shape[0] #number of elements\nt = np.linspace(0, 300, N) \n#t=np.arange(N)\ns = data\n\nfft = np.fft.fft(s)\nfftfreq = np.fft.fftfreq(len(s))\n\nT = t[1] - t[0]\nprint(T)\n\nf = np.linspace(0, 1 / T, N)\nplt.ylabel(\"Amplitude\")\nplt.xlabel(\"Frequency [Hz]\")\nplt.plot(fftfreq,fft)\n#plt.xlim(0,100)\n\nplt.show()\n```\n\n    ", "Answer": "\r\nWhat you've posted works for me, but your data isn't valid for an FFT because the timesteps aren't consistent.  That is, you don't have a well defined sample rate.\n```\ndata = pd.read_csv('torque_data.txt',index_col=0)\ndata = data['Torque'].astype(float).values\nprint(data)\n\nN = data.shape[0] #number of elements\nt = np.linspace(0, 300, N) \n#t=np.arange(N)\ns = data\n\nfft = np.fft.fft(s)\nfftfreq = np.fft.fftfreq(len(s))\n\nT = t[1] - t[0]\nprint(T)\n\nf = np.linspace(0, 1 / T, N)\nplt.ylabel(\"Amplitude\")\nplt.xlabel(\"Frequency [Hz]\")\nplt.plot(fftfreq, np.absolute(fft))\n#plt.xlim(0,100)\n```\n\n\nThere's probably something wrong with the data that you didn't include in the sample that's giving you the NaNs.\nStill, in the data you provided, the sample rate isn't consistent, which is required for an FFT.  To see this, plot a histogram of the time steps:\n```\n# read in the data like this to get the times\ndata = pd.read_csv('torque_data.txt')\ntime = data['Seconds'].astype(float).values\ndata = data['Torque'].astype(float).values\n\n# now look at the timesteps\nfig, axs = plt.subplots()\ntime_deltas = t[1:]-t[:-1]\nh = axs.hist(time_deltas, bins=50)\n```\n\n\nBecause so many of the timesteps have different values, I'd be worried about trusting the FFT.  (When I first looked at your data, most of the earlier points seemed to have the 0.004s timestep, so I wonder if your data collection is changing over time and not just randomly, but whatever, you need to sort this out too.)  There are solutions to this, like interpolation/resampling, or down-sampling, but one can't reliably trust the FFT results without a fix.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What is the Fast Fourier Transform? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI was asked an interview question where I needed to use it but I have no idea what it is.\nSo in plain english what is the Fast Fourier Transform and how can I use it to find the derivative of a function given its (x, y) values as input?  \n\nHow would you implement it?  \n\nEDIT:\nI am asking this because given a sequence of (x, y) values I needed to calculate how the function looks like, derive it and find the number of times it is constantly changing (that is, (0, 1), (1, 2) is counted as one) or does not change at all (0, 5), (1, 5) is also counted as one change).\n    ", "Answer": "\r\nAs for the first part of the question, a former Physics professor, Bartosz Milewski, has a very nice explanation, what FFT is and how it works.\n\nAlso, Mastering The Fourier Transform in One Day is worth reading as well.\n\nIn English (?)\n\nSay you have a sound coming from the speaker.\n\nYou then set up, let's get a nice round number here, 1024 harmonic oscillators that resonate to specific frequency ranges.\n\nPlay the sound for, say, a second.\n\nOscillators begin to resonate to the sound coming from the speaker. After the said second you read how much every oscillator is resonating. As a result you get a discrete fourier transform, meaning you get a chart of how much each of the frequency ranges contributed to the sound coming from the speaker.\n\nInstead of visualising the sound as amount of air pressure caused by the waveform, changing in time slots, you visualized it as a series of intensities of the frequency ranges.\n\nOf course in explaining the DFT, the speakers part is not really appropriate since you have to work on sampled input. So in this case the 1024 digital \"oscillators\" should actually be measured after 1/44th of a second, given the audio is sampled at the rate of 44kHz.\n\nFast Fourier Transform is an algorithm to perform a Discrete Fourier Transform that's pretty easy for computers to run on an incoming signal. It imposes some constraints you have to work with in your implementation (e.g. the number of samples has to be a power of 2), because it uses some clever tricks to drastically reduce the amount of calculation performed on the sample buffer.\n\nThere is really no need to go deeper, since the two links I gave provide a pretty clear explanation. And note that it's impossible to go from theory to implementation without knowing the math behind it.\n\nI hope this introduction makes some sense!\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for non log 2\r\n                \r\nI want to implement Fast Fourier Transform in Java for chord recognition, but I don't really get it. It says that the number of samples should be a power of 2, so what should we do for a song that doesn't have number of samples equal to a power of 2? Also I would like to know about the STFT.\n    ", "Answer": "\r\nYou normally generate an STFT over a sliding window throughout your file. The size of the window is chosen to give a reasonable time period over which the characteristics of the sound do not change greatly. Typically a window might be around 10 ms, so if your sample rate is 44.1kHz for example, then you might use a window size N = 512, so that you get the required duration and a power of 2 in size. You then take successive chunks of size N samples through the file, and generate the FFT for each N point chunk. (Note: in most cases you actually want the magnitude of the FFT output, in order to get an estimate of the power spectrum.) For increased resolution the chunks can overlap, e.g. by 50%, but this increases the processing load of course. The end result is a succession of short term spectra, so in effect you have a 3D matrix (amplitude v frequency v time) which describes the contents of the sound in the frequency domain.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to convert image in fast fourier transform signal?\r\n                \r\nI am trying to convert image into fast fourier transform signal and used the following peace of code:\n```\nfake_A1 = tf.signal.fft2d(fake_A1)\n```\n\nwhere input image type is: <class 'numpy.ndarray'> but I am getting following error:\n```\ntensorflow.python.framework.errors_impl.InvalidArgumentError: Value for attr 'Tcomplex' of float is not in the list of allowed values: complex64, complex128\n; NodeDef: {{node FFT2D}}; Op<name=FFT2D; signature=input:Tcomplex -> output:Tcomplex; attr=Tcomplex:type,default=DT_COMPLEX64,allowed=[DT_COMPLEX64, DT_COMPLEX128]> [Op:FFT2D]\n```\n\nHow may I make it solve?\n    ", "Answer": "\r\nP.S.: If you want to make edits then do it on your question, not as an answer.\nNow coming to the topic: 2D FFT of an image. Firstly an image is of shape:\n```\nimage.shape = (3,rows,columns)\n```\n\nWhere 3 stands for 3 matrices which are of 2 dimensions, corresponding to RGB. Hence to carry out 2D FFT, we first need to flatten this by converting it to grayscale. I found a useful tutorial here on ThePythonCodingBook. Ill add the code here for TL:DR purposes.\n```\nimport matplotlib.pyplot as plt\nimage_filename = \"Earth.png\"\n# Read and process image\nimage = plt.imread(image_filename)\nimage = image[:, :, :3].mean(axis=2)  # Convert to grayscale\nprint(image.shape)\nplt.set_cmap(\"gray\")\nplt.imshow(image)\nplt.axis(\"off\")\nplt.show()\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimage_filename = \"Earth.png\"\ndef calculate_2dft(input):\n    ft = np.fft.ifftshift(input)\n    ft = np.fft.fft2(ft)\n    return np.fft.fftshift(ft)\n# Read and process image\nimage = plt.imread(image_filename)\nimage = image[:, :, :3].mean(axis=2)  # Convert to grayscale\nplt.set_cmap(\"gray\")\nft = calculate_2dft(image)\nplt.subplot(121)\nplt.imshow(image)\nplt.title('Grayscale Image')\nplt.axis(\"off\")\nplt.subplot(122)\nplt.imshow(np.log(abs(ft)))\nplt.title(\"2D FFT\")\nplt.axis(\"off\")\nplt.show()\n```\n\nI'll add the grayscale and FFT plots as well.\n\nHope this helps.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Generating correlated random potential using fast Fourier transform\r\n                \r\nI would like to generate a random potential in 1D or 2D spaces with a specified autocorrelation function, and according to some mathematical derivations including the Wiener-Khinchin theorem and properties of the Fourier transforms, it turns out that this can be done using the following equation:\n\nwhere ```\nphi(k)```\n is uniformly distributed in interval [0, 1). And this function satisfies , which is to ensure that the potential generated is always real. \nThe autocorrelation function should not affect what I am doing here, and I take a simple Gaussian distribution . \n\nThe choice of the phase term and the condition of ```\nphi(k)```\n is based on the following properties\n\n\nThe phase term must have a modulus of 1 (by Wiener-Khinchin theorem, i.e. the Fourier transform of the autocorrelation of a function equals the modulus of the Fourier transform of that function);\nThe Fourier transform of a real function must satisfy  (by directly inspecting the definition of Fourier transform in integral form). \nBoth the generated potential and the autocorrelation are real.\n\n\nBy combining these three properties, this term can only take the form as stated above. \n\nFor the relevant mathematics, you may refer to p.16 of the following pdf:\nhttps://d-nb.info/1007346671/34\n\nI randomly generated a numpy array using uniform distribution and concatenated the negative of the array with the original array, such that it satisfies the condition of ```\nphi(k)```\n stated above. And then I performed the numpy (inverse) fast Fourier transform. \n\nI have tried both 1D and 2D cases, and only the 1D case is shown below. \n\n```\nimport numpy as np\nfrom numpy.fft import fft, ifft\nimport matplotlib.pyplot as plt\n\n## The Gaussian autocorrelation function \ndef c(x, V0, rho):\n    return V0**2 * np.exp(-x**2/rho**2) \n\nx_min, x_max, interval_x = -10, 10, 10000\nx = np.linspace(x_min, x_max, interval_x, endpoint=False)\n\nV0 = 1\n## the correlation length\nrho = 1 \n\n## (Uniformly) randomly generated array for k>0\nphi1 = np.random.rand(int(interval_x)/2)\nphi = np.concatenate((-1*phi1[::-1], phi1))\nphase = np.exp(2j*np.pi*phi)\n\nC = c(x, V0, rho) \nV = ifft(np.power(fft(C), 0.5)*phase)\nplt.plot(x, V.real)\nplt.plot(x, V.imag)\nplt.show()\n```\n\n\nAnd the plot is similar to what is shown as follows:\n.\n\nHowever, the generated potential turns out to be complex, and the imaginary parts are of the same order of magnitude as that of the real parts, which is not expected. I have checked the math many times, but I couldn't spot any problems. So I am thinking whether it's related to the implementation problems, for example whether the data points are dense enough for Fast Fourier Transform, etc.\n    ", "Answer": "\r\nYou have a few misunderstandings about how ```\nfft```\n (more correctly, DFT) operates. \nFirst note that DFT assumes that the samples of the sequence are indexed as ```\n0, 1, ..., N-1```\n, where ```\nN```\n are the number of samples. Instead, you generate a sequence corresponding to indices ```\n-10000, ..., 10000```\n. Second, note that the DFT of a real sequence will generate real values for the \"frequencies\" corresponding to ```\n0```\n and ```\nN/2```\n. You also seem to not take this into account. \n\nI won't go into further details as this is out of the scope of this stackexchange site. \n\nJust for a sanity check, the code below generates a sequence that has the properties expected for the DFT (FFT) of a real-valued sequence:\n\n\nconjugate symmetry of positive and negative frequencies,\nreal-valued elements corresponding to frequencies ```\n0```\n and ```\nN/2```\n\nsequence assumed to correspond to indices ```\n0```\n to ```\nN-1```\n\n\n\nAs you can see, the ```\nifft```\n of this sequence indeed generates a real-valued sequence\n\n```\nfrom scipy.fftpack import ifft\n\nN = 32 # number of samples\nn_range = np.arange(N) # indices over which the sequence is defined\nn_range_positive = np.arange(int(N/2)+1) # the \"positive frequencies\" sample indices\nn_range_negative = np.arange(int(N/2)+1, N) # the \"negative frequencies\" sample indices\n\n# generate a complex-valued sequence with the properties expected for the DFT of a real-valued sequence\nabs_FFT_positive = np.exp(-n_range_positive**2/100)\nphase_FFT_positive =  np.r_[0, np.random.uniform(0, 2*np.pi, int(N/2)-1), 0] # note last frequency has zero phase\nFFT_positive = abs_FFT_positive * np.exp(1j * phase_FFT_positive)\nFFT_negative = np.conj(np.flip(FFT_positive[1:-1]))\nFFT = np.r_[FFT_positive, FFT_negative] # this is the final FFT sequence\n\n# compute the IFFT of the above sequence\nIFFT = ifft(FFT)\n\n#plot the results\n\nplt.plot(np.abs(FFT), '-o', label = 'FFT sequence (abs. value)')\nplt.plot(np.real(IFFT), '-s', label = 'IFFT (real part)')\nplt.plot(np.imag(IFFT), '-x', label = 'IFFT (imag. part)')\nplt.legend()\n```\n\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how to apply Fast Fourier Transform using multiple .csv files\r\n                \r\nI am a beginner in python and i need help. I have a vibration data of 5 different pumps in .csv format each csv file  have 4 columns(time, ax, ay, and az) and multiple rows. Can anyone help me how to apply fast Fourier transform  and plot them and also how to plot them before applying fast fourier transform.\ni try to plot them but could get the required and clear results. Thanks\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fftpack import fft, ifft\nimport pandas as pd\nfrom pandas import DataFrame\n\n# Import csv file\ndata = pd.read_csv(\"dry pump_6h data_acceleration.csv\")\nprint(data.head()) \n# plot data\ndf.plot(linestyle = '', marker = '*', color='r')\nplt.show()\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform using NumPy: why it looks like this?\r\n                \r\nFast Fourier Transform is fast method of Discrete Fourier Transformation calculation, as far as I understood.\n\nI've been playing with NumPy math library, as so has such plot with this code:\n\n```\nimport numpy as np\nfrom numpy.fft import fft, fftfreq\nimport matplotlib.pyplot as plt\n\nt = np.arange(0, 10, step=0.001)\nsignal = np.sin(t) + np.sin(10*t)\nsp = fft(signal)\nfreq = fftfreq(signal.size, d=0.001)\nplt.plot(freq, sp)\nplt.show()\n```\n\n\nIt seems to me, that must look just like d(x-1) + d(x-10) ... // d is delta-function\n\n(Discrete Fourier Transformation must look like simple Fourier Transformation, but with sloping edges, as far as I understand)\n\nBut it doesn't. it looks like \"d(x-0.1) + d(x-1.5) ...\" and I wonder why. Problems with fftfreq?\n    ", "Answer": "\r\nIt's been many a year  since I studied this ...\n\nYou're expecting to see peaks at 1 and 10 Hz (cycles/sec)?\nThen you need to change the arguments of the sin functions.\nsin takes radians for arg. 1 Hz is 2*pi radians/sec and 10 Hz is 10*2*pi rad/sec\n\nChange your signal =np.sin(2*np.pi*t) + np.sin(10*2*np.pi*t) # optimize math as desired.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Dataflow Diagram or Pseudo Code for Fast Fourier Transform?\r\n                \r\nI have an ArrayList that has ```\nDouble```\n elements. I want to implement ```\nFFT```\n(Fast Fourier Transform) on it. However I don't want to take a Java code somewhere else and copy it. How can I find the understandable ```\ndataflow diagram or pseudo code```\n of FFT algorithm?\n\nPS: My ArrayList variable is a one-dimensional List.\n    ", "Answer": "\r\nWould diagram in this article satisfy you: http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm ?\n\nI built a Pascal program that was using this method almost 20 years ago.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Using Excel's VBA\r\n                \r\nI'm trying to implement a Fast Fourier Transform (Radix-2) in MS's Excel VBA. The code I'm using pulls data from a range in the worksheet, does the calculations, then dumps the results in the adjacent columns. What I'm having trouble with is 1) know what to do with the resulting X[k] arrays, and 2) matching these results with the results from Excel's built in FFT (they do not currently match). The code is shown below. Thanks in advance for your help. \n\n```\nSub Enforce_DecimationInTime()\n\nOn Error GoTo ERROR_HANDLING\nDim SubName As String\nSubName = \"Enforce_DecimationInTime()\"\n\nDim WS As Worksheet\nDim n As Long, v As Long, LR As Long, x As Long\n\nSet WS = Worksheets(\"FFT\")\nLR = WS.Range(\"A\" & Rows.Count).End(xlUp).Row\nn = LR - 1\nDo Until 2 ^ x <= n And 2 ^ (x + 1) > n     'locates largest power of 2 from size of input array\n    x = x + 1\nLoop\nn = n - (n - 2 ^ x) 'calculates n using the largest power of 2\nIf n + 1 <> WS.Range(\"A\" & Rows.Count).End(xlUp).Row Then\n    WS.Range(\"A\" & 2 ^ x + 2 & \":A\" & LR).Delete xlUp   'deletes extra input data\nEnd If\nv = WorksheetFunction.Log(n, 2)     'calculates number of decimations necessary\n\nApplication.ScreenUpdating = False\nFor x = 1 To v\n    Call Called_Core.DecimationInTime(WS, n, 2 ^ x, x)  'calls decimation in time subroutine\nNext x\nApplication.ScreenUpdating = True\n\nExit Sub\nERROR_HANDLING:\n    MsgBox \"Error encountered in \" & SubName & \": exiting subroutine.\" _\n    & vbNewLine _\n    & vbNewLine & \"Error description: \" & Err.Description _\n    & vbNewLine & \"Error number: \" & Err.Number, vbCritical, Title:=\"Error!\"\n    End\n\nEnd Sub\n```\n\n\nThe above subroutine calls the below subroutine through a For/Next loop to the count of \"v\".\n\n```\nSub DecimationInTime(WS As Worksheet, n As Long, Factor As Integer, x As Long)\n\nOn Error GoTo ERROR_HANDLING\nDim SubName As String\nSubName = \"DecimationInTime()\"\n\nDim f_1() As Single, f_2() As Single\nDim i As Long, m As Long, k As Long\nDim TFactor_N1 As String, TFactor_N2 As String, X_k() As String\nDim G_1() As Variant, G_2() As Variant\n\nReDim f_1(0 To n / Factor - 1) As Single\nReDim f_2(0 To n / Factor - 1) As Single\nReDim G_1(0 To n / 1 - 1) As Variant\nReDim G_2(0 To n / 1 - 1) As Variant\nReDim X_k(0 To n - 1) As String\n\nTFactor_N1 = WorksheetFunction.Complex(0, -2 * WorksheetFunction.Pi / (n / 1))  'twiddle factor for N\nTFactor_N2 = WorksheetFunction.Complex(0, -2 * WorksheetFunction.Pi / (n / 2))  'twiddle factor for N/2\n\nFor i = 0 To n / Factor - 1\n    f_1(i) = WS.Range(\"A\" & 2 * i + 2).Value    'assign input data\n    f_2(i) = WS.Range(\"A\" & 2 * i + 3).Value    'assign input data\nNext i\n\nWS.Cells(1, 1 + x).Value = \"X[\" & x & \"]\"   'labels X[k] column with k number\nFor k = 0 To n / 2 - 1\n    For m = 0 To n / Factor - 1\n        G_1(m) = WorksheetFunction.ImProduct(WorksheetFunction.ImPower(TFactor_N2, k * m), WorksheetFunction.Complex(f_1(m), 0))    'defines G_1[m]\n        G_2(m) = WorksheetFunction.ImProduct(WorksheetFunction.ImPower(TFactor_N2, k * m), WorksheetFunction.Complex(f_2(m), 0))    'defines G_2[m]\n    Next m\n    X_k(k) = WorksheetFunction.ImSum(WorksheetFunction.ImSum(G_1), WorksheetFunction.ImProduct(WorksheetFunction.ImSum(G_2), WorksheetFunction.ImPower(TFactor_N1, k)))  'defines X[k] for k\n    If k <= n / 2 Then X_k(k + n / 2) = WorksheetFunction.ImSum(WorksheetFunction.ImSum(G_1), WorksheetFunction.ImProduct(WorksheetFunction.ImSum(G_2), WorksheetFunction.ImPower(TFactor_N1, k), WorksheetFunction.Complex(-1, 0)))  'defines X[k] for k + n/2\n    WS.Cells(k + 2, 1 + x).Value = X_k(k)\n    WS.Cells(k + 2 + n / 2, 1 + x).Value = X_k(k + n / 2)\nNext k\n\nExit Sub\nERROR_HANDLING:\n    MsgBox \"Error encountered in \" & SubName & \": exiting subroutine.\" _\n    & vbNewLine _\n    & vbNewLine & \"Error description: \" & Err.Description _\n    & vbNewLine & \"Error number: \" & Err.Number, vbCritical, Title:=\"Error!\"\n    End\n\nEnd Sub\n```\n\n    ", "Answer": "\r\nI went back through the process and determined my problem was that I had assigned the wrong values to the twiddle factors, TFactor_N1 and TFactor_N2. After fixing this problem and adjusting which values are displayed, I was able to get the same results as Excel's built in FFT. The fixed code is show below.\n\n```\nSub Enforce_DecimationInTime()\n\nOn Error GoTo ERROR_HANDLING\nDim SubName As String\nSubName = \"Enforce_DecimationInTime()\"\n\nDim WS As Worksheet\nDim n As Long, v As Long, LR As Long, x As Long\nDim TFactor_N1 As String, TFactor_N2 As String\n\nSet WS = Worksheets(\"FFT\")\nLR = WS.Range(\"A\" & Rows.Count).End(xlUp).Row\nn = LR - 1\nDo Until 2 ^ x <= n And 2 ^ (x + 1) > n                                                                     'locates largest power of 2 from size of input array\n    x = x + 1\nLoop\nn = n - (n - 2 ^ x)                                                                                         'calculates n using the largest power of 2\nIf n + 1 <> WS.Range(\"A\" & Rows.Count).End(xlUp).Row Then\n    WS.Range(\"A\" & 2 ^ x + 2 & \":A\" & LR).Delete xlUp                                                       'deletes extra input data\nEnd If\nv = WorksheetFunction.Log(n, 2)                                                                             'calculates number of decimations necessary\n\nTFactor_N1 = WorksheetFunction.ImExp(WorksheetFunction.Complex(0, -2 * WorksheetFunction.Pi / (n / 1)))     'twiddle factor for N\nTFactor_N2 = WorksheetFunction.ImExp(WorksheetFunction.Complex(0, -2 * WorksheetFunction.Pi / (n / 2)))     'twiddle factor for N/2\n\nApplication.ScreenUpdating = False\nFor x = 1 To v\n    Call Called_Core.DecimationInTime(WS, n, 2 ^ x, x, TFactor_N1, TFactor_N2)                              'calls decimation in time subroutine\nNext x\nApplication.ScreenUpdating = True\n\nExit Sub\nERROR_HANDLING:\n    MsgBox \"Error encountered in \" & SubName & \": exiting subroutine.\" _\n    & vbNewLine _\n    & vbNewLine & \"Error description: \" & Err.Description _\n    & vbNewLine & \"Error number: \" & Err.Number, vbCritical, Title:=\"Error!\"\n    End\n\nEnd Sub\n\n\nSub DecimationInTime(WS As Worksheet, n As Long, Factor As Integer, x As Long, TFactor_N1 As String, TFactor_N2 As String)\n\nOn Error GoTo ERROR_HANDLING\nDim SubName As String\nSubName = \"DecimationInTime()\"\n\nDim f_1() As String, f_2() As String\nDim i As Long, m As Long, k As Long\nDim X_k() As String\nDim G_1() As Variant, G_2() As Variant\n\nReDim f_1(0 To n / Factor - 1) As String\nReDim f_2(0 To n / Factor - 1) As String\nReDim G_1(0 To n / 1 - 1) As Variant\nReDim G_2(0 To n / 1 - 1) As Variant\nReDim X_k(0 To n - 1) As String\n\nFor i = 0 To n / Factor - 1\n    f_1(i) = WS.Cells(2 * i + 2, 1).Value                                                                   'assign input data\n    f_2(i) = WS.Cells(2 * i + 3, 1).Value                                                                   'assign input data\nNext i\nFor k = 0 To n / 2 - 1\n    For m = 0 To n / Factor - 1                                                                             'defines G_1[m] and G_2[m]\n        G_1(m) = WorksheetFunction.ImProduct(WorksheetFunction.ImPower(TFactor_N2, k * m), f_1(m))\n        G_2(m) = WorksheetFunction.ImProduct(WorksheetFunction.ImPower(TFactor_N2, k * m), f_2(m))\n    Next m                                                                                                  'defines X[k] for k and k + n/2\n    X_k(k) = WorksheetFunction.ImSum(WorksheetFunction.ImSum(G_1), WorksheetFunction.ImProduct(WorksheetFunction.ImSum(G_2), WorksheetFunction.ImPower(TFactor_N1, k)))\n    If k <= n / 2 Then X_k(k + n / 2) = WorksheetFunction.ImSub(WorksheetFunction.ImSum(G_1), WorksheetFunction.ImProduct(WorksheetFunction.ImSum(G_2), WorksheetFunction.ImPower(TFactor_N1, k)))\n    If x = 1 Then\n        WS.Cells(k + 2, 1 + x).Value = X_k(k)\n        WS.Cells(k + 2 + n / 2, 1 + x).Value = X_k(k + n / 2)\n    End If\nNext k\n\nExit Sub\nERROR_HANDLING:\n    MsgBox \"Error encountered in \" & SubName & \": exiting subroutine.\" _\n    & vbNewLine _\n    & vbNewLine & \"Error description: \" & Err.Description _\n    & vbNewLine & \"Error number: \" & Err.Number, vbCritical, Title:=\"Error!\"\n    End\n\nEnd Sub\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Denoising Python\r\n                \r\nI want to denoise my Swat dataset. In this dataset actuator_columns have 0-1 values. Sensors columns have numeric values. I used OneHotEncoding for actuators, and Standardscaler for sensors. 72 columns\nThen I tried to implement Fast Fourier Transform for denoising.\nMy code is:\n```\nsignals=df.to_numpy() \ndef filter_signal(signal, threshold=1e8):\nfourier = rfft(signal)\nfrequencies = rfftfreq(signal.size, d=20e-3/signal.size)\nfourier[frequencies > threshold] = 0\nreturn irfft(fourier)\nfiltered = filter_signal(signals[0, 0 :], threshold=1e3)\nplt.figure(figsize=(15, 10))\nplt.xlabel('Frequencies')\nplt.ylabel('Amplitude')\nplt.plot(signals[0, 0 :], label='Raw')\nplt.plot(filtered, label='Filtered')\nplt.legend()\nplt.title(\"FFT Denoising with threshold = 1e3\", size=15)\nplt.show()\n```\n\nAfter this code I have denoısed filtered array with 72 size.\nAfter denoising part I want to implement IsolatonForest for anomaly detection.\nSo I need dataframe for using in IsolatıonForest model. I tried\n```\npd.DataFrame(filtered)\n```\n\nbut had 1 column with 72 rows. So I cant use this for my model.\nHow can I get dataframe after denoising part? How can I solve this problem?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Matlab Fast Fourier Transform / fft for time and speed\r\n                \r\nI have a 2 column vector with times and speeds of a subset of data, like so:\n\n```\n5 40\n10 37\n15 34\n20 39\n```\n\n\nAnd so on. I want to get the fourier transform of speeds to get a frequency. How would I go about doing this with a fast fourier transform (fft)?\n\nIf my vector name is sampleData, I have tried\n\n```\nfft(sampleData);\n```\n\n\nbut that gives me a vector of real and imaginary numbers. To be able to get sensible data to plot, how would I go about doing this?\n    ", "Answer": "\r\nFourier Transform will yield a complex vector, when you fft you get a vector of frequencies, each has a spectral phase. These phases can be extremely important! (they contain most of the information of the time-domain signal, you won't see interference effects without them etc...).  If you want to plot the power spectrum, you can\n\n```\nplot(abs(fft(sampleData)));\n```\n\n\nTo complete the story, you'll probably need to fftshift, and also produce a frequency vector. Here's a more elaborate code:\n\n```\n% Assuming 'time' is the 1st col, and 'sampleData' is the 2nd col: \nN=length(sampleData);  \nf=window(@hamming,N)';\ndt=mean(diff(time)); \ndf=1/(N*dt); % the frequency resolution (df=1/max_T)\nif mod(N,2)==0\n    f_vec= df*((1:N)-1-N/2); % frequency vector for EVEN length vector\n    else\n    f_vec= df*((1:N)-0.5-N/2); \nend\n\nfft_data= fftshift(fft(fftshift(sampleData.*f))) ;\n\nplot(f_vec,abs(fft_data))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to compute fast fourier transform aka fft using Ffmpeg\r\n                \r\nHow can i compute fast Fourier transform of an audio signal using Ffmpeg. I know there is a library in Ffmpeg for doing that but no sure how.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How do you do a Fast Fourier Transform in maxima (the computer algebra system)?\r\n                \r\nI get the basic idea of a continuous Fourier transform and I am a little fuzzy with a discrete Fourier transform and hazier still on the fast Fourier transform. I want to know how to compute and interpret the fast Fourier transform (FFT) of some function in maxima. For example, how would I compute the FFT of sin(x)? I know how to do this in MATLAB, but I am not sure how to do it in maxima.\n    ", "Answer": "\r\nWell, there is a built-in fast Fourier transform function: see 'fft'.\n\n'fft' is only for numerical data. Maybe you want a function which works for symbolic data as well. It is easy to write an ordinary (not fast) discrete Fourier transform as a summation, something like: ```\n(1/n) sum(y[k]*exp(2*%pi*%i*j*k/n)```\n for the ```\nj```\n-th element. (Formula may be wrong, I am working from memory.)\n\nIf you want a fast Fourier transform for symbolic data, you will need to work from a published algorithm. (There are many books which have FFT algorithms in them.) Just write the algorithm in Maxima and operations will automatically be symbolic.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How can I convert Arduino signal from Python to Fast Fourier transform?\r\n                \r\nI'm now trying to convert the signal into a Fast Fourier transform in Python and draw a graph. I have a problem with Len here. How can I fix this? And does anyone have any other ideas about converting  Fast Fourier transform?\n\nException has occurred: TypeError\n\nobject of type 'method' has no len()\n\nThat is my problem.\n\n```\nfrom PyQt5.QtWidgets import*\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\nfrom matplotlib.figure import Figure\nimport matplotlib.pyplot as plt\nimport random\nfrom PyQt5 import QtCore, QtGui, QtWidgets\nimport datetime\nimport serial\nimport time\nimport random\nimport numpy as np\nfrom matplotlib import animation\nfrom collections import deque\nimport threading\n\n\nx = 0\nvalue = [0]\n\nser = serial.Serial('com5', 9600)\n\nclass scope : \n\n    def data(self) :\n        if ser.readable() :\n            time.sleep(0.01)\n            reciving = ser.readline(ser.inWaiting())           \n            str = reciving.decode()\n            if len(str) > 0  :         \n                if str[:1] == 'X' :\n                    value[0] = str[1:]\n                    #print(float(value[5]))\n                    time.sleep(0.5)\n                    x = float(value[0])\n        return x\n\ns = scope()\n\nn = len(s.data)\n\nTs = 0.01\nFs = 1/Ts                     \n                    # length of the signal\nk = np.arange(n)\nT = n/Fs\nfreq = k/T                  # two sides frequency range\nfreq = freq[range(int(n/2))]            # one side frequency range\n\nY = np.fft.fft(x)/n                 # fft computing and normalization\nY = Y[range(int(n/2))]\n\nfig, ax = plt.subplots(2, 1)\n\nax.plot(freq, abs(Y), 'r', linestyle=' ', marker='^') \nax.set_xlabel('Freq (Hz)')\nax.set_ylabel('|Y(freq)|')\n#3ax.vlines(freq, [0], abs(Y))\nax.grid(True)\n\nt = threading.Thread(target= s.data)\nt.daemon = True\nt.start()\n\nplt.show()\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Blur a matrix using Fast Fourier Transforms\r\n                \r\nI want to blur values in matrix, so that in neighboring elements we'll not have sharp transitions.\n\nFrom the Wikipedia page Gaussian Blur I've found some info on Gaussian blurring. I've tried it with the most simple algorithm, and, hence the run-time was too long. Frankly, I'm not sure if my implementation is correct, as on boundary tiles sharp transition still exists.\n\nI've noticed that this blurring could be done with discrete Fourier transforms which is much faster, but I couldn't figure it out.\n\nSo, the idea is that we can get blurred matrix with the formulas below:\n\n```\nblurredMatrix = IFFT[FFT[initialMatrix]FFT[weightingFunction]]\n```\n\n\nWhere FFT/IFFT are Fast Fourier Transform/Inverse Fast Fourier Transform.\n\nCurrently I'm trying to do some testing on Wolfram Mathematica to make sure that this kind of approximation with Fourier transforms is correct.\n\nI'm using ```\nGaussianMatrix```\n as weightingFunction.\n\nI need 2d blurring, so I've created Gaussian matrix as below:\n\nSuppose our initial matrix has nxn sizes, where n = 2k+1\n\n```\nG = Chop[GaussianMatrix[k] GaussianMatrix[k], 10^6]\n```\n\n\nAnd, then, I've tried to create blurredMatrix as below:\n\n```\nblurredMatrix = Chop[FourierDCT[(FourierDCT[G]) (FourierDCT[initialMatrix]), 3], 10^-6]\n```\n\n\nBut I'm getting zeros as a result.\n\nSeems I'm doing it all wrong.\n\nAlso, I've tried another approach:\n\n```\nf[xi_, yj_] := 1/(2 \\[Pi] \\[Sigma]^2) Exp[-(((xi^2) + (yj^2) )/(2 \\[Sigma]^2))];<br/>\n[Sigma] = 3;<br/>\nG = Chop[N[Table[f[i, j], {i, 1, 100}, {j, 1, 100}]]]; <br/>\nTavg = Chop[ 1000 InverseFourier[(Fourier[G]) (Fourier[T]) ], 10^-6]; <br/>\n```\n\n\nWith this approach the picture looks fine (the image is blurred), but there is big difference between between values of blurredMatrix and initialMatrix.\n\nSeems there are some normalization or other problems.\n\nI need to write the code in C/C++, there is a library FFTW library in C which supports discrete Fourier transforms.\n\nPlease let me know if this is a wrong way of blurring and there are other possibilities to do what I want.\n    ", "Answer": "\r\nUsing FFT to do convolutions is only efficient when you have very large convolution kernels. In most blurring applications the kernel is much much smaller than the image, e.g. 3x3, so FFT would be significantly slower. \n\nThere are many implementations for doing small-kernel convolutions.\nMost modern hardware supports such intrinsic operations (MMX, SSE, GPUs...).\nFFT is probably not the way to go in your case.\n\nIn C++, OpenCV supports both cross-platform and hardware accelerated image convolutions. Convolutions really are one of (if not) the most foundational operation of any image and signal processing package. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to output a spectrum Fast Fourier Transform on C++\r\n                \r\nI'm using this code to compute the Discrete Fourier Transform (DFT) efficiently using the Fast Fourier Transform (FFT) algorithm, I'm new to this topic and I don't really understand what do I need to do after getting the output from the fft which are basically 8 points that are describing each wave.\nMy end goal is to show a spectrum according to the sample points I wrote\nAgain, I'm no expert and I can really use example or articles because all that data I found online doesn't tell me what do I do with these points to compute the spectrum.\nFFT code:\n```\n#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iterator>\n\nusing namespace std;\n\nunsigned int bitReverse(unsigned int x, int log2n) {\n    int n = 0;\n    int mask = 0x1;\n    for (int i = 0; i < log2n; i++) {\n        n <<= 1;\n        n |= (x & 1);\n        x >>= 1;\n    }\n    return n;\n}\n\nconst double PI = 3.1415926536;\n\ntemplate<class Iter_T>\nvoid fft(Iter_T a, Iter_T b, int log2n)\n{\n    typedef typename iterator_traits<Iter_T>::value_type complex;\n    const complex J(0, 1);\n    int n = 1 << log2n;\n    for (unsigned int i = 0; i < n; ++i) {\n        b[bitReverse(i, log2n)] = a[i];\n    }\n    for (int s = 1; s <= log2n; ++s) {\n        int m = 1 << s;\n        int m2 = m >> 1;\n        complex w(1, 0);\n        complex wm = exp(-J * (PI / m2));\n        for (int j = 0; j < m2; ++j) {\n            for (int k = j; k < n; k += m) {\n                complex t = w * b[k + m2];\n                complex u = b[k];\n                b[k] = u + t;\n                b[k + m2] = u - t;\n            }\n            w *= wm;\n        }\n    }\n}\n\nint main() {\n    typedef complex<double> cx;\n    cx a[] = { cx(1,0), cx(3,0), cx(5,0), cx(7,0),\n      cx(9, 0), cx(11, 0), cx(13,0), cx(15,0) };\n    cx b[8];\n    fft(a, b, 3);\n    for (int i = 0; i < 8; ++i)\n        cout << b[i] << \"\\n\";\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "What is the recommended Python module for fast Fourier transforms (FFT)?\r\n                \r\nTaking speed as an issue it may be better to choose another language, but what is your library/module/implementation of choice for doing a 1D fast Fourier transform (FFT) in Python?\n    ", "Answer": "\r\nI would recommend numpy library, I not sure if it's the fastest implementation that exist but but surely it's one of best scientific module on the \"market\". \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform using a Vandermonde Matrix - Evaluation of Co-efficients?\r\n                \r\nSay i'm trying to evaluate the Polynomial:\n\n```\nx^2 + 1\n```\n\n\nUsing the Fast Fourier transform method for evaluating co-efficients. Now i can change this into matrix/vector form using the co-effcient as inputs for the fast fourier transform:\n\nso:\n\n```\nx^2 + 1 = <1, 0, 1, 0>\n```\n\n\nThis is done by using the coefficient value e.g 1 = 1, 0x^1 = 0, X^2 = 1 and so on\n\nNow we get to the bit where i'm totally confused. I'm meant to use the vandermonde matrix :Vandermonde matrix ~ Wiki to evaluate these values into FFT Form using the matrix:\n\n```\n1 1 1 1  \n1 i-1-i\n1-1 1-i\n1-i 1 i\n```\n\n\nThe output of\n\n```\nfft(1,0,1,0)\n```\n\n\nis\n\n```\n(2,0,2,0)\n```\n\n\nNow thats the step i don't quite understand, how did we use that matrix to get (2,0,2,0)?\n    ", "Answer": "\r\nFirst, your Vandermonde matrix is incorrect.  The (4,3) entry should be -1, not 1, since the fourth row should be (-i)0, (-i)1, (-i)2, (-i)3.  Note in particular that \n\n(-i)*(-i) = (-1)2 * i2 = i2 = -1.\n\nWith this correction, the result follows from multiplying the Vandermonde matrix by the column vector (1,0,1,0).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform of 1D and 3D arrays\r\n                \r\nI'm doing N-body calculations using pyopencl and I need to have my data to be 1D array as input and as output of some kernel. So if I have 2D problem, I do something like this: 1D_arr=numpy.reshape(3D_arr,(LxLy)), where LxLy number of all particles.\nHow to perform a fast fourier transform(fft) of 1D array(If it is possible!), which corresponds to fft of 3D array (and ifft after)? These 2 arrays are connected by reshape transformation in real space.\n\n```\nimport numpy as np\nfrom scipy.fftpack import fftn, fft\n\n\nLx = 10 \nLy = 9\nLz = 1\nL = Lx * Ly * Lz\nLspec = (2 * Lx - 1) * (2 * Ly - 1) * (2 * Lz - 1)\n\nM1 = np.zeros(L).astype(np.float32)\nfor i in range(L):\n    M1[i] = np.random.random()\nM3 = np.zeros((Lx, Ly, Lz))\nfor z in range(Lz):\n    for y in range(Ly):\n        for x in range(Lx):\n            i = x + Lx * y\n            M3[x, y, z] = i\n            M1[i] = i\n            print(M3[x,y,z], M1[i])\n\n\nprint(\"________________________\")\n\n\nFM3 = fftn(M3)\nFM1 = fftn(M1)\n\nfor z in range(Lz):\n    for y in range(Ly):\n        for x in range(Lx):\n            i = x + Lx * y\n            i2 = y + Ly * x\n            print(FM3[x,y,z], FM1[i2])\n```\n\n\nI expect to see all ellements of FM1 and FM3 equal, but I don't know how to manage it.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How exactly do you compute the Fast Fourier Transform?\r\n                \r\nI've been reading a lot about Fast Fourier Transform and am trying to understand the low-level aspect of it. Unfortunately, Google and Wikipedia are not helping much at all.. and I have like 5 different algorithm books open that aren't helping much either. \n\nI'm trying to find the FFT of something simple like a vector [1,0,0,0]. Sure I could just plug it into Matlab but that won't help me understand what's going on underneath. Also, when I say I want to find the FFT of a vector, is that the same as saying I want to find the DFT of a vector just with a more efficient algorithm? \n    ", "Answer": "\r\nYou're right, \"the\" Fast Fourier transform is just a name for any algorithm that computes the discrete Fourier transform in O(n log n) time, and there are several such algorithms.\n\nHere's the simplest explanation of the DFT and FFT as I think of them, and also examples for small N, which may help. (Note that there are alternative interpretations, and other algorithms.)\n\nDiscrete Fourier transform\n\nGiven ```\nN```\n numbers f0, f1, f2, …, fN-1, the DFT gives a different set of ```\nN```\n numbers. \n\nSpecifically: Let ω be a primitive Nth root of 1 (either in the complex numbers or in some finite field), which means that ωN=1 but no smaller power is 1. You can think of the fk's as the coefficients of a polynomial P(x) = ∑fkxk. The N new numbers F0, F1, …, FN-1 that the DFT gives are the results of evaluating the polynomial at powers of ω. That is, for each n from 0 to N-1, the new number Fn is P(ωn) = ∑0≤k≤N-1 fkωnk.\n\n\n\n[The reason for choosing ω is that the inverse DFT has a nice form, very similar to the DFT itself.]\n\nNote that finding these F's naively takes O(N2) operations. But we can exploit the special structure that comes from the ω's we chose, and that allows us to do it in O(N log N). Any such algorithm is called the fast Fourier transform.\n\nFast Fourier Transform\n\nSo here's one way of doing the FFT. I'll replace N with 2N to simplify notation. We have f0, f1, f2, …, f2N-1, and we want to compute P(ω0), P(ω1), … P(ω2N-1) where we can write \n\n\n  P(x) = Q(x) + ωNR(x) with   \n  \n  Q(x) = f0 + f1x + … + fN-1xN-1  \n  \n  R(x) = fN + fN+1x + … + f2N-1x2N-1\n\n\nNow here's the beauty of the thing. Observe that the value at ωk+N is very simply related to the value at ωk:\nP(ωk+N) = ωN(Q(ωk) + ωNR(ωk)) = R(ωk) + ωNQ(ωk). So the evaluations of Q and R at ω0 to ωN-1 are enough.\n\nThis means that your original problem — of evaluating the 2N-term polynomial P at 2N points ω0 to ω2N-1 — has been reduced to the two problems of evaluating the N-term polynomials Q and R at the N points ω0 to ωN-1. So the running time T(2N) = 2T(N) + O(N) and all that, which gives T(N) = O(N log N).\n\nExamples of DFT\n\nNote that other definitions put factors of 1/N or 1/√N.\n\nFor N=2, ω=-1, and the Fourier transform of (a,b) is (a+b, a-b).\n\nFor N=3, ω is the complex cube root of 1, and the Fourier transform of (a,b,c) is (a+b+c, a+bω+cω2, a+bω2+cω). (Since ω4=ω.)\n\nFor N=4 and ω=i, and the Fourier transform of (a,b,c,d) is (a+b+c+d, a+bi-c-di, a-b+c-d, a-bi-c+di). In particular, the example in your question: the DFT on (1,0,0,0) gives (1,1,1,1), not very illuminating perhaps.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier coefficients for NFFT - non uniform fast Fourier transform?\r\n                \r\nI am trying to use the package pynfft in python 2.7 to do the non-uniform fast Fourier transform (nfft). I have learnt python for only two months, so I have some difficulties.\n\nThis is my code:\n\n```\nimport numpy as np\nfrom pynfft.nfft import NFFT\n\n#loading data, 104 lines\nt_diff, x_diff = np.loadtxt('data/analysis/amplitudes.dat', unpack = True)\n\nN = [13,8]\nM = 52\n\n#fourier coefficients\nf_hat = np.fft.fft(x_diff)/(2*M)\n\n#instantiation\nplan = NFFT(N,M)\n\n#precomputation\nx = t_diff\nplan.x = x\nplan.precompute()\n\n# vector of non uniform samples\nf = x_diff[0:M]\n\n#execution\nplan.f = f\nplan.f_hat = f_hat\nf = plan.trafo()\n```\n\n\nI am basically following the instructions I found in the pynfft tutorial (http://pythonhosted.org/pyNFFT/tutorial.html).\n\nI need the nfft because the time intervals in which my data are taken are not constant (I mean, the first measure is taken at t, the second after dt, the third after dt+dt' with dt' different from dt and so on).\n\nThe pynfft package wants the vector of the fourier coefficients (\"f_hat\") before execution, so I calculated it using numpy.fft, but I am not sure this procedure is correct. Is there another way to do it (maybe with the nfft)?\n\nI would like also to calculate the frquencies; I know that with numpy.fft there is a command: is ther anything like that also for pynfft? I did not find anything in the tutorial.\n\nThank you for any advice you can give me.\n    ", "Answer": "\r\nHere is a working example, taken from here:\n\nFirst we define the function we want to reconstruct, which is the sum of four harmonics:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(12345)\n\n%pylab inline --no-import-all\n\n# function we want to reconstruct\nk=[1,5,10,30] # modulating coefficients\ndef myf(x,k): \n    return sum(np.sin(x*k0*(2*np.pi)) for k0 in k)\n\nx=np.linspace(-0.5,0.5,1000)   # 'continuous' time/spatial domain; -0.5<x<+0.5\ny=myf(x,k)                     # 'true' underlying trigonometric function\n\nfig=plt.figure(1,(20,5))\nax =fig.add_subplot(111)\n\nax.plot(x,y,'red')\nax.plot(x,y,'r.')\n\n                        # we should sample at a rate of >2*~max(k)\nM=256                   # number of nodes\nN=128                   # number of Fourier coefficients\n\nnodes =np.random.rand(M)-0.5 # non-uniform oversampling\nvalues=myf(nodes,k)     # nodes&values will be used below to reconstruct \n                        # original function using the Solver\n\nax.plot(nodes,values,'bo')\n\nax.set_xlim(-0.5,+0.5)\n```\n\n\nThe we initialize and run the Solver:\n\n```\nfrom pynfft import NFFT, Solver\n\nf     = np.empty(M,     dtype=np.complex128)\nf_hat = np.empty([N,N], dtype=np.complex128)\n\nthis_nfft = NFFT(N=[N,N], M=M)\nthis_nfft.x = np.array([[node_i,0.] for node_i in nodes])\nthis_nfft.precompute()\n\nthis_nfft.f = f\nret2=this_nfft.adjoint()\n\nprint this_nfft.M  # number of nodes, complex typed\nprint this_nfft.N  # number of Fourier coefficients, complex typed\n#print this_nfft.x # nodes in [-0.5, 0.5), float typed\n\n\nthis_solver = Solver(this_nfft)\nthis_solver.y = values          # '''right hand side, samples.'''\n\n#this_solver.f_hat_iter = f_hat # assign arbitrary initial solution guess, default is 0\n\nthis_solver.before_loop()       # initialize solver internals\n\nwhile not np.all(this_solver.r_iter < 1e-2):\nthis_solver.loop_one_step()\n```\n\n\nFinally, we display the frequencies:\n\n```\nimport matplotlib.pyplot as plt\n\nfig=plt.figure(1,(20,5))\nax =fig.add_subplot(111)\n\n\nfoo=[ np.abs( this_solver.f_hat_iter[i][0])**2 for i in range(len(this_solver.f_hat_iter) ) ]\n\nax.plot(np.abs(np.arange(-N/2,+N/2,1)),foo)\n```\n\n\ncheers\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier function for image transformation Problems\r\n                \r\nI have coded the following function to apply fast fourier transform on input image. I have got null pointer exception in line \"F[2*k]= F[2*k].plus(w_ux.mul(f_even));\".\n\n\nWould anyone give any advice to me, please? [solved]\nIt takes quite a long time to finish running the transform, the time is similar to normal fourier transform. and the result image is not as expected. \n\n\n```\nprivate Complex[] fft(byte[] img, int width, int height) {\n    // M - height  N - width , u - height v - width\n    Complex[] F = new Complex[width*height];  // one single point\n    Complex w;\n    int size = F.length;\n    double w_ux_exp, w_u_exp;\n    double f_even, f_odd;\n    for (int u=0; u<size/2;u++){\n        for (int k=0; k<size/2; k++){\n            f_even = (double)(img[2*k]&0xFF)*Math.pow(-1, k);  // f(x) for even, centering\n            f_odd = (double)(img[2*k+1]&0xFF)*Math.pow(-1, k);  // f(x) for odd, centering\n            w_u_exp =-2.0 * Math.PI*2*(img[u]&0xFF) / size;\n            w_ux_exp =-2.0 * Math.PI*(2*k)*(img[u]&0xFF) / size;  //even\n            Complex w_ux = Complex.fromPolar(1, w_ux_exp);\n            Complex w_u = Complex.fromPolar(1, w_u_exp);\n            F[2*u]= F[2*u].plus(w_ux.mul(f_even)); \n            F[2*u+1]=F[2*u+1].plus(w_u.mul(f_odd));\n        }\n    }\n\n    return F;\n} \n```\n\n\nThank you very much for your help.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for Harmonic Analysis\r\n                \r\nI'm analyzing the harmonics present in the wave motion as a function of where along the string the pluck occurs.  I hope to obtain a plot like those exhibited on this page: https://softwaredevelopmentperestroika.wordpress.com/2013/12/10/fast-fourier-transforms-with-python-the-noise-and-the-signal/.  To do this, I've written code modelling an asymmetric triangle and implemented numpy's fft.  The data being output, however, is not what I expect, and it's peaked about a frequency of 0 Hz.  Here is my code and its output:\n\n```\nfrom numpy.fft import fft as npfft, fftfreq as npfftfreq\n#triangular pulse\ndef triangular_pulse(x, xmean, sigma):\n    for i in x:\n        if x[i]<=xmean:\n            y[i] = x[i]*(sigma/xmean)\n        else :\n            y[i] = sigma-(x[i]-xmean)*(sigma/(200-xmean))\n    return y\n\nN_masses = 200\nT  = 0.0669264714\nmu = .03937\ncSq = T/mu\nc  = np.sqrt(cSq)\ndx = 1.0\n\ndt = dx/c\nprint dt\n\n#Initialize some arrays\nx0  = np.arange(N_masses)*dx\ny   = np.zeros(N_masses)\nvy  = np.zeros(N_masses)\nay  = np.zeros(N_masses)\n\n#Set Initial conditions (pluck)\n# # half-pluck\n# y = 30*gaussian_pulse(x0,x0[N_masses/2],2)\n\n# quarter-pluck\ny = triangular_pulse(x0,x0[N_masses/4],1)\n\nrhat=npfft(y)\nfreaq=npfftfreq(len(y),dt)\nplt.plot(freaq,np.abs(rhat)/len(rhat))\nplt.show()\n```\n\n\nPlease let me know if you spot the source of my problem.  Thanks!\n\nUpdate\n\nAdded\n    y = triangular_pulse(x0,x0[N_masses/40],1)\n    y-=np.mean(y)\nwith the result of a broader non-zero band; peak is still centered around \"0\", however.\n    ", "Answer": "\r\nJust subtract the mean of the signal before running the frequency analysis, i.e. after calling ```\ntriangular_pulse```\n:\n\n```\ny-=y.mean()\n```\n\n\nand you will obtain the peak at a non-zero frequency. This is because the signal has a mean component that is not zero, that will show up as the component at zero frequency.\n\nEDIT: as a comment, you can rewrite the triangular pulse function using numpy where:\n\n```\ndef triangular_pulse2(x,xmean,sigma):\n    return where(x<xmean,x*sigma/xmean,sigma-(x-xmean)*(sigma/(200-xmean)))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Is Fast Fourier transform algorithm appropriate for image gradient computation?\r\n                \r\nI've a matrix of size ```\nmXn```\n and a filter ```\n[-1 0 1]```\n on which I need to perform convolution. I'm able to do this in O(n^2) steps, but on further googling fast fourier transform keeps on popping up everywhere. I would like to know if FFT is appropriate for this problem. The matrix has random integers only. But if I were to have floating values, will it make a difference? Is FFT meant for a problem like this?\n    ", "Answer": "\r\nIf your filter has only two nonzero elements, computing the convolution by definition will only take ```\nO(n*m)```\n steps (which is the size of your data). FFT isn't gonna help you in that case: a 2D FFT would take something like ```\nO(n*m*(log n+log m))```\n.\n\nTo sum up: when you have a simple, localized filter, the best way to perform convolution is computing the sum directly. When you need to compute convolutions or correlations with bigger data (think correlation with another image) or perform complex operations, FFT can help you.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "scale and rotation Template matching\r\n                \r\nI'm using the method of match template with ```\nCV_TM_CCORR_NORMED```\n to compare two images ... I want to make to make this rotation and scale invariant .. any ideas?\n\nI tried to use the same method on the fourier transform of the image and the template , but still the result after rotation is different\n    ", "Answer": "\r\nTemplate matching with ```\nmatchTemplate```\n is not good when your object is rotated or scaled in scene.\n\nYou should try openCV function from ```\nFeatures2D```\n Framework. For example ```\nSIFT```\n or ```\nSURF```\n descriptors, and ```\nFLANN```\n matcher. Also, you will need ```\nfindHomography```\n method.\n\nHere is a good example of finding rotated object in scene.\n\nUpdate:\n\nIn short, algorithm is this:\n\n\nFinding keypoints of your object image\n1.1. Extracting descriptors from those keypoints\nFinding keypoints of your scene image\n2.1 Extracting descriptors from keypoints\nMatch descriptors by matcher\nAnalyze your matches\n\n\nThere are different classes of FeatureDetectors, DescriptorExtractors, and DescriptorMatches, you may read about them and choose those, that fit good for your tasks.\n\n\nopenCV FeatureDetector    (steps 1 and 2 in algorithm above)\nopenCV DescriptorExtractor ( steps 1.1 and 2.1 in algorithm\nabove ) \nopenCV DescriptorMatcher ( step 3 in algorithm above )\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Window function after Fast Fourier Transform\r\n                \r\nHi this is open for discussion since I am doing a capstone project. So I am working with a Raspberry Pi4 and we have a piezoelectric sensor hooked up and and LCD screen as well. My team is recording voltages after a playing an instrument and we used the guitar for this. So I have data that we recorded. My question is... do i need to perform a fast Fourier transform on that data first and then do a window function or can i just simply use a window function if i want my data to have better noise measurements? Our project is coded in python and I've been looking at python code for FFT and window functions.\nJust been looking online sources for this and I am not sure how i can apply this to my application since I've never done this before.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Optimization - How To Pre Calculate Exponential?\r\n                \r\nActually, I think that I get the discrete Fourier transform some basics. And now I have some problems with the fast Fourier transform algorithm.\nI don't want to share all the functions so as not to complicate the problem. But if you don't understand some parts I can edit the question.\nSlow Fourier transform:\n```\nvoid slowft (float *x, COMPLEX *y, int n)\n{\n    COMPLEX tmp, z1, z2, z3, z4;\n    int m, k;\n\n/* Constant factor -2 pi */\n    cmplx (0.0, (float)(atan (1.0)/n * -8.0), &tmp);\n    \n    printf (\" constant factor -2 pi %f \", (float)(atan (1.0)/n * -8.0));\n    for (m = 0; m<=n; m++)\n    {\n      \n      cmplx (x[0], 0.0, &(y[m]));\n      for (k=1; k<=n-1; k++)\n      {\n/* Exp (tmp*k*m) */\n        cmplx ((float)k, 0.0, &z2);\n        cmult (tmp, z2, &z3);\n        cmplx ((float)m, 0.0, &z2);\n        cmult (z2, z3, &z4);\n        cexp (z4, &z2);\n/* *x[k] */\n        cmplx (x[k], 0.0, &z3);\n        cmult (z2, z3, &z4);\n/* + y[m] */\n        csum (y[m], z4, &z2);\n        y[m].real = z2.real; y[m].imag = z2.imag;\n      }\n    }\n}\n```\n\nto make clear:\ncmplx is creating a complete number, cmult is complex multiplication and cexp is taking exponent. that's all.\nAnd some optimizations:\n```\nvoid newslowft (double *x, COMPLEX *y, int n)\n{\n    COMPLEX tmp, z1, z2, z3, z4, *pre;\n    long  m, k, i, p;\n\n    pre = (COMPLEX *)malloc(sizeof(struct cpx)*1024);\n\n/* Constant factor -2 pi */\n    cmplx (0.0, atan (1.0)/n * -8.0, &z1);  \n    cexp (z1, &tmp);\n\n/* Pre-compute most of the exponential */\n    cmplx (1.0, 0.0, &z1);          /* Z1 = 1.0; */\n    //n=1024\n    for (i=0; i<n; i++)\n    {\n      cmplx (z1.real, z1.imag, &(pre[i]));\n      cmult (z1, tmp, &z3);\n      cmplx (z3.real, z3.imag, &z1);\n    }\n\n/* Double loop to compute all Y entries */\n    for (m = 0; m<n; m++)\n    {\n      cmplx (x[0], 0.0, &(y[m]));\n      for (k=1; k<=n-1; k++)\n      {\n/* Exp (tmp*k*m) */\n        p = (k*m % n);\n\n/* *x[k] */\n        cmplx (x[k], 0.0, &z3);\n        cmult (z3, pre[p], &z4);\n/* + y[m] */\n        csum (y[m], z4, &z2);\n        y[m].real = z2.real; \n        y[m].imag = z2.imag;\n      }\n    }\n}\n```\n\nThe problem: The first step of the optimization:\n\"precalculating some exponential inside the loop\".\nSo this is actually what I ask. How does this algorithm calculate the all exponential?\nI think we are calculating the following exponentials: e^0 e^1 e^2.... e^1023  So where are the other exponentials?\nI mean, in the first algorithm, inside the for loops we are using m (m=0; m<=1024; m  ) and k(k=0; k<1023-1; k  ) but, where is the e^1000*900?\nAs far as I understand, the second algorithm takes the mode according to n. I think this is the key point right? But I didn't get how to work?\nThanks in advance masters.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform\r\n                \r\nI need to multiply two polynomials each having small integral coefficients. I need a fast FFT routine in C/C++ which can convolve them. I have seen several libraries but they seem to be too large spread over multiple files. What is important is I need code which is not too long and can be very easily used and compiled in a single ```\n.c/.cpp```\n file. \n\n\nFFT should be optimized for real inputs at least if not small integers.\nRadix 4 implementation if available would be fine too. \nCompiling it should take no special compilation flags as compilation of program has to be done in external environment which I can't control.\n\n\nOne that very well matches my needs is here. But I need something twice as fast.\n    ", "Answer": "\r\nFor a straightforward and easy to use FFT implementation try KissFFT. If you need absolute maximum performance though, and don't mind a little complexity, then it has to be FFTW.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "numpy's fast Fourier transform yields unexpected results\r\n                \r\nI am struggling with ```\nnumpy```\n's implementation of the fast Fourier transform. My signal is not of periodic nature and therefore certainly not an ideal candidate, the result of the FFT however is far from what I was expecting. It is the same signal, simply stretched by some factor. I plotted a sinus curve, approximating my signal next to it which should illustrate, that I use the FFT function correctly: \n\n```\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nsignal = array([[ 0.], [ 0.1667557 ], [ 0.31103874], [ 0.44339886], [ 0.50747922],\n    [ 0.47848347], [ 0.64544846], [ 0.67861755], [ 0.69268326], [ 0.71581176],\n    [ 0.726552  ], [ 0.75032795], [ 0.77133769], [ 0.77379966], [ 0.80519187],\n    [ 0.78756476], [ 0.84179849], [ 0.85406538], [ 0.82852684], [ 0.87172407],\n    [ 0.9055542 ], [ 0.90563205], [ 0.92073452], [ 0.91178145], [ 0.8795554 ],\n    [ 0.89155587], [ 0.87965686], [ 0.91819571], [ 0.95774404], [ 0.95432073],\n    [ 0.96326252], [ 0.99480947], [ 0.94754962], [ 0.9818627 ], [ 0.9804966 ],\n    [ 1.], [ 0.99919711], [ 0.97202208], [ 0.99065786], [ 0.90567128],\n    [ 0.94300558], [ 0.89839004], [ 0.87312245], [ 0.86288378], [ 0.87301008],\n    [ 0.78184963], [ 0.73774451], [ 0.7450479 ], [ 0.67291666], [ 0.63518575],\n    [ 0.57036157], [ 0.5709147 ], [ 0.63079811], [ 0.61821523], [ 0.49526048],\n    [ 0.4434457 ], [ 0.29746173], [ 0.13024641], [ 0.17631683], [ 0.08590552]])\n\nsinus = np.sin(np.linspace(0, np.pi, 60))\n\nplt.plot(signal)\nplt.plot(sinus)\n```\n\n\nThe blue line is my signal, the green line is the sinus.\n\n\n\n```\ntransformed_signal = abs(np.fft.fft(signal)[:30] / len(signal))\ntransformed_sinus = abs(np.fft.fft(sinus)[:30] / len(sinus))\n\nplt.plot(transformed_signal)\nplt.plot(transformed_sinus)\n```\n\n\nThe blue line is ```\ntransformed_signal```\n, the green line is the ```\ntransformed_sinus```\n.\n\n\n\nPlotting only ```\ntransformed_signal```\n illustrates the behavior described above:\n\n\n\nCan someone explain to me what's going on here?\n\nUPDATE\n\nI was indeed a problem of calling the FFT. This is the correct call and the correct result:\n\n```\ntransformed_signal = abs(np.fft.fft(signal,axis=0)[:30] / len(signal))\n```\n\n\n\n    ", "Answer": "\r\nNumpy's ```\nfft```\n is by default applied over rows. Since your ```\nsignal```\n variable is a column vector, ```\nfft```\n is applied over the rows consisting of one element and returns the one-point FFT of each element. \n\nUse the axis option of ```\nfft```\n to specify that you want FFT applied over the columns of ```\nsignal```\n, i.e., \n\n```\ntransformed_signal = abs(np.fft.fft(signal,axis=0)[:30] / len(signal))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "I want to find the time-displacement curve through inverse fast Fourier transform\r\n                \r\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN=1000; T=10; dt=T/N\nt=np.arange(0,N*dt,dt)\n\n#system properties\nwn = 4 * np.pi\nw=0.2*wn\nTn = 2*np.pi/wn\nfn = 1/Tn\n\nm = 1\nZ = 0.05\nk = wn*wn * m\nc = 2*m*wn*Z\n######################################################\nP = np.sin(wn * t)\n\n#Frequency response\nL = len(P)\na = np.arange(L)\nfreq = a * (1/dt) / L\nfreq = freq[range(int(L/2))]\n\nPf = np.fft.fft(P)/L\nPf = Pf[range(int(L/2))]\nFFT = 2*abs(Pf)\n#########################################################\n# transfer function\nH=(1/k)*(1/(1+(w/wn)**2)+1j*(2*Z*(w/wn)))\n\nUf=2*Pf*H\n\n# for i in range(0,int(N/2)):\n#     Uf[N-i-1] = np.conjugate(Uf[i+1])\n\nut= np.real(np.fft.ifft(Uf)*(1/dt))\n\nplt.plot(t, ut)\nplt.show()\n```\n\ni don't know this ValueError\nValueError: x and y must have same first dimension, but have shapes (1000,) and (500,)\nI want to find the time-displacement curve through inverse fast Fourier transform\n    ", "Answer": "\r\nThe ```\nplt.plot()```\n function is just complaining that ```\nt```\n and ```\nut```\n do not have the same length.\nThis line ```\nPf = Pf[range(int(L/2))]```\n takes ```\nPf```\n from an array of length ```\nN```\n to ```\nN/2```\n. This affects ```\nUf```\n and consequently ```\nut```\n, and that is why you get the error message. Im not sure what you are trying to do in this command... are you trying to filter out certain frequencies? Either way, taking another look at this command might give you what you want.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform (fft) with Time Associated Data Python\r\n                \r\nI have data and a time 'value' associated with it (Tx and X).\n\nHow can I perform a fast Fourier transform on my data.\n\nTx is an array I have and X is another array I have. The length of both arrays are of course the same and they are associated by Tx[i] with X[i] , where i goes from 0 to len(X).\n\nHow can I perform a fft on such data to ultimately achieve a Power Spectral Density plot frequency against |fft|^2.\n    ", "Answer": "\r\nIf the data is not uniformly sampled (i.e. Tx[i]-Tx[i-1] is constant), then you cannot do an FFT on it.\n\nHere's an idea:\nIf you have a pretty good idea of the bandwidth of the signal, then you could create a resampled version of the DFT basis vectors R.  I.e. the complex sinusoids evaluated at the Tx times.  Then solve the linear system x = A*z: where x is your observation, z is the unknown frequency content of the signal, and A is the resamapled DFT basis. Note that A may not actually be a basis depending on the severity of the non-uniformity.  It will almost certainly not be an orthogonal basis like the DFT.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Incorrect data length when invoking Fast Fourier Transform in AForge\r\n                \r\nI'm working on a FFT (fast fourier transform) function in C#. \nI've found AForge library but when using it I keep getting the error message:\n\n\n  Incorrect data length.\n\n\nThe data I'm putting in is a list of doubles and the size can vary, depending on the signal I'm sending in.\n\nWhat to do about this?\n\nThis is what my function looks like so far\n\n```\nprivate void FastFoulierMethod(ISignal signal, List<IMarker> markers)\n{\n    AForge.Math.Complex[] complex = new AForge.Math.Complex[samples.Count];\n    for (int i = 0; i < samples.Count-1; i++)\n    {\n         complex[i] = new AForge.Math.Complex(samples[i].GetTimeInSec(),0);\n    }\n    AForge.Math.Complex[] complex2 = complex;\n    FourierTransform.DFT(complex, FourierTransform.Direction.Backward);\n    FourierTransform.FFT(complex2, FourierTransform.Direction.Backward);\n}\n```\n\n    ", "Answer": "\r\nAs per AForge documentation:\n\n\n  The method accepts data array of 2n size only, where n may vary in the [1, 14] range\n\n\nSo you would need to make sure the input size is correctly padded to a length that is a power of 2, and in the specified range:\n\n```\ndouble logLength    = Math.Ceiling(Math.Log((double)sample.Count, 2.0));\nint    paddedLength = (int) Math.Pow(2.0, Math.Min(Math.Max(1.0, logLength), 14.0));\nAForge.Math.Complex[] complex = new AForge.Math.Complex[paddedLength];\n\n// copy all input samples\nint i = 0;\nfor (; i < sample.Count; i++)\n{\n    complex[i] = new AForge.Math.Complex(samples[i].GetTimeInSec(),0);\n}\n// pad with zeros\nfor (; i < paddedLength; i++)\n{\n    complex[i] = new AForge.Math.Complex(0,0);\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Evaluating the fast Fourier transform of Gaussian function in FORTRAN using FFTW3 library\r\n                \r\nI am trying to write a FORTRAN code to evaluate the fast Fourier transform of the Gaussian function ```\nf(r)=exp(-(r^2))```\n using ```\nFFTW3```\n library. As everyone knows, the Fourier transform of the Gaussian function is another Gaussian function. \n\nI consider evaluating the Fourier-transform integral of the Gaussian function in the spherical coordinate.\n\nHence the resulting integral can be simplified to be integral of ```\n[r*exp(-(r^2))*sin(kr)]dr```\n.\n\nI wrote the following FORTRAN code to evaluate the discrete SINE transform DST which is the discrete Fourier transform DFT using a PURELY real input array. DST is performed by ```\nC_FFTW_RODFT00```\n existing in ```\nFFTW3```\n, taking into account that the discrete values in position space are r=i*delta (i=1,2,...,1024), and the input array for DST is the function ```\nr*exp(-(r^2))```\n NOT the Gaussian. The sine function in the integral of ```\n[r*exp(-(r^2))*sin(kr)]dr```\n resulting from the INTEGRATION over the SPHERICAL coordinates, and it is NOT the imaginary part of ```\nexp(ik.r)```\n that appears when taking the analytic Fourier transform in general.\n\nHowever, the result is not a Gaussian function in the momentum space.  \n\n```\nModule FFTW3\n use, intrinsic :: iso_c_binding\ninclude 'fftw3.f03'\nend module  \n\nprogram sine_FFT_transform\nuse FFTW3\nimplicit none\ninteger, parameter :: dp=selected_real_kind(8)\n\nreal(kind=dp), parameter :: pi=acos(-1.0_dp)\ninteger, parameter :: n=1024 \nreal(kind=dp) :: delta, k\nreal(kind=dp) :: numerical_F_transform\ninteger :: i\ntype(C_PTR) ::  my_plan\nreal(C_DOUBLE), dimension(1024) :: y\nreal(C_DOUBLE), dimension(1024) :: yy, yk\ninteger(C_FFTW_R2R_KIND) :: C_FFTW_RODFT00\n\nmy_plan= fftw_plan_r2r_1d(1024,y,yy,FFTW_FORWARD, FFTW_ESTIMATE)\n\ndelta=0.0125_dp\ndo i=1, n        !inserting the input one-dimension position function\ny(i)= 2*(delta)*(i-1)*exp(-((i-1)*delta)**2) \n! I multiplied by 2 due to the definition of C_FFTW_RODFT00 in FFTW3\nend do\n\ncall fftw_execute_r2r(my_plan, y,yy)   \ndo i=2, n\nk = (i-1)*pi/n/delta \nyk(i) = 4*pi*delta*yy(i)/2  !I divide by 2 due to the definition of \n                            !C_FFTW_RODFT00\nnumerical_F_transform=yk(i)/k\nwrite(11,*) i,k,numerical_F_transform\nend do\ncall fftw_destroy_plan(my_plan)\n\nend program \n```\n\n\nExecuting the previous code gives the following plot which is not for Gaussian function. \n\nCan anyone help me understand what the problem is? I guess the problem is mainly due to ```\nFFTW3```\n. Maybe I did not use it properly especially concerning the boundary conditions.    \n    ", "Answer": "\r\nLooking at the related pages in the FFTW site (Real-to-Real Transforms, transform kinds, Real-odd DFT (DST)) and the header file for Fortran, it seems that FFTW expects ```\nFFTW_RODFT00```\n etc rather than ```\nFFTW_FORWARD```\n for specifying the kind of \nreal-to-real transform. For example,\n\n```\n! my_plan= fftw_plan_r2r_1d( n, y, yy, FFTW_FORWARD, FFTW_ESTIMATE )\nmy_plan= fftw_plan_r2r_1d( n, y, yy, FFTW_RODFT00, FFTW_ESTIMATE )\n```\n\n\nperforms the \"type-I\" discrete sine transform (DST-I) shown in the above page. This modification seems to fix the problem (i.e., makes the Fourier transform a Gaussian with positive values).\n\n\n\nThe following is a slightly modified version of OP's code to experiment the above modification:\n\n```\n! ... only the modified part is shown...\nreal(dp) :: delta, k, r, fftw, num, ana\ninteger :: i, j, n\ntype(C_PTR) ::  my_plan\nreal(C_DOUBLE), allocatable :: y(:), yy(:)\n\ndelta = 0.0125_dp ; n = 1024   ! rmax = 12.8\n! delta = 0.1_dp    ; n = 128    ! rmax = 12.8\n! delta = 0.2_dp    ; n = 64    ! rmax = 12.8\n! delta = 0.4_dp    ; n = 32    ! rmax = 12.8\n\nallocate( y( n ), yy( n ) )\n\n! my_plan= fftw_plan_r2r_1d( n, y, yy, FFTW_FORWARD, FFTW_ESTIMATE )\nmy_plan= fftw_plan_r2r_1d( n, y, yy, FFTW_RODFT00, FFTW_ESTIMATE )\n\n! Loop over r-grid\ndo i = 1, n\n    r = i * delta              ! (2-a)\n    y( i )= r * exp( -r**2 )\nend do\n\ncall fftw_execute_r2r( my_plan, y, yy )\n\n! Loop over k-grid\ndo i = 1, n\n\n    ! Result of FFTW\n    k = i * pi / ((n + 1) * delta)    ! (2-b)\n    fftw = 4 * pi * delta * yy( i ) / k / 2   ! the last 2 due to RODFT00\n\n    ! Numerical result via quadrature\n    num = 0\n    do j = 1, n\n        r = j * delta\n        num = num + r * exp( -r**2 ) * sin( k * r )\n    enddo\n    num = num * 4 * pi * delta / k\n\n    ! Analytical result\n    ana = sqrt( pi )**3 * exp( -k**2 / 4 )\n\n    ! Output\n    write(10,*) k, fftw\n    write(20,*) k, num\n    write(30,*) k, ana\nend do\n```\n\n\nCompile (with gfortran-8.2 + FFTW3.3.8 + OSX10.11):\n\n```\n$ gfortran -fcheck=all -Wall sine.f90 -I/usr/local/Cellar/fftw/3.3.8/include -L/usr/local/Cellar/fftw/3.3.8/lib -lfftw3\n```\n\n\nIf we use ```\nFFTW_FORWARD```\n as in the original code, we get\n\n\n\nwhich has a negative lobe (where fort.10, fort.20, and fort.30 correspond to FFTW, quadrature, and analytical results). Modifying the code to use ```\nFFTW_RODFT00```\n changes the result as below, so the modification seems to be working (but please see below for the grid definition).\n\n\n\n\n\nAdditional notes\n\n\nI have slightly modified the grid definition for r and k in my code (Lines (2-a) and (2-b)), which is found to improve the accuracy. But I'm still not sure whether the above definition matches the definition used by FFTW, so please read the manual for details...\nThe ```\nfftw3.f03```\n header file gives the interface for ```\nfftw_plan_r2r_1d```\n\n\n```\ntype(C_PTR) function fftw_plan_r2r_1d(n,in,out,kind,flags) bind(C, name='fftw_plan_r2r_1d')\n  import\n  integer(C_INT), value :: n\n  real(C_DOUBLE), dimension(*), intent(out) :: in\n  real(C_DOUBLE), dimension(*), intent(out) :: out\n  integer(C_FFTW_R2R_KIND), value :: kind\n  integer(C_INT), value :: flags\nend function fftw_plan_r2r_1d\n```\n\n(Because of no Tex support, this part is very ugly...) The integral of ```\n4 pi r^2 * exp(-r^2) * sin(kr)/(kr)```\n for r = 0 -> infinite is ```\npi^(3/2) * exp(-k^2 / 4)```\n (obtained from Wolfram Alpha or by noting that this is actually a 3-D Fourier transform of exp(-(x^2 + y^2 + z^2)) by exp(-i*(k1 x + k2 y + k3 z)) with k =(k1,k2,k3)). So, although a bit counter-intuitive, the result becomes a positive Gaussian.\nI guess the r-grid can be chosen much coarser (e.g. ```\ndelta```\n up to 0.4), which gives almost the same accuracy as long as it covers the frequency domain of the transformed function (here ```\nexp(-r^2)```\n).\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Implementation of own fast fourier transform algorithm does not work\r\n                \r\nI have found and customized algorithm for fast fourier transform. The algorithm is below:\n\n```\nfunction X = myFFT(x)\n   %only works if N = 2^k\n   N = numel(x);\n   xp = x(1:2:end);\n   xpp = x(2:2:end);\n   if N>=8\n      Xp = myFFT(xp);\n      Xpp = myFFT(xpp);\n      X = zeros(N,1);\n      Wn = exp(-1i*2*pi.*((0:N/2-1)')/N);\n      tmp = Wn .* Xpp;\n      X = [(Xp + tmp);(Xp -tmp)];\n   else\n     switch N\n       case 2\n          X = [1 1;1 -1]*x;\n       case 4\n          X = [1 0 1 0; 0 1 0 -1i; 1 0 -1 0;0 1 0 1i]*[1 0 1 0;1 0 -1 0;0 1 0 1;0 1 0 -1]*x;\n       otherwise\n          error('N not correct.');\n     end\n   end\nend\n```\n\n\nThe algorithm above is stored in an .m file named myFFT.\n\nI want to use the code for two subsequent signals:\nh1=sin(t2) and for time t2=0:1:255;\n\nI recall the myFFT function in another .m file in this way:\n\n```\nx=h1;\nX11 = myFFT(x);\n```\n\n\nBut it gives me this error:\n\n```\nError using  * \nInner matrix dimensions must agree.\n\nError in myFFT (line 18)\n           X = [1 0 1 0; 0 1 0 -1i; 1 0 -1 0;0 1 0 1i]*[1 0 1 0;1 0 -1 0;0 1 0 1;0 1 0 -1]*x;\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n\nError in myFFT (line 7)\n    Xp = myFFT(xp);\n```\n\n\nHonestly, I have no idea how to fix it. Could you please help me?\nThank you very much in advance!\n    ", "Answer": "\r\nThe issue is the multiplication of a 4x4 to a 1x4 matrix. The variable ```\nx```\n need to be transposed. \n\n```\n   function X = myFFT(x)\n       %only works if N = 2^k\n       N = numel(x);\n       xp = x(1:2:end);\n       xpp = x(2:2:end);\n       if N>=8\n          Xp = myFFT(xp);\n          Xpp = myFFT(xpp);\n          X = zeros(N,1);\n          Wn = exp(-1i*2*pi.*((0:N/2-1)')/N);\n          tmp = Wn .* Xpp;\n          X = [(Xp + tmp);(Xp -tmp)];\n       else\n         switch N\n           case 2\n              X = [1 1;1 -1]*x';\n           case 4\n              X = [1 0 1 0; 0 1 0 -1i; 1 0 -1 0;0 1 0 1i]*[1 0 1 0;1 0 -1 0;0 1 0 1;0 1 0 -1]*x';\n           otherwise\n              error('N not correct.');\n         end\n       end\n    end\n```\n\n\nthen test it with\n\n```\nt2 = 0:1:255;\nmyFFT(sin(t2));\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to perform a 2D Fast Fourier Transform in c++ [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI saw there was a post about this topic, but without any reply.\nHow to write a function that performs the 2D Fast Fourier Transform for a given image f?\nIt is possible to assume that the width = 2^m, height = 2^n for some integers m and n, and the input image is already properly padded.\nInput: f - An 2D Image represented in Complex Numbers\nOutput: F - The transformed coefficients, also represented in Complex Numbers\n\n```\nvoid FFT2D(Complex<double> *f, Complex<double> *F, int width, int height)\n{\n\n}\n```\n\n\nFor everyone who think I want you to program it for me:\nI don't. Just want some theoretical explanation of how this should work\n    ", "Answer": "\r\nYou can use the FFTW library to perform this: \n\n```\n#include <fftw.h>\n\nvoid FFT2D(Complex<double> *f, Complex<double> *F, int width, int height){   \n  fftw_plan p = fftw_plan_dft_2d(width, height, f, F, FFTW_FORWARD, FFTW_ESTIMATE);            \n  fftw_execute(p); \n  fftw_destroy_plan(p);\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Quaternion Fourier Transform of color image in Python\r\n                \r\nI'm working on a research project concerning image watermarking. The main part of it is the actual watermark embedding scheme, which I have chosen to be the  robust blind color image watermarking in quaternion Fourier transform domain. I have started the implementation using OpenCV python interface and got stuck on the step where I have to do the quaternion Fourier transform. The description in the article doesn't help a lot. My code is very basic:\n\n```\nimg = cv2.imread(\"jurassic_world.jpg\", cv2.IMREAD_COLOR)\n```\n\n\nhere image is being split into 8x8 blocks.\n\n```\nfft = np.fft.fft(img)\nreturn map(lambda row: map(lambda pix:(sum(pix.real), pix[0].imag, pix[1].imag, pix[2].imag), row) , fft)\n```\n\n\nFrom the article: \n\n\n  Jiang et al. (2008) introduced the fast algorithms of the 2D quaternion Fourier transform by using the traditional complex fast Fourier transforms, in which each part Fourier transform is calculated by FFT algorithm by means of separating a quaternion into a real part and other imaginary parts. The fast quaternion Fourier transform of color image f(m,n) can be represented as:\n  \n  F(u,v) = i(Real(Rrft) + μImag(Rrft)) +\n             j(Real(Grft) + μImag(Grft)) +\n             k(Real(Brft) + μ*Imag(Brft))\n\n\nwhere Real(x) denotes the real part of complex number x, Imag(x) denotes the imaginary part of complex number x, and Rrft is the real Fourier transform of array R.\n\nCan someone explain what I'm doing wrong, and show me the right way?\n\nUpdate 1\n\nI have updated the code to compute separate fft for each color channel. Then I sum the real parts and append imagine ones to form a quaternion. \n\n```\ndef computeBlockQFFT(block):\n\n  fft0 = np.fft.fft(block[:,:,0])\n  fft1 = np.fft.fft(block[:,:,1])\n  fft2 = np.fft.fft(block[:,:,2])\n\n  res =  np.empty([block.shape[0],block.shape[1],block.shape[2]+1])\n\n  res[:,:,0] = fft0[:,:].real + fft1[:,:].real + fft2[:,:].real\n  res[:,:,1] = fft0[:,:].imag\n  res[:,:,2] = fft1[:,:].imag\n  res[:,:,3] = fft2[:,:].imag\n  return res\n```\n\n\nNow when I plot one color imagine component I get this picture and the data has a form of -764.882831772. The plot looks somewhere similar, however it doesn't match the one from article even though the same Lenna images were used. Can the reason be in the missing μ in my implementation? Also I'm struggling with the inverse transform. There are four components in the inverse formula:\n\n\n  f(u,v) = (Real(Airft) + μImag(Airft)) +\n             i(Real(Cirft) + μImag(Cirft)) +\n             j(Real(Dirft) + μImag(Dirft)) +\n             k(Real(Eirft) + μImag(Eirft)) \n\n\nHow can I map them to 3 color channels? Leave out the first one?\n    ", "Answer": "\r\nThe formula you quoted:\n\n\n  F(u,v) = i(Real(Rrft) + μImag(Rrft)) + j(Real(Grft) + μImag(Grft)) +\n  k(Real(Brft) + μ*Imag(Brft))\n\n\nFirst thing: ```\ni,j,k```\n are the imaginary axis. ```\nmu```\n is a quaternion and the direction used for the quaternion fourier transform.\n\nWhen we calculate ```\ni*mu```\n, ```\nj```\nmu```\nand```\nk*mu```\n, this will give us quaterions again.\nWe map real to 0,```\ni```\nto 1```\nj```\nto 2 and```\nk` to 3.\n\nThe formula tells us:\n\nlet ```\ni*mu*fft0.imag = a0+b0*i+c0*j+d0*k```\n , ```\nj*mu*fft1.imag = a1+b1*i+c1*j+d1*k```\n and ```\nk*mu*fft2.imag = a2+b2*i+c2*j+d2*k```\n.\n\n```\nres[0] = a0+a1+a2\nres[1] = fft0.real + b0+b1+b2\nres[2] = fft1.real + c0+c1+c2\nres[3] = fft2.real + d0+d1+d2\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Android audio recording, applying Fast Fourier transform\r\n                \r\nCurrently I'm recording audio using ```\nAudioRecord```\n, more precisely - using it's ```\nread```\n method overloads that is fed with short buffer (can't use ```\nfloat[]```\n one because of min API constraints).\n\nI want to apply Fast Fourier transform to the data I get during recording. Firstly I convert a received ```\nshort[]```\n to ```\nfloat[]```\n using such a conversion:\n\n```\npublic static float[] convertShortToFloat(short[] array) {\n    float[] data = new float[array.length];\n    for (int i = 0; i < array.length; i++) {\n        data[i] = 1.f * array[i] / Short.MAX_VALUE;\n    }\n    return data;\n}\n```\n\n\nThen I just provide the resulting ```\nfloat[]```\n to the ```\nFFT```\n instance and get the result using ```\ngetRealPart()```\n method (the implementation of this class I have is actually a bit different, but I believe that it works almost the same as this).\n\nAs far as I understand, now I should convert the data I got after transformation back to ```\nshort[]```\n form (convert back to a primal signal domain), and then submit to a muxer. I created a ```\nshort[]```\n-```\nfloat[]```\n array conversion just to be the opposite to the one I've shown earlier, but I just get noise when I play the recording.\n\nWhat's wrong with the implementation? \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transforms on GPU on iOS\r\n                \r\nI am implementing compute intensive applications for iOS (i.e., iPhone or iPad) that heavily use fast Fourier transforms (and some signal processing operations such as interpolations and resampling). What are the best libraries and API that allows for running FFTs on iOS? \n\nI have briefly looked into Apple Metal as well as Apple vDSP. I wasn't sure that vDSP utilizes GPUs although it seems to be highly parallelized and utilizes SIMD. Metal seems to allow to access GPU for compute intensive apps, but I am not able to find libraries for FFT and basic signal processing operations (something like AMD's clFFT). Does Apple provide such libraries?\n\nAre there other APIs and libraries utilizing GPUs for iOS that are suitable for compute intensive apps?   \n\nThanks.\n    ", "Answer": "\r\nvDSP actually uses the builtin (from iPhone 3GS onward) NEON vector arithmetic processor, which is, as you already said a SIMD engine and is really fast for certain tasks, including FFT.\n\nI have no experience with computing an FFT on the GPU but i doubt it will be faster as the NEON instructions in vDSP, as its only purpose are these media and signal processing related tasks.\n\nvDSP uses Arm NEON instructions under the hood and makes using them really easy. If you want to get down and dirty you could also use the NEON instruction set manually, but i think even getting on par with vDSP runtime wise will be a challenge, especially if you only need out of the box functions like FFT.\n\nIf you want to test the NEON engine yourself there is a great benchmark as APK for Android devices which tests regular vs NEON computation. The only thing you have to notice is, that if your data is larger than the L1 Cache the L2 Cache accessing becomes the limiting factor and if you even exceed this, there wont be a noticable runtime advantage.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Getting correct frequencies using a fast Fourier transform\r\n                \r\nI am trying to take understand the frequencies of a dataset and am having issues in getting the fast Fourier transform to work. The main problem is that I cannot figure out how to get the correct frequencies on the x-axis.\nBackground\nI have a dataset with many columns but the columns of interest are TOF(time of flight) and dE/dx. I have attached the CSV file containing the data. Here is how I access it.\n```\nimport pandas as pd\nfile = 'np_15us.csv'\ndataset = pd.read_csv(file,skiprows=8)\ndf = dataset[:-1] #necesssary because last row of the dataset is null for some reason\nx = df['TOF'] #TOF is in micro-seconds\ny= df['dE/dx']\n```\n\nNow, when you plot ```\nx vs. y```\n it's roughly a sinusoid. I can eyeball the frequency to be roughly 116kHz. I want to get the exact frequencies by using a fast Fourier transform because I expect other datasets to be imperfect sinusoids.\n\nProblem\nWhen I try to take the ```\nfft```\n of the data set using this code:\n```\nimport numpy as np\nx_new = np.arange(0,14, dt)\ny_new = func_1(x_new)\nfs = len(y_new)\n\nfig = plt.figure(2)\nplt.subplot(2,1,1)\nplt.plot(x_new, y_new)\nplt.xlabel('time (usec)')\nplt.ylabel('E (V/mm)')\nplt.subplot(2,1,2)\nfft = np.fft.fft(y)/len(y)\nfft = fft[range(int(len(y)/2))]\ntpCount = len(fft)\nvalues = np.arange(int(tpCount))\ntimePeriod = tpCount/samp\nfrequencies = (values/(2*timePeriod))*10**6 #followed some tutorial to get here\nplt.plot(frequencies[:100], abs(fft)[:100]) #zooming in to one of the peaks \nfig.tight_layout()\nplt.show()\n```\n\nI get,\n\nThis has a frequency of roughly 260kHz which is an overestimate. I can run the same script using ```\nnp.fft.fftfreq```\n to get\n```\nfunc_1 = interpolate.interp1d(x, y)\nsamp = 100\ndt = 1/samp\nx_new = np.arange(0,14, dt)\ny_new = func_1(x_new)\nfs = len(y_new)\nfig = plt.figure(2)\nplt.subplot(2,1,1)\nplt.plot(x_new, y_new)\nplt.xlabel('time (usec)')\nplt.ylabel('E (V/mm)')\nplt.subplot(2,1,2)\nfft = np.fft.fft(y)/len(y)\nfreqs = np.fft.fftfreq(len(fft),dt)\nfft_shift = np.fft.fftshift(fft)\nfreqs = np.fft.fftshift(freqs)\nplt.plot(freqs[int(len(freqs)/2):int(len(freqs))-300], abs(fft_shift[int(len(fft_shift)/2):int(len(freqs))-300]) #now I don't understand the frequnecies\nfig.tight_layout()\nplt.show()\n```\n\n\nWhichever way I use, I get incorrect frequencies. So, I am definitely doing something wrong. I don't really understand how the frequencies are calculated using np.fft.fftfreq.\nI don't exactly know the sampling frequency of the dataset which is why I am interpolating to get more control over that. I am not sure if I am supposed to be doing that. I would like to use ```\nnp.fft.fftfreq```\n since the code for that seems cleaner.\nThank you for your help. Please let me know if you have any questions.\nPlease note - in this case dE/dx in the dataset should actually be dV/dx like shown in the first plot. The CSV file just has is named incorrectly.\nlink to CSV file - https://drive.google.com/file/d/1LNcue82K2y4ZgKr8cPIgp7VCC2vFk_J9/view?usp=sharing\n    ", "Answer": "\r\nIf your data is very close to a sinusoid like this, and you generally have at least one period I think you will get a much better estimate in the time domain.  FFTs have energy in bins and it just picking the top bin will not give you the best result.\nI would measure the distance between zero crossings of the dE/dx value.  (Do a linear interpolation to get a more exact zero crossing location).  Without even doing the interpolation I got a value of 117.9kHz.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how can i calculate bits perminute using Fast Fourier transform\r\n                \r\ni am getting  signals as given bellow this data capture for just 10 second  (due to limited space here) now i want to write a code which shows bits per minute and i m considering the value 3.00 as a bit \n\nWhat i did: \n\nI just used a threshold value to print data to count bits per minute \n\nas \n\n```\nthreshold  = 2.8     # Threshold to do something if value is more than to that. \nif signal >= 2.8:\n    print signal              \n    counter  = counter +1 # to count how many times we get value more than 2.8 or (near by 3)\n    bits_per_mint = counterx6 # captured for 10 second so converted it to minute \nprint bits_per_mint   \n\ndata out put in 10 second  \n\n1.7646050347\n1.6970572917\n1.6774392361\n0\n3.486762153\n1.6310026042\n1.6582465278\n1.6384114583\n1.6501171875\n1.6769661458\n3.9909898997\n0\n1.6688020833\n1.6627473958\n1.6689800347\n1.6756423611\n1.6579513889\n0\n1.6809592014\n1.6504774306\n3.7684857685\n1.6463671875\n1.67640625\n0\n1.6509635417\n1.6736501736\n3.5653423434\n1.6581206597\n1.6516666667\n0\n1.6449348958\n1.6630338542\n1.6605772569\n1.6500824653\n3.4554564564\n0\n1.6839409722\n1.6495399306\n1.6393663194\n1.6684244792\n------------\n--------- so on \n```\n\n\nHow can i do this  using Fast Fourier transform\n\nthanks \n    ", "Answer": "\r\nTry this and let me know if it helped you. You can use ```\ntime```\n module to introduce the delay in seconds in an outer ```\nwhile```\n loop and then check for the condition if the signal is greater than the threshold if yes then print it and also append it to a list ```\nbits_per_min```\n. Example code shown below.\n\n```\nimport time\nthreshold  = 2.8     # Threshold to do something if value is more than to that. \nseconds = 0\ncounter = 0\n\nwhile seconds != 60:\n    bits_per_min = []    # this part of code runs for one min duration\n    if signal >= threshold:   # to compare if signal is greater than the threshold value\n        print signal\n        bits_per_min.append(signal)\n        counter += 1\n    time.sleep(1)\n    seconds += 1\nprint bits_per_min\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Do I need to resize the image to 2^a x 2^b before performing a fast fourier transform?\r\n                \r\nDo I need to resize the image to 2^a x 2^b before performing a fast fourier transform?\n    ", "Answer": "\r\nFor the cases where you do need to use a power of 2, rather than resizing, you should pad with zeros.\n\nIn some cases, even if the algorithm you are using is not limited to powers of 2, it may be more efficient to pad to that size anyway (particularly if your image is just slightly smaller than the next power of 2).  Also, if your image is not square, you can pad to a square image of 2^a before taking the fft.  Some algorithms will do this behind the scenes anyway - pad your image to square, take the fft, then crop back to the original size.\n\nZero padding is also sometimes used to increase the number of points in the output - a higher frequency \"resolution\", although since you're not adding any more data it's more like an interpolation.\n\nWhether you need to do this will depend on what fft library you are using.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Passing GpuMat directly to cufftExecC2C function for doing fast fourier transform\r\n                \r\nI am trying to optimize my code using opencv with cuda and cufft library. Everytime I have do fast fourier transform, I have to download cv::Mat from GpuMat and then do cufft. (Please see the code below) and again download the result of the fft. Is there any way I can optimize this ? I wanted to know if there is any way I could directly pass GpuMat without having to download it. \n\n```\nstd::vector<cv::cuda::GpuMat> ReconClass::FFT2(std::vector<cv::cuda::GpuMat>& mat, int height, int width)\n{\n    cufftHandle plan;\n    cufftComplex* data, * datao, * devdata, * devdatao;\n\n    size_t arraySize = sizeof(cufftComplex) * mat[0].size().area();\n    cudaMallocHost((void**)& data, arraySize);\n    cudaMallocHost((void**)& datao, arraySize);\n\n    cudaMalloc((void**)& devdata, arraySize);\n    cudaMalloc((void**)& devdatao, arraySize);\n\n    cv::Mat iReal;\n    cv::Mat iImag;\n    mat[0].download(iReal);\n    mat[1].download(iImag);\n\n    for (int i = 0; i < height; i++)\n    {\n        for (int j = 0; j < width; j++)\n        {\n            data[i * width + j].x = iReal.at<float>(i, j);\n            data[i * width + j].y = iImag.at<float>(i, j);\n        }\n    }\n    cudaMemcpy(devdata, data, arraySize, cudaMemcpyHostToDevice);\n\n    cufftPlan2d(&plan, height, width, CUFFT_C2C);\n\n    if (!plan)\n        std::cout << \"the cufftPlan2d plan returned is null\" << std::endl;\n\n    cufftExecC2C(plan, (cufftComplex*)devdata, (cufftComplex*)devdatao, CUFFT_FORWARD);\n\n    cudaMemcpy(datao, devdatao, arraySize, cudaMemcpyDeviceToHost);\n\n    cv::Mat realRecon(height, width, CV_32F);\n    cv::Mat imagRecon(height, width, CV_32F);\n\n    for (int i = 0; i < height; i++)\n    {\n        for (int j = 0; j < width; j++)\n        {\n            realRecon.at<float>(i, j) = datao[i * width + j].x;\n            imagRecon.at<float>(i, j) = datao[i * width + j].y;\n        }\n    }\n\n    cv::cuda::GpuMat mat1, mat2;\n    mat1.upload(realRecon);\n    mat2.upload(imagRecon);\n\n    std::vector<cv::cuda::GpuMat> re = { mat1 , mat2 };\n\n    cufftDestroy(plan);\n    cudaFreeHost(data);\n    cudaFreeHost(datao);\n    cudaFree(devdata);\n    cudaFree(devdatao);\n\n    return re;\n}\n```\n\n    ", "Answer": "\r\nI was able to avoid copy to the CPU and back copy to the device. Also doing inplace FFT helped improve performance. I have pasted my code below. \n\n```\nvoid Dataransfer2Cuda(const cv::InputArray _dReal, const cv::InputArray _dImag, float2* zCufftcomplex)\n{\n    const cv::cuda::GpuMat Real = _dReal.getGpuMat();\n    const cv::cuda::GpuMat Imag = _dImag.getGpuMat();\n\n    dim3 cthreads(32, 32);\n    dim3 cblocks(\n        static_cast<int>(std::ceil(Real.size().width /\n            static_cast<double>(cthreads.x))),\n        static_cast<int>(std::ceil(Real.size().height /\n            static_cast<double>(cthreads.y))));\n\n    Kernel_DataTransfer2Cuda << <cblocks, cthreads >> > (Real, Imag, zCufftcomplex);\n\n    if (cudaSuccess != cudaGetLastError())\n        std::cout << \"Dataransfer2Cuda(): gave an error\" << std::endl;\n\n    return;\n}\n\nvoid DataransferFromCuda(const float2* zCufftcomplex, cv::OutputArray _outputReal, cv::OutputArray _outputImag, std::size_t iWidth, std::size_t iHeight)\n{\n\n    _outputReal.create(iHeight, iWidth, CV_32F);\n    _outputImag.create(iHeight, iWidth, CV_32F);\n\n    cv::cuda::GpuMat outputReal = _outputReal.getGpuMat();\n    cv::cuda::GpuMat outputImag = _outputImag.getGpuMat();\n\n\n    dim3 cthreads(32, 32);\n    dim3 cblocks(\n        static_cast<int>(std::ceil(outputReal.size().width /\n            static_cast<double>(cthreads.x))),\n        static_cast<int>(std::ceil(outputReal.size().height /\n            static_cast<double>(cthreads.y))));\n\n    Kernel_DataTransferFromCuda << <cblocks, cthreads >> > (zCufftcomplex, outputReal, outputImag);\n\n    if (cudaSuccess != cudaGetLastError())\n        std::cout << \"DataransferFromCuda(): gave an error\" << std::endl;\n\n    return;\n}\n\nstd::vector<cv::cuda::GpuMat> ReconClass::FFT2(std::vector<cv::cuda::GpuMat>& mat, int height, int width)\n{\n    cufftHandle plan;\n    cufftComplex* devdata;\n\n    size_t arraySize = sizeof(cufftComplex) * mat[0].size().area();\n\n    cudaMalloc((void**)& devdata, arraySize);\n\n    Dataransfer2Cuda(mat[0], mat[1], devdata);\n\n    cufftPlan2d(&plan, height, width, CUFFT_C2C);\n\n    if (!plan)\n        std::cout << \"the cufftPlan2d plan returned is null\" << std::endl;\n\n    cufftExecC2C(plan, (cufftComplex*)devdata, (cufftComplex*)devdata, CUFFT_FORWARD);\n\n    cv::cuda::GpuMat mat1, mat2;\n    DataransferFromCuda(devdata, mat1, mat2, width, height);\n    std::vector<cv::cuda::GpuMat> re = { mat1 , mat2 };\n\n    cufftDestroy(plan);\n    cudaFree(devdata);\n\n    return re;\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Determining the amplitude for a specific cycle (frequency) using a fast fourier transform\r\n                \r\nI have been set an assignment using a dataset obtained from remote sensing on sea surface height anomaly. Before starting the question I'm having trouble with, I have loaded the data into matlab, filtered it so that it only contains data within the desired geographic location and plotted the data as a function of time. \n\nThe question I'm struggling with specifically is: \n\n\"Determine the amplitude of the annual cycle in the SSHA data at 36°, 21°W\nusing fast Fourier transform.\"\n\nwhere SSHA is the sea surface height anomaly data. \n\nAs I said above, I have filtered the data. I have also used the fast fourier transform command on the filtered data; fft(sshaFiltered) \n\nand plotted the absolute data; abs(sshaFilteredFft); plot(sshaFilteredAbs). \n\nThis has enabled me to plot the data as a function of it's frequency (I believe). I just don't understand how to determine the amplitude of it's annual cycle. \n\nAny response is greatly appreciated, thank you.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "An implementation of the fast Fourier transform (FFT) in C# [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhere can I find a free, very quick, and reliable implementation of FFT in C#?\n\nThat can be used in a product? Or are there any restrictions?\n    ", "Answer": "\r\nThe guy that did AForge did a fairly good job but it's not commercial quality.  It's great to learn from but you can tell he was learning too so he has some pretty serious mistakes like assuming the size of an image instead of using the correct bits per pixel.\n\nI'm not knocking the guy, I respect the heck out of him for learning all that and show us how to do it. I think he's a Ph.D now or at least he's about to be so he's really smart it's just not a commercially usable library.\n\nThe Math.Net library has its own weirdness when working with Fourier transforms and complex images/numbers. Like, if I'm not mistaken, it outputs the Fourier transform in human viewable format which is nice for humans if you want to look at a picture of the transform but it's not so good when you are expecting the data to be in a certain format (the normal format). I could be mistaken about that but I just remember there was some weirdness so I actually went to the original code they used for the Fourier stuff and it worked much better. (ExocortexDSP v1.2 http://www.exocortex.org/dsp/)\n\nMath.net also had some other funkyness I didn't like when dealing with the data from the FFT, I can't remember what it was I just know it was much easier to get what I wanted out of the ExoCortex DSP library. I'm not a mathematician or engineer though; to those guys it might make perfect sense.\n\nSo! I use the FFT code yanked from ExoCortex, which Math.Net is based on, without anything else and it works great.\n\nAnd finally, I know it's not C#, but I've started looking at using FFTW (http://www.fftw.org/).  And this guy already made a C# wrapper so I was going to check it out but haven't actually used it yet. (http://www.sdss.jhu.edu/~tamas/bytes/fftwcsharp.html)\n\nOH! I don't know if you are doing this for school or work but either way there is a GREAT free lecture series given by a Stanford professor on iTunes University.  \n\nhttps://podcasts.apple.com/us/podcast/the-fourier-transforms-and-its-applications/id384232849\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Extract amplitude and phase using scipy fft (fast fourier transform)\r\n                \r\nI am trying to use a Fast Fourier Transform to extract the amplitude and phase shift of two sinusoidal waves. By experimenting, I found out that transform returned from the FFT had an amplitude that was actually an N/2 times multiple of my actual signal (where N is the number of samples in the wave). So, to extract and plot the actual transform, I had to multiply the gain by 2/N.\nThe portion of the code showing this is attached below:\n```\nfrom scipy.fft import fft, rfft\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 600  # number of sample points\nd = 1.0  # time domain\nf = 50   # frequency\nu = 0.1  # mean inlet velocity\ndu = 0.1  # velocity perturbation rate\nT = 1.0 / f  # period\ns = d/N  # sample spacing\n\n# 1st sine wave\nx1 = np.linspace(0.0, d, N)\ny1 = u*du* np.sin(f * 2.0*np.pi*x1)\nyf1 = rfft(y1)\nxf1 = np.linspace(0.0, 1.0/(2.0*s), N//2)\n\n# 2nd sine wave\nq = 0.08  \ndq = 0.1  \nphi = np.pi / 2 # phase delay (rad)\n\nx2 = np.linspace(0.0, d, N)\ny2 = q*dq* np.sin(f * 2.0*np.pi*x2 - phi)\nyf2 = fft(y2)\nxf2 = np.linspace(0.0, 1.0/(2.0*s), N//2)\n\n#plt.plot(x,y)\nplt.plot(xf1, 2.0/N * np.abs(yf1[0:N//2]))\nplt.plot(xf2, 2.0/N * np.abs(yf2[0:N//2]))\nplt.grid()\nplt.show()\n```\n\nI cannot figure out why the FFT returns this amplitude multiplied by N/2.\nA secondary problem I face is how to extract the phase shift (phi) from the 2 transformed waves. Any help would be appreciated.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform algorithm wrong by a single minus sign\r\n                \r\nSo after watching this video on the fast fourier transform https://www.youtube.com/watch?v=h7apO7q16V0\nI analysed the pseudocode and implemented it in python to find out that it was producing a different output to that of many fft calculator sites. My values seem to be all there its just odd, as the order is out of place, anyone know why. Is it a different kind of algorithm implementation or something.\n```\n\nimport cmath\nimport math\ndef FFT(P):\n    n= len(P)\n\n    if n == 1:\n        return P\n\n    omega = cmath.exp((2 * cmath.pi * 1j)/n)\n\n    p_even = P[::2]\n    p_odd = P[1::2]\n\n    y_even = FFT(p_even)\n    y_odd = FFT(p_odd)\n\n    y = [0] * n\n\n    \n    for i in range(n//2):\n        y[i] = y_even[i] + omega**i*y_odd[i]\n        y[i+n//2] = y_even[i] - omega**i*y_odd[i]\n    return y\n\n    \npoly = [0,1,2,3]\nprint(FFT([0,1,2,3]))\n```\n\nThe site I tested it against was https://tonysader.github.io/FFT_Calculator/?\nand I input into this site 0,1,2,3 and obtained: 6, -2+2J, -2, -2+-2J\nwhilst my python program output : 6, -2-2J, -2, -2+2J\nThe pseudocode I followed:\n\n    ", "Answer": "\r\nI think the program you're running is executing the inverse FFT.  Try\n```\nomega = cmath.exp((-2 * cmath.pi * 1j)/n)```\n.  Note the minus sign.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to use the FFT (Fast Fourier Transform) in Matlab\r\n                \r\nI'm just learning Matlab and the fast fourier transform algorithm.\n\nAs a first step I tried to duplicate this example: https://en.wikipedia.org/wiki/Fourier_transform#Example\n\nI use the following code:\n\n```\nt = -6:0.01:6;\ns = cos(2 * pi * 3 * t) .* exp(-pi * t.^2);\nfigure(1);\nplot(t, s);\nxlim([-2 2]);\nr = fft(s);\nfigure(2);\nplot(t, abs(r));\n```\n\n\nAnd I obtained the following picture:\n\nFigure 2:\n\n\n\nFigure 1 is OK, but Figure 2 is not. I see one of the problem is that in Figure 2 I should plot vector r against frequency, not against time. Another problem in Figure 2 is the scale in the Y-axis.\n\nThus, I have 2 questions in order to duplicate the example:\n\n\nHow can I obtain the frequency domain (X-axis in Figure 2)?\nHow should I scale vector r (Y-axis in Figure 2)?\n\n    ", "Answer": "\r\nYour issue is that you aren't actually creating a frequency vector to plot the ```\nfft```\n against. The reason that the fft is plotted against time is because that is what you specified in your plot command.\n\nHere is a working fft outline:\n\n```\nN=length(t);\nindex=0:N-1;\nFrequencyResolution=SamplingRate/N;\nFrequency=index.*FrequencyResolution;\ndata_fft=fft(detrend(data)); \n%the detrend isn't necessary but it does look nicer because it focuses the plot on changes around the mean of the data\ndata_FFTmagnitude=abs(data_fft);\nplot(Frequency, data_FFTmagnitude)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform difference in result between wolframalpha and commons-math\r\n                \r\nI have a question related with Fast Fourier Transform. \nI downloaded \"Math Commons 3.2\" library where is FFT. But the result is different than I expected.   \n\nFor instance, for data like, real: ```\n1,0,0,0,0,0,0,0,0```\n imaginary: ```\n0,0,0,0,0,0,0,0,0```\n \nI've got, real:```\n1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0```\n imaginary:```\n0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0```\n\nthe same result I've got when I used this code\n(in \"public static main\" section this example exist as a \"test\")\nbut in wolframalpha the real values are all 1/3 rather than 1.0.\n\nThe question:\nWhere/What is a difference and how can I get the same result like in wolframalpha\nBest regards\nDawid D\n    ", "Answer": "\r\nIdeally, the Discrete Fourier Transform is an orthonormal transformation. It just rotates the coordinate system to give a different set of coordinates for the same point in space.\n\nMany implementations of the DFT are not normal; they change the magnitude of the vector simply for computational convenience. Essentially, all the additions they do multiply the vector length by the number of elements in it, and the implementations never multiply or divide to compensate for that.\n\nObserve that the length of the vector WolframAlpha returned to you is 1, the same as the length of the input vector. (The length is the square root of the sum of the squares of the elements. The length of the input vector is sqrt(1+0+0+0+0+0+0+0+0) = 1. The length of the output vector is sqrt(1/9+1/9+1/9+1/9+1/9+1/9+1/9+1/9) = 1.)\n\nIt is a common convention for DFT implementations to ignore the normalization and return scaled results. This works because most operations used on the transform results do not care about the absolute magnitude. Additionally, a common process is to compute one or more DFTs, combine or process the results, and compute an inverse DFT. If the scaling is part of the DFTs, then it must be performed in each DFT and each inverse DFT. If you leave the scaling out of the DFTs, then the application can combine all of the scales that are involved into a single scaling operation at the end. It is better for computing performance to do a scaling once than many times, so this is preferred.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Is there any way to use Youtube API stream to do fast fourier transform with C# application\r\n                \r\nSay you link to a video on Youtube with a C# application using Youtube API.\nIs there any way to deal with the video Flash so it's look like doing fast fourier transform on realtime?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Computational complexity of an n-dimensional Fast Fourier Transform? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Computational complexity of the FFT in n dimensions\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm trying to write a bit of code that will predict the time taken to perform a discrete Fourier transform on a given n-dimensional array, but I'm struggling to get my head around the computational complexity of n-dimensional FFTs.\n\nAs I understand it:\n\n\nThe 1D FFT of a vector of length ```\nN```\n should take ```\nk*(N*log(N))```\n where ```\nk```\n is some timing constant\nFor an ```\nM*N```\n matrix, the 2D FFT should take:\n\n```\nN*(k*M*log(M)) + M*(k*N*log(N)) = k*M*N*(log(M)+log(N))```\n\n\nsince it requires taking 1D FFTs in each row and column\n\n\nHow does this generalize to the ND case? Does it follow that it should be ```\nk*prod(dimensions)*sum(log(dimensions))```\n?\n    ", "Answer": "\r\nIf we take your derivation of 2D a bit further, it becomes clear:\n\n```\nN*(k*M*log(M)) + M*(k*N*log(N)) = k*M*N*(log(M)+log(N))\n```\n\n\nbecomes:\n\n```\n                                = k*M*N*(log(M*N))\n```\n\n\nFor N dimensions (A,B,C, etc...), the complexity is:\n\n```\nO( A*B*C*... * log(A*B*C*...) )\n```\n\n\nMathematically speaking, an N-Dimensional FFT is the same as a 1-D FFT with the size of the product of the dimensions, except that the twiddle factors are different. So it naturally follows that the computational complexity is the same.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to calculate a sum of products of array elements using a fast Fourier transform?\r\n                \r\nI have some binary array. For example, let my array is:\n\n```\nint a[] = {1, 0, 0, 0, 1, 0, 1, 0, 1}\n```\n\n\nI want to calculate the values based on this formula:\n\n\n\nHow to calculate this function, using a fast Fourier transform? I have a large array and I have to calculate this function many times. So, I want to be able to calculate this function quick.\n    ", "Answer": "\r\nThe calculation you are making is basically a convolution and convolution in the time domain is simply multiplication in the frequency domain.So just get the FFT of ```\na```\n and multiply it with itself, then perform an IFFT to return to the time domain.So in short, you can calculate b by\n\n```\nb(2*i) = IFFT( FFT(a[0:2*i)]).FFT(a[0:2*i]) ) \n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Implementing a Fast Fourier Transform for Option Pricing\r\n                \r\nI'm in need of some tips regarding a small project I'm doing. My goal is an implementation of a Fast Fourier Transform algorithm (FFT) which can be applied to the pricing of options.\n\nFirst concern: which FFT?\n\nThere are a lot of different FFT algorithms, the most famous one being Cooley-Tukey. My thoughts on this: I prefer the most simple one, since this is no thesis or big project, just a course on Algorithms. But it has to be compatible with option pricing (in contrast with the most - well in our general literature- referenced application of images/sound processing). So it depends on the form of input that is provided (on which I need some advice). I'm familiar with the several improvements, like a Fractional FFT, mixed-radix FFT etc. But these seem pretty complex and optimization/performance driven, which is not relevant for my project.\n\nSecond concern: which pricing model?\n\nI Guess Black-Scholes (BS) is a bit too 'flat' and I am aware of the several models that emerged after BS. So, with the same objectives as stated above, I'd initially prefer the Heston model.\n\nThere are a lot of considerations, and the truth is that I just can't see the wood for the trees.\n\nSome background info:\n\nMy background is a B.Sc in Mathematics (Theoretical), so I have some understanding of Fourier transforms. \n\nThe goal is a working FFT implementation for calculating option pricing. It does not have to be the fastest (no extreme optimization). The goals are trying to understand the chosen FFT and having a real-world working application. \n\nSo could you give some advice on the choices?\n\nI've read a lot of papers on FFT + Option pricing, say all the decent hits on googles first few pages. But those studies were written with a much 'higher' cause.\n    ", "Answer": "\r\nIf your goal is to make some use of the FFT, then your choices are poor: only affine models give you enough information to obtain the Fourier transform of the spot density. In practice, this means Black-Scholes, or Heston. Perhaps a few more, but none of the \"useful\" models.\n\nHeston's model has peculiar features (pertaining to its implied vol dynamics) which makes it quite useless as a stochastic vol model. I suppose it is popular precisely because of the fact that you can price vanilla options in semi-closed form, through Fourier transforms. With modern technology, this is no longer a real asset.\n\nIf you are interested in option pricing, I'd therefore suggest you don't try too hard with FFT, and turn to PDE or Monte-Carlo methods: the range of models you can play with are much more interesting (and much more valuable on the job market, in case you're interested).\n\nFor the FFT part of your question, implementing Cooley-Tukey from scratch is not hard, and you can start there. Of course, in production code, you are better using a canned package (like FFTW).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform results: frequency axis scale?\r\n                \r\nI successfully implemented code that takes array data and runs a fast fourier transform on it, using Apple's Accelerate Framework (performed on iOS device).\n\nMy question now is what is the scale of the frequency axis?  The results have peaks as expected in certain frequency ranges, but I'm not sure what the frequency should be.  The Accelerate Framework's FFT functions take in an array and spit out an array with the same (or more) number of data points.  Does it assume that all those points are equally spaced in time?  It doesn't take the sampling frequency or time variable as input.  Is the scale of the frequency axis (i.e. frequency increment on each point) just the sampling period divided by 2*Pi (or something similar to that?)  I couldn't find a lot of information in the documentation on this.  I've been looking for similar questions online and haven't found anything.\n\nThis is in some ways a math question, although it depends heavily on the Accelerate Framework implementation.\n\nThanks\n\nEDIT\nI asked a follow-up question here but no one has answered it yet.  Please take a look!\n    ", "Answer": "\r\nThe FFT gives you linearly spaced frequency bins up to the sampling frequency. This means that the spacing between the bins is (sample frequency) / (number of bins).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Image processing and Fast Fourier Transformation\r\n                \r\nI am developing an application which does image processing in real time to get the y-sum and time between each frame. They are stored in 2 double arrays and for further implementations i need to run Fast Fourier Transformation on these values.\n\nI have seen several fft algorithms in other questions such as\n\n\nStack Overflow Question 1\nStack Overflow Question 2\n\n\nI have also read topics where they suggesting using JTransform library\n\nHowever, Since I have very very limited knowledge about FFT, I am not sure how to implement it into my code.\n\nMy MainActivity is this\n\n```\npublic class MainActivity extends AppCompatActivity implements CameraView.PreviewReadyCallback {\nprivate static Camera camera = null;\nprivate CameraView image = null;\nButton fftButton;\n\nprivate LineChart bp_graph;\nprivate int img_Y_Avg, img_U_Avg, img_V_Avg;\nprivate long end = 0, begin = 0;\nHandler handler;\nprivate int readingRemaining = 1200;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n    bp_graph = (LineChart)findViewById(R.id.graph);\n    fftButton = (Button)findViewById(R.id.runFFT);\n\n    graph_features();\n\n    //open camera\n    try {\n        camera = Camera.open();\n\n        handler = new Handler();\n        final Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                camera.stopPreview();\n                camera.release();\n                fftButton.setVisibility(View.VISIBLE);\n            }\n        };\n        handler.postDelayed(runnable, 30000);\n\n    } catch (Exception e) {\n        Log.d(\"ERROR\", \"Failed to get camera: \" + e.getMessage());\n    }\n\n    if (camera != null) {\n        image = new CameraView(this, camera);\n        FrameLayout camera_view = (FrameLayout) findViewById(R.id.camera_view);\n        camera_view.addView(image);\n        image.setOnPreviewReady(this);\n    }\n}\n\n\n@Override\nprotected void onResume(){\n    super.onResume();\n}\n\n@Override\nprotected void onPause() {\n    super.onPause();\n}\n\n@Override\npublic void onPreviewFrame(long startTime, int ySum, int uSum, int vSum, long endTime) {\n    begin = startTime;\n    img_Y_Avg = ySum;\n    img_U_Avg = uSum;\n    img_V_Avg = vSum;\n    end = endTime;\n\n   showResults(begin, img_Y_Avg, img_U_Avg, img_V_Avg, end);\n}\n\nprivate void showResults(long startTime, int ySum, int uSum, int vSum, long endTime){\n\n    //set value of Y on the text view\n    TextView valueOfY = (TextView)findViewById(R.id.valueY);\n    //valueY = img_Y_Avg;\n    valueOfY.setText(String.valueOf(img_Y_Avg));\n\n    //start time in milliseconds\n    long StartDurationInMs = TimeUnit.MILLISECONDS.convert(begin, TimeUnit.MILLISECONDS);\n    ArrayList<Long> startOfTime = new ArrayList<>();\n    startOfTime.add(StartDurationInMs);\n\n    //store value to array list\n    ArrayList<Integer> yAverage = new ArrayList<>();\n    yAverage.add(img_Y_Avg);\n\n    ArrayList<Long> getValues = new ArrayList<>();\n\n    for(int i = 0; i < yAverage.size(); i++) {\n        getValues.add(startOfTime.get(i));\n        getValues.add((long)(yAverage.get(i)));\n    }\n\n    storeCsv(yAverage, getValues);\n    Log.d(\"MyEntryData\", String.valueOf(getValues));\n\n}\n\n/**\n * method to store raw time and y-sum data into CSV file**/\npublic void storeCsv(ArrayList<Integer>yAverage, ArrayList<Long>getValues){\n\n    String filename = \"temporary.csv\";\n\n    //File directoryDownload = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    String path = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/bpReader\";\n    //File logDir = new File (directoryDownload, \"bpReader\"); //Creates a new folder in DOWNLOAD directory\n    File logDir = new File(path);\n    logDir.mkdirs();\n    File file = new File(logDir, filename);\n\n\n    FileOutputStream outputStream = null;\n       try {\n           file.createNewFile();\n           outputStream = new FileOutputStream(file, true);\n           //outputStream = openFileOutput(filename, Context.MODE_PRIVATE);\n           for (int i = 0; i < yAverage.size(); i += 2) {\n               outputStream.write((getValues.get(i) + \",\").getBytes());\n               outputStream.write((getValues.get(i + 1) + \"\\n\").getBytes());\n               //outputStream.write((getValues.get(i + 2) + \",\").getBytes());\n               //outputStream.write((getValues.get(i + 3) + \"\\n\").getBytes());\n           }\n           outputStream.flush();\n           outputStream.close();\n       } catch (Exception e) {\n           e.printStackTrace();\n       }\n\n}\n\n//Method for button which appears after the reading is done and the data is saved into csv file\npublic void readFile(View view){\n    readCsv();\n}\n//Method to read the data from the csv and get the time and y-sum value\npublic void readCsv(){\n    String getPath = Environment.getExternalStorageDirectory() + \"/bpReader\";\n    String csvFile = \"temporary.csv\";\n    String path = getPath+ \"/\" + csvFile;\n\n\n    int length = 500;\n    double[] xCoords = new double[length];\n    double[] yCoords = new double[length];\n    double[] newXcord = new double[length];\n\n    CSVReader reader;\n\n    try {\n        File myFile = new File (path);\n        reader = new CSVReader(new FileReader(myFile));\n        String[] line;\n        int i;\n        for (i = 0; i < xCoords.length; i ++){\n            if ((line = reader.readNext()) != null){\n                xCoords[i] = Double.parseDouble(line[0]);\n                yCoords[i] = Double.parseDouble(line[1]);\n            }\n        }\n\n        for (i = 0; i < xCoords.length ; i++){\n            if (xCoords[i]!=0) {\n                newXcord[i] = xCoords[i] - xCoords[0];\n\n                Log.d(\"read:: \", \"Time: \" + String.valueOf(newXcord[i]) + \" Y-Sum \" + String.valueOf(yCoords[i]));\n            }\n        }\n        myFile.delete();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n}\n}\n```\n\n\nAfter I have read the CSV file in ```\nreadCsv()```\n method, i get data like this\n\n```\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 0.0 Y-Sum 570194.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 50.0 Y-Sum 405504.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 118.0 Y-Sum 405504.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 168.0 Y-Sum 405504.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 234.0 Y-Sum 429242.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 301.0 Y-Sum 1217635.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 368.0 Y-Sum 1516666.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 418.0 Y-Sum 1495037.0\n10-15 16:37:50.127 16912-16912/redlight55.com.bpreader D/read::: Time: 486.0 Y-Sum 1514453.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 553.0 Y-Sum 1507075.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 625.0 Y-Sum 1511241.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 678.0 Y-Sum 1476090.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 749.0 Y-Sum 1476961.0\n10-15 16:37:50.128 16912-16912/redlight55.com.bpreader D/read::: Time: 815.0 Y-Sum 1470232.0\n```\n\n\nMy FFT class is this which i got from some of the suggestions in other stack overflow questions.\n\n```\npublic class FFT {\n\n/**\n * The Fast Fourier Transform (generic version, with NO optimizations).\n *\n * @param inputReal\n *            an array of length n, the real part\n * @param inputImag\n *            an array of length n, the imaginary part\n * @param DIRECT\n *            TRUE = direct transform, FALSE = inverse transform\n * @return a new array of length 2n\n */\npublic static double[] fft(final double[] inputReal, double[] inputImag,\n                           boolean DIRECT) {\n    // - n is the dimension of the problem\n    // - nu is its logarithm in base e\n    int n = inputReal.length;\n\n    // If n is a power of 2, then ld is an integer (_without_ decimals)\n    double ld = Math.log(n) / Math.log(2.0);\n\n    // Here I check if n is a power of 2. If exist decimals in ld, I quit\n    // from the function returning null.\n    if (((int) ld) - ld != 0) {\n        System.out.println(\"The number of elements is not a power of 2.\");\n        return null;\n    }\n\n    // Declaration and initialization of the variables\n    // ld should be an integer, actually, so I don't lose any information in\n    // the cast\n    int nu = (int) ld;\n    int n2 = n / 2;\n    int nu1 = nu - 1;\n    double[] xReal = new double[n];\n    double[] xImag = new double[n];\n    double tReal, tImag, p, arg, c, s;\n\n    // Here I check if I'm going to do the direct transform or the inverse\n    // transform.\n    double constant;\n    if (DIRECT)\n        constant = -2 * Math.PI;\n    else\n        constant = 2 * Math.PI;\n\n    // I don't want to overwrite the input arrays, so here I copy them. This\n    // choice adds \\Theta(2n) to the complexity.\n    for (int i = 0; i < n; i++) {\n        xReal[i] = inputReal[i];\n        xImag[i] = inputImag[i];\n    }\n\n    // First phase - calculation\n    int k = 0;\n    for (int l = 1; l <= nu; l++) {\n        while (k < n) {\n            for (int i = 1; i <= n2; i++) {\n                p = bitReverseReference(k >> nu1, nu);\n                // direct FFT or inverse FFT\n                arg = constant * p / n;\n                c = Math.cos(arg);\n                s = Math.sin(arg);\n                tReal = xReal[k + n2] * c + xImag[k + n2] * s;\n                tImag = xImag[k + n2] * c - xReal[k + n2] * s;\n                xReal[k + n2] = xReal[k] - tReal;\n                xImag[k + n2] = xImag[k] - tImag;\n                xReal[k] += tReal;\n                xImag[k] += tImag;\n                k++;\n            }\n            k += n2;\n        }\n        k = 0;\n        nu1--;\n        n2 /= 2;\n    }\n\n    // Second phase - recombination\n    k = 0;\n    int r;\n    while (k < n) {\n        r = bitReverseReference(k, nu);\n        if (r > k) {\n            tReal = xReal[k];\n            tImag = xImag[k];\n            xReal[k] = xReal[r];\n            xImag[k] = xImag[r];\n            xReal[r] = tReal;\n            xImag[r] = tImag;\n        }\n        k++;\n    }\n\n    // Here I have to mix xReal and xImag to have an array (yes, it should\n    // be possible to do this stuff in the earlier parts of the code, but\n    // it's here to readibility).\n    double[] newArray = new double[xReal.length * 2];\n    double radice = 1 / Math.sqrt(n);\n    for (int i = 0; i < newArray.length; i += 2) {\n        int i2 = i / 2;\n        // I used Stephen Wolfram's Mathematica as a reference so I'm going\n        // to normalize the output while I'm copying the elements.\n        newArray[i] = xReal[i2] * radice;\n        newArray[i + 1] = xImag[i2] * radice;\n    }\n    return newArray;\n}\n\n/**\n * The reference bitreverse function.\n */\nprivate static int bitReverseReference(int j, int nu) {\n    int j2;\n    int j1 = j;\n    int k = 0;\n    for (int i = 1; i <= nu; i++) {\n        j2 = j1 / 2;\n        k = 2 * k + j1 - 2 * j2;\n        j1 = j2;\n    }\n    return k;\n}\n}\n```\n\n\nMy Question is\n\n\nCan I implement this FFT class in my code.\nIf, yes can anyone direct me on how to do it? I guess i have to perform the fft inside the ```\nreadCsv```\n method and use the values as input once have read all the values. \n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast fourier transform for deasonalizing data in MATLAB\r\n                \r\nI'm very much a novice at signal processing techniques, but I am trying to apply the fast fourier transform to a daily time series to remove the seasonality present in the data. The example I am working with is from here: \nhttp://www.mathworks.com/help/signal/ug/frequency-domain-linear-regression.html\n\nWhile I understand how to implement the code as it is written in the example, I am having a hard time adapting it to my specific application. What I am trying to do is create a preprocessing function which deseasonalizes the training data using similar code to the above example. Then, using the same estimated coefficients from the in-sample data, deseasonalize the out-of-sample data to preserve its independence from the in-sample data. Basically, once the coefficients are estimated, I will normalize each new data point using the same coefficients. I suspect this is akin to estimating a linear trend, then removing it from the in-sample data, and then using the same linear model on unseen data to detrend it i the same manner. \n\nObviously, when I estimate the fourier coefficients, the vector I get out is equal to the length of the in-sample data. The out-of-sample data is comprised of much fewer observations, so directly applying them is impossible. \n\nIs this sort of analysis possible using this technique or am I going down a dead end road? How should I approach that using the code in the example above?\n    ", "Answer": "\r\nWhat you want to do is certainly possible, you are on the right track, but you seem to misunderstand a few points in the example. First, it is shown in the example that the technique is the equivalent of linear regression in the time domain, exploiting the FFT to perform in the frequency domain an operation with the same effect. Second, the trend that is removed is not linear, it is equal to a sum of sinusoids, which is why ```\nFFT```\n is used to identify particular frequency components in a relatively tidy way. \n\nIn your case it seems you are interested in the residuals. The initial approach is therefore to proceed as in the example as follows:\n\n(1) Perform a rough \"detrending\" by removing the DC component (the mean of the time-domain data)\n\n(2) FFT and inspect the data, choose frequency channels that contain most of the signal. \n\nYou can then use those channels to generate a trend in the time domain and subtract that from the original data to obtain the residuals. You need not proceed by using ```\nIFFT```\n, however. Instead you can explicitly sum over the cosine and sine components. You do this in a way similar to the last step of the example, which explains how to find the amplitudes via time-domain regression, but substituting the amplitudes obtained from the FFT.\n\nThe following code shows how you can do this:\n\n```\ntim = (time - time0)/timestep;  % <-- acquisition times for your *new* data, normalized\nNFpick = [2 7 13]; % <-- channels you picked to build the detrending baseline\n\n% Compute the trend\nmu = mean(ts);\ntsdft = fft(ts-mu);\nNchannels = length(ts);      % <-- size of time domain data\nMpick = 2*length(NFpick);\nX(:,1:2:Mpick) = cos(2*pi*(NFpick-1)'/Nchannels*tim)';\nX(:,2:2:Mpick) = sin(-2*pi*(NFpick-1)'/Nchannels*tim)';\n\n% Generate beta vector \"bet\" containing scaled amplitudes from the spectrum\nbet = 2*tsdft(NFpick)/Nchannels;\nbet = reshape([real(bet) imag(bet)].', numel(bet)*2,1)\ntrend = X*bet + mu;\n```\n\n\nTo remove the trend just do\n\n```\ndetrended = dat - trend; \n```\n\n\nwhere ```\ndat```\n is your new data acquired at times ```\ntim```\n. Make sure you define the time origin consistently. In addition this assumes the data is real (not complex), as in the example linked to. You'll have to examine the code to make it work for complex data.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform on .wav file gives weird results\r\n                \r\nI'm writing a frequency visualizer for .wav files. I'm using SDL to extract data from the file so i could do a Fast Fourier Transform to calculate the magnitude of each frequency.\n\nAs far as I can tell everything I give the FFT is correct, but the function is spitting weird results and I can't figure out why.\n\nWhen I don't do a windowing function before the Fourier transform I get a right result and then ~5 not right results which are close to 20000Hz and are seemingly random, so i can't predict what they were supposed to mean. I suspected this could be because of spectral leakage so i tried and ran a windowing function  before the transform but after that I get the same wrong frequency every iteration.\n\nNOTE: THIS IS WITHOUT A WINDOWING FUNCTION\n\nHere is a test when I run it with this audio https://www.youtube.com/watch?v=qNf9nzvnd1k:\n\n30 20480 20480 20470 20490 20480 20480 20470 x 20470 20480 20480 20480 20480 20480 20480 20480 20490 x 20480 20480 20480 20480 20480 20480 x x 20490 20480 20480 x x 20470 20480 x x 20480 20470 x 20480 x 20480 10 20480 20490 20480 x 20480 x 20480 20480 x 20480 x 20470 x\n\nThe x here would be the correct value which changes according to what is expected of it throughout the clip.\n\nMy problem is that I need a correct value every iteration, otherwise i get a sloppy animation.\n\nmain.cpp:\n\n```\n#include \"visualization.h\"\n#define FILE_PATH \"audiosamples/test.wav\" //https://www.youtube.com/watch?v=qNf9nzvnd1k\n#define PI 3.14159265359\n\n/*\nfreq = i * Fs / N;      (1)\nwhere,\nfreq = frequency in Hertz,\ni = index (position of DFT output or can also think of it as representing the number of cycles)\nFs = sampling rate of audio,\nN = size of FFT buffer or array.\n\nTo explain further, lets say that:\n\nN = 4096          //a buffer that holds 4096 audio data samples\nFs = 44100       //a common sample rate [frames per sec] for audio signals: 44.1 kHz\n\nThe spectral bin numbers aka frequency bins using equation (1) from above would be:\n\n    bin:      i      Fs         N            freq\n     0  :     0  *  44100 /  2048  =        0.0 Hz\n     1  :     1  *  44100 /  2048  =        21.5 Hz\n     2  :     2  *  44100 /  2048  =        43 Hz\n     3  :     3  *  44100 /  2048  =        64.5 Hz\n     4  :     ...\n     5  :     ...\n\n   1024 :    1024 * 44100 /  2048  =        22.05 kHz\n*/\n\nSDL *visualization = nullptr;\n\nUint8* sampData;\nSDL_AudioSpec wavSpec;\nSDL_AudioSpec obtained;\nUint8* wavStart;\nUint32 wavLength;\nSDL_AudioDeviceID aDevice;\ndouble arrSamples[4096];\ndouble max_magnitude_index;\n\n\nstruct AudioData {\n    Uint8* filePosition;\n    Uint32 fileLength;\n};\n\nvoid PlayAudioCallback(void* userData, Uint8* stream, int streamLength) {\n    AudioData* audio = (AudioData*)userData;\n    sampData = (Uint8*)stream;\n    double magnitude[4096];\n    fftw_complex x[4096], y[4096];\n    double max_magnitude = 0;\n\n    if (audio->fileLength == 0) {\n        return;\n    }\n\n    Uint32 length = (Uint32)streamLength;\n    length = (length > audio->fileLength ? audio->fileLength : length);\n    std::vector<double> samples (stream, stream + length);\n\n    for( int i = 0; i < 4095; i ++ ){\n        double multiplier = 0.5 * (1 - cos((2*PI*i)/4095));\n    //  x[i][REAL] = multiplier * (double)samples[i];\n        x[i][REAL] = (double)samples[i];\n        x[i][IMAG] = 0.0;\n    //  std::cout << i << \" - \" << x[i][REAL] << std::endl << std::flush;\n    }\n\n    fftw_plan plan = fftw_plan_dft_1d( 4096, x, y,  FFTW_FORWARD, FFTW_ESTIMATE );\n    fftw_execute(plan);\n\n    for( int i = 0; i < 4095; i ++ ){\n        if( y[i][IMAG] < 0 ){\n            magnitude[i] = sqrt( y[i][REAL] * y[i][REAL] + y[i][IMAG] * y[i][IMAG] );\n        }\n        else{\n            magnitude[i] = sqrt( y[i][REAL] * y[i][REAL] + y[i][IMAG] * y[i][IMAG] );\n        }\n    }\n    for( int i = 1; i < 4095; i ++ ){\n        if( magnitude[i] > max_magnitude ){\n            max_magnitude = magnitude[i];\n            max_magnitude_index = i;\n        }\n    }\n    int freq = max_magnitude_index * ( 44100 / 4096 );\n    if ( freq < 20000 ){\n        std::cout << freq << std::endl << std::flush;\n    }\n\n//  SDL_memcpy(&in, sampData, sizeof(sampData));\n    SDL_memcpy(stream, audio->filePosition, length);\n\n\n    audio->filePosition += length;\n    audio->fileLength -= length;\n\n}\n\nint main() {\n    int cnt = 0;\n\n    visualization = new SDL();\n    visualization -> init( \"asd\", 100, 0, 800, 400, false );\n    SDL_Init(SDL_INIT_AUDIO);\n\n    if (SDL_LoadWAV(FILE_PATH, &wavSpec, &wavStart, &wavLength) == NULL) {\n        std::cerr << \"Couldnt load file: \" << FILE_PATH << std::endl;\n        getchar();\n    }\n    std::cout << \"Loaded \" << FILE_PATH << std::endl;\n\n    AudioData audio;\n    audio.filePosition = wavStart;\n    audio.fileLength = wavLength;\n    wavSpec.samples = 4096;\n\n    wavSpec.callback = PlayAudioCallback;\n    wavSpec.userdata = &audio;\n\n\n    aDevice = SDL_OpenAudioDevice( NULL, 0, &wavSpec, &obtained, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE);\n    if (aDevice == 0) {\n        std::cerr << \"Audio Device connection failed: \" << SDL_GetError() << std::endl;\n        getchar();\n    }\n    SDL_PauseAudioDevice(aDevice, 0);\n\n    std::cout << obtained.samples << std::endl << std::flush;\n\n    while( visualization -> running () ){\n        visualization -> handleEvents();\n        visualization -> render();\n        cnt ++;\n        visualization -> update(max_magnitude_index, cnt);\n    }\n\n    visualization->clean();\n\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python Numpy FFT fast fourier transform - weird results\r\n                \r\nI am trying to get the phase distribution of a 2D aperture using FFT.\nThe input is a circle, where everything inside the circle has value 1, outside it has value 0.\nIn order to make a good transform, I use an input array that is 200x as large as the radius of the circle, and make a 5000x5000 grid out of it. This ensures that the circle is actually circular and there is enough room around in order that no Nyquist things happen.\n\nI need to 2D Fourier transform the aperture and then calculate the phase of the Fourier transform at every point.\nThe function I use for creating the input (aperture):\ncreating the input aperture\n\nNext do the numpy fft2 2D fourier transform:\nFourier transforming aperture\n\nAnd the result of this is a 2D complex array (as expected!), BUT with the imaginary parts so much much much smaller than the real parts (17 orders of magnitude difference imaginary parts ~10E-17).\nThis is not expected and most probably wrong. What went wrong?\n    ", "Answer": "\r\nThe FFT phase result of a perfectly symmetric input is zero, e.g. a strictly real result, thus atan2(Im,Re) == 0 , (imaginary components all zero, except for rounding noise).\n\n(even symmetry with respect to (0,0) circularly, or to (n/2,n/2))\n\nThe phase will become non-zero (thus a non-zero imaginary component in the FFT result) when the input is moved off center or otherwise made non-symmetric.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Create equally spaced data from sensor data to apply Fast Fourier Transform\r\n                \r\nI have the following sensor sample data:\n\n```\nTime(milliseconds)            Data\n------------------    -------------------\n0                     0.30865225195884705   \n60                    0.14355185627937317   \n100                  -0.16846869885921478   \n156                  -0.2458019256591797    \n198                  -0.19664153456687927\n258                   0.27148059010505676   \n305                  -0.16949564218521118   \n350                  -0.227480947971344 \n397                   0.23532353341579437   \n458                   0.20740140974521637\n```\n\n\nWhich means at time ```\n0```\n I have the value ```\n0.30865225195884705```\n and at time ```\n60```\n I have the value ```\n0.14355185627937317```\n and so on.\n\nAs it is observed, data are not equally spaced which means I have data at different time stamps. I need this because I will apply Fast Fourier Transform to this signals.\n\nAre there any methods or implementations so that I can create equally spaced data from my sensor data? (using MATLAB)\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Output Manipulation in Ruby\r\n                \r\nI am building a visual equalizer for audio and am confused what the output to my FFT is. My end goal is to send a simplified array of 6 numbers (1 bass, 4 mid-tones, and 1 treble) to an Arduino equipped with bluetooth.  The numbers will denote how many LEDs to light up in each column (1 column for bass, 1 column for treble, etc).\n\nThe first step is to change an audio signal into numerical representations.\nIn order to do that I want to combine certain frequencies into discrete buckets at regular time intervals, i.e. one for Bass that's 60 to 250 Hz.\n\nI've obtained a 300Hz wav file that I am trying to deconvolute using the ruby ```\nFFTW3```\n gem.  I would expect one sine wave that completes 300 periods over the course of a 1 second sample. When I pass in a 1s sample of a 300 Hz tone, the ```\nfft.length = 1024```\n and ```\nfft[0] = 22528```\n.  \n\nI have been using these conversations Audio Equalizer in Ruby, and Extract Fast Fourier Transform data from file as my main points of reference as the documentation for the ruby gem is confusing.\n\nHere's my code:\n\n```\nrequire \"ruby-audio\"\nrequire \"fftw3\"\nrequire \"narray\"\n\n# Audio sample rate and block size:\nSAMPLE_RATE = 44100\n# break the audio into chunks (called windows, or frames)\n# pass them sequentially to the FFT.\n# gives a frequency profile that changes over time\n# e.g. 1024, 2048, 4096, 8192, etc..\nWINDOW = 2048\n# samplerate/window => 44100/2048 = 10.7\n# Updates about 11 times/second\n# RESOLUTION = (1.0*SAMPLE_RATE/WINDOW)\n\nfilename = ARGV[0]\n\nwave = Array.new # length is window size/2\nfft = Array.new(WINDOW/2,[])\n\nbegin\n  # extracting audio from wav with ruby-audio\n  buf = RubyAudio::Buffer.float(WINDOW)\n  RubyAudio::Sound.open(filename) do |snd|\n    while snd.read(buf) != 0\n      wave.concat(buf.to_a)\n      na = NArray.to_na(buf.to_a)\n      fft_slice = FFTW3.fft(na).to_a[0, WINDOW/2]\\\n      # na = array to be transformed\n      j=0\n      fft_slice.each do |x|\n        # getting the real part of the complex number\n        x = x.abs\n        fft[j] << x; j+=1\n      end\n    end\n  end\n\nrescue => err\n    # log.error \"error reading audio file: \" + err\n    puts 'There was an error, exiting!'\n    exit\nend\n```\n\n\nAre the inner-most arrays denoting frequencies, and the outer representing time passing, or is it the other way around.  How do I know which array index represents a specific frequency? \n\nI am unsure of how to test this to see if it has accurately created the proper frequency. Is there a good way to look at the data that I've missed, visually or otherwise?\n\nThanks for any pointers!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for varying period (Order analysis)\r\n                \r\nI am trying to do a fast Fourier transformation on accelerometer data from a shaft rotating at varying speed. \n\nWhat I have done so far: \n\n1: The original plot was in the time domain, and I therefore did a order analysis (resampled), and got the following plot:\n\n\nThis plot shows the angular rotation plotted against amplitude.\n\n2: Now, an FFT was done with this code:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nclass FastFourierTransform:\n    # Amplitudes is a row vector\n    def __init__(self, amplitudes, t):\n        self.s = amplitudes\n        self.t = t\n\n    # Plotting in the input domain before fft\n    def plot_input(self):\n        plt.ylabel(\"Amplitude\")\n        plt.xlabel(\"Shaft angle [Radians]\")\n        plt.plot(self.t, self.s)\n        plt.margins(0)\n        plt.show()\n\n        '''\n        The second half of this array of fft sequence have similar frequencies\n        since the frequency is the absolute value of this value.\n        '''\n    def fft_transform(self):\n        mean_amplitude = np.mean(self.s)\n        self.s = self.s - mean_amplitude # Centering around 0\n        fft = np.fft.fft(self.s)\n\n        # We now have the fft for every timestep in out plot.\n\n        # T is the sample frequency in the data set\n        T = self.t[1] - self.t[0] # This is true when the period between each sample in the time waveform is equal\n        N = self.s.size  # size of the amplitude vector\n        f = np.linspace(0, 1 / T, N, )  # start, stop, number of. 1 / T = frequency is the bigges freq\n        plt.ylabel(\"Amplitude\")\n        plt.xlabel(\"Frequency [Hz]\")\n        y = np.abs(fft)[:N // 2] * 1 /N\n\n        # Cutting away half of the fft frequencies.\n\n        sns.lineplot(f[:N // 2], y) # N // 2 is normalizing it\n        plt.margins(0)\n        plt.show()\n        time = f[:N // 2]\n        return fft, time\n```\n\n\n3. Result, with the normalized amplitudes plotted:\n\n\nQuestions:\n\n\nDoes this thought process look correct?\nIs it correct to say that the final fft plot is in the frequency domain? From this link, http://zone.ni.com/reference/en-XX/help/372416L-01/svtconcepts/svcompfftorder/, it looks like the final plot domain should be in the order domain, but I am not sure since the fft was \ndone from the radian domain.\n\n\nVibration- Based Condition Monitoring of Wind Turbines by Tomasz Barszcz has this image \n\nThanks in advance.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Interpolation via Fast Discrete Fourier Transform with Chebyshev extreme points\r\n                \r\nI'm trying to interpolate a function at arbitrary points and I have the function values at Chebyshev extreme points. I use the real values from Fast Fourier Transform to compute the Chebyshev coefficients. Then I scale them with 2/N and then I use the polynomial library to evaluate the series of chebyshev polynomials at a set of points. This produces the wrong function approximation. Where am I going wrong?\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the number of \n# Chebyshev extreme points\nN = 10\n\n# Define the function to be \n# approximated\ndef f(x):\n   return x**2\n\n# Evaluate the function at the \n# Chebyshev extreme points\nx = np.cos(np.arange(N) * np.pi / N)\ny = f(x)\n\n# Compute the discrete Fourier \n# transform (DFT) of the function \n# values using the FFT algorithm\nDFT = np.fft.fft(y).real\n\n# Compute the correct scaling \n# factor\nscaling_factor = 2/N\n\n# Scale the DFT coefficients by \n# the correct scaling factor\nchebyshev_coefficients = scaling_factor * DFT\n\n# Use Chebval to \n# evaluate the approximated \n# polynomial at a set of points\nx_eval = np.linspace(-1, 1, 100)\ny_approx =  np.polynomial.chebyshev.chebval(x_eval, chebyshev_coefficients[::-1])\n\n# Plot the original function \n# and the approximated function\nplt.plot(x, y, 'o', \nlabel='Original function')\nplt.plot(x_eval, y_approx, '-', \nlabel='Approximated function')\nplt.legend()\nplt.show()\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "GSL Fast-Fourier Transform - Non-zero Imaginary for Transformed Gaussian?\r\n                \r\nAs an extension to this question that I asked. The Fourier transform of a real Gaussian is a real Gaussian. Now of course a DFT of a set of points that only resemble a Gaussian will not always be a perfect Gaussian, but it should certainly be close. In the code below I'm taking this [discrete] Fourier transform using GSL. Aside from the issue of the returned/transformed real components (outlined in linked question), I'm getting a weird result for the imaginary component (which should be identically zero). Granted, it's very small in magnitude, but its still weird. What is the cause for this asymmetric & funky output?\n\n```\n#include <gsl/gsl_fft_complex.h>\n#include <gsl/gsl_errno.h>\n#include <fstream>\n#include <iostream>\n#include <iomanip> \n\n#define REAL(z,i) ((z)[2*(i)]) //complex arrays stored as    [Re(z0),Im(z0),Re(z1),Im(z1),...]\n#define IMAG(z,i) ((z)[2*(i)+1])\n#define MODU(z,i) ((z)[2*(i)])*((z)[2*(i)])+((z)[2*(i)+1])*((z)[2*(i)+1])\n#define PI 3.14159265359\n\nusing namespace std;\n\nint main(){\n\n    int n = pow(2,9);\n    double data[2*n];\n    double N = (double) n;\n\n    ofstream file_out(\"out.txt\");\n\n    double xmin=-10.;\n    double xmax=10.;\n    double dx=(xmax-xmin)/N;\n    double x=xmin;\n\n    for (int i=0; i<n; ++i){\n        REAL(data,i)=exp(-100.*x*x);\n        IMAG(data,i)=0.;\n        x+=dx;\n    }\n\n    gsl_fft_complex_radix2_forward(data, 1, n); \n\n    for (int i=0; i<n; ++i){\n        file_out<<(i-n/2)<<\"    \"<<IMAG(data,((i+n/2)%n))<<'\\n';\n    }\n\n    file_out.close();\n}\n```\n\n\n\n    ", "Answer": "\r\nYour result for the imaginary part is correct and expected. \n\nThe difference to zero (10^-15) is less than accuracy that you give to pi (12 digits, pi is used in the FFT, but I'm can't know whether you are overriding the pi inside the routine). \n\nThe FFT of a real function is not in general  a real function. When you do the math analytically you integrate over the following expression: \n\n```\nf(t) e^{i w t} = f(t) cos wt  + i f(t) sin wt, \n```\n\n\nso only if the function f(t) is ```\nreal and even```\n will the imaginary part (which is otherwise odd) vanish during integration. This has little meaning though, since the real part and imaginary part have physical meaning only in special cases.\n\nDirect physical meaning is in the abs value (```\nmagnitude spectrum```\n), the abs. value squared (```\nintensity spectrum```\n) and the phase or angle (```\nphase spectrum```\n).  \n\nA more significant offset from zero in the imaginary part would happen if it wasn't centered at the center of your time vector. Try shifting the ```\nx```\n vector by some fraction of ```\ndx```\n. \n\nSee below how the shift of the input by dx/2 (right column) affects the imaginary part, but not the magnitude (example written in Python, Numpy).\n\n\n\n```\nfrom __future__ import division\nimport numpy as np\nimport matplotlib.pyplot as p\n%matplotlib inline\n\nn=512    # number of samples 2**9\nx0,x1=-10,10\ndx=(x1-x0)/n\n\nx= np.arange(-10,10,dx)  # even number, asymmetric range [-10, 10-dx]   \n\n#make signal\ns1= np.exp(-100*x**2) \ns2= np.exp(-100*(x+dx/2 )**2)\n\n#make ffts\nf1=np.fft.fftshift(np.fft.fft(s1))\nf2=np.fft.fftshift(np.fft.fft(s2))\n\n#plots\np.figure(figsize=(16,12))\np.subplot(421)\np.title('gaussian (just ctr shown)')\np.plot(s1[250:262])\np.subplot(422)\np.title('same, shifted by dx/2')\np.plot(s2[250:262])\n\np.subplot(423)\np.plot(np.imag(f1))\np.title('imaginary part of FFT')\np.subplot(424)\np.plot(np.imag(f2))\n\np.subplot(425)\np.plot(np.real(f1))\np.title('real part of FFT')\np.subplot(426)\np.plot(np.real(f2))\n\np.subplot(427)\np.plot(np.abs(f1))\np.title('abs. value of FFT')\np.subplot(428)\np.plot(np.abs(f2))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier cosine transform for poisson equation with all zero Neumann boundary condition\r\n                \r\nI am trying to solve Poisson equation in rectangular domain by using Fast Fourier Cosine transform with FFTW3 library.\n\nThe boundary condition of four sides is zero Neumann boundary condition.\n\n\nThe equation ```\nd^u/dx^2+d^2u/dy^2=-f```\n\nwith ```\nf=cos(x)+cos(y)```\n, domain ```\n[-pi pi,-pi pi]```\n\nexact solution is ```\nu=f```\n.\nfunction ```\nf```\n satisfy Neumann boundary condition.\nDrive the equation by using Fourier transform, we have:\n```\nU=F/(lamda(i)+lamda(j))```\n\nhere ```\nlamda(k)=2*(1-cos(i/(n0-1)))```\n\nand ```\nU```\n is invert transformed to get small ```\nu```\n.\n\n\nHowever, i still get wrong result compared with exact solution.\n\nCould you please help me? Thank you so much.\n\nHere is my code\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fftw3.h>\n#include <iostream>\n\nusing namespace std;\nint main() {\n\n    int n0=64;\n    int n1=64;\n\n    int N=n0*n1;\n\n    double pi = 3.14159265359;\n    double L  = 2.*pi;\n   double dx = L/(n0);\n\n    double *in1=new double [N];\n    double *in2=new double [N];\n    double *out1=new double [N];\n    double *out2=new double [N];\n    double *X=new double [N];\n    double *Y=new double [N];\n\n\n    fftw_plan p, q;\n    int i,j;\n    p = fftw_plan_r2r_2d(n0,n1, in1, out1, FFTW_REDFT00, FFTW_REDFT00, FFTW_ESTIMATE);\n    q = fftw_plan_r2r_2d(n0,n1, in2, out2, FFTW_REDFT00, FFTW_REDFT00, FFTW_ESTIMATE);\n\n    for(i = 0;i <n0;i++){\n        X[i] =-pi+i*dx ;\n        for(j = 0;j<n1;j++){\n            Y[j] = -pi+j*dx ;\n            in1[i*n0 + j]= cos(X[i]) + cos(Y[j]) ; // row major ordering\n        }\n    }\n\n    fftw_execute(p);\n\n    double *lamda=new double [n0];\n\n    for (i=0;i<n0;i++){\n        lamda[i]=cos(pi*i/(n0-1));\n    }\n\n    for ( i= 0; i< n0; i++){   // f = g / ( lamda(ii)+lamda(jj) )  \n        for( j = 0; j < n1; j++){\n\n            double fact=0;\n            in2[i*n0 + j]=0;\n\n            fact=2*(2-lamda[i]-lamda[j]);\n\n            if(fact!=0){\n                in2[i*n0 + j] = out1[i*n0 + j]/fact;\n            }else{\n                in2[i*n0 + j] =0;\n            }\n\n        }\n    }\n\n    fftw_execute(q);\n\n    double erl1 = 0.;\n    for ( i = 0; i < n0; i++) {\n        for( j = 0; j < n1; j++){\n\n            cout<< i <<\" \"<< j<<\" \"<< cos(X[i])+cos(Y[j])<<\" \"<<  dx*dx*out2[i*n0+j]/(2.*(double)(n0-1))/(2.0*(double)(n1-1)) <<\" \"<< endl; \n\n        }\n    }\n\n    fftw_destroy_plan(p); fftw_destroy_plan(q); fftw_cleanup();\n    delete [] in1;\n    delete [] in2;\n    delete [] out1;\n    delete [] out2;\n    delete [] X;\n    delete [] Y;\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform and Clustering of Time Series\r\n                \r\nI'm making a project connected with identifying dynamic of sales. That's how the piece of my database looks like http://imagizer.imageshack.us/a/img854/1958/zlco.jpg. There are three columns:\n\nProduct - present the group of product \n\nWeek - time since launch the product (week), first 26 weeks \n\nSales_gain - how the sales of product change by week\n\nIn the database there is 3302 observations = 127 time series\n\nMy aim is to cluster time series in groups which are going to show me different dynamic of sales. Before clustering I want to use Fast Fourier Transform to change time series on vectors and take into consideration amplitude etc and then use a distance algorithm and group products. \n\nIt's my first time I deal with FFT and clustering, so I would be grateful if anybody would point steps, which I have to do before/after using FFT to group dynamics of sales. I want to do all steps in R, so it would be wonderful if somebody type which procedures should I use to do all steps.\n\nThat's how my time series look like now http://imageshack.com/a/img703/6726/sru7.jpg \n\nPlease note that I am relatively new to time series analysis (that's why I cannot put here my code) so any clarity you could provide in R or any package you could recommend that would accomplish this task efficiently would be appreciated.\n\nP.S. Instead of FFT I found the code for DWT here -> www.rdatamining.com/examples/time-series-clustering-classification but cannot use it on my data base and time series (suggest R to analyze new time series after 26 weeks). Can sb explain it to me?\n    ", "Answer": "\r\nYou may have too little data for FFT/DWT to make sense. DTW may be better, but I also don't think it makes sense for sales data - why would there be a x-week temporal offset from one location to another? It's not as if the data were captured at unknown starting weeks.\n\nFFT and DWT are good when your data will have interesting repetitive patterns, and you have A) a good temporal resolution (for audio data, e.g. 16000 Hz - I am talking about thousands of data points!) and B) you have no idea of what frequencies to expect. If you know e.g. you will have weekly patterns (e.g. no sales on sundays) then you should filter them with other algorithms instead.\n\nDTW (dynamic time-warping) is good when you don't know when the event starts and how they align. Say you are capturing heart measurements. You cannot expect to have the hearts of two subjects to beat in synchronization. DTW will try to align this data, and may (or may not) succeed in matching e.g. an anomaly in the heart beat of two subjects. In theory...\n\nMaybe you don't need specialized time methods here at all.\n\nA) your data has too low temporal resolution\n\nB) your data is already perfectly aligned\n\nMaybe all you need is spend more time in preprocessing your data, in particular normalization, to be able to capture similarity.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in Python\r\n                \r\nI am new to the fourier theory and I've seen very good tutorials on how to apply fft to a signal and plot it in order to see the frequencies it contains. Somehow, all of them create a mix of sines as their data and i am having trouble adapting it to my real problem. \n\nI have 242 hourly observations with a daily periodicity, meaning that my period is 24. So I expect to have a peak around 24 on my fft plot.\n\nA sample of my data.csv is here:\nhttps://pastebin.com/1srKFpJQ\n\nData plotted:\n\n\n\nMy code:\n\n```\ndata = pd.read_csv('data.csv',index_col=0)\ndata.index = pd.to_datetime(data.index)\ndata = data['max_open_files'].astype(float).values\n\nN = data.shape[0] #number of elements\nt = np.linspace(0, N * 3600, N) #converting hours to seconds\ns = data\n\nfft = np.fft.fft(s)\nT = t[1] - t[0]\n\nf = np.linspace(0, 1 / T, N)\nplt.ylabel(\"Amplitude\")\nplt.xlabel(\"Frequency [Hz]\")\nplt.bar(f[:N // 2], np.abs(fft)[:N // 2] * 1 / N, width=1.5)  # 1 / N is a normalization factor\nplt.show()\n\n```\n\n\nThis outputs a very weird result where it seems I am getting the same value for every frequency.\n\n\n\nI suppose that the problems comes with the definition of N, t and T but I cannot find anything online that has helped me understand this clearly. Please help :)\n\nEDIT1:\n\nWith the code provided by charles answer I have a spike around 0 that seems very weird. I have used ```\nrfft```\n and ```\nrfftfreq```\n instead to avoid having too much frequencies.\n\n\n\nI have read that this might be because of the DC component of the series, so after substracting the mean i get:\n\n\n\nI am having trouble interpreting this, the spikes seem to happen periodically but the values in Hz don't let me obtain my 24 value (the overall frequency). Anybody knows how to interpret this ? What am I missing ?\n    ", "Answer": "\r\nThe problem you're seeing is because the bars are too wide, and you're only seeing one bar. You will have to change the width of the bars to 0.00001 or smaller to see them show up.\n\nInstead of using a bar chart, make your x axis using ```\nfftfreq = np.fft.fftfreq(len(s))```\n and then use the plot function, ```\nplt.plot(fftfreq, fft)```\n:\n\n```\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\ndata = pd.read_csv('data.csv',index_col=0)\ndata.index = pd.to_datetime(data.index)\ndata = data['max_open_files'].astype(float).values\n\nN = data.shape[0] #number of elements\nt = np.linspace(0, N * 3600, N) #converting hours to seconds\ns = data\n\nfft = np.fft.fft(s)\nfftfreq = np.fft.fftfreq(len(s))\n\nT = t[1] - t[0]\n\nf = np.linspace(0, 1 / T, N)\nplt.ylabel(\"Amplitude\")\nplt.xlabel(\"Frequency [Hz]\")\nplt.plot(fftfreq,fft)\nplt.show()\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "python scipy.fft huge y scale of Fast Fourier Transform\r\n                \r\nI have a working python script for Fast Fourier Transform (fft) signal which plots the graph and fft correctly, I am fetching data from postgre so I ommited that code.\nAnd due to limit of paste i pasted shorter version of signal, but the signal is preatty much the similar on longer timeframe.\nThe x scale of fft is fine, but what i get is a large y scale which i do not understand.\nI have an fft processed by machine directly that looks correct and i have another measurement done by hand held machine. The ffts look almost identical on x scale and relative sizes on y scale, but the actual calculated y scale differ a lot.\ndata\nplot from python\nfrom device\nIn script data_step is in micro second between two timestamps.\nThe n and datastep cant be wrong since the x axis is fine.\nFrom the data i get:\n```\nMin of signal(value_points_sensor1): -0.057881687\n\nMax of signal: 0.07810274\n\nMax of fft y: 5522.93\n```\n\nShouldnt the  size  of fft be similar to size of amplitude of signal? Also arent the unit of amplitude on fft and signal on y axis the same?\n```\nimport matplotlib.pyplot as plt\nfrom scipy.fft import rfft, rfftfreq, irfft\nimport numpy as np\n\nfigure, axis = plt.subplots(2, 1)\nplt.subplots_adjust(hspace=1)\n    \ntime_points_sensor1 = np.array(row[4])\nvalue_points_sensor1 = np.array(row[3])\n    \naxis[0].plot(time_points_sensor1, value_points_sensor1)\n\n   \nn  = len(row[2])\ndata_step = (abs((int(row[2][-2] - row[2][-1]))) / 1000000)\n\nyf = rfft(value_points_sensor1)\nxf = rfftfreq(n,data_step)\n\naxis[1].plot(xf,abs(yf))\n    \nplt.show()\n```\n\n    ", "Answer": "\r\nThe value of rfft is proportional both to the magnitude of the data and the number of points.  So you should expect the values in ```\nyf```\n to be large.\nCompare:\n```\n# One cycle of a cosine curve\nx = rfft(np.cos(np.linspace(0, 2 * np.pi, 1000)))\nmax(abs(x))\n500.2493021844711\n\n# Two cycles of a cosine curve, again 1000 points per cycle\nx = rfft(np.cos(np.linspace(0, 4 * np.pi, 2000)))\nmax(abs(x))\n1000.2484171710441\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "correct ordering of array for numpy fast Fourier transform\r\n                \r\nI am trying to implement a simple version of the immersed boundary method for fluid-structure interactions in a periodic domain using the fast Fourier transform. This is done by first setting a force on the fluid, taking its FFT, solving a series of matrix equations, and taking the inverse FFT to recover the solution to the matrix system in the real domain. I am currently getting very strange results, and I think it might be because the solutions in Fourier space (u_hat, v_hat, p_hat) are not ordered correctly for the numpy ifft2 function, but I don't know how to fix that. I'd appreciate any help!\nEdit: the idea is that given f, g, we want to find u, v, p. The algorithm is to take the fft in 2D of f and g, use that to compute the fft of u, v, and p, and then take the inverse fft to recover the real u, v, p. I've added the specific function relating f_hat, g_hat and u_hat, v_hat, p_hat.\nEdit2: what I'd really like to know is how to order an arbitrary array so that it can be passed to the numpy ifft2 function, which requires the following: input should have the term for zero frequency in the low-order corner of the two axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of both axes, in order of decreasingly negative frequency.\n```\n   N = 20   # Number of cartesian grid points\n   l = 1.0     # Length of domain\n   dx = l / N     # Grid step size\n   mu = 8.9 * 10**(-4) \n\n   f_hat = np.fft.fft2(f)    # Fourier transform of x component of the force\n   g_hat = np.fft.fft2(g)    # Fourier transform of y component of the force \n\n   u_hat = np.zeros((N, N), dtype=np.complex)\n   v_hat = np.zeros((N, N), dtype=np.complex)\n   p_hat = np.zeros((N, N), dtype=np.complex)\n   \n   for k in range(0, N):\n       for m in range(0, N):\n           if k == 0 and m == 0:\n               u_hat[k,m] = 0.0\n               v_hat[k,m] = 0.0 \n               p_hat[k,m] = 0.0\n           else:\n               u_hat[k,m], v_hat[k,m], p_hat[k,m] = fluid_system(k, m, N, dx, mu, f_hat[k,m], g_hat[k,m])\n   \n   # Take inverse Fourier transform to get u and p  \n   u = np.real((np.fft.ifft2(u_hat))).reshape((len(x),1))\n   v = np.real((np.fft.ifft2(v_hat))).reshape((len(x),1))\n   p = np.real(np.fft.ifft2(p_hat))\n\ndef fluid_system(l, m, N, h, mu, fft_f, fft_g):\n   L = - 4.0 / (h**2) * ((np.sin(np.pi * l / N))**2 + (np.sin(np.pi * m / N))**2)\n   D_l = - 1j / h * np.sin(2.0 * np.pi * l / N)\n   D_m = - 1j / h * np.sin(2.0 * np.pi * m / N)\n   A = np.zeros((3,3), dtype=np.complex)\n   A[0,0] = mu * L\n   A[0,2] = - D_l\n   A[1,1] = mu * L\n   A[1,2] = - D_m\n   A[2,0] = D_l\n   A[2,1] = D_m\n   b = np.zeros((3,1), dtype=np.complex)\n   b[0] = fft_f\n   b[1] = fft_g\n   res = (np.linalg.solve(A, b)).ravel()\n   return res \n\n\n\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to get pitches from a wav buffer in JAVA - Fast Fourier Transform\r\n                \r\nI am new to signal processing and am trying to detect the pitches in a wav file. I generated a 2-channel wav file that plays 3 distinct notes in 1 second. I was able to read the wave using a class a java and have a double array: \n\n```\n-0.12847900390625\n-0.161651611328125\n-0.161651611328125\n-0.1907958984375\n-0.1907958984375\n-0.215179443359375\n-0.215179443359375\n       .\n       .\n       .\n```\n\n\nI was to get the notes that are being played in the double array. I have googled around and believe a Fast Fourier Transform is the way to go. However, I am a bit unsure what this Transformation does. \n\nDoes FFT return the frequency at a given time period? \n\nAny help is appreciated. Thankyou \n    ", "Answer": "\r\nThe Discrete Fourier Transform is used to map any discrete time-domain signal into frequency domain to reduce computation while performing operations like  convolution, co-relation etc since it is easier to compute in frequency domain and take the inverse transform and convert back into time domain compared to direct operation in time domain.\nFFT is the simpler algorithmic implementation of DFT with reduced time complexity of  ```\nO(nlogn)```\ncompared to time complexity of DFT ```\nO(n^2)```\n.\n\nYou can find more details here:\n\nhttp://www.dspguide.com/ch12/2.htm\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Picking up high frequency in fast fourier transform and inverse fourier transforms\r\n                \r\nGiven a function f(t) and its second derivative, ddf(t)==g(t), I am interested in how their Fourier transforms relate. Mathematically speaking, noting F(w) and G(w) the transforms of f(t) and g(t) respectively, we should have\nG(w) = -w^2F(w)\nI wanted to investigate this numerically in Python and I am hitting the common roadblocks that I never completely understood in the Gibbs effect, and ringing effects when handling discrete fourier transforms. Below is the mwe python code snippet I was working with.\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, ifft\nt=np.linspace(-5,5,100)\ndt=t[1]-t[0]\nw=fftfreq(len(t),dt)\na=3.0\n\n#some sigmoid function\nf=1/(1+np.exp(-a*t))\nplt.plot(f)\nFw=fft(f) #its fourier transform\n\nplt.plot(np.real(4*np.pi*np.pi*ifft(-Fw*w*w))) #The ifft/fft way of computing the     second derivative\nplt.plot(np.gradient(np.gradient(f))/dt**2) #the finite difference way of computing     the second derivative\n\nplt.ylim(-2,2)\nplt.legend(['f(t)',r'ifft(fft(-$\\omega^2$F[$\\omega$]))]','ddf(t)'], fontsize=15)\n```\n\nThis is the result of this code snippet\nComputing the second derivative as the inverse transform of -F[w]*w^2 should in principle yield the second derivative of f(t). But I am picking up extremely large weights at either end of my time scale, and there is a high frequency ringing on top of my signal.\nI am aware this might originate from rounding issues in frequency space or improperly binned frequencies, but I do not know how to correct these issues and do not fully understand them. The results do not depend on how fine-grained the time axis is.\nAny help appreciated\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "GSL Fast-Fourier Transform - Double-Valued Gaussian?\r\n                \r\nAll I want to do is evaluate the Fourier transform of a Gaussian (as a test of course), but I'm getting what looks like a double-valued function, as can be seen in the plot below. When you look closely at the tails of the Gaussian, you can see that the FFT returned values are actually oscillating between positive and negative, making the DFT look \"double-valued\". Why is this happening? Is there a way to fix this (without just plotting the complex modulus of course)?\n\n```\n#include <gsl/gsl_fft_complex.h>\n#include <gsl/gsl_errno.h>\n#include <fstream>\n#include <iostream>\n#include <iomanip> \n\n#define REAL(z,i) ((z)[2*(i)]) //complex arrays stored as    [Re(z0),Im(z0),Re(z1),Im(z1),...]\n#define IMAG(z,i) ((z)[2*(i)+1])\n#define MODU(z,i) ((z)[2*(i)])*((z)[2*(i)])+((z)[2*(i)+1])*((z)[2*(i)+1])\n#define PI 3.14159265359\n\nusing namespace std;\n\nint main(){\n\n    int n = pow(2,9);\n    double data[2*n];\n    double N = (double) n;\n\n    ofstream file_out(\"out.txt\");\n\n    double xmin=-10.;\n    double xmax=10.;\n    double dx=(xmax-xmin)/N;\n    double x=xmin;\n\n    for (int i=0; i<n; ++i){\n        REAL(data,i)=exp(-100.*x*x);\n        IMAG(data,i)=0.;\n        x+=dx;\n    }\n\n    gsl_fft_complex_radix2_forward(data, 1, n); \n\n    for (int i=0; i<n; ++i){\n        file_out<<(i-n/2)<<\"    \"<<REAL(data,((i+n/2)%n))<<'\\n';\n    }\n\n    file_out.close();\n}\n```\n\n\n\n    ", "Answer": "\r\nYou are plotting just the real component, e.g. the even or cosine component.  Note that a cosine wave of integer frequency N toggles between being -1 in the middle and to being 1 in the middle, as N increases from an odd number to an even number.  Thus any noise in the middle of the input to a DFT window can cause various real components in the DFT result to toggle (unless that noise is exactly orthogonal to all those DFT basis vectors) .\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "OpenCV / C++ - Convert image to vector of doubles for FFT (Fast Fourier Transform)\r\n                \r\nI'm trying to compute the FFT (Fast Fourier Transform) of an image to use the frequencies to determine whether or not the image is blurry.\n\nI need to use a custom FFT algorithm that we already have in our codebase. The FFT algorithm requires a standard 1D vector of ```\ndoubles```\n or ```\nints```\n. I need a way to read in an image and then convert it to a vector of doubles so that I can compute the FFT of the image. \n\nI have tried the following:\n\n```\ncv::Mat inputImage = cv::imread(\"testImage.png\");\ncv::Mat fImage; \n\ninputImage.convertTo(fImage, CV_32F); \nstd::vector<double> actualImage = fImage.clone();\n```\n\n\nHowever, I am getting the error:\n\n\n  \n    OpenCV Error: Assertion failed (channels() == CV_MAT_CN(dtype)) in copyTo,\n  \n\n\nAny ideas to how I can achieve this? \n    ", "Answer": "\r\n```\nCV_32F```\n means ```\nfloat```\n, not ```\ndouble```\n. You should use ```\nCV_64F```\n instead.\n\nYou also need to specify the number of channels. This example is for 1 channel image (grayscale), and probably what you need:\n\n```\n// Load the image\ncv::Mat inputImage = cv::imread(\"testImage.png\");\n// Convert to single channel (grayscale)\ncv::cvtColor(inputImage, inputImage, cv::COLOR_BGR2GRAY);\n\n// Or directly load as grayscale    \n// cv::Mat inputImage = cv::imread(\"testImage.png\", cv::IMREAD_GRAYSCALE);\n\n// Convert to double\ncv::Mat fImage; \ninputImage.convertTo(fImage, CV_64F); \n\n// Initialize the vector with the image content\nstd::vector<double> actualImage(fImage.begin<double>(), fImage.end<double>());\n```\n\n\nFor 3 channels you can do:\n\n```\ncv::Mat inputImage = cv::imread(\"testImage.png\");\ncv::Mat fImage; \n\ninputImage.convertTo(fImage, CV_64F); \nfImage = fImage.reshape(1); // You need to reshape to single channel\nstd::vector<double> actualImage(fImage.begin<double>(), fImage.end<double>());\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how to execute a fast fourier transform in a loss function for neural network training\r\n                \r\nI'm currently working on a fully convolutional neural network (image in, image out) and i'm trying to implement a loss function that does the fast fourier transform of the 2 images before doing some operation on them, the code is like this\n```\ndef fourierLoss2(y_actual,y_pred):\n  actual_fft = tf.signal.rfft3d(y_actual)\n  pred_fft = tf.signal.rfft3d(y_pred)\n  lossV=tf.math.real(tf.math.reduce_mean(tf.math.square(actual_fft-pred_fft)))\n  return lossV\n\nwith strategy.scope():\n  model = hd_unet_model(INPUT_SIZE)\n  model.compile(optimizer=Adam(lr=0.1),\n                loss= fourierLoss2,\n                metrics=tf.keras.metrics.MeanSquaredError())\n```\n\nthe 2 tensors (y_actual,y_pred) have type float.\nbut if i try to train the model i get the following error\n```\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:806 train_function  *\n        return step_function(self, iterator)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:796 step_function  **\n        outputs = model.distribute_strategy.run(run_step, args=(data,))\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/distribute_lib.py:1211 run\n        return self._extended.call_for_each_replica(fn, args=args, kwargs=kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/distribute_lib.py:2585 call_for_each_replica\n        return self._call_for_each_replica(fn, args, kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/mirrored_strategy.py:585 _call_for_each_replica\n        self._container_strategy(), fn, args, kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/mirrored_run.py:96 call_for_each_replica\n        return _call_for_each_replica(strategy, fn, args, kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/mirrored_run.py:237 _call_for_each_replica\n        coord.join(threads)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/training/coordinator.py:389 join\n        six.reraise(*self._exc_info_to_raise)\n    /usr/local/lib/python3.6/dist-packages/six.py:703 reraise\n        raise value\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/training/coordinator.py:297 stop_on_exception\n        yield\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/distribute/mirrored_run.py:323 run\n        self.main_result = self.main_fn(*self.main_args, **self.main_kwargs)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:789 run_step  **\n        outputs = model.train_step(data)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:757 train_step\n        self.trainable_variables)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/engine/training.py:2722 _minimize\n        gradients = tape.gradient(loss, trainable_variables)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/eager/backprop.py:1073 gradient\n        unconnected_gradients=unconnected_gradients)\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/eager/imperative_grad.py:77 imperative_grad\n        compat.as_str(unconnected_gradients.value))\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/eager/backprop.py:151 _gradient_function\n        grad_fn = ops._gradient_registry.lookup(op_name)  # pylint: disable=protected-access\n    /usr/local/lib/python3.6/dist-packages/tensorflow/python/framework/registry.py:97 lookup\n        \"%s registry has no entry for: %s\" % (self._name, name))\n\n    LookupError: gradient registry has no entry for: RFFT3D\n```\n\nAfter some research i understood that the problem is that the operation tf.signal.rfft3d does not have a registered gradient function.\nDoes anybody know a way to get around this problem?\n    ", "Answer": "\r\nI have found out a solution to the problem, instead of using ```\ntf.signal.rfft3d```\n i had to use ```\ntf.signal.fft3d```\n, this function has an entry for the gradient and works in a loss function, the downside is that now i had to convert the float tensors to complex type before the fourier trasform\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in processing of an input signal from Arduino\r\n                \r\nI have been trying to get audio signal from an arduino microphone. First I setup my arduino in Free Running Mode, and then I wait for a message from Processing that is a capital A. When Processing sends the serial signal, my arduino should send back 16 audio amplitude samples. Then, processing should take those 16 audio samples and pass them by the Fast Fourier Transform in orden to get a real time frequency spectrum. However, it seems that my Arduino never detects the capital A, and also, if I try to send the samples from my Arduino without waiting for the capital A, when Processing gets the samples it seems something went wrong with the serial communication. I tried with many arduinos and different serial cables to be sure it was no the problem. Here you are the arduino code: \n\n```\n// Arrays to save our results in\n\nint values[16];\n\n\n// Define various ADC prescaler\nconst unsigned char PS_16 = (1 << ADPS2);\nconst unsigned char PS_32 = (1 << ADPS2) | (1 << ADPS0);\nconst unsigned char PS_64 = (1 << ADPS2) | (1 << ADPS1);\nconst unsigned char PS_128 = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);\n\n// Setup the serial port and pin 2\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(2, INPUT);\n\n  // set up the ADC\n  ADCSRA &= ~PS_128;  // remove bits set by Arduino library\n\n  // you can choose a prescaler from above.\n  // PS_16, PS_32, PS_64 or PS_128\n  ADCSRA |= PS_64;    // set our own prescaler to 64 \n\n}\n\n\nvoid loop() {  \n  unsigned int i;\n\n  for(i=0;i<16;i++) {\n      values[i] = analogRead(2);\n\n  }\n\n  if(Serial.available() > 0) {\n\n    char c = Serial.read();\n    if(c == 'A') { \n      for(i=0;i<16;i++) {\n        Serial.println(values[i]);\n      }\n    }\n  }\n  delay(10);\n}\n```\n\n\nHere you are the processing code: \n\n```\nimport processing.serial.*;\nimport ddf.minim.analysis.*;\nFFT fft;\n\nSerial myPort;  // Create object from Serial class\n\nvoid setup() \n{\n\n  String portName = Serial.list()[0];\n  myPort = new Serial(this, portName, 115200);\n  size(800, 600);\n  background(255);\n  fft = new FFT(16, 16000);\n\n\n}\n\n\nString mensaje;\n\nfloat[] magnitudes = new float[16];\nint contador = 0;\nbyte request = true;\nvoid draw()\n{\n\n  if(request) {\n     myPort.write('A');//Solicita nuevos datos.\n     request = false;\n  } \n  while(!request) { \n    if(myPort.available()>0) {\n       mensaje = myPort.readStringUntil(13);\n       print(\" mensaje: \"+mensaje);\n       if(mensaje != null){\n         magnitudes[contador++] = int(mensaje);\n       }\n    }\n    if(contador >= 15) {\n      contador=0;\n      fft.forward(magnitudes);\n      request = true; \n      fill(100);\n      rect(0,0,800,800);\n      for (int i = 0; i < 15; i++) { \n         fill(200);\n         rect(i*30+10, 0, 10, fft.getBand(i) * 0.1);\n      }\n    }\n  }\n}\n```\n\n\nThank you a lot for your attention!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform(FFT) - problem with fourier resolution\r\n                \r\nI have been working quite a bit with fourier transforms in python the last couple of days.\nI have discovered that in order to accurately capture known periods of incoming data, the resolution or spacing of the x-axis (1/n_samples) has to be sufficiently small. Typically this is done by zero-padding the incoming data. (I have also tried windowing, but with no additional effect)\nI have an issue related to this: I have specified that i have a period of 128 in a dataseries of 500. I.e. a frequency of 0.0078125. In order to find the correct peak at 0.0078125 in my fft, i need a resolution that is <<0.0078125, which I have made sure of. I am however missing my peak of 0.0078125 by quite a bit. And in the period-axis, the result is even more obvious. Is there anyone who can help me understand why?\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Flat lines in Fast Fourier Transform using numpy\r\n                \r\nI have data of 500 years with data point for every year.\nThe data in numpy array is here\n\nLooking at the data there is a clear signal of 100 years, however, when I'm doing the Fourier transform I get two flat lines in the plot which I can't understand why they are there.\n\nThe plot looks like that:\n\n\n\nThe code I'm using is:\n\n```\nimport numpy as np\nfrom scipy.fftpack import fft, rfft, fftfreq\nimport pylab as plt\n\nsig = np.load('fft.npy')\nsig = sig.squeeze()/(80*60) # Grid scaling\nx = np.arange(1,501,1)\n\nW = fftfreq(sig.size, d=(x[1]-x[0]))\n\nplt.figure(figsize=(7,3.5))\nplt.subplot(2,1,1)\nplt.plot(x,sig)\nplt.xlabel('Time (years)')\n\nf_sig = fft(sig)\nplt.subplot(2,1,2)\nplt.plot(W, abs(f_sig)**2)\nplt.xlabel('Frequency (1/year)')\n\nplt.xscale('log')\nplt.yscale('log')\nplt.xlim(10**(-3), 1)\nplt.show()\n```\n\n\nWhy there are two flat lines on the frequency plot? Why don't I see clearly the 100 yr frequency?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to apply data parallelim on haskell Fast Fourier Transformation?\r\n                \r\nI have a haskell code to resolve a Fast Fourier Transformation, and i want to apply data parallelism on it. However, every strategy that i use generate too many sparks and most of them are being overflowed.\n\nDoes anyone have any idea on how to apply a good data parallelism strategy on the following algorithm:\n\n```\n-- radix 2 Cooley-Tukey FFT\n\nfft::[Complex Float] -> [Complex Float]\nfft [a] = [a]\nfft as = interleave ls rs\n  where\n    (cs,ds) = bflyS as\n    ls = fft cs\n    rs = fft ds\n\ninterleave [] bs = bs\ninterleave (a:as) bs = a : interleave bs as\n\nbflyS :: [Complex Float] -> ([Complex Float], [Complex Float])\nbflyS as = (los,rts)\n  where\n    (ls,rs) = halve as\n    los = zipWith (+) ls rs\n    ros = zipWith (-) ls rs\n    rts = zipWith (*) ros [tw (length as) i | i <- [0..(length ros) - 1]]\n\nhalve as = splitAt n' as\n  where\n    n' = div (length as + 1) 2\n\n-- twiddle factors\ntw :: Int -> Int -> Complex Float\ntw n k = cis (-2 * pi * fromIntegral k / fromIntegral n)\n```\n\n\nPAR MONAD\n\nThe answer from leftaroundabout helped me a lot about understanging on how to apply data parallelism on the code. However, i have studied the par monad and tried to apply task parallelism to it. The problem is that it is running way slower than the original bflyS. I think the code i developed is way to expensive to create threads comparing to the relative work I am doing. Does anyone know how to use the par monad in a better way ?\n\n```\n--New Task Parallelism bflyS\n\nbflySTask :: [Complex Float] -> ([Complex Float], [Complex Float])\nbflySTask as = runPar $ do\n    let (ls, rs) = halve as\n    v1<-new\n    v2<-new\n    let ros = DATA.zipWith (-) ls rs\n    let aux = DATA.map  (tw n) [0..n-1]\n    fork $ put v1 (DATA.zipWith (+) ls rs)\n    fork $ put v2 (DATA.zipWith (*) ros aux)\n    los <- get v1\n    rts <- get v2   \n    return (los, rts)\n        where\n                n = DATA.length as\n```\n\n    ", "Answer": "\r\nFirst off: there's a lot of optimisation to be done here before I'd start to think about parallelism:\n\n\nLists rock, but their non-consecutive memory model means they just can't allow for traversals nearly as fast as what you can achieve with tight arrays such as ```\nData.Vector```\n, because you inevitably end up with lots of cache misses. Indeed I've seldom seen a list-based algorithm to gain much from parallelisation, because they're bound by memory- rather than CPU performance.\nYour twiddle factors are computed over and over again, you can obviously gain a lot through memoisation here.\nYou keep on calling ```\nlength```\n, but that's an extremely wasteful function (O (n) for something that could be O (1)). Use some container that probably handles length; lists aren't meant to (we like to keep their ability to be infinite).\n\n\nThe parallelisation itself will be pretty simple; I'd check on the length as suggested by John L, indeed I'd rather require a pretty large size before sparking a thread, at least something like 256: as the performance probably becomes crucial only at sizes of several thousands, this should sill be enough threads to keep your cores busy.\n\n```\nimport Data.Vector.Unboxed as UBV\nimport Control.Parallel.Strategies\n\ntype ℂ = Complex Float\n\nfft' :: UBV.Vector ℂ -> UBV.Vector ℂ\nfft' aₓs = interleave lᵥs rᵥs\n where (lᵥs, rᵥs) = (fft lₓs, fft rₓs)\n                     `using` if UBV.length aₓs > 256 then parTuple2 else r0\n       (lₓs, rₓs) = byflyS aₓs\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "scipy Fast fourier transform doesn't recognize the signal\r\n                \r\ni'm trying to get the frequency of a signal via fourier transform but it's not able to recognize it (sets the peak to f=0). Maybe something is wrong in my code (FULL reprudible code at the end of the page):\n```\nPF = fft.fft(Y[0,:])/Npoints #/Npoints to get the true amplitudes\nZF = fft.fft(Y[1,:])/Npoints\nfreq = fft.fftfreq(Npoints,deltaT)\nPF = fft.fftshift(PF) #change of ordering so that the frequencies are increasing\nZF = fft.fftshift(ZF)\nfreq = fft.fftshift(freq)\nplt.plot(freq, np.abs(PF))\nplt.show()\nplt.plot(T,Y[0,:])\nplt.show()\n```\n\nwhere Npoints is the number of intervals (points) and deltaT is the time spacing of the intervals. You can see that the peak is at f=0\n\nI show also a plot of Y[0,:] (my signal) over time where it's clear that the signal has a characteristic frequency\n\nFULL REPRUDICIBLE CODE\n```\nimport numpy as np \nimport matplotlib.pyplot as plt\n#numerical integration\nfrom scipy.integrate import solve_ivp\nimport scipy.fft as fft\n\nr=0.5\ng=0.4\ne=0.6\nH=0.6\nm=0.15\n#define a vector of K between 0 and 4 with 50 componets\nK=np.arange(0.1,4,0.4)\n\ntsteps=np.arange(7200,10000,5)\nNpoints=len(tsteps)\ndeltaT=2800/Npoints #sample spacing\nfor k in K :\n    i=0\n    def RmAmodel(t,y):\n        return [r*y[0]*(1-y[0]/k)-g*y[0]/(y[0]+H)*y[1], e*g*y[0]/(y[1]+H)*y[1]-m*y[1]]\n\n    sol = solve_ivp(RmAmodel, [0,10000], [3,3], t_eval=tsteps) #t_eval specify the points where the solution is desired\n    T=sol.t\n    Y=sol.y\n    vk=[]\n    for i in range(Npoints):\n        vk.append(k)\n    XYZ=[vk,Y[0,:],Y[1,:]]\n    #check periodicity over P and Z with fourier transform\n\n    \n    \n#try Fourier analysis just for the last value of K        \n    PF = fft.fft(Y[0,:])/Npoints #/Npoints to get the true amplitudes\n    ZF = fft.fft(Y[1,:])/Npoints\n    freq = fft.fftfreq(Npoints,deltaT)\n    PF = fft.fftshift(PF) #change of ordering so that the frequencies are increasing\n    ZF = fft.fftshift(ZF)\n    freq = fft.fftshift(freq)\n    plt.plot(T,Y[0,:])\n    plt.show()\n    plt.plot(freq, np.abs(PF))\n    plt.show()\n```\n\n    ", "Answer": "\r\nI can't pinpoint where the problem is. It looks like there is some problem in the ```\nfft```\n code. Anyway, I have little time so I will just put a sample code I made before. You can use it as reference or copy-paste it. It should work.\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq\n\nfs = 1000   #sampling frequency\nT = 1/fs    #sampling period\nN = int((1 / T) + 1) #number of sample points for 1 second\nt = np.linspace(0, 1, N) #time array\npi = np.pi\n\nsig1 = 1 * np.sin(2*pi*10*t)\nsig2 = 2 * np.sin(2*pi*30*t)\nsig3 = 3 * np.sin(2*pi*50*t)\n#generate signal\nsignal = sig1 + sig2 + sig3\n#plot signal\nplt.plot(t, signal)\nplt.show()\n\nsignal_fft = fft(signal)    #getting fft\nf2 = np.abs(signal_fft / N) #full spectrum\nf1 = f2[:N//2]              #half spectrum\nf1[1:] = 2*f1[1:]           #actual amplitude\n\nfreq = fs * np.linspace(0,N/2,int(N/2)) / N     #frequency array\n#plot fft result\nplt.plot(freq, f1)\nplt.xlim(0,100)\nplt.show()\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for tensor product spaces in Julia\r\n                \r\nRight now I use the package FFTW in order to get some Fourier Transforms I am interested in. However, I'm wondering if there is already a package of FFT that can do the transformation in a vector space which is of the form ```\nkron(C2, Rn)```\n, where ```\nC2```\n means a 2x2 system and ```\nRn```\n represents the \"spatial\" subspace in which one is interested in getting the Fourier Transform. In other words, does it exist a routine that implements:\n```\nkron(Id2x2, FFT)[kron(C2, Rn)] = kron(C2, FFT(Rn))\n```\n\nOf course the real problem I am interested is in the \"two particle case\" where the vector space (Hilbert space) is ```\nkron(kron(C2, Rn),kron(C2, Rn))```\n, so in this case the routine would need an operator like ```\nkron(kron(Id2x2, FFT), kron(Id2x2, FFT))```\n.\nNote 1: I haven't tried to do the problem taking partial traces, but in my case this option simply may not work because the states are sparse, i.e. it might be ineficient.\nNote 2: Note that (unless I'm mistaken) for ```\nkron(C2, Rn)```\n one could do \"twice\" the fft (one in each sector of ```\nC2```\n). However this might also be ineficient for large vector spaces.\n    ", "Answer": "\r\nHere's an example of what I think you are asking. ```\nres```\n is computed by FFT from  ```\nmat = kron(C2, Rn)```\n, and this is (as you say) a wasteful way of doing ```\nkron(C2, fft(Rn))```\n since it the FFT along the ```\nk```\n dimension is re-done for each of the 2×2 other dimensions. But the point, presumably, is to do this for \"entangled\" states in the product space -- a generic ```\nlikemat = rand(8,2)```\n cannot be decomposed into factors ```\nkron(likeC2, likeRn)```\n.\n(If instead you are really only interested in \"un-entangled\" product states, then you should probably just work with their components. Combining with ```\nkron```\n will then always be wasteful. The package Kronecker.jl may help for some things, but I don't think it knows about ```\nfft```\n.)\nThis uses my package to handle ```\nkron```\n-like operations; you could just write out the necessary ```\nreshape```\ns yourself, too.\n```\njulia> C2 = [1 2; 3 4]; Rn = [1,10,0,0];\n\njulia> mat = kron(C2,Rn)\n8×2 Matrix{Int64}:\n  1   2\n 10  20\n  0   0\n  0   0\n  3   4\n 30  40\n  0   0\n  0   0\n\njulia> using TensorCast, FFTW\n\n# notation: kron is a reshape of a tensor product, to combine i & k\n\njulia> kron(C2,Rn) == @cast out[(k,i),j] := C2[i,j] * Rn[k]\ntrue\n\n# reshape mat to put the index from Rn in its own dimension:\n\njulia> @cast tri[k,i,j] := mat[(k,i),j]  (i in 1:2);\n\njulia> summary(tri)\n\"4×2×2 Array{Int64, 3}\"\n\n# then fft(tri, 1) is the FFT along only that, reshape back:\n\njulia> @cast res[(ktil,i),j] := fft(tri, 1)[ktil,i,j]\n8×2 Matrix{ComplexF64}:\n  11.0+0.0im    22.0+0.0im\n   1.0-10.0im    2.0-20.0im\n  -9.0+0.0im   -18.0+0.0im\n   1.0+10.0im    2.0+20.0im\n  33.0+0.0im    44.0+0.0im\n   3.0-30.0im    4.0-40.0im\n -27.0+0.0im   -36.0+0.0im\n   3.0+30.0im    4.0+40.0im\n\njulia> res ≈ kron(C2, fft(Rn))\ntrue\n\njulia> res ≈ fft(mat, 1)\nfalse\n\njulia> fft(Rn)\n4-element Vector{ComplexF64}:\n 11.0 + 0.0im\n  1.0 - 10.0im\n -9.0 + 0.0im\n  1.0 + 10.0im\n\n# if fft() understood the dims keyword, it could be tidier:\n\njulia> _fft(x; dims) = fft(x, dims);\n\njulia> @cast _res[(k,i),j] := _fft(k) mat[(k,i),j]  (i in 1:2);\n\njulia> _res ≈ res\ntrue\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Inverse fast fourier transform in MATLAB\r\n                \r\nMy MATLAB code for ```\nfft```\n and ```\nifft```\n below has a problem with the inverse Fourier signal ```\ny```\n not matching the in put signal ```\nx```\n. Is there any solution to resolve this?\n\n```\nN = 1000;\nt0 = 1e-13;\ntau = 2*1e-14;\nn = [0:t0/40:2*1e-13-t0/40];\nf0 = 3*1e8/(150*1e-9);\n\nx = cos(2*pi*f0*n);\nx = x.*exp((-(n-t0).^2)./(tau^2));\nX = abs(fft(x,N));\nF = [-N/2 : N/2 - 1]/N;\nX = fftshift(X);\ny=ifft(X,80);\n\nfigure(3)\nplot(n,y)\n```\n\n    ", "Answer": "\r\nI see a number of issues here:\n\n```\nN = 1000;\nt0 = 1e-13;\ntau = 2*1e-14;\nn = [0:t0/40:2*1e-13-t0/40];\nf0 = 3*1e8/(150*1e-9);\n\nx = cos(2*pi*f0*n);\nx = x.*exp((-(n-t0).^2)./(tau^2));\n%  X = abs(fft(x,N));  <-- Not seen this technique before, and why N=1000?\n% try something more like:\nX = fft(x);\n\nF = [-N/2 : N/2 - 1]/N;\n% this is fine to shift and plot the function\nXshifted = fftshift(X);\nplot( abs( Xshifted ) )\n% now you're taking the inverse of the shifted function, not what you want\n% y=ifft(X,80);  also not sure about the 80\ny = ifft(X);\n\nfigure(3)\nplot(n,y)\nfigure(4)\nplot( n, x ); hold on; plot( n, y, 'o' )\n```\n\n\n\n\nThat's all I see at first. HTH!\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Using GEKKO with Fast Fourier Transform\r\n                \r\nI am actually trying to use the IPOPT Optimisor available on GEKKO in order to optimise a large non-convex and non-linear problem.In order to do that I need to use the Fast Fourrier Transform with scipy.First,lets fix our sample data(for simplicity):\n```\nimport numpy as np\nimport pandas as pd\nimport math\nfrom scipy import *\nfrom scipy.integrate import quad\nimport scipy.stats as ss\nimport scipy.optimize as scpo\nfrom scipy import sparse\nfrom scipy.fftpack import ifft\nfrom scipy.interpolate import interp1d\nfrom scipy.optimize import fsolve\nfrom functools import partial\n\nr,prices, strikes, spreads,s0,T  = 0,array([1532.45 , 1507.55 , 1482.65 , 1457.8  , 1432.95 , 1408.1  ,\n        1383.25 , 1358.45 , 1333.6  , 1308.8  , 1284.   , 1259.2  ,\n        1234.45 , 1209.7  , 1037.15 , 1012.55 ,  988.05 ,  963.35 ,\n         938.9  ,  914.3  ,  889.8  ,  865.5  ,  841.   ,  816.65 ,\n         792.45 ,  768.1  ,  743.95 ,  719.85 ,  695.85 ,  672.   ,\n         648.1  ,  624.5  ,  600.9  ,  577.5  ,  554.2  ,  531.   ,\n         508.15 ,  485.35 ,  462.9  ,  440.65 ,  418.65 ,  396.85 ,\n         375.55 ,  354.5  ,  333.9  ,  313.65 ,  293.85 ,  255.75 ,\n         237.55 ,  219.8  ,  202.8  ,  186.35 ,  170.55 ,  155.4  ,\n         141.05 ,  127.4  ,  113.5  ,  101.35 ,   90.1  ,   79.65 ,\n          70.   ,   61.3  ,   53.4  ,   46.35 ,   34.5  ,   29.6  ,\n          25.35 ,   18.55 ,   15.85 ,   13.55 ,   11.55 ,    9.9  ,\n           7.35 ,    5.45 ,    3.075,    2.7  ]),array([12500., 12525., 12550., 12575., 12600., 12625., 12650., 12675.,\n        12700., 12725., 12750., 12775., 12800., 12825., 13000., 13025.,\n        13050., 13075., 13100., 13125., 13150., 13175., 13200., 13225.,\n        13250., 13275., 13300., 13325., 13350., 13375., 13400., 13425.,\n        13450., 13475., 13500., 13525., 13550., 13575., 13600., 13625.,\n        13650., 13675., 13700., 13725., 13750., 13775., 13800., 13850.,\n        13875., 13900., 13925., 13950., 13975., 14000., 14025., 14050.,\n        14075., 14100., 14125., 14150., 14175., 14200., 14225., 14250.,\n        14300., 14325., 14350., 14400., 14425., 14450., 14475., 14500.,\n        14550., 14600., 14700., 14725.]),array([29.7 , 29.7 , 29.7 , 29.8 , 29.7 , 29.8 , 29.7 , 29.7 , 29.8 ,\n        29.8 , 29.8 , 29.8 , 29.7 , 29.8 , 10.3 , 10.3 , 10.5 , 10.3 ,\n        10.6 , 10.4 , 10.4 , 10.6 , 10.4 , 10.5 , 10.7 , 10.4 , 10.5 ,\n        10.5 , 10.5 , 10.8 , 10.6 , 10.8 , 10.6 , 10.8 , 10.6 , 10.6 ,\n        10.9 , 10.5 , 10.8 , 10.7 , 10.7 , 10.3 , 10.5 , 10.4 , 10.2 ,\n        10.1 ,  9.9 ,  9.5 ,  9.3 ,  9.  ,  8.8 ,  8.5 ,  8.3 ,  8.2 ,\n         7.9 ,  7.6 ,  3.8 ,  3.7 ,  3.6 ,  3.5 ,  3.4 ,  3.2 ,  3.2 ,\n         3.1 ,  2.8 ,  2.6 ,  2.5 ,  2.3 ,  2.1 ,  2.1 ,  1.9 ,  1.8 ,\n         1.7 ,  1.5 ,  1.25,  1.2 ]),14000,0.05\n```\n\nthen the fourrier functions:\n```\nclass Heston_pricer():\n\n    def __init__(self, Option_info, Process_info ):\n        \"\"\"\n        Process_info: a instance of \"Heston_process.\", which contains (mu, rho, sigma, theta, kappa)\n        Option_info: of type Option_param, which contains (S0,K,T)\n        \"\"\"\n        self.r = Process_info.mu              # interest rate\n        self.sigma = Process_info.sigma       # Heston parameters\n        self.theta = Process_info.theta       \n        self.kappa = Process_info.kappa       \n        self.rho = Process_info.rho           \n\n        self.S0 = Option_info.S0          # current price\n        self.v0 = Option_info.v0          # spot variance\n        self.K = Option_info.K            # strike\n        self.T = Option_info.T            # maturity(in years)\n        self.exercise = Option_info.exercise\n        self.payoff = Option_info.payoff\n\n    # payoff function\n    def payoff_f(self, S):\n        if self.payoff == \"call\":\n            Payoff = np.maximum( S - self.K, 0 )\n        elif self.payoff == \"put\":    \n            Payoff = np.maximum( self.K - S, 0 )  \n        return Payoff\n\n    # FFT method. It returns a vector of prices.\n    def FFT(self, K): # K: strikes\n        K = np.array(K)\n\n        # Heston characteristic function (proposed by Schoutens 2004)\n        def cf_Heston_good(u, t, v0, mu, kappa, theta, sigma, rho):\n            xi = kappa - sigma*rho*u*1j\n            d = m.sqrt( xi**2 + sigma**2 * (u**2 + 1j*u) ) \n            g1 = (xi+d)/(xi-d)  \n            g2 = 1/g1\n            cf = m.exp( 1j*u*mu*t + (kappa*theta)/(sigma**2) * ( (xi-d)*t - 2*m.log( (1-g2*m.exp(-d*t))/(1-g2) ))\\\n                      + (v0/sigma**2)*(xi-d) * (1-m.exp(-d*t))/(1-g2*m.exp(-d*t))) \n            return cf\n\n        cf_H_b_good = partial(cf_Heston_good, t=self.T, v0=self.v0, mu=self.r, theta=self.theta, \n                                  sigma=self.sigma, kappa=self.kappa, rho=self.rho)\n        if self.payoff == \"call\":\n            return fft_(K, self.S0, self.r, self.T, cf_H_b_good)\n        elif self.payoff == \"put\":        # put-call parity\n            return fft_(K, self.S0, self.r, self.T, cf_H_b_good) - self.S0 + K*m.exp(-self.r*self.T)\n\nclass Heston_process():\n  def __init__(self, mu=0, rho=0, sigma=0.00001, theta=0.4, kappa=.00001):\n            \"\"\"\n            r: risk free constant rate\n            rho: correlation between stock noise and variance noise (|rho| must be <=1)\n            theta: long term mean of the variance process(positive)\n            sigma: volatility coefficient(positive)\n            kappa: mean reversion coefficient for the variance process(positive)\n            \"\"\"\n            self.mu, self.rho, self.theta, self.sigma, self.kappa = mu, rho, theta, sigma, kappa\n\ndef fft_(K, S0, r, T, cf): # interp support cubic \n    \"\"\" \n    K = vector of strike\n    S0 = spot price scalar\n    cf = characteristic function\n    \"\"\"\n    N=2**15                         # FFT more efficient for N power of 2\n    B = 500                         # integration limit \n\n    dx = B/N\n    x = np.arange(N) * dx\n\n    weight = 3 + (-1)**(np.arange(N)+1) # Simpson weights\n    weight[0] = 1; weight[N-1]=1\n\n    dk = 2*np.pi/B\n    b = N * dk /2\n    ks = -b + dk * np.arange(N)\n\n    integrand = m.exp(- 1j * b *(np.arange(N))*dx) * cf(x - 0.5j) * 1/(x**2 + 0.25) * weight * dx/3\n    integral_value = np.real(ifft(integrand)*N)\n    spline_cub = interp1d(ks, integral_value, kind=\"cubic\") # cubic will fit better than linear\n    prices = S0 - m.sqrt(S0 * K) * m.exp(-r*T)/np.pi * spline_cub( m.log(S0/K) )\n    return prices\n\n# A class that stores option parameters (in order to write BS/Heston class neatly)\nclass Option_param():  \n    def __init__(self, S0=10000, K=10000, T=.1, v0=0.04, payoff=\"call\", exercise=\"European\"):\n        \"\"\"\n        S0: current stock price\n        K: Strike price\n        T: time to maturity\n        v0: (optional) spot variance \n        exercise: European or American\n        \"\"\"\n        self.S0, self.v0, self.K, self.T, self.exercise, self.payoff = S0, v0, K, T, exercise, payoff\n```\n\nNow let's use GEKKO:\n```\n#Initialize Model\nm = GEKKO()\n\n#define parameter\neq = m.Param(value=5)\n\n#initialize variables\nx1,x2,x3,x4,x5 = [m.Var(lb=-1, ub=1),m.Var(lb=1e-3, ub=1),m.Var(lb=1e-3, ub=1),m.Var(lb=1e-3, ub=20),m.Var(lb=1e-3, ub=1)]\n\n#initial values\nx1.value = 0\nx2.value = 0.5\nx3.value = 0.5\nx4.value = 0.5\nx5.value = 0.5\n\nX = [x1,x2,x3,x4,x5]\n\n#Equations,Feller Condition\nm.Equation(2*x3*x4 - x2*x2 >=0)\n\ndef least_sq(x):\n    \"\"\" Objective function \"\"\"\n    Heston_param = Heston_process(mu=0, rho=X[0], sigma=X[1], theta=X[2], kappa=X[3])\n    m = 1/(spreads**2)\n    if len(m) == 1:\n      l = 1\n    else:\n      l = (m - np.min(m))/(np.max(m)-np.min(m))\n    opt_param = Option_param(S0=s0, K=strikes, T=T, v0=X[4], exercise=\"European\", payoff=\"call\" )\n    Hest = Heston_pricer(opt_param, Heston_param)\n    prices_calib = Hest.FFT(strikes)\n    results = (l * (prices_calib-prices)**2)/len(prices)\n    return results\n\nm.Obj(m.sum(least_sq(X)))\n#Set global options\nm.options.IMODE = 3 #steady state optimization\n\n#Solve simulation\nm.solve()\n\n#Results\nprint('')\nprint('Results')\nprint('x1: ' + str(x1.value))\nprint('x2: ' + str(x2.value))\nprint('x3: ' + str(x3.value))\nprint('x4: ' + str(x4.value))\nprint('x5: ' + str(x5.value))\n```\n\nThe problem here is the ifft scipy function that doesn't work because of the different type of variable given by GEKKO.The problem is I don't see how I can replace or avoid it.\nThe error is such :\n```\n<ipython-input-16-305a2bb0769b> in fft_(K, S0, r, T, cf)\n     78 \n     79     integrand = m.exp(- 1j * b *m.CV(np.arange(N))*dx) * cf(x - 0.5j) * 1/(x**2 + 0.25) * weight * dx/3\n---> 80     integral_value = np.real(ifft(integrand)*N)\n     81     spline_cub = interp1d(ks, integral_value, kind=\"cubic\") # cubic will fit better than linear\n     82     prices = S0 - m.sqrt(S0 * K) * m.exp(-r*T)/np.pi * spline_cub( m.log(S0/K) )\n\n/usr/local/lib/python3.7/dist-packages/scipy/_lib/deprecation.py in call(*args, **kwargs)\n     18             warnings.warn(msg, category=DeprecationWarning,\n     19                           stacklevel=stacklevel)\n---> 20             return fun(*args, **kwargs)\n     21         call.__doc__ = msg\n     22         return call\n\n<__array_function__ internals> in ifft(*args, **kwargs)\n\n/usr/local/lib/python3.7/dist-packages/numpy/fft/_pocketfft.py in ifft(a, n, axis, norm)\n    274     a = asarray(a)\n    275     if n is None:\n--> 276         n = a.shape[axis]\n    277     if norm is not None and _unitary(norm):\n    278         inv_norm = sqrt(max(n, 1))\n\nIndexError: tuple index out of range\n```\n\nCould someone help me debugging this.Thank you\n    ", "Answer": "\r\nGekko requires that expressions are not black box but are able to be expressed with special types of variables (Gekko type) for automatic differentiation and sparsity detection. This may be better solved with a solver such as Scipy.optimize.minimize. Here is a comparison of the two on a simple problem.\nScipy\n```\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef objective(x):\n    return x[0]*x[3]*(x[0]+x[1]+x[2])+x[2]\n\ndef constraint1(x):\n    return x[0]*x[1]*x[2]*x[3]-25.0\n\ndef constraint2(x):\n    sum_eq = 40.0\n    for i in range(4):\n        sum_eq = sum_eq - x[i]**2\n    return sum_eq\n\n# initial guesses\nn = 4\nx0 = np.zeros(n)\nx0[0] = 1.0\nx0[1] = 5.0\nx0[2] = 5.0\nx0[3] = 1.0\n\n# show initial objective\nprint('Initial Objective: ' + str(objective(x0)))\n\n# optimize\nb = (1.0,5.0)\nbnds = (b, b, b, b)\ncon1 = {'type': 'ineq', 'fun': constraint1} \ncon2 = {'type': 'eq', 'fun': constraint2}\ncons = ([con1,con2])\nsolution = minimize(objective,x0,method='SLSQP',\\\n                    bounds=bnds,constraints=cons)\nx = solution.x\n\n# show final objective\nprint('Final Objective: ' + str(objective(x)))\n\n# print solution\nprint('Solution')\nprint('x1 = ' + str(x[0]))\nprint('x2 = ' + str(x[1]))\nprint('x3 = ' + str(x[2]))\nprint('x4 = ' + str(x[3]))\n```\n\nGekko\n```\nfrom gekko import GEKKO    \n\nm = GEKKO()\n\n#initialize variables\nx1,x2,x3,x4 = [m.Var(lb=1,ub=5) for i in range(4)]\nx1.value = 1; x2.value = 5; x3.value = 5; x4.value = 1\n\nm.Equation(x1*x2*x3*x4>=25)\nm.Equation(x1**2+x2**2+x3**2+x4**2==40)\n\nm.Minimize(x1*x4*(x1+x2+x3)+x3)\n\nm.solve()\n\nprint('x1: ' + str(x1.value))\nprint('x2: ' + str(x2.value))\nprint('x3: ' + str(x3.value))\nprint('x4: ' + str(x4.value))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why does my own implementation of Fast Fourier Transform in N dimensions give different results than NumPy's?\r\n                \r\nI've written the following code for the N-dimensional Fast Fourier Transform but it doesn't give me the same result as numpy's function.\n```\ndef nffourier(f, direct):\n    dim = f.ndim  \n    N = f.shape\n    G = np.zeros(f.shape, dtype=complex)\n    G = f\n    \n    for k in range(dim):\n        for i in range(N[k]):\n            aux = G[(slice(None),) * (k) + (i,)]\n            trans = ffourier(aux, direct)\n            G[(slice(None),) * (k) + (i,)] = trans\n            \n    return G\n```\n\nMy code for calculating FFT in 1d is the following:\n```\ndef ffourier(f, direct):\n    N = len(f)\n    \n    M = int(m.log(N)/m.log(2))\n        \n    G = []\n    order = []\n    \n    for i in range(N):\n        order.append(int(bin(i)[2:]))\n    \n    digitos = len(aux)\n    for i in range(N):\n        contenido_aux = str(int(order[i]))\n        aux = len(str(order[i]))\n        if(aux<digitos):\n            añadir=digitos-aux\n            for k in range(añadir):\n                contenido_aux = '0'+contenido_aux\n        G.append(contenido_aux)\n    for i in range(len(G)):\n        G[i] = G[i][::-1]\n    \n\n    for i in range(len(G)):\n        G[i] = int(G[i], 2)\n    for i in range(len(G)):\n        G[i] = f[G[i]]\n    \n\n    \n   \n    if direct == False:\n        signo = 1\n    else:\n        signo = -1\n\n\n    kmax = 1\n    kmax = int(kmax)\n    for alfa in range(1,M+1):\n        w1 = np.exp(signo*1j*2*m.pi/(2**alfa))\n        kmax = int(2*kmax)\n        W = 1\n        for k in range(0, int(kmax/2)-1+1):\n            for s in range(0, N-1+1, int(kmax)):\n                T0 = G[s+k]\n                T1 = G[s+k+int(kmax/2)]*W\n                G[s+k]=T0+T1\n                G[s+k+int(kmax/2)]=T0-T1\n            W=W*w1\n    cte = 1/m.sqrt(N)\n    for i in range(0, N-1+1):\n        G[i] = G[i]*cte \n    return G\n```\n\nThe fundamentals of it is quite hard to explain, it's based on bit inversion, but I've checked it works properly, so the problem is with the N dimensional code.\n    ", "Answer": "\r\nYour indexing ```\nG[(slice(None),) * (k) + (i,)]```\n works in 2D but not in higher dimensions. Let’s see what it does:\nSay ```\nG```\n is 2D. Now when ```\nk=0```\n, your indexing is the same as ```\nG[i]```\n, which is the same as ```\nG[i,:]```\n. You are selecting rows. When ```\nk=1```\n, then that indexing is ```\nG[:,i]```\n. You are selecting columns.\nBut now say ```\nG```\n is 3D. Now when ```\nk=0```\n, you get ```\nG[i]```\n again, which now is equivalent to ```\nG[i,:,:]```\n. You are selecting a 2D subarray! What you need is a 1D subarray. You need to get ```\nG[i,j,:]```\n for all ```\ni```\n and all ```\nj```\n. And then ```\nG[i,:,j]```\n, and then ```\nG[:,i,j]```\n.\nLikewise, for a 5D array, you want ```\nG[i,j,k,l,:]```\n, etc. That is to say, you want to loop over all dimensions minus one.\nTo loop over all ```\ni```\n and ```\nj```\n, you could do a double loop, but then you have specific 3D code. It is possible to write a loop over an arbitrary number of dimensions, but it’s not pretty. So we’ll look for an alternative.\nI think the simplest way to get this to work is to flatten those N-1 dimensions, turning a MxNxOxPxQ array into a 2D (```\nN*M*O*P```\n)xQ array. Now you can do a 1D loop over the first dimension.\nNow you need to loop over the dimensions, it’s a different dimension that we leave out every time. We can simplify this problem by “rolling” the dimensions, make a different dimension the last one every time, then apply that same flattening code. Now it’s easy to write a loop (not tested):\n```\ndef nffourier(f, direct):\n    dim = f.ndim  \n    G = f.astype(complex)\n    \n    for k in range(dim):\n        G = np.moveaxis(G, 0, -1)  # shifts the dimensions by one to the left\n        shape = G.shape\n        m = shape[-1]\n        G = np.reshape(G, (-1, m))  # flattens all but last dimension\n        m = G.shape[0]\n        for i in range(m):          # loop over first dimension\n            G[i, :] = ffourier(G[i, :], direct)  # apply over last dimension\n        G = np.reshape(G, shape)    # return to original shape\n    \n    # After applying moveaxis dim times, G should have the same dimension order it had at the start\n    return G\n```\n\n(Note also, as we already discussed in the comments, that the ```\nG = f```\n line causes the output array ```\nG```\n to be of the same type as ```\nf```\n, likely not complex, and so will cause errors also.)\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "simultaneous inverse fast fourier transform of two real functions\r\n                \r\nI'm trying to calculate the inverse Fourier Transform of two real functions with a single IFFT. The best and most straightforward explanation I've found so far is here, where it says:\n\n\n  Use the fact that the FFT is linear and form the sum of the first transform plus i times the second.\n  You have two vectors, x1 and x2, with\n  discrete Fourier Transforms X1 and X2\n  respectively. Then\n  \n  x1 = Re[ IDFT[ X1 + i X2 ] ]\n  \n  and\n  \n  x2 = Im[ IDFT[ X1 + i X2 ] ].\n\n\nThe problem is that I don't get where the 'i' parameter comes from.\nAny hint on this would be much appreciated.\n\nThanks in advance.\n\nEDIT:\n\nAfter doing some experiments I finally made it work, but now I'm more confused than before as it didn't work as I expected and had to use some imagination to figure out the correct formulas.\n\nI just made up a new complex array where:\n\n```\nRe[n] = X1Re[n] - X2Im[n]\nIm[n] = X2Re[n] + X1Im[n]\n```\n\n\nAfter doing an IFFT on it x1 = Re and x2 = Im, so wouldn't it be correct to express it like this?\n\n```\nx1 = Re[ IDFT[ X1 - i X2 ] ]\nx2 = Im[ IDFT[ X2 + i X1 ] ].\n```\n\n    ", "Answer": "\r\nAre you wondering what the 'i' represents?  In this case, I believe 'i' is referring to sqrt(-1), the imaginary unit vector.\n\nThen:\n\n```\nRe[ IDFT[ X1 + i X2 ] ]\n```\n\n\nwill be the 'real' part of that transform (anything without an 'i') and \n\n```\nIm[ IDFT[ X1 + i X2 ] ]\n```\n\n\nwill be the 'imaginary' part of that transform (anything multiplied by an 'i').\n\nIt is possible I've misunderstood your question and this answer is much too simplistic; if it is, no insult was intended to your intelligence, I just misunderstood you.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Output array after performing fast fast fourier transform of a data set\r\n                \r\nI'm trying to perform a fourier transform of a data set that I have and subsequently writing its real and imaginary parts separately.\n\nThis is my code:\n\n```\nimport sys,string\nimport numpy as np\nfrom math import *\nimport fileinput\nfrom scipy.fftpack import fft, ifft\n\ntemparray = []\n\nfor i in range(200000):\n    line = sys.stdin.readline() ## reads data from a text file\n    fields = map(float,line.split())\n    temparray.append(fields)\nacf = sum(temparray,[]) ## I need to do this as the appended array from above is nested\ny = np.fft.fft(acf)\nz = (y.real,y.imag)\nprint z\n```\n\n\nThe output that I get is as follows:\n\n```\n(array([ 2600.36368107, 2439.50426935, 1617.52631545, ..., 1575.78483016, 1617.52631545, 2439.50426935]), array([ 0. , -767.19967198, -743.75183367, ..., 726.45052092, 743.75183367, 767.19967198]))\n```\n\n\nIt looks like its only printing the first few and last few values, completely skipping everything in between. Can anybody please tell me why this is happening?\n\nThanks\n    ", "Answer": "\r\nAs others have indicated, include a modified version of \n\n```\n>>> np.set_printoptions(edgeitems=5,linewidth=80,precision=2,suppress=True,threshold=10) \n>>> a = np.arange(0,100.)\n>>> \n>>> a\narray([  0.,   1.,   2.,   3.,   4., ...,  95.,  96.,  97.,  98.,  99.])\n>>> np.set_printoptions(edgeitems=5,linewidth=80,precision=2,suppress=True,threshold=100) \n>>> a\narray([  0.,   1.,   2.,   3.,   4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.,\n        12.,  13.,  14.,  15.,  16.,  17.,  18.,  19.,  20.,  21.,  22.,  23.,\n        24.,  25.,  26.,  27.,  28.,  29.,  30.,  31.,  32.,  33.,  34.,  35.,\n        36.,  37.,  38.,  39.,  40.,  41.,  42.,  43.,  44.,  45.,  46.,  47.,\n        48.,  49.,  50.,  51.,  52.,  53.,  54.,  55.,  56.,  57.,  58.,  59.,\n        60.,  61.,  62.,  63.,  64.,  65.,  66.,  67.,  68.,  69.,  70.,  71.,\n        72.,  73.,  74.,  75.,  76.,  77.,  78.,  79.,  80.,  81.,  82.,  83.,\n        84.,  85.,  86.,  87.,  88.,  89.,  90.,  91.,  92.,  93.,  94.,  95.,\n        96.,  97.,  98.,  99.])\n\nnp.set_printoptions(edgeitems=3,linewidth=80,precision=2,suppress=True,threshold=5)\n```\n\n\nperhaps setting threshold to some very large number. \n\nAddendum\n\nI would be remiss if I didn't state that the simplest solution to the above is to simple use\n\n```\n>>> list(a)\n```\n\n\nshould you not care whether an array is visually returned or not.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Computational complexity of n-dimensional Discrete Fourier Transform?\r\n                \r\nThe computational complexity of n-dimensional Fast Fourier Transform was discussed here and (as the former's duplicate) here.\n\nThe computational complexity of a 1-dimensional Discrete Fourier Transform is ```\nO(N^2)```\n, ```\nN```\n is the data set size.\n\nCould you please tell us what is the computational complexity of the n-dimensional Discrete Fourier Transform consisting {N1, N2 ... Nn} points along each dimension?\n    ", "Answer": "\r\nThe FFT itself is also a DFT (with some constraints). Will assume that you mean the naive summation method.\n\nRe-writing the 1D DFT in integral form (the continuous version):\n\n\n\nA particular value of ```\nf```\n-tilde is equivalent to a single element in your DFT array. When the integral is discretized (i.e. converted a finite sum), there are ```\nN```\n terms in the sum. This gives ```\nO(N)```\n for each element and hence ```\nO(N^2)```\n overall.\n\nIn case you were wondering, writing in this form allows for more compact notation for a general ```\nn```\n-D DFT:\n\n\n\nWhen this is discretized, we can see that for each element there are ```\nn```\n sums, each over one of the dimensions and of length ```\nN```\n. There are ```\nN ^ n```\n values in the input \"array\", so the complexity is:\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast fourier transform went wrong\r\n                \r\nI tried to implement FFT using this code: Rosetta Code FFT\n\nHere's a screenshot of the result I got:\nFFT gone wrong\n\nHere's my code where I used the above FFT on an image:\n\n```\nfunction fastFourier(img){\n\nlet height=img.rows;\nlet width=img.cols;\nlet tmp=createArray(height,width);\nlet temp=createArray(height,width);\nlet rows=createArray(height,width);\nlet prettypls=img.clone();\n\n//new complex array\nfor(i=0;i<height;i++){\n  for(j=0;j<width;j++){\n  rows[i][j]=new Complex(0, 0);\n    }\n}\n\n//put pixel values in complex array\nif(height%2==0&&width%2==0){\n  for ( y = 0; y < height; y++) {\n    for ( x = 0; x < width; x++) {\n    let pixel = img.ucharPtr(y,x);\n    rows[y][x].re=pixel[0];\n  }\n}\n\n//perform fft\nfor(y=0;y<height;y++){\n  tmp[y]=cfft(rows[y]);\n}\n\n//take the magnitudes\nfor(i=0;i<height;i++){\n  for(j=0;j<width;j++){\n    temp[i][j]=Math.round(tmp[i][j].re);\n  }\n}\n\n//do a log transform\ntemp=logTransform(temp,height,width);\n\n//put the real values into Mat\nfor(i=0;i<height;i++){\n  for(j=0;j<width;j++){\n    let pixel = prettypls.ucharPtr(i,j);\n    pixel[0]=Math.round(temp[i][j]);\n  }\n}\ncv.imshow('fourierTransform', prettypls);\nrows=[];temp=[];tmp=[];prettypls.delete();\n}\nelse alert('Image size must be a power of 2.');\n}\n```\n\n\nI did the log transform based on this description of FFT. Here's my log transform code:\n\n```\nfunction logTransform(img,h,w){\n//https://homepages.inf.ed.ac.uk/rbf/HIPR2/pixlog.htm\nlet max=findMax2d(img,h,w);\nlet c=255/(Math.log(1+max));\nfor(i=0;i<h;i++){\n  for(j=0;j<w;j++){\n    img[i][j]=c*Math.log(1+Math.abs(img[i][j]));\n  }\n}\nreturn img;\n}\n```\n\n\nI have no idea what I did wrong. The FFT results are fine when it's just a normal array, but using it with images returns the above results.\n    ", "Answer": "\r\nYou're getting exactly what you asked for: for each row in the image, an analysis of the intensity frequencies in that row. Your code treats each row as an individual array of samples, and takes the FFT of that.\n\nWhat you probably want is a two-dimensional FFT as described here: http://www.robots.ox.ac.uk/~az/lectures/ia/lect2.pdf\n\nRight now, you are just calculating a series of one-dimensional FFTs, which is not the same.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "1D Fast Fourier Transform\r\n                \r\nWhat algorithm is the following?\n\nWhat I understand from the following source code is:\n\n\n```\ndir```\n is the direction of FFT: forward=1, inverse=-1.\n```\nx```\n is the real part\n```\ny```\n is the imaginary part\n\n\nWhat is ```\nm```\n here?\n\nIf ```\nx```\n = {1, 1, 1, 1, 0, 0, 0, 0}, and, ```\ny```\n = {0,0,0,0,0,0,0,0,0}, what would be the value of ```\nm```\n?\n\n```\n        //Inplace 1D FFT\n        public static void FFT1D(int dir, int m, ref double[] x, ref double[] y)\n        {\n            long nn, i, i1, j, k, i2, l, l1, l2;\n            double c1, c2, tx, ty, t1, t2, u1, u2, z;\n            /* Calculate the number of points */\n            nn = 1;\n            for (i = 0; i < m; i++)\n                nn *= 2;\n            /* Do the bit reversal */\n            i2 = nn >> 1;\n            j = 0;\n            for (i = 0; i < nn - 1; i++)\n            {\n                if (i < j)\n                {\n                    tx = x[i];\n                    ty = y[i];\n                    x[i] = x[j];\n                    y[i] = y[j];\n                    x[j] = tx;\n                    y[j] = ty;\n                }\n                k = i2;\n                while (k <= j)\n                {\n                    j -= k;\n                    k >>= 1;\n                }\n                j += k;\n            }\n            /* Compute the FFT */\n            c1 = -1.0;\n            c2 = 0.0;\n            l2 = 1;\n            for (l = 0; l < m; l++)\n            {\n                l1 = l2;\n                l2 <<= 1;\n                u1 = 1.0;\n                u2 = 0.0;\n                for (j = 0; j < l1; j++)\n                {\n                    for (i = j; i < nn; i += l2)\n                    {\n                        i1 = i + l1;\n                        t1 = u1 * x[i1] - u2 * y[i1];\n                        t2 = u1 * y[i1] + u2 * x[i1];\n                        x[i1] = x[i] - t1;\n                        y[i1] = y[i] - t2;\n                        x[i] += t1;\n                        y[i] += t2;\n                    }\n                    z = u1 * c1 - u2 * c2;\n                    u2 = u1 * c2 + u2 * c1;\n                    u1 = z;\n                }\n                c2 = Math.Sqrt((1.0 - c1) / 2.0);\n                if (dir == 1)\n                    c2 = -c2;\n                c1 = Math.Sqrt((1.0 + c1) / 2.0);\n            }\n            /* Scaling for forward transform */\n            if (dir == 1)\n            {\n                for (i = 0; i < nn; i++)\n                {\n                    x[i] /= (double)nn;\n                    y[i] /= (double)nn;\n                }\n            }\n        }\n```\n\n    ", "Answer": "\r\nThe implementation of the FFT you have posted is limited to inputs of size 2```\nm```\n. Here ```\nm```\n thus indirectly specify the size of the FFT block size. So, for your example with ```\nx = {1,1,1,1,0,0,0,0}```\n and ```\ny={1,1,1,1,0,0,0,0}```\n being arrays of size 8=23, ```\nm```\n would be equal to 3.\n\nNote that there are no additional checks for the size of the arrays ```\nx```\n and ```\ny```\n so make sure they are at least that size. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Pseudocode?\r\n                \r\nThe purpose of the following code is to convert a polynomial from coefficient representation into value representation by dividing it into its odd and even powers and then recursing on the smaller polynomials.\n\n```\nfunction FFT(A, w)\n\nInput: Coefficient representation of a polynomials A(x) of degree ≤ n-1, where n \nis a power of 2w, an nth root of unity.\n\nOutput: Value representation A(w^0),...,A(w^(n-1))\n\nif w = 1; return A(1)\nexpress A(x) in the form A_e(x^2) and xA_o(x^2) /*where A_e are the even powers and A_o  \nthe odd.*/\ncall FFT(A_e,w^2) to evaluate A_e at even of powers of w\ncall FFT(A_o,w^2) to evaluate A_o at even powers of w\nfor j = 0 to n-1;\n    compute A(w^j) = A_e(w^(2j))+w^j(A_o(w^(2j)))\n\nreturn A(w^0),...,A(w^(n-1))\n```\n\n\n\nWhat is the for loop being used for?\nWhy is the pseudocode only adding the smaller polynomials, doesn't it need to subtract them too? (to calculate A(-x)). Isn't that what the algorithm completely based on? Adding and subtracting the smaller polynomials to reduce the points in half?*\nWhy are powers of \"w\" being evaluated as opposed to \"x\"?\n\n\nI am not a too sure if this belongs here, since the question is quite mathematical. If you feel this question is off-topic, I would appreciate it if you moved it to a site where you felt this question would be more appropriate, rather that just closing it.\n\n*Psuedocode was gotten from Algorithms by S. Dasgupta. Page 71.\n    ", "Answer": "\r\n\nThe loop is for recursion.\nNo need to add for negative x; the FFT transforms from time to frequency space.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Changing the inverse fast Fourier transform (ifft) to use an arbitrary waveform instead of sine waves to create a new signal\r\n                \r\nI know that an inverse fast Fourier transform (ifft) sums multiple sine waves together from data obtain from doing an fft on a signal. Is there a way to create a signal using a new type of inverse fast Fourier transform (ifft) using an arbitrary waveform instead of just using sine waves?\n\nI'm not trying to re-create the original signal. I'm trying to create a new signal using a new type of inverse fast Fourier transform (ifft) using a given arbitrary waveform based on the (frequency, amplitude, phase) data calculated from the fft   from the source signal.\n\nThe arbitrary waveform is a sampled signal that will replace one period of the sine wave used in the fft. That is, the signal is to be scaled, repeated, and shifted according to the values given by the fft.\n\nSee simple example below: the signals I will be applying FFT to are human audio signals about 60 seconds long at 44100 samples (large arrays) so I'm trying to see if I can use / alter the ifft command in some way to create a new signal using / based on an arbitrary waveform. \n\nPS: I'm using Octave 4.0 which is similar to Matlab and the arbitrary waveform signal used to create a new signal will be changed to create different signals.\n\n```\nclear all,clf reset, clc,tic\n\nfs=44100 % Sampling frequency\nlen_of_sig=2; %length of signal in seconds\nt=linspace(0,2*pi*len_of_sig,fs*len_of_sig);\nafp=[.5,2.43,pi/9;.3,3,pi/2;.3,4.3,pi/3];  %represents Amplitude,frequency,phase data array\n\n%1 create source signal\nya=0;\nfor zz=1:size(afp,1)\n  ya = ya+afp(zz,1)*sin(afp(zz,2)*t+afp(zz,3));\nend\n\n%2 create source frequency domain data\nya_fft = fft(ya);\n\n%3 rebuild original source signal\nmag = abs(ya_fft);\nphase = unwrap(angle(ya_fft));\nya_newifft=ifft(mag.*exp(i*phase));\nifft_sig_combined_L1=ifft(mag.*exp(i*phase),length(ya_newifft)); \n\n%4 %%%-----begin create arbitrary waveform to use ---- \ngauss = @(t, t0, g) exp(-((t-t0)/g).^2); % a simple gaussian\n\nt_arbitrary=0:1:44100; % sampling\nt_arbitrary_1 = 10000; % pulses peak positions (s)\nt_arbitrary_2 = 30000; % pulses peak positions (s)\n\ng = 2000; % pulses width (at 1/e^2) (s)\n\nlilly = gauss(t_arbitrary, t_arbitrary_1, g) - (.57*gauss(t_arbitrary, t_arbitrary_2, g)); %different amplitude peaks\n%%%%-----End arbitrary waveform to use---- \n\n%5 plot\nt_sec=t./(2*pi); %converts time in radians to seconds\nt_arbitrary_sec=t_arbitrary./length(lilly); %converts time in radians to seconds\n\nsubplot(4,1,1);\nplot(t_sec,ya,'r')\ntitle('1) source signal')\n\nsubplot(4,1,2);\nplot(t_sec,ifft_sig_combined_L1)\ntitle('2) rebuilt source signal using ifft')\n\nsubplot(4,1,3);\nplot(t_arbitrary_sec,lilly,'r')\ntitle('3) arbitrary waveform used to create new signal')\n```\n\n\n\n\nAdded a work-flow chart below with simple signals to see if that explains it better:\n\n```\nSection 1) The audio signal is read into an array\nSection 2) FFT is done on the signal\nSection 3 Red) Normally Inverse FFT uses sin waves to rebuild the signal see signal in red\nSection 3 Blue) I want to use an arbitrary signal wave instead to rebuild the signal using the FFT data calculated in (Section 2)\nSection 4) New signals created using a new type of Inverse FFT (Section 3).\nPlease note the new type of Inverse FFT final signal (in blue ) must use the FFT data taken from the original signal.\nThe signal Sample rate tested should be 44100 and the length of the signal in seconds should be 57.3 seconds long.  I use these numbers to test that the array can handle large amounts and that the code can handle non even numbers in seconds.\n```\n\n\n\n    ", "Answer": "\r\nLet's start with a function ```\nlilly```\n that takes a frequency, an amplitude and a phase (all scalars), as well as a signal length ```\nN```\n, and computes a sine wave as expected for the inverse DFT (see note 2 below):\n\n```\nfunction out = lilly(N,periods,amp,phase)\npersistent t\npersistent oneperiod\nif numel(t)~=N\n   disp('recomputung \"oneperiod\"');\n   t = 0:N-1;\n   oneperiod = cos(t * 2 * pi / N);\nend\np = round(t * periods + phase/(2*pi)*N);\np = mod(p,N) + 1;\nout = amp * oneperiod(p);\n```\n\n\nI have written this function such that it uses a sampled signal representing a single period of the since wave.\n\nThe following function uses the ```\nlilly```\n function to compute an inverse DFT (see note 1 below):\n\n```\nfunction out = pseudoifft(ft)\nN = length(ft);\nhalf = ceil((N+1)/2);\nout = abs(ft(1)) + abs(ft(half)) * ones(1,N);\nfor k=2:half-1\n   out = out + lilly(N,k-1,2*abs(ft(k)),angle(ft(k)));\nend\nout = out/N;\n```\n\n\nNow I test to verify that it actually computes the inverse DFT:\n\n```\n>> a=randn(1,256);\n>> b=fft(a);\n>> c=pseudoifft(b);\nrecomputung \"oneperiod\"\n>> max(abs(a-c))\nans =  0.059656\n>> subplot(2,1,1);plot(a)\n>> subplot(2,1,2);plot(c)\n```\n\n\n\n\nThe error is relatively large, due to the ```\nround```\n function: we're subsampling the signal instead of interpolating. If you need more precision (not likely I think) you should use ```\ninterp1```\n instead of indexing using ```\nround(p)```\n.\n\nNext, we replace the sine in the ```\nlilly```\n function with your example signal:\n\n```\nfunction out = lilly(N,periods,amp,phase)\npersistent t\npersistent oneperiod\nif numel(t)~=N\n   disp('recomputung \"oneperiod\"');\n   t = 0:N-1;\n   %oneperiod = cos(t * 2 * pi / N);\n   gauss = @(t,t0,g) exp(-((t-t0)/g).^2); % a simple gaussian\n   t1 = N/4;   % pulses peak positions (s)\n   t2 = 3*N/4; % pulses peak positions (s)\n   g = N/20;   % pulses width (at 1/e^2) (s)\n   oneperiod = gauss(t,t1,g) - (.57*gauss(t,t2,g)); %different amplitude peaks\n   oneperiod = circshift(oneperiod,[1,-round(N/4)]); % this will make it look more like cos\nend\np = round(t * periods + phase/(2*pi)*N);\np = mod(p,N) + 1;\nout = amp * oneperiod(p);\n```\n\n\nThe function ```\npseudoifft```\n now creates a function composed of your basis:\n\n```\n>> c=pseudoifft(b);\nrecomputung \"oneperiod\"\n>> subplot(2,1,2);plot(c)\n```\n\n\n\n\nLet's look at a simpler input:\n\n```\n>> z=zeros(size(a));\n>> z(10)=1;\n>> subplot(2,1,1);plot(pseudoifft(z))\n>> z(19)=0.2;\n>> subplot(2,1,2);plot(pseudoifft(z))\n```\n\n\n\n\n\n\nNote 1: In your question you specifically ask to use the FFT. The FFT is simply a every efficient way of computing the forward and inverse DFT. The code above computes the inverse DFT in O(n^2), the FFT would compute the same result in O(n log n). Unfortunately, the FFT is an algorithm built on the properties of the complex exponential used in the DFT, and the same algorithm would not be possible if one were to replace that complex exponential with any other function.\n\nNote 2: I use a cosine function in the inverse DFT. It should of course be a complex exponential. But I'm just taking a shortcut assuming that the data being inverse-transformed is conjugate symmetric. This is always the case if the input to the forward transform is real (the output of the inverse transform must be real too, the complex components of two frequencies cancel out because of the conjugate symmetry).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Javascript\r\n                \r\nI need a FFT function like the FFT in ```\nnumpy```\n (python) that takes only ONE list( length doesnt necessarily need to be power of 2).\n\nI used ```\ndsp.js```\n but it needs the Buffer size and buffer size must be power of 2 but my data length is 500.\n\nis there any library that isnt audio exclusive ? \nor should I add ```\n0```\n to end of array ?\n    ", "Answer": "\r\nYou absolutely can pad with zeros to reach the desired size.  See this reference: http://www.bitweenie.com/listings/fft-zero-padding/\n\nA quote straight from the article:\n\n\n  There are a few reasons why you might want to zero pad time-domain data. The most common reason is to make a waveform have a power-of-two number of samples. When the time-domain length of a waveform is a power of two, radix-2 FFT algorithms, which are extremely efficient, can be used to speed up processing time. FFT algorithms made for FPGAs also typically only work on lengths of power two.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to plot fast-fourier transform data as a function of frequencies in Python?\r\n                \r\nI am new to Scipy and still learning about structuring data in the NumPy array. Can someone please help me resolve the following :\nMy data array consists of 10 columns and 110 rows. I am unable to get the right number of freq points.\nI want to:\n\nMatch the array shapes to ultimately plot frequency points using scipy's ```\nrfftfreq```\n\nPad zeros to my data before computing th fast fourier transform\n\nHere is my code:\nI am converting the dataframe to numpy array and extracting ```\nx```\n and ```\ny```\n data\n```\nxdata=np.array(combine.iloc[:,0:20:2])          #both x and y data shapes are (110,10) #the data corresponds to positions in mm \nydata=np.array(combine.iloc[:,1:20:2])\n```\n\nI compute the fft:\n```\nfftdata=fft(ydata)                             # array of 110 by 10 \nfftlen = len(fftdata)                          # size is 1 and value 110\ntime = (2*fftlen*xdata*0.0075e-3)/c/1e-12      # the numbers are constants #time axis is generated from x data with different delay position of the laser beam\ntimestep=abs(xdata[fftlen-1]-xdata[0])/(fftlen-1)/0.1499 #sampling rate\n\nsample_size=fftdata.size                        # size is 1 and value of 1100\n\nfreq = rfftfreq(sample_size, d=timestep)        \n# shape is (551,) - (N/2)nyquist points \n\nplt.plot(freq,fftdata[0:(fftlen//2+1)])\n\n```\n\nBut, I am getting this error\n```\nError : x and y must have same first dimension, but have shapes (551,) and (56, 10)\n```\n\nI understand that these cannot be plotted due to different shapes. But I would like to apply FFT to the whole of my array (110,10) instead of loading individual files to different NumPy arrays. I would very much appreciate it if anyone could also help me with padding zeros to ```\nxdata```\n and ```\nydata```\n before computing the FFT to improve the frequency domain resolution.\n    ", "Answer": "\r\nThe example in numpy documentation is all you need :\n```\nimport numpy as np\n\n# Let's say here is your signal\nsignal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)\n\nfourier = np.fft.rfft(signal)\nn = signal.size\nsample_rate = 100\nfreq = np.fft.fftfreq(n, d=1./sample_rate)\n```\n\n```\n>> freq\n array([  0.,  10.,  20., ..., -30., -20., -10.])\n```\n\nbut when you apply ```\nrfftfreq```\n, you get only positive frequencies:\n```\nfreq = np.fft.rfftfreq(n, d=1./sample_rate)\n```\n\nSo if you want to plot something you take only the corresponding half of values (in the fourier transform magnitude for example).\n```\n>> freq\n array([  0.,  10.,  20., 40., 50.])\n```\n\nTo perform zero-padding, you can just use ```\nnp.pad```\n\n```\nnp.pad(signal, (2,2), 'constant', constant_values=(0,0))\n\n```\n\nThis added 2 zero values in the beginning and the end of the array. Multiple options are possible. Check this https://numpy.org/doc/stable/reference/generated/numpy.pad.html\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "react native how to use fast fourier Transform with my data\r\n                \r\nMy team want to evaluate and check micro current through a sensor and bluetooth to react-native app when someone workout.\nI have a list of voltage powers from workout.\nexample) list = [1023,300,200,500,...]\nXaxis is index(This will change to time).\nYaxis is voltage.\nMy Maximum size is 1023(max is 1024-1)\n\nI want to make this data into frequency and amplitude graph(linear graph that I can know I am doing good on my workout)\nMy mentor said me to use the fast fourier transform.\nBut it doesn't matter if I use different algorithm or just integral to make the list data to frequency and amplitude  linear graph.\n\nThere was no react-native library, I have searched some npm library such as fft-js, fft.js, dsp.js\nfrom here https://npm.io/search/keyword%3Afft/1\nBut I don't know how to use them. I really don't understand where to put my data when I use the library.\nfor instance, https://npm.io/package/fft.js\n```\nconst FFT = require('fft.js');\nconst f = new FFT(4096);\n// what is the size meaning? It means my voltage maximum height? which is 1024?\nconst input = new Array(4096);\ninput.fill(0);\nconst out = f.createComplexArray();\n\n//where to put my data to realInput variable??\nconst realInput = new Array(f.size);\nf.realTransform(out, realInput);\n```\n\nIf there is an example GitHub code, it would be really helpful..\nIf someone made it, would you please help me?\n    ", "Answer": "\r\nI have found out signal data should be power of 2. It worked well.I used fft-js npm library\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Strange artefact in my Fourier transform\r\n                \r\nI have performed an fft (fast fourier transform) on a time series waveform in Matlab, but I seem to have a weird wave actually in the fourier transform plot, although there are spikes this wave looks like something I'd expect to see only in the time domain. Is there any programming reason why this could happen?\n    ", "Answer": "\r\nThe Fourier transform is quite similar to the Inverse Fourier Transform. A spike in one is a wave in the other. Hence, if you have one outlier datapoint in your series, you'll have a wave component in the frequency domain. \n\nA possible programming-related issue could be an uninitialized data point, e.g. providing 1023 datapoints to a 1024-point FFT. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast fourier transformation in python using scipy\r\n                \r\nI am using scipy.fft module for calculating Fourier transformation of an array. Now using the module I got the transformation. But my question is how do I know the elements in the transformed array corresponds to which frequency.\nIn short, the module scipy.fft.fft takes an array as input, how it knows that at which frequencies transformation has to be determined.\n    ", "Answer": "\r\nThe ```\nscipy.fft.fftfreq()```\n helper function calculates the frequencies corresponding to the discrete values in the array returned by ```\nscipy.fft.fft()```\n.\nAs an example, assume that you have a signal sampled every 0.25 seconds and it is 10 samples long:\n```\nfrom scipy import fft\n\nn = 10  # number of samples\nd = 0.25  # sample spacing\n\nfrequencies = fft.fftfreq(n, d)\nprint(frequencies)\n```\n\nwhich outputs:\n```\n[ 0.   0.4  0.8  1.2  1.6 -2.  -1.6 -1.2 -0.8 -0.4]\n```\n\nThese correspond to the center frequencies of the bins in your transformed array.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier Transform of experimental Data\r\n                \r\nI've tried to do a fast fourier transform in Matlab of some data taken from an experiment in the windtunnel trying to show the frequency of the velocity variation in a flow, but somehow I keep on getting 0Hz as the main frequency. Anyone has encountered this problem before and knows how to solve it or can explain me a bit better how to do the frequency transform.\n\nPs: It seems to be doing the fast fourier transform alright, the problem might be when converting the data from imaginary to real values\n\nHelp me please!\n\nThank you!\n    ", "Answer": "\r\nThis is a pretty normal thing to encounter. The 0 Hz component (often referred to as the DC component in analogy to the electrical equivalent) is the constant, non-time-varying component of the data -- it's equivalent to the mean of the data. If you have data that does not have a mean of zero, this is a very normal thing to see.\n\nIf you want to, you can calculate the mean and then subtract it from your data series, but this is not really necessary, since it will only change that DC component of the FFT. If you're not interested in the DC component for your purposes, you can simply ignore it.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform in MATLAB\r\n                \r\nI have found a bit of code in MATLAB:\n```\ny = fft(y, nfft);\n```\n\nWhere y is a 512x443 two-dimensional array and nfft = 512.\nI thought that fft is for a one-dimensional array and for a two-dimensional array there should be fft2, but fft is working. How is that possible?\n    ", "Answer": "\r\nFrom the documentation (emphasis mine):\n\nY = fft(x) returns the discrete Fourier transform (DFT) of vector x, computed with a fast Fourier transform (FFT) algorithm.\nIf the input X is a matrix, Y = fft(X) returns the Fourier transform of each column of the matrix.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why the need for a mask when performing Fast Fourier Transform?\r\n                \r\nI'm trying to find out the peak frequencies hidden in my data using the fft() method in R. While preparing the data, a more experienced user recommends to create a \"mask\" (more after explaining the details), that does give me the exact diagram I'm looking for. The problem is, I don't understand what it does or why it's needed.\n\nTo give some context, I'm working with .txt files with around 12000 entries each. It's voltage vs. time information, and the expected result is just a sinusoidal wave with a clear peak frequency that should be close to 1-2 Hz. This is an example of what one of those files look like:\n\n\n\nI've been trying to use the Fast Fourier Transform method fft() implemented in R to find the peak frequencies and get a diagram that reflected them clearly. At first, I calculate some things that I understand are going to be useful, like the Nyquist frequency and the range of frequencies I'll show in the final graph:\n\n```\n    n = length(variable)\ndt = time[5]-time[4] \ndf = 1/(max(time))  #Find out the \"unit\" frequency\nfnyquist = 1/(2*dt) #The Nyquist frequency\n    f = seq(-fnyquist, fnyquist-df, by=df) #These are the frequencies I'll plot\n```\n\n\nBut when I plot the absolute value of what fft(data) calculates vs. the range of frequencies, I get this:\n\n\n\nThe peak frequency seems to be close to 50 Hz, but I know that's not the case. It should be close to 1 Hz. I'm a complete newbie in R and in Fourier analysis, so after researching a little, I found in a Swiss page that this can be solved by creating a \"mask\", which is actually just a vector with a repeatting patern (1, -1, 1, -1...) with the same length as my data vector itself:\n\n```\n    mask=rep(c(1, -1),length.out=n)\n```\n\n\nThen if I multiply my data vector by this mask and plot the results:\n\n```\n    results = mask*data\n    plot(f,abs(fft(results)),type=\"h\")\n```\n\n\nI get what I was looking for. (This is the graph after limiting the x-axis to a reasonable scale).\n\n\nSo, what's the mask actually doing? I undestand it's changing my data point signs in an alternate manner, but I don't get why it would take the infered peak frequencies from ~50 Hz to the correct result of ~1 Hz.\n\nThanks in advance!\n    ", "Answer": "\r\nYour \"mask\" is one of two methods of performing an fftshift, which is commonly done to center the 0 Hz output of an FFT in the middle of a graph or plot (instead of at the left edge, with the negative frequencies wrapping around to the right edge).\n\nTo perform an fftshift, you can hetrodyne or modulate your data (by Fs/2) before the FFT, or simply do a circular shift by 50% after the FFT.  Both produce the same result.  They are the same due to the shift property of the DFT.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in Android\r\n                \r\nWhere can I find a free, very quick, and reliable implementation of FFT in Android? Only I have left to do a porting of the FFT of Matlab in Android to finish the Proyect of the end of career. Thank you for all!\n    ", "Answer": "\r\ncheck this out: FFT library in android Sdk\n\nI personally am using JFFT pack which runs smoothly at analysing audio with an fft window size of 2048.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Understanding the Spectrum obtained after Fast Fourier Transform application or analyse data\r\n                \r\nI have obtained, data by performing some long task and then tried to obtain the Fast fourier transform of it using below code in python. I have attached two file named RK4_step_Gradient_EF_0.01_Harmonics_Data_0.out.npz and RK4_step_Gradient_EF_0.01_Harmonics_Data_1.out.npz on link given below, I used this to obtain the FFT by loading it in the python.\nBut, the spectrum obtained is different from one another. As in figure the blue graph corresponding to data\"RK4_step_Gradient_EF_0.01_Harmonics_Data_0.out.npz\" shows less harmonics, while orange graph with data - \"RK4_step_Gradient_EF_0.01_Harmonics_Data_1.out.npz\" shows many harmonics.\nI want to understand or see how is the data in orange is different from blue. Why does orange curve shows many harmonics as compared to blue curve Or Which part of data in orange curve contributes to so many harmonics. As this is very important for me to analyse. I have tried a lot but cannot understand which data of orange produces so many harmonics. Hence I request if someone can help me to analyse the data or spectrum.\nIn one way I am trying to do reverse process like using spectrum and data, I am trying to see which part of data led to this many harmonics in orange curve as compared to blue curve.\nI humbly request to please please help.\nThank you so much for reading my post.\nHarmonics with Blue and Orange curve\nData Link\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.fftpack import fft, fftfreq, fftshift\nimport matplotlib.pyplot as plt\nfrom numpy import zeros\nimport math\nfrom matplotlib.ticker import ScalarFormatter\nimport plotly.tools as tls\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, iplot\nimport plotly.graph_objects as go\nimport matplotlib as mpl\nfrom mpl_toolkits.mplot3d import axes3d\nsns.set(style=\"whitegrid\")\nimport plotly.io as pio\npio.templates.default = \"simple_white\"\n\nf_name = 'RK4_step_Gradient_EF_0.01_Harmonics_Data_0.out.npz'\n    \ndat_article     = np.load(f_name)\n\n\nAcceleration_x     = dat_article['ax_listG']\nAcceleration_y     = dat_article['ay_listG']\n\n#Fast Fourier Transform\n\nN = 200000\naf_y = fft(Acceleration_y)\naf_x = fft(Acceleration_x)\n\nayf = (af_x**2 + af_y**2)\nay = fftshift(ayf)\n\nxf = fftfreq(N,0.001e-15)\nxf_1 = fftshift(xf)/(37.5e13)\n\nfig = go.Figure()\n\nfig.add_trace(\ngo.Scatter(x=xf_1,y=(1.0/N * np.abs(ay))) )\nfig.update_xaxes(range=[0, 50])\n\nfig.update_layout(yaxis_type=\"log\", title=\"Velocity & Position equal to 0,  Gradient = 0, -1/1e-9\",\n          xaxis_title=\"Harmonic order(ω/ω0)\",\n          yaxis_title=\"FFT of acceleration\",\n          font=dict(family=\"Arial\",size=14,color=\"RebeccaPurple\")) \n\n\nfig.update_layout(legend=dict(\n                                orientation=\"h\",\n                                yanchor=\"bottom\",\n                                y=1.02,\n                                xanchor=\"right\",\n                                x=1\n                            ))\nfig.update_layout(\n    xaxis = dict(\n        tickmode = 'linear',\n        tick0 = 1,\n        dtick = 1\n    )\n)\nfig.write_html(\"Harmonic.html\")\n\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform: using templated derived classes 'undefined reference' error even though header and .cpp file match\r\n                \r\nI'm coding a Fast Fourier Transform algorithm that does the Cooley Tukey method recursively using complex vectors.  The header file and the .cpp file match in parameter name and syntax, but I get the 'undefined reference' error still.  Due to the \"extra\" allocator parameter being mentioned in the error.  I think this might have something to do with using a template for our abstract base class and derived Cooley-tukey class.  All of the problems have come from the FFF_REC function that recursively divides up the input.\n\nGithub: https://github.com/ProgrammerB/Fourier-Transform-Terminal-/blob/master/classes/cooley-tukey.h \n\nI've already tried to change my parameters to references and add a private member into the cooley-tukey class, but I get the same error.  \n\nCooley-Tukey Class:\n\n```\ntemplate<typename T>\nclass Cooley_tukey: protected Fourier<T>{\npublic:\n    Cooley_tukey();\n    Cooley_tukey(std::string file_name, double frequency, double, \n      frequency_step, std::string output_name);\n    //~Cooley_tukey();\n\n    void FFT(const std::vector<T> &index, const std::vector<T> &value);\n\n    std::vector<complex<T>> FFT_REC(std::vector<complex<T>> &temp, int \n      total_time); //recursion function for FFT\n\nprivate:\n    int total_time;\n```\n\n\n};\n\nPart of the error:\n\n```\nclasses\\cooley-tukey.cpp:91:10: error: no matching function for call to \n'Cooley_tukey<double>::FFT_REC(std::vector<std::complex<double>, \nstd::allocator<std::complex<double> > > [(total_time / 2)], int, \nstd::vector<std::complex<double>, std::allocator<std::complex<double> > \n>&)'FFT_REC(odd, total_time/2, result);\n```\n\n\nFFT-Recursion function(source of errors):\n\n```\n    template<typename T>\n    std::vector<complex<T>> Cooley_tukey<T>::FFT_REC(std::vector<complex<T>>& temp, int total_time)\n    {\n        // Check if it is split up enough\n        if (total_time >= 2)\n        {\n\n            // Split even and odds up\n            std::vector<complex<T>> odd[total_time/2];\n            std::vector<complex<T>> even[total_time/2];\n            for (int i = 0; i < total_time / 2; i++)\n            {\n                even->at(i) = temp.at(i*2);\n                odd->at(i)  = temp.at(i*2+1);\n            }\n\n            // Split up tasks through FFT recursion method\n            FFT_REC(even, total_time/2);\n            FFT_REC(odd, total_time/2);\n\n\n            // DFT portion of FFT - calculates after everything has been split up through FFT_REC\n            for (int frequency = 0; frequency < total_time / 2; frequency += this->frequency_step)\n            {\n                std::complex<T> t = exp(std::complex<T>(0, -2 * M_PI * frequency / total_time)) * odd->at(frequency);\n\n                //Result of Cooley-Tukey algorithm:\n                    //*This gives us the frequency values at certain times\n                temp.at(frequency) = even->at(frequency) + t;\n                temp.at(total_time / 2 + frequency) = even->at(frequency) - t;\n\n            }\n        }\n        return temp;\n    }\n\n    template class Cooley_tukey<double>;\n```\n\n    ", "Answer": "\r\nYou’re creating an array of vectors as ```\neven```\n/```\nodd```\n whereas you should just have a vector. The error says there isn’t a method that takes an array of vectors. \n\nI assume you mean:\n\n```\n// Split even and odds up\nstd::vector<complex<T>> odd;\nstd::vector<complex<T>> even;\nodd.reserve(total_time/2);\neven.reserve(total_time/2);\nfor (int i = 0; i < total_time / 2; i++)\n{\n    even.push_back(temp.at(i*2));\n    odd.push_back(temp.at(i*2+1));\n}\n```\n\n\nYou were also trying to use the ```\nat()```\n to set values into empty vectors which would’ve caused errors. Vectors may not have any storage allocated and if you try to index them with ```\nat()```\n you’ll get an exception when it goes out of bounds. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform: using templated derived classes 'undefined reference' error even though header and .cpp file match\r\n                \r\nI'm coding a Fast Fourier Transform algorithm that does the Cooley Tukey method recursively using complex vectors.  The header file and the .cpp file match in parameter name and syntax, but I get the 'undefined reference' error still.  Due to the \"extra\" allocator parameter being mentioned in the error.  I think this might have something to do with using a template for our abstract base class and derived Cooley-tukey class.  All of the problems have come from the FFF_REC function that recursively divides up the input.\n\nGithub: https://github.com/ProgrammerB/Fourier-Transform-Terminal-/blob/master/classes/cooley-tukey.h \n\nI've already tried to change my parameters to references and add a private member into the cooley-tukey class, but I get the same error.  \n\nCooley-Tukey Class:\n\n```\ntemplate<typename T>\nclass Cooley_tukey: protected Fourier<T>{\npublic:\n    Cooley_tukey();\n    Cooley_tukey(std::string file_name, double frequency, double, \n      frequency_step, std::string output_name);\n    //~Cooley_tukey();\n\n    void FFT(const std::vector<T> &index, const std::vector<T> &value);\n\n    std::vector<complex<T>> FFT_REC(std::vector<complex<T>> &temp, int \n      total_time); //recursion function for FFT\n\nprivate:\n    int total_time;\n```\n\n\n};\n\nPart of the error:\n\n```\nclasses\\cooley-tukey.cpp:91:10: error: no matching function for call to \n'Cooley_tukey<double>::FFT_REC(std::vector<std::complex<double>, \nstd::allocator<std::complex<double> > > [(total_time / 2)], int, \nstd::vector<std::complex<double>, std::allocator<std::complex<double> > \n>&)'FFT_REC(odd, total_time/2, result);\n```\n\n\nFFT-Recursion function(source of errors):\n\n```\n    template<typename T>\n    std::vector<complex<T>> Cooley_tukey<T>::FFT_REC(std::vector<complex<T>>& temp, int total_time)\n    {\n        // Check if it is split up enough\n        if (total_time >= 2)\n        {\n\n            // Split even and odds up\n            std::vector<complex<T>> odd[total_time/2];\n            std::vector<complex<T>> even[total_time/2];\n            for (int i = 0; i < total_time / 2; i++)\n            {\n                even->at(i) = temp.at(i*2);\n                odd->at(i)  = temp.at(i*2+1);\n            }\n\n            // Split up tasks through FFT recursion method\n            FFT_REC(even, total_time/2);\n            FFT_REC(odd, total_time/2);\n\n\n            // DFT portion of FFT - calculates after everything has been split up through FFT_REC\n            for (int frequency = 0; frequency < total_time / 2; frequency += this->frequency_step)\n            {\n                std::complex<T> t = exp(std::complex<T>(0, -2 * M_PI * frequency / total_time)) * odd->at(frequency);\n\n                //Result of Cooley-Tukey algorithm:\n                    //*This gives us the frequency values at certain times\n                temp.at(frequency) = even->at(frequency) + t;\n                temp.at(total_time / 2 + frequency) = even->at(frequency) - t;\n\n            }\n        }\n        return temp;\n    }\n\n    template class Cooley_tukey<double>;\n```\n\n    ", "Answer": "\r\nYou’re creating an array of vectors as ```\neven```\n/```\nodd```\n whereas you should just have a vector. The error says there isn’t a method that takes an array of vectors. \n\nI assume you mean:\n\n```\n// Split even and odds up\nstd::vector<complex<T>> odd;\nstd::vector<complex<T>> even;\nodd.reserve(total_time/2);\neven.reserve(total_time/2);\nfor (int i = 0; i < total_time / 2; i++)\n{\n    even.push_back(temp.at(i*2));\n    odd.push_back(temp.at(i*2+1));\n}\n```\n\n\nYou were also trying to use the ```\nat()```\n to set values into empty vectors which would’ve caused errors. Vectors may not have any storage allocated and if you try to index them with ```\nat()```\n you’ll get an exception when it goes out of bounds. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform on Python\r\n                \r\nI would like some guidance on the proper way to compute a FFT on python for a real, non-periodic signal. I am relatively new to coding and signal analysis, so this post will contain questions relatives to both domains.\nTo give some context, here is a graphical representation of my signal (time domain):\n\nand this is the data I am working from:\n```\nt_norm  acc_norm\n1   0.000000  0.000000\n2   0.031918  2.336610\n3   0.063340  1.817758\n4   0.095058  0.544868\n5   0.126293 -0.953833\n6   0.157302  0.217959\n7   0.188844 -1.331151\n8   0.219892 -1.548037\n9   0.251234  2.288458\n10  0.282859  2.837413\n11  0.314361  1.835081\n12  0.345838  1.659622\n13  0.376913  1.309823\n14  0.408362  1.035765\n15  0.439503  0.771576\n16  0.470980  1.235591\n17  0.502364  2.456847\n18  0.533518  1.668552\n19  0.564633  1.076637\n20  0.595747  1.377580\n21  0.626756  0.673881\n22  0.658192  0.529822\n23  0.689240  0.483709\n24  0.720207  1.354278\n25  0.751281  2.072109\n26  0.782463  1.027122\n27  0.813699  0.333459\n28  0.844841  0.406036\n29  0.875902  0.401840\n30  0.906883  0.044780\n31  0.937957  0.557944\n32  0.968992  1.962894\n33  1.000000  1.446186\n```\n\nNote that the device used to record the signal use a variable rate sampling with cross detection to capture data points. It limits (down samples) this to a maximum of 50 points per seconde (50Hz). I have made an histogram to show the distribution of the time intervals between measurements of all my datas :\n\nMETHODOLOGICAL QUESTIONS:\n\nIn regards to the overall shape of my signal (Fig 1), should I detrend it before doing the FFT (I am only interested in the high frequencies) ?\n\nDoes the FFT necessarily require to resample the datas if the rate of sampling is not uniform, even if the distribution of the time intervals between measurements is not really spread out (Fig 2) ?\n\n\nTECHNICAL QUESTIONS (PYTHON):\n\nAll the examples I have seen on internet on how to compute a FFT works from a synthetic signals (directly made in python). I have tried to reproduce the methodology used and adapt it to fit for my signal derived from 'real world' data. The first steps seems to be to calculate some characteristics of the signal, and then to compute the FFT.\nSignal characteristics\nspl_nbr =    # number of sample of the signal\nd_fs =       # sampling frequency, hertz\ni_ns = (2*d_fs)\nd_time = np.linspace(0, (i_ns-1), i_ns)/d_fs # Time series, seconds\nd_f_sig =    # signal freqeuncy, hertz\nd_sig =      # signal itself\nCompute the FFT\ncx_y = rfft(d_sig)/float(i_ns/2.)\nd_ws = rfftfreq(i_ns,1./d_fs)\n\n\nTherefore, I would like to know how to calculate each elements from my datas. I know I can use ```\n.count()```\n function to calculate the number of sample of the signal, but that is pretty much all I can do for now. I am especially wondering on how I should pass the signal information (d_sig) to python.\nThank you in advance for your contributions, and feel free to comment on things that I could be missing in my approach !\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "MemoryError during Fast Fourier Transform on an image using NumPy arrays under Windows\r\n                \r\nThe code could compute Fourier transform from a ```\n.tiff```\n image on my Ubuntu 11.04. On Windows XP it produces memory error. What to change? Thank you.\n\n```\ndef fouriertransform(result):     #function for Fourier transform computation\n    for filename in glob.iglob ('*.tif')\n        imgfourier = scipy.misc.imread(filename) #read the image\n        arrayfourier = numpy.array([imgfourier])#make an array \n        # Take the fourier transform of the image.\n        F1 = fftpack.fft2(arrayfourier)\n        # Now shift so that low spatial frequencies are in the center.\n        F2 = fftpack.fftshift(F1)\n        # the 2D power spectrum is:\n        psd2D = np.abs(F2)**2\n        L = psd2D\n        np.set_printoptions(threshold=3)\n        #np.set_printoptions(precision = 3, threshold = None, edgeitems = None, linewidth = 3, suppress = True, nanstr = None, infstr = None, formatter = None)\n        for subarray in L:\n            for array in subarray:\n                for array in subarray:\n                    for elem in array:\n                        print '%3.10f\\n' % elem\n```\n\n\nThe error output is:\n\n```\nTraceback (most recent call last):\n  File \"C:\\Documents and Settings\\HrenMudak\\Мои документы\\Моя музыка\\fourier.py\", line 27, in <module>\n    F1 = fftpack.fft2(arrayfourier)\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 571, in fft2\n    return fftn(x,shape,axes,overwrite_x)\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 521, in fftn\n    return _raw_fftn_dispatch(x, shape, axes, overwrite_x, 1)\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 535, in _raw_fftn_dispatch\n    return _raw_fftnd(tmp,shape,axes,direction,overwrite_x,work_function)\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 463, in _raw_fftnd\n    x, copy_made = _fix_shape(x, s[i], waxes[i])\n  File \"C:\\Python27\\lib\\site-packages\\scipy\\fftpack\\basic.py\", line 134, in _fix_shape\n    z = zeros(s,x.dtype.char)\nMemoryError\n```\n\n    ", "Answer": "\r\nI've tried to run your code, except that I replaced the ```\nmahotas.imread```\n with the ```\nscipy.misc.imread```\n function, because I don't have that library, and I could not reproduce your error.\n\nSome further remarks:\n\n\ncan you try to use the ```\nscipy.misc.imread```\n function instead of the ```\nmahotas```\n function? I suppose the issue could be there\nwhat is the actual exception that is thrown? (+other output?)\nwhat are the dimensions of your image? Gray-scale / RGB? Printing all values for a large image could indeed take up quite some memory, so it might be better to visualize the results with e.g. matplotlibs ```\nimshow```\n function.\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to create the complex representation from magnitude and phase information to perform an inverse fast fourier transform(IFFT)? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        FFT Images and its Inverse\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have a problem with converting amplitude and phase data into the complex form, which is required to perform an IFFT. (inverse fast fourier transform). This is the only data I have. \n\nMy frequency range goes from 0.1 to 2.6 and, with 200 samples. I would like to use IFFT to obtain a time signal. How do I convert this magnitude and phase dataset into the complex plane?\n\nI have never used IFFT (Or fft) before, so some helpful insights would be very helpful!\n    ", "Answer": "\r\nAssuming you want the complex representation like this:\n\n```\na = 3+4i; \nmagnitude = abs(a);\nphase = angle(a);\n```\n\n\nyou should have magnitude = 5, and theta = 0.9273 \n\nNow to inverse and obtain back your complex representation, use the formula:\n\n```\n z = magnitude*exp(i*phase)\n```\n\n\nif all goes correctly, you should have the complex representation back.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Inverse Fast Fourier Transform Implementation\r\n                \r\nI'm trying to program a FFT algorithm in Python and I've got the initial transform working. It takes in a polynomial in vector form and spits out the evaluation of that vector at the complex roots of unity. The issue arises in my Inverse FFT. This is supposed to take in the evaluation of a function at the complex roots and return the polynomial that passes through those points. This second half is nearly identical to the first, but it uses the inverse of the complex roots. The output of this is scaled by the number of input points, so each coefficient is divided by that number.\nMy code looks like:\n```\nimport math\n\nfrom cmath import sqrt\n\n\ndef getNthRoots(n):\n    # Determines how many roots are needed. Only works for powers of two.\n\n    targetLength = math.pow(2, math.ceil(math.log(n, 2)))\n    newOutput = [1.0 + 0j]\n\n    # Starting with just 1, it takes the sqrt of each term and appends it. Then it appends a negative copy of the list.\n\n    while len(newOutput) < targetLength:\n        previous = newOutput\n        newOutput = []\n\n        for item in range(len(previous)):\n            newOutput.append(sqrt(previous[item]))\n\n        for item in range(len(newOutput)):\n            newOutput.append(newOutput[item] * -1)\n\n    return newOutput\n```\n\nThis works excellently.\n```\ndef FFT(inputList, rootsOfUnity):\n    # End case for the loop\n\n    if len(inputList) == 1:\n        return [inputList[0]]\n\n    # Splits the input list into two parts, one even and one odd\n\n    evenList = [inputList[2 * x] for x in range((len(inputList) // 2))]\n\n    oddList = [inputList[(2 * x) + 1] for x in range(len(inputList) // 2)]\n\n    # Takes the \"square\" of the roots of unity. This is the same as just taking every other entry.\n\n    newRootsOfU = [rootsOfUnity[2 * x] for x in range((len(rootsOfUnity) // 2))]\n\n    # Calls itself with the even and odd halves and the shortened roots of unity\n\n    evenTransform = FFT(evenList, newRootsOfU)\n\n    oddTransform = FFT(oddList, newRootsOfU)\n\n    outputs = []\n\n    # Calculates the output for each root of unity\n\n    for x in range(len(rootsOfUnity)):\n        outputs.append(evenTransform[x % (int(len(rootsOfUnity) / 2))] + rootsOfUnity[x] * oddTransform[\n            x % (int(len(rootsOfUnity) / 2))])\n\n    return outputs\n\nPolyVec1 = [1, 5, 3, 2]\n\n# addZeros just attaches zeros until the length of the list is a power of two\nPolyVec1 = addZeros(PolyVec1)\n\n# Converts PolyVec1 into point form\nrootsOfUnity = getNthRoots(len(PolyVec1))\n\nPolyPoint1 = FFT(PolyVec1, rootsOfUnity)\ntoBeInverted = getNthRoots(len(PolyVec1))\nInvertedRoots = [1 / i for i in toBeInverted]\nreversedFFT1 = FFT(PolyPoint1, InvertedRoots)\nprint(reversedFFT1)\nreversedFFT1Final = [abs(i) / len(reversedFFT1) for i in reversedFFT1]\nprint(reversedFFT1Final)\n```\n\nThis code works fine for converting a polynomial into a series of points. However, when I try and use it to find the inverse it doesn't work for polynomials of a degree greater than 3.\nAny idea why?\nEdit:\nI've had some new insights. The output for any polynomial\n[a, b, c, d, e, f, g, h]\nis\n[a, y, c, z, e, y, g, z]\na, c, e, and g are all consistently interpolated, but b, d, f, and h are not. b and f are replaced by the same value and d and h are replaced by a different value. As long as b and f are identical and d and h are identical, the output will be correct.\nEdit:\nMore insight. It has something to do with complex numbers. No matter the input, a, c, e, g always have no complex component and when b and f or d and h are identical, the output has no complex component. When there is a complex component, the output is incorrect.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "C++ Image 2D Fast Fourier Transform\r\n                \r\nI have to implement 2D FFT transform on the image (I cannot use library to do it for me - part of the course). I use ```\nCImg```\n to load and save images. I have made the following code:\n\n```\nCImg<Complex> FastFourier(CImg<unsigned char> &originalImage)\n{\n    //check size in the main.cpp\n    CImg<Complex> resultantImage = TransformToComplex(originalImage);\n    vector< vector< vector< Complex > > > vectorImage = imageToVector(resultantImage);\n    //cout << \"Transform to complex\" << endl;\n    int size = originalImage.width();\n\n    for(int i = 0; i < size; i++)\n        FastFourier1D(vectorImage[i], false);\n\n    vectorImage = rotateVector(vectorImage);\n\n    for(int i = 0; i < size; i++)\n       FastFourier1D(vectorImage[i], false);\n\n    vectorImage = rotateVector(vectorImage);\n\n    resultantImage = vectorToImage(vectorImage);\n\n    return resultantImage;\n}\n```\n\n\nAnd:\n\n```\nvoid FastFourier1D(vector< vector< Complex > > &input, bool inverse)\n{\n    int size = input.size();\n    double angle;\n\n    if(size <= 1)\n        return;\n\n    int channels = input[0].size();\n    vector< vector< Complex > > even;\n    vector< vector< Complex > > odd;\n\n    for(int i = 0; i < size; i+=2)\n    {\n        vector< Complex > tempEven;\n        vector< Complex > tempOdd;\n        for(int channelIterator = 0; channelIterator < channels; channelIterator++)\n        {\n            tempEven.push_back(input[i][channelIterator]);\n            tempOdd.push_back(input[i + 1][channelIterator]);\n        }\n\n        even.push_back(tempEven);\n        odd.push_back(tempOdd);\n    }\n\n    FastFourier1D(even, inverse);\n    FastFourier1D(odd, inverse);\n\n    for(int channelIterator = 0; channelIterator < channels; channelIterator++)\n    {\n        for(int i = 0; i < size / 2; i++)\n        {\n           if(inverse == false)\n               angle = -2.0 * (double)PI * (double)i / (double)size;\n           else\n               angle = 2.0 * (double)PI * (double)i / (double)size;\n\n           double real = cos(angle);\n           double imaginary = sin(angle);\n\n           Complex W;\n           W.setRP(real);\n           W.setIP(imaginary);\n\n           W = W * odd[i][channelIterator];\n\n           input[i][channelIterator] = even[i][channelIterator] + W;\n           input[(size / 2) + i][channelIterator] = even[i][channelIterator] - W;\n       }\n    }\n}\n```\n\n\nHowever the results are not good. Input image:\n\n\nFFT (without any transform):\n\n\nInverse FFT:\n\n\n\nAs you can see, it has colors of lena, but does not look like lena. Could you help me? Is there any mistake?\n    ", "Answer": "\r\nI found out that the answer was an incorrect implementation of multiplication operator in my ```\nComplex```\n class.\n\n```\nComplex Complex::operator*(const Complex& a)\n{\n    Complex number;\n    double RP = realPart * a.getRP() - imaginaryPart * a.getIP(); // this line was wrong\n    double IP = realPart * a.getIP() + imaginaryPart * a.getRP();\n    number.setRP(RP);\n    number.setIP(IP);\n    return number;\n}\n```\n\n\nIn ```\nreal part```\n, I forgot about ```\nminus```\n. Now the whole implementation is working and fourier successfully converts an image into frequency domain and makes inverse into spatial domain as well.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform polynomial multiplication?\r\n                \r\nI am using the FFT to evaluate a polynomial at certain points so that it can be represented using value representation. (representation as a number of points equal to its degree)\n\nHowever to multiply two polynomials of degree d, I need to evaluate both at 2d + 1 points. However using the FFT for evaluation (multiplying by the dth roots of unity) only evaluates the polynomial at d points. Therefore how can the FFT be used for evaluation for polynomial evaluation if it only evaluates a polynomial at d points? (as opposed to 2d + 1)\n    ", "Answer": "\r\nYou get to choose which n-th roots of -1 you evaluate at. If you need 2d-1 points (as I suspect you do) just use the (2d-1)-th roots of -1. In fact, you would normally use the 2^k-th roots of -1, where 2^k is the first power of 2 >= 2d-1, because it is much easier to get fast FFT for powers of 2. The complexity is still O(d log d) because the definition of O allows for constant factors.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform adjust scaling\r\n                \r\nI'm trying to show trends of my data by doing a FFT. The data I want to perform a FFT on looks like this:\n\n\n\nWithin every year we see a clear trend almost like a sin wave and I thought this should be visible after a FFT transformation but I got this:\n\n\n\nOn the x-axis is hours and on the y-axis the detrended data also in W/m^2. Originally every data point was taken every 16 day within the same year. However, this is not necessarily the case between transitions of two years.\n\nFor the FFT I used this code and the detrended data ```\ndata_plot_multi_year1[\"y\"]-mean(data_plot_multi_year1[\"y\"]```\n can be found here:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nhann = np.hanning(len(data_plot_multi_year1[\"y\"]))\n\nY = np.fft.fft(hann*(data_plot_multi_year1[\"y\"]-mean(data_plot_multi_year1[\"y\"])))\nN = len(Y)/2+1\nfa = 1.0 / (16.0*24*60.0* 60.0)  # every 16th day\nprint('fa=%.7fHz (Frequency)' % fa)\n\nX = np.linspace(0, fa/2, N, endpoint=True)\nXp = 1.0/X                 # in seconds\nXph = Xp /(60.0*60.0*24)   # in days\n\nplt.figure()\nplt.plot(Xph, 2.0 * np.abs(Y[:N]) / N)\nplt.show()\n```\n\n\nSince this is my first time doing something like this, does it need to look like this or how can I make the trends more visible?\n\nThe original data is here: y values and x values.\n    ", "Answer": "\r\nLooking at the original data, I see a very different plot than if I look at the detrended data that you (and the other answers) have used to compute the FFT from.\n\nSo, starting with this original data:\n\n```\nimport numpy as np\nimport matplotlib.pyplt as pp\n\n# Data\ny = np.array([4.9163581574416115, 4.5232489635722359, 5.1418668265986014, 4.7243929349211378, 5.0922668745097237, 3.2505877068809528, 5.266713471351407, 3.2593612955944398, 6.0329599566748149, 5.501028641922999, 3.6033946768899154, 4.0640736190761837, 3.9015401707437629, 4.5497509491042667, 3.7227800407604765, 3.3294036636861795, 3.2400339075816058, 3.4354831362560447, 5.0721090065474757, 4.2898468699869312, 3.9352309911472898, 4.6544147503812772, 3.5076460922078962, 4.8823458504641311, 3.006733596435486, 3.3404353221374912, 4.2604198197171943, 3.5110363901532828, 4.7495904044204913, 4.4755614380567836, 2.8255977501087353, 4.0147937265525631, 4.6982506962329369, 4.1073988606130554, 4.3779635559151062, 3.8455643143910585, 2.8446707334831589, 3.8864340895006602, 5.407473632935444, 3.7776659978957676, 3.7474804428857103, 4.4231421808719968, 4.1145572839087201, 3.4407172122286807, 5.7068484749384503, 3.3175924030243089, 2.8563413179332078, 3.520760038353695, 3.9712227784619754, 5.0318859983482076, 3.7642574784532088, 3.4828932021013372, 3.2259745458147786, 5.032377633970162, 5.2464640619126435, 4.9482379500988491, 3.798306221105471, 3.3672821755011646, 4.8054046257516898, 4.5758461857175972, 4.4079132488332275, 3.5862463276840586, 5.0281771086563696, 3.9038881511201029, 3.5464781504503957, 3.752348181547787, 3.1520445958602115, 4.370394739799015, 3.896389496115487, 4.118225887215103, 4.802537302837913, 4.1800322086907791, 3.9270327778098264, 2.9892139644432794, 3.5412442495098522, 4.9353516122953636, 3.6311330623837823, 3.4788493170853205, 3.4571475745293054, 5.3964493189396956, 4.0166801210413112, 3.184902965087919, 4.3231987474246907, 3.821044625315142, 3.2501749085457448, 4.1218393070599149, 3.4907498564324784, 3.7048147909485549, 4.4067985127175193, 3.2628048471339661, 3.4299356612804384, 3.054687769820104, 3.4394826446333515, 3.8926147692854536, 3.5274891297329392, 5.1600491179626147, 5.1267218406912436, 4.9196604682508616, 3.288844643645831, 5.0123334575721739, 5.8837792219610296, 3.6525485317948769, 5.2655629050160382, 4.5940509381861077, 3.5326474318629821, 4.7549446018611174, 5.5400627941766389, 4.2340183526794908, 3.833235556736899, 4.1055923866919404, 3.9041368756551273, 2.8355474432294439, 5.0365898742249708, 5.558027054794378, 3.0385703101397779, 4.1301188661365806, 3.4824265559683489, 3.9319218096961523, 3.0332372505317466, 4.0506899500473681, 5.298987852183183, 3.2070084334136282, 3.4802868005912773, 3.2223945502453342, 3.6057387919024859, 4.1135183367430654, 5.4774825204501179, 3.7504701089542696, 3.3997275593227916, 4.0280467030451277, 5.1921516666697185, 4.1662957219173871, 4.9276361137412961, 4.3055659900345269, 4.2160192742975298, 4.5582352743558525, 3.5779282232857184, 3.3303571863388153, 4.7062814020334001, 3.763690626719586, 4.020276538555315, 3.2952422897541718, 4.3944836078620826, 5.0651527836251846, 3.2736433168588834, 4.0164274892409875, 4.6926928415631961, 3.5439697283257536, 4.8170195490454715, 5.1717553137007295, 4.47489761280195, 4.2721415529277245, 3.7722293780212186, 4.6163723178866256, 3.4852465925030596, 3.5081857100611429, 4.9526591274218141, 2.7418823869877671, 5.2309064498443112, 2.9584799885836368, 5.9208165893988971, 3.7266204734555268, 3.9696836775155155, 3.0817605147405351, 5.3501874894485368, 4.823298910487158, 4.094371587882315, 3.666534185013655, 4.3613972464934943, 3.5253937700241282, 3.5114759216562974, 3.7387872601144321, 3.2428544820295313, 4.3174760573045647, 3.8153701553661081, 5.3510324878858881, 5.887473202470229, 5.2483141940171967, 3.6730647722321899, 3.2527108096051762, 5.087119161099805, 5.4376786692500971, 5.1985667958007626, 4.0776721320121245, 4.0746559030897966, 5.3838863415603209, 2.9772622863398106, 4.4371692352610923, 4.824375079864156, 5.1574523180746281, 3.6417281403335027, 3.7353723232513896, 4.8786928981111108, 3.1549797688883685, 4.9273350311811477, 4.8909872856262631, 5.0733312023802286, 4.7195548768733193, 3.2117711403989326, 4.0607353048756289, 3.2068686273897913, 3.8104210279601221, 4.0764549403056849, 5.1905644211359325, 4.9059727970323124, 4.3312408753376159, 4.495834529789291, 3.7017758002769088, 3.8928592560408886, 3.3590820111611572, 5.6800192429325946, 5.2801982921123018, 3.4971867534798688, 4.1434397763487363, 5.0320214435810486, 3.2572048463905596, 3.5708589225079157, 5.5420277180979705, 4.816537191178262, 4.7123032533220774, 4.6276901989665546, 3.3033314780041207, 3.7031834923679217, 4.9531169434719784, 3.9520303484745076, 4.7069324020275154, 3.3485205880519819, 3.578929442922882, 5.0416858356367751, 3.2471486950110151, 4.8036517687546469, 2.9564023409041931, 4.370824090704172, 3.3111933909292781, 5.4693269793385397, 5.9471091984264612, 5.5997609124508001, 3.253791264246908, 5.5589687791680173, 4.0347612835986313, 5.0860759232647048, 3.8236359577497381, 4.2502050750154163, 5.3804473886648889, 3.0777806788604702, 4.3119059095678196, 3.6076909731506221, 3.6675311219295414, 4.5761803934468732, 4.1294871300142644, 3.6827073669759471, 3.9918347122796098, 3.4194166080890587, 5.3442479778374041, 3.325200562869143, 5.4364117543671719, 2.7691861112204053, 3.2431028421965107, 5.7997059152735284, 5.1396423172415746, 3.8341163596077106, 4.6158592382839672, 5.2991510313934427, 4.2613846468512486, 3.3747692135915655, 3.7002229064232939, 3.1618285314537342, 5.3066215213431933, 3.4764287458899688, 4.2664404462781276, 3.7020536806298709, 4.4920788644955021, 4.7765300011524729, 3.6234351180642332, 4.2676647387441031, 3.1419131638878253, 5.0149070978243522, 3.6335404191164362, 5.6667351882464283, 3.4029057890404824, 4.1230483413169239, 4.8245272024467116, 3.65830252796454, 4.4813334423826712, 3.6740443622552865, 4.1977102616532935, 4.1320785201142503, 3.1085193591271505, 5.0012055352868723, 4.0428697712217607, 5.201396550122233, 5.5110799401116326, 3.2437611839952023, 4.8397817377344712, 5.4850675142216154, 3.627247179469125, 4.0577205671254726, 2.5798969377153802, 4.6359100698702171, 4.7640011574006191, 5.8635971341249009, 3.6510638760009013, 3.2845760628978011, 5.1435067636186025, 3.8973081092150159, 3.1445177808730125, 3.5112954060023718, 5.5052935046977147, 4.0618208001814811, 5.2828398404225272, 4.8693030005934981, 3.413421242301824, 5.7045184220496115, 5.3221412413004741, 4.3631763041559992, 4.188513180452488, 3.9197228949008855, 4.2780523472142535, 3.695429486781181, 4.8294238192705237, 5.264103644882745, 5.0998049360010391, 5.5094161509890887, 4.3214874721201451, 3.6102609731613162, 5.2723061570113243, 3.8298642965515364, 4.8098072099418445, 3.632970055942816, 3.5542517670129983, 4.9124440128270983, 5.0786806222541223, 5.0248576192789542, 5.0029379966378063, 3.1383857221712161, 5.4119593837374813, 5.2071519069366392, 4.81942138782507, 5.4131759970726518, 4.9823428242283274, 4.0704364655939997, 3.6092965241074735, 4.7229918731679614, 4.7586642729235562, 3.9002260395078925])\nx = np.array([2817, 1960, 3500, 1357, 183, 1482, 1642, 372, 2008, 1626, 2641, 5228, 2865, 4277, 1437, 3612, 359, 752, 5276, 1578, 1754, 1341, 2212, 1261, 4402, 2593, 3054, 4021, 5008, 3420, 676, 3324, 2340, 2136, 4149, 3278, 71, 1024, 4944, 3752, 1181, 628, 2657, 3736, 4594, 3976, 4738, 5132, 5452, 532, 3372, 1546, 2913, 5260, 2753, 2769, 311, 1072, 5340, 3198, 5372, 2625, 1690, 4482, 2990, 4309, 4373, 848, 3356, 295, 1706, 2308, 39, 2244, 4450, 1213, 1149, 4085, 2926, 2372, 3388, 708, 5056, 4816, 5180, 103, 4690, 4706, 2468, 4466, 452, 3720, 1880, 2184, 4752, 2705, 215, 1610, 4008, 3864, 1658, 468, 199, 5388, 3596, 516, 3150, 1738, 5212, 5404, 2881, 1848, 2420, 5308, 4418, 4514, 768, 4053, 2577, 5104, 4960, 3308, 4101, 816, 4784, 1117, 2356, 3656, 4117, 3262, 3118, 644, 1245, 5072, 3784, 2673, 5196, 3960, 3532, 5436, 5040, 4722, 4642, 960, 420, 484, 4880, 5148, 2088, 4229, 1594, 1944, 327, 3912, 784, 1088, 247, 388, 1992, 1466, 3086, 1802, 2484, 4325, 3468, 3166, 1421, 3628, 2452, 2958, 2532, 4386, 23, 1197, 5088, 4546, 2388, 596, 4832, 4357, 1293, 1309, 4992, 4848, 119, 3848, 55, 1008, 3816, 612, 2168, 4768, 5324, 2276, 1976, 2801, 4610, 3516, 3688, 1040, 3992, 4674, 3944, 2056, 4261, 5244, 1722, 4341, 3580, 736, 896, 2785, 3644, 279, 5292, 4037, 1770, 4197, 3038, 976, 3214, 2609, 2500, 3436, 1405, 1229, 1133, 2260, 151, 1896, 3800, 4069, 4133, 4434, 564, 4578, 3102, 2196, 912, 3564, 4896, 5420, 4658, 2721, 87, 2104, 5116, 1928, 2833, 2120, 1056, 3928, 1832, 231, 1498, 2024, 404, 1818, 1674, 3070, 3340, 864, 3484, 4293, 2974, 2548, 343, 2404, 1453, 1389, 1562, 5356, 4165, 2228, 1373, 2561, 4530, 2942, 1277, 692, 1514, 5024, 2516, 4864, 1912, 4800, 2152, 3672, 992, 3246, 3832, 4928, 1165, 2324, 2040, 1864, 3768, 3704, 3880, 2689, 944, 1530, 5164, 2072, 5468, 436, 2897, 4245, 1101, 3134, 3896, 800, 2737, 167, 263, 3404, 3022, 4498, 1786, 1325, 3452, 3182, 880, 2849, 3292, 4976, 832, 2436, 7, 2292, 4562, 548, 4181, 580, 724, 928, 4213, 4626, 4912, 3548, 660, 3230, 135, 500, 3006])\n```\n\n\nWe first notice that the x-values are not sorted. Let's sort the data:\n\n```\n# Sort data on x values\nindex = np.argsort(x)\ny = y[index]\nx = x[index]\n```\n\n\nNext, we notice that the x locations are not evenly spaced. The FFT expects even-spaced data. Let's resample the data to make it evenly spaced:\n\n```\n# Interpolate data so it is regularly sampled\nn = len(x)\nnewx = np.linspace(x[0], x[-1], n)\ny = np.interp(newx, x, y)\nx = newx\n```\n\n\nNow we can confidently compute the FFT and plot, just like in the question:\n\n```\n# Compute FFT and plot\nY = np.fft.fft(y - np.mean(y))\nfa = 365.0 / (x[1] - x[0]) # samples/year\nN = n//2+1\nX = np.linspace(0, fa/2, N)\n\npp.figure()\npp.plot(X, abs(Y[:N])) # I'm ignoring all that scaling here, it's irrelevant...\npp.show()\n```\n\n\n\n\nWe now clearly see a peak at 1 cycle/year, as expected!\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform - Multiplying Polynomials?\r\n                \r\ni just don't understand how to perform a FFT on two polynomials such as X^2+1 and X+1...can anyone step by step go through the process with me?\n\nThanks very much\n    ", "Answer": "\r\nJust use your polynomial coefficients as input for fft:\n\n```\noctave:16> poly1=[1 0 1 0]\npoly1 =\n\n   1   0   1   0\n```\n\n\nNote: this means x^2+1\n\n```\noctave:17> poly2=[1 1 0 0]\npoly2 =\n\n   1   1   0   0\n\noctave:18> ifft( fft(poly1).*fft(poly2))\nans =\n\n   1   1   1   1\n```\n\n\nThis is the result. Interpret as x^3+x^2+x+1, which is the product of the two polynomials.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Magnitude Values within Fast Fourier Transformation FFT are different by constant input signal?\r\n                \r\nWithin my Beat-Detection, I'm using a Fast Fourier Transformation to detect the bass within an audio Signal. Im recording a solo basedrum, not moving the sound or volume. After plotting the values over time. I get non constant values. They differ very strong. Maybe you got an idea why this happens?\nI can only guess but maybe Im not using the right Buffersize or WindowSize for the FFT?\n\nDown a plotted graphic and the source code\n\nprivate class RecordingThread extends Thread {\n\n```\n    private boolean mShallContinue = true;\n\n    @Override\n    public void run() {\n// Compute the minimum required audio buffer size and allocate the\n    // buffer.\n    mBufferSize = 4096;// AudioRecord.getMinBufferSize(SAMPLING_RATE,\n                        // //4096;//\n                        // AudioFormat.CHANNEL_IN_MONO,\n\n    mAudioBuffer = new short[1024];// [mBufferSize / 2];\n    bufferDouble2 = new int[mBufferSize / 2];\n    bufferDouble = new int[(blockSize - 1) * 2];\n    camera = Camera.open();\n\n}\n        AudioRecord record = new AudioRecord(\n                MediaRecorder.AudioSource.DEFAULT, SAMPLING_RATE,\n                AudioFormat.CHANNEL_IN_MONO,\n                AudioFormat.ENCODING_PCM_16BIT, mBufferSize);\n\n        short[] buffer = new short[blockSize];\n        double[] audioDataDoubles = new double[(blockSize * 2)];\n        double[] re = new double[blockSize];\n        double[] im = new double[blockSize];\n        double[] magnitude = new double[blockSize];\n\n        // start collecting data\n        record.startRecording();\n\n        DoubleFFT_1D fft = new DoubleFFT_1D(blockSize);\n        synchronized (this) {\n            while (shallContinue()) {\n\n                /** decibels */\n                record.read(mAudioBuffer, 0, 1024);\n                // updateDecibelLevel();\n\n                /** frequency */\n                // /windowing!?\n                for (int i = 0; i < mAudioBuffer.length; i++) {\n                    bufferDouble2[i] = (int) mAudioBuffer[i];\n                }\n\n                for (int i = 0; i < blockSize - 1; i++) {\n                    double x = -Math.PI + 2 * i * (Math.PI / blockSize);\n                    double winValue = (1 + Math.cos(x)) / 2.0;\n                    bufferDouble[i] = (int) (bufferDouble2[i] * winValue);\n                }\n\n                int bufferReadResult = record.read(buffer, 0, blockSize);\n\n                // Read in the data from the mic to the array\n                for (int i = 0; i < blockSize && i < bufferReadResult; i++) {\n                    audioDataDoubles[2 * i] = (double) buffer[i] / 32768.0; // signed\n                                                                            // 16\n                                                                            // bit\n                    audioDataDoubles[(2 * i) + 1] = 0.0;\n                }\n\n                // audiodataDoubles now holds data to work with\n                fft.complexForward(audioDataDoubles); // complexForward\n\n                for (int i = 0; i < blockSize; i++) {\n\n                    // real is stored in first part of array\n                    re[i] = audioDataDoubles[i * 2];\n                    // imaginary is stored in the sequential part\n                    im[i] = audioDataDoubles[(i * 2) + 1];\n\n                    // magnitude is calculated by the square root of\n                    // (imaginary^2 + real^2)\n                    magnitude[i] = Math.sqrt((re[i] * re[i])\n                            + (im[i] * im[i]));\n                }\n                magnitude[0] = 0.0;\n\n                magnitude2 = magnitude[2];\n                magnitude3 = magnitude[3];\n                magnitude4 = magnitude[4];\n\n                updateShortBuffer();\n                bufferCount++;\n                updateLongBuffer();\n\n                // if (detectedRoomRMS == 200)\n                updateFrequency();\n                System.out.println(System.currentTimeMillis() + \" M2: \"\n                        + magnitude2 + \" M3: \" + magnitude3 + \" M4: \"\n                        + magnitude4 + \" M5: \" + magnitude[5] + \" M10: \"\n                        + magnitude[10] + \" M20: \" + magnitude[20] + \" M24: \"\n                        + magnitude[24] + \" M48: \" + magnitude[48] + \" LONG20: \"\n                        + rms_Long_Buffer_five + \" LONNG: \"\n                        + rms_Long_Buffer);\n            }\n            record.stop(); // stop recording please.\n            record.release(); // Destroy the recording, PLEASE!\n        }\n    }\n\n    /**\n     * true if the thread should continue running or false if it should stop\n     */\n    private synchronized boolean shallContinue() {\n        return mShallContinue;\n    }\n\n    /**\n     * Notifies the thread that it should stop running at the next\n     * opportunity.\n     */\n    private synchronized void stopRunning() {\n        mShallContinue = false;\n    }\n\n}\n\n// / post the output frequency to TextView\nprivate void updateFrequency() {\n    tvfreq.post(new Runnable() {\n\n        String RoomRMS;\n        String s;\n\n        public void run() {\n\n            if (RMSMessureDone == false) {\n                String l = \"..\";\n                String KK = \"...\";\n                tvfreq.setTextColor(Color.WHITE);\n                if ((rmsCounter > 10))\n                    tvfreq.setText(KK); //\n                else\n                    tvfreq.setText(l);\n            } else {\n                BPM = round(BPM, 1);\n                s = Double.toString(BPM);\n                s = s + \" bpm\";\n                tvfreq.setTextColor(Color.WHITE);\n                tvfreq.setText((s));\n\n                RoomRMS = Double.toString(detectedRoomRMS);\n                tvdb.setText(RoomRMS);\n            }\n        }\n\n    });\n\n}\n```\n\n    ", "Answer": "\r\nI imagine the discrepancies you see have to do with the relationship of the onset with the window used for the FFT.\n\nFundamentally, the approach you are using is the wrong one for this problem:\n\n1: The nature of the signal: The signal from a bass drum (and by this I assume you probably mean a kick drum?), features a sharp onset (it's just been hit hard), with a rapid decay. The initial peak is incoherent with a wide bandwidth; it's essentially white noise.  Whilst there will be plenty of low frequency content in there, it won't dominate.  After the initial attack, the drum skin vibrates at its natural frequency, with much lower output than the initial peak. \n\n2: Looking through the square window: You're currently applying a square window function to your samples. This is not a winning choice as it splatters energy into places you don't want it. The Hamming and Blackman windows are common choices with FFTs.  \n\n3: Resolution: The fundamental flaw with using an FFT is that it is windowed. The results of an DFT is simply contribution of each frequency bin over the period of the window.  The window period limits your temporal resolution (you only know that an event with in the range of frequencies occurred somewhere with in the window).   On the other hand, if you want meaningful results from the low frequency bins of the FFT, Nyquist's theory applies with respect to the frequency of the window relative to the signal measured.   Let's say you sample at 44.1kHz, this means you need a 2048 point DFT if you want meaningful results at, say, 50Hz.  Each window now has a period of 0.047s (or about 1/20s). This is your margin of error on each temporal measurement.  \n\nThere are a variety of time-domain onset-detection algorithms out there that are commonly used for beat-detection.  You might use a frequency-domain approach in tandem if you wanted to detect the likely source of a signal.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transformation - Rounding Errors\r\n                \r\nI am transforming an image to a frequency spectrum, convolving it with a kernel, then inverse-transforming it back.\n\nI wanted to ask how I can handle the rounding errors which occur during the transformation. Like when I transform an image, then immediately transform it back I have an average PSNR of 127. (I transform the pixels in float format between 0.0 and 1.0.)\n\nIs it possible to calculate the errors and correct them?\n    ", "Answer": "\r\nShort answer: If you want less rounding error, then you need a more accurate number format. Also, you cannot calculate the error.\n\nMore accurate floating-point formats include:\n\n\nx87 80-bit extended precision (long double)\nFixed point with BigInteger\nBigDecimal\n\n\nAlso, isn't a PSNR of 127 dB very good already?\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to compute the gradient of a multidimensional array using numpy's fast Fourier transform\r\n                \r\nI wrote this short and simple python method the other day\n```\ndef dFFT_1D(f):\n    k = 2*np.pi * np.fft.fftfreq(f.shape[0])\n    return np.fft.ifft(1j*k * np.fft.fft(f)).real\n```\n\nwhich takes a one-dimensional array containing samples of a scalar function (step size is taken as unity) as input argument and returns the derivative using numpy's fast Fourier transform.\nMy goal is to generalize this method; so that it will take a multidimensional array and return the gradient/derivative along any of its axis.\n```\ndef dFFT(f, axis):\n    k = 2*np.pi * np.fft.fftfreq(f.shape[axis])\n    return np.fft.ifftn( 1j*k * np.fft.fftn(f) ).real\n```\n\nfor the sake of simplicity, let us take f to be two-dimensional array with shape (m,n) and say I wish to compute its derivative along its first axis (i.e. axis=0) using the above method. Then, my problem simply is that k has shape (m,) and therefor can't be broadcasted together with a (m,n) array. I have so far been able to come up with to different attempts at resolving this. My first attempt is simply to expand the dimension of k by\n```\nk = np.expand_dims(k, axis).T\n```\n\nwhich ensure that k has shape (n,1). My second attempt is to begin by swapping the axis of f\n```\nf = np.swapaxes(f, 0, axis)\n```\n\nHowever, both of these approaches doesn't seem elegant (as in efficiency and readability). I am also afraid that they don't really extend beyond the two-dimensionally case. I have tried reaching for a solution online, so far unsuccessfully.\nCheers!.\n    ", "Answer": "\r\nYou should be able to do\n```\n1j * k[:, None] * np.fft.fftn(f)\n```\n\nto line up dimensions.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to get data from a notepad file and use fft (fast fourier transform on it)\r\n                \r\nI am a bit of a novice with programming as we are being made to do it in our physics degree. I am using Python 2.\n\nI've been given a txt file with two columns of data, the first few lines look like this:\n\n```\n0.000000000000000000e+00 7.335686114232199684e-02 \n1.999999999999999909e-07 7.571960558042964973e-01\n3.999999999999999819e-07 9.909475704320810374e-01\n5.999999999999999728e-07 3.412754086075696081e-01\n7.999999999999999638e-07 -5.558766000866324219e-01\n9.999999999999999547e-07 -9.810046985453722002e-01\n1.199999999999999946e-06 -5.436864816312496629e-01\n1.399999999999999937e-06 2.645021165628647641e-01\n1.599999999999999928e-06 9.667259209284312371e-01\n1.799999999999999919e-06 7.395753817164774091e-01\n1.999999999999999909e-06 7.289488801158025555e-02\n2.200000000000000112e-06 -7.925906572709742193e-01\n2.399999999999999891e-06 -9.727702002847055107e-01\n2.599999999999999671e-06 -1.772398644968510018e-01\n2.799999999999999873e-06 6.627909312992285029e-01\n3.000000000000000076e-06 1.022032186188189362e+00\n3.199999999999999855e-06 5.531242183135693935e-01\n```\n\n\nand on it goes for many hundreds of lines.\n\nThe question asks:\nThis week you have been provided with a file which consists of a simulated NMR time domain response following an external impulse. This free induction decay (FID) is characterized by a frequency, an initial amplitude and a decay constant. The data has a single \noscillation frequency and the second contains a mixture of two frequencies.\nWrite a program to evaluate the Fast Fourier transform of both signals and plot them\nin the frequency domain.\n\nCould someone give me an example of how I might go about doing this? Unfortunately we are not given much guidance in the lab, just some online tutorials and otherwise told to google stuff.\n    ", "Answer": "\r\nI'll turn my comment into an answer:\n\nIt is actually very easy. Load your data using numpy.genfromtxt() into a numpy array, and then you can choose some form of FFT from numpy.fft.\n\nAs this is your exercise I won't write down exact code but that basically sums it.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Can't plot results of matlab 2D fast fourier transform\r\n                \r\nI conducted a 2D fourier transform on a 4436413x3 matrix using the matlab fft2 command (this one: https://www.mathworks.com/help/matlab/ref/fft2.html). The product is a 4436413x3 matrix containing complex values. When I try to plot the data, I end up with a graph that is all one color or an error message that references the complex values in my data.\nI have tried interpolating to create a 2D set of values using the griddata() function, however, when applied to my 3D dataset, this returns a 1D vector equal to the z-column in my original 3D dataset. My 3D dataset consists of x, y, and z points, and in my attempt to interpolate I used vq = griddata(x,y,z,x,y). I had also tried to create a 4436412x3 meshgrid for my query points (using [xq, yq] = meshgrid(4436412, 3), and then using xq and yq as my query points), but this was returning NaN.\nWhen I run\nY = fft2(x);\nimagesc(abs(fftshift(Y)))\nI get a single purple box.\nWhen I run\nY = fft2(x);\nimagesc(Y)\nI get the following error message:\n```\nError using image\nComplex values are not supported. Specify the color data as numeric or logical values.\n\nError in imagesc (line 52)\n    hh = image(varargin{:}, 'CDataMapping', 'scaled');\n```\n\n    ", "Answer": "\r\nTo apply the FFT, you need data to be sampled on a regular grid. Your data represents (x,y,z) coordinates of points. Here's how to use ```\ngriddata```\n to resample these coordinates onto a regular (x,y) grid:\n```\n% Generate example data, let's say x and y are in the range [-3,3]:\nn = 62500;\nx = rand(n, 1) * 6 - 3;\ny = rand(n, 1) * 6 - 3;\nz = sin(4*x) + cos(2*y); % an example function\ndata = [x,y,z]; % This is a 4436413x3 array with (x,y,z) coordinates\n\n% Interpolate z values onto a regular (x,y) grid:\n[xq, yq] = meshgrid(linspace(min(x), max(x), sqrt(n)), ...\n                    linspace(min(y), max(y), sqrt(n)));\nzq = griddata(x, y, z, xq, yq);\n\n% griddata doesn't extrapolate, writes NaN instead. Let's fill those\n% in with zeros (maybe a different value is more meaningful in your\n% application).\nzq(isnan(zq)) = 0;\n\n% Now you can apply a 2D Fourier transform:\nZ = fft2(zq);\nimshow(log(abs(fftshift(Z))), []);\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Inverse fast fourier transform algorithm on Android\r\n                \r\nI use AudioRecord on Android to record audio,read into the buffer and use FFT algorithm to transform to frequencies blocks.Now Can I use inverse FFT algorithm to recover the data and playback the sound i have recorded?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how to calculate and plot the fast fourier transform of sla data (3 d matrix) in matlab?\r\n                \r\nI want to check for the existent dominant peaks in sla data(3 d matrix lon, lat ,time) from which I can delineate what period to choose so that I can filter this data and look for waves propagating in the region. My data is for all lat and lon(global data). However, I want to average over a lon range of 70E to 100E and after that average over 10S to 10N. This average will give a a vector only in time dimension over which I can perform fast fourier transform. Then I want to plot this with time as the x axis. I'm new to matlab, any help is appreciated. Also if anyone has done this before it would be nice if you told  me if my logic is correct or not. \n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how fft (fast Fourier transform) works\r\n                \r\nI am a learner of python and developing a small project related to image analysis, to learn the concept I tried to understand various python codes, but this time I sucked and can any one explain this code ? Especially the FFT part ? \n\n```\nclass HeartMonitor(object):\n\n    def __init__(self, window_duration, fps = 30, min_bpm = 50, max_bpm = 200):\n        \"\"\"\n        Class which detects heart-beats in a sequence of image colour samples.\n        @param window_duration The number of seconds of samples to use\n        @param fps             The nominal sample rate\n        @param min_bpm         Minimum cut-off for possible heartrates\n        @param max_bpm         Maximum cut-off for possible heartrates\n        \"\"\"\n\n        self.min_bpm = min_bpm\n        self.max_bpm = max_bpm\n\n        # The maximum number of samples to buffer\n        self.buf_size = int(window_duration*fps)\n\n        # Buffer of (timestamp, value) tuples\n        self.buf = []\n\n\n    @property\n    def fps(self):\n        \"\"\"\n        The average framerate/samplerate of the buffer\n        \"\"\"\n        return float(len(self.buf)) / (self.buf[-1][0] - self.buf[0][0])\n\n\n    def get_fft(self):\n        \"\"\"\n        Perform an Fast-Fourier-Transform on the buffer and return (magnitude,\n        phase) tuples for each of the bins.\n        \"\"\"\n        # Get the \"ideal\" evenly spaced times\n        even_times = numpy.linspace(self.buf[0][0], self.buf[-1][0], len(self.buf))\n\n        # Interpolate the data to generate evenly temporally spaced samples\n        interpolated = numpy.interp(even_times, *zip(*self.buf))\n\n        # Perform the FFT\n        fft = numpy.fft.rfft(interpolated)\n        return zip(numpy.abs(fft), numpy.angle(fft))\n```\n\n    ", "Answer": "\r\n```\nnumpy.fft.rfft```\n is a library function that computes an fft from real data\n\nThe samples need to be evenly spaced in the time domain.\n\nSince some samples may not be evenly spaced in ```\nbuf```\n they are interpolated using ```\nnumpy.interp```\n\n\n```\nself.buf[0]```\n is the first item of ```\nbuf```\n\n```\nself.buf[-1]```\n is the last item of ```\nbuf```\n\n```\nlen(self.buf)```\n is the number of items in ```\nbuf```\n\n\nSo you end up with the same number of samples, but moved along the time axis so they are evenly spaced (stored in the variable ```\ninterpolated```\n).\n\nNow ```\ninterpolated```\n can be passed to ```\nnumpy.fft.rfft```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to calculate Frequency with Fast Fourier Transformation\r\n                \r\ni am working on a pulse sensor project. I get data from the sensor like this:\n\n\nNow i would like to use this code:\n\n```\n  #include <complex>\n#include <iostream>\n#include <valarray>\n\nconst double PI = 3.141592653589793238460;\n\ntypedef std::complex<double> Complex;\ntypedef std::valarray<Complex> CArray;\n\n// Cooley–Tukey FFT (in-place, divide-and-conquer)\n// Higher memory requirements and redundancy although more intuitive\nvoid fft(CArray& x)\n{\n    const size_t N = x.size();\n    if (N <= 1) return;\n\n    // divide\n    CArray even = x[std::slice(0, N/2, 2)];\n    CArray  odd = x[std::slice(1, N/2, 2)];\n\n    // conquer\n    fft(even);\n    fft(odd);\n\n    // combine\n    for (size_t k = 0; k < N/2; ++k)\n    {\n        Complex t = std::polar(1.0, -2 * PI * k / N) * odd[k];\n        x[k    ] = even[k] + t;\n        x[k+N/2] = even[k] - t;\n    }\n}\n\n// Cooley-Tukey FFT (in-place, breadth-first, decimation-in-frequency)\n// Better optimized but less intuitive\n// !!! Warning : in some cases this code make result different from not optimased version above (need to fix bug)\n// The bug is now fixed @2017/05/30 \nvoid fft(CArray &x)\n{\n    // DFT\n    unsigned int N = x.size(), k = N, n;\n    double thetaT = 3.14159265358979323846264338328L / N;\n    Complex phiT = Complex(cos(thetaT), -sin(thetaT)), T;\n    while (k > 1)\n    {\n        n = k;\n        k >>= 1;\n        phiT = phiT * phiT;\n        T = 1.0L;\n        for (unsigned int l = 0; l < k; l++)\n        {\n            for (unsigned int a = l; a < N; a += n)\n            {\n                unsigned int b = a + k;\n                Complex t = x[a] - x[b];\n                x[a] += x[b];\n                x[b] = t * T;\n            }\n            T *= phiT;\n        }\n    }\n    // Decimate\n    unsigned int m = (unsigned int)log2(N);\n    for (unsigned int a = 0; a < N; a++)\n    {\n        unsigned int b = a;\n        // Reverse bits\n        b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n        b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n        b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n        b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n        b = ((b >> 16) | (b << 16)) >> (32 - m);\n        if (b > a)\n        {\n            Complex t = x[a];\n            x[a] = x[b];\n            x[b] = t;\n        }\n    }\n    //// Normalize (This section make it not working correctly)\n    //Complex f = 1.0 / sqrt(N);\n    //for (unsigned int i = 0; i < N; i++)\n    //  x[i] *= f;\n}\n\n\nint main()\n{\n    const Complex test[] = { 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 };\n    CArray data(test, 8);\n\n    // forward fft\n    fft(data);\n\n    std::cout << \"fft\" << std::endl;\n    for (int i = 0; i < 8; ++i)\n    {\n        std::cout << data[i] << std::endl;\n    }\n\n    }\n    return 0;\n}\n```\n\n\nTo calculate the frequency of my heartbeat. The problem i have right now is making sense of the output i get:\nfft\n(4,0)\n(1,-2.41421)\n(0,0)\n(1,-0.414214)\n(0,0)\n(1,0.414214)\n(0,0)\n(1,2.41421)\n\nWhat is this? I think it is the Amplitude and the phase, but i dont know how to calculate from that the frequency. \n\nThe frequency of a pulse is around 0.33 Hz to 3 Hz. Is the resolution of this code good enough? I never had to work with fourier transformation\n\nThanks for the help. I look forward to your answers. \n    ", "Answer": "\r\nThe complex numbers that are outputs of the FFT are the coefficients that the component sine waves are multiplied by. Essentially they are rectangular coordinates, and the equivalent polar coordinates of magnitude and angle would give you the amplitude and phase.\n\nThe frequency is determined by position in the array. The element at index i is for the sampling frequency multiplied by i/N, where N is the number of elements in the FFT.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Using Fast Fourier Transform on matlab?\r\n                \r\nI am having some difficulty in solving a simple 2D Poisson equation in Matlab using spectral methods in one direction on finite difference in the other.\n\nI am obtaining a scaled version of the correct answer but can't work out why although I think it has something to do with the wavenumber.\n\nAny help would be greatly appreciated, the code can be seen below.\n\n```\nN = 32;\nx = ((0:N-1)/N)*2*pi;\ny = ((0:N-1)/N)*2*pi;\ndx = 2*pi/N;\nk  =  fftshift(-N/2:N/2-1);\n[X,Y] = meshgrid(x,y);\nf = (-2)*cos(X).*sin(Y);\nf_comparison = cos(X).*sin(Y);\nchecker = 10;\nu = zeros(N,N);\nu_new = zeros(N,N);\nf_hat = fftn(f);\nwhile checker > 1*10^(-7);\n    u_new_hat = fftn(u_new);\n    for aa = 1:N\n        for a = 1:N\n            q1 = a+1;\n            q2 = a-1;\n            if q2 == 0\n                q2 = N;\n            end\n            if q1 == N+1\n                q1 = 1;\n            end\n            denom = ((dx^2)*((k(aa))^2))+2;\n            u_new_hat(a,aa) = (1/denom)*((u_new_hat(q1,aa))+(u_new_hat(q2,aa))-((f_hat(a,aa))*(dx^2)));\n        end\n    end\n    u_new = real(ifftn(u_new_hat));\n    for aa = 1:N\n        for a = 1:N\n            u_checker(a,aa) = abs(u_new(a,aa)-u(a,aa));\n        end\n    end\n    compare = max(u_checker);\n    checker = max(compare);\n    for aa = 1:N\n        for a = 1:N\n            u(a,aa) = u_new(a,aa);\n        end\n    end\nend\n%calculate scaling discrepency\nddd = f_comparison./u;\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform with negative amplitude\r\n                \r\nUsing wavesurfer to analyse bird songs data and getting negative amplitudes with the FFT analysis that I can not find the reason why.\n\nI have been using wavesurfer for analysing my paper data on birds song. I open my data with the spectrogram and then in spectrum section is possible to find frequency and amplitude (using FFT analysis). My amplitude is negative but I can not find a way to justify that. I dont know why is that and I have significant results on my data, meaning that everything needs to be justified. The forum of the software does not work and there is literally no answer to my question on the internet. I have even emailed the creators asking for help. Find a screen attached to the windows.\n\n\n    ", "Answer": "\r\ndB are on a logarithmic scale.  The log of a small enough positive FFT magnitude can be negative.\ne.g. 20*log10(0.1) = -20\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Help with EXCEL Fast Fourier Transform\r\n                \r\nI am trying to use Excel's (2007) built in FFT feature, however, it requires that I have 2^n data points - which I do not have.\n\nI have tried two things, both give different results:\n\n\nPad the data values by zeros so that N (the number of data points) reach the closest power of 2 \nUse a divide-and-conquer approach i.e. if I have 112 data points, then I do a FFT for 64, then 32, then 16 (112=64+32+16)\n\n\nWhich is the better approach? I am comfortable writing VBA macros but I am looking for an algorithm which does not require the constraint of N being power of 2. Can anyone help?\n    ", "Answer": "\r\nSplitting your data into smaller bits will result in erroneous output, especially for smaller numbers of data points.\n\nPadding with zeroes is a much better idea, and the general approach for FFTs. If you are interested in an alternative way of doing the FFT, octave will do it for you, and most of the Matlab documentation applies so you should have no trouble with it.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fast fourier transform with complex numbers from a file\r\n                \r\nMy code let a user to introduce an array of numbers  that will be transformed with Fourier. But I want to read this array from a file . How can I do this? I just started to learn python ..\n\n```\nimport cmath\nfrom scipy.fftpack import fft\nf=open(\"complex.txt\",\"r+\")\nc=[]\nfor line in f:\n    line=line.split()\n    if line:\n        line=[complex(i.replace('i','j')) for i in line]\n        c.append(line)\n\ndef omega(p, q):\n    return cmath.exp((2.0 * cmath.pi * 1j * q) / p)\n\ndef fft(signal):\n    n = len(signal)\n    if n == 1:\n        return signal\n    else:\n        Feven = fft([signal[i] for i in xrange(0, n, 2)])\n        Fodd = fft([signal[i] for i in xrange(1, n, 2)])\n        combined = [0] * n\n        for m in xrange(n/2):\n            combined[m] = Feven[m] + omega(n, -m) * Fodd[m]\n            combined[m + n/2] = Feven[m] - omega(n, -m) * Fodd[m]\n\n    return combined\n```\n\n    ", "Answer": "\r\nIt turns out (see comments above) that Mady's actual difficulty was in calling a function in Python, rather than in reading data from a file or Fourier-transforming it. So:\n\nTo apply a function ```\nf```\n to arguments ```\na```\n,```\nb```\n,```\nc```\n, you say\n\n```\nf(a,b,c)\n```\n\n\nand if you want to put the result in a variable called ```\nd```\n, you say\n\n```\nd = f(a,b,c)\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform performance in Python\r\n                \r\nSo I wrote a short Python program to estimate the accuracy of the Python's FFT method.\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#Aufgabe 1\nx0=0\na=2.5\nk0=3\nX=np.linspace(-4,4,100)\ntimestep=0.1\nk=np.fft.fftfreq(X.size,d=timestep)\npsi_analytical=[(2/(np.pi*a**2))**(1/4)*np.exp(-((i-x0)**2)/a**2)*np.exp(1j*k0*(i-x0)) for i in X]\npsi_tilde_numerical=np.fft.fft(psi_analytical)\npsi_tilde_analytical=[(2/(np.pi*a**2))**(1/4)*(a/2)*np.exp(-(a*(i-k0))**2/4)*np.exp(-1j*i*x0) for i in k]\npsi_numerical=np.fft.ifft(psi_tilde_analytical)\n\n\n#plt.plot(k,np.abs(psi_tilde_numerical),label='numerical psi tilde')\n#plt.plot(k,np.abs(psi_tilde_analytical),'--',color='tab:orange', label='analytical psi tilde')\n\nplt.plot(X,np.abs(psi_analytical),label='analytical psi, real')\nplt.plot(X,np.abs(psi_numerical),'--',color='tab:orange',label='numerical psi, real')\nplt.legend()\nplt.show()\n```\n\nThe analytical function is as follows:\n\nTo my surprise, the numerical and analytical functions are totally different. However, I'm not sure why this is the case.\nThe normalisation constant ```\nN```\n is ```\n(2/(np.pi*a**2))**(1/4)```\n\n    ", "Answer": "\r\nDoing a bit more research, I think I might have an answer for you.\nDiscrete Fourier Transform (```\nDFT```\n), which is computed efficiently using the Fast Fourier Transform algorithm (```\nFFT```\n), operates on discrete time domain signals. The Fourier Transform (```\nFT```\n) operates on function in continuous time domain.\n```\nDFT```\n will approximate the ```\nFT```\n under certain condition. One of those conditions is that the signal has to be band limited. This means that the ```\nFT```\n for the function has to be zero for all frequencies above a certain frequency threshold ```\nα```\n and the DFT has to have a sample rate that is at least ```\n2*α```\n This goes back to Nyquist-Shannon sampling theorem.\nIn your case, you are trying to approximate a Gaussian function ```\nexp(-x²)```\n which is not band limited. This is because as you can see from your formulas, ```\nFT```\n of a Gaussian is also a Gaussian. This means that it has negligible but non-zero components for frequencies all the way to infinity. As a result, you won't be able to approximate the ```\nFT```\n using a ```\nDFT```\n since you would need to have infinite sampling rate.\nIn conclusion, its important to realize that the ```\nDFT```\n and ```\nFT```\n are vastly different transforms and thus can not just be compared.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier cosine transform in two dimension by using FFTW3 library\r\n                \r\nPlease help me this problem.\nI am trying to use fast fourier cosine transform in two dimensional by using FFTW3 library . In my case, i really need to transform with a lot of point. When i set number of points in x and y direction equal to n0*n1=512*512, my program run correctly. However, i set number of points equal to n0*n1=1024*1024, i got the message \"segmentation fault\". The problem, may be, come from memory with three arrays double in[N], in2[N], out[N](here N=n0*n1), which are built.    \n\nSo i have tried to replace arrays by vector but it seems to be not suitable for FFTW3 library.\nMy program is run on laptop with RAM 4GB and core i3.\n\nCould you give for me a advice for my case?\n\nI appreciate with any your ideal.\nThank you so much.\n\nHere is my program\n\n```\nenter code here\n#include <stdio.h>\n#include <math.h>\n#include <fftw3.h>\n\nusing namespace std;\nint main() {\n\n    int n0=1024;\n    int n1=1024;\n\n    int N=n0*n1;\n\n    double in[N], in2[N], out[N];\n\n    fftw_plan p, q;\n    int i,j;\n    p = fftw_plan_r2r_2d(n0,n1, in, out, FFTW_REDFT00, FFTW_REDFT00, FFTW_ESTIMATE);\n\n    for (i =0;i <n0;i++){\n        for (j=0;j<n1;j++)\n        { \n            in[i*n0+j] = cos(2.0*M_PI*(double)i/(n0 - 1))+cos(2.0*M_PI*(double)j/(n1 - 1)); \n        }\n    }\n\n    fftw_execute(p);\n    q = fftw_plan_r2r_2d(n0,n1, out, in2, FFTW_REDFT00, FFTW_REDFT00, FFTW_ESTIMATE);\n    fftw_execute(q);\n\n    for (i =0;i<n0;i++){\n        for (j=0;j<n1;j++)\n        {\n            printf(\"%3d %9.5f %9.5f\\n\", i*n0+j, in[i*n0+j], in2[i*n0+j]/(2.0*(double)(n0 - 1))/(2.0*(double)(n1 - 1)));\n        }\n    }\n  fftw_destroy_plan(p); fftw_destroy_plan(q); fftw_cleanup();\n  return 0;\n}\n```\n\n    ", "Answer": "\r\n\nVariable length arrays are forbidden by C++ standard. Some compilers do support them, but it is not a good idea to use them because it makes your program not portable(that is, ```\nN```\n must be a compile time constant if you create an array of size ```\nN```\n on stack).\n```\nin```\n, ```\nin2```\n and ```\nout```\n arrays are allocated on stack. The default stack size varies for different OS, but it is usually a few megabytes(8 MB on Linux). It is not enough to hold them. That's why you get a SEGFAULT.\nTo fix this problem, you can allocate arrays dynamically:\n\n```\ndouble* in = new double[N];\ndouble* in2 = new double[N];\ndouble* out = new double[N];\n```\n\nDo not forget to delete them when they are not needed anymore(at the end of the program in this case) to avoid memory leaks:\n\n```\ndelete[] in;\ndelete[] in2;\ndelete[] out;\n```\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform and Hamming Window\r\n                \r\nI need help with implementing FFT in hamming window to search peak on the graph/chart (determination of the spectral phase function). At this moment I know how to mark all the peaks on my chart, and also how to load all the file from folder on one chart. And now the most important thing is to find a peak by FFT hamming window. For now the most important thing for me is just to implement this to my script or show me how to do this. When I understand this, I can modify it to search for the peak I want. \n\nMy code:\n\n```\nfolder = 'C:\\Users\\an\\Desktop\\Materialy\\';\n\nfiles = dir(fullfile(folder,'*.dat'));\nfiles_len = numel(files);\n\nif (files_len == 0)\nreturn;\nend\n\nfigure(1);\n\nfile = fullfile(folder,files(1).name);\n[lam,I] = read_spectrum(file);\nlam = lam * 1e-3;\nplot(lam,I);\n\nif (files_len > 1)\nhold on;\n\nfor i = 2:files_len\n    file = fullfile(folder,files(i).name);\n    [lam,I] = read_spectrum(file);\n    lam = lam * 1e-3;\n    plot(lam,I);\nend\n\nhold off;\nend\n```\n\n    ", "Answer": "\r\nSteps for you: \n\ncalculate Hamming window weights for your array size\n\nmultiply data by Hamming weights\n\nmake FFT\n\nIn general-purpose language I use HW in such way (N is array size):\n\n```\n  Re[i] := Re[i] * (0.54-0.46*cos(2*Pi*i/N));\n```\n\n\nBut seems that in Matlab you have ready function\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Open Code in c++ [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have been looking up an open c++ code about FFT. I wanna process an image with FFT and I wrote a code but the code which is mine is not fast even so slow. \nI wrote it using four for loop that's way it is not efficient. The point is, is there is anyone can help me. I searched the internet fully, but i couldn't find any document or code file in c++. I do NOT wanna have a pre-written code by any lib. That's way please show me a site and I can write my code.\nMy code is here;\n\n```\nvoid NaiveDFT::Apply( Image & img )\n{\n\n     complex<double> dft[512][512];    \n\n    for(unsigned u = 0; u < img.rows; ++u)\n    {\n        for(unsigned v = 0; v < img.cols; ++v)\n        {\n            std::complex<double> sum = 0;\n            for(unsigned x = 0; x < img.rows; ++x)\n            {\n                for(unsigned y = 0; y < img.cols; ++y)\n                {\n                    std::complex<double> i = sqrt(std::complex<double>(-1));\n                    std::complex<double> theta = 2 * M_PI * (((u * x) / img.GetWidth()) + ((v * y) / img.cols));\n                    sum += std::complex<double>(img.at<uchar>(i, j)[0]) * cos(theta) + (-i * sin(theta));\n                    //sum += std::complex<double>(std::complex<double>(imgData[x][y]._red) * pow(EULER, -i * theta));\n\n                }\n            }\n            dftData[u][v] = (sum.imag() / (img.GetWidth() * img.GetHeight()));\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nKISSFFT is BSD-licensed:\n\nhttp://kissfft.sourceforge.net\n\nFFTW is GPL-licensed:\n\nhttp://www.fftw.org\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Processing Audio Data using Fourier Transforms in Java\r\n                \r\nI'm trying to process audio data. I'm working with Java.\nI've extracted the audio data to an array. Now I should pass N data samples to a function that calculates the Discrete Fourier Transform (or Fast Fourier Transform, which is more efficient). I've read documentation but I'm getting more and more confused. What I'm trying to calculate is the magnitude spectrum (|X(k)|). \nCan anyone help me? Thanks\n    ", "Answer": "\r\nRichard G. Baldwin has a number of very good articles on Fast Fourier Transform algorithms in Java on the Developer.com website.  In particular, the following articles should prove to be useful:\n\nFun with Java, Understanding the Fast Fourier Transform (FFT) Algorithm\nhttp://www.developer.com/java/other/article.php/3457251/Fun-with-Java-Understanding-the-Fast-Fourier-Transform-FFT-Algorithm.htm\n\nSpectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT Algorithm\nhttp://www.developer.com/java/other/article.php/3380031/Spectrum-Analysis-using-Java-Sampling-Frequency-Folding-Frequency-and-the-FFT-Algorithm.htm\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How can I see Fast Fourier Transform makes sense by an easy example\r\n                \r\nLets assume the the theory of fourier analysis is clear.\nI only want to see that the fast fourier transfom give me somehow, what I would expect from the theory.\nFor the example below, I would expect in a plot (amplitude over frequency) somehow a peak of 0.5 over 2 and a peak of 1 over 5. How I could see this point? Or where I am running in the wrong direction?\n```\nfrom scipy.fftpack import fft\n\nN = 100\nx = np.linspace(0.0, 1, N)\ny = np.sin(5 * 2.0*np.pi*x) + 0.5*np.sin(2 * 2.0*np.pi*x)\nyf = fft(y)*(x[1]-x[0])\nfreq = scipy.fftpack.rfftfreq(N, x[1]-x[0])\n\nplt.plot(freq, np.abs(yf))\n```\n\nThanks to the suggestion from Ammon, I corrected the typo and added a scaling of the step size. But still I don't find a peak of 0.5 over 2 and a peak of 1 over 5.\n    ", "Answer": "\r\nIf you want just to see peaks, you need to plot fft, not input data in meaning yf, not y:\n```\nplt.plot(freq, np.abs(yf))\n```\n\nHave you tried this tutorial:\nhttps://docs.scipy.org/doc/scipy/reference/tutorial/fft.html\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "NumPy Fast Fourier transform (FFT) does not work on sine wave generated in Audacity\r\n                \r\nI am trying to use the NumPy library for Python to do some frequency analysis. I have two .wav files that both contain a 440 Hz sine wave. One of them I generated with the NumPy sine function, and the other I generated in Audacity. The FFT works on the Python-generated one, but does nothing on the Audacity one.\n\nHere are links to the two files:\n\nThe non-working file: 440_audacity.wav\n\nThe working file: 440_gen.wav\n\nThis is the code I am using to do the Fourier transform:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wave\n\ninfile = \"440_gen.wav\"\nrate, data = wave.read(infile)\n\ndata = np.array(data)\n\ndata_fft = np.fft.fft(data)\nfrequencies = np.abs(data_fft)\n\nplt.subplot(2,1,1)\nplt.plot(data[:800])\nplt.title(\"Original wave: \" + infile)\n\nplt.subplot(2,1,2)\nplt.plot(frequencies)\nplt.title(\"Fourier transform results\")\n\nplt.xlim(0, 1000)\n\nplt.tight_layout()\n\nplt.show()\n```\n\n\nI have two 16-bit PCM .wav files, one from Audacity and one created with the NumPy sine function. The NumPy-generated one gives the following (correct) result, with the spike at 440Hz:\n\n\nThe one I created with Audacity, although the waveform appears identical, does not give any result on the Fourier transform:\n\n\nI admit I am at a loss here. The two files should contain in effect the same data. They are encoded the same way, and the wave forms appear identical on the upper graph.\n\nHere is the code used to generate the working file:\n\n```\nimport numpy as np\nimport wave\nimport struct\nimport matplotlib.pyplot as plt\nfrom operator import add\n\nfreq_one = 440.0\nnum_samples = 44100\nsample_rate = 44100.0\namplitude = 12800\n\nfile = \"440_gen.wav\"\n\ns1 = [np.sin(2 * np.pi * freq_one * x/sample_rate) * amplitude for x in range(num_samples)]\n\nsine_one = np.array(s1)\n\nnframes = num_samples\ncomptype = \"NONE\"\ncompname=\"not compressed\"\nnchannels = 1\nsampwidth = 2\n\nwav_file = wave.open(file, 'w')\nwav_file.setparams((nchannels, sampwidth, int(sample_rate), nframes, comptype, compname))\n\nfor s in sine_one:\n    wav_file.writeframes(struct.pack('h', int(s)))\n```\n\n    ", "Answer": "\r\nLet me explain why your code doesn't work. And why it works with ```\n[:44100]```\n.\nFirst of all, you have different files:\n```\n440_gen.wav      = 1 sec and 44100  samples (counts)        \n440_audacity.wav = 5 sec and 220500 samples (counts)\n```\n\nSince for ```\n440_gen.wav```\n in FFT you use the number of reference points N=44100 and the sample rate 44100, your frequency resolution is 1 Hz (bins are followed in 1 Hz increments).\nTherefore, on the graph, each FFT sample corresponds to a delta equal to 1 Hz.\n```\nplt.xlim(0, 1000)```\n just corresponds to the range 0-1000 Hz.\nHowever, for ```\n440_audacity.wav```\n in FFT, you use the number of reference points N=220500 and the sample rate 44100. Your frequency resolution is 0.2 Hz (bins follow in 0.2 Hz increments) - on the graph, each FFT sample corresponds to a frequency in 0.2 Hz increments (min-max = +(-) 22500 Hz).\n```\nplt.xlim(0, 1000)```\n just corresponds to the range 1000x0.2 = 0-200 Hz.\nThat is why the result is not visible - it does not fall within this range.\n```\nplt.xlim (0, 5000)```\n will correct your situation and extend the range to 0-1000 Hz.\nThe solution ```\n[:44100]```\n that jwalton brought in really only forces the FFT to use N = 44100. And this repeats the situation with the calculation for 440_gen.wav\nA more correct solution to your problem is to use the ```\nN (Windows Size)```\n parameter in the code and the ```\nnp.fft.fftfreq()```\n function.\nSample code below.\nI also recommend an excellent article https://realpython.com/python-scipy-fft/\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wave\n\nN = 44100 # added\n\ninfile = \"440_audacity.wav\"\nrate, data = wave.read(infile)\n\ndata = np.array(data)\n\ndata_fft = np.fft.fft(data, N)  # added N\nfrequencies = np.abs(data_fft)\nx_freq = np.fft.fftfreq(N, 1/44100)  # added\n\nplt.subplot(2,1,1)\nplt.plot(data[:800])\nplt.title(\"Original wave: \" + infile)\n\nplt.subplot(2,1,2)\nplt.plot(x_freq, frequencies)  # added x_freq \nplt.title(\"Fourier transform results\")\n\nplt.xlim(0, 1000)\nplt.tight_layout()\nplt.show()\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform library from Exocortex.DSP\r\n                \r\nI am trying to use the FFT library from Exocortex.DSP.\n\nThe calling function is:\n\n```\nExocortex.DSP.Fourier.FFT(float[], int, Exocortex.DSP.FourierDirection)\n```\n\n\nMy line of code to use this function is:\n\n```\nFourier.FFT(floatArray, arraycount, FourierDirection.Forward);\n```\n\n\nMy program compiles, but why does it break at this line?\n\n**The breaking window says:\n\n```\nAn unhandled exception of type 'System.MissingMethodException' occurred in Exocortex.DSP.v1.dll\nAdditional information: Method not found: Log System.Math.\"*\n```\n\n    ", "Answer": "\r\nThese sorts of errors happen when you compile your code against a library but then run against a different version, or if you compile only a sub-set of your solution's projects. What happens then is that the code attempts to call methods that don't exist or have a different signature in the assembly used at run-time.\n\nThings I would check are:\n\n\nIn the Build Configuration dialog, whether all the boxes are ticked/checked.\nWhether your projects are building to the directories you think they are.\nWhether you are actually running the built code or whether, somehow, you could be running old code from a different directory.\nWhether the library you are using is getting copied to the executable project's target directory correctly (if it's not it could suggest a dodgy reference somewhere in the solution).\n\n\nFinally, it's possible that the library itself has been compiled against different versions of the libraries it uses. You may want to set up a small test project to make sure the library works correctly in a very simple test case before investigating why your existing project is not working.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Inverse fast fourier transform: different phases\r\n                \r\nRosettaCode gives a simple implementation of the Cooley–Tukey FFT algorithm here. The question is the following and is from a mathematical and programming point of view. Suppose that an input of a program is the spectrum of a signal, and we want to generate a signal which has such a spectrum. If am correct, we need to take the inverse FFT of the input spectrum.\n\nThe code given by RosettaCode is the following:\n\n```\n// inverse fft (in-place)\nvoid ifft(CArray& x)\n{\n    // conjugate the complex numbers\n    x = x.apply(std::conj);\n\n    // forward fft\n    fft( x );\n\n    // conjugate the complex numbers again\n    x = x.apply(std::conj);\n\n    // scale the numbers\n    x /= x.size();\n}\n```\n\n\nBut this can only generate one signal. But several signals can have the same spectrum. So how to add a parameter to be able to generate these different signals?\n    ", "Answer": "\r\nNo, different signals have different Fourier transforms; it is invertible. N complex numbers in, N complex numbers out; the discrete Fourier transform amounts to multiplying a vector of samples by a nonsingular matrix, getting a vector of the same size.\n\nYou might be confusing an actual Fourier transform with a \"spectrum\" obtained taking the magnitude of the Fourier transform or with the result of other information-destroying operations.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast fourier transform in ruby on rails\r\n                \r\nI'm now developing a project in ruby on rails.\n\nIs there anyway to calculate fft in ruby on rails?\nSay retrieve some time domain raw data from database and do fft then out put the freq domain graph in web page.\n\nIs there any gem support this calculation?\n\nif not,is it possible to use ruby write calculate fft code? Or is there any other way of implementing this?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Performing 2D fast fourier transform in R\r\n                \r\nI want to know how to perform 2D fft in R. I can see the function ```\nfft```\n only but I want to do that in 2D. Is there a function available like ```\nfft2```\n in matlab?\n    ", "Answer": "\r\nAs pointed out in the comments, ```\nfft```\n can handle single or multi-dimensional input. From the docs:\n\n\n  When z is a vector, the value computed and returned by fft is the\n  unnormalized univariate Fourier transform of the sequence of values in\n  z. When z contains an array, fft computes and returns the multivariate\n  (spatial) transform.\n\n\nI think this documentation is confusing the terms (since an R array can have 1, 2, or more dimensions), but what they are trying to say is fairly clear.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to perform FFT2D (Fast Fourier Transform 2D) R, G, B color component\r\n                \r\nI am new in fast fourier transform (FFT) and does not have much idea, how it calculate in programming language such as C++.  Here is method of FFT2D\n\n```\nvoid FFT2D(Complex<double> *f, Complex<double> *F, int width, int height);\nIt takes an input image f of size width * height and output the transformed \ncoefficients into F.\n```\n\n\nHints: Image pixels are stored as three separate image color (R, G, B) planes, with each of them being represented by a 1D array of complex numbers. Suppose an image is of size width W and height H, then the color component values (R, G and B) of the pixels at image location (m, n) can be found as R[m + n * W], G(m + n * W) and B[m + n * W], where R, G, B are the three arrays of complex numbers.\nThe 1D array for the transformed coefficients is also represents in the same manner.\n\nWhat I need to implement the processing for one color component only and the programming template will process the R, G, B separately based on implemented functions. The template will also pad the image with zeros so that each input image is of size 2m * 2n. \n\n```\nIf I called from another class, I have to pass R, G, B separately\nSuppose: \nComplex<double> *R = new Complex<double>[width * height];\nLet, width = 4096 and height 4096\nFFT2D(R, output F, width, height) for compute “R” color component;\nFFT2D(G, output F, width, height) for compute “G” color component;\nFFT2D(B, output F, width, height) for compute “B” color component;\n\nWe have template of calculated FFT1D function:\nvoid FFT1D(Complex<double> *fx, Complex<double> *Fu, int twoK, int stride)\nHint: it outputs the frequency coefficients in the array Fu.\n```\n\n\nFFT1D is calling from inside a function of FFT2D. I found several different type of code in C, C++, and Java and C #of FFT2D. Most of them have implemented using 2D array structure; they assign real and imaginary part to 2D array structure in loop of rows and columns. However, in my case is 1D array structure of color component.\n\nLet's, do some code and this is inside FFT2D function:\n\n```\nComplex<double> *outPutMap = new Complex<double>[width * height];\n for (int i = 0; i < height; i++){\n #  for(int j = 0; j < width; j++){\n #     outPutMap[i + j * width] = f[i + j * width];\n #      I don’t understand how to implement in here for color component and how \n #      it assign a value for real and imaginary part\n #   }\n  }\n```\n\n\nBefore, calling a FFTID, it also required calculate a value of twoK as in book, M = 2K\n\nIf you have any idea or any reference please let me know.\n\nThank you\n\nRegards\nIchiro\n    ", "Answer": "\r\nI would suggest you get hold of a book such as [Numerical Recipes][1] . \n\nhttp://www.amazon.com/Numerical-Recipes-Art-Scientific-Computing/dp/0521750334\n\nFFT, Simpsons Rule, Fouriers Algorith should all be there. I had read from an author named Rajaram .. it was in C.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Extract Fast Fourier Transform data from file\r\n                \r\n\nI am building a tool which is supposed to run on a server and analyze sound files. I want to do this in Ruby as all my other tools are written in Ruby as well. But I am having trouble finding a good way of accomplishing this.\n\nA lot of the examples I've found has been doing visualizers and graphical stuff. I just need the FFT data, nothing more. I need to both get the audio data, and do a FFT on it. My end goal is to calculate some stuff like the mean/median/mode, 25th-percentile, and 75th-percentile over all frequencies (weighted amplitude), the BPM, and perhaps some other good characteristic to later be able to cluster similar sounds together.\n\nFirst I tried to use ruby-audio and fftw3 but I never go the two to really work together. The documentation wasn't good either so I really didn't know what data was being shuffled around.\nNext I tried to use bplay / brec and limit my Ruby script to just use STDIN and perform an FFT on that (still using fftw3). But I couldn't get bplay/brec to work since the server doesn't have a sound card and I didn't manage to just get the audio directly to STDOUT without going to an audio device first.\n\nHere's the closest I've gotten:\n\n```\n# extracting audio from wav with ruby-audio\nbuf = RubyAudio::Buffer.float(1024)\nRubyAudio::Sound.open(fname) do |snd|\n    while snd.read(buf) != 0\n        # ???\n    end\nend\n\n# performing FFT on audio\ndef get_fft(input, window_size)\n    data = input.read(window_size).unpack(\"s*\")\n    na = NArray.to_na(data)\n    fft = FFTW3.fft(na).to_a[0, window_size/2]\n    return fft\nend\n```\n\n\nSo now I'm stuck and can't find any more good results on Google. So perhaps you SO guys can help me out?\n\nThanks!\n    ", "Answer": "\r\nI think there are two problems here. One is getting the samples, the other is performing the FFT.\n\nTo get the samples, there are two main steps: decoding and downmixing. To decode wav files, you just need to parse the header so you can know how to interpret the samples. For mp3 files, you'll need to do a full decode. Once the audio has been decoded, if you are not interested in processing the stereo channels separately, you may need to downmix it into mono, since the FFT expects a single channel as input. If you don't mind venturing outside of Ruby, the sox tool makes this easy. For example ```\nsox song.mp3 -b 16 song.raw channels 1```\n should convert an mp3 to a mono file of pure PCM samples (i.e. 16-bit integers). BTW, a quick search revealed the ruby/audio library (perhaps it is the one mentioned in your post). It looks pretty good, especially since it wraps libsndfile.\n\nTo perform the FFT, I see three options. One is to use this snippet of code that performs an FFT. I'm no Ruby expert, but it looks like it might be OK. The second option is to use NArray. It has a ton of mathematical methods, including FFTW, available in a separate module, a tarball for which is linked in the middle of the NArray page. The third option is to write your own FFT code. It's not an especially complicated algorithm, and could give you great experience with numerical processing in Ruby (if you need that).\n\nYou are probably aware of this, but the FFT expects complex input and generates complex output. Audio signals are real, of course, so the imaginary component of the input should always be zero (```\na + 0*i```\n). Since your input is real, the output will be symmetrical about the midpoint of the output array. You can safely ignore the upper half. If you want the energy in a particular frequency bin (they are spaced linearly up to half the sample rate), you'll need to compute the magnitude of the complex value (```\nsqrt(real*real + imag*imag)```\n).\n\nOne more thing: Because frequency zero (the DC offset of the signal) and the Nyquist frequency (half the sample rate) have no phase components, some FFT implementations put them together into the same complex bin (one in the real component, one in the imaginary component, typically of the first bin). You can create some simple signals (all 1s for just a DC signal,  and alternating +1, -1 for a Nyquist signal) and see what the FFT output looks like.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform - Plot looks strange\r\n                \r\nThe beginning of my fft plot looks strange. Any ideas why?\nThe data were recorded at 400 HZ.\nThe plot shows only the first 400 datapoints.\nWhen I change it to e.g. y = df['Vibra0_X'][800:1200].values, the beginning of the plot looks the same:\n```\nimport scipy.fftpack\nfrom scipy.fft import fft, fftfreq\n\n# sample spacing\nT = 1.0 / 800.0\n\ny = df['Vibra0_X'].head(400).values\n\nN = len(y)\nx = np.linspace(0.0, N*T, N)\nyf = scipy.fftpack.fft(y)\nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\n\nfig, ax = plt.subplots()\nax.plot(xf, 2.0/N * np.abs(yf[:N//2]),linestyle='-', color='blue' )\n\nplt.ylabel('Amplitude')\nplt.xlabel('Frequency [Hz]')\nplt.title(\"Frequency domain of the signal\", fontsize=16)\n\n\nplt.show()\n\n```\n\n\nIs T correctly defined (assuming the data was recorded at 400 Hz)?\nOr is the plot correct and just implies noise?\nI have uploaded the datapoints (1 second, 400 datapoints) to https://pastebin.com/QCCnbugL\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform in OpenGL Compute Shader\r\n                \r\nI'm trying to implement FFT in OpenGL Compute Shaders in educational purposes (that's why I do not want to use CUDA and OpenCL), but I think that some approaches for parallel programming used in OpenCL, for example, are similar to OpenGL Compute Shaders. I've found several code examples of FFT in OpenCL: one of them is Eric Bainville's article. Sample source code from it is following:\n\n```\n__kernel void fft_radix2(__global const float2 * x,__global float2 * y,int p)\n\n{\n\n  int i = get_global_id(0); // number of threads\n\n  int t = get_global_size(0); // current thread\n\n  int k = i & (p-1); // index in input sequence, in 0..P-1\n\n  x += i; // input offset\n\n  y += (i<<1) - k; // output offset\n\n  float4 u = dft2( (float4)(x[0], mul_1(exp_alpha_1(-M_PI*(float)k/(float)p),x[t]) ));\n\n  y[0] = u.lo;\n\n  y[p] = u.hi;\n\n}\n```\n\n\nHere ```\nx```\n is input and ```\ny```\n is output for each step in FFT.After that, he says that \"This kernel must be called for ```\np = 1```\n, then ```\np = 2```\n, etc. until ```\np = N/2```\n. The number of threads at each call is ```\nN/2```\n, and the work group size WG doesn't matter since all threads are independent.\" Here ```\nN```\n is size of input (should be power of 2).\nSo, my question is about parameter ```\np```\n. How can I push that parameter in compute shader, so the latter will be invoked for ```\np = 1```\n, then ```\np = 2```\n, etc. until ```\np = N/2```\n?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Strange result from Fast Fourier transform signal reconstruction\r\n                \r\nI have some data which is shown in the below figure and am interested in finding some of its Fourier series coefficients.\n\n```\nr = np.array([119.80601628, 119.84629291, 119.85290735, 119.45778804,\n   115.64497439, 105.58519852, 100.72765819, 100.04327702,\n   100.08590518, 100.35824977, 101.58424993, 105.47976376,\n   112.27556007, 117.07679226, 118.99998888, 119.60458086,\n   119.78624424, 119.83022022, 119.36116943, 115.72323767,\n   106.58946834, 101.19479124, 100.11537349, 100.13313755,\n   100.41846106, 101.42255377, 104.33650237, 109.73625492,\n   115.14763728, 118.24665037, 119.35359999, 119.68061835])\n\nz = np.array([-411.42980545, -384.98596279, -358.13032372, -330.89578468,\n   -303.39129113, -275.76248957, -248.24478443, -221.07069838,\n   -194.33260984, -168.05271807, -142.19357982, -116.62090103,\n    -91.15354178,  -65.56745626,  -39.65284757,  -13.29632162,\n     13.54374939,   40.84929432,   68.50496394,   96.33720787,\n    124.08525182,  151.36802193,  177.98791952,  204.0805317 ,\n    229.85399128,  255.44727674,  281.02166554,  306.75399703,\n    332.74638285,  359.05528646,  385.74336711,  412.8189858 ])\n\nplt.plot(z, r, label='data')\nplt.legend()\n```\n\n\n\nThen I calculate the average sampling period, since it is not constant as seen in the Z variable:\n\n```\nl = []\nfor i in range(32-1):\n    l.append(z[i]-z[i+1])\nTs = np.mean(l)\n```\n\n\nThen I calculate the fft:\n    from scipy.fftpack import fft\n\n```\nrf = scipy.fftpack.fft(r)\n```\n\n\nFor reconstruction of the signal then:\n\n```\nfs = 1/Ts\n\namp = np.abs(rf)/r.shape[0]\nn = r.shape[0]\ns = 0\nfor i in range(n//2):\n\n    phi = np.angle(rf[i], deg=False)\n    a   = amp[i]\n    k   = i*fs/n\n\n    s += a*np.cos(2*np.pi*k  *(z)  +phi)\n\nplt.plot(z, s, label='fft result')\nplt.plot(z, r, label='data')\nplt.legend()\n```\n\n\n\n\nThe result is strange however both in terms of amplitude and frequency.\n    ", "Answer": "\r\nThe complex spectrum is a symmetric spectrum with the range of (-fMax/2, ..., +fMax/2).\nYou only used the right hand positive part of the spectrum. This means, your reconstructed signal contains only half of the spectrums frequencies.\nBecause the spectrum is symmetric, all you have to do is to double the calculated absolute values. However, there is an important exception. The DC value amplitude[0] must not be doubled.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Calculating frequency present in Fast Fourier Transform\r\n                \r\nI have signal output values recorded by a Software-defined radio whose center frequency was 162.550 MHz & sample rate of 1,000,000. Now to analyse the data in frequency domain I calculated FFT which was straight forward. \n\n```\n#Calculating FFT of signal \nfourier=np.fft.fft(RadioData)\n```\n\n\nSince for Amplitude vs Frequency plot I need to calculate frequencies present in the signal too. I used Numpy fftfreq for that.\n\n```\nfreq=np.fft.fftfreq(fourier.shape[0])\n```\n\n\nThe output was in the range of [-0.5 0.4999995]. I am confused how to interpret this result or alternatively how to calculate frequencies present in the data ?\n    ", "Answer": "\r\nWhen SDR samples are baseband IQ (or complex, or cosine/sine), then the bandwidth is equal to the IQ sample rate.  This is because baseband IQ samples (unlike single_channel strictly real samples) can contain both positive and negative frequency spectrum, independently, half the bandwidth above and half the bandwidth below an RTL-SDR's (et.al.) tuned RF frequency setting (unless a frequency offset is selected).\n\nThus, the frequency range of the FFT of IQ data will be from Fcenter - (indicated_bandwidth/2) to almost Fcenter + (indicated_bandwidth/2).  Or for your example: 162.050 to (a bit below) 163.050 MHz. (the \"bit below\" value depends on the FFT size.)  The step size, dF, with be the IQ sample rate divided by the FFT length.\n\n(Note that the data rate in scalar samples is twice the IQ sample rate because each IQ sample contains two samples (real and imaginary components, or cosine and sine mixer outputs).  Thus, because each IQ sample contains more information, the information bandwidth can be greater.  But SDR apps usually indicate the IQ sample rate, not the higher raw data rate.)\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for an accelerometer in Python\r\n                \r\nI have data from the accelerometer in m/s2 (Y-axis) for a time period  in seconds (X-axis). I would like to convert this data real-time so that I get the value of an acceleration related to the frequency in Hz. I know that, for example, there is an FFT function in numpy, but I have no idea at all how to use it. I would appreciate, if somebody could provide an example code to convert the raw data (Y: m/s2, X: s) to the desired data (Y: m/s2, X: Hz). It should not be necessarily exactly this function. Thanks!\n    ", "Answer": "\r\nFirst, let's create a time-domain signal.\nFor simplicity, I will create a sine wave with frequency components ```\n12Hz```\n and ```\n24Hz```\n and you can assume the unit of the values are ```\nm/s^2```\n:\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# This would be the actual sample rate of your signal\n# since you didn't provide that, I just picked one\n# big enough to make our graphs look pretty\nsample_rate = 22050\n\n# To produce a 1-second wave\nlength = 1\n\n# The x-axis of your time-domain signal\nt = np.linspace(0, length, sample_rate * length)\n\n# A signal with 2 frequency components\n# - 12Hz and 24Hz\ny = np.sin(12 * (2 * np.pi) * t) + 0.5*np.sin(24 * (2 * np.pi) * t) \n\n# Plot time domain signal\nplt.plot(t, y)\nplt.xlabel(\"Time (s)\")\nplt.show()\n```\n\nThis will output:\n\nNow, we continue on with the script by taking the Fourier transform of our original time-domain signal and then creating the magnitude spectrum (since that gives us a better way to visualize how each component is contributing than the phase spectrum):\n```\n# This returns the fourier transform coeficients as complex numbers\ntransformed_y = np.fft.fft(y)\n\n# Take the absolute value of the complex numbers for magnitude spectrum\nfreqs_magnitude = np.abs(transformed_y)\n\n# Create frequency x-axis that will span up to sample_rate\nfreq_axis = np.linspace(0, sample_rate, len(freqs_magnitude))\n\n# Plot frequency domain\nplt.plot(freq_axis, freqs_magnitude)\nplt.xlabel(\"Frequency (Hz)\")\nplt.xlim(0, 100)\nplt.show()\n```\n\nSo now we can visualize the frequency-domain:\n\nNotice how the magnitude of the ```\n24Hz```\n component is about half of the ```\n12Hz```\n component. That is because I purposely timed the ```\n24Hz```\n component by ```\n0.5```\n on the time-domain signal, so the ```\n24Hz```\n component 'contributes' less to the overall signal, hence we get this halved spike for that component.\nNote, also, that the y-axis of our output signal is not really in ```\nm/s^2 per Hz```\n as you wanted. But you could compute the actual ```\nm/s^2```\n values by taking the integral over your desired frequency band.\nI'll leave the jupyter notebook I created available here, feel free to use it and open issues if you have any problems with it.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fast fourier transform apply window and overlap\r\n                \r\nThis may be a naive question, but I didn't find exact details in searching.\n\nIn FFT with window overlapping, after we've applied window functions to sequences of data set with overlapping and got the FFT results, how do we combine those FFT results for overlapping sequence? \n\nDo we just add them together, treating those frequency domain results as non-overlapping parts?\n\nAre magnitudes of these results in complex numbers frequency magnitudes?\n\nThank you. \n    ", "Answer": "\r\nFor each FFT you typically calculate the magnitude of each complex output bin - this gives you a spectrum (magnitude versus frequency) for one window. The sequence of magnitude spectra for all time windows is effectively a 3D data set or graph - magnitude versus frequency versus time - which is typically plotted as a a spectrogram, waterfall or time varying 2D spectrum. \n\nIn the specific case where the data is statistically stationary and you just want to reduce the variance you can average the successive magnitude spectra - this is called ensemble averaging. Normally though for time-varying signals such as speech or music you would not want to do this.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "DM Script, why does the fourier transform of gaussian-kenel needs modulus\r\n                \r\nRecently I learn DM_Script for TEM image processing\nI needed Gaussian blur process and I found one whose name is 'Gaussian Blur' in http://www.dmscripting.com/recent_updates.html\n\nThis code implements Gaussian blur algorithm by multiplying the fast fourier transform(FFT) of source image by the FFT of Gaussian-kernel image and finally doing inverse fourier transform of it.\n\nHere is the part of the code,\n\n```\n// Carry out the convolution in Fourier space\n\ncompleximage fftkernelimg:=realFFT(kernelimg) (-> FFT of Gaussian-kernel image)\ncompleximage FFTSource:=realfft(warpimg) (-> FFT of source image)\ncompleximage FFTProduct:=FFTSource*fftkernelimg.modulus().sqrt()\nrealimage invFFT:=realIFFT(FFTProduct)\n```\n\n\nThe point I want to ask is this\n    compleximage FFTProduct:=FFTSource*fftkernelimg.modulus().sqrt()\n\nWhy does the FFT of Gaussian-kernel need '.modulus().sqrt()' for the convolution?\n\nIt is related to the fact that the fourier transform of a Gaussian function becomes another Gaussian function?\nOr It is related to a sort of limitation of discrete fourier transform?\n\nPlease answer me\nThanks\n    ", "Answer": "\r\nThis is related to the general precision limitation of any floating point numeric computing. (see f.e. here, or more in depth here)\n\nA rotational (real-valued) Gaussian of stand.dev. sigma should be transformed into a 100% real-values rotational Gaussioan of 1/sigma. However, doing this numerically will show you deviations: Just try the following:\n\n```\nnumber sigma = 30\nnumber A0 = 1\nrealimage first := RealImage( \"First\", 8, 256, 256 )\nfirst = A0 * exp( - (iradius**2/(2*sigma*sigma) ))\nfirst.showimage()\ncomplexImage second := FFT(first)\nsecond.Showimage()\n\nimage nonZeroImaginaryMask = ( 0 != second.Imaginary() )\nnonZeroImaginaryMask.Showimage()\nnonZeroImaginaryMask.SetLimits(0,1)\n```\n\n\nWhen you then multiply these complex images (before back-transferring) you are introducing even more errors. By using modulus, one ensures that the forward transformed kernel is purely real and hence a better \"damping\" curve.\n\nA better implementation of a FFT filtering code would actually create the FFT(Gaussian) directly with a std.dev of 1/sigma, as this is the analytically correct result. Doing a FFT of the kernel only makes sense if the kernel (or its FFT) is not analytically known.\n\nIn general: When implementing any \"maths\" into a program code, it can pay hugely to think it through with numerical computation limits in the back of your head. Reduce actual computation whenever possible (i.e. compute analytically and use the result instead of relying on brute force numerical computation) and try to \"reshape\" equations when possible, f.e. avoid large sums over many small numbers, be careful about checks against exact numeric values, try to avoid expressions which are very sensitive on small numerica errors  etc. \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to use Fast Fourier Transform to execute convolution of matrix?\r\n                \r\nI need to add many big 3D arrays (with a shape of 500x500x500) together and want to speed up the process by using multiplication in the Fourier space. The problem is that I don't get the same answer when multiplying in the Fourier space compared to simply adding the matrix.\n\nTo test it out, I wrote a minimal example trying to make it work but the answer is not what I expected. Either my math knowledge is wrong or I am not using the function correctly.\n\nBelow is the simplest code showing what I am trying to do:\n\n```\nimport numpy as np\n\nc = np.asarray(((1,2),(2,3)))\nd = np.asarray(((1,4),(1,5)))\n\nprint(\"Transform\")\nNc = np.fft.rfft2(c)\nNd = np.fft.rfft2(d)\n\nprint(\"Inverse\")\nNnc = np.fft.irfft2(Nc)\nNnd = np.fft.irfft2(Nd)\n\nprint(\"Somme\")\nS = np.dot(Nc, Nd)\nprint(np.fft.irfft2(S))\n```\n\n\nWhen I print S, I get the result:\n\n```\n[[6, 28],[10,46]]\n```\n\n\nBut from what I understood about the Fourier space, multiplication would mean addition outside of the Fourier space so I should get ```\nS = c + d```\n?\n\nAm I doing something wrong using the FFT function or is my assumption that S should equal c plus d wrong?\n    ", "Answer": "\r\nThere is a little misunderstanding here: \n\nMultiplication in Fourier space corresponds to convolution in the spatial domain and not to addition.\n\nThere is no way to speed up addition in that way.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform With Microphone Input Data in AS3\r\n                \r\nIs it possible to get the source of adobes ```\nflash.media.SoundMixer```\n class ?\n\nIf it is, where can i find / get it ?\n\nI waht to \"clone\" the ```\n.computeSpectrum()```\n function to transform a raw sound wave ( byteArray ) from Microphone input into a frequency spectrum.\n\nI've found a couple of examples like this one -> http://pierrickpluchon.fr/blog/as3-how-to-plug-your-microphone-with-a-soundspectrum-in-flash-player-10-1/\n\nAll other methos i've found are pretty much the same.\n\nThe problem is that there is always a ```\nSound()```\n playing, what i DON'T want. ( I don't want any loopback )\n\nBut if i'm not playing a sound, i can't use the ```\nSoundMixer.computeSpectrum()```\n function to transform my ByteArray that comes from the ```\nMicrophone```\n to a frequency spectrum by turning the FFTMode to true ( ```\ncomputeSpectrum(myByteArray,true)```\n )\n\nAlso if you know any other method to get the Frequency Spectrum from the Raw Sound Wave, please let me know.\n\nUPDATE\n\nmy code:\n\n```\nvar bytes:ByteArray = new ByteArray();\n\nvar mic:Microphone = Microphone.getMicrophone();\nmic.rate = 44;\n// mic.gain = 100; // gain\nmic.addEventListener(SampleDataEvent.SAMPLE_DATA, onSampleData);\n\nfunction onSampleData( event:SampleDataEvent ):void {\n    graphics.clear();\n    graphics.lineStyle(1, 0xFF0000);\n    for( var i:uint = 0; i < 256; i++ ) {\n        var num:Number = event.data.readFloat() * 100 + 100; // -Math.abs( )\n        if( i == 0 ) {\n            graphics.moveTo( i, num );\n        } else {\n            graphics.lineTo( i, num );\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\n\n  \"..Also if you know any other method to get the Frequency Spectrum from the Raw Sound Wave, please let me know.\"\n\n\nWell Joe Beuckman beat me to it and gave you the link to Gerry Beauregard's FFT code. That's the best AS3 one I've seen so far since I found it two years ago. From the comments I see you were wondering how to implement... Well to see implementation code you need to see another page on his blog:\n\nhttp://gerrybeauregard.wordpress.com/2010/08/06/real-time-spectrum-analysis/\n\n\nTo test that code yourself you first have to save the classes shown in the link here: http://gerrybeauregard.wordpress.com/2010/08/03/an-even-faster-as3-fft/\nSave each package's code respectively as FFT2.as and FFTElement.as\nNow in your document class put the code from:  http://gerrybeauregard.wordpress.com/2010/08/06/real-time-spectrum-analysis/  \n\n\nHowever in that code you must also add some lines importing the other saved .as classes \n\n```\nimport __AS3__.vec.Vector;\nimport flash.display.Sprite;\nimport flash.events.*;\nimport flash.media.Microphone;\nimport flash.text.*;\nimport flash.utils.*;\n\nimport FFT2;\nimport FFTElement;\n```\n\n\nNow it should run without errors and show the same thing as screenshot on his blog. The online demo used to work for me but not today so I say screenshot just so you know what to expect when it works fine.\n\nHope it helps. VC:One\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Would multithreading help a Fast Fourier Transform?\r\n                \r\nI have to get performance out of an application by multi-threading it for a project. So far I attempted to make a Task that would be created to handle a 2048 segment of audio, and that task would be created for each segment to run independently. However, this configuration means making several thousands of tasks which causes more performance problems then worth, not to mention I couldn't find a way to convert the existing recursive FFT into an iterative one to maintain that 1:1 on segments to tasks.\nWould there be any benefit to continuing to attempt this? or should I look more to optimizing the application else where.\n    ", "Answer": "\r\nLook at your core usage on your computer when running the transformation as a serial process. Have you maxed out your CPU?\nIf not, then the parallel library can help you access more computing power.\nI would recommend reading up on tutorials and theory on the parallel library (assembly) in C#.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform Algorithm and Technical Analysis\r\n                \r\nMy Mini Practice Project requires me to do:\n\n\nDownload stock prices.\nDetrend stock prices.\nSmooth detrended stock prices. \nApply FFT algorithm.\n\n\nThe Mini Practice Project Python code can be seen below:\n\n```\n#Python code: Download the Daily Stock Prices from Yahoo Finance \nfrom matplotlib.finance \nimport quotes_historical_yahoo \nfrom pylab\nimport * import numpy as np import\nscipy.signal as sc import\nmatplotlib.pyplot as plt \nimport pandas as pd\nticker='AAPL' begdate=(2013,12,6) enddate=(2015,12,20)\ndata = quotes_historical_yahoo(ticker, begdate, enddate,asobject=True, adjusted=True)\naapl=data.aclose[1:]\nnp.count_nonzero(aapl)\nplt.plot(aapl)\nplt.title(‘Apple stock price movement’)\n\n#Python code: Detrend stock prices\ndetrend=sc.detrend(aapl)\nplt.plot(detrend)\nplt.title(‘Apple stock detrended prices’) \n\n#Python code: Smooth Detrended Apple Stock Prices \nw=np.blackman(20) \n\n#we selected 20 the parameter of the blackman window function \ny=np.convolve(w/w.sum(),detrend,mode='same')\nplt.plot(y) plt.title(‘Blackman window function for detrended Apple stock\nprice’) \n\n#Python code: Apply FFT Algorithm \nfft=abs(rfft(y)) plt.plot(fft)\nplt.title(‘FFT Algorithm applied to Apple stock price’)\n```\n\n\nWhen I type >>> fft, the result should be:\narray([ 31.29635197, 2706.46455209, 1093.11797192, 904.02261366, 582.27538238, 282.87694269, 244.95336969, 501.27771573, 247.04690328, 554.24978967, 115.67400179, 270.14245787, 194.51970654, 179.0406388, 302.98350318, 170.32131932, 51.39420044, 87.25308608, 87.15654977, 39.34619432])\n\nI keep getting a code error: from matplotlib.finance is an invalid syntax. How do I fix this?\n    ", "Answer": "\r\n```\nfrom matplotlib.finance \nimport quotes_historical_yahoo \n```\n\n\nshould be on the same line like so:\n\n```\nfrom matplotlib.finance import quotes_historical_yahoo\n```\n\n\nAlternatively, you can break lines:\n\n```\nfrom matplotlib.finance \\\nimport quotes_historical_yahoo \n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Analytical Fourier transform vs FFT of functions in Matlab\r\n                \r\nI have adapted the code in Comparing FFT of Function to Analytical FT Solution in Matlab for this question. I am trying to do FFTs and comparing the result with analytical expressions in the Wikipedia tables.\n\nMy code is:\n\n```\na = 1.223;\nfs = 1e5; %sampling frequency\ndt = 1/fs;\nt = 0:dt:30-dt;     %time vector\nL = length(t); % no. sample points\nt = t - 0.5*max(t); %center around t=0\n\ny = ; % original function in time\nY = dt*fftshift(abs(fft(y))); %numerical soln\n\nfreq = (-L/2:L/2-1)*fs/L; %freq vector\nw = 2*pi*freq; % angular freq\n\nF = ; %analytical solution\n\nfigure; subplot(1,2,1); hold on\nplot(w,real(Y),'.')\nplot(w,real(F),'-')\nxlabel('Frequency, w')\ntitle('real')\nlegend('numerical','analytic')\nxlim([-5,5])\nsubplot(1,2,2); hold on;\nplot(w,imag(Y),'.')\nplot(w,imag(F),'-')\nxlabel('Frequency, w')\ntitle('imag')\nlegend('numerical','analytic')\nxlim([-5,5])\n```\n\n\nIf I study the Gaussian function and let\n\n```\ny = exp(-a*t.^2); % original function in time\n\nF = exp(-w.^2/(4*a))*sqrt(pi/a); %analytical solution\n```\n\n\nin the above code, looks like there is good agreement when the real and imaginary parts of the function are plotted:\n\n\n\nBut if I study a decaying exponential multiplied with a Heaviside function:\n\n```\nH = @(x)1*(x>0); % Heaviside function\ny = exp(-a*t).*H(t);\n\nF = 1./(a+1j*w); %analytical solution\n```\n\n\nthen\n\n\n\nWhy is there a discrepancy? I suspect it's related to the line ```\nY =```\n but I'm not sure why or how.\n\nEdit: I changed the ```\nifftshift```\n to ```\nfftshift```\n in ```\nY = dt*fftshift(abs(fft(y)));```\n. Then I also removed the ```\nabs```\n. The second graph now looks like:\n\n\n\nWhat is the mathematical reason behind the 'mirrored' graph and how can I remove it?\n    ", "Answer": "\r\nThe plots at the bottom of the question are not mirrored. If you plot those using lines instead of dots you'll see the numeric results have very high frequencies. The absolute component matches, but the phase doesn't. When this happens, it's almost certainly a case of a shift in the time domain.\n\nAnd indeed, you define the time domain function with the origin in the middle. The FFT expects the origin to be at the first (leftmost) sample. This is what ```\nifftshift```\n is for:\n\n```\nY = dt*fftshift(fft(ifftshift(y)));\n```\n\n\n```\nifftshift```\n moves the origin to the first sample, in preparation for the ```\nfft```\n call, and ```\nfftshift```\n moves the origin of the result to the middle, for display.\n\n\n\nEdit\n\nYour ```\nt```\n does not have a 0:\n\n```\n>> t(L/2+(-1:2))\nans =\n  -1.5000e-05  -5.0000e-06   5.0000e-06   1.5000e-05\n```\n\n\nThe sample at ```\nt(floor(L/2)+1)```\n needs to be 0. That is the sample that ```\nifftshift```\n moves to the leftmost sample. (I use ```\nfloor```\n there in case ```\nL```\n is odd in size, not the case here.)\n\nTo generate a correct ```\nt```\n do as follows:\n\n```\nfs = 1e5; % sampling frequency\nL = 30 * fs;\nt = -floor(L/2):floor((L-1)/2);\nt = t / fs;\n```\n\n\nI first generate an integer ```\nt```\n axis of the right length, with 0 at the correct location (```\nt(floor(L/2)+1)==0```\n). Then I convert that to seconds by dividing by the sampling frequency.\n\nWith this ```\nt```\n, the ```\nY```\n as I suggest above, and the rest of your code as-is, I see this for the Gaussian example:\n\n```\n>> max(abs(F-Y))\nans =    4.5254e-16\n```\n\n\nFor the other function I see larger differences, in the order of 6e-6. This is due to the inability to sample the Heaviside function. You need t=0 in your sampled function, but H doesn't have a value at 0. I noticed that the real component has an offset of similar magnitude, which is caused by the sample at t=0.\n\nTypically, the sampled Heaviside function is set to 0.5 for t=0. If I do that, the offset is removed completely, and max difference for the real component is reduced by 3 orders of magnitude (largest errors happen for values very close to 0, where I see a zig-zag pattern). For the imaginary component, the max error is reduced to 3e-6, still quite large, and is maximal at high frequencies. I attribute these errors to the difference between the ideal and sampled Heaviside functions.\n\nYou should probably limit yourself to band-limited functions (or nearly-band-limited ones such as the Gaussian). You might want to try to replace the Heaviside function with an error function (integral of Gaussian) with a small sigma (```\nsigma = 0.8 * fs```\n is the smallest sigma I would consider for proper sampling). Its Fourier transform is known.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "inverse fast fourier transform for frequency range\r\n                \r\nMy problem is to obtain original signal from amplitude spectrum (fft) based on inverse fft but only for some frequency range ex. 8-12 Hz. Could anyone help me? I try to used: \n\n```\nxdft=fft(x); \nixdft=ifft(xdft(a:b)), %where xdft(a:b) is |Y(f)| for freq 8-12 Hz.\n```\n\n\nBut it doesn't want to work.\n    ", "Answer": "\r\nYou can set all the values of ```\nxdft```\n to zero except those you want, i.e.,\n\n```\nxdft = fft(x);\nxdft = xdft(1:ceil(length(xdft) / 2));\nxdft(1:a) = 0;\nxdft(b+1:end) = 0;\nixdft = ifft(xdft, 'symmetric');\n```\n\n\nThe reason I have taken only half of the original FFT'd data is that your result will be symmetric about Fs / 2 (where Fs is the sample rate), and if you don't do the same thing to the frequencies either side of the centre, you will get a complex signal out. Instead of doing the same thing to both sides manually, I've just taken one side, modified it, and told ```\nifft```\n that it has to reconstruct the data for the full frequency range by appending a mirror image of what you pass it; this by done by calling it with the ```\n'symmetric'```\n option.\n\nIf you need to figure out what ```\na```\n and ```\nb```\n should be for some frequency, you can first create a vector of the frequencies at which you've performed the FFT, then find those frequencies that are within your range, like so:\n\n```\nxdft = fft(x);\nxdft = xdft(1:ceil(length(xdft) / 2));\nf = linspace(0, Fs / 2, length(xdft));\nkeepInd = f >= 8 & f <= 12; % Keep frequencies between 8 and 12 Hz\nxdft(~keepInd) = 0;\n```\n\n\nNote that I've actually omitted the use of the two variables ```\na```\n and ```\nb```\n altogether in this example and opted for logical indexing, and that ```\nFs```\n is the sample rate.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "\"Tree\" for Fast Fourier Transform polynomial evaluation?\r\n                \r\nI am trying to evaluate polynomial A(x) through a divide and conquer algorithm using the FFT. I basically break the polynomial into its odd roots and even roots and then recurse on the two smaller polynomials.(allowing me to evaluate twice the number values per recursion).\n\nTo visualize this, I am trying to create a tree to show the polynomial's path through the algorithm. I am not exactly sure how to get started- could someone just start me off? I am not expecting a complete tree just a brief example to get me on the right path.\n    ", "Answer": "\r\nHere is a simple example from Chapter 2 of Algorithms:\n\n```\nA(x) = 3 + 4x + 6x^2 + 2x^3 + x^4 + 10x^5\n     = (3 + 6x^2 + x^4) + x(4 + 2x^2 + 10x^4)\n     = E(x^2) + x*O(x^2)\n```\n\n\nwhere\n\n```\nE(x) = 3 + 6x + x^2\nO(x) = 4 + 2x + 10x^2\n```\n\n\nNotice how the size of the polynomial has shrunk by a factor of 2? Also, we can recycle an evaluation at ```\nx```\n since ```\n-x```\n will result in a similar value.\n\n```\nA(x) = E(x^2) + x*O(x^2)\nA(-x) = E(x^2) - x*O(x^2)\n```\n\n\nI hope you can see how this recursive process becomes a tree.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "3d vibration data with Fast Fourier Transform\r\n                \r\nI'm trying to use FFT method in python to convert 3d vibration data collected from accelerometer. We set the frequency to 50 hz. \n\nWhen I was trying to plot the data, I got a weird graph. Can someone please tell me why? \n\n```\nimport scipy.fftpack\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nY = pd.read_excel(r'/Users/0000/Documents/0000/data/accelData1.xls')\n\n\ny1 = Y['X'].values\ny2 = Y['Y'].values\ny3 = Y['Z'].values\n\ny = y1 + y2 +y3\n\nN = 1280\nT = 0.01\nx = np.linspace(0.0, N*T, N)\n\nyf = np.abs(scipy.fft(y))\nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\n\n\nplt.plot(yf[0:N//2], xf, label = 'signal')\n\n```\n\n\nfft plot\n\n\n    ", "Answer": "\r\nYour graph is upside down, you inverted x and y when plotting\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Dividing fourier transform by factor n\r\n                \r\nI have a problem with the fast fourier transform in python. I would like to extract the low and high frequency power of a signal. I have seen the following example:\n\n```\nY = np.fft.fft(signal)/n #Calculate FFT\nY = Y[range(n/2)] #Return one side of the FFT\nlf = np.trapz(abs(Y[(frq>=0.04) & (frq<=0.15)]))\nhf = np.trapz(abs(Y[(frq>=0.16) & (frq<=0.5)])) #Do the same for 0.16-0.5Hz (HF)\n```\n\n\n```\nsignal```\n is just a an array of values (Let's say 10000 values).\n\nThe problem here is that I don't see what ```\nn```\n should be. Should ```\nn```\n just be the length of ```\nsignal```\n?\n    ", "Answer": "\r\nNo, n should not always be the length of the signal.  n is the length of the FFT, which is determined by the frequency resolution and time localization required, which may also depend on the stationarity and/or other characteristics of the signal, as well as whether any windowing or zero-padding is to be used.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Is there a package in R that gives -normalized- inverse FFT?\r\n                \r\nHas anyone written a fast Fourier transform extension for R that modifies R's native fft() function so that when you call for the inverse fast Fourier transform you don't have to divide by the length of the fast Fourier transform output? I'm doing a lot of FFTs and inverse FFTs and having to do this every time is getting annoying.\n    ", "Answer": "\r\nYou could write your own:\n\n```\nfftinv <- function( x ) { fft( x, inverse=TRUE ) / length( x ) }\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Calculating W for NTT (Integer Fast Fourier Transform)\r\n                \r\nI'm attempting to implement an NTT (Number Theoretic Transform) in Objective C, however the abstract mathematical documents posted online are missing crucial details.  I've found the following existing Question on Stack Overflow which purports to include a working (albeit non-optimal) implementation of NTT:\nModular arithmetics and NTT (finite field DFT) optimizations\n\nMy question is regarding the computation of \"W\".  \"p\" is obviously a chosen prime number.  However this implementation computes \"W=(2^L) mod p\".  \"L\" is a predefined constant equal to \"0x30000000\", which is most definitely not a power of base 2.  This directly contradicts several different mathematical abstracts I've found which seem to indicate that \"L\" should not only be the number of elements in the source array (and thus a power of base 2), but also variable to boot!  Obviously I'm missing something important here.  Can someone please resolve this contradiction.  How was the value of \"L\" chosen here?  More importantly, given a different prime number how would one go about determining the corresponding value of \"L\"?\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast-fourier transform for low-frequency signals in the WebAudio API / javascript\r\n                \r\nI have a single-channel wave coming in at an 8000 Hz sampling rate.\n\nI need to analyze frequencies that are between 5 Hz and 300 Hz in real-time, with emphasis on signals from 10 to 60 Hz.\n\nMy thought initially is to run the 8000 Hz sample into a buffer, collecting about 32000 samples. Then, run a 32000 window-sized fourier transform on it. \n\nThe reasoning here is that for lower-frequency signals, you need a larger window size (right?)\n\nHowever, if I'm trying to display this signal in real-time, it seems like the AudioAnalyserNode might not be a good choice here. I know the WebAudio API would allow me to get the raw data, but ideally the AudioAnalyserNode would be able to run a new fft based on the previous 32000 samples, even if a smaller amount of samples have become newly available. At this point, it seems like the fft data is only updating once every four seconds.\n\nDo I have to create a special \"running bin\" so that the display updates more frequently than once every 4 seconds? Or, what's the smallest window size I can use to still get reasonable values in this range? Is 32000 a large enough window size? \n\nI am using the WebAudio API analyser node in javascript, but if I have to get the raw data, I'm also willing to change libraries to another one in javascript.\n    ", "Answer": "\r\nUsing an AnalyserNode, you can call ```\ngetFloatFrequencyData```\n as often as you like.  This will return the FFT of the last ```\nfftSize```\n samples.  These get smoothed together.  For full details, see AnalyserNode Interface\n\nAlso, the WebAudio spec allows you to construct an ```\nAudioContext```\n with a user-selectable sample rate.  You could set your sample rate to 8000 Hz.  Then your FFTs can have finer resolution with less complexity.\n\nHowever, I don't think any browser has implemented this capability yet.\n\nAn alternative would be to get a supported audio card that allows a sample rate of 8000 Hz and set up your system to use that as the default audio output device,  Then the audio context will have a sample rate of 8000 Hz.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform for radial forces in Python\r\n                \r\nFirst of all I want to say that I am very new in this and some help it would be welcome. I want to calculate fft for radial forces and something I'm missing. Until now I have something like this:\n\n```\nt=np.arange(145)\nsp=np.fft.fft(radial_force)\nfreq=np.fft.fftfreq(t.shape[-1])\npl.plot(freq, radial_force.real, freq,radial_force.imag)\npl.show()\n```\n\n\nI get really big values and I don't know why. Any hint would be helpful.\nThank you in advance !\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to use fast Fourier transform for the complex values in MATLAB\r\n                \r\nI solved a differential equation and the solutions of that are the complex values in the time domain. I have to transform it to the frequency domain with FFT. I have used FFT in MATLAB, but the answers are not correct. How can I choose my interval of frequency?\nThe time domain is between -10 and 60 and the number of steps is 1000.\n```\nfunction r = fur()\n    clc\n    clear\n    format long\n    a = -10;          % tmin\n    b = 60;           % tmax\n    m = 1000;         % Number of steps\n    t = zeros(1, m);\n    y = zeros(1, m);\n\n    t(1) = a;         % Boundary condition\n    y(1) = 0;         % Boundary condition\n    t0 = 0.01;\n    h = (b-a)/m;\n\n    for j=1:m\n        T = t(j); Y = y(j);\n        k1 = h*Fun(T, Y);\n        k2 = h*Fun(T + h/2, Y + k1/2);\n        k3 = h*Fun(T + h/2, Y + k2/2);\n        k4 = h*Fun(T + h, Y + k3);\n        y(j+1) = Y + (k1 + 2*k2 + 2*k3 + k4)/6;\n        t(j+1) = a + h*(j);\n    end\n\n    % real_y = real(y);\n    % imag_y = imag(y);\n    y;\n\n    %% Fast Fourier transformation for P(W)\n\n    NFFT = length(y);\n    fs = 2*pi/h;\n    X = fftshift(fft(y, NFFT));\n    fVals = (0:NFFT-1)*fs/NFFT;\n\n    figure(1)\n    plot(fVals, abs(X), '-b');\n    title('Fast Fourier transform');\n    xlabel('Frequency (THz)')\n    ylabel('p(w)');\n\n    hold on\n\n\n    %% Fast Fourier transformation for E(W)\n\n    NFFT = length(y);\n\n    fs = 2*pi/h;\n    Z = fftshift(fft(Et(t, t0), NFFT));\n    fVals = (0:NFFT-1)*fs/NFFT;\n\n    figure (2)\n    plot(fVals, abs(Z), '-r');\n    title('Fast Fourier Transform');\n    xlabel('Frequency (THz)')\n    ylabel('E(w)');\n    hold on\n\n    %% Linear susceptibility\n\n    f = X./Z;\n    f_imag = imag(f);\n    f_real = real(f);\n    fVal = (0:NFFT-1)*fs/NFFT;\n\n    figure(3)\n    plot(fVal, f_real, '-r');\n    title('total part of susceptibility');\n    xlabel('Frequency (THz)')\n    ylabel('Kappa(w)');\n    hold on\n\n    figure(4);\n    plot(fVals, f_imag, '-r');\n    title('imaginary part of susceptibility');\n    xlabel('Frequency (THz)')\n    ylabel('kappa(w)');\n    hold on\n```\n\nAnd this is the Fun.m file:\n```\nfunction F = Fun(t, y)\n    format long\n    E_g = 1.52; % Binding energy for GaAs\n    gamma = 0.1*E_g;\n    t0 = 0.01; % This is a damping operator\n    k = 1;\n    F = -i*((((k^2)-i*gamma)*y)-Et(t, t0)); % F = -i*((-i*gamma)*y-1/2);;\n```\n\nAnd this is the Et.m file:\n```\nfunction e = Et(t, t0)\n    format long\n    t0 = 0.1;\n    e = (1/2)*(exp(-(t/t0).^2));\nend\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform of subset of vibration dataset\r\n                \r\nI am new at signal processing. I am trying to compute and plot FFT of a given dataset. The dataset corresponds to vibration signals captured using accelerometer. Dataset contains amplitude in x, y and z direction along with time.\nThe problem that I am facing is when I try to take a subset of the data, the FFT gives a straight line, I cannot see the frequencies and amplitude in those. Below is the code that I am using:\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.fftpack import fft\nfrom scipy import signal\nimport tkinter as tk\nfrom tkinter import filedialog\nimport time\n\n#Prompt user for file\nroot = tk.Tk()\nroot.withdraw()\nfile_path = filedialog.askopenfilename(filetypes=[(\"Two Column CSV\",\"*.csv\")])\nprint(file_path)\ntitle = input(\"Enter Experiment Name: \")\n\n#Load Data (assumes two column array\ntic = time.process_time()\nx, y, z, t = np.genfromtxt(file_path,delimiter=',', unpack=True)\nprint(t)\ntoc = time.process_time()\nprint(\"Load Time:\",toc-tic)\n\n#Determine variables\nN = np.int(np.prod(t.shape))#length of the array\nFs = 1/((t[1]-t[0])/10**9)  #sample rate (Hz)\ntotal_duration = (t[-1] - t[0])/10**9\nT = 1/Fs\nt_sec = [(t[i+1] - t[0])/10**9 for i in range(0,len(t)-1)]\nprint('Total Duration: ', total_duration)\nprint(\"# Samples:\",N)\nprint('Sampling rate: ',Fs)\n\ntic = time.process_time()\nfig_fft, host_fft = plt.subplots()\nfig_fft.set_size_inches(16,9)\nplt.figure(3)  \nxf = np.linspace(0.0, 1.0/(2.0*T), N//2)\nyf = fft(x)\nplt.plot(xf, 2.0/N * np.abs(yf[0:np.int(N/2)]))\nplt.grid()\nplt.xlabel('Frequency (Hz)', fontsize=14)\nplt.ylabel('Acc (m/$sec^2$)', fontsize=14)\nplt.title('FFT (X)- ' + title, fontsize=18)\nplt.savefig('FFT (X) {}'.format(title), dpi=300, bbox_inches='tight')\nplt.show()\n```\n\nhere is the link to main dataset\nhere is the link to 10sec data extracted from above dataset\n\n\nplease let me know how to fix this problem.\nThank you\n    ", "Answer": "\r\nI frequently had this problem. The zeroth entry of the Fourier transform contains the integral (or the sum) of the signal. If your signal is not centered around zero, this entry will be always very large.\nThere are two easy ways to get around this: Either center the measured data around zero (but maybe you want to keep that information of the center for something else)\n```\nx = x - np.mean(x)\n```\n\nAlternatively, simply set the zeroth component to zero:\n```\nyf[0] = 0\n```\n\nA third way would be not to plot the zeroth entry of the array.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to transform a FFT (Fast Fourier Transform) into a Polar Transformation with Python?\r\n                \r\nI was able to create a FFT Transformation from my image but I don't know how to continue...\n\nI am using this to solve my problem: Align text for OCR\n\nThis code was all that worked for me until now:\n\n```\nimport cv2\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n%matplotlib inline\n\nimg = cv2.imread(r'test.jpg', cv2.IMREAD_GRAYSCALE)\n\nf = np.fft.fft2(img)\nfshift = np.fft.fftshift(f)\nmagnitude_spectrum = 20 * np.log(np.abs(fshift))\n\nplt.subplot(121), plt.imshow(img, cmap='gray')\nplt.title('Input Image'), plt.xticks([]), plt.yticks([])\n\nplt.subplot(122), plt.imshow(magnitude_spectrum, cmap='gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\n\nplt.show()\n```\n\n\nI need the mean value generated from a Polar Transformation, but I don't know how to transform a FFT to a Polar Transformation in Python.\n    ", "Answer": "\r\nThis is roughly solution to you problem; It was tested on one sample image, and the result looks credible. \n\n```\n# your code goes here... \n\ndef transform_data(m):\n    dpix, dpiy = m.shape\n    x_c, y_c = np.unravel_index(np.argmax(m), m.shape)\n    angles = np.linspace(0, np.pi*2, min(dpix, dpiy))\n    mrc = min(abs(x_c - dpix), abs(y_c - dpiy), x_c, y_c)\n    radiuses = np.linspace(0, mrc, max(dpix, dpiy))\n    A, R = np.meshgrid(angles, radiuses)\n    X = R * np.cos(A)\n    Y = R * np.sin(A)\n    return A, R, m[X.astype(int) + mrc - 1, Y.astype(int) + mrc - 1]\n\n    angles, radiuses, m = transform_data(magnitude_spectrum)\n\n    plt.contourf(angles, radiuses, m)\n```\n\n\n\n\nFinally, we can get the angle we want to turn the original image:\n\n```\nsample_angles = np.linspace(0,  2 * np.pi, len(c.sum(axis=0))) / np.pi*180\nturn_angle_in_degrees = 90 - sample_angles[np.argmax(c.sum(axis=0))]\n```\n\n\nFor my sample image I got: \n\n```\nturn_angle_in_degrees = 3.2015810276679844 degrees.\n```\n\n\nAlso, we can plot projected spectrum magnitude: \n\n```\nplt.plot(sample_angles, c.sum(axis=0))\n```\n\n\n\n\nHope that helps... \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Impact of data intervals in fast fourier transform\r\n                \r\nI have sampled sensor data for 1 minute with 5kHz sampling.\nSo, one sampled data file includes 5,000 x 60 = 300,000 data points.\nNote that the sensor measures periodic data such as 60Hz AC current.\n\nNow, I would like to apply FFT (using python numpy.rfft function) to the one data file.\nAs I know, the number of FFT results is half of the number of input data, i.e., 150,000 FFT results in the case of 300,000 data points.\nHowever, the number of FFT results is too large to analyze them.\n\nSo, I would like to reduce the number of FFT results.\nRegarding that, my question is that the following method valid given the one sampled data file?\n\n\nSegment the one sampled data file into M segments\nApply FFT to each segment\nAverage the M FFT results to get one averaged FFT result\nUse the average FFT result as FFT result of the given one sampled data file\n\n\nThank you in advance.\n    ", "Answer": "\r\nIt depends on your purposes. \n\nIf source signal is sampled with 5 kHz, then frequency of max output element will corresponds to 2.5 kHz. So for 150K output length frequency resolution will about 0.017 Hz. If you apply transform to 3000 data points, you'll get freq.resolution 1.7 Hz. \n\nIs this important for you? Do you need to register  all possible frequency components of AC current? \n\nAC quality (magnitude, frequency, noise) might vary during one-minute interval. Do you need to register such instability? \n\nPerhaps, high freq. resolution and short-range temporal stability is not necessary for AC control, in this case you approach is quite well.\n\nEdit: Longer interval also diminishes finite-duration signal windowing effect that gives false peaks\n\nP.S. Note that fast Fourier transform usually (not always, I don't see such directions in rfft description) works with ```\ninterval length = 2^N```\n, so here output might contain 256K \n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "plotstft() plotting short time fast fourier transform\r\n                \r\nHere is my code:\n\n```\n>  from scipy.fftpack import fft \n>  import matplotlib.pyplot as plt \n>  from numpy.lib import stride_tricks \n>  import matplotlib.pyplot as plt\n>  plotstft(sound_files[\"jazz\"][\"wavedata\"],sound_files[\"jazz\"][\"samplerate\"])\n```\n\n\nAnd it gives an error : \"NameError: name 'plotstft' is not defined\". How can I fix it? I am using python2.7 on ubuntu\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform of Frequency Analysis in Labview\r\n                \r\nI'm currently measuring the signal from 3 direction vibration sensor. I wan to convert my signal to a FFT form to determine the frequency analysis of it. Anyone got idea how I do it in Labview?\n    ", "Answer": "\r\nThere is an FFT VI under Signal Processing >> Transforms on the Functions Palette that should do what you're asking. Probably not a bad place to start.\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Assume pixel is circular in Fast Fourier Transform\r\n                \r\nI'm trying to calculate holograms through an iterative algorithm that applies FFT. Holograms are calculated though based on square signals(pixels). I want to calculate FFT from  a signal ( a pixel ) but i want its FFT to be the FFT of a circular \"pixel\".\n\nWhat ive tried os far is to take a 64x64 pixels hologram, enlarge it by 31 times (1984x1984) and create a circle with central point the pixel.\n\nI want to avoid that rescaling.\n Although the smaller the size of the rescaled image the less accurate the circle is.\n\n```\nI=imread('MM.bmp'); I=imresize(I,[64 64 ],'Method', 'nearest');\nI=I./max(max(I)); \navg1=mean(mean(I));\nI1=I;\nph=rand([size(I,1),size(I,2)]);\nU=I1.*exp(1j*ph);\n\nfor n=1:700\n        n1=n1+1;\nU1= fftshift(fft2(fftshift(U)));\nU2=fftshift(ifft2(fftshift(exp(1j*angle(U1)))));\navg2=mean(mean(abs(U2)));\nU3=(U2./avg2).*avg1;\nU=I.*exp(1j.*angle(U3));\nend\nimwrite(angle(U1), 'HOLOGRAM.jpg')\n```\n\n\nwhen i will use the fft on a pixel signal, i want to get the fft of a circle not the sinc function from the square signal.`\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Land masking and Fast Fourier transformation\r\n                \r\nI want to create a land masking for a netcdf file I have that contains information about the horizontal velocity on the Gulf Stream. So I want to have only oceanic points. I am attaching info for the nc file down here. Any ideas about the land masking?enter image description here\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in Objective-C doesn't work fine\r\n                \r\nI have a method in ```\nObjective-C```\n that receives an ```\narray of doubles```\n and then it uses the ```\nFast Fourier Transform```\n, however the exit of the ```\nFFT```\n doesn't match to what I want. \n\nCan someone help me, I don't know what I'm doing wrong?\n\nThis is my method where ```\nfftLength```\n is 4096:\n\n```\n-(double(*)) doFFT:(double(*))data{\n    double (*fft) = malloc((fftLength * 2) * sizeof(double));\n\n    FFTSetupD fft_weights = vDSP_create_fftsetupD((log2((double)(fftLength))), kFFTRadix2);\n\n    DSPDoubleSplitComplex fftData;\n    //fftData.imagp = fftMagnitudes;\n\n    fftData.imagp = (double*)malloc(fftLength * sizeof(double));\n    fftData.realp = (double*)malloc(fftLength * sizeof(double));\n\n    for (int i=0; i< fftLength; i++) {\n        fftData.realp[i] = (double)data[i];\n        fftData.imagp[i] = (double)0.0;\n\n    }\n\n    vDSP_fft_zipD(fft_weights, &fftData, 1, log2((double)(fftLength)), FFT_FORWARD);\n\n    for(int i = 0;i<fftLength * 2;i++){\n        fft[i] = fftData.realp[i];\n        fft[i+1] = fftData.imagp[i];\n    }\n\n    return fft;\n}\n```\n\n\nAnd this is part of my input data:\n\n```\n[0.0,2.092731423889438E-4, 8.858534436404497E-4,0.0013714427743574675,0.0012678166431137061,-9.650789019044481E-4,-0.002852548808273958,-0.005176802258252122,-0.007281581949909022,-0.00575977878132905,…]\n```\n\n\nAnd the result should be:\n\n```\n[21478.183372382526,0.0,-10190.412374839314,…]\n```\n\n\nBut I'm not getting this.\n    ", "Answer": "\r\nThis loop is wrong:\n\n```\nfor(int i = 0;i<fftLength * 2;i++){\n    fft[i] = fftData.realp[i];\n    fft[i+1] = fftData.imagp[i];\n}\n```\n\n\nAssuming you want interleaved real/complex output data then it should be:\n\n```\nfor(int i = 0; i < fftLength; i++) {\n    fft[i * 2] = fftData.realp[i];\n    fft[i * 2 + 1] = fftData.imagp[i];\n}\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Result in fast fourier transform in python is different\r\n                \r\nAlthough it a lot of topic about this but I dont really understanding when look up for exactly what in this problems.When I see some implementation FFT2 and apply them to Guassian kernel it has the diffirence from the numpy.fft.fft2 that also I apply them into its, specifically I have kernel like this:\n```\nkernel = np.fft.fft2(kernel)\nreturn kernel\n\n#KERNEL\n[[0.07511361 0.1238414  0.07511361]\n\n [0.1238414  0.20417996 0.1238414 ]\n\n [0.07511361 0.1238414  0.07511361]]\n```\n\nIn python:\n```\n#Results\n\n[[-0.01580538-2.73757188e-02j -0.08889707+1.53974244e-01j\n   0.03161076-3.46944695e-18j]\n [-0.08889707+1.53974244e-01j  1.        +0.00000000e+00j\n  -0.08889707-1.53974244e-01j]\n [ 0.03161076+3.46944695e-18j -0.08889707-1.53974244e-01j\n  -0.01580538+2.73757188e-02j]]\n```\n\nIn the implementation java:\n```\n0.6666666666666667 + 0.6666666666666667i   -0.059264713333333344 + -0.059264713333333344i    -0.05926471333333333 + -0.05926471333333333i \n\n-0.05926471333333333 + -0.05926471333333333i   -0.010536923333333337 + -0.010536923333333337i      0.021073846666666618 + 0.021073846666666618i \n\n-0.05926471333333332 + -0.05926471333333332i    0.021073846666666625 + 0.021073846666666625i    -0.010536923333333283 + -0.010536923333333283i \n```\n\nAnd the code when apply is:\n```\npublic static double[][] FFT2D(double[][] inputData,\n                      double[][] realOut,\n                      double[][] imagOut,\n                      double[][] amplitudeOut){\n    int height = inputData.length;\n    int width = inputData[0].length;\n   \n    System.out.println(\"height = \" + height);\n    System.out.println(\"width = \" + width);\n    for(int yWave = 0;yWave < height;yWave++){\n      for(int xWave = 0;xWave < width;xWave++){\n        for(int ySpace = 0;ySpace < height;\n                                       ySpace++){\n          for(int xSpace = 0;xSpace < width;\n                                       xSpace++){\n      realOut[yWave][xWave] += (inputData[ySpace][xSpace]*Math.cos(2*Math.PI*((1.0*\n                             xWave*xSpace/width)+(1.0*yWave*ySpace/height))))\n                              /Math.sqrt(width*height);\n       imagOut[yWave][xWave ] -= (inputData[ySpace][xSpace]*Math.sin(2*Math.PI*((1.0*xWave*\n                               xSpace/width) + (1.0*yWave*ySpace/height))))\n                             /Math.sqrt(width*height);\n \n       amplitudeOut[yWave][xWave] =  Math.sqrt( realOut[yWave][xWave] * realOut[yWave][xWave] +\n                   imagOut[yWave][xWave] * imagOut[yWave][xWave]);\n          }\n        }\n      }\n    }\n     //return realOut and imagOut;\n}\npublic static void main(String[] args){\n\n int rows = 3;\n    int cols = 3;\n    \n    double[][] spatialData = \n[[0.07511361 0.1238414  0.07511361]\n\n [0.1238414  0.20417996 0.1238414 ]\n\n [0.07511361 0.1238414  0.07511361]];\n                                    \n    double[][] realSpect=new double[rows][cols];\n    double[][] imagSpect = new double[rows][cols];\n    double[][] amplitudeSpect = new double[rows][cols];\n    //Now perform the transform\n    realSpect = FFT2D(spatialData,realSpect,\n                       imagSpect,amplitudeSpect);\n    imagSpect = FFT2D(spatialData,realSpect,\n                       imagSpect,amplitudeSpect);\n                       \n    for(int i=0;i<rows;i++){\n        for(int j=0;j < cols;j++){\n            System.out.printf(realSpect[i][j] +\" + \" +imagSpect[i][j]+\"i    \");\n        }\n        System.out.println(\"\\n\");\n    }\n    }\n}\n```\n\nIs it wrong when apply in java like these? Thank you all for helping me!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Build sample data for apache commons Fast Fourier Transform algorithm\r\n                \r\nI wanted to use Apache math commons implementation for FFT (FastFourierTransformer class) to process some dummy data whose 8 data samples are contributing to one complete sinusoidal wave. The maximum being amplitude 230. The code snippet that I tried is below :\n\n```\nprivate double[] transform() \n{   \n    double [] input = new double[8];\n    input[0] = 0.0;\n    input[1] = 162.6345596729059;\n    input[2] = 230.0;\n    input[3] = 162.63455967290594;\n    input[4] = 2.8166876380389125E-14;\n    input[5] = -162.6345596729059;\n    input[6] = -230.0;\n    input[7] = -162.63455967290597;\n\n    double[] tempConversion = new double[input.length];\n\n    FastFourierTransformer transformer = new FastFourierTransformer();\n    try {           \n        Complex[] complx = transformer.transform(input);\n\n        for (int i = 0; i < complx.length; i++) {               \n            double rr = (complx[i].getReal());\n            double ri = (complx[i].getImaginary());\n\n            tempConversion[i] = Math.sqrt((rr * rr) + (ri * ri));\n        }\n\n    } catch (IllegalArgumentException e) {\n        System.out.println(e);\n    }\n\n    return tempConversion;\n}\n```\n\n\n1) Now the data returned by method transform is an array of complex number. Does that array contains the frequency component information about input data? or the tempConversion array that I created will contain the frequency information? The values in tempConversion array is :\n\n```\n 2.5483305001488234E-16\n 920.0\n 4.0014578493024757E-14\n 2.2914314707516465E-13\n 5.658858581079313E-14\n 2.2914314707516465E-13\n 4.0014578493024757E-14\n 920.0\n```\n\n\n2) I searched a lot but at most of the places there is no clear documentation on what format of data algorithm expects (in terms of sample code to understand better) and how do I use the array of results to calculate the frequencies contained in the signal?\n    ", "Answer": "\r\nYour output data looks correct. You've calculated the magnitude of the complex FFT output at each frequency bin which corresponds to the energy in the input signal at the corresponding frequency for that bin. Since your input is purely real, the output is complex conjugate symmetric, and the last 3 output values are redundant.\n\nSo you have:\n\n```\nBin     Freq        Magnitude\n  0     0 (DC)        2.5483305001488234E-16\n  1     Fs/8        920.0\n  2     Fs/4          4.0014578493024757E-14\n  3     3Fs/8         2.2914314707516465E-13\n  4     Fs/2 (Nyq)    5.658858581079313E-14\n  5     3Fs/8         2.2914314707516465E-13  # redundant - mirror image of bin 3\n  6     Fs/4          4.0014578493024757E-14  # redundant - mirror image of bin 2\n  7     Fs/8        920.0                     # redundant - mirror image of bin 1\n```\n\n\nAll the values are effectively 0 apart from bin 1 (and bin 6) which corresponds to a frequency of ```\nFs/8```\n as expected.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Optimizing Fourier transformed signal length\r\n                \r\nI recently stumbled on an interessting problem, when computing the fourier transform of a signal with ```\nnp.fft.fft```\n. The reproduced problem is:\n\n```\n%timeit np.fft.fft(np.random.rand(59601))    \n1 loops, best of 3: 1.34 s per loop\n```\n\n\nI found that the amount of time is unexpectedly long. For instance lets look at some other fft's, but with a slightly longer/shorter signal:\n\n```\n%timeit np.fft.fft(np.random.rand(59600))\n100 loops, best of 3: 6.18 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59602))\n10 loops, best of 3: 61.3 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59603))\n10 loops, best of 3: 113 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59604))\n1 loops, best of 3: 182 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59605))\n100 loops, best of 3: 6.53 ms per loop\n\n%timeit np.fft.fft(np.random.rand(59606))\n1 loops, best of 3: 2.17 s per loop\n\n%timeit np.fft.fft(np.random.rand(59607))\n100 loops, best of 3: 8.14 ms per loop\n```\n\n\nWe can observe that the times are now in miliseconds, except for ```\nnp.random.rand(59606)```\n, which lasts 2.17 s.\n\nNote, the numpy documentation states:\n\n\n  FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform (DFT) can be calculated efficiently, by using symmetries in the calculated terms. The symmetry is highest when n is a power of 2, and the transform is therefore most efficient for these sizes.\n\n\nHowever these vectors do not have the length of a power of 2. Could someone explain how to avoid/predict cases, when computation times are considerably higher?\n    ", "Answer": "\r\nAs some comments have pointed, the prime factor decomposition allows you to predict the time to calculate the FFT. The following graphs show your results. Remark the logarithmic scale!\n\n\nThis image is generated with the following code:\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef prime_factors(n):\n    \"\"\"Returns all the prime factors of a positive integer\"\"\"\n    #from http://stackoverflow.com/questions/23287/largest-prime-factor-of-a-number/412942#412942\n    factors = []\n    d = 2\n    while n > 1:\n        while n % d == 0:\n            factors.append(d)\n            n /= d\n        d = d + 1\n\n    return factors\n\n\ntimes = []\ndecomp = []\nfor i in range(59600, 59613):\n    print(i)\n    t= %timeit -o np.fft.fft(np.random.rand(i))\n    times.append(t.best)\n    decomp.append(max(prime_factors(i)))\n\nplt.loglog(decomp, times, 'o')\nplt.ylabel(\"best time\")\nplt.xlabel(\"largest prime in prime factor decomposition\")\nplt.title(\"FFT timings\")\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "run fft(fast fourier transform in splash2 benchmark)\r\n                \r\nhi i want to run fft code(following code) in Ubuntu.\nfor run it i installed m4 in my Ubuntu then after going to the fft directory and make i got many error?\nwhy? anyone can help me?\nand in the top of code i see some command line? what should i do with this commands?how should i use them?\n\nhere is the fft code:\n\n```\n                                                                   */\n/*  Command line options:                                                */\n/*                                                                       */\n/*  -mM : M = even integer; 2**M total complex data points transformed.  */\n/*  -pP : P = number of processors; Must be a power of 2.                */\n/*  -nN : N = number of cache lines.                                     */\n/*  -lL : L = Log base 2 of cache line length in bytes.                  */\n/*  -s  : Print individual processor timing statistics.                  */\n/*  -t  : Perform FFT and inverse FFT.  Test output by comparing the     */\n/*        integral of the original data to the integral of the data      */\n/*        that results from performing the FFT and inverse FFT.          */\n/*  -o  : Print out complex data points.                                 */\n/*  -h  : Print out command line options.                                */\n/*                                                                       */\n/*  Note: This version works under both the FORK and SPROC models        */\n/*                                                                       */\n/*************************************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#define PAGE_SIZE               4096\n#define NUM_CACHE_LINES        65536 \n#define LOG2_LINE_SIZE             4\n#define PI                         3.1416\n#define DEFAULT_M                 10\n#define DEFAULT_P                  1\n\nMAIN_ENV\n\n#define SWAP_VALS(a,b) {double tmp; tmp=a; a=b; b=tmp;}\n\nstruct GlobalMemory {\n  long id;\n  LOCKDEC(idlock)\n  BARDEC(start)\n  long *transtimes;\n  long *totaltimes;\n  unsigned long starttime;\n  unsigned long finishtime;\n  unsigned long initdonetime;\n} *Global;\n\n\nlong P = DEFAULT_P;\nlong M = DEFAULT_M;\nlong N;                  /* N = 2^M                                */\nlong rootN;              /* rootN = N^1/2                          */\ndouble *x;              /* x is the original time-domain data     */\ndouble *trans;          /* trans is used as scratch space         */\ndouble *umain;          /* umain is roots of unity for 1D FFTs    */\ndouble *umain2;         /* umain2 is entire roots of unity matrix */\nlong test_result = 0;\nlong doprint = 0;\nlong dostats = 0;\nlong transtime = 0;\nlong transtime2 = 0;\nlong avgtranstime = 0;\nlong avgcomptime = 0;\nunsigned long transstart = 0;\nunsigned long transend = 0;\nlong maxtotal=0;\nlong mintotal=0;\ndouble maxfrac=0;\ndouble minfrac=0;\ndouble avgfractime=0;\nlong orig_num_lines = NUM_CACHE_LINES;     /* number of cache lines */\nlong num_cache_lines = NUM_CACHE_LINES;    /* number of cache lines */\nlong log2_line_size = LOG2_LINE_SIZE;\nlong line_size;\nlong rowsperproc;\ndouble ck1;\ndouble ck3;                        /* checksums for testing answer */\nlong pad_length;\n\nvoid SlaveStart(void);\ndouble TouchArray(double *x, double *scratch, double *u, double *upriv, long MyFirst, long MyLast);\ndouble CheckSum(double *x);\nvoid InitX(double *x);\nvoid InitU(long N, double *u);\nvoid InitU2(long N, double *u, long n1);\nlong BitReverse(long M, long k);\nvoid FFT1D(long direction, long M, long N, double *x, double *scratch, double *upriv, double *umain2,\n       long MyNum, long *l_transtime, long MyFirst, long MyLast, long pad_length, long test_result, long dostats);\nvoid TwiddleOneCol(long direction, long n1, long j, double *u, double *x, long pad_length);\nvoid Scale(long n1, long N, double *x);\nvoid Transpose(long n1, double *src, double *dest, long MyNum, long MyFirst, long MyLast, long pad_length);\nvoid CopyColumn(long n1, double *src, double *dest);\nvoid Reverse(long N, long M, double *x);\nvoid FFT1DOnce(long direction, long M, long N, double *u, double *x);\nvoid PrintArray(long N, double *x);\nvoid printerr(char *s);\nlong log_2(long number);\n\nvoid srand48(long int seedval);\ndouble drand48(void);\n\nint main(int argc, char *argv[])\n{\n  long i; \n  long c;\n  extern char *optarg;\n  long m1;\n  long factor;\n  long pages;\n  unsigned long start;\n\n  CLOCK(start);\n\n  while ((c = getopt(argc, argv, \"p:m:n:l:stoh\")) != -1) {\n    switch(c) {\n      case 'p': P = atoi(optarg); \n                if (P < 1) {\n                  printerr(\"P must be >= 1\\n\");\n                  exit(-1);\n                }\n                if (log_2(P) == -1) {\n                  printerr(\"P must be a power of 2\\n\");\n                  exit(-1);\n                }\n            break;  \n      case 'm': M = atoi(optarg); \n                m1 = M/2;\n                if (2*m1 != M) {\n                  printerr(\"M must be even\\n\");\n                  exit(-1);\n                }\n            break;  \n      case 'n': num_cache_lines = atoi(optarg); \n                orig_num_lines = num_cache_lines;\n                if (num_cache_lines < 1) {\n                  printerr(\"Number of cache lines must be >= 1\\n\");\n                  exit(-1);\n                }\n            break;  \n      case 'l': log2_line_size = atoi(optarg); \n                if (log2_line_size < 0) {\n                  printerr(\"Log base 2 of cache line length in bytes must be >= 0\\n\");\n                  exit(-1);\n                }\n            break;  \n      case 's': dostats = !dostats; \n            break;\n      case 't': test_result = !test_result; \n            break;\n      case 'o': doprint = !doprint; \n            break;\n      case 'h': printf(\"Usage: FFT <options>\\n\\n\");\n                printf(\"options:\\n\");\n                printf(\"  -mM : M = even integer; 2**M total complex data points transformed.\\n\");\n                printf(\"  -pP : P = number of processors; Must be a power of 2.\\n\");\n                printf(\"  -nN : N = number of cache lines.\\n\");\n                printf(\"  -lL : L = Log base 2 of cache line length in bytes.\\n\");\n                printf(\"  -s  : Print individual processor timing statistics.\\n\");\n                printf(\"  -t  : Perform FFT and inverse FFT.  Test output by comparing the\\n\");\n                printf(\"        integral of the original data to the integral of the data that\\n\");\n                printf(\"        results from performing the FFT and inverse FFT.\\n\");\n                printf(\"  -o  : Print out complex data points.\\n\");\n                printf(\"  -h  : Print out command line options.\\n\\n\");\n                printf(\"Default: FFT -m%1d -p%1d -n%1d -l%1d\\n\",\n                       DEFAULT_M,DEFAULT_P,NUM_CACHE_LINES,LOG2_LINE_SIZE);\n        exit(0);\n            break;\n    }\n  }\n\n  MAIN_INITENV(,80000000);\n\n  N = 1<<M;\n  rootN = 1<<(M/2);\n  rowsperproc = rootN/P;\n  if (rowsperproc == 0) {\n    printerr(\"Matrix not large enough. 2**(M/2) must be >= P\\n\");\n    exit(-1);\n  }\n\n  line_size = 1 << log2_line_size;\n  if (line_size < 2*sizeof(double)) {\n    printf(\"WARNING: Each element is a complex double (%ld bytes)\\n\",2*sizeof(double));\n    printf(\"  => Less than one element per cache line\\n\");\n    printf(\"     Computing transpose blocking factor\\n\");\n    factor = (2*sizeof(double)) / line_size;\n    num_cache_lines = orig_num_lines / factor;\n  }  \n  if (line_size <= 2*sizeof(double)) {\n    pad_length = 1;\n  } else {\n    pad_length = line_size / (2*sizeof(double));\n  }\n\n  if (rowsperproc * rootN * 2 * sizeof(double) >= PAGE_SIZE) {\n    pages = (2 * pad_length * sizeof(double) * rowsperproc) / PAGE_SIZE;\n    if (pages * PAGE_SIZE != 2 * pad_length * sizeof(double) * rowsperproc) {\n      pages ++;\n    }\n    pad_length = (pages * PAGE_SIZE) / (2 * sizeof(double) * rowsperproc);\n  } else {\n    pad_length = (PAGE_SIZE - (rowsperproc * rootN * 2 * sizeof(double))) /\n\n                 (2 * sizeof(double) * rowsperproc);\n    if (pad_length * (2 * sizeof(double) * rowsperproc) !=\n        (PAGE_SIZE - (rowsperproc * rootN * 2 * sizeof(double)))) {\n      printerr(\"Padding algorithm unsuccessful\\n\");\n      exit(-1);\n    }\n  }\n\n  Global = (struct GlobalMemory *) G_MALLOC(sizeof(struct GlobalMemory));\n  x = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n  trans = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n  umain = (double *) G_MALLOC(2*rootN*sizeof(double));  \n  umain2 = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n\n  Global->transtimes = (long *) G_MALLOC(P*sizeof(long));  \n  Global->totaltimes = (long *) G_MALLOC(P*sizeof(long));  \n  if (Global == NULL) {\n    printerr(\"Could not malloc memory for Global\\n\");\n    exit(-1);\n  } else if (x == NULL) {\n    printerr(\"Could not malloc memory for x\\n\");\n    exit(-1);\n  } else if (trans == NULL) {\n    printerr(\"Could not malloc memory for trans\\n\");\n    exit(-1);\n  } else if (umain == NULL) {\n    printerr(\"Could not malloc memory for umain\\n\");\n    exit(-1);\n  } else if (umain2 == NULL) {\n    printerr(\"Could not malloc memory for umain2\\n\");\n    exit(-1);\n  }\n\n  x = (double *) (((unsigned long) x) + PAGE_SIZE - ((unsigned long) x) % PAGE_SIZE);\n  trans = (double *) (((unsigned long) trans) + PAGE_SIZE - ((unsigned long) trans) % PAGE_SIZE);\n  umain2 = (double *) (((unsigned long) umain2) + PAGE_SIZE - ((unsigned long) umain2) % PAGE_SIZE);\n\n/* In order to optimize data distribution, the data structures x, trans, \n   and umain2 have been aligned so that each begins on a page boundary. \n   This ensures that the amount of padding calculated by the program is \n   such that each processor's partition ends on a page boundary, thus \n   ensuring that all data from these structures that are needed by a \n   processor can be allocated to its local memory */\n\n/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the x,\n   trans, and umain2 data structures across physically distributed \n   memories as desired.\n\n   One way to place data is as follows:\n\n   double *base;\n   long i;\n\n   i = ((N/P)+(rootN/P)*pad_length)*2;\n   base = &(x[0]);\n   for (j=0;j<P;j++) {\n    Place all addresses x such that (base <= x < base+i) on node j\n    base += i;\n   }\n\n   The trans and umain2 data structures can be placed in a similar manner.\n\n   */\n\n  printf(\"\\n\");\n  printf(\"FFT with Blocking Transpose\\n\");\n  printf(\"   %ld Complex Doubles\\n\",N);\n  printf(\"   %ld Processors\\n\",P);\n  if (num_cache_lines != orig_num_lines) {\n    printf(\"   %ld Cache lines\\n\",orig_num_lines);\n    printf(\"   %ld Cache lines for blocking transpose\\n\",num_cache_lines);\n  } else {\n    printf(\"   %ld Cache lines\\n\",num_cache_lines);\n  }\n  printf(\"   %d Byte line size\\n\",(1 << log2_line_size));\n  printf(\"   %d Bytes per page\\n\",PAGE_SIZE);\n  printf(\"\\n\");\n\n  BARINIT(Global->start, P);\n  LOCKINIT(Global->idlock);\n  Global->id = 0;\n  InitX(x);                  /* place random values in x */\n\n  if (test_result) {\n    ck1 = CheckSum(x);\n  }\n  if (doprint) {\n    printf(\"Original data values:\\n\");\n    PrintArray(N, x);\n  }\n\n  InitU(N,umain);               /* initialize u arrays*/\n  InitU2(N,umain2,rootN);\n\n  /* fire off P processes */\n\n  CREATE(SlaveStart, P);\n  WAIT_FOR_END(P);\n\n  if (doprint) {\n    if (test_result) {\n      printf(\"Data values after inverse FFT:\\n\");\n    } else {\n      printf(\"Data values after FFT:\\n\");\n    }\n    PrintArray(N, x);\n  }\n\n  transtime = Global->transtimes[0];\n  printf(\"\\n\");\n  printf(\"                 PROCESS STATISTICS\\n\");\n  printf(\"            Computation      Transpose     Transpose\\n\");\n  printf(\" Proc          Time            Time        Fraction\\n\");\n  printf(\"    0        %10ld     %10ld      %8.5f\\n\",\n         Global->totaltimes[0],Global->transtimes[0],\n         ((double)Global->transtimes[0])/Global->totaltimes[0]);\n  if (dostats) {\n    transtime2 = Global->transtimes[0];\n    avgtranstime = Global->transtimes[0];\n    avgcomptime = Global->totaltimes[0];\n    maxtotal = Global->totaltimes[0];\n    mintotal = Global->totaltimes[0];\n    maxfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n    minfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n    avgfractime = ((double)Global->transtimes[0])/Global->totaltimes[0];\n    for (i=1;i<P;i++) {\n      if (Global->transtimes[i] > transtime) {\n        transtime = Global->transtimes[i];\n      }\n      if (Global->transtimes[i] < transtime2) {\n        transtime2 = Global->transtimes[i];\n      }\n      if (Global->totaltimes[i] > maxtotal) {\n        maxtotal = Global->totaltimes[i];\n      }\n      if (Global->totaltimes[i] < mintotal) {\n        mintotal = Global->totaltimes[i];\n      }\n      if (((double)Global->transtimes[i])/Global->totaltimes[i] > maxfrac) {\n        maxfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n      }\n      if (((double)Global->transtimes[i])/Global->totaltimes[i] < minfrac) {\n        minfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n      }\n      printf(\"  %3ld        %10ld     %10ld      %8.5f\\n\",\n             i,Global->totaltimes[i],Global->transtimes[i],\n             ((double)Global->transtimes[i])/Global->totaltimes[i]);\n      avgtranstime += Global->transtimes[i];\n      avgcomptime += Global->totaltimes[i];\n      avgfractime += ((double)Global->transtimes[i])/Global->totaltimes[i];\n    }\n    printf(\"  Avg        %10.0f     %10.0f      %8.5f\\n\",\n           ((double) avgcomptime)/P,((double) avgtranstime)/P,avgfractime/P);\n    printf(\"  Max        %10ld     %10ld      %8.5f\\n\",\n       maxtotal,transtime,maxfrac);\n    printf(\"  Min        %10ld     %10ld      %8.5f\\n\",\n       mintotal,transtime2,minfrac);\n  }\n  Global->starttime = start;\n  printf(\"\\n\");\n  printf(\"                 TIMING INFORMATION\\n\");\n  printf(\"Start time                        : %16lu\\n\",\n      Global->starttime);\n  printf(\"Initialization finish time        : %16lu\\n\",\n      Global->initdonetime);\n  printf(\"Overall finish time               : %16lu\\n\",\n      Global->finishtime);\n  printf(\"Total time with initialization    : %16lu\\n\",\n      Global->finishtime-Global->starttime);\n  printf(\"Total time without initialization : %16lu\\n\",\n      Global->finishtime-Global->initdonetime);\n  printf(\"Overall transpose time            : %16ld\\n\",\n         transtime);\n  printf(\"Overall transpose fraction        : %16.5f\\n\",\n         ((double) transtime)/(Global->finishtime-Global->initdonetime));\n  printf(\"\\n\");\n\n  if (test_result) {\n    ck3 = CheckSum(x);\n    printf(\"              INVERSE FFT TEST RESULTS\\n\");\n    printf(\"Checksum difference is %.3f (%.3f, %.3f)\\n\",\n       ck1-ck3, ck1, ck3);\n    if (fabs(ck1-ck3) < 0.001) {\n      printf(\"TEST PASSED\\n\");\n    } else {\n      printf(\"TEST FAILED\\n\");\n    }\n  }\n\n  MAIN_END;\n}\n\n\nvoid SlaveStart()\n{\n  long i;\n  long MyNum;\n  double *upriv;\n  long initdone; \n  long finish; \n  long l_transtime=0;\n  long MyFirst; \n  long MyLast;\n\n  LOCK(Global->idlock);\n    MyNum = Global->id;\n    Global->id++;\n  UNLOCK(Global->idlock); \n\n  BARINCLUDE(Global->start);\n\n/* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to\n   processors to avoid migration */\n\n  BARRIER(Global->start, P);\n\n  upriv = (double *) malloc(2*(rootN-1)*sizeof(double));  \n  if (upriv == NULL) {\n    fprintf(stderr,\"Proc %ld could not malloc memory for upriv\\n\",MyNum);\n    exit(-1);\n  }\n  for (i=0;i<2*(rootN-1);i++) {\n    upriv[i] = umain[i];\n  }   \n\n  MyFirst = rootN*MyNum/P;\n  MyLast = rootN*(MyNum+1)/P;\n\n  TouchArray(x, trans, umain2, upriv, MyFirst, MyLast);\n\n  BARRIER(Global->start, P);\n\n/* POSSIBLE ENHANCEMENT:  Here is where one might reset the\n   statistics that one is measuring about the parallel execution */\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(initdone);\n  }\n\n  /* perform forward FFT */\n  FFT1D(1, M, N, x, trans, upriv, umain2, MyNum, &l_transtime, MyFirst, \n    MyLast, pad_length, test_result, dostats);\n\n  /* perform backward FFT */\n  if (test_result) {\n    FFT1D(-1, M, N, x, trans, upriv, umain2, MyNum, &l_transtime, MyFirst, \n      MyLast, pad_length, test_result, dostats);\n  }  \n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(finish);\n    Global->transtimes[MyNum] = l_transtime;\n    Global->totaltimes[MyNum] = finish-initdone;\n  }\n  if (MyNum == 0) {\n    Global->finishtime = finish;\n    Global->initdonetime = initdone;\n  }\n}\n\n\ndouble TouchArray(double *x, double *scratch, double *u, double *upriv, long MyFirst, long MyLast)\n{\n  long i,j,k;\n  double tot = 0.0;\n\n  /* touch my data */\n  for (j=0;j<2*(rootN-1);j++) {\n    tot += upriv[j];\n  }   \n  for (j=MyFirst; j<MyLast; j++) {\n    k = j * (rootN + pad_length);\n    for (i=0;i<rootN;i++) {\n      tot += x[2*(k+i)] + x[2*(k+i)+1] + \n             scratch[2*(k+i)] + scratch[2*(k+i)+1] +\n         u[2*(k+i)] + u[2*(k+i)+1];\n    }\n  }  \n  return tot;\n}\n\n\ndouble CheckSum(double *x)\n{\n  long i,j,k;\n  double cks;\n\n  cks = 0.0;\n  for (j=0; j<rootN; j++) {\n    k = j * (rootN + pad_length);\n    for (i=0;i<rootN;i++) {\n      cks += x[2*(k+i)] + x[2*(k+i)+1];\n    }\n  }\n\n  return(cks);\n}\n\n\nvoid InitX(double *x)\n{\n  long i,j,k;\n\n  srand48(0);\n  for (j=0; j<rootN; j++) {\n    k = j * (rootN + pad_length);\n    for (i=0;i<rootN;i++) {\n      x[2*(k+i)] = drand48();\n      x[2*(k+i)+1] = drand48();\n    }\n  }\n}\n\n\nvoid InitU(long N, double *u)\n{\n  long q; \n  long j; \n  long base; \n  long n1;\n\n  for (q=0; 1<<q<N; q++) {  \n    n1 = 1<<q;\n    base = n1-1;\n    for (j=0; j<n1; j++) {\n      if (base+j > rootN-1) { \n    return;\n      }\n      u[2*(base+j)] = cos(2.0*PI*j/(2*n1));\n      u[2*(base+j)+1] = -sin(2.0*PI*j/(2*n1));\n    }\n  }\n}\n\n\nvoid InitU2(long N, double *u, long n1)\n{\n  long i,j,k; \n\n  for (j=0; j<n1; j++) {  \n    k = j*(rootN+pad_length);\n    for (i=0; i<n1; i++) {  \n      u[2*(k+i)] = cos(2.0*PI*i*j/(N));\n      u[2*(k+i)+1] = -sin(2.0*PI*i*j/(N));\n    }\n  }\n}\n\n\nlong BitReverse(long M, long k)\n{\n  long i; \n  long j; \n  long tmp;\n\n  j = 0;\n  tmp = k;\n  for (i=0; i<M; i++) {\n    j = 2*j + (tmp&0x1);\n    tmp = tmp>>1;\n  }\n  return(j);\n}\n\n\nvoid FFT1D(long direction, long M, long N, double *x, double *scratch, double *upriv, double *umain2,\n           long MyNum, long *l_transtime, long MyFirst, long MyLast, long pad_length, long test_result, long dostats)\n{\n  long j;\n  long m1; \n  long n1;\n  unsigned long clocktime1;\n  unsigned long clocktime2;\n\n  m1 = M/2;\n  n1 = 1<<m1;\n\n  BARRIER(Global->start, P);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime1);\n  }\n\n  /* transpose from x into scratch */\n  Transpose(n1, x, scratch, MyNum, MyFirst, MyLast, pad_length);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime2);\n    *l_transtime += (clocktime2-clocktime1);\n  }\n\n  /* do n1 1D FFTs on columns */\n  for (j=MyFirst; j<MyLast; j++) {\n    FFT1DOnce(direction, m1, n1, upriv, &scratch[2*j*(n1+pad_length)]);\n    TwiddleOneCol(direction, n1, j, umain2, &scratch[2*j*(n1+pad_length)], pad_length);\n  }  \n\n  BARRIER(Global->start, P);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime1);\n  }\n  /* transpose */\n  Transpose(n1, scratch, x, MyNum, MyFirst, MyLast, pad_length);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime2);\n    *l_transtime += (clocktime2-clocktime1);\n  }\n\n  /* do n1 1D FFTs on columns again */\n  for (j=MyFirst; j<MyLast; j++) {\n    FFT1DOnce(direction, m1, n1, upriv, &x[2*j*(n1+pad_length)]);\n    if (direction == -1)\n      Scale(n1, N, &x[2*j*(n1+pad_length)]);\n  }\n\n  BARRIER(Global->start, P);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime1);\n  }\n\n  /* transpose back */\n  Transpose(n1, x, scratch, MyNum, MyFirst, MyLast, pad_length);\n\n  if ((MyNum == 0) || (dostats)) {\n    CLOCK(clocktime2);\n    *l_transtime += (clocktime2-clocktime1);\n  }\n\n  BARRIER(Global->start, P);\n\n  /* copy columns from scratch to x */\n  if ((test_result) || (doprint)) {  \n    for (j=MyFirst; j<MyLast; j++) {\n      CopyColumn(n1, &scratch[2*j*(n1+pad_length)], &x[2*j*(n1+pad_length)]); \n    }  \n  }  \n\n  BARRIER(Global->start, P);\n}\n\n\nvoid TwiddleOneCol(long direction, long n1, long j, double *u, double *x, long pad_length)\n{\n  long i;\n  double omega_r; \n  double omega_c; \n  double x_r; \n  double x_c;\n\n  for (i=0; i<n1; i++) {\n    omega_r = u[2*(j*(n1+pad_length)+i)];\n    omega_c = direction*u[2*(j*(n1+pad_length)+i)+1];  \n    x_r = x[2*i]; \n    x_c = x[2*i+1];\n    x[2*i] = omega_r*x_r - omega_c*x_c;\n    x[2*i+1] = omega_r*x_c + omega_c*x_r;\n  }\n}\n\n\nvoid Scale(long n1, long N, double *x)\n{\n  long i;\n\n  for (i=0; i<n1; i++) {\n    x[2*i] /= N;\n    x[2*i+1] /= N;\n  }\n}\n\n\nvoid Transpose(long n1, double *src, double *dest, long MyNum, long MyFirst, long MyLast, long pad_length)\n{\n  long i; \n  long j; \n  long k; \n  long l; \n  long m;\n  long blksize;\n  long numblks;\n  long firstfirst;\n  long h_off;\n  long v_off;\n  long v;\n  long h;\n  long n1p;\n  long row_count;\n\n  blksize = MyLast-MyFirst;\n  numblks = (2*blksize)/num_cache_lines;\n  if (numblks * num_cache_lines != 2 * blksize) {\n    numblks ++;\n  }\n  blksize = blksize / numblks;\n  firstfirst = MyFirst;\n  row_count = n1/P;\n  n1p = n1+pad_length;\n  for (l=MyNum+1;l<P;l++) {\n    v_off = l*row_count;\n    for (k=0; k<numblks; k++) {\n      h_off = firstfirst;\n      for (m=0; m<numblks; m++) {\n        for (i=0; i<blksize; i++) {\n      v = v_off + i;\n          for (j=0; j<blksize; j++) {\n        h = h_off + j;\n            dest[2*(h*n1p+v)] = src[2*(v*n1p+h)];\n            dest[2*(h*n1p+v)+1] = src[2*(v*n1p+h)+1];\n          }\n        }\n    h_off += blksize;\n      }\n      v_off+=blksize;\n    }\n  }\n\n  for (l=0;l<MyNum;l++) {\n    v_off = l*row_count;\n    for (k=0; k<numblks; k++) {\n      h_off = firstfirst;\n      for (m=0; m<numblks; m++) {\n        for (i=0; i<blksize; i++) {\n      v = v_off + i;\n          for (j=0; j<blksize; j++) {\n            h = h_off + j;\n            dest[2*(h*n1p+v)] = src[2*(v*n1p+h)];\n            dest[2*(h*n1p+v)+1] = src[2*(v*n1p+h)+1];\n          }\n        }\n    h_off += blksize;\n      }\n      v_off+=blksize;\n    }\n  }\n\n  v_off = MyNum*row_count;\n  for (k=0; k<numblks; k++) {\n    h_off = firstfirst;\n    for (m=0; m<numblks; m++) {\n      for (i=0; i<blksize; i++) {\n        v = v_off + i;\n        for (j=0; j<blksize; j++) {\n          h = h_off + j;\n          dest[2*(h*n1p+v)] = src[2*(v*n1p+h)];\n          dest[2*(h*n1p+v)+1] = src[2*(v*n1p+h)+1];\n    }\n      }\n      h_off += blksize;\n    }\n    v_off+=blksize;\n  }\n}\n\n\nvoid CopyColumn(long n1, double *src, double *dest)\n{\n  long i;\n\n  for (i=0; i<n1; i++) {\n    dest[2*i] = src[2*i];\n    dest[2*i+1] = src[2*i+1];\n  }\n}\n\n\nvoid Reverse(long N, long M, double *x)\n{\n  long j, k;\n\n  for (k=0; k<N; k++) {\n    j = BitReverse(M, k);\n    if (j > k) {\n      SWAP_VALS(x[2*j], x[2*k]);\n      SWAP_VALS(x[2*j+1], x[2*k+1]);\n    }\n  }\n}\n\n\nvoid FFT1DOnce(long direction, long M, long N, double *u, double *x)\n{\n  long j; \n  long k; \n  long q; \n  long L; \n  long r; \n  long Lstar;\n  double *u1; \n  double *x1; \n  double *x2;\n  double omega_r; \n  double omega_c; \n  double tau_r; \n  double tau_c; \n  double x_r; \n  double x_c;\n\n  Reverse(N, M, x);\n\n  for (q=1; q<=M; q++) {\n    L = 1<<q; r = N/L; Lstar = L/2;\n    u1 = &u[2*(Lstar-1)];\n    for (k=0; k<r; k++) {\n      x1 = &x[2*(k*L)];\n      x2 = &x[2*(k*L+Lstar)];\n      for (j=0; j<Lstar; j++) {\n    omega_r = u1[2*j]; \n        omega_c = direction*u1[2*j+1];\n    x_r = x2[2*j]; \n        x_c = x2[2*j+1];\n    tau_r = omega_r*x_r - omega_c*x_c;\n    tau_c = omega_r*x_c + omega_c*x_r;\n    x_r = x1[2*j]; \n        x_c = x1[2*j+1];\n    x2[2*j] = x_r - tau_r;\n    x2[2*j+1] = x_c - tau_c;\n    x1[2*j] = x_r + tau_r;\n    x1[2*j+1] = x_c + tau_c;\n      }\n    }\n  }\n}\n\n\nvoid PrintArray(long N, double *x)\n{\n  long i, j, k;\n\n  for (i=0; i<rootN; i++) {\n    k = i*(rootN+pad_length);\n    for (j=0; j<rootN; j++) {\n      printf(\" %4.2f %4.2f\", x[2*(k+j)], x[2*(k+j)+1]);\n      if (i*rootN+j != N-1) {\n        printf(\",\");\n      }\n      if ((i*rootN+j+1) % 8 == 0) {\n        printf(\"\\n\");\n      }\n    }\n  }\n  printf(\"\\n\");\n  printf(\"\\n\");\n}\n\n\nvoid printerr(char *s)\n{\n  fprintf(stderr,\"ERROR: %s\\n\",s);\n}\n\n\nlong log_2(long number)\n{\n  long cumulative = 1, out = 0, done = 0;\n\n  while ((cumulative < number) && (!done) && (out < 50)) {\n    if (cumulative == number) {\n      done = 1;\n    } else {\n      cumulative = cumulative * 2;\n      out ++;\n    }\n  }\n\n  if (cumulative == number) {\n    return(out);\n  } else {\n    return(-1);\n  }\n}\n```\n\n\nThese are some of the errors I get:\n\n```\nfft.C: In function ‘FFT1D’:\nfft.C:603:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:623:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:643:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:657:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:666:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C: In function ‘main’:\nfft.C:416:1: warning: control reaches end of non-void function [-Wreturn-type]\n }\n ^\n../../Makefile.config:30: recipe for target 'fft.o' failed\nmake: *** [fft.o] Error 1\n```\n\n    ", "Answer": "\r\n~/Desktop/splash2/codes/kernels/fft$ make\n\n```\ngcc -c -O3 -pthread -D_POSIX_C_SOURCE=200112 -Wall -W -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls -Wdisabled-optimization -Wpadded -Winline -Wpointer-arith -Wsign-compare -Wendif-labels fft.c\nfft.C:59:1: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘struct’\n struct GlobalMemory {\n ^\nfft.C: In function ‘main’:\nfft.C:134:3: warning: implicit declaration of function ‘CLOCK’ [-Wimplicit-function-declaration]\n   CLOCK(start);\n   ^\nfft.C:136:3: warning: implicit declaration of function ‘getopt’ [-Wimplicit-function-declaration]\n   while ((c = getopt(argc, argv, \"p:m:n:l:stoh\")) != -1) {\n   ^\nfft.C:138:7: warning: implicit declaration of function ‘atoi’ [-Wimplicit-function-declaration]\n       case 'p': P = atoi(optarg); \n       ^\nfft.C:141:19: warning: implicit declaration of function ‘exit’ [-Wimplicit-function-declaration]\n                   exit(-1);\n                   ^\nfft.C:141:19: warning: incompatible implicit declaration of built-in function ‘exit’\nfft.C:145:19: warning: incompatible implicit declaration of built-in function ‘exit’\n                   exit(-1);\n                   ^\nfft.C:152:19: warning: incompatible implicit declaration of built-in function ‘exit’\n                   exit(-1);\n                   ^\nfft.C:159:19: warning: incompatible implicit declaration of built-in function ‘exit’\n                   exit(-1);\n                   ^\nfft.C:165:19: warning: incompatible implicit declaration of built-in function ‘exit’\n                   exit(-1);\n                   ^\nfft.C:188:3: warning: incompatible implicit declaration of built-in function ‘exit’\n   exit(0);\n   ^\nfft.C:193:3: warning: implicit declaration of function ‘MAIN_INITENV’ [-Wimplicit-function-declaration]\n   MAIN_INITENV(,80000000);\n   ^\nfft.C:193:16: error: expected expression before ‘,’ token\n   MAIN_INITENV(,80000000);\n                ^\nfft.C:200:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:204:17: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]\n   if (line_size < 2*sizeof(double)) {\n                 ^\nfft.C:211:17: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]\n   if (line_size <= 2*sizeof(double)) {\n                 ^\nfft.C:219:27: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]\n     if (pages * PAGE_SIZE != 2 * pad_length * sizeof(double) * rowsperproc) {\n                           ^\nfft.C:230:7: warning: incompatible implicit declaration of built-in function ‘exit’\n       exit(-1);\n       ^\nfft.C:234:20: warning: implicit declaration of function ‘G_MALLOC’ [-Wimplicit-function-declaration]\n   Global = (struct GlobalMemory *) G_MALLOC(sizeof(struct GlobalMemory));\n                    ^\nfft.C:234:12: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   Global = (struct GlobalMemory *) G_MALLOC(sizeof(struct GlobalMemory));\n            ^\nfft.C:235:7: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   x = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n       ^\nfft.C:236:11: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   trans = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n           ^\nfft.C:237:11: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   umain = (double *) G_MALLOC(2*rootN*sizeof(double));  \n           ^\nfft.C:238:12: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   umain2 = (double *) G_MALLOC(2*(N+rootN*pad_length)*sizeof(double)+PAGE_SIZE);\n            ^\nfft.C:240:9: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n   Global->transtimes = (long *) G_MALLOC(P*sizeof(long));  \n         ^\nfft.C:240:24: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   Global->transtimes = (long *) G_MALLOC(P*sizeof(long));  \n                        ^\nfft.C:241:9: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n   Global->totaltimes = (long *) G_MALLOC(P*sizeof(long));  \n         ^\nfft.C:241:24: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]\n   Global->totaltimes = (long *) G_MALLOC(P*sizeof(long));  \n                        ^\nfft.C:244:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:247:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:250:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:253:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:256:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:304:3: warning: implicit declaration of function ‘BARINIT’ [-Wimplicit-function-declaration]\n   BARINIT(Global->start, P);\n   ^\nfft.C:304:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARINIT(Global->start, P);\n                 ^\nfft.C:305:3: warning: implicit declaration of function ‘LOCKINIT’ [-Wimplicit-function-declaration]\n   LOCKINIT(Global->idlock);\n   ^\nfft.C:305:18: error: ‘struct GlobalMemory’ has no member named ‘idlock’\n   LOCKINIT(Global->idlock);\n                  ^\nfft.C:306:9: error: ‘struct GlobalMemory’ has no member named ‘id’\n   Global->id = 0;\n         ^\nfft.C:322:3: warning: implicit declaration of function ‘CREATE’ [-Wimplicit-function-declaration]\n   CREATE(SlaveStart, P);\n   ^\nfft.C:323:3: warning: implicit declaration of function ‘WAIT_FOR_END’ [-Wimplicit-function-declaration]\n   WAIT_FOR_END(P);\n   ^\nfft.C:334:21: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n   transtime = Global->transtimes[0];\n                     ^\nfft.C:340:16: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n          Global->totaltimes[0],Global->transtimes[0],\n                ^\nfft.C:340:38: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n          Global->totaltimes[0],Global->transtimes[0],\n                                      ^\nfft.C:341:25: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n          ((double)Global->transtimes[0])/Global->totaltimes[0]);\n                         ^\nfft.C:341:48: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n          ((double)Global->transtimes[0])/Global->totaltimes[0]);\n                                                ^\nfft.C:343:24: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     transtime2 = Global->transtimes[0];\n                        ^\nfft.C:344:26: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     avgtranstime = Global->transtimes[0];\n                          ^\nfft.C:345:25: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     avgcomptime = Global->totaltimes[0];\n                         ^\nfft.C:346:22: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     maxtotal = Global->totaltimes[0];\n                      ^\nfft.C:347:22: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     mintotal = Global->totaltimes[0];\n                      ^\nfft.C:348:30: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     maxfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                              ^\nfft.C:348:53: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     maxfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                                                     ^\nfft.C:349:30: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     minfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                              ^\nfft.C:349:53: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     minfrac = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                                                     ^\nfft.C:350:34: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     avgfractime = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                                  ^\nfft.C:350:57: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     avgfractime = ((double)Global->transtimes[0])/Global->totaltimes[0];\n                                                         ^\nfft.C:352:17: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       if (Global->transtimes[i] > transtime) {\n                 ^\nfft.C:353:27: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n         transtime = Global->transtimes[i];\n                           ^\nfft.C:355:17: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       if (Global->transtimes[i] < transtime2) {\n                 ^\nfft.C:356:28: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n         transtime2 = Global->transtimes[i];\n                            ^\nfft.C:358:17: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       if (Global->totaltimes[i] > maxtotal) {\n                 ^\nfft.C:359:26: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n         maxtotal = Global->totaltimes[i];\n                          ^\nfft.C:361:17: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       if (Global->totaltimes[i] < mintotal) {\n                 ^\nfft.C:362:26: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n         mintotal = Global->totaltimes[i];\n                          ^\nfft.C:364:26: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       if (((double)Global->transtimes[i])/Global->totaltimes[i] > maxfrac) {\n                          ^\nfft.C:364:49: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       if (((double)Global->transtimes[i])/Global->totaltimes[i] > maxfrac) {\n                                                 ^\nfft.C:365:34: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n         maxfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                  ^\nfft.C:365:57: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n         maxfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                                         ^\nfft.C:367:26: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       if (((double)Global->transtimes[i])/Global->totaltimes[i] < minfrac) {\n                          ^\nfft.C:367:49: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       if (((double)Global->transtimes[i])/Global->totaltimes[i] < minfrac) {\n                                                 ^\nfft.C:368:34: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n         minfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                  ^\nfft.C:368:57: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n         minfrac = ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                                         ^\nfft.C:371:22: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n              i,Global->totaltimes[i],Global->transtimes[i],\n                      ^\nfft.C:371:44: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n              i,Global->totaltimes[i],Global->transtimes[i],\n                                            ^\nfft.C:372:29: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n              ((double)Global->transtimes[i])/Global->totaltimes[i]);\n                             ^\nfft.C:372:52: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n              ((double)Global->transtimes[i])/Global->totaltimes[i]);\n                                                    ^\nfft.C:373:29: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       avgtranstime += Global->transtimes[i];\n                             ^\nfft.C:374:28: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       avgcomptime += Global->totaltimes[i];\n                            ^\nfft.C:375:37: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n       avgfractime += ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                     ^\nfft.C:375:60: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n       avgfractime += ((double)Global->transtimes[i])/Global->totaltimes[i];\n                                                            ^\nfft.C:384:9: error: ‘struct GlobalMemory’ has no member named ‘starttime’\n   Global->starttime = start;\n         ^\nfft.C:388:10: error: ‘struct GlobalMemory’ has no member named ‘starttime’\n    Global->starttime);\n          ^\nfft.C:390:10: error: ‘struct GlobalMemory’ has no member named ‘initdonetime’\n    Global->initdonetime);\n          ^\nfft.C:392:10: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n    Global->finishtime);\n          ^\nfft.C:394:10: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n    Global->finishtime-Global->starttime);\n          ^\nfft.C:394:29: error: ‘struct GlobalMemory’ has no member named ‘starttime’\n    Global->finishtime-Global->starttime);\n                             ^\nfft.C:396:10: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n    Global->finishtime-Global->initdonetime);\n          ^\nfft.C:396:29: error: ‘struct GlobalMemory’ has no member named ‘initdonetime’\n    Global->finishtime-Global->initdonetime);\n                             ^\nfft.C:400:38: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n          ((double) transtime)/(Global->finishtime-Global->initdonetime));\n                                      ^\nfft.C:400:57: error: ‘struct GlobalMemory’ has no member named ‘initdonetime’\n          ((double) transtime)/(Global->finishtime-Global->initdonetime));\n                                                         ^\nfft.C:415:3: error: ‘MAIN_END’ undeclared (first use in this function)\n   MAIN_END;\n   ^\nfft.C:415:3: note: each undeclared identifier is reported only once for each function it appears in\nfft.C: In function ‘SlaveStart’:\nfft.C:430:3: warning: implicit declaration of function ‘LOCK’ [-Wimplicit-function-declaration]\n   LOCK(Global->idlock);\n   ^\nfft.C:430:14: error: ‘struct GlobalMemory’ has no member named ‘idlock’\n   LOCK(Global->idlock);\n              ^\nfft.C:431:19: error: ‘struct GlobalMemory’ has no member named ‘id’\n     MyNum = Global->id;\n                   ^\nfft.C:432:11: error: ‘struct GlobalMemory’ has no member named ‘id’\n     Global->id++;\n           ^\nfft.C:433:3: warning: implicit declaration of function ‘UNLOCK’ [-Wimplicit-function-declaration]\n   UNLOCK(Global->idlock); \n   ^\nfft.C:433:16: error: ‘struct GlobalMemory’ has no member named ‘idlock’\n   UNLOCK(Global->idlock); \n                ^\nfft.C:435:3: warning: implicit declaration of function ‘BARINCLUDE’ [-Wimplicit-function-declaration]\n   BARINCLUDE(Global->start);\n   ^\nfft.C:435:20: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARINCLUDE(Global->start);\n                    ^\nfft.C:440:3: warning: implicit declaration of function ‘BARRIER’ [-Wimplicit-function-declaration]\n   BARRIER(Global->start, P);\n   ^\nfft.C:440:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:442:3: warning: implicit declaration of function ‘malloc’ [-Wimplicit-function-declaration]\n   upriv = (double *) malloc(2*(rootN-1)*sizeof(double));  \n   ^\nfft.C:442:22: warning: incompatible implicit declaration of built-in function ‘malloc’\n   upriv = (double *) malloc(2*(rootN-1)*sizeof(double));  \n                      ^\nfft.C:445:5: warning: incompatible implicit declaration of built-in function ‘exit’\n     exit(-1);\n     ^\nfft.C:456:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:477:11: error: ‘struct GlobalMemory’ has no member named ‘transtimes’\n     Global->transtimes[MyNum] = l_transtime;\n           ^\nfft.C:478:11: error: ‘struct GlobalMemory’ has no member named ‘totaltimes’\n     Global->totaltimes[MyNum] = finish-initdone;\n           ^\nfft.C:481:11: error: ‘struct GlobalMemory’ has no member named ‘finishtime’\n     Global->finishtime = finish;\n           ^\nfft.C:482:11: error: ‘struct GlobalMemory’ has no member named ‘initdonetime’\n     Global->initdonetime = initdone;\n           ^\nfft.C: In function ‘FFT1D’:\nfft.C:603:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:623:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:643:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:657:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C:666:17: error: ‘struct GlobalMemory’ has no member named ‘start’\n   BARRIER(Global->start, P);\n                 ^\nfft.C: In function ‘main’:\nfft.C:416:1: warning: control reaches end of non-void function [-Wreturn-type]\n }\n ^\n../../Makefile.config:30: recipe for target 'fft.o' failed\nmake: *** [fft.o] Error 1\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to find period of signal (autocorrelation vs fast fourier transform vs power spectral density)?\r\n                \r\nSuppose one wanted to find the period of a given sinusoidal wave signal. From what I have read online, it appears that the two main approaches employ either fourier analysis or autocorrelation. I am trying to automate the process using python and my usage case is to apply this concept to similar signals that come from the time-series of positions (or speeds or accelerations) of simulated bodies orbiting a star. \n\nFor simple-examples-sake, consider ```\nx = sin(t)```\n for ```\n0 ≤ t ≤ 10 pi```\n.\n\n```\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\n\n## sample data\nt = np.linspace(0, 10 * np.pi, 100)\nx = np.sin(t)\nfig, ax = plt.subplots()\nax.plot(t, x, color='b', marker='o')\nax.grid(color='k', alpha=0.3, linestyle=':')\nplt.show()\nplt.close(fig)\n```\n\n\n\n\nGiven a sine-wave of the form ```\nx = a sin(b(t+c)) + d```\n, the period of the sine-wave is obtained as ```\n2 * pi / b```\n. Since ```\nb=1```\n (or by visual inspection), the period of our sine wave is ```\n2 * pi```\n. I can check the results obtained from other methods against this baseline.\n\nAttempt 1: Autocorrelation\n\nAs I understand it (please correct me if I'm wrong), correlation can be used to see if one signal is a time-lagged copy of another signal (similar to how cosine and sine differ by a phase difference). So autocorrelation is testing a signal against itself to measure the times at which the time-lag repeats said signal. Using the example posted here:\n\n```\nresult = np.correlate(x, x, mode='full')\n```\n\n\nSince ```\nx```\n and ```\nt```\n each consist of ```\n100```\n elements and ```\nresult```\n consists of ```\n199```\n elements, I am not sure why I should arbitrarily select the last ```\n100```\n elements.\n\n```\nprint(\"\\n autocorrelation (shape={}):\\n{}\\n\".format(result.shape, result))  \n\n autocorrelation (shape=(199,)):\n[ 0.00000000e+00 -3.82130761e-16 -9.73648712e-02 -3.70014208e-01\n -8.59889695e-01 -1.56185995e+00 -2.41986054e+00 -3.33109112e+00\n -4.15799070e+00 -4.74662427e+00 -4.94918053e+00 -4.64762251e+00\n -3.77524157e+00 -2.33298717e+00 -3.97976240e-01  1.87752669e+00\n  4.27722402e+00  6.54129270e+00  8.39434617e+00  9.57785701e+00\n  9.88331103e+00  9.18204933e+00  7.44791758e+00  4.76948221e+00\n  1.34963425e+00 -2.50822289e+00 -6.42666652e+00 -9.99116299e+00\n -1.27937834e+01 -1.44791297e+01 -1.47873668e+01 -1.35893098e+01\n -1.09091510e+01 -6.93157447e+00 -1.99159756e+00  3.45267493e+00\n  8.86228186e+00  1.36707567e+01  1.73433176e+01  1.94357232e+01\n  1.96463736e+01  1.78556800e+01  1.41478477e+01  8.81191526e+00\n  2.32100171e+00 -4.70897483e+00 -1.15775811e+01 -1.75696560e+01\n -2.20296487e+01 -2.44327920e+01 -2.44454330e+01 -2.19677060e+01\n -1.71533510e+01 -1.04037163e+01 -2.33560966e+00  6.27458308e+00\n  1.45655029e+01  2.16769872e+01  2.68391837e+01  2.94553896e+01\n  2.91697473e+01  2.59122266e+01  1.99154591e+01  1.17007613e+01\n  2.03381596e+00 -8.14633251e+00 -1.78184255e+01 -2.59814393e+01\n -3.17580589e+01 -3.44884934e+01 -3.38046447e+01 -2.96763956e+01\n -2.24244433e+01 -1.26974172e+01 -1.41464998e+00  1.03204331e+01\n  2.13281784e+01  3.04712823e+01  3.67721634e+01  3.95170295e+01\n  3.83356037e+01  3.32477037e+01  2.46710643e+01  1.33886439e+01\n  4.77778141e-01 -1.27924775e+01 -2.50860560e+01 -3.51343866e+01\n -4.18671622e+01 -4.45258983e+01 -4.27482779e+01 -3.66140001e+01\n -2.66465884e+01 -1.37700036e+01  7.76494745e-01  1.55574483e+01\n  2.90828312e+01  3.99582426e+01  4.70285203e+01  4.95000000e+01\n  4.70285203e+01  3.99582426e+01  2.90828312e+01  1.55574483e+01\n  7.76494745e-01 -1.37700036e+01 -2.66465884e+01 -3.66140001e+01\n -4.27482779e+01 -4.45258983e+01 -4.18671622e+01 -3.51343866e+01\n -2.50860560e+01 -1.27924775e+01  4.77778141e-01  1.33886439e+01\n  2.46710643e+01  3.32477037e+01  3.83356037e+01  3.95170295e+01\n  3.67721634e+01  3.04712823e+01  2.13281784e+01  1.03204331e+01\n -1.41464998e+00 -1.26974172e+01 -2.24244433e+01 -2.96763956e+01\n -3.38046447e+01 -3.44884934e+01 -3.17580589e+01 -2.59814393e+01\n -1.78184255e+01 -8.14633251e+00  2.03381596e+00  1.17007613e+01\n  1.99154591e+01  2.59122266e+01  2.91697473e+01  2.94553896e+01\n  2.68391837e+01  2.16769872e+01  1.45655029e+01  6.27458308e+00\n -2.33560966e+00 -1.04037163e+01 -1.71533510e+01 -2.19677060e+01\n -2.44454330e+01 -2.44327920e+01 -2.20296487e+01 -1.75696560e+01\n -1.15775811e+01 -4.70897483e+00  2.32100171e+00  8.81191526e+00\n  1.41478477e+01  1.78556800e+01  1.96463736e+01  1.94357232e+01\n  1.73433176e+01  1.36707567e+01  8.86228186e+00  3.45267493e+00\n -1.99159756e+00 -6.93157447e+00 -1.09091510e+01 -1.35893098e+01\n -1.47873668e+01 -1.44791297e+01 -1.27937834e+01 -9.99116299e+00\n -6.42666652e+00 -2.50822289e+00  1.34963425e+00  4.76948221e+00\n  7.44791758e+00  9.18204933e+00  9.88331103e+00  9.57785701e+00\n  8.39434617e+00  6.54129270e+00  4.27722402e+00  1.87752669e+00\n -3.97976240e-01 -2.33298717e+00 -3.77524157e+00 -4.64762251e+00\n -4.94918053e+00 -4.74662427e+00 -4.15799070e+00 -3.33109112e+00\n -2.41986054e+00 -1.56185995e+00 -8.59889695e-01 -3.70014208e-01\n -9.73648712e-02 -3.82130761e-16  0.00000000e+00]\n```\n\n\nAttempt 2: Fourier\n\nSince I am not sure where to go from the last attempt, I sought a new attempt. To my understanding, Fourier analysis basically shifts a signal from/to the time-domain (```\nx(t) vs t```\n) to/from the frequency domain (```\nx(t) vs f=1/t```\n); the signal in frequency-space should appear as a sinusoidal wave that dampens over time. The period is obtained from the most observed frequency since this is the location of the peak of the distribution of frequencies. \n\nSince my values are all real-valued, applying the Fourier transform should mean my output values are all complex-valued. I wouldn't think this is a problem, except for the fact that scipy has methods for real-values. I do not fully understand the differences between all of the different scipy methods. That makes following the algorithm proposed in this posted solution hard for me to follow (ie, how/why is the threshold value picked?). \n\n```\nomega = np.fft.fft(x)\nfreq = np.fft.fftfreq(x.size, 1)\nthreshold = 0\nidx = np.where(abs(omega)>threshold)[0][-1]\nmax_f = abs(freq[idx])\nprint(max_f)\n```\n\n\nThis outputs ```\n0.01```\n, meaning the period is ```\n1/0.01 = 100```\n. This doesn't make sense either.\n\nAttempt 3: Power Spectral Density\n\nAccording to the scipy docs, I should be able to estimate the power spectral density (psd) of the signal using a periodogram (which, according to wikipedia, is the fourier transform of the autocorrelation function). By selecting the dominant frequency ```\nfmax```\n at which the signal peaks, the period of the signal can be obtained as ```\n1 / fmax```\n.\n\n```\nfreq, pdensity = signal.periodogram(x)\n\nfig, ax = plt.subplots()\nax.plot(freq, pdensity, color='r')\nax.grid(color='k', alpha=0.3, linestyle=':')\nplt.show()\nplt.close(fig)\n```\n\n\nThe periodogram shown below peaks at ```\n49.076...```\n at a frequency of ```\nfmax = 0.05```\n. So, ```\nperiod = 1/fmax = 20```\n. This doesn't make sense to me. I have a feeling it has something to do with the sampling rate, but don't know enough to confirm or progress further.\n\nI realize I am missing some fundamental gaps in understanding how these things work. There are a lot of resources online, but it's hard to find this needle in the haystack. Can someone help me learn more about this?\n\n\n    ", "Answer": "\r\nLet's first look at your signal (I've added ```\nendpoint=False```\n to make the division even):\n\n```\nt = np.linspace(0, 10*np.pi, 100, endpoint=False)\nx = np.sin(t)\n```\n\n\nLet's divide out the radians (essentially by taking ```\nt /= 2*np.pi```\n) and create the same signal by relating to frequencies:\n\n```\nfs = 20 # Sampling rate of 100/5 = 20 (e.g. Hz)\nf = 1 # Signal frequency of 1 (e.g. Hz)\nt = np.linspace(0, 5, 5*fs, endpoint=False)\nx = np.sin(2*np.pi*f*t)\n```\n\n\nThis makes it more salient that ```\nf/fs == 1/20 == 0.05```\n (i.e. the periodicity of the signal is exactly 20 samples). Frequencies in a digital signal always relate to its sampling rate, as you have already guessed. Note that the actual signal is exactly the same no matter what the values of ```\nf```\n and ```\nfs```\n are, as long as their ratio is the same:\n\n```\nfs = 1 # Natural units\nf = 0.05\nt = np.linspace(0, 100, 100*fs, endpoint=False)\nx = np.sin(2*np.pi*f*t)\n```\n\n\nIn the following I'll use these natural units (```\nfs = 1```\n). The only difference will be in ```\nt```\n and hence the generated frequency axes.\n\nAutocorrelation\n\nYour understanding of what the autocorrelation function does is correct. It detects the correlation of a signal with a time-lagged version of itself. It does this by sliding the signal over itself as seen in the right column here (from Wikipedia):\n\n\n\nNote that as both inputs to the correlation function are the same, the resulting signal is necessarily symmetric. That is why the output of ```\nnp.correlate```\n is usually sliced from the middle:\n\n```\nacf = np.correlate(x, x, 'full')[-len(x):]\n```\n\n\nNow index 0 corresponds to 0 delay between the two copies of the signal.\n\nNext you'll want to find the index or delay that presents the largest correlation. Due to the shrinking overlap this will by default also be index 0, so the following won't work:\n\n```\nacf.argmax() # Always returns 0\n```\n\n\nInstead I recommend to find the largest peak instead, where a peak is defined to be any index with a larger value than both its direct neighbours:\n\n```\ninflection = np.diff(np.sign(np.diff(acf))) # Find the second-order differences\npeaks = (inflection < 0).nonzero()[0] + 1 # Find where they are negative\ndelay = peaks[acf[peaks].argmax()] # Of those, find the index with the maximum value\n```\n\n\nNow ```\ndelay == 20```\n, which tells you that the signal has a frequency of ```\n1/20```\n of its sampling rate:\n\n```\nsignal_freq = fs/delay # Gives 0.05\n```\n\n\nFourier transform\n\nYou used the following to calculate the FFT:\n\n```\nomega = np.fft.fft(x)\nfreq = np.fft.fftfreq(x.size, 1)\n```\n\n\nThhese functions re designed for complex-valued signals. They will work for real-valued signals, but you'll get a symmetric output as the negative frequency components will be identical to the positive frequency components. NumPy provides separate functions for real-valued signals:\n\n```\nft = np.fft.rfft(x)\nfreqs = np.fft.rfftfreq(len(x), t[1]-t[0]) # Get frequency axis from the time axis\nmags = abs(ft) # We don't care about the phase information here\n```\n\n\nLet's have a look:\n\n```\nplt.plot(freqs, mags)\nplt.show()\n```\n\n\n\n\nNote two things: the peak is at frequency 0.05, and the maximum frequency on the axis is 0.5 (the Nyquist frequency, which is exactly half the sampling rate). If we had picked ```\nfs = 20```\n, this would be 10.\n\nNow let's find the maximum. The thresholding method you have tried can work, but the target frequency bin is selected blindly and so this method would suffer in the presence of other signals. We could just select the maximum value:\n\n```\nsignal_freq = freqs[mags.argmax()] # Gives 0.05\n```\n\n\nHowever, this would fail if, e.g., we have a large DC offset (and hence a large component in index 0). In that case we could just select the highest peak again, to make it more robust:\n\n```\ninflection = np.diff(np.sign(np.diff(mags)))\npeaks = (inflection < 0).nonzero()[0] + 1\npeak = peaks[mags[peaks].argmax()]\nsignal_freq = freqs[peak] # Gives 0.05\n```\n\n\nIf we had picked ```\nfs = 20```\n, this would have given ```\nsignal_freq == 1.0```\n due to the different time axis from which the frequency axis was generated.\n\nPeriodogram\n\nThe method here is essentially the same. The autocorrelation function of ```\nx```\n has the same time axis and period as ```\nx```\n, so we can use the FFT as above to find the signal frequency:\n\n```\npdg = np.fft.rfft(acf)\nfreqs = np.fft.rfftfreq(len(x), t[1]-t[0])\n\nplt.plot(freqs, abs(pdg))\nplt.show()\n```\n\n\n\n\nThis curve obviously has slightly different characteristics from the direct FFT on ```\nx```\n, but the main takeaways are the same: the frequency axis ranges from ```\n0```\n to ```\n0.5*fs```\n, and we find a peak at the same signal frequency as before: ```\nfreqs[abs(pdg).argmax()] == 0.05```\n.\n\nEdit:\n\nTo measure the actual periodicity of ```\nnp.sin```\n, we can just use the \"angle axis\" that we passed to ```\nnp.sin```\n instead of the time axis when generating the frequency axis:\n\n```\nfreqs = np.fft.rfftfreq(len(x), 2*np.pi*f*(t[1]-t[0]))\nrad_period = 1/freqs[mags.argmax()] # 6.283185307179586\n```\n\n\nThough that seems pointless, right? We pass in ```\n2*np.pi```\n and we get ```\n2*np.pi```\n. However, we can do the same with any regular time axis, without presupposing ```\npi```\n at any point:\n\n```\nfs = 10\nt = np.arange(1000)/fs\nx = np.sin(t)\nrad_period = 1/np.fft.rfftfreq(len(x), 1/fs)[abs(np.fft.rfft(x)).argmax()] # 6.25\n```\n\n\nNaturally, the true value now lies in between two bins. That's where interpolation comes in and the associated need to choose a suitable window function.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform in R. What am I doing wrong?\r\n                \r\nI am a non-expert in Fourier analysis and quite don't get what R's function fft() does. Even after crossreading a lot I couldnt figure it out. \nI built an example.\n\n```\nrequire(ggplot2)\n\nfreq <- 200  #sample frequency in Hz \nduration <- 3 # length of signal in seconds\n\n#arbitrary sine wave \nx <- seq(-4*pi,4*pi, length.out = freq*duration)\ny <- sin(0.25*x) + sin(0.5*x) + sin(x)\n```\n\n\nwhich looks like:\n\n\n\n```\nfourier <- fft(y)\n\n#frequency \"amounts\" and associated frequencies\n\namo <- Mod(fft(y))\n\nfreqvec <- 1:length(amo) \n```\n\n\nI ASSUME that fft expects a vector recorded over a timespan of 1 second, so I divide by the timespan\n\n```\nfreqvec <- freqvec/duration \n\n#and put this into a data.frame\n\ndf <- data.frame(freq = freqvec, ammount = amo)\n```\n\n\nNow I ASSUMABLY can/have to omit the second half of the data.frame since the frequency \"amounts\" are only significant to half of the sampling rate due to Nyquist.\n\n```\ndf <- df[(1:as.integer(0.5*freq*duration)),]\n```\n\n\nFor plotting I discretize a bit\n\n```\ndf.disc <- data.frame(freq = 1:100)\ncum.amo <- numeric(100)\nfor (i in 1:100){\n  cum.amo[i] <- sum(df$ammount[c(3*i-2,3*i-1,3*i)])\n}\ndf.disc$ammount <- cum.amo\n```\n\n\nThe plot function for the first 20 frequencies: \n\n```\ndf.disc$freq <- as.factor(df.disc$freq)\n\nggplot(df.disc[1:20,], aes(x=freq, y=ammount)) + geom_bar(stat = \"identity\")\n```\n\n\nThe result:\n\n\n\nIs this really a correct spectrogram of the above function? Are my two assumptions correct? Where is my mistake? If there is no, what does this plot now tell me?\n\nEDIT:\nHere is a picture without discretization:\n\n\n\nTHANKS to all of you,\n\nMicha.\n    ", "Answer": "\r\nOkay, okay. Due to the generally inferior nature of my mistake the solution is quite trivial.\nI wrote freq = 200 and duration = 3. But the real duration is from -4pi to 4 pi, hence 8pi resulting in a \"real\" sample frequency of  1/ ((8*pi)/600) = 23.87324 which does not equal 200. \nReplacing the respective lines in the example code by \n\n```\nfreq <- 200  #sample frequency in Hz\nduration <- 6 # length of signal in seconds\nx <- seq(0,duration, length.out = freq*duration) \ny <- sin(4*pi*x) + sin(6*pi*x) + sin(8*pi*x)\n```\n\n\n(with a more illustrative function) yields the correct frequencies as demonstrated by the following plot (restricted to the important part of the frequency domain):\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Applying Fast Fourier transform with a specific product function\r\n                \r\nProblem: Given ```\n2N```\n degree polynomials as ```\na0+a1x+a2x2..+aNxN```\n and\n```\nb0+b1x+b2x2..+bNxN```\n. Assume no 2 coefficient are the same in the 2 polynomials.\n\nFind the product of the polynomials, the catch is that the product(*) operator between the coefficients is defined differently:\n\n```\nf(i,j) := ai * bj := 1/abs(ai-bj)```\n\n\nThat means, find the following polynomial:\n\n```\nc0+c1x+c2x2..+c2Nx2N```\n,\n\nwhere\n\n```\nck := Σi=0..N f(i,k-i)```\n\n\nI know that with FFT, 2 polynomials can be multiplied in ```\nO(n lg n)```\n time with normal product operator between the coefficients but don't have any idea for this kind of problem.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Forward and Backward Fast Fourier Transform, shuift by half period\r\n                \r\nI have a simple problem that i'm not managing to solve.\nI am simply taking the dft of a periodical sequence of numbers (using the fftw3 in fortran), and I noticed that, when taking the inverse transform, the output is the initial sequence, but shifted by exactly one half of the period. Can someone tell me what is the problem? I think I am missing something in the functioning of the fftw3\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform on motor vibration signal in python\r\n                \r\nI collected some data(178,432) of motor vibration signal, and the unit was g(Acceleration). The Sampling rate of signal is 25000/sec, motor speed is 1500rpm(25hz). But while I try to do the FFT using python, the picture isn't right. Can anyone help me with it? \n\nmy data : https://drive.google.com/file/d/12V8H3h6ved4lBflVxoHo2Qv5rfVZqXf0/view?usp=sharing\n\nHere is my code:\n\n```\nimport scipy.fftpack\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nnor = pd.read_csv('normal.csv', header=1)\n\nN = nor.size # data size\nT = 1.0 / 25000.0 # inverse of sampling rate\nx = np.linspace(0.0, N*T, N)\ny = nor.values\nyf = np.abs(scipy.fft(y))\nxf = scipy.fftpack.fftfreq(nor.size, d=T)\n\nfig, ax = plt.subplots()\nax.plot(np.abs(xf), np.abs(yf))\nplt.show()\n```\n\n\nmy FFT plot:\n\n\n    ", "Answer": "\r\nWhen you access the ```\nvalues```\n of a ```\nDataFrame```\n you get an array of arrays, or a 2D array:\n\n```\nIn [23]: pd.read_csv('../Downloads/normal.csv', header=1).values\nOut[23]: \narray([[ 0.006038 ],\n       [ 0.0040734],\n       [ 0.0031316],\n       ..., \n       [-0.0103366],\n       [-0.0025845],\n       [ 0.0012779]])\n```\n\n\nAnd so the result of ```\nscipy.fft(y)```\n is an array of ```\nnor.size```\n separate 1-dimensional 1-item DFFT result arrays, in other words the original signal:\n\n```\nIn [42]: scipy.fft(y)\nOut[42]: \narray([[ 0.0060380+0.j],\n       [ 0.0040734+0.j],\n       [ 0.0031316+0.j],\n       ..., \n       [-0.0103366+0.j],\n       [-0.0025845+0.j],\n       [ 0.0012779+0.j]])\n```\n\n\nYou then proceeded to plot the absolute value of the original signal, against the FFT freqs. Instead you'll want to perform a single DFFT against a vector:\n\n```\nIn [49]: yf = scipy.fft(nor['Channel_0  '].values)  # column/series values\n\nIn [50]: yf\nOut[50]: \narray([ 1.58282430+0.j        , -3.61766030-1.86904326j,\n       -0.50666930+4.24825582j, ...,  4.54241118-0.97200708j,\n       -0.50666930-4.24825582j, -3.61766030+1.86904326j])\n\nIn [51]: x = scipy.fftpack.fftfreq(yf.size, 1 / 25e3)\n\nIn [56]: plot(x[:x.size//2], abs(yf)[:yf.size//2])  # omit fold\nOut[56]: [<matplotlib.lines.Line2D at 0x7f2f39f01cf8>]\n```\n\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python fast Fourier transform for very noisy data\r\n                \r\nI have a file with velocity magnitude data and vorticity magnitude data from a fluid simulation. \n\nI want to find out what is the frequency for these two data sets. \n\nmy code:\n\n```\n# -*- coding: utf-8 -*-\n\"\"\"\nSpyder Editor\n\nThis is a temporary script file.\n\"\"\"\nimport re\nimport math\nimport matplotlib.pyplot as plt\n\nimport numpy as np\n\n\nprobeU1 = []\nprobeV1 = []\n# this creates an array containig all the timesteps, cutting of the first 180, because the system has to stabelize.\nnumber = [ round(x * 0.1, 1) for x in range(180, 301)] \n\n# this function loops over the different time directories, and reads the velocity file.\nfor i in range(len(number)):\n    filenamepath = \"/Refinement/Vorticity4/probes/\" +str(number[i]) + \"/U\"\n    data= open(filenamepath,\"r\")\n    temparray = []\n    #removes all the formatting around the data\n    for line in data:\n        if line.startswith('#'):\n            continue\n    else:\n        line = re.sub('[()]', \"\", line)\n        values = line.split()\n        #print values[1], values[2]\n        xco = values[1::3]\n        yco = values[2::3]        \n        #here it extracts all the velocity data from all the different probes\n        for i in range(len(xco)):\n\n            floatx = float(xco[i])\n            floaty = float(yco[i])\n            temp1 = math.pow(floatx,2)\n            temp2 = math.pow(floaty,2)\n            #print temp2, temp1\n            temp3 = temp1+temp2\n            temp4 = math.sqrt(temp3)\n            #takes the magnitude of the velocity\n            #print temp4\n            temparray.append(temp4)\n        probeU1.append(temparray)\n\n#        \n#print probeU1[0]  \n#print len(probeU1[0])     \n#        \n\n# this function loops over the different time directories, and reads the vorticity file.\nfor i in range(len(number)):\n    filenamepath = \"/Refinement/Vorticity4/probes/\" +str(number[i]) + \"/vorticity\"\n    data= open(filenamepath,\"r\")\n#    print data.read()\n    temparray1 = []\n\n    for line in data:\n        if line.startswith('#'):\n            continue\n    else:\n        line = re.sub('[()]', \"\", line)\n        values = line.split()\n        zco = values[3::3]\n        #because the 2 dimensionallity the z-component of the vorticity is already the magnitude\n        for i in range(len(zco)):  \n            abso = float(zco[i])\n            add = np.abs(abso)\n\n            temparray1.append(add)\n\n    probeV1.append(temparray1)\n\n#Old code block to display the data and check that it made a wave pattern(which it did) \n##Printing all probe data from 180-300 in one graph(unintelligible)\n#for i in range(len(probeU1[1])):\n#    B=[]\n#    for l in probeU1:\n#      B.append(l[i])\n##    print 'B=', B\n##    print i\n#    plt.plot(number,B)\n#\n#\n#plt.ylabel('magnitude of velocity')\n#plt.show()  \n#\n##Printing all probe data from 180-300 in one graph(unintelligible)\n#for i in range(len(probeV1[1])):\n#    R=[]\n#    for l in probeV1:\n#      R.append(l[i])\n##    print 'R=', R\n##    print i\n#    plt.plot(number,R)\n#\n#\n#plt.ylabel('magnitude of vorticity')\n#plt.show()  \n\n#Here is where the magic happens, (i hope)\nans=[]\nfor i in range(len(probeU1[1])):\n    b=[]\n   #probeU1 is a nested list, because there are 117 different probes, wich all have the data from timestep 180-301\n    for l in probeU1:\n      b.append(l[i])\n      #the freqeuncy was not oscillating around 0, so moved it there by substracting the mean\n      B=b-np.mean(b)\n      #here the fft happens\n      u    = np.fft.fft(B)\n      #This should calculate the frequencies?\n      freq = np.fft.fftfreq(len(B), d= (number[1] - number[0]))\n      # If im not mistakes this finds the peak frequency for 1 probe and passes it another list\n      val = np.argmax(np.abs(u))\n      ans.append(np.abs(freq[val]))    \n\n      plt.plot(freq, np.abs(u))\n\n#print np.mean(ans)\nplt.xlabel('frequency?')\nplt.savefig('velocitiy frequency')\nplt.show()\n\n# just duplicate to the one above it\nans1=[]\nfor i in range(len(probeV1[1])):\n    c=[]\n\n    for l in probeU1:\n      c.append(l[i])\n      C=c-np.mean(c)\n      y    = np.fft.fft(C)\n      freq1 = np.fft.fftfreq(len(C), d= (number[1] - number[0]))\n      val = np.argmax(np.abs(y))\n      ans1.append(np.abs(freq1[val]))    \n\n      plt.plot(freq1, np.abs(y))\n\n#print np.mean(ans1)\nplt.ylabel('frequency?')\nplt.savefig('vorticity frequency')\nplt.show()     \n\n\n\ndata.close()\n```\n\n\nMy data contains 117 probes each having their own 121 point of velocity magnitude data. \n\nMy aim is to find the dominate frequency for each probe and then collect all those and plot them in a histogram. \n\nMy question is about the part where it says this is where the magic happens. I believe the fft is already working correctly\n\n```\n  y    = np.fft.fft(C)\n          freq1 = np.fft.fftfreq(len(C), d= (number[1] - number[0]))\n```\n\n\nAnd if I'm not mistaken the freq1 list should contain all the frequencies for a given probe. I've checked this list visually and the amount of different frequencies is very high(20+) so the signal is probably very noisy.\n\n```\n# If im not mistakes this finds the peak frequency for 1 probe and passes it another list\n      val = np.argmax(np.abs(u))\n      ans.append(np.abs(freq1[val]))    \n```\n\n\nThat this part should in theory take the biggest signal from one probe and than put in the \"ans\" list. But I'm a bit confused as to how i can no correctly identify the right frequency. As there should i theory be one main frequency. How can I correctly estimate the \"main\" frequency from all this data from all the noise\n\nFor reference I'm modeling an Von Karmann vortex street and I'm looking for the frequency of vortex shedding. https://en.wikipedia.org/wiki/K%C3%A1rm%C3%A1n_vortex_street\n\nCan anyone help me on how to solve this?\n    ", "Answer": "\r\nThe line\n\n```\nfreq1 = np.fft.fftfreq(len(C), d= (number[1] - number[0]))\n```\n\n\nOnly generates an index going from \n\n```\nfreq1 = [0, 1, ...,   len(C)/2-1,     -len(C)/2, ..., -1] / (d*len(C))\n```\n\n\nWhich is useful to compute your frequencies array as\n\n```\nfreq[i] = freq1[i]*alpha\n```\n\n\nWhere ```\nalpha```\n is your basic wavenumber computed as\n\n```\nalpha = 1/Ts\n```\n\n\nBeing ```\nTs```\n your sampling period. I think that because ```\nfreq1```\n is not scaled you array of frequencies is so high.\n\nNote that if you are sampling your data using different time steps you will need to interpolate it at in a evenly space domain using ```\nnumpy.interp```\n (for example).\n\nTo estimate the main frequency just find the index where the fft-transformed variable is higher and relate that index to ```\nfreq[i]```\n.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Bi-dimensional Fast Fourier Transformation Problem\r\n                \r\nI am new to image processing and in need of some help here. I refer to Fig.10 of the paper by Z. Yang, M. Krishnamurthy and I. P. Brown, \"Electromagnetic and vibrational characteristic of IPM over full torque-speed range\" \n\nAccording to the authors, a 2d-FFT was performed to change the figure on the left to that on the right. However, it did not work out for me. Applied fft2(Matlab) to  and got this .\n\nPlease tell me what am I missing.\n\nThank you in advance.\n\nTony\n    ", "Answer": "\r\nIt looks like the authors used artistic license to cut off the coefficients below some chosen intensity threshold close to zero, and not color them at all. This helps presentation if the order of magnitude of the coefficients is close to the numeric noise floor, i.e. in a clean data set.\n\nExclude the DC value in your upper left from the dynamic range (color bar range) calculations. It tends to be the largest value and not central to the purpose of the plot.\n\nTo account for the different position of your spectral peaks, consider the differences in your data set which has a higher base frequency along both axis (assuming the units are the same.)\n\nAnother difference are the axis meanings. The paper plots frequencies as harmonics to some base frequency.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Bi-dimensional Fast Fourier Transformation Problem\r\n                \r\nI am new to image processing and in need of some help here. I refer to Fig.10 of the paper by Z. Yang, M. Krishnamurthy and I. P. Brown, \"Electromagnetic and vibrational characteristic of IPM over full torque-speed range\" \n\nAccording to the authors, a 2d-FFT was performed to change the figure on the left to that on the right. However, it did not work out for me. Applied fft2(Matlab) to  and got this .\n\nPlease tell me what am I missing.\n\nThank you in advance.\n\nTony\n    ", "Answer": "\r\nIt looks like the authors used artistic license to cut off the coefficients below some chosen intensity threshold close to zero, and not color them at all. This helps presentation if the order of magnitude of the coefficients is close to the numeric noise floor, i.e. in a clean data set.\n\nExclude the DC value in your upper left from the dynamic range (color bar range) calculations. It tends to be the largest value and not central to the purpose of the plot.\n\nTo account for the different position of your spectral peaks, consider the differences in your data set which has a higher base frequency along both axis (assuming the units are the same.)\n\nAnother difference are the axis meanings. The paper plots frequencies as harmonics to some base frequency.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Car vibration evaluated by Fast Fourier Transform in Octave\r\n                \r\nI must evaluate vibration of a car. For this trial I used accelerometer. Collected data are depended on the time.\n\nI need to convert the data from time domain to frequency domain by FFT. Unfortunately, I am not familiar with coding and FTT very well, however I found and used the code below.\n\nWhat is strange for me, that maximum high point has 0Hz. Please, see attached image.\nAnyway, is there a way how to do a graph more obvious? For example, cut a series in x-axis and shows only data under 200Hz.\n\n\n\n```\nclc\nA=xlsread('50_dirt_road.xlsx');\nt=A(:,9);\ns=A(:,8);\nTs = mean(diff(t));                                     % Sampling Interval\nFs = 1/Ts;                                              % Sampling Frequency\nFn = Fs/2;                                              % Nyquist Frequency\nL = numel(t);                                           % Signal Length\nsm = s - mean(s);                                       % Mean-Corrected Signal (Eliminates 0 Hz Offset)\nFTs = fft(sm)/L;                                        % Fourier Transform\nFv = linspace(0, 1, fix(L/2)+1)*Fn;                     % Frequency Vector\nIv = 1:numel(Fv);                                       % Index Vector\n[MaxV,idx] = max(abs(FTs(Iv))*2);                       % Maximum V & Index\nFreq = Fv(idx);                                         % Frequency Of Maximum V\nfigure\nplot(Fv, abs(FTs(Iv))*2)\ngrid\ntext(Freq, MaxV, sprintf('\\\\leftarrow %.4f G, %.0f Hz', MaxV, Freq), 'HorizontalAlignment','left')\nxlabel('Frequency (Hz)')\nylabel('Amplitude')\n```\n\n\nCould you double check it, please? My variables are defined as follows:\n\n\n```\ns```\n: measured \"G\" value. In total 3395 measured values.\n```\nt```\n: time. Every single value was recorded after 0.001s, in total 3.395s.\n\n    ", "Answer": "\r\nThe maximum high point you are referring to is normal.  Without having frequency cut offs, the beginning, (nearest zero), of your fourier transform will always have the most spectral energy because it is resolving sampling rates tending towards zero which as you can imagine would have a ton of representation in the time series.  Obviously 0 hz is impossible, so you should choose a lower bound frequency that makes sense in the domain of car vibrations.  So I recommend a band pass filter, one that does forward and backward filtering (filt filt) to preserve the original time series and then running the result through this analysis.  I would start with a butterworth filter and experiment with othes if desired:\n\nhttps://octave.sourceforge.io/signal/function/butter.html\n\nEDIT:\n\nI was using t but the signal is in s.  Here is the whole thing:\n\n```\nclc\nA=xlsread('50_dirt_road.xlsx');\nt=A(:,9);\ns=A(:,8);\nTs = mean(diff(t));                                     % Sampling Interval\nFs = 1/Ts;                                              % Sampling Frequency\nFn = Fs/2;                                              % Nyquist Frequency\nL = numel(t);                                           % Signal Length\n\n%1st order butterworth filter with a band pass of 1hz to 200hz in radians\n%forward and reverse filtered\n[b,a] = butter(1, [1/(L/2), 200/(L/2)]);\nfiltered_s = filtfilt(b,a,s);\n\nsm = filtered_s - mean(filtered_s);                     % Mean-Corrected Signal (Eliminates 0 Hz Offset)\nFTs = fft(sm)/L;                                        % Fourier Transform\nFv = linspace(0, 1, fix(L/2)+1)*Fn;                     % Frequency Vector\nIv = 1:numel(Fv);                                       % Index Vector\n[MaxV,idx] = max(abs(FTs(Iv))*2);                       % Maximum V & Index\nFreq = Fv(idx);                                         % Frequency Of Maximum V\nfigure\nplot(Fv, abs(FTs(Iv))*2)\ngrid\ntext(Freq, MaxV, sprintf('\\\\leftarrow %.4f G, %.0f Hz', MaxV, Freq), 'HorizontalAlignment','left')\nxlabel('Frequency (Hz)')\nylabel('Amplitude')\n```\n\n\nLAST EDIT:\n\nOkay, so I think I got you an intro in to the world of filtering when I think all you were looking to do is constrain the axis of your FFT.  Same arguments for the band pass filter above, 1hz and 200hz.  The above code should work but the following code is probably what you were looking for originally:\n\n```\nclc\nA=xlsread('50_dirt_road.xlsx');\nt=A(:,9);\ns=A(:,8);\nTs = mean(diff(t));                                     % Sampling Interval\nFs = 1/Ts;                                              % Sampling Frequency\nFn = Fs/2;                                              % Nyquist Frequency\nL = numel(t);                                           % Signal Length\n\nsm = s - mean(s);                     % Mean-Corrected Signal (Eliminates 0 Hz Offset)\nFTs = fft(sm)/L;                                        % Fourier Transform\nFv = linspace(0, 1, fix(L/2)+1)*Fn;                     % Frequency Vector\nfreqMask = (Fv > 1) & (Fv < 200);\nFv = Fv(freqMask);\nFTs = FTs(freqMask);\nIv = 1:numel(Fv);                                       % Index Vector\n[MaxV,idx] = max(abs(FTs(Iv))*2);                       % Maximum V & Index\nFreq = Fv(idx);                                         % Frequency Of Maximum V\nfigure\nplot(Fv, abs(FTs(Iv))*2)\ngrid\ntext(Freq, MaxV, sprintf('\\\\leftarrow %.4f G, %.0f Hz', MaxV, Freq), 'HorizontalAlignment','left')\nxlabel('Frequency (Hz)')\nylabel('Amplitude')\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Casting complex values discards imaginary part on fast fourier algorithm\r\n                \r\nI was making the fast fourier transformation algorithm, based on cooley-tukey method. The code looks fine to me, but I keep getting numpy error like: \n\n```\nCasting complex values to real discards the imaginary part\n```\n\n\nI am not sure how to change the assignments in the iterrations. The algorithm is described here: \n\n```\ndef fast_fourier_transformation(data):\n    N = len(data)\n    if N > 1:\n        Wn = math.e ** (2 * math.pi * 1j / N)\n        W = 1\n        A_even = data[::2]\n        A_odd = data[1::2]\n        B_even = fast_fourier_transformation(A_even)\n        B_odd = fast_fourier_transformation(A_odd)\n        for k in range(0, N // 2):\n            data[k] = B_even[k] + W * B_odd[k]\n            data[k + N // 2] = B_even[k] - W * B_odd[k]\n            W = W * Wn\n    return data\n```\n\n    ", "Answer": "\r\nYour data variable needs to be declared as complex (set the imaginary component to zero for strictly real input), since the output of your function needs to be complex, and you are using \"data\" for both the input parameter and the return value (output).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Help with FFT(Fast Fourier Transforms) and/or DSP\r\n                \r\nIm trying to do a screen-flashing application, that flashes the screen according to the music(which will be frequencies, such as healing frequencies, etc...).\nI already made the player and know how will I make the screen flash, but I need to make the screen flash super fast according to the music, for example if the music speeds up, the screen-flash will flash faster. I understand that I would achieve this by FFT or DSP(as I only need to know when the frequency raises from some Hz, lets say 20 to change the color, making the screen-flash). \n\nBut I've found that I understand NOTHING, even less try to implement it to my application. \n\nCan somebody help me out to learn whichever both of them? My email is sismetic_chaos@hotmail.com. I really need help, I've been stucked for like 3 days not coding or doing anything at all, trying to understand, but I dont.\n\nPS:My application is written in C++ and Qt.\n\nPS:Thanks for taking the time to read this and the willingness to help.\n\nEdit: Thanks to all for the answers, the problem is in no way solved yet, but I appreciate all the answers, I didnt thought I would get so many answers and info. Thanks to you all.\n    ", "Answer": "\r\nThis is a difficult problem, requiring more than an FFT. I'll briefly describe how I implemented beat detection when I was writing software for professional DJ equipment.\n\nFirst of all, you'll need to cut down the amount of data you're dealing with, since there are only two or three beats per second, but tens of thousands of samples. You'll also need to look at different frequency ranges, since some types of music carry the tempo in the bassline, and others in percussion or other instruments. So pass the signal through several band-pass filters (I chose 8 filters, each covering one octave, from low bass to high treble), and then downsample each band by averaging the power over a few hundred samples.\n\nEvery few seconds, you'll have a thousand or so samples in each band. Your next tool is an autocorrelation, to identify repetitive patterns in the music. The peaks of the autocorrelation tell you what the beat is more or less likely to be; but you'll need to make up some heuristics to compare all the frequency bands to find a beat that you can be confident in, and to avoid misleading syncopations. If you can manage that, then you'll have a reasonable guess at the tempo, but no idea of the phase (i.e. exactly when to flash the screen).\n\nNow you can look at the a smoothed version of the audio data for peaks, some of which are likely to correspond to beats. Initially, look for the strongest peak over the course of a few seconds and take that as a downbeat. In conjunction with the tempo you estimated in the first stage, you can predict when the next beat is due, and measure where you actually saw something like a beat, and adjust your estimate to more closely match the data. You can also maintain a confidence level based on how well the predicted beats match the measured peaks; if that drops too low, then restart the beat detection from scratch.\n\nThere are a lot of fiddly details to this, and it took me some weeks to get it working nicely. It is a difficult problem.\n\nOr for a simple visualisation effect, you could simply detect peaks and flash the screen for each one; it will probably look good enough.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Understanding the output from the fast Fourier transform method\r\n                \r\nI'm trying to make sense of the output produced by the python FFT library. \n\nI have a sqlite database where I have logged several series of ADC values. Each series consist of 1024 samples taken with a frequency of 1 ms.\n\nAfter importing a dataseries, I normalize it and run int through the ```\nfft```\n method. I've included a few plots of the original signal compared to the FFT output.\n\n```\nimport sqlite3\nimport struct\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport math\n\nconn = sqlite3.connect(r\"C:\\my_test_data.sqlite\")\nc = conn.cursor()\n\nc.execute('SELECT ID, time, data_blob FROM log_tbl')\n\n\nfor row in c:\n    data_raw = bytes(row[2])\n    data_raw_floats = struct.unpack('f'*1024, data_raw)\n    data_np = np.asarray(data_raw_floats)\n\n    data_normalized = (data_np - data_np.mean()) / (data_np.max() - data_np.min())\n\n    fft = np.fft.fft(data_normalized)\n    N = data_normalized .size\n\n    plt.figure(1)\n    plt.subplot(211)\n    plt.plot(data_normalized )\n\n    plt.subplot(212)\n    plt.plot(np.abs(fft)[:N // 2] * 1 / N)\n    plt.show()\n\n    plt.clf()\n```\n\n\n\n\n\n\n\n\nThe signal clearly contains some frequencies, and I was expecting them to be visible from the FFT output.\n\nWhat am I doing wrong?\n    ", "Answer": "\r\nYou need to make sure that your data is evenly spaced when using ```\nnp.fft.fft```\n, otherwise the output will not be accurate. If they are not evenly spaced, you can use LS periodograms for example: http://docs.astropy.org/en/stable/stats/lombscargle.html.\nOr look up non-uniform fft.\n\nAbout the plots:\nI don't think that you are doing something obviously wrong. Your signal consists a signal with period in the order of magnitude ```\n100```\n, so you can expect a strong frequency signal around ```\n1/period=0.01```\n. This is what is visible on your graphs. The time-domain signals are not that sinusoidal, so your peak in the frequency domain will be blurry, as seen on your graphs.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Any Open Source Fast Fourier Transform C implementation? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking us to recommend or find a book, tool, software library, tutorial or other off-site resource are off-topic for Stack Overflow as they tend to attract opinionated answers and spam. Instead, describe the problem and what has been done so far to solve it.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm trying to find the fundamental frequency of a recorded sound using FFT in C. Would anyone know a open source implementation in C that I can modify and use?\n\nThanks!\n    ", "Answer": "\r\nFFTW is probably what you are looking for.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python discrete fourier transformation\r\n                \r\nI write my own version of 2d DFT with NumPy, however, it is extremely slow and gives a different result from np.fft.fft2. Is the np fft.fft2 basing on the fast Fourier transformation? Is there anything wrong with my code?\n```\ndef gray_DFT(spatial_img, centerlize = False):\n    M,N = spatial_img.shape\n    frequency_img = np.zeros(spatial_img.shape)\n    for u in range(0,M):\n        for v in range(0,N):\n            print(u,v)\n            mesh_x, mesh_y = np.meshgrid(np.arange(M),np.arange(N), indexing = 'ij')\n            matrix = u * mesh_x / M + v * mesh_y / N\n            complex_matrix = -2j*np.pi*matrix\n            exp_matrix = np.exp(complex_matrix)\n            if centerlize:\n                transform_matrix = np.power((-np.ones((M,N))), mesh_x + mesh_y)\n                frequency_img[u,v] = np.sum(spatial_img*transform_matrix*exp_matrix)\n            else:    \n                frequency_img[u,v] = np.sum(spatial_img*exp_matrix)\n    return frequency_img\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Doubling input array when using numpy for fast fourier transforms\r\n                \r\nI wrote a function that returns the real component of the fast four transform of a grid. \n\n```\ndef take_FFT(x):\n    # some arbitrary field for a 1D grid\n    y = abs(1.0/x)\n    # compute FFT (in general multi-dimensional) array of real numbers\n    y_k = np.fft.rfftn(y)\n\n    #compute the inverse FFT\n    y_invk = np.fft.irfftn(y_k)\n    return y,y_k, y_invk # return fourier transform and inv transform\n\n# initialize sample x\nx_test = np.arange(-5,5,0.001)\n\nfield,FFT_test, inv_test = take_FFT(x_test)\n```\n\n\nHow do I make an appropriate new \"x array\" to plot against the FFT? It is not clear to me how to make an array of length = (n/2)+1, like the one that np.fft.irfftn returns \n    ", "Answer": "\r\nWelcome to StackOverflow, @Messier!\n\nIf I understand your question correctly, you want to ```\nslice```\n a ```\nnumpy.array```\n.\n\nSuppose we have a ```\nnumpy.array```\n ```\narr```\n that has length ```\nN```\n. Then to slice up to length ```\nM```\n (such that ```\nM<=N```\n) or up to ```\n(N/2)+1```\n:\n\n```\nsliced_arr = arr[:M]\nslice_half = arr[:N//2+1]\n```\n\n\nwhere in ```\npython```\n versions ```\n3```\n or greater, ```\nN//2```\n does integer division.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Does R have inverse fast fourier transform function?\r\n                \r\nI believe R has ifft function, but whenever I enter ```\n?ifft```\n it returns this message:\n```\nNo documentation for ‘ifft’ in specified packages and libraries:\nyou could try ‘??ifft’\n```\n\nWhat is the package for ifft?\n    ", "Answer": "\r\nTry ```\nsignal```\n library. For further information you may use this resource: https://www.rdocumentation.org/packages/signal/versions/0.7-6/topics/ifft\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Frequency resolution(or increment) of FFT(Fast fourier transform)\r\n                \r\nI tried to use ```\nfft```\n function in Matlab. I could understand why 'dt(sampling time interval) = 1/fs(sampling frequency). But I couldn't understand why 'df(frequency resolution(increment) = fs/N(length of data or Tmax)'. Why is df variable decided by using fs/N?\n    ", "Answer": "\r\nA discrete signal of length N can be decomposed into (shifted) sine waves with periods of N, N/2, N/3, N/4, etc., plus a constant (DC) term. This is the decomposition that the DFT computes. Each bin in the DFT thus represents a frequency corresponding to a wavelength (period) that is an integer fraction of the signal length.\nConsequently, the smallest frequency in the decomposition is 1/N (corresponding to 1/(dt N) Hz if dt is in seconds).\nThe next frequency component is 2/N, then 3/N, etc.\nThe largest frequency component is 1 (corresponding to 1/dt), though that frequency is aliased.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Scipy Fourier Transform KeyError: 'ALIGNED'?\r\n                \r\nI'm trying to run a fast fourier transform on a pandas dataframe that I have. I am using the Kepler exoplanet dataset, here, and a specific notebook for it, here. I recreate the code in cells 27-30 (Note that the code in cell 29 is executed elsewhere, thus both dataframes have the same shape as the original notebook), which looks as follows:\n```\nimport scipy\n\ndef spectrum_getter(X):\n    Spectrum = scipy.fft.fft(X, n=X.size)\n    return np.abs(Spectrum)\n\nx_train_OS_FT = x_train_OS.apply(spectrum_getter, axis=1)\nx_test_FT = x_test.apply(spectrum_getter, axis=1)\n```\n\nBoth x_train_OS and x_test are ```\npandas.core.frame.DataFrame```\n. Running this produces:\n```\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nInput In [245], in <module>\n----> 1 x_train_OS_FT = x_train_OS.apply(spectrum_getter, axis=1)\n      2 x_test_FT = x_test.apply(spectrum_getter, axis=1)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\frame.py:8827, in DataFrame.apply(self, func, axis, raw, result_type, args, **kwargs)\n   8816 from pandas.core.apply import frame_apply\n   8818 op = frame_apply(\n   8819     self,\n   8820     func=func,\n   (...)\n   8825     kwargs=kwargs,\n   8826 )\n-> 8827 return op.apply().__finalize__(self, method=\"apply\")\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\apply.py:727, in FrameApply.apply(self)\n    724 elif self.raw:\n    725     return self.apply_raw()\n--> 727 return self.apply_standard()\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\apply.py:851, in FrameApply.apply_standard(self)\n    850 def apply_standard(self):\n--> 851     results, res_index = self.apply_series_generator()\n    853     # wrap results\n    854     return self.wrap_results(results, res_index)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\apply.py:867, in FrameApply.apply_series_generator(self)\n    864 with option_context(\"mode.chained_assignment\", None):\n    865     for i, v in enumerate(series_gen):\n    866         # ignore SettingWithCopy here in case the user mutates\n--> 867         results[i] = self.f(v)\n    868         if isinstance(results[i], ABCSeries):\n    869             # If we have a view on v, we need to make a copy because\n    870             #  series_generator will swap out the underlying data\n    871             results[i] = results[i].copy(deep=False)\n\nInput In [244], in spectrum_getter(X)\n      3 def spectrum_getter(X):\n----> 4     Spectrum = scipy.fft.fft(X, n=X.size)\n      5     return np.abs(Spectrum)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\scipy\\fft\\_backend.py:22, in _ScipyBackend.__ua_function__(method, args, kwargs)\n     20 if fn is None:\n     21     return NotImplemented\n---> 22 return fn(*args, **kwargs)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\scipy\\fft\\_pocketfft\\basic.py:17, in c2c(forward, x, n, axis, norm, overwrite_x, workers, plan)\n     14 if plan is not None:\n     15     raise NotImplementedError('Passing a precomputed plan is not yet '\n     16                               'supported by scipy.fft functions')\n---> 17 tmp = _asfarray(x)\n     18 overwrite_x = overwrite_x or _datacopied(tmp, x)\n     19 norm = _normalization(norm, forward)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\scipy\\fft\\_pocketfft\\helper.py:97, in _asfarray(x)\n     95 dtype = x.dtype.newbyteorder('=')\n     96 # Always align input\n---> 97 copy = not x.flags['ALIGNED']\n     98 return np.array(x, dtype=dtype, copy=copy)\n\nFile c:\\users\\marti\\appdata\\local\\programs\\python\\python39\\lib\\site-packages\\pandas\\core\\flags.py:98, in Flags.__getitem__(self, key)\n     96 def __getitem__(self, key):\n     97     if key not in self._keys:\n---> 98         raise KeyError(key)\n    100     return getattr(self, key)\n\nKeyError: 'ALIGNED'\n```\n\nI attempted to convert the dataframe to a numpy array, but ran into other issues. What am I doing wrong here?\n    ", "Answer": "\r\nI ran to the same error so I converted my datatype to dataframe and it solved my problem.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why Fast Fourier Convolution does not work in set parameter : ratio_gin and ratio_gout:0.5?\r\n                \r\nI am studying about the Fourier Transform and Fast Fourier Convolution.\nI would like to use FFC but having trouble getting it to work.\nFast Fourier Convolution\nFast Fourier Convolution NeurIPS 2020\noriginal implementation https://github.com/pkumivision/FFC/blob/main/model_zoo/ffc.py\npaper https://proceedings.neurips.cc/paper/2020/file/2fd5d41ec6cfab47e32164d5624269b1-Paper.pdf\n\n\nThe above imgs refer to pages 3 and 4 of the paper\n##FFC code is\nreference:\nhttps://github.com/pkumivision/FFC/blob/main/model_zoo/ffc.py\n```\n\nclass FFC(nn.Module):\n\n    def __init__(self, in_channels, out_channels, kernel_size,\n                 ratio_gin, ratio_gout, stride=1, padding=0,\n                 dilation=1, groups=1, bias=False, enable_lfu=True):\n        super(FFC, self).__init__()\n\n        assert stride == 1 or stride == 2, \"Stride should be 1 or 2.\"\n        self.stride = stride\n\n        in_cg = int(in_channels * ratio_gin)\n        in_cl = in_channels - in_cg\n        out_cg = int(out_channels * ratio_gout)\n        out_cl = out_channels - out_cg\n        #groups_g = 1 if groups == 1 else int(groups * ratio_gout)\n        #groups_l = 1 if groups == 1 else groups - groups_g\n\n        self.ratio_gin = ratio_gin\n        self.ratio_gout = ratio_gout\n\n        module = nn.Identity if in_cl == 0 or out_cl == 0 else nn.Conv2d\n        self.convl2l = module(in_cl, out_cl, kernel_size,\n                              stride, padding, dilation, groups, bias)\n        module = nn.Identity if in_cl == 0 or out_cg == 0 else nn.Conv2d\n        self.convl2g = module(in_cl, out_cg, kernel_size,\n                              stride, padding, dilation, groups, bias)\n        module = nn.Identity if in_cg == 0 or out_cl == 0 else nn.Conv2d\n        self.convg2l = module(in_cg, out_cl, kernel_size,\n                              stride, padding, dilation, groups, bias)\n        module = nn.Identity if in_cg == 0 or out_cg == 0 else SpectralTransform\n        self.convg2g = module(\n            in_cg, out_cg, stride, 1 if groups == 1 else groups // 2, enable_lfu)\n\n    def forward(self, x):\n        x_l, x_g = x if type(x) is tuple else (x, 0)\n        out_xl, out_xg = 0, 0\n\n        if self.ratio_gout != 1:\n            out_xl = self.convl2l(x_l) + self.convg2l(x_g)\n        if self.ratio_gout != 0:\n            out_xg = self.convl2g(x_l) + self.convg2g(x_g)\n\n        return out_xl, out_xg\n```\n\nBelow is my test code using this above .py file.\nIf ratio_gout is set to 0.5 each as 　α parameter in the paper, it will result in ERROR.\n```\n\n#1.gray schale:\n\nffc_m=FFC(in_channels=1,out_channels=10,kernel_size=1,\n         ratio_gin=0.5,ratio_gout=0.5,padding=\"same\",groups=1)\n\n#gray schale sample\ngray_img=torch.randn(1,1,32,32).float()\n\nout1,out2=ffc_m(temp_img)\nprint(out1.shape)\nprint(out2.shape)\n\n#>>>torch.Size([1, 5, 32, 32])\n#>>>torch.Size([1, 5, 32, 32])\n\n2.like RGB schale :\nffc_m=FFC(in_channels=3,out_channels=10,kernel_size=1,\n         ratio_gin=0.5,ratio_gout=0.5,padding=\"same\",groups=1)\n\n#3channels\ntemp_img=torch.randn(1,3,32,32).float()\n\nout=ffc_m(temp_img)\n#>>>output error is below\n#RuntimeError: Given groups=1, weight of size [5, 2, 1, 1], expected input[1, 3, 32, 32] to have 2 channels, but got 3 channels instead\n\n#but works for the following parameters: ratio_gin=0. ratio_gout=1\nffc_m=FFC(in_channels=3,out_channels=10,kernel_size=1,\n         ratio_gin=0,ratio_gout=1.,padding=\"same\",groups=1)\n\ntemp_img=torch.randn(1,3,32,32).float()\nout1,out2=ffc_m(temp_img)\n#out1:0.\n#out2.shape:torch.Size([1, 10, 32, 32])\n\n```\n\nI just couldn't figure out Why this FFC module does not work for 3 channel img tensor with ratio_gin:0.5 and ratio_gout:0.5 each parameter.\nThe parameter of [αin,αout] in this reference is not equal　 FFC module`s ratio_gin and ratio_gout?\nSorry for the confusing explanation.\nI would appreciate any advice you could give me. Best regards.Thank you.\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform and Time-Series Forecasting in R\r\n                \r\nAfter reviewing the literature available for FFT,  I saw very little documentation of employing FFT for macroeconomic data. Can you please give sources to utilize FFT using time-series data in R? Thank you for your time. \n    ", "Answer": "\r\nDon't waste your time with applying FFT's to macroeconomic data. If there are cycles in the data, then the only things to find is the fundamental frequency and probably a second harmonic. All else is noise.\n\nAn autocorrelation function is the (much) better tool here.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform: The first element is correct, but the rest are not\r\n                \r\nI'm implementing FFT, and my solution can consistently solve the first element of the transform, but can't do the rest.\n\nHere is the code:\n\n```\nvector<complex<double>> FFT(vector<complex<double>> a, complex<double> w)\n{\n    if (a.size() == 1) {\n        return a;\n    }\n    vector<complex<double>> even;\n    vector<complex<double>> odd;\n    for (int i = 0; i < a.size(); i ++) {\n        if (i % 2 == 0) {\n            even.push_back(a[i]);\n        }\n        else {\n             odd.push_back(a[i]);\n        }\n    }\n    vector<complex<double>> FFTeven = FFT(even, nthRoot(a.size() / 2));\n    vector<complex<double>> FFTodd = FFT(odd, nthRoot(a.size() / 2));\n\n    vector<complex<double>> ret;\n    for (int i = 0; i < a.size(); i++) {\n    ret.push_back(0);\n    }\n    for (int i = 0; i <= (a.size() / 2) - 1; i++) {\n        ret[i] = FFTeven[i] + pow(w, i) * FFTodd[i];\n        ret[i + a.size() / 2] = FFTeven[i] - pow(w, i) * FFTodd[i];\n    }\n    return ret;\n}\n```\n\n\nmain code:\n\n```\nint n = 4;\nvector <complex<double>> a;\nvector<complex<double>> b;\nfor (int i = 1; i < 9; i++) {\n    if (i < 5) {\n        a.push_back((complex<double>) i);\n    }\n    else {\n        b.push_back((complex<double>) i);\n    }\n}\nfor (int i = 0; i < n; i++) {\n    a.push_back(0);\n    b.push_back(0);\n}\ncomplex<double> w = nthRoot(a.size());\n\na = FFT(a, w);\nb = FFT(b, w);\nfor (int i = 0; i < a.size() - 1; i++) {\n    cout << a[i].real() << \", \";\n}\ncout << a.back().real() << \">\\n\";\nfor (int i = 0; i < b.size() - 1; i++) {\n    cout << b[i].real() << \", \";\n}\ncout << b.back().real() << \">\\n\";\n```\n\n\nnthRoot:\n\n```\ncomplex<double> nthRoot(int n)\n{\n    return (cos(2 * M_PI / n) + i * sin(2 * M_PI / n));\n}\n```\n\n\ni globally declared:\n\n```\nconst complex<double> i = (0.0, 1.0);\n```\n\n\nexample input:\n\n\n  a = <5, 6, 7, 8, 0, 0, 0, 0>\n\n\nexample output:\n\n\n  ret = <26, 31.799, -6, -7.65685, -2, -7.79899, 2, 3.65685>\n\n\nexpected output:\n\n\n  ret = <26, 3.5858, -2, 6.4142, -2, 6.4142, -2, 3.5858>\n\n\nThis FFT is being used to find a convolution, hence the padded zeros at the end of the input vector. Any help would be appeciated.\n    ", "Answer": "\r\nWell I got your expected output by running your code. The only difference is when I ```\npushback```\n 0s, I have to use ```\npush_back(complex<double>(0))```\n. I don't think that matters.\n\nDid you messed up with expected result and example result?\n\nIn case someone is interested in this FFT example, I put the \"copy-paste-run\" version below: \n\n```\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <complex>\n\nusing namespace std;\n\ncomplex<double> nthRoot(int n)\n{\n    return complex<double>(cos(2 * M_PI / n), sin(2 * M_PI / n));\n}\n\nvector<complex<double> > FFT(vector<complex<double> > a, complex<double> w)\n{\n    if (a.size() == 1) {\n        return a;\n    }\n    vector<complex<double> > even;\n    vector<complex<double> > odd;\n    for (int i = 0; i < a.size(); i ++) {\n        if (i % 2 == 0) {\n            even.push_back(a[i]);\n        }\n        else {\n             odd.push_back(a[i]);\n        }\n    }\n    vector<complex<double> > FFTeven = FFT(even, nthRoot(a.size() / 2));\n    vector<complex<double> > FFTodd = FFT(odd, nthRoot(a.size() / 2));\n\n    vector<complex<double> > ret;\n    for (size_t i = 0; i < a.size(); i++) {\n        ret.push_back(complex<double>(0));\n    }\n    for (size_t i = 0; i <= (a.size() / 2) - 1; i++) {\n        ret[i] = FFTeven[i] + pow(w, i) * FFTodd[i];\n        ret[i + a.size() / 2] = FFTeven[i] - pow(w, i) * FFTodd[i];\n    }\n    return ret;\n}\n\nint main(void) {\n\n  int n = 4;\n  vector<complex<double> > a;\n  vector<complex<double> > b;\n  for (int i = 1; i < 9; i++) {\n      if (i < 5) {\n          a.push_back((complex<double>) i);\n      }\n      else {\n          b.push_back((complex<double>) i);\n      }\n  }\n  for (int i = 0; i < n; i++) {\n      a.push_back(complex<double>(0));\n      b.push_back(complex<double>(0));\n  }\n  complex<double> w = nthRoot(a.size());\n\n  a = FFT(a, w);\n  b = FFT(b, w);\n  for (int i = 0; i < a.size() - 1; i++) {\n      cout << a[i].real() << \", \";\n  }\n  cout << a.back().real() << \">\\n\";\n  for (int i = 0; i < b.size() - 1; i++) {\n      cout << b[i].real() << \", \";\n  }\n  cout << b.back().real() << \">\\n\";\n}\n```\n\n\nThe output is\n\n\n  10, -0.414214, -2, 2.41421, -2, 2.41421, -2, -0.414214>\n  \n  26, 3.58579, -2, 6.41421, -2, 6.41421, -2, 3.58579>\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "On the fly calculation of Fourier transformation in Java\r\n                \r\nI want to write a program in Java that uses fast Fourier transformation.\nThe program reads data every 5 milliseconds seconds from sensors and is supposed to do something with the data every 200 milliseconds based on the data from the last five seconds.\n\nIs there a good library in Java that provides a way to do Fourier transformation without recalculating all five seconds every time?\n    ", "Answer": "\r\nHard real time problems are not the proper application of Java. There are too many variables such as Garbage collection and Threads not guaranteed to happen within a given interval to make this possible. If close enough is acceptable it will work. The performance of your software as far as timing will also depend on the OS and hardware you are using and what other programs are also running on that box.  \n\nThere is a Real Time Java, that does have a special API for the issues I mention above. You do not indicate that you are using that. It is also a different animal in a lot of respects than plain Java.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier transform of the recorded wav file in Android\r\n                \r\nThere is a wav file on SD card. First, I connect to a file and reads the byte:\n\n```\nFile file = null;file = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + \"/202.wav\");\n       byte[] byteData = new byte[(int) file.length()];\n       FileInputStream in = null;\n       try {\n       in = new FileInputStream( file );\n       in.read( byteData );\n       in.close();}\n```\n\n\nI then use the transformation of data from a byte type in type double, because the FFT procedure does not work with byte type:\n\n```\ndouble[] transformed = new double[(int) file.length()];\n      for (int j=1;j<8194;j++) {\n              transformed[j] = (double)byteData[j]; }\n```\n\n\nAnd then the procedure of FFT processing this data:\n\n```\npublic void spektr(double[] x, double[] y, int Dim, int D, double[] xx, double[] yy) {\n\n     int I,J,N,L,K,LE,LE1,IP,NV2,NM1;\n     double Arg,U1,U2,U3,C,S,T1,T2,T3,T4;\n\n\n     N = (int) Math.pow(2,Dim);\n     Log.v(\"N\", \"N \"+N);\n     for (L = 1; L < Dim; L++){\n      LE = (int) Math.pow(2,Dim+1-L);\n      LE1 = LE/2;\n      U1 = (double)1.0;\n      U2 = (double)0.0;\n      Arg = (double)Math.PI/LE1;\n      C = (double)Math.cos(Arg);\n      S = D*(double)Math.sin(Arg);\n      for(J = 1; J < LE1; J++){\n       I = J;\n       do{\n            IP = I+LE1;\n            T1 = x[I] + x[IP];\n            T2 = y[I] + y[IP];\n            T3 = x[I] - x[IP];\n            T4 = y[I] - y[IP];\n            x[IP] = T3*U1 - T4*U2;\n            y[IP] = T4*U1 + T3*U2;\n            x[I] = T1;\n            y[I] = T2;\n            I = I + LE;\n       }while(I <= N);\n       U3 = U1*C - U2*S;\n       U2 = U2*C - U1*S;\n       U1 = U3;\n      }\n\n     }\n\n     NV2 = N / 2;\n     Log.v(\"NV2\", \"NV2 \"+NV2);\n     NM1 = N-1;\n     Log.v(\"NM1\", \"NM1 \"+NM1);\n     J = 1;\n     for(I = 1; I < NM1; I++){\n      if (I < J){\n       T1 = x[J];\n       T2 = y[J];\n       x[J] = x[I];\n       y[J] = y[I];\n       x[I] = T1;\n       y[I] = T2;\n      }\n      K = NV2;\n      while (K < J){\n       J = J - K;\n       K = K / 2;\n      };\n\n      J = J + K;\n     }\n\n     for(I = 1; I < N; I++){\n      x[I] = x[I] / N*2;\n      y[I] = y[I] / N*2;\n\n     }\n        for(I = 1; I < N; I++){\n\n      xx[I] = x[I];\n      yy[I] = y[I];\n\n     }\n\n     xx[1] = (double)0.0;\n    }\n```\n\n\nReads the file successfully, but the processing procedure of the FFT is not working.\nHow to find the FFT procedure, or give the code to check the FFT result?\n    ", "Answer": "\r\nhere is some free library to do FFT in java.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Sine wave Generation in Flutter using FFT ( Fast Fourier Transform)\r\n                \r\nHello stackoverflow ive been trying to implement a Fast Fourire tranform for about a week now but i dont seem to get any clooser to my souloution and im pretty sure its not supposed to be this diffucult i just dont know what im doing wrong and any help would be greatly aprichiated.\nbasickly what im trying to do is to create a sine wave on 2 hertz and a samplerate of 100 over 1024 samples and doing an FFT of this just to check if my implementation of the FFT is working, but this is proving rather difficult.\n```\nimport 'dart:math';\nimport 'package:complex/complex.dart';\nimport 'dart:typed_data';\nimport 'package:fftea/fftea.dart';\n\nvoid calculatefft() {\nfinal signal = generateMockSignal();\nfinal fft = performFFT(signal);\nconst sampleRate = 100.0; // Sampling rate in Hz\n\nprint(\"Input signal: $signal\");\n\n\n// Calculate the frequency resolution in Hz\nfinal freqResolution = sampleRate / (fft.length - 1);\n\n// Calculate the frequency values of the FFT bins in Hz\nfinal freqValues = List.generate(fft.length, (i) => i * freqResolution);\n\n\nprint(\"FFT Amplitude Spectrum: ${fft.map((c) => 'Re=${c.real.toStringAsFixed(2)},     \nIm=${c.imaginary.toStringAsFixed(2)}, Mag=${c.abs().toStringAsFixed(2)}').toList().join(',     \n')}\");\n\n\n\n}\n\nList<Complex> generateMockSignal() {\n  const int sampleRate = 100; // Sample rate (in samples per second)\nconst double duration = 10; // Duration of the signal (in seconds)\nconst double frequency = 2; // Frequency of the signal (in Hz)\nconst double amplitude = 5; // Amplitude of the signal\nconst int desiredNumSamples = 1024; // Desired number of samples\n\n// Find the nearest power of two greater than or equal to the desired number of samples\nfinal int numSamples = pow(2, (log(desiredNumSamples) / log(2)).ceil()).toInt();\n\nfinal List<Complex> signal = List.generate(numSamples, (i) {\n  final double t = i.toDouble() / sampleRate; // Time for each sample\n  return Complex(amplitude * sin(2 * pi * frequency * t), 0);\n});\n\nreturn signal;\n}\n\n\nList <Complex> performFFT(List<Complex> signal) {\nvar nSamplesLog2 =\n  log(signal.length.toDouble()) / log(2).toDouble();\nif ((nSamplesLog2 - nSamplesLog2.floor()) != .0) {\n  throw ArgumentError(\n      \"The number of samples must be a power of two.\");\n}\nvar output = Float64List(signal.length * 2);\nfor(var i=0;i<signal.length;i++) {\n  output[i*2]=signal[i].real;\n  output[i*2+1]=signal[i].imaginary;\n}\nvar fftTransformer = FFT(nSamplesLog2.toInt());\nfftTransformer.realFft(output);\nvar result=<Complex>[];\nfor(var i=0;i<signal.length;i++) {\n  result.add(Complex(output[i*2],output[i*2+1]));\n}\nreturn result;\n}\n\n\n//Another way i have made my code is a bit more simple with the sample libraries but the signal \n//generation and perform FFT is different \n\nList<double> generateMockSignal() {\n// Generate a 10-second sinusoidal signal with a frequency of 1Hz sampled at 100Hz.\nconst int sampleRate = 100;\nconst double duration = 10; // IN SEC\nconst double frequency = 1;\nconst signalAmplitude = 5;\nfinal int numSamples = (sampleRate * duration).round();\nfinal List<double> signal = List.generate(\n  numSamples, (i) => sin( signalAmplitude * pi * frequency * i / sampleRate),\n);\n\nreturn signal;\n\n\n}\n\nList<Complex> performFFT(List<double> signal) {\nfinal fft = FFT(signal.length);\nfinal freq = fft.realFft(signal);\nfinal complexFreq = freq.map((f) => Complex(f.x, 0)).toList();\n\nreturn complexFreq;\n}\n```\n\nit feels like im going in circkles and have tried it all i hope some of you will be able to help thank you so much in advance\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to properly scale frequency axis in Fast Fourier Transform?\r\n                \r\nI am trying some sample code taking the FFT of a simple sinusoidal function. Below is the code\n\n```\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nN = 1024\nlimit = 10\nx = np.linspace(-limit, limit, N)\ndx = x[1] - x[0]\ny = np.sin(2 * np.pi * 5 * x) + np.sin(2 * np.pi * x)\nY = np.abs(np.fft.fft(y) ** 2)\nz = fft.fftshift(np.fft.fftfreq(N, dx))\nplt.plot(z[int(N/2):], Y[int(N/2):])\nplt.show()\n```\n\n\nFrom the function that is given, , it is clear there should be two spikes at frequencies 1 and 5. However, when I run this code, I get the following plot.\n\n             \n             \n             \n\nClearly the spikes are not where they should be. Additionally, I have noticed that the frequency scaling is sensitive to the number of points ```\nN```\n as well as the interval limits that I make ```\nlimit```\n. As an example, setting ```\nN = 2048```\n gives the following plot.\n\n             \n             \n             \n\nAs you can see, the locations of the spikes have changed. Now keeping ```\nN = 1024```\n and setting ```\nlimit = 100```\n also changes the result.\n\n             \n             \n             \n\nHow can I make it so the frequency axis is properly scaled at all times?\n    ", "Answer": "\r\n```\nfftfreq```\n returns the frequency range in the following order: the positive frequencies from lowest to highest, then the negative frequencies in reverse order of absolute value. (You usually only want to plot one half, as you do in your code.) Note how the function actually needs to know very little about the data: just the number of samples and their spacing in the time domain.\n```\nfft```\n performs the actual (Fast) Fourier transformation. It makes the same assumption about the input sampling, that it's equidistant, and outputs the Fourier components in the same order as ```\nfftfreq```\n. It doesn't care about the actual frequency values: the sampling interval is not passed in as a parameter.\nIt does however accept complex numbers as input. In practice, this is rare. Input is usually samples of real numbers, as in the above example. In that case, the Fourier transform has a special property: it's symmetric in the frequency domain, i.e. has the same value for ```\nf```\n and ```\n−f```\n. For that reason, it often doesn't make sense to plot both halves of the spectrum, as they contain the same information.\nThere is one frequency that stands out: ```\nf = 0```\n. It's a measure of the average value of the signal, its offset from zero. In the spectrum returned by ```\nfft```\n and the frequency range from ```\nfftfreq```\n, it's at the very first array index. If plotting both halves, it may make sense to shift the frequency spectrum around, so that the negative half is to the left of the zero-component, the positive half to its right, meaning all values are in ascending order and ready to be plotted.\n```\nfftshift```\n does exactly that. However, if you plot only half of the spectrum anyway, then you may as well not bother doing this at all. Though if you do, you must shift both arrays: the frequencies and the Fourier components. In your code, you only shifted the frequencies. That's how the peaks ended up on the wrong side of the spectrum: You plotted the Fourier components referring to the positive half of the frequencies with respect to the negative half, so the peaks on the right are actually meant to be close to zero, not at the far end.\nYou don't really need to rely on any of those functions operating on the frequencies. It is straightforward to generate their range based on the documentation of ```\nfftfreq```\n alone:\n```\nfrom numpy.fft import fft\nfrom numpy import arange, linspace, sin, pi as π\nfrom matplotlib import pyplot\n\ndef FFT(t, y):\n    n = len(t)\n    Δ = (max(t) - min(t)) / (n-1)\n    k = int(n/2)\n    f = arange(k) / (n*Δ)\n    Y = abs(fft(y))[:k]\n    return (f, Y)\n\nt = linspace(-10, +10, num=1024)\ny = sin(2*π * 5*t) + sin(2*π * t)\n(f, Y) = FFT(t, y)\npyplot.plot(f, Y)\npyplot.show()\n```\n\nNote that NumPy also offers dedicated functions, ```\nrfft```\n and ```\nrfftfreq```\n, for the common use case of real-valued data.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transform (fft) aggregation on Spark Dataframe groupby\r\n                \r\nI am trying to get the fft over a window using numpy fft with spark dataframe like this:\n```\nimport numpy as np\n\ndf_grouped = df.groupBy(\n    \"id\",\n    \"type\",\n    \"mode\",\n    func.window(\"timestamp\", \"10 seconds\", \"5 seconds\"),\n).agg(\n    percentile_approx(\"value\", 0.25).alias(\"quantile_1(value)\"),\n    percentile_approx(\"magnitude\", 0.25).alias(\"quantile_1(magnitude)\"),\n    percentile_approx(\"value\", 0.5).alias(\"quantile_2(value)\"),\n    percentile_approx(\"magnitude\", 0.5).alias(\"quantile_2(magnitude)\"),\n    percentile_approx(\"value\", 0.75).alias(\"quantile_3(value)\"),\n    percentile_approx(\"magnitude\", 0.75).alias(\"quantile_3(magnitude)\"),\n    avg(\"value\"),\n    avg(\"magnitude\"),\n    min(\"value\"),\n    min(\"magnitude\"),\n    max(\"value\"),\n    max(\"magnitude\"),\n    kurtosis(\"value\"),\n    kurtosis(\"magnitude\"),\n    var_samp(\"value\"),\n    var_samp(\"magnitude\"),\n    stddev_samp(\"value\"),\n    stddev_samp(\"magnitude\"),\n    np.fft.fft(\"value\"),\n    np.fft.fft(\"magnitude\"),\n    np.fft.rfft(\"value\"),\n    np.fft.rfft(\"magnitude\"),\n)\n```\n\nEvery aggregation function works fine, however for the fft I get:\n```\ntuple index out of range\n```\n\nand I don't understand why. Do I need to do anything particular to the values in order for numpy fft to work? The values are all floats. When I ```\nprint```\n the column it looks like this:\n```\n[Row(value_0=6.247499942779541), Row(value_0=63.0), Row(value_0=54.54375076293945), Row(value_0=0.7088077664375305), Row(value_0=51.431251525878906), Row(value_0=0.09377499669790268), Row(value_0=0.09707500040531158), Row(value_0=6.308750152587891), Row(value_0=8.503950119018555), Row(value_0=295.8463134765625), Row(value_0=7.938048839569092), Row(value_0=8.503950119018555), Row(value_0=0.7090428471565247), Row(value_0=0.7169944643974304), Row(value_0=0.5659012794494629)]\n```\n\nI am guessing the spark row might be an issue, but I am unsure of how to convert it in this context.\n    ", "Answer": "\r\n```\nnp.fft.fft```\n is a numpy function, not a pyspark function. Therefore, you cannot apply it directly to a dataframe.\nMoreover, it takes as entry an array. ```\n\"value\"```\n is a string. The function ```\nfft```\n cannot infer that as being the aggregated list of the values of the column ```\n\"value\"```\n. You have to do it manually.\n```\nfrom pyspark.sql import functions as F, types as T\n\ndf_grouped = df.groupBy(\n    \"id\",\n    \"type\",\n    \"mode\",\n    func.window(\"timestamp\", \"10 seconds\", \"5 seconds\"),\n).agg(\n    F.percentile_approx(\"value\", 0.25).alias(\"quantile_1(value)\"),\n    ...,\n    F.stddev_samp(\"magnitude\"), # I replace the np.fft.fft with a collect_list\n    F.collect_list(\"value\").alias(\"values\"),\n    F.collect_list(\"magnitude\").alias(\"magnitudes\"),\n)\n\n\n#  Definition of the UDF fft. Do the same for rfft\n@F.udf(T.ArrayType(T.FloatType()))\ndef fft_udf(array):\n    return [float(x) for x in np.fft.fft(array)]\n\n# Do that for all your columns.\ndf_grouped.withColumn(\"ftt_values\", fft_udf(F.col(\"values\")))\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How plot the Riemann zeta zero spectrum with the Fourier transform in Mathematica?\r\n                \r\nIn the paper \"The Riemann Hypothesis\" by J. Brian Conrey in figure 6 there is a plot of the Fourier transform of the error term in the prime number theorem. See the plot to the left in the image below:\n\n\n\nIn a blog post called Primes out of Thin Air written by Chris King there is a Matlab program that plots the spectrum. See the plot to the right at the beginning of the post. A translation into Mathematica is possible:\n\nMathematica:\n\n```\n scale = 10^6;\n start = 1;\n fin = 50;\n its = 490;\n xres = 600;\n y = N[Accumulate[Table[MangoldtLambda[i], {i, 1, scale}]], 10];\n x = scale;\n a = 1;\n myspan = 800;\n xres = 4000;\n xx = N[Range[a, myspan, (myspan - a)/(xres - 1)]];\n stpval = 10^4;\n F = Range[1, xres]*0;\n\nFor[t = 1, t <= xres, t++,\n For[yy=0, yy<=Log[x], yy+=1/stpval,\n F[[t]] =\n F[[t]] +\n Sin[t*myspan/xres*yy]*(y[[Floor[Exp[yy]]]] - Exp[yy])/Exp[yy/2];\n ]\n ]\n F = F/Log[x];\n ListLinePlot[F]\n```\n\n\nHowever, this is as I understand it the matrix formulation of the Fourier sine transform and it is therefore very costly to compute. I do NOT recommend running it because it already crashed my computer once.\n\nIs there a way in Mathematica utilising the Fast Fourier Transform, to plot the spectrum with spikes at x-values equal to imaginary part of Riemann zeta zeros?\n\nI have tried the commands ```\nFourierDST```\n and ```\nFourier```\n without success. The problem seems to be that the variable ```\nyy```\n in the code is included in both ```\nSin[t*myspan/xres*yy]```\n and ```\n(y[[Floor[Exp[yy]]]] - Exp[yy])/Exp[yy/2]```\n.\n\nEDIT: 20.1.2012, I changed the line:\n\n```\nFor[yy = 0, yy <= Log[x], 1/stpval++,```\n\n\ninto the following:\n\n```\nFor[yy = 0, yy/stpval <= Log[x], yy++,```\n\n\nEDIT: 22.1.2012, From Heike's comment, changed:\n\n```\nFor[yy = 0, yy/stpval <= Log[x], yy++,```\n\n\ninto:\n\n```\nFor[yy=0, yy<=Log[x], yy+=1/stpval,```\n\n    ", "Answer": "\r\nWhat about this? I've rewritten the sine transform slightly using the identity ```\nExp[a Log[x]]==x^a```\n\n\n```\nClear[f]\nscale = 1000000;\nf = ConstantArray[0, scale];\nf[[1]] = N@MangoldtLambda[1];\nMonitor[Do[f[[i]] = N@MangoldtLambda[i] + f[[i - 1]], {i, 2, scale}], i]\n\nxres = .002;\nxlist = Exp[Range[0, Log[scale], xres]];\ntmax = 60;\ntres = .015;\nMonitor[errList = Table[(xlist^(-1/2 + I t).(f[[Floor[xlist]]] - xlist)), \n  {t, Range[0, 60, tres]}];, t]\n\nListLinePlot[Im[errList]/Length[xlist], DataRange -> {0, 60}, \n  PlotRange -> {-.09, .02}, Frame -> True, Axes -> False]\n```\n\n\nwhich produces \n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Guitar Chord Recognition Algorithm?\r\n                \r\nWhats a good digital signal processing algorithm that is good on guitar chords? Since Fast Fourier Transform I think only is accurate on single notes played on the guitar but not notes that are played simultaenously (i.e. chords).\n\nThanks!\n    ", "Answer": "\r\nThe short answer is that you need much more than one algorithm. Good chord recognition methods could more aptly be described as \"systems\", but usually they are indeed based on an initial transform to the frequency domain (most often DFT).\n\nIf you want a chord representaton of the song similar to this\n\n```\nC G Am F7 F6 C ...\n```\n\n\nthen this is actually a problem that is slightly removed from recognising the notes in a piece of audio. In fact, there are two problems (roughly speaking):\n\n\nfinding which pitches are present at any time\ngrouping these pitches over time so as to be able to assign a chord label to a time interval.\n\n\nIt turns out that the way you transform from the time domain (normal audio) to the frequency domain (spectral representation) is only of limited importance. It's very important what you do afterwards, and often sophisticated probabilistic models (similar to those in speech recognition: HMMs, DBNs, ...) are used to tackle this problem.\n\nTry google scholar \"chord transcription\", or \"chord detection\", or \"chord labelling\" for advanced research in this area.\n\nMost of these approaches use a discrete Fourier transform (DFT) to create the initial spectrogram. During further processing, too, they tend to differ only slightly, though different time-series smoothing techniques have been used: hidden Markov models, dynamic Bayesian networks, support vector machines (SVMstruct), and conditional random fields -- among others. \nThe most advanced transcribers use automatic tuning, key information, bass note information, and information of the metric position to improve the results. My thesis (Chapter 2) gives a nice overview.\n\nOpen source chord detection algorithms:\n\n\nChordino at http://isophonics.net/nnls-chroma\nChordata at http://clam-project.org/\nLabROSA Chord Recognition http://labrosa.ee.columbia.edu/projects/chords/\n\n\nHope this helps.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Numpy FFT (Fast Fourier Transformation) of 1-dimensional array\r\n                \r\nI have a simple one-dimensional array like ```\n[0,0,0,0,0,1,1,1,1,1,0,0,0,0,0]```\n which describes a square impulse. I would like to transform this impulse to the frequency domain and plot its magnitude spectrum by using the code below (I got it from OpenCV Python Tutorials):\n\n```\nsquareimpulse = np.array([0,0,0,0,0,1,1,1,1,1,0,0,0,0,0])\n\nimg = (squareimpulse)\nf = np.fft.fft(img)\nfshift = np.fft.fftshift(f)\nmagnitude_spectrum = 20*np.log(np.abs(fshift))\n\nplt.subplot(121),plt.imshow(img, cmap = 'gray')\nplt.title('Input Image'), plt.xticks([]), plt.yticks([])\nplt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\nplt.show()\n```\n\n\nThe script works fine for two-dimensional arrays with ```\nf = np.fft.fft2(img)```\n but not for my case where I only got one dimension.\n\nHope we can figure this out.\n    ", "Answer": "\r\n```\nplt.magnitude_spectrum(img)\nplt.show()\n```\n\n\nWell, seriously, the ```\nimshow```\n function doesn't accept just a list of values. See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.imshow\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Python - Fourier transform wrong frequency\r\n                \r\nI am trying to find the frequency of an array of numbers taken from a wav file using Fast Fourier Transform and numpy, however I am receiving an output of the wrong frequency.\n\nHere is my code:\n\n```\nfrom pydub import AudioSegment\nimport numpy as np\n\nnp.set_printoptions(threshold=np.inf)\n\nsound = AudioSegment.from_mp3(\"500Hz.wav\")\n\nraw_data = sound.raw_data\nraw_data = np.fromstring(raw_data, dtype=np.int16)\n\nprint(raw_data[:2000:21])\n\nwave = raw_data \nfft = np.fft.rfft(wave)\nfft = np.abs(fft)\n\nprint(max(list(fft)))\nprint(list(fft).index(max(list(fft))))\n\nfft = np.array([int(i) for i in fft])\n```\n\n\nThe 500Hz.wav file is a 500Hz audio wave for 3 seconds created using Audacity. \n\nThe code returns the following:\n\n```\n[     0  26138   3906 -25559  -7727  24402  11370 -22702 -14767  20496\n  17830 -17830 -20498  14763  22701 -11374 -24400   7728  25557  -3907\n -26140      0  26141   3905 -25555  -7728  24404  11373 -22704 -14767\n  20496  17831 -17829 -20493  14765  22698 -11375 -24404   7725  25553\n  -3906 -26138     -1  26141   3907 -25559  -7726  24402  11375 -22702\n -14765  20497  17830 -17831 -20498  14762  22700 -11374 -24401   7726\n  25557  -3906 -26141      2  26139   3912 -25556  -7728  24401  11376\n -22702 -14767  20499  17830 -17830 -20496  14766  22704 -11372 -24405\n   7725  25559  -3906 -26141     -1  26139   3906 -25556  -7725  24404\n  11373 -22702 -14769  20495  17831 -17832]\n2046217405.9084692\n1770\n```\n\n\nThis shows that the peak is at 1770Hz and not at 500Hz and I am unsure what is causing this.\nIf I am missing any information, please let me know so I can add it to the question!\n\nEdit: The file is available at https://ufile.io/nk7j9\n    ", "Answer": "\r\nThe frequency corresponding to the index 1770 depends on the duration of the frame. For instance, if the frame lasts ```\n3```\n seconds, the frequency of index ```\ni```\n is ```\ni/3```\n Hz. The zero-frequency corresponds to the average, or DC component of the signal: it is presently null. It the index 1770 corresponds to 500Hz, the duration of the frame is likely about 3.22 seconds. Since the file is read using pydub, this duration can be retreived in miliseconds using ```\nlen(sound)```\n\n\nEven if the signal is a sine wave, the peak of the discrete Fourier transform (DFT) may span over multiple frequencies. It occurs whenever the length of the frame is not a multiple of the period of the sine wave and it is called spectral leakage. It can be tempered by applying a window before the DFT. \n\nFinally, the period of the sine wave used as input is likely different from the dicrete frequencies of the DFT. Hence, estimating the frequency of the sine wave using the index of the highest amplitude can be slightly erroneous. To correct that, the actual freqency of a peak of DFT amplitude can be estimated as its mean frequency wih respect to power density See Why are frequency values rounded in signal using FFT?\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to Fourier transform an Interferogramm to an IR Spectrum using R?\r\n                \r\nHello people of the Internet, I have an Interferogramm (time domain) and want to to Fourier transform it into a IR Spectrum (frequency domain) to obtain the peaks of the functional groups in the molecule. FTIR (Fourier Transformation Infrared Spectroscopy) is a advanced method to determine functional groups in a molecule. The so-called interferometer is build like this:\n\n\n\nAn interferogram plots the signal intensity in Volt vs. the mirror position in nanometers, as in this script:\n\n```\npar(family=\"mono\", font.axis=1)\ndata <- read.table(\"D13-4-aminobenzoic_acid_interferogram.asc\")\nx <- data[,1]\ny <- data[,2]\n\nplot(x,y, \n     type=\"l\", \n     xlab=\"Mirror position [mm]\", \n     ylab=\"Signal intensity [V]\",\n     axes=F,\n     )\naxis(1)\naxis(2)\n```\n\n\nHere is the Link to the ```\n.asc```\n file with the measured data. After the Fourier Transformation the spectrum should look like this:\n\n\n\nMy question is: How do I make a fast discrete Fourier transformation in R using ```\nfft()```\n from the Interferogram to the IR spectrum? Is the reverse transformation from the spectrum to the Interferogram possible in R and if yes how is it done.\nCheers, \nKris\n    ", "Answer": "\r\nTry this solution:\n\n```\nd <- read.table('D13-4-aminobenzoic_acid_interferogram.asc')\nf <- fft(d[,2])\n# do fft(f,inverse=T) to get the unnormalized inverse\n\nf2 <- sqrt(Re(f)^2 + Im(f)^2)\n\nc <- 2.9979e8 # speed of light\nlambda.laser <- 632.8e-9 # (nm) HeNe\nnu.Nyquist <- 1e-2/lambda.laser # upper limit of the wavenumber\ndelta.nu <- nu.Nyquist/nrow(d) # wavenumber spacing\n\ni.nu <- 1:floor(length(f2)/2) # show plot up to the Nyquist limit\nplot((i.nu-1)*delta.nu,f2[i.nu],type='l')\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to convert from Inverse Fast Fourier Transform to .wav?\r\n                \r\nI used made a fft to make a band pass filter.\nAfter that I made the ifft to inverse it and pass it to time domain.\n\nMy ifft has the same length of the fft.\n\nThe ifft must be longer or is there a way to make it longer?\nHow do I pass this ifft to .wav?\n    ", "Answer": "\r\nThe WAV file format is documented pretty well (see below). It's basically some header information followed by the raw sample data. \n\nfirst result with Google:\nhttps://ccrma.stanford.edu/courses/422/projects/WaveFormat/\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "C# library to do fft and ifft? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nis there a free c# library to do the fast fourier transform and its inverse?\n    ", "Answer": "\r\nBoth Math.NET and Aforce are based on the Exocortex.DSP library.  http://www.exocortex.org/dsp\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why does python use Karatsuba algorithm for its multiplication? Isn't FFT faster? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWill there be some issues using multiplication with FFT(fast fourier transform)? I am curious. Thanks.\n    ", "Answer": "\r\nI assume by \"FFT\" you're referring to something like Schönhage–Strassen. The answer is likely that this algorithm, while asymptotically faster than Karatsuba, is more complicated and only achieves this advantage on very large numbers due to larger constant factors (Wikipedia quotes multiple sources that cut over to this algorithm only when the multiplicands have tens of thousands of digits).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "fft (fast Fourier transform) to speed up opencv in python?\r\n                \r\ni have a raspberry pi with opencv and python installed. I want is to do a simple frontal face haarcascade using opencv. It works however i only have about 2 fps. So i searched through the internet and found this: ```\nhttps://www.raspberrypi.org/blog/accelerating-fourier-transforms-using-the-gpu/```\n\n\nI think it's quiet interesting, but how do i implement it into python?\n\nCan you help me?\n    ", "Answer": "\r\nYou can highly improve the performance of the classification when you specify the parameters correctly.\nJust set the min,max frame size to reasonable values and maybe set a scale factor.\n\nFor the fft there are already some python packages available for that.\nI would not recommend to write your own fft function, since the library functions a mostly optimized and you will unlikely be able to write a faster version yourself.\nThere is another issue posted for that topic:\nhttps://github.com/numpy/numpy/issues/5348\n\nThey linked a github repo for this as well:\nhttps://github.com/raspberrypi/userland/tree/master/host_applications/linux/apps/hello_pi/hello_fft\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "2-Dimensional Fast Fourier Transform 3-D plot in Matlab\r\n                \r\nWe want to plot in Matlab using mesh function the FFT2 of an image (we have applied ```\nfftshift```\n, ```\nabs```\n, and ```\nlog```\n).\n\nSo how do we do that?\n\n```\nimageB=imread('pic2', 'jpg');\n\nfigure, imshow(imageB)\n\nfftB=fft2(double(imageB));\n\nF1=fftshift(fftB);\n\nF2=abs(F1);\n\nF3=log(F2+1);\n\nmesh(F3)\n```\n\n\nWe want a 3-D plot of the FFT.\n    ", "Answer": "\r\nAn option using ```\nsurf```\n:\n\n```\nimageB=rgb2gray(imread('http://upload.wikimedia.org/wikipedia/commons/d/db/Patern_test.jpg'));\n```\n\n\nNote that the original image is a RGB image, thus the FFT will also be a 3-channel array. Either convert to grayscale or access one channel with ```\nF1(:,:,1)```\n\n\n```\nfftB=fft2(double(imageB));\nF1=log(abs(fftshift(fftB)));\n\nsurf(F1), shading flat;\n```\n\n\nResult:\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier Transform and Fourier Descriptors to extract shapes features on Java\r\n                \r\nI am trying to build a simple system to recognize simple shapes using Fourier descriptors: \nI am using this implementation of Fast fourier transform on my program: (link below) \nhttp://www.wikijava.org/wiki/The_Fast_Fourier_Transform_in_Java_%28part_1%29\n\n```\nfft(double[] inputReal, double[] inputImag, boolean direction)\n```\n\n\ninputs are: real and imag part (which are essentially x,y coordinates of boundary parameter I have)\nand outputs are the transformed real and imag numbers.\n\nquestion: How can i use the output (transformed real,imag ) as a invariant descriptors of my simple shapes? \n\nThis was what I thought : \n\n\ncalculate ```\nR = sqrt( real^2 + imag^2 )```\n for each N steps.  \ndivide each ```\nR```\n by ```\nR[1]```\n = the normalization factor to make it invariant. \n\n\nThe problem is I get very different R values for slightly different images (such as slight rotations applied, etc) \n\nIn other words : \nMy descriptors are not invariant... I think I am doing something wrong with getting the R value.\n    ", "Answer": "\r\nThere is some theory you need to know first about Fourier Descriptors: it's an extremely interesting technique, but should be devised correctly. What you want is invariance; invariance for rotation, translation, maybe even affine transforms. To allow good comparison with other sets of Fourier descriptors you should take following things in consideration:\n\n\nif you want invariance to translation, do not use the DC-term, that is the first element in your resulting array of Fourier coefficients\nif you want invariance to scaling, make the comparison ratio-like, for example by dividing every Fourier coefficient by the DC-coefficient. f*[1] = f[1]/f[0], f*[2]/f[0], and so on.\nif you want invariance to the start point of your contour, only use absolute values of the resulting Fourier coefficients.\nOnly the first 5 to 8 Fourier coefficients are useful when comparing the coefficients of two different objects; higher coefficients only go into the details of your contour which mostly isn't very useful information. (it's the global form that matters)\nLet's say you have 2 objects, and their Fourier descriptors. The resulting array of Fourier coefficients can be of a different size, meaning that the 'frequency interval' of the resulting frequency content is different for both shapes. You can't compare apples with pears. Zero-pad your shortest contour to match the size of the longest contour, and then calculate the Fourier descriptors. Now you have analogy between coefficients and a good comparison.\n\n\nHope this helps. Btw, user-made FFT solutions are not to be trusted in my opinion. Go for the solutions libraries reach out. If working with images, OpenCV provides Fourier transform utilities.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Why is Matlab Function fft() not working for certain equations\r\n                \r\nI am trying to get the Fourier transform of a sinc function but I don't know why ```\nfft()```\n (fast Fourier transform) is not working as it works for a basic sine function.\nHere is my code, the plot produced is empty:\n```\nfunction fourier_transform\n\nTs= 1/50000;\nt = 0:Ts:.5-Ts;\n% p = sin(40*t);\nm = sin(100*t)./(100*t);\n\nf = fft(m);\nplot(t,abs(f));\n\nend \n```\n\n    ", "Answer": "\r\n```\nm(1)```\n is computed by ```\nsin(0)/0```\n, which equals ```\nNaN```\n.\n```\nNaN```\n means \"Not a Number\", and indicates an error situation. Any computation you do with ```\nNaN```\n will propagate that ```\nNaN```\n, to warn you that there was an error somewhere along the way when computing. For example, ```\nsum(m)```\n equals ```\nNaN```\n. Since each output element of the FFT involves computations with each input of ```\nm```\n, all of those output elements will be ```\nNaN```\n as well.\nYour ```\nf```\n is all ```\nNaN```\n, and ```\nplot```\n will just skip the ```\nNaN```\n points, and so produces no output.\nYou can fix your computation in one of two ways:\n\nAvoid the division by zero by dividing by ```\n100*t + 1e-9```\n, the very small value added will prevent a zero but otherwise not affect other results.\n```\n m = sin(100*t)./(100*t + 1e-9);\n```\n\n\nKnow that ```\nm(1)```\n involves a division by zero and fix it.\n```\n m = sin(100*t)./(100*t);\n m(1) = 1;\n```\n\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "C++ FFTW (fast fourier transforms) with complex numbers\r\n                \r\nI am trying to use FFT with complex numbers in C++. The problem is that I cannot make inner products, or sums of complex vectors with a common sintax, when using fftw_complex numbers.\n\nHere is a reduced simple program:\n\n```\n#include <complex.h>\n#include <fftw3.h>\n\n\nint main(void){\n\nint n=1024;\n    fftw_complex *in, *out;\n    fftw_plan p;\n\n    in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * n);\n    out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * n);\n//  out = 1*in;   /!\\\n//  out = in+0;  / ! \\\n\n    p = fftw_plan_dft_1d(n, in, out, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    fftw_execute(p); /* repeat as needed */\n\n    fftw_destroy_plan(p);\n    fftw_free(in); fftw_free(out);\n\n    return 0;\n}\n```\n\n\nThe two lines that are commented do not work:\n\ni) the 1st one gives, when compiling:\n\n```\ntest.cpp:13:10: error: invalid operands of types ‘int’ and ‘fftw_complex* {aka __complex__ double*}’ to binary ‘operator*’\n```\n\n\nii) the 2nd one gives, during the execution:\n\n```\n*** glibc detected *** ./prog: corrupted double-linked list: 0x09350030 ***\n```\n\n\nAccordingly to the documentation of fftw.org [link], standard sintax for manipulating fftw_complex should be accepted. Why not with vectors of fftw_complex?\n\nFor instance, I want to compute:\n\n```\nr = i*gamma_p*w/w0*m*exp(-l*z);\n```\n\n\nwhere i is the imaginary number; gamma_p, w0, and z are real numbers; w, m, and l are vectors of complex numbers.\n\nI tried:\n\n```\n    fftw_complex* i_NUMBER = (fftw_complex*) fftw_malloc(1*sizeof(fftw_complex));\nmemset(i_NUMBER, 0, n*sizeof(fftw_complex));\n    i_NUMBER[0][0]=0;\n    i_NUMBER[0][1]=1;   //#real(i_NUMBER)=0; imag(i_NUMBER)=1; i.e. i_NUMBER=i;\nfftw_complex* r = (fftw_complex*) fftw_malloc(n*sizeof(fftw_complex));\n\nfor (int i=0; i<n; i++){\n    r[i] = i_NUMBER[0]*gamma_p*w[i]/w0*m[i]*pow(e_NUMBER, -l[i]*z);\n}\n```\n\n\nbut the compiler gives errors about the types of operands and operations.\n\n```\ngnlse.h:58:22: error: invalid operands of types ‘fftw_complex {aka double [2]}’ and ‘double’ to binary ‘operator*’\ngnlse.h:58:61: error: wrong type argument to unary minus\n```\n\n\nAny help is welcome, thanks!\n    ", "Answer": "\r\nYou have to write explicit loops to works with vectors.\n\nLine ```\nout = in+0;```\n will produce two pointer pointing to the same location. When you deallocation it twice, you'll get corrupted heap\n\nUPDATE\n\nI think I know what problem might be. Default FFTW mode is C89. Automatic computations with complex numbers pretty much require either C99 mode or C++ using ```\n<complex>```\n header. I would guess you picked some example, modified it and wondering why it doesn't work.\n\nIn C89 mode fftw_complex is just a double[2]. So any expression in C89 mode requires pretty much manual handling of the real and imag part, just what I proposed. Cannot mix in expression coerced-to-pointer complex and doubles, functions and expect automatic handling.\n\nIn C99 mode you could get native complex which makes working with them in expression a real treat wrt C89.\n\nC++ native complex should work as well.\n\nSee http://www.fftw.org/doc/Complex-numbers.html for a detailed description.\n\nMy guess you're now effectively in C89 mode. You have to compile the example either with C99 (typically on linux /usr/bin/c99), or move to C++ and use C++ native complex along the line\n\n```\n#include <complex>\n\n...\n\nstd::complex<double>* in  = new std::complex<double>[n];\nstd::complex<double>* out = new std::complex<double>[n];\n...\np = fftw_plan_dft_1d(n,\n                     reinterpret_cast<fftw_complex*>(in),\n                     reinterpret_cast<fftw_complex*>(out),\n                     FFTW_FORWARD, FFTW_ESTIMATE);\n...\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "SciPy Fast Fourier Transform returning 0 Hz at infinite amplitude?\r\n                \r\nI've run thousands of signals through this function:\n```\ndef decompose_signal(x, time):\n    # Calculate the Fourier Transform\n    fft_vals = fft(x)\n    \n    # Calculate the frequencies corresponding to the Fourier Transform\n    n = len(x)\n    timestep = time[1] - time[0]\n    freq_resolution = 1 / (n * timestep)\n    frequencies = fftfreq(n, d=timestep)[:n//2]\n    \n    # Filter frequencies and FFT values to range from 0 to 3 Hz\n    mask = (frequencies >= 0) & (frequencies <= 3)\n    frequencies = frequencies[mask]\n    fft_vals = fft_vals[:n//2][mask]\n    \n    # Generate higher resolution frequencies\n    higher_resolution_frequencies = np.linspace(0, 3, 5000)\n    \n    # Interpolate the FFT values to match the higher resolution frequencies\n    interpolated_fft_vals = np.interp(higher_resolution_frequencies, frequencies, fft_vals)\n    \n    return higher_resolution_frequencies, np.abs(interpolated_fft_vals)**\n```\n\nFor many signals, this works just fine and the function returns the expected power spectrum. But for some, it assigns enormous power to 0 Hz and the power spectrum has a vertical asymptote on the left.\nThe signals are time series for variables in an oscillatory system. They are generate with Runge-Kutta integration (also from SciPy), and I've tried changing the integration method (RK23 vs RK45 vs DOP853 in ```\nscipy.solve_ivp```\n). This occasionally works, but rarely. Generally, if only one method removes the asymptote, it is RK23.\n\"Proper\" power spectrum:\n\nProblem power spectrum:\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fourier transformation Algorithms\r\n                \r\nPlease do bear with me if you find my query a little stupid. But I am currently doing a high school research project on how Fourier transformation can be used in recognizing human speech(similar to how Shazam works). But I need to  two different Fast Fourier Transformation algorithms for this project. One of the algorithms I am using would definitely be the Cooley-Tukey FTT algorithm. However, I am unsure of another FTT algorithm I should use. Thus, what would be a good algorithm to use and is there any pseudo code/source code for that particular algorithm? I was only able to find algorithms for Cooley-Tukey thus far.\n\nThanks!\n    ", "Answer": "\r\nIf you don't need speed (due to some performance constraints), then a DFT (straight matrix multiply) should produce very similar results (differing due to rounding noise) using a very different algorithm.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Shift in inverse Fourier Transform\r\n                \r\nI have written a little script (MATLAB) using fast Fourier transform  in order to filter messy time series. \n\nGiven a signal S(t) my function filter the n biggest amplitude components from the FFT transformation of S(t) and return's the filtered signal by inverse FFT.\n\nThe problem is that when I use a test signal the filtered signal is somehow shifted by approx. -1 in amplitude. I have tried to change the windowing but it doesn't appear to help (but the shift is moved toward +1). \n\nHere is a sample code of my script:\n\n```\n% test Signal\n\nt=0:0.1:1000;\nf1=1/50; f2=1/300; f3=1/20;\nSignal=100*sin(f1*2*pi*t)6x1+8*sin(f2*2*pi*t)+x3+x4+65*sin(f3*2*pi*t);\n\n[FiltredSignal]=Filter(data,5,0); % call Filter function\n\nfigure\nplot(t,real(a)*2,t,data) \n\nfigure\nplot(t,real(a)*2-data) % ???? shift of -1 in ifft ????\n\n\nfunction [FiltredSignal]=Filter(Signal,n)   \n% n= nbr of \"most significative spectra components\"\n\ntimelen=length(Signal);\n\nFT=fft(Signal); % fast fourrier transform\n\nFTcopy=FT/timelen; % Copy for spectral analysis\nFTcopy(floor(timelen/2+1):end)=[]; % cut at nyquist point\nFTcopy(1,1)=0; \n\n\n% sort FT2 in descending amplitude order\nsortedFT=sort(abs(FTcopy),'descend');\n\n% spectral selection --> n biggest amplitudes\nFiltredFT=zeros(1,timelen); \nfor i=1:n\n  freq=find(abs(FTcopy)==sortedFT(i));      \n  FiltredFT(freq)=FT(1,freq);\n  %FiltredFT(freq-1)=FT(1,freq-1); % windowing\n  %FiltredFT(freq+1)=FT(1,freq+1); % windowing\nend\n\nFiltredData=ifft(FiltredFT); % return filtred signal time serie\n\n% END\n```\n\n\nCould someone explain what is happening? \n\nI surely miss some theoretical facts of FFT (I am self learning so everything is not that clear).\n    ", "Answer": "\r\nHere is a revised version of the function above that is working, thanks to Paul R remarks.\n\n```\nfunction [FiltredSignal]=Filter(Signal,n)   \n\"% n= nbr of spectral components to keep \"\n\ntimelen=length(Signal);\n\nFT=fft(Signal); \"% fast fourrier transform\"\n\nFTcopy=FT/timelen; \"% Copy for spectral analysis\"\nFTcopy(floor(timelen/2+1):end)=[]; \"% cut at nyquist point\"\n\n\n\"% sort FT2 in descending amplitude order\"\nsortedFT=sort(abs(FTcopy),'descend');\n\n\"% spectral selection --> n biggest amplitudes\"\n\nFiltredFT=zeros(1,timelen); \n\nfor i=1:n\n  freq=find(abs(FTcopy)==sortedFT(i));      \n  FiltredFT(freq)=FT(1,freq);\nend\n\n\"% return filtred signal time serie with complex conjugate reconstruction\"\nFiltredData=ifft(FiltredFT,'symmetric'); \n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Can somebody explain how to model seasonality in timeseries, via Fast Fourier Transform, FFT?\r\n                \r\nA series, yt, can be decomposed and modeled thus:\n```\nyt = drift(or trend) + seasonality + noise```\n, which is in tandem with Parseval's theorem.\nOne of the techniques used to model a series's seasonality is the application of the FFT algorithm. I have read few texts about it(FFT) and I understand what it does but how do I incorporate it back into the model, before modeling for noise?\nI suppose FFT transforms a signal into a linear combination of sine and cosine functions of frequencies that makes up the signal. How then do I incorporate it back into the model? I have read few examples I haven't understood properly, or should I say my curiosity isn't satisfied yet.\nFor example, consider the series yt:\n```\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeature\nfrom sklearn.pipeline import Pipeline, FeatureUnion\nfrom sklearn.model_selection import train_test_split\n\n\n# data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)\n\n# estimators\nlinear_model = LinearRegression()\npoly_feat = PolynomialFeatures(degree=3)\n\n# modeling trend\npipe = Pipeline([ ('poly_trans', poly_feat), ('regressor', linear_model) ])\npipe.fit(X_train, y_train).score(X_test, y_test) # 0.76\n```\n\nNow suppose I am to model the seasonality in this series, where I get employ FFT, I think I would attempt to use a FeatureUnion to combine the trend and seasonal effect thus:\n```\nfrom scipy.fftpack import fft\n\npoly_fft_union = FeatureUnion([ ('poly_trans', poly_feat), ('fft', fft) ])\n```\n\nThis is where I am stuck. fft transformation returns complex numbers. I do not want to share more information because I don't want folks around to make assumptions that I know some aspects of this. Examples I have studied online either avoided using the fft or wrote a custom Estimator that applied the sin/cosine Fourier transformation formula directly.\nIf I weren't stuck, then I would model the trend and seasonality thus\n```\npipe = Pipeline([ ('union', poly_fft_union), ('regressor', linear_model)\npipe.fit(X_train, y_train)\n```\n\nI need to feed my curiosity here. Please, anyone?!\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "how to apply band pass filter using fast Fourier transform\r\n                \r\nI'm trying to make a band-pass filer using ftt in order to  build an audio  equalizer, I successfully  realize the low-pass and high-pass filter of a signal ```\ny```\n with sample rate ```\nsr```\n:\n```\ndef lowpass(y,sr):\n    S = librosa.stft(y)\n    f = np.arange(S.shape[0])\n    t = np.arange(S.shape[1])\n    A = np.exp(-t[None, :]*f[:, None]/(100*S.shape[1]))\n    SNew = S*A\n    p_bas= librosa.istft(SNew)\n```\n\n```\ndef higyhpass(y,sr):\n    S = librosa.stft(y)\n    f = np.arange(S.shape[0])\n    t = np.arange(S.shape[1])\n    A = np.exp(t[None, :]*f[:, None]/(100*S.shape[1]))\n    SNew = S*A\n    p_bas= librosa.istft(SNew)\n```\n\nI get stuck on how to implement the low-cut and high-cut  frequency using the same algorithm of low-pass and high-pass\n```\ndef band_pass(data, lowcut, highcut, fs, order=5):\n    nyq = 0.5 * fs\n    low = lowcut / nyq\n    high = highcut / nyq\n    b, a = butter(order, [low, high], btype='bandpass')\n    filtered = lfilter(b, a, data)\n    return filtered\n```\n\n    ", "Answer": "", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to use aubio framework in iOS?\r\n                \r\nI am trying to detect beat, pitch, onset, and fast Fourier Transform (FFT) of audio file in iOS and I found that aubio provides these features and iOS framework also available.\n\nSo far, I am using The Amazing Audio Engine to receive audio data in terms of ```\nCore Audio```\n's ```\nAudioBufferList```\n like this:\n\n```\nid<AEAudioReceiver> receiver = [AEBlockAudioReceiver audioReceiverWithBlock:\n                               ^(void                     *source,\n                                 const AudioTimeStamp     *time,\n                                 UInt32                    frames,\n                                 AudioBufferList          *audio) {\n    // I don't know how to use audio library.\n}];\n```\n\n\nCan I detect beat, pitch, onset, and fast Fourier Transform (FFT) using aubio from this ```\nAudioBufferList```\n and how?\nIf I am on the wrong track, please give me any suggestion?\n    ", "Answer": "\r\nLook at the aubio download page, I believe they've compiled it into framework for iOS and you can import to your Xcode directly.\n\nReference : http://aubio.org/download#ios\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to manage a 2D Fourier Transform(FFT) on a 3D numpy masked array?\r\n                \r\nI am having problems with doing 2D Fast Fourier Transforms on a 3D array. They are of a mathematical nature and of an 'understanding python/numpy' nature. \n\nEDIT: For clarification, the core questions are:\nHow does numpy.fft deal with masked arrays?\nCan I average over an axis and then do an fft and get the same result as doing an fft and then averaging over the axes that was not involved in the fft?\n\nThe array consists of a carbon dioxide flux value (in 'units') between the atmosphere and the ocean for each degree of latitude and longitude (in a certain domain). The shape of the array is (730, 50, 182) corresponding to (time, latitude, longitude). The land values are masked using:\n\n```\nimport numpy as np\nfrom numpy import ma\ncarbon_flux = ma.masked_values(carbon_flux, 1e+20)\n```\n\n\nI would like to show the log of the variance of the 2D Fourier Transform of carbon_flux averaged over longitude. I average the array over the last axis (longitude) and then do the Fourier Transform like this:\n\n```\nft_type_1 = np.log(np.abs(np.fft.fft2(ma.mean(cflux, 2)))\n```\n\n\nThis gives me an acceptable looking result. However, I was told to do the averaging first:\n\n```\nft_type_2 = np.log(np.mean(np.abs(np.fft.fft2(carbon_flux, axes=(0, 1))),axis=2)\n```\n\n\nThis results in the masked values being used to calculate the fft (I can tell by the first value of the fft being to the order of 10e19). \n\nFrom what I understand, the result of doing the averaging before the fft will differ to doing the averaging after the fft. Am I correct in the assumption or does it make no difference in what order I perform these functions?\n\nDoes the fft use the masked values? Can I avoid this?\n\nLastly, I have calculated the log of the 2D Fourier Transform of carbon_flux averaged over latitude. I fail to understand how to calculate the log of the VARIANCE of the 2D Fourier Transform averaged in latitude. Does the value of my resultant fft image simply need to be squared to become the variance? \n\nThis seems to have come across as a very complicated series of questions but any help in any department would be appreciated. Thank you.\n    ", "Answer": "\r\nAfter looking at the documentation briefly, I think ```\nnumpy.fft```\n may just ignore the mask. I would try using the ```\nma.filled()```\n function to put some other value in all the masked entries.\n\nSomething like this (taken from your example code):\n\n```\nft_type_1 = np.log(np.abs(np.fft.fft2(ma.mean(carbon_flux.filled(cflux_fill_value), 2)))\nft_type_2 = np.log(np.mean(np.abs(np.fft.fft2(carbon_flux.filled(cflux_fill_value), axes=(0, 1))),axis=2)\n```\n\n\nwhere ```\ncflux_fill_value```\n is some reasonable guess to substitute for the masked values. The fill value can also be set in another step (it is stored as part of a masked array) and then you could use ```\ncarbon_flux.filled()```\n without an argument.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Matlab FFT (Fast Fourier Transform) function of non log-base2 numbers\r\n                \r\nI have an app that I am developing that utalizes Apple's Accelerate Framework FFT function and I am trying to make it mimic the functionality of Matlab's FFT function.  I have my current code set up to output exactly the same way as I am doing so in matlab.  The only time that it doesn't output identically is when the number of elements in the data array are != a logarithm of base 2 (technically necessary for an FFT).  I was wondering if anyone knew how the Matlab Function handled this case.  If I do it using the apple code, it produces different results. \n\nNote:  I am not simply calling fft(x).  I also FFT shift and take the absolute value and square it.  I also mirror these in the apple code because they aren't directly affected by the FFT.  They are called after the fact.\n\nExample 1 - 16 Elements (Log base 2):  Similar Output\n\nMatlab Call: \n\n```\nx = 1:16;\nFxx = abs(fftshift(fft(x))).^2;\n\nFxx =\n\n  Columns 1 through 7\n\n64    66.5322    74.9807    92.5736    128    207.3490    437.0193\n\n Columns 8 through 14\n\n1681.5451    18496    1682.5451    437.0193    207.3490    128    92.5736\n\n  Columns 15 through 16\n\n74.9807    66.5322\n```\n\n\n*Apple code omitted due to length\n\nApple Output:\n\n```\nFxx[0] = 64.000000\nFxx[1] = 66.532232\nFxx[2] = 74.980664\nFxx[3] = 92.573612\nFxx[4] = 128.000000\nFxx[5] = 207.349044\nFxx[6] = 437.019336\nFxx[7] = 1681.545112\nFxx[8] = 18496.000000\nFxx[9] = 1681.545112\nFxx[10] = 437.019336\nFxx[11] = 207.349044\nFxx[12] = 128.000000\nFxx[13] = 92.573612\nFxx[14] = 74.980664\nFxx[15] = 66.532232\n```\n\n\nExample 2 - 10 Elements (NOT Log base 2): Different Output\n\nMatlab Call:\n\n```\nx = 1:10;\nFxx = abs(fftshift(fft(x))).^2;\n\nFxx = \n\nColumns 1 through 7\n\n25    27.6393    38.1966    72.3607    261.8034    3025    261.8034\n\nColumns 8 through 10\n\n72.3607    38.1966    27.6393\n```\n\n\n*Apple code omitted due to length\n\nApple Output:\n\n```\nFxx[0] = 16.000000\nFxx[1] = 45.250000\nFxx[2] = 18.745166\nFxx[3] = 32.000000\nFxx[4] = 109.254834\nFxx[5] = 1296.000000\nFxx[6] = 109.254834\nFxx[7] = 32.000000\nFxx[8] = 18.745166\nFxx[9] = 45.250000\n```\n\n\nAs you can see, they clearly produce the same output in the first example vs the second.  I have tested with both positive and negative inputs and the only time they are different is when they are NOT log base 2.  Does anyone know how Matlab handles this problem?  Perhaps it fills the array with 0's until its a log base 2 number and then do the average of certain points?  I have done lots of searching and cannot figure out what they do to obtain their output in this special case.  \n    ", "Answer": "\r\nFrom the official MATLAB documentation:\n\nThe FFT functions (fft, fft2, fftn, ifft, ifft2, ifftn) are based on a library called FFTW.\nTo compute an N-point DFT when N is composite (that is, when N = N1N2), the FFTW library decomposes the problem using the Cooley-Tukey algorithm, which first computes N1 transforms of size N2, and then computes N2 transforms of size N1.\nWhen N is a prime number, the FFTW library first decomposes an N-point problem into three (N – 1)-point problems using Rader's algorithm. It then uses the Cooley-Tukey decomposition described above to compute the (N – 1)-point DFTs.\n\n\nI'm not sure how Apple's Accelerate Framework computes such FFTs, but I'm favouring MATLAB here to produce correct results.\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Fast Fourier Transforms on existing dataframe is showing unexpexted results\r\n                \r\nI have a ```\n.csv```\n file with voltage data, when I plot the data with time I can see that it is a sinusoidal wave with ```\n60hz```\n frequency.\n\nNow when I try to perform ```\nfft```\n using the ```\nscipy/numpy fft```\n modules, I get a spike at near ```\n0```\n frequency while logically it should be at ```\n60```\n. (shown below)\n\nWhen I tried it with a sin wave created in python I get proper results but I'm not getting it with my actual data.\nI'm sharing my code below, please let me know if I am doing something wrong. Thanks in advance.\n```\nimport csv\nfrom matplotlib import pyplot as plt\nimport pandas as pd\nimport numpy as np\nfrom scipy.fftpack import fft\nfrom scipy.fftpack import fftfreq\n\ndf = pd.read_csv('Va_data.csv')\n\nprint(df.head())\n\nN = df.shape[0]\nfrequency = np.linspace(0.0,100, int(N/2))\nfreq_data = fft(df['Va'])\ny = (2/N)*np.abs(freq_data[0:np.int(N/2)])\n\nplt.plot(frequency, y)\nplt.title('Frequency Domain Signal')\nplt.xlabel('Frequency in Hz')\nplt.ylabel('Amplitude')\nplt.show()\n\n```\n\nVoltage data\n    ", "Answer": "\r\nData should be fine and FFT calculation (upto a constant) is fine too. It is about how the the results are plotted. To make the x-axis values represent the frequency information in terms of Hertz, you need\n```\nfrequency = np.arange(N) / N * sampling_rate\n```\n\nand then you can crop the half of it\n```\nfrequency = frequency[:N//2]\n```\n\nand give it to ```\nplt.plot(frequency, y)```\n. The equation for ```\nfrequency```\n above comes from the fact that each DFT coefficient ```\nX(k)```\n for ```\nk = 0, .., N-1```\n has a ```\nexp(-j 2pi kn/N)```\n in it where ```\nk/N```\n gives you the normalized frequency. Multiplying by sampling rate recovers the frequency corresponding to the continous domain.\nA sample:\n```\n# sample x data\nxs = np.linspace(0, 4, 1_000)\n\n# sampling rate in this case\nfs = 1 / np.diff(xs)[0]\n\n# sine of it\nys = np.sin(2 * np.pi * 60 * xs)\n\n# taking FFT\ndft = np.fft.fft(ys)\n\n# getting x-axis values to represent freq in Hz\nN = len(xs)\nx_as_freq = np.arange(N) / N * fs\n\n# now plotting it\nplt.plot(x_as_freq, np.abs(dft))\nplt.xlabel(\"Frequency (Hz)\")\nplt.ylabel(\"DFT magnitude\")\n\n# to see that peak is indeed at 60Hz\nplt.xticks(np.arange(0, 250, 20))\n```\n\nwhich gives\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "TypeError: src data type = 15 is not supported\r\n                \r\nI want to use Fast Fourier Transform but already trying a simple back and forth transformation doesn't work. The code is\n\n```\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('Picture.bmp',0)\nf = np.fft.fft2(img)\nfshift = np.fft.fftshift(f)\nf_ishift = np.fft.ifftshift(fshift)\nimg_back = cv2.idft(f_ishift)\nimg_back = cv2.magnitude(img_back[:,:,0],img_back[:,:,1])\n```\n\n\nand the error is\n\n```\nTraceback (most recent call last):\n  File \"test.py\", line 8, in <module>\n    img_back = cv2.idft(f_ishift)\nTypeError: src data type = 15 is not supported\n```\n\n\nHow can this be fixed?\n    ", "Answer": "\r\nI think I figured it out. cv2.idft() wants the complex numbers in a different format. I had to extract the real and imaginary part separately and write them in the third dimension:\n\n```\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('Bild.bmp',0)\nf = np.fft.fft2(img)\nfshift = np.fft.fftshift(f)\nf_ishift = np.fft.ifftshift(fshift)\nd_shift = np.array(np.dstack([f_ishift.real,f_ishift.imag]))\nimg_back = cv2.idft(d_shift)\nimg = cv2.magnitude(img_back[:,:,0],img_back[:,:,1])\n```\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "How to calculate 95% confidence level of Fourier transform in Python?\r\n                \r\nAfter calculating the Fast Fourier Transform (FFT) of a time series in Python/Scipy, I am trying to plot the 95% confidence level that for which the power spectrum is different from red or white noise, but haven't found a straightforward way to do so. I tried following this thread: Power spectrum in python - significance levels\nand wrote the following code to test for a sine function with random noise:\n```\nimport numpy as np\nfrom scipy.stats import chi2\nfrom scipy.fft import rfft, rfftfreq\n\nx=np.linspace(0,10,500)\n\ndata = np.sin(20*np.pi*x)+np.random.rand(500) - 0.5\n\nyf = rfft(data)\nxf = rfftfreq(len(data), 1) \nn=len(data)\n\nvar=np.var(data)\n\n### degrees of freedom\nM=n/2\nphi=(2*(n-1)-M/2.)/M       \n###values of chi-squared\nchi_val_99 = chi2.isf(q=0.01/2, df=phi) #/2 for two-sided test\nchi_val_95 = chi2.isf(q=0.05/2, df=phi)\n\n\n\n### normalization of power spectrum with 1/n\nplt.figure(figsize=(5,5))\nplt.plot(xf,np.abs(yf)/n, color='k')  \nplt.axhline(y=(var/n)*(chi_val_95/phi),color='r',linestyle='--') \n```\n\nBut the resulting line lies below all of the power spectrum, as in Fig. 1. What am I doing wrong? Is there another way to get the significance of the FFT power spectrum ?\n\n    ", "Answer": "\r\nBackground considerations\nI did not read the entire references included in the answer you linked to (and in particular Pankofsky et. al.), but couldn't find an explicit derivation of the formula and exactly under which conditions the results applied. On the other hand I've found a few other references where a derivation could more readily be confirmed.\nBased on the answer to this question on dsp.stackexchange.com, if you only had white gaussian noise with unit variance, the squared-amplitude of each Fourier coefficients would have Chi-squared distribution with degree of freedom asymptotically 2 (sum of 2 Gaussians, one for each of the real and imaginary parts of the complex Fourier coefficient, when ```\nn >> 1```\n). When the noise does not have unit variance, it follows a more general Gamma distribution (although in this case you can simply think of it as scaling the survival function). For noise with a uniform distribution in the ```\n[-0.5,0.5]```\n range, and a sufficiently large number of samples, the distribution can also be approximated by a Gamma distribution thanks to the Central Limit Theorem.\nTo illustrate and better understand these distribution, we can go through gradually more complex cases.\nFrequency domain distribution of random noise\nFor sake of comparing with the later case of uniformly distributed data we will use a gaussian noise with a matching variance. Since the variance of uniformly distributed data is in the range ```\n[-0.5,0.5]```\n is ```\n1/12```\n, this gives us the following data:\n```\ndata = np.sqrt(1.0/12)*np.random.randn(500)\n```\n\nNow let us check the statistics on the power spectrum. As indicated earlier, the squared magnitude of each frequency coefficient is a random variable with an approximately Gamma distribution. The shape parameter is half the degrees of freedom of a Chi-Squared distribution that could have been used for a unit-variance case (so 1 in this case), and the scale parameter corresponds to the square of the scaling of the time-domain (from linearity the variate ```\nyf```\n scales as ```\ndata```\n, such that ```\nnp.abs(yf)**2```\n scales as the square of ```\ndata```\n).\nWe can validate this by plotting the histogram of the ```\ndata```\n against the probability density function:\n```\nyf = rfft(data)\nspectrum = np.abs(yf)**2/len(data)\nplt.figure(figsize=(5,5))\nplt.hist(spectrum, bins=100, density=True, label='data')\nz = np.linspace(0, np.max(spectrum), 100)\nplt.plot(z, gamma.pdf(z, 1, scale=1.0/12), 'k', label='$\\Gamma(1,{:.3f})$'.format(1.0/12))\n```\n\nAs you can see the values are in pretty good agreement:\n\nGoing back to the spectrum plot:\n```\n# degrees of freedom\nphi = 2\n###values of chi-squared\nchi_val_95 = chi2.isf(q=0.05/2, df=phi) #/2 for two-sided test\n\n### normalization of power spectrum with 1/n\nplt.figure(figsize=(5,5))\nplt.plot(xf,np.abs(yf)**2/n, color='k')\n# the following two lines should overlap\nplt.axhline(y=var*(chi_val_95/phi),color='r',linestyle='--')\nplt.axhline(y=gamma.isf(q=0.05/2, a=1, scale=var),color='b')\n```\n\n\nJust changing the ```\ndata```\n to use a uniform distribution in the ```\n[-0.5,0.5]```\n range (with ```\ndata = np.random.rand(500) - 0.5```\n) gives an almost identical plot, with the confidence level remaining unchanged.\nFrequency domain distribution of signal with noise\nTo get a single threshold value corresponding to a 95% confidence interval where the noise part would fall if you could separate it from the ```\ndata```\n containing a sinusoidal component and noise (or otherwise stated as the 95% confidence interval of the null-hypothesis that the ```\ndata```\n is white noise), you would need the variance of the noise. While trying to estimate this variance you may quickly realize that the sinusoidal contributes a non-negligible portion of the overall ```\ndata```\n's variance. To remove this contribution we could take advantage of the fact that sinusoidal signals are more readily separated in the frequency-domain.\nSo we could simply discard the x% largest values of the spectrum, under the assumption that those are mostly contributed by spike of the sinusoidal component in the frequency-domain. Note that 95 percentile choice below for the outliers is somewhat arbitrary:\n```\n# remove outliers\nthreshold = np.percentile(np.abs(yf)**2, 95) \nfiltered = [x for x in np.abs(yf)**2 if x <= threshold]\n```\n\nThen we can get the time-domain variance using Parseval's theorem:\n```\n# estimate variance\n# In time-domain variance ~ np.sum(data**2)/len(data))\n# In frequency-domain, using Parseval's theorem we get np.sum(data**2)/len(data) = np.mean(np.abs(spectrum)**2)/len(data)\nvar = np.mean(filtered)/len(data)\n```\n\nNote that due to the dynamic range of values across the spectrum, you may prefer to visualize the results on a logarithmic scale:\n```\nplt.figure(figsize=(5,5))\nplt.plot(xf,10*np.log10(np.abs(yf)**2/n), color='k')  \nplt.axhline(y=10*np.log10(gamma.isf(q=0.05/2, a=1, scale=var)),color='r',linestyle='--')\n```\n\n\nIf on the other hand you are trying to obtain a frequency-dependent 95% confidence interval, then you'd need to consider the contribution of the sinusoidal component at each frequency. For sake of simplicity we will assume here that the amplitude of the sinusoidal component and the variance of the noise are known (otherwise we'd first need to estimate these). In this case the distribution gets shifted by the sinusoidal component's contribution:\n```\nsignal = np.sin(20*np.pi*x)\ndata = signal + np.random.rand(500) - 0.5\nSf   = rfft(signal)  # Assuming perfect knowledge of the sinusoidal component\nyf   = rfft(data)\n\nnoiseVar = 1.0/12    # Assuming perfect knowledge of the noise variance\nthreshold95 = np.abs(Sf)**2/n + gamma.isf(q=0.05/2, a=1, scale=noiseVar)\nplt.figure(figsize=(5,5))\nplt.plot(xf, 10*np.log10(np.abs(yf)**2/n), color='k')  \nplt.plot(xf, 10*np.log10(threshold95), color='r',linestyle='--')\n```\n\n\nFinally, while I kept the final plots in squared-amplitude units, nothing prevents you from taking the square root and view the corresponding thresholds in amplitude units.\n\nEdit : I've used a ```\ngamma(1,s)```\n distribution which is an asymptotically good distribution for data with sufficient number of samples ```\nn```\n. For really small data sizes the distribution more closely match a ```\ngamma(0.5*(n/(n//2+1)),s)```\n (due to the DC and Nyquist coefficients being purely real, thus having 1 degree of freedom unlike all other coefficients).\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
{"Question": "Plot a fourier transform of a sin wav with matplotlib\r\n                \r\nI am trying to plot a fourier transform of a sign wave based on the scipy documentation\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fft\n\ndef sinWav(amp, freq, time, phase=0):\n    return amp * np.sin(2 * np.pi * (freq * time - phase))\n\ndef plotFFT(f, speriod, time):\n    \"\"\"Plots a fast fourier transform\n\n    Args:\n        f (np.arr): A signal wave\n        speriod (int): Number of samples per second\n        time ([type]): total seconds in wave\n    \"\"\"\n\n    N = speriod * time\n    # sample spacing\n    T = 1.0 / 800.0\n    x = np.linspace(0.0, N*T, N, endpoint=False)\n\n    yf = scipy.fft.fft(f)\n    xf = scipy.fft.fftfreq(N, T)[:N//2]\n    plt.plot(xf, 2.0/N * np.abs(yf[0:N//2]))\n    plt.grid()\n    plt.xlim([1,3])\n    plt.show()\n\n\nsperiod = 1000\ntime  = {\n    0: np.arange(0, 4, 1/speriod),\n    1: np.arange(4, 8, 1/speriod),\n    2: np.arange(8, 12, 1/speriod)\n}\n\nsignal = np.concatenate([\n    sinWav(amp=0.25, freq=2, time=time[0]),\n    sinWav(amp=1, freq=2, time=time[1]),\n    sinWav(amp=0.5, freq=2, time=time[2])\n])   # generate signal\n\nplotFFT(signal, speriod, 12)\n```\n\n\nDesired output\nI want to be getting a fourier transform graph which looks like this\n\nCurrent output\nBut instead it looks like this\n\n\nExtra\nThis is the sin wave I am working with\n\n    ", "Answer": "\r\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fft\n\ndef sinWav(amp, freq, time, phase=0):\n    return amp * np.sin(2 * np.pi * (freq * time - phase))\n\ndef plotFFT(f, speriod, time):\n    \"\"\"Plots a fast fourier transform\n\n    Args:\n        f (np.arr): A signal wave\n        speriod (int): Number of samples per second\n        time ([type]): total seconds in wave\n    \"\"\"\n\n    N = speriod * time\n    # sample spacing\n    T = 1.0 / 800.0\n    x = np.linspace(0.0, N*T, N, endpoint=False)\n\n    yf = scipy.fft.fft(f)\n    xf = scipy.fft.fftfreq(N, T)[:N//2]\n\n    amplitudes = 1/speriod* np.abs(yf[:N//2])\n  \n    plt.plot(xf, amplitudes)\n    plt.grid()\n    plt.xlim([1,3])\n    plt.show()\n\n\nsperiod = 800\ntime  = {\n    0: np.arange(0, 4, 1/speriod),\n    1: np.arange(4, 8, 1/speriod),\n    2: np.arange(8, 12, 1/speriod)\n}\n\nsignal = np.concatenate([\n    sinWav(amp=0.25, freq=2, time=time[0]),\n    sinWav(amp=1, freq=2, time=time[1]),\n    sinWav(amp=0.5, freq=2, time=time[2])\n])   # generate signal\n\nplotFFT(signal, speriod, 12)\n```\n\nYou should have what you want. Your amplitudes were not properly computed, as your resolution and speriod were inconsistent.\n\nLonger data acquisition:\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.fft\n\ndef sinWav(amp, freq, time, phase=0):\n    return amp * np.sin(2 * np.pi * (freq * time - phase))\n\ndef plotFFT(f, speriod, time):\n    \"\"\"Plots a fast fourier transform\n\n    Args:\n        f (np.arr): A signal wave\n        speriod (int): Number of samples per second\n        time ([type]): total seconds in wave\n    \"\"\"\n\n    N = speriod * time\n    # sample spacing\n    T = 1.0 / 800.0\n    x = np.linspace(0.0, N*T, N, endpoint=False)\n\n    yf = scipy.fft.fft(f)\n    xf = scipy.fft.fftfreq(N, T)[:N//2]\n\n    amplitudes = 1/(speriod*4)* np.abs(yf[:N//2])\n  \n    plt.plot(xf, amplitudes)\n    plt.grid()\n    plt.xlim([1,3])\n    plt.show()\n\n\nsperiod = 800\ntime  = {\n    0: np.arange(0, 4*4, 1/speriod),\n    1: np.arange(4*4, 8*4, 1/speriod),\n    2: np.arange(8*4, 12*4, 1/speriod)\n}\n\nsignal = np.concatenate([\n    sinWav(amp=0.25, freq=2, time=time[0]),\n    sinWav(amp=1, freq=2, time=time[1]),\n    sinWav(amp=0.5, freq=2, time=time[2])\n])   # generate signal\n\nplotFFT(signal, speriod, 48)\n```\n\n\n    ", "Knowledge_point": "Fast Fourier Transform", "Tag": "算法分析"}
