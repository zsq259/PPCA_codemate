{"Question": "Computational complexity of Fibonacci Sequence\r\n                \r\nI understand Big-O notation, but I don't know how to calculate it for many functions. In particular, I've been trying to figure out the computational complexity of the naive version of the Fibonacci sequence:\n\n```\nint Fibonacci(int n)\n{\n    if (n <= 1)\n        return n;\n    else\n        return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n```\n\n\nWhat is the computational complexity of the Fibonacci sequence and how is it calculated?\n    ", "Answer": "\r\nYou model the time function to calculate ```\nFib(n)```\n as sum of time to calculate ```\nFib(n-1)```\n plus the time to calculate ```\nFib(n-2)```\n plus the time to add them together (```\nO(1)```\n).  This is assuming that repeated evaluations of the same ```\nFib(n)```\n take the same time - i.e. no memoization is used.\n```\nT(n<=1) = O(1)```\n\n```\nT(n) = T(n-1) + T(n-2) + O(1)```\n\nYou solve this recurrence relation (using generating functions, for instance) and you'll end up with the answer.\nAlternatively, you can draw the recursion tree, which will have depth ```\nn```\n and intuitively figure out that this function is asymptotically ```\nO(2```\n```\nn```\n```\n)```\n. You can then prove your conjecture by induction.\nBase: ```\nn = 1```\n is obvious\nAssume ```\nT(n-1) = O(2```\n```\nn-1```\n```\n)```\n, therefore\n```\nT(n) = T(n-1) + T(n-2) + O(1)```\n which is equal to\n```\nT(n) = O(2```\n```\nn-1```\n```\n) + O(2```\n```\nn-2```\n```\n) + O(1) = O(2```\n```\nn```\n```\n)```\n\nHowever, as noted in a comment, this is not the tight bound. An interesting fact about this function is that the T(n) is asymptotically the same as the value of ```\nFib(n)```\n since both are defined as\n```\nf(n) = f(n-1) + f(n-2)```\n.\nThe leaves of the recursion tree will always return 1. The value of ```\nFib(n)```\n is sum of all values returned by the leaves in the recursion tree which is equal to the count of leaves. Since each leaf will take O(1) to compute, ```\nT(n)```\n is equal to ```\nFib(n) x O(1)```\n. Consequently, the tight bound for this function is the Fibonacci sequence itself (~```\nθ(1.6```\n```\nn```\n```\n)```\n). You can find out this tight bound by using generating functions as I'd mentioned above.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Java recursive Fibonacci sequence\r\n                \r\nPlease explain this simple code:\n\n```\npublic int fibonacci(int n)  {\n    if(n == 0)\n        return 0;\n    else if(n == 1)\n      return 1;\n   else\n      return fibonacci(n - 1) + fibonacci(n - 2);\n}\n```\n\n\nI'm confused with the last line especially because if n = 5 for example, then fibonacci(4) + fibonacci(3) would be called and so on but I don't understand how this algorithm calculates the value at index 5 by this method. Please explain with a lot of detail! \n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generating Fibonacci Sequence\r\n                \r\n```\nvar x = 0;\nvar y = 1;\nvar z;\n\nfib[0] = 0;\nfib[1] = 1;\n\nfor (i = 2; i <= 10; i++) {\n  alert(x + y);\n  fib[i] = x + y;\n  x = y;\n  z = y;\n}\n```\n\n\nI'm trying to get to generate a simple Fibonacci Sequence but there no output. \n\nCan anybody let me know what's wrong?\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence multiplying\r\n                \r\nI tried to make the fibonacci sequence with the following code:\n\n```\ndef fibonacci(n): # write Fibonacci series up to n\n    \"\"\"Print a Fibonacci series up to n.\"\"\"\n    a = 0\n    b = 1\n    the_list = []\n    while n > len(the_list):\n        the_list.append(a)\n    #By saying a = b and b = a+b we define the\n    #fibonacci sequence, since this is how the\n    #fibonacci sequence works.\n        a = b\n        b = a+b\n    print the_list\n# Now call the function we just defined:\nfibonacci(10)\n```\n\n\nAs far as I know this code should do it but instead of giving me the fibonacci sequence its giving the following output:\n\n```\n[0, 1, 2, 4, 8, 16, 32, 64, 128, 256]\n```\n\n\nSo my fibonacci sequence is multiplying instead of working correcly. I have no idea why because i thought\n\n```\na = b\nb = a+b\n```\n\n\nshould do the trick, if i look at my while loop the statements for this loop are also correct, so I just dont get it why i dont get the right output. \n\nSo if someone could explain me why this code is not working it would be highly appriciated\n    ", "Answer": "\r\nYour code is creating an exponential sequence because of a logic flaw. Based on your code:\n\n```\nStart:\na = 0\nb = 1\n\n1st iteration:\na = b = 1\nb = a + 1 = 1 + 1 = 2\n\n2nd iteration:\na = b = 2\nb = a + 2 = 2 + 2 = 4\n```\n\n\nAs you can see the fact that you set ```\na```\n before performing the ```\nb```\n calculation causes your issue.\n\nInstead you need would something like (to prove the point):\n\n```\ntmp = a\na = b\nb = tmp + a\n```\n\n\nA little extra math would eliminate the need for the extra variable:\n\n```\nb += a\na = b - a\n```\n\n\nBut the easiest (and most pythonic) way would be:\n\n```\na, b = b, a + b\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "PHP Fibonacci Sequence\r\n                \r\nThis php method is suppose to print the Fibonacci sequence up to a specified value using a for loop. I am unsure why it does not work?\n\n```\n<?php\nfunction fib ($n) { // a function called fib, declaire variable n (the sequence number)\n    for ($n=0;$n<30;$n++) {\n        if ($n < 3) { return $n; } // if n is smaller than 3 return n (1 or 2)\n        else { return fib ($n - 1) + fib ($n - 2); } \n    /* if the number is 3 or above do 2 sums (n-1) and (n-2)\n    and then add the 2 sums together (n-1)+(n-2)\n    Example Fibonacci number 4\n    (4-1)+(4-2) = 5\n    3 + 2 = 5\n    */\n}\nprint $n;\n?>\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence\r\n                \r\nI'm trying to calculate the numbers of the fibonacci Sequence under 100, but the code I made doesn't work. What I have is:\n\n```\ndef fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\nnum=0\nwhile(num<100):\n        print (fib(num))\n        num+=1\n```\n\n\nI think this should work, but it doesn't, so it's definitely my issue with my coding. Could anyone resolve this?\n    ", "Answer": "\r\nSo what about this code is not working? It looks like the implementation is correct, but it's of course, slow. You can try to store the numbers you compute in some kind of data structure as you go along to reduce your stack trace and prevent having to recalculate fib of 23 when you're trying to calculate fib of 24.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursion and fibonacci sequence\r\n                \r\nHow do I get this code to print all values of the fibonacci sequence of given terms? Right now it prints only the last term \n\n```\n#include <stdio.h>\n\nint fibonacci(int n){\n\n    if (n==2)\n        return 1; \n    else\n      return fibonacci(n-1) + fibonacci(n-2);   \n\n}\n\n\nint main()\n{\n\n    int n;\n    int answer;\n    printf(\"Enter the number of terms you'd like in the sequence\\n\");\n    scanf(\"%d\",&n);\n\n    answer = fibonacci(n);\n    printf(\"The answer is %d\\n\", answer);\n\n}\n```\n\n    ", "Answer": "\r\nYour base case is incorrect.  When ```\nn==2```\n, you'll call ```\nfibonacci(1)```\n and ```\nfibonacci(0)```\n.  The latter will continue downward until you run out of stack space.\n\nYou should check for numbers less than to equal to the base case:\n\n```\nif (n<=2)\n```\n\n\nEDIT:\n\nIf you want to print all the values, you can't do it the way the function is currently structured because of the double recursion.\n\nIf you keep track of the numbers you've calculated previously, it can be done.  Then you only print out a number (and perform recursion) the first time you calculate a number, otherwise you look it up from the list and continue.\n\n```\nint fibonacci(int n){\n    static int seq[50] = {0};\n\n    if (n > 50) {\n        printf(\"number too large\\n\");\n        return 0;\n    }\n    if (seq[n-1] == 0) {\n        if (n<=2) {\n            seq[n-1] = 1;\n        } else {\n            seq[n-1] = fibonacci(n-1) + fibonacci(n-2);\n        }\n        printf(\"%d \", seq[n-1]);\n    }\n    return seq[n-1];\n}\n```\n\n\nOutput:\n\n```\nEnter the number of terms you'd like in the sequence\n10\n1 1 2 3 5 8 13 21 34 55 The answer is 55\n```\n\n\nNote that the above function has a limit of 50, since the result is too large for a 32 bit int at around that range.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence datastructure\r\n                \r\nIt is known that Fibonacci sequence is {0,1,1,2,3,5,8,13,21... ...}, try to write recursive functions and non-recursive functions, calculate the values of 10th numbers, 29th numbers, 50th numbers and 64th numbers of Fibonacci sequence on the computer, and compare the time consumed by the two, the performance of the two design methods is analyzed.\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Ruby\r\n                \r\nI have coded the fibonacci sequence on Ruby:\n\n```\nn=40\ndef fibonacci (n)\n    if n == 1\n        1\n    elsif n == 2\n        1\n    else\n        fibonacci(n-1) + fibonacci(n-2)\n    end\nend\nputs \"#{n}'s fibonacci value is #{fibonacci(n)}\"\n```\n\n\nWhat code do I need to add to allow the user to select which part of the sequence they are looking for eg: n=35? I'm using the MAC terminal to test\n    ", "Answer": "\r\nRuby can take input from the user in a variety of forms, but the easiest is through ```\nARGV```\n, which encapsualtes the command-line arguments.\n\nFirst let's clean up the implementation by using Ruby's flexible ```\ncase```\n statement:\n\n```\ndef fibonacci(n)\n  case (n)\n  when 1,2\n    1\n  else\n      fibonacci(n-1) + fibonacci(n-2)\n  end\nend\n```\n\n\nThen feed input from the command-line argument thorugh to the function. Note that command-line input is always strings, so these need to be converted to integers with ```\n.to_i```\n:\n\n```\nn = ARGV[0].to_i\nputs \"#{n}'s fibonacci value is #{fibonacci(n)}\"\n```\n\n\nAnd then you call it like this:\n\n```\nruby fib.rb 35\n# => 35's fibonacci value is 9227465\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Compiling error in Java Fibonacci sequence\r\n                \r\nI am confused on why I'm getting an error and how to fix it. My version of the fibonacci sequence is supposed to only print the desired target index value, and not all the numbers before it like most other Fibonacci sequences I've seen.\n\n```\nimport java.util.Scanner;\n\npublic class Fibonacci_ronhoward\n{\npublic static void main(String[] args)\n{\n    Scanner scan = new Scanner(System.in);\n\n    System.out.println(\"This is a Fibonacci sequence generator\");\n\n    System.out.println(\"Choose what you would like to do\");\n\n    System.out.println(\"1. Find the nth Fibonacci number\");\n\n    System.out.println(\"2. Find the smallest Fibonacci number that exceeds user given value\");\n\n    System.out.println(\"Enter your choice: \");\n\n    int choice = scan.nextInt();\n\n    switch (choice)\n    {\n        case 1:\n\n            System.out.println();\n\n            System.out.println(\"Enter the target index to generate (>1): \");\n\n            int n = scan.nextInt();\n\n            int a = 0;\n\n            int b = 1;\n\n            for (int i = 1; i < n; i++)\n            {\n\n                int nextNumber = a + b;\n                a = b;\n                b = nextNumber;\n\n            }\n\n            System.out.println(\"The \" + n + \"th Fibonacci number is \" + nextNumber + \" \");\n\n            break;\n\n    }\n\n\n}\n}\n```\n\n    ", "Answer": "\r\nYou define ```\nnextNumber```\n in ```\nfor```\n loop but then try to use it outside of for loop scope, that's the problem.\n\nYou should declare it outside of the loop. \n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence inconsistency\r\n                \r\nI've made a short program to generate the fibonacci sequence in a length specified by the user. At the moment when I run the code and input a digit like 6, it will display the sequence as follows:\n\n1 , 1,2,3,5,8,\n\nHow do i get rid of the initial spaces while the string stays on one line? below is my code\n\n```\n#user intiger input\nprint(\"\\n\")\nf = int(input(\"Enter length of sequence: \"))\nprint(\"\\n\")\n\n\nf1 = 1\nf2 = 1\nmultiply = 2\n\n\nif f <=0:\n   print(\"Enter a positive integer for the length: \")\n\n\nelif f == 1:\n   print(\"The Fibonacci sequence: \")\n   print(\"\\n\")\n   print(f1,end=',')\n\nelse:\n   print(\"The Fibonacci sequence: \")\n   print(f1,\",\",f2,end=\",\")\n   while multiply < f:\n       f3 = f1 + f2\n       print(f3,end=\",\")\n\n       f1 = f2 \n       f2 = f3 \n       multiply += 1\n\nprint(\"\\n\")\n```\n\n    ", "Answer": "\r\n```\nelse:\nprint(\"The Fibonacci sequence: \")\nprint(f1,end=\",\")\nprint(f2,end=\",\")\n```\n\n\nThis is the simplest solution as per my perspective..\nbut by seeing your code its seems like output should be rid of initial spce\nhowever try as per suggetion & let me know output\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python Fibonacci sequence and sequence unpacking\r\n                \r\nI'm processing the fibonacci sequence by iteration. I expected the following two functions to provide the same results, but they do not.\n\nExample 1 (returns Fibonacci sequence as desired):\n\n```\ndef run():\n    for x in range(0,20):    \n        fib(x)\n\ndef fib(n):\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    print a\n\nrun() \n```\n\n\nExample 1 results:\n\n```\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n```\n\n\nExample 2 (without sequence unpacking):\n\n```\ndef run():\n    for x in range(0,20):    \n        fib(x)\n\ndef fib(n):\n    a = 0\n    b = 1\n    for i in range(n):\n        a = b\n        b = a + b \n    print a\n\nrun() \n```\n\n\nExample 2 results:\n\n```\n0\n1\n2\n4\n8\n16\n32\n64\n128\n256\n```\n\n\nSpecifically, why is... \n\n```\na, b = b, a + b\n```\n\n\nDifferent than...\n\n```\na = b\nb = a + b\n```\n\n    ", "Answer": "\r\n```\na, b = b, a + b```\n is first evaluating the right side of the ```\n=```\n and then assigning it to the left side. I.e. the results in ```\na```\n and ```\nb```\n would be based on the calculation with the previous values (before this line). While the second code is doing exactly what is written sequentially, while the second line is evaluating with the values obtained in the first line.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "The Fibonacci sequence using threads in C\r\n                \r\nI wrote a program in C to generate a Fibonacci sequence with n numbers where each  Fibonacci number created by a separate thread, the parent thread outputs whole produced Fibonacci sequence yet I got wrong sequence for n>2 it some how rewrite the value of the last element  in the Fibonacci sequence array to 0 if n>2 .How i can fix it? please find the code below.\n\n```\n/*============================================================================\n   Description :The Fibonacci sequence\n  ============================================================================ */\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint n;                          // size of fibonacci sequence.\nint *fibseq;                    // arry holds the value of each fibonacci term.\nint i;                          // counter for the threads.\n\nvoid *runn(void *arg);\n\nint main(int argc, char *argv[])\n{\n    if (argc != 2)\n    {\n        printf(\"format is:./a.out <intgervalue>\\n\");\n        return -1;\n    }                           // valdiate num of args.\n\n    if (atoi(argv[1]) < 0)\n    {\n        printf(\"%d must be>=0\\n\", atoi(argv[1]));\n        return -1;\n    }                           // valdiate value of arg1.\n\n    n = atoi(argv[1]);\n    fibseq = (int *)malloc(n * sizeof(int));\n    pthread_t *threads = (pthread_t *) malloc(n * sizeof(pthread_t));\n    pthread_attr_t attr;        // set of thread attribute\n\n    pthread_attr_init(&attr);\n\n    for (i = 0; i < n; i++)\n    {\n        pthread_create(&threads[i], &attr, runn, NULL);\n    }                           // End of creating threads.\n\n    int j;\n\n    for (j = 0; j < n; j++)\n    {\n        pthread_join(threads[j], NULL);\n    }                           // End of wating the threads to exit.\n\n    // printing fibseq.\n    printf(\"The Fibonacci sequence.:\");\n    int k;\n\n    for (k = 0; k < n; k++)\n    {\n        printf(\"%d,\", fibseq[k]);\n    }                           // End of printing fibseq.\n    return 0;\n}                               // End of main.\n\nvoid *runn(void *arg)\n{\n    if (i == 0)\n    {\n        fibseq[i] = 0;\n        pthread_exit(0);\n    }                           // first fib term\n\n    if (i == 1)\n    {\n        fibseq[i] = 1;\n        pthread_exit(0);\n    }                           // seconed fib term\n    else\n    {\n        fibseq[0] = 0;\n        fibseq[1] = 1;\n\n        int p, pp, fibp, fibpp;\n\n        p = (i - 1);\n        pp = (i - 2);\n        fibp = fibseq[p];\n        // printf(\"fibseq[%d]%d\\n\",p,fibp);\n        fibpp = fibseq[pp];\n        // printf(\"fibseq[%d]%d\\n\",pp,fibpp);\n        fibseq[i] = fibseq[i - 1] + fibseq[i - 2];\n        // printf(\"fibseq[%d]%d,\\n\",i,fibseq[i]);\n        pthread_exit(0);        // thread exit.\n    }                           // End of else\n}                               // End of run.\n```\n\n    ", "Answer": "\r\nI see that this post is from December of 2015, however the answer to your problem is quite simple. The reason is because you are using two separate for loops to create and join your threads. What this is doing is causing i < n threads to create and run through your *runn function at the same time. Meaning the threads are not waiting for the array to be updated.\n\nThey should be in a single for loop, that way the thread_join statement regulates each thread during each loop cycle. As I did below.\n\n```\nfor (i = 0; i < n; i++)\n{\n    pthread_create(&threads[i], &attr, runn, NULL);\n    pthread_join(threads[i], NULL);\n}   \n```\n\n\nNow your threads are going through your *runn function one at a time. Thus fixing your issue. \n\nOn a side note you seem to have some unnecessary code towards the bottom of your *runn function this isn't necessary and is just redoing the work you have already done.\n\n```\n fibseq[0] = 0; //this is unnecessary, because from your first threads fibseq[0] should \n                //already equal 0\n fibseq[1] = 1; //same for here this value should be equal to 1 already\n```\n\n\nAlso, this is unnecessary. Although if I understand it correctly, this was used for debugging purposes right?\n\n```\nint p, pp, fibp, fibpp;\n\np = (i - 1);\npp = (i - 2);\nfibp = fibseq[p];\n// printf(\"fibseq[%d]%d\\n\",p,fibp);\nfibpp = fibseq[pp];\n// printf(\"fibseq[%d]%d\\n\",pp,fibpp);\n```\n\n\nThe only relevant code needed for the else statement is here\n\n```\nfibseq[i] = fibseq[i - 1] + fibseq[i - 2];\npthread_exit(0);        // thread exit.\n```\n\n\nI hope this helps answer this question.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python - About Fibonacci sequence\r\n                \r\nI try to make a code that asks from the user to enter a positive number and then tells him/her if this number belongs to the Fibonacci sequence. The problem is that, when I run the code never stops runnning (or eventually I'll get an error). Here's my the code so far:\n```\nprint(\"\\nEnter any positive number, to see if it\")\nuser = input(\"belongs to the Fibonacci sequence: \")\n\ndef fibo(user):\n    if user in [0,1]:\n        return user\n    else:\n        return fibo(user-1) + fibo(user-2)\n\n\nwhile user.isdigit() == False:\n    user = input(\"Input error. Please enter a positive number: \")\nelse:\n    user = int(user)\n\nif user == fibo(user):\n    print(\"\\nNumber\",user,\"belongs to the Fibonacci sequence.\\n\")\nelse:\n    print(\"\\nNumber\",user,\"doesn't belong to the Fibonacci sequence.\\n\")\n```\n\n    ", "Answer": "\r\n```\ndef fibo(input):\n    i = int(input)\n    # set z to 1 if you want\n    # False to be returned for 0\n    x = 0; y = 1; z = 0\n    while z < i:\n        z = x + y; x = y; y = z\n    return z == i\n \nprint(fibo(input(\"fibonacci?: \")))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  How to write the Fibonacci Sequence in Python  \n\n\n\n\nHi. I'm also a learning programmer and I've been asked the same question you were asked for Fibonacci numbers and I can't figure it out. Can you please show me the code you used to generate these numbers asking the user to give numbers and find only the numbers in the range specified? Thank you\n    ", "Answer": "\r\nI'm not going to give you the code - you should be able to write it yourself. Here are some things you may need to know when writing it however (Not using recursion):\n\n\nCreate 3 variables equal to -1 ```\n(n1)```\n,  1 ```\n(n2)```\n, and n1 + n2 ```\nsumn```\n.\nCreate a loop using ```\nfor i in range(amount_of_numbers)```\n, where ```\namount_of_numbers```\n is how many numbers you want to generate\nIn this loop, reassign ```\nn1```\n to ```\nn2```\n, ```\nn2```\n to ```\nsumn```\n, and, once again, ```\nsumn```\n to n1 + n2.\nPrint out ```\nsumn```\n (Inside the loop).\n\n\nThat should be all you need to know if you are really lost on where to go with this. If you need help with specific syntax, you can check out the python docs.\n\nYour output should look like this:\n\n```\n1\n1\n2\n3\n5\n8\n13\n21\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Define a function : Fibonacci Sequence\r\n                \r\nDefine a function to implement Fibonacci Sequence: 1, 1, 2, 3, 5, 8, 13, 21, 34. Please use the function output first 20 figures of Fibonacci Sequence.\n    ", "Answer": "\r\nHere is a python implementation\n\n```\ndef fib(n):\n    a, b = 0, 1\n    while a < n:\n        print(a, end=' ')\n        a, b = b, a+b\n    print()\n\nfib(5000)\n```\n\n\nOutput\n\n```\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181\n```\n\n\nA recursive implementation\n\n```\nmemo = [-1] * 21\nmemo[0] = 0\nmemo[1] = 1\nprint(memo[0], end=' ')\nprint(memo[1], end=' ')\n\ndef fibrec(n):\n    if(memo[n] == -1):\n        memo[n] = fibrec(n-2) + fibrec(n-1)\n        print(memo[n], end=' ')\n\n    return memo[n]\n\nfibrec(20)\n```\n\n\nOutput\n\n```\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Nested Loops Fibonacci Sequence\r\n                \r\nI am trying to write a program which will ask the user to enter a number. I then need to validate it is in the fib sequence\n\nCode: \n\n```\n# asking the user to input number\nnumber = int(input(\"Enter a number: \"))\n\n# creating empty list to be filled\nsequence = [0, 1]\n\nx = -2\ny = -1\n\n\n# append items to list\nfor i in range(number):\n    x+=2\n    y+=2\n# this code will be executed 'length' times\n    sequence.append(x+y)\n\n# This should be somewhere in the loop: \nif number in sequence:\n    print(\"The number is in the Fibonacci sequence\")\nelse:\n    print(\"The number is not in the Fibonacci sequence\")\n```\n\n\nExpected Output:\n\nFibonacci Sequence = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …. \n\n```\nEnter a number: 5\n>>> The number is in the Fibonacci sequence\n```\n\n    ", "Answer": "\r\nYou will need to do some iteration (or recursion) in order to find the sequence of Fibonacci numbers. Here is one way to do it with a while loop:\n\n```\nnumber = int(input(\"Enter a number: \"))\n\nsequence = [0, 1]\n\ni= 0\nwhile True:\n    new_item = sequence[i] + sequence[i+1]\n    if new_item == number or number in [0,1]:\n        print(\"The number is in the Fibonacci sequence\")\n        break\n    elif new_item > number:\n        print(\"The number is not in the Fibonacci sequence\")\n        break\n    sequence.append(new_item)\n    i+=1\n```\n\n\nNotice that you will iterate until the new item in your Fibonacci sequence is greater than or equal to the number the user input.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Mod 1000000007\r\n                \r\nEveryone knows that the Fibonacci sequence goes\n```\nF[0]=1, F[1]=1, F[2]=2, F[3]=3, F[4]=5, F[5]=8```\n,\nwith ```\nF[n] = F[n-1]+F[n-2]```\n.\nNow, how do you compute a number in the Fibonacci sequence when taken modulo 1000000007 = 10^9+7?\nNeeds to run as efficiently as possible, and in Python language :)\nFor example F[10**15] should take less than a second or so.\nI know matrix exponentiation works, but how do you correct Matrix Exponentiation to reflect MODULO? (Another example, see https://www.nayuki.io/page/fast-fibonacci-algorithms)\n    ", "Answer": "\r\nThe tricks needed:\n\n1) Use the closed form of Fibonacci numbers, this is much faster than recursion. http://mathworld.wolfram.com/FibonacciNumber.html (formula 6)\n\n2) modulo essentially factors over multiplication and addition, and sort of factors over division (you have to compute the multiplicative inverse in the mod space with the extended euclidean algorithm first) so you can basically just mod as you go.  https://en.wikipedia.org/wiki/Modulo_operation#Equivalencies  https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Modular_integers\n\ncode:\n\n```\ndef rootiply(a1,b1,a2,b2,c):\n    ''' multipy a1+b1*sqrt(c) and a2+b2*sqrt(c)... return a,b'''\n    return a1*a2 + b1*b2*c, a1*b2 + a2*b1\n\ndef rootipower(a,b,c,n):\n    ''' raise a + b * sqrt(c) to the nth power... returns the new a,b and c of the result in the same format'''\n    ar,br = 1,0\n    while n != 0:\n        if n%2:\n            ar,br = rootiply(ar,br,a,b,c)\n        a,b = rootiply(a,b,a,b,c)\n        n /= 2\n    return ar,br\n\ndef rootipowermod(a,b,c,k,n):\n    ''' compute root powers, but modding as we go'''\n    ar,br = 1,0\n    while k != 0:\n        if k%2:\n            ar,br = rootiply(ar,br,a,b,c) \n            ar,br = ar%n,br%n\n        a,b = rootiply(a,b,a,b,c)\n        a,b = a%n, b%n\n        k /= 2\n    return ar,br\n\ndef fib(k):\n    ''' the kth fibonacci number'''\n    a1,b1 = rootipower(1,1,5,k)\n    a2,b2 = rootipower(1,-1,5,k)\n    a = a1-a2\n    b = b1-b2\n    a,b = rootiply(0,1,a,b,5)\n    # b should be 0!\n    assert b == 0\n    return a/2**k/5\n\ndef powermod(a,k,n):\n    ''' raise a**k, modding as we go by n'''\n    r = 1\n    while k!=0:\n        if k%2:\n            r = (a*r)%n\n        a = (a**2)%n\n        k/=2\n    return r\n\ndef mod_inv(a,n):\n    ''' compute the multiplicative inverse of a, mod n'''\n    t,newt,r,newr = 0,1,n,a\n    while newr != 0:\n        quotient = r / newr\n        t, newt = newt, t - quotient * newt\n        r, newr = newr, r - quotient * newr\n    if r > 1: return \"a is not invertible\"\n    if t < 0: t = t + n\n    return t\n\ndef fibmod(k,n):\n    ''' compute the kth fibonacci number mod n, modding as we go for efficiency'''\n    a1,b1 = rootipowermod(1,1,5,k,n)\n    a2,b2 = rootipowermod(1,-1,5,k,n)\n    a = a1-a2\n    b = b1-b2\n    a,b = rootiply(0,1,a,b,5)\n    a,b = a%n,b%n\n    assert b == 0\n    return (a*mod_inv(5,n)*mod_inv(powermod(2,k,n),n))%n\n\nif __name__ == \"__main__\":\n    assert rootipower(1,2,3,3) == (37,30) # 1+2sqrt(3) **3 => 13 + 4sqrt(3) => 39 + 30sqrt(3)\n    assert fib(10)==55\n    #print fib(10**15)%(10**9+7) # takes forever because the integers involved are REALLY REALLY REALLY BIG\n    print fibmod(10**15,10**9+7) # much faster because we never deal with integers bigger than 10**9+7\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence with arrays\r\n                \r\nI have the task of writing a program using the fibonacci sequence and putting them into arrays. It works by getting user input ( how many numbers in the sequence the user wants to print out) and then it implements that into an array and prints out the sequence with the number of 'numbers' the user inputed.\nAs I missed out on 2 weeks of class I looked online on how to write this program and found a video which the following code was written. So I do not take credit for the following code, I'm merely using it as an example.\n\nAnyway here's the code:\n\n```\npublic class Fibonacci\n{\n    public static void main(String[] args)\n    {\n        int numToPrint;\n        //how many numbers to print out\n\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Hvað viltu prenta út margar tölur úr Fibonacci röðinni?\");\n        numToPrint = scan.nextInt();\n        scan.close();\n\n        //prints out the first 2 numbers\n        int nuverandiT = 1;\n        int lokaT = 0;\n        System.out.println(lokaT);\n        System.out.println(nuverandiT);\n\n        //prints out the rest of the sequence\n        int lokaLokaT;\n        for(int i = 2; i < numToPrint; i++)\n        {\n            lokaLokaT = lokaT;\n            lokaT = nuverandiT;\n            nuverandiT = lokaLokaT + lokaT;\n            System.out.println(nuverandiT);\n        }\n    }\n}\n```\n\n\nNow this prints out the fibonacci sequence with input from the user, but I'm not quite sure how to make it print out into an array. Do any of you guys know how to do this?\n    ", "Answer": "\r\nYou have to create an array, for example:\n\n```\nint[] simpleArray;\nsimpleArray = new int[numToPrint];\n```\n\n\nAt the place of\n\n```\nSystem.out.println(lokaT);\nSystem.out.println(nuverandiT);\n```\n\n\nPut:\n\n```\nsimpleArray[0] = lokaT;\nsimpleArray[1] = nuverandiT;\n```\n\n\nAnd inside your loop, you put instead this:\n\n```\nSystem.out.println(nuverandiT);\n```\n\n\nThis:\n    simpleArray[i] = nuverandiT;\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in SML\r\n                \r\n```\n  1 fun fib 0 = 0                                                                   \n  2     | fib 1 = 1                                                                 \n  3     | fib n = (fib n-1) + (fib n-2)                                             \n  4                                                                                 \n  5 val x = fib 8 \n```\n\n\nWhat's incorrect about this implementation of the nth number in the fibonacci sequence? When I run the program it just hangs...\n    ", "Answer": "\r\n```\nfib n - 1```\n is equivalent to ```\n(fib n) - 1```\n, not ```\nfib (n - 1)```\n. So the line ```\nfib n = (fib n - 1) + (fib n - 2)```\n calls ```\nfib n```\n again, causing infinite recursion.\n\nTo fix the problem, add parentheses.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Java [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking for code must demonstrate a minimal understanding of the problem being solved. Include attempted solutions, why they didn't work, and the expected results. See also: Stack Overflow question checklist\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI want to write a java program for  the Fibonacci sequence function.It is not working .Can someone help me please?It is working for small numbers only\n\n```\npublic static void main(String[] args)\n\n{\n    Scanner input = new Scanner(System.in);\n\n    int x = input.nextInt();\n\n    int e =fan(x);\n\n            System.out.println(e);\n    }\n\npublic static int fan(int e){ \n           int a =1;\n           int b;\n           int c = 0;\n\n    for (int i=1; i<=e; i++) {\n                b=c;\n                c=b+a;\n                a=b;\n            }\n\n        return c;\n\n\n}\n\n}\n```\n\n    ", "Answer": "\r\nThis is implemented using BigInteger for big numbers.\n\n```\npublic static String fan(int i) {\n    BigInteger a = BigInteger.ZERO;\n    BigInteger b = BigInteger.ONE;\n    if(i==0) return a.toString();\n\n    for (int f = 1; f < i; f++) {\n        BigInteger temp = b;\n        b = a.add(b);\n        a = temp;\n    }\n    return b.toString();\n}\n\npublic static void main(String[] args)\n\n{\n    Scanner input = new Scanner(System.in);\n\n    int x = input.nextInt();\n\n    String i = fan(x);\n\n    System.out.println(i);\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence error\r\n                \r\nI am coding a Fibonacci sequence in Eclipse and this is my code-\n\n```\npublic class FibonacciAlgorithm {\n    private int a = 0;\n    private int b = 1;\n\n    public FibonacciAlgorithm() {\n    }\n\n    public int increment() {\n        int temp = b;\n        b = a + b;\n        a = temp;\n        return value;\n    }\n\n    public int getValue() {\n        return b;\n    }\n}\n```\n\n\nIt is showing an error in the ```\nreturn value;```\n line saying ```\nvalue cannot be resolved to a variable```\n. I don't see any other errors.\n    ", "Answer": "\r\nWhere is ```\nvalue```\n defined? You return something that was not defined anywhere.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence primes\r\n                \r\nI wasnt able to find any topic on this despite multiple searches. Apologies if this was already covered here.\n\nCan anyone point me in the right direction for further research on the below topic:\n\nI have played recently with the Fibonacci sequence and prime numbers. I have noticed that, at least for certain initial items in that sequence, if you mark all of the primes in the sequence (I did it for numbers: 2(odd prime),3,5,13,89,233,1597,28657) and check their place in the sequence, it also turns out to be a prime. I'm asssuming that 0 is the 0th item. To give some examples: for 2(odd prime) - which is the 3rd number of the sequence - 3 is also a prime, for 13 being 7th number of the sequence - 7 is also prime, for 233 - being 17th number of the sequence - 17 is also a prime. This seems to be true for all primes up to 17 item in the sequence, it then starts to diverge as 19th (19 being a prime) number of the sequence is 4181 which is not a prime.\n\nTo give a visual example:\n\n```\n    item number Fib number  \n    0       0   \n    1       1   \n    2       1   \nprime   3       2   prime   !\nnot prm 4       3   prime\nprime   5       5   prime   !\n    6       8   \nprime   7       13  prime   !\n    8       21  \n    9       34  \n    10      55  \nprime   11      89  prime   !\n    12      144 \nprime   13      233 prime   !\n    14      377 \n    15      610 \n    16      987 \nprime   17      1597    prime   !\n    18      2584    \nprime   19      4181    not prime\n    20      6765    \n    21      10946   \n    22      17711   \nprime   23      28657   prime   !\n    24      46368   \n    25      75025   \n    26      121393  \n    27      196418  \n    28      317811  \nprime   29      514229  prime   !\n    30      832040  \nprime   31      1346269 not prime\n    32      2178309 \n    33      3524578 \n    34      5702887 \n    35      9227465 \n    36      14930352    \nprime   37      24157817    not prime\n    38      39088169    \n    39      63245986    \n    40      102334155   \n    41      165580141\n```\n\n\nDespite there being certain numbers in the sequence which are primes but their sequence order number not being a prime and vice versa, it's still quite interesting to know why is there such a pattern and if it's true for majority of Fibonacci sequence numbers.\n\nAgain, apologies if this is something obvious.\n\nTIA for any clarification on this!\n    ", "Answer": "\r\nYou might want to look at A001605 and follow the links from there. The Online Encyclopedia of Integer Sequences is a fantastic resource for things like this.\n\nI also discuss fibonacci primes at my blog.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence return\r\n                \r\nI'm playing with a Fibonacci sequence using PHP. I understand the concept of recursive functions, but I don't understand what's going on here.\n\nCode:\n\n```\nfunction fs($n) {\n    if ($n < 1) {\n       return 1;\n    } // if\n\n    echo \" n is \" . $n . \"<br>\"; \n    echo fs($n - 1) + fs($n - 2) . \" when n is \" . $n . \"<br>\";\n} // function\n\necho fs(3);\n```\n\n\nAnd here is the return:\n\n```\nn is 3\nn is 2\nn is 1\n2 when n is 1\n1 when n is 2\nn is 1\n2 when n is 1\n0 when n is 3\n```\n\n    ", "Answer": "\r\nYour ```\nfunction```\n, if the input is smaller than 1 will return 1. Otherwise it will print the value of the input and call the function recursively for lower values. Since for -1 it will return 1, you will get incorrect values. Let's call it with 1. It will call it for 0 and -1, returning 1 for each and adding them, resulting in 2, which is incorrect. You need to implement it in a different way:\n\n```\n    function fs($n){\n\n    if ($n<=1) {\n        return 1;\n    }\n    echo fs($n-1)+fs($n-2) .\" when n is \".$n. \"<br>\";   \n\n   } //function\n\n   fs(3);\n```\n\n\nThis will fix the issue.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence while loop\r\n                \r\nI have to write code that displays the Fibonacci sequence to the user desired number of terms and must also use a while loop. I'm not sure why this code isn't working. \n\n```\n#include <stdio.h>\n#include <stdlib.h>\nint main (void) {\n    int max;\n    printf(\"Enter the max term of the Fibonacci Sequence:\\n\");\n    scanf(\"%i\", &max);\n    int a=0;\n    int b=0;\n    a=2;\n\n    while(a<max) {\n        if((a==0||a==1))\n        {\n            printf(\"%i\\n\", &a);\n            ++a;\n        }\n        else if(a>1)\n        {\n            a=(a-1)+(a-2);\n            printf(\"%i\\n\", &a);\n            ++a;\n        }\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nYou can try this.\n```\n#include <stdio.h>\n#include <stdlib.h>\nint main (void) {\n   int max;\n   printf(\"Enter the max term of the Fibonacci Sequence:\\n\");\n   scanf(\"%i\", &max);\n   int n=0;\n   int a=0;\n   int b=1;\n   int next;\n\n   while(n<max) {\n      if ( n <= 1 )\n        {\n          next = n;\n          n++;\n        }\n      else\n        {\n          next = a + b;\n          a = b;\n          b = next;\n          n++;\n        }\n      printf(\"%d\\n\", next);\n   }\n   return 0;\n}\n```\n\nissues with your code:\n\nfollowing declaration & initialisation, you set ```\na=2```\n => it won't take the true branch of the ```\nif```\n statement  -- ```\n'0'```\n will not be printed in your result.\n```\na=(a-1)+(a-2);```\n i.e  ```\na = 1```\n\nthen you are doing ```\n++a;```\n  =>  ```\na == 2```\n. thus it again ```\nelse```\n statement with same ```\na==2```\n.\n\nhence it will print the same value and loop executes infinitely.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence overflow, C++\r\n                \r\nI want to print the first 100 numbers in the fibonacci sequence. My program prints until around 20 numbers than the numbers turn negative.\n\nCan someone explain this to me please and provide a fix?\n\nThanks,\n\n```\n/*Fibonacci sequence*/\n\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    long int i, fib;\n    int firstNum=0, secondNum=1;\n\n    cout << firstNum << endl; \n    cout << secondNum << endl;\n\n    for (i=0; i < 100; i++){\n        fib = firstNum + secondNum;\n        firstNum = secondNum;\n        secondNum = fib;\n        cout << fib << endl;\n    }\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nWhat you are seeing is an integer overflow problem. firstNum and secondNum are not long.\n\nThis should fix it\n\n```\n    unsigned long long i, fib;\n    unsigned long long firstNum=0, secondNum=1;\n```\n\n\nEDIT:\n\nThis will help you avoid overflow after the 20th number, but your program will still overflow. You can use unsigned long long, and you'll make it to the 100th sequence element.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence generation\r\n                \r\nI was writing a fibonacci sequence generator, and I was trying to understand the following code in Haskell\n\n```\nfibs = 1 : 1 : zipWith (+) fibs (tail fibs)\n```\n\n\nI understand what ```\nzipWith```\n is, but I do not exactly know how the program executes and why it does generate all the fibonacci numbers. I was trying to understand why it does not terminate using the environment concept in functional languages as follows:\n\nInitially, because Haskell's lazy evaluation, the binding in the ```\nenv```\n should be ```\nfibs : [1,1,x]```\n, then to evaluate ```\nfibs```\n, the interpreter evaluates ```\nx```\n which is ```\nzipWith (+) fibs (tail fibs)```\n in this case. When evaluating ```\nzipWith```\n, it gets ```\nfibs : [1,1,2,x]```\n, again because of the lazy evaluation of Haskell. And ```\nfibs```\n in ```\nenv```\n is bound to ```\n[1,1,2,x]```\n at this time. However, to fully evaluate ```\nfibs```\n, it continues to evaluate ```\nx```\n and we go back to the previous steps.\n\nIs this correct?\n\nBesides, I noticed that when I ran the program above in ```\nghci```\n, it instantly prompts the fibonacci sequence it currently has computed, why? Shouldn't it print the result once it finishes all the computation?\n    ", "Answer": "\r\nSo, most of your reasoning is correct. In particular, you described correctly how each new element of the list is evaluated in terms of older ones. You are also correct that to fully evaluate ```\nfibs```\n would require repeating the steps you outlined and would, in fact, loop forever.\n\nThe key ingredient you're missing is that we don't have to fully evaluate the list. A binding like ```\nfibs = ...```\n just assigns a name to the expression; it does not require evaluating the whole list. Haskell will only evaluate as much of the list as it needs to run ```\nmain```\n. So, for example, if our ```\nmain```\n is\n\n```\nmain = print $ fibs !! 100\n```\n\n\nHaskell will only calculate the first 100 elements of ```\nfibs```\n (following the steps you outlined) but will not need any more than that and will not loop forever.\n\nMoreover, even if we are evaluating the whole thing (which will loop forever), we can use the parts we've calculated as we go along. This is exactly what's happening when you see the value of ```\nfibs```\n in ghci: it prints as much as it can as each element is being calculated and does not have to wait until the whole list is ready.\n\nSeeing Strictness in GHCi\n\nYou can see how much of a list is evaluated in ```\nghci```\n using the ```\n:sprint```\n command which will print a Haskell data structure with ```\n_```\n for the parts that haven't been evaluated yet (called \"thunks\"). You can use this to see how ```\nfibs```\n gets evaluated in action:\n\n```\nPrelude> let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)\nPrelude> :sprint fibs\nfibs = _\nPrelude> print $ fibs !! 10\n89\nPrelude> :sprint fibs\nfibs = _\n```\n\n\nOops, that's not what we expected! In fact, this is a case where the lack of the monomorphism restriction is a problem! ```\nfibs```\n gets a polymorphic type\n\n```\nPrelude> :t fibs\nfibs :: Num a => [a]\n```\n\n\nwhich means it behaves like a function call each time you use it, not like a normal value. (In the background, GHC implements instantiating the ```\nNum```\n type class as passing in a dictionary to ```\nfibs```\n; it's implemented like a ```\nNumDictionary a -> [a]```\n function.)\n\nTo really understand what's going on, we'll need to make ```\nfibs```\n monomorphic explicitly. We can do this by loading it from a module where the restriction is active or by giving it an explicit type signature. Let's do the latter:\n\n```\nPrelude> let fibs :: [Integer]; fibs = 1 : 1 : zipWith (+) fibs (tail fibs)\nPrelude> :sprint fibs\nfibs = _\nPrelude> print $ fibs !! 10\n89\nPrelude> :sprint fibs\nfibs = 1 : 1 : 2 : 3 : 5 : 8 : 13 : 21 : 34 : 55 : 89 : _\n```\n\n\nAnd there you are: you can see which parts of the list needed to be evaluated and which ones didn't to get the 10th element. You can play around with other lists or other lazy data structures to get a good feel for what's going on in the background.\n\nAlso, you can take a look at my blog post about this sort of laziness. It goes into greater detail about the ```\nfibs```\n example (with diagrams!) and talks about how to use this approach for general memoization and dynamic programming.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "nth number in the Fibonacci sequence\r\n                \r\nI do not know how to print, where in the fibonacci sequence the number is (nth number). The bold text is what I'm having trouble with and I have to use a while loop. \n\nPlease input a number for analysis >> 1\n1 is a Fibonacci number whose order in the sequence is both 2 and 3.\n\nPlease input a number for analysis >> 56\n55 is not a Fibonacci number. However 56 is between 11 and 12. \n\nhere is my code\n\n```\nimport java.util.Scanner;\npublic class While\n{\npublic static void main(String[] args) \n{\nSystem.out.println(\"Welcome to the Fibonacci Sequence Detector\\n\\n\");\nScanner in = new Scanner(System.in);    \nSystem.out.print(\"Please input a number for analysis: \");\nint input = in.nextInt();\n\nint fib = 0;\nint fib1 = 1;\nint n;\nwhile(true)\n{\n    n=fib+fib1;\n    if(input == fib1)\n    {\n        fib = -1;\n        break;\n    }\n    if(input>fib1 && input < n)\n    {\n        break;\n    }\n    fib = fib1;\n    fib1=n;\n}\nif (fib == -1 || input == 0)\n    System.out.println(input+\" is a Fibonacci number whose order in the sequence is \" );\n    else\n    System.out.println(input+ \" is not a Fibonacci number\" );\n\n\n} \n}\n```\n\n    ", "Answer": "\r\nThe easiest way I can think of is to have a counter variable that you increment every time through.\n\n```\nwhile(true) {\n    count++;\n...\n}\n...\nSystem.out.println(input+\" is a Fibonacci number whose order in the sequence is \"+count);\n```\n\n\nAs a side note, is there a reason you're using ```\nwhile(true)```\n? Usually there's a way to track a condition where you want to STOP looping. (I was taught that ```\nwhile(true)```\n isn't always wrong, but it usually is.) :)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Backwards Fibonacci Sequence in Assembly\r\n                \r\nDoes anyone know how to output the Fibonacci sequence backwards based on a given Fibonacci number as a starting value? I'm using the MIPS r3000 processor.\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence with while\r\n                \r\nI tried to write fibonacci sequence in JS.\n\nI could get result \n\n```\nvar x = 0;\nvar y = 1;\nvar result = 0;\nwhile (result<100){\n\nresult=x+y;\nx = y;\ny = result;\ndocument.write(\"This is next number \"+result+\"<br>\")\n}\nconsole.log(result)\n```\n\n\nI wonder if it is  possible to get result with this while(total and count) loop like this one?\n\n```\nvar total = 0, count = 1;\nwhile(count <= 10){\ntotal += count;\ncount += 1;\n}\nconsole.log(total);\n```\n\n    ", "Answer": "\r\nNo it isn't possible, the second one will give you quadratic polynomial values.\n\nThere are however various ways to calculate the nth fibonacci nummber without calculating the previous ones. One way is using matrix multiplication, the other is using a real-valued formula with roots where the reals happen to be integers.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generating \"own\" Fibonacci sequence\r\n                \r\nI've got an unusual (I think) problem. For a given number F_n (I don't know the value of n), I have to find numbers F_0, F_1 such that F_{n}=F_{n-1}+F_{n-2}. The additional difficulty is that this sequence should be as long as possible (value n for F_n should be the highest) and if there exist more then one solution I must take this with the smallest F_0. In short I must generate my \"own\" Fibonacci sequence. Some examples:\n\nin: F_n = 10;\nout:  F_0 = 0; F_1 = 2;\n\nin: F_n = 17;\nout: F_0 = 1; F_1 = 5;\n\nin: F_n = 4181;\nout: F_0 = 0; F_1 = 1;\n\nWhat I observed for every sequence (with \"Fibonacci rule\") F_n there is: \n\nF_n = Fib_n * F_1 + Fib_{n-1} * F_0\n\nWhere Fib_n is the n-th Fibonacci number. It is true especially for Fibonacci sequence. But I do not know whether this observation is worth anything. We don't know n and our task is to find F_1, F_0 so I think we have gained nothing. Any ideas?\n    ", "Answer": "\r\nFn-1 = round(Fn/φ)\n\nwhere φ=(√5+1)/2.\n\nProof is left as an exercise for the reader ;^P\n\nUpdate This is incorrect, back to the drawing board.\n\nUpdate 2 Let's compute backwards from Fn and Fn-1.\n\nFn-2 = Fn - Fn-1\nFn-3 = Fn-1 - Fn-2 = Fn-1 - (Fn - Fn-1) = 2Fn-1 - Fn\nFn-4 = Fn-2 - Fn-3 = (Fn - Fn-1) - (2Fn-1 - Fn) = 2Fn - 3Fn-1\nFn-5 = Fn-3 - Fn-4 = (2Fn-1 - Fn) - (2Fn - 3Fn-1) = 5Fn-1 - 3Fn\nFn-6 = Fn-4 - Fn-5 = (2Fn - 3Fn-1) - (5Fn-1 - 3Fn) = 5Fn - 8Fn-1\n\nNotice the pattern? It is easy to compute any member of the sequence out of the real Fibonacci sequence and the last two members. But we only know the last member, how can we know the one before last? \n\nLet's write down the requirement Fi>0 in terms of Fn-1.\n\nFn-2 = Fn - Fn-1 > 0 ⇒ Fn-1 < Fn\nFn-3 = 2Fn-1 - Fn > 0 ⇒ Fn-1 > Fn/2\nFn-4 = 2Fn - 3Fn-1 ⇒ Fn-1 < 2Fn/3\nFn-5 = 5Fn-1 - 3Fn ⇒ Fn-1 > 3Fn/5\n\nSo we have a sequence of bounds on Fn-1 in written terms of the real Fibonacci sequence, each one tighter than the previous. The very last bound that is still satisfiable determines Fn-1 that corresponds to the longest sequence. If there's more than one number that satisfies the last bound, use either the smallest or the largest one , depending on whether the sequence has even or odd length.\n\nFor instance, if Fn=101, then \n101*5/8 < Fn-1 < 101*8/13 ⇒ Fn-1 = 63\n\nThe previous (incorrect) solution would imply Fn-1 = 62, which is close but no cigar.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Reversed Fibonacci Sequence\r\n                \r\nI was assigned a problem in which I have to create a reversed Fibonacci sequence. It is meant to converge when the ratio is ```\n-3.23607```\n. I am unsure why it won't output the ```\nnum```\n but I'm thinking it has something to do with my while loop. Thanks in advance. \n\n```\n#include <iostream>\nusing namespace std;\n\nvoid reverseFibonacci(int*, int*);\n\n\n// Driver function \nint main()\n{\nint a, b;\nint *ptr_1 = &a;\nint *ptr_2 = &b;\ncout << \"what are points 1 and 2?\" << endl;\ncin >> *ptr_1 >> *ptr_2;\nreverseFibonacci(ptr_1, ptr_2);\nreturn 0;\n}\n\nvoid reverseFibonacci(int *a, int *b)\n{\nint *ptr1 = a;\nint *ptr2 = b;\nint c = *ptr1 - *ptr2;\nint *ptr3 = &c;\n\n\nint num = 0;\n\n\ndo\n{\n    *ptr3 = *ptr1-*ptr2;\n    *ptr2 = *ptr1;\n    *ptr1 = *ptr3;\n    num++;\n} while (((*ptr1 / *ptr2) + (*ptr2 / *ptr3)) >= -3.23607);\n\ncout << num << endl;\n\nint *q = new int[num];\n\nfor (int f = 0; f < num; f++)\n{\n    q[f] = *ptr1;\n    q[f + 1] = *ptr2;\n    c = *a - *b;\n    *b = *a;\n    *a = c;\n}\n\n\nfor (int j = num - 1; j >= 0; j--) \n{\n    cout << q[j] << \" \";\n}\n\ndelete[] q;\n}\n```\n\n    ", "Answer": "\r\nThere are several issues in your code.\nFor example, in  the calculation (*ptr1 / *ptr2) + (*ptr2 / *ptr3)), you divide int, so you get int, not double as I guess you expected.\n\nThere were also some errors in term calculations (I assume that 'a' is the first term of the inverse series, forgive me if I am wrong).\nFor calculation of the q[] table, you only calculate q[0] and q[1]. I corrected it, assuming this q[] corresponds to the Fibonacci series in direct order.\n\nI don't think it is necessary to use pointers to int instead of int. I modified it, but maybe it is not your choice. \n\nI inserted writing of some intermediate values : I used them to correct the code. I let them to show you a possible way to debug a programme. \nI also used a vector instead of a C array. It will be easy for you to come back to the array if you need it. Besides that, I tried to follow your own code and not to modify everything. \n\nAs I may have modified the meaning of ptr1 and ptr2, please check that calculation of the convergence test ('ratio') is still correct.\n\nHere is the code, seems to work:\n\n```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid reverseFibonacci(int, int);\nint main()\n{\n    int a, b;\n    cout << \"what are points 1 and 2?\" << endl;\n    cin >> a >> b;\n    reverseFibonacci(a, b);\n    return 0;\n}\n\nvoid reverseFibonacci(int a, int b)\n{\n    const int num_max = 100;\n    int ptr1 = a;\n    int ptr2 = b;\n    int ptr3;\n\n    cout << \"a = \" << a << \"\\tb = \" << b << \"\\n\";\n    int num = 0;\n    double ratio;\n    do\n    {\n        ptr3 = ptr1-ptr2;\n        ptr1 = ptr2;\n        ptr2 = ptr3;\n        if ((ptr2 != 0) && (ptr3 != 0))\n            ratio = static_cast<double> (ptr1) / ptr2 + static_cast<double>(ptr2) / ptr3;\n        else\n            ratio = -100.0; \n        cout << \"num = \" << num << \"\\t\\tptr2 = \" << ptr2 << \"\\t\\tptr1 = \" << ptr1 << \"\\t\\tratio = \" << ratio<< endl;\n        num++;\n    } while ((ratio >= -3.23607) && (num < num_max));\n\n    cout << \"num = \" << num << endl;\n    int n = num + 2;\n    vector<int> q(n);\n    for (int f = 0; f < n; f++)\n    {\n        q[f] = ptr2;\n        ptr3 = ptr1 + ptr2;\n        ptr2 = ptr1;\n        ptr1 = ptr3;\n    }\n    cout << \"Fibonacci series in direct order:\\n\";\n    for (auto j : q) \n    {\n        cout << j << \" \";\n    }\n    cout << endl;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence indent error using Python\r\n                \r\nHere is my code for the above tasks for a Fibonacci sequence.  I was told that I indented incorrectly, but I still couldn't figure out why it happened. Can anyone have a look for me, please?  I'm very grateful for any help.  Also, my code worked for task 1 but not for task 2. The error i got is IndentationError: unindent does not match any outer indentation level, which is really frustrating after hours of trying to sort things out.\n\nTask 1 The first 10 numbers of the Fibonacci sequence are:\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34\nThe sequence is generated from the first two numbers (0 and 1), and every subsequent number is the sum of the previous two numbers. What is the largest number in the Fibonacci sequence smaller then 10^ 22?\n\nTask 2 Rewrite your previous Fibonacci code as a function taking as arguments one or two arguments. If there is one argument, print all the Fibonacci numbers up to that number. If there are two arguments, print all the Fibonacci sequence numbers between the two arguments.\n\n```\nx0,x1=0,1\nwhile x1 < 1e22:\n    x0,x1=x1,x0+x1\n    print x1\n#end of task 1\n\ndef fibo(xmax,xmin=0):\n    x0,x1 = 0,1\n    while x0 <= xmax:\n        x0,x1=x0,x0+x1\n        if x0 >= xmin:\n            print x0\nprint fibo(60,6)\n#end of task 2\n```\n\n    ", "Answer": "\r\nCouple problems.\n\n\nIn the first task, you're only supposed to print the number less than 10e22. Unindent the python statement here because you print all the numbers upto that number in your code.\n\n```\nx0,x1=0,1\nwhile x1 < 1e22:\n    x0,x1=x1,x0+x1\nprint x1\n#end of task 1\n```\n\nIn the second code, you seem to have mixed up the update statements, you reassign ```\nx0```\n to itself.\n\n```\ndef fibo(xmax,xmin=0):\n    x0,x1 = 0,1\n    while x0 <= xmax:\n        x0,x1=x1, x1+x0\n        if x0 >= xmin:\n            print x0\nfibo(60,6)\n#end of task 2\n```\n\n\n\nAlso, since you don't return anything, you should not do ```\nprint fibo(60,6)```\n because the implicit return value of ```\nNone```\n gets printed at the end.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Calculating previous number in Fibonacci Sequence\r\n                \r\nGiven a Fibonacci number, n, how can I calculate the previous number in the Fibonacci Sequence?\n    ", "Answer": "\r\nDivide by phi (```\n(1 + sqrt(5)) / 2```\n) and round to nearest integer.\n\nThis works because the Nth Fibonacci number is\n\n```\nFn = (Phi ^ n - Psi ^ n) / (Phi - Psi)\n```\n\n\nwhere ```\nPsi = -1 / Phi```\n. By rearranging the formula and massaging it a bit, you will get that the difference between ```\nF_n+1 / Phi```\n and ```\nF_n```\n is less than ```\nPsi ^ n```\n, and since ```\n| Psi | < 1```\n, rounding to the nearest integer will yield the correct result.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence C program error\r\n                \r\nI am trying to write a program which takes the first 2 numbers of the Fibonacci sequence as input and also the value of ```\nn```\n. Then the program gives the output of the nth digit of the Fibonacci sequence.\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nint main () {\n    int n, i;\n    int s[n - 1];\n    int a, b;   \n\n    printf(\"Enter two first two numbers:\");\n    scanf(\"%d %d\", &a, &b);\n    printf(\"Enter the value of n(3-100):\");\n    scanf(\"%d\", &n);\n\n    for (i = 2; i <= n - 1; i++) {\n        s[i] = s[i - 1] + s[i - 2];\n    }\n\n    printf(\"The nth digit is %d\", s[n - 1]);\n\n    return(0);\n}\n```\n\n\nI am getting the answer number which is followed by some additional arbitrary numbers\n    ", "Answer": "\r\nActually to implement your code there is no need of an array ```\ns[]```\n .\n\nThis can be simply implemented as :-\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int n, i;\n    int a, b;\n\n    printf(\"Enter two first two numbers:\");\n    scanf(\"%d%d\", &a, &b);                      // not scanf(\"%d %d\", &a, &b);\n    printf(\"Enter the value of n(3-100):\");\n    scanf(\"%d\", &n);\n\n    for (i = 1; i < n; i++)\n    {\n        b += a;\n        a = b - a;\n    }\n\n    printf(\"The nth digit is %d\\n\", a);\n\n    return (0);\n}\n```\n\n\nOutput:\n\n```\nEnter two first two numbers:0 1\nEnter the value of n(3-100):5\nThe nth digit is 3                     // 0 1 1 2 3\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Can´t return fibonacci sequence [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Java Program Fibonacci Sequence\r\n                            \r\n                                (15 answers)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI tried to return fibonacci sequence in java, but i have a problem with the values. \n\nExample code.\n\n```\n@Override\npublic int fibonacci(int numero) throws RemoteException {\n    int numero1 = 1;\n    int numero2 = 0;\n    int fibonacci = 0;\n    for (int i = 0; i <= numero; i++) {\n        fibonacci = numero1 + numero2;\n        numero1 = numero2;\n        numero2 = fibonacci;\n        //return \"La serie fibonnaci es:\" + fibonacci;\n    }\n    return fibonacci;\n\n}\n```\n\n\nFibonacci variable return 0 but i need to return a fibonnaci sequence. ¿Any idea?\n    ", "Answer": "\r\nTwo peoposals for your problem:\n\nNumber one: Print on screen\n\n```\npublic static void fibonacci(int numero) {\n    int numero1 = 0;\n    int numero2 = 1;\n    int fibonacci = 0;\n    for (int i = 0; i <= numero; i++) {\n        fibonacci = numero1 + numero2;\n        numero1 = numero2;\n        numero2 = fibonacci;\n        System.out.println(fibonacci);\n    }\n}\n```\n\n\nNumber two (better in my opinion): Return list\n\n```\npublic static List<Integer> fibonacci(int numero) {\n    LinkedList<Integer> fibonacciSequence = new LinkedList<>();\n    int numero1 = 0;\n    int numero2 = 1;\n    int fibonacci = 0;\n    for (int i = 0; i <= numero; i++) {\n        fibonacci = numero1 + numero2;\n        numero1 = numero2;\n        numero2 = fibonacci;\n        fibonacciSequence.add(fibonacci);\n    }\n    return fibonacciSequence;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Negative output in Fibonacci sequence\r\n                \r\nI am getting negative output when adding large numbers in Fibonacci sequence despite using long int. How to fix that?\n\n```\n#include <iostream>\nusing namespace std;\nvoid main() {\n\n    long int sum = 2;\n    long int f1 = 1, f2 = 2, f3;\n    for (unsigned int i = 2; i < 4000000; i++) {\n        f3 = f2 + f1;\n        if (!(f3 % 2)) {\n            sum += f3;\n        }\n        swap(f1, f2);\n        swap(f2, f3);\n    }\n    cout << sum << endl;\n}\n```\n\n\nThe output is -1833689714\n    ", "Answer": "\r\nAs you can see here the 47th Fibonacci Number exceeds the range of a 32Bit/4Byte integer. Everything after that will become negative.\n\nFor your program you used a long int which may or may not be 32 or 64 bits wide, the C++ standard does not guarantee that (for good reasons). If I see your result it seems like 32 Bit for me.\n\nFirst, to prevent negativeness, you could use unsigned long int which makes all your results positive and gives the ability to model \"slightly\" bigger numbers.\n\nHowever you will still get the wrong results if you pass the 47th Fibonacci number since your data type is still too small. To fix this you could use unsigned long long or uint64_t.\n\nRemember even for such big datatypes that can represent numbers up to approx. 18 trillion/quintillion (10^18) the Fibonacci numbers exceed this at the 89th iteration.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence animation\r\n                \r\nI am currently attempting to program the Fibonacci Sequence animation on a HTML5 canvas using JavaScript.\n\nI have calculated the Fibonacci numbers and am able to add the squares to a grid layout. The trouble I am having is being able to calculate the offset so they will automatically fit together side by side nicely. Does anyone have any pointers to how this can be achieved.\n\nhere is my JavaScript Code:\n\n```\nvar canvas;\nvar context;\n\nfunction init(){\n\n    canvas = document.getElementById('canvas');\n    context = canvas.getContext('2d');\n\n    drawgrid();\n    drawlines();\n\n}\n\n\nfunction drawgrid(){\n\n    context.strokeStyle=\"LightGrey\";\n\n    for(var i = 0; i < 600; i+=20){\n\n        context.beginPath();\n        context.moveTo(i, 0);\n        context.lineTo(i, 600);\n        context.stroke();\n\n        context.beginPath();\n        context.moveTo(0, i);\n        context.lineTo(600, i);\n        context.stroke();\n\n    }\n\n}\n\nfunction drawlines(){\n\n    context.strokeStyle=\"blue\";\n    var startLeft = (canvas.width / 2) - 20;\n    var startTop = (canvas.height / 2) - 20;\n\n    var first = 1;\n    var second = 1;\n    var next = 0;\n    var c = 0;\n    var count = 0;\n\n    for (var i = 0; i < 5; i++){\n\n        if ( c <= 1 ){\n\n            next = 1;\n\n        }else{\n\n            next = first + second;\n            first = second;\n            second = next;\n\n        }\n\n        c++;\n        next *= 20;\n\n\n        //This is a minor attempt at offsetting which does not work what so ever\n        switch(count) {\n            case 1:\n                startLeft += next;\n                break;\n            case 2:\n                startTop-=next;\n                break;\n            case 3:\n                startTop -= next - 20;\n                startLeft -= next;\n                break;\n            case 4:\n                startTop += next - 80;\n                startLeft += next - 160;\n                break;\n        }\n\n        context.beginPath();\n        context.rect(startLeft,startTop,next,next);\n        context.stroke();\n\n        count++;\n\n        if (count > 4){\n\n            count = 1;\n\n        }\n\n        startLeft = (canvas.width / 2) - 20;\n        startTop = (canvas.height / 2) - 20;\n\n    }\n\n}\n```\n\n\nJSFiddle: http://jsfiddle.net/schoolboytom/73prkp8L/\n    ", "Answer": "\r\nOne way would be to keep track of all coordinates at all times and increment depending of the orientation of the following square to place. I think your whole structure is ok, but there are some info lacking, mainly keeping bottom and right coordinates.\n\nSomething like this seems to work (I've put increment of 10 to see if the logic was ok, but it should work with any):\n\n```\nfunction drawlines() {\n\n    context.strokeStyle = \"blue\";\n    var curLeft = (canvas.width / 2) - 10;\n    var curTop = (canvas.height / 2) - 10;\n    //You add right and bottom position to help calculate positioning later.\n    var curRight = curLeft + 10;\n    var curBottom = curTop + 10;\n\n    var first = 0;\n    var second = 1;\n    var next = 10;\n    var c = 0;\n    //You draw the first square out of the loop cause it's conditions are\n    //not exactly the same, meaning its positioning is not dependent on previous square\n    context.beginPath();\n    context.rect(curLeft, curTop, next, next);\n    context.stroke();\n\n    for (var i = 1; i <= 9; i++) {\n\n        next = first + second;\n        first = second;\n        second = next;\n\n        next *= 10;\n        //changed this to fetch if square should be added right, top, left or bottom\n        count = i % 4\n\n        //You switch depending on where you're at. Each direction has its increment pattern.\n        //For example to add right you keep bottom, but get current right to get left positioning\n        //and you increment top depending on next value. The structure is \n        //similar to yours but since you now have right and bottom it's \n        //easier to place each square correctly\n        switch (count) {\n            case 0:\n\n                curRight = curLeft + next\n                curLeft = curLeft\n                curTop = curBottom\n                curBottom = curBottom + next\n\n                break;\n            case 1:\n                curLeft = curRight\n                curRight = curRight + next\n                curTop = curBottom - next\n                curBottom = curBottom\n\n                break;\n\n            case 2:\n                curLeft = curRight - next\n                curRight = curRight\n                curBottom = curTop\n                curTop = curBottom - next\n                break;\n            case 3:\n                curRight = curLeft\n                curLeft = curLeft - next\n                curBottom = curTop + next\n                curTop = curTop\n                break;\n        }\n       // the rest is pretty much the same\n        context.beginPath();\n        context.rect(curLeft, curTop, next, next);\n        context.stroke();\n\n        count++;\n\n    }\n\n}\n```\n\n\nSee fiddle: http://jsfiddle.net/a0aLg6Ly/3/\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence c prog\r\n                \r\nI have a problem with C programming. I want to reach large numbers of fibonacci sequence but program, 47 Number of minutes to give the error. Here is the preview.\n\n```\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n4181\n6765\n10946\n17711\n28657\n46368\n75025\n121393\n196418\n317811\n514229\n832040\n1346269\n2178309\n3524578\n5702887\n9227465\n14930352\n24157817\n39088169\n63245986\n102334155\n165580141\n267914296\n433494437\n701408733\n1134903170\n1836311903\n**-1323752223**\n```\n\n    ", "Answer": "\r\nLooks like you rolled over the limit for a 32 bit integer. Try using a 64 bit integer.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in Javascript\r\n                \r\nI am very new to programming in general and am having a hard time understanding this Fibonacci sequence example:\n\n```\nvar fib = [0, 1];\nfor (var i = 2; i < n; i++) {\n    fib[ i ] = fib[ i - 1 ] + fib[ i - 2 ];\n    console.log(fib);\n}\n```\n\n\nOn the first iteration, index 2 is equal to 1, simple enough. But, when I try the second iteration with i = 3, I get: \n\n```\nfib[ 3 ] = fib[ 3 - 1 ] + fib[ 3 - 2 ];  \nfib[ 3 ] = fib[ 2 ] + fib[ 1 ]; \nfib[ 3 ] = fib[ 3 ];\n```\n\n\nWhere am I going wrong with my thinking? So far I have:\n\n```\nvar fib = [0,1,1,3]\n```\n\n\nwhich I know is not correct.\n    ", "Answer": "\r\nWhen you are reasoning about the code, you make the jump from ```\nfib[3] = fib[2] + fib[1]```\n to ```\nfib[3] = fib[3]```\n. This happens to be a transformation that results in a correct statement, but it is not how it works. This code is adding the value at index ```\n2```\n to the value at index ```\n1```\n. That is not the same as taking the value at index ```\n3```\n. The way this reasoning should work is as follows:\n\nYou start with ```\nfib = [0, 1]```\n. Then in the first iteration of the loop you have ```\nfib[2] = fib[1] + fib[0]```\n. This means that you add the value at index ```\n0```\n (which happens to be ```\n0```\n) to the value at index ```\n1```\n (which happens to be ```\n1```\n) to get the value that you put at the end of the array (```\n1```\n). Then in the second iteration, you do a similar thing, adding the value at index ```\n1```\n (still ```\n1```\n) to the value at index ```\n2```\n (also ```\n1```\n) to get ```\n2```\n, which goes at the end of the array. This continues, and at each iteration you add together the last two values in the array to get the next value.\n\nIn JavaScript, when using an array like ```\nfib```\n, ```\nfib[i]```\n refers to the ```\ni```\nth value in this array, counting from ```\n0```\n. So ```\nfib[0]```\n is the first element in the array, ```\nfib[1]```\n is the second element in the array, and so on.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "powershell Fibonacci sequence stops early\r\n                \r\nwhen i enter 55 i want the function to print the fibonacci sequence 55 times but the sequence stops at 55\n\n```\nfunction Get-Fibonacci ($n) {\n    $current = 0 ; \n    $previous = 1; \n    while ($current -lt $n) { \n        $current; \n        $current,$previous = ($current+$previous),$current\n    }\n}\n```\n\n    ", "Answer": "\r\n```\nfunction Get-Fibonacci ($n) {\n    $current = 0 ; \n    $previous = 1; \n    for ($i=0; $i -lt $n; $i++) {\n        $current; \n        $current,$previous = ($current+$previous),$current\n    }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence in R\r\n                \r\nI am a new R user and have very limited programming experience, hence my question and poorly written code.\n\nI was assigned a problem where I had to use a while loop to generate the numbers of the Fibonacci sequence that are less than 4,000,000 (the Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones).\n\nNext, I had to compute the sum of the even numbers in the sequence that was generated.\n\nI was successful with my response, however, I don't think the code is written very well. What could I have done better?\n\n```\n> x <- 0\n> y <- 1\n> z <- 0\nif (x == 0 & y == 1) {\n  cat(x)\n  cat(\" \")\n  cat(y)\n  cat(\" \")\n    while (x < 4000000 & y < 4000000) {\n    x <- x + y\n    cat(x)\n    cat(\" \")\n    if (x %% 2 == 0) {\n        z <- x + z\n    }\n    y <- x + y\n    cat(y)\n    cat(\" \")\n    if (y %% 2 == 0) {\n        z <- y + z\n    }\n  }\n}\n```\n\n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465\n\n```\ncat(z)\n```\n\n\n4613732\n    ", "Answer": "\r\nFirst of all, ```\ncat```\n comes with a ```\nsep```\n argument. You can do ```\ncat(x, y, sep = \" \")```\n rather than using 3 lines for that. \n\nSecondly, when you call ```\nwhile (x < 4000000 & y < 4000000)```\n note that ```\ny```\n will always be greater than ```\nx```\n because it is the sum of the last ```\nx```\n and ```\ny```\n ... so it should suffice to check for ```\ny < 4000000```\n here.\n\nFor the while loop, you could also use a counter - might be more intuitive. Indexing in R isn't that fast though\n\n```\nfib <- c(0, 1)\ni <- 2\nwhile (fib[i] < 4000000) {\n  fib <- c(fib, fib[i-1] + fib[i])\n  i <- i + 1\n}\n\nsum(fib[fib %% 2 == 0]) \n```\n\n\nIf you don't necessarily need the ```\nwhile```\n, you could also approach it via recursion\n\n```\nfib <- function(x, y) {\n  s <- x + y\n  c(s, if (s < 4000000) fib(y, s))\n}\n\nf <- fib(0, 1)\nsum(f[f %% 2 == 0])\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Pascal's triangle and Fibonacci sequence explanation\r\n                \r\nOkay I need to redraw the pascal's triangle and explain the Fibonacci sequence embedded in it.. And i need to observe over 12 rows of the triangle (which ends on the number 144 in the fibonacci sequence)  -- I understand this part as i am just explaining how each row diagonally forms the sum of the Fibonacci numbers. \n\nBut I need to use the fact that the rth number in the nth row of the triangle is \nC(n, r) = n!/r! n-r!\n\nThis last part is whats confusing me.. How can i use C(n,r) to explain the Fibonacci sequence in the triangle??\n\nPlease Help. Thanks \n    ", "Answer": "\r\nConsider the following problem : \n\nIn how many ways can you go up a ladder of n steps if you can take either a single step at a time or 2 steps at a time?\n\nSolution 1 : Let's construct a recurrence relation for this problem. It's pretty clear that the recurrence would be something like this : ```\na(n) = a(n-1) + a(n-2);```\n where ```\na(1)=1```\n and ```\na(2)=2```\n\nThus, the answer for ```\nn```\n would be the ```\n(n+1)th```\n fibonacci term.\n\nSolution 2 : Each unique way of climbing up the ladder corresponds to a unique sequence of 1's and 2's which adds up to n. The number of such sequences thus would be our answer. Let's start counting such sequences :\n\nNumber of sequences without a 2 = ```\n$ {n \\choose 0 } $```\n.\nNumber of sequences with one 2 = ```\n$ {n-1 \\choose 1 } $```\n.  \n\n.\n.\n.\nand so on.\nIn case of even n, the last term would be ```\n$ {n/2 \\choose n/2 }  $```\n.\nAnd for odd n, it would be ```\n$ {(n+1)/2 \\choose (n-1)/2 } $```\n.\nAs you can see, These are the diagonal terms in a pascal's triangle.  \n\nAs these two solutions compute the same result, hence they must be equal. Thus we get the relation between Fibonacci numbers and the diagonals of a pascals triangle.\n\nRefer the link \nhttp://ms.appliedprobability.org/data/files/Articles%2033/33-1-5.pdf\nfor anymore doubts.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Parallelize Fibonacci sequence generator\r\n                \r\nI'm learning about parallelization and in one exercise I'm given a couple of algorithms that I should improve in performance. One of them is a Fibonacci sequence generator:\n\n```\narray[0] = 0;\narray[1] = 1;\nfor (q = 2; q < MAX; q++) {\n    array[q] = array[q−1] + array[q−2];\n}\n```\n\n\nMy suspicion is, that this cannot be optimized (by parallelization), since every number depends on the two preceding numbers (and therefore indirectly on all preceding numbers). How could this be parallelized?\n    ", "Answer": "\r\nThe Fibonacci sequence is determined just by its first two elements; in fact, you could somehow parallelize it, although ugly:\n\n```\nF(n + 2) = F(n + 1) + F(n)\nF(n + 3) = F(n + 1) + F(n + 2) = F(n + 1) * 2 + F(n)\nF(n + 4) = F(n + 2) + F(n + 3) = F(n + 1) * 3 + F(n) * 2\nF(n + 5) = F(n + 3) + F(n + 4) = F(n + 1) * 5 + F(n) * 3\nF(n + 6) = F(n + 4) + F(n + 5) = F(n + 1) * 8 + F(n) * 5\n```\n\n\nHopefully by now, you can see that:\n\n```\nF(n + k) = F(n + 1) * F(K) + F(n) * F(k - 1)\n```\n\n\nSo after computing the first k numbers, you could use this relation to compute the next k items in the sequence, at the same time, parallelized.\n\nYou could also use the direct formula for Fibonacci numbers to compute them in parallel, but that is kind of too uncool (also might be too simple for learning purposes that it might serve).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Creating a Fibonacci sequence function in Python 3\r\n                \r\nI am trying to create a function that prints a list of the first 4 numbers in the Fibonacci sequence, the first 10 numbers in the Fibonacci sequence, and then \"the first -4\" numbers in the Fibonacci sequence. The \"-4\" numbers in the Fibonacci sequence should return an empty list because there is no \"-4\" numbers in the sequence. I need the function to print the 3 lists as an end result in the main() function. Here is my code so far, I'm new to functions so any help would be appreciated.\n\n```\nfn = []\n\ndef F(n):\n    i = 0\n    a = 0\n    b = 1\n    for i in range(0,n):\n        temp = a\n        a = b\n        b = temp + b\n    fn.append(b)\n    i = i + 1\n    return fn\n\n\nmain():\n    print F(4)\n    print F(10)\n    print F(-4)\n```\n\n    ", "Answer": "\r\nYour function for generating Fibonacci numbers is correct except the global variable ```\nfn = []```\n should be declared within the function body. Also, as suggested in the comment by @alfasin, ```\na, b = b, a + b```\n is more Pythonic.\n\n```\ndef fib_list(n):\n    a = 0; b = 1; fib_list = []\n    if n <= 0:\n        return \n    for i in range(0, n):\n        a, b = b, a + b\n        fib_list.append(b)\n    return fib_list\n```\n\n\nThe other problems I could find with your code:\n*  ```\nprint```\n is not a statement in Python 3.x.x, it is a function instead, i.e. ```\nprint F(4)```\n should be ```\nprint(F(4))```\n\n* ```\nmain():```\n should be changed to ```\nif __name__ == '__main__':```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence in C\r\n                \r\nThis is the expected output:\n\n\n\n\nWe are to make a C program that calculates for the Fibonacci Sequence.\nWe're only allowed up to 3 variables and we're NOT allowed to use loops.\nAnd I don't know what to do and how to start.\n\nI hope you guys can help me. :/\n    ", "Answer": "\r\nOn the assumption that you are using 32 bit unsigned integers, the 48th Fibonacci number will cause an integer overflow.  That makes it perfectly feasible to use a lookup table with all the values precalculated (by hand).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence python\r\n                \r\nI am trying to understand Python, but I still don't get it. I am new to the language, and wants to understand it properly.\nThis is a line from a Fibonacci sequence using loops. Please explain the meaning of this code. I am trying to get the pattern by hand. I got the pattern up to 3, but after 3 I am not getting the answer.\n\n```\na, b = 0, 1\nwhile b < 50:\n    print(b)\n    a, b = b, a + b\n```\n\n    ", "Answer": "\r\n```\na, b = b, a + b\n```\n\n\nThis is known as multiple assignment. It's basically an atomic version of:\n\n```\na = b\nb = a + b\n```\n\n\nBy atomic, I mean everything on the right is calculated before pacing it into the variables on the left. So ```\na```\n becomes ```\nb```\n and ```\nb```\n becomes the old version of ```\na```\n plus ```\nb```\n, equivalent to the non-atomic:\n\n```\nold_a = a\na = b\nb = old_a + b\n```\n\n\nSo, in terms of what you see:\n\n```\n        a                        b               output\n================    =========================    ======\n(initial values)        (initial values)\n        0                        1                  1\n(becomes prev b)    (becomes sum of prev a,b)\n        1                        1                  1\n        1                        2                  2\n        2                        3                  3\n        3                        5                  5\n        5                        8                  8\n```\n\n\nThat exact code (along with the explanation of multiple assignment) can be found here in the tutorial.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence in c++ [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI just start to learn programming and here is a problem about fibonacci sequence:\n\nIt is asked to make a function with parameter k(means k-order of fibonacci) and parameter n(means the n th member of sequence) and use that function to get the m th member of a k-order sequence.\n\n```\nf0 = 0, f1 =0, ....fk-2 =0, fk-1=1;\nwhen n=k, k+1,...\nfn= fn-1+fn-2+....+fn-k;     n=k,k+1,....\n```\n\n\n(letters and numbers on right-side of f are subscripts which mean the n th member, n-1 th member..) \n\nfollowing is my code:\n\n```\nint Fibonacci(int k, int n){\nint result=0;\nif (n==k-1) return 1;\nif (n<k-1) return 0;\nif (n>=k){\n    for(int i=n-1; i>i-k-1;--i){\n        result+=Fibonacci(k,i);\n        cout<<result<<endl;\n    }\nreturn result;\n}\n```\n\n\n}\n\n\n\nnew version \n\n```\nint result=0;\nint Fibonacci(int k, int n){\nif (n==k-1) return 1;\nif (n<k-1) return 0;\nif (n>=k){\n    for(int i=n-1; i>n-k-1;--i){\n        result+=Fibonacci(k,i);\n        cout<<result<<endl;\n    }\nreturn result;\n}\n}\n```\n\n\n\n\nmy question is why this code cannot come out correct answer? there should be some problems in the loop but I cannot find them. Will someone help me?\n    ", "Answer": "\r\n```\nfor(int i=n-1; i>i-k-1;--i)\n```\n\n\n```\ni```\n will pretty much always be greater than ```\ni-k-1```\n\n\nMaybe you mean ```\nfor(int i=n-1; i>n-k-1;--i)```\n, but you should check.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "The space complexity of Fibonacci Sequence\r\n                \r\nI saw some textbook about the worst-case space complexity of Fibonacci Sequence. However, I have the following question:\n\n\n    ", "Answer": "\r\nYou can start with a concrete example and generalize. Start with n = 5.\n\n```\nS(5) = S(4) + c\n     = (S(3) + c) + c\n     = ((S(2) + c) + c) + c\n     = (((S(1) + c) + c) + c) + c\n\n     = S(1) + 4c\n```\n\n\nThere are 4 c's when n = 5. In general, there are n-1 c's.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Java Fibonacci Sequence fast method\r\n                \r\nI need a task about finding Fibonacci Sequence for my independent project in Java. Here are methods for find.\n\n```\nprivate static long getFibonacci(int n) {\n    switch (n) {\n        case 0:\n            return 0;\n        case 1:\n            return 1;\n        default:\n            return (getFibonacci(n-1)+getFibonacci(n-2));\n    }\n}\n\nprivate static long getFibonacciSum(int n) {\n    long result = 0;\n\n    while(n >= 0) {\n        result += getFibonacci(n);\n        n--;\n    }\n    return result;\n}\n\nprivate static boolean isInFibonacci(long n) {\n    long a = 0, b = 1, c = 0;\n\n    while (c < n) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n\n    return c == n;\n}\n```\n\n\nHere is main method:\n\n```\n    long key = getFibonacciSum(n);\n    System.out.println(\"Sum of all Fibonacci Numbers until Fibonacci[n]: \"+key);\n\n    System.out.println(getFibonacci(n)+\" is Fibonacci[n]\");\n\n    System.out.println(\"Is n2 in Fibonacci Sequence ?: \"+isInFibonacci(n2));\n```\n\n\nCodes are completely done and working. But if the n or n2 will be more than normal (50th numbers in Fib. Seq.) ? Codes will be runout. Are there any suggestions ?\n    ", "Answer": "\r\nThere is a way to calculate Fibonacci numbers instantaneously by using Binet's Formula\n\nAlgorithm:\n\n```\nfunction fib(n):\n   root5 = squareroot(5)\n   gr = (1 + root5) / 2\n   igr = 1 - gr\n   value = (power(gr, n) - power(igr, n)) / root5\n\n   // round it to the closest integer since floating \n   // point arithmetic cannot be trusted to give\n   // perfect integer answers. \n   return floor(value + 0.5) \n```\n\n\nOnce you do this, you need to be aware of the programming language you're using and how it behaves. This will probably return a floating point decimal type, whereas integers are probably desired.\n\n\n  The complexity of this solution is O(1).\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence using codelab\r\n                \r\nIn the following sequence, each number (except the first two) is the sum of the previous two number: 0, 1, 1, 2, 3, 5, 8, 13, .... This sequence is known as the Fibonacci sequence.\n\nGiven the positive integers m and n (with m < n) create a list consisting of the portion of the Fibonacci sequence greater than or equal to m and less than or equal to n. For example, if m is 3 and n is 6, then the list would be [3, 5] and if m is 2 and n is 20, then the list would be [2, 3, 5, 8, 13].\n\nAssociate the list with the variable fib.\n\nHave done this far, but still getting error.\nWhere does it need to be fixed?\n\n```\nfib = [0,1,1]\nresult = 0\nwhile result <=n:\n    result=fib[-1]+fib[-2]\n    if result <=n and result>=m:\n        fib.append(result)\n```\n\n    ", "Answer": "\r\n```\n# create a fibonacci series from 0 to n\nf = [0,1]\nfor i in range(1, n+1):\n    x = f[i]+f[i-1]\n    if x > n:\n       break\n    else:\n        f.append(x)\n# copy only those numbers of series that are in range m to n\nfib = []\nfor i in range(0, len(f)):\n    if f[i] >= m and f[i] <= n:\n        fib.append(f[i])\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generating Pythagorean Triples using Fibonacci Sequence\r\n                \r\nI'm using the Fibonacci sequence to generate some pythagorean triples (3, 4, 5, etc) based off  this page: http://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples starting at \"Generalized Fibonacci Sequence\".\n\n```\npublic static int fib(int n) {\n        if(n == 0) return 0;\n        if(n <= 2) return 1;\n        int i = 1;\n        int temp = 0;\n\n        while(n != 1) {\n            i += temp;\n            temp = i - temp;\n            n--;\n        }\n\n        return i;\n    }\n\n    public static void main(String[] args) {\n        int a = 4; //a(3)\n        int b = 3; //b(3)\n        int c = 5; //c(3)\n\n        for(int n = 4; n < 10; n++) {\n            System.out.println(a + \"^2 + \" + b + \"^2 = \" + c + \"^2\");\n            a = a + b + c;\n            b = fib((2 * n) - 1) - b;\n            c = fib(2 * n);\n        }  \n    } \n```\n\n\nHowever, the output my program is giving me is not accurate:\n\n```\n4^2 + 3^2 = 5^2\n12^2 + 10^2 = 21^2\n43^2 + 24^2 = 55^2\n122^2 + 65^2 = 144^2\n331^2 + 168^2 = 377^2\n876^2 + 442^2 = 987^2\n```\n\n\nWhat could be causing this problem? Have I been duped by Wikipedia?\n    ", "Answer": "\r\n@MarkDickinson pointed out that the formula required F(1) = 0 and F(2) = 1, which is different from what is widely used, where F(1) = 1 and F(2) = 1. That fixed my problem!\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursion vs. Iteration (Fibonacci sequence)\r\n                \r\nI've got two different methods, one is calculating Fibonacci sequence to the nth element by using iteration and the other one is doing the same thing using recursive method.\n\n\n\nProgram example looks like this:\n\n```\nimport java.util.Scanner;\n\npublic class recursionVsIteration {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        //nth element input\n        System.out.print(\"Enter the last element of Fibonacci sequence: \");\n        int n = sc.nextInt();\n\n        //Print out iteration method\n        System.out.println(\"Fibonacci iteration:\");\n        long start = System.currentTimeMillis();\n        System.out.printf(\"Fibonacci sequence(element at index %d) = %d \\n\", n, fibIteration(n));\n        System.out.printf(\"Time: %d ms\\n\", System.currentTimeMillis() - start);\n\n        //Print out recursive method\n        System.out.println(\"Fibonacci recursion:\");\n        start = System.currentTimeMillis();\n        System.out.printf(\"Fibonacci sequence(element at index %d) = %d \\n\", n, fibRecursion(n));\n        System.out.printf(\"Time: %d ms\\n\", System.currentTimeMillis() - start);\n    }\n\n    //Iteration method\n    static int fibIteration(int n) {\n        int x = 0, y = 1, z = 1;\n        for (int i = 0; i < n; i++) {\n            x = y;\n            y = z;\n            z = x + y;\n        }\n        return x;\n    }\n\n    //Recursive method\n    static int fibRecursion(int  n) {\n        if ((n == 1) || (n == 0)) {\n            return n;\n        }\n        return fibRecursion(n - 1) + fibRecursion(n - 2);\n    }\n}\n```\n\n\n\n\nI was trying to find out which method is faster. I came to the conclusion that recursion is faster for the smaller amount of numbers, but as the value of nth element increases recursion becomes slower and iteration becomes faster. Here are the three different results for three different n:\n\n\n\nExample #1 (n = 10)\n\n```\nEnter the last element of Fibonacci sequence: 10\nFibonacci iteration:\nFibonacci sequence(element at index 10) = 55 \nTime: 5 ms\nFibonacci recursion:\nFibonacci sequence(element at index 10) = 55 \nTime: 0 ms\n```\n\n\n\n\nExample #2 (n = 20)\n\n```\nEnter the last element of Fibonacci sequence: 20\nFibonacci iteration:\nFibonacci sequence(element at index 20) = 6765 \nTime: 4 ms\nFibonacci recursion:\nFibonacci sequence(element at index 20) = 6765 \nTime: 2 ms\n```\n\n\n\n\nExample #3 (n = 30)\n\n```\nEnter the last element of Fibonacci sequence: 30\nFibonacci iteration:\nFibonacci sequence(element at index 30) = 832040\nTime: 4 ms\nFibonacci recursion:\nFibonacci sequence(element at index 30) = 832040\nTime: 15 ms\n```\n\n\n\n\nWhat I really want to know is why all of a sudden iteration became faster and recursion became slower. I'm sorry if I missed some obvious answer to this question, but I'm still new to the programming, I really don't understand what's going on behind that and I would like to know. Please provide a good explanation or point me in the right direction so I can find out the answer myself. Also, if this is not a good way to test which method is faster let me know and suggest me different method.\n\nThanks in advance!\n    ", "Answer": "\r\nFor terseness, Let F(x) be the recursive Fibonacci \n\n```\nF(10) = F(9)                      + F(8)\nF(10) = F(8)        + F(7)        + F(7) + F(6)\nF(10) = F(7) + F(6) + F(6) + F(5) + 4 more calls.\n....\n```\n\n\nSo your are calling F(8) twice,\nF(7) 3 times, F(6) 5 times, F(5) 7 times.. and so on\n\nSo with larger inputs, the tree gets bigger and bigger.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursion in bash(fibonacci sequence)\r\n                \r\nThe main problem my code doesn't do echo every time(fibonacci sequence)\n```\n#!/bin/bash\n\nfunction fib(){\n        if [ $1 -le 0 ]; then\n                echo 0\n        elif [ $1 -eq 1 ]; then\n                echo 1\n        else\n                echo $[`fib $[$1 - 2]` + `fib $[$1 - 1]` ]\n        fi\n}\n\nfib $1\n```\n\ni was expecting it will do echo every time. It shows:\n```\n~/Bash$ ./fn.sh 12\n144\n```\n\nbut i need it to show like this:\n```\n~/Bash$ ./fn.sh 12\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n```\n\n    ", "Answer": "\r\nYour function is consuming the output of its invocation via backticks (command substitution). Only the last output is sent to the terminal. Your function will only return the n-th number of the Fibonacci sequence.\nIf you want to return all the numbers of the sequence up to a certain point, you can use a loop:\n```\nfor i in $(seq \"$i\"); do\n  fib \"$i\"\ndone\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python Fibonacci sequence error\r\n                \r\nthis was one of the problems I was assigned in MyProgrammingLab. I've attempted to answer this problem over 45 times, but can't get it right. \nAny help will be appreciated\n\nQuestion:\nIn the following sequence, each number (except the first two) is the sum of the previous two numbers: 0, 1, 1, 2, 3, 5, 8, 13, .... This sequence is known as the Fibonacci sequence.\n\nWe speak of the i'th element of the sequence (starting at 0)-- thus the 0th element is 0, the 1st element is 1, the 2nd element is 1, the 3rd element is 2 and so on. Given the positive integer n, associate the nth value of the fibonacci sequence with the variable  result. For example, if n is associated with the value 8 then result would be associated with 21.\n\nMy work:\n\n```\ndef fib(n):\n    if n <= 1:\n        result == n\n    elif n >= 1:\n        result = fib(n-1)+fib(n-2)\n    else:\n        return result\n```\n\n    ", "Answer": "\r\nIt's because in all of your cases, you assign the result but don't return it. \n\nSo, for example, when ```\nfib(1)```\n is called, Python returns ```\nNone```\n because you never told it to return ```\nresult```\n in that case. The same thing happens for, say, ```\nfib(45)```\n.\n\nTo correct this, just return ```\nresult```\n always. (This is a good idea no matter what type of program you are writing - functions should always have an explicit return value).\n\n```\ndef fib(n):\n    if n <= 1:\n        result = n\n    elif n > 1:\n        result = fib(n-1)+fib(n-2)\n    return result # always return result!\n```\n\n\nThings to Know\n\n\nYou should be aware that this implementation of the Fibonacci sequence is the least efficient one out there. If you can ditch the recursive calls altogether and just use a ```\nwhile```\n loop to calculate ```\nfib(n)```\n - or, if you want recursion, store previously computed values of ```\nfib(n)```\n instead of forcing it to compute all the way to ```\nfib(n)```\n - you will have a much more efficient implementation.\nYour code contained numerous issues, such as\n\n\nAssigning without returning, which we've already discussed.\nUsing ```\n==```\n instead of ```\n=```\n. The first checks if the left and right  hand side are equal, and returns ```\nTrue```\n or ```\nFalse```\n. The second actually assigns the value of the right hand side to the variable on the left hand side. Don't confuse checking for equality with assignment.\nUsing the same base case twice but telling Python to do something different in both cases. This is such a bad idea that I feel jonrsharpe in the comments is justified in saying \"Seriously?\". The reason for this is because doing this makes no sense and makes it hard to predict behaviour. The whole point of an ```\nif-else```\n statement is to do different things in different cases. \nEdit based on examples provided by OP. Indentation should only be four spaces, not eight. This is more of a stylistic issue than anything else, but it is the standard.\n\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence listing numbers upto integer\r\n                \r\n```\n<h2>Fibonacci</h2>\n        <form method=\"$_GET\" action=\"Wk4.php\">\n            <fieldset>\n\n                <label for=\"Number\">Fibonacci: </label>\n                <input type=\"text\" name=\"Number\" value=\"<?php echo $_GET['powerof']; ?>\"/>\n                <input type=\"submit\" name='Go' value=\"Calculate\" />\n            </fieldset>\n        </form>\n\n        <?php\n$message = 'The fibonacci sequence is: <br />1<br />2<br />';\n$powerof = 0;\n$max = 10;\n$temp = $max;\n\nif(isset($_GET['Go'])) {\n    $powerof = $_GET['Go'];}else{$powerof = 2;\n}\n\nif($powerof > 100) {\n    $powerof = 100;\n    $message = 'Sorry, your input was too high. I converted it to the maximum value of 100.<br />The fibonacci sequence is: <br />1<br />2<br />';\n}\n\n$i = 1;\n\nfor($i;$i<$powerof;$i++){\n    $max = $max * $temp;\n}\n\n$x = 1;\n$y = 2;\n$z = $x + $y;\n\necho($message);\n\nwhile($z < $max) {\n\n    $z = $x + $y; \n    echo($z.\"<br />\"); \n    $x = $y;\n    $y = $z;\n}\n    ?>\n```\n\n\n\n\n\nim trying to create a mechanism that allows me to enter an integer into the text box then once i hit the button it is returned listing all the fibonacci sequence up ton  that number.\n    ", "Answer": "\r\nPretty sure now my comment should be an answer, so here it is.  Couple of issues here:\n\n1) ```\n$_GET```\n is not a valid HTTP verb. Valid values* of the method attribute of a form are one of ```\nget```\n, ```\npost```\n, ```\nput```\n, ```\ndelete```\n, and ```\n'dialog'```\n (HTML5+) (all case insensitive).\n\n\nSince the default value for the ```\nmethod```\n attribute is ```\nget```\n for both empty an ```\nmethod```\n attribute as well as when it is provided an invalid value, leaving it as is may still work, but it is not standard and how browsers behave when they see that may not be what you expect.\n\n\n2) I believe your main problem is how you're trying to retrieve the input after the form submission.  You named your input as ```\npowerof```\n in this line:\n\n```\n<input type=\"text\" name=\"powerof\" value=\"<?php echo $_GET['powerof']; ?>\"/>\n```\n\n\nTherefore you should change this:\n\n```\nif(isset($_GET['Go'])) {\n    $powerof = $_GET['Go'];}else{$powerof = 2;\n}\n```\n\n\nTo this:\n\n```\nif(isset($_GET['powerof'])) {\n    $powerof = $_GET['powerof'];}else{$powerof = 2;\n}\n```\n\n\nUpdate\n\nFrom your comments, I don't think you're exactly answering the question correctly for the interview.  Also, if the user enters 1 or 2, you're not going to return the correct value. (The fibonacci sequence begins as 1, 1, 2, 3, 5, 8**, ..., so input of 2 should return 1).\n\nTry changing your while loop to look like this:\n\n```\n$x = 0;\n$y = 1;\n$z = 0;\n$counter = 0;\n\nwhile($counter < $powerof) {\n    if($counter <= 1) {\n        $z = 1;\n    } else {\n        $z = $x + $y;\n    }\n    $x = $y;\n    $y = $z;\n    $counter++;\n}\n\necho 'Ouput: ' . $z . \"<br>\";\n```\n\n\n* According to this, only ```\nget```\n and ```\npost```\n were standardized in HTML v4, but today all of the others are supported by all the major browsers. Interested readers may find the bug submission regarding the HTML v5 standard related to this issue.. interesting.  Also, according to the HTML5 standard, a value of ```\n'dialog'```\n is also supported.\n\n** According to Wikipedia, there's not a 'standard' starting point of the sequence (should 0 be considered a fibonacci number or not?).  According to this answer, using 0 as the starting point is known as the 'classical' definition, but using 1 as the starting point is known as the 'combinatorial' definition. You might get bonus points in the interview if you bring that up.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Creating fibonacci sequence generator (Beginner Python)\r\n                \r\nHi I'm trying to create a Fibonacci sequence generator in Python. This is my code:\n\n```\nd =raw_input(\"How many numbers would you like to display\")\n\na = 1\nb = 1\n\nprint a\nprint b\n\nfor d in range(d):\n    c = a + b \n    print c\n    a = b\n    b = c\n```\n\n\nWhen I ran this program, I get the error:\n\n```\nFile \"Fibonacci Sequence Gen.py\", line 10, in <module>\n    for d in range(d):\nTypeError: range() integer end argument expected, got str\n```\n\n\nThanks for your help, I'm trying to teach myself python with basic projects. \n    ", "Answer": "\r\nraw_input returns a string. So convert d to an integer with:\n\n```\nd = int(d)\n```\n\n\nOne more thing: Do not use ```\nfor d in range(d)```\n. It works but it is awful, unpythonic, whatever.\nTry this way for example:\n\n```\nnumbers = raw_input(\"How many numbers would you like to display\")\n\na = 1\nb = 1\n\nprint a\nprint b\n\nfor d in range(int(numbers)):\n    c = a + b \n    print c\n    a = b\n    b = c\n```\n\n\nEdit: I complete below the answer with additional code tuning (thanks to commenters):\n\n```\n# one space will separate better visually question and entry in console\nnumbers = raw_input(\"How many numbers would you like to display > \")    \n\n# I personnally prefer this here, although you could put it\n# as above as `range(int(numbers))` or in `int(raw_input())`\n# In a robust program you should use try/except to catch wrong entries\n# Note the number you enter should be > 2: you print 0,1 by default\nnumbers = int(numbers)  \n\na, b = 0, 1        # tuple assignation\n                   # note fibonnaci is 0,1,1,2,3...\n\nprint a            # you can write this as print \"%i\\n%i\" % (a, b)\nprint b            # but I think several prints look better in this particular case.\n\nfor d in range(numbers - 2):  # you already printed 2 numbers, now print 2 less\n    c = a + b \n    print c\n    a, b = b, c    # value swapping.\n                   # A sorter alternative for this three lines would be:\n                   # `a, b = b, a + b`\n                   # `print b` \n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Hmmm Assembly Fibonacci Sequence\r\n                \r\nI need to write and print out the Fibonacci sequence up to a given integer (can choose yourself)\nI have to do this in Hmmm... Assembly\nIt gets stuck in infinite recursion, but I have no idea why\n```\n00 read r4          # User input\n01 setn r4 -1       # adds -1 to r4\n02 setn r1 1        # r1 == 1\n03 setn r2 0        # r2 == 0\n04 setn r5 1        # used as the first number of the fibonacci sequence\n05 write r5         # 1\n06 jeqzn r4 13      # if r4 == 0, the fibonacci sequence stops\n07 add r3 r1 r2     # r3 = r1 + r2\n08 addn r4 -1       # r4 = r4 -1 \n09 copy r2 r1       # r2 now equals r1\n10 copy r1 r3       # r1 nog equals r3\n11 write r3         # prints fibonacci number\n12 jumpn 06         # checks if r4 == 0\n13 halt             # stops\n```\n\ncurrent output:\n```\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n..\n..\n```\n\nWanted output (example): if input (r4) = 10\n```\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n```\n\n08 addn r4 -1 (r4 should eventually end up being 0)\n06 jeqzn r4 13 (should check when it's true, and it should halt)\nWhat prevents it from halting?\n    ", "Answer": "\r\nLooks like line 1 sets ```\nr4```\n (the input) to -1 instead of the desired subtracting 1, so it should be ```\naddn r4 -1```\n.\nIt's also worth noting the current implementation is iterative and not recursive, and the loop doesn't appear to be infinite but just really long as it would have to count down from -1 to wrap around to 0 (assuming ```\naddn```\n does not saturate).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence in tuple Python\r\n                \r\nTo be writing a make_fibonacci that accepts a parameter n which generates and returns a tuple containing the first n+1 terms of the fibonacci sequence, where n>= 0. From the other questions here, \n\n```\ndef make_fibonacci(n):\n    a, b = 0, 1\n    for i in range(d):\n        a, b = b, a+b\n```\n\n\nbut since I need the range of the fibonacci in a tuple, like \n\n```\nmake_fibonacci(10)  \n>>> (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)\n```\n\n\nThanks a lot!\n    ", "Answer": "\r\nhere's a naive solution, construct as a list and return a tuple\n\n```\ndef make_fibonacci(n):\n    a = [0, 1]\n    [a.append(a[-1]+a[-2]) for i in xrange(n)]\n    return tuple(a)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence has a negative number [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Often big numbers become negative\r\n                            \r\n                                (4 answers)\r\n                            \r\n                    \r\n                Closed 2 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have this code for fibonacci sequence :\n```\npublic class Fibonacci {\n    private List<Integer> fibonacci;\n\n    public void fillFibonacci(){\n        fibonacci = new ArrayList<>();\n        int n1 = 1 , n2 = 1 , n3;\n        fibonacci.add(n1);\n        fibonacci.add(n2);\n        for(int i = 2 ; i < 4000 ; i ++){\n            n3 = n1 + n2;\n            fibonacci.add(n3);\n            n1=n2;\n            n2=n3;\n        }\n    }\n\n    public void printFibonacci(){\n        for(int i = 0 ; i < fibonacci.size() ; i ++){\n            System.out.print(fibonacci.get(i) + \" \");\n            System.out.println(i);\n        }\n    }\n}\n```\n\nthis code show negative number what's wrong with it?\n    ", "Answer": "\r\nYou cannot go up to index= 4000 in this loop, you have integer overflowed. Maximum you can go to is 49. Change the loop as such.\n```\nfor(int i = 2 ; i < 49 ; i ++){\n            n3 = n1 + n2;\n            fibonacci.add(n3);\n            n1=n2;\n            n2=n3;\n        }\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Lazy Fibonacci Sequence in Ruby\r\n                \r\nComing from Python if I wanted to create an iterative lazy Fibonacci sequence, I could do something like this:\n\n```\ndef fib():\n    a = 1\n    b = 2\n    yield a\n    yield b\n    while True:\n        yield a + b\n        tmp = a\n        a = b\n        b = tmp + b\n```\n\n\nGrabbing ```\nnext(fib)```\n  will give me the next element in the sequence by simply adding the previous two elements, so if I want to get the first 1000 Fibonacci elements, I can do that quickly:  \n\n```\nfib = fib()\nfor i in range(0,1000):\n    print(next(fib))  \n```\n\n\nIf I try to reproduce that in Ruby with an Enumerator, it quickly chokes, recalculating the entire sequence each time we call fib.next():  \n\n```\ndef fib()\n    Enumerator.new do |yielder|\n        yielder << 1 << 2\n        fib.lazy.zip(fib.lazy.drop(1)).each do |a,b|\n            yielder << a + b\n        end\n    end\nend  \n```\n\n\nI found another SO post on how to fix a recursive fibonacci with memoization in Ruby, but I am curious, are lazy sequences and generators a thing in Ruby?\n    ", "Answer": "\r\nDon't use recursive enumerators but do it like in Python? With a loop?\n\n```\ndef fib()\n  Enumerator.new do |yielder|\n    a, b = 1, 2\n    yielder << a << b\n    loop do\n      a, b = b, a + b\n      yielder << b\n    end\n  end\nend  \n```\n\n\nWhat you did there in Ruby looks in Python like this:\n\n```\ndef fib():\n    yield from (1, 2)\n    for a, b in zip(fib(), islice(fib(), 1, None)):\n        yield a + b\n```\n\n\nThat's slow as well.\n\nBtw, worse than the exponential time is the exponential amount of memory. That recursive Python version crashes for me when trying to compute the 32nd Fibonacci number. At that point I already have almost 4 million generators running. And your Ruby version crashes for me when trying to compute the 20th Fibonacci number, with error ```\ncan't create fiber (FiberError)```\n. At that point I have almost 12000 fibers running.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "To print Fibonacci Sequence [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        The range of int in Java\r\n                            \r\n                                (5 answers)\r\n                            \r\n                    \r\n                    \r\n                        How does Java handle integer underflows and overflows and how would you check for it?\r\n                            \r\n                                (12 answers)\r\n                            \r\n                    \r\n                Closed 2 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nAn integer value N is passed as the input. The program must print the first N terms in the Fibonacci sequence.\n```\nimport java.util.Scanner;\npublic class FibonacciExample {\n \n    public static void main(String[] args) \n    {\n    \n         int maxNumber = 0; \n         int previousNumber = 0;\n         int nextNumber = 1;\n         \n            System.out.println(\"How many numbers you want in Fibonacci:\");\n            Scanner scanner = new Scanner(System.in);\n            maxNumber = scanner.nextInt();\n            System.out.print(\"Fibonacci Series of \"+maxNumber+\" numbers:\");\n \n            for (int i = 1; i <= maxNumber; ++i)\n            {\n                System.out.print(previousNumber+\" \");\n                /* On each iteration, we are assigning second number\n                 * to the first number and assigning the sum of last two\n                 * numbers to the second number\n                 */\n \n          \n                int sum = previousNumber + nextNumber;\n                previousNumber = nextNumber;\n                nextNumber = sum;\n            }\n \n    }\n \n}\n```\n\nAs here the code works fine for below 30 Numbers . But after 30 It showing the negative values which i don't need\nFor eg If i want\n```\n5\n```\n\nNumber of fibonacci series it showing perfect solution\n```\n0 1 1 2 3\n```\n\nBut if Im giving\n```\n48\n```\n\nIt showing\n```\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 **-1323752223** \n```\n\nBut I need this answer\n```\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 **2971215073**\n```\n\nSEE THE LAST NUMBER\n.I have also tried ```\nlong```\n but didn't result in\n.So what Can i do to achieve that Output . Thanks In Advance\n    ", "Answer": "\r\nThe ```\nInteger.MAX_VALUE```\n is 2147483647.\nYour maximum value expected is 2971215073, which is higher than this.\nIf you need to get higher numbers, use ```\nlong```\n like this:\n```\n    int maxNumber = 0;\n    long previousNumber = 0;\n    long nextNumber = 1;\n\n    //...\n        long sum = previousNumber + nextNumber;\n    //...\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence without for loop in octave\r\n                \r\nI'm trying to create a Fibonacci sequence without for loop in octave, but all I get is error and I'm totally stuck here. Any ideas on how to deal with this\n```\nx(1)=1;\nx(2)=1;\nm=3:10\nx(m)=x(m-1)+x(m-2)\n```\n\n\nerror: x(9): out of bound 2 (dimensions are 1x2)\n\nI was expecting getting the 1st 10 Fibonacci sequence but it isn't working\n    ", "Answer": "\r\nUnfortunately, Octave does not recalculate in-place vectorized operators at each step (nor MATLAB, as far as I'm aware of), so\n```\noctave> x=ones(1,10)\nx =\n   1   1   1   1   1   1   1   1   1   1\n\noctave> x(3:10)=x(2:9)+x(1:8)\nx =\n    1   1   2   2   2   2   2   2   2   2\n```\n\nYou can either use a closed-form expression, as mentioned on the comments, or just do a simple loop:\n```\noctave> x=ones(1,2)\noctave> for i=3:10\n> x(i)=x(i-1)+x(i-2)\n> endfor\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding terms of Fibonacci sequence\r\n                \r\nI am trying to find all terms of Fibonacci sequence that do not exceed 100. Here is my code:\n\n```\nfibonacci_sequence = [1,2]\nindex = fibonacci_sequence.length\n\n# finding next term, term 3\n# current index is 2\nnext_term = fibonacci_sequence[index - 2] + fibonacci_sequence[index - 1]\nfibonacci_sequence.push(next_term)\nindex += 1\n\nuntil next_term > 100 do\n  next_term = fibonacci_sequence[index - 2] + fibonacci_sequence[index - 1]\n  fibonacci_sequence.push(next_term)\n  index += 1\nend\n\np fibonacci_sequence\n```\n\n\nWhen I try to run my code, the value ```\n144```\n is also included. Any idea?\n    ", "Answer": "\r\nYour condition:\n\n```\nuntil next_term > 100\n```\n\n\nevaluates ```\nnext_term```\n before updating. Within the loop, you calculate the next ```\nnext_term```\n and add it. So your loop ends one iteration after the condition is satisfied.\n\nYou also don't need ```\nindex```\n, and also don't need to do the first iteration separately.\n\nChange it to:\n\n```\nfibonacci_sequence = [1, 2]\nloop do\n  next_term = fibonacci_sequence[-2] + fibonacci_sequence[-1]\n  break if next_term > 100\n  fibonacci_sequence.push(next_term)\nend\np fibonacci_sequence # => [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Computing a Fibonacci sequence in Terraform\r\n                \r\nThe title is really all there is to the question: how would you compute the values of a Fibonacci sequence (first N values, where N is an input variable) and store them in a Terraform ```\nlocal```\n variable?\nThis could, of course, be done with an ```\nexternal```\n data source, but I'm looking for a way to do it in pure Terraform.\nThere's no real need to actually do this, but the Fibonacci sequence is a representation of a problem I need to solve in Terraform (where values in a list depend on previous values of that same list).\n    ", "Answer": "\r\nI think the easiest way would be to create your own external data source for that, as in TF you can't access existing list elements during iteration when you create the lists itself.\nAnd specific to Fibonacci sequence. I would just per-compute its values, and then just read any number of values I need from a list in TF or a file. Usually you would know a possible maximum number of those elements your app requires. Thus there is no reason to recalculate it every single time.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "C++ Fibonacci sequence\r\n                \r\nThe program I am trying to make is supposed to calculate and display each entry of the fibonacci sequence up to the 40th.\n\nI believe I'm nearly there in terms of getting this done. The issue is: after the numbers 1 and 2, the sequence just seems to reset itself and leaves every subsequent number 1 place behind in the sequence.\n\nThis is the code:\n\n```\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int a = 0;\n    int b = 1;\n    for (int i = 0; i < 40; ++i)\n    {\n        if (i==1)\n        {\n            cout << i << \" \" << b << endl;\n        }\n        else if (i==2)\n        {\n            cout << i << \" \" << b*2 << endl;\n        }\n        else\n        {\n            int c = a + b;\n            a = b;\n            b = c;\n            cout << i << \" \" << c << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\nI pre-programmed the first couple of numbers in the sequence because I couldn't get them to work properly, but after doing this, it seems to throw off the rest of the program.\n\nThe output from the code is this:\n\n```\n0 1\n1 1\n2 2\n3 2\n4 3\n5 5\n6 8\n7 13\n8 21\n9 34\n10 55\n11 89\n12 144\n13 233\n14 377\n15 610\n16 987\n17 1597\n18 2584\n19 4181\n20 6765\n21 10946\n22 17711\n23 28657\n24 46368\n25 75025\n26 121393\n27 196418\n28 317811\n29 514229\n30 832040\n31 1346269\n32 2178309\n33 3524578\n34 5702887\n35 9227465\n36 14930352\n37 24157817\n38 39088169\n39 63245986\n```\n\n    ", "Answer": "\r\nIt seems that I have solved this issue instantly after creating the post.\n\nI decided to try pre-program the very first entry in the sequence (0) to be one, and completely remove the other pre-programmed parts in the sequence. This solved the entire thing.\n\nHere's the working code:\n\n```\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int a = 0;\n    int b = 1;\n\n    for (int i = 0; i < 40; ++i)\n    {\n        if (i == 0)\n        {\n            cout << i << \" \" << b << endl;\n        }\n        else\n        {\n            int c = a + b;\n            a = b;\n            b = c;\n            cout << i << \" \" << c << endl;\n        }\n    }\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Iterating through the Fibonacci sequence\r\n                \r\nso i'd like to iterate through the Fibonacci sequence (but this could apply to any non-arithmetic sequence). i've written a function fibonacci:\n\n```\nfrom math import sqrt\ndef F(n):\n    return ((1+sqrt(5))**n-(1-sqrt(5))**n)/(2**n*sqrt(5))\n```\n\n\nwhich returns the fibonacci number for any given input. this bit seems to work OK. However, I'd like to include a couple of conditions, like even numbers and F(n) below a certain limit. I tried using an if loop like this:\n\n```\ndef ser():\n    count = 0\n    for i in F(n):\n        if F(n) <= 4000000 and F(n) % 2 == 0:\n            count = count + F(n)\n```\n\n\nBut it seems like you can't use F(n) in the iteration for loop like I did. I'm a complete novice at python, so how would be best to use the F(n) function I created to iterate over the sequence? Thanks\n    ", "Answer": "\r\nWhat is the range of ```\nn```\n that you are looking to run the fibonacci number on?\nYour definition of fibonacci is in a closed form, so you need to give each number you want to calculate:\n\n```\nimport itertools\ncount = 0\nfor n in itertools.count(1):\n    if F(n) > 4000000:\n        break\n    if F(n) % 2 == 0:\n        count += F(n)\n```\n\n\nYou can use a generator form of fibonacci and use ```\nitertools.takewhile()```\n to limit the output:\n\n```\ndef F():\n    a,b = 0,1\n    yield b\n    while True:\n        a, b = b, a + b\n        yield b\n\ncount = sum(f for f in it.takewhile(lambda x: x <= 4000000, F()) if f % 2 == 0)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Perfect square in fibonacci sequence?\r\n                \r\nCreate a program to find out the first perfect square greater than 1 that occurs in the Fibonacci sequence and display it to the console.\n\nI have no output when I enter an input. \n\n```\n#include <stdio.h>\n#include <math.h>\n\nint PerfectSquare(int n);\nint Fibonacci(int n);\n\nmain()\n{\n    int i;\n    int number=0;\n\n    int fibNumber=0;\n    int psNumber=0;\n\n\n    printf(\"Enter fibonacci number:\");\n    scanf(\"%i\",&number);\n\n\n    fibNumber = Fibonacci(number);\n\n    psNumber = PerfectSquare(fibNumber);\n\n    if(psNumber != 0){\n        printf(\"%i\\n\",psNumber);\n    }\n}\n\n\n\nint PerfectSquare(int n)\n{\n\n    float root = sqrt(n);\n    if (n == ((int) root)*((int) root))\n        return root;\n    else\n        return 0;\n}\n\nint Fibonacci(int n){\n    if (n==0) return 0;\n    if (n==1) return 1;\n    return( Fibonacci(n-1)+Fibonacci(n-2) );\n}\n```\n\n    ", "Answer": "\r\nLuke is right. If your input is n, then the Fibonacci(n) returns the (n+1)th Fibonacci number.\nYour program check whether (number +1)th is perfect square or not actually.\n\nIf you enter 12, then there is output. Because the 13th Fibonacci number is 144. And it is perfect square. PS: print fibNumber instead of psNumber.\n\n```\n        printf(\"%i\\n\", fibNumber);\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "LabVIEW help explain simple Fibonacci sequence\r\n                \r\nI have an assignment due for my LabVIEW class that involves a Fibonacci sequence, here is the exact question:\n\n\n  Create a VI that uses a WHILE loop to keep calculating iterations of a Fibonacci sequence until the ratio of  |fib(n-1)/fib(n) - fib(n-2)/fib(n-1)| converges. Inputs should include the first two elements of the sequence and the magnitude of the convergence. The output should be the number of iterations required to converge.\n\n\nI looked on Wikipedia, that didn't help. I have done some Googling around and still nothing. I don't understand what a Fibonacci sequence is nor do I know how to make it converge. Where do the two user inputed elements come in and what of the magnitude. I can code it but I don't what I am to code. If you understand please explain it to me.\n\nTo be clear I don't really want you to give me the code, just clarification; thanks.\n    ", "Answer": "\r\nYou probably need something in that style. Try translating the following Python code into LabVIEW. Use shift registers in while loop. :\n\n```\nimport math\nordofmag = 4\nresult = 1\nn = 0\nwhile result >= ( 10 ** (-ordofmag) ):\n  n = n + 1\n  if n == 1 or n==2:\n    x0 = 1.0     # fib(n)\n    x1 = 1.0     # fib(n+1)\n    x2 = x1 + x0 # fib(n+2)\n    result = math.fabs(x1/x2 - x0/x1)  \n  elif n > 2:\n    x2 = x1 + x0\n    result = math.fabs(x1/x2 - x0/x1)  \n    x0 = x1\n    x1 = x2\n  print int(x1), round(result,ordofmag)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "What is a good example of recursion other than generating a Fibonacci sequence?\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                Locked. This question is not currently accepting new answers or interactions. Learn more.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicates:\n  Real-world examples of recursion\n  Examples of Recursive functions  \n\n\n\n\nI see that most programming language tutorial teach recursion by using a simple example which is how to generate fibonacci sequence, my question is, is there another good example other than generating fibonacci sequence to explain how recursion works?\n    ", "Answer": "\r\nThe classic is the binary tree search:\n\n```\ndef findval (node,val):\n    if node == null:\n        return null\n    if node.val = val:\n        return node\n    if node.val > val:\n        return findval (node.left,val)\n    return findval (node.right,val)\n\nfindval (root,thing_to_find)\n```\n\n\nThat may be a little more complex than a simple formula but it's the \"bread and butter\" use of recursion, and it illustrates the best places to use it, that where the recursion levels are minimised.\n\nBy that I mean: you could add two non-negative numbers with:\n\n```\ndef add (a,b):\n    if b == 0:\n        return a\n    return add (a+1,b-1)\n```\n\n\nbut you'd find yourself running out of stack space pretty quickly for large numbers (unless the compiler optimised tail-end recursions of course, but you should probably ignore that for the level of teaching you're concerned with).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Infinite fibonacci sequence\r\n                \r\nI'm trying to imitate Haskell's famous infinite fibonacci list in F# using sequences. Why doesn't the following sequence evaluate as expected? How is it being evaluated?\n\n```\nlet rec fibs = lazy (Seq.append \n                        (Seq.ofList [0;1]) \n                        ((Seq.map2 (+) (fibs.Force()) \n                                       (Seq.skip 1 (fibs.Force())))))\n```\n\n    ", "Answer": "\r\nThe problem is that your code still isn't lazy enough: the arguments to ```\nSeq.append```\n are evaluated before the result can be accessed, but evaluating the second argument (```\nSeq.map2 ...```\n) requires evaluating its own arguments, which forces the same lazy value that's being defined.  This can be\nworked around by using the ```\nSeq.delay```\n function.  You can also forgo the ```\nlazy```\n wrapper, and ```\nlist```\ns are already ```\nseq```\ns, so you don't need ```\nSeq.ofList```\n:\n\n```\nlet rec fibs = \n    Seq.append [0;1]\n        (Seq.delay (fun () -> Seq.map2 (+) fibs (Seq.skip 1 fibs)))\n```\n\n\nHowever, personally I'd recommend using a sequence expression, which I find to be more pleasant to read (and easier to write correctly):\n\n```\nlet rec fibs = seq {\n    yield 0\n    yield 1\n    yield! Seq.map2 (+) fibs (fibs |> Seq.skip 1)\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Basic arraylist using Fibonacci sequence\r\n                \r\nI want this program to take an array list \"max\" that the size is created by the user. Then the program uses the Fibonacci sequence to store all the Fibonacci numbers in the arraylist that are less than the arraylist \"max\" which is created by the user input. \n\n```\nimport java.util.*;\nimport javax.swing.*;\n\n public class FibonacciArrayList {\n\n public static ArrayList<Integer> Fibonacci (Integer Max){\n\n     ArrayList<Integer> A = new ArrayList<Integer>();\n   int n0;\n   int n1;\n   int n2;\n\n   for(int i= 0; i = max; i++){\n     n2= n1 + n0;\n     system.out.println(n2);\n     n0=n1;\n     n1=n2;\n\n  return A;\n}\n\n\n  public static void main (String[] arg){\n    Integer max;\n    String Title = \"Fibonacci ArryList\";\n    String data = JOptionPane.showInputDialog(null, \"Enter the upper bound\",    Title, 1);\n  max = new Integer(data);\n    ArrayList<Integer> A = Fibonacci(max);\n    System.out.println(\"There are \" + A.size()+ \" Fibonacci numbers less than \"+max);\n\n    }\n\n}\n```\n\n    ", "Answer": "\r\nModified and simplified the logic to the ```\nFibonacci```\n function. Comments have been added to help you understand the changes.\n\n```\npublic static ArrayList<Integer> Fibonacci (Integer max) { //Instead of 'Max' use 'max'\n    ArrayList<Integer> A = new ArrayList<Integer>();\n\n    //Initialize value of n0, n1 and n2\n    int n0=0;\n    int n1=1;\n    int n2=1;\n\n    //Handling the base conditions\n    if(max == 0) return A;\n\n    if(max == 1) {\n        A.add(n0);\n        return A;\n    }\n\n    //Add first 2 elements in the array\n    A.add(n0);\n    A.add(n1);\n\n    //A 'while' loop will be more suitable to what you want to achieve\n    while(n2 < max) {\n        A.add(n2); //Instead of printing the values, add them into ArrayList A\n        n0=n1;\n        n1=n2;\n        n2 = n1 + n0;\n    } //Add a closing bracket for the 'for' loop\n\n    return A;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Understanding the Fibonacci sequence\r\n                \r\nI have an algorithm that I found online that calculates the Fibonacci sequence. I feel a bit like a fool but I have no idea how it works! \n\n```\n def fib(n)\n\n  if n == 0 || n == 1\n   return n\n  end\n\n  if n >= 2\n    return fib(n-1) + fib(n-2)\n  end\n end\n```\n\n\nIf I call the method with the argument of 10 why does it not return 18? I assume some recursion is happening here but I have no idea. Can someone help me understand this?\n    ", "Answer": "\r\nLet's look at ```\nfib(4)```\n, according to your code above:\n\n```\nfib(4) #=> 3\n```\n\n\nIt does so by using the following results:\n\n```\nfib(4) #calculates fib(3) + fib(2)\nfib(3) #calculates fib(2) + fib(1)\nfib(2) #calculates fib(1) + fib(0)\nfib(1) #returns 1\nfib(0) #returns 0\n```\n\n\nCrudely speaking your method uses the above results in the following fashion\n(note: below I am using math-notation (not code) and some dubious spacing to illustrate which bits are being substituted with the results from above):\n\n```\n# fib(4) =   fib(3)                       +  fib(2)\n#        = ( fib(2)            + fib(1))  + (fib(1) + fib(0))\n#        = ((fib(1) + fib(0))  + 1     )  + (1      + 0     )\n#        = ((1      + 0     )  + 1     )  +  1\n#        = ( 1                 + 1     )  +  1\n#        =   2                            +  1\n#        =   3\n```\n\n\nYour algorithm goes through the above steps. Similarly for ```\nfib(10)```\n, although it's hardly worth going through it manually as it can be quite cumbersome. As long as you get the basic idea, move on. And by the way you're not a fool, you're just trying to get better at something which is what many of us are trying to do as well. Good luck.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generate a sequence of Fibonacci number in Scala [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        What is the fastest way to write Fibonacci function in Scala?\r\n                            \r\n                                (8 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n```\n\n  def fibSeq(n: Int): List[Int] = {\n    var ret = scala.collection.mutable.ListBuffer[Int](1, 2)\n    while (ret(ret.length - 1) < n) {\n      val temp = ret(ret.length - 1) + ret(ret.length - 2)\n      if (temp >= n) {\n        return ret.toList\n      }\n      ret += temp\n    }\n    ret.toList\n  }\n```\n\n\n\nSo the above is my code to generate a Fibonacci sequence using Scala to a value ```\nn```\n.  I am wondering if there is a more elegant way to do this in Scala?\n    ", "Answer": "\r\nThis is a bit more elegant:\n```\nval fibs: Stream[Int] = 0 #:: fibs.scanLeft(1)(_ + _)\n```\n\nWith Streams you \"take\" a number of values, which you can then turn into a List:\n```\nscala> fibs take 10 toList\nres42: List[Int] = List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)\n```\n\nUpdate: I've written a blog post which goes more detail regarding how this solution works, and why you end up with a Fibonacci sequence!\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Counting program for fibonacci sequence Python\r\n                \r\nI think what I am trying to do is display a select section from a defined list.  Currently this is what I am working with:\n\n```\n#fibonacci sequence algorithm, user stops by either \n#entering a maximum Fibonacci value not to exceed or\n#a total count that the sequence of numbers must not\n#exceed. Use a loop that allows User to repeat program\n#as much as they wish, asking if they would like to \n#repeat the program each time. Validate that User input\n#is either a yes or a no and only allow User to continue\n#once a correct response has been given.\nimport array\n\narray.listOfFibSeq = ['0','1','1','2','3','5','8','13','21','34','55','89','144','...']\nstartingNumber = ''\nendingNumber = ''\ncontinueYes = ''\n\ndef getStartingNumber():\n    print('Please enter a valid starting number of the Fibonacci Sequence')\n    print(listOfFibSeq)\n    startingNumber = input()\n\ndef getEndingNumber():\n    print('Please enter a valid ending number the the Fibonacci Sequence')\n    print(listOfFibSeq)\n    endingNumber = input()\n```\n\n\nI'm unsure of how to go about this, but I believe I'm trying to display (for example) 3 through 89 in the Fibonacci sequence or do something like:\n\n```\nlsitOfFibSeq.remove(<3) and listOfFibSeq.remove(>89)\n```\n\n\nor should I try to display a range of the Fib Sequence with a for loop?\n    ", "Answer": "\r\nThere is no reasonable way to precompute the fibonacci sequence before the user enters a range — you should do this dynamically.\n\nA naive approach would be to have a function that computes the sequence for a given ```\n(a, b)```\n, all the way to ```\nend```\n, discarding everything up to ```\nstart```\n.\n\nI prefer the generator approach:\n\n```\nimport itertools\ndef fib():\n    a, b = 0, 1\n    while 1:\n        yield a\n        a, b = b, a + b\n\n# Print the first 10 values of the sequence\nfor i in itertools.islice(fib(), 0, 10):\n    print(i)\n```\n\n\nOr, in your case, something like:\n\n```\nstart = input('Start index: ')\nend = input('End index: ')\n\nfor i in itertools.islice(fib(), int(start), int(end)):\n    print(i)\n    if input('Continue [y/n]: ').rstrip() == 'n':\n        break\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Dynamic Programming Fibonacci Sequence\r\n                \r\nI was learning dynamic programming's application to the Fibonacci Sequence and had a question. Here is the code for reference:\n\n```\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class FibonacciNumbersB {\n\n    static BigInteger[] dp = new BigInteger[10000];\n\n    public static void main(String[] args) {\n        Arrays.fill(dp, BigInteger.ZERO);\n        dp[0] = BigInteger.ONE;\n        dp[1] = BigInteger.ONE;\n\n        for(int i = 4; i < 9999; i++)\n            System.out.println(fibRecurse(i).toString());\n    }\n\n    public static BigInteger fibRecurse(int N) {\n        for(int i = 2; i < N; i++) {\n            // For numerous calls to this function, this will save as it goes\n            if(dp[i].equals(BigInteger.ZERO))\n                dp[i] = dp[i - 1].add(dp[i - 2]);\n        }\n\n        return dp[N - 1];\n    }\n}\n```\n\n\nI have a statement check if ```\ndp[i]```\n equals ```\n0```\n in the ```\nfibRecurse```\n method (although ```\nfibRecurse```\n isn't recursive). \n\nIs it more efficient to check if ```\ndp[i]```\n has been calculated already or to just let ```\ndp[i]```\n equal to the sum of the previous two elements?\n    ", "Answer": "\r\nI would prefer a ```\nMap<Integer, BigInteger>```\n over using a fixed ```\nBigInteger[]```\n when performing this memoization. Note that your current approach is not recursive. The ```\nMap```\n might be declared and initialized like\n\n```\nstatic Map<Integer, BigInteger> memo = new HashMap<>();\nstatic {\n    memo.put(0, BigInteger.ONE);\n    memo.put(1, BigInteger.ONE);\n}\n```\n\n\nThen check if the current ```\nn```\n is present in the ```\nmemo```\n (if it is, return it) - otherwise, computer and store it. Like,\n\n```\npublic static BigInteger fibRecurse(int n) {\n    if (memo.containsKey(n)) {\n        return memo.get(n);\n    }\n    BigInteger v = fibRecurse(n - 1).add(fibRecurse(n - 2));\n    memo.put(n, v);\n    return v;\n}\n```\n\n\nA version without memoization would simply omit ```\nmemo```\n like\n\n```\npublic static BigInteger fibRecurseSlow(int n) {\n    if (n == 0 || n == 1) return BigInteger.ONE;\n    BigInteger v = fibRecurse(n - 1).add(fibRecurse(n - 2));\n    return v;\n}\n```\n\n\nI think you can infer from the method names I've chosen which is slower.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Problems with Recursive Multiplicative Fibonacci Sequence\r\n                \r\nI am writing a recursive method that will calculate a multiplicative Fibonacci Sequence.  This sequence is similar to a regular Fibonacci Sequence except that instead of adding the two previous numbers to find the next numbers, you instead multiply them. I currently have this method written but instead of returning what I would think the correct result is, the method is returning 0 no matter what the input number is.  Any help or ideas would be greatly appreciated. \nHere is the method:\n\n```\npublic static int fibonacciPower(int n)\n{\n    if(n < 2)\n    {\n        return n;\n    }\n    else\n    {\n        return (fibonacciPower(n-1) * fibonacciPower(n-2));\n    }\n\n}\n```\n\n    ", "Answer": "\r\nYou need to return 1\n\n```\nif(n < 2)\n{\n    return 1;\n}\n```\n\n\nThis is because, if n becomes 0, you end up multiplying by 0 and in turn your product becomes 0. Thus instead we multiply with 1 in case of n equal to 0 or 1\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Double condition Fibonacci sequence in Excel\r\n                \r\nI'm trying to create a Fibonacci sequence which incrementation depends on one column and then restarts depends on another column.\nGiven columns ```\nA```\n and ```\nB```\n, I'd like to calculate ```\nFIB```\n:\n```\n A | B |FIB\n---|---|---\n 1 | T | 0    // A=1, B=T -> FIB=0\n 2 | T | 1    // A!=1, B=T -> FIB=1\n 0 | F |      // B=F -> Do Nothing\n 2 | T | 1    // A!=1, B=T -> FIB=FIB(-1)+FIB(-2)=1\n 2 | T | 2    // A!=1, B=T -> FIB=FIB(-1)+FIB(-2)=2\n 0 | T | 3    // A!=1, B=T -> FIB=FIB(-1)+FIB(-2)=3\n 2 | F |      // B=F -> Do Nothing\n 1 | F |      // B=F -> Do Nothing\n 2 | T | 5    // A!=1, B=T -> FIB=FIB(-1)+FIB(-2)=5\n 0 | F |      // B=F -> Do Nothing\n 1 | T | 0    // A=1, B=T -> Restart -> FIB=0\n 2 | T | 1    // A!=1, B=T -> FIB=1\n 0 | F |      // B=F -> Do Nothing\n 0 | T | 1    // A!=1, B=T -> FIB=FIB(-1)+FIB(-2)=1\n 2 | T | 2    // A!=1, B=T -> FIB=FIB(-1)+FIB(-2)=2\n```\n\nWhen ```\nA=1```\n I want FIB to restart the Fibonacci sequence.\nWhen ```\nB=T```\n I want FIB to increment.\nDo you see any way, without VB, to do this?\nMy attempt --\n```\nFIB =IF(B, IF(A=1,0,FIB[-1] + FIB[-2]))\n```\n\nThis doesn't work because the increment is not taking into consideration that the previous cells may be empty or may be a restart.\n    ", "Answer": "\r\nHere's a solution, with the aid of some helper columns\n\nIn cell ```\nG2```\n\n\n```\n=IF($B2=\"T\",IF($A2=1,0,IF($B1=\"T\",-1,$G1)),$G1-1)\n```\n\n\nIn cell ```\nH2```\n\n\n```\n=INDEX($G:$G,ROW()+$G2)+$G2\n```\n\n\nIn cell ```\nI2```\n\n\n```\n=INDEX($C:$C,ROW()+$G2)\n```\n\n\nIn cell ```\nJ2```\n\n\n```\n=INDEX($C:$C,ROW()+$H2)\n```\n\n\nAnd in FIB cell, ```\nC2```\n\n\n```\n=IF(B5=\"T\",IF(A5=1,0,IF($I5=0,1,$I5+$J5)),\"\")\n```\n\n\nAnd copy down as far as required\n\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursive Fibonacci Sequence print out the list\r\n                \r\nI have the follow code for a recursive Fibonacci Sequence\n\n```\n    if (term < 2){\n        System.out.print(\"1 \");\n        return 1;\n    } \n        int results = fibonacci(term - 1) + fibonacci(term - 2);\n        System.out.print(results + \" \");\n\n        return results;\n```\n\n\nThe output I get is\n\nWhat term would you like to do the Fibonacci Sequence up to: 4\n\n1 1 2 1 3 1 1 2 5 The 4th is 5\n\nHow do I make it so it prints\n\n1 1 2 3 The 4th is 5\n    ", "Answer": "\r\nUse tail recursion.\n\n```\n  public static void main(String[] args) {\n\n    System.out.print(\"The 10th is: \" + fibonnaci(10));\n  }\n\n  public static int fibonnaci(int number) {\n     return fibonnaciHelper(number, 1, 1);\n  }\n\n  public static int fibonnaciHelper(int term, int lower, int higher) {\n      if (term < 2){\n          return higher;\n\n      } \n\n      System.out.print(higher + \" \");\n      int results = fibonnaciHelper(term - 1, higher, higher + lower);\n      return results;\n  }\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursive Fibonacci Sequence\r\n                \r\nSo I wrote a recursive program that asks the user now many Fibonacci numbers they would like to execute. The problem I'm having is that after the 45th number, it gives me a number with a \"-\" and its a number that doesn't fit into the sequence. How can I change that to give me the proper number? Here is the recursive part of the code that executes the calculation:\n\n```\nvoid fibonacci (int a, int b, int n, int count)\n{\n    if(n < count) \n    {\n        cout<<a+b<<endl;\n        fibonacci(b, a+b, n+1, count);\n    }\n}\n```\n\n\nhere's the output of the sequence:\n\n```\nHow many numbers do you want the Fibonacci sequence to process: 50\nThe starting numbers for the sequence are: 0, 1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n4181\n6765\n10946\n17711\n28657\n46368\n75025\n121393\n196418\n317811\n514229\n832040\n1346269\n2178309\n3524578\n5702887\n9227465\n14930352\n24157817\n39088169\n63245986\n102334155\n165580141\n267914296\n433494437\n701408733\n1134903170\n1836311903\n-1323752223\n512559680\n-811192543\n-298632863\n-1109825406\n```\n\n\nWhat changes do I need to make in order for it to change the -#'s to the real numbers?\n    ", "Answer": "\r\nYou're running into problems because the datatype ```\nint```\n you're using is 32 bits and can only hold values up to 2^31-1 = 2147483647 when ```\nsigned```\n (default, 31 bits used, 1 bit is occupied to indicate signedness, this also explains the negative numbers), 2^32-1 = 4294967295 when ```\nunsigned```\n. You can use a 64 bit datatype here (```\nlong long```\n in most cases), but will also run in problems with this one later (around the 94th fibonacci number, I think).\n\nThe \"real\" solution to this problem is to write your own methods for numerical calculations and use an own representation of the numbers, f.e. an array of chars. You can also look for one of the various possibilites to use a \"bignum\" library. You should find more information about this in some SO questions, for example this one.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence In Python (Most Efficient) [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Efficient calculation of Fibonacci series\r\n                            \r\n                                (34 answers)\r\n                            \r\n                    \r\n                Closed 3 months ago.\r\n        \r\n\r\n\r\n    \r\n\r\nAnyone know the most efficient way of displaying the first 100 numbers in the Fibonacci Sequence in Python please?\n\nHere is my current code:\n\n```\nfib1,fib2,fib3= 0,0,1  \n\nwhile fib3< 100: \n    print(fib3) \n    fib1=fib2 \n    fib2=fib3\n    fib3=fib1 + fib2\n```\n\n    ", "Answer": "\r\nUnderstand the working of python and fibonacci Sequence. Use ```\ngenerator```\n feature of python. Follow the code\n\n```\na = int(input('Give num: '))\n\ndef fib(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n\nprint(list(fib(a)))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence without using Array\r\n                \r\nI am trying to practice JAVA by coding a Fibonacci sequence in which the user can declare the length of the Fibonacci starting from 0 to n. Here is my code:  \n\n```\npublic class test {\npublic static void main(String args[]) throws IOException {\n    BufferedReader pao = new BufferedReader(\n            new InputStreamReader(System.in));\n\n    System.out.print(\"Enter number: \");\n    String enter = pao.readLine();\n    int ent = Integer.parseInt(enter);\n\n    int total1 = 0;\n    int total2 = 1;\n    int total3 = 0;\n\n    for (int a = 0; a < ent; a++) {\n        if (a <= 1) {\n            System.out.print(\" \" + total3);\n            total3 = total1 + total2;\n\n        } else if (a == 2) {\n            System.out.print(\" \" + total3);\n        } else {\n            total1 = total2;\n            total2 = total3;\n            total3 = total1 + total2;\n            System.out.print(\" \" + total3);\n\n        }\n    }\n\n}\n}  \n```\n\n\nIs there another way to do this in a much more simpler, shorter and \"Nicer\" way? still without using arrays. Thank you in advance.\n    ", "Answer": "\r\nYou can use recursive fibonacci but it will increase your runtime from ```\nO(n)```\n to ```\nO(2^n)```\n it's like bellow\n\n```\nint fib(int n) {\n   if (n <= 1)\n      return n;\n   return fib(n-1) + fib(n-2);\n}\n```\n\n\nand there is another way that decrease your runtime to ```\nO(log n)```\n but it use arrays (Using power of the matrix ```\n{{1,1},{1,0}}```\n) you can read about it here. also for above recursion if you use array you can change runtime to ```\nO(n)```\n again by method call dynamic programming.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Algorithm\r\n                \r\nI am attempting to find the first number in the Fibonacci sequence to contain N digits (N being somewhere in the range of 500 and 2000). I attempt to do this with the following code:\n\n```\nBigInteger num = BigInteger.valueOf(2);\nBigInteger num1 = BigInteger.ONE;\nBigInteger num2 = BigInteger.ONE;\nint record = 0;\nBigInteger TEN = BigInteger.valueOf(10);\n\npublic BigInteger run()\n{\n    BigInteger temp = BigInteger.ZERO;\n    while(num2.compareTo(TEN.pow(SomeN - 1)) < 0)\n    {\n        if(num2.compareTo(TEN.pow(record + 1)) >= 0)\n        {\n            System.out.println(\"\"+record);\n            record++;\n        }\n\n        temp = num1.add(num2);\n        num1 = num2;\n        num2 = temp;\n\n        num = num.add(BigInteger.ONE);\n    }\n    System.out.println(\"\"+num);\n    System.out.println(\"\"+num2);\n    return num2;\n}\n```\n\n\nThe problem is, when I test for 1500 digits, the answer I get is apparently wrong. I do not know what the answer is supposed to be, and I have even checked the answers immediately around it in case my algorithm is off by a power of 10 (i.e. I checked 1499 digits and 1501), but to no avail. Anyone see what is wrong?\n    ", "Answer": "\r\n(deleted way off base hint)\n\nEDIT: EP web site is back up, and the answer I get when using your code matches what the web site accepted as correct for me, way back when.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence using Datastage\r\n                \r\nI'm trying to get an output of Fibonacci sequence in Datastage. I am trying it with a row generator-->Transformer-->Sequential File. My data inside row generator is (0 and 1). I have no idea what to put in my transformer.\n\n```\nData:0,1\n```\n\n\nThe output should be ```\n(0,1,2,3,5,8,13,21,34)```\n. The number should be only up to 100, so I'm thinking of a loop variable.\n    ", "Answer": "\r\nwe can do this using three loop variables.\n\n```\nName --> Derivation\nvarSum-->if (@ITERATION=1) then 0 else if (@ITERATION=2) then 1 else varFirst+varSecond\nvarFirst --> varSecond\nvarSecond --> varSum.\n```\n\n\noutput will be ```\nvarSum```\n\n\nfrom row generator u can get a single row to complete the job.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence - Time Complexity\r\n                \r\nGiven that fib(n)=fib(n-1)+fib(n-2) for n>1 and given that fib(0)=a, fib(1)=b (some a, b >0), which of the following is true?\n\n```\nfib(n) is \n\nSelect one or more:\na. O(n^2)\nb. O(2^n)\nc. O((1-sqrt 5)/2)^n)\nd. O(n)\ne. Answer depends on a and b.\nf. O((1+sqrt 5)/2)^n)\n```\n\n\nSolving the Fibonacci sequence I got that:\n\n```\nfib(n)= 1/(sqrt 5) ((1+sqrt 5)/2)^n - 1/(sqrt 5) ((1-sqrt 5)/2)^n\n```\n\n\nBut what would be the time complexity in this case? Would that mean the answers are c and f?\n    ", "Answer": "\r\nFrom your closed form of your formula, the term ```\n1 / (sqrt 5) ((1 - sqrt 5) / 2)^n```\n has limit ```\n0```\n as ```\nn```\n grows to infinity (```\n|(1 - sqrt 5) / 2| < 1```\n). Therefore we can ignore this term. Also since in time complexity theory we don't care about muliplication constants the following is true:\n\n\n  fib(n) = Θ(φ^n)\n\n\nwhere φ = ```\n(1 + sqrt 5) / 2```\n a.k.a. the golden ratio constant.\n\nSo it's an exponential function and we can exclude ```\na, d, e```\n. We can exclude ```\nc```\n since as was said it has limit ```\n0```\n. But answer ```\nb```\n is also correct because ```\nφ < 2```\n and ```\nO```\n expresses an upper bound.\n\nFinally, the correct answers are:\n\n\n  b, f\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence omitting numbers c\r\n                \r\nI'm trying to print out the Fibonacci sequence but the output doesn't match the expected output. I used the printf function and referred to the array where the data is stored, so I'm not sure where my mistake is. I'm getting strange output, too.\n\nif m = 0, the loop that should print the sequence is designed to print the ith Fibonacci number should print out the 8 digits of each Fibonacci number.\nfor any other m, it stores n more spaces in the array for each m and the print function is designed to print accordingly.\n\nInstead only the first 9 Fibbonacci numbers are printed when m = 0 and only the first 7 display the correct number of digits when m = 1.\n\nI'm not sure where my mistake is.\n\nCode:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n\n    int a, b, n;\n\n    //create a list for the Fibonacci sequence\n    printf(\"Enter n.\\n\");\n    scanf(\"%d\", &n);\n\n   //store a long for each 8 places\n\n    int m;\n    printf(\"Enter level of precision.\");\n    scanf(\"%d\",&m);\n    long fibonacci[(m+1)*n];\n    fibonacci[0] = 0;\n    fibonacci[1] = 1;\n    for (int u = 2; u<((m+1)*n-1);u++) {\n        fibonacci[u] = 0;\n    }\n    printf(\"F_0 =%d\\n\",fibonacci[0]);\n    printf(\"F_1 =%d\\n\",fibonacci[1]);\n    int j,l;\n    for (int i = 2; i<n; i++) {\n        a = i-1;\n        b = i-2;\n        fibonacci[i] = fibonacci[a] + fibonacci[b];\n        fibonacci[n+i] = (fibonacci[i]-(fibonacci[i]%100000000))/100000000;\n        fibonacci[i] = fibonacci[i]%100000000;\n\n        for (j = 0;j<m;j++) {\n            fibonacci[(j+1)*n+i] = fibonacci[(j+1)*n+i] + fibonacci[(j+1)*n+a] + fibonacci[(j+1)*n+b];\n            fibonacci[(j+2)*n+i] = (fibonacci[(j+1)*n+i] - (fibonacci[(j+1)*n+i]%100000000)) / 100000000;\n            fibonacci[(j+1)*n+i] = fibonacci[(j+1)*n+i]%100000000;\n        }\n        printf(\"F_%d=\",i);\n\n        for (l = 0;l<(m+1);l++) {\n            printf(\"%08d\",fibonacci[(m-l)*n+i]);\n        }\n        printf(\"\\n\");\n    }\n}\n```\n\n\noutput:\n\nfor m = 0\n\n```\nEnter n.\n20\nEnter level of precision.0\nF_0 =0\nF_1 =1\nF_2=00000001\nF_3=00000002\nF_4=00000003\nF_5=00000005\nF_6=00000008\nF_7=00000013\nF_8=00000021\nF_9=00000034\n```\n\n\nfor m = 1:\n\n```\nEnter n.\n20\nEnter level of precision.1\nF_0 =0\nF_1 =1\nF_2=0000000000000001\nF_3=0000000000000002\nF_4=0000000000000003\nF_5=0000000000000005\nF_6=0000000000000008\nF_7=0000000000000013\nF_8=00000021\nF_9=00000034\nF_10=00000055\nF_11=00000089\nF_12=00000144\nF_13=00000233\nF_14=00000377\nF_15=00000610\nF_16=00000987\nF_17=00001597\nF_18=00002584\nF_19=00004181\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence detector Java\r\n                \r\nI'm having trouble with my Fibonacci number program for my Intro to Java class. It works only when I type the numbers in ascending order. \n\nGoal: Must use a while loop, must detect if a number is a fibonacci number, and must detect the order of the number in the sequence. If it's not a fibonacci number it must say so, and tell what numbers it's between. The program must also keep asking for an input number until a user exits\n\nExample of how output should be: \n\n```\nPlease input a number for analysis >> 2\n2 is a fibonacci number whose order in the sequence is 4\nPlease input a number for analysis >> 53\n53 is not a fibonacci number \nHowever, it lies between the Fibonacci numbers 34 (order:10) and 55 (order:11)\n```\n\n\nMy problem: The program works only when I type the input numbers in ascending order. So for example if I input 5, it tells me it's a fib number with a seq. of 6. But when I then type in 2, it says it's not a fib number, but it lies between the Fibonacci numbers 3 (order:5) and 5 (order:6). And when I type in 55, it tells me it's a fib number. But then I can't type in any number lower than 55 without it showing incorrect input. \n\nI think the problem lies in the else if statement, possibly (fibnext != testnum). Or maybe the count? Can anyone point me in the direction to where the problem might be? \n\n```\nimport java.util.Scanner;\n\npublic class Fibonacci\n{\n    public Fibonacci()\n    {\n        int fibhigh = 1;\n        int fiblow = 0;\n        int count = 2;\n        int fibnext = 0;\n        Scanner input = new Scanner(System.in);\n        boolean quit = false;\n\n        System.out.println(\"Welcome to Fibonacci Sequence Dectector\");\n        while(!false)\n        {\n            System.out.print(\"Please input a number for analysis >> \");\n            int testnum = input.nextInt();\n\n            if(testnum < 0)\n            {\n                System.out.println(\"Please enter a positive number\");\n                continue;\n            }\n            while(fibnext < testnum)\n            {\n                fibnext = fibhigh + fiblow;\n                fiblow = fibhigh;\n                fibhigh = fibnext;\n                count++;\n            }\n            if(fibnext == testnum)\n            {\n                System.out.println(testnum + \" is a fibonacci number whose order in the sequence is \" + count);\n            }\n            else if(fibnext != testnum) System.out.println(testnum + \" is not a fibonacci number \\nHowever, it lies between the Fibonacci numbers \" + fiblow + \" (order:\" + (count - 1) + \") and \" + fibhigh + \" (order:\" + count + \")\");\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nYou are never reset variables \n```\nint fibhigh = 1, fiblow = 0, count = 2, fibnext = 0;```\n \n\nYou should move this code snippet \n\n```\nint fibhigh = 1;\nint fiblow = 0;\nint count = 2;\nint fibnext = 0;\n```\n\n\nat the beginning of loop: \n\n```\nwhile (!false) {  }\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence in Custom Assembly\r\n                \r\nI've made a custom 8Bit computer in java similar to Ben Eater's 8Bit breadboard computer. I had Fibonacci working but then I decided to change the ram size and I had to also change the size of the program counter. Ever since that change, the program has just been spitting out zeroes instead of the Fibonacci Sequence. Heres the entire class:\n\n```\npublic class CPU {\n\n    boolean running = true;\n    int hz;\n\n    int pc = 0, addr;\n    short a, b, s, i, psc = 0;\n    boolean c, z, hlt = false;\n\n    short[] ram;\n\n    public CPU() {\n        hz = 8;\n        ram = new short[34];\n        //Fibonacci Sequence Code\n        ram[0] = 0b00000101; //LDI\n        ram[1] = 0b00000001; //1\n        ram[2] = 0b00000100; //STA\n        ram[3] = 0b00000000; \n        ram[4] = 0b00100000; //32 a\n        ram[5] = 0b00000101; //LDI\n        ram[6] = 0b00000000; //0\n        ram[7] = 0b00000100; //STA  \n        ram[8] = 0b00000000;\n        ram[9] = 0b00011111; //31 b\n        ram[10] = 0b00000001; //LDA\n        ram[11] = 0b00000000;\n        ram[12] = 0b00011111; //31 b\n        ram[13] = 0b00001110; //OUT\n        ram[14] = 0b00000001; //LDA\n        ram[15] = 0b00000000;\n        ram[16] = 0b00100000; //32 a\n        ram[17] = 0b00000010; //ADD\n        ram[18] = 0b00000000;\n        ram[19] = 0b00001111; //32 a\n        ram[20] = 0b00000100; //STA\n        ram[21] = 0b00000000;\n        ram[22] = 0b00011111; //31 b\n        ram[23] = 0b00000011; //SUB\n        ram[24] = 0b00000000;\n        ram[25] = 0b00100000; //32 a\n        ram[26] = 0b00000100; //STA\n        ram[27] = 0b00000000;\n        ram[28] = 0b00100000; //32 a\n        ram[29] = 0b00000110; //JMP\n        ram[30] = 0b00000000;\n        ram[31] = 0b00001010; //10\n        long lastTime = System.nanoTime();\n        double ns = 1000000000 / (hz*7);\n        double delta = 0;\n        while(running){\n            long now = System.nanoTime();\n            delta += (now-lastTime) / ns;\n            lastTime = now;\n            while(delta >= 1){\n                update();\n                delta--;\n            }\n        }       \n    }\n\n    void executeMicroCode() {\n        switch(i) {\n            case 1:\n                if(psc==2) a = ram[(int)ram[pc]<<8|ram[pc+1]]; //LDA\n                if(psc==3) pc+=2;\n                break;\n            case 2:\n                if(psc==2) b = ram[(int)ram[pc]<<8|ram[pc+1]]; //ADD\n                if(psc==3) s = (short) (a+b);\n                if(psc==4) a = s;\n                c = (s>=256)?true:false;\n                z = (s==0)?true:false;\n                if(psc==5) pc+=2;\n                break;\n            case 3:\n                if(psc==2) b = ram[(int)ram[pc]<<8|ram[pc+1]]; //SUB\n                if(psc==3) s = (short) (a-b);\n                if(psc==4) a = s;\n                c = (s>=256)?true:false;\n                z = (s==0)?true:false;\n                if(psc==5) pc+=2;\n                break;\n            case 4:\n                if(psc==2) addr = (int)ram[pc]<<8|ram[pc+1]; //STA\n                if(psc==3) ram[addr] = a;\n                if(psc==4) pc+=2;\n                break;\n            case 5:\n                if(psc==2) a = ram[pc]; //LDI\n                if(psc==3) pc++;\n                break;\n            case 6:\n                if(psc==2) pc = (int)ram[pc]<<8|ram[pc+1]; //JMP\n                break;\n            case 7:\n                if(psc==2) if(c) pc = (int)ram[pc]<<8|ram[pc+1]; //JC\n                if(psc==2) if(!c) pc+=2;\n                break;\n            case 8:\n                if(psc==2) if(z) pc = (int)ram[pc]<<8|ram[pc+1]; //JZ\n                if(psc==2) if(!c) pc+=2;\n                break;\n            case 9:\n\n                break;\n            case 10:\n\n                break;\n            case 11:\n\n                break;\n            case 12:\n\n                break;\n            case 13:\n\n                break;\n            case 14:\n                if(psc==2) {\n                    System.out.println(a); //OUT\n                }   \n                break;\n            case 15:\n                hlt = true; //HLT\n                break;\n        }\n    }\n\n    void update() { \n        if(!hlt) {\n            if(psc>=6) psc = 0;\n            if(pc>=16) pc = 0;\n            if(a>=255||a<0) a&=0xFF;\n            if(b>=255||b<0) b&=0xFF;\n            if(s>=512||s<0) s = 0;\n            if(psc==0) addr = pc;\n            if(psc==0x1) {\n                i = ram[addr];\n                pc++;\n            }   \n            executeMicroCode();\n            psc++;\n        }   \n    }\n\n    public static void main(String[] args) {\n        new CPU();\n    }\n\n}\n```\n\n\nSorry if it is a little hard to read. Thank you\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Non-recursive Fibonacci Sequence in Assembly\r\n                \r\nIn some homework, I have to create a Fibonacci Sequence program in Assembly. I created this code, but it doesn't seem to be working correctly and I am not sure as to why. I believe that I am doing this correctly, but EAX remains \"2\" every loop.\n\n```\n    INCLUDE Irvine32.inc\n    .data\n        prev DWORD ?\n        next DWORD ?\n        val DWORD ?\n        count DWORD ?\n        total DWORD ?\n\n        myMsg BYTE \"Fibonacci Sequence \",0dh,0ah,0\n\n   .code\n    main PROC\n       mov ecx,15\n       mov val,1\n       mov prev,-1\n       mov eax,1\n       mov edx,OFFSET myMsg\n       call WriteString\n\n    L1:\n       mov count,ecx\n       mov ebx,val\n       add ebx,prev\n       mov total,ebx\n       mov ebx,val\n       mov prev,ebx\n       mov eax,total\n       mov val, ebx\n       call WriteInt\n       call Crlf\n       loop L1\n\n    exit\n    main ENDP\n    END main\n```\n\n    ", "Answer": "\r\nCould look like this (untested):\n\n```\n    mov  ecx, 15\n    mov  eax, 0    ;a = 0\n    mov  ebx, 1    ;b = 1\n_fib:\n    mov  edx, eax \n    add  edx, ebx  ;sum = a + b\n    mov  eax, ebx  ;a = b\n    mov  ebx, edx  ;b = sum\n    loop _fib\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Producing the Nth value of Fibonacci Sequence in Java [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is not reproducible or was caused by typos. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question was caused by a typo or a problem that can no longer be reproduced. While similar questions may be on-topic here, this one was resolved in a way less likely to help future readers.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThis is the program I'm running to print the nth value of the Fibonacci sequence, but I've come across the problem that when I enter an invalid value I defined, it still runs the loop either way. For example if I enter 0, it will print:\n\n\"Not a valid number\nThe 0 value of the Fibonacci Sequence is 0\"\n\nHopefully someone can point out where I made my error, I've reviewed all of my bracketing and I can't find where the mistake might be\n\n```\n//position is user input for nth position, fold2 and fnew will calculate fSequence to find value\n\nint position, fold1, fold2, fNew, loopCount;\n\n//telling user what program will do and stipulations on how to get program to execute correctly\nSystem.out.println(\"This program will tell you the nth value of the Fibonacci sequence.\");\nSystem.out.println(\"Enter an integer (1 - 46):\");\nposition = keyboard.nextInt();\n\nfold1 = 0;\nfold2 = 1; \n\n//setting upper parameters for limit on given positions\nif (position < 1 || position > 46){\n    System.out.println(\"Not a valid number\");\n} \nelse {\n    for (loopCount = 0; loopCount < position; loopCount++ ){\n        fNew = fold1 + fold2;\n        fold1 = fold2;\n        fold2 = fNew;                       \n    }\n}\n\nSystem.out.println(\"The \" + position + \" of the Fibonacci Sequence is \" + fold1);\n```\n\n    ", "Answer": "\r\nYour\n```\nSystem.out.println(\"The \" + position + \" of the Fibonacci Sequence is \" + fold1);```\n is outside the ```\nelse```\n scope, hence executed no matter what the condition is.\n\nYour code should read,\n\n```\n if (position < 1 || position > 46){\n        System.out.println(\"Not a valid number\");\n    } \n    else {\n        for (loopCount = 0; loopCount < position; loopCount++ ){\n            fNew = fold1 + fold2;\n            fold1 = fold2;\n            fold2 = fNew;\n            System.out.println(\"The \" + position + \" of the Fibonacci Sequence is \" + fold1);                       \n        }\n    }   \n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Non-recursive Fibonacci Sequence in Assembly\r\n                \r\nIn some homework, I have to create a Fibonacci Sequence program in Assembly. I created this code, but it doesn't seem to be working correctly and I am not sure as to why. I believe that I am doing this correctly, but EAX remains \"2\" every loop.\n\n```\n    INCLUDE Irvine32.inc\n    .data\n        prev DWORD ?\n        next DWORD ?\n        val DWORD ?\n        count DWORD ?\n        total DWORD ?\n\n        myMsg BYTE \"Fibonacci Sequence \",0dh,0ah,0\n\n   .code\n    main PROC\n       mov ecx,15\n       mov val,1\n       mov prev,-1\n       mov eax,1\n       mov edx,OFFSET myMsg\n       call WriteString\n\n    L1:\n       mov count,ecx\n       mov ebx,val\n       add ebx,prev\n       mov total,ebx\n       mov ebx,val\n       mov prev,ebx\n       mov eax,total\n       mov val, ebx\n       call WriteInt\n       call Crlf\n       loop L1\n\n    exit\n    main ENDP\n    END main\n```\n\n    ", "Answer": "\r\nCould look like this (untested):\n\n```\n    mov  ecx, 15\n    mov  eax, 0    ;a = 0\n    mov  ebx, 1    ;b = 1\n_fib:\n    mov  edx, eax \n    add  edx, ebx  ;sum = a + b\n    mov  eax, ebx  ;a = b\n    mov  ebx, edx  ;b = sum\n    loop _fib\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence in Java taking too long?\r\n                \r\nI'm trying to find the sum of the Fibonacci sequence in Java, but the run time is taking way too long (or is it suppose to?). This slows down anytime I use an integer past 40.\n\nNote: At 50, a negative value is returned which boggles my mind. \n\nAny advice? \n\n```\npublic static void main(String[] args) {        \n    //Find Fibonacci sequence\n    int sum=getSum(50);\n    System.out.println(\"Sum of Fibonacci Numbers is \" + sum); \n}\nstatic int getSum(int n){\n    if (n==0) return 0;\n    if (n==1 || n==2) return 1;\n    else return getSum(n-1) + getSum(n-2);\n}\n```\n\n    ", "Answer": "\r\nFor ```\nn > 2```\n, an invocation of your ```\ngetSum(n)```\n recursively invokes itself twice.  Each of those invocations may recurse further.  The total number of method invocations scales as ```\n2^n```\n, and ```\n2^50```\n is a very large number.  This poor scaling reflects the fact that the simple-minded recursive approach ends up needlessly recomputing the same results (e.g. fib(4)) a great many times, and it is why your program slows down so rapidly as you increase ```\nn```\n.\n\nThe negative return value you get after a certain point arises from exceeding the limits of data type ```\nint```\n.  You could get a larger limit with a wider data type, presumably ```\nlong```\n.  If that's not enough then you would need to go to something like ```\nBigInteger```\n, at a substantial performance penalty.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Postgres approach to solving Fibonacci sequence\r\n                \r\nI'm trying to solve a question to generate the fibonacci sequence using SQL. Through my method, the query is timing out after about the 21st iteration call using the function through a series of ```\nunion all```\n against it.\n```\ncreate function f(bigint) returns bigint\n  as 'select case\n        when $1 = 0 then 0\n        when $1 = 1 then 1\n        when $1 = 2 then 1\n        when $1 = 3 then 2\n      else f($1-1) + f($1-2)\n      end;'\nlanguage sql\nimmutable\nreturns null on null input;\n```\n\ncurrent query to generate f(n) as rows in a table:\n```\nselect f(0) as x\nunion all\nselect f(1) as x\nunion all\nselect f(2) as x\nunion all\n...\nselect f(21) as x\n```\n\nCould ```\ngenerate_series(start, end)```\n with ```\nf(start),f(end)```\n somehow be leveraged? Did try this approach but it is not working it seems as it simply returns results from start to end and not the fibonacci sequence itself.\nAny suggestions or alternate approached are welcome. Thanks.\n    ", "Answer": "\r\nLike Mike, my first thought was a recursive CTE.  However, I would phrase it as:\n```\nwith recursive seed (n, fib_n, fib_n_minus_1) as (\n       values (1::numeric, 1::numeric, 0::numeric)\n      ),\n      fib (n, fib_n, fib_n_minus_1) as (\n       select n, fib_n, fib_n_minus_1\n       from seed\n       union all\n       select n + 1, fib_n + fib_n_minus_1, fib_n\n       from fib f\n       where n < 1000\n     )\nselect *\nfrom fib\norder by n;\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Creating table for Fibonacci Sequence\r\n                \r\nThank you in advance. I appreciate any and all feedback. I am new to programming and i am working on an assignment that prints the Fibonacci Sequence based on how many numbers the user asks for. I have most of the code complete, but there is one remaining piece I am having difficulty with. I would like my output in a table format, but something is off with my code and I am not getting all of the data I would like in my output. In grey is my code, my output, and my desired output. \n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\nint i, n;\nint sequence = 1;\nint a = 0, b = 1, c = 0;\n\nprintf(\"How many Fibonacci numbers would you like to print?: \");\nscanf(\"%d\",&n);\n\nprintf(\"\\n n\\t\\t Fibonacci Numbers\\n\");\n\nprintf(\" %d \\t\\t\\t%d\\n \\t\\t\\t%d\\n \", sequence, a, b);\n\nfor (i=0; i <= (n - 3); i++)\n{\n    c = a + b;\n    a = b;\n    b = c;\n    sequence++;\n    printf(\"\\t\\t\\t%d\\n \", c);\n}\nreturn 0;\n}\n\nHere is my output: \nHow many Fibonacci numbers would you like to print?: 8\n\nn        Fibonacci Numbers\n1           0\n            1\n            1\n            2\n            3\n            5\n            8\n            13\n\nHere is my desired output: \nHow many Fibonacci numbers would you like to print?: 8\n\n n       Fibonacci Numbers\n 1          0\n 2          1\n 3          1\n 4          2\n 5          3\n 6          5\n 7          8\n 8          13\n```\n\n    ", "Answer": "\r\n\n  I am not getting all of the data\n\n\n\nThat's because you are not printing the ```\nsequence```\n in ```\nprintf()```\n of the ```\nfor```\n loop.\n\n```\nprintf(\"\\t\\t\\t%d\\n \", c);\n```\n\nand even before 2nd number before ```\nfor```\n loop\n\n```\nprintf(\" %d \\t\\t\\t%d\\n \\t\\t\\t%d\\n \", sequence, a, b);\n```\n\n\n\n\n\ntry making the below changes to your code :\n\n```\nprintf(\" %d \\t\\t\\t%d\\n %d\\t\\t\\t%d\\n \", sequence, a, sequence+1, b);\n\nsequence++; //as you've printed 2 values already in above printf\n\nfor (i=0; i <= (n - 3); i++)\n{\n    c = a + b;\n    a = b;\n    b = c;\n    printf(\"%d\\t\\t\\t%d\\n \",++sequence, c); \n //or do sequence++ before printf as you did and just use sequence in printf\n}\n```\n\n\n\n\nsample input : ```\n5```\n\n\nsample output :\n\n```\nHow many Fibonacci numbers would you like to print?: 5 \n n       Fibonacci Numbers\n 1          0\n 2          1\n 3          1\n 4          2\n 5          3\n```\n\n\n\n\nEdit : you can do it using functions this way... it's nearly the same thing :)\n\n```\n#include <stdio.h>\n\nvoid fib(int n)\n{\n    int i,sequence=0,a=0,b=1,c=0;\n\n    printf(\"\\n n\\t\\t Fibonacci Numbers\\n\");\n\n    printf(\" %d \\t\\t\\t%d\\n %d\\t\\t\\t%d\\n \", sequence, a, sequence+1, b);\n\n    sequence++;\n\n    for (i=0; i <= (n - 2); i++)\n    {\n        c = a + b;\n        a = b;\n        b = c;\n        printf(\"%d\\t\\t\\t%d\\n \",++sequence, c);\n    }\n}\n\nint main()\n{\nint n;\n\nprintf(\"How many Fibonacci numbers would you like to print?: \");\nscanf(\"%d\",&n);\nfib(n);\n\nreturn 0;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence numbers to list with an optional start parameter\r\n                \r\nI am trying to create a function which will take a number n as its parameter and returns the first n elements of a fibonacci sequence in a list.\nBut, I also want to include an optimal parameter 'start' (a pair of numbers, which specifies the first two elements of a generalised Fibonacci sequence.\nAny ideas how to include the optional parameter in the code?\nThanks for help in an advance.\n```\ndef fibonacci(n: int, start: tuple[int, int] = (0, 1)) -> list[int]:\n    sequence = [0,1]\n\n    for i in range(3,n+1):\n        next_num = sequence[-1] + sequence[-2]\n        sequence.append(next_num)\n    \n    return sequence\n\nprint(fibonacci(8))\n```\n\nCurrent output\n```\n[0, 1, 1, 2, 3, 5, 8, 13]```\n\n\nDesired input ```\nfibonacci(6, start=(2, 2))```\n\nDesired output ```\n [2, 2, 4, 6, 10, 16]```\n\nCurent output ```\n[0, 1, 1, 2, 3, 5]```\n\n    ", "Answer": "\r\nBecause You pass ```\nstart```\n as a ```\ntuple```\n you need to convert this to a ```\nlist```\n and assign it to ```\nsequence```\n.\n```\ndef fibonacci(n, start = (0, 1)):\n    sequence = list(start)\n\n    for i in range(3,n+1):\n        next_num = sequence[-1] + sequence[-2]\n        sequence.append(next_num)\n    \n    return sequence\n\nprint(fibonacci(8))\n# [0, 1, 1, 2, 3, 5, 8, 13]\n\nprint(fibonacci(6, start=(2, 2)))\n# [2, 2, 4, 6, 10, 16]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Print Fibonacci sequence up to nth place?\r\n                \r\nI am trying to print the entire fibonacci sequence up to a given place. So the user would decide how many numbers of the fibonacci sequence they want to see (up to 16 repetitions) and it would print the entire sequence.\n\nMy current code only prints the number in the sequences for the place that you choose.\nex: 4 prints 2 instead of 0 1 1 2.\n\n```\npublic int Fibonacci(int number){\n    if(number == 1 || number == 2){\n        return 1;\n    }\n    int fib1=1, fib2=1, fibonacci=1;\n    for(int count= 3; count<= number; count++){\n        fibonacci = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = fibonacci;\n    }\n    return fibonacci;\n}\n```\n\n\nHere is my main method:\n\n```\nimport java.util.Scanner;\n\npublic class FibonacciPrinter \n{\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        System.out.print(\"Enter an integer: \");\n        int input = in.nextInt();\n\n        FibonacciGenerator newNumber = new FibonacciGenerator();\n\n        for(int fibCount = 0; fibCount < input; fibCount++)\n        {\n            System.out.println(newNumber.Fibonacci(input));\n        } \n    }\n}\n```\n\n    ", "Answer": "\r\nI think here,\n\n```\nfor(int fibCount = 0; fibCount < input; fibCount++)\n{\n  System.out.println(newNumber.Fibonacci(input));\n} \n```\n\n\nYou almost certainly wanted,\n\n```\nfor(int fibCount = 0; fibCount < input; fibCount++)\n{\n  System.out.println(newNumber.Fibonacci(fibCount)); // <-- fibCount not input\n} \n```\n\n\nYou need to update your method to handle the zero case, for example\n\n```\n public int Fibonacci(int number) {\n   if (number == 0) return 0;\n   // ...\n }\n```\n\n\nand in Java, the convention would name ```\nFibonacci```\n to ```\nfibonacci```\n because method names are camel case starting with a lower case letter (classes start with a capital letter by convention).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "C# Fibonacci Sequence Replication\r\n                \r\nI'm attempting to solve the second problem on Project Euler, here is the problem:\n\n\n  Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n  \n  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n  \n  Find the sum of all the even-valued terms in the sequence which do not exceed four million.\n\n\nSo, I have set up the following:\n\n```\nusing System;\n\nnamespace ProjectEuler\n{\n    class Question2\n    {\n        //Project Euler - Question 2\n        //Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n        //1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n        //Find the sum of all the even-valued terms in the sequence which do not exceed four million\n        static void Main()\n        {\n            int sum = 0;\n\n            int oldNumber = 1;\n            int currentNumber = 1;\n            int nextNumber;\n\n            while (currentNumber <= 500)\n            {\n                nextNumber = currentNumber + oldNumber;\n\n                if (nextNumber % 2 == 0)\n                {\n                    sum += currentNumber;\n                }\n            }\n\n            Console.WriteLine(\"Project Euler - Question 2\\n\\nAnswer: \" + sum);\n            Console.ReadLine();\n        }\n    }\n}\n```\n\n\nWhen I run the program, there is nothing visible, just a cursor in the Windows command line.  I think that may be do the fact that currentNumber isn't getting updated, but I can't think of how to do that properly, if that even is the case.\n    ", "Answer": "\r\nYou don't have a condition to end your loop.  You never change the value of currentNumber to anything but 1.\n\nYou probably want something like:\n\n```\nnextNumber = currentNumber + oldNumber;\noldNumber = currentNumber;\ncurrentNumber = nextNumber;\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence python without the term zero\r\n                \r\nJust wondering if there was any possible way to print out a fibonacci sequence starting with 1.\nExample:\nFibonacci sequence for MAX = 17 is as\n1,\n1,\n2,\n3,\n5,\n8,\n13,\n21,\n34,\n55,\n89,\n144,\n233,\n377,\n610,\n987.\nThis is the current code I have:\n```\nMAX = 17\nn1, n2 = 0,1\ni= 0\nwhile i < MAX:\n    print(n1)\n    nth = n1 + n2\n    n1 = n2\n    n2 = nth\n    i +=1\n```\n\nI don't know how to get rid of zero without hindering the code.\n    ", "Answer": "\r\nTo perform this action, I would do the following:\nI would start n1 and n2 at 1 and 1, respectively. Like this:\n```\nMAX = 17\nn1, n2 = 1, 1\ni = 0\nwhile i < MAX:\n  print(n1)\n  nth = n1 + n2\n  n1 = n2\n  n2 = nth\n  i += 1\n```\n\nI think you can also get the same result by changing the \"```\nwhile```\n\" loop to ```\ni<= MAX```\n and making \"```\nMAX```\n\" start at 16.\nI hope I have been helpful.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Define a function: Fibonacci Sequence in python [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 1 year ago.\r\n                    \r\n                \r\n            This post was edited and submitted for review 1 year ago and failed to reopen the post:\r\n            \r\n                    Original close reason(s) were not resolved\r\n            \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI want to execute the first 20 entries of the Fibonacci Sequence.\nLike this 1,1,2,3,5,8.... with 4 entries per line.\nI tried the following code:\n```\ndef fib(n):\n    a, b = 0, 1\n    while a < n:\n        print(a, end=' ')\n        a, b = b, a+b\n    print()\n\nfib(20)\n```\n\n    ", "Answer": "\r\n```\ndef fib(n):\n    a=[1,1]\n    for i in range(2,n):\n        a.append(a[i-1]+a[i-2])\n    return a\n\na=fib(20)\nfor i in range(20):\n    print(a[i],end=\" \")\n    if(i+1)%4==0:\n        print()\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "The math step in the Fibonacci sequence\r\n                \r\nAgain new to Python.\n\nWrite the Fibonacci sequence using a ```\nfor```\n loop.\n\nI understand how ```\nfor```\n loops work, you're basically telling a function to run on repeat for a given range of numbers.\nThis might sound dumb but I can't wrap my head around the math step of it. I know Fibonacci is the two previous numbers added together give the current number in the I have seen a bunch of examples of the code but it's just not clicking for me. Here my code (I stole the math piece from someone else):\n```\nn = int(input(\"Please provide a sequence term: \"))\n\ndef fib2(num):\n    a, b = 1, 1\n    for i in range(num - 1):\n        a, b = b, a + b\n    return (\"The nth term in the Fibonacci sequence is:\", a)\n\nprint(fib2(n))\n```\n\nAlso, can someone tell me how to make ```\nnth```\n be the input value for ```\nn```\n?\n    ", "Answer": "\r\nIn the first column are values for ```\ni```\n - in every next iteration it increases.\n```\ni        1    1    2    3    5    8\n         a    b  (a+b)  \n0             a    b  (a+b)\n1                  a    b  (a+b)\n2                       a    b  (a+b)\n3                            a    b\n```\n\nYou may see, that in every next row (step, iteration) previous ```\nb```\n becomes ```\na```\n, and previous ```\n(a+b)```\n becomes ```\nb```\n, so someone would have temptation write it in the form\n```\n a = b \n b = a + b\n```\n\nBut it is wrong — the first statement changes ```\na```\n, whereas we need to use the unchanged value of it in the second statement.\nWe need to change values of both variables ```\na```\n and ```\nb```\n on the basis of their current, unchanged values obtained from the preceding iteration.\nIn Python it is possible by using the single statement\n```\na, b = b, a + b\n```\n\n\nNote\nInstead of\n```\nreturn (\"The nth term in the Fibonacci sequence is:\", a)\n```\n\nuse\n```\nreturn f\"The {num}th term in the Fibonacci sequence is {a}\"\n```\n\nto obtain a prettier output.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How do I fix this Fibonacci Sequence?\r\n                \r\nI wrote this c++ Program that's suppose to do the Fibonacci Sequence. The problem once I pass 8 the sequence goes bad, like instead of the last number it messes up, I don't know how to explain it, just read the source code, but please help me, thanks very much.\n\n```\n#include <iostream>\n#include <unistd.h>\nusing namespace std;\n\nint main()\n{\n    sleep(3);\n    cout << \"Doing The Fibonacci Sequence\"; sleep(5);\n    cout << \"\"<<endl;\n    for (int num=1; num <= 8; num++)\n    {\n        /*int number, lastnum;\n          lastnum = num - 1;\n          number = num + lastnum;\n          cout << number<<endl;\n        */\n        for(int i=1; i <= 8; i++)\n        {\n            //cout << num << \"+\" << i <<endl;\n            int numb = num+i;\n            int nun  = numb - 1;\n            int c = nun + i;\n            cout << nun << \" + \" << i << \" = \" << c <<endl;\n            num ++;\n        }\n\n    }\n    return 0;\n}\n\n/*The Output\n  Doing The Fibonacci Sequence\n1 + 1 = 2\n3 + 2 = 5\n5 + 3 = 8\n7 + 4 = 11\n9 + 5 = 14\n11 + 6 = 17\n13 + 7 = 20\n15 + 8 = 23\n\n*/\n```\n\n    ", "Answer": "\r\n```\n#include <iostream>\n//#include <unistd.h> \nusing namespace std;\n\nint main()\n{\n    //sleep(3);\n    int number;\n    cout << \"Doing The Fibonacci Sequence\"; //sleep(5);\n    cout << \"\"<<endl;\n    cin>>number;\n    int a=1;\n    int b=1;\n\n    for (int num=1; num < number-1; num++)\n    {\n        int c=a+b;\n        cout << a << \" + \" << b << \" = \" << c <<endl;\n        a=b;\n        b=c;\n    }\n    return 0;\n}\n```\n\n\noutput\n\n```\nDoing The Fibonacci Sequence\n\n8\n1 + 1 = 2\n1 + 2 = 3\n2 + 3 = 5\n3 + 5 = 8\n5 + 8 = 13\n8 + 13 = 21\n```\n\n\ncheck the code and see it might answer your question.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Constructing the Fibonacci sequence in Haskell [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Generating Fibonacci numbers in Haskell?\r\n                            \r\n                                (12 answers)\r\n                            \r\n                    \r\n                Closed 6 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm a complete beginner with Haskell and just encountered the following terse expression for constructing the Fibonacci sequence:\n\n```\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n```\n\n\nI think I understand what each individual piece is doing (```\n:```\n, ```\nzipWith```\n, ```\ntail```\n), and I know some sort of recursion is happening, but am not quite sure how.\n    ", "Answer": "\r\nThe first two values are 0 and 1.  Thereafter, the elements are appended (zipped on) by adding the current and immediately previous series, shifted by one position.\n\nFor instance, if the \"current\" list is (0, 1, 1, 2, 3, 5), then the tail is (1, 1, 2, 3, 5).  Adding these gives us ...\n\n```\nfibs = (0, 1, 1, 2, 3, 5)\ntail = (1, 1, 2, 3, 5)\nsum  = (1, 2, 3, 5, 8)\n```\n\n\nThis gives us the expression\n\n```\n0: 1: (1, 2, 3, 5, 8)\n```\n\n\n... which results in a one-element extension of the list.  When we recur on this without limit, we get the Fibonacci sequence.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursion error in R (Fibonacci sequence)\r\n                \r\nSo I am trying to learn R on my own and am just working through the online tutorial. I am trying to code a recursive function that prints the first n terms of the Fibonacci sequence and can't get the code to run without the error:  \n\n\n  Error in if (nterms <= 0) { : missing value where TRUE/FALSE needed\n\n\nMy code does ask me for input before entering the ```\nif else```\n statement either which I think is odd as well. Below is my code any help is appreciated.\n\n```\n#Define the fibonacci sequence\n\nrecurse_fibonacci <- function(n) {\n    # Define the initial two values of the sequence\n\n    if (n <= 1){\n        return(n)\n    } else {\n\n    # define the rest of the terms of the sequence using recursion\n    return(recurse_fibonacci(n-1) + recurse_fibonacci(n-2))\n    }\n}\n\n#Take input from the user\nnterms = as.integer(readline(prompt=\"How many terms? \"))\n\n# check to see if the number of terms entered is valid\nif(nterms <= 0) {\n    print(\"please enter a positive integer\")\n} else {\n\n    # This part actually calculates and displays the first n terms of the sequence\n    print(\"Fibonacci Sequence: \")\n    for(i in 0:(nterms - 1)){\n        print(recurse_fibonacci(i))\n    }\n}\n```\n\n    ", "Answer": "\r\nThis is a problem of ```\nreadline```\n in non-interactive mode. ```\nreadline```\n does not wait for a keypress and immediately executes the next instruction. The solution below is the solution posted in this other SO post.  \n\nI post below a complete answer, with the Fibonnaci numbers function a bit modified.\n\n```\nrecurse_fibonacci <- function(n) {\n  # Define the initial two values of the sequence\n  if (n <= 1){\n    n\n  } else{\n    # define the rest of the terms of the sequence using recursion\n    Recall(n - 1) + Recall(n - 2)\n  }\n}\n\n#Take input from the user\ncat(\"How many terms?\\n\")\nrepeat{\n  nterms <- scan(\"stdin\", what = character(), n = 1)\n  if(nchar(nterms) > 0) break\n}\nnterms <- as.integer(nterms)\n\n# check to see if the number of terms entered is valid\nif(nterms <= 0) {\n  print(\"please enter a positive integer\")\n} else {\n  # This part actually calculates and displays the first n terms of the sequence\n  print(\"Fibonacci Sequence: \")\n  for(i in 0:(nterms - 1)){\n    print(recurse_fibonacci(i))\n  }\n}\n```\n\n\nThis code is the contents of file ```\nfib.R```\n. Running in a Ubuntu 20.04 terminal gives\n\n```\nrui@rui:~$ Rscript fib.R\nHow many terms?\n8\nRead 1 item\n[1] \"Fibonacci Sequence: \"\n[1] 0\n[1] 1\n[1] 1\n[1] 2\n[1] 3\n[1] 5\n[1] 8\n[1] 13\nrui@rui:~$\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Does Ruby already know the Fibonacci Sequence?\r\n                \r\nThe following method is used to find the nth number in the Fibonacci Sequence:\n```\ndef fibonacci(number)\n  if number < 2\n    number\n  else\n    fibonacci(number - 1) + fibonacci(number - 2)\n  end\nend\n\nputs fibonacci(6)\n```\n\nThe answer is ```\n8```\n (the sixth number in the sequence if you start counting from 1 and not 0 (0, 1, 1, 2, 3, 5, 8...)\nThe above code simply deals with the position of numbers in the sequence, right? So how does Ruby already know what the value of a number is at a given position? In the words, how does Ruby know that ```\nfibonacci(4)```\n has the value ```\n3```\n ? Is the Fibonacci sequence already built in to Ruby?\n    ", "Answer": "\r\nNo, the sequence is not built in.\n```\nfibonacci```\n is a recursive function. It will be called nine times (!) to compute ```\nfibonacci(4)```\n to get ```\n3```\n. (By the way, this is a terrible approach to calculating Fibonacci numbers. 25 calls for ```\nfibonacci(6)```\n! It should at least memoize previous calculations.)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "writing a method for fibonacci sequence\r\n                \r\nI'm trying to write a for loop that calls the method fibonacci and prints the first 25 numbers in the fibonacci sequence. The problem is I'm a little confused about how to do that correctly.   I'm a little confused about when the for loop in the run method calls the fibonacci method do the values inside the fibonacci method reset after reach pass of the for loop? So for example during the first pass of the for loop i = 0 and the values for int a and int b change inside the the fibonacci method. Do the values inside the fibonacci method reset on the next pass of the for loop? \n\n```\nimport acm.program.*;\n\npublic class Fibonacci extends ConsoleProgram{\nprivate void run(){\n\n  for(int i = 0; i <= 25; i++){\n    fibonacci(i);\n    println(fibonacci(i));\n   }\n\n\n}\n private int fibonacci(int n){\n   int n = 0;\n\n   int a = 0; \n   int b = 1;\n\n   while (n < 25);\n\n   int c = a + b;\n   a = b;\n   b = c;\n\n     }\n   return(a);\n\n}\n```\n\n    ", "Answer": "\r\nYou're looping in two different places - ```\nrun()```\n and ```\nfibonacci()```\n.  Only one of these places should care about the loop, and the other should care about computing Fibonacci(n).\n\nWhat we can do remove the loop from ```\nfibonacci```\n, and only rely on the loop on the outside.  Also, we're going to remove that statement ```\nint n = 0```\n, since that shadows the parameter you're passing in.\n\nLastly, we're going to create two new static variables ```\na```\n and ```\nb```\n, so that the values of those are preserved with this instance.  If you don't do that, then you'd have to rely on either recursion or some other methodology to provide the appropriate values of ```\na```\n and ```\nb```\n.\n\nI'm not entirely sure why you need to extend ```\nConsoleProgram```\n, but I'll leave it in for now.\n\nSo, here's what it should look like.\n\n```\npublic class Fibonacci extends ConsoleProgram {\n    static int a = 0;\n    static int b = 1;\n\n    public void run() {\n        for(int i = 0; i <= 25; i++) {\n            // Print the call to fibonacci(i) with every iteration.\n        }\n    }\n\n    private int fibonacci(int n) {\n        int c = a + b;\n        a = b;\n        b = c;\n        return c;\n    }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence with vectors\r\n                \r\nI'm currently trying to solve some problems of the Euler-Projects, but I'm currently stuck at the second problem. Here is what I have right now:\n\n```\nvoid p002()\n{\n    unsigned int result = 0;    \n    std::vector<int> fibonacci{ 1,2 };\n\n    for (int i = 2; fibonacci.at(i) < 4000000; i++)\n    {\n        fibonacci.at(i) = fibonacci.at(i - 1) + fibonacci.at(i - 2); //<- Doesn't work\n        if (fibonacci.at(i) % 2 == 0)\n            result += fibonacci.at(i);\n    }\n\n    std::cout << result;\n}\n```\n\n\nCould someone help me out and tell me why this one line doesn't seem to work? (I get an \"abort() called\" error when trying to execute the code.)\n\nIn case anyone wonders: The task is to get the sum of all integers of the fibonacci sequence with a lower value than 4,000,000 which are even-valued.\n\nThanks!\n    ", "Answer": "\r\n```\nvector::at```\n throws an exception if you try to access an element at an index that is out of bounds. Your vector contains 2 elements (at indices 0 and 1). Therefore ```\nfibonacci.at(2)```\n is out of bounds, and an exception is thrown. You don't catch the exception, so ```\nstd::terminate```\n is called. By default, ```\nstd::terminate```\n points to ```\nabort```\n which terminates your process.\n\nSolution: Add enough elements into the vector so that ```\nfibonacci.at(i)```\n isn't out of bounds.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "python using the fibonacci sequence\r\n                \r\nI am trying to only have the words print out if they occur the same number of times as in the fibonacci sequence.  If a words show up 1,2,3,5,8 etc then it will print up.  I have gotten the program to print up the words based on how many times the appear.  I am having trouble figuring out how to use the sequence in my program.  Any tips or examples would be very appreciated.\n\n```\ndef fib():\n    a,b = 0, 1\n    while 1:\n            yield a\n            a, b= b, a+b\n\nfrom collections import Counter \nimport string\n\n\nwhile True:\n    filename=raw_input('Enter a file name: ')\n    if filename == 'exit':\n        break\n    try:\n        file = open(filename, 'r') \n        text=file.read() \n        file.close() \n    except:\n        print('file does not exist')\n    else:\n\n        for word in string.punctuation:\n            text=text.replace(word, \"\")\n        word_list = text.lower().split(None)\n        word_freq = {}\n\n        for word in word_list:\n            if len(word) > 1:\n                word_freq[word] = word_freq.get(word, 0) + 1\n\n        print(sorted(word_freq.items(), key=lambda item: item[1])) \n// I am pretty sure something with the seqeunce should go into the above line\n// but have been unable to figure it out.         \n\nprint('Bye')\n```\n\n    ", "Answer": "\r\n```\nclass FibSet:\n    '''Fibonacci sequence with the in operator defined'''\n\n    def __init__(self):\n        self.a, self.b = 0, 1\n        self.fib = set()\n\n    def __contains__(self, n):\n        if n > self.b:\n            self.compute_upto(n)\n        return n in self.fib\n\n    def compute_upto(self, n):\n        while self.b < n:\n            self.fib.add(self.a)\n            self.a, self.b = self.b, self.a + self.b\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Error in C#\r\n                \r\nI've recently started learning C# (having learnt other languages) and I'm trying to create a function that generates the fibonacci sequence to the 'nth' term using a while loop and then returns the value of the 'nth' term. \nMy current code is this:\n\n```\n    void fibonacci(int n)\n    {\n        int[] terms = { 0, 1 };\n        int i = 2;\n\n        while (i<=n)\n        {\n            terms.Concat( terms[i-1] + terms[i-2] );\n            i += 1;\n        }\n\n        return terms[n];\n    }\n```\n\n\nMy understanding of C# is very poor as visual studio is telling me that I can't use 'Concat' with int[] - I'm trying to append the array with the new values. Any help would be great.\n    ", "Answer": "\r\nArrays in C# are fixed length. \n\nIf you want to use a variable length collection, use a strongly typed ```\nList<T>```\n instead, which has an ```\nAdd```\n method:\n\n```\nint fibonacci(int n)\n{\n    var terms = new List<int>{ 0, 1 };\n    int i = 2;\n\n    while (i<=n)\n    {\n        terms.Add( terms[i-1] + terms[i-2] );\n        i += 1;\n    }\n\n    return terms[n];\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "display Fibonacci sequence with disp_function in matlab [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\ni want to result Fibonacci sequence from its  formula:\n\n```\n1+sqrt(5)/2).^n-(1-sqrt(5)/2).^n)/sqrt(5);```\n \n\nby disp function,not fprintf;but i couldn't. how can write it by disp to below form:\n```\nf(0)= 0\nf(1)= 1\nf(2)= 1\nf(3)= 2```\n\n    ", "Answer": "\r\n\nFirst of all, you had errors in you code when calculate Fibonacci sequence, where brackets should surround ```\n1+sqrt(5)```\n and ```\n1-sqrt(5)```\n\nSecondly, you can remove ```\n;```\n at the end of expression ```\nf = ...```\n, such that it will display ```\nf```\n in the command window\n\n\nExample\n\n```\nn = 1:10;\nf=(((1+sqrt(5))/2).^n-((1-sqrt(5))/2).^n)/sqrt(5)\n```\n\n\nsuch that\n\n```\nf =\n\n    1.0000    1.0000    2.0000    3.0000    5.0000    8.0000   13.0000   21.0000   34.0000\n```\n\n\nor display result like below\n\n```\nfor n = 1:10\n  f=(((1+sqrt(5))/2).^n-((1-sqrt(5))/2).^n)/sqrt(5);\n  disp(['F(',num2str(n-1),')=',num2str(f)]);\nend\n```\n\n\nsuch that\n\n```\nF(0)=1\nF(1)=1\nF(2)=2\nF(3)=3\nF(4)=5\nF(5)=8\nF(6)=13\nF(7)=21\nF(8)=34\nF(9)=55\n```\n\n\nUPDATE\n\nIf you would like to apply ```\narrayfun```\n, you can use the code below\n\n```\na =input('n:');\nn = 1:a;\nfdisp = @(n) disp(['F(',num2str(n-1),')=',num2str((((1+sqrt(5))/2).^n-((1-sqrt(5))/2).^n)/sqrt(5))]);\n\narrayfun(fdisp,n)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "sum of even numbers in Fibonacci sequence\r\n                \r\nI'm trying to create a function to calculate the sum of only even numbers  in Fibonacci sequence. How can I make  this if/while loop to work?.\n\n```\nfunction fib() {\n  var x, y, total;\n  for (var i = 0; i < 10; i++) {\n    if (i === 0) {\n      x = 1;\n      y = 2;\n    }\n\n    while( x % 2) {\n      total = x + y;\n      x = y;\n      y = total;\n    }\n\n    return(total);\n  }\n};\n```\n\n    ", "Answer": "\r\n\r\n\r\n```\nfunction sumFibs(num) {\r\n  let a = 1,\r\n    b = 1,\r\n    acc = 0;\r\n\r\n  for (let i = 0; i < num - 2; i++) {\r\n    let c = a;\r\n\r\n    a += b;\r\n    b = c;\r\n\r\n    if (a % 2 === 0) {\r\n      acc += a;\r\n    }\r\n  }\r\n\r\n  return acc;\r\n}\r\n\r\nconsole.log(sumFibs(10)); // Logs out the even sum of the first 10 fabonacci sequence```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Print the Fibonacci Sequence to the screen (5 columns of numbers per row)\r\n                \r\nI an trying to print the Fibonacci sequence to the canvas. 5 numbers per row\nI have calculated the Fibonacci sequence but printing 5 numbers per row to the canvas is the issue. This is what I have done so far\n\n```\nimport javax.swing.JOptionPane;\nint fibonacciNumber; //the Fibonacci Number\nint fibNum1; //Fibonacci Number 1\nint fibNum2;// Fibonacci Number 2\nfinal int COL_NUM = 5;\nString n = JOptionPane.showInputDialog(\"Choose the Nth Fibonacci number\"); \n\n// collect the n Fibonacci number for the user;\nvoid setup(){\n    size(500 , 500);\n}\n\nvoid draw(){\n    background(128);\n}\n\nvoid fibonacciSequance(){\n    //Calculate the Fibonacci number\n    fibNum1 = 0;\n    fibNum2 = 1;\n    for(int x=1; x<=int(n); x++){\n        //if x is <= 1 ..output should be 1\n        if(x <= 1){\n            fibonacciNumber = fibNum2;\n        }// if()\n        else{\n            /*\n            Calculating the Fibonacci  Sequence\n            */\n            fibonacciNumber = fibNum1 + fibNum2;\n            fibNum1 = fibNum2;\n            fibNum2 =  fibonacciNumber;\n        }//else()\n    }//for()\n}\n\nvoid printSequence( ){\n}\n```\n\n    ", "Answer": "\r\nHere is the code, if you do not understand some part of it, feel free to ask.\n\n```\nimport javax.swing.JOptionPane;\n\nint fibonacciNumber; //the Fibonacci Number\nint fibNum1; //Fibonacci Number 1\nint fibNum2;// Fibonacci Number 2\n\nfinal int GRID_SIZE = 100;//because it is the number of numbers per row and column\nString n = JOptionPane.showInputDialog(\"Choose the Nth Fibonacci number\"); \nfinal int FONT_SIZE = 25;\n\n// collect the n Fibonacci number for the user;\nvoid setup() {\n  size(500, 500);\n  background(128);\n  textSize(FONT_SIZE);\n  fibonacciSequance();\n}\n\nvoid fibonacciSequance() {\n  //Calculate the Fibonacci number\n  fibNum1 = 0;\n  fibNum2 = 1;\n  int x = 0;\n  for (int y=0; y<int(n); y++) {\n    //if x is <= 1 ..output should be 1\n    if (y != 0 && y % 5 == 0)\n      x++;//makes sure it does not pass the grid size\n    if (y <= 1) {\n      fibonacciNumber = fibNum2;\n      printSequence(fibonacciNumber, x, y % 5);//prints the number on the grid\n    }// if()\n    else {\n      /*\n            Calculating the Fibonacci  Sequence\n       */\n      fibonacciNumber = fibNum1 + fibNum2;\n      fibNum1 = fibNum2;\n      fibNum2 =  fibonacciNumber;\n      printSequence(fibonacciNumber, x, y % 5);//prints the number on the grid\n    }//else()\n  }//for()\n}\n\nvoid printSequence(int number, int x, int y) {\n  text(number, x * GRID_SIZE + FONT_SIZE / 2, (y % 5) * GRID_SIZE + 2 * FONT_SIZE);//prints it on the grid\n  //based on the font size\n}\n```\n\n\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to fix aborting Fibonacci sequence code\r\n                \r\nI am trying to get a Fibonacci sequence of 5 million elements.\n\nThis code aborts abnormally, when I pass 1000 as a parameter. \n\n```\ndef self.fibo_seq(limit)\n  result_array = [0,1]\n  return result_array if limit < 2\n   while result_array.length <= limit\n     result_array << result_array[-1] + result_array[-2]\n   end\n  return result_array\nend\nres= Multiple.fibo_seq(5_000_000)\nprint res\n\nError: [1]    22382 killed     ruby fibo.rb\n```\n\n\nExample output:\n\n```\n# >> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, , 1...] upto 5 Million elements\n```\n\n    ", "Answer": "\r\nStoring the first 5000000 Fibonacci numbers using YARV's implementation of ```\nInteger```\n uses exactly 1084762047712 bytes (assuming 8 bits per byte) on a 64 bit platform. That's close to one TiByte (0.9865853351 TiByte, to be precise). And that's just the space for the numbers themselves, there's also the overhead for the array (a couple of bytes) and the pointers inside the array (a little bit less than 5000000 times 8, or a little over 38 MiByte).\n\nComputing those 5000000 numbers even without storing them (only remembering the last 2 to avoid re-computation), took a little over 20 minutes on my late 2011 model MacBook Pro. Computing them while at the same time allocating 1 TiByte of RAM is going to be much slower. If you don't have 1 TiByte of RAM, and the OS starts swapping out to disk, it is going to be orders of magnitude slower, even if you have a blazing RAID of SSDs connected via FibreChannel.\n\nIn order to print the array, it needs to be represented as a string first. Even just the commas and spaces without the numbers are already 4999999*2 characters, which need close to 10 MiByte of RAM (assuming a single-byte character set). If you tried to print out just the commas and spaces, you would need about 2500 pages of DIN A4 paper, or 1250 sheets if you print double-sided. Office paper is typically sold in stacks of 500 sheets which are roughly 5 cm high, so you have 2.5 stacks about 12.5 cm high just for the commas and spaces.\n\nThe total number of digits, and thus characters (and bytes) for the 5000000 numbers, is roughly 2.7 trillion digits, that's about 2.5 TiByte of RAM for the final string to be printed. Printing that out on DIN A4 double-sided would result in a stack of paper 33 km high, 4 times the height of Mt. Everest.\n\nAll in all, at the point that you are calling ```\nprint```\n, your program needs about 3.5 TiByte of RAM.\n\nPrinting to the console is actually surprisingly slow, on my standard macOS Terminal.app, I get about 1 MiByte/s, which means that not only will calculating the 5000000 numbers take at least tens of minutes without even counting the time for allocating all those objects and all that RAM, not only will your program use 3.5 TiByte of RAM, just the act of displaying the final array on the terminal will take about one month.\n\ntl;dr summary: 5000000 Fibonacci numbers are big.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence using recursion in C [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am trying (and failing) to print the fibonacci sequence using recursion. I'm sure this is very very basic but I can't seem to get it. \nPlease tell me what I am doing wrong, thanks!\n\n```\n#include <stdio.h>\n\nint fib(int a, int i)\n{\n    int nextnum, num1 = nextnum - 1, num2 = nextnum - 2;\n    for (i = 0; i >= a; i++) {\n        nextnum = num1 + num2;\n        printf(\"%d\", nextnum);\n        i++;\n        fib(a, i);\n    }\n}\n\nint main(void)\n{\n    int a, i = 0;\n\n    printf(\"Enter a number for fib series: \");\n    scanf(\"%d\", &a);\n\n    if (a == 1 || a == 2) {\n        printf(\"Enter higher number please!\\n\");\n    }\n    else {\n        fib(a, i);\n    }\n}\n```\n\n    ", "Answer": "\r\nFibonacci numbers are often used as an intro into recursion because they are naturally recursive. In fact, implementing them recursively is trivial in any language. On a side note, it is usually not the best way to implement Fibonacci sequence for practical purposes.\n\nBy definition, Fib(X) = Fib(X - 1) + Fib(X - 2). This is recursion right there. The only thing which is missing is how we stop the recursion, and we know that Fib(0) is the same as Fib(1) and is 1.\n\nHow do we translate this to the C language? Very simple, almost one-to-one mapping!\n\n```\nunsigned int fib(unsigned int k) {\n    // First, check our exit (stop) conditions:\n    if (k == 0 || k == 1) return 1;\n\n    // Now recursive part  \n    return fib(k - 1) + fib(k - 2);\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence and changing the rule\r\n                \r\nI wrote a loop to compute the first 10 numbers of the Fibonacci sequence. F(0)=0 ; F(1)=1 ; Rule: F(i)=F(i-2)+F(i-1)\n\n```\nx <- c(0,1)\nwhile (length(x) < 10) {\n  position <- length(x)\n  new <- x[position] + x[position-1]\n  x <- c(x,new)\n}\nprint(x)\n```\n\n\nNow I wanted to change the rule to: F(i)=F(i-1)-F(i-2)\n\n```\nx <- c(0,1)\nwhile (length(x) < 10) {\n  position <- length(x)\n  new <- x[position-1] - x[position]\n  x <- c(x,new)\n}\nprint(x)\n```\n\n\nBut the (small) change in the code doesn´t deliver the correct sequence. \nIs there a smarter way to this?\n    ", "Answer": "\r\nIf you want the rule to be ```\nF(i)=F(i-1)-F(i-2)```\n, then it should be\n\n```\nnew <- x[position] - x[position-1]\n```\n\n\nOn another note, if you are going to do this for just a small size vector then it makes no difference, but if you plan to go for a larger number then you should allocate the memory for the object beforehand, with a vector of NAs, Os or whatever you prefer. Otherwise, if you make your vector grow with each iteration, your code could become really slow.\n\nSomething like this:\n\n```\nlen <- 10\nx <- rep(NA, len)\nx[1] <- 0\nx[2] <- 1\nfor (i in 3:len) {\n  x[i] <- x[i-1] - x[i-2]\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "BufferedReader error in Fibonacci sequence in Java\r\n                \r\nI am new to Java, coming from a C background. While trying to implement a Fibonacci Sequence,I received the following error: \n\n\n```\n error: cannot find symbol\n    n = Integer.parseInt(br.readline());\n                           ^\n symbol:   method readline()\n location: variable br of type BufferedReader\n```\n\n\n\nThe program is as follows :\n\n```\nimport java.io.*;\n\npublic class fibonacci\n{\npublic static void main(String args[])throws IOException\n{\n    int n;\n    InputStreamReader read = new InputStreamReader(System.in);\n    BufferedReader br = new BufferedReader(read);\n\n    System.out.println(\"enter the value of n\");\n    n = Integer.parseInt(br.readline());\n\nint fib[];\n    fib[1]=1;\n    fib[2]=1;\n    for(int i=3; i<=n; i++)\n    {\n        fib[i] = fib[i-1] + fib[i-2] ;\n    }\n\n    System.out.println(\"the\"+n+\"th fibonacci term is \"+fib[n]);\n}\n}\n```\n\n\nKindly help.\n    ", "Answer": "\r\nJava is case sensitive\n\n```\nn = Integer.parseInt(br.readline());\n                            ^\n```\n\n\nshould be\n\n```\nn = Integer.parseInt(br.readLine());\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Creating a Fibonacci Sequence in JavaScript\r\n                \r\nI know that there are several posts on StackOverflow regarding Fibonacci Sequences, but none I have seen seem to directly address the questions I have.\n\nI am trying to list out to the console all numbers in the sequence following the number 2.\n\nI have created a function that I call from within a for loop, but it endlessly lists out a value of \"Infinity\" rather than the number in the sequence.\n\nTo clarify, here is my code:\n\n```\nconsole.log('\\nFIBONACCI SEQUENCE UP TO AND INCLUDING 4 MILLION:\\n');\n\nvar sequence = [1, 2];\n\nvar number = 0;\n\nfunction addToSequence(arr, num)    {\n\n        number = sequence[num] + sequence[num -1];\n\n        sequence.push(number);\n\n        return number;\n\n}   // end addToSequence(num)\n\nvar i = 1;\n\ndo {\n\n    var nextNum = addToSequence(sequence, i);\n    console.log('Next Number in Sequence:', nextNum);\n\n    i++;\n\n}   while (i < 4000000);\n```\n\n\nAfter the printout of the header, the output I get from this code is something like this:\n\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity\nNext Number in Sequence: Infinity  \n\nI don't know why the number from within the Fibonacci sequence does not print. Any insight you can provide is greatly appreciated.\n\n—Robert Hieger\n    ", "Answer": "\r\n```\nfunction fibonacci(n) {\n   var a =[0,1];\n        \n   if (n==1)\n    {\n    \n      console.log(`[${0}]`);\n            \n    }\n        \n   else\n    {\n\n       for(var i=2;i<n;i++)\n          {\n    \n          a[i] = a[i-1] + a[i-2];\n                \n          }\n            \n          console.log(`[${a}]`);\n     }\n        \n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Print fibonacci sequence\r\n                \r\nI'm having trouble printing a matrix with the fibonacci series.\nWhen I start the program, it prints a sequence with an integer and the rest of zeros. I would like a north, to be able to conclude.\n\nSequential printing function:\n\n```\nvoid printArray(int _A[], int _sz)\n{\n    _A = new int(_sz);\n\n\n    cout << \">>> [ \";\n    for (int i = 0; i <= _sz; i++)\n    {\n        cout << _A[i] << \" \";\n    }\n    cout << \" ]\\n\";\n\n}\n```\n\n\nFunction to calculate the sequence:\n\n```\nint fib(int _limit, int *_A)\n{\n    int count = 0;\n    int fib0 = 1;\n    int fib1 = 1;\n    int fib2 = 0;\n    while (fib2 < _limit)\n    {\n        fib2 = fib0 + fib1;\n\n        count++;  \n\n        fib0 = fib1;\n        fib1 = fib2;\n    }\n\n    _A = new int(count);\n    for (int i = 0; i < count; i++)\n    {\n        cout << _A[i] << \" \";\n    }\n\n    return count;\n}\n```\n\n\nMain:\n\n```\nint main()\n{\n    int L;            \n    int *A = nullptr; \n    cout << \">>> Press number: \"\n    cin >> L; \n\n    if (L >= 0)\n    {\n        auto sz = fib(L, A); \n        cout << \">>> The Fibonacci series up to \" << L << \" is: \\n\";\n        printArray(A, sz); .\n    }\n    else\n        cout << \">>> Sorry, only positive integers accepted. Aborting...\\n\";\n}\n```\n\n    ", "Answer": "\r\nYou have a number of issues.\n\nIn ```\nprintArray```\n you overwrite the passed in array with a single integer pointer ```\n_A = new int(_sz);```\n, attempting to print all the elements of the array will be undefined behaviour.\n\nIn ```\nfib```\n you also use ```\nnew int(count);```\n, again this allocates a single pointer rather than array. You should use ```\nnew int[count];```\n instead. You never assign values to the elements of the array ```\n_A```\n so they are uninitialised and using them is undefined behaviour.\n\nYou don't pass the array ```\n_A```\n back to the calling function. You can fix this by changing the declaration of ```\nfib```\n to:\n\n```\nint fib(int _limit, int *&_A)\n```\n\n\nA good way of fixing all these problems is to use ```\nstd::vector```\n instead of an array, you then don't need to pre-compute the size of the sequence:\n\n```\n#include <iostream>\n#include <vector>\nusing std::cout;\nusing std::cin;\nusing std::vector;\n\nvoid printArray(const std::vector<int>& A)\n{\n    cout << \">>> [ \";\n    for (int i : A)\n    {\n        cout << i << \" \";\n    }\n    cout << \" ]\\n\";\n\n}\n\nvoid fib(int _limit, std::vector<int>& A)\n{\n    int fib0 = 1;\n    A.push_back(fib0);\n    int fib1 = 1;\n    int fib2 = 0;\n    while (fib2 < _limit)\n    {\n        A.push_back(fib1);\n        fib2 = fib0 + fib1;\n\n        fib0 = fib1;\n        fib1 = fib2;\n    }\n}\n\nint main()\n{\n    int L;\n    std::vector<int> A;\n    cout << \">>> Press number: \";\n    cin >> L; \n\n    if (L >= 0)\n    {\n        fib(L, A); \n        cout << \">>> The Fibonacci series up to \" << L << \" is: \\n\";\n        printArray(A);\n    }\n    else\n        cout << \">>> Sorry, only positive integers accepted. Aborting...\\n\";\n}\n```\n\n\nIf you're taking some perverse computer science course that is teaching you c++ but won't let you use c++ classes then the same code using arrays could look like:\n\n```\n#include <iostream>\nusing std::cout;\nusing std::cin;\n\nvoid printArray(int A[], int _sz)\n{\n    cout << \">>> [ \";\n    for (int i = 0; i <= _sz; i++)\n    {\n        cout << A[i] << \" \";\n    }\n    cout << \" ]\\n\";\n\n}\n\nint fib(int _limit, int *A)\n{\n    int count = 0;\n    int fib0 = 1;\n    if (A) A[0] = fib0;\n    int fib1 = 1;\n    int fib2 = 0;\n    while (fib2 < _limit)\n    {\n        count++;\n        if (A) A[count] = fib1;\n        fib2 = fib0 + fib1;\n        fib0 = fib1;\n        fib1 = fib2;\n    }\n    return count;\n}\n\nint main()\n{\n    int L;            \n    int *A = nullptr; \n    cout << \">>> Press number: \";\n    cin >> L;\n\n    if (L >= 0)\n    {\n        auto sz = fib(L, A);\n        A = new int[sz];\n        fib(L, A);\n        cout << \">>> The Fibonacci series up to \" << L << \" is: \\n\";\n        printArray(A, sz);\n    }\n    else\n        cout << \">>> Sorry, only positive integers accepted. Aborting...\\n\";\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Java: check if arraylist is part of fibonacci sequence\r\n                \r\nMy assignment for school is to implement a method that checks if a given ```\nArrayList```\n is part of the Fibonacci sequence.\n\nThe array must not be empty and must be bigger than 3.\n\nI understood that I have to check if one number of the array and the next one are part of the Fibonacci sequence, however I have a lot of trouble with it since you're supposed to accept the array if it's any part of the sequence and not just from the start.\n\ne.g.: ```\n0 1 1 2 3 5```\n will be accepted as well as ```\n2 3 5 8 13 21```\n.\n\nThis is my code so far. I know it's very flawed but i really have no clue how to move on.\n\n```\npublic class ArrayCheck {\n /**\n * Tests if the given array is a part of the Fibonacci sequence.\n *\n * @param arr array to be tested\n * @return true if the elements are part of the fibonacci sequence\n */\npublic boolean isFibonacci(ArrayList<Integer> arr) {\n    //check if array exists\n    if(arr.size() == 0)\n        return false;\n\n    //check if array is bigger than 3\n    if (arr.size() < 3)\n        return false;\n\n    //check for the startsequence of 0,1,1\n    else if(arr.get(0) == 0 && arr.get(1) == 1 && arr.get(2) == 1)\n        return true;\n\n    //check every number in array\n    for(int i = 0; i < arr.size(); i++) {\n        //check if i >= 2 is fib\n        if(i >= 2) {\n            int fibn = i;\n            int nextfib = i + 1;\n\n            int fibnew = (fibn - 1) + (fibn - 2);\n            int fibnext = (nextfib - 1) + (nextfib - 2);\n\n            if (arr.get(i) != fibnew && arr.get(i + 1) != fibnext)\n                return false;\n        }\n        //check if the order is right\n        if(arr.get(i) > arr.get(i+1))\n            return false;\n    }\n    return true;\n}\n```\n\n\nAny help is greatly appreciated!\n    ", "Answer": "\r\nWell, you have a few issues with your code. First of all, if you array is at least 3 items, you check if only the first three are the start of the Fibonacci sequence:\n\n```\n//check for the startsequence of 0,1,1\nelse if(arr.get(0)==0 && arr.get(1)==1 && arr.get(2)==1){\n    return true;\n}\n```\n\n\nThis is bad, as this mean ```\n0 1 1 5```\n which is not part of the sequence will return true.\n\nWhat you need to do is split this into two tasks:\n\n\nFind the first relevant number in the sequence (i.e. if the array starts with ```\n7```\n, you know this isn't a part of the sequence; alternatively, if it starts with ```\n8```\n, you know you need to start checking from ```\n8```\n onward).\nOnce you've found the \"start\", simply check that the rest of the array follows the Fibonacci rule. you'll need to manually verify the first two items.\n\n\n\n\n```\npublic boolean isFibonacci(ArrayList<Integer> arr) {\n\n    if (arr.size() < 3){\n        return false;\n    }\n\n    /** find if the first element is part of the sequence: **/\n\n    int fib1 = 0;\n    int fib2 = 1;\n\n    while (fib1 < arr.get(0)) {\n        int tmp = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = tmp;\n    }\n\n    if (fib1 != arr.get(0)) {\n        // first element is not part of Fibonacci sequence\n        return false;\n    }\n\n    if (fib2 != arr.get(1)) {\n       // the first two elements are not part of the Fibonacci sequence\n       return false;\n    }\n\n    /*** now simply verify that the rest of the elements uphold the rule:\n         each element is the sum of the two previous ones: **/\n\n    for(int i=2; i < arr.size(); i++) {\n\n        // make sure there are no negatives in the array:\n        if (arr.get(i) < 0)\n           return false;\n\n        if (arr.get(i) != (arr.get(i-1) + arr.get(i-2)))\n           return false;\n\n    }\n\n    //everything checks out okay - return true:\n    return true;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "JavaScript - Right Pascal pattern with the Fibonacci sequence\r\n                \r\nI'm trying to create a Pascal triangle using the Fibonacci sequence. I´m looking for this output:\n```\n0\n0 1\n0 1 1\n0 1 1 2\n0 1 1 2 3\n0 1 1 2 3 5\n0 1 1 2 3 5 8 \n0 1 1 2 3 5\n0 1 1 2 3\n0 1 1 2\n0 1 1\n0 1\n0\n```\n\nThis is the code I have written so far. I managed to get the Fibonacci sequence running into a triangle but not the way I want.\n\r\n\r\n```\nfunction fiboP(n) {\n  let string = \"\";\n  let n1 = 0\n  let n2 = 1\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j < i; j++) {\n      string += n1 + \" \";\n      next_num = n1 + n2;\n      n1 = n2;\n      n2 = next_num;\n    }\n    string += \"\\n\";\n  }\n  for (let i = 1; i <= n - 1; i++) {\n    for (let j = 0; j < n - i; j++) {\n      string += n1 + \" \";\n      next_num = n2 - n1;\n      n2 = n1;\n      n1 = next_num;\n    }\n    string += \"\\n\";\n\n  }\n  console.log(string)\n}\n\n\nfiboP(5)```\n\r\n\r\n\r\n\n```\nOutput:\n0 \n1 1 \n2 3 5 \n8 13 21 34 \n55 89 144 233 377 \n610 377 233 144 \n89 55 34 \n21 13 \n8\n```\n\nI would like to understand what I am missing here and if there is a cleaner and simpler way to produce the desired output.\n    ", "Answer": "\r\nIf you reset your values when you go to next line, you should be able to generate the output you're looking for\n\r\n\r\n```\nfunction fiboP(n) {\n  let string = \"\";\n  for (let i = 1; i <= n; i++) {\n    let n1 = 0\n    let n2 = 1\n    for (let j = 0; j < i; j++) {\n      string += n1 + \" \";\n      next_num = n1 + n2;\n      n1 = n2;\n      n2 = next_num;\n    }\n    string += \"\\n\";\n  }\n  for (let i = 1; i <= n - 1; i++) {\n    let n1 = 0\n    let n2 = 1\n    for (let j = 0; j < n - i; j++) {\n      string += n1 + \" \";\n      next_num = n2 + n1;\n      n2 = n1;\n      n1 = next_num;\n    }\n    string += \"\\n\";\n\n  }\n  console.log(string)\n}\n\n\nfiboP(7)```\n\r\n\r\n\r\n\nAs an improvement i will suggest finding fibonacci sequence once and then just using these values to create this triangle.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Trouble with 'for loop' for Fibonacci sequence\r\n                \r\nI recently started programming and currently working on a method for Fibonacci Sequence and it seems the method only adds 0s after the first two number. I think there is an issue with my for loop but can't get my head around it.\n```\nstatic int fib(int number)\n        {\n            if (number == 1 || number == 2)\n                return 1;\n\n            int[] fibBase = new int[number];\n            fibBase[0] = 1;\n            fibBase[1] = 1;\n\n            for (int i = 2; i < fibBase.Length; i++)\n            {\n            \n                int temp = fibBase[i - 2] + fibBase[i - 1];\n\n                fibBase[i] = temp;\n\n                int lastindex = fibBase.Length;\n                number = fibBase[lastindex - 1];\n\n            }\n            \n            foreach (int fib in fibBase)\n                Console.WriteLine(fib);\n            return number;\n            \n                \n        }\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "need help correcting my code for fibonacci sequence\r\n                \r\nI need to create a program that asks the user for an integer N, and then prints out the first N terms of the fibonacci sequence using a void function for fibonacci sequence.  After one instance, the program must ask the user if he wishes to continue. If user replies Y, the program must ask user for another integer N, and then prints out the first N terms of the fibonacci sequence and so on. \n\nI have already written code for this. It works in the first instance. The problem is, if the user chooses to do it again, the result is no longer the right fibonacci sequence. Below is the code.\n\n```\n#include<stdio.h>\n\nvoid printFibonacci(int n){\n    static int n1=0,n2=1,n3;\n    if(n>0){\n         n3 = n1 + n2;\n         n1 = n2;\n         n2 = n3;\n         printf(\"%d \",n3);\n         printFibonacci(n-1);\n    }\n}\n\nint main()\n{\n    int n;\n    char choice;\n    printf(\"Enter the number of elements: \");\n    scanf(\"%d\",&n);\n    printf(\"Fibonacci Series: \");\n    printf(\"%d %d \",0,1);\n    printFibonacci(n-2);//n-2 because 2 numbers are already printed\n\n    printf(\"\\nDo you wish to continue?(Y/N)\");\n    scanf(\" %c\", &choice);\n\n    while (choice=='Y')\n    {\n        printf(\"Enter the number of elements: \");\n    scanf(\"%d\",&n);\n    printf(\"Fibonacci Series: \");\n    printf(\"%d %d \",0,1);\n    printFibonacci(n-2);//n-2 because 2 numbers are already printed\n\n    printf(\"\\nDo you wish to continue?(Y/N)\");\n    scanf(\" %c\", &choice);\n    }\n  return 0;\n }\n\n\n```\n\n\nThe expected result is the Fibonacci sequence. When I run the code above, on first instance if I say N = 5, it gives the correct result:\n0,1,1,2,3. \nProblem comes after I answer yes to \"Do you wish to continue? (Y/N)\". If I again input N = 5, I expect to get 0,1,1,2,3 but instead, I get 0,1,5,8,13.\n    ", "Answer": "\r\nYour issue is using those static variables. They keep their values even out of scope, which means that when the function is recalled both n1 and n2 will have their last assigned values.\nI solved that issue by passing n1 and n2 by parameters. These functions replace your printFibonacci.\n\n\n```\nvoid printFibonacci2(int length, int n1, int n2) {\n    int n3;\n    if(length > 0) {\n        n3 = n1 + n2;\n        n1 = n2;\n        n2 = n3;\n        printf(\"%d \", n3);\n        printFibonacci2(length - 1, n1, n2);\n    }\n}\n\nvoid printFibonacci (int n)\n{\n  printFibonacci2(n, 0, 1);\n}\n```\n\n\nYou can pretty up the code, but the issue is solved.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Trouble with 'for loop' for Fibonacci sequence\r\n                \r\nI recently started programming and currently working on a method for Fibonacci Sequence and it seems the method only adds 0s after the first two number. I think there is an issue with my for loop but can't get my head around it.\n```\nstatic int fib(int number)\n        {\n            if (number == 1 || number == 2)\n                return 1;\n\n            int[] fibBase = new int[number];\n            fibBase[0] = 1;\n            fibBase[1] = 1;\n\n            for (int i = 2; i < fibBase.Length; i++)\n            {\n            \n                int temp = fibBase[i - 2] + fibBase[i - 1];\n\n                fibBase[i] = temp;\n\n                int lastindex = fibBase.Length;\n                number = fibBase[lastindex - 1];\n\n            }\n            \n            foreach (int fib in fibBase)\n                Console.WriteLine(fib);\n            return number;\n            \n                \n        }\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "My first ruby app - fibonacci sequence\r\n                \r\nI am writing a method that returns the nth element in the Fibonacci sequence, but am running into an unexpected end error.\n\n```\ndef fib_seq(n)\n\n  a = [0]\n\n  n.times do |i|\n    if i==0\n      a[i] = 0\n    else if i==1\n      a[i] = 1\n    else\n      a[i] = a[i-1] + a[i-2]\n    end  \n  end\n\n  return a[n]\nend\n\nputs fib_seq(4)\n```\n\n\nAny tip on what I can be screwing up on?\n    ", "Answer": "\r\nAssuming you are trying to return the nth (and not the (n-1)th, i.e. fib(1) = 0 NOT fib(0) = 0).\n\nI fixed it by changing:\n\n```\nelse if i==1\n```\n\n\nto\n\n```\nelsif i==1\n```\n\n\n(AND)\n\n```\nreturn a[n]\n```\n\n\nto\n\n```\nreturn a[n - 1]\n```\n\n\nSo your final code should look like:\n\n```\ndef fibSeq(n)\n\n  a = [0]\n\n  n.times do |i|\n    if i==0\n      a[i] = 0\n    elsif i==1\n      a[i] = 1\n    else\n      a[i] = a[i-1] + a[i-2]\n    end  \n  end\n\n  return a[n-1]\nend\n\nputs fibSeq(4)\n```\n\n\nPer your comment below, the following code will work:\n\n```\ndef fibSeq(n)\n\n  a = [0]\n\n  (n+1).times do |i|\n    if i==0\n      a[i] = 0\n    elsif i==1\n      a[i] = 1\n    else\n      a[i] = a[i-1] + a[i-2]\n    end  \n  end\n\n  return a[n]\nend\n\nputs fibSeq(4)\n```\n\n\nIf you want to output the fibs as a list then use:\n\n```\nreturn a[0..n]\n```\n\n\nInstead of\n\n```\nreturn a[n]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Java code shows wrong Fibonacci number in Fibonacci sequence\r\n                \r\nIm trying to make a Java code that displays the nth number in the Fibonacci sequence. For example if i put in 7, the code should show the number 8 since the 7th number in the Fibonacci sequence is 8.\nBut when I tried to make one, it shows the wrong number. For some reason, when i enter 7 it shows 13, and when I enter 1, it shows a 1 although I already stated that the first number is 0 in the code.\n```\nScanner input = new Scanner(System.in);\nSystem.out.print(“In: ”);\nint n = input.nextInt();\n\nint x = 0;\nint y = 1;\nint a;\n\nfor (int i = 1; i <= n; i++) {\n  a = x + y;\n  x = y;\n  y = a;\n}\nSystem.out.print(x + \" \");\n```\n\nI think the code for some reason ignores the first 0 which I dint understand. I would love some help, thank you.\n    ", "Answer": "\r\nSpandan is correct, if you modify your code to the below you will get the correct response all the way from 1 and up...\nNote:\n\nThe loop now iterates only as long as i<n which removes the unwanted result.\n\nThe loop though will never produce the first number in the sequence (zero) as the first iteration can not be lower than one. For that reason I have added the print of X before the loop runs the first time.\n\n\nI hope this helps :)\n```\nimport java.util.Scanner;\n\npublic class Fibonacci {\n  public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n    System.out.print(\"Enter the number of terms: \");\n    int n = input.nextInt();\n\n    int x = 0;\n    int y = 1;\n    int a;\n\n    System.out.print(\"Fibonacci sequence: \");\n    System.out.print(x + \" \");\n     \n    for (int i = 1; i < n; i++) {\n      a = x + y;\n      x = y;\n      y = a;\n      System.out.print(x + \" \");\n    }\n  }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Creating a Fibonacci sequence in C\r\n                \r\nConsider a Fibonacci sequence whose values do not exceed four million. Find the sum of the even-valued terms. Your answer must be 4613732.\n```\n#include <stdio.h>\n\nint main()\n{\n   int a =0,b=1,c=0,sum=0;\n\n   while (c<=10){\n       int c=a+b;\n       a=b;\n       b=c;\n\n       if(c%2==0){\n           sum=sum+c;\n       }\n   }\n\n   printf(\"%d\",sum);\n\n   return 0;\n}\n```\n\nThe output comes out to be blank. I tried 10 for smaller calculation time and the answer should be 2+8=10. I don't know what to do.\n    ", "Answer": "\r\nIn this question\n```\nint c=a+b;\n```\n\nYou are not using the value declared outside of the method Insted you are defining a new variable that only works on inside of your method. Try removing the ```\nint```\n decleration inside the ```\nwhile```\n loop  and It should work\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How a for loop works in Fibonacci Sequence\r\n                \r\nI have a code for calculating Fibonacci Sequence as shown below .. I do not understand how the for loop works in this example : \n\n```\npublic class program {          \n    private static int fibo (int n){\n        if (n==1 || n==2) return 1;\n\n        int f = 0;\n        int f1 = 1;\n        int f2 = 1;\n        for (int i = 3; i <= n;i++) {\n            f = f1 + f2;\n            f1 = f2;\n            f2 = f;\n        }\n        return f;\n    }\n\n    public static void main(String[] args) {\n        int n=7;\n        System.out.println(fibo(n));\n    }\n}\n```\n\n\nThe output of the code is ```\n13```\n..\n    ", "Answer": "\r\nSo the first two Fibonacci number are always ```\n0```\n and ```\n1```\n.\nAfter that all following numbers are the sum of the previous two numbers.\nAccording this the next step is ```\n0 + 1 = 1```\n, which is the same as your code here:\n\n```\nint f = 0; //fibonacci #1\nint f1 = 1; //fibonacci #2\nint f2 = 1; //fibonacci #3\n```\n\n\nAfter that it wil loop through all numbers doing it the same way:\n\n```\nfor (int i = 3;i <= n;i++) {\n    //calculate the new fibanacci, will get the fibonacci #1 variable\n    f = f1 + f2;\n\n    //the next fibonacci #2 will be the same as fibonacci #3 was before\n    f1 = f2;\n\n    //set the new fibonacci to fibonacci #3\n    f2 = f; \n}\n```\n\n\nWhen it finished looping, it just returns the fibonacci number:\n\n```\nreturn f;\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "javascript Fibonacci sequence return undefined\r\n                \r\nI am new to javascript and I was trying to write a small function return Fibonacci sequence. Here is my code:\n\n\r\n\r\n```\nfunction fib2(n) {\r\n  let fib = [];\r\n  fib[0] = 1;\r\n  fib[1] = 1;\r\n  for (var i = 2; i < n; i++) {\r\n    fib[i] = fib[i - 2] + fib[i - 1];\r\n  }\r\n  return fib[i];\r\n}\r\n\r\nconsole.log(fib2(6));```\n\r\n\r\n\r\n\n\nbut the result is undefined. I guess it's because of some closure issue but I am not sure about why. Could someone explain what happened? Thank you\n    ", "Answer": "\r\nAfter the for loop, variable i has value n, so fib[i] is out of the array.\n\n\r\n\r\n```\nfunction fib2(n) {\r\n  let fib = [];\r\n  fib[0] = 1;\r\n  fib[1] = 1;\r\n  for (var i = 2; i < n; i++) {\r\n    fib[i] = fib[i - 2] + fib[i - 1];\r\n  }\r\n  return fib[n-1];\r\n}\r\n\r\nconsole.log(fib2(6));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Java Program Fibonacci Sequence\r\n                \r\nI am writing a \"simple\" program to determine the Nth number in the Fibonacci sequence. Ex: the 7th number in the sequence is: 13.  I have finished writing the program, it works, but beginning at the 40th number it begins to delay, and takes longer, and longer.  My program has to go to the 100th spot in the series.\n\nHow can I fix this so it doesn't take so long? This is very basic program, so I don't know all the fancy syntax codes.. my formula is:\n\n```\nif n =1 || n = 0\n   return n;\n\nelse \n    return F(n-1) + F(n-2);\n```\n\n\nThis works great until it goes past the 40th term. What other statement do I have to add to make it go quicker for higher numbers??\n    ", "Answer": "\r\nThe problem is that because you are using simple recursion, you re-evaluate F(n) multiple times, so your execution time is exponential.\n\nThere are two simple ways to fix this:\n\n1) Cache values of F(n) when they are evaluated the first time. Check the cache first before evaluating F(n) to see if you have already calculated it for this n.\n\n2) Use an iterative approach: Calculate F(1), F(2), F(3), etc... until you reach the number you need.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence calculator python\r\n                \r\nHi I'm fairly new to python and trying to create a Fibonacci calculator function that prints all values up to a given number, if the number entered is not in the sequence then it adds the next Fibonacci number to the list. For example, if 10 is entered it should return ```\n[0, 1, 1, 2, 3, 5, 8, 13]```\n. The function has to be recursive. Here is my current code:\n\n```\ndef fibonacci(n):\n    n = int(n)\n    # The nested sub_fib function computes the Fibonacci sequence\n\n    def sub_fib(n):\n        if n < 2:\n            return n\n        else:\n            return (sub_fib(n-1) + sub_fib(n-2))\n\n    #This aspect of the main fib function applies the condition if the number\n    # input is not in the sequence then it returns the next value up\n\n    fib_seq= [sub_fib(i) for i in range(0,n) if sub_fib(i)<=n]\n    if fib_seq[-1] < n:\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n        return fib_seq\n    else:\n        return fib_seq\nprint(fibonacci(input(\"Input a number to print sequence up to: \")))\n```\n\n\nI've managed to get it to work but it is incredibly slow (I assume due to the recursion) is there anyway I can speed it up without massively changing the program?\n    ", "Answer": "\r\nThe two main reasons why your program is slow:\n\n\nyou calculate each Fibonacci number separately, you do not reuse the effort you have invested in finding the previous number;\nyou calculate the first n Fibonacci numbers, but from the moment the condition fails, you can stop.\n\n\nYou can change the program to still be recursive, but reuse the work to compute the previous number, and stop from the moment you have constructed the list.\n\nYou simply have to use the following function:\n\n```\ndef fibon(a,b,n,result):\n    c = a+b\n    result.append(c)\n    if c < n:\n        fibon(b,c,n,result)\n    return result\n```\n\n\nand we initialize it with: ```\nfibon(0,1,n,[])```\n. In each iteration, it will calculate  the next Fibonacci number ```\nc = a+b```\n and append it to the ```\nresult```\n. In case that number is still smaller than ```\nc < n```\n then we need to calculate the next number and thus perform the recursive call.\n\n```\ndef fibonacci(n):\n    n = int(n)\n\n    def fibon(a,b,n,result):\n        c = a+b\n        result.append(c)\n        if c < n:\n            fibon(b,c,n,result)\n        return result\n\n    return fibon(0,1,n,[])\n\nprint(fibonacci(input(\"Input a number to print sequence up to: \")))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Get run-time of each number in a Fibonacci sequence\r\n                \r\n```\n#include <stdio.h>\n#include <time.h>\n\nvoid printFibonacci(int n) {    \n    static int n1 = 0, n2 = 1, n3;    \n    if (n > 0) {    \n        n3 = n1 + n2;    \n        n1 = n2;    \n        n2 = n3;    \n        printf(\"%d \", n3);    \n        printFibonacci(n - 1);    \n    }    \n}\n\nint main() {\n    int n;\n    struct timespec start, stop;\n    double total_time;\n    \n    clock_gettime(CLOCK_REALTIME, &start);\n    printf(\"Enter the number of elements: \");    \n    scanf(\"%d\", &n);    \n    printf(\"Fibonacci Series: \");    \n    printf(\"%d %d \", 0, 1);    \n    printFibonacci(n - 2);\n    \n    clock_gettime(CLOCK_REALTIME, &stop);\n    total_time = (stop.tv_sec - start.tv_sec) * 1e9;\n    total_time = (total_time + (stop.tv_nsec - start.tv_nsec)) * 1e-9;\n    printf(\"\\nTime taken for each sequence: %lf\", total_time);\n    return 0; \n}\n```\n\nThis C program above has the user enter an integer, and the program will then output the Fibonacci sequence. What I am trying to do is to get the run-time of each number in the Fibonacci sequence down to the nanosecond. So far my attempt has been to use the ```\nclockgettime()```\n function to get the start and stop time of the ```\nfibonacci```\n function. However, that only outputs the total time the function took instead of how long each individual sequence took. How would I fix this code so I would get each individual sequence time instead?\nFor example, if the user inputs 12 the output I desire would look like this, where each sequence time is displayed:\n```\nEnter the number of elements: 12        \nFibonacci Series: 0 1 1 2 3 5 8 13 21 34 55 89           \nTime taken for each sequence: 0.1023, 0.2024, 0.3025, 0.7024, 0.9323, 0.12023, 0.78923, 0.6723, 0.12323, 0.9033, 0.34523, 0.123423\n```\n\n    ", "Answer": "\r\nAs coded in the question, you compute the time for the whole sequence, including the time it takes the user to enter the number and the time it takes ```\nprintf```\n to output the values. This is meaningless.\nFurthermore, you multiply the number of seconds by 109 but then divide the number of nanoseconds by 109 too: you should do one or the other but not both.\nIf you want to time the computation of each number, you should retrieve the clock just before the addition of the 2 previous numbers an immediately after the 3 assignments, retrieve the clock again. Trying to clock such a simple operation is quite difficult: ```\nclock_gettime()```\n is not the right tool for this, you will more likely just measure the overhead of ```\nclock_gettime```\n, the imprecision of the ```\nCLOCK_REALTIME```\n, possibly polluted by asynchronous processes interrupting your program as you measure ```\nCLOCK_REALTIME```\n instead of the current process' runtime. You probably should use ```\nclock()```\n instead, but the measurements are likely to be insignificant.\nIntermediary timings should be stored in a ```\nstatic```\n array for ```\nmain```\n to print them.\nHere is a modified version:\n```\n#include <stdio.h>\n#include <time.h>\n\n#define MAX_TIMINGS 100\nstatic double timings[MAX_TIMINGS];\nstatic int timing_index = 2;\n\nvoid printFibonacci(int n) {    \n    static int n1 = 0, n2 = 1, n3;    \n    if (n > 0) {  \n        struct timespec start, stop;\n        clock_gettime(CLOCK_REALTIME, &start);\n        n3 = n1 + n2;    \n        n1 = n2;    \n        n2 = n3;    \n        clock_gettime(CLOCK_REALTIME, &stop);\n        if (timing_index < MAX_TIMINGS) {\n            timings[n] = (stop.tv_sec - start.tv_sec) * 1e9 +\n                         (stop.tv_nsec - start.tv_nsec);\n        }\n        printf(\"%d \", n3);\n        printFibonacci(n - 1);\n    }\n}\n\nint main() {\n    int i, n;\n    double total_time = 0;\n    \n    printf(\"Enter the number of elements: \");    \n    scanf(\"%d\", &n);    \n    printf(\"Fibonacci Series: \");    \n    printf(\"%d %d \", 0, 1);    \n    printFibonacci(n - 2);\n    printf(\"\\n\");\n    printf(\"Time taken for each number:\");\n    for (i = 0; i <= n; i++) {\n        printf(\" %.0fns\", timings[i]);\n        total_time += timings[i];\n    }\n    printf(\"\\n\");\n    printf(\"Total time: %.0fns\\n\", total_time);\n    return 0; \n}\n```\n\nOutput:\n```\nEnter the number of elements: 20\nFibonacci Series: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181\nTime taken for each number: 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns\nTotal time: 0ns\n```\n\nUnsurprisingly, all timings are null. Measuring the time for each number for your sequential generator is meaningless.\nConversely, timings are significant for the classic recursive implementation where many recursive calls are involved for even moderately large arguments.\nHere is a more classic example:\n```\n#include <stdio.h>\n#include <time.h>\n\nunsigned long long fib(int n) {\n    if (n < 2)\n        return n;\n    else\n        return fib(n - 1) + fib(n - 2);\n}\n\nint main() {\n    int i, n;\n    double total_time = 0;\n\n    printf(\"Enter the number of elements: \");\n    if (scanf(\"%d\", &n) != 1)\n        return 1;\n    double timings[n + 1];\n    printf(\"Fibonacci Series:\");\n    for (i = 0; i <= n; i++) {\n        struct timespec start, stop;\n        unsigned long long res;\n        clock_gettime(CLOCK_REALTIME, &start);\n        res = fib(i);\n        clock_gettime(CLOCK_REALTIME, &stop);\n        timings[i] = ((stop.tv_sec - start.tv_sec) * 1e9 +\n                      (stop.tv_nsec - start.tv_nsec));\n        printf(\" %llu\", res);\n    }\n    printf(\"\\n\");\n    printf(\"Time taken for each number:\");\n    for (i = 0; i <= n; i++) {\n        printf(\" %.0fns\", timings[i]);\n        total_time += timings[i];\n    }\n    printf(\"\\n\");\n    printf(\"Total time: %.0fns\\n\", total_time);\n    return 0;\n}\n```\n\nOutput:\n```\nEnter the number of elements: 20\nFibonacci Series: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765\nTime taken for each number: 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 0ns 1000ns 0ns 1000ns 1000ns 2000ns 5000ns 6000ns 10000ns 18000ns 38000ns 69000ns\nTotal time: 151000ns\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "program to find fibonacci sequence of a number\r\n                \r\nhow do i find the fibonacci sequence of a number . Here Is The code\n```\ndef fib(n):\n    for i in range(n):\n        b = 1 \n        \n        b+=i\n        print(b)\n        \np = fib(9)\n\n```\n\nthe program just returns the normal sum. how to do this in the easy way\n    ", "Answer": "\r\nThe fibonacci sequence is built by adding the last two values of the sequence, starting with 1,1 (or 0,1 for the modern version).  A recursive function does it elegantly:\n```\ndef fib(n,a=1,b=1): \n    return a if n==1 else fib(n-1,b,a+b)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in Python3.2 [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI really need your help. I know this question has been asked countless times already but I still cant find the answer...\n\nI need to programm a fibonacci sequence recursively in a bla-bla.py file, this is what I've got so far:\n\n```\nprint(\"Unendlicher Fibonacci-Generator Rekursiv\")\ndef fib(n):\n\n  if n == 0:\n        return 0\n  elif n == 1:\n        return 1\n  else:\n        return fib(n-1) + fib(n-2)\n\nfor n in fib(n):\n  print (str(n))\n```\n\n\nBut I always get a NameError \"name 'n' is not defined\" which is driving me crazy... I just cannot understand how one can \"print\" the value of a variable in Python! Please help!\n\nI tried to use \"in\" to get rid of this NameError. I've programmed one Fibonacci Generator before and it worked perfectly fine exactly with that \"for...in\". I do understand i need some kind of iteration for it to work. So this is the version that works fine:\n\n```\nprint(\"Unendlicher Fibonacci-Generator\")\ndef fibonacci():\n  a, b = 0, 1   #a=0, b=1\n  while True:\n    yield a\n    a, b = b, a + b\nf = fibonacci()\n\ncounter = 0\nfor x in f:\n  print (\"fib(\" + str(counter) +\") = \" +str(x))\n  counter +=1\n  if (counter > 25): break\n```\n\n\nCan someone tell me what the correct code is for the recursive function?\n    ", "Answer": "\r\nYou have a couple of things wrong with your code.\n\n1) ```\nfib(n)```\n - ```\nn```\n is not defined. Instead, pass in a specific number like: ```\nfib(5)```\n\n\n2) ```\nin```\n - You cannot do ```\nin int```\n. Just print the result of the function call as follows:\n\n```\nprint(fib(12))\n\n[OUTPUT]\n144\n```\n\n\nHere is a non-recursive approach to get a list of values:\n\n```\ndef fib(n,):\n    l = [0, 1]\n    for i in range(n-2):\n        l.append(l[-1]+l[-2])\n    return l\n\n>>> print fib(10)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python script to create Fibonacci Sequence Generator [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Python Fibonacci Generator  \n\n\n\n\nI am trying to construct a function that can append values to an empty list\n\n```\nn1 = 1\n\nn2 = 2\n\nfn = []\n```\n\n\nI want to add both n1 and n2 together and then send that value to fn.\n\nThen I want to reassign n1 and n2 to the last two values of the sequence.\n\nI then want to be able to stop it after a certain amount of iterations.\n\nI'm basically trying to construct a fibonacci sequence generator without using the function\n\n```\n#s(n) = (1.618^n-(1-1.618)^n)/(5^.5)`\n```\n\n\nExample:\n\n```\n fn = []\n\n\n\n\n def fibb(n1,n2,f_iter):\n # n1 would be the first number of the sequence\n # n2 would be the second number of the sequence\n # f_iter would be how many iterations it would do until finished\n```\n\n\nSo if the input was:\n\n```\n def fibb(1,2,10):  \n    return fn\n\n fn = [1,2,3,5,8,13,21,34,55,89,144,233]\n\n#f_iter(0:1+2=3,1:2+3=5,2:3+5=8,3:5+8=13, . . . 10:89+144=233)\n```\n\n    ", "Answer": "\r\nYou can use this\n\n```\ndef fib():\n    first, second = 0, 1\n    while 1:\n        yield first\n        first, second = second, first + second\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "botton up algorithm for fibonacci sequence\r\n                \r\nThe exception:\n```\nC:\\Users\\Wandres\\venv\\insertionsort\\Scripts\\python.exe C:/Users/Wandres/PycharmProjects/insertionsort/fibobottomup.py\nTraceback (most recent call last):\n  File \"C:\\Users\\Wandres\\PycharmProjects\\insertionsort\\fibobottomup.py\", line 13, in <module>\n    print(fibbottonup(5))\n  File \"C:\\Users\\Wandres\\PycharmProjects\\insertionsort\\fibobottomup.py\", line 8, in fibbottonup\n    f=fib[k-1]+fib[k-2]\nKeyError: 0\n```\n\nAnd the code\n```\ndef fibbottonup (n):  \n    fib = {}     \n    for  k in range (1, n + 1):    \n        if k<2:       \n           f=1            \n           fib[k]=f        \n        else:             \n           f=fib[k-1] + fib[k-2]            \n           fib[k]=f     \n    return fib[n] \n```\n\nI am learning about dynamic programming so i tried to use the theory and i want to add every element of the fibonacci sequence in the array \"fib\". I do not know where the mistake is.\n    ", "Answer": "\r\n```\ndef fibbottonup (n):  \n    fib = [0, 1]   \n    for i in range (n-1):    \n        fib.append(fib[i] + fib[i+1])\n    return fib[n]\n```\n\nIt is the code and\nExplanation is:\nFirst two items of ibonacci sequence is them\n0,\n1\nAfter that it starts to sum before two elements to find current element for all elements. So I did it.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Find the index of a number in the fibonacci sequence\r\n                \r\nI want to find the index of a number in the fibonacci sequence using recursion.\nExample : 13 (my input) is the 8th (output) number of the fibonacci sequence\nHere is my function :\n```\n#!/bin/bash\n\nfunction fib() {\n    \nnumber=1\ncpt=1   \nif [[ $number -lt $1 ]]\nthen\n    compteur=$(($cpt+ 1))\n    echo $(( $(fib $(($number - 1)) ) + $(fib $(($number - 2)) ) ))\nfi\necho $cpt\n}\n\nfib $1\n```\n\nI have this error : Wrong symbol near the +\nThen I don't know if my logic for the algorithm is good. I don't know if my syntax of how we are calling the function in the recursion in bash is great.\nAny help would be appreciated. Thanks !\n    ", "Answer": "\r\nWith ```\nrecursion```\n, would you please try the following:\n```\n#!/bin/bash\n\n# \"fib n\" returns the nth Fibonacci number (n starts from 0)\nfib() {\n    local n=$1\n    if (( n == 0 )); then\n        echo \"0\"\n    elif (( n == 1 )); then\n        echo \"1\"\n    else\n        echo \"$(( $(fib \"$(( n - 1 ))\" ) + $(fib \"$(( n - 2 ))\" ) ))\"\n    fi\n}\n\ninput=$1                        # user's input as a 1st argument to this script\n\nfor (( i = 0; ; i++ )); do      # increment the index i starting from 0\n    f=$(fib i)\n    (( f >= input)) && break    # if \"fib i\" >= input, then exit the loop\ndone\n\nif (( f == input )); then       # the input is a Fibonacci number\n    echo \"$i\"\nelse\n    echo \"$i (input $input is not a Fibonacci number.)\"\nfi\n```\n\nBy convention, the index starts with \"0\", then 13 is the 7th Fibonacci number.\nBtw if you increase the input number, you'll see the execution of the script takes a while (e.g. please try with 987 as an input).\nHere is an alternative without the recursion:\n```\n#!/bin/bash\n\nf0=0\nf1=1\n\ninput=$1\n\nfor (( i = 0; ; i++ )); do\n    (( f0 >= input )) && break\n    f2=$(( f1 + f0 ))\n    f0=$f1\n    f1=$f2\ndone\n\nif (( f0 == input )); then\n    echo \"$i\"\nelse\n    echo \"$i (input $input is not a Fibonacci number.)\"\nfi\n```\n\nAlthough the ```\nrecursion```\n is mathematically simple and elegant, the number\nof computation depends on the implementation. Fibonacci sequence is a\ntypical example which requires a consideration.\nThe 1st script includes two problems:\n\nIn the 1st recursion, the ```\nfib```\n function calls two ```\nfib```\n functions.\nIn the 2nd recursion, four functions are called. The number of computation\nreaches O(2**N).\nThe intermediate values such as fib(n-1) and fib(n-2) are discarded and\ncalculated again in the next invocation.\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence return argument\r\n                \r\nI need to generate a program that generates the Fibonacci Sequence\nHere is what I have so far:\n\n```\nimport java.util.Scanner;\n\npublic class FibonacciRunner\n{\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        System.out.println(\"Enter n:\");\n        int n = in.nextInt();\n\n        EP64 fg = new EP64();\n\n        for (int i = 1; i <= n; i++)\n            System.out.println(fg.nextNumber());\n    }\n}\n\n\n\npublic class EP64\n{\n\n    public static void nextNumber(int n)\n    {\n        int fold1 = 1;\n        int fold2 = 1;\n        int fnew = fold1 + fold2;        \n        fold1 = fnew;\n    }\n}\n```\n\n\nI get an  error on:\n\n```\n    System.out.println(fg.nextNumber());\n```\n\n\nsaying:\nmethod nextNumber in class EP64 cannot be applied to given types:\nrequired: int\nfound: no arguments\nreason: actual and formal argument lists differ in length\n\nand can someone also tell me if I am doing this program right? If not, help! I looked at other similar questions but I cannot make much sense of them\n\nThank you all!\n    ", "Answer": "\r\n\n  method nextNumber in class EP64 cannot be applied to given types: required: int found: no arguments reason: actual and formal argument lists differ in length\n\n\nYour \n\n```\npublic static void nextNumber(int n)\n                             ^^^^^^^\n```\n\n\nsays that any call to the method must provide an integer as argument. But here:\n\n```\nSystem.out.println(fg.nextNumber());\n                                ^^    you need to add an integer argument\n```\n\n\nyou violate this by providing no argument.\n\nAs your code reads now, I'd probably drop the ```\nint n```\n argument.\n\n\n  and can someone also tell me if I am doing this program right?\n\n\nNaah, not really...\n\n\n```\nfold1```\n and ```\nfold2```\n should probably be member variables (so they don't get reset in every call to the method),\nYou're forgetting to update ```\nfold2```\n (you only update ```\nfold1```\n),\nAlso, you probably want to return an ```\nint```\n from the ```\nnextNumber```\n method.\n\n\nRead up on \n\n\nOfficial Java Tutorial: Defining Methods\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence using shared memory in C\r\n                \r\nI got a question to solve but it is giving me errors:\n\n```\n2009-EE-182-Part2.c: In function ‘main’:\n2009-EE-182-Part2.c:35:13: error: expected identifier or ‘(’ before ‘->’ token\n2009-EE-182-Part2.c:40:22: error: expected identifier or ‘(’ before ‘->’ token\n2009-EE-182-Part2.c:41:14: error: expected identifier or ‘(’ before ‘->’ token\n2009-EE-182-Part2.c:42:22: error: expected expression before ‘shared_data’\n2009-EE-182-Part2.c:44:15: error: expected identifier or ‘(’ before ‘->’ token\n2009-EE-182-Part2.c:54:15: error: expected expression before ‘shared_data’\n2009-EE-182-Part2.c:55:19: error: expected expression before ‘shared_data’\n```\n\n\nThe code is:\n\n```\n# include <stdio.h>\n# include <sys/shm.h>\n# include <sys/stat.h>\n# include <sys/types.h>\n# include <unistd.h>\n# define MAX_SEQUENCE 10\n\ntypedef struct{\nlong fib_sequence[MAX_SEQUENCE];\nint sequence_size;\n} shared_data;\n\nchar* shared_memory; /* a pointer to the shared memory segment */\n\nint main()\n{\nint a,b,m,n,i,j;\na=0; b=1;\nprintf(\"Enter the number of a Fibonacci Sequence:\\n\");\nscanf(\"%d\", &m);\n\nif (m < 0)\n        printf(\"Please enter a non-negative integer\\n\");\nelse if (m> MAX_SEQUENCE)\n        printf(\"Please enter an integer less than 10\\n\");\n\nint segment_id; /* the identifier for the shared memory segment */\n\nint segment_size = sizeof(shared_data); /* the size (in bytes) of the shared memory segment */\nsegment_id = shmget(IPC_PRIVATE, segment_size, S_IRUSR | S_IWUSR); /** allocate  a shared memory segment */\nshared_data *shared_memory = shmat(segment_id, NULL, 0); /** attach the shared memory segment */\nprintf(\"\\nshared memory segment %d attached at address %p\\n\", segment_id, shared_memory);\n\nshared_data->sequence_size = m;\npid_t pid;\npid = fork();\n    if (pid == 0){\n        printf(\"Child is producing the Fibonacci Sequence...\\n\");\n        shared_data->fib_sequence[0] = a;\n    shared_data->fib_sequence[1] = b;\n        for (i=2;i<shared_data->sequence_size;i++){\n        n=a+b;\n        shared_data->fib_sequence[i] = n;\n        a=b;\n        b=n;\n        }\n        printf(\"\\nChild ends\\n\"); \n    }\n    else{\n        printf(\"Parent is waiting for child to complete...\\n\");\n        wait(NULL);\n        printf(\"Parent ends\\n\");\n    for(i=0;i<= shared_data->sequence_size;i++)\n        printf(\"%ld \", shared_data->fib_sequence[i]);\n    }\n\n/**printf(\"%s \\n\", shared_memory);  now print out the string from shared memory */\n\n/** now detach the shared memory segment */ \nif ( shmdt(shared_memory) == -1) {\n    fprintf(stderr, \"Unable to detach\\n\");\n}\n\n/** now remove the shared memory segment */\nshmctl(segment_id, IPC_RMID, NULL); \n\nreturn 0;\n}\n```\n\n\nThe statement is\n\"An approach to designing fibonacci program is to establish a shared-memory segment between the parent and child processes.\nThis technique allows the child to write contents of the Fibonacci sequence to the shared-\nmemory segment and has the parent output the sequence when the child completes.\nBecause the memory is shared, any changes the child makes will be reflected in parent\nprocess as well. This program will be structured using POSIX shared memory as described in\nhttp://graphics.im.ntu.edu.tw/~robin/courses/os07/code/03proc/shm-posix.c\nThis program first requires creating the data structure for the shared-memory segment. This is most easily accomplished using a struct. This data structure will contain two items:\n1. A fixed size array of size MAX_SEQUENCE that will hold the Fibonacci values and\n2. The size of the sequence the child process is to generate, i.e. sequence_size, where\nsequence_size ≤ MAX_SEQUENCE.\n\nThese items can be represented in a struct as follows:\n\n```\n# define MAX_SEQUENCE 10\ntypedef struct{\nlong fib_sequence[MAX_SEQUENCE];\nint sequence_size;\n} shared_data;\n```\n\n\nThe parent process will progress through the following steps:\na. Accept the parameter passed on the command line and perform error checking to ensure\nthat the parameter is ≤ MAX_SEQUENCE.\nb. Create a shared memory segment of size shared_data .\nc. Attach the shared-memory segment to its address space.\nd. Set the value of sequence_size to the parameter on the command line.\ne. Fork the child process and invoke the wait() system call to wait for the child process to\nfinish.\nf. Output the value of Fibonacci sequence in the shared- memory segment.\ng. Detach and remove the shared-memory segment.\n\nThe shared-memory segment will be attached to the child’s address space as well as the\nparent’s address space. The child process will then write the Fibonacci sequence to the\n\nshared-memory segment. The parent and child processes must be synchronized so that\nthe parent would not output the Fibonacci sequence until the child finishes generating the\nsequence.\nNOTE: Display sufficient messages on the console to let the user know when a certain action\nis performed, e.g. creation and termination of child process, etc.\"\n\nExpert minds Kindly help.\n    ", "Answer": "\r\nFirst problem:\n\n```\nint a,b,m,n,i,j;\n\nsequence.fib_sequence[0] = a;\nsequence.fib_sequence[1] = b;\n```\n\n\nYou never initialise ```\na```\n and ```\nb```\n, thus you get garbage (and undefined behaviour). Initialise\n\n```\na = 0;\nb = 1;\n```\n\n\nDeeper problem: You set up a shared memory segment, but never use it. You use the global\n\n```\nshared_data sequence;\n```\n\n\nto write to in the child, and to read from in the parent. Since that global has nothing to do with the shared memory you set up, the child's actions don't modify the parent's ```\nsequence```\n.\n\nYou should use ```\nshared_memory```\n, the pointer to the shared memory to write to and read from. So instead of a ```\nchar*```\n, it should be\n\n```\nshared_data *shared_memory = shmat(...);\n```\n\n\nand then use ```\nshared_memory->sequence[i]```\n etc.\n\nAfter fixing the ```\nshared_data/shared_memory```\n mixup and adding a bit of error-checking, the programme could look like\n\n```\n# include <stdlib.h>\n# include <stdio.h>\n# include <sys/shm.h>\n# include <sys/stat.h>\n# include <sys/types.h>\n# include <unistd.h>\n# include <sys/wait.h>\n# include <errno.h>\n\n// So we could use other sizes without editing the source.\n#ifndef MAX_SEQUENCE\n# define MAX_SEQUENCE 10\n#endif\n\n// Check that MAX_SEQUENCE is large enough!\n#if MAX_SEQUENCE < 2\n#error MAX_SEQUENCE must be at least 2\n#endif\n\ntypedef struct{\n    long fib_sequence[MAX_SEQUENCE];\n    int sequence_size;\n} shared_data;\n\nint main()\n{\n    int a, b, m, n, i;\n    a = 0; b = 1;\n    printf(\"Enter the number of a Fibonacci Sequence:\\n\");\n    // Always check whether input conversion worked\n    if (scanf(\"%d\", &m) != 1) {\n        printf(\"Invalid input, couldn't be converted.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if (m <= 0) {\n        printf(\"Please enter a positive integer\\n\");\n        return EXIT_FAILURE;  // exit if input is invalid\n    } else if (m > MAX_SEQUENCE) {\n        printf(\"Please enter an integer less than %d\\n\", MAX_SEQUENCE);\n        return EXIT_FAILURE;  // exit if input is invalid\n    }\n\n    /* the identifier for the shared memory segment */\n    int segment_id;\n\n    /* the size (in bytes) of the shared memory segment */\n    size_t segment_size = sizeof(shared_data);\n\n    /* allocate  a shared memory segment */\n    segment_id = shmget(IPC_PRIVATE, segment_size, S_IRUSR | S_IWUSR);\n\n    // Check result of shmget\n    if (segment_id == -1) {\n        perror(\"shmget failed\");\n        return EXIT_FAILURE;\n    }\n\n    /* attach the shared memory segment */\n    shared_data *shared_memory = shmat(segment_id, NULL, 0);\n\n    // Check whether attaching succeeded\n    if ((void*)shared_memory == (void*)-1) {\n        perror(\"shmat failed\");\n        goto destroy; // clean up\n    }\n    printf(\"\\nshared memory segment %d attached at address %p\\n\", segment_id, (void*)shared_memory);\n\n    shared_memory->sequence_size = m;\n    pid_t pid;\n    pid = fork();\n    if (pid == 0){\n        printf(\"Child is producing the Fibonacci Sequence...\\n\");\n        shared_memory->fib_sequence[0] = a;\n        shared_memory->fib_sequence[1] = b;\n        for (i = 2; i < shared_memory->sequence_size; i++){\n            n = a+b;\n            shared_memory->fib_sequence[i] = n;\n            a = b;\n            b = n;\n        }\n        printf(\"\\nChild ends\\n\"); \n    }\n    else{\n        printf(\"Parent is waiting for child to complete...\\n\");\n        wait(NULL);\n        printf(\"Parent ends\\n\");\n        for(i = 0; i < shared_memory->sequence_size; i++) {\n            printf(\"%ld \", shared_memory->fib_sequence[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    /* now detach the shared memory segment */ \n    if (shmdt(shared_memory) == -1) {\n        fprintf(stderr, \"Unable to detach\\n\");\n    }\n\n    destroy:\n    /* now remove the shared memory segment */\n    shmctl(segment_id, IPC_RMID, NULL); \n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence Javascript do while loop\r\n                \r\nI have been going through various threads and languages on this topic but I do not seem to find a solution for setting a bar for a fibonacci sequence to stop below 100 with a ```\ndo while```\n loop in Javascript.\n\n```\nvar fbnci = [0, 1];\nvar i = 2;\n\ndo {\n   // Add the fibonacci sequence: add previous to one before previous\n   fbnci[i] = fbnci [i-2] + fbnci[i-1];\n   console.log(fbnci[i]);\n   fbnci[i]++;\n} \nwhile (fbnci[i] < 100);\n```\n\n\nFor some reason, the code above only runs once. What should I set the while condition to in order to keep printing the result until it reaches the closest value to 100?\n    ", "Answer": "\r\nYou have an error in the code, it should be :\n\n```\nvar fbnci = [0, 1], max = 100, index = 1, next;\ndo {\n  index++;\n  next = fbnci[index-2] + fbnci[index-1];\n  if (next <= max) {\n      console.log(next);\n      fbnci[index] = next;\n  }\n} while(next < max);\n```\n\n\nSolution that prints all fib numbers that are lower than max.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why does my python Fibonacci Sequence algorithm not run properly?\r\n                \r\nWrite a program that prints the Fibonacci Sequence from the 5th till the 15th element of the sequence.\nHow should i start from the 5th one, which is '3'? here is my code\n```\ndef fibonacci_nums(n):\n    if n <= 0:\n        return [0]\n    sequence = [0, 1]\n    while len(sequence) <= n:\n        next_value = sequence[len(sequence) - 1] + sequence[len(sequence) - 2]\n        sequence.append(next_value)\n      \n\nreturn sequence\n\nprint(\"First 15 Fibonacci numbers:\")\nprint(fibonacci_nums(15))\n```\n\n    ", "Answer": "\r\n```\ndef fibonacci_nums(n):\n  if n <= 0:\n    return [0]\n  sequence = [0, 1]\n  while len(sequence) <= n:\n    next_value = sequence[len(sequence) - 1] + sequence[len(sequence) - 2]\n    sequence.append(next_value)\n  return sequence[4:]\nprint(\"Fibonacci numbers from 5th to 15th number:\")\nprint(fibonacci_nums(14))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Using Intstream to generate infinite Fibonacci sequence\r\n                \r\nIm having a little issue figuring out how to use stream to generate an infinite sized, sequential stream which contains all the numbers in a fibonacci sequence. \n\nHow would I be able to print out an infinite stream? Any advice helps, thanks.\n    ", "Answer": "\r\n```\npublic class Fibonacci {\n\n    public static void main(String[] args) {\n        IntStream stream = IntStream.generate(new FibonacciSupplier());\n        stream.limit(20).forEach(System.out::println);\n    }\n\n    private static class FibonacciSupplier implements IntSupplier {\n\n        int current = 1;\n        int previous = 0;\n\n        @Override\n        public int getAsInt() {\n            int result = current;\n            current = previous + current;\n            previous = result;\n            return result;\n        }\n    }\n}\n```\n\n\nNote however that this stream can't be infinite as soon as you reach the 47th element, the value is too large to fit into a positive integer.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence using a do-while loop in java?\r\n                \r\nI am trying to print a Fibonacci sequence using a ```\ndo-while```\n loop in java and can't understand this.  Needs to be between 0 and 100.\n\nI have the following code:\n\n```\nint prevPrevVal = 0;\nint prevVal = 1;\nint currVal;\nSystem.out.println(prevPrevVal);\nSystem.out.println(prevVal);\n\ndo\n{       \n    currVal = prevVal + prevPrevVal;\n    System.out.println(currVal);\n\n    prevPrevVal = prevVal;\n    prevVal = currVal;          \n} while (prevVal <= 100);\n```\n\n    ", "Answer": "\r\nThis is a simplified program to find out the Fibonacci series by providing the conditional limit in the while loop. Hope you guys get an idea over with this....!!\n\n```\n    int a=0;\n    int b=0;\n    int temp=1;\n    do {    \n        a=b;\n        b=temp;\n        temp=a+b;\n        System.out.println(temp);\n    }while(temp<100);\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence using reduce method\r\n                \r\nSo, I saw someone using the reduce method to calculate the Fibonacci sequence.\nHere is his idea: (1,0) , (1,1) , (2,1) , (3,2) , (5,3) corresponds to\n1, 1, 2, 3, 5, 8, 13, 21 .......\nand the code looks like this\n```\ndef fib_reduce(n):\n    initial =(1,0)\n    dummy = range(n)\n    fib_n = reduce(lambda prev ,b : (prev[0] + prev[1], prev[0]),\n                   dummy,\n                   initial)\n    \n    return fib_n[0]\n```\n\nI understand the ```\n(prev[0] + prev[1] , prev[0])```\n which is like\n```\na, b = b, b + a```\n.\nHowever, I don't understand what this ```\nb```\n stands for ?\nMay someone please explain this ```\nb```\n?\n    ", "Answer": "\r\nRepeatedly applying a function using ```\nreduce```\n\nThis answer suggests writing up your own function ```\nrepeated```\n to repeatedly apply a function, rather than calling ```\nreduce```\n with a dummy second argument.\nWe still use ```\nreduce```\n, but in a more functional manner and with ```\nitertools.repeat```\n.\n```\nfrom itertools import repeat\nfrom functools import reduce\n\ndef repeated(func, n):\n    def apply(x, f):\n        return f(x)\n    def ret(x):\n        return reduce(apply, repeat(func, n), x)\n    return ret\n\ndef fibonacci(n):\n  get_next_pair = lambda p: (sum(p), p[0])\n  first_pair = (1, 0)\n  return repeated(get_next_pair, n)(first_pair)[1]\n\nprint(fibonacci(0), fibonacci(1), fibonacci(11))\n# 0 1 89\n```\n\nRepeatedly apply a linear function using linear algebra\nThe function ```\nlambda a,b: b,a+b```\n which you want to apply happens to be a linear function. It can be represented by a 2*2 matrix. Repeatedly applying the function to a two-element tuple is the same as repeatedly multiplying a two-element vector by the matrix.\nThis is cool, because taking the power of a matrix is much, much faster than repeatedly applying a function.\n```\nimport numpy as np\n\ndef fibonacci(n):\n  return np.linalg.matrix_power(np.array([[0, 1],[1,1]]), n).dot(np.array([0,1]))[0]\n\nprint(fibonacci(0), fibonacci(1), fibonacci(11))\n# 0 1 89\n```\n\nIf you don't like one-liners, here is the same function decomposed on a few lines with more explicit variable names:\n```\nimport numpy as np\n\ndef fibonacci(n):\n  next_pair_matrix = np.array([[0, 1],[1,1]])\n  matrix_to_the_nth = np.linalg.matrix_power(next_pair_matrix, n)\n  first_pair_vector = np.array([0,1])\n  nth_pair_vector = matrix_to_the_nth.dot(first_pair_vector)\n  return nth_pair_vector[0]\n\nprint(fibonacci(0), fibonacci(1), fibonacci(11))\n# 0 1 89\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence calculator\r\n                \r\nI have an issue with some homework, so basically we were asked to create a bash script that takes a variable greater than 2 and gives back the same number of Fibonacci sequence numbers, i.o. if i were to give 5 it would print:\n0 1 1 2 3\nI have done some research and have come up with a unique idea i havent really seen anywhere online, (keep in mind i have some experience in python) but i have run into a problem, so basically i use a for expression in bash and 2 variables to calculate the sequence, i first manually set them to be 0 and 1 (the first and second numbers in the sequence) and then i add them together while changing their values,\n\nSo here is the code :\n\n```\n#!/bin/bash\na=0\nb=1\nfor i in $(seq 1 $1);\ndo\n  if [\"$a\" -gt \"$b\"]\n  then \n    b=($a +$b)\n    echo \"$b\"\n  else\n    a=($a +$b)\n    echo $a\n  fi\ndone\n```\n\n\nI have many issues and expect to be completely out of context but i hope you get the general idea and can help guide me through the problem :/\nIt seems like i want something to be treated as a number but its treated as text... Not sure though, any help is highly appreciated\n    ", "Answer": "\r\nYou were very close, some small syntactic changes and new initial values make it work.\n\nNotes: \n\n\nwhitespace is important in bash, especially with special characters [ ] ; \nalso, calculation with integer number can be forced using let\n\n\nNice idea to use a comparison to do the calculation with just two variables :)\n\n```\n#!/bin/bash - \na=1\nb=0\necho $a\nfor i in $(seq 1 $1);\ndo\n    if [ $a -gt $b ] ; then\n        let b=($a +$b)\n        echo $b\n    else\n        let a=($a +$b)\n        echo $a\n    fi\ndone\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "I want to find if given numbers are in fibonacci sequence\r\n                \r\nI want to find if the given numbers are in the Fibonacci sequence.\n```\nnum = map(int,input(\"Enter numbers: \").split())\n\ndef fib(num):\n    a = 0\n    b = 1\n    while b<num:\n        c = a+b\n        a = b\n        b = c\n    if b==num or a==num:\n        return True\n    if b > num:\n        return False\n\n```\n\n\nIn this part I found the number if it's Fibonacci or not. But I couldn't find the sequence of fibonacci numbers.\n\n    ", "Answer": "\r\nOne way you can get the sequence is to store the result as you iterate through in a dictionary:\n```\ndef in_fib(num):\n    if num==0:\n        return True\n    d={}\n    d[0]=0; d[1]=1\n    i=2\n    while d[i-1]<num:\n        d[i]=d[i-1]+d[i-2]\n        i+=1\n    \n    print(\"The sequence is: \", d.values())\n    \n    if d[i-1]==num:\n        return True\n    \n    \n    return False\n    \n\nprint(in_fib(1))\nprint(in_fib(144))\nprint(in_fib(88))\n```\n\nOutput:\n```\n'The sequence is: ', [0, 1])\nTrue\n('The sequence is: ', [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144])\nTrue\n('The sequence is: ', [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89])\nFalse\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Creating Fibonacci sequence in C\r\n                \r\nI'm in the process of creating a Fibonacci sequence generator in C for a school lab, but it can't be the regular way of 0 1 1 2 3 5 etc... the program is supposed to ask the user for a limit, and 2 numbers and generate the sequence from there.\n\nHere is what I have so far:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\nint main(void) \n{\n    int num1, num2, num3, limit;\n    int Fibarray[10];\n    //Ask the user for a limit to the number of values displayed, checks to see if value is greater\n    // than 10 or less than 0, if so displays an error message  \n    printf(\"Please enter limit of values generated, the limit must be 10 or less, but greater than 0\\n\");\n    scanf (\"%i\", &limit);\n    if (limit > 10)\n    {\n        printf(\"Please enter a valid integer greater than 0, and less than or equal to 10\");\n    }\n    else    \n        printf(\"Please enter 2 numbers separated by a space, the second number must be larger than the first\"); \n    scanf (\"%i\", &num1, &num2);\n    if (num1>num2||num1<0)\n    {\n        puts(\"Please re enter your numbers, make sure they are in ascending order & the second number is greater than 0\");\n        return(15); \n    }\n    else\n    {\n        // ...\n    }\n}\n```\n\n\nWhat I'm trying to figure out is, how would I have the two values added together, stored in the array, and added again etc. to the limit.\n\nI believe this problem is different from How to generate Fibonacci series in C because in this program I need to have it accept values from the user, not preset values.\n\nI've been looking through my book on this but it's not very helpful.\n    ", "Answer": "\r\nregarding: \n\n```\nscanf (\"%i\", &num1, &num2); \n```\n\n\nThis will cause the compiler to output a warning message AND the variable num2 will never be set. Suggest: \n\n```\nsize_t num1;\nsize_t num2;\n\n....\n\nif( 2 != scanf( \"%lu %lu\", &num1, &num2 ) ) \n{ \n    fprintf( stderr, \"scanf for num1, num2 failed\\n\" );\n    exit( EXIT_FAILURE ); \n} \n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Writing Fibonacci Sequence to a file Python?\r\n                \r\nI've been having some struggle getting each number in the Fibonacci sequence to write to a file, I know there is something I'm doing wrong, but I can't pinpoint it. Is there a more efficient approach? Any help is appreciated.\n\n```\nimport sys\nimport os\nimport time\n\nknown = {0:0, 1:1}\n\ndef fibonacci_slow(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci_slow(n-1) + fibonacci_slow(n-2)\n\ndef fibonacci_fast(n):\n    f = open('fib500.txt', 'w')\n    if n in known:\n        return known[n]\n    res = fibonacci_fast(n-1) + fibonacci_fast(n-2)\n    print res\n    if fibonacci_fast:\n        f.write(res)\n    known[n] = res\n    return res\n\ndef main():\n    time_start = time.time()\n    print fibonacci_slow(10)\n    time_end = time.time()\n    print \"Time for slow fibonacci to complete \", time_end - time_start\n\n    time_start = time.time()\n    print fibonacci_fast(500)\n\n    time_end = time.time()\n    print \"Time for fast fibonacci to complete \", time_end - time_start\n\n\nif __name__ == '__main__':\n    main()\n```\n\n    ", "Answer": "\r\nYou need to take the writing into the file out of the fibonacci_fast method. Each time you call it, it re-opens the file and, since you didn't close it, there is no guarantee that it will be written into the file. \n\nAs for speed, recursion is not a good fit for your calculations. You don't need the recursive call:\n\n```\nres = fibonacci_fast(n-1) + fibonacci_fast(n-2)\n```\n\n\nbecause you could have already come up with the return value of those calls. It would be better to start from the beginning and working until you get to the value that you want, without suffering the overhead caused by this kind of recursion. In other words, it would be faster to take an iterative approach. \n\nAs you are probably trying to show, generating the n-th number in the Fibonacci sequence is not a good candidate for recursion, in the sense of speed/optimization. \n\nIf you change your fibonacci_fast to something like:\n\n```\ndef fibonacci_fast(n):\n    known = [0, 1]\n    count = 0\n    for i in range(n):\n        newNum = known[0] + known[1]\n        known[0] = known[1]\n        known[1] = newNum\n    return known[0]\n```\n\n\nand running your test script:\n\n```\ndef main():\n    time_start = time.time()\n    print fibonacci_slow(20)\n    time_end = time.time()\n    print \"Time for slow fibonacci to complete \", time_end - time_start\n\n    time_start = time.time()\n    print fibonacci_fast(20)\n    time_end = time.time()\n    print \"Time for fast fibonacci to complete \", time_end - time_start\n```\n\n\nyou get:\n\n```\n6765\nTime for slow fibonacci to complete  0.0043318271637\n6765\nTime for fast fibonacci to complete  0.00010085105896\n```\n\n\nand to write it to a file you can add a file argument which you can write to:\n\n```\ndef fibonacci_fast(n, f):\n    known = [0, 1]\n    for i in range(n):\n        newNum = known[0] + known[1]\n        known[0] = known[1]\n        known[1] = newNum\n        f.write(str(known[0]) + \" \")\n    return known[0]\n```\n\n\nand call it like so:\n\n```\nf = open(\"fib.txt\", \"w\")\nfibonacci_fast(20, f)\nf.close()\n```\n\n\nor the more 'pythonic' way (which is a little bit faster):\n\n```\nwith open(\"fib.txt\", \"w\") as f:\n    fibonacci_fast(20, f)\n```\n\n\nYou can see the big difference between the recursive and iterative approach if you try to generate the 500th number in the sequence. It takes minutes (if not hours, I haven't waited it out) to finish the recursive function but only a fraction of a fraction of a second to do the iterative method, even with writing it to a file.\n\nMore information on the fibonacci sequence can be found here.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence using list in PYTHON?\r\n                \r\nI have a problem about making a fibonacci sequence to a list, I'm just new to python someone help me please. \n\nThis is my code. I know this is looking wrong or something because it says invalid syntax. I don't know what to do about this really :(\n\nThis code works for a normal code without using a list!\n\n```\nmyArray1 = [0] \nmyArray2 = [1]\n\nwhile myArray2 < 700:\n    myArray1, myArray2 = b[i], myArray1+myArray2[i]\n    print(myArray2)\n```\n\n    ", "Answer": "\r\nThis code puts the first 700 fibonacci numbers in a list. Using meaningful variable names helps improve readability!\n\n```\nfibonacci_numbers = [0, 1]\nfor i in range(2,700):\n    fibonacci_numbers.append(fibonacci_numbers[i-1]+fibonacci_numbers[i-2])\n```\n\n\nNote: If you're using Python < 3, use ```\nxrange```\n instead of ```\nrange```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence with Unfold in Ocaml\r\n                \r\nI'm relatively new to Ocaml and think I'm understanding the Unfold function correctly but I just can't see how to make a fibonacci sequence using it. Wouldn't we need to have a holder variable of the last two values so we could find the current one? All help is greatly appreciated. I'm adding the Unfold function below for reference. \n\n```\nlet rec unfold (f: 'seed -> ('a * 'seed)) (stop : 'b -> bool) (b :'seed) : 'a list =\nif stop b then []\nelse \n  let x, b' = f b in\n   x :: (unfold f stop b')\n```\n\n    ", "Answer": "\r\nYou had the right idea of storing the last two values to create the next one. The trick is to store them in a tuple.\n\nThe generator function takes the tuple, returns the first number as the generated value and creates a new state with the second number of the tuple and the next fibonacci number:\n\n```\nfun (a, b) -> (a, (b, a+b))\n```\n\n\nThe stop function just takes the tuple and decides when to stop, e.g.\n\n```\nfun (a, b) -> a > 1000\n```\n\n\nThe first state is ```\n(0, 1)```\n which are the first two fibonacci numbers.\n\nPutting it all together:\n\n```\n# unfold (fun (a, b) -> (a, (b, a+b))) (fun (a, b) -> a > 1000) (0, 1);;\n- : int list =\n[0; 1; 1; 2; 3; 5; 8; 13; 21; 34; 55; 89; 144; 233; 377; 610; 987]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence in VB.net using loop\r\n                \r\nPlease could you help me with displaying the first 10 Fibonacci numbers.  My code displays the following result:  1, 2, 3, 5, 8, 13, 21, 34, 55 and I need it to also display the first two Fibonacci numbers (0 and 1). How would I do that?\n\n```\nPublic Class Form1\n  Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click\n    Dim a As Integer = 0\n    Dim b As Integer = 1\n    Dim fib As Integer = 0\n\n    Do\n      fib = a + b\n      a = b\n      b = fib\n      Label1.Text = Label1.Text + fib.ToString & ControlChars.NewLine\n    Loop While fib < 55\n  End Sub\nEnd Class\n```\n\n\nWhere in professional programming would you need to use Fibonacci sequences?\n    ", "Answer": "\r\nJust add \n\n```\nLabel1.Text = Label1.Text + a.ToString & ControlChars.NewLine\nLabel1.Text = Label1.Text + b.ToString & ControlChars.NewLine\n```\n\n\nbefore the ```\nDo ... while```\n.\n\nFor applications linked to Fibonacci numbers see : Fibonacci: Applications\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Nth Value of Fibonacci Sequence JavaScript (timeout error)\r\n                \r\nI have a working solution for this Kata (find nth value of Fibonacci Sequence), however I keep getting a timeout error.  Can anyone offer advice on how to refactor this to run more efficiently?  Thanks in advance!   \n\nHere is the link with description - https://www.codewars.com/kata/simple-fun-number-395-fibonacci-digit-sequence/train/javascript\n\n\n  You are given three non negative integers a, b and n, and making an infinite sequence just like fibonacci sequence, use the following rules:\n  \n  step1: use ab as the initial sequence. \n  step2: calculate the sum of the\n  last two digits of the sequence, and append it to the end of sequence.\n  repeat step2 \n  Your task is to complete function find. \n  Return nth digit(0-based) of the sequence.\n\n\n\r\n\r\n```\nfunction find(a,b,n){\r\n  let start = (\"\" + a + b);\r\n  let next = a + b;\r\n  let seq = start + next;\r\n  \r\n  while (seq.length <= n) {\r\n    seq += (parseInt(seq[seq.length-2]) + parseInt(seq[seq.length-1]));\r\n  }\r\n  return parseInt(seq[n]);\r\n}\r\n\r\nconsole.log(find(7,8,9))\r\n\r\n// should return 5```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nFirstly . . . don't use strings, don't use ```\nparseInt```\n, don't hold onto the entire sequence at once. You only need numbers, and you only need the last two digits. Given a number ```\nx```\n between 10 and 18 (which is the largest possible sum of two digits), its tens' place is ```\n1```\n and its ones' place is ```\nx - 10```\n. That alone will be a significant improvement.\n\nSecondly . . . since the entire sequence after a given point is determined by the first two digits at that point,1 and there are only 100 possible sequences of two digits, every sequence has to repeat within 200 digits; that is, within at most 200 digits, it will necessarily enter a loop of repeating digits that it never gets out of, where that loop is less than 200 digits long.2 So if ```\nn```\n is greater than a few hundred, you can massively optimize by finding the length of this loop and \"skipping\" a large multiple of that length.\n\n1. Actually, this isn't quite true as written. For example, the sequences 69156… and 79167… bot contain 91, but followed by different things. This is because the '1' belongs to a two-digit number, both of whose digits are determined by the previous two digits. I'm not sure how to express this better, but hopefully you see what I mean. It doesn't affect the overall argument, but it's something you need to be careful with in how you apply the idea.\n2. Actually much less; testing all possible values of a and b, I find that the sequence always enters the loop and completes its first iteration within just 25 digits! But I'm not sure how to rigorously justify this much smaller figure other than exhaustive testing; so it would probably be cheating to write the code in a way that relied on it.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generating Fibonacci sequence with PL/pgSQL function\r\n                \r\nI'm trying to generate the Fibonacci sequence with a function in SQL. It takes an input parameter ```\npstop integer```\n (10 by default) and returns a table with all Fibonacci numbers less than ```\npstop```\n.\nBut the output starts with these numbers (1, 2, 3, 5, 8, 13) and skips the numbers of the beginning of the sequence which are 0 and 1 (0, 1, 2, 3, 5, 8, 13).\nHow can I fix it?\n```\nCREATE OR REPLACE FUNCTION fnc_fibonacci (pstop INTEGER DEFAULT 10)\nRETURNS TABLE (fibonacci_num INTEGER) AS $BODY$\nDECLARE\n    a INTEGER;\n    b INTEGER;\n    c INTEGER;\nBEGIN\n    a := 0;\n    b := 1;\n    fibonacci_num := 0;\n    WHILE\n        fibonacci_num < pstop LOOP\n        c := a + b;\n        fibonacci_num := c;\n        IF\n            fibonacci_num < pstop THEN\n            RETURN NEXT;\n        END IF;\n        a := b;\n        b := c;\n    END LOOP;\nEND;\n$BODY$\nLANGUAGE PLPGSQL;\n\nSELECT * FROM fnc_fibonacci(20);\n```\n\n    ", "Answer": "\r\nTo note: the Fibonacci sequence starts with 0, 1, 1, 2 (not 0, 1, 2).\nAssignments are ever so slightly expensive in PL/pgSQL. So keep those at a minimum. It's an academic consideration for a function returning no more than 46 rows with type ```\ninteger```\n. (It gets more relevant with big numbers operating with ```\nnumeric```\n.)\nAnyway, here is an optimized function with a single addition and assignment per output row:\n```\nCREATE OR REPLACE FUNCTION f_fibonacci (pstop int = 10)\n  RETURNS SETOF int\n  LANGUAGE plpgsql IMMUTABLE STRICT AS\n$func$\nDECLARE\n    a int := 0;\n    b int := 1;\nBEGIN\n   /*\n   -- optional sanity check:\n   -- function starts operating at 2\n   -- and int4 computation overflows past Fibonacci Nr. 1836311903\n   IF pstop NOT BETWEEN 2 AND 1836311903 THEN\n      RAISE EXCEPTION 'Pass integer betwen 2 and 1836311903. Received %', pstop;\n   END IF;\n   */\n\n   -- main\n   RETURN NEXT 0;\n   RETURN NEXT 1;\n   LOOP\n      a := a + b;\n      EXIT WHEN a >= pstop;\n      RETURN NEXT a;\n\n      b := b + a;\n      EXIT WHEN b >= pstop;\n      RETURN NEXT b;\n   END LOOP;\nEND;\n$func$;\n```\n\nfiddle\nNote that we can simply ```\nRETURN NEXT 0;```\n in a function declared with ```\nRETURNS SETOF int```\n without naming any ```\nOUT```\n parameters. (Column names in ```\nRETURNS TABLE```\n are ```\nOUT```\n parameters, too.)\nDetails in the manual chapter \"Returning from a Function\".\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Check if string includes part of Fibonacci Sequence\r\n                \r\nWhich way should I follow to create an algorithm to find out whether fibonacci sequence exists in a given string ? \n\nThe string includes only digits with no whitespaces and there may be more than one sequence, I need to find all of them.\n    ", "Answer": "\r\nIf as your comment says the first number must have less than 6 digits, you can simply search for all positions there one of the 25 fibonacci numbers (there are only 25 with less than 6 digits) and than try to expand this 1 number sequence in both directions.\n\nAfter your update:\n\nYou can even speed things up when you are only looking for sequences of at least 3 numbers.\n\nPrebuild all 25 3-number-Strings that start with one of the 25 first fibonnaci-numbers this should give much less matches than the search for the single fibonacci-numbers I suggested above.  \n\nThan search for them (like described above and try to expand the found 3-number-sequences).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "First real program in C: Fibonacci sequence\r\n                \r\nI'm trying to write the first 10 terms of the Fibonacci sequence. I feel like I'm on the right line, but I can't seem to quite grasp the actual code (in C).\n\n```\nfloat fib = 0;\nconst float minn = 1;\nconst float maxn  = 20;\nfloat n = minn;\nwhile (n <= maxn);{\nn = n + 1;\nprintf (\" %4,2f\", fib);\nfib = (n - 1) + (n - 2);\n}\n```\n\n    ", "Answer": "\r\nWith the fibonacci sequence the value f(n) = f(n - 1) + f(n = 2).  the first three values are defined as 0, 1, 1.\n\nThe fibonacci sequence is a sequence of integer values (math integers, not necessarily C language values).  consider using int or long for the fibonacci value.  float is worthless, it only adds unneeded overhead.\n\nwhen calculating the fibonacci sequence you must store the previous 2 values to get the next value.\n\nyou want 10 fibonacci values.  you know the first three already so print those and then calculate the next seven values.\n\n7 values implies a loop that iterates 7 times.  it has no bearing on the maximum value of the fibonacci value returned, just how many values you want to print.\n\ndo something like this:\n\n```\nprintf(\"0, 1, 1\");\n\nint currentValue;\nint valueN1 = 1;\nint valueN2 = 1;\n\nfor (int counter = 1; counter <= 7; ++counter)\n{\n    currentValue = valueN1 + valueN2;\n    printf(\", %d\", currentValue);\n\n    valueN2 = valueN1;\n    valueN1 = currentValue;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Linked list Fibonacci sequence runtime error\r\n                \r\nMy program saves the odd and even numbers seperately in linked lists among a given first n numbers of the Fibonacci sequence. Its in C.\n\nWhen allocating the Head nodes I get a runtime error, Stopped Responding. I'm not able to locate the problem. It may even be about something else I'm not sure.\n\nThanks in advance\n\n```\nstruct odd{\n       int value;\n       struct odd * next;\n};\n\nstruct even{\n       int value;\n       struct even * next;\n};\n\nstruct list{\n\n       struct odd * oHead;\n       struct odd * oCurrent;\n\n       struct even * eHead;\n       struct even * eCurrent;\n};\n\ntypedef struct list * List;\n\nvoid init(int i, List fib){ // allocates the linked list according to first i numbers of the Fibonacci sequence\n\n     int evenCount;\n     int oddCount;\n     int j;\n\n     /*Calculates the count of even and odd numbers */\n\n     for( j = 0 ; j < evenCount ; j++){\n           if(j == 0){\n                    **fib->eHead->next = (struct even*)malloc(sizeof(struct even));**\n                    fib->eCurrent = fib->eHead->next;\n           }\n           else{\n                fib->eCurrent->next = (struct even*)malloc(sizeof(struct even));\n                fib->eCurrent = fib->eCurrent->next;\n           }\n     }\n     for( j = 0 ; j < oddCount ; j++){\n           if(j == 0){\n                    **fib->oHead->next = (struct odd*)malloc(sizeof(struct odd));**\n                    fib->oCurrent = fib->oHead->next;\n\n           }\n           else{\n               fib->oCurrent->next = (struct odd*)malloc(sizeof(struct odd));\n               fib->oCurrent = fib->oCurrent->next;\n           }\n     }\n}\n\nmain(){\n   List fib\n   init(15,fib);\n}\n```\n\n    ", "Answer": "\r\nI don't know why you've not set ```\nevenCount```\n and ```\noddCount```\n but if they're greater than 0 then this line\n```\nfib->eHead\n```\n\nis dereferencing a pointer that's NULL. The following line is not initialization\n```\nList fib;\n```\n\nThat's a declaration of a pointer to a List object that has not been initialized yet. If your typedef was...\n```\ntypedef struct list List;\n```\n\nIt would initialize an empty struct on the stack but that's not what you're doing. If you do change the type declaration you're still using pointers in this\n```\nstruct list{\n       struct odd * oHead;\n       struct odd * oCurrent;\n       struct even * eHead;\n       struct even * eCurrent;\n};\n```\n\nso the same problem applies, you cannot dereference any of them until they allocated.\nWith regards ```\nevenCount```\n and ```\noddCount```\n you should explicitly set them in the function or you have undefined behavior.\n\nIf an object that has automatic storage duration is not initialized explicitly, its value is indeterminate.\nIf an object that has static storage duration is not initialized\nexplicitly, then:\nif it has pointer type, it is initialized to a null pointer; if it has\narithmetic type, it is initialized to (positive or unsigned) zero; if\nit is an aggregate, every member is initialized (recursively)\naccording to these rules; if it isaunion, the ﬁrst named member is\ninitialized (recursively) according to these rules.\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Calculate the Fibonacci sequence using two threads.\r\n                \r\nI have this code:\n\n```\n#include <vcl.h>\n#pragma hdrstop\n\n#include \"Unit1.h\"\n\n#pragma package(smart_init)\n#pragma resource \"*.dfm\"\nTForm1 *Form1;\n\n__fastcall TForm1::TForm1(TComponent* Owner) : TForm(Owner) { }\n\nint Fibonacci(int nNumber) {\n    if (nNumber == 0)\n        return 0;\n    if (nNumber == 1)\n        return 1;\n\n    return Fibonacci(nNumber-1) + Fibonacci(nNumber-2);\n}\n\nvoid __fastcall TForm1::Button1Click(TObject *Sender) {\n    int k=0;\n    int val;\n\n    k = StrToInt(Edit1->Text);\n\n    for (int i=0; i < k; i++) {\n        val =  Fibonacci(i);\n        Form1->ListBox1->Items->Add(\"F\"+IntToStr(i)+\"-->\"+IntToStr(val));\n    }\n}\n```\n\n\nHow can I make 2 threads which will compute and print the even and odd indexed numbers of the fibonacci sequence, respectively?\n\nThis is for an exercise in Builder 6.\n    ", "Answer": "\r\nYou can use a formula for Fibonacci numbers that uses only the even or odd elements. To develop this formula:\n\n```\nf(n) = f(n-1) + f(n-2) [1]\nf(n-1) = f(n-2) + f(n-3) [2]\nf(n-2) = f(n-3) + f(n-4) [3]\n\nCombining [1] and [2]:\nf(n) = 2 * f(n-2) + f(n-3) [4]\n\nRearranging [3]:\nf(n-3) = f(n-2) - f(n-4) [5]\n\nCombining [4] and [5]:\nf(n) = 3 * f(n-2) - f(n-4) [6]\n```\n\n\nNow each thread can calculate even or odd Fibonacci numbers using [6], without waiting for other thread's results.\n\n```\nint Fibonacci(int nNumber) {\n    switch (nNumber)\n    {\n    case 0: return 0;\n    case 1: return 1;\n    case 2: return 1;\n    case 3: return 2;\n    default: return 3 * Fibonacci(nNumber-2) - Fibonacci(nNumber-4);\n    }\n}\n```\n\n\nHowever, this may ruin the exercise for you, making things much simpler than they are supposed to be.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Find the nth number of fibonacci sequence\r\n                \r\nI have this code, with ```\ninput_number = 10```\n. I have to make a fibonacci sequence with condition: ```\nfibo[-2] < input_number < fibo[-1]```\n\n```\ndef fibonacci(input_number):\n  a = 0\n  b = 1\n  fibo=[a, b]\n  while b < input_number:\n    a, b = b, a+b\n    fibo.append(b)\n    print(fibo)\n```\n\nand the output was like this, just as I expected:\n```\n[0, 1, 1]\n[0, 1, 1, 2]\n[0, 1, 1, 2, 3]\n[0, 1, 1, 2, 3, 5]\n[0, 1, 1, 2, 3, 5, 8]\n[0, 1, 1, 2, 3, 5, 8, 13]\n```\n\nBut the problem now is that I want to call the last fibonacci number which is 13 and the output supposed to be ```\n\"The last fibonacci number is 13 and it is the 8th fibonacci number\"```\n. But I can't call the number of 13 because it is an integer and not a list.\nHow can I convert that into a list?\n    ", "Answer": "\r\nYou probably just need the syntax to access the fibo array. Hope the below helps:\n```\ndef fibonacci(input_number):\n    a = 0\n    b = 1\n    fibo = [a, b]\n    while b < input_number:\n        a, b = b, a + b\n        fibo.append(b)\n        print(fibo)\n\n    print(f'fibonacci number {len(fibo)} is {fibo[len(fibo) - 1]}')\n    print('===')\n    i = 0\n    while i < len(fibo):\n       print(f'fibonacci number {i + 1} is {fibo[i]}')\n       i += 1\n\nfibonacci(10)\n```\n\nResult:\n```\n[0, 1, 1]\n[0, 1, 1, 2]\n[0, 1, 1, 2, 3]\n[0, 1, 1, 2, 3, 5]\n[0, 1, 1, 2, 3, 5, 8]\n[0, 1, 1, 2, 3, 5, 8, 13]\nfibonacci number 8 is 13\n===\nfibonacci number 1 is 0\nfibonacci number 2 is 1\nfibonacci number 3 is 1\nfibonacci number 4 is 2\nfibonacci number 5 is 3\nfibonacci number 6 is 5\nfibonacci number 7 is 8\nfibonacci number 8 is 13\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Optimization of Fibonacci sequence generating algorithm\r\n                \r\nAs we all know, the simplest algorithm to generate Fibonacci sequence is as follows:\n\n```\nif(n<=0) return 0;\nelse if(n==1) return 1;\nf(n) = f(n-1) + f(n-2);\n```\n\n\nBut this algorithm has some repetitive calculation. For example, if you calculate f(5), it will calculate f(4) and f(3). When you calculate f(4), it will again calculate both f(3) and f(2). Could someone give me a more time-efficient recursive algorithm?\n    ", "Answer": "\r\nI have read about some of the methods for calculating Fibonacci with efficient time complexity following are some of them - \n\nMethod 1 - Dynamic Programming\nNow here the substructure is commonly known hence I'll straightly Jump to the solution -\n\n```\nstatic int fib(int n) \n{ \nint f[] = new int[n+2]; // 1 extra to handle case, n = 0 \nint i; \n\nf[0] = 0; \nf[1] = 1; \n\nfor (i = 2; i <= n; i++) \n{ \n    f[i] = f[i-1] + f[i-2]; \n} \n\nreturn f[n]; \n}\n```\n\n\nA space-optimized version of above can be done as follows - \n\n```\nstatic int fib(int n) \n { \n    int a = 0, b = 1, c; \n    if (n == 0) \n        return a; \n    for (int i = 2; i <= n; i++) \n    { \n        c = a + b; \n        a = b; \n        b = c; \n    } \n    return b; \n} \n```\n\n\nMethod 2- ( Using power of the matrix {{1,1},{1,0}} )\n\nThis an O(n) which relies on the fact that if we n times multiply the matrix M = {{1,1},{1,0}} to itself (in other words calculate power(M, n )), then we get the (n+1)th Fibonacci number as the element at row and column (0, 0) in the resultant matrix. This solution would have O(n) time.\n\nThe matrix representation gives the following closed expression for the Fibonacci numbers:\nfibonaccimatrix\n\n```\nstatic int fib(int n) \n{ \nint F[][] = new int[][]{{1,1},{1,0}}; \nif (n == 0) \n    return 0; \npower(F, n-1); \n\nreturn F[0][0]; \n} \n\n/*multiplies 2 matrices F and M of size 2*2, and \nputs the multiplication result back to F[][] */\nstatic void multiply(int F[][], int M[][]) \n{ \nint x = F[0][0]*M[0][0] + F[0][1]*M[1][0]; \nint y = F[0][0]*M[0][1] + F[0][1]*M[1][1]; \nint z = F[1][0]*M[0][0] + F[1][1]*M[1][0]; \nint w = F[1][0]*M[0][1] + F[1][1]*M[1][1]; \n\nF[0][0] = x; \nF[0][1] = y; \nF[1][0] = z; \nF[1][1] = w; \n} \n\n/*function that calculates F[][] raise to the power n and puts the \nresult in F[][]*/\nstatic void power(int F[][], int n) \n{ \nint i; \nint M[][] = new int[][]{{1,1},{1,0}}; \n\n// n - 1 times multiply the matrix to {{1,0},{0,1}} \nfor (i = 2; i <= n; i++) \n    multiply(F, M); \n} \n```\n\n\nThis can be optimized to work in O(Logn) time complexity. We can do recursive multiplication to get power(M, n) in the previous method.\n\n```\nstatic int fib(int n) \n{ \nint F[][] = new int[][]{{1,1},{1,0}}; \nif (n == 0) \n    return 0; \npower(F, n-1); \n\nreturn F[0][0]; \n} \n\nstatic void multiply(int F[][], int M[][]) \n{ \nint x =  F[0][0]*M[0][0] + F[0][1]*M[1][0]; \nint y =  F[0][0]*M[0][1] + F[0][1]*M[1][1]; \nint z =  F[1][0]*M[0][0] + F[1][1]*M[1][0]; \nint w =  F[1][0]*M[0][1] + F[1][1]*M[1][1]; \n\nF[0][0] = x; \nF[0][1] = y; \nF[1][0] = z; \nF[1][1] = w; \n} \n\nstatic void power(int F[][], int n) \n{ \nif( n == 0 || n == 1) \n  return; \nint M[][] = new int[][]{{1,1},{1,0}}; \n\npower(F, n/2); \nmultiply(F, F); \n\nif (n%2 != 0) \n   multiply(F, M); \n} \n```\n\n\nMethod 3 (O(log n) Time)\nBelow is one more interesting recurrence formula that can be used to find nth Fibonacci Number in O(log n) time.\n\nIf n is even then k = n/2:\nF(n) = [2*F(k-1) + F(k)]*F(k)\n\nIf n is odd then k = (n + 1)/2\nF(n) = F(k)*F(k) + F(k-1)*F(k-1)\nHow does this formula work?\nThe formula can be derived from the above matrix equation.\nfibonaccimatrix\n\nTaking determinant on both sides, we get\n(-1)n = Fn+1Fn-1 – Fn2\nMoreover, since AnAm = An+m for any square matrix A, the following identities can be derived (they are obtained from two different coefficients of the matrix product)\n\nFmFn + Fm-1Fn-1 = Fm+n-1\n\nBy putting n = n+1,\n\nFmFn+1 + Fm-1Fn = Fm+n\n\nPutting m = n\n\nF2n-1 = Fn2 + Fn-12\n\nF2n = (Fn-1 + Fn+1)Fn = (2Fn-1 + Fn)Fn (Source: Wiki)\n\nTo get the formula to be proved, we simply need to do the following\nIf n is even, we can put k = n/2\nIf n is odd, we can put k = (n+1)/2\n\n```\npublic static int fib(int n) \n{ \n\n    if (n == 0) \n        return 0; \n\n    if (n == 1 || n == 2) \n        return (f[n] = 1); \n\n    // If fib(n) is already computed \n    if (f[n] != 0) \n        return f[n]; \n\n    int k = (n & 1) == 1? (n + 1) / 2 \n                        : n / 2; \n\n    // Applyting above formula [See value \n    // n&1 is 1 if n is odd, else 0. \n    f[n] = (n & 1) == 1? (fib(k) * fib(k) +  \n                    fib(k - 1) * fib(k - 1)) \n                   : (2 * fib(k - 1) + fib(k))  \n                   * fib(k); \n\n    return f[n]; \n} \n```\n\n\nMethod 4 - Using a formula\nIn this method, we directly implement the formula for the nth term in the Fibonacci series. Time O(1) Space O(1)\nFn = {[(√5 + 1)/2] ^ n} / √5\n\n```\nstatic int fib(int n) { \ndouble phi = (1 + Math.sqrt(5)) / 2; \nreturn (int) Math.round(Math.pow(phi, n)  \n                    / Math.sqrt(5)); \n} \n```\n\n\nReference: http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibFormula.html\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Displaying Fibonacci sequence\r\n                \r\nwrote a program to calculate and display the first 20 fibonacci numbers, the sequence goes as follows:\n\n1, 1, 2, 3, 5, 8, 13... (each number is the sum of the previous two numbers)\n\nThe problem is that the numbers that get displayed are from 2 onwards , the first and second numbers of the sequence do not get displayed , could someone tell me what needs to be done to correct this?\n\nCode:\n\n```\n        private void button1_Click(object sender, EventArgs e)\n    {\n        int previousNumber = 1;\n        int currentNumber = 1;\n        int nextNumber = 1;\n\n        while (currentNumber <= 11000)\n        {\n            nextNumber = previousNumber + currentNumber;\n            previousNumber = currentNumber;\n            currentNumber = nextNumber;\n            textBox1.AppendText(Convert.ToString(nextNumber) + \" \");\n                nextNumber++;\n\n        }\n    }\n```\n\n    ", "Answer": "\r\nI suggest carefully tracing through the logic and predicting what the computer will do at each step. Since the bug affects the very first output, you won't have to look at very many statements to encounter the problem. This is a basic skill for a programmer, so it will be well worth the time, especially since this sounds like homework.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence with Matlab using Loops(Iteration)\r\n                \r\nHow do I write a Fibonacci function in Matlab using loops? Function must have two inputs.\n\ninputs:\n1.a number to start the sequence\n2.the number of terms to return (must be a positive integer (N))\n\nOutput: is a 1xN vector of the Fibonacci sequence.\n\nConditions: If the initial term is 0 or 1, the second term will be 1. For any other number, the initial term will be repeated for the second number.\n\nThanks\n    ", "Answer": "\r\nThe definition of the Fibonacci sequence is the following:\n\n\n\nThe specifications for your function are rather odd, but nonetheless doable.  First you need to check if the initial term is 0 or 1.  If that's the case, the second term will be 1.  If anything else, the first two terms will be exactly the same as the initial term.  You'll require a bunch of ```\nif```\n statements first.... so something like this:\n\n```\nfunction out = fibonacci(initial_term, N)\n\n    if initial_term == 0 || initial_term == 1\n        second_num = 1;\n    else\n        second_num = initial_term;\n    end\n\n    if N == 1\n        out = initial_term;\n    elseif N == 2\n        out = [initial_term second_num];\n    else\n        out = zeros(1,N);\n        out(1:2) = [initial_term second_num];\n        for idx = 3 : N\n            out(idx) = out(idx-1) + out(idx-2);\n        end\n    end\nend\n```\n\n\nThe first ```\nif```\n statement checks to see if the initial term is either 0 or 1.  If it is, the second number will be 1.  If it isn't, the second number will be the same as the initial term.\n\nNext, we check to see what ```\nN```\n is.  If it's 1, then just return the initial term.  If it's 2, then return an array of the initial term and second term.  If it's anything larger, then create an output array of size ```\nN```\n where the first two elements are initialized like in the case of ```\nN = 2```\n, then we simply loop through and use the Fibonacci recurrence formula to populate each element in the output from index 3 and onwards.\n\nYou can also write the ```\nfor```\n loop as a ```\nwhile```\n loop as well.  Remember, a ```\nwhile```\n loop keeps iterating until the ```\nlogical```\n condition that the ```\nwhile```\n loop checks becomes ```\nfalse```\n.  As such, you would do:\n\n```\nout = zeros(1,N);\nout(1:2) = [initial_term second_num];\nidx = 3;\nwhile idx <= N\n    out(idx) = out(idx-1) + out(idx-2);\n    idx = idx + 1;\nend\n```\n\n\nExample Calls\n\n```\n>> out = fibonacci(3, 6)\n\nout =\n\n     3     3     6     9    15    24\n\n>> out = fibonacci(0, 6)\n\nout =\n\n     0     1     1     2     3     5\n\n>> out = fibonacci(4, 10)\n\nout =\n\n     4     4     8    12    20    32    52    84   136   220\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence C++ Displaying One/Largest value [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nLiterally, I have been asked this question \"\"The Fibonacci sequence is 0, 1, 1, 2, 3, 5, 8, 13, … ; the first two terms are 0 and 1, and each term thereafter is the sum of the two preceding terms – i.e., Fib[n] = Fib[n – 1] + Fib[n – 2]. Using this information, write a C++ program that calculates the nth number in a Fibonacci sequence, where the user enters n in the program interactively. For example, if n = 6, the program should display the value 8.\"\n\nThanks for the answers to the previous question, I have put it into my full code. I did have a loop that meant the User could chose whether to continue the program or not. It was working earlier, but now nothing happens. Can anyone shed any light on this? Thanks  \n\n```\n{int N;\n\nchar ans = 'C';\n\nwhile (toupper(ans) == 'C')\n{\n    cout<<\"This program is designed to give the user any value of the Fibonacci Sequence that they desire, provided the number is a positive integer.\";//Tell user what the program does\n\n    cout<<\"\\n\\nThe formula of the Fibonacci Sequence is;   Fib[N] = Fib[N – 1] + Fib[N – 2]\\n\\n\"; //Declare the Formula for the User\n\n    cout<<\"Enter a value for N, then press Enter:\"; //Declare Value that the User wants to see\n\n    cin>>N;//Enter the Number\n\n    if (N>1) {\n            long u = 0, v = 1, t;\n\n            for(int Variable=2; Variable<=N; Variable++)\n            {\n                t = u + v;\n                u = v;\n                v = t;\n            } //Calculate the Answer\n\n        cout<<\"\\n\\nThe \"<<N<<\"th Number of the Fibonacci Sequence is: \"<<t; //Show the Answer\n    }\n\n    if (N<0) {\n        cout<<\"\\n\\nThe value N must be a POSITIVE integer, i.e. N > 0\"; //Confirm that N must be a positive integer. Loop.\n    }\n    if (N>100) {\n        cout<<\"\\n\\nThe value for N must be less than 100, i.e. N < 100. N must be between 0 - 100.\";//Confirm that N must be less than 100. Loop.\n    }\n    if (N==0) {\n        cout<<\"\\n\\nFor your value of N, \\nFib[0] = 0\"; //Value will remain constant throughout, cannot be caculated through formula. Loop.\n    }\n    if (N==1) {\n        cout<<\"\\n\\nFor your value of N. \\nFib[1]=1\";//Value will remain constant throughout, cannot be caculated through formula. Loop.\n    }\n\n  cout << \"\\n\\nIf you want to select a new value for N, then click C then press Enter. If you want to quit, click P then press Enter: \";\n    cin >> ans;\n}\n\n\nreturn 0;\n```\n\n\n}\n    ", "Answer": "\r\nAll You need is to put ```\ncout```\n 2 lines below. And you don't need extra {}, but it does not harm.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Print Fibonacci Sequence to (n)\r\n                \r\nI was asked to print a list to the console of the Fibonacci sequence up to a given number.\nIt took me a while to come up with a solution, and I'm happy to have written something that works.\nI struggled with trying to incorporate while loop, and ended up using a for loop with an if statement.\nI have two questions:\n\nIs it sensible to try this with a while loop?\nHow could one create this sequence without a preset array with the first two numbers in the sequence?\n\nThank you!\nBy the way, this is my first post to StackOverflow, so any feedback on posting etiquette would be appreciated as well.\n```\n\nfunction fibbonaciToNum(num) {\n    let current = 0;\n    let arr = [0, 1];\n    for (let i = 1; i < arr.length; i++) {\n        current = arr[i] + arr[i - 1]\n        if (current <= num) {\n\n            arr.push(current);\n        }\n    }\n    return arr;\n}\n\nconsole.log(fibbonaciToNum(34));\n```\n\n    ", "Answer": "\r\n\nYes, it is possible to use while loop, and I that in this case it would be recomended.\n\n```\nconst fib = (upTo) => {\n    let n1=0, n2=1, n3;\n    n3 = n1 + n2; \n    while (n3 <= upTo) {\n        console.log(n3); \n        n1 = n2;  \n        n2 = nextTerm; \n        n3 = n1 + n2; \n    }\n}\n```\n\n\nFibonacci series is also defined by an very long and hard equation which does not depend on previous elements of sequence. So theoretically, yes, it is possible, but I would highly advise against it.\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Question about Fibonacci sequence generator - nothing prints\r\n                \r\nI was given an assigmnent in my class where I need to write an algorithm that can generate \"n\" numbers of the Fibonacci sequence.\nI feel like this code should work, but am still having troubles locating what bug is preventing it from working.\nThe algorithm should start printing the Fibonacci sequence starting at the number ```\n2```\n (the first 3 numbers are patched in), but it only prints the first 3 numbers and my algorithm doesn't print anything.\nI even have sophisticated error checking that should rule out bad values, but it isn't reporting anything either.\n\n```\n#/usr/bin/python\n\nimport re\nimport math\nimport time\nimport sys\n\ndef errchk(hwmny,int1,int2,int3,int4,errcnt):\n    #Sanity check; first 12 numbers don't have 6's\n    expression = re.compile(r\"^[^6]{1,3}\", re.I | re.S) #expression for no sixes\n    if expression.match(str(int3)):     # if it doesn't match\n        return                      # return\n    else:                           #otherwise\n        if (hwmny > 12):        # as long as it's less than 12\n            return          # no errors\n        zints.err()         #but ifnot, errors\n    return None\n\ndef nofloats():\n    return math.floor(zints.int3)\n\nclass zeroints:\n    int3=int4 = 0   #int3 and int4 are 0\n    errcnt = 0  #count the number of errors\n    def err(self):\n        print \"Errors\"\n        return\n\nhwmny =15       #hwmny variable is 10\nint1 =int2 =1       #int1 and int2 are 1\nzints = zeroints()  #ints init'd to 0\nprint \"0\\n1\\n1\"\n\ndef loop(hwmny,int1,int2,int3,int4,errcnt):\n    while(((zints.int4<hwmny)or not(zints.int4>0))and not(zints.int4==0)):  #while int4 is less than hwmny and error checking\n        zints.int3 =int1+ int2          #int3 is int1 plus int2\n        int1 =int2              #int1 is int2\n        string = 'The Values Are'       #string is set to 'The Values Are'\n        int2= zints.int3            #int2 is int3\n        errchk(hwmny,int1,int2,zints.int3,zints.int4,zints.errcnt)\n        print zints.int3            #print int3\n        zints.int4= zints.int4+1        #int4 is int4 plus 1\n        loop(hwmny,int1,int2,zints.int3,zints.int4,zints.errcnt)\n        continue\n\nloop(hwmny,int1,int2,zints.int3,zints.int4,zints.errcnt)\n```\n\n    ", "Answer": "\r\nThis fix looks simple.\nThe grouping in the while loop is wrong, change it to the following and it should work fine:\n\n```\nwhile((zints.int4<hwmny)or not(zints.int4>0)and not(zints.int4==0)):\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence, public static void xxx\r\n                \r\nI'm just a very beginner and need for help with Fibonacci sequence. So the problem is that I need to ask a number from the answerer and secondly print the Fibonacci number that fits with the answerer's number?  Is the method that I need to use \"public static void xxx\" loop?\nI hope someone understands my bad English and can help me with my problem. \n    ", "Answer": "\r\nI hope you need it in java:\n\n```\n    import java.io.*;\n    public class Fibonacci{\n        // your method public static void xxx\n        public static void fib() throws IOException \n        {\n            // take input from user\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n\n            // compute nth fibonacci: your loop\n            int f1 = 0, f2 = 1;\n            if(n == 0)\n             System.out.println(f1);\n            for(int i=2; i<n; i++)\n            {\n               int fi = f1 + f2;\n               f1 = f2;\n               f2 = fi;\n            }\n           // print your answer\n           System.out.println(f2);\n        }\n        public static void main(Strings args[])\n        {\n            // call fib method\n            fib();\n        } \n    }\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Generator in C++\r\n                \r\nI am trying to make a Fibonacci Sequence Generator in C++ and was having some trouble. I am new to C++ and was trying to make this work as I have done it in other languages that I know.  So I wrote a program:\n\n```\n#include <iostream>\n\nusing namespace std;\n\nint NextNumber(int x, int y, int z)\n{\n    z=x+y;\n    return z;\n}\n\nint main()\n{\n    int q;\n    int w;\n    int x=0;\n    int y=1;\n    int z=1;\n    int t=1;\n    cout << x;\n    cout << \", \"<< y ;\n    cout << \", \"<< z ;\n    while (t<10)\n        x=NextNumber(y,z,x);\n        cout << \", \"<< x ;\n        q=y; //Q is farthest back\n        w=z; //W is in the middle\n        z=x; //Z moves from middle to front\n        y=w; //Y moves from back to middle\n        x=q; //X moves from front to back\n        t=t+1; //Add a rotation to the while loop\n}\n```\n\n\nI am using Xcode to compile and it appears that no output is displayed when I run the program.  If anyone has any thoughts on why this may be happening or if my program has any logical flaws please help.  Thank you.\n    ", "Answer": "\r\nC++ is not Python, and white spaces are ignored by the compiler. You must use braces for the ```\nwhile```\n loop,\n\n```\nwhile (t<10)\n{\n  // details\n} // end loop \n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "C Program to search for numbers NOT in the Fibonacci Sequence\r\n                \r\nI want help in writing a simple program in C Programming Language that helps the user search for integers NOT in the Fibonacci sequence for a given range of integers.\nI have the program that displays the Fibonacci numbers in a given sequence for reference.\n\n```\nint main()\n{\nint i;\n/* Declare and initialise an int array with the first 2 fibonacci numbers 1 and 1 */\n/* The size of the array should be NUM_FIBON. */\nint *fibonacci;\nint sizeOfArray;\n/* Display the purpose of the program */\nprintf(\"\\nThis program displays the fibonacci numbers\\n\\n\");\nprintf(\"Enter the number of Fibonacci numbers to compute: \");\nscanf(\"%i\", &sizeOfArray);\nfibonacci = malloc(sizeof(int) * sizeOfArray);\nfibonacci[0]=1;\nfibonacci[1]=1;\n\n/* Populate the array with other fibonacci numbers, starting with the 3rd number */\n/* Each fibonacci number is the sum of the previous two */\nfor(i=2; i<sizeOfArray; i++)\n{\n fibonacci[i] = fibonacci[i-1]+fibonacci[i-2];\n}\n\n/* Print message: \n * Calculation over.\n * Press [Enter] to display the first x fibonacci numbers\n *\n * then wait for the [Enter] key to be pressed.  \n */\nprintf(\"Calculation over \\nPress ENTER to display the first %i fibonacci numbers\\n\\n\", sizeOfArray);\ngetch();\n\n/* Print the 12 first fibonacci numbers */\nfor(i=0; i<sizeOfArray; i++)\n{\n if (i % 10 == 0)\n {\n  printf(\"\\n\");\n  printf(\"%-8i\", fibonacci[i]);\n }\n else\n {\n  printf(\"%-8i\", fibonacci[i]);\n }\n}\nfree(fibonacci);\n\n/* Pause so the result can be seen when the program starts from windows explorer */ \ngetch();\n\n/* Return success code to the operating system */\nreturn 0;\n```\n\n\n}\n    ", "Answer": "\r\nYeah, that code is kind of a red herring. You need a function called is_fibbonacci, 1 parameter an int, returns either TRUE or FALSE. You only need 3 variables in a while loop to calculate next fibbonacci until next is greater or equals to parameter.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "finding the nth term fibonacci sequence using loop in javascript\r\n                \r\nI'm just new here in Javascript and I would like to ask you question on how to make a simple fibonacci generator by which when a user input any number, it will find the nth term of the fibonacci sequence. Sample code is given.\n\n```\n<html>\n<body>\nthe number inserted in this textbox will find the nth term of the fibonacci sequence. The sample is 4 where the 4th term is 5. \n<script type=\"text/javascript\">\nfunction myFunction() {\nvar x = document.f1.n1.value;\nif(x=4) {\n\ndocument.write(5);\n}\n}\n</script>\n<form name=\"f1\" onsubmit=\"return false\">\nFirst no. <input type=\"text\"name=\"n1\" value=3 disabled>\n<input type=\"submit\" value=GO onClick=\"myFunction()\">\n</form>\n</body>\n</html>\n```\n\n    ", "Answer": "\r\nHere's a working example with recursive call: \n\n\r\n\r\n```\nfunction myFunction(getLucas) {\r\n  var x = document.f1.n1.value;\r\n  if (getLucas) {\r\n      alert(lucas(x));\r\n  }\r\n  else {\r\n      alert(fib(x));\r\n  }\r\n}\r\n\r\nfunction fib(n) {\r\n  if (n < 2) {\r\n      return n;\r\n  }\r\n  else {\r\n      return fib(n - 1) + fib(n - 2);\r\n  }\r\n}\r\n\r\nfunction lucas(n) {\r\n  if (n < 2) {\r\n      return 2-n;\r\n  }\r\n  else {\r\n      return lucas(n - 1) + lucas(n - 2);\r\n  }\r\n}```\n\r\n```\n<form name=\"f1\" onsubmit=\"return false\">\r\n  First no.\r\n  <input type=\"text\" name=\"n1\" value=\"3\">\r\n  <input type=\"submit\" value=\"Fibonacci\" onClick=\"myFunction()\">\r\n  <input type=\"submit\" value=\"Lucas\" onClick=\"myFunction(true)\">\r\n</form>```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Generator in C++\r\n                \r\nI am trying to make a Fibonacci Sequence Generator in C++ and was having some trouble. I am new to C++ and was trying to make this work as I have done it in other languages that I know.  So I wrote a program:\n\n```\n#include <iostream>\n\nusing namespace std;\n\nint NextNumber(int x, int y, int z)\n{\n    z=x+y;\n    return z;\n}\n\nint main()\n{\n    int q;\n    int w;\n    int x=0;\n    int y=1;\n    int z=1;\n    int t=1;\n    cout << x;\n    cout << \", \"<< y ;\n    cout << \", \"<< z ;\n    while (t<10)\n        x=NextNumber(y,z,x);\n        cout << \", \"<< x ;\n        q=y; //Q is farthest back\n        w=z; //W is in the middle\n        z=x; //Z moves from middle to front\n        y=w; //Y moves from back to middle\n        x=q; //X moves from front to back\n        t=t+1; //Add a rotation to the while loop\n}\n```\n\n\nI am using Xcode to compile and it appears that no output is displayed when I run the program.  If anyone has any thoughts on why this may be happening or if my program has any logical flaws please help.  Thank you.\n    ", "Answer": "\r\nC++ is not Python, and white spaces are ignored by the compiler. You must use braces for the ```\nwhile```\n loop,\n\n```\nwhile (t<10)\n{\n  // details\n} // end loop \n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Wrongly implemented Fibonacci Sequence in Scala\r\n                \r\nWas at a Scala meetup and we were discussing the \"Scala way\" of doing things...\n\nSomeone asked a different developer how he / she would implement the Fibonacci sequence in Scala... The person answered with the following code (only to be told that while it worked, it was non-optimal):\n\n```\ndef fibonacci(n: Int):BigInt = n match {\n    case 0 => 0\n    case 1 => 1\n    case _ => fibonacci(n - 1) + fibonacci(n - 2)\n}\n```\n\n\n\nWhat's wrong with this method? \nWhat are the ways to improve this code, the Scala way?\n\n    ", "Answer": "\r\nThe problem with that function, as described are the non-tail recursive calls. This means that the recursivity involved here needs a stack to work (in your sample, it's the call stack). In other words, that function is roughly the equivalent of:\n\n```\nimport scala.collection.mutable.Stack\n\ndef fibonacci(n: Int): BigInt = {\n  var result = BigInt(0)\n  val stack = Stack.empty[Int]\n  stack.push(n)\n\n  while (stack.nonEmpty) {\n    val x = stack.pop()\n    if (x == 1) {\n      result += 1\n    }\n    else if (x > 1) {\n      stack.push(x - 2)\n      stack.push(x - 1)\n    }\n  }\n\n  result\n}\n```\n\n\nAs you can see, that's not very efficient, is it? On each iteration, the stack's size grows by one and because you can view the calls being made as a tree, that would be a proper binary tree whose size depends on ```\nN```\n and the number of leaves on it approximately 2N (actually less but constant factors don't matter when N is big), so we are talking about O(2N) time complexity and O(n) memory complexity (i.e. needed stack size is ```\nN```\n). Now that's exponential growth for time and linear growth for the memory used. What that means is that it takes a loooong time to process and it uses more memory than it should. Btw, it's a good idea as a software developer to reason in terms of Big O notation, because that's the first thing you need to look at when talking about performance or memory consumption.\n\nThankfully, for Fibonnaci we don't need that recursion. Here's a more efficient implementation:\n\n```\ndef fibonacci(n: Int): BigInt = {\n  var a = BigInt(0)\n  var b = BigInt(1)\n  var idx = 0\n\n  while (idx < n) {\n    val tmp = a\n    a = b\n    b = tmp + a\n    idx += 1\n  }\n\n  a\n}\n```\n\n\nThis is just a plain loop. It doesn't need a stack to work. The memory complexity is ```\nO(1)```\n (meaning it needs a constant amount of memory to work, independent of input). In terms of time  this algorithm is ```\nO(n)```\n, roughly meaning that to process the result a loop involving ```\nN```\n iterations is involved, so the growth in time does depend on input ```\nN```\n, but is linear and not exponential. \n\nIn Scala, you can also describe this as a tail recursion:\n\n```\nimport annotation.tailrec \n\ndef fibonacci(n: Int): BigInt = {\n  @tailrec\n  def loop(a: BigInt, b: BigInt, idx: Int = 0): BigInt = \n    if (idx < n) \n      loop(b, a + b, idx + 1)\n    else\n      a\n\n  loop(0, 1)\n}\n```\n\n\nThis loop is described as a recursive function, however because that's a \"tail-recursive call\", the compiler rewrites this function to a simple loop. You can also see the presence of the ```\n@tailrec```\n annotation. It's not strictly necessary, the compiler will optimize that into a loop without it, but if you use this annotation, the compiler will error if the described function is not a tail-recursion - which is nice, because it's easy to make mistakes when relying on tail-recursion to work (i.e. you make a change and without noticing, bam, the function is not a tail-recursion anymore). Use this annotation, because the compiler can protect you if you do.\n\nSo in this case you work with immutable things (no more vars specified), yet it will have the same performance characteristics as the while loop. Which version you prefer, that's up to your preferences. I prefer the later, because it's easier for me to spot invariants and exit conditions, plus I like immutability, but other people prefer the former. And about the idiomatic way of doing this, you can also get fancy with a lazy ```\nStream```\n or ```\nIterable```\n, but nobody in the FP department will complain about tail recursions :-)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence function with lru_cache doesn't show all fibonacci numbers\r\n                \r\nI have this function that can print large lists of numbers from fibonacci sequence. but it is pretty slow due to recursion. so I found out about the lru_cache. but it doesn't start the sequence from 1. In this example, from 1 to 501, it starts printing numbers from 352 to 500. Can you tell me why?\n```\nfrom functools import lru_cache\n\n@lru_cache(maxsize=1000)\ndef fibonacci(n):\n    if n == 1 :\n        return 1\n    elif n == 2:\n        return 2\n    elif n > 2:\n        return fibonacci(n-1) + fibonacci(n-2)\n\nfor i in range(1,501):\n    print(i, '::', fibonacci(i))\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence with other qualifications such as a limit and no shift functions\r\n                \r\nDoes anyone have any tips on how I can start the assembly for this program?\n\nWrite a program to find and print a Fibonacci sequence of numbers. The Fibonacci sequence is \ndefined as follows: \n\nYour program should prompt the user to enter a limit, print the sequence up to the limit, and then \nindicate what is the greatest power of 2 that the final number printed is divisible by. Note: You \nare NOT allowed to use the divide function or any shift functions. If the number is odd, then the \ngreatest power of 2 would be 20\n = 1. Assume user input will be between 1 and 4096. \n    ", "Answer": "\r\nAssuming that you have no problem in finding the fibonacci number in the given limit. Let it be n\n\nI guess % should not be  used as it is closely related to /.\n\nNow you can tr this (based on boolean properties)\n\n\nTake a number t=1 and another ctr=0;\nIn a loop take n&t. if (n&t==0) {ctr++;t*=2;}else break the loop;\nThe final ctr value should be your answer\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence using Array in Java\r\n                \r\nI want to get the fibonacci sequence entered by the user in array. The task given to me was \"Ask the user for 2 integer input which will be taken for first and second array elements of size 10 array.\"\nHere is my code.\n```\nint limit = 10;\n    int[] fib = new int[limit];\n    fib[0] = 0;\n    fib[1] = 1;\n  for (int j = 1; j < 2; j++) \n  {\n    System.out.print(\"Enter number \" + \"[\" + j + \"]: \");\n    num[j] = reader.nextInt();\n    num[j] = fib[j+1] + fib[j+2];\n    System.out.println(\"\");\n  }\n    System.out.print(\"Result: \");\n    for(int j = 0; j < limit; j++ ) \n    {\n      System.out.print(fib[j] + \" \");\n      System.out.print(\"\");\n    }\n```\n\nI badly need help for this one, been searching for solution for hours and still don't get it.\n    ", "Answer": "\r\nI'll just make some corrections to your code and explain them:\n```\nint limit = 10;\nint[] fib = new int[limit];\n// fib[0] = 0;\n// fib[1] = 1;\n// The two lines above are wrong. Even though the real fibonacci sequence starts\n// with 0 and 1, the question asks for the first two terms to come from user\n// inputs. Instead, you can initialize them below:\n\n// In your old code, you had \"j = 1; j < 2; j++\". However, that only loops once.\n// So, have your condition to be j <= 2 instead: (I'm assuming that you want 1\n// and 2 and not zero-based because it should print out \"Enter number [1]:\" and\n// \"Enter number [2]:\"\nfor (int j = 0; j < 2; j++) // Not \"j < 2\"\n{\n  System.out.print(\"Enter number \" + \"[\" + j + \"]: \");\n  fib[j] = reader.nextInt(); // not num[j] = ..., it's fib[j] = ...\n  // num[j] = fib[j+1] + fib[j+2];\n  // You don't need this ^^^\n  System.out.println(\"\");\n}\n\n// Now you need to fill in the array:\nfor (int j = 2; j < limit; j++)\n{\n  fib[j] = fib[j - 1] + fib[j - 2];\n}\n\nSystem.out.print(\"Result: \");\nfor(int j = 0; j < limit; j++) \n{\n  System.out.print(fib[j] + \" \");\n  System.out.print(\"\");\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to compute Fibonacci sequence\r\n                \r\nI have written code below which does the Fibonacci Sequence the problem I am having is that when I run it against my JUnit Test code only one problem is resolved. I will show you below. \n\nThis is my code.\n\n```\nimport java.util.ArrayList;\n\npublic class ResitCode {\n\npublic int Fib_No(int position) {\n    position = 10;\n    ArrayList<Integer> a = new ArrayList<Integer>();\n    a.add(0);\n    a.add(1);\n      System.out.println(position); \n    for (int i = 1; i <= position; ++i) {\n\n        System.out.println(a.get(0) + \" \");\n        int sumofBoth = a.get(0) + a.get(1);\n        int a1 = a.get(0);\n        int a2 = a.get(1);\n        a1 = a2;\n        a2 = sumofBoth;\n\n\n    }\n\n    return 0 ;\n\n}\n```\n\n\nNow this is my Unit Test code \n\n```\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nclass ResitCodeTest {\n\n\npublic static ResitCode test;\n\n@BeforeAll\nstatic void setUpBeforeClass() throws Exception {\n    test = new ResitCode();\n}\n\n@ParameterizedTest\n@DisplayName(\"Testing Fib_No\")\n@CsvSource({\n                \"1,0\",\n                \"2,1\",\n                \"3,1\",\n                \"4,2\",\n                \"8,13\",\n                \"14,233\"                   \n})\nvoid testFib_No(int pos, int fibno) {\n    assertEquals(fibno,test.Fib_No(pos));\n}\n```\n\n\nWhen I run it against this only one issue is resolved, if anybody can tell me what i am doing wrong and how I can make it pass all the test it will be greatly appreciated. \nJUNIT FAILURE\n    ", "Answer": "\r\nThere are two errors in the ```\nFib_No```\n function:\n\n1) You don't return the result. Replace ```\nreturn 0```\n with ```\nreturn a.get(1)```\n.\n\n2) In the for loop, you are working on temporary variables, not references. Thus, the assignments done inside the loop have no effect. To replace the previous values, use:\n\n```\n    int sumofBoth = a.get(0) + a.get(1);\n    a.set(0,a.get(1));\n    a.set(1,sumofBoth);\n```\n\n\nNote: since you are working with only two integers, using a list structure make the code slower and harder to read. Consider using two variables ```\nint a=0; int b=1;```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in haskell returning all the values [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Fibonacci Numbers in Haskell\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI need help for my assignment using haskell which return a list up to the nth number in the Fibonacci sequence.\n\nlike\n\n```\nMain> fib 5\n[0,1,1,2,3,5]\nMain> fib 15\n[0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]\n```\n\n\nI understand this\n\n```\nfib::Int->Int\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n-1) + fib (n-2)\n```\n\n\nbut I don't know how to produce list that containing all the value up to the nth number.\n\nThank you\n    ", "Answer": "\r\nThere are a few cool ways to do it, first the simplest\n\n```\nfib::Int->Int\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n-1) + fib (n-2)\nfibList n = map fib [1..n]\n```\n\n\nor we can merge this into one\n\n```\nfib::Int->[Int]\nfib 0 = [0]\nfib 1 = [1, 0]\nfib n = (head (fib (n-1)) + head (fib (n-2))) : fib (n-1)\n```\n\n\nSo here we're just combining the list building with the recursion. Now we take a step towards the crazy\n\n```\nfib n = take n fiblist\n  where fiblist = 0:1:(zipWith (+) fiblist (tail fiblist))\n```\n\n\nHere ```\nfiblist```\n is an infinite list of Fibonacci numbers. All we're doing is grabbing the appropriate amount. This is possible because Haskell is \"lazy\". If you're new to Haskell, just smile and nod.\n\nLastly, for kicks and giggles\n\n```\nfib = flip take . fix $ \\f -> 0 : 1 : (zipWith (+) f (tail f))\n```\n\n\nThis is the same of above except point-free and with a fixed point instead of recursion.\n\nAgain if you're new to haskell, the first 2 are a little easier to grok, come back to the last 2 in a few weeks :)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "how can i store fibonacci sequence in a matrix\r\n                \r\nwell, i need to store the fibonacci sequence in a 2x5 matrix but what im doing its not working. here's my attempt\n```\nint main()\n{\n    int i,j,k;\n    int mat[2][5];\n    mat[0][0]=0;\n    mat[0][1]=1;\n    k=2;\n    for (i=0; i<2; i++)\n    {\n        for(j=0; j<5; j++)\n        {\n            \n            mat[i][k]=mat[i][j]+mat[i][j+1];\n           \n            k++;\n        }\n    }\n    for(i=0; i<2; i++)\n    {\n        for(j=0; j<5; j++)\n        {\n            printf(\"%d\\t\",mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nHow about using the row and column of the matrix to calculate the \"position\" of that element at the fibonacci sequence?\n```\n#include <stdio.h>\n#define ROWS 2\n#define COLS 5\n\nint fibonacci(int position)\n{\n    if (position == 0)\n        return 0;\n\n    if (position == 1)\n        return 1;\n\n    return fibonacci(position - 1) + fibonacci(position - 2);\n}\n\nint main()\n{\n    int mat[ROWS][COLS];\n\n    for(int row = 0; row < ROWS; row++)\n    {\n        for(int col = 0; col < COLS; col++)\n        {\n            /*\n            [0,0] = 0 [0,1] = 1, [0,2] = 2, [0,3] = 3, [0,4] = 4\n            [1,0] = 5 [1,1] = 6, [1,2] = 7, [1,3] = 8, [1,4] = 9\n            */\n            mat[row][col] = fibonacci(COLS * row  + col);\n\n            printf(\"%3d, \", mat[row][col]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Prolog tail recursion for Fibonacci sequence\r\n                \r\nI have been trying to make a Prolog tail recursion for Fibonacci sequence, but I have a lot of trouble making the code, this is kinda what I was doing and I'm not sure if I'm going the right path\n```\nfibonacci(X,S):-\n    fibonacci(X,1,S).\n\nfibonacci(1,R,R).\nfibonacci(2,R,R).\nfibonacci(X,R,S):-\n    X>2,\n    X1 is X-1, \n    X2 is X-2,\n    R1 is R,\n    fibonacci(X1,R1,S1), \n    R2 is R1+R,\n    fibonacci(X2,R2,S2).\n```\n\nI tried changing the code a bit and was even able to make the program in normal recursion, but not in tail recursion\n    ", "Answer": "\r\nSomething like this?\nThe first two elements in a Fibonacci sequence are special. After that,\neverything follows a regular pattern. Use a helper predicate that carries the extra state you'll want:\n\nthe previous two values, and\nthe current position within the sequence\n\n```\n% ----------------------------------------------------------------------\n%\n% fibonacci(Index,Value)\n%\n% where\n% \n% - Index is the ordinal position with the sequence, relative to 0, and\n% \n% - Value is the value of the sequence at that index.\n%\n% For instance,\n%\n% fib(  0,  1 ).\n% fib(  1,  1 ).\n% fib(  2,  2 ).\n% fib(  3,  3 ).\n% fib(  4,  5 ),\n% fib(  5,  8 ).\n% fib(  6, 13 ).\n% fib(  7, 21 ).\n% fib(  8, 34 ).\n% fib(  9, 55 ).\n% \n% ----------------------------------------------------------------------\nfib(0,1) .                              % the initial element in the sequence is special,\nfib(1,1) .                              % as is the next element, but\nfib(N,V) :- valid(N), fib0(1,1,2,N,V) . % all subsequent element follow the same pattern.\n\nvalid(N) :- integer(N) -> N > 1 ; var(N) .\n\n% ------------------------------------------------------------------------------\n% \n% fib0( Prev1, Prev2 , Ctr, Index, Value ) .\n% \n% \"private\" helper predicate to tail-recursively compute the fibonacci sequence,\n% \n% ------------------------------------------------------------------------------\nfib0( P1 , P2 , N , N , S ) :-              S is P1+P2 .\nfib0( P1 , P2 , C , N , S ) :- C1 is C+1 , P3 is P1+P2 , fib0(P2,P3,C1,N,S) .\n\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to calculate the 25th term of recursive Fibonacci Sequence in MASM(16-bit)\r\n                \r\nI am programming a recursive Fibonacci Sequence through assembly language (x86) in MASM(16-bit). Here is the code:\n\n```\nDATAS SEGMENT\n   TH DW 1; \n   TIP DB 0DH,0AH, 'Please Input The Num Of Fibonacci Sequence Required:$'\n   NUM DW 0;\n   BUF DB 0;\n   TIP1 DB 0DH,0AH,'The $'\n   TIP2 DB 'th Of Fibonacci Sequence is:    $'\n   FORMAT DB '              $'\n   FORMAT2 DB '                   $'\n   ENDSTRING DB 'Do You Want To Continue The Process? Y/N $'\nDATAS ENDS\n\nSTACKS SEGMENT\n   STACK DW 4096 DUP(?);\nSTACKS ENDS\n\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:STACKS\n\nSTART:\n\nMAIN PROC FAR   \n  MOV AX,DATAS\n  MOV DS,AX\n\nBEG:\n  MOV AX,3\n  INT 0AH\n\n  MOV AH,09H\n  LEA DX,TIP\n  INT 21H\n\n  MOV AH,01H;\n  INT 21H\n\n  ;convert input to number\n  SUB AL,30H\n  PUSH CX\n  MOV CL,10\n  MUL CL\n  MOV BUF,AL\n  POP CX\n\n  MOV AH,01H\n  INT 21H\n  SUB AL,30H\n  ADD AL,BUF\n  MOV AH,0\n  MOV NUM,AX\n\n  XOR AX,AX  \n  PUSH DS  \n  PUSH AX  \n  MOV SP,STACK\n  MOV AX,1 \nFIB:\n  PUSH AX;\n  CALL Fibonacci ;\n\n  ;disply\n  push ax\n  push bx\n  push dx\n  mov ah,09h\n  lea dx,format2 \n  int 21h\n  mov ah,09h\n  lea dx,tip1\n  int 21h\n\n  mov bx,th\n  call smallbinidec\n\n  mov ah,09h\n  lea dx,tip2\n  int 21h \n  pop dx\n  pop bx\n  pop ax\n\n  mov bx,ax   ;disp\n  call binidec\n  call crlf  \n  inc th\n  mov ax,th\n  cmp ax,num\n  jbe fib\n\n  call crlf\n  jmp exit\n\nmain endp  \n\nFibonacci proc near  \n  PUSH BP  \n  MOV BP,SP  \n  ADD SP,-4   \n  ;ax----the value of fibonacci，cx----the number of fibonacci \n  MOV CX,[BP+4]  \n  CMP CX,2  \n  JA CALCULATE  ;if CX > 2 :recursive else :1\n  MOV AX,1  \n  ADD SP,4 \n  POP BP  \n  RET 2  \n\ncalculate:;sp = bp - 4 \n  mov word ptr[bp-4],cx  \n  dec cx  \n  push cx  \n  call Fibonacci   \n  mov word ptr[bp-2],ax  ;save f（x-1）\n  dec cx  \n  push cx  ;\n  call Fibonacci  \n  add AX,word ptr[bp-2]   ;f（x）= f（x-1）+ f（x-2）\n                          ;ax = f（x-2），word ptr[bp-2] = f（x-1）\n  mov cx,word ptr[bp-4]  \n  add sp,4 \n  pop bp  \n  ret 2  \nFibonacci endp  \n\nbinidec  proc  near \n         mov   cx, 10000d\n         call  dec_div\n         mov   cx, 1000d\n         call  dec_div\n         mov   cx, 100d\n         call  dec_div\n         mov   cx, 10d\n         call  dec_div\n         mov   cx, 1d\n         call  dec_div\n         ret\n\nbinidec  endp\n\nsmallbinidec  proc  near \n         mov   cx, 10d\n         call  dec_div\n         mov   cx, 1d\n         call  dec_div\n         ret\n\nsmallbinidec  endp\n\ndec_div  proc  near\n         mov   ax, bx\n         mov   dx, 0\n         div   cx\n         mov   bx, dx\n         mov   dl, al\n         add   dl, 30h\n         mov   ah, 2\n         int   21h\n         ret\ndec_div  endp\n\nCRLF PROC NEAR\n         MOV AH,02H\n         MOV DL,0DH\n         INT 21H\n         MOV AH,02H\n         MOV DL,0AH\n         INT 21H\n         RET\nCRLF ENDP\n\nexit:\n    MOV AH,4CH\n    INT 21H\n\nCODES ENDS\n    END START\n```\n\n\nIt does work well when calculating terms with n < 25. However, it went wrong when calculating the 25th term of Fibonacci Sequence.\n\nAfter analyzing, I think the problem is that registers like ```\nAX```\n is just 16-bit, which makes it cannot store a number larger than 65535 (less than the 25th term of Fibonacci Sequence).\n\nA simple method is using ```\nEAX```\n in MASM(32bit) instead of ```\nAX```\n. Unfortunately, this is not allowed. \n\nTherefore, how to enable this code to process terms with n >=25?\n\nThanks after all :)\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence in C generating negatives?\r\n                \r\nI'm new to programming and need help in C. I am writing a program to generate a Fibonacci sequence for values with up to 1000 digits. \n\nHere is my code:\n\n```\n#include <stdio.h>\n\nint main(void)\n{\n    int seq[1000];\n    int i,n;\n\n    printf(\"How many Fibonacci numbers do you want?: \");\n    scanf(\"%d\",&n);\n\n    seq[0] = 0;\n    seq[1] = 1;\n\n    for(i = 2; i < n; i++)\n        seq[i] = seq[i-1] + seq[i-2];\n\n    for (i = 1; i < n; i++)\n        printf(\"%d: %d\\n\", i, seq[i]);\n\n    return 0;\n}\n```\n\n\nNow the problem is, the numbers are all correct up until the 47th number. Then it just goes crazy and there's negative numbers and its all wrong. Can anyone see the error in my code? Any help is greatly appreciated.\n    ", "Answer": "\r\n\n  I am writing a program to generate a Fibonacci sequence for values with up to 1000 digits.\n\n\nNot yet you aren't.  You are storing the values in variables of type ```\nint```\n. Commonly such variables are 32 bit values and have a maximum possible value of ```\n2^31 - 1```\n. That equals ```\n2,147,483,647```\n which is some way short of your goal of reaching 1,000 digits. \n\nThe 47th Fibonacci number is the first number to exceed ```\n2,147,483,647```\n. According to Wolfram Alpha, the value is ```\n2,971,215,073```\n.\n\nWhen your program attempts to calculate such a number it suffers from integer overflow, because the true value cannot be stored in an ```\nint```\n. You could try to analyse exactly what happens when you overflow, why you see negative values, but it really doesn't get you very far. Simply put, what you are attempting is clearly impossible with ```\nint```\n.\n\nIn order to reach 1,000 digits you need to use a big integer type. None of the built-in types can handle numbers as large as you intend to handle.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Haskell checking if number is from Fibonacci sequence\r\n                \r\nI'm Haskell beginner. Last time I have learnt about Fibonacci sequences, so I can create Fib sequence. Now I'm wondering how to write a function which checks if number belongs to Fib sequence.\n\nI mean function:\n\n```\nbelongToFib :: Int -> Bool\n```\n\n\nI don't really need code. Some hints how to handle with this would be enough. Thanks in advance.\n    ", "Answer": "\r\nI will give you some hints for a solution involving lazy evaluation:\n\n\nDefine the list of all fibonacci numbers.\nCheck whether your input number belongs to the sequence.\n\n\nThese are the signatures for the two things you'll need to define:\n\n```\nfib :: [Int]\nbelongToFib :: Int -> Bool\n```\n\n\nOf course you will need some tricks to make this work. Even though your list has a (theoretically) infinite sequence of numbers, if you make sure that you only need to work on a finite subsequence, thanks to its laziness, Haskell will generate only the strictly needed part, and your function will not loop forever. So, when checking for the membership of your number to ```\nfib```\n, make sure you return ```\nFalse```\n at some point.\n\nAnother possible solution is to try to find out whether your number is in the fibonacci sequence without actually generating it up to the input, but rather by relying on arithmetic only. As a hint for this, have a look at this thread.\n\nOn Wikipedia you'll find a number of other ways to check membership to the fibonacci sequence.\n\nedit: by the way, beware of overflows with ```\nInt```\n. You may wish to switch to ```\nInteger```\n instead.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence value in haskell\r\n                \r\nhow to get sum of fibonacci sequence using that code:\n\n```\nfibs= 0 : 1 : zipWith (+) fibs (tail fibs)\n```\n\n\nedit: take 5 fibs gives list of [0,1,1,2,3], so the value of 5th element is 3, to extract it we have to type : 'last(take(5 fibs))' and we get 3. And so on\n\nif we use interpreter to seek for 5th element we get list of [ 0, 1, 2, 3] the last element is the same what value of 5th element, how to get LAST element of that list?\nCan I 'make' it using ```\nlast```\n , do you have any ideas, could you?\n    ", "Answer": "\r\nThat definition yields an infinite stream of integers. There is no last element.\n\nIf instead you want to index a particular element from the list, you can do so with the ```\n(!!)```\n operator:\n\n```\n> [1..] !! 7\n8\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence formula not working\r\n                \r\nPlease see image below for my references.\nThe first column just gives us the row numbers\n2nd column is the Fibonacci sequence, just adding the previous 2 to get the new row\n3rd column should be the quotient of last row b divided by previous a value\n\nIt works up until the 4th iteration where the fraction should be:\n1.6, but it is 1.0000000 from then on\n3rd col should be \n\n```\n0\n1\n2\n1.66666666667\n1.6\n1.625 etc etc.\n```\n\n\nBut it is doing\n\n```\n0\n1\n2\n1.0000\n1.0000\n1.0000\n1.0000 etc.\n```\n\n\nWhat is wrong with my code? It should work but isn't. Here is python 3 code:\n\n```\na, b = 0, 1\nnum = 1\ni = 1\nf= 0\n\n#loop\nfor i in range(1, 101):\n   #use if to avoid divide by zero initially because a is 0\n   if a >= 1:\n      f = b / a\n\n   #print 3 column of 3 different numbers   \n   print ('{0:4d} {1:20d} {2:1.14f}'.format(i, b, f) )\n   i = i + 1 \n   a,b = b, a+b\n```\n\n\n\n    ", "Answer": "\r\nIf you're using Python 2, change the line:\n\n```\nf = b / a\n```\n\n\ninto\n\n```\nf = float(b) / float(a)\n```\n\n\nAre you sure you're using Python 3?  What does ```\npython -V```\n report?\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence: can understand the code [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nFibonacci sequence is 1, 1, 2, 3, 5, 8, ... The first two elements are 1. Each successive element is the sum of previous two elements.\n\nI have problem understanding the code below. I understand that ```\ni1, i2 = i2, i1+i2```\n will return ```\n1, 1, 2, ...```\n, but how come it returns ```\n..., 3, 5, 8, ...```\n? ```\ni1, i2 = 1, 1```\n is specified; where does this ```\n3```\n come from? If I understand this, I think I will understand why it becomes ```\n5, 8, ...```\n.\n\n```\ndef fib_to(max)\n  i1,i2 = 1,1\n  while i1 <= max\n    yield i1\n    i1, i2 = i2, i1+i2\n  end\nend\n\nfib_to(100) do |f| \n  #yeild(i1) is replaced by this |f|?\n  puts f\nend\n```\n\n\nresult\n\n```\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n```\n\n    ", "Answer": "\r\nTry to think about what numbers are stored in ```\ni1```\n and ```\ni2```\n, and what happens to them at each step. At each step, the value of ```\ni2```\n gets overwritten into ```\ni1```\n, and the value that was stored in ```\ni2```\n gets incremented by the value stored in ```\ni1```\n. At each step, you return the value stored in ```\ni1```\n.\n\nYou start with ```\n1, 1```\n (and return 1), then you get ```\n1, 2```\n (and return 1), then you get ```\n2, 3```\n (and return 2), then you get ```\n3, 5```\n (and return 3) and so on. \n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in Java using for statements\r\n                \r\nI tried making a Java program executing the Fibonacci sequence.\n\nHere's my code:\n\n```\nimport java.io.*;\npublic class Fibonacci{\n    public static void main(String[]args){\n        BufferedReader Data=new BufferedReader (new InputStreamReader(System.in));\n        int ctr1=0;\n        int ctr2=0;\n        int num1=0;\n        int num2=0;\n        int num3=0;\n        try{\n            System.out.println(\"How many numbers would you want to see?\");\n            ctr2=Integer.parseInt(Data.readLine());\n            for(int ans=0; ctr1==ctr2; ctr1++){\n            num1++;\n            System.out.println(num2 + \"\\n\" + num1);\n            ans=num1+num2;\n            System.out.println(ans);\n            ans=num3;\n            }\n        }catch(IOException err){\n            System.out.println(\"Error!\" + err);\n        }catch(NumberFormatException err){\n            System.out.println(\"Invald Input!\");\n        }\n    }\n}\n```\n\n\nObviously, I'm a beginner in Java and I don't know how to properly use the for statement. Would somebody be kind enough to make my code work? Or maybe make a way shorter code that works. I'm a beginner so be cool. Thanks :)\n    ", "Answer": "\r\nFibonacci series in java is actually quite simple and can be done with just one single for-loop!!!!\n\n```\nimport java.io.*;\nclass fibonacci{    \n    public static void main() throws NumberFormatException, IOException{  \n        BufferedReader Data=new BufferedReader (new InputStreamReader(System.in));\n        int a,b,c,d;\n        System.out.println(\"Upto How many numbers do you want to see?\");\n        d=Integer.parseInt(Data.readLine());\n        for  (a=0,b=1,c=a;a<d;c=a,a+=b,b=c){            \n            System.out.println(a);        \n        }            \n    }\n}    \n```\n\n\nThis has been done using buffered reader........ If you are said to use only bufferedreader go for this else you can use Scanner class which is much simple and easy to use because you don't have to catch or throw any exceptions.....\n\nScanner program:-\n\n```\nimport java.util.*;\nclass fibonacci{    \n    public static void main(){  \n        Scanner sc = new Scanner(System.in);\n        int a,b,c;\n        System.out.println(\"Upto How many numbers do you want to see?\");\n        d=sc.nextInt();\n        for  (a=0,b=1,c=a;a<d;c=a,a+=b,b=c){            \n            System.out.println(a);        \n        }            \n    }\n}    \n```\n\n\nNow as I said in one loop you can do it.... Here is another method where you do the swapping inside the body of the loop and not in the arguments of it...\nAnd this is much simplier to understand for beginners as u don't have to pass multiple variables inside the arguments and yeah its a bit longer\n\n```\nimport java.util.*;\nclass fibonacci{    \n    public static void main(){  \n        Scanner sc = new Scanner(System.in);\n        int a = 0,b = 1,c,d;\n        System.out.println(\"Upto How many numbers do you want to see?\");\n        d=sc.nextInt();\n        System.out.println(a +\"\\n\" +b);//\\n is used to go to next line....\n        for  (c=0;c<d;c++){  \n            c = a + b;//Doing and printing the fibonacci...\n            System.out.println(c);     \n            a = b;\n            b = c;//Swapping the values...\n        }            \n    }\n}    \n\n```\n\n\nSo here i have given you three methods that should give the same output(Most probably) choose whichever is convenient for you..\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Error C\r\n                \r\nI have an assignment where i have to write fibonacci's sequence and then print the first n numbers of it, where n is input by the user. What i wrote is:\n\n```\n#include <stdio.h>\nint main(int argc, char*argv[]){\n\nint n, i, seq[n];\nscanf(\"%d\", &n);\nseq[0]=0; seq[1]=1;\nfor(i=2; i<n; i++)\nseq[i]=seq[i-1]+seq[i-2];\n\nfor(i=0; i<n; i++)\nprintf(\"%d \", seq[i]);\nreturn(0);\n}\n```\n\n\nWhich works until n is equal or bigger than nine. Supposing that you input 8, the sequence will be 0 1 1 2 3 5 8 13 as it should be. If you input 9 or bigger the sequence looks like this 0 1 1 2 3 5 8 13 21 -9 (bunch of random numbers).\n\nAnyone who can point out the problem? Thx in advance.    \n    ", "Answer": "\r\nYou declare ```\nint n, i, seq[n];```\n before you have a value of ```\nn```\n to set the array's length with.  The behavior for an uninitialized variable is undefined.\n\nYou don't need an array to do this assignment as described.  You just need to remember the last and current Fibonacci values.  Sum them to produce the new one, then migrate current -> last and new -> current.  Put that logic in a loop controlled by ```\nn```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence - Find the number of digits - JavaScript\r\n                \r\nSo, I have successfully written the Fibonacci sequence to create an ```\narray```\n with the sequence of numbers, but I need to know the length (how many digits) the ```\n500th```\n number has.\n\nI've tried the below code, but its finding the length of the scientific notation (22 digits), not the proper 105 it should be returning.\n\nAny ideas how to convert a scientific notation number into an actual integer?\n\n```\nvar fiblength = function fiblength(nth) {\n    var temparr = [0,1];\n    for(var i = 2; i<=nth; i++){\n        var prev = temparr[temparr.length-2],\n            cur = temparr[temparr.length-1],\n            next = prev + cur;\n            temparr.push(next);\n    }\n    var final = temparr[temparr.length-1].toString().length;\n    console.log(temparr[temparr.length-1]);\n    return final;\n};\na = fiblength(500);\nconsole.log(a);\n```\n\n    ", "Answer": "\r\nWhy not use the simple procedure of dividing the number by 10 until the number is less than 1.\n\nSomething as simple as this should work (a recursive def obv works as well)\n\n```\nfunction getDigits(n) {\n   var digits = 0;\n   while(n >= 1) {\n      n/=10;\n      digits += 1;\n   }\n   return digits;\n}\n\ngetDigits(200);//3\ngetDigits(3.2 * 10e20);//=>22\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding an answer according to \" Fibonacci sequence\"\r\n                \r\nPlease have a look at the following code\n\n```\npackage Euler;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Problem2\n{\n    public static void main(String[]args)\n    {\n        int firstNumber=1;\n        int secondNumber=2;\n        int thirdNumber = 0;\n\n        int sum = 0;\n\n        List array = new ArrayList();\n\n        while(true)\n        {\n\n            if(thirdNumber>=400000)\n            {\n                break;\n            }\n            else\n            {\n                thirdNumber = firstNumber+secondNumber;\n                System.out.println(thirdNumber);\n\n\n                 if(thirdNumber%2==0)\n                {\n                    array.add(thirdNumber);\n                }\n\n                firstNumber = secondNumber;\n                secondNumber = thirdNumber;\n            }\n        }\n\n        for( int i=0;i<array.size();i++)\n        {\n            int num = Integer.parseInt(array.get(i).toString());\n\n            sum = sum+num;\n        }\n\n        System.out.println(\"The Sum is: \"+sum);\n    }\n}\n```\n\n\nHere I am trying to solve this problem, from Project Euler, Here is the problem anyway.\n\n\n  Each new term in the Fibonacci sequence is generated by adding the\n  previous two terms. By starting with 1 and 2, the first 10 terms will\n  be:\n  \n  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n  \n  By considering the terms in the Fibonacci sequence whose values do not\n  exceed four million, find the sum of the even-valued terms.\n\n\nThis was the answer I got- 257112;\n\nIt says the answer is wrong. I don't know why that is. For your information, my native language is not English, and I didn't do math in English too. So I doubt whether I misunderstood the question. \n\nPlease help me to find the correct way to solve this. Thanks\n    ", "Answer": "\r\n\n  By considering the terms in the Fibonacci sequence whose values do not exceed four million...\n\n\nOne problem is here:\n\n```\nif(thirdNumber>=400000)\n```\n\n\nThat's not four million. You need one more zero.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How do I code the Fibonacci sequence LMC?\r\n                \r\nI was wondering if it was possible to create a program that creates the Fibonacci Sequence in \"Little Man Computer\". \n\nThe program would output in the letter boxes the individual numbers of the sequence. The only input made would be asking the user how high it would like the sequence to go. For example if I input \"20\" it would only go up to to number 13.\n\nAny help would be greatly appreciated,\n\nIsaac.\n    ", "Answer": "\r\n\n  Source: link\n\n\n```\n        INP\n        STA N\nLOOP    LDA A\n        SUB N\n        BRP ENDLOOP\n        LDA A\n        OUT\n        LDA B\n        ADD A\n        STA ACC\n        LDA B\n        STA A\n        LDA ACC\n        STA B\n        BRA LOOP\nENDLOOP HLT\nA       DAT 0\nB       DAT 1\nN       DAT\nACC     DAT\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Calculate nth term of Fibonacci sequence in Python\r\n                \r\nThe following code is to calculate nth term og fibonacci sequence in python using matrix exponentiation for various test cases t.But the program gives absurd output.Please tell me where i am wrong.when i ran the code in C++ it runs perfectly.\n\n```\nclass matrix:\n    def __init__(self):\n        self.a=self.b=self.c=1\n        self.d=0\n\n    def mul(self,e,f):\n        ret = matrix()\n        ret.a=(e.a*f.a)+(e.b+f.c)\n        ret.b=(e.a*f.b)+(e.b+f.d)\n        ret.c=(e.c*f.a)+(e.d+f.c)\n        ret.d=(e.c*f.b)+(e.d+f.d)\n        return ret\n\n    def exp(self,a,p):\n        if(p==0):\n            temp=matrix()\n            temp.a=temp.b=temp.c=temp.d=1\n            return temp\n        if(p==1):\n            return a\n        if(p%2==0):\n            return self.exp(self.mul(a,a),p/2)\n        else:\n            return self.mul(a,self.exp(self.mul(a,a),(p-1)/2))\n\n    def fib(self,n):\n        if (n==0):\n            return 0\n        if (n==1):\n            return 1\n        s=matrix()\n        s=self.exp(s,n)\n        return s.d\n\nt=int(raw_input())\nwhile(t>0):\n    v=matrix()\n    n=int(raw_input())\n    print v.fib(n)\n    t=t-1\n```\n\n    ", "Answer": "\r\nThe problem lies in your ```\n__init__```\n function. In python the so-called variables are just 'tags' to data in the memory. To compare with C/C++, these can be thought of as pointers. when you assign ```\nself.a = self.b = self.c```\n, you are basically assigning three different names to the same data in the memory. Any change you make in ```\na```\n will be reflected back in ```\nb```\n and ```\nc```\n and so on.\n\nFor your problem where you need three separate variables, one way to change the ```\n__init__```\n function is like:\n\n```\nself.a, self.b, self.c = 1, 1, 1\n```\n\n\nor you can use ```\ncopy```\n. ```\ncopy()```\n tells python to assign a new memory location and then assign the tag on the right hand side to that location. For more read the official documentation on this http://docs.python.org/2/library/copy.html. You can also read a short walk-through on this in Python Tutorial: Shallow and Deep-copy\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence in MIPS using a while loop\r\n                \r\nI'm trying to write a program that allows for the user find to find out the nth fibonacci sequence. I'm new to MIPS however and I cannot seem to get it working. It's confusing the hell out of me.\n\n```\n    .data\n    msg: .asciiz \"Please enter a number to calculate the fibonnaci sequence for\"\n    equalsOne: .asciiz \"The answer is 1\"\n    equalsTwo: .asciiz \"The answer is 2\"\n    answer: .asciiz \"The answer is \"\n\n\n.text\n    addi $v0, $zero, 4  #Set $v0 to 4 (Print String)\n    la $a0, msg         #Set memory address of msg to $a0\n    syscall\n    addi $v0, $zero, 5  #Set $v0 to 5 (Read Integer)\n    syscall\n    add $t0, $zero, $v0 #Store input integer in $t0\n    beq $t0, 1, equals1 #If input integer == 1, go to equals1 \n    beq $t0, 2, equals2 #If input integer == 2, go to equals2\n    addi $t1, $zero, 1  #Stores 1 in register $t1\n    addi $a1, $zero, 1  # $a1 = currentNumber\n    addi $a2, $zero, 1  # $a2 = oldNumber\n\nfib:    slt $t2, $a1, $t0   #While $a1 < $t0\n    bne $t2, 1, exit\n    add $a3, $a1, $a2   # $a3 = nextNumber = currentNumber + oldNumber\n    add $a2, $a1, $zero #Set oldNumber = currentNumber\n    add $a1, $a3, $zero #Set currentNumber = nextNumber\n    j fib\n\nequals1: la $a0, equalsOne\n    addi $v0, $zero, 4\n    syscall\n\nequals2: la $a0, equalsTwo\n    addi $v0, $zero, 4\n    syscall\n\nexit: addi $v0, $zero, 1    #Print integer\n    add $a1, $a1, $zero #Print nextNumber\n    syscall\n```\n\n    ", "Answer": "\r\nThe argument for syscall 1 goes into ```\n$a0```\n. So this line:\n\n```\nadd $a1, $a1, $zero #Print nextNumber\n```\n\n\nshould be changed to:\n\n```\nadd $a0, $a1, $zero #Print nextNumber\n```\n\n\nNote that what you'll get is the smallest fibonacci number greater than or equal to N. If what you really wanted was the N:th fibonacci number, you'll have to change your loop exit condition so that you iterate N times, instead of until ```\n$a1```\n reaches a certain value like you do now.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci series sequence in ruby [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI want to write a Fibonacci sequence program in ruby without using the recursion.\ncan you please help me to write this function. \n    ", "Answer": "\r\n```\ndef fibonacci(n)\n  final = []\n  (0..n).each_with_index do |i, _|\n    next final << i if i.zero? || i == 1\n    final << final[i - 1] + final[i - 2]\n  end\n  final\nend\n\nputs fibonacci(10)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Checking whether a number is in Fibonacci Sequence?\r\n                \r\nIt was asked to find a way to check whether a number is in the Fibonacci Sequence or not.\nThe constraints are\n1≤T≤10^5 \n\n1≤N≤10^10\n\nwhere the T is the number of test cases,\n\nand N is the given number, the Fibonacci candidate to be tested.\n\nI wrote it the following using the fact a number is Fibonacci if and only if one or both of (5*n2 + 4) or (5*n2 – 4) is a perfect square :-\n\n```\nimport java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n public static void main(String[] args) {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n\n    for(int i = 0 ; i < n; i++){\n        int cand = sc.nextInt();\n        if(cand < 0){System.out.println(\"IsNotFibo\"); return; }\n        int aTest =(5 * (cand *cand)) + 4;\n        int bTest = (5 * (cand *cand)) - 4;\n        int sqrt1 = (int)Math.sqrt(aTest);// Taking square root of aTest, taking into account only the integer part.\n        int sqrt2 = (int)Math.sqrt(bTest);// Taking square root of bTest, taking into account only the integer part.\n        if((sqrt1 * sqrt1 == aTest)||(sqrt2 * sqrt2 == bTest)){\n            System.out.println(\"IsFibo\");\n        }else{\n            System.out.println(\"IsNotFibo\");\n        }\n       }\n     }\n  }\n```\n\n\nBut its not clearing all the test cases? What bug fixes I can do ?\n    ", "Answer": "\r\nA much simpler solution is based on the fact that there are only 49 Fibonacci numbers below 10^10. \n\nPrecompute them and store them in an array or hash table for existency checks. \n\nThe runtime complexity will be O(log N + T):\n\n```\nSet<Long> nums = new HashSet<>();\nlong a = 1, b = 2;\nwhile (a <= 10000000000L) {\n    nums.add(a);\n    long c = a + b;\n    a = b;\n    b = c;\n}\n// then for each query, use nums.contains() to check for Fibonacci-ness\n```\n\n\nIf you want to go down the perfect square route, you might want to use arbitrary-precision arithmetics:\n\n```\n// find ceil(sqrt(n)) in O(log n) steps\nBigInteger ceilSqrt(BigInteger n) {\n    // use binary search to find smallest x with x^2 >= n\n    BigInteger lo = BigInteger.valueOf(1),\n               hi = BigInteger.valueOf(n);\n    while (lo.compareTo(hi) < 0) {\n        BigInteger mid = lo.add(hi).divide(2);\n        if (mid.multiply(mid).compareTo(x) >= 0)\n            hi = mid;\n        else\n            lo = mid.add(BigInteger.ONE);\n    }\n    return lo;\n}\n// checks if n is a perfect square\nboolean isPerfectSquare(BigInteger n) {\n    BigInteger x = ceilSqrt(n);\n    return x.multiply(x).equals(n);\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Create Fibonacci Sequence in Prolog with 1 Parameter\r\n                \r\nI am a beginner on prolog and is trying to create fibonacci sequence rules. But it can't run because of error in the code called arithmetic fib is not a function.\n\nSource for my code : \n\n```\nfib(N):-\n    N<1, S is 0,\n    N<2, S is 1,\n    N1 is fib(N-1),\n    N2 is fib(N-2),\n    S is N1 + N2,\n    write(S, \" \").\n```\n\n\nThanks in advance for the help.\n    ", "Answer": "\r\n```\nfib(0,0).\nfib(1,1).\n\nfib(N,R):- N>1,\n           N1 is N-1,\n           N2 is N-2,\n           fib(N1,R1),\n           fib(N2,R2),\n           R is R1+R2.\n```\n\n\nThis how fibonacci can be defined using prolog, I defined the two base cases where the element n0 is 0 and element n1 is 1\n\nand then I identified any other element that is not equal to 0 or 1 to be Fn-1 + Fn-2\n\nto call the predicate you simply\n\n```\n?- fib(6,X).\n```\n\n\nwhere you expect X to have the result\n\nthe result this case will be\n\n```\nX = 8 \n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Check the given number belongs to Fibonacci sequence in node.js?\r\n                \r\nI need to create a web server with rest service in node.js. The server have to find a given input is Fibonacci or not. If it is Fibonacci, find the next number in Fibonacci sequence.\n\nSo I just write a simple program for finding Fibonacci number, but it doesn't work. \n\nFollowing are the Javascript functions I tried:\n\n```\nvar n = 5,s, a, fib;\n\nfunction isPerfectSquare(s)\n{\n    var a = Math.sqrt(s);\n    return a * a == s;\n}    \nfunction isFibonacci(n)\n{\n    s = (5 * Math.pow(n, 2) + 4 || 5 * Math.pow(n, 2) - 4)\n    return s;\n}\n\n//How to fix this line. I don't know how to check perfect square conditions \nif(isPerfectSquare(isFibonacci(n)) || isPerfectSquare(isFibonacci(n)))\n{\n    fib = Math.round(n * 1.618); // finds the next fibonacci series of given input\n    console.log(\"The next Fibonacci number is \" + fib);\n}    \nelse\n{\n    console.log(\"The given number is not a fibonacci number\");\n}\n```\n\n    ", "Answer": "\r\nFinally, I found the solution for my own Fibonacci sequence question.  Thank you for your suggestions guys.\n\nThe following snippet is working for me.\n\n\r\n\r\n```\nfunction isFibonacci(n) {\r\n  var fib,\r\n    a = (5 * Math.pow(n, 2) + 4),\r\n    b = (5 * Math.pow(n, 2) - 4)\r\n\r\n  var result = Math.sqrt(a) % 1 == 0,\r\n    res = Math.sqrt(b) % 1 == 0;\r\n\r\n  //fixed this line\r\n  if (result || res == true) // checks the given input is fibonacci series\r\n  {\r\n    fib = Math.round(n * 1.618); // finds the next fibonacci series of given input\r\n    console.log(\"The next Fibonacci number is \" + fib);\r\n\r\n  } else {\r\n    console.log(`The given number ${n} is not a fibonacci number`);\r\n  }\r\n}\r\n\r\n$('#fib').on(\"keyup change\", function() {\r\n  isFibonacci(+this.value)\r\n})```\n\r\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\"></script>\r\n<input id=\"fib\" type=\"number\" min=0 placeholder=\"Enter numebr..\" />```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Returning Nth Fibonacci number the sequence?\r\n                \r\nI have a question on my homework for class and I need to know how to return nth number of Fibonacci sequence using iteration (no recursion allowed).\n\nI need some tips on how to do this so I can better understand what I am doing wrong. I output to the console in my program.cs, hence it being absent in the code below.\n\n```\n    // Q1)\n    //\n    // Return the Nth Fibonacci number in the sequence\n    //\n    // Input: uint n (which number to get)\n    // Output: The nth fibonacci number\n    //\n\n    public static UInt64 GetNthFibonacciNumber(uint n)\n    {\n\n    // Return the nth fibonacci number based on n.\n\n\n    if (n == 0 || n == 1)\n        {\n            return 1;\n        }\n\n        // The basic Fibonacci sequence is \n        // 1, 1, 2, 3, 5, 8, 13, 21, 34...\n        // f(0) = 1\n        // f(1) = 1\n        // f(n) = f(n-1) + f(n-2)\n        ///////////////\n        //my code is below this comment\n\n        uint a = 0;\n        uint b = 1;\n\n        for (uint i = 0; i < n; i++)\n        {\n            n = b + a;\n            a = b;\n            b = n;\n        }\n        return n;\n```\n\n    ", "Answer": "\r\n:)\n\n```\nstatic ulong Fib(int n) \n{\n    double sqrt5 = Math.Sqrt(5);\n    double p1 = (1 + sqrt5) / 2;\n    double p2 = -1 * (p1 - 1);\n\n\n    double n1 = Math.Pow(p1, n + 1);\n    double n2 = Math.Pow(p2, n + 1);\n    return (ulong)((n1 - n2) / sqrt5);\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "JS:checking if number belongs to Fibonacci sequence(without loop)\r\n                \r\nIs there an efficient way to check if number belongs to Fibonacci sequence?\n\nI've seen many examples with a loop that creates the sequence in an array and checks every time if newly generated number of the sequence is equal to the input number. Is there another way?\n    ", "Answer": "\r\nhttp://www.geeksforgeeks.org/check-number-fibonacci-number/\n\nThis link details that there is a special quality about fibonacci numbers that means that a number is Fibonacci if and only if one or both of (5*n2 + 4) or (5*n2 – 4) is a perfect square.\n\nSo, \n\n```\nfunction (num) {\n    if (isSquare(5*(num*num)-4) || isSquare(5*(num*num)+4)) {\n       return true;\n    } else { return false; }\n}\n```\n\n\nThen isSquare would just be a simple checking function.\n\nEdit: Worth noting that while this is a much more efficient and easy way to find fibonacci numbers, it does have an upper bound. At about the 70th Fibonacci number and above, you may see issues because the numbers are too large. \n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Optimising a fibonacci sequence generator python\r\n                \r\nI am trying to create a program which creates a Fibonacci sequence up to the value of the sequence being 200. I have the basic set up down where I can compute the sequence but I wish to display it in a certain way and I have forgotten how to achieve this.\n\nI wish to write the numbers to an array which I have defined as empty initially, compute the numbers and assign them to the array and print said array. In my code below the computation is ok but when printed to screen, the array shows the value 233 which is above 200 and not what I'm looking for. I wish to print all the values under 200 which I've stored in an array.\n\nIs there a better way to initially define the array for what I want and what is the correct way to print the array at the end with all elements below 200?\n\nCode follows:\n\n```\n#This program calculates the fibonacci sequence up to the value of 200\nimport numpy as np\n\n\nx = np.empty(14, float) #Ideally creates an empty array to deposit the fibonacci numbers in\nf = 0.0 #Dummy variable to be edited in the while loop\n\n#Here the first two values of the sequence are defined alongside a counter starting at i = 1\nx[0] = 0.0\nx[1] = 1.0\ni = 1\n\n#While loop which computes the values and writes them to the array x\nwhile f <= 200:\n  f = x[i]+x[i-1] #calculates the sequence element\n  i += 1 #Increases the iteration counter by 1 for each loop\n  x[i] = f #set the array element equal to the calculated sequence number\n\nprint(x)\n```\n\n\nFor reference here is a quick terminal output, Ideally I wish to remove the last element:\n\n```\n[   0.    1.    1.    2.    3.    5.    8.   13.   21.   34.   55.   89.\n144.  233.]\n```\n\n    ", "Answer": "\r\nThere are a number of stylistic points here. Firstly, you should probably use integers, rather than floats. Secondly, you should simply append each number to a list, rather than pre-define an array of a particular size.\n\nHere's an interactive session:\n\n```\n>>> a=[0,1]\n>>> while True:\n        b=a[-1]+a[-2]\n        if b<=200:\n            a.append(b)\n        else:\n            break\n>>> a\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Trying to generate a fibonacci sequence into a listbox item\r\n                \r\n```\n private void btn_Click(object sender, EventArgs e)\n    {\n        int quantity = Convert.ToInt32(txtseq.Text);\n        int[] array = new int[lbox.Items.Count];\n        if (txtseq.Text.Length > 0)\n        {\n            for (int i = 2; i < array.Length; i++)\n            {\n                array[0] = 0;\n                array[1] = 1;\n                array[i] = array[i--] + array[i];\n                lbox.Items.Add(array[0].ToString() + array[1].ToString() + array[i].ToString());\n                \n            }\n\n            \n        }\n        else\n            MessageBox.Show(\"Insert something first\");\n    }\n```\n\nTrying to generate a fibonacci sequence and sending it to a listbox item however i dont understand why its not being added to the listbox as a item in the for\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "how to save all terms in Fibonacci sequence till `n`\r\n                \r\nI was trying to save all items in Fibonacci sequence till a given number ```\nn```\n. For example, if the function is ```\nfib```\n, my expected out would be\n\n\n```\n1 1 2```\n for ```\nfib(3)```\n\n```\n1 1 2 3 5```\n for ```\nfib(5)```\n\n```\n1 1 2 3 5 8 13 21```\n for ```\nfib(8)```\n\n\n\nso on and so forth.\n\nMy code is \n\n```\nfib <- function(n) {\n  if (n<= 2) {\n    return(1)\n  } else {\n    return(f(n-1)+f(n-2))\n  }\n}\n```\n\n\nbut it only gives a single value for the ```\nn```\n-th elements in the Fibonacci sequence. \n\nAny clue to save the elements from ```\n1```\n to ```\nn```\n as the output of ```\nfib(n)```\n? Thank you!\n    ", "Answer": "\r\nI think you have a couple of ways to make it:\n\n\nApproach 1: Redefine ```\nfib```\n in a recursive manner \n\n\n```\nfib <- function(n) {\n  if (n<=2) return(rep(1,n))\n  c(u <- Recall(n-1),sum(tail(u,2)))\n}\n```\n\n\nsuch that\n\n```\n> fib(10)\n [1]  1  1  2  3  5  8 13 21 34 55\n\n> fib(20)\n [1]    1    1    2    3    5    8   13   21   34   55   89\n[12]  144  233  377  610  987 1597 2584 4181 6765\n```\n\n\n\nApproach 2: Use your ```\nfib```\n but with ```\nsapply```\n\n\n\n```\nfib1 <- function(n) sapply(seq(n),fib)\n```\n\n\nsuch that\n\n```\n> fib1(10)\n [1]  1  1  2  3  5  8 13 21 34 55\n\n> fib1(20)\n [1]    1    1    2    3    5    8   13   21   34   55   89\n[12]  144  233  377  610  987 1597 2584 4181 6765\n```\n\n\n\nApproach 3: Use ```\nfor```\n loop (I think this would be the most efficient one among three approaches)\n\n\n```\nfib2 <- function(n) {\n  r <- rep(1,n)\n  if (n>=3) {\n    for (k in 3:n) {\n      r[k] <- sum(r[k-(1:2)])\n    }\n  }\n  r\n}\n```\n\n\nsuch that\n\n```\n> fib2(10)\n [1]  1  1  2  3  5  8 13 21 34 55\n\n> fib2(20)\n [1]    1    1    2    3    5    8   13   21   34   55   89\n[12]  144  233  377  610  987 1597 2584 4181 6765\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Optimising a fibonacci sequence generator python\r\n                \r\nI am trying to create a program which creates a Fibonacci sequence up to the value of the sequence being 200. I have the basic set up down where I can compute the sequence but I wish to display it in a certain way and I have forgotten how to achieve this.\n\nI wish to write the numbers to an array which I have defined as empty initially, compute the numbers and assign them to the array and print said array. In my code below the computation is ok but when printed to screen, the array shows the value 233 which is above 200 and not what I'm looking for. I wish to print all the values under 200 which I've stored in an array.\n\nIs there a better way to initially define the array for what I want and what is the correct way to print the array at the end with all elements below 200?\n\nCode follows:\n\n```\n#This program calculates the fibonacci sequence up to the value of 200\nimport numpy as np\n\n\nx = np.empty(14, float) #Ideally creates an empty array to deposit the fibonacci numbers in\nf = 0.0 #Dummy variable to be edited in the while loop\n\n#Here the first two values of the sequence are defined alongside a counter starting at i = 1\nx[0] = 0.0\nx[1] = 1.0\ni = 1\n\n#While loop which computes the values and writes them to the array x\nwhile f <= 200:\n  f = x[i]+x[i-1] #calculates the sequence element\n  i += 1 #Increases the iteration counter by 1 for each loop\n  x[i] = f #set the array element equal to the calculated sequence number\n\nprint(x)\n```\n\n\nFor reference here is a quick terminal output, Ideally I wish to remove the last element:\n\n```\n[   0.    1.    1.    2.    3.    5.    8.   13.   21.   34.   55.   89.\n144.  233.]\n```\n\n    ", "Answer": "\r\nThere are a number of stylistic points here. Firstly, you should probably use integers, rather than floats. Secondly, you should simply append each number to a list, rather than pre-define an array of a particular size.\n\nHere's an interactive session:\n\n```\n>>> a=[0,1]\n>>> while True:\n        b=a[-1]+a[-2]\n        if b<=200:\n            a.append(b)\n        else:\n            break\n>>> a\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence and nth number with reduce()\r\n                \r\n```\nconst generateFibonnaciSequence = (n) => {\n    return [\n        (arr = new Array(n).fill(1).reduce((arr, _, i) => {\n            arr.push(i <= 1 ? 1 : arr[i - 2] + arr[i - 1]);\n            return arr;\n        }, [])),\n        arr[n - 1],\n    ];\n};\n\nconst [fibonacciSequence, fibonacciNthNumber] = generateFibonnaciSequence(n);\n```\n\nMy idea is to return an array holding fibonacci sequence up to ```\nn```\n in index 0 and fibonnaci's n-th value in index 1. Can someone help me with a prettier way of constructing this function. I'd like to avoid holding the array in temp arr variable if possible, but still use a single expression for return statement.\n    ", "Answer": "\r\nI'm using recursion with tail call optimization. This code shouldn't have problems with fib(1000) and more\n\r\n\r\n```\nfunction fib(n){\nlet result=new Array(2);\nresult[0]=\"0 \";\nresult[1] = fibImp(0,1,n);\n\n   return result;\n\nfunction fibImp(a,b,n){\n  if(n===0)\n    return a;\n    \n  result[0] += b+\" \";\n  return fibImp(b,a+b,n-1);\n}\n\n}\n\n[sequence, result] = fib(8);\nconsole.log(sequence);\nconsole.log(result);```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Creating a Fibonacci Sequence in Visual Studio 2017\r\n                \r\nI wanted to create a program which will list a number of terms in the Fibonacci sequence. The number of terms has to be specified by the user. I am quite new to programming and Visual Studio, can someone help me out?\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "can you output a Fibonacci sequence with one variable?\r\n                \r\nHey I am trying to get a Fibonacci sequence to output with a single variable in the mix. normally if I was using 2 variables I would have it set up like this:\n\n```\nnmbr1 = nmbr2 = 1\nwhile nmbr1 < 100:\n  nmbr1, nmbr2 = nmbr1 + nmbr2, nmbr1\n  print (nmbr1)\n```\n\n\nbut how would I get it complete the sequence with only one variable in python?\n    ", "Answer": "\r\nSince nobody mentioned what sort of object the variable should be, here's using a ```\nlist```\n ;-)\n\n```\nx = [1, 1]\n\nwhile x[0] < 100:\n     x = x[1], sum(x)\n     print(x[0])\n\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n```\n\n\n\n\nIf you really want to be sneaky, you can use the closed form solution for the Fibonacci series by approximation with the golden ratio.\n\n```\ndef fib(n): \n    return int((((1 + 5 ** .5) / 2) ** n) / (5 ** .5) + .5)\n\nf = c = 1\nwhile f < 100:\n    c += 1\n    f = fib(c) \n    print(f)\n\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n```\n\n\nThis only uses one variable - ```\nn```\n - and it calculates ```\nF[n]```\n in constant time. Run a loop and keep calling ```\nfib```\n successively.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How do I print a fibonacci sequence to the nth number in Python?\r\n                \r\nI have a homework assignment that I'm stumped on. I'm trying to write a program that outputs the fibonacci sequence up the nth number. Here's what I have so far: \n\n```\ndef fib():\n   n = int(input(\"Please Enter a number: \"))\n\n   if n == 1:\n      return(1)\n   elif n == 0:   \n      return(0)            \n   else:                      \n      return (n-1) + (n-2)\n\n\nmylist = range[0:n]\nprint(mylist)\n```\n\n\nI'm thinking I could use separate functions but I can't figure out how to pass the argument that calculates the fibonacci sequence. Then the next step would be to to print out the sequence of numbers up to that number.  \n    ", "Answer": "\r\nNon-recursive solution\n\n```\ndef fib(n):\n    cur = 1\n    old = 1\n    i = 1\n    while (i < n):\n        cur, old, i = cur+old, cur, i+1\n    return cur\n\nfor i in range(10):\n    print(fib(i))\n```\n\n\nGenerator solution:\n\n```\ndef fib(n):\n    old = 0\n    cur = 1\n    i = 1\n    yield cur\n    while (i < n):\n        cur, old, i = cur+old, cur, i+1\n        yield cur\n\nfor f in fib(10):\n    print(f)\n```\n\n\nNote that generator solution outperforms the non-recursive (and non-recursive outperforms recursive, if memoization is not applied to recursive solution)\n\nOne more time, recursive with memoization:\n\n```\ndef memoize(func):\n    memo = dict()\n    def decorated(n):\n        if n not in memo:\n            memo[n] = func(n)\n        return memo[n]\n\n    return decorated\n\n@memoize\ndef fib(n):\n    #added for demonstration purposes only - not really needed\n    global call_count\n    call_count = call_count + 1\n    #end demonstration purposes\n\n    if n<=1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\ncall_count = 0 #added for demonstration purposes only - not really needed\nfor i in range(100):\n    print(fib(i))\nprint(call_count) #prints 100\n```\n\n\nThis time each fibbonacci number calculated exactly once, and than stored. So, this solution would outperform all the rest. However, the decorator implementation is just quick and dirty, don't let it into production. (see this amazing question on SO for details about python decorators :)\n\nSo, having ```\nfib```\n defined, the program would be something like (sorry, just looping is boring, here's some more cool python stuff: list comprehensions)\n\n```\nfib_n = int(input(\"Fib number?\"))\nfibs = [fib(i) for i in range(fib_n)]\nprint \" \".join(fibs) \n```\n\n\nthis prints all numbers in ONE line, separated by spaces. If you want each on it's own line - replace ```\n\" \"```\n with ```\n\"\\n\"```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to calculate fibonacci-sequence for String data set?\r\n                \r\nI want to calculate Fibonacci sequence for a string data set. I'm writing a normal JavaScript function but I want to write the code using the latest ECMAScript features.\n\n\r\n\r\n```\nvar message = \"The Da Vinci Code is a 2003 mystery-detective novel by Dan Brown\";\r\n\r\nfunction FibonacciSecret(message) {\r\n  var s = '';\r\n  for (var i = 0; i < 10; i++) {\r\n    s += message.replace(/\\s+/g, '').substr(getNthValue(i), 1).toUpperCase();\r\n    if (i != 9) {\r\n      s += \"-\";\r\n    }\r\n  }\r\n\r\n  function getNthValue(n) {\r\n    if (n <= 1) {\r\n      return n;\r\n    }\r\n    if (n > 1) {\r\n      return getNthValue(n - 1) + getNthValue(n - 2);\r\n    }\r\n  }\r\n  return s;\r\n}\r\n\r\nconsole.log(FibonacciSecret(message)); // \"T-H-H-E-D-V-C-E-M-T\"```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nMemoization\nInstead of calculate every time the ```\nn```\n number of fibonacci you can simple look it up in a table if you calculated it once. This is called Memoization. You can read more about it in Faster JavaScript Memoization by Addy Osmani.\nYour Code\nThe function ```\ngetNthValue```\n gets defined every time you call ```\nFibonacciSecret```\n. It may be would have a better performance if you would define it outside, but I did't test it. But it would be definitely better to test your code.\nAdditionally on each iteration you remove whitspaces ```\nmessage.replace(/\\s+/g, '')```\n and call ```\ntoUpperCase```\nbut one call would be enough.\nExample\nI wrote it recursively because I think the code is easier to read. I pass in String without whitespaces (```\ncreateSecretString(messageWithoutWhitespace, memory, secret)```\n and save on each recursion a letter in ```\nsecret```\n. On the last recursion I return the array joined to a string and upper case all letters once. (```\nsecret.join('-').toUpperCase()```\n)\n\r\n\r\n```\nconst message = \"The Da Vinci Code is a 2003 mystery-detective novel by Dan Brown\";\nconst fibonacciMemory = {}\n\nfunction fibonacci(x, memory = {}) {\n  if (memory[x]) {\n    return memory[x]\n  }\n  if (x < 1) {\n    return 0\n  }\n  if (x <= 2) {\n    return 1\n  }\n  return memory[x] = fibonacci(x - 1, memory) + fibonacci(x - 2, memory);\n}\n\nfunction createSecretString(message, memory, secret) {\n  const length = secret.length - 1\n  return length < 10 \n    ? createSecretString(message, memory, secret.concat(message.substr(fibonacci(length, memory), 1))) \n    : secret.join('-').toUpperCase()\n}\n\nfunction fibonacciSecret(message, memory, secret = []) {\n  const messageWithoutWhitespace = message.replace(/\\s+/g, '')\n  return createSecretString(messageWithoutWhitespace, memory, secret)\n}\n\nconsole.log(fibonacciSecret(message, fibonacciMemory))```\n\r\n\r\n\r\n\n\"Benchmark\"\nwith memoization\n\r\n\r\n```\nconst message = \"The Da Vinci Code is a 2003 mystery-detective novel by Dan Brown\";\nconst fibonacciMemory = {}\n\nfunction fibonacci(x, memory = {}) {\n  if (memory[x]) {\n    return memory[x]\n  }\n  if (x < 1) {\n    return 0\n  }\n  if (x <= 2) {\n    return 1\n  }\n  return memory[x] = fibonacci(x - 1, memory) + fibonacci(x - 2, memory);\n}\n\nfunction createSecretString(message, memory, secret) {\n  const length = secret.length - 1\n  return length < 10 \n    ? createSecretString(message, memory, secret.concat(message.substr(fibonacci(length, memory), 1))) \n    : secret.join('-').toUpperCase()\n}\n\nfunction fibonacciSecret(message, memory, secret = []) {\n  const messageWithoutWhitespace = message.replace(/\\s+/g, '')\n  return createSecretString(messageWithoutWhitespace, memory, secret)\n}\n\nconst t0 = performance.now();\nfibonacciSecret(message, fibonacciMemory);\nconst t1 = performance.now();\nconsole.log(\"First call took \" + (t1 - t0) + \" milliseconds.\");\n\nvar t2 = performance.now();\nfibonacciSecret(message, fibonacciMemory);\nvar t3 = performance.now();\nconsole.log(\"Second call took \" + (t3 - t2) + \" milliseconds.\");```\n\r\n\r\n\r\n\nwithout memoization\n\r\n\r\n```\nvar message = \"The Da Vinci Code is a 2003 mystery-detective novel by Dan Brown\";\n\nfunction FibonacciSecret(message){\n  var s = '';\n   for(var i = 0; i < 10; i++) {\n   s += message.replace(/\\s+/g,'').substr(getNthValue(i), 1).toUpperCase();\n   if(i != 9) {\n       s += \"-\";\n      }\n   }\n\n   function getNthValue(n) {\n   if(n <= 1) {\n       return n;\n      }\n   if(n > 1) {\n       return getNthValue(n-1) + getNthValue(n-2);\n      }\n   }\n   return s;\n}\n\nvar t0 = performance.now();\nFibonacciSecret(message);\nvar t1 = performance.now();\nconsole.log(\"Call took \" + (t1 - t0) + \" milliseconds.\");```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Using Stream to iterate over Fibonacci Sequence in Java\r\n                \r\nIn class we used this code to generate a Fibonacci sequence via an Integer Stream. \nCan someone please explain to me what the .map() function is doing in this code? \n\n```\npublic class fibStream {\n\n    public static Stream<Integer> getFibStream() {\n        return Stream.iterate(new Integer[] {0,1}, s -> new Integer[]{s[1], s[0] + s[1]})\n              .map(s -> s[0]);  //what is .map() doing here?\n    }\n}\n```\n\n    ", "Answer": "\r\nOwing to the seed ```\nnew Integer[] {0,1}```\n, you would be iterating on ```\nInteger[]```\n with two elements. Iterating with a new ```\nInteger[]```\n every step with its values re-evaluated.\n\nThe ```\nmap```\n is just accessing the first of those ```\nInteger```\n to finally consume(make use of) it.\n\nFor an example, better composed implementation of the same could look like(print 20 first fibonacci element) :\n\n```\nStream.iterate(new Integer[] {0,1}, s -> new Integer[]{s[1], s[0] + s[1]})\n      .limit(20) // short-circuit\n      .map(s -> s[0])\n      .forEach(System.out::println); // consume the mapped element\n```\n\n\nFrom the comments by JollyJoker\n\n\n  Additional clarification; the fibonacci stream is made of arrays like\n  ```\n{0,1} {1,1} {1,2} {2,3} {3,5}```\n and ```\n.map(s -> s[0])```\n gets each array,\n  returning the first number from them, like ```\n0 1 1 2 3```\n.\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Optimizing the Fibonacci sequence recursive function by making it a wrapper\r\n                \r\nThere is an issue with the recursive definition of the fibonacci sequence when it comes to efficiency. It is defined as follows:\n\n```\nprivate fib(int n) {\n    if(n < 2) return n;\n    else return fib(n - 1) + fib(n-2);\n}\n```\n\n\nSuppose we call fib(5). This makes 1 call to fib(4) , two calls to fib(3), three calls to fib(2), five calls to fib(1) and three calls to fib(0).\n\nIn his book\n\n\n  Programming Abstractions in Java by Eric Roberts\n\n\nRoberts mentions that we can resolve this efficiency issue by realizing that the fibonacci sequence is just a special case of the ```\nadditiveSequence(int n, int t0, int t1)```\n method. Basically, the Fibonacci sequence is just an additive sequence that strictly begins with 0 and 1. There are an infinite number of sequences that match the recurrence relation expressed by Fibonacci.\n\nThe author resolves the efficiency issue as follows:\n\n```\nprivate int fib(int n) {\n    return additiveSequence(n, 0, 1);\n}\n```\n\n\nSo my questions is, by making the fib sequence a wrapper for the more general additiveSequence method, are we really improving efficiency ? Wouldn't the implementation of additiveSequence have the same exact \"problem\" in terms of efficiency that fib had, given that it does follow the same exact reccurence relation ?\n    ", "Answer": "\r\nHere's an example implementation of an additive sequence calculation, where ti = ti-1 +  ti-2:\n\n```\nint additiveSequence(int n, int t0, int t1) {\n  if(n==0) return t0;\n  if(n==1) return t1;\n  return additiveSequence(n-1, t1, t0+t1);\n}\n```\n\n\nThis method returns the n-th value in the series. Work through some examples and you should be able to convince yourself that each ti will be calculated only once. Compare that with your naively implemented fib method and you can see why this approach is much faster.\n\nThe Fibonacci series is this kind of additive sequence, with the starting conditions t0 = 0 and t1 = 1. There's nothing particularly special about it, other than the fact that the obvious way to code it is a poor one. The author's point, presumably, is that implementation makes a huge difference in processing time. It does not appear to be clearly explained, however.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Java: check if number belongs to Fibonacci sequence\r\n                \r\nI'm supposed to write a code which checks if a given number belongs to the Fibonacci sequence. After a few hours of hard work this is what i came up with:\n\n```\npublic class TP2 {\n\n    /**\n     * @param args\n     */\n\n    public static boolean ehFibonacci(int n) {\n        int fib1 = 0;\n        int fib2 = 1;\n        do {\n            int saveFib1 = fib1;\n            fib1 = fib2;\n            fib2 = saveFib1 + fib2;\n            }\n        while (fib2 <= n);\n\n        if (fib2 == n)\n            return true;\n        else\n            return false;\n\n    }\n    public static void main(String[] args) {\n        int n = 8;\n        System.out.println(ehFibonacci(n));\n\n    }\n}\n```\n\n\nI must be doing something wrong, because it always returns \"false\". Any tips on how to fix this?\n    ", "Answer": "\r\nYou continue the loop while ```\nfib2 <= n```\n, so when you are out of the loop, fib2 is always ```\n> n```\n, and so it returns ```\nfalse```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence going from point a to point b?\r\n                \r\n```\nm = 2\nn =20\na,b = m,0\nfib = [m]\nwhile a <= n:\n   fib.append(a)\n   a,b = a+b, a\n```\n\n\nSo given two variables from ```\nm```\n to ```\nn (and m < n)```\n, I need to create a list containing all the numbers of the Fibonacci sequence between ```\nm```\n and ```\nn```\n inclusive (but cannot exceed) ex: if ```\nm = 2```\n and ```\nn = 20```\n then ```\nfib```\n should be ```\n[2,3,5,8,13]```\n.\n    ", "Answer": "\r\nI do not know how to start the fibonnaci sequence midway, so the best I can think of is to filter the results afterwards.\n\n```\ndef f(low, high):\n    fib = [0]\n    a, b = 1, 0\n    while a <= n:\n       fib.append(a)\n       a,b = a+b, a\n    return filter(lambda x: x >= low and x =< high, fib)\n```\n\n\nThe fibonacci code is trivial, the new thing you might be seeing here is ```\nfilter```\n, which takes a function ```\nf```\n and an iterable ```\nx```\n, and returns a new iterable with all of the elements from ```\nx```\n such that ```\nf(x)```\n is true.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to find the Fibonacci Sequence with C++?\r\n                \r\nI am trying to solve Problem 2 on Project Euler. The problem is: \n\n\"Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n\nBy considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\"\n\nI am trying to solve this in C++.\n\nHere is my code so far\n\n```\n#include <iostream>\n using namespace std;\n\nint main()\n{\n    //ANSWER = 4613732\n    int max = 4000000;\n    int n;\n    int sum;\n\n    for(n=0; n<=max;)\n    {\n        while(n%2 == 0)\n        {\n            n = (n-1)+(n-2);\n        }\n    }\n    sum = n+=0;\n    cout << sum << endl;\n    return 0;\n}\n```\n\n\nAs you can see I know the correct answer from searching for it to check my answer. This code I have just runs forever and never shows an answer. Can anyone give me hints on how to arrive to this answer and to help improve my C++ code. Thanks in advance!\n    ", "Answer": "\r\nHere is an approach you should not follow.  (Note: this post is a joke, but I'm serious about not following this approach.  Attempting to understand this approach at your level of C++ understanding is also ill advised.)\n\n```\n#include <iostream>\n\nstruct Fib\n{\n  template<int n, int first=1, int second=1> struct Eval { enum {value = Eval<n-1, first, second>::value + Eval<n-2, first, second>::value}; };\n  template<int first, int second> struct Eval<1, first, second> { enum {value = second}; };\n  template<int first, int second> struct Eval<0, first, second> { enum {value = first}; };\n\n};\nstruct SpecificFib\n{\n  template<int n> struct Eval { enum{ value = Fib::template Eval<n, 1, 2>::value }; };\n};\n\ntemplate<int... values> struct Sequence {};\ntemplate<typename Seq, int n> struct Append;\ntemplate<int... values, int n> struct Append<Sequence<values...>, n> { typedef Sequence<values...,n> type; };\ntemplate<typename Seq, int n> struct Prepend;\ntemplate<int... values, int n> struct Prepend<Sequence<values...>, n> { typedef Sequence<n, values...> type; };\n\ntemplate<typename Func,typename Seq,typename Test=void> struct Filter;\n\ntemplate<typename Func,int first, int... values>\nstruct Filter<Func,Sequence<first,values...>,typename std::enable_if< Func::template Eval<first>::value>::type>\n{\n  typedef typename Prepend<typename Filter<Func,Sequence<values...>>::type,first>::type type;\n};\n\ntemplate<typename Func,int first, int... values>\nstruct Filter<Func,Sequence<first,values...>,typename std::enable_if< !Func::template Eval<first>::value>::type>\n{\n  typedef typename Filter<Func,Sequence<values...>>::type type;\n};\ntemplate<typename Func> struct Filter<Func,Sequence<>> { typedef Sequence<> type; };\n\nstruct IsEven {\n  template<int n> struct Eval { enum{ value = !(n%2) }; };\n};\n\ntemplate<typename Func,typename Seq> struct Map;\ntemplate<typename Func,int first, int... values>\nstruct Map<Func, Sequence<first,values...>>\n{\n  typedef Sequence<values...> Tail;\n  typedef typename Map<Func,Tail>::type TailMapped;\n  enum { firstMapped = Func::template Eval<first>::value };\n\n  typedef typename Prepend<TailMapped,firstMapped>::type type;\n};\ntemplate<typename Func>\nstruct Map<Func,Sequence<>>\n{\n  typedef Sequence<> type;\n};\n\ntemplate<int begin, int end>\nstruct generate_sequence\n{\n  template<int current, int... values>\n  struct helper: helper<current-1, current-1, values...> {};\n  template<int... values>\n  struct helper<begin, values...>\n  {\n    typedef Sequence<values...> type;\n  };\n  typedef typename helper<end>::type type;\n};\ntemplate<typename Seq> struct Sum;\ntemplate<int first, int... values> struct Sum<Sequence<first, values...>> { enum {value = first + Sum<Sequence<values...>>::value}; };\ntemplate<> struct Sum<Sequence<>> { enum {value = 0}; };\n\ntemplate<typename Seq1, typename Seq2=Sequence<>>\nstruct Reverse { typedef Seq2 type; };\n\ntemplate<int first, int... values, typename Seq2>\nstruct Reverse<Sequence<first,values...>, Seq2>:Reverse<Sequence<values...>, typename Prepend<Seq2,first>::type> {};\n\ntemplate<typename Seq, char sep=','> struct PrintHelper;\ntemplate<int first, int second, int... values, char sep> struct PrintHelper<Sequence<first,second,values...>, sep>:PrintHelper<Sequence<second,values...>, sep>\n{\n  PrintHelper() { std::cout << sep << first; }\n};\ntemplate<int last, char sep> struct PrintHelper<Sequence<last>, sep>:PrintHelper<Sequence<>, sep>\n{\n  PrintHelper() { std::cout << last; }\n};\ntemplate<char sep> struct PrintHelper<Sequence<>,sep> { PrintHelper() {} void Do() const {} };\ntemplate<typename Seq, char sep=','> struct Print: PrintHelper< typename Reverse<Seq>::type, sep >\n{};\n\ntypedef typename generate_sequence<0, 10>::type ZeroTo9;\ntypedef typename Map<SpecificFib,ZeroTo9>::type First10Fibs;\ntypedef typename Filter<IsEven,First10Fibs>::type First10FibsThatAreEven;\n\ntemplate<typename Sequence>\nvoid PrintSomeInfo( std::string const& name )\n{\n  std::cout << name << \" {\";\n  Print<Sequence>();\n  std::cout << \"} sums to \" << Sum<Sequence>::value << \"\\n\";\n}\nint main()\n{\n  PrintSomeInfo<ZeroTo9>(\"Zero to 9\");\n  PrintSomeInfo<First10Fibs>(\"First 10 fibs\");\n  PrintSomeInfo<First10FibsThatAreEven>(\"First 10 fibs that are even\");\n}\n```\n\n\nI hope that helps.\n\nWhat I am doing above is playing around with template programming.  I'm deducing the answer using the rather over powered C++ type system, such that if a compiler properly compiled ```\nSum<Sequence>::value```\n, it would be a single compile-time value.\n\nTechnically, this is an answer to your question written in C++.  As a bonus, it will have ```\nO(1)```\n run time.  :)\n\n...\n\nMore seriously.  You need to solve your problem one step at a time.\n\nWrite a program that outputs the first 10 elements of the sequence.  I would say \"like the above\", but you should do it in a way you understand.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Basic JavaScript - Fibonacci Sequence Generator Not Working\r\n                \r\nI am new to JavaScript, for some reason my Fibonacci Sequence Generator. What is a Fibonacci Sequence, easy, it is a sequence that takes the last two numbers of the sequence and adds them to create the next number. Here is an example. 0, 1, 1, 2, 3, 5, 8, 13, 21... I tried to make a loop with a while statement in which the variable that was once the first number (in this case 0), converts into a new number which is whatever that number was plus the second number (in this case 1). example: var firstNumber(which is 0) + var secondNumber(which is 1) = var firstNumber(which no equals to 1 because we added 0 + 1). If this goes on in a loop, then, in theory, it could go infinitely adding the last number and the one before it, and making that second to last number making the result of the addition. Here is my code, it is not working at all. Any help would be deeply appreciated. Hopefully, I have explained my self correctly.\n\r\n\r\n```\nvar firstNumber = 0;\nvar secondNumber = 1;\n\nfunction fibonacciGenerator(n){\n    while (secondNumber <= n){\n        firstNumber + secondNumber == firstNumber;\n        secondNumber + firstNumber == secondNumber;\n    }\n}\nconsole.log(fibonacciGenerator(50));```\n\r\n\r\n\r\n\n    ", "Answer": "\r\n```\nfirstNumber + secondNumber == firstNumber;```\n this is not the way to assign a value to a variable\nand you need to add a return statement at the end of your function.\nDoes this help ?\n\r\n\r\n```\nvar firstNumber = 0;\nvar secondNumber = 1;\n\nfunction fibonacciGenerator(n){\n  while (secondNumber <= n){\n      firstNumber = firstNumber + secondNumber;\n      secondNumber = secondNumber + firstNumber;\n  }\n  return secondNumber\n}\n\nconsole.log(fibonacciGenerator(50));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to make fibonacci sequence in racket using abstract list functions\r\n                \r\nI am trying to write a racket program that computes the sum of the first n terms in a fibonacci sequence without using recursion, and only using abstract list functions (so map, builld-list, foldr, foldl). I can use helper functions.\nI'm stuck on how to make a list of the fibonacci numbers without using recursion. I thought I could use a lambda function:\n\n```\n(lambda (lst) (+ (list-ref lst (- (length lst) 1)) (list-ref lst (- (length lst 2)))))\n```\n\n\nBut I am not sure how to generate the input list/how to add this to a function.\nOnce I have a fibonacci sequence I know I can just use (foldl + (car lst) (cdr lst)) to find the sum.\nCould anyone explain to me how to make the fibonacci sequence/give me a hint? \n    ", "Answer": "\r\n```\n; This is how I figure out\n#|\n(1 2 3 4 (0 1))\n-> (1 2 3 (1 1))\n-> (1 2 (1 2))\n-> (1 (2 3))\n-> (3 5)\n|#\n\n(define (fib n)\n  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [(> n 1)\n     (second\n      (foldr (λ (no-use ls) (list (second ls) (+ (first ls) (second ls))))\n             '(0 1)\n             (build-list (- n 1) (λ (x) x))))]))\n\n(fib 10)\n(build-list 10 fib)\n```\n\n\nUpgrade version 2\n\n```\n(define (fib-v2 n)\n  (first\n   (foldr (λ (no-use ls) (list (second ls) (+ (first ls) (second ls))))\n          '(0 1)\n          (build-list n (λ (x) x)))))\n\n\n(build-list 10 fib-v2)\n\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generating a Cryptographic Key using Fibonacci Sequence in Python\r\n                \r\nI'm trying to generate a cryptographic key using the Fibonacci sequence in Python. I have a specific key (ebe42a225e8593e448d9c5457381aaf7) that I want to use as a starting point. However, my current implementation is not working as expected. Could someone please help me identify the issue in my code and provide guidance on how to achieve this?\n```\ndef generate_key_from_fibonacci(seed_key):\n    # Convert the seed key from hexadecimal to an integer\n    seed_key_int = int(seed_key, 16)\n\n    # Generate Fibonacci numbers until the key length is reached\n    fib_nums = [0, 1]\n    while len(fib_nums[-1]) < len(seed_key):\n        next_fib = fib_nums[-1] + fib_nums[-2]\n        fib_nums.append(next_fib)\n\n    # Truncate or expand the last Fibonacci number to match the key length\n    fib_nums[-1] = fib_nums[-1][:len(seed_key)]\n\n    # XOR each Fibonacci number with the seed key\n    key = hex(int(seed_key, 16) ^ int(fib_nums[-1], 2))[2:]\n\n    return key\n\nseed_key = 'ebe42a225e8593e448d9c5457381aaf7'\ngenerated_key = generate_key_from_fibonacci(seed_key)\nprint(\"Generated Key:\", generated_key)\n```\n\nI would greatly appreciate any assistance or suggestions on how to modify my code to generate a cryptographic key using the Fibonacci sequence in Python. Thank you in advance.\nThank you for helping me.\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "I was trying to make a recursion function with python for the fibonacci sequence\r\n                \r\nThe function is supposed to return a list of the first n numbers of the fibonacci sequence, but its returning nothing and I'd like to know why\n```\n\ndef fibonacci(n, sequence=[0, 1], originalN=0):\n    print(n, sequence[:-2])\n\n    if n <= 0:\n        print(n)\n        return(sequence[:-2])\n\n    nextValue = sequence[-1] + sequence[-2]\n    sequence.append(nextValue)\n\n    \n\n    fibonacci(n-1, sequence, originalN)\n\nprint(fibonacci(10))\n```\n\nsome print functions inside the main function are left behind for debugging purposes\n    ", "Answer": "\r\nYou are missing a ```\nreturn```\n statement. The recursive calls are not returning back the slice up the recursion stack. The only reason your Fibonacci series is even building with the previous code is that they are all sharing the same list object.\n```\ndef fibonacci(n, sequence=[0, 1], originalN=0):\n    if n <= 0:\n        return (sequence[:-2])\n\n    nextValue = sequence[-1] + sequence[-2]\n    sequence.append(nextValue)\n\n    return fibonacci(n-1, sequence, originalN)\n\nprint(fibonacci(10))\n```\n\nOutput:\n```\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```\n\nEdit: To clarify, the ```\nreturn```\n statement you previously had only returned the sequence from the deepest call (leaf on the recursion tree to its parent (when n was 1), but the ```\nreturn```\n statement is also needed for the recursive call to pass this value up the recursion tree.\nYou can avoid using the recursion stack and do a more efficient Fibonacci sequence computation as follows:\n```\ndef fibonacci(n):\n    sequence = [0, 1]\n    for i in range(2, n):\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n```\n\nEdit 2: As @Clockwork-Muse recommended, a more pythonic way is to use an infinite generator instead of returning lists. You can also generate as long sequences as you want. Here is my take at this approach:\n```\ndef fib():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nsequence = fib()\n```\n\nDemo (n can be anything, as ```\nfib```\n is a generator object and will keep generating the next number in the sequence):\n```\nn = 10\nfor i in range(n):\n    print(next(sequence), end=\", \")\n```\n\nOutput: ```\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generating an infinite list of Fibonacci sequence in ML\r\n                \r\nI have to generate an infinite list containing a Fibonacci sequence. I am new to ML so I want to check if this is correct.\n\n```\n-datatype 'a infist=NIL\n=           | CONS of 'a * (unit -> 'a inflist);\n- fun fib a b = CONS (a , fn()=> fib b (a+b));\nval fib=fn: int->int-int inflist\n```\n\n\nIs this what is called a generator function?\nWill it give me an actual output i.e the infinite fib sequence when I give a and b inputs?\n    ", "Answer": "\r\nYour datatype definition and your function definition seem correct. Although I still would have preferred a Fibonacci function that does not expect any arguments, to avoid the possibility of getting wrong input:\n\n```\nfun fibonacci () = \n   let\n      fun fib(a,b) = Cons(a+b, fn() => fib(b,a+b))\n   in\n      Cons(0, fn()=> fib(0,1))\n   end  \n```\n\n\nThis is what I would call a stream\n\nWhen you invoke it, it'll give an element of type infislist. You may consider writing some other functions to process your stream and interpret its contents. You may want see some examples of this in my another answer, for example, functions like ```\ntakeWhile```\n, ```\ntake```\n, ```\nfilter```\n, ```\nzip```\n and ```\ntoList```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to implement a Fibonacci sequence in JavaScript?\r\n                \r\nI need to implement a Fibonacci sequence Оthrough a function for my homework. And I need to implement a function so that each subsequent call will output the next number in the sequence. It seems simple if you pass an argument to the function, but I'm not allowed to do that by the assignment. I have implemented this function with an argument, the code is shown below:\n\r\n\r\n```\nfunction helperFibonacci(n) {\n  let number1 = 0;\n  let number2 = 1;\n\n  for (i = 0; i < n; i++) {\n    let current = number1 + number2;\n    number1 = number2;\n    number2 = current;\n    console.log(current);\n  }\n}\n\nhelperFibonacci(2);```\n\r\n\r\n\r\n\nPlease help me implement this function without passing an argument. thanks!\n    ", "Answer": "\r\nChange ```\nnumber1```\n and ```\nnumber2```\n to global variables, and get rid of the loop.\n\r\n\r\n```\nlet number1 = 0;\nlet number2 = 1;\n\nfunction helperFibonacci() {\n  let current = number1 + number2;\n  number1 = number2;\n  number2 = current;\n  console.log(current);\n}\n\nfor (let i = 0; i < 10; i++) {\n  helperFibonacci();\n}```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Type level Fibonacci sequence results in \"overflow evaluating the requirement\"\r\n                \r\nI'm writing a type level Fibonacci sequence. I've already written a type level addition, which works fine. Every number is represented as ```\nInc<Inc<...<Zero>...>>```\n. There is a trait ```\nAdd```\n, then the structure ```\nBop<Left, Right>```\n (binary operation) implements the ```\nAdd```\n trait. The usage is that ```\n<Bop<Inc<Inc<Inc<Zero>>>, Inc<Inc<Zero>>> as Add>::Get```\n will be ```\nInc<Inc<Inc<Inc<Inc<Zero>>>>>```\n, that is 3 + 2 = 5.\n\nThen I write a Fibonacci sequence based on the addition:\n\n```\nuse std::marker::PhantomData;\nstruct Zero {}\nstruct Inc<T> {\n    _phantom: PhantomData<T>,\n}\n\nstruct Bop<Left, Right> {\n    _phantom_l: PhantomData<Left>,\n    _phantom_r: PhantomData<Right>,\n}\n\ntrait Add {\n    type Get;\n}\n\nimpl<Left> Add for Bop<Left, Zero> {\n    type Get = Left;\n}\n\nimpl<Left, RightInner> Add for Bop<Left, Inc<RightInner>>\nwhere\n    Bop<Left, RightInner>: Add,\n{\n    type Get = Inc<<Bop<Left, RightInner> as Add>::Get>;\n}\n\ntype One = Inc<Zero>;\ntype Two = Inc<One>;\ntype Three = Inc<Two>;\ntype Four = Inc<Three>;\ntype Five = Inc<Four>;\n// then <Bop<Three, Two> as Add>::Get will be type Five\n\n// 0 1 2 3 4 5 6 7\n// 0 1 1 2 3 5 8 13\n// usage: <Inc<Inc<Inc<Zero>>> as Fib>::Get should be the third fib number,\n// i.e. 2, or Inc<Inc<Zero>>\ntrait Fib {\n    type Get;\n}\nimpl Fib for Zero {\n    type Get = Zero;\n}\nimpl Fib for One {\n    type Get = One;\n}\n\nimpl<T> Fib for Inc<Inc<T>>\nwhere\n    T: Fib,\n    Inc<T>: Fib,\n    Bop<<T as Fib>::Get, <Inc<T> as Fib>::Get>: Add,\n{\n    type Get = <Bop<<T as Fib>::Get, <Inc<T> as Fib>::Get> as Add>::Get;\n}\n\nfn main() {}\n```\n\n\ncomplete example\n\nThe compiler has trouble figuring out the ```\nimpl<T> Fib for Uop<Inc<Inc<T>>>```\n part, it complains:\n\n```\nerror[E0275]: overflow evaluating the requirement `Inc<_>: Fib`\n  |\n  = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<_>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<_>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<_>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<_>>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<Inc<_>>>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<Inc<Inc<_>>>>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<_>>>>>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<_>>>>>>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<_>>>>>>>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<_>>>>>>>>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<_>>>>>>>>>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<_>>>>>>>>>>>>>`\n  = note: required because of the requirements on the impl of `Fib` for `Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<Inc<_>>>>>>>>>>>>>>`\n\n// cut off more\n```\n\n\nWhat's the reason of the error? How to resolve it?\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to make fibonacci sequence in racket using abstract list functions\r\n                \r\nI am trying to write a racket program that computes the sum of the first n terms in a fibonacci sequence without using recursion, and only using abstract list functions (so map, builld-list, foldr, foldl). I can use helper functions.\nI'm stuck on how to make a list of the fibonacci numbers without using recursion. I thought I could use a lambda function:\n\n```\n(lambda (lst) (+ (list-ref lst (- (length lst) 1)) (list-ref lst (- (length lst 2)))))\n```\n\n\nBut I am not sure how to generate the input list/how to add this to a function.\nOnce I have a fibonacci sequence I know I can just use (foldl + (car lst) (cdr lst)) to find the sum.\nCould anyone explain to me how to make the fibonacci sequence/give me a hint? \n    ", "Answer": "\r\n```\n; This is how I figure out\n#|\n(1 2 3 4 (0 1))\n-> (1 2 3 (1 1))\n-> (1 2 (1 2))\n-> (1 (2 3))\n-> (3 5)\n|#\n\n(define (fib n)\n  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [(> n 1)\n     (second\n      (foldr (λ (no-use ls) (list (second ls) (+ (first ls) (second ls))))\n             '(0 1)\n             (build-list (- n 1) (λ (x) x))))]))\n\n(fib 10)\n(build-list 10 fib)\n```\n\n\nUpgrade version 2\n\n```\n(define (fib-v2 n)\n  (first\n   (foldr (λ (no-use ls) (list (second ls) (+ (first ls) (second ls))))\n          '(0 1)\n          (build-list n (λ (x) x)))))\n\n\n(build-list 10 fib-v2)\n\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence calculations? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Create a mechanism to pass in a positive integer and display all the values of the Fibonacci series up to and including the specified value\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nHow would I create a mechanism to pass in a positive integer and display the operand, the Fibonacci series number of the operand and the sum of all the values of the Fibonacci series up to and including the specified value?\n\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <link type=\"text/css\" rel=\"stylesheet\" href=\"main.css\"/>\n        <title>Fib Activity 3</title>\n    </head>\n    <body>\n        <h1>Pick Category Using GET</h1>\n        <a href=\"ISDWK4.php?cat=Films\">Films</a>\n        <a href=\"ISDWK4.php?cat=Music\">Music</a>\n        <a href=\"ISDWK4.php?cat=Books\">Books</a>\n        <br />\n\n        <h2>Fibonacci</h2>\n        <form method=\"get\" action=\"fib3.php\">\n            <fieldset>\n\n<label for=\"powerof\">Fibonacci: </label>\n<input type=\"text\" name=\"powerof\" value=\"<?php echo $_GET['powerof']; ?>\"/>\n<input type=\"submit\" name='Go' value=\"Calculate\" />\n</fieldset>\n</form>\n<?php\n$message = 'The fibonacci sequence is: <br />1<br />2<br />';\n$powerof = 0;\n$max = 10;\n$temp = $max;\n\nif (isset($_GET['powerof'])) {\n    $powerof = $_GET['powerof'];\n}\n\nif ($powerof > 100) {\n    $powerof = 100;\n    $message = 'Sorry, your input was too high. I converted it to the maximum value of 100.<br />The fibonacci sequence is: <br />1<br />2<br />';\n\n}\n\n$x = 0;\n$y = 1;\n$z = 0;\n$counter = 0;\n\n\nwhile ($counter < $powerof) {\n    if ($counter <= 1) {\n        $z = 1;\n    } else {\n        $z = $x + $y;\n    }\n    echo ($z. \"<br />\"); \n    $x = $y;\n    $y = $z;\n    $counter++;\n}\n\n?>\n\n    </body>\n</html>\n```\n\n\nall help is appreciated\n    ", "Answer": "\r\nFirst off, you aren't quite getting the Fibonacci series correct. The first number in the Fibonacci series is 0. The script I wrote here assumes that $powerof needs to be at least 1 (this can be easily changed if you need).\n\nI also wrote this using a recursive function which takes the number you are going to. the first number, and the second number. It will loop through by calling itself and each time, it will print out the fibonacci series at the number.\n\n```\n<?php\n\n$powerof = 0;\n\nif (isset($_GET['powerof'])) {\n    $powerof = $_GET['powerof'];\n}\n\n$message = 'The fibonacci sequence is:';\n\nif ($powerof > 100) {\n    $powerof = 100;\n    $message = 'Sorry, your input was too high. I converted it to the maximum value of 100.<br />The fibonacci sequence is:';\n}\n\necho $message;\n\n$first = 0;\n$second = 1;\n\nif ($powerof > 1) {\n    echo '<br>0<br>1';\n} else if ($powerof < 1) {\n    echo ' Invalid input';\n} else {\n    fib($powerof, $first, $second);\n}\n\nfunction fib($powerof, $first, $second) {\n    if( $powerof > 0 ) {\n         $sum = $first + $second;\n         $first = $second;\n         $second = $sum;\n         echo $sum.'<br>';\n         fib($n-1, $first, $second);\n    }\n}\n\n?>\n```\n\n\nI hope this all makes sense, if you have any more questions, let me know\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "using fibonacci sequence to print out words\r\n                \r\nI am writing a program where it prints out how the frequency of a word as long as the frequency is in the fibonacci sequence (1,2,3,5,8,etc). I have figured out how to print all the words that appear once, however I am having trouble figuring out how to iterate so it prints out the words that have a higher freqeuncy.\n\n```\nimport string\nimport itertools\n\ndef fib():\n    a,b = 0, 1\n    while 1:\n        yield b\n        a, b = b, a + b\n\nwhile True:\n    filename = raw_input('Enter a file name: ')\n    if filename == 'exit':\n        break\n    try:\n        file = open(filename, 'r') \n        text = file.read() \n        file.close() \n    except:\n        print('file does not exist')\n    else:\n\n        for word in string.punctuation:\n            text=text.replace(word, \"\")\n        word_list = text.lower().split(None)\n        word_freq = {}\n\n        for word in word_list:\n            if len(word) > 1:\n                word_freq[word] = word_freq.get(word, 0) + 1\n\n        frequencies = sorted(word_freq.items(), key=lambda item: item[1])\n        a = fib()\n        order = sorted(word_freq.values())\n        n = 1\n        a = next(a)\n        for words in frequencies:\n            try:\n                if a == words.index(n):\n                    print(words)\n            except:\n                print('nope')  # HELP: how would I iterate here??\n\n\nprint('Bye')\n```\n\n    ", "Answer": "\r\nTry changing the end of your ```\nwhile```\n loop to the following:\n\n```\n    f = next(a)\n    for words in frequencies:\n        # we need a new value from fib, since we have passed the current one\n        while words[1] > f:\n            f = next(a)\n        # if the frequency of this word matches the fib value, print it\n        if words[1] == f:\n            print(words)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to print the Fibonacci sequence in Swift Playground using recursion\r\n                \r\nI am trying to use recursion in Swift to print out the Fibonacci sequence for a number \"n\" iterations. However, I keep getting the same error.\n\nI have already tried doing it without recursion and was able to do it. However, I am now trying to do in a more complex and \"computer scientisty\" way by using recursion.\n\n```\nfunc fibonacciSequence (n: Int) -> [Int]  {\n\n// Consumes a number \"n\", which is the number of iterations to go through with the Fibonacci formula and prints such sequence.\n\n    var fibonacciArray = [Int]()\n\n    for n in 0 ... n {\n\n        if n == 0 {\n            fibonacciArray.append(0)\n        }\n        else if n == 1 {\n            fibonacciArray.append(1)\n        }\n        else {\n            fibonacciArray.append (fibonacciSequence(n: (n - 1)) +\n            fibonacciSequence(n: (n-2)))\n        }\n    }\n    return fibonacciArray\n```\n\n\nI expect to call the function with a number n and for the function to print out the Fibonacci sequence. Example: if n = 5, I expect the console to print 0, 1, 1, 2, 3, 5. The error I get is this: (Cannot convert value of type '[Int]' to expected argument type 'Int').\n    ", "Answer": "\r\nAs pointed out above, the return value is causing an error when summed. A possible way (but not recursive) of fixing the code would be to simply change the ```\nelse```\n statement:\n\n```\nfunc fibonacciSequence (n: Int) -> [Int]  {\n\n    // Consumes a number \"n\", which is the number of iterations to go through with the Fibonacci formula and prints such sequence.\n\n    var fibonacciArray = [Int]()\n\n    for n in 0 ... n {\n\n        if n == 0 {\n            fibonacciArray.append(0)\n        }\n        else if n == 1 {\n            fibonacciArray.append(1)\n        }\n        else {\n            fibonacciArray.append (fibonacciArray[n-1] + fibonacciArray[n-2] )\n        }\n    }\n    return fibonacciArray\n}\n\n```\n\n\nA recursive solution would be the following:\n\n```\n\nfunc fibonacciSequence (n: Int, sumOne: Int, sumTwo: Int, counter: Int, start: Bool) {\n\n    if start {\n        print(0)\n        print(1)\n    }\n    if counter == -1 {\n        print(1)\n    }\n    if (counter == n - 2) {\n        return\n    }\n    let sum = sumOne + sumTwo\n    print(sum)\n\n    fibonacciSequence(n: n, sumOne: sumTwo , sumTwo: sum, counter: counter + 1, start: false)\n}\n\nfibonacciSequence(n: 8, sumOne: 0, sumTwo: 1, counter: 0, start: true)\n\n```\n\n\nThere is probably a \"nicer\" way, but I hope it helps. Cheers.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Correct way to return list of fibonacci sequence using recursion\r\n                \r\nI understand how to return a Fibonacci sequence using the iterative approach,\nas well as the dynamic programming approach.\nWith recursion, I understand the recursion tree for Fibonacci.\nand how to return Nth Fibonacci number\n```\ndef fib(num):\n    if num <= 2: \n        return num \n\n    return fib(num -1) + fib(num-2)\n\nprint(fib(5))\n```\n\nThe above code returns ```\n8```\n which is great,\nbut I want to understand how could I return a list of the sequence\nby updating the above recursive code.\n```\neg: [1,1,2,3,5,8]\n```\n\n    ", "Answer": "\r\nWorking with a Fibonacci sequence that begins with 0, we can rewrite your code recursively, without any external data, by doing:\n```\ndef fib(index):\n    if index <= 2:\n        return [0, 1][:index]\n\n    sequence = fib(index - 1)\n\n    sequence.append(sum(sequence[-2:]))\n\n    return sequence\n\nprint(fib(11))\n```\n\nOUTPUT\n```\n> python3 test.py\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>\n```\n\nBut as @TomKarzes comments, there are much better algorithms.  But since you insist on doing this recursively, efficiency isn't a primary concern.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "C Fibonacci Sequence in Array Segmentation Fault\r\n                \r\nI want to fill an array up to n digits of the Fibonacci sequence. Here's what I have so far:\n\n```\nvoid fib(int **seq, int n){\n    seq = malloc(sizeof(int)*n);\n\n    if(n==1){\n        *seq[0] = 0;\n    }\n\n    if(n==2){\n        *seq[0] = 0;\n        *seq[1] = 1;\n    }\n\n    if(n>=3){\n        *seq[0] = 0;\n        *seq[1] = 1;\n        *seq[2] = 1;\n        for(int i=3; i<n; i++){\n            *seq[i] = *seq[i-1]+*seq[i-2];\n        }\n\n    }\n}\n```\n\n\nI've tested the basic algorithm in Python and it works as expected, but in C I'm getting a segmentation fault and I'm not sure where that is coming from.\n\nAny help would be appreciated.\n    ", "Answer": "\r\nYour program is correct on most parts except for the following errors:\n\n(1) Repalce\n\n```\nseq = malloc(sizeof(int)*n);```\n\n\nwith\n\n```\n*seq = malloc(sizeof(int)*n);```\n\n\nNote that you should not be allocating memory to the double pointer.  You should be allocating the memory to the pointer pointed by 'seq'.\n\n(2) Replace all the statements like\n\n```\n*seq[i]...```\n\n\nwith\n\n```\n(*seq)[i]```\n\n\nNote that [] has a stronger affinity than *. So you need to surround *seq with parenthesis on all the instances. \n\n(3) You haven't shown how you invoke this function. But I am assuming that you are allocating memory to the double pointer before calling the function.\n\nHere's a working program for your reference:\n\n```\n#include <stdio.h>\n\nvoid fib(int **seq, int n);\n\nint main()\n{\n    int ** sequence = malloc(sizeof(int*));       \n\n    fib(sequence, 5);\n    for(int x = 0; x < 5; x++)\n       printf(\"%d\", (*sequence)[x]);\n    return 0;\n}\n\nvoid fib(int **seq, int n){\n    *seq = malloc(sizeof(int)*n);\n\n    if(n==1){\n        (*seq)[0] = 0;\n    }\n\n    if(n==2){\n        (*seq)[0] = 0;\n        (*seq)[1] = 1;\n    }\n\n    if(n>=3){\n        (*seq)[0] = 0;\n        (*seq)[1] = 1;\n        (*seq)[2] = 1;\n        for(int i=3; i<n; i++){\n            (*seq)[i] = (*seq)[i-1]+(*seq)[i-2];\n        }\n\n    }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "calculate fibonacci sequence position from user inserted value\r\n                \r\nBelow is my full program's code:\n\n```\nGradeAvg = [[59, 'F'], [69, 'D'], [79, 'C'], [89, 'B'], [100, 'A']]\n\ndef letter_grade\n  num = number_grade\n  _, letter = GradeAvg.find { |n, _| num <= n }\n  [num, letter]\nend\n\ndef number_grade\n  loop do\n    puts 'Please insert a number between 1 and 100.'\n    num = gets.to_i\n    break(num) if (1..100).cover?(num)\n  end\nend\n\ndef fib(n)\n  return n if n < 2\n\n  fib(n-1) + fib(n-2)\nend\n\n10.times { print letter_grade; (num).each { |n| puts fib(n) }; puts }\n```\n\n\nIt is failing with the below error:\n\n```\nundefined local variable or method `num' for main:Object (NameError)\n```\n\n\nWhy can't I apply my fibonacci sequence calculation on my acceptable user inserted value in variable ```\nnum```\n?\n    ", "Answer": "\r\nYou're trying to access ```\nnum```\n which is assigned in ```\nletter_grade```\n. You must use the return value of the function call (ie ```\nnum, letter = letter_grade```\n) to read the result.\n\nIt should also be noted that ```\nFixnum#each```\n (ie ```\n(num).each```\n) is not a method. ```\n10.times { ... }```\n already makes a loop though, so I think this was just an oversight on your part.\n\nSee the bolded section for changes. I also changed your fibonacci function to calculate in linear time (instead of exponential time)\n\n```\nGradeAvg = [[59, 'F'], [69, 'D'], [79, 'C'], [89, 'B'], [100, 'A']]\n\ndef number_grade\n  loop do\n    print \"Please insert a number between 1 and 100.\"\n    num = gets.to_i\n    break(num) if (1..100).cover?(num)\n  end\nend\n\ndef letter_grade\n  num = number_grade\n  _, letter = GradeAvg.find { |n, _| num <= n }\n  [num, letter]\nend\n\ndef fib (n, a = 0, b = 1)\n  if n == 0 then\n    a\n  else\n    fib n - 1, b, a + b\n  end\nend\n\n10.times do\n  num, letter = letter_grade\n  puts letter\n  puts (fib num)\nend```\n\n\nExample program execution\n\n```\n# Please insert a number between 1 and 100. 95\n# A\n# 31940434634990099905\n# Please insert a number between 1 and 100. 87\n# B\n# 679891637638612258\n# Please insert a number between 1 and 100. 77\n# C\n# 5527939700884757\n# Please insert a number between 1 and 100. 66\n# D\n# 27777890035288\n# Please insert a number between 1 and 100. 55\n# F\n# 139583862445\n# Please insert a number between 1 and 100. 10\n# F\n# 55\n# Please insert a number between 1 and 100. ...\n# ...\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Infinite Fibonacci Sequence with Memoized in Java 8\r\n                \r\nFirstly, I'm a JavaScript programmer, and fairly new to Java8 and trying the new functional feature.\n\nSince I expertise JS coding, I implemented my own JS lazy-functional library for proof of concept.\n\nhttps://github.com/kenokabe/spacetime\n\nUsing the library, I could write Infinite sequence of Natural numbers and Fibonacci as below: \n\nJavaScript\n\n```\nvar spacetime = require('./spacetime');\nvar _ = spacetime.lazy(); \n\nvar natural = _(function(n)   //memoized automatically\n{\n  return n;    // Natural numbers is defined as the `n`th number becomes `n`\n});\n\nvar natural10 = _(natural)\n  .take(10)\n  .compute(function(x)\n  {\n    console.log(x);\n  });\n\n\n//wrap a recursive function to memoize\n// must be at the definition in the same scope\nvar fib = _(function(n)\n{\n  if (n <= 1)\n    return 1; // as the Fib definition in Math\n  else\n    return fib(n - 2) + fib(n - 1); // as the Fib definition in Math\n});\n\nvar fib10 = _(fib)\n  .take(10)\n  .compute(function(x)\n  {\n    console.log(x);\n  });\n```\n\n\nClear enough. The point is that I can define Natural/Fibonacci infinite sequence as the math definition as it is, then later compute the required part of the infinite sequence with lazy-evaluation.\n\nSo, now I wonder if I can do the same manner with Java8.\n\nFor natural sequence, I had post another Question here.\n\nInfinite sequence of Natural numbers with Java8 generator\n\nOne of the way to define Natural sequence is to use ```\niterator```\n of Java8:\n\nJava8\n\n```\nIntStream natural = IntStream.iterate(0, i -> i + 1);\n\nnatural\n .limit(10)\n .forEach(System.out::println);\n```\n\n\nI observe ```\nIntStream natural = IntStream.iterate(0, i -> i + 1);```\n is a fair definition of natural numbers in math sense.\n\nHowever, I wonder if it's possible to define it as I did before, that is,\n\nJavaScript\n\n```\nvar natural = _(function(n)   //memoized automatically\n    {\n      return n;    // Natural numbers is defined as the `n`th number becomes `n`\n    });\n```\n\n\nbecause this looks more concise. Unfortunately, the answers suggest it's probably not possible even we use ```\ngenerate```\n.\n\nIn addition, ```\nIntStream.iterate```\n does not fit for Fibonacci sequence.\n\nI seek web to ```\ngenerate```\n indefinite sequence of  Fibonacci, the best results I found are\n\nhttp://blog.informatech.cr/2013/05/08/memoized-fibonacci-numbers-with-java-8/\n\nJava8\n\n```\nprivate static Map<Integer,Long> memo = new HashMap<>();\nstatic {\n   memo.put(0,0L); //fibonacci(0)\n   memo.put(1,1L); //fibonacci(1)\n}\n\n//And for the inductive step all we have to do is redefine our Fibonacci function as follows:\n\npublic static long fibonacci(int x) {\n   return memo.computeIfAbsent(x, n -> fibonacci(n-1) + fibonacci(n-2));\n}\n```\n\n\nThis is not an infinite sequence (lazy ```\nStream```\n in Java8).\n\nand\n\nProviding Limit condition on Stream generation\n\nJava8\n\n```\nStream.generate(new Supplier<Long>() {\n    private long n1 = 1;\n    private long n2 = 2;\n\n    @Override\n    public Long get() {\n        long fibonacci = n1;\n        long n3 = n2 + n1;\n        n1 = n2;\n        n2 = n3;\n        return fibonacci;\n    }\n}).limit(50).forEach(System.out::println);\n```\n\n\nThis is an infinite sequence (lazy ```\nStream```\n in Java8), and you could say it's defined as Math.\nHowever I do not like this implementation because, as you can see, there are many internal valuable to obtain the sequence such as ```\nn1```\n ```\nn2```\n ```\nn3```\n then ```\nfibonacci```\n, accordingly the code structure is complicated and you need to control mutable state which is anti-functional manner - unlike the math definition, and probably this is not memoized.\n\nSo, here's my question. With Java8 ```\nStream```\n, is there any way to write a code to define the infinite sequence of fibonacci in concise math manner with memoization like\n\nJavaScript\n\n```\n var fib = _(function(n)\n    {\n      if (n <= 1)\n        return 1; // as the Fib definition in Math\n      else\n        return fib(n - 2) + fib(n - 1); // as the Fib definition in Math\n    });\n```\n\n\nThanks for your thought.\n    ", "Answer": "\r\nYou can take your map-based memoized fibonacci(x) and make an infinite stream out of it like this:\n\n```\nLongStream fibs = IntStream.iterate(1, i->i+1).mapToLong(i -> fibonacci(i));\n```\n\n\nBut the easiest way to make an infinite stream of fibonacci numbers is like this:\n\n```\nLongStream fibs = Stream.iterate(\n        new long[]{1, 1},\n        f -> new long[]{f[1], f[0] + f[1]}\n).mapToLong(f -> f[0]);\n```\n\n\nAs the article you linked to points out, \"infinite\" really means \"until long overflows\" which happens quickly.  If you want to generate hundreds of fibonacci numbers, replace long with BigInteger:\n\n```\n    Stream<BigInteger> bigFibs = Stream.iterate(\n            new BigInteger[]{BigInteger.ONE, BigInteger.ONE},\n            f -> new BigInteger[]{f[1], f[0].add(f[1])}\n    ).map(f -> f[0]);\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Check if arraylist is part of fibonacci sequence c#\r\n                \r\nI found on this link similar solution Java: check if arraylist is part of fibonacci sequence, but I want that in c#. I tray to convert that in c# but it doesn't work. Can someone help me and tell me where I'm wrong.\n\n```\nstatic void Main(string[] args)\n    {\n        List<int> list = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13, 21 };\n        Console.WriteLine(isFibonacci(list));\n        Console.ReadLine();\n    }\n public static bool isFibonacci(List<int> arr)\n    {\n\n        if (arr.Count() < 3)\n        {\n            return false;\n        }\n\n        int fib1 = 0;\n        int fib2 = 1;\n\n        while (fib1 < arr.IndexOf(0))\n        {\n            int tmp = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = tmp;\n        }\n\n        if (fib1 != arr.IndexOf(0))\n        {\n            return false;\n        }\n\n        if (fib2 != arr.IndexOf(1))\n        {\n            return false;\n        }\n\n        for (int i = 2; i < arr.Count(); i++)\n        {\n            if (arr.IndexOf(i) < 0)\n                return false;\n\n            // I think that problem is in this part of code\n            if (arr.IndexOf(i) != (arr.IndexOf(i - 1) + arr.IndexOf(i - 2))) \n                return false;\n        }\n        return true;\n     }\n```\n\n    ", "Answer": "\r\nThe List.IndexOf method returns the index of the element specified as arguments: https://msdn.microsoft.com/en-us/library/e4w08k17%28v=vs.110%29.aspx \n\nDidn't you rather want to get the element at the specified index, which would be arr[i]?\n\nUpdated source code:\n\n```\nstatic void Main(string[] args)\n    {\n        List<int> list = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13, 21 };\n        Console.WriteLine(isFibonacci(list));\n        Console.ReadLine();\n    }\n\n    public static bool isFibonacci(List<int> arr)\n    {\n\n        if (arr.Count() < 3)\n        {\n            return false;\n        }\n\n        int fib1 = 0;\n        int fib2 = 1;\n\n        while (fib1 < arr[0])\n        {\n            int tmp = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = tmp;\n        }\n\n        if (fib1 != arr[0])\n        {\n            return false;\n        }\n\n        if (fib2 != arr[1])\n        {\n            return false;\n        }\n\n        for (int i = 2; i < arr.Count(); i++)\n        {\n            if (arr[i] < 0)\n                return false;\n\n            // I think that problem is in this part of code\n            if (arr[i] != (arr[i - 1] + arr[i - 2]))\n                return false;\n        }\n        return true;\n    }\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Systems Dynamics in AnyLogic - Fibonacci sequence [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed last year.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have a systems dynamics model in AnyLogic in which I'm trying to model the Fibonacci sequence. Yet, for some reason, my results differ from the expected ones:  \n\nInstead of\n\n\n  1,1,2,3,5,8,13... \n\n\nI get \n\n\n  1, 2.137954153, 4.021788196, 7.471205823, 13.86070806...\n\n\nI followed these (spanish) instructions to build my simple model. \n\nI suppose this is not common to all software because in VenSim this example seems to work perfectly...\n\nCan somebody explain to me why this happens in my AnyLogic program?\n    ", "Answer": "\r\nThe reason why this happens is because of the way differential equations are handled in each Software.\nThe reason you are getting the fibonacci sequence in vensim is because you are using Euler method with time step 1 (check in model settings)\nIf you change the integration type to RK45 in Vensim or if you reduce the time step using euler's method, you will probably get the same results as AnyLogic gets... Runge-Kutta method even though it starts with the fixed step of 1, it later changes the time step depending on the requirements of the dynamics of the model.\nNow, let's understand that using a time-step of 1 in a System Dynamics model, with the model giving you wrong results with lower timesteps, means that your model is not very robust... But THAT'S WHy you get exact values in vensim... because those exact values are really extremely inaccurate for what the model really is. I would even say that the model on your link is a bad model and shouldn't be ever shown to the public.\nFortunately (or unfortunately), AnyLogic doesn't allow you to do that. You can set up a time step of 1 in the model properties, but anylogic will change the time step to something else without notice (unless you run in virtual mode, and other conditions are met)... AnyLogic only allows to use Euler+Newton in the mixed equations option, but not Euler alone.\nI consider this a bug in AnyLogic that has persisted for many years and I have informed it to them, and I don't think they will ever solve it, until maybe AnyLogic 9 if we are lucky.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Check if arraylist is part of fibonacci sequence c#\r\n                \r\nI found on this link similar solution Java: check if arraylist is part of fibonacci sequence, but I want that in c#. I tray to convert that in c# but it doesn't work. Can someone help me and tell me where I'm wrong.\n\n```\nstatic void Main(string[] args)\n    {\n        List<int> list = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13, 21 };\n        Console.WriteLine(isFibonacci(list));\n        Console.ReadLine();\n    }\n public static bool isFibonacci(List<int> arr)\n    {\n\n        if (arr.Count() < 3)\n        {\n            return false;\n        }\n\n        int fib1 = 0;\n        int fib2 = 1;\n\n        while (fib1 < arr.IndexOf(0))\n        {\n            int tmp = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = tmp;\n        }\n\n        if (fib1 != arr.IndexOf(0))\n        {\n            return false;\n        }\n\n        if (fib2 != arr.IndexOf(1))\n        {\n            return false;\n        }\n\n        for (int i = 2; i < arr.Count(); i++)\n        {\n            if (arr.IndexOf(i) < 0)\n                return false;\n\n            // I think that problem is in this part of code\n            if (arr.IndexOf(i) != (arr.IndexOf(i - 1) + arr.IndexOf(i - 2))) \n                return false;\n        }\n        return true;\n     }\n```\n\n    ", "Answer": "\r\nThe List.IndexOf method returns the index of the element specified as arguments: https://msdn.microsoft.com/en-us/library/e4w08k17%28v=vs.110%29.aspx \n\nDidn't you rather want to get the element at the specified index, which would be arr[i]?\n\nUpdated source code:\n\n```\nstatic void Main(string[] args)\n    {\n        List<int> list = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13, 21 };\n        Console.WriteLine(isFibonacci(list));\n        Console.ReadLine();\n    }\n\n    public static bool isFibonacci(List<int> arr)\n    {\n\n        if (arr.Count() < 3)\n        {\n            return false;\n        }\n\n        int fib1 = 0;\n        int fib2 = 1;\n\n        while (fib1 < arr[0])\n        {\n            int tmp = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = tmp;\n        }\n\n        if (fib1 != arr[0])\n        {\n            return false;\n        }\n\n        if (fib2 != arr[1])\n        {\n            return false;\n        }\n\n        for (int i = 2; i < arr.Count(); i++)\n        {\n            if (arr[i] < 0)\n                return false;\n\n            // I think that problem is in this part of code\n            if (arr[i] != (arr[i - 1] + arr[i - 2]))\n                return false;\n        }\n        return true;\n    }\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How do I make this Fibonacci sequence generator more elegant?\r\n                \r\n```\npackage main\n\nimport \"fmt\"\n\nfunc fib_seq() func() int {\n    n0, n1 := 0, 1\n\n    return func() int {\n        result := n0\n        n0, n1 = n1, n0 + n1\n        return result\n    }\n}\n\nfunc main() {\n    f := fib_seq()\n    for i := 0; i < 10; i++ {\n        fmt.Println(f())\n    }\n}\n```\n\n\nThis is my Fibonacci sequence generator. The definition of ```\nresult```\n is unwanted (but necessary).\n\nI wonder is there a way to execute ```\nx, y = y, x + y```\n after ```\nreturn```\n?\n    ", "Answer": "\r\nYou may want to take a look at ```\ndefer```\n:\n\n```\nfunc fib_seq() func() int {\n    n0, n1 := 0, 1\n\n    return func() int {\n        defer func() {\n            n0, n1 = n1, n0 + n1\n        }()\n\n        return n0\n    }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Can't Get Correct Fibonacci Sequence From Scala Code\r\n                \r\nI have written the following code to print the first 10 numbers in a Fibonacci sequence. I am expecting an output of 0,1,1,2,3,5,8,13,21,34. Instead I get 0,1,2,3,5,8,13,21,34,55. Here is the code - \n\n```\nvar a = 0\nvar b = 0\nvar i = 0\n\nwhile(i < 10) {\n  val c = a +b\n a = b\n b = c\n i = i + 1\n if (a < 1) a = 1\n\nprintln(b)\n }\n```\n\n    ", "Answer": "\r\nThis should work:\n\n```\nvar a = 0 \nvar b = 1 \nvar i = 0 \n\nwhile(i < 10) {\n  println(a)\n  val c = a + b \n  a = b \n  b = c \n  i = i + 1 \n}\n```\n\n\nbut this is not functional and so not really scala\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Use map(v, reduce) to create Fibonacci sequence in R?\r\n                \r\nI was wondering if we could use ```\npurrr```\n's ```\nmap```\n and ```\nreduce```\n to create to Fibonacci function akin to this one in JavaScript:\n\n```\nfunction fib(n){\n  return new Array(n).fill(1).reduce((arr, _ ,i) => {\n    arr.push((i <= 1) ? i : arr[i-2] + arr[i-1])\n    return arr\n  },[]) ;\n}\nconsole.log(fib(10))\n```\n\n\nI see answers here Fibonacci Sequence in R that use recursion but I was wondering if we could specifically use purrr's ```\nreduce```\n and if so how?\n    ", "Answer": "\r\nI think ```\npurrr::accumulate()```\n is better suited for the task:\n\n```\nn <- 10                                         # Desired number of values\npurrr::accumulate( .init = c(0L,1L),            # Starting with (0,1)\n                   rep(0,n),                    # Accumulate n times\n                   ~c(.x,sum(.x))[2:3]          # (x,y) -> (x, y, x+y)[2:3]\n                 ) %>% \n    purrr::map_int( `[`, 1 )                    # (x,y) -> x\n\n# [1]  0  1  1  2  3  5  8 13 21 34 55\n```\n\n\nThe key to this solution is to keep pairs of values throughout the ```\naccumulate()```\n call: ```\n(0,1)```\n, ```\n(1,1)```\n, ```\n(1,2)```\n, etc., since you need two previous values to compute the new one.\n\nThis is followed by retrieving the first element of each pair.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How do I generate the Fibonacci sequence without using a list? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     \r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n                        \r\n                                Questions concerning problems with code you've written must describe the specific problem — and include valid code to reproduce it — in the question itself. See SSCCE.org for guidance.\r\n                                Questions asking for code must demonstrate a minimal understanding of the problem being solved. Include attempted solutions, why they didn't work, and the expected results. See also: Stack Overflow question checklist\r\n                        \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have been asked the following: \n\n\n  Using a while-loop, write a program that generates a Fibonacci\n  sequence of integers. Your program should ask the user how many\n  Fibonacci sequence entries to generate and print this quantity of them\n  to the screen.\n\n\nI don't know where to begin.  Can someone point me in the right direction?\n    ", "Answer": "\r\nuse a variable to hold last value and current value, print the current value, and then update the last value... don't want to write it for you :)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to check if an array contains a Fibonacci sequence?\r\n                \r\nI have this code below where I generate a fibonacci sequence that stops based on the highest number in NSArray numbers. I am trying to check if the numbers in the numbers array are all fibonacci numbers. How do I compare the numbers and fibonacciArray so that my function will return yes if the numbers are all fibonacci numbers or no if some of the numbers in numbers array are not fibonacci numbers?\n\nEDIT: Here are the example test arrays if that helps..\n\n```\n [self onlyFibonacciValues:@[@21, @2, @8, @3]];\n [self onlyFibonacciValues:@[@21, @6, @2]];\n\n\n- (BOOL)onlyFibonacciValues:(NSArray *)numbers {\n\nNSArray *newNumbers = [numbers sortedArrayUsingDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@\"intValue\" ascending:YES]]];\nNSMutableArray *sortedArray = [newNumbers mutableCopy];\n\nNSInteger firstFibonacci = 1;\nNSInteger secondFibonacci = 2;\n\nNSInteger lastObjectInArray = [sortedArray.lastObject integerValue];\n\nNSMutableArray *fibonacciArray = [NSMutableArray new];\n[fibonacciArray addObject:[NSNumber numberWithInteger:firstFibonacci]];\n[fibonacciArray addObject:[NSNumber numberWithInteger:secondFibonacci]];\n\nwhile (lastObjectInArray > secondFibonacci) {\n\n    secondFibonacci = secondFibonacci + firstFibonacci;\n    firstFibonacci = secondFibonacci - firstFibonacci;\n\n    [fibonacciArray addObject:[NSNumber numberWithInteger:secondFibonacci]];\n\n}\n\nreturn YES;\n}\n```\n\n    ", "Answer": "\r\nIt is not necessary to generate an all new array of Fibonacci numbers in order to check the values from the current array. All you need to do is to walk through elements of the current array, checking each element to the next Fibonacci number. You can do it in a single loop:\n\n```\nint curr = 1, prev = 1;\nfor (NSNumber *n in newNumbers) { // You do not need a mutable copy of the sorted array\n    int v = [n intValue];\n    while (curr < v) {\n        curr += prev;\n        prev = curr-prev;\n    }\n    // At this point curr is the next Fibonacci number\n    // which is greater than or equal to the current value\n    // in the array. Holes and duplicates are allowed.\n    if (curr != v) return NO;\n}\nreturn YES;\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Does the number belong in the fibonacci sequence?\r\n                \r\nA Ke-number is an integer 10≤n≤99 such that, if we start a Fibonacci sequence with its digits, the sequence contains n.\nFor example, 47 is a Ke-number because the sequence starts like this: 4,7,11,18,29,47, coming to the number itself.\nI'm trying to define the recursive function ke_number that takes a two-digit integer and checks if it is a Ke-number. (True or False)\nI got it to work like this:\n```\ndef ke_number(n):\n n1 = int(str(n)[0])\n n2 = int(str(n)[1])\n return n in [fib(i,n1,n2) for i in range(1,100)]\n\n\ndef fib(n, a, b):\n  if n==0 or n==1:\n    return b\n  return fib(n-1, b, a+b)\n\n```\n\nBut as you can see, it's not just one function, it's two.\nHow can I transform this into just one recursive function?\n    ", "Answer": "\r\nRecursive solution:\nTry it online!\n```\ndef ke_number(n, a = None, b = None):\n    if a is None:\n        return ke_number(n, n // 10, n % 10)\n    if a < n:\n        return ke_number(n, b, a + b)\n    return a == n\n\nprint(ke_number(47))\nprint(ke_number(46))\n```\n\nOutput:\n```\nTrue    # for 47\nFalse   # for 46\n```\n\n\nWith function above if you do:\nTry it online!\n```\nfor i in range(10, 100):\n    if ke_number(i):\n        print(i)\n```\n\nyou'll get all Ke numbers:\n```\n14\n19\n28\n47\n61\n75\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence using loop and recur\r\n                \r\nI am doing the Project Euler challenge in Clojure and I want to find the sum of all the even numbers in a fibonacci sequence up to a certain number.\n\nThe code for a function that does this is below. I know there are quicker and easier ways of doing this, I am just experimenting with recursion using loop and recur. However the code doesn't seem to work it never returns an answer. \n\n```\n(defn fib-even-sum [upto]\n  (loop [previous 1 nxt 1 sum 0]\n    (if (or (<= upto 1) (>= nxt upto))\n     sum)\n    (if (= (mod nxt 2) 0)\n       (recur nxt (+ previous nxt) (+ sum nxt))\n       (recur nxt (+ previous nxt) sum))))\n```\n\n\nI was not sure if I could do recur twice in the same loop or not. I'm not sure if this is causing the problem?\n    ", "Answer": "\r\nYou have a misplaced closing paren in the first IF (after ```\nsum```\n)...\n\n```\n(defn fib-even-sum [upto]\n  (loop [previous 1 nxt 1 sum 0]\n    (if (or (<= upto 1) (>= nxt upto))\n        sum\n        (if (= (mod nxt 2) 0)\n           (recur nxt (+ previous nxt) (+ sum nxt))\n           (recur nxt (+ previous nxt) sum)))))\n```\n\n\nNow it works and fast\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Problems in memoization Fibonacci sequences in Python\r\n                \r\nI am implementing a Fibonacci sequence with Python. And I used an array (\"[]\") for memoization, but I get an ```\nIndexError: list assignment index out of range```\n.\n\nHowever, using an object (\"{}\") works fine. What's the difference?\n\ncode\n\n```\ndef fib(n):\n    if n <= 1:\n        memo[n] = n\n\n    if n not in memo:\n        memo[n] = fib(n-2) + fib(n-1)\n\n    return memo[n]\n\n\n# memo = [] not work.\n# memo = {} work.\n\nprint(fib(6))\n```\n\n    ", "Answer": "\r\nwhen you do memo = [] it doesn't have any elements in it.\nand when you send fib(2) its actually doing\n\n```\nmemo[2] = n\n```\n\n\nwhich will throw an error list index out of range, because memo doesnt have any element at index 2\n\nWhen you do memo = {}, its creating a dict and \n\n```\nmemo[2] = n\n```\n\n\nwill add a new key 2 with value n it it. like this:\n\n```\nmemo = {\n  2: n\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to generate Fibonacci sequence from first and second values?\r\n                \r\nHow to recursively generate Fibonacci sequence from first and second values? For ```\nfib(int f0, int f1, int n)```\n where ```\nf0```\n is first value of sequence and ```\nf1```\n the second, what should the code look like?\nI tried this but it doesn't work:\n```\npublic static int fib(int f0, int f1, int n)\n{\nif (n == f0){\n        return f0;\n    }\nif (n == f1){\n        return f1;\n    }\nreturn fib(f0, f1, n-1) + fib(f0, f1, n-2);\n}\n```\n\n    ", "Answer": "\r\nHere is one way.  Just supply the first and second value and the number of terms to print.\n```\nfib(0,1, 12);\n    \npublic static void fib(int first, int second, int nTerms) {\n    System.out.println(first);\n    if(nTerms == 0) {\n        return;\n    }\n    fib(second, first+second, --nTerms);\n}\n```\n\nprints\n```\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why does the fibonacci recursive sequence work?\r\n                \r\nI am wondering why this Fibonacci recursive function works:\n\n```\nint fibRec(int n)\n{\n    if ((n == 1) || (n == 0))\n    {\n        return n;\n    }\n\n    int i = fibRec(n - 1) + fibRec(n - 2);\n    return i;\n}\n```\n\n\nI understand what the Fibonacci sequence is and I understand what a recursive function does and how this function is working. I'm just having troubles understanding why it works. I know that when you break it down, you are essentially adding a bunch of 0s and 1s, as this image depicts.\n\nfibonacci recursive\n\nBut why is it that when I pass a 5 to the function and all the 0 and 1s are added that it will equal the 5th sequence number in the Fibonacci sequence? I've seen this question asked before but never really explained. The responses are all just \"because recursion\". Yes, I know what a recursive function is and how this one is working. But WHY does this recursive function give you the correct Fibonacci sequence number?\n    ", "Answer": "\r\nIn the Fibonacci sequence the first two numbers are zero and one. Every number after these is the sum of the previous 2 numbers. So the first few numbers are\n```\nF(0) ≡ 0\nF(1) ≡ 1\nF(2) = F(1) + F(0) = 1 + 0 = 1\nF(3) = F(2) + F(1) = 1 + 1 = 2\nF(4) = F(3) + F(2) = 2 + 1 = 3\nF(5) = F(4) + F(3) = 3 + 2 = 5\nF(6) = F(5) + F(4) = 5 + 3 = 8\n...\nF(n) = F(n - 1) + F(n - 2) ∀ n > 1\n```\n\nTherefore when we calculate a Fibonacci number recursively we have to practice the following logical procedure (in pseudo-code out of respect to StackOverflow).\n```\nInteger NthFibonacci(Integer n) {\n    if (n < 0) {\n        return undefined;\n    } else if (n < 2) {\n        return n;\n    } else {\n        return NthFibonacci(n - 1) + NthFibonacci(n - 2);\n    }\n}\n```\n\nI'm sure you know all this but I think it will help my explanation to have this part as a reference.\nWhere the Ones and Zeros Come In\nThe best way to explain this is probably with an example.\nImagine that, as above, we are trying to recursively calculate ```\nF(6)```\n. Try following the procedure given above. Remember that we will perform recursion only if n > 1.\nFirst we start with ```\nF(6) = F(5) + F(4)```\n.\nThen we find ```\nF(5) = F(4) + F(3)```\n.\nThen we find ```\nF(4) = F(3) + F(2)```\n.\nThen we find ```\nF(3) = F(2) + F(1)```\n.\nThen we find ```\nF(2) = F(1) + F(0)```\n.\nThis is where things start to work out!\nWe have now gotten ```\nF(2)```\n in terms of ```\nF(1) ≡ 1```\n and ```\nF(0) ≡ 0```\n (both of which are known), and so we are able to calculate an actual value instead of performing more recursion.\nWe can now find ```\nF(2) = F(1) + F(0) = 1 + 0 = 1```\n.\nNOTICE THE 1 AND 0 Those are what people are talking about when they say the whole thing comes down to ones and zeros. Every time we recurse down to find a base value we will end up finding ```\nF(2) = 1 + 0```\n. This leads to more ones and zeros as we move back up our recursion tree being able to calculate higher and higher values, as follows.\n```\nF(3) = F(2) + F(1) = (1 + 0) + 1\nF(4) = F(3) + F(2) = ((1 + 0) + 1) + (1 + 0)\nF(5) = F(4) + F(3) = (((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1)\nF(6) = F(5) + F(4) = ((((1 + 0) + 1) + (1 + 0)) + ((1 + 0) + 1)) + (((1 + 0) + 1) + (1 + 0))\n```\n\nNow if you add up all the 1's you get a sum of 8, and so ```\nF(6) = 8```\n, which is correct!\nThis is how it works, and this is how it breaks down to ones and zeros.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "What should be the correct Fibonacci sequence, where I am doing wrong?\r\n                \r\nHere is my python code for sequence of 'Fibonacci Numbers '. My code counts the Fibonacci sequence as  (0,1,1,2,3........ ). But what I can see at many places Fibonacci sequence as ( 0,1,2,3,5.....).\nMy code generates ' 1 ' as the output for input ' 3 '. But when I am submitting it to Coursera, they expect the output of ' 2 ' for input ' 3 '.\nHere is my code, please tell me where I am doing wrong.\n```\nN = int(input())\n\n#initialize the list with starting elements: 0, 1\nfibonacciSeries = [0,1]\n\nif (N>=0 and N<=1):\n    print(fibonacciSeries[N])\n    \n\nelse:\n    for i in range(2, N):\n        #next elment in series = sum of its previous two numbers\n        nextElement = fibonacciSeries[i-1] + fibonacciSeries[i-2]\n       \n        #append the element to the series\n        fibonacciSeries.append(nextElement)\n    \n    print(fibonacciSeries[-1])\n```\n\n    ", "Answer": "\r\nThe Fibonacci sequence is often stated to begin with ```\n1, 1```\n, not ```\n0, 1```\n (though ```\n0, 1```\n is also a common start point). To match the site's expectations, either make your initial ```\nlist```\n ```\n[1, 1]```\n or run your ```\nrange```\n out to ```\nN + 1```\n, not ```\nN```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "First 30 numbers of the fibonacci sequence with arrays [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Python Fibonacci Generator\r\n                            \r\n                                (20 answers)\r\n                            \r\n                    \r\n                Closed last year.\r\n        \r\n\r\n\r\n    \r\n\r\nso I have to make a thing for school, but I can't figure it out. So I have to get the first 30 numbers of the Fibonacci sequence using arrays. The code should be simple, and mine looks something like this.\n```\nfib = [0, 1] * 15\nfor i in range(30):\n    fib = fib[i-1] + fib[i-2]\n    print(fib)\n```\n\nAny input is appreciated!\n    ", "Answer": "\r\nWhat you have is fairly close with some modification, that is, the Fibonacci sequence starts with 1, 1 not 0, 1 and you need to store the result of each calculation for the next:\n```\nfib = [1]*30\nfor i in range(2, 30):\n    fib[i] = fib[i-1] + fib[i-2]\n    print(fib[i])\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generating Fibonacci Sequence and creating subsets for it\r\n                \r\nI am trying to generate a  Fibonacci sequence computed by starting with the array [ 0, 1 ] and each subsequent number is computed by adding the two numbers before it.\n// E.g.  0, 1, [0 + 1 =] 1, [1 + 1 =] 2, [1 + 2 =] 3, [2 + 3 =] 5, and so on.\n\nTwo methods I am trying to implement are below however i am badly stuck in generating a subsets(GenerateSubset(params)). Any help would be really appreciable.  \n\n```\n    public IEnumerable<long> Generate()\n            {\n          int i, count, f1 = 0, f2 = 1, f3 = 0;\n        Console.Write(\"Enter the Limit : \");\n        count = int.Parse(Console.ReadLine());\n        Console.WriteLine(f1);\n        Console.WriteLine(f2);\n        for (i = 0; i <= count; i++)\n        {\n            f3 = f1 + f2;\n            Console.WriteLine(f3);\n            f1 = f2;\n            f2 = f3;\n        }\n        Console.ReadLine();\n  }\n\n\n\npublic Task<IEnumerable<long>> GenerateSubset(int fromIndex, int toIndex)\n    {\n        throw new NotImplementedException();\n    }\n```\n\n\nBelow is the file containing the test cases which i am trying to pass by implementing those methods.\n\n```\nTest cases file: \n```\n\n\n[ drive.google.com/open?id=0B_6Eur5JYu9_MDNfelVKOWswRGs]\n    ", "Answer": "\r\nI think you want a logic for generating a subset of Fibonacci series. here is the logic i write in java. you may convert it into c#.\n\n```\nint fibonacci(int x) {\nif (x == 0)\n    return 0;\n\nif (x == 1)\n    return 1;\n\nreturn fibonacci(x-1)+fibonacci(x-2);\n}\n```\n\n\nand second function which generates the subset is:\n\n```\nList<Integer> GenerateSubset(int fromIndex, int toIndex) {\n    int first=fibonacci(fromIndex);\n    int second= fibonacci(fromIndex+1);\n    int third;\n    List<Integer> result= new ArrayList<Integer>();\n    result.add(first);\n    result.add(second);\n    for(int i= fromIndex+2;i<=toIndex-1;i++) {\n      third= first+second;\n      result.add(third);\n      first=second;\n      second=third;\n    }\n\n    return result;\n\n  }\n```\n\n\nIt returns the list which contain the subset of fibonacci series.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in assembly language\r\n                \r\nNeed some help understanding this more or less.  We are just getting into loops and OFFSET operands and would appreciate some help.  So here are my instructions:\n\n\n\nWrite an assembly language program using the LOOP instruction with indirect addressing mode that calculating the first 12 values in the Fibonacci number sequence, {1, 1, 2, 3, 5, 8, 13, …}.  Place each value in the EAX register and display it with a call DumpRegs statement inside the loop.\n\nPlease use the following variable definition: \n     Fibonacci BYTE 1, 1, 10 DUP (?)\n\nInsert the following statements immediately after the loop.  They will display the hexadecimal contents of the target string:\n  mov   esi, OFFSET Fibonacci       ; offset the variables\n  mov   ebx,1               ; byte format\n  mov   ecx, SIZEOF Fibonacci       ; counter\n  call  dumpMem                 ; display the data in the memory\n\nIf your program works correctly, you will see the following sequence of hexadecimal bytes on the screen when the program runs:\n01 01 02 03 05 08 0D 15 22 37 59 90\n\n\n\n```\n    .data\n\nFibonacci BYTE 1, 1, 10 DUP (?)\n\n.code\nmain PROC\n\n  L1:\n\n  mov   esi, OFFSET Fibonacci       ; offset the variables\n  mov   ebx,1               ; byte format\n  mov   ecx, SIZEOF Fibonacci       ; counter\n  call  dumpMem             ; display the data in the memory\n\n\n    exit                    ;exits to Operating System\n    main ENDP\n\nEND main\n```\n\n\n\n\nSo I know I need to make a loop statement, but am completely stuck on how to begin it.  Any advice will be greatly appreciated!\n    ", "Answer": "\r\nI believe you just want to know how to create a loop in assembly. See the below for some examples:\n\nx86 assembly programming loops with ecx and loop instruction versus jmp + j<condition>\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence less than 1000 in R\r\n                \r\nI'm trying to print the Fibonacci Sequence less than 1000 using while loop in R.\nSo far,\nfib <- c(1,1)\ncounter <-3\nwhile (fib[counter-1]<1000){\n  fib[counter]<- fib[counter-2]+fib[counter-1]\n  counter = counter+1\n}\nfib\n\nI have this code. Only the first two numbers are given: 1,1. This is printing:\n```\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\n```\n\nHow do I fix my code to print only less than 1000?\n    ", "Answer": "\r\nInstead of checking the value of the last element wrt 1000, for the expected output you should be checking the sum of the last two elements as so.\n```\nfib <- c(1,1)\ncounter <-3\nwhile (fib[counter-2]+fib[counter - 1]<1000){\n  fib[counter]<- fib[counter-2]+fib[counter-1]\n  counter = counter+1\n}\nfib\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence using recursion with negative numbers python\r\n                \r\nI'm trying to write a program that finds the fibonacci sequence of any given number using the formula:\nF-n = (-1)n+1Fn\n\nI have written the code for the positive side, which works, but I am getting nonstop recursion when I enter a negative number.\n\n```\ndef fib(n):\n    if n > -1:\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fib(n-1) + fib(n-2)\n    if n <= -1:\n        return ((-1)**(n+1)) + fib(n)\n\n\nnum = eval(input(\"enter a number: \"))\nprint(\"The value of the fibonacci series for the number\", num, \"is: \", fib(num))\n```\n\n    ", "Answer": "\r\nFor the negative side, your last clause, you have to call fib(-n), the absolute value of n.  \n\n```\nif n <= -1:\n    return ((-1)**(n+1)) + fib(-n)   # Note the negation; abs(n) would also work.\n```\n\n\nIf you insist on calculating it directly, you need to maintain the relation:\n\n```\nf(n) = f(n-1) + f(n-2)\n```\n\n\nTo solve this for the least number:\n\n```\nf(n-2) = f(n) - f(n-1)\n```\n\n\n... and then normalize for the current negative value: let j = n-2:\n\n```\nf(j) = f(j+2) - f(j+1)\n```\n\n\nCan you handle the variations from there?\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Error with Fibonacci sequence in python\r\n                \r\nEdit - All fixed thank you    \n\n```\nfib=[0,1]\nfor i in range(0,700):\n    fib.append(fib[len(fib)-2]+fib[len(fib)-1])\n    print(fib[len(fib)-1])\nprint('Do you want a range of numbers or single?')\nanswer=input()\nif answer=='single':\n    print('Which number?')\n    number=int(input())\n    fib[number]\nelif answer=='range':\n    print('From:')\n    firstNumber=int(input())\n    print('To:')\n    secondNumber=int(input())\n    fib[firstNumber:secondNumber]\n```\n\n\nI have been trying to create a Fibonacci sequence in python which allows you to choose either which number to show or what range of numbers to show (script above). However when i run the script it runs fine at the start, i get to the part when you enter the number you want (either a single number, or the to and from numbers) but when i do nothing happens and the script ends. I am very new to python (coming from html and css, and i CBA right now to code this in HTML xD). Could anyone help me?\n    ", "Answer": "\r\n```\nfib=[0,1]\nfor i in range(0,700):\n    fib.append(fib[len(fib)-2]+fib[len(fib)-1])\n    print(fib[len(fib)-1])\nanswer=input('Do you want a range of numbers or single?')\nif answer=='single':\n    number=int(input('Which number?[index]: '))\n    print(fib[number])\nelif answer=='range':\n    firstNumber=int(input('From[index]: '))\n    secondNumber=int(input('To[index]: '))\n    print(fib[firstNumber:secondNumber])\nelse:\n   print('Error')\n```\n\n\nMaybe this will work for you\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "I want to subtract the largest possible number from the Fibonacci sequence by decreasing it in\r\n                \r\nI want to get ```\nn```\n from user and subtract the largest possible number from the Fibonacci sequence by decreasing it in sequence and continue this process until it reaches zero. Our Fibonacci sequence starts from 1. The number 88 can be The form 1 + 3 + 8 + 21 + 55 wrote that these numbers are the sentences 1, 3, 5, 7 and 9 of the Fibonacci sequence, respectively.\nInput: ```\n88```\n\nOutput: ```\n9 7 5 3 1```\n\nMy code:\n```\nclass Main {\n    public static void main(String args[]) {\n        Scanner input = new Scanner(System.in);\n\n        int n = input.nextInt();\n        int[] fibo = new int[1000];\n        int[] arr = new int [100];\n        int d = 0;\n        int b = 0;\n        fibo[1] = 1;\n        fibo[2] = 2;\n\n        for (int i = 3, j = 1; i <= 20; i++, j++)\n            fibo[i] = fibo[i - 1] + fibo[i - 2];\n\n        b = n;\n\n        for (int i = 1, j = 1; i <= 20 && b >= 0; i++, j++) {\n            if (b == fibo[i] || b + 1 == fibo[i] || b - 1 == fibo[i]) {\n                d = i;\n                b -= fibo[d - 1];\n                System.out.println(\"B= \" + b);\n                arr[j] = d - 1;\n                System.out.println(\"arr= \" + arr[j]);\n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nThe first problem is that, every time you subtract something from your number, the next number you will subtract will have to be smaller - because your number itself is smaller now - whereas in your code, the numbers just keep getting bigger.\nFor instance, after you try the 9th fibonacci number 55, you are trying 89, whereas you should be trying 34.\nThis can be solved by iterating backwards through the fibonacci numbers, as in starting from the biggest number at the end of the array, so that as the loop iterates, the numbers get smaller.\nThe second problem is your check in the if statement, which is only satisfied if there happens to be a fibonacci number very close to the number you are at.\nInstead, if you want to select the largest fibonacci number that is smaller than your number, you can just check for the 'smaller than your number' part, since 'the largest fibonacci' part is already taken care of by how the for loop works.\nHere is the working code. You will also notice a lot fewer variables. Also I hard-coded the input number for testing, you'll have to add the scanner stuff back in. Sorry.\n```\npublic class Main {\n    public static int len = 20; // the program considers this many fibonacci numbers\n    \n    public static void main(String args[])\n    {\n        int n = 88;\n        int[] fibo = new int[len];\n        \n        for(int i=0; i<len; i++)\n        {\n            if (i < 2) fibo[i] = i+1; // for 1 and 2\n            else fibo[i] = fibo[i-1] + fibo[i-2]; // for 3 and 5 and ...\n        }\n        \n        for(int i=len-1; i>=0; i--)\n        {\n            if (fibo[i] <= n)\n            {\n                System.out.format(\"%d: %d - %d = %d\\n\",\n                    i+1, // to correct for 0-indexing\n                    n, fibo[i], n-fibo[i]);\n                n -= fibo[i];\n            }\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence How is it Working [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Java recursive Fibonacci sequence\r\n                            \r\n                                (37 answers)\r\n                            \r\n                    \r\n                Closed 5 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am confused as to how Java is running this specific code. I am comfortable with the Fibonacci sequence but not exactly with how to grapple my mind to the way this specific method is running. So obviously I'm returning 0 if n is 0 and returning 1 if n is 1. Now let us say I pass 3 for n. We return fib(2) + fib(1). How does it know what fib(2) is if it never calculated that in the first place? Does it go through the whole function again to find out what fib(2) is? When does it stop? My mind is going to blow up.\n\n```\n public static int fib(int n){\n    if (n == 0){\n        return 0;\n    }\n    else if (n == 1){\n        return 1;\n    }\n    return (fib(n-1) + fib(n-2));\n\n}\n```\n\n    ", "Answer": "\r\nYou are expreiencing one of the coolest concepts in programming/math called Recursion. It can be beautiful but itcan also be a curse. At the beginning of learning recursive functions I was also driven mad by these compilcated self calling monsters but after a while I recognised how many problems can be solved much easier with recursion. So back to your problem.\n\nSo according to Wikipedia the Fibonacci sequence is\n\n\"The sequence Fn of Fibonacci numbers is defined by the recurrence relation:\n\n\n```\nF n = F n−1 + F n−2\n```\n\n\n\nn being the current number. \n\nSo at the beginning we callfor example\n\n```\nfib(3);\n```\n\n\nin the method it calls \n\n```\nfib(2);\n```\n\n\nthen in fib(2) it calls\n\n```\nfib(1)\n```\n\n\nthis returns 1 (because of the if) so this gets to fib(2) and fib 2 calls fib(0) results in 0\nso fib(2) returns 1\n\nBecause fib(3) was interrupted by the other methods its still at the point of returning. which looks like that currently.\n\n```\nreturn 1 + fib(3 - 2)\n```\n\n\nfib(1) returns 1 so \n\nfib returns 2 at the end\n\nThis was a bit hard to explain but I think you'll understand pretty soon. \n\nTIP: When you cant understand how something executes use a debugger.It helps so much with visualizing data and algorithms. It helps you understand much quicker.\nfib(1)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Weird output as the numbers get bigger in Fibonacci sequence\r\n                \r\nI noticed in my fibonacci sequence that I'm getting negative numbers after a certain point:\n\n```\n267914296 433494437 701408733 1134903170\n1836311903 -1323752223 512559680 -811192543 -298632863 \n```\n\n\nDoes this have to do with the limited range of \"int\"? or is there something wrong with my code? \n\nHere is the code:\n\n```\nusing std::cout;\n\nint main()\n{\n\nint n = 50, f1 = 0, f2 = 1, fn = 0, i = 0;\n\ncout << \"0 \";\nfor (i = 0; i < n; i++)\n{\n    fn = f1 + f2;\n    f2 = f1;\n    f1 = fn;\n\n    cout << fn << \" \";\n}\n```\n\n    ", "Answer": "\r\nYes, this has to do with the limited range of ```\nint```\n. This is called rollover or overflow, and works just like the odometer in your car. Once the number passes its highest possible value, it rolls over to its lowest possible value (which for ```\nint```\n is a negative number). Consider using an ```\nunsigned int```\n or ```\nlong unsigned int```\n, though the second one is not neccessarily longer (it's platform-dependent). A ```\nlong double```\n can hold even bigger numbers. If you'd like to use an arbitrarily large number (as big as you want), you can find appropriate libraries in answers to this question.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Implementing the Fibonacci sequence for the last n elements: The nBonacci sequence\r\n                \r\nI was curious about how I can implement the Fibonacci sequence for summing the last n elements instead of just the last 2. So I was thinking about implementing a function ```\nnBonacci(n,m)```\n where n is the number of last elements we gotta sum, and m is the number of elements in this list.\nThe Fibonacci sequence starts with 2 ones, and each following element is the sum of the 2 previous numbers.\nLet's make a generalization: The nBonacci sequence starts with n ones, and each following element is the sum of the previous n numbers.\nI want to define the nBonacci function that takes the positive integer n and a positive integer m, with m>n, and returns a list with the first m elements of the nBonacci sequence corresponding to the value n.\nFor example, ```\nnBonacci(3,8)```\n should return the list [1, 1, 1, 3, 5, 9, 17, 31].\n```\ndef fib(num):\n    a = 0\n    b = 1\n    while b <= num:\n        prev_a = a\n        a = b\n        b = prev_a +b\n```\n\nThe problem is that I don't know the number of times I gotta sum. Does anyone have an idea and a suggestion of resolution?\n    ", "Answer": "\r\nThe nBonacci sequence will always have to start with ```\nn```\n ones, or the sequence could never start. Therefore, we can just take advantage of the ```\nrange()```\n function and slice the existing list:\n```\ndef nfib(n, m):\n    lst = [1] * n\n    for i in range(n, m):\n        lst.append(sum(lst[i-n:i]))\n    return lst\n\n\nprint(nfib(3, 8))  # => [1, 1, 1, 3, 5, 9, 17, 31]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "C++ Recursion and Exception Handling with Fibonacci Sequence\r\n                \r\nThis program seems to work for the Fibonacci Sequence using recursion and exception handling. (Yes I want to do it with recursion, I know I can use loops).\nIt is supposed to throw an error if the next result is out of range for long long. Which it works, if I put in most numbers, but if I put in number 91, it shows one negative result without printing the error message. If I put in 89, 90, 92, 93, ... it works fine.\nWhy 91?\nOutput of 91:\n```\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025 20365011074 32951280099 53316291173 86267571272 139583862445 225851433717 365435296162 591286729879 956722026041 1548008755920 2504730781961 4052739537881 6557470319842 10610209857723 17167680177565 27777890035288 44945570212853 72723460248141 117669030460994 190392490709135 308061521170129 498454011879264 806515533049393 1304969544928657 2111485077978050 3416454622906707 5527939700884757 8944394323791464 14472334024676221 23416728348467685 37889062373143906 61305790721611591 99194853094755497 160500643816367088 259695496911122585 420196140727489673 679891637638612258 1100087778366101931 1779979416004714189 2880067194370816120 4660046610375530309 -6246583658587674878\n```\n\nCPP Program:\n```\n#include <iostream>\n\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::cerr;\n\n#include <stdexcept>\nusing std::out_of_range;\n\n#include <climits>\n\nclass OUTofRage : public out_of_range\n{\n   public:\n      OUTofRage()\n          : out_of_range(\"Out Of Range\\n\") {}\n} ;\n\nlong long fibonacci(long long target, long long numberOne, long long numberTwo);\n\nint main() {\n    long long fiboSub;\n    cout << \"--fibonacci Sequencer--\\n\" << endl;\n\n    cout << \"Which place in the fibonacci sequence do you want to reach (F(n))?\\n\";\n    cout << \"n> \";\n    cin >> fiboSub;\n    \n    cout << endl << fibonacci(fiboSub, 0, 1) << endl << endl;\n    return 0;\n}\n\nlong long fibonacci(long long target, long long numberOne, long long numberTwo) {\n    cout << numberOne << \" \";\n\n    if(target < 0) {\n        throw OUTofRage();\n    } else if(target == 0) {\n        return numberOne + numberTwo;\n    } else {\n        try {\n            if((numberOne + numberTwo) < 0) {\n                throw OUTofRage();\n            } else {\n                fibonacci(target-1, numberTwo, numberOne + numberTwo);\n            }\n        }\n        catch (const out_of_range& O_O_R) {\n            cerr << endl << \"\\nError: \" << O_O_R.what() << '\\n';\n            exit (EXIT_FAILURE);\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nThis line of code is invalid:\n```\nif((numberOne + numberTwo) < 0)\n```\n\nper Is signed integer overflow still undefined behavior in C++? you are relying on Undefined Behaviour, which is a mistake. You can replace your condition with:\n```\nif( std::numeric_limits<long long>::max() - numberOne < numberTwo ) \n```\n\nor more generic:\n```\nif( std::numeric_limits<decltype(numberOne)>::max() - numberOne < numberTwo ) \n```\n\nwhich does not overflow and will give you predictable result. For this to work, you also cannot keep this condition as it is, without checking for overflow first:\n```\nif(target == 0) {\n    return numberOne + numberTwo;\n```\n\nas it relies on the same problem. So here how your function could look like:\n```\nlong long fibonacci(long long target, long long numberOne, long long numberTwo)\n{\n    // check for overflow first\n    if(std::numeric_limits<decltype(numberOne)>::max() - numberOne < numberTwo) \n         throw OUTofRage();\n\n    if(target == 0) \n        return numberOne + numberTwo;\n        \n    return fibonacci(target-1, numberTwo, numberOne + numberTwo);\n}\n```\n\nLive example\nPS on this line:\n```\n            fibonacci(target-1, numberTwo, numberOne + numberTwo);\n```\n\nyou are missing return statement\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to create Fibonacci Sequence in Java\r\n                \r\nI really suck at math. I mean, I REALLY suck at math. \nI'm trying to make a simple fibonacci sequence class for an algorithm I'll be using. I have seen the python example which looks something like this:\n\n```\na = 0\nb = 1\nwhile b < 10:\n    print b\n    a, b = b, b+a\n```\n\n\nThe problem is that I can't really make this work in any other language. I'd like to make it work in Java, since I can pretty much translate it into the other languages I use from there. This is the general thought:\n\n```\n    public class FibonacciAlgorithm {\n\n    private Integer a = 0;\n\n    private Integer b = 1;\n\n    public FibonacciAlgorithm() {\n\n    }\n\n    public Integer increment() {\n        a = b;\n        b = a + b;\n        return value;\n    }\n\n    public Integer getValue() {\n        return b;\n    }\n}\n```\n\n\nAll that I end up with is doubling, which I could do with multiplication :(\nCan anyone help me out? Math pwns me. \n    ", "Answer": "\r\nI'd do it this way:\n\n```\npublic class FibonacciAlgorithm {\n\n    private int a = 0;\n\n    private int b = 1;\n\n    public FibonacciAlgorithm() {\n\n    }\n\n    public int increment() {\n        int temp = b;\n        b = a + b;\n        a = temp;\n        return value;\n    }\n\n    public int getValue() {\n        return b;\n    }\n}\n```\n\n\nThis keeps it as close to your original Java code as possible.\n\n[Editor's note: ```\nIntegers```\n have been replaced with ```\nints```\n. There is no reason to use ```\nIntegers```\n for this.]\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence: C vs Python\r\n                \r\nThis is a code I wrote in C for Fibonacci sequence:\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n)\n{\n    int a = 0, b = 1, c, i;\n    if (n == 0)\n        return a;\n    for (i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\nint main()\n{\n    printf(\"%d\",fib(1000));\n    return 0;\n}\n\n```\n\nAnd this is the direct translation in Python:\n```\ndef fib(n):\n    a=0\n    b=1\n    if n == 0:\n        return a\n\n    for _ in range(n-1):\n        c = a + b\n        a = b\n        b = c\n\n    return b\n\nprint(fib(1000))\n```\n\nThe C program outputs:\n```\n    1556111435\n```\n\nWhere Python (correctly) outputs:\n```\n    43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875\n```\n\nI realize the problem with C is with the variable type (since the ```\nfib(50)```\n works just fine in C), but I have two major questions:\n\nHow should I correct the C program in a way that I can calculate ```\nfib```\n of any number? In other words, rather than just using double (which has its own limitation), how can I calculate any ```\nfib```\n in C?\n\nHow does Python handle this? Because apparently, it has no limitation in the size of integers.\n\n\n    ", "Answer": "\r\nC does not offer any dynamically sized integer types directly. The biggest you can go within the language itself is ```\nlong long```\n. However there is nothing stopping you from writing your own big-integer functions that allocate memory and handle carry as needed.\nOr you can just use someone else's big integer lib, for instance BigInt.\n(Looking at BigInt's source code will also answer the question how Python does this.)\nEdit: I just had a bit of a closer look at BigInt myself. Beware that it uses the regular pen&paper method unconditionally for multiplication, which is fast for \"small\" numbers, but for \"large\" numbers has worse performance than the Karatsuba method. However please note that the border between \"small\" and \"large\" in this context is probably so high, that in most practical cases the pen&paper method is enough (see the linked Wiki article). It's also worth noting that you can combine both algorithms for multiplication, by writing them recursively and having Karatsuba's method fall back to pen&paper if the number of bits is below a given threshold.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding the numbers in the Fibonacci sequence using recursion - how to make it faster?\r\n                \r\nMy code to Finding the numbers in the Fibonacci sequence is working correct but it is really slooooow. (It is almost impossibleto find number over n=55). Where did I make a mistake?\n\n```\npublic static void main(String[] args) {\n\n    for (; ; ) {\n        System.out.println(\"The value of the fibonacci sequence \");\n        Scanner numer = new Scanner(System.in);\n        long n = numer.nextLong();\n        long result = Fib(n);\n        System.out.println(result);\n\n    }\n}\n\n\nprivate static long Fib(long n) {\n    if (n <= 0) { System.out.println(\"Error\"); return 0;}\n    else if (n == 1 | n == 2) return 1;\n    else return Fib(n-1)+ Fib(n-2) ;\n\n}\n```\n\n    ", "Answer": "\r\nDo you understand how many times you compute fib(k) for each k? If you want your program to run fast, don't use recursion so blindly, use loop instead:\n\n```\nprivate static long Fib(long n) {\n    long prev = 1;\n    long current = 1;\n    if (n <= 0) { System.out.println(\"Error\"); return 0;}\n    if (n == 1 | n == 2) return 1;\n    for (int i = 3; i <= n; i++) {\n        long next = prev + current;\n        prev = current;\n        current = next;\n    }\n    return current;\n\n}\n```\n\n\nIf you want to solve this problem only by recursion, then you need to store already computed results. It can be done either by memoization or by using lazy dynamic programming, and it's way harder than just using loop.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence\r\n                \r\n```\n#define MAX_SEQUENCE 10 // Max values to store in shared memory\n#define MIN_SEQUENCE 2 // Min value the user can enter\n\n//shared memory:\n// 1) holds an array of numbers\n// 2) holds how many numbers are in the array\ntypedef struct {\n    int fib_seq[MAX_SEQUENCE];\n    int sequence_size;\n} shared_data;\n\n//MAIN function\nint main(int argc, char *argv[]) {\n\n    pid_t pid; //process ID\n    int segment_id; //Shared Memory ID\n    shared_data *mem; //Shared Memory Pointer\n\n    //check to validate atleast two arguments\n    if(argc != 2) {\n        printf(\"USAGE ERROR: [0-9]\\n\");\n        exit(0);\n    }\n\n    //validate the input is not larger then the MAX\n    if(atoi(argv[1]) > MAX_SEQUENCE) {\n        printf(\"Max Input Size: %d\\n\", MAX_SEQUENCE);\n        exit(0);\n    }\n\n    //validate the input is not smaller then the MIN\n    if(atoi(argv[1]) < MIN_SEQUENCE) {\n        printf(\"Min Input Size: %d\\n\", MIN_SEQUENCE);\n        exit(0);\n    }\n\n    // 1) create a new shared memory location 'IPC_PRIVATE'\n    // 2) the size of our shared memory structure 'sizeof(shared_data)'\n    // 3) Set Modes S_IRUSR and S_IWUSR so the owner can read and write to the shared memory 'S_IRUSR|S_IWUSR'\n    segment_id = shmget(IPC_PRIVATE, sizeof(shared_data), S_IRUSR|S_IWUSR);\n\n    //attach the shared memory and get the pointer to the beginning location in memory\n    mem = (shared_data *) shmat(segment_id,NULL,0);\n\n    //set the size of the sequence to the argument that was passed in via command line\n    mem->sequence_size = atoi(argv[1]);\n\n    // fork a child process\n    pid = fork();\n\n    if(pid < 0) { /* error occured */\n        fprintf(stderr, \"Fork Failed\\n\");\n        return 1;\n    }\n    else if(pid == 0) { /* child process */\n        int counter = 0;\n        printf(\"Child Fibonacci Sequence: \");\n\n        while(counter < mem->sequence_size) {\n            if(counter == 0){\n                //FIB of zero is always zero\n                mem->fib_seq[counter] = 0;\n            }\n            else if(counter == 1){\n                //FIB of one is always one\n                mem->fib_seq[counter] = 1;\n            }\n            else {\n                //The Fibonacci Sequence formula 'R = fib(n-1) + fib(n-2)'\n                //The first two numbers in the sequence are always 0 and 1.\n                //To get a value in the sequence you will want to take the previous\n                //two numbers and add them together. For example:\n                // b + a = c\n                // [fib(d-1) = c] + [fib(d-2) = b] = R\n                // fib(0) = 0\n                // fib(1) = 1\n                // fib(2): 1 + 0 = 1\n                // fib(3): 1 + 1 = 2\n                // fib(4): 2 + 1 = 3\n                // fib(5): 3 + 2 = 5\n                // The next Fibonacci number in the sequence will be '8'\n                mem->fib_seq[counter] = mem->fib_seq[counter - 1] + mem->fib_seq[counter - 2];\n            }\n            printf(\"%d \", mem->fib_seq[(counter)]);\n            counter++;\n        }\n    }\n    else { /* parent process */\n\n        /* parent will wait for the child process to complete */\n        wait(NULL);\n\n        //Print out shared memory\n        int count = 0;\n        printf(\"\\nParent Fibonacci Sequence: \");\n        while(count < mem->sequence_size){\n            printf(\"%d \", mem->fib_seq[count]);\n            count++;\n        }\n\n        //detach shared memory\n        shmdt(mem);\n        //remove shared memory segment\n        shmctl(segment_id,IPC_RMID,NULL);\n        printf(\"\\nComplete\\n\");\n    }\n\n    return 0;\n}\n```\n\n\nOk, I have this program that I've been working on for a while now, the problem is that the sequence of numbers are off by 1 and I can not seem to find where it is. It's not printing the 0 for fib(0). So when I do Fib(2) it gives me 0 1 instead of 0 1 1, anyone have any suggestions?\n    ", "Answer": "\r\nA classical Obi Wan error (off-by-one). You need to do:\n\n```\nmem->sequence_size = atoi(argv[1]) + 1;\n```\n\n\n(Edited, the previous posting was causing out-of-bounds array access)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to draw fibonacci sequence using turtle module\r\n                \r\nThis is my first question ever, and I am a complete and utter beginner, so please don't eat me :) What I am trying to to is to draw a fibonacci sequence using the Python turtle module. My code is as follows: \n\n```\nimport turtle\n\nzuf = turtle.Turtle()\n\nwhile True:\n\n  zuf.forward(10)\n  zuf.left(3.1415)\n```\n\n\nThis, however, drives around in circles only. I have tried to create a variable, say X, and assign a fibonacci rule to it ```\nxn = xn-1 + xn-2```\n then I'd put it in here ```\nzuf.forward(x)```\n but it doesn't work.  I tried multiple variations of that, but none seems to work. Please don't give a whole solution, only some hint, thanks a lot.\n    ", "Answer": "\r\nI think I can get you from where you are to where you want to be.  First, your invocation of:\n\n```\nzuf.left(3.1415)\n```\n\n\nseems to indicate you're thinking in radians, which is fine.  But you need to tell your turtle that:\n\n```\nzuf = turtle.Turtle()\nzuf.radians()\n```\n\n\nthis will still make your code go in circles, but very different circles.  Next, we want to replace ```\n10```\n with our fibonacci value.  Before the ```\nwhile```\n loop, initialize your fibonacci counters:\n\n```\nprevious, current = 0, 1\n```\n\n\nas the last statement in the ```\nwhile```\n loop, bump them up:\n\n```\nprevious, current = current, current + previous\n```\n\n\nand in your ```\nforward()```\n call, replace ```\n10```\n with ```\ncurrent```\n.  Next, we need to turn the line that it's drawing into a square.  To do this, we need to do two things. First, loop the drawing code four times:\n\n```\nfor i in range(4):\n    zuf.forward(current)\n    zuf.left(3.1415)\n```\n\n\nAnd second, replace your angle with pi/2 instead:\n\n```\n    zuf.left(3.1415 / 2)\n```\n\n\nIf you assemble this all correctly, you should end up with a figure like:\n\n\n\nshowing the increasing size of the fibonacci values.  Not the greatest looking image, you'll still have to do some work on it to clean it up to look nice.\n\nFinally, I was impressed with the fibonacci drawing code that @IvanS95 linked to in his comment, that I wrote a high speed version of it that uses stamping instead of drawing:\n\n```\nfrom turtle import Screen, Turtle\n\nSCALE = 5\nCURSOR_SIZE = 20\n\nsquare = Turtle('square', visible=False)\nsquare.fillcolor('white')\nsquare.speed('fastest')\nsquare.right(90)\nsquare.penup()\n\nprevious_scaled, previous, current = 0, 0, 1\n\nfor _ in range(10):\n    current_scaled = current * SCALE\n    square.forward(current_scaled/2 + previous_scaled/2)\n    square.shapesize(current_scaled / CURSOR_SIZE)\n    square.left(90)\n    square.forward(current_scaled/2 - previous_scaled/2)\n    square.stamp()\n    previous_scaled, previous, current = current_scaled, current, current + previous\n\nscreen = Screen()\nscreen.exitonclick()\n```\n\n\n\n\nThis is not a whole solution for you, only a hint of what can be done as you're drawing your squares and this is a stamp-based solution which plays by different rules.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Sum of Fibonacci Sequence off by a value of 1\r\n                \r\nI have a code to calculate the sum of all even numbers of the Fibonacci Sequence less than 4,000,000.\n```\n/*\n  Through the use of Binet's formula for the Fibonacci Sequence and the fact\n  that every third number of the sequence is an even number.\n*/\n\nimport java.lang.Math.*;\n\npublic class Optimised002 {\n  public static void main(String[] args) {\n    long sum = 0;\n    for (int i = 0; i < 4_000_000; i += 3) {\n      long number = binetsFormula(i);\n      if (number < 4_000_000L) {\n        sum += number;\n      }\n    }\n    System.out.println(sum);\n  }\n\n  public static float sqrt5 = 2.2360679775f;\n  public static float goldenRatio = 1.61803398875f;\n  public static float reciprocalGoldenRaio = -0.61803398875f;\n\n  public static long binetsFormula(int nth) {\n    return Math.round((Math.pow(goldenRatio, nth) - Math.pow(reciprocalGoldenRaio, nth)) / sqrt5);\n  }\n}\n```\n\nThe correct answer that I had obtained through bruteforce previously is 4613732, for this method I am obtaining the sum of 4613733: off by a value of 1. Maybe its because of sqrt5 or goldenRatio not being precise enough or some computers being bad at maths sort of thing: I have no idea why. Insights are greatly appreciated.\n    ", "Answer": "\r\nYou can change the floats to doubles and also use the built-in Math class.\nI think that double can store more decimals than float, since double stores 64 bits of information whereas float stores 32 bits of information.\nhttps://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\nIt is also the case that the static method Math.sqrt(n) returns a double, so it makes sense to use double.\nHere is a code example.\n```\npublic class BinetsFormula {\n  \n    public int fib(int n) {\n        double a = (1 + Math.sqrt(5))/2;\n        double b = (1 - Math.sqrt(5))/2;\n        double c = (Math.pow(a, n) - Math.pow(b, n))/Math.sqrt(5);\n        return (int) c;\n    }\n\n    public static void main(String[] args) {\n        BinetsFormula formula = new BinetsFormula();\n        for (int i = 0; i < 20; i++) {\n            if (i < 19)\n                System.out.print(formula.fib(i) + \" \");\n            else if (i == 19) \n                System.out.println(formula.fib(i));\n        }\n    }\n}\n```\n\nThe above code prints out the first 20 fibonacci numbers.\nNow we can get the sum of all even fibonacci numbers less than 4,000,000.\n```\npublic class BinetsFormula {\n \n    private final double sqrt5 = Math.sqrt(5);\n    private final double a = (1 + sqrt5)/2;\n    private final double b = (1 - sqrt5)/2;\n\n    public long fib(int n) {\n        return Math.round((Math.pow(a, n) - Math.pow(b, n))/sqrt5);\n    }\n\n    public static void main(String[] args) {\n        BinetsFormula formula = new BinetsFormula();\n        int n = 0;\n        long f = 0;\n        long sum = 0;\n        long max = 4000000;\n        while ((f = formula.fib(n)) < max) {\n            if (f % 2 == 0)\n                sum += f;\n            n++;\n        }\n        System.out.printf(\"Sum: %d\\n\", sum);\n    }\n}\n```\n\nThe second example is optimized.\nI created the constants sqrt5, a, and b so that these computations are only performed once.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How can I recursively generate an Array of the Fibonacci sequence?\r\n                \r\nI've seen several posts on generating a given fibonacci sequence, such as this one. However, I can't figure out how to generate the sequence (return an array) of fibonnaci numbers for a given ```\nn```\n using recursion.  What I have clearly doesn't work, but I really can't figure out how to do it otherwise.\n\n```\nvar fibArray = function(n) {\n    var f = [];\n    n < 2 ? f.push(n) : f.push(fibArray(n-1) + fibArray(n-2));\n    return f;\n};\n```\n\n    ", "Answer": "\r\nA slightly modified version from the previous answer:\n\n\r\n\r\n```\nfunction fib(n) {\r\n  if (n == 0) return [0]\r\n  if (n == 1) return [0, 1]\r\n  const arr = fib(n - 1)\r\n  return [...arr, arr[n-1] + arr[n-2]]\r\n}\r\n\r\nconsole.log(fib(15))```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to Make a Simpler Python Fibonacci Sequence Prompt? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to write the Fibonacci Sequence?\r\n                            \r\n                                (67 answers)\r\n                            \r\n                    \r\n                Closed 8 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nSo just for fun I created a small little python script that prompts the user for a number and then prints out that many digits of the Fibonacci sequence. The script that I came up with works, but I can't help but feel its a bit convoluted and there is a probably a better and simpler way to do it.\n\nHow could I simplify this script and still have it accomplish the same thing?\n\n```\ndef fib(number):\n    if number == 0:\n        return 0\n    elif number == 1:\n        return 1\n    else:\n        numbers = [1, 1]\n        for i in range(number - 2):\n            i = numbers[-2] + numbers[-1]\n            numbers.append(i)\n        return numbers\n\nx = int(raw_input(\"How many digits of the Fibonacci sequence would you like to see?\"))\n\nResults = fib(x)\n\nprint Results\n```\n\n    ", "Answer": "\r\n```\n  def fib(n):\n        cur = 1\n        old = 1\n        i = 1\n        while (i < n):\n            cur, old, i = cur+old, cur, i+1\n        return cur\n\n    for i in range(10):\n        print(fib(i))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Returning specific values at any given index in the Fibonacci Sequence\r\n                \r\nI am trying to output the value at any given indices in the Fibonacci sequence using recursion for my coding assignment. Can anyone explain why my function ```\nfibonacci```\n is not returning the correct values that it should? I can seem to find the bug that causing an error message to pop up saying \"invalid pointer.\"\nany help is appreciated.\n```\nfibonacciType1 fibonacci(int index, int counter, BigNumber FibVal, vector<BigNumber>FibList) {\n\n   if ((index == counter)) { // base cases\n      return FibList[index];\n   }\n   else { // recursion step\n      if (counter == 0){\n         return FibList[0];\n      }\n      else{\n          FibVal += FibList[index - 1];\n          FibList.push_back(FibVal);\n          ++index;\n          fibonacci(index, counter, FibVal, FibList);\n      }\n   }\n}\n\nint main() {\n\n   cout << \"Do not change this line.  Enter a sequence of increasing Fibonacci indicies and -1 to stop input.\" << endl;\n\n   // Section 1\n   // *** insert here a loop to input Fibonacci indexes and calculate Fibonacci numbers, or input -1 to stop input ***\n\n   int counter{0};\n\n   while (\n         cin >> counter,\n         -1 != counter) {\n\n      int index{1};\n      BigNumber FibVal{1};\n      vector<BigNumber> FibList{0,1};\n\n      cout << counter << endl;\n      cout << fibonacci(index, counter, FibVal, FibList) << endl;\n   }\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Find the Nth term of the fibonacci sequence\r\n                \r\nI am writing some code that uses multiple functions. One is to generate the Fibonacci sequence up to the Nth term that the user inputs. The other function is to find the largest/last number in the sequence.\nI currently have the sequence printed out just fine, but my main problem is that I cannot find a way to print out the last/largest integer in the sequence.\nThis is the output I want to get:\n```\nEnter a number: 9\nThe series is: 0 1 1 2 3 5 8 13 21 \nthe maximum input is 21\n```\n\nIn the function to find the last number, I am unsure of where to start as I assume the printout is an integer so I can't think of a way to access the final integer.\nThis is the code I have:\n```\n#include <iostream>\n#include <ctime>\n#include <time.h>\n\nusing namespace std;\n\nint printSequence(int x);\nint maxInput(int n);\n```\n\n```\nint main()\n{\n    int x;\n    cout << \"Enter an integer: \" << endl;\n    cin >> x;\n\n    printSequence(x);\n\n    cout << maxInput(x) << endl;\n\n    return 0;\n}\n```\n\n```\nint printSequence(int x)\n{\n    int t1 = 0, t2 = 1, temp = 0;\n\n    for (int i = 1; i <= x; ++i)\n    {\n        if (i == 1)\n        {\n            cout << t1 << \", \";\n            continue;\n        }\n        if (i == 2)\n        {\n            cout << t2 << \", \";\n            continue;\n        }\n        temp = t1 + t2;\n        t1 = t2;\n        t2 = temp;\n\n        cout << temp << \", \";\n    }\n    cout << endl;\n\n    return temp;\n}\n```\n\n```\nint maxInput(int x)\n{\n    x = x % 60;\n    return (printSequence(x) % 10);\n}\n```\n\n    ", "Answer": "\r\nHere is the Code After Modification:\n```\n#include <iostream>\n#include <ctime>\n#include <time.h> \n\nusing namespace std;\n\nint printSequence(int x);\n\nint maxInput(int n);\n\nint main() {\n\n    int x;\n    cout<<\"Enter an integer: \"<< endl;\n    cin>> x;\n\n    int max = printSequence(x);\n    // max is the last Integer in Set\n    cout<<\"the maximum input is: \"<<max<< endl;\n\n\n    return 0;\n}\n\nint printSequence(int x){\n\n    int t1 = 0, t2 = 1, temp = 0;\n\n    for (int i = 1; i <= x; ++i) {\n\n        if(i == 1) {\n            cout << t1 << \", \";\n            continue;\n        }\n        if(i == 2) {\n            cout << t2 << \", \";\n            continue;\n        }\n        temp = t1 + t2;\n        t1 = t2;\n        t2 = temp;\n        \n        cout << temp;\n        if(i!=x)cout << \", \";\n\n    }\n    cout<<endl;\n\n    return temp;\n}\n```\n\nDescription:\nYou already return the last number as ```\ntemp```\n from the function call ```\nprintSequence```\n so you can use this as your final integer.\nAnother Solution:\nit is better to make your ```\nprintSequence```\n void function to only print and at the end of the loop you can set ```\ntemp```\n value to a global int to use it as the max Integer/ last integer from the sequence.\nHere you can use the ```\nmaxx```\n as your final/last variable.\nSuch As:\n```\n#include <iostream>\n#include <ctime>\n#include <time.h> \n\nusing namespace std;\n\nvoid printSequence(int x);\nint maxx;\n\nint main() {\n\n    int x;\n    cout<<\"Enter an integer: \"<< endl;\n    cin>> x;\n    printSequence(x);\n    // max is the last Integer in Set\n    cout<<\"the maximum input is: \"<<maxx<< endl;\n\n\n    return 0;\n}\n\nvoid printSequence(int x){\n    \n    int t1 = 0, t2 = 1, temp = 0;\n\n    for (int i = 1; i <= x; ++i) {\n\n        if(i == 1) {\n            cout << t1 << \", \";\n            continue;\n        }\n        if(i == 2) {\n            cout << t2 << \", \";\n            continue;\n        }\n        temp = t1 + t2;\n        t1 = t2;\n        t2 = temp;\n        \n        cout << temp;\n        if(i!=x)cout << \", \";\n\n    }\n    cout<<endl;\n    maxx = temp;\n    \n}\n```\n\nOutput:\n\nAnother Output:\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Ruby Sum of Integers for Fibonacci Sequence\r\n                \r\nI've searched Stack Overflow and haven't found my question, so I think this will be safe to post. I'm working on a standard piece of code that prints the first 10 integers of the Fibonacci sequence, and then adds those first 10 integers together and prints the sum. The code I have written essentially works, but I'm trying to combine the map and inject methods at the bottom to make the code more efficient. Any input would be greatly appreciated.\n\n```\n  def fib(n)\n      return 1 if n <= 2\n\n      fib_index = 3\n      a, b = 1, 1\n\n      while fib_index <= n\n        c = a + b\n        a = b\n        b = c\n        fib_index += 1\n      end\n    c\n  end\n\np (1..10).map {|i| fib(i)}\np (1..10).inject {|sum, i| sum + fib(i)}\n```\n\n\nI am also interested in a method that uses recursion:\n\n```\n def fibonacci( n )\n    return  n  if n <= 1\n    fibonacci( n - 1 ) + fibonacci( n - 2 )\n  end\n  p ( 1..10 ).map {|i| fibonacci(i)}\n  p ( 1..10 ).inject {|sum, i| sum + fibonacci(i)}\n```\n\n    ", "Answer": "\r\n```\nputs \"Total: %i\" %\n  ((1..10).inject(0) do |t,i|\n    f = fib(i)\n    puts \"%s: %s\" % [i.to_s.rjust(2), f.to_s.rjust(3)]\n    t + f\n  end)\n 1:   1\n 2:   1\n 3:   2\n 4:   3\n 5:   5\n 6:   8\n 7:  13\n 8:  21\n 9:  34\n10:  55\nTotal: 143\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "FIbonacci sequence in ARM assembly\r\n                \r\nJust started learning assembly on the ARM processors(cortex M4) and I'm trying to play a bit with recursion, using the stack etc.\nI'm trying to implement a code which will load the first 5 FIbonacci numbers in the register R3.\nI managed to write some code using recursion in assembly for example sum of first n numbers or factorial of a number and I could do that but in the case of fibonacci we have to remember both fibonacci(n-1) and fibonacci(n-2) at each iteration and that I was not able to do.\nThis would be a C function I'm trying to implement in assembly:\n```\nint fibbonacci(int n) {\n   if(n == 0){\n      return 0;\n   } else if(n == 1) {\n      return 1;\n   } else {\n      return (fibbonacci(n-1) + fibbonacci(n-2));\n   }\n}\n```\n\nThis is the code I wrote:\n```\n__main\n        MOV     R0, #4\nSum     \n        CMP     R0, #1\n        BEQ     done\n        SUBS    R0, R0, #1\n        BL      Sum\n        POP     {R1, R2}\n        ADD     R0, R1, R2\n        MOV     R3, R0\n        PUSH    {R0, R1}\n        BX      LR\n        \nStop    B       Stop\n        \n        \ndone\n        MOV     R0, #0\n        MOV     R3, R0\n        PUSH    {R0}\n        \n        MOV     R0, #1\n        MOV     R3, R0\n        PUSH    {R0}\n        \n        BX      LR\n        ALIGN\n\n    \n```\n\nWhat my logic was is that we recursive all the way to when R0 is equal to 1 and then we go into the 'done' subroutine where we load R0 with two values(0 and 1) and push these values on the stack. Then we use the register R3 to see the values and then we return to what would be fibonacci(2) on this line:\n```\nPOP     {R0, R1}\n```\n\nSo here we extract those two values from the top of the stack(1 and 0) and do calculate fibonacci(2)=fibonacci(1)+fibonacci(0) and store it in R0 and then R3.\nThen we store R0(1) and R2(1).\nThe program kinda works as in it displays all the numbers in the sequence in the register R3 however I was not able to make the program stop after 4 numbers. For example since in the above example I have R0=4 in the beginning of the program I want the code to show me the first 4 numbers in the sequence then go to the endless while loop(Stop B Stop). I was not able to do this I guess I have to make use of the LR somehow and push it on the stack and pop it but I'm not sure where I could do this so the program returns after displaying only 4 numbers.\nPlease help me fix this. Thank you!\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Printing Fibonacci sequence using recursion in mips\r\n                \r\nHey guys I need to print out the values of the Fibonacci sequence up till the nth value (user inputted). So if the user entered 3, I would have to print 1, 1, 2. I have to do it recursively and iteratively. I  got the iterative part but I am having a little trouble with the recursive part. In the program I can get it to print the values. Any help would be appreciated.\n\n```\n.data\n\ninputMsg: .asciiz \"Enter number: \"\niterationMsg: .asciiz \"\\nIterative: \"\nrecursionMsg: .asciiz \"\\nRecursive: \"\nseries: .asciiz \"\\nThe series is: \"\nspace: .asciiz \" \"\n\n.text\n\nmain:\n    la $a0, inputMsg        #Print out inputMsg\n    li $v0, 4\n    syscall\n\n    li $v0, 5           #Read in integer into v0\n    syscall\n\n    subi $s0, $v0, 1        #s0 = v0-1\n    add $s7, $s0, 0         #s7 = s0\n    add $s3, $v0, 0     #s3 = v0-1\n\n    addi $s1, $s1, 1        #s1 = 1\n    addi $s2, $s2, 1        #s2 = 1\n\n    la $a0, iterationMsg        #Print out text_iteration\n    li $v0, 4\n    syscall\n\n    la $a0, series          #Print out series\n    syscall\n\n    addi $a0, $zero, 1      #a0 = 1\n    li $v0, 1\n    syscall             #Prints out 1\n\n    jal iterative           #Jump to iterative\n\n    la $a0, recursionMsg        #Print Out Recursion text\n    li $v0, 4\n    syscall\n\n    la $a0, series          #Print out Series text\n    syscall\n\n    add $a0, $s3, $0        #t0 = s3 = inputted val\n    add $s0, $0, $0\n    jal recursive\n\nexit:       \n    li, $v0, 10         #Exit Program\n    syscall\n\niterative:\n    beq $s0, 0, iterativeExit   #if s0 = 0 then exit\n    subi $s0, $s0, 1        # s0 = s0 \n\n    add $t0, $s2, $zero     # t0 = s2(1) + 0 \n    add $s2, $s1, $s2       # s2 = s1(1) + s2(1)\n    add $s1, $t0, $zero     # s1 = t0(1) + 0\n\n    la $a0, space\n    li $v0, 4\n    syscall\n\n    add $a0, $s1, $zero\n    li $v0, 1\n    syscall\n\n    bnez $s0, iterative\n\niterativeExit:\n    jr $ra\n\nrecursive:\n    addi $sp, $sp, -4   #create/save stack\n\n    sw $ra, 0($sp)\n\n    sub $a0, $a0, 1     #minus one from inputted val (a0) till 0\n    beq $a0, 1, oneRec\n    jal recursive\n\n    jal print\n\n        lw  $ra, 0($sp)         #\n        addi $sp, $sp, 4      # decrease the stack size\n\n    jr $ra\noneRec:\n    li $a0, 1\n    li $v0, 1\n    syscall\n\n    addi $s0, $a0, 0\n\n    la $a0, space\n    li $v0, 4\n    syscall\n\n    jr $ra\nprint:\n    add $t0, $0, $a0\n    add $a0, $s0, $a0\n\n    li $v0, 1\n    syscall\n\n    la $a0, space\n    li $v0, 4\n    syscall\n\n    add $s0, $t0, $0\n    jr $ra\n```\n\n    ", "Answer": "\r\nThere is a small error up top. you have $s3 = what you say is $v0 - 1 but you actually have it = to $v0. And you use $s3 in your recursive part\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Limit input to only print a fibonacci sequence up to 16 places?\r\n                \r\nI am have a program which prints off the fibonacci sequence up to a given input. The user puts in a number and it prints out the sequence up to that many numbers.\n\nex: input = 4 prints 1 1 2 3\n\nI want to limit the program to only allowing an input 1-16. The way I have it now will print the sequence an then prints the error message? Any suggestions? Thank you\n\n```\npublic class FibonacciGenerator \n{\n    private int fibonacci = 1;\n\n    public FibonacciGenerator()\n    {\n\n    }\n\n    public int Fibonacci(int number)\n    {\n        if(number == 1 || number == 2)\n        {\n            return 1;\n        }\n        else if (number > 16)\n        {\n            System.out.println(\"Error must select 1-16\");\n        }\n        else\n        {\n            int fib1=1, fib2=1;\n            for(int count= 3; count < 17 && count <= number; count++)\n            {\n                fibonacci = fib1 + fib2;\n                fib1 = fib2;\n                fib2 = fibonacci;\n            }\n        }\n    return fibonacci;\n    }\n}\n```\n\n\nHere is my main method:\n\n```\nimport java.util.Scanner;\n\npublic class FibonacciPrinter \n{\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        System.out.print(\"Enter an integer 1-16: \");\n        int input = in.nextInt();\n\n        FibonacciGenerator newNumber = new FibonacciGenerator();\n\n        System.out.println(\"Fibonacci sequence up to \" + input + \" places.\");\n\n        for(int fibCount = 1; fibCount <= input; fibCount++)\n        {\n            int sequence = newNumber.Fibonacci(fibCount);\n            System.out.print(sequence);\n        } \n    }\n}\n```\n\n    ", "Answer": "\r\nAs a recommendation don't make your methods or variables start with capital letter, capital letter is used by convention for Classes only.\n\nAlso, you should validate ```\ninput```\n variable before passing it to your method.\n\nI mean:\n\n```\nif (input > 16 || input < 1) {\n    System.out.println(\"Enter a number between 1-16\");\n}\nelse {\n\n    for(int fibCount = 1; fibCount <= input; fibCount++)\n    {\n        int sequence = newNumber.Fibonacci(fibCount);\n        System.out.print(sequence);\n    } \n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How can I improve my fibonacci sequence generator? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 1 year ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhat have I done?\n\nI have made a Fibonacci sequence generator, see the code below:\n```\nprev_nums = [0, 1]\ncount = int(1) \n\nfor i in range(20):\n    count += 1\n    ans = prev_nums[count-1] + prev_nums[count-2]\n    print(ans)\n    prev_nums.append(ans)\n\n```\n\nOutput:\n```\n1\n2\n3\n5\n8\n13\n21\n34\n55\n...\n```\n\nBasically, I have a for loop. Every iteration, i will add ```\n1```\n to the variable ```\ncount```\n, so that i can keep track of the index i should use to find the previous numbers to add together.\n(The next value in a fibonacci sequence is always equal to the two values before it added together)\nI then append the value in that specific iteration to the list ```\nprev_nums```\n to keep track of all the values that i have already generated, so that i can generate the next one.\nHow can I improve this code?\n\nI have found some other examples online of a Fibonacci generator, such as:\n```\ndef fibonacci():\n    a=0\n    b=1\n    for i in range(6):\n        print(b)\n        a,b= b,a+b\n```\n\nand,\n```\ndef fib(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n```\n\nWhy are (or why not) are these solutions better/worse than my own and what can I learn from these to improve my own?\n    ", "Answer": "\r\nYours has some disadvantages:\n\nIt only prints the numbers. That reduces its usability to that particular side-effect. You cannot use the numbers for further processing.\nIt builds an ever-growing list that uses up memory even though you only ever need the last two elements.\nYou have hard-coded the number of fibonacci numbers you want to generate. You have to change the generation code if you need more of them.\nIt is not encapsulated in a function. That reduces its reusability.\n\nIssues  1. and 3. also apply to the first alternative you proposed.\nThe parametrized generator function (second proposed alternative)\n```\ndef fib(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n```\n\ndoes not have any of those problems. If you want to print some numbers, you can easily do that (see how the purpose and count are left to the caller):\n```\nfor f in fib(5):\n    print(f)\n```\n\nor you can collect them in a ```\nlist```\n if you need to:\n```\nfib_nums = list(fib(5))\n```\n\nor apply a function to all of them:\n```\nfor double_fib in map((2).__mul__, fib(5)):\n    print(double_fib)\n```\n\nAnd if you need the numbers with their according index, there are built-in utils you can apply:\n```\nfor i, f in enumerate(fib(5)):\n    print(f\"{i}: {f}\")\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequencing difficulties in python\r\n                \r\n(I'm in a basic computer science class, and this is homework)\n\nI am trying to create a basic  fibonacci sequence with \"n\" as the parameter.\n\nwhat I have so far seems to be working fine when I run the program in idle \n\n```\ndef fibonacci(n):\n    a=0\n    b=1\n    n = input(\"How high do you want to go? If you want to go forever, put 4ever.\")\n    print(1)\n    while stopNumber==\"4ever\" or int(stopNumber) > a+b:\n       a, b = b, a+b\n       print(b)\nfibonacci(n)\n```\n\n\nbut when I try to run the program so that it displays the info I get this error\n\n```\n  Traceback (most recent call last):\n File \"C:/Users/Joseph/Desktop/hope.py\", line 10, in <module> fibonacci(n)\n NameError: name 'n' is not defined\n```\n\n\nAny idea how I can fix this?\n    ", "Answer": "\r\nSince your ```\nfibonacci```\n function is taking an input there isn't exactly a need to pass a parameter. But in the case of your error ```\nn```\n isn't defined in the global scope. I would just get rid of the ```\nn```\n parameter. Also, just replace ```\nstopNumber```\n with ```\nn```\n.\n\n```\ndef fibonacci():\n    a=0\n    b=1\n    n = input(\"How high do you want to go? If you want to go forever, put 4ever.\")\n    print(1)\n    while n == \"4ever\" or int(n) > a+b:\n       a, b = b, a+b\n       print(b)\n\nfibonacci()\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Delete element from Array based on fibonacci sequence\r\n                \r\nI have to write the function C that receives a linked list with L pointers of values ​​of type int, e\nreturns among the formal parameters a V array obtained in the following way:  \n\n\nInitially, the function removes from the list L the elements whose position corresponds to a Fibonacci sequence number (assume that the first element of the list has position 1 and that the first two values ​​of the Fibonacci sequence are F0 = 1, F1 = 2, with the generic element of the sequence given by Fn = Fn-1 + Fn-2);\nElements removed from L are inserted into the V array so that the last element removed from L is the overhead element of V (the array V must be allocated internally to the function.) list L).\n\n\nEach element of the L list has the following form:   \n\n```\nstruct list {\n   int value;\nint pos; // posizione occupata inizialmente nella lista struct list * \nnext_ptr;\n};\n```\n\n\nwhere the position occupied by the element in the list does not change during the execution.\nI wrote the following code and would like you to review it.\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\ntypedef unsigned short int Boolean;\n#define FALSE 0\n#define TRUE 1\n#include \"header.h\"\nstruct list{\nint value;\nint pos;\nstruct list * next_ptr;\n};\n\nBoolean function (struct list **L, int** V, int *length){\nint i, j, size;\nint * F;\nstruct list * positionPtr=*L;\nstruct list ** ptrptr=L;\nstruct list *tmp;\nwhile (positionPtr!=NULL && positionPtr->next_ptr!=NULL)\n    positionPtr=positionPtr->next_ptr;\nif (positionPtr!=NULL) size=positionPtr->pos;\nelse return FALSE;\n*V=(int*)malloc(sizeof(int)*(size));\nF=(int*)malloc(sizeof(int)*(size));\nif (*V==NULL || F==NULL) return FALSE;\nF[0]=1;\nF[1]=2;\nfor (i=2;i<size && F[i-1]<size;i++)\n    F[i]=F[i-1]+F[i-2];\ni=0;\nj=size-1;\nwhile (*ptrptr!=NULL){\n    if ((*ptrptr)->pos==F[i]) {\n        (*V)[j] = (*ptrptr)->value;\n        tmp = *ptrptr;\n        *ptrptr = (*ptrptr)->next_ptr;\n        free(tmp);\n        i++;\n        j--;\n    }\n    else\n        ptrptr=&((*ptrptr)->next_ptr);\n}\nfor (i=j+1;i<size;i++)\n    (*V)[i-j-1]=(*V)[i];\n*length=size-j-1;\nreturn TRUE;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to find out if a number is in the Fibonacci Sequence\r\n                \r\nI have created a function that gives the Fibonacci number for a given input. I now want to create a function to check if a given number is in the Fibonacci Sequence.\nHere is what I have done so far:\n```\n-- Basic Fib Function \nfib :: Int -> Int \nfib x =\n  if x < 1\n    then 0\n    else if x < 2\n           then 1\n           else fib (x - 1) + fib (x - 2)\n\n-- Outputs list of all the functions \nfibList :: [Int]\nfibList  = map fib [1..]\n--  function that takes an Integer, and returns True if the argument is a Fibonacci number and False otherwise\nisFib :: Int -> [Int] -> Bool\nisFib n fibList\n    |n `elem` fibList = True\n    |otherwise = False\n```\n\n```\nfibList```\n works but the computation is taking very long time.\nAlso, I have done this:\n```\nfibList' :: [Int]\nfibList'  = map fib [1..100]\n\nisFib' :: Int -> [Int] -> Bool\nisFib' n fibList'\n    |n `elem` fibList' = True\n    |otherwise = False\n```\n\nWith a smaller number, it still takes a long time to compute\nghci\n    ", "Answer": "\r\nThe problem is that ```\nn```\n is an ```\nInt```\n and ```\nfibList```\n is an ```\n[Int]```\n, you can not check if an ```\nInt```\n and ```\n[Int]```\n are the same, since these have a different type.\nUsing ```\nelem```\n will also fail in case the given number is not a Fibonacci number, since Haskell will keep enumerating over the list looking for the next candidate and will only return ```\nFalse```\n if it reaches the end of the list, but if you generate an infinite list, then this will never end.\nYou can implement the ```\nisFib```\n function where we check if the first item of the list is greater than ```\nn```\n. If that is the case, we know that all remaining elements will be larger, and thus we can stop searching:\n```\nisFib :: Int -> [Int] -> Bool\nisFib _ [] = False\nisFib n (x:xs)\n    | x >= n = -- ...  🖘 to implement\n    | otherwise = isFib n xs```\n\nwhere I leave filling in the ```\n…```\n part as an exercise.\nYour ```\nfib```\n function is not very efficient: it will take exponential time to determine the n-th element. You can generate the Fibonacci numbers through recursion and check if one of the items we generate is indeed a Fibonacci number:\n```\nisFib :: Int -> Bool\nisFib n = go 0 1\n  where go f1 f2\n          | f1 >= n = …\n          | otherwise = go f2 (f1 + f2)```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence sum of even numbers\r\n                \r\nI ran across this problem here on stackoverflow:\n\n\n  \"I'm having some trouble with this problem in Project Euler.\n  Here's what the question asks:\n  Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... Find the sum of all the even-valued terms in the sequence which do not exceed four million.\"\n\n\nThe top answer was this(which does not compile for me in VS2010...why?): \n\n```\n    IEnumerable<int> Fibonacci()\n    {\n        int n1 = 0;\n        int n2 = 1;\n\n        yield return 1;\n        while (true)\n        {\n          int n = n1 + n2;\n          n1 = n2;\n          n2 = n;\n          yield return n;\n        }\n    }\n\n    long result=0;\n\n    foreach (int i in Fibonacci().TakeWhile(i => i<4000000).Where(i % 2 == 0))\n    {\n        result+=i;\n    }\n    Console.WriteLine(result);\n```\n\n\nI decided to try it for myself before looking for an answer and came up with this(please tell me why or why not this is a good or bad way of solving this problem):\n\nI wrote it in a class because I could add much more to the class in the future than just solving a single Fibonacci problem.\n\n```\nclass Fibonacci\n{\n    private int prevNum1 = 1;\n    private int prevNum2 = 2;\n    private int sum = 0;\n\n    public int GetSum(int min, int max)\n    {\n        prevNum1 = min;\n        prevNum2 = prevNum1 + prevNum1;\n        if (prevNum1 % 2 == 0)\n        {\n            sum += prevNum1;\n        }\n        if (prevNum2 % 2 == 0)\n        {\n            sum += prevNum2;\n        }\n        int fNum = 0;\n        while (prevNum2 <= max)\n        {\n            fNum = prevNum1 + prevNum2;\n            if (fNum % 2 == 0)\n            {\n                //is an even number...add to total\n                sum += fNum;\n            }\n            prevNum1 = prevNum2;\n            prevNum2 = fNum;\n\n        }\n\n        return sum;\n    }\n\n}\n\n        Fibonacci Fib = new Fibonacci();\n        int sum = Fib.GetSum(1, 4000000);\n\n        Console.WriteLine(\"Sum of all even Fibonacci numbers 1-4,000,000 = {0}\", sum);\n```\n\n\nAgain, I'm looking for an answer as to why this is a good or bad way to solve this problem. Also why the first solution does not compile. I'm a beginning programmer and trying to learn. Thanks!\n    ", "Answer": "\r\nWith this it must compile:\n\n```\nforeach (int i in Fibonacci().TakeWhile(i => i < 4000000).Where(i => i % 2 == 0))\n{\n    result += i;\n}\n```\n\n\nThe problem why the code didn't compile was bad lambda expression, it was:\n\n```\n.Where(i % 2 == 0)\n```\n\n\nbut must be\n\n```\n.Where(i => i % 2 == 0)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "The fastest Java algorithm for calculating nth term of Fibonacci sequence? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nIs it known what is the fastest Java algorithm for calculating nth term of Fibonacci sequence ? \n\nI have found these algorithms . I guess that Iterative algorithms should be faster than Recursive and Analytic algorithms .  \n    ", "Answer": "\r\nPrecalculate all Fibonacci numbers up to a sufficiently large number of n, and generate a source code snippet defining an array with the numbers in a type which can hold these numbers.\n\nThen you can just retrieve the value in index ```\nn```\n in your array.  This is ```\nO(1)```\n.  Doesn't come much faster than that.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to parallel Fibonacci sequence until 10^5 term\r\n                \r\nI need to parallel (with openmp) the Fibonacci sequence from this sequential code to calculate the 105-th term of the sequence, but I have been stuck for 3 weeks without any good idea, someone have any idea or tip of a good way to do it?\n\nHere is the sequential code in C:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100010\n#define LEN 25001\n\nchar seq[MAX][LEN];\n\nvoid add(int a, int b) {\n    int i, aux, s;\n\n    for (i = 0, aux = 0; seq[a][i] != '\\0' && seq[b][i] != '\\0'; i++) {\n        s = seq[a][i] + seq[b][i] + aux - '0' - '0';\n        aux = s / 10;\n        seq[a + 1][i] = s % 10 + '0';\n    }\n\n    while (seq[a][i] != '\\0') {\n        s = seq[a][i] + aux - '0';\n        aux = s / 10;\n        seq[a + 1][i] = s % 10 + '0';\n        i++;\n    }\n\n    while (seq[b][i] != '\\0') {\n        s = seq[b][i] + aux - '0';\n        aux = s / 10;\n        seq[a + 1][i] = s % 10 + '0';\n        i++;\n    }\n\n    if (aux != 0)\n        seq[a + 1][i++] = aux + '0';\n\n    seq[a + 1][i] = '\\0';\n}\n\nint main() {\n    int n, i, len;\n\n    seq[0][0] = '0';\n    seq[0][1] = '\\0';\n    seq[1][0] = '1';\n    seq[1][1] = '\\0';\n\n    for (i = 2; i < MAX; i++)\n        add(i - 1, i - 2);\n\n    scanf(\"%d\", &n);\n\n    len = strlen(seq[n]);\n    for (i = 0; i <= len - 1; i++)\n        printf(\"%c\", seq[n][len - 1 - i]);\n    printf(\"\\n\");\n    fflush(stdout);\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nInstead of trying to parallelise the bignum addition, which is tricky, you can take try and compute multiple terms in parallel:\n\n```\nF(n+1) = F(n) + F(n-1)\nF(n+2) = F(n+1) + F(n) = 2*F(n) + F(n-1)\nF(n+3) = F(n+2) + F(n+1) = 2*F(n+1) + F(n) = 2*F(n) + 2*F(n-1) + F(n) = 3*F(n) + 2*F(n-1)\n...\n```\n\n\nNote also that you should compute blocks of digits at a time: 8 or 9 base-10 digits can be computed using 32-bit array elements.\n\nHere is a modified version with multiple improvements:\n\n\nit computes blocks of 8 digits at a time\nit can take command line arguments\nit uses much less memory\nit can handle much larger values\nit is much more efficient (20x)\n\n\nYou should be able to parallelise it easily.\n\n```\n/* Parallelisable bignum Fibonacci computation by chqrlie */\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 0\n\n/* 2500ms for fib(100000) */\n#define DIGIT  10\n#define NDIGIT 1\n#define FMT \"d\"\ntypedef unsigned char digit_t;\n\n#elif 1\n\n/* 279ms for fib(100000) */\n#define DIGIT  100000000\n#define NDIGIT 8\n#define FMT PRIu32\ntypedef uint32_t digit_t;\n\n#else\n\n/* 720ms for fib(100000) */\n#define DIGIT  1000000000000000000\n#define NDIGIT 18\n#define FMT PRIu64\ntypedef uint64_t digit_t;\n\n#endif\n\nint add1(digit_t *c, const digit_t *a, int alen, const digit_t *b, int blen) {\n    digit_t aux, s;\n    int i;\n\n    /* assuming alen >= blen */\n    for (i = 0, aux = 0; i < alen; i++) {\n        s = a[i] + b[i] + aux;\n        aux = s / DIGIT;\n        c[i] = s % DIGIT;\n    }\n    if (aux != 0) {\n        c[i++] = (digit_t)aux;\n    }\n    return i;\n}\n\nint add2(digit_t *c, const digit_t *a, int alen, const digit_t *b, int blen) {\n    digit_t aux, s;\n    int i;\n\n    /* assuming alen >= blen */\n    for (i = 0, aux = 0; i < alen; i++) {\n        s = 2 * a[i] + b[i] + aux;\n        aux = s / DIGIT;\n        c[i] = s % DIGIT;\n    }\n    if (aux != 0) {\n        c[i++] = (digit_t)aux;\n    }\n    return i;\n}\n\nint add3(digit_t *c, const digit_t *a, int alen, const digit_t *b, int blen) {\n    digit_t aux, s;\n    int i;\n\n    /* assuming alen >= blen */\n    for (i = 0, aux = 0; i < alen; i++) {\n        s = 3 * a[i] + 2 * b[i] + aux;\n        aux = s / DIGIT;\n        c[i] = s % DIGIT;\n    }\n    if (aux != 0) {\n        c[i++] = (digit_t)aux;\n    }\n    return i;\n}\n\nint add4(digit_t *c, const digit_t *a, int alen, const digit_t *b, int blen) {\n    digit_t aux, s;\n    int i;\n\n    /* assuming alen >= blen */\n    for (i = 0, aux = 0; i < alen; i++) {\n        s = 5 * a[i] + 3 * b[i] + aux;\n        aux = s / DIGIT;\n        c[i] = s % DIGIT;\n    }\n    if (aux != 0) {\n        c[i++] = (digit_t)aux;\n    }\n    return i;\n}\n\nvoid printseq(const digit_t *s, int len) {\n    printf(\"%\"FMT, s[len - 1]);\n    for (int i = 1; i < len; i++)\n        printf(\"%.*\"FMT, NDIGIT, s[len - 1 - i]);\n    printf(\"\\n\");\n}\n\nint main(int argc, char *argv[]) {\n    int MIN, i, LEN, MAX;\n\n    if (argc > 1) {\n        MAX = MIN = strtol(argv[1], NULL, 0);\n        if (argc > 2)\n            MAX = strtol(argv[2], NULL, 0);\n    } else {\n        scanf(\"%d\", &MIN);\n        MAX = MIN;\n    }\n\n    /* length if fib(n) is less than n*log10(phi)+2 */\n    LEN = (MAX * 20910ULL) / 100000 / NDIGIT + 2;\n    /* allocate 8 bignums */\n    int *slen = calloc(sizeof(*slen), 8);\n    digit_t (*seq)[LEN] = calloc(sizeof(*seq), 8);\n\n    if (slen == NULL || seq == NULL) {\n        fprintf(stderr, \"memory allocation error\\n\");\n        return 1;\n    }\n\n    seq[0][0] = 0;\n    slen[0] = 1;\n    if (0 >= MIN) printseq(seq[0], slen[0]);\n    seq[1][0] = 1;\n    slen[1] = 1;\n    if (1 >= MIN) printseq(seq[1], slen[1]);\n\n    for (i = 2; i <= MAX && (MAX + 1 - i) % 4 != 0; i++) {\n        slen[i] = add1(seq[i], seq[i - 1], slen[i - 1], seq[i - 2], slen[i - 2]);\n        if (i >= MIN) printseq(seq[i], slen[i]);\n    }\n    for (; i <= MAX; i += 4) {\n        int im2 = (i - 2) & 7;\n        int im1 = (i - 1) & 7;\n        int i0 = (i + 0) & 7;\n        int i1 = (i + 1) & 7;\n        int i2 = (i + 2) & 7;\n        int i3 = (i + 3) & 7;\n        /* the next 4 calls can be parallelised */\n        slen[i0] = add1(seq[i0], seq[im1], slen[im1], seq[im2], slen[im2]);\n        slen[i1] = add2(seq[i1], seq[im1], slen[im1], seq[im2], slen[im2]);\n        slen[i2] = add3(seq[i2], seq[im1], slen[im1], seq[im2], slen[im2]);\n        slen[i3] = add4(seq[i3], seq[im1], slen[im1], seq[im2], slen[im2]);\n        /* the print calls must be called sequentially */\n        if (i + 0 >= MIN) printseq(seq[i0], slen[i0]);\n        if (i + 1 >= MIN) printseq(seq[i1], slen[i1]);\n        if (i + 2 >= MIN) printseq(seq[i2], slen[i2]);\n        if (i + 3 >= MIN) printseq(seq[i3], slen[i3]);\n    }\n    free(slen);\n    free(seq);\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to return the sum of only even numbers in Fibonacci sequence? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        sum of even numbers in Fibonacci sequence\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm struggling to make this loop work. Is the for/while loop a good way to return the sum of even numbers in a Fibonacci sequence?\n\n```\n   function evenFib() {\n  var x, y, total;\n  for (var i = 0; i < 10; i++) {\n    if (i === 0) {\n      x = 1;\n      y = 2;\n    }\n\n    while( x %2===0) {\n      total = x + y;\n      x = y;\n      y = total;\n    }\n\n    return(total);\n  }\n};\n```\n\n    ", "Answer": "\r\n```\n    function fibEven(){\n        var max = 50;\n        var cur = 1;\n        var last = 1;\n        var evens = 0;\n        for(var i = 1; i < max; i ++)\n        {\n            var tlast = i > 1 ? cur : last;\n            cur = cur + last;\n            last = tlast;\n            if(cur % 2 === 0)\n            {\n                evens += cur;   \n                console.log(evens);             \n            }\n\n        }\n\n       return evens;\n    }\n```\n\n\nI'm not even sure how to begin explaining why your attempt is not going to work. So basically we give this a range since fibonacci is infinite. You will start getting insane numbers around 100 iterations. general rule is next number is this number plus last number. use modulus to check if there's a remainder at all. If not, add to the total evens. run this function and see.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Custom/Modified 'Fibonacci' Number sequence\r\n                \r\nI need to produce a much more different implementation of the Fibonacci sequence. Here is the implementation \n\n```\n(FSM) - FSM(0) = 0,\nFSM(1) = 1, \nFSM(n) = FSM(n - 2) + FSM(n - 1) / n\n```\n\n\nHow do I achieve this in javascript? I am supposed to feed in a large int ```\n60000000```\n and get the next 10 numbers in the sequence. \n\nPlease note that there is a /n on the (n-1) part of the equation.\n\nMy current code looks like this:\n\n```\nvar fibonacci = (function() {\n        var memo = {};\n\n\n          function f(n) {\n            var value;\n\n\n            if (n in memo) {\n              value = memo[n];\n            } else {\n              if (n === 0 || n === 1)\n                value = n;\n              else             \n              value = f(n - 1)/n + f(n - 2);\n              memo[n] = value;\n            }\n            console.log(value);\n            return value;\n          }\n\n\n          return f;\n        })();\nfibonacci(10);\n```\n\n\nNow my task says \"Get the 10 following Modified Fibonacci Numbers starting from 60000000 element\"\n\nIf I pass fibonacci(60000000); this will crash.\n    ", "Answer": "\r\nUPDATE:\n\nTry following one.\nParameters: ```\nn```\n from where to start saving numbers, ```\nm```\n how many numbers do you want to save\n\n```\nfunction getFibonacci(n,m) {\n    var a = 0, b = 1, z = null, arr = [], c = 0;\n\n    for ( var i = 0; i <= n; i++ ) {\n        if ( a >= n ) {\n            if ( c >= m ) {\n                return arr;\n            }\n            arr.push(a);\n            c++;\n        }\n        z = a + b;\n        a = b;\n        b = z;\n    }\n}\n\ngetFibonacci(60000000,10); // [63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976]\n```\n\n\nDEMO\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding the sum of even valued terms in fibonacci sequence using for loop\r\n                \r\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\nBy considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\n\n```\nprev, cur = 0, 1\ntotal = 0\nwhile True:\n    prev, cur = cur, prev + cur\n    if cur >= 4000000:\n        break\n    if cur % 2 == 0:\n        total += cur\nprint(total)\n```\n\n\nHow can i solve this using for loop?\n    ", "Answer": "\r\n```\nfirst = 0\nsecond = 1\nfor i in range(1,4000000):\n    next=(first+second)\n    print(next)\n    first=second\n    second=next \n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How efficient is this Python Code for the fibonacci sequence? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Efficient calculation of Fibonacci series\r\n                            \r\n                                (34 answers)\r\n                            \r\n                    \r\n                Closed 3 months ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI wrote this a few days ago and it seems to be working fine, but it is slow. It took 25 seconds to generate the 1 millionth number in the fibonacci sequence. Is there a way to make this more efficient?\n\n```\ndef main():\n    num1 = 0\n    num2 = 1\n    var = 0\n    num = int(raw_input(\"What fibonacci number do you want to know? \"))\n    while 1:\n        num3 = num1\n        num1 = num1 + num2\n        num2 = num3\n        var+=1\n        if var>=num:\n            print num3\n            return main()\n        else:\n            None\n\nmain()\n```\n\n\nNote that I am a beginner in python, so I won't understand advanced concepts\n    ", "Answer": "\r\nI've found that using Lucas numbers gives me results fastests:\n\n```\ndef powLF(n):\n    if n == 1:     return (1, 1)\n    L, F = powLF(n//2)\n    L, F = (L**2 + 5*F**2) >> 1, L*F\n    if n & 1:\n        return ((L + 5*F)>>1, (L + F) >>1)\n    else:\n        return (L, F)\n\ndef fib(n):\n    if n & 1:\n        return powLF(n)[1]\n    else:\n        L, F = powLF(n // 2)\n        return L * F\n```\n\n\nLike matrix exponention, it has O(NlogN) complexity, but it's constant cost is lower, thus beating it 'on points':\n\n```\n>>> timeit.timeit('fib(1000)', 'from __main__ import fibM as fib', number=10000)\n0.40711593627929688\n>>> timeit.timeit('fib(1000)', 'from __main__ import fibL as fib', number=10000)\n0.20211100578308105\n```\n\n\nYes, that's twice as fast.\n\nI can't take credit for the above implementation, nor of the matrix exponention algorithm I compared it with; both were listed on literateprograms.org.\n\nTo calculate the 1,000,000th Fibonacci number takes:\n\n```\n>>> timeit.timeit('fib(1000000)', 'from __main__ import fib', number=100)/100\n0.09112384080886841\n```\n\n\njust under a 10th of a second.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why python fibonacci sequence loop is slower than recursion?\r\n                \r\nBelow is the well-known example of fibonacci sequence\n```\n# test.py\nimport sys\nsys.setrecursionlimit(20000)\n\ndef fib_loop(n):\n    if n <= 1:\n        return n\n    fn, fnm1 = 1, 0\n    for _ in range(2, n+1):\n        fn, fnm1 = fn + fnm1, fn\n    return fn\n\ndef fib_recursion(n, memo={}):\n    if n <= 1:\n        return n\n    if n not in memo:\n        memo[n] = fib_recursion(n-1, memo) + fib_recursion(n-2, memo)\n    return memo[n]\n```\n\nAs everybody does, I used to think that the loop variant will be much faster than the recursive one. However, the actual result is quite surprising.\n```\n$ python3 -m timeit \"import test; test.fib_loop(10000)\"\n100 loops, best of 5: 1.93 msec per loop\n$ python3 -m timeit \"import test; test.fib_recursion(10000)\"\n500000 loops, best of 5: 471 nsec per loop\n```\n\nI have no idea why. Could anybody help me?\n    ", "Answer": "\r\nBecause you are memoizing your result. And you are re-using that memo dict on every iteration. So the first time it runs it is slow. On every other invoctation, it is a simple dict-lookup.\nIf you use ```\nnumber=1```\n so it only runs just once, you'll see the first call is actually slower\n```\n>>> import sys\n>>> sys.setrecursionlimit(20000)\n>>>\n>>> def fib_loop(n):\n...     if n <= 1:\n...         return n\n...     fn, fnm1 = 1, 0\n...     for _ in range(2, n+1):\n...         fn, fnm1 = fn + fnm1, fn\n...     return fn\n...\n>>> def fib_recursion(n, memo={}):\n...     if n <= 1:\n...         return n\n...     if n not in memo:\n...         memo[n] = fib_recursion(n-1, memo) + fib_recursion(n-2, memo)\n...     return memo[n]\n...\n>>> import timeit\n>>> timeit.timeit(\"fib_loop(1000)\", setup=\"from __main__ import fib_loop\", number=1)\n9.027599999456015e-05\n>>> timeit.timeit(\"fib_recursion(1000)\", setup=\"from __main__ import fib_recursion\", number=1)\n0.0016194200000114733\n```\n\nAlternatively, if you pass a new memo dict for each outer call, you get the same behavior:\n```\n>>> timeit.timeit(\"fib_recursion(1000, {})\", setup=\"from __main__ import fib_recursion\", number=1000)\n0.38679519899999093\n>>> timeit.timeit(\"fib_loop(1000)\", setup=\"from __main__ import fib_loop\", number=1000)\n0.07079556799999409\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Get number of Nth place of modified Fibonacci sequence\r\n                \r\nIn an interview today, I was given this sequence, which is sort of a modified Fibonacci:\n\n1, 1, 2, 4, 6, 13, 19, 42, 61, 135, ...,\n\nI was asked to write a function to return the number at place n.\n\nSo, if n = 4, the function should return 4, n = 6 return 13, etc.\n\nAs I'm sure you already noticed, the difference is that even items equal the previous 4 items, while odd items equal the previous 2.\n\nIt isn't a problem if you use recursion. That's what I did, but it's not the approach I would have liked.\n\nThe Fibonacci calculation goes something like this (in PHP):\n\n```\n$n = 17;\n$phi = (1 + sqrt(5)) / 2;\n$u = (pow($phi, $n) - pow(1 - $phi, $n)) / sqrt(5);\n```\n\n\n$u being, in this case, 1597.\n\nHowever, I have no idea how to solve it with a modified version of a Fibonacci sequence like this one.\n    ", "Answer": "\r\nIf I understand you correctly, you want to compute efficiently [i.e. in O( log(n) )] sequence defined as:\n\n```\na[2n + 5] = a[2n + 4] + a[2n + 3] + a[2n + 2] + a[2n + 1]\na[2n + 2] = a[2n + 1] + a[2n]\n```\n\n\nLet's define two new sequences. First one will correspond to the values of a on even positions, the second one to the values on even positions:\n\n```\nb[n] = a[2n]\nc[n] = a[2n + 1]\n```\n\n\nNow we have:\n\n```\nc[n] = b[n] + c[n - 1] + b[n - 1] + c[n - 2]\nb[n] = c[n - 1] + b[n - 1]\n```\n\n\nSubtracting the second equation from the first we get (after some transformation):\n\n```\nb[n] = ( c[n] - c[n-1] ) /2\n```\n\n\nNext substitute this formula into first equation to get formula for c:\n\n```\nc[n] = 2 c[n-1] + c[n-2] \n```\n\n\nNotice that this equation involves only elements from c. Therefore now it is possible to compute elements of c, using techniques described here. By transforming equations a little bit further you will be able to compute b efficiently as well.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generalizing Fibonacci sequence with SICStus Prolog\r\n                \r\nI'm trying to find a solution for a query on a generalized Fibonacci sequence (GFS). The query is: are there any GFS that have 885 as their 12th number? The initial 2 numbers may be restricted between 1 and 10.\n\nI already found the solution to find the Nth number in a sequence that starts at (1, 1) in which I explicitly define the initial numbers. Here is what I have for this:\n\n```\nfib(1, 1).\nfib(2, 1).\n\nfib(N, X) :-\n    N #> 1,\n    Nmin1 #= N - 1,\n    Nmin2 #= N - 2,\n    fib(Nmin1, Xmin1),\n    fib(Nmin2, Xmin2),\n    X #= Xmin1 + Xmin2.\n```\n\n\nFor the query mentioned I thought the following would do the trick, in which I reuse the fib method without defining the initial numbers explicitly since this now needs to be done dynamically:\n\n```\nfib(N, X) :-\n    N #> 1,\n    Nmin1 #= N - 1,\n    Nmin2 #= N - 2,\n    fib(Nmin1, Xmin1),\n    fib(Nmin2, Xmin2),\n    X #= Xmin1 + Xmin2.\n\nfib2 :-\n    X1 in 1..10,\n    X2 in 1..10,\n    fib(1, X1),\n    fib(2, X2),\n    fib(12, 885).\n```\n\n\n... but this does not seem to work.\n\nIs it not possible this way to define the initial numbers, or am I doing something terribly wrong? I'm not asking for the solution, but any advice that could help me solve this would be greatly appreciated.\n    ", "Answer": "\r\nUnder SWI-Prolog:\n\n```\n:- use_module(library(clpfd)).\n\nfib(A,B,N,X):-\n    N #> 0,\n    N0 #= N-1,\n    C #= A+B,\n    fib(B,C,N0,X).\nfib(A,B,0,A).\n\ntask(A,B):-\n    A in 1..10,\n    B in 1..10,\n    fib(A,B,11,885).\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python: Find Every Fibonacci Sequence in a Given List of Numbers\r\n                \r\na program that takes a list of numbers separated with \",\" from the user and extracts and prints every fibonacci sequence from the list.\nlike this:\n\n```\nIn: 5,6,9,3,0,1,1,2,3,8,2,9,3,0,1,1,2,3,5,98\nOut: \n[0,1,1,2,3]\n[0,1,1,2,3,5]\n```\n\n\ni tried to use \"for\" loops to find the first 0 and process the program after it. like it checks and follows the list for the fibonacci sequence until it's out of the sequence, prints the list, and then looks for the next 0.\ni wrote the part of the code that gets the input, but i don't know how to do the rest\n\n```\nnumbers = input(\"Enter your numbers list and use comma to seperate them: \")\nnumlist = numbers.split(\",\")\nnumlist = [int(x) for x in numlist]\nresult = []\n```\n\n\n\"result\" is the output list (or lists).\ni hope my explanations were clear. anyone can help?\n    ", "Answer": "\r\nBelow program should work, it will check for the fibbonaci series in the list of numbers\n\n```\nnumbers = [5,6,9,3,0,1,1,2,3,8,2,9,3,0,1,1,2,3,5,98]\n\nfirst = numbers[0]\nsecond = numbers[1]\n\nfibbonacci = []\nresult = []\n\nfor number in numbers[2:]:\n    if first + second == number:\n        if not fibbonacci:\n            fibbonacci.extend([first, second, number])\n        else:\n            fibbonacci.append(number)\n    elif fibbonacci:\n        result.append(fibbonacci)\n        fibbonacci = []\n    first = second\n    second = number\n\nprint(result)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Need help summing all even numbers in a given Fibonacci sequence (Project Euler)\r\n                \r\nI'm doing Problem 232. Project Euler: Problem 2, Sum of even Fibonacci on Cody. I need to sum all even terms in a Fibonacci sequence with a given Fibonacci number. I pass 3/4 tests but the final test evades me. This is the code that I have written:\n```\nfunction y = euler002(x)\nf(1) = 1;\nf(2) = 2;\nn = 10^5;\nfor i = 3:n-2\n    f(i) = f(i-1) + f(i-2);\n    if f(end) > x\n        break\n    else\n        continue\n    end   \nend\n\nidx = rem(f, 2) == 0;\ny = sum(f(idx))     \nend\n```\n\nSo I'm constructing the Fibonacci sequence in f and then extracting and summing the even Fibonacci numbers in the sequence.\nIn the final test, we are given x = 666576 and the sum should evaluate to 257114. However, I'm getting it to be 1089154.\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Return a specific number from the fibonacci sequence in C\r\n                \r\nI'm writing a C program that calculates a specific number in the fibonacci sequence, though I'm having trouble returning the sequence as an array....\n\nWhat am I doing wrong?\n\n\nint fibonacci(int ceiling)\n{\n  int counter;\n  int num1 = 1, num2 = 1;\n  static int fibArray[1000];\n  for (counter = 1; counter < ceiling; counter+=2)\n    {\n      fibArray[counter] = num1;\n      fibArray[counter+1] = num2;\n      num2 += num1;\n      num1 += num2;\n    }\n  return &(fibArray);\n}\n\n\nI also get the error:\n\n\nfibonacci.c:28: warning: return makes integer from pointer without a cast\n\n\n?\n    ", "Answer": "\r\nSince you are returning a pointer to an array, the return type should be ```\nint*```\n. Here is sample code:\n\n```\nint* fibonacci(int ceiling) //Modified return type\n{\n  int counter;\n  int num1 = 1, num2 = 1;\n  static int fibArray[1000];\n  for (counter = 1; counter < ceiling; counter+=2)\n    {\n      fibArray[counter] = num1;\n      fibArray[counter+1] = num2;\n      num2 += num1;\n      num1 += num2;\n    }\n  return (fibArray); //Return the address of the array's starting position\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "postgreSQL Fibonacci Sequence - Query has no destination for result data\r\n                \r\nSo I wrote a Fibonacci sequence function like this:\n\n```\nCREATE OR REPLACE FUNCTION fibonacci (lastN INTEGER) \nRETURNS int AS $$\nBEGIN\nWITH RECURSIVE t(a, b) AS (\n    VALUES(0,1)\n    UNION ALL\n        SELECT GREATEST(a, b), a + b AS a from t\n        WHERE b < $1\n)\nSELECT a FROM t;\nEND;\n$$ LANGUAGE plpgsql;\n```\n\n\nBut when I called:\n\n```\nSELECT * FROM fibonacci(20);\n```\n\n\nthe console shows:\n\n```\nERROR:  query has no destination for result data\nHINT:  If you want to discard the results of a SELECT, use PERFORM instead.\nCONTEXT:  PL/pgSQL function fibonacci(integer) line 5 at SQL statement\n```\n\n\nI think the Return statement should return the query result but it isn't. I'm completely a new guy on writing SQL functions like this.\n    ", "Answer": "\r\nYou are close. Basically your ```\nSELECT```\n is leading to nowhere and your function header says it is supposed to return a ```\nINT```\n value. Since it is a pure ```\nSQL```\n query using ```\nCTE```\n, there is no need to use ```\nPLPGSQL```\n, so I also changed the language type to ```\nSQL```\n\n\n```\nCREATE OR REPLACE FUNCTION fibonacci (lastN INTEGER) \nRETURNS SETOF INTEGER LANGUAGE SQL AS $$\nWITH RECURSIVE t(a, b) AS (\n    VALUES(0,1)\n    UNION ALL\n        SELECT GREATEST(a, b), a + b AS a from t\n        WHERE b < $1\n)\nSELECT a FROM t;\n$$;\n\nSELECT fibonacci(20);\n```\n\n\nEDIT: as requested, the same function using the language ```\nPLPGSQL```\n\n\n```\nCREATE OR REPLACE FUNCTION fibonacci (lastN INTEGER) \nRETURNS SETOF INT LANGUAGE PLPGSQL AS $$\nBEGIN\nRETURN QUERY WITH RECURSIVE t(a, b) AS (\n    VALUES(0,1)\n    UNION ALL\n        SELECT GREATEST(a, b), a + b AS a from t\n        WHERE b < $1\n)\nSELECT a FROM t;\nEND $$;\n\nSELECT fibonacci(20);\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "What is wrong with my fibonacci sequence program that uses \"for loop\"\r\n                \r\n```\ndef fibonacci(n):\n    terms = [0,1]\n    i = 2\n\n    for i in terms[2:n+1]:\n        terms.append(terms[i-1] + terms[i-2])\n        return terms[n]\n\nuser_input= input ('Write the number order by which you want to know its corresponding value in the fibonacci sequence')\nfibonacci_user_input = fibonacci(user_input)\nprint fibonacci_user_input\n```\n\n\nThe semantic error cited in the Pyscripter Python 2.7.9 that I'm using regarding this program is that it returns the value ```\nNone```\n.\nI'm just starting to learn Python and I have been finding what is wrong with this program for quite some time now.\nI already discovered how to write Fibonacci sequence program using while loop and recursion and I'm just having a hard time using this process.\n    ", "Answer": "\r\n```\nfor i in terms[2:n+1]:\n```\n\n\nshould be:\n\n```\nfor i in range(2, n+1):\n```\n\n\nYou're adding to ```\nterms```\n, you don't want to iterate over its current contents.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence going wrong for large numbers\r\n                \r\nI have just started learning C++ and here is my C++ code for generating fibonacci sequences. \n\n```\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    while(true){\n        cout << \"Enter the number of terms upto which a the fibonocci sequence should be generated: \";\n    cin >> n;\n    cout << \"------------------------\" << endl;\n    long long fib1 = 1;\n    long long fib2 = 1;\n    long long fibnext;\n    cout << 1 << \" \" << fib1 << endl << 2 << \" \" << fib2 <<endl;\n\n    for (int i =1; i <= n-2; ++i){\n        fibnext = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = fibnext;\n        cout << i+2 << \" \" << fibnext << endl;\n    }\n    }\nreturn 0;\n}\n```\n\n\nThis code produces correct numbers up to the 92nd term, but goes wrong in the 93rd term. I have no idea why. My guess is that it's related to the data type of fib1, fib2 and fibnext.\nHow can I make my code correct so that it generates the sequence up to any number?\n\nEDIT:\n\nI generated the first 100 terms and here is the result:\n\n```\nEnter the number of terms upto which a the fibonocci sequence should be generated: \n100\n------------------------\n1 1\n2 1\n3 2\n4 3\n5 5\n6 8\n7 13\n8 21\n9 34\n10 55\n11 89\n12 144\n13 233\n14 377\n15 610\n16 987\n17 1597\n18 2584\n19 4181\n20 6765\n21 10946\n22 17711\n23 28657\n24 46368\n25 75025\n26 121393\n27 196418\n28 317811\n29 514229\n30 832040\n31 1346269\n32 2178309\n33 3524578\n34 5702887\n35 9227465\n36 14930352\n37 24157817\n38 39088169\n39 63245986\n40 102334155\n41 165580141\n42 267914296\n43 433494437\n44 701408733\n45 1134903170\n46 1836311903\n47 2971215073\n48 4807526976\n49 7778742049\n50 12586269025\n51 20365011074\n52 32951280099\n53 53316291173\n54 86267571272\n55 139583862445\n56 225851433717\n57 365435296162\n58 591286729879\n59 956722026041\n60 1548008755920\n61 2504730781961\n62 4052739537881\n63 6557470319842\n64 10610209857723\n65 17167680177565\n66 27777890035288\n67 44945570212853\n68 72723460248141\n69 117669030460994\n70 190392490709135\n71 308061521170129\n72 498454011879264\n73 806515533049393\n74 1304969544928657\n75 2111485077978050\n76 3416454622906707\n77 5527939700884757\n78 8944394323791464\n79 14472334024676221\n80 23416728348467685\n81 37889062373143906\n82 61305790721611591\n83 99194853094755497\n84 160500643816367088\n85 259695496911122585\n86 420196140727489673\n87 679891637638612258\n88 1100087778366101931\n89 1779979416004714189\n90 2880067194370816120\n91 4660046610375530309\n92 7540113804746346429\n93 -6246583658587674878\n94 1293530146158671551\n95 -4953053512429003327\n96 -3659523366270331776\n97 -8612576878699335103\n98 6174643828739884737\n99 -2437933049959450366\n100 3736710778780434371\n```\n\n    ", "Answer": "\r\nHave a look at the following table of values:\n\n\n     4660046610375530309 - 92nd Fibonacci number\n     9223372036854775807 - largest 64-bit two's complement, 2^63 - 1\n    12200160415121876738 - 93rd Fibonacci number\n    18446744073709551615 - largest 64-bit unsigned, 2^64 - 1\n\n\nAs you can see, a 64-bit two's complement type (which is almost certainly what the ```\nlong long```\n type is in your case) has enough capacity to store the 92nd Fibonacci number, but the 93rd one is too large for it.\n\nSo what you're seeing is overflow, where the number wraps around into the negative space (what is actually happening is undefined behaviour where there is no guarantee that you will see any particular result, it's just that overflow to negative is a common occurrence).\n\nIf you want to calculate Fibonacci numbers beyond the 92nd, you'll need a \"wider\" data type, one able to handle larger numbers. Switching to ```\nunsigned long long```\n will allow to to calculate the 93rd (see the fourth entry in above table, the limit of the unsigned 64-bit variant) but nothing beyond that.\n\nIt won't go negative any more (since it's unsigned) but it will still give an erroneous result since the 94th seems to be smaller than the 93rd, something that's clearly impossible in the Fibonacci sequence where each term is the sum of the two previous terms, always positive:\n\n```\n:\n92 7540113804746346429\n93 12200160415121876738\n94 1293530146158671551    <<<--- ???\n95 13493690561280548289\n```\n\n\nFor larger values, you can switch to an arbitrary-precision (colloquially referred to as \"bignum\") mathematical library such as MPIR.\n\n\n\nBy way of example, here's your original code modified to use MPIR and output the first thousand Fibonacci numbers:\n\n```\n#include <mpir.h>\n#include <iostream>\n\n// Helper function for checked output.\n\nvoid OutZ(int num, mpz_t &x) {\n    static char textX[10000]; // can handle up to fib(47846)\n    if (gmp_snprintf(textX, sizeof(textX), \"%Zd\", x) >= sizeof(textX)) {\n        std::cout << \"*** ERROR: Number was too big, need more space\\n\";\n        exit(1);\n    }\n    std::cout << num << \" \" << textX << '\\n';\n}\n\nint main() {\n    // Initialise all MPIR integers to specific values.\n\n    mpz_t fib1, fib2, fib3;\n\n    mpz_init_set_ui(fib1, 1);          // fib1 = 1\n    mpz_init_set_ui(fib2, 1);          // fib2 = 1\n    mpz_init(fib3);                    // fib3 = 0\n\n    // No need for helper, these first two are well-known.\n\n    std::cout << \"1 1\\n2 1\\n\";\n\n    // Now do the rest of them.\n\n    for (int i = 3; i <= 1000; ++i) {\n        mpz_add(fib3, fib1, fib2);     // fib3 = fib1 + fib2\n        mpz_set(fib1, fib2);           // fib1 = fib2\n        mpz_set(fib2, fib3);           // fib2 = fib3\n\n        OutZ(i, fib3);\n    }\n\n    return 0;\n}\n```\n\n\nThe final few lines of that are (after about 0.01 seconds, so not too bad efficiency-wise):\n\n```\n999 26863810024485359386146727202142923967616609318986952340123175997617981700247881689338369654483356564191827856161443356312976673642210350324634850410377680367334151172899169723197082763985615764450078474174626\n1000 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875\n```\n\n\nand you can verify the final one by asking Wolfram Alpha to give you ```\nfib(1000)```\n:\n\n```\nResult:\n43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python: Fibonacci Sequence\r\n                \r\nI'm just trying to improve my programming skill by making some basic functions.\n\nI want to fill a list with fibonacci values, but I think my code gives the sum of all the numbers put together and prints that instead..\n\n```\nnumberlist = []\ni = 0\nfor i in range(20):\n    numberlist.append(i)\n\nprint numberlist\n\nfibonaccinumbers = []\n\nfor n in numberlist:\n    def fib(n):\n        a, b = 0, 1\n        for i in range(n):\n            a, b = b, a + b\n        return a\n    a = fib(n)\n    fibonaccinumbers.append(a)\n\n\nprint a\n```\n\n\nWhere have I gone wrong?\n    ", "Answer": "\r\n```\nprint a\n```\n\n\nWell, you print the final value.\n\n\n\nAlso some more comments on your code:\n\n```\nnumberlist = []\ni = 0\nfor i in range(20):\n    numberlist.append(i)\n```\n\n\nYou don’t need to initialize ```\ni```\n there, the for loop does that for you. Also, you can simplify the whole block by just doing this:\n\n```\nnumberlist = list(range(20))\n```\n\n\nAnd given that you don’t actually need that to be a list, you don’t need to construct that at all but you can just run ```\nfor n in range(20)```\n later.\n\nThen you are redefinining your ```\nfib```\n function inside the loop over and over again. You should define it outside of it and just reuse it.\n\nAlso, when you know you want to create a list of multiple fibonacci numbers, it helps to just store all the numbers you calculate in between. That way you don’t have to do the same things over and over again. You can also use a generator function to make that all easier:\n\n```\ndef fibGenerator():\n    a, b = 0, 1\n    yield 0\n    while True:\n        a, b = b, a + b\n        yield a\n\nfibonaccinumbers = []\nfib = fibGenerator()\nfor n in range(20):\n    fibonaccinumbers.append(next(fib))\n```\n\n\nInstead of iterating over a range and calling ```\nnext```\n on the generator manually, you then can also just use the ```\ntake```\n-recipe from itertools to do it just like this:\n\n```\nfibonaccinumbers = take(20, fibGenerator())\n```\n\n\nOn generators\n\n\n  Still not too sure what the generator does however.\n\n\nA generator is a Python function which generates a sequence of return values. The values are generated lazily, that means when you request it. You create a generator by simply using ```\nyield```\n instead of ```\nreturn```\n. A ```\nyield```\n will “return” a value and pause the generator. The next time you request a value, the generator will continue where it left off.\n\nUsing a generator allows you to create an endless sequence. As you see in the definition of ```\nfibGenerator```\n above, there is a endless while-loop which has a ```\nyield```\n inside. As the generator stops, it won’t hang up despite that loop.\n\nHere is a quick self-explanationary example:\n\n```\n>>> def example():\n    print('begin')\n    i = 0\n    while True:\n        print('Calculating next value')\n        yield i\n        i += 1\n\n>>> g = example()\n>>> next(g)\nbegin\nCalculating next value\n0\n>>> next(g)\nCalculating next value\n1\n>>> next(g)\nCalculating next value\n2\n>>> next(g)\nCalculating next value\n3\n>>> next(g)\nCalculating next value\n4\n```\n\n\nThe ```\nnext```\n function is the built-in function that requests the next value from the iterable. An iterable is anything you can iterate (e.g. ```\nfor x in iterable: ...```\n); and any generator is also an iterable.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence will not print anything but the number that is inputted by the user\r\n                \r\nHere is my main method, I am trying to call the Fibonacci sequence to tell me what number would be at the location the user inputs:\n```\nimport java.util.Scanner; //import Scanner\n\npublic class Main {\n    public static void main(String[] args) {\n         \n       System.out.println(\"enter number\");\n       Scanner input = new Scanner(System.in); \n       int n = input.nextInt();\n         \n       Fibonacci fibonacci_test = new Fibonacci();\n       fibonacci_test.Recursivefibonacci(n);\n         \n    }\n}\n```\n\nHere is my Fibonacci code that I have:\n```\npublic class Fibonacci {\n//Fn=F(n-1)+F(n-2)\n    \n        \n    //The recursive Fibonacci method \n    public int Recursivefibonacci(int n) {\n       \n        if(n==0) {\n            return 0;\n        } if(n==1) {\n            return 1;\n        }else {\n            \n        int fib = Recursivefibonacci(n-1)+Recursivefibonacci(n-2);\n        return fib;\n        }\n            \n    }\n}\n```\n\nI cannot get this thing to print anything. How can I fix this?\n    ", "Answer": "\r\nIt's because you're not printing anything else.\nYour method doesn't print anything (just returns a value), and your main doesn't print anything (aside from \"enter number\").\nYou can try changing: ```\nfibonacci_test.Recursivefibonacci(n);```\n to ```\nprintln (fibonacci_test.Recursivefibonacci(n));```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Solve Fibonacci Sequence Recursively returning void in function\r\n                \r\nMy professor has asked us to write a program that uses recursion to solve a fibonacci sequence.  This is all pretty normal, but he's asked us to make our function return void.  I've been working at this for a few days now and can't find a way to do this.\n\nI have:\n\n```\nvoid fibonacci(double *n,double *x,double *y,double *result) {\n     if(*n == 1)\n          *result = 0;\n     else if(*n == 2)\n          *result = 1;\n     else\n          fibonacci(--n,n,(n-1),(n+(n-1))); }\n```\n\n\nIs what I'm doing right? I have never had to use\nparameters in such ways before and I'm not sure\nif I'm on the right track.  For some reason it's \nnot compiling at the recursive call to fibonacci,\nstating invalid pointer addition.  Thanks!\n    ", "Answer": "\r\nHint: problem is there: ```\nfibonacci(--n,n,(n-1),(n+(n-1)));```\n or even just there ```\n--n```\n. You're working with pointers\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Solve Fibonacci Sequence Recursively returning void in function\r\n                \r\nMy professor has asked us to write a program that uses recursion to solve a fibonacci sequence.  This is all pretty normal, but he's asked us to make our function return void.  I've been working at this for a few days now and can't find a way to do this.\n\nI have:\n\n```\nvoid fibonacci(double *n,double *x,double *y,double *result) {\n     if(*n == 1)\n          *result = 0;\n     else if(*n == 2)\n          *result = 1;\n     else\n          fibonacci(--n,n,(n-1),(n+(n-1))); }\n```\n\n\nIs what I'm doing right? I have never had to use\nparameters in such ways before and I'm not sure\nif I'm on the right track.  For some reason it's \nnot compiling at the recursive call to fibonacci,\nstating invalid pointer addition.  Thanks!\n    ", "Answer": "\r\nHint: problem is there: ```\nfibonacci(--n,n,(n-1),(n+(n-1)));```\n or even just there ```\n--n```\n. You're working with pointers\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to limit Fibonacci Sequence in an array under a Number Javascript\r\n                \r\nI wrote a Fibonacci Sequence javascript solution. I was able to push out a Fibonacci Sequence array. However, this solution add an extra number in the array that is more than the limited number.\n\nFor example, if I want all the numbers in the array to be under 10, then the array should be [0, 1, 1, 2, 3, 5, 8]. However, with my solution, it still output the extra \"13\" in the array.\n\n\r\n\r\n```\nfunction fib(num) {\r\nvar x = 0;\r\nvar y = 1;\r\nvar fibarray = [0, 1];\r\n\r\nwhile(y < num) {\r\n    y += x;\r\n    x = y - x;\r\n    fibarray.push(y);\r\n}\r\n\r\nreturn fibarray;\r\n}\r\nconsole.log(fib(10));```\n\r\n\r\n\r\n\n\nI don't understand why it output \"13\" when it shouldn't work as \"13\" is more than \"10\". Please help me fix this solution.\n    ", "Answer": "\r\nIt is happening because you are computing next y, pushing it to array and then checking if y is less than num or not but by then you have already added y to fibarray. Solution would be to check if y is less than num and then push it to fibarray and then compute next y and while condition is checked all over again.\n\n\r\n\r\n```\nfunction fib(num) {\r\nvar x = 0;\r\nvar y = 1;\r\nvar fibarray = [0];\r\n\r\nwhile(y < num) {\r\n    fibarray.push(y);\r\n    y += x;\r\n    x = y - x;\r\n}\r\n\r\nreturn fibarray;\r\n}\r\nconsole.log(fib(10));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence pruning using java\r\n                \r\nHere is my implementation of the fibonacci sequence using java\n\n```\n/**\n * Returns nth fibonacci number\n */\npublic class fib {\n\n   public static void main(String[] args){\n      System.out.println(fibonacci(12));\n   }\n\n   public static int fibonacci(int n) {\n      if (n == 0){\n         return 0;\n      } else if (n == 1){\n         return 1;\n      } else {\n         return fibonacci(n - 1) + fibonacci(n - 2);\n      }\n   }\n}\n```\n\n\nBut visualization of this method using recursion made me think it would be a lot faster.\nHere is a visualization of fib(5). https://i.stack.imgur.com/jxkdf.jpg\nBut this got my thinking, notice at the bottom when we bubble up from the bottom of the recursive path we calculate fib(2), fib(3) and fib(4) but then we recalculate fib(3) on the very top right branch. So I was thinking when we are bubbling back up why not save fib(3) calculated from the left branch so we don't do any calculations on the right branch like my method currently does, like a hashtable while coming back up.\nMy question is, how do I implement this idea?\n    ", "Answer": "\r\nWhen you want to add the ```\nHashMap```\n and stay with your original approach, try this:\n\n```\nstatic HashMap<Integer, Integer> values = new HashMap<Integer, Integer>();\n\npublic static void main(String[] args){\n    values.put(0, 0);\n    values.put(1, 1);\n    System.out.println(fibonacci(12));\n}\n\npublic static int fibonacci(int n) {\n    if (values.containsKey(n)){\n        return values.get(n);\n    } else {\n        int left = values.containsKey(n - 1) ? values.get(n - 1) : fibonacci(n - 1);\n        values.put(n - 1, left);\n        int right = values.containsKey(n - 2) ? values.get(n - 2) : fibonacci(n - 2);\n        values.put(n - 2, right);\n        return left + right;\n    }\n}\n```\n\n\nThis approach could be very fast if you call it more often because the fibonacci results are already stored in the ```\nvalues```\n (for sure this could also be done with other approaches):\n\n```\npublic static void main(String[] args){\n    values.put(0, 0);\n    values.put(1, 1);\n    System.out.println(fibonacci(12));\n    System.out.println(fibonacci(11));\n    System.out.println(fibonacci(10));\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursion in Common Lisp, pushing values, and the Fibonacci Sequence\r\n                \r\nThis is not a homework assignment. In the following code:\n\n```\n(defparameter nums '())\n\n(defun fib (number)\n  (if (< number 2)\n      number\n    (push (+ (fib (- number 1)) (fib (- number 2))) nums))\n  return nums)\n\n(format t \"~a \" (fib 100))\n```\n\n\nSince I am quite inexperienced with Common Lisp, I am at a loss as to why the function does not return an value. I am a trying to print first 'n' values, e.g., 100, of the Fibonacci Sequence.\n\nThank you.\n    ", "Answer": "\r\nAn obvious approach to computing fibonacci numbers is this:\n\n```\n(defun fib (n)\n  (if (< n 2)\n      n\n    (+ (fib (- n 1)) (fib (- n 2)))))\n\n(defun fibs (n)\n  (loop for i from 1 below n\n        collect (fib i)))\n```\n\n\nA little thought should tell you why no approach like this is going to help you compute the first 100 Fibonacci numbers: the time taken to compute ```\n(fib n)```\n is equal to or a little more than the time taken to compute ```\n(fib (- n 1))```\n plus the time taken to compute ```\n(fib (- n 2))```\n: this is exponential (see this stack overflow answer).\n\nA good solution to this is memoization: the calculation of ```\n(fib n)```\n repeats subcalculations a huge number of times, and if we can just remember the answer we computed last time we can avoid doing so again.\n\n(An earlier version of this answer has an overcomplex macro here: something like that may be useful in general but is not needed here.)\n\nHere is how you can memoize ```\nfib```\n:\n\n```\n(defun fib (n)\n  (check-type n (integer 0) \"natural number\")\n  (let ((so-far '((2 . 1) (1 . 1) (0 . 0))))\n    (labels ((fibber (m)\n               (when (> m (car (first so-far)))\n                 (push (cons m (+ (fibber (- m 1))\n                                  (fibber (- m 2))))\n                       so-far))\n               (cdr (assoc m so-far))))\n      (fibber n))))\n```\n\n\nThis keeps a table – an alist – of the results it has computed so far, and uses this to avoid recomputation.\n\nWith this memoized version of the function:\n\n```\n> (time (fib 1000))\nTiming the evaluation of (fib 1000)\n\nUser time    =        0.000\nSystem time  =        0.000\nElapsed time =        0.000\nAllocation   = 101944 bytes\n0 Page faults\n43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875\n```\n\n\nThe above definition uses a fresh cache for each call to ```\nfib```\n: this is fine, because the local function, ```\nfibber```\n does reuse the cache.  But you can do better than this by putting the cache outside the function altogether:\n\n```\n(defmacro define-function (name expression)\n  ;; Install EXPRESSION as the function value of NAME, returning NAME\n  ;; This is just to avoid having to say `(setf ...)`: it should\n  ;; probably do something at compile-time too so the compiler knows\n  ;; the function will be defined.\n  `(progn\n     (setf (fdefinition ',name) ,expression)\n     ',name))\n\n(define-function fib\n  (let ((so-far '((2 . 1) (1 . 1) (0 . 0))))\n    (lambda (n)\n      (block fib\n        (check-type n (integer 0) \"natural number\")\n        (labels ((fibber (m)\n                   (when (> m (car (first so-far)))\n                     (push (cons m (+ (fibber (- m 1))\n                                      (fibber (- m 2))))\n                           so-far))\n                   (cdr (assoc m so-far))))\n          (fibber n))))))\n```\n\n\nThis version of ```\nfib```\n will share its cache between calls, which means it is a little faster, allocates a little less memory but may be less thread-safe:\n\n```\n> (time (fib 1000))\n[...]\nAllocation   = 96072 bytes\n[...]\n\n> (time (fib 1000))\n[...]\nAllocation   = 0 bytes\n[...]\n```\n\n\nInterestingly memoization was invented (or at least named) by Donald Michie, who worked on breaking Tunny (and hence with Colossus), and who I also knew slightly: the history of computing is still pretty short!\n\n\n\nNote that memoization is one of the times where you can end up fighting a battle with the compiler.  In particular for a function like this:\n\n```\n(defun f (...)\n  ...\n  ;; no function bindings or notinline declarations of F here\n  ...\n  (f ...)\n  ...)\n```\n\n\nThen the compiler is allowed (but not required) to assume that the apparently recursive call to ```\nf```\n is a recursive call into the function it is compiling, and thus to avoid a lot of the overhead of a full function call.  In particular it is not required to retrieve the current function value of the symbol ```\nf```\n: it can just call directly into the function itself.\n\nWhat this means is that an attempt to write a function, ```\nmemoize```\n which can be used to mamoize an existing recursive function, as ```\n(setf (fdefinition 'f) (memoize #'f))```\n may not work: the function ```\nf```\n still call directly into the unmemoized version of itself and won't notice that the function value of ```\nf```\n has been changed.\n\nThis is in fact true even if the recursion is indirect in many cases: the compiler is allowed to assume that calls to a function ```\ng```\n for which there is a definition in the same file are calls to the version defined in the file, and again avoid the overhead of a full call.\n\nThe way to deal with this is to add suitable ```\nnotinline```\n declarations: if a call is covered by a ```\nnotinline```\n declaration (which must be known to the compiler) then it must be made as a full call.  From the spec:\n\n\n  A compiler is not free to ignore this declaration; calls to the specified functions must be implemented as out-of-line subroutine calls.\n\n\nWhat this means is that, in order to memoize functions you have to add suitable ```\nnotinline```\n declarations for recursive calls, and this means that memoizing either needs to be done by a macro, or must rely on the user adding suitable declarations to the functions to be memoized.\n\nThis is only a problem because the CL compiler is allowed to be smart: almost always that's a good thing!\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding Fibonacci sequence in C#. [Project Euler Exercise]\r\n                \r\nI'm having some trouble with this problem in Project Euler.\n\nHere's what the question asks:\n\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\nFind the sum of all the even-valued terms in the sequence which do not exceed four million.\n\nMy code so far: EDITED WITH NEW CODE THAT STILL DOESN'T WORK.\n\n```\nstatic void Main(string[] args)\n{\n    int a = 1;\n    int b = 2;\n    int Container = 0;\n    int Sum = 0;\n\n    while (b < 4000000)\n    {\n        if (a % 2 == 0)\n        {\n            Container += a;\n        }\n\n        Sum = a + b;\n        a = b;\n        b = Sum;\n    }\n\n    Container += b;\n\n    Console.WriteLine(Container.ToString());\n    Console.ReadLine();\n}\n```\n\n    ", "Answer": "\r\nOne of the fun feature in C# is the \"yield\" keyword, which is very useful for this kind of thing:\n\n```\nIEnumerable<int> Fibonacci()\n{\n   int n1 = 0;\n   int n2 = 1;\n\n   yield return 1;\n   while (true)\n   {\n      int n = n1 + n2;\n      n1 = n2;\n      n2 = n;\n      yield return n;\n   }\n}\n\nlong result=0;\n\nforeach (int i in Fibonacci().TakeWhile(i => i<4000000).Where(i => i % 2 == 0))\n{\n    result+=i;\n}\nConsole.WriteLine(result);\n```\n\n\nThe \"traditional\" recursive Fibonacci implementation is problematic here because it throws away all the work done along the way to the last requested term. You would have to call such a function over and over in a loop, which would duplicate a lot of work, or you could start with that implementation and add an argument to the recursive function to build up the desired sum result as the final fibonacci term is calculated. I like this much better, because it's still a general purpose fibonacci sequence at the core, rather than one you had to re-write or specialize.\n\nAnother approach is to use events (delegates) in a traditional implementation to call a separate method as each term is completed, but as I still like the iterator method better I'll leave the delegate option as an exercise for the reader.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Q: How can I turn this Fibonacci sequence into an array in batch programming?\r\n                \r\nthe script successfully calculates the fibonacci sequence but I am not sure how to turn the numbers into an array.\n\n`Title Fibonacci array\n    @echo off\n    setlocal enableDelayedExpansion\n\n```\n:Fibonacci\nsetlocal\n    ::C=current L=last S=Swap\n    set C=1\n    set L=0\n\n    for /l %%G in (1,1,30) do (\n        set S=!C!\n        set /a C+=!L! & Call :Array !C!\n        set L=!S!\n)\n\n:Array\n    ::Here is where you create the array\n    set i=-1\n\n    for %%X in (%1 %2 %3 %4 %5 %6 %7 %8 %9) Do (\n        set /a i+=1\n        set /a Fib[!i!]=%%X\n)   \n    set index=!i!\n\n    for /l %%X in (0,1,!index!) do (\n        echo !Fib[%%X]!\n\n)\npause>nul\nendlocal`\n```\n\n    ", "Answer": "\r\n```\nTitle Fibonacci array\n@echo off\nsetlocal enableDelayedExpansion\n\n:Fibonacci\n\n    ::C=current L=last S=Swap\n    set C=1\n    set L=0\n\n    set i=-1\n    for /l %%G in (1,1,30) do (\n        set S=!C!\n        set /a C+=L\n\n        rem Here is where you create the array,\n        set /a i+=1\n        set /a Fib[!i!]=C\n\n        set L=!S!\n    )\n    set index=!i!\n\n\n:ShowArray\n\n    for /l %%X in (0,1,!index!) do (\n        echo %%X- !Fib[%%X]!\n    )\n\npause>nul\nendlocal\n```\n\n\nEDIT: Simpler method\n\n```\n@echo off\nTitle Fibonacci array\nsetlocal EnableDelayedExpansion\n\nset N=30\n\n:Fibonacci\n\n    set /A i=0, j=1, Fib[0]=1, Fib[1]=1\n\n    for /L %%G in (2,1,%N%) do set /A Fib[%%G]=Fib[!i!]+Fib[!j!], i=j, j+=1\n\n:ShowArray\n\n    for /L %%X in (1,1,%N%) do echo %%X- !Fib[%%X]!\n\npause>nul\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence long[] array throws negative numbers after index 92\r\n                \r\nI'm testing this code to insert the Fibonacci sequence in a long[] array:\n\n```\npublic class Test {\n    public static void Fibonacci(int n){\n        long[] array = new long[n];\n        array[0]=1;\n        for (int i = 1; i < n; i++) {\n            if (i==1) {\n                array[i]=i;\n            }\n            else {\n                array[i] = array[i-2] + array[i-1];\n            }\n        }\n        System.out.println(array[n-3]+\"    \"+array[n-2]); // verify sum\n        System.out.println(array[n-1]);\n    }\n    public static void main(String[] args) {\n\n        Scanner scan = new Scanner(System.in);\n\n        System.out.print(\"Insert Fibonacci sequence index: \");\n        int n = scan.nextInt();\n\n        Fibonacci(n);\n    }\n}\n```\n\n\nHowever, after position 92, it starts throwing wrong or negative numbers. I'm using this Fibonacci Calculator to verify the numbers and until 92 it's correct.\nI've seen some questions here about this problem and most answers say its about Integer overflow, and that you should use long, which I am using. \n\nIs 93th number over the limit of long type? What should I use instead to reach 100 or bigger numbers and still manage it with an array?\n    ", "Answer": "\r\nYou are overflowing the range of ```\nlong```\n. You can use ```\nBigInteger```\n (and extract ```\narray[1]```\n from the loop); something1 like\n\n```\npublic static void fibonacci(int n) {\n    BigInteger[] array = new BigInteger[n];\n    array[0] = array[1] = BigInteger.ONE;\n\n    for (int i = 2; i < n; i++) {\n        array[i] = array[i - 2].add(array[i - 1]);\n    }\n    System.out.println(array[n - 3] + \"    \" + array[n - 2]); // verify sum\n    System.out.println(array[n - 1]);\n}\n```\n\n\n1Also, please follow Java naming conventions. Method names start with a lower case letter, ```\nFibonacci```\n looks like a class name.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence results in infinity, then NaN\r\n                \r\nI was playing around with writing a javascript Fibonacci sequence, as I had never tried to do so, came up with an easy iterative formula to calculate it. Then I decided to test run it by doing 10000 iterations to see the results. to my surprise, it worked until the 1476th iteration, then broke. 1477 and 1478 both gave the result \"Infinity\". I have tried different browsers, changing the methods for display, but ended up with the same results.\n\n1475i - 1.3069892237633983e+308\n1476i - Infinity\n1477i - Infinity\n1478i - NaN\n\nCode used:\n\n```\n<!DOCTYPE html><html><head><script>\nfunction fibonacci(){\nvar x = 1;\nvar y = 0;\n  for(i=0;i<1478;i++){\n    var box = document.createElement('div');\n    box.setAttribute('id','box'+i);\n    document.body.appendChild(box);\n    document.getElementById('box'+i).innerHTML = [i] + 'i - ' + x;\n        x = x + y;\n    y = x - y;\n  }\n}\n</script></head><body onLoad=\"fibonacci();\"><div id=\"output\"></div></body></html>\n```\n\n\nI am not sure if then function broke at a certain point, or what I may have failed to take into accountof in the sequence. And yes, I realize that I skipped the first integer, but that shouldn't affect the function.\n    ", "Answer": "\r\nThe 1477th Fibonacci number is too big to be represented by Javascript. The \"overflow\" causes your number to become ```\nInfinity```\n.\n\n```\nInfinity - 1476thFibonacciNumber```\n is still ```\nInfinity```\n in the following ```\ny```\n calculation. \n\nThen on the next iteration you have ```\nInfinity - Infinity```\n which is ```\nNaN```\n in ```\nJavaScript```\n. From that point, it's ```\nNaN```\n all the way to the end.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "A twist in Fibonacci's sequence in Python\r\n                \r\nI am studyng recursion in Python and now I am having a problem with this exercise: \n\n\n  Remember that Fibonacci's sequence is a sequence of numbers where every number is the sum of the previous two numbers.\n  \n  For this problem, implement Fibonacci recursively, with a twist! Imagine that we want to create a new number sequence called Fibonacci-3. In Fibonacci-3, each number in the sequence is the sum of the previous three numbers. The\n  sequence will start with three 1s, so the fourth Fibonacci-3\n  number would be 3 (1+1+1), the fifth would be 5 (1+1+3), the sixth would be 9 (1+3+5), the seventh would be 17 (3+5+9), etc.\n  \n  Name your function fib3, and make sure to use recursion.\n  \n  The lines below will test your code. \n  \n  If your function is correct, they will print 1, 3, 17, and 57.\n\n```\nprint(fib3(3))\nprint(fib3(4))\nprint(fib3(7))\nprint(fib3(9))\n```\n\n\n\nThis is the code until now:\n\n```\ndef fib3(n):\n    if n <= 1:\n        return n\n    else:\n        return(fib3(n-1) + fib3(n-2) + fib3(n-3))\n```\n\n\nBut the results are: 1, 2, 11, 37\n\nCan you help me please to correct it?\n    ", "Answer": "\r\nYour problem description tells you why:\n\n\n  The sequence will start with three 1s\n\n\nYour solution, however only returns ```\n1```\n for ```\nn == 1```\n or lower:\n\n```\nif n <= 1:\n    return n\n```\n\n\nThis means that for ```\nn == 2```\n (which should still return ```\n1```\n), you'd instead return ```\nfib3(2-1) + fib3(2-2) + fib3(2-3)```\n, or ```\nfib3(1) + fib3(0) + fib(-1)```\n, which thanks to the above test, then bottoms out to produce ```\n1 + 0 + -1```\n == ```\n0```\n.\n\nFor ```\nn == 3```\n, you'd return ```\nfib3(2) + fib3(1) + fib3(0)```\n; we worked out above that ```\nfib3(2)```\n is ```\n0```\n, so the end result is ```\n0 + 1 + 0```\n is the ```\n1```\n you observed.\n\nFinally, the 4th ```\nfib3```\n number (```\nn == 4```\n), does not return 3, but ```\nfib3(3) + fib3(2) + fib3(1)```\n == ```\n1 + 0 + 1```\n == ```\n2```\n.\n\nChange that first test return ```\n1```\n for ```\nn <= 3```\n, to fix those first 3 values in the series:\n\n```\ndef fib3(n):\n    if n <= 3:\n        return 1\n    else:\n        return fib3(n-1) + fib3(n-2) + fib3(n-3)\n```\n\n\nNow the code passes the given tests:\n\n```\n>>> def fib3(n):\n...     if n <= 3:\n...         return 1\n...     else:\n...         return fib3(n-1) + fib3(n-2) + fib3(n-3)\n...\n>>> print(fib3(3))\n1\n>>> print(fib3(4))\n3\n>>> print(fib3(7))\n17\n>>> print(fib3(9))\n57\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Printing user given values in Fibonacci sequence in R\r\n                \r\nI am trying to make function that prints values of Fibonacci sequence that are under user given value (n). So input 8 will return values (1,1,2,3,5,8)\n```\nFib<-  function(n){\n v=NULL\n v[1]<-1\n v[2]<-1 \n for(i in 3:n){\n     v[i]<-v[i-1]+v[i-2]\n     while(v[i]<=n){\n         print(v)\n         break}}}\n```\n\ninput\n```\nfib(8)\n[1] 1 1 2\n[1] 1 1 2 3\n[1] 1 1 2 3 5\n[1] 1 1 2 3 5 8\n```\n\nI would want only the last one printed out.\nI also tried it with ```\nappend(v,v[i])```\n but haven't got that working so it would return only values below n.\nWill appreciate any tips given.\n    ", "Answer": "\r\nYou can try a recursive approach (if you want, you can modify this to let the limit be an input, but I like it better this way to conserve stack space ):\n```\nV = c(1,1)\nLimit = 10\n\nfib = function(n){\n        if(n > L){\n          print(V)\n          return()\n        }else{\n          n = V[(length(V)-1) : length(V)] %>% sum\n          V <<- c(V,n)\n          return(fib(n))\n        }\n}\nfib(0)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "I can't figure out why my fibonacci sequence isn't working\r\n                \r\nI have to make a little program to calculate a certain iteration of the fibonacci sequence. right now, it always gives out a 2, no matter what i do... \n\n```\npublic partial class Form1 : Form\n       {\n        int num1=0;\n        int num2=1;\n        int sum=0;\n\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void btnCal_Click(object sender, EventArgs e)\n        {\n            for (int z = 0; z <= Convert.ToInt32(txtCal.Text); z++)\n            {        \n                sum = num1 + num2;\n\n                lblErg.Text = Convert.ToString(sum);\n                num1 = num2;\n                sum = num1;\n            }\n        }\n```\n\n    ", "Answer": "\r\nYou were setting num1 to sum not sum to num2.\n\n```\n            sum = num1 + num2;\n            num1 = num2;\n            num2 = sum;\n\n            lblErg.Text = Convert.ToString(sum);\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "My code is bringing my fibonacci sequence out one number short (Python college course)\r\n                \r\nI have this program which is supposed to take the sum of all integers from 1 and including the input integer. Get the factorial of the input integer, and then take that integer to calculate the number in the fibonacci sequence. I believe I did all of this correctly except the fibonacci number is coming out 1 short. \n\n```\n# This program should find the factorial of the interger\n\n#Used for later\n\n# takes the user input\nnum = int(input(\"Enter a number: \"))\nfactorial = 1\n\n# Gets the sum\n\nsum_up_to_number = 0\ntnum = 1\nwhile tnum <= num:\n sum_up_to_number += tnum\n tnum += 1\n\nprint(\"Sum of all numbers up to\", num, \"is\", sum_up_to_number )\n\n\n\n#Gets the factorial\n\nif num < 0:\n print(\"Sorry, factorial does not exist for negative numbers\")\nelif num == 0:\n print(\"The factorial of 0 is 1\")\nelse:\n for i in range(1,num + 1):\n   factorial = factorial*i\n print(\"The factorial of\",num,\"is\",factorial)\n\n\n# Should begin the process the making the getting the sum and the fibonacci\n\n# Takes your num to start the fibonacci sequence\nnterms = num\n\n# first two terms\nn1 = 0\nn2 = 1\ncount = 2\n\n# check if the number of terms is valid\nfibonacci_sum = 0 #A small check to make sure it receives something it wants\nif nterms <= 0:\n print(\"Plese enter a positive integer\")\nelif nterms == 1:    #A small check to make sure it receives something it wants\n print(\"Fibonacci sequence:\")\n print(n1)\nelse:\n print(\"Fibonacci sequence:\")   #Gives the sequence since it receives an input it likes\n print(n1,\",\",n2,end=', ')\nwhile count < nterms: #Retrieves the fibonacci sequence\n\n   nth = n1 + n2\n   print(nth,end=' , ')\n   # update values\n   n1 = n2\n   n2 = nth\n   count += 1\nprint(\"\") #Makes the sequence of the print clean\nprint(num, \"number of Fibonacci sequence is\", n2) #Gives the original integer and then the final number in the fibonacci sequence\n```\n\n\nI need to figure out how to not make the fibonacci come out one number short.\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence negative answer after 92 python\r\n                \r\nI am trying to create a function that gives me the fibonacci sequence for any value of n. However, after the n = 92, I am getting incorrect answers. \n\n```\neg. For n = 93\nExpected output = 12200160415121876738\nActual Output = -6246583658587674878\n```\n\n\nMy code is below:\n\n```\nimport numpy as np\ndef Power(M, n):\n         if not n:\n                 return 1\n         elif n % 2:\n                 return M*Power(M, n-1)\n         else:\n                 sqrt = Power(M, n//2)\n                 return sqrt**2\n\n  def _fib(n):\n     G = np.matrix([[1,1],[1,0]])\n     F = Power(G, n)\n     return F[0,1]   \n```\n\n\nI think it has something to do with integer overflow related to the limitation of the matrix library. I am not sure how to fix it. Please help me out. I would prefer if this algorithm is improved upon.\n\nAlgorithm used:\n\n    ", "Answer": "\r\nYou should set an explicit ```\ndtype```\n to allow for larger numbers in your matrix:\n\n```\nG = np.matrix([[1,1],[1,0]], dtype=np.uint64)\n```\n\n\nHowever, this raises the bar only slightly (if your system is not even using this as a default) and will soon overflow, too, and you won't even notice it as easily as the numbers will not get negative...\n\n@Michael's answer works much better.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "failure to invoke reverse on a fibonacci sequence in range-v3\r\n                \r\nI can't seem to make ```\nview::reverse```\n operate on the first 10 elements (using ```\nview::take(10)```\n) of the fibonacci sequence ```\nv```\n generated using ```\nrange-v3```\n's ```\nview::generate```\n\n\n```\n#include <iostream>\n#include <range/v3/view/iota.hpp>\n#include <range/v3/view/generate.hpp>\n#include <range/v3/view/take.hpp>\n#include <range/v3/view/reverse.hpp>\n\nusing namespace ranges;\n\nint main() {\n    int i = 0 ; int j = 1;\n    auto v = view::generate([&]()->int{int tmp = i; i += j; std::swap(i, j); return tmp;}); // fibonacci\n    std::cout << (v | view::take(10) | view::reverse) << '\\n';\n    return 0;\n}\n```\n\n\nI get the following error (followed by a lot more template-related output):\n\n```\nerror: no match for 'operator<<' (operand types are 'std::ostream {aka std::basic_ostream<char>}' and 'void')\n     std::cout << (v | view::take(10) | view::reverse) << '\\n';\n```\n\n\nHowever, if I use ```\nview::iota```\n to create ```\nv```\n, e.g.,\n\n```\n auto v = view::iota(20);\n```\n\n\nI get no error and the expected output. \n\nWhat's going wrong?\n    ", "Answer": "\r\n```\nview::generate```\n produced an Input range. You can't reverse an Input range. That requires Bidirectional. ```\nview::iota```\n on the other hand produces RandomAccess ranges, which can be reversed.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How would I approach making the Fibonacci Sequence in ARM?\r\n                \r\nI need to make an ARM assembly program which will print out the Fibonacci Sequence and i'm unsure of how to approach it. The program will ask the user for a number, and when they input that number, the program should print out the Fibonacci sequence for that amount of numbers, so for example, if the user inputs 10, the program will run through printing \n\n\"Fibonacci number 1 is 1.\"\n\n\"Fibonacci number 2 is 1.\"\n\nAnd so on.\n\nCurrently my code for this looks like this:\n\n```\nB   main\n\nmaxF    DEFW    0\nenterI  DEFB \"Please enter the number of fibonacci numbers to print: \",0\nnewline DEFB \"\\n\",0\nfibbo   DEFB    \"Fibonacci number \",0\nis      DEFB    \" is \",0\nend     DEFB    \".\\n\",0\nerrorM  DEFB \"Error, try again!\\n\",0\n\n    ALIGN                          \nmain    ADR R0, enterI\n    SWI 3\n    MOV R1, #0\n    MOV R2, #10                                         \n    MOV R3, #0      ;lastNumber variable\n    MOV R4, #1      ;numberbeforeLast variable\n    MOV R5, #0      ;currentNumber variable\n\nstart   SWI 1           ;take user input\n\n    CMP R0, #10     ;compare R0 with #10 (enter)\n    BEQ _end        ;if equal, go to _end\n\n    CMP R0, #48     ;compare R0 with #48 (0)\n    BLT _error      ;if less than, go to _error\n\n    CMP R0, #57     ;compare R0 with #57 (9)\n    BGT _error      ;if greater than, go to _error\n\n    SUB R0, R0, #48 ;R0 = R0 - #48\n    SWI 4           ;print the above\n\n    MUL R1, R1, R2  ;Multiply the R1 register by R2 and store in R1\n    ADD R1, R1, R0  ;Add the R1 register to R0 and store in R1\n\n    B while_cond\n while_loop\n    ADD R5, R3, R4  ;currentnumber = lastnumber + numberbeforelast\n    ADR R0, fibbo\n    SWI 3\n    STR R5, maxF\n    LDR R0, value\n    SWI 4\n    ADR R0, is\n    SWI 3\n while_cond\n    CMP R0, #0\n    BGT while_loop\n\n_end    SWI 2\n\n_error  ADR R0, errorM\n    SWI 3\n    B main\n```\n\n\nI've been thinking of an approach for this and I have something but i'm unsure of how to do it. I was thinking that the program expects an input from the user for the number, and then it does the calculation for that number and then prints out the line for number currently in the register, branches back up to the top where the register is overwritten with the next value and then does the same thing until the value of that register is equal to the value that the user specified, which is when it stops. \n    ", "Answer": "\r\nRight now the code stands no chance of working because you don't ever update the values of ```\nr3```\n and ```\nr4```\n (your previous two Fibonacci numbers), and you overwrite ```\nr0```\n (intended to be your loop counter) in a number of places.  There may be other problems too.\n\nIt's not really clear where you're stuck - it seems perhaps to be a combination of inexperience with assembly language and inexperience with the process of developing an algorithm.  My advice would be to separate the two processes.  Write some code in C (or another language, but C is the closest you'll get to assembly language without actually using it!) that computes the first ```\nn```\n Fibonacci numbers.  Once that works, start thinking about how you would implement the same thing in assembly language.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "replacement has length zero in fibonacci sequence in R code\r\n                \r\nSo I have this code for the fibonacci sequence, and I keep getting an error when I try to print out the value of the function.\n```\nfibonacci <- function(nn) {\n  if (!(nn%%1==0) | (nn<1)){\n    return(0)\n  } \n  my.fib <- c(1,1)\n  for (kk in 3:nn){\n    my.fib[kk] <- my.fib[kk-1] + my.fib[kk-2]\n  }\n  return(my.fib[nn])\n}\n\nfibonacci(7)   \nfibonacci(5)   \nfibonacci(1)   \nfibonacci(1.5) \nfibonacci(0)   \n```\n\nIt prints everything correctly for 7,5,1.5 and 0, as it gives me the vaules 13, 5, 0, and 0. But when trying to print fibonacci(1), I get the error\n```\nError in my.fib[kk] <- my.fib[kk - 1] + my.fib[kk - 2] : \n  replacement has length zero\n```\n\nI want to leave as much as the code the same as possible.\n    ", "Answer": "\r\nAdd another ```\nif```\n condition to check for ```\nnn = 1```\n.\n```\nfibonacci <- function(nn) {\n  if (!(nn%%1==0) | (nn<1)){\n    return(0)\n  } else if(nn == 1) return(1)\n  my.fib <- c(1,1)\n  for (kk in 3:nn){\n    my.fib[kk] <- my.fib[kk-1] + my.fib[kk-2]\n  }\n  return(my.fib[nn])\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to find an integer's position in the fibonacci sequence\r\n                \r\nI'm trying to use fibonacci's sequence as limits for a game's experience points to level conversion (i would like critics on that decision too), something like this:\n\nIf a player has 49.450 points, he's in level 25, because the closest smaller fibonacci number is 46.368.\n\nI'm having trouble, however, to figure out how to do that. Apart from creating a map with levels as keys and limits as values, is there any smarter way?\n    ", "Answer": "\r\nFibonacci grows exponentially. The base is phi (the golden ratio), so it's not quite as fast as 2^n, but it's still pretty fast. only the smallest 94 or so Fibonacci numbers can be represented by an unsigned 64-bit integer, so a lookup table is probably your best option.\n\nHowever, if you really did want to compute it, you could invert the closed form solution to get something like:\n\n```\nint fibIndex(long n) {\n    return Math.round(Math.log(n * Math.sqrt(5))/Math.log(PHI));\n}\n```\n\n\nthis may be of by one, and of course cannot distinguish between the double 1s early in the sequence.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "R: Summing the even terms in a Fibonacci Sequence with warnings\r\n                \r\nI've been set a question on the Fibonacci Sequence and although I've been successful in doing the sequence, I haven't been as lucky summing the even terms up (i.e. 2nd, 4th, 6th... etc.) My code is below as well as the part of the question I am stuck on. Any guidance would be brilliant!\nQuestion:\nWrite a function which will take as an input ```\nx```\n and ```\ny```\n and will return either the sum of the first ```\nx```\n even Fibonacci numbers or the sum of even Fibonacci numbers less than ```\ny```\n.\nThat means the user will be able to specify either ```\nx```\n or ```\ny```\n but not both.\nYou have to return a warning if someone uses both numbers (decide\non the message to return)\nCode:\n\n```\ny <- 10\nfibvals <- numeric(y)\nfibvals[1] <- 1\nfibvals[2] <- 1\nfor (i in 3:y) { \n   fibvals[i] <- fibvals[i-1]+fibvals[i-2]\n    if (i %% 2) \n  v<-sum(fibvals[i])\n}\nv\n```\n\n    ", "Answer": "\r\nTo get you started since this sounds like an exercise.\n\nI would split your loop up into steps rather than do the summing within the loop with an ```\nif```\n statement. Since you already have the sequence code working, you can just return what is asked for by the user. The ```\nmissing```\n function would probably help you out here\n\n```\nf <- function(x, y) {\n  if (missing(y)) {\n    warning('you must give y')\n    y <- 10\n  }\n  fibvals <- numeric(y)\n  fibvals[1] <- 1\n  fibvals[2] <- 1\n  for (i in 3:y) { \n    fibvals[i] <- fibvals[i-1]+fibvals[i-2]\n  }\n\n  evens <- fibvals %% 2 == 0\n  odds <- fibvals %% 2 != 0\n\n  if (missing(x)) {\n    return(sum(fibvals[evens]))\n  } else return(fibvals)\n}\n\nf(y = 20)\n# [1] 3382\nf(10)\n# [1]  1  1  2  3  5  8 13 21 34 55\n# Warning message:\n# In f(10) : you must give y\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in Haskell\r\n                \r\nI am trying to build a fibonacci wrapper function that takes in multiple command line arguments and computes the associated Fibonacci number for each argument\n    ", "Answer": "\r\nYou should use the ```\nread```\n or ```\nreadMaybe```\n functions to get an ```\nInt```\n from the ```\nString```\n:\n\n```\nfibonacci_wrapper :: [String] -> Maybe Int\nfibonacci_wrapper (x:_) =\n    case readMaybe x of\n        Just n -> Just (fibonacci n)\n        Nothing -> Nothing -- read failed\n-- Not enough args\nfibonacci_wrapper _ = Nothing\n```\n\n\nHowever, if you want to take multiple arguments, you should return the rest of the argument list along with the ```\nInt```\n result so that you can continue consuming arguments.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Solve Fibonacci sequence recursively without prior digits\r\n                \r\nIs there a way to print the Fibonacci sequence up to the nth digit without any information before hand? Here's one of my methods to do so, although it us using prior information.\n\n```\nint p;\nint n = 0;\nString fib = \"0, 1\";\n\npublic printFib () {\n    String fibSequence = fibPrint(0, 1, x); //x denotes xth fib number\n    System.out.println(fibSequence);\n}\n\nprivate String logicFib (int a, int b, int c) {\n    if (n == c-2) {\n        return fib;\n    } else {\n        n++;\n        p = a + b;\n        fib = fib + \", \" + p;\n        logicFib(b, p, c);\n    }\n}\n```\n\n\nThe problem here is that I'm printing digits ```\n3, 4, 5, ... n```\n on top of digits ```\n1, 2```\n, when I would like to print them all without first declaring the first two digits. My method's logic only works if the first two digits are already known, when I'd like to forgo this.\n    ", "Answer": "\r\nI think the standard solution for Fibonacci would look like the following:\n\n```\npublic class Fibonacci {\n\n    public long fibo(long n){   \n        if(n == 0)\n            return 0;\n        if(n == 1)\n            return 1;\n        else\n            return fibo(n-1) + fibo(n-2);\n    }\n\n    public static void main(String...args){\n\n        int n = 20;\n        Fibonacci f = new Fibonacci();\n        for(int i = 0; i < n; i++){\n            System.out.println(f.fibo(i));\n        }\n    }\n}\n```\n\n\nIn a recursive method you always need a break condition. In the case of this fibonacci method this would be the 0th and 1st fibonacci number as you can recognize above. There is no other way to calculate the fibonacci number recursively. You simply need the break condition.\n\nIf you don't need the recursive character of your method you can calculate the number via the Binet's formula. For further information about this one click here.\n\nEDIT:\n\nI change my method. It's now counting up till the nth Fibonacci number.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding the nth term of the fibonacci sequence in matlab\r\n                \r\nI am attempting to write a program that takes a user's input (n) and outputs the nth term of the Fibonacci sequence, without using any of MATLAB's inbuilt functions. I have currently written the following function, however, I wish to alter this code slightly so that ```\nn=input(\"Enter value of n\")```\n however I am unsure how to go about this? Do I need to declare an empty array called fib1?\n\n```\nfunction f = fib1(n)\n    if n <= 1\n        f = 1;\n    else\n        f = fib1(n-1) + fib1(n-2);\n    end\nend\n```\n\n    ", "Answer": "\r\nThe Fibonacci sequence is defined by a difference equation, which is equivalent to a recursive discrete-time ```\nfilter```\n:\n\n```\n>> n = 10;\n>> result = [1 filter([1 1], [1 -1 -1], [1 zeros(1,n-2)])]\nresult =\n     1     1     2     3     5     8    13    21    34    55\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why is the Fibonacci series used in agile planning poker? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhen estimating the relative size of user stories in agile software development the members of the team are supposed to estimate the size of a user story as being 1, 2, 3, 5, 8, 13, ... . So the estimated values should resemble the Fibonacci series. But I wonder, why?\n\nThe description of http://en.wikipedia.org/wiki/Planning_poker on Wikipedia holds the mysterious sentence:\n\n\n  The reason for using the Fibonacci sequence is to reflect the inherent\n  uncertainty in estimating larger items.\n\n\nBut why should there be inherent uncertainty in larger items? Isn't the uncertainty higher, if we make fewer measurement, meaning if fewer people estimate the same story? \nAnd even if the uncertainty is higher in larger stories, why does that imply the use of the Fibonacci sequence? Is there a mathematical or statistical reason for it?\nOtherwise using the Fibonacci series for estimation feels like CargoCult science to me.\n    ", "Answer": "\r\nThe Fibonacci series is just one example of an exponential estimation scale. The reason an exponential scale is used comes from Information Theory.\n\nThe information that we obtain out of estimation grows much slower than the precision of estimation. In fact it grows as a logarithmic function. This is the reason for the higher uncertainty for larger items.\n\nDetermining the most optimal base of the exponential scale (normalization) is difficult in practise. The base corresponding to the Fibonacci scale may or may not be optimal.\n\nHere is a more detailed explanation of the mathematical justification: http://www.yakyma.com/2012/05/why-progressive-estimation-scale-is-so.html\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Avoiding stack overflow error for Fibonacci sequence\r\n                \r\nI was originally solving the Project Euler problem #2 which computes even numbers of the fibonacci sequence up to 4,000,000. I completed this and then I wanted to increase the maximum number so that it would continue infinitely, producing results more slowing as it took longer to compute.\n\nI got a Stack Overflow Error and wondered if there was an alternative solution for the code so that it would be able to continue running, albeit slowly, without encountering a stack overflow error.\n\nCan someone please provide assistance in refactoring my solution? Thanks.\n\nThe relevant code for this problem has been provided below.\n\n```\npublic static void main(String[] args) {\n    fibonacci(1,2,2);\n  }\n\n  private static void fibonacci(long first, long second, long sum) {\n       long number = first + second;       \n         if (number % 2 == 0){ //Checks for even number\n           sum = sum + number;\n         }\n         System.out.println(sum);\n         fibonacci(second, number, sum);\n         // Produces the following error:\n         // Exception in thread \"main\" java.lang.StackOverflowError\n  }\n```\n\n    ", "Answer": "\r\nYou're problem is that you don't have a terminating condition to stop the recursion, you are keep on going until your run out of stack space.\n\nThe general format of a recursive function in pseudo code is:\n\n```\nreturn-typo function(some, values)\n{\n  if(got to the end of recursion based on some values)\n  {\n    return something;\n  }\n  else\n  {\n    // Recurse\n    return function(changes to some values);\n  }\n}\n```\n\n\nNOTE: This isn't a hard and fast rule, just a general outline.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci-like sequence that is composite for 10,000 terms\r\n                \r\nPlease teach me how to optimize my code...\nI am looking to find Fibonacci sequences of the equation ```\na*Xn-1 - (c*c)Xn-2```\n. I am looking for ```\na, c```\n values with a GCD of 1 that will result in a Fibonacci sequence that is composite from the ```\n10th```\n term to the ```\n10,000th```\n term. However, for each term in the sequence, I also want the value of the ```\nterm + 1```\n and the value of the ```\nterm - 1```\n to be composite as well.\nAs the numbers get very large, the code is taking incredibly long to complete.\nTo test primality, I am using the ```\nfrom sympy.ntheory import isprime```\n function.\nInstead of using a list, I am using two variables to represent my Fibonacci sequence.\nI am using recursion to analyze smaller intervals and gradually move up to the maximum. The print statements should help understand what the code is doing as it runs.\nHere is my code:\n```\nfrom math import gcd\nfrom sympy.ntheory import isprime\n\n\ndef check_pairs(a_c_pairs, start_checking_from, increment, max):\n    end_checking_at = start_checking_from + increment\n    pairs_that_passed_the_composite_test = []  # list of the successful pairs\n\n    print()\n    print(f\"{a_c_pairs = }\")\n    print(f\"{start_checking_from = }, {end_checking_at = }, {increment = }, {max = }\")\n    print()\n    print(f\"Number of terms to check: {len(a_c_pairs)}\")\n\n    count = 1\n    for a, c in a_c_pairs:  # checking for each of the provided pairs\n        print(f\"{count}/{len(a_c_pairs)}: {a=}, {c=}, result=\", end=\"\")\n        count += 1\n\n        first_term = 0\n        second_term = 1\n\n        fail = False\n        # iterating through each term in the sequence without using a list\n        for i in range(end_checking_at):\n            third_term = a*second_term - (c*c)*first_term\n\n            if not i < start_checking_from:  # if the term is in our targeted range, check if that term is prime\n                if isprime(third_term) or isprime(third_term + 1) or isprime(third_term - 1):\n                    fail = True\n                    print(\"FAIL\")\n                    break\n\n            # set values for the loop to calculate the next term in the sequence\n            first_term = second_term\n            second_term = third_term\n\n        if not fail:  # after the entire sequence has been analyzed, if none of the terms were prime\n            print(\"pass\")\n            pairs_that_passed_the_composite_test.append([a, c])\n\n    if not end_checking_at == max:\n        check_pairs(pairs_that_passed_the_composite_test,\n                    start_checking_from + increment, increment, max)\n    else:\n        print()\n        print(\"FINAL LIST OF PAIRS:\")\n        for a, c in pairs_that_passed_the_composite_test:\n            print(a, c)\n\n        return\n\n\n# these pairs have passed up to 3000 terms\na_c_pairs = [\n    [11, 3],\n    [34, 3],\n    [37, 3],\n    [38, 3],\n    [40, 3],\n    [41, 3],\n    [53, 3],\n    [56, 3],\n    [59, 3],\n    [61, 3],\n    [65, 3],\n    [71, 3],\n    [77, 3],\n    [82, 3],\n    [89, 3],\n    [94, 3],\n    [95, 3],\n    [98, 3],\n    [37, 5],\n    [39, 5],\n    [42, 5],\n    [43, 5],\n    [46, 5],\n    [51, 5],\n    [54, 5],\n    [57, 5],\n    [64, 5],\n    [73, 5],\n    [74, 5],\n    [77, 5],\n    [86, 5],\n    [89, 5],\n    [91, 5],\n    [98, 5],\n    [53, 7],\n    [55, 7],\n    [64, 7],\n    [71, 7],\n    [75, 7],\n    [79, 7],\n    [81, 7],\n    [83, 7],\n    [87, 7],\n    [92, 7],\n    [99, 7],\n    [100, 7],\n    [86, 9],\n    [89, 9],\n    [94, 9],\n    [97, 9],\n    [98, 9]\n]\n\ncheck_pairs(a_c_pairs, 2000, 500, 3000)\n\n```\n\n    ", "Answer": "\r\nChecking if a number is prime is expensive for huge numbers. Although there are algorithm with polynomial complexity like AKS to do that, the of the polynomial is big (ie. ```\nO(n^7)```\n where ```\nn```\n is the size of the tested number N in bits). Non-deterministic algorithms have a lower polynomial complexity, but this is still quite big. For example, the Miller Rabin test can do that in ```\nO(n^4)```\n assuming the unproven generalized Riemann hypothesis is true (which appear to be the case so far). For moderately large numbers like the one fitting in 64 bits, you can check only few bases resulting in a fast primality test. For huge numbers, researchers are actively working on designing better algorithm (especially deterministic generalist unconditional tests) and finding theoretical algorithmic complexity bounds of such an algorithm. Unfortunately, AFAIK ```\nO(n^4)```\n is close to the best known complexity (without any huge hidden constants) to test if a number is composite or not.\nThe problem is the Fibonacci sequence grow very quickly. For the standard version, the number of bit to represent the ith element is close to ```\n2 i / 3```\n. Thus, the computation time will be quite big for ```\ni = 10 000```\n since it would require to work on  numbers with roughly 6700 bits requiring millions of billion iterations in the worst case (ie. a prime number). No mainstream computer can do that quickly yet (and probably not in the next 20 years).\nThe only possible solution to fix that is to design a specific primality test the numbers you generate which seems to be rather a very hard task at first glance. If there is no relation between prime numbers and Fibonacci numbers, then there is no better solution than using the state-of-the-art algorithms (which are too slow in your case). Otherwise, if there is any relation, such a problem is off-topic on stack overflow, but you can ask this question on math.stackexchange.com.\nFew side notes:\nIf ```\nthird_term-1```\n is even, then only ```\nthird_term```\n need to be checked (since other are not prime numbers). If ```\nthird_term-1```\n is odd, ```\nthird_term```\n is not a prime and either ```\nthird_term-1```\n or ```\nthird_term+1```\n is not a prime number. Moreover, note that there is a relation between the GCD and the Fibonacci numbers and there is a relation between GCD and prime numbers so there might be a relation between Fibonacci numbers and prime ones.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How can I make loops in Little Man Computer for a Fibonacci Sequence?\r\n                \r\n```\n        INP\n        STA numOne\n        OUT\n        INP\n        STA numTwo\n        OUT\n        LDA numOne\n        ADD numTwo\n        STA numThree\n        OUT\n        LDA numTwo\n        ADD numThree\n        STA numFour\n        OUT\n        LDA numThree\n        ADD numFour\n        STA numFive\n        OUT\n        LDA numFour\n        ADD numFive\n        STA numSix\n        OUT\n        LDA numFive\n        ADD numSix\n        STA numSeven\n        OUT\n        LDA numSix\n        ADD numSeven\n        STA numEight\n    OUT\n        LDA numSeven\n        ADD numEight\n        STA numNine\n    OUT\n        LDA numEight\n        ADD numNine\n        STA numTen\n        OUT\nnumOne  dat\nnumTwo  dat\nnumThree dat\nnumFour dat\nnumFive dat\nnumSix  dat\nnumSeven dat\nnumEight dat\nnumNine dat\nnumTen dat\n```\n\n\nI am using the following code in Little Man Computer to output the first 10 Fibonacci sequence terms, however I need to make a loop out of this, which will let me control the amount of iterations I want to be outputted. \n\nFrom my understanding, I'd guess I would have to input 3 numbers - two of them being the first Fibonacci sequence terms, the third one being the amount of iterations I want to be outputted. But how can I achieve this? \n    ", "Answer": "\r\nThe fibonacci series can be printed in the LMC in the following manner:\n\n```\n      INP\n      STO   n     #number of terms\n      LDA   one\n      OUT\n\nloop  LDA   fib     #THE MAIN LOOP THAT PRINTS FIBONACCI NUMBERS\n      STO   temp2\n      ADD   temp\n      STO   fib\n      LDA   temp2\n      STO   temp\n      BR    check\n\ncheck LDA   n         #LOOP TO KEEP A TRACK OF NUMBER OF TERMS\n      BRZ   halt\n      SUB   one\n      STO   n\n      BRZ   halt\n      LDA   fib\n      OUT\n      BR    loop\n\nhalt  HLT        \nn     DAT   000\nfib   DAT   001\ntemp  DAT   001\ntemp2 DAT   000\none   DAT   001\n```\n\n\nExplanation: The program first asks for an input n, the number of terms to be printed.Then the loop starts running - it will print the default value of variable fib, which has been set to 1. The value of fib is stored in another variable temp2, and the variable temp is used to record the previous value of fib so that the numbers are added correctly and a correct sequence is obtained. The loop controls the values of fib, temp and temp2 as the number of terms are increased. \n\nThe program then checks if the number of terms required have been printed and decrements the value of n. If n=0 it means that the required number of terms has been reached and the program halts. If n is not zero, the loop continues till n=0.\n\n**Though there might me more efficient methods, however this one works correctly and uses a pretty less number of mailboxes which makes it quite efficient. \n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "why my code isn't working while making fibonacci sequence inside a list\r\n                \r\nso i want to make a fibonacci sequence inside a list (not array), so i want the result to be something like this with the bracket symbols\n[2 3 5 8 13 21 34 55 89]\ni've made the code, please help me to spot the mistake\n```\nprint('============FIBONACCI SEQUENCE PROGRAM===============')\n\nnumber_of_sequence = int(input('Type the number of sequence = '))\n\nfirst_value = int(input('Insert the first value = '))\n\nsecond_value = int(input('Insert the second value = '))\n\nfirst_sequence = ([2, 3])\n\nsequence = first_sequence + ([0] * number_of_sequence)\n\nfor i in range (1, number_of_sequence-1) :\n\n    sequence[i+1] = first_value + second_value\n\n    first_value = second_value\n\n    second_value = sequence\n\n    print(sequence, end = ' ') \n```\n\nhere's the output i got  image\n    ", "Answer": "\r\nI am not 100% sure as to what you are doing, however, I fixed the error:\n```\nprint('============FIBONACCI SEQUENCE PROGRAM===============')\nnumber_of_sequence = int(input('Type the number of sequence = '))\nfirst_value = int(input('Insert the first value = '))\nsecond_value = int(input('Insert the second value = '))\nfirst_sequence = ([2, 3])\nsequence = first_sequence + ([0] * number_of_sequence)\nfor i in range(1, number_of_sequence-1):\n    sequence[i+1] = first_value + second_value\n    first_value = second_value\n    second_value = sequence[i+1]\n    print(sequence, end=' ')\n\n\n```\n\nThe error was when you:\n```\nsecond_value = sequence\n```\n\ninstead of:\n```\nsecond_value = sequence[i+1]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence time and space complexity\r\n                \r\nThis is not the most efficient way to get Fibonacci sequence numbers but I am learning Big O and would like confirmation and explanation of the space and time efficiency of the code below. The code is in Python and I wrote it such that I use a list and append to it and just return the last value. \n\nThe append method takes O(1) time as shown here but I am doing the operation almost n times so would I get O(n) for time complexity?\n\nWith regard to space complexity, should I consider the space used as an arithmetic series because the list would have to be moved elsewhere if the number entered is larger than what is given to the function stack at the beginning?\n\nThe code in this question is for the recursive approach.\n\n```\ndef getFib(position):\n  if position == 0:\n    return 0\n  if position == 1:\n    return 1\n\n  list_ = [0, 1]\n  previous = 1\n\n  for pos in range(2, position+1):\n    list_.append(list_[pos-1] + list_[pos-2])\n\n  return list_[position]\n\nif __name__ == \"__main__\":\n  print(getFib(0))\n  print(getFib(1))\n  print(getFib(2))\n  print(getFib(3))\n  print(getFib(4))\n  print(getFib(5))\n  print(getFib(6))\n  print(getFib(7))\n  print(getFib(8))\n  print(getFib(9))\n```\n\n    ", "Answer": "\r\ntime complexity: ```\nO(n)```\n because you are executing ```\nn```\n times your loop that has a constant time complexity.\n\nspace complexity: ```\nO(n)```\n because you are storing ```\nn```\n numbers in your list.\n\nOf course, you didn't need to store all the numbers but only the last two values. That would have reduced the space complexity to ```\nO(1)```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursive fibonacci sequence using stack pointer\r\n                \r\nI'm studying for a Computer Systems final and we're expected to have a strong grasp of recursion and for certain programming questions, to use the run-time stack to pass all parameters, return the result of the main program and to stack all variables that the subroutine uses to protect the main program. \n\nThe program I'm writing for practice recursively calculates a Fibonacci sequence. I understand how the subroutine will use the stack to receive arguments/parameters from the main program but I'm having difficulty understanding how it will use the stack as its method of returning the result to the main program, and when/how to stack all variables to protect the main program. Additionally, I'm having difficulty understanding how to implement the recursion portion. \n\nI'm really looking for pointers on understanding the stack pointer, when/how to use it, how to implement recursion, and as a result, where I've gone wrong in my code and general pointers for my coding in MIPS. Thanks! The following is what I have so far:\n\n```\n.data\nprompt: .ascii \"This program calculates Fibonacci sequence. Enter non-negative number:\"\nresult: .asciiz \"F=\"\nnewline: .asciiz \"\\n\"\n\n.text\n.globl main #defining starting point\nmain:\n\nli $v0, 4   #print string\nla $a0, prompt\nsyscall\n\nli $v0, 5   #read in int\nsyscall\n\nmove $t0, $v0   #putting int into temporary register\n\nmove $a0, $t0   #put int as first argument\nsubi $sp, $sp, 8 #setting up stack\nsw $zero, 4($sp)  # for return\nsw $a0, 0($sp)    #push int onto stack\njal fibonacci\n\nlw $t0, -4($sp) #get result from fibonacci\n\nli $v0, 4   #print F=\nla $a0, result\nsyscall\n\nli $v0, 1\nmove $a0, $t0\nsyscall\n\nli $v0, 4\nla $a0, newline\nsyscall\n\nli $v0, 10\nsyscall\n\nfibonacci:\nlw $v0, 4($sp) #load parameters\nlw $a0, 0($sp)\nbeqz $a0, zero  #if n =0 return 0\nbeq $a0, $1, one # if n=1 return 1\n\n#calling fib(n-1)\nsubi $sp, $sp, 4\nsw $ra, 0($sp) #push return address onto stack\n\nsub $a0, $a0, 1 #n-1\nsubi $sp, $sp, 8\nsw $zero, 4($sp)\nsw $a0, 0($sp)   #pushing n-1 onto stack\njal fibonacci    #fib(n-1)\n\nlw $v0, -4($sp) #get result of fibonacci\nadd $a0, $a0, 1  #increment back our value\n\nlw $ra, 0($sp) #restoring return address from stack\nlw $a0, 4($sp) #protect main program by putting stuff back\nsw $v0, 8($sp) #put result on stack\n\n#calling fib(n-2)\nsubi $sp, $sp, 4\nsw $ra, 0($sp)\nsub $a0, $a0, 2 #n-2\nsubi $sp, $sp, 8\nsw $zero, 4($sp)   #pushing n-2 onto stack\nsw $a0, 0($sp)\njal fibonacci\n\nlw $v0, -4($sp)\naddi $a0, $a0, 2\nlw $ra, 0($sp)  #restoring return address from stack \nlw $a0, 4($sp)  #protect main program by puttting stuff back\nsw $v0, 8($sp)  #put result on stack\n\nlw $s7, 0($sp)  #pop return value from stack (from f(n-1)\nadd $v0, $v0, $s7  #f(n-2) +f(n-1)\naddi $sp, $sp, 12\njr $ra \n\n\nzero:\nli $v0, 0\nlw $ra, 0($sp)      # Get return address\nlw $a0, 4($sp)      # Protect main program by putting stuff back\nsw $v0, 8($sp)      # Put result on stack\naddi $sp, $sp, 12\njr $ra\n\none:\nli $v0, 1\nlw $ra, 0($sp)      # Get return address\nlw $a0, 4($sp)      # Protect main program by putting stuff back\nsw $v0, 8($sp)      # Put result on stack\naddi $sp, $sp, 12\njr $ra    \n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in python giving out incorrect result instead of the right one\r\n                \r\nI am trying to implement the Fibonacci sequence in python \n\nI am getting the wrong result instead of correct one. The correct one shows     \n\n```\nclass FibonacciIterator:\n    def __init__(self, max):\n        self.max = max\n\n    def __iter__(self):\n        self.a = 1\n        self.b = 1\n        return self\n\n    def __next__(self):\n        fib = self.a\n        if fib > self.max:\n            raise StopIteration\n        self.a, self.b = self.b, self.a + self.b\n        return fib\n```\n\n\n\n\n```\nfib_ = FibonacciIterator(2)\nfor term in fib_:\n    print(term,end=\" \")\n```\n\n\nOutput:\n\n```\nExpected: 1 1\nGot: 1 1 2\n```\n\n\n\n\n```\nfib_nums = FibonacciIterator(5)\nfor term in fib_nums:\n    print(term,end=\" \")\n```\n\n\nOutput:\n\n```\nExpected: 1 1 2 3 5\nGot : 1 1 2 3 5\n```\n\n    ", "Answer": "\r\nYour condition to stop the iteration is wrong. You need to set a ```\nself.counter```\n to zero in the ```\n__init__```\n method, then in the ```\n__next__```\n method increment this counter and in the condition compare it with max. The second case you got right by coincidence because the fifth element is five. \n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How Can I write a Fibonacci sequence, which uses an array?\r\n                \r\nHere is the code:\n\n```\nclass Fibonacci {\n    static final int MIN_INDEX = 1;\n    public static void main (String[] args){\n        int high = 1;\n        int low = 1;\n        String jel;\n        System.out.println(\"9: \" + high);\n\n      for (int i = 8; i >= MIN_INDEX; i--){\n        if (high % 2 == 0)\n          jel = \" *\";\n        else \n          jel = \" \";\n        System.out.println(i + \": \" + high + jel);\n        high = low + high;\n        low = high - low;\n      }\n   }\n}\n```\n\n\nI want to write this program, to store the Fibonacci sequence in an array, and then write out them. But I can't write it. What can I do? I don't need to \"mark them\" with an *.\n    ", "Answer": "\r\nHere are the steps\n\n\nCalculate the Fibonacci Sequence numbers that you need; store each value.\nPrint the values that you calculated.\n\n\nCalculate and store the Fibonacci Numbers\n\nThe Fibonacci sequence is a recursive function, but it would be ridiculous to implement it in any probramming language using recursion.  Instead use a loop.  For example:\n\n```\nint[] fibonacciNumbers = new int[20];\nfibonacciNumbers[0] = 0;\nfibonacciNumbers[1] = 1;\n\nfor (int index = 2; index < fibonacciNumbers.length; ++index)\n{\n    fibonacciNumbers[index] = fibonacciNumbers[index - 1] + fibonacciNumbers[index - 2];\n}\n\n```\n\n\nPrint the array\n\nLoop through each element in the array and print it however you want; for example, you could ```\nSystem.out.println(fibonacciNumbers[index]);```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to write fibonacci-sequence using recrusion in Ruby?\r\n                \r\nI have tried to create a method in Ruby which returns true if number is included fibonacci-sequence or false if it's not.\n\nI think I got a problem when I return true or false.\n\nCould anybody tell me why the first code doesn't work please?\n\n```\ndef is_fibonacci?(num, array=[0,1])\n\n  n = array.length - 1\n\n  if array[n] > num\n    array.include?(num) ? true : false\n  end\n\n  array << array[n] + array[n-1]\n  is_fibonacci?(num, array)\n\nend\n```\n\n\nWhen I run this code, I got this error message.\n\n=>filename.rb:36:in `include?': Interrupt\n\n```\ndef is_fibonacci?(num, array=[0,1])\n  n = array.length - 1\n\n  if array[n] > num\n    if array.include?(num)\n        return true\n    else\n        return false\n    end\n  end\n\n  array << array[n] + array[n-1]\n  is_fibonacci?(num, array)\n\nend\n```\n\n\nSecond code worked.\n\nWhy can't I use \n\n```\narray.include?(num) ? true : false \n```\n\n\nin the code?\n\nThank you for helping.\n    ", "Answer": "\r\nShivam already gave an good answer to the question why your first version does not work. \n\nI just want to note that there is no reason to keep all calculated fibonacci numbers in the array. That is a waste of space and probably a bit inefficient. Therefore you could simplify your method to:\n\n```\ndef fibonacci?(number)\n  fibos = [0, 1]\n  fibos << (fibos.shift + fibos.last) while fibos.last < number\n  fibos.include?(number)\nend\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursive fibonacci sequence using stack pointer\r\n                \r\nI'm studying for a Computer Systems final and we're expected to have a strong grasp of recursion and for certain programming questions, to use the run-time stack to pass all parameters, return the result of the main program and to stack all variables that the subroutine uses to protect the main program. \n\nThe program I'm writing for practice recursively calculates a Fibonacci sequence. I understand how the subroutine will use the stack to receive arguments/parameters from the main program but I'm having difficulty understanding how it will use the stack as its method of returning the result to the main program, and when/how to stack all variables to protect the main program. Additionally, I'm having difficulty understanding how to implement the recursion portion. \n\nI'm really looking for pointers on understanding the stack pointer, when/how to use it, how to implement recursion, and as a result, where I've gone wrong in my code and general pointers for my coding in MIPS. Thanks! The following is what I have so far:\n\n```\n.data\nprompt: .ascii \"This program calculates Fibonacci sequence. Enter non-negative number:\"\nresult: .asciiz \"F=\"\nnewline: .asciiz \"\\n\"\n\n.text\n.globl main #defining starting point\nmain:\n\nli $v0, 4   #print string\nla $a0, prompt\nsyscall\n\nli $v0, 5   #read in int\nsyscall\n\nmove $t0, $v0   #putting int into temporary register\n\nmove $a0, $t0   #put int as first argument\nsubi $sp, $sp, 8 #setting up stack\nsw $zero, 4($sp)  # for return\nsw $a0, 0($sp)    #push int onto stack\njal fibonacci\n\nlw $t0, -4($sp) #get result from fibonacci\n\nli $v0, 4   #print F=\nla $a0, result\nsyscall\n\nli $v0, 1\nmove $a0, $t0\nsyscall\n\nli $v0, 4\nla $a0, newline\nsyscall\n\nli $v0, 10\nsyscall\n\nfibonacci:\nlw $v0, 4($sp) #load parameters\nlw $a0, 0($sp)\nbeqz $a0, zero  #if n =0 return 0\nbeq $a0, $1, one # if n=1 return 1\n\n#calling fib(n-1)\nsubi $sp, $sp, 4\nsw $ra, 0($sp) #push return address onto stack\n\nsub $a0, $a0, 1 #n-1\nsubi $sp, $sp, 8\nsw $zero, 4($sp)\nsw $a0, 0($sp)   #pushing n-1 onto stack\njal fibonacci    #fib(n-1)\n\nlw $v0, -4($sp) #get result of fibonacci\nadd $a0, $a0, 1  #increment back our value\n\nlw $ra, 0($sp) #restoring return address from stack\nlw $a0, 4($sp) #protect main program by putting stuff back\nsw $v0, 8($sp) #put result on stack\n\n#calling fib(n-2)\nsubi $sp, $sp, 4\nsw $ra, 0($sp)\nsub $a0, $a0, 2 #n-2\nsubi $sp, $sp, 8\nsw $zero, 4($sp)   #pushing n-2 onto stack\nsw $a0, 0($sp)\njal fibonacci\n\nlw $v0, -4($sp)\naddi $a0, $a0, 2\nlw $ra, 0($sp)  #restoring return address from stack \nlw $a0, 4($sp)  #protect main program by puttting stuff back\nsw $v0, 8($sp)  #put result on stack\n\nlw $s7, 0($sp)  #pop return value from stack (from f(n-1)\nadd $v0, $v0, $s7  #f(n-2) +f(n-1)\naddi $sp, $sp, 12\njr $ra \n\n\nzero:\nli $v0, 0\nlw $ra, 0($sp)      # Get return address\nlw $a0, 4($sp)      # Protect main program by putting stuff back\nsw $v0, 8($sp)      # Put result on stack\naddi $sp, $sp, 12\njr $ra\n\none:\nli $v0, 1\nlw $ra, 0($sp)      # Get return address\nlw $a0, 4($sp)      # Protect main program by putting stuff back\nsw $v0, 8($sp)      # Put result on stack\naddi $sp, $sp, 12\njr $ra    \n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence: ruby each method - nil can't be coerced\r\n                \r\nI put together the following methods in order to (1) generate a Fibonacci sequence in an array up to a particular index value, and then (2) return the product of all values in that sequence for the given index. \n\nMy issues seems to come about when I increase the master_num value above 4. Prior to that both the sequence generating & product methods work. I'm pretty sure my problem is related to a mistake in my mind about how Ruby is indexing the sequence array...\n\n```\nrequire 'pry'  #optional, i use pry to debug\n\nmaster_num = 5\n\ndef gen_fib_sequence_up_to_index num\n  rec_gen_fib_values num, []\nend\n\ndef rec_gen_fib_values num, full_array\n  start_array = [1,1]\n  count = 0\n\n  if num < start_array.size\n    num\n  end\n\n  until start_array.size == num\n    next_element = start_array[count] + start_array[count + 1]\n    start_array.push(next_element)\n    count += 1\n  end\n  return start_array\nend\n\np gen_fib_sequence_up_to_index master_num\n\ndef fib_sequence_product sequence_array\n  product = 1\n  sequence_array.each do |i|\n    product = product * sequence_array[i]\n    #binding.pry\n  end\n  product\nend\n\np fib_sequence_product gen_fib_sequence_up_to_index master_num\n```\n\n\nThanks so much for your comments and suggestions.\n    ", "Answer": "\r\n```\ndef fib_sequence_product sequence_array\n  product = 1\n  sequence_array.each do |i|\n    product = product * sequence_array[i]\n    #binding.pry\n  end\n  product\nend\n```\n\n\nIn the block ```\ni```\n is not an index, it's the actual value. This should work:\n\n```\ndef fib_sequence_product sequence_array\n  product = 1\n  sequence_array.each do |i|\n    product = product * i # or product *= i or ...\n  end\n  product\nend\n```\n\n\nBoth generating an array with Fibonacci numbers and calculating the product can be done less verbose.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "MIPS assembly: print the Fibonacci sequence (with syscalls)\r\n                \r\nGood afternoon! I have a MIPS instruction program that simulates the Fibonacci sequence. My program works by entering in a number ```\n(n)```\n that will determine how many iterations the program will work through. The program spits out the correct results but i was wondering how i could output each sequence of number(s) of the ```\nFib```\n method. Heres my code first : \n\n```\n.data\nmsg1:.asciiz \"Give a number: \" # message for fib(n)\n.text\n\nmain:\n\nli $v0,4 #read string\nla $a0,msg1 # set iterations to msg1 value\nsyscall \nli $v0,5 # read an int\nsyscall \nadd $a0,$v0,$zero #move to $a0\n\njal fib #call fib\n\nadd $a0,$v0,$zero # add result into argument\nli $v0,1 # output integer\nsyscall\n\nli $v0,10\nsyscall\n\nfib:\n#a0=y\n#if (y==0) return 0;\n#if (y==1) return 1;\n#return( fib(y-1)+fib(y-2) );\n\naddi $sp,$sp,-12 #save in stack\nsw $ra,0($sp) # save return adress to stack\nsw $s0,4($sp)# save msg value\nsw $s1,8($sp)# save fib(y-1)\nadd $s0,$a0,$zero # store msg value into s0\naddi $t1,$zero,1 # comparable value\n\nbeq $s0,$zero,return0 # if s0 == 0 jump to return 0 block\nbeq $s0,$t1,return1# if s0 == t1 (1) jump to return 1 block\naddi $a0,$s0,-1 # else decrement initial value by 1\n\njal fib\nadd $s1,$zero,$v0     #s1=fib(y-1)############################syscall needed#########################################\naddi $a0,$s0,-2 # subtract two\n\njal fib               #v0=fib(n-2)\nadd $v0,$v0,$s1       #v0=fib(n-2)+$s1 ##########################syscall needed#################################\n\nexitfib:\n\nlw $ra,0($sp)       #read return adress from stack\nlw $s0,4($sp)       # read msg value from stack\nlw $s1,8($sp)       # read fib(y-1) from stack\naddi $sp,$sp,12       #bring back stack pointer\njr $ra\n\nreturn1:\n li $v0,10 # return 1 to result\n\n j exitfib\nreturn0 :     li $v0,0 # return 0 to result\n\n\n j exitfib\n```\n\n\nHopefully you saw, but i have two lines commented where i believe a ```\nsyscall```\n would be necessary to output each number per sequence (```\n$s1 = fib(y-1)```\n)(```\n$v0 = fib(n-2) - $s1```\n). I tried loading the correct code into the result register to output an ```\ninteger```\n but it still gives me problems (not displaying the process before the final result). How could i correctly implement a ```\nsyscall```\n so that i can print each number the ```\nfib```\n method calculates before reaching a final result?\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How could I print a fibonacci sequence on different lines without using lists?\r\n                \r\nI am trying to calculate a simple fibonacci sequence and then print the numbers on different lines. However I want a specific amount of numbers on each line (ex: 5 numbers on each line).\n```\na, b = 1, 1\nwhile b < 150:\n    print(b, \"\\n\")\n    a, b = b, a + b\n```\n\nThe code above calculates a fibonacci sequence of numbers between 1 and 150 and is working just fine. I have tried using nested for/while loops and the \\n keyword to print the sequence on different lines but I can't seem to get it to work. Could anyone give me some advice?\n    ", "Answer": "\r\nyou could just count up and everytime you hit your max print the line break, like this:\n```\na, b, i = 1, 1, 0\nwhile b < 150:\n    print(f\"{b}, \") # pretty print\n    a, b = b, a + b\n    i += 1\n    if i > 5:\n        print(\"\\n\")\n        i = 0\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Creating a Fibonacci sequence, finding sum of all odd numbers\r\n                \r\nI am trying to create a Fibonacci sequence, starting with 1 and 2, that ends at 1000. That part I have figured out, but it also needs to return the sum of all odd numbers. I thought I figured it out, but I keep getting results that are incorrect.\nHere is my code, appreciate any help I can get.\n```\npublic class Fibonacci {\n    public static void main(String[] args) {\n        int n = 1000, t1 = 1, t2 = 2, odd = 0;\n        \n        System.out.print(\"Fibonacci to \" + n + \": \");\n        while (t1 <= n)\n        {\n            System.out.print(t1 + \" + \");\n\n            int sum = t1 + t2;\n            t1 = t2;\n            t2 = sum;\n            if (t1 % 2 != 0)\n                odd = odd + t1;\n        }\n        System.out.print(\"All odd numbers combined are: \" + odd);\n    }\n}\n```\n\n    ", "Answer": "\r\nYou are skipping values in your algorithm.\nBefore you add the current ```\nt1```\n value into ```\nodd```\n, you update it to the next.\nThe fibonacci sequece is:\n```\nt1  t2  t1  t2  t1  t2   t1   t2\n1   2   3   5   8   13   21   34\n```\n\nInstead of adding 1, you are updating ```\nt1```\n to 3 before, so 1 is ignored.\nInside your ```\nwhile```\n loop, try this:\n```\nSystem.out.print(t1 + \" + \");\n\nif (t1 % 2 != 0) odd += t1;\nt2 += t1;\nt1 = t2 - t1;\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence - How to calculate the sum of the first 100 even-values Fibonacci numbers?\r\n                \r\nFibonacci sequence is defined as a sequence of integers starting with 1 and 1, where each subsequent value is  the sum of the preceding two I.e.\n```\nf(0) = 1\nf(1) = 1\nf(n) = f(n-1) + f(n-2) where n>=2\n\n```\n\nMy goal is to calculate the sum of the first 100 even-values Fibonacci numbers.\nSo far I've found this code which works perfectly to calculate the sum of even numbers to 4million , however I'm unable to find edit the code so that it stops at the sum of the 100th value, rather than reaching 4million.\n```\n\npublic class Improvement {\n  public static int Fibonacci(int j) {\n      \n      /**\n       * \n       * Recursive took a long time so continued with iterative \n       * \n       * Complexity is n squared.. try to improve to just n\n       * \n       */\n            int tmp;\n            int a = 2;\n            int b = 1;\n            int total = 0;\n\n            do {\n              if(isEven(a)) total +=a;\n              tmp = a + b;\n              b = a;\n              a = tmp;      \n            } while (a < j);\n\n            return total;\n\n          }\n\n          private static boolean isEven(int a) {\n            return (a & 1) == 0;\n          }\n\n          public static void main(String[] args) {\n            // Notice there is no more loop here\n            System.out.println(Fibonacci(4_000_000));\n          }\n        }\n\n```\n\nJust to show the console from @mr1554 code answer, the first 100 even values are shown and then the sum of all is 4850741640 as can be seen below:\nAny help is appreciated, thanks!\n\n    ", "Answer": "\r\nYou need to use ```\nBigInteger```\n because ```\nlong ```\neasily overflows as Fibonacci's scales quite easily. ```\nBigInteger```\n is also tricky to check whether is an odd or even number, but you can use ```\nBigInteger::testBit```\n returning ```\nboolean```\n as explained in this answer.\nHere is some complete code:\n```\nBigInteger fibonacciSum(int count, boolean isOdd) {\n    int i = 0;\n    BigInteger sum = BigInteger.ZERO;\n    BigInteger current = BigInteger.ONE;\n    BigInteger next = BigInteger.ONE;\n    BigInteger temp;\n\n    while (i < count) {\n        temp = current;\n        current = current.add(next);\n        next = temp;\n\n        if ((current.testBit(0) && isOdd) || ((!current.testBit(0) && !isOdd))) {\n            sum = sum.add(current);\n            i++;\n        }\n    }\n\n    return sum;\n}\n```\n\nOr you can have some fun with Stream API:\n```\nBigInteger fibonacciSum(int count, boolean isOdd) {\n    final BigInteger[] firstSecond = new BigInteger[] {BigInteger.ONE, BigInteger.ONE};\n    return Stream.iterate(\n            firstSecond, \n            num -> new BigInteger[] { num[1], num[0].add(num[1]) })\n        .filter(pair -> \n            (pair[1].testBit(0) && isOdd) || \n            (!pair[1].testBit(0) && !isOdd))\n        .limit(count)\n        .map(pair -> pair[1])\n        .reduce(BigInteger.ZERO, BigInteger::add);\n}\n```\n\nIn any way, don't forget to test it out:\n```\n@Test\nvoid test() {\n    assertThat(\n        fibonacciSum(100, false),\n        is(new BigInteger(\"290905784918002003245752779317049533129517076702883498623284700\")));\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Calculating the Sum of the Fibonacci Sequence Using Recursion MATLAB\r\n                \r\nSo I am having a little issue with recursion. I see there are a lot of questions in regards to finding the Fibonacci sequence using recursion, but I figured that out(for the most part) on my own. What I am struggling with, however, is trying to find the sum of all of the fibonnaci numbers up until a certain value. For instance, if I input the number 3, I should get four. If I input the number 10, my total should be 143. So basically:\n\n```\n Test Cases:\n  out1 = sumFib(3);\n   out1 = 4;\n\n   out2 = sumFib(10);\n   out2 = 143;\n\n   out3 = sumFib(28);\n   out3 = 832039\n```\n\n\nI'm struggling a little understanding how to get the base case (or terminating factor). Here is what I have so far for my code:\n\n```\nfunction out = sumFib(n)\n\nif n==1 || n==2\n    out = 1;\n   else\n    out =sumFib(n-1) + sumFib(n-2) ;\n    %// Gives us the value of n-1 and adds it to the value of n-2\n\nend\n\nend\n```\n\n\nThis gives me what the value of the number is at the nth position. To find the total sum, I've tried the following\n\n```\nif n==3\nout = 4\nelse\nout = sumFib(n) + sumFib(n - (n-1))\n```\n\n\nAs you cna imagine, this flags me with \n\n```\n\"Maximum recursion limit of 500 reached. Use set(0,'RecursionLimit',N) to change the limit. Be aware that exceeding your available stack space can crash MATLAB and/or your computer.\"\n```\n\n\nI've also tried to do:\n\n```\nfunction out = sumFib(n)\n\nif n==1 || n==2\n    out = 1;\n   else\n    out =(1+sumFib(n-1)) + sumFib(n-2) ;\n    %Gives us the value of n-1 and adds it to the value of n-2\n```\n\n\nAnd using the correct sum aspect for the Fibonacci sequence \n\n```\nif n==3\n        out = 4;\n    else\n       out = sumFib(n+2)-1;\nend\n```\n\n\nHere the 1 is my attempt to let the problem know to move on to the next number, but that doesn't work. If anyone could better explain the base condition to me and help, I'd appreciate it.\n    ", "Answer": "\r\nKeep it simple, and split the functions in two:\n\n```\nfunction out = fib_sum(n)\n    out = fib(n+2) - 1;\nend\n\nfunction out = fib(n)\n    if n < 2\n        out = n;\n    else\n        out = fib(n-1) + fib(n-2);\n    end\nend\n```\n\n\n(of course I'm assuming non-negative integer numbers)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence using array without using recursion technique\r\n                \r\nI'm trying to generate a code that will display the Fibonacci sequence using an array I did generate a code that has the right solution but I think it's too long since the instructor told us it's gonna be a maximum of 5 lines of code\nSo here is the method :\n```\npublic static void fibonacci_array_calc(int[] array) {\n    int result;\n    System.out.println(\"Fibonacci Series of \" + array.length + \" numbers: \");\n    if (array.length == 0 || array.length == 1) {\n        for(int i = 0;i < array.length; i++)\n            System.out.print(array[i] + \" \");\n    } else {\n        for (int i = 0; i <= 1; i++) {\n            result = array[i] = i;\n            System.out.print(result + \" \");\n            if (array[i] >= 1) {\n                for (int j = 2; j < array.length; i++, j++) {\n                    result = (array[j] = (array[i] + array[i - 1]));\n                    System.out.print(result + \" \");\n                }\n            }\n        }\n    }\n}\n```\n\nthe output is\n```\nFibonacci Series of 10 numbers: \n0 1 1 2 3 5 8 13 21 34\n```\n\nit's not allowed to use the recursion technique is there any way to shorten this code?\n    ", "Answer": "\r\nYou can greatly simplify your code by using a conditional assignment to ```\narray[i]```\n. This assignment can then be used regardless of the length of the input array:\n```\npublic static void fibonacci_array_calc(int[] array) {\n    System.out.println(\"Fibonacci Series of \" + array.length + \" numbers: \");\n    for (int i = 0; i < array.length; i++) {\n        array[i] = i <= 1 ? i : array[i-2] + array[i-1];\n        System.out.print(array[i] + \" \");\n    }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in RISC V using recursion\r\n                \r\nI am trying to write a recursive function in RISC-V where it calculates the Fibonacci sequence in RISC V of a number n, in this case n=7. So the expected answer of fib(n) where n=7 should be 13.\n```\naddi x10, x10, 7  \nmain:\n    beq x10, x0, done \n    addi x5, x0, 1\n    beq x10, x5, done \n    addi sp, sp -16 \n    sd ra, 8(sp)\n    sd x10, 0(sp)\n    addi x10, x10, -1 \n    jal x1, main\n    ld x5, 0(sp)\n    sd x10, 0(sp)\n    addi x10, x5, -2\n    jal x1, main\n    ld x5, 8(sp)\ndone:\n    add x10, x10, x5\n    li a7, 1\n    ecall\n    ld ra, 0(sp)\n    addi sp, sp, 16\n    li a7, 10\n    ecall\n```\n\nI've managed to get this far and the code does run but it always prints out the value of 2. I would like to know why and what I need to change to print out the value of fib(n) which like I said n=7 so fib(7)=13 is the expected value. Where is my mistake in my code? Thank you.\n    ", "Answer": "\r\nYour function fails to account for register collisions between different levels of the recursion.  You cannot put 2 different values in the same register without wiping out the former value with the latter.  Nothing in the hardware \"stacks\" register values, so if you want that behavior, you do it yourself using instructions to accomplish that.\n\nDon't write a recursive ```\nmain```\n.  Your ```\nmain```\n should be a test case that either inputs a test value, then calls your recursive ```\nfib```\n function (or calls with a hard-coded parameter), then prints out the results, then stops the process.\n\nNever mix x register names like x10 with friendly register names, like a7; very confusing and super error prone.\nIf you want to write readable code use only the friendly register names, and don't use x register names at all (except perhaps x0).\n\nThe calling convention tells us what how to\n\npass parameter, and\nreceive return values registers\n\nWhich registers are\n\nscratch/call-clobbered, and,\ncall-preserved, and how to preserve them\n\nWhen one function calls another the convention should be observed (though optimizations are possible, one should learn the standard approach first).\nRecursion adds no additional requirements to the calling convention — it is just one function calling another — that it is calling itself is just a red herring.  All you have to do is the usual things required by the calling convention and the needs of your function, viewed as if it were calling something external rather than itself.\nYou can search for function calling for RISC V (or MIPS, very similar), to find lots of posts about how this is done.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "JAVA Determining the limit before stack overflow occurs, fibonacci sequence\r\n                \r\nI am trying to calculate the Fibonacci sequence using 2 different methods, one recursively and the other using a loop. I'm having difficulty figuring out how to determine the limit for each of the methods if the user is asked to input a number. Here is my code:\n\n```\nimport java.util.Scanner;\npublic class Recursion {\n\npublic static void main(String[] args) \n{\n    Scanner kb = new Scanner(System.in);\n    long n, result1, result2, startTime1, stopTime1, startTime2, stopTime2;\n\n    System.out.println(\"Please Enter A Number in between 0 and maxValue, will be calcualtred using 2 methods....\");\n    n = kb.nextLong();\n\n    startTime1 = System.nanoTime();\n    result1 = fibRecursive(n);\n    stopTime1 = System.nanoTime();\n\n    startTime2 = System.nanoTime();\n    result2 = fibLoop(n);\n    stopTime2 = System.nanoTime();\n\n    System.out.println(\"\\nDisplaying solution for recursive method: \"+ result1 + \" Time Taken (in nanoseconds): \" + (stopTime1 - startTime1));\n    System.out.println(\"\\nDisplaying solution for loop method: \"+ result2 + \" Time Taken (in nanoseconds): \" + (stopTime2 - startTime2));\n    System.out.println(\"\\nThanks for using our fibnoacci calculator. \");\n}\n\npublic static long fibRecursive(long i)  \n{\n    if(i == 0)\n        return 0;\n    else if(i == 1)\n        return 1;\n    else\n        return fibRecursive(i - 1) + fibRecursive(i - 2);\n}\npublic static long fibLoop(long k)  \n{\n    long a = 0, b = 1, ans = 0;\n    if(k == 0)\n        return 0;\n    else if(k == 1)\n        return 1;\n    else\n    for(int i = 1; i < k; i++)\n    {\n        ans = a + b;\n        a = b;\n        b = ans;    \n    }\n    return ans;\n}\n```\n\n    ", "Answer": "\r\nAnother approach could be try to catch the Error.\n\n```\ntry {\n\n} catch(StackOverflowError e){\n        System.err.println(\"ouch!\");\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence iteratively?\r\n                \r\nI'm new to racket and trying to give a function an integer and it should return it's Fibonacci value (iteratively). I don't know what I'm getting wrong with the do and if I incorporate an if statement to catch when the number = 1 everything breaks\n\n```\n(define (fib-iterat n)\n (do ((i 1 (+ i 1))\n   (nextTerm 0 (+ value0 value1))\n   (value0 0 (+ value1 0))\n   (value1 1 (+ nextTerm 0)))\n((> i n) nextTerm))\n)\n```\n\n\nI get:\n\n```\n1 = 1\n2 = 1\n6 = 3\n9 = 7\n12 = 16\n```\n\n    ", "Answer": "\r\n```\n;;; correct\n(define (fib n)\n  (do ((i 0 (+ i 1))\n       (n1 1 (+ n0 n1))\n       (n0 0 n1))\n    ((= i n) n0)))\n\n;;; still correct\n(define (fib n)\n    (do ((i 0 (+ i 1))\n         (n0 0 n1)\n         (n1 1 (+ n0 n1)))\n      ((= i n) n0)))\n\n\n;;; wrong\n(define (fib-iterat n)\n  (do ((i 0 (+ i 1))\n       (value1 1 nextTerm)\n       (value0 0 value1)\n       (nextTerm 1 (+ value0 value1))) ; first bracket close\n    ((= i n) (list value0 value1 nextTerm)))) ; second bracket\n```\n\n\nI never read any \"do loop\" code (but it should be easy to understand). You can think like this way. We separate old state and new state. In first bracket variable calculus only use old state values. So in do loop first bracket order in many case should be irrelevant. We refresh variable value but new values will be use in next loop or second bracket.\n\ntry (fib-iterat 2),\nwe call old state (o1,o2,o3),\ni=0≠n,\nold state:none,\nnew state:(value0,value1,nextTerm)=(0,1,1),\ni=i+1\n\ni=1≠n,\nold state:(0,1,1),\nnew state:(o2,o3,o2+o3)=(1,1,1),\ni=i+1\n\ni=2=n,\nold state:(1,1,1),\nnew state:(o2,o3,o2+o3)=(1,1,2)\nwe want (1,2,2) so it wrong.\n\nI think the most important thing is don't think it a set! binding. It's more like this.\n\n```\n(define (f n)\n  (do ([i 0 (+ i 1)]\n       [n1 1 (+ n1 n3)]\n       [n2 1 (+ n1 n2)]\n       [n3 1 (+ n2 n3)])\n    ((= i n) (list n1 n2 n3))))\n\n(define (my-do-loop  n)\n  (local ((define (λ0 i n1 n2 n3) (+ i 1))\n          (define (λ1 i n1 n2 n3) (+ n1 n3))\n          (define (λ2 i n1 n2 n3) (+ n1 n2))\n          (define (λ3 i n1 n2 n3) (+ n2 n3))\n          (define (aux i n1 n2 n3)\n            (if (= i n)\n                (list n1 n2 n3)\n                (aux (λ0 i n1 n2 n3) \n                     (λ1 i n1 n2 n3)\n                     (λ2 i n1 n2 n3)\n                     (λ3 i n1 n2 n3)))))\n    (aux 0 1 1 1)))\n\n```\n\n\nSo it makes us easy understanding why we only use old value and binding order is not important because we don't do any value binding.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python Fibonacci sequence\r\n                \r\n```\nfrom decimal import Decimal\npos_inf = Decimal('Infinity')\n\nf1 = 1\nf2 = 1\nn = 0\n\nwhile n < pos_inf:\n    n = f1 + f2\n\n    f1 = n\n    f2 = f1 + f2\n\n    print(f1)\n    if(len(str(f1) == 3):\n         break\n     print(f1 + the number is found)\nprint(f2)\n\nif(len(str(f2) == 3):\n    break\nprint(f2 + the number is found)\n```\n\n\nThis is obviously a Fibonacci generator where at one point one of the number being printed will be 144, and this will be the first number with 3 digits. I am not sure why the above isn't working? \n    ", "Answer": "\r\nThe problem is how you calculate Fibonacci number. It should be\n\n```\nwhile n < pos_inf:\n    n = f1 + f2\n    f2 = f1\n    f1 = n\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "how to find the 'n' term in fibonacci sequence?\r\n                \r\nSo i need help with finding a certain term in the fibonacci sequence. I have a program that is pretty close to it, but it will always find the term before the one i actually want.For example, if i want to show the 12th term it will show 89 instead of 144. This is also based on user input, so the user will choose what term to display. Heres the program i have.\n\n```\n#include <iostream>\nusing namespace std;\n\nfloat fibSequence(float x);\n\nint main(){\n  int x;\n  cout << \"Term in fibonacci number: \";\n  cin >> x;\n  cout << \"Fibonacci term: \" << fibSequence(x) << endl;\n}\n\nfloat fibSequence(float x){\n  int prev = 1;\n  int prev2 = 0;\n  int current = x;\n  for(int i = 2; i <= x; i++){\n    current = prev + prev2;\n    prev = prev2;\n    prev2 = current;\n  }\n  return current;\n}\n```\n\n\nAnd for the life of me i cannot figure out why. Like always, any help is appreciated!\n    ", "Answer": "\r\nYou have an error in your assignment order. It should be:  \n\n```\ncurrent = prev + prev2;  \nprev2 = prev;  \nprev = current;  \n```\n\n\nedit: \nyou could also switch the initial values:\n\n```\nint prev = 0;\nint prev2 = 1;\n```\n\n\nbut i assume ```\nprev2```\n is meant to be 'older' than ```\nprev```\n \n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Create a fibonacci sequences using for-loop and arrays in java\r\n                \r\nGenerate a Fibonacci sequence. \n\n\nEach number in the Fibonacci sequence is the\nsum of the two preceding numbers in the sequence. \nThe first two numbers in the sequence are both 1. \nThe third number is 2 , the fourth number is 3, the fifth number is 5, and the sixth number is 8. \nThe program should\nbe able to return a specified number in the fibo sequence. \nIf a number is specified that is out of range, a -1\nshould be returned.\n\n\nThe starting of code:\n\n```\n public class Fibonacci\n {\n  public static int[] go(int[] ray)\n  {\n   int [] array = int[];\n    array[0] = 0;\n    array[1] = 1;\n    for(int i = 2; i<ray.length; i++)\n    {\n      array[i] = array[i-1] + array[i-2];\n    }  \n    return array; \n  }\n}\n```\n\n\nThe Runner that i use with this program:\n\n```\nclass Main {\n  public static void main(String[] args) {\n    Fibonacci rt = new Fibonacci();\n    //Set size to 50\n    System.out.println( rt.go(1,50));\n    System.out.println( rt.go(2,50));\n    System.out.println( rt.go(3,50));\n    System.out.println( rt.go(4,50));\n    System.out.println( rt.go(5,50));\n    System.out.println( rt.go(6,50));\n    System.out.println( rt.go(11,50));\n    System.out.println( rt.go(16,50));\n    System.out.println( rt.go(21,50));\n    System.out.println( rt.go(31,50));\n    System.out.println( rt.go(41,50));\n    System.out.println( rt.go(46,50));\n    //Set size to 1\n    System.out.println( rt.go(1,1));\n    //Set size to 2\n    System.out.println( rt.go(1,2));\n    System.out.println( rt.go(2,2));\n    System.out.println( rt.go(11,2));\n  }\n}\n```\n\n\nCorrect answers with this runner:\n\n```\n1\n1\n2\n3\n5\n8\n89\n987\n10946\n1346269\n165580141\n1836311903\n1\n1\n1\n-1\n```\n\n\nPlease anyone correct my code because it do not work but do not change the concept that i use.\n\nThank you\n    ", "Answer": "\r\n\nThe method is supposed to take two int arguments ```\nk```\n and ```\nn```\n.  ```\nk```\n is the ```\nkth```\n one to return and ```\nn```\n is the number to generate.\nThe method is supposed to return an an ```\nint```\n which would be the ```\nkth```\n fibonacci.  You are returning the entire array which is incorrect.\nIf k is > than n you are supposed to return a -1.\n\n\nSo you need to make those changes and then run the code to see if it is working.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Create a fibonacci sequences using for-loop and arrays in java\r\n                \r\nGenerate a Fibonacci sequence. \n\n\nEach number in the Fibonacci sequence is the\nsum of the two preceding numbers in the sequence. \nThe first two numbers in the sequence are both 1. \nThe third number is 2 , the fourth number is 3, the fifth number is 5, and the sixth number is 8. \nThe program should\nbe able to return a specified number in the fibo sequence. \nIf a number is specified that is out of range, a -1\nshould be returned.\n\n\nThe starting of code:\n\n```\n public class Fibonacci\n {\n  public static int[] go(int[] ray)\n  {\n   int [] array = int[];\n    array[0] = 0;\n    array[1] = 1;\n    for(int i = 2; i<ray.length; i++)\n    {\n      array[i] = array[i-1] + array[i-2];\n    }  \n    return array; \n  }\n}\n```\n\n\nThe Runner that i use with this program:\n\n```\nclass Main {\n  public static void main(String[] args) {\n    Fibonacci rt = new Fibonacci();\n    //Set size to 50\n    System.out.println( rt.go(1,50));\n    System.out.println( rt.go(2,50));\n    System.out.println( rt.go(3,50));\n    System.out.println( rt.go(4,50));\n    System.out.println( rt.go(5,50));\n    System.out.println( rt.go(6,50));\n    System.out.println( rt.go(11,50));\n    System.out.println( rt.go(16,50));\n    System.out.println( rt.go(21,50));\n    System.out.println( rt.go(31,50));\n    System.out.println( rt.go(41,50));\n    System.out.println( rt.go(46,50));\n    //Set size to 1\n    System.out.println( rt.go(1,1));\n    //Set size to 2\n    System.out.println( rt.go(1,2));\n    System.out.println( rt.go(2,2));\n    System.out.println( rt.go(11,2));\n  }\n}\n```\n\n\nCorrect answers with this runner:\n\n```\n1\n1\n2\n3\n5\n8\n89\n987\n10946\n1346269\n165580141\n1836311903\n1\n1\n1\n-1\n```\n\n\nPlease anyone correct my code because it do not work but do not change the concept that i use.\n\nThank you\n    ", "Answer": "\r\n\nThe method is supposed to take two int arguments ```\nk```\n and ```\nn```\n.  ```\nk```\n is the ```\nkth```\n one to return and ```\nn```\n is the number to generate.\nThe method is supposed to return an an ```\nint```\n which would be the ```\nkth```\n fibonacci.  You are returning the entire array which is incorrect.\nIf k is > than n you are supposed to return a -1.\n\n\nSo you need to make those changes and then run the code to see if it is working.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding nth number of primes in Fibonacci sequence (Faster)\r\n                \r\nI'm taking my first programming course, and my assignment has been to list the nth number of prime numbers in the Fibonacci sequence.\nSo far I've come up with this:\n\n```\n num = int(input(\"Enter a number: \"))\n\na = 1\nb = 1\nc = 0\ncount = 0\nisPrime = True \n\nwhile (count < num):\n    isPrime = True\n    c = a + b\n\n    for i in range(2,c):\n        if (c % i == 0):\n            isPrime = False\n            break\n\n    if (isPrime):\n        print (c)\n        count = count + 1\n    a = b\n    b = c\n```\n\n\nThis works, but for any input greater than 10 it takes a really long time, can anyone help me figure out how to make it a bit quicker? I assume it's because a,b and c end up becoming really big, but I'm not sure how to fix this.\n    ", "Answer": "\r\n```\nfib = lambda n:reduce(lambda x,n:[x[1],x[0]+x[1]], range(n),[0,1])[0]\n```\n\n\nshortest and fastest fibonacci numbers one liner script in python.\n\n```\n>>> fib(1000)\n43466557686937456435688527675040625802564660517371780402481729089536555417949051\n89040387984007925516929592259308032263477520968962323987332247116164299644090653\n3187938298969649928516003704476137795166849228875L\n```\n\n\nfound here.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Endless Loop in C while making Fibonacci Sequence with fork()\r\n                \r\nI am a beginner programmer in C and have been trying to program a Fibonacci sequence sequence in C that reads a command line argument and uses a fork command to output the results. However whenever I run it my program gets stuck in an infinite loop and I have no idea what is causing the issue in the While loop. I haven't been able to use an IDE for this so I apologize for the rough formatting.\n```\nint main(int argc, char* argv[])\n{\n    pid_t id;\n    int x = 0;\n    int y = 1;\n    int fib = 0;\n    long input = 0;\n\n\n\n    input = (long)argv[1];\n\n    id = fork();\n\n    if(input < 0){\n        printf(\"Enter a positive number. Invalid input\");\n    }\n\n    if(id == 0){ /*Child Process */\n       printf(\"The numbers in your Fib sequence are: 0, 1, \");\n       while(input > 0){\n          fib = x + y;\n          printf(\"%d\", fib);\n          x = y;\n          y = fib;\n          input = input -1;\n       }\n       return 1;\n    }\n    else{ /*parent*/\n       wait(NULL);\n       printf(\"Parent is done\");\n    }\n    return 0;\n  }\n```\n\n    ", "Answer": "\r\nthis is wrong\n```\ninput = (long)argv[1];\n```\n\nargv[1] is a string. You have forced a pointer into being a long and so have ended up with a huge number.\nYou need ```\nstrtol```\n, see https://man7.org/linux/man-pages/man3/strtol.3.html\nTest argc first to be sure argc > 1\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to implement the Fibonacci sequence in successor arithmetics for all argument modes?\r\n                \r\nThe following Prolog program defines a predicate ```\nfib/2```\n for computing the Fibonacci number of an integer in successor arithmetics:\n```\nfib(0, 0).\nfib(s(0), s(0)).\nfib(s(s(N)), F) :-\n  fib(N, F1),\n  fib(s(N), F2),\n  sum(F1, F2, F).\n\nsum(0, N, N).\nsum(s(N1), N2, s(S)) :-\n  sum(N1, N2, S).\n```\n\nIt works with queries in this argument mode:\n```\n?- fib(s(0), s(0)).\n   true\n;  false.\n```\n\nIt also works with queries in this argument mode:\n```\n?- fib(s(0), F).\n   F = s(0)\n;  false.\n```\n\nIt also works with queries in this argument mode:\n```\n?- fib(N, F).\n   N = F, F = 0\n;  N = F, F = s(0)\n;  N = s(s(0)), F = s(0)\n;  N = s(s(s(0))), F = s(s(0))\n;  N = s(s(s(s(0)))), F = s(s(s(0)))\n;  …\n```\n\nBut it exhausts resources with queries in this argument mode:\n```\n?- fib(N, s(0)).\n   N = s(0)\n;  N = s(s(0))\n;\nTime limit exceeded\n```\n\nHow to implement the Fibonacci sequence in successor arithmetics for all argument modes?\n    ", "Answer": "\r\nThis answer computes the fibonacci number \"bottom up\" using the two previous computed values, so that it will only make one recursive tail call:\n```\nfib(0, 0).\nfib(s(0), s(0)).\nfib(s(s(X)), F):-\n  fib(X, 0, s(0), F, F).\n  \nfib(0, F_2, F_1, _, F):-\n  sum(F_2, F_1, F).\nfib(s(X), F_2, F_1, s(Y), F):-\n  sum(F_2, F_1, F_0),\n  fib(X, F_1, F_0, Y, F).\n\nsum(0, Y, Y).\nsum(s(X), Y, s(Z)):- \n  sum(X, Y, Z).\n```\n\nAt least in SWI with default configuration it exhausts resources computing the fibonacci(37) building the addition term in ```\nsum/3```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "bash script array to memoize fibonacci sequence\r\n                \r\nUnable to save Fibonacci values to an associative array for momoization. This script takes a Fibonacci index as an argument and returns the associated value sequence value. On each script execution a new sequence is generated from 1 to the argument value. Memoization should decrease the overall runtime.\n\nfab.sh\n\n```\nif [ -f log.txt ]; then\n  rm log.txt\nfi\n\n# initialize SAVED array\nSAVED=()\n\n# populate saved with $1 of 0's\nfor i in $(eval echo {0..$(($1-1))}); do\n  SAVED[i]=0\ndone\n\nfib () {\n  local currentIndex=$1\n\n  if [ \"$currentIndex\" -eq 0 ]\n  then\n    echo 0\n  elif [ \"$currentIndex\" -eq 1 ] ; then\n    echo 1\n  elif [[ ${SAVED[$currentIndex]} -ne 0 ]]; then\n    echo 'MEMOIZED' >> log.txt\n    echo ${SAVED[$currentIndex]}\n  else\n    SAVED[$currentIndex]=$((`fib $[$currentIndex - 1]`+`fib $[$currentIndex - 2]`))\n    echo ${SAVED[@]} >> log.txt\n    echo ${SAVED[$currentIndex]}\n  fi\n}\n\nif [[ $1 -eq 0 ]]\nthen\n  echo \"Sequence limit must be at least 1\"\nelif [[ $1 -gt 0 ]]\nthen\n  fib $(($1 - 1)) \nfi\n```\n\n\nif fab.sh is ran using ```\n$ source fab.sh 5```\n:\n\n```\n$ 3\n```\n\n\nIt is printing the correct value but memoization is not functioning.\n\nThe log.txt file out is:\n\n```\n0 0 1 0 0\n0 0 0 2 0\n0 0 1 0 0\n0 0 0 0 3\n```\n\n\nIt seems like the 'SAVED' array is being reset or the assigned values aren't persisting. Since the SAVED array is a global variable I would think this would work. It could have something to do with how bash handles recursive functions.\n\nAny insights would be greatly appreciated.\n    ", "Answer": "\r\nInstead of\n\n```\nSAVED[$currentIndex]=$((`fib $[$currentIndex - 1]`+`fib $[$currentIndex - 2]`))\n```\n\n\nyou probably wanted to write\n\n```\nSAVED[currentIndex]=$((`fib $((currentIndex - 1))` + `fib $((currentIndex - 2))`))\n```\n\n\nHowever, that wouldn't solve the actual problem. As we can see from your log, the memoization array has at all times at most one entry. How is it possible that the last entry is filled, but the entries which are needed to compute that last entry are 0? The answer is »subshells«!\n\nWhen you call your function using a subshell ```\n$(fib ...)```\n, the changes that function makes on variables are only inside the subshell.\nTo work around the problem, you have to either use a file for memoization or find a way to call your function without a subshell.\n\nHere is how I would have written that scrip, if I were forced to use your current approach. Please note that there are better ways to compute the fibonacci numbers and better languages to program these computations in.\n\n```\n#! /bin/bash\nmemo=(0 1)\nfib() {\n        >&2 printf %s \"fib($1) memo=(${memo[*]}) => \"\n        local n=\"$1\"\n        if [ \"${memo[n]+x}\" ]; then\n                >&2 echo lookup\n                return\n        fi\n        >&2 echo compute\n        fib \"$((n-1))\"\n        fib \"$((n-2))\"\n        ((memo[n]=memo[n-1]+memo[n-2]))\n}\nfib \"$1\"\necho \"${memo[$1]}\"\n```\n\n\nLines starting with ```\n>&2```\n are only there to print debug information; you can delete them. To suppress debug output, run the script as ```\nscript.sh 12 2> /dev/null```\n.\n\nImprovements:\n\n\nTo work around the subshell problem, don't echo the function result and store it using ```\nvar=$(fib ...)```\n, but remain silent and directly store the result in a designated global variable. Here we don't need a new variable because we already have the memoization array. We first call ```\nfib x```\n to make sure that array entry ```\nx```\n is there, then we access that entry with ```\nmemo[x]```\n.  \nInstead of printing to a log, print debug information to ```\nstderr```\n using ```\n>&2 echo```\n.\nBy storing ```\nfib(0)=0```\n in the memoization array, we don't have to use an index offset.\nEmbed the trivial cases 0 and 1 directly into the memoization array.\nDon't initialize the array with ```\n0```\n.\n```\n${memo[n]}+x```\n expands to ```\nx```\n if and only if ```\nfib(n)```\n is already memoized.\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "code for the sum of a Fibonacci sequence doesnt give the correct sum\r\n                \r\nI wrote this code to calculate the sum of any n that I input for the Fibonacci sequence. \n\n```\ndef fib(n):\n    if n==0:\n        return 0\n    elif n==1:\n        return 1\n    elif n==2:\n        return 2\n    else:\n        num = fib(n-1) + fib(n-2)\n        return num \n    return sum(num)\n\nfib(7)\n```\n\n\nThis produces an output of 21 when it's supposed to produce an outcome of 20? It always seems to output a sum of one more than the actual sum \n    ", "Answer": "\r\nIt's because for ```\nn=2```\n the result is ```\nf(0)+f(1)= 0+1 =1```\n and not ```\n2```\n so ```\nreturn 1```\n so you can remove that condition, also the ```\nsum```\n code is useless and it not reachable, so it becomes : \n\n```\ndef fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n# can be shorten with python if/else inline syntax\ndef fib(n):\n    return n if n <= 1 else fib(n - 1) + fib(n - 2)\n```\n\n\nYou can find others implementations here : How to write the Fibonacci Sequence?\n\n\n\n\nTO get the sum of fibo values, you may store the values, to not count them a lots of time, solution : ```\narray```\n. And if you manage to use it several time, get the array out of the function, here is an example of how to use it to be performant\n\n```\nfibonacci_numbers = [0, 1]\ndef fibo_setup(max_value=10):\n    \"\"\"Compute the values until a limit, and store in a list\"\"\"\n    for i in range(len(fibonacci_numbers), max_value):\n        fibonacci_numbers.append(fibonacci_numbers[i - 1] + fibonacci_numbers[i - 2])\n\ndef fibo(n):\n    \"\"\"Retrieve a fibo value using the array, compute if not present\"\"\"\n    if len(fibonacci_numbers) < n:\n        fibo_setup(n + 1)\n    return fibonacci_numbers[n]\n\ndef fibo_sum(n):\n    \"\"\"Get the sum of fibo values, and before it checks that the array is filled\"\"\"\n    fibo_setup(n)\n    return sum(fibonacci_numbers[:n])\n\nif __name__ == '__main__':\n    fibo_setup(10)\n    print(fibo(12))\n    print(fibo_sum(15))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Verify User Input is a number only on Fibonacci sequence\r\n                \r\n```\nimport java.util.Scanner;\n\npublic class Fibonacci {\npublic static void main(String args[]) {\n\n\n    \n    int result = UserInput();\n\n    fibArray[0] = 1;\n    fibArray[1] = 1;\n\n    for (int i = 0; i < result; i++)\n\n\n        System.out.print(fibonacci(i) + \" \");\n\n}\n\n\npublic static long fibArray[] = new long[1000];\n\npublic static long fibonacci(long n) {\n    long fibValue = 0;\n    if (n == 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n\n    } else if (fibArray[(int) n] != 0) {\n        return fibArray[(int) n];\n    } else {\n        fibValue = fibonacci(n - 1) + fibonacci(n - 2);\n        fibArray[(int) n] = fibValue;\n        return fibValue;\n    }\n}\n\npublic static int UserInput() {\n\n    System.out.print(\"Enter a Fibonacci Number \");\n    Scanner test = new Scanner(System.in);\n    int n = test.nextInt();\n   \n\n    return n;\n}\n}\n```\n\nHi This is not homework nor is it a college assignment. I'm just learning java and I would like to implement a check in my UserInput method on Fibonacci sequence, I want only numbers to be entered and not special characters or letters. I've read other similar topics here but\nI'm still a bit unsure as to how to do this.\nHow would I achieve this ?\nAnd btw sorry if the code is sloppy.\nThanks\n    ", "Answer": "\r\nTo check if an entered value is part of a fibonacci series\n\nfirst add a set to add the fibValue in your method where you add it to the long array\n\n```\npublic static Set<Long> fibSet = new HashSet<>();\n```\n\n\nthen do the following:\n```\n  int value = UserInput();\n  boolean has = fibSet.contains(value);\n  for (int i = 0; i < 1000 && has == false; i++) {\n      if (value == fibonacci(i)) {\n          has = true;\n          break;\n      }\n  }\n  System.out.println(value + \" is\" + (has ? \"\" : \" not\")\n          + \" a term in the standard fibonacci sequence\");\n```\n\n}\n\n\nNote that the static set is only useful for multiple runs in the same program as is checks for previously added entries.\nAnd the 1000 value in the loop is arbitrary and can be altered to either increase or decrease the number of terms.\nUpdated Answer.\nAs you may already know, computing fibonacci series using recursion is an excellent exercise in seeing how that would work. But in practice it is incredibly slow.  As was mentioned in some comments, a simple iterative method is preferred and remembering previous computations (memoization) increases its efficiency.  Here is an example:\n```\nlong testValue = UserInput();\nboolean has = isFibonacciTerm(testValue);\n\nSystem.out.println(testValue + \" is\" + (has? \"\" : \" not\")\n        + \" a term in the standard fibonacci sequence\");\n    \npublic static List<Long> fibList = new ArrayList<>(List.of(0L,1L));\npublic static Set<Long> fibSet = new HashSet<>(fibList);\n    \npublic static boolean isFibonacciTerm(long testValue) {\n    long lastComputed = fibList.get(fibList.size()-1);\n    int start = fibList.size()-1;\n    while (testValue > lastComputed) {\n        lastComputed += fibList.get(start-1);\n        fibList.add(lastComputed);\n        fibSet.add(lastComputed);\n        start++;\n    }\n    return fibSet.contains(testValue);\n}\n```\n\n\nthe method only generates sufficient terms starting from the previous computed until the value under test is at least as large.\nthe the set is checked to see if it has the value under test.\n\nThe list allows for ordered access to get the most recent computed value and the set simply allows for quick lookup (a conditional could have been employed for certain cases but I decided to let the set handle that).\nNote that this can also be used to generate fibonacci sequences just by putting in a limiting term and printing the list.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How do I make my fibonacci sequence go up to n and not over at all\r\n                \r\nGiven the positive integer ```\nn```\n create a list consisting of the portion of the Fibonacci sequence less than or equal to n. For example, if ```\nn is 6```\n, then the list would be ```\n[0, 1, 1, 2, 3, 5]```\n and if ```\nn is 1```\n, then the list would be ```\n[0, 1, 1]```\n.\n\nCurrently this is what I have, if ```\nn```\n equals numbers as 6 or 20 than the Fibonacci sequence goes over ```\nn```\n e.g ```\n[0, 1, 1, 2, 3, 5, 8]```\n for ```\nn = 6```\n or ```\n[0, 1, 1, 2, 3, 5, 8, 13, 21]```\n for ```\nn = 20```\n\n\nthis is what I currently have \n\n```\nfib = [0,1]\n\nresult = 0\n\nwhile result < n:\n    result = fib[-1] + fib[-2]\n    fib.append(result)\n```\n\n    ", "Answer": "\r\n```\nfib = [0,1]\n\nresult = fib[-1] + fib[-2]\nwhile result < n:\n    fib.append(result)\n    result = fib[-1] + fib[-2]\n```\n\n\nthis should work.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence using Cache\r\n                \r\nI am trying to make use of a cache to improve the performance of my Fibonacci method. However, it is still taking a lot of time to compute even fibonacci(40).\n\n```\nimport java.util.Scanner;\npublic class FibWithCache {\n\n    public static void main(String args[]) {\n        System.out.println(\"Enter Fibonacci index: \");\n        Scanner sc = new Scanner(System.in);\n        int index = sc.nextInt();\n        sc.close();\n\n        System.out.println(fibonacci(index));\n    }\n\n    private static long fibonacci(int index) {\n\n        long result = 0;\n        long[] fibCache = new long[200];\n\n        if(index==0)\n            return 0;\n        else if(index == 1)\n            return 1;\n        else if(fibCache[index] != 0)\n            return fibCache[index];\n        else {\n            result = fibonacci(index-1) + fibonacci(index-2);\n            fibCache[index] = result;\n            return result;\n        }\n    }\n}\n```\n\n\nWhy am I unable to benefit from the cache?\n    ", "Answer": "\r\nHint: The issue is that each recursive call to ```\nfibonacci()```\n has its own cache. For every call you create an empty cache, store something in it, and immediately discard it.\n\nWhat you want is one cache shared by all the calls.\n\nI'll let you figure out how best to do it. :)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Feeling like a bad learner with Fibonacci sequence\r\n                \r\nI should start by saying I’m a noob at this. I just started learning Python 3 three weeks ago.\nI’m using Codio and trying to print out the Fibonacci sequence from 0 through 21. If someone could help me find a solution for this I’d be so grateful! I’ve been stuck on this for a while.\nHere is my code:\n```\nimport sys\n\nN = int(sys.argv[1])\n\nn1, n2 = 0, 1\nwhile n2 < 22:\n    print(n2)\n    n1, n2 = n2, n1 + n2\n```\n\nI’m using ```\npython3```\n to run this script, if that helps. Thank you guys in advance! I don’t really like asking for help often, but I’m lost. I’ve rewrote my code a few times and still end up with an error, am I just a bad beginner?\n    ", "Answer": "\r\nFor ```\nFibonacci```\n, there is a popular formula known as Binet's Formula, which states the counting the fibonnaci till ```\nn```\n numbers. The formula is:\n\nSo, making use of the formula, you can take the input of ```\nn```\n here, which is the end, in your case: ```\n21```\n\n```\nimport math\n\ndef fibonacci(n):\n  outer_number = 1 / pow(5, 1/2) \n  first_computation = ((1 + pow(5, 1/2)) / 2)\n  second_computation = ((1 - pow(5, 1/2)) / 2)\n  \n  return outer_number * (pow(first_computation, n) - pow(second_computation, n))\n  \nprint(int(fibonacci(21))) # >>> 10946\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence - PHP shortest code possible\r\n                \r\nI have spent some time trying to execute the Fibonacci sequence to 500 numbers and output to screen in the shortest amount of code possible. This was a learning exercise for me.\n\nI have condensed it from 21 lines down to 12, this is the shortest code I can write that makes this work.. Can anyone show me how I could have made the code even shorter?\n\nI have looked on google for PHP loops, and the while loop seemed to work best.\nAre there any other math tricks in PHP I can use to condense this even more?\n\nNormally when I ask a question, I like to show what research I have done into the problem, but since I don't know any keywords to look up for better math or loops, I am not sure what to search.. \n\nCode:\n\n```\n$counter = 0;\n$first = 1;\n$second = 1;\necho $first.\"<br/>\";\necho $second.\"<br/>\";\nwhile ($counter < 500) {\n  $next = $first + $second;\n  echo $next.\"<br/>\";\n  $counter++;\n  $second=$first;\n  $first=$next;\n}\n```\n\n    ", "Answer": "\r\nThe research for the shortest code is called \"code golf\" and there is a whole stack exchange site devoted to it.\n\nIn particular, your question is answered here.\n\nThe code is:\n\n```\n<?for($a=$b++;;$b+=$a=$b-$a){echo$a;}\n```\n\n\nthis works by:\n\n\nremoving whitespaces (which are ignored anyway) (cosmetic)\ngiving variables meaningless names (doesn't affect the output)(cosmetic)\nabusing various language features like implicit initialization to zero and multiple assignments\nthe multiple assignment trick lets you use two variables instead of three (no need for the \"current number\") exploiting the order of the assignment\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python convert simple integer list to Fibonacci sequence [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to find the cumulative sum of numbers in a list?\r\n                            \r\n                                (25 answers)\r\n                            \r\n                    \r\n                Closed 3 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have an int element list. \n\nI want to change that list to a Fibonacci series sequence.\n\n```\ndata = [1,0,2,4,5]\noutput_data = [1,1,3,7,12]\n```\n\n    ", "Answer": "\r\nYou can use ```\nitertools.accumulate```\n:\n```\nimport itertools as it\n\ndata = [1,0,2,4,5]\noutput = list(it.accumulate(data))\n\n# [1, 1, 3, 7, 12]\n```\n\nThe default binary function it applies is summation (more precisely, ```\noperator.add```\n).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence with 32 bit overflow algorithm\r\n                \r\nI am currently implementing a code that runs Fibonacci sequence (up to the 60th number) in riscv32I, which means that the memory address that I can use only has 32bits.\nI have first implemented the code in C, and then in Assembly, but I am curious if the algorithm I used has a name so I can do more research.  The code is as such,\n```\n#include <stdint.h>\n#include <stdio.h>\n#include <inttypes.h>\n\nint main() {\n    uint32_t n1 = 0;        // first pre number  (n - 2)\n    uint32_t n2 = 1;        // second pre number (n - 1)\n    uint32_t add = 0;       // current number\n\n    uint32_t store_hi = 0;  \n    uint32_t store_lo = 0; \n    uint32_t result;        // result\n    uint32_t carry;         // carry bit\n\n    for (int i = 2; i < 61; i++) {\n        carry = 0;                              // reset carry bit\n        add = (uint32_t)(n2 + n1);              // calculate current fib number\n        \n        if (add < n1) {                         // if overflow  \n            carry = 1;                          // set carry bit\n        }\n\n        result = store_hi + store_lo;           // keeping track of higher bits\n        result = result + carry;                // add carry bit\n\n        store_lo = store_hi;                    // \n        n1 = n2;                                // update first pre number\n        store_hi = result;                      // \n        n2 = add;                               // update second pre number\n    }\n\n    printf(\"Result32: 0x%08\" PRIx32 \" 0x%08\" PRIx32 \"\\n\", result, add);\n    uint64_t result64 = ((uint64_t)result << 32) | add;\n    printf(\"Result64: 0x%016\" PRIx64 \" -> %\" PRId64 \"\\n\", result64, result64);\n}\n```\n\nRunning the code gives\n```\nResult32: 0x00000168 0x6c8312d0\nResult64: 0x000001686c8312d0 -> 1548008755920\n```\n\nThe basic concept is that because the Fibonacci number gets too big to fit within a single 32bit memory address, we have to split it into 32bit memory address, one holding the upper bit, and one holding the lower bit.\nLet's generalize the above algorithm to a 4 bit memory space, to make it easier to follow the algorithm. This means that the maximum int can be 16. Let ss set n1 = 10, n2 = 10.\n```\nLoop 1:\n     add = 4 # (10 + 10 = 20, but overflow, so 20 % 16 = 4)\n     carry = 1\n     result = 1\n     store_lo = 0\n     store_hi = 1\n     n1 = 10\n     n2 = 4\n     # output: 0x14, 0x1 hi bit, 0x4 lo bit, which is 10 + 10 = 20\nLoop 2:\n     add = 14\n     carry = 0\n     result = 1\n     store_lo = 1\n     store_hi = 1\n     n1 = 4\n     n2 = 14\n     # output: 0x1e, 0x1 hi bit, 0xe or 14, lo bit, which is 10 + 20 = 30\nloop 3:\n     add = 2 (14 + 4 = 18, but overflow, so 18 % 16, 2)\n     carry = 1\n     result = 3\n     store_lo = 1\n     store_hi = 2\n     n1 = 14\n     n2 = 2\n     #output: 0x32, 0x3 hi bit, 0x2 low bit, which is  20 + 30 = 50\n.... and so on.\n```\n\nThis should work for any base, but I am curious what this algorithm is denoted as, or if it is simply related to modules and powers?\nThanks!\n    ", "Answer": "\r\nIt's called Arbitrary-precision arithmetic, you can read more about it here.\nArbitrary-precision arithmetic, also called bignum arithmetic, multiple-precision arithmetic, or sometimes infinite-precision arithmetic, indicates that calculations are performed on numbers whose digits of precision are limited only by the available memory of the host system.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Find n-th element of Fibonacci sequence given first two integers [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm doing some practicing and I've come across a question that I'm having trouble wrapping my head around.\n\nYou are given the first two integers of a Fibonacci sequence. You are to then find the n-th element of the sequence.\n\nFor example, given the sequence ```\n2,4```\n, output the ```\n4th```\n element. The answer is ```\n10```\n, because:\n\n```\n2,4,6,10```\n\n\nHow would I program this solution in JavaScript (with and without recursion)?\n    ", "Answer": "\r\nWithout recursion:\n\n```\nfunction Fibonacci(first, second, n){\n      let iter = 3; //set it to 3 since you are passing the first and second\n\n      //Use while loop instead of recursive calls to Fibonacci\n      while(iter < n){\n           let temp = first;\n           first = second;\n           second = temp + first;\n           iter++;\n      }\n\n      //If n is one, return first\n      if(n == 1)\n         return first;\n\n      //Display last item in sequence\n      console.log(second);\n\n       //Or return it\n      return second;\n}\n```\n\n\nWith Recursion:\n\n```\n function Fibonacci(first, second, n){\n      //If n - 2 (passing first 2 in sequence) is greater than or equal to 0, do operations and recall Fibonacci\n      if((n - 2) > 0){\n          let temp = first;\n          first = second;\n          second = temp + first;\n          n--;\n          return Fibonacci(first, second, n);\n      }\n\n      //If n is one, return first\n      if(n == 1)\n         return first;\n\n      //Display last item in sequence\n      console.log(second);\n\n      //Or return it\n      return second;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Using switch statement in Fibonacci sequence\r\n                \r\nIm currently writing a program which calculates the fibonacci number of a given integer using recursion. I created my own function 'fibonacci' and made the program to run on loops as you can see in the code.\n\nThe program wants me to use switch statement to operate the menu (The menu is the one where the user gets two options of either choosing to find fibonacci or to exit the program), and I am stuck on how to use switch statement in order to use the menu.\n\nHere is the code I wrote so far \n\n```\n #include <stdio.h>\n\n int fibonacci(int num);\n\n int main(int argc, char const *argv[]) {\n int choice;\n int num;\n int sequence;\n\n printf(\"1) Calculate Fibonacci\\n\");\n printf(\"2) Exit\\n\");\n scanf(\"%d\", &choice);\n\n if (choice == 1) \n {\n   do \n   {\n     printf(\"Input integer n :\\n\");\n     scanf(\"%d\", &num);\n\n     if (num < 0) \n     {\n       printf(\"n should be a positive integer (n >= 1). Retry\\n\");\n     }\n   } while (num < 0);\n }\n\n if (choice == 1 && num > 0) \n {\n   printf(\"Fibonacci sequence of %d terms\\n\", num);\n```\n\n    ", "Answer": "\r\nFrom \"The C Programming Language\" by Kernighan and Ritchie: \n\n\n  \"The switch statement is a multi-way decision that tests whether an expression matches one of a number of constant integer values, and branches accordingly.\"\n\n\nSo it should look similar to this:\n\n```\nwhile ((choice = getchar())!= EOF){\n    switch (choice){\n      case '1':\n          // calculate Fibonacci sequence\n          break;\n      case '2':\n          return 0;\n    }\n}\n```\n\n\nAs one of the comments suggests, either initialize your local variables in the beginning or check the return value of your getchar() or scanf() calls, since values of uninitialized variables are indeterminate.\n\nIf you've just started studying C, I suggest that you read the book that I mentioned. It's relatively short and has lots of helpful examples.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How do I determine if a number is part of the Fibonacci sequence?\r\n                \r\nI have an assignment to write a method that determines whether or not a number is part of the Fibonacci sequence.\n\nGoing along with the formula:\n\n\n  a positive integer z is a Fibonacci number if and only if one of 5z^2 + 4 or 5z^2 − 4 is a perfect square\n\n\nI defined the following method which works for small numbers and large Fibonacci numbers, however, for whatever reason, my assignment specs throw an error when processing a large non-Fibonacci number, specifically when running ```\nis_fibonacci?(927372692193078999171)```\n. Apparently the method returns ```\ntrue```\n instead of ```\nfalse```\n. Everything else seems to be correct, so I'm kind of pulling my hair out over why this wouldn't work. Any suggestions? \n\n```\ndef is_fibonacci?(i)\n  bigNumber1 = Math.sqrt((5*(i**2)+4))\n  bigNumber2 = Math.sqrt((5*(i**2)-4))\n  if bigNumber1 == bigNumber1.round || bigNumber2 == bigNumber2.round\n    return true\n  else \n    return false\n  end\nend\n```\n\n    ", "Answer": "\r\nAs noted elsewhere, the issue is with the precision of Floats.  BigDecimal provides arbitrary-precision arithmetic:\n\n```\nrequire 'bigdecimal'\n\ndef is_fibonacci?(i)\n  i = BigDecimal.new(i)\n  bigNumber1 = (5*(i**2)+4).sqrt(0)\n  bigNumber2 = (5*(i**2)-4).sqrt(0)\n  return (bigNumber1 == bigNumber1.round || bigNumber2 == bigNumber2.round)\nend\n\nis_fibonacci? 927372692193078999171 # => false\nis_fibonacci? 927372692193078999176 # => true\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursion on Fibonacci Sequence\r\n                \r\nI need some help in understanding the processing that happens here, so let´s say I call ```\nfib(5)```\n I want the fibonacci  5, which is 8. But my brain in trying to understand the algorithm says it´s not. This is how i (wrongly) think:   \n\n```\nreturn fib(4) + fib(3) // Stack frame 1\nreturn fib(3) + fib(1) // Stack frame 2\n```\n\n\nnow cause x is 1 ```\nfib(1)```\n, the conditional statement ```\nif x == 0 or x == 1:```\n causes the recursion to end. Which according to my logic would become 3+1+4+3. Please correct my faulty logic.\n\n```\ndef fib(x):\n    \"\"\"assumes x an int >= 0\n       returns Fibonacci of x\"\"\"\n    assert type(x) == int and x >= 0\n    if x == 0 or x == 1:\n        return 1\n    else:\n        return fib(x-1) + fib(x-2)\n```\n\n    ", "Answer": "\r\nHere is the full expansion of what happens:\n\n```\nfib(5) expands to fib(4)+fib(3)\n  fib(4) expands to fib(3)+fib(2)\n    fib(3) expands to fib(2)+fib(1)\n      fib(2) expands to fib(1)+fib(0)\n        fib(1) evaluates to 1\n        fib(0) evaluates to 1\n      fib(1) evaluates to 1\n    fib(2) expands to fib(1)+fib(0)\n      fib(1) evaluates to 1\n      fib(0) evaluates to 1\n  fib(3) expands to fib(2)+fib(1)\n    fib(2) expands to fib(1)+fib(0)\n      fib(1) evaluates to 1\n      fib(0) evaluates to 1\n    fib(1) evaluates to 1\n```\n\n\nIf you count the ones, you get 8 as the answer.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence using BigInteger Does not yield an answer\r\n                \r\nIm to find 100th element of a Fibonacci Sequence, I initially tried to store the value of numbers using an ```\nint```\n but it overflowed and switched to negative values just like ```\nlong```\n.Then I came across ```\nBigInteger```\n I did get the solution using a simple ```\nfor```\n loop and an ```\narray```\n to store the results, and access the previous elements. Now as Im trying to do the same problem using ```\nrecursion```\n The program does not seem to be terminating. Am I missing something here? Or are ```\nBigInteger```\n's not suggested to used with recursion? Here is the code:\n```\nimport java.math.BigInteger;\n\nclass Test {\n  public static void main(String[] args) {\n    BigInteger n = BigInteger.valueOf(100);\n    System.out.println(fib(n));\n  }\n\n  public static BigInteger fib(BigInteger n) {\n    if (n.compareTo(BigInteger.valueOf(1)) == 0 || n.compareTo(BigInteger.valueOf(1)) == -1)\n      return n;\n    return fib(n.subtract(BigInteger.valueOf(1))).add(fib(n.subtract(BigInteger.valueOf(2))));\n  }\n}\n```\n\n    ", "Answer": "\r\nIn the comments, you mentioned that your assumption that the program doesn't terminate is based on the fact that it ran for over 5 minutes. That is not how you prove non-termination.\nIf you observe the program terminating within a certain amount of time, then you can conclude that it does, indeed, terminate. However, if you don't observe it terminating within a certain amount of time, then you can say precisely nothing about whether it terminates or not. It may terminate if you wait a little bit longer, it may terminate if you wait a lot longer, it may even theoretically terminate but take longer than the heat death of the universe.\nIn your specific case, the algorithm is perfectly correct, and it always terminates. It is simply not a very efficient algorithm: for computing ```\nfib(n)```\n, ```\nfib```\n gets called fib(n) times, because you compute the same numbers over and over and over and over again.\nIf we assume that you can execute ```\nfib```\n once per clock cycle (which is an optimistic assumption since a single call to ```\nfib```\n performs one condition, two subtractions, one addition, and two calls to ```\nfib```\n in most cases, and a single addition may already take multiple clock cycles depending on the CPU), and we further assume that you have a 100 core CPU and your code is actually executed in parallel, and you have 100 CPUs, and each CPU is clocked at 100 GHz, and you have a cluster of 100 computers, then it will still take you about an hour.\nUnder some more realistic assumptions, the time it takes your program to finish is more on the order of tens of thousands of years.\nSince your code is not parallelized, in order for your code to finish in 5 minutes on a more realistic 4 GHz CPU, it would need to execute ```\nfib```\n almost 300 million times per clock cycle.\nIt often helps to do some very rough guesstimates of the expected performance of your code. As you can see, you don't need to be an expert in Java or JVM or compilers or optimization or computer organization or CPU design or performance engineering. You don't need to know what, exactly, your code gets compiled down to. You don't need to know how many clock cycles an integer ```\nADD```\n takes. Because even when you make some totally over-the-top ridiculous assumptions, you can still easily see that your code cannot possibly finish in minutes or even hours.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to implement Fibonacci Sequence in Python with Scikit-Learn?\r\n                \r\nI am trying to implement the Fibonacci Sequence in Python with Machine Learning. I want my program to predict the next 5 digits after the given input. Such as, if I pass ```\n[0,1,1]```\n, it will predict and return ```\n[2,3,5,8,13]```\n. However, I can't find a way to do this. my program can currently predict the next digit only. Yes, I could hard-code it, updating the array with the new outputs, but I don't want to do that. \nMy code:\n\n```\n#! /usr/bin/python3\nfrom sklearn import svm\nfrom sklearn.linear_model import LinearRegression\n\nfeatures = [\n [0,1,1],\n [2,3,5],\n [8,13,21],\n [34,55,89],\n\n ]\nlabels = [2,8,34,144]\n\nclf = LinearRegression()\nclf.fit(features, labels)\ntest = [[144, 233, 377]]\nprint(clf.predict(test))\n```\n\n\nAny help?\n    ", "Answer": "\r\nIf you want multiple outputs from your model, then you have to train it in such way. Then this becomes a multi-output problem, where you give 3 features and want to predict 5 outputs. \n\nLook at my answer here for some description about this.\n\nCurrently you are training it to predict a single value. So the model will always predict single value. Train the model by feeding multiple values in output. \n\nSomething like this:\n\n```\n# Three features per row\nfeatures = [[0,   1,  1],\n            [2,   3,  5],\n            [8,  13, 21],\n            [34, 55, 89]]\n\n# This changed.\n# Now a single label consists of a list of output values to be predicted\n# 5 outputs per row\nlabels = [[2,     3,   5,   8,  13], \n          [8,    13,  21,  34,  55], \n          [34,   55,  89, 144, 233], \n          [144, 233, 377, 610, 987]]\n\nclf = LinearRegression()\nclf.fit(features, labels)\ntest = [[144, 233, 377]]\nprint(clf.predict(test))\n\n# Output\n# array([[ 610.,  987., 1597., 2584., 4181.]])\n```\n\n\nBut note that as I mentioned in my linked answer, all scikit-learn estimators are not capable of predicting multiple outputs.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Need help cleaning up fibonacci sequence using C++ please\r\n                \r\nI'm still very new to C++ still and decided to make a fibonacci sequence. It worked (Woo!) but it doesn't work as well as I would like it to.\n\nwhat I mean by that is say for example I told my program to count the first 10 terms of the sequence I will get \n\n\"0, 1, 1\" and then I have to press enter for each additional number until it hits ten in which case the program returns 0 and ends.\n\nHow do I get the program to display all the numbers I want to without hitting enter for each additional one?\n\nHere is my script:\n\n```\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int FibNum;\n    cout << \"How many numbers of the Fibonacci Sequence would you like to see? \\n\\n\";\n    cin>> FibNum;\n    cin.ignore();\n    int a = 0;\n    int b = 1;\n    int c = 2;\n    cout << \"Fibonacci Sequence up to \" << FibNum << \" terms.\\n\\n\";\n    cout << a << \"\\n\" << b << \"\\n\";\n\n    for (int c = 2; c < FibNum; c++) {\n        int d = a + b;\n        cout << d;\n        cin.ignore();\n        a = b;\n        b = d;\n    }\n}\n```\n\n\nThanks in advance for any help! \n\nP.s. Also if you notice anything terrible I'm doing please feel free to correct me, I'm very aware I'm probably doing a lot wrong, I'm just trying to learn. :]\n    ", "Answer": "\r\nA few things:\n\n1) Remove ```\nint c = 2;```\n as you're re-defining ```\nc```\n inside the ```\nfor```\n loop.\n\n2) Drop the line ```\ncin.ignore();```\n: in your ```\nfor```\n loop: that will fix your \"enter\" problem; that line waits for some input then ignores it.\n\n3) Put some white space in your output: e.g. ```\ncout << d << ' '```\n so your numbers are separated.\n\n4) [Acknowledge vincent_zhang] Consider moving to ```\nuint64_t```\n as your data type for ```\na```\n, ```\nb```\n, and ```\nd```\n. This is a standard type in C++11. It's a 64 bit unsigned integer type; adequate for a large number of terms.\n\nand a small thing, bordering on personal opinion,\n\n5) Use ```\n++c```\n instead of ```\nc++```\n as the former will never run slower as, conceptually at least, post-increment has to take a copy of the original value.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why does the \"Double\" data type mess up my Fibonacci sequence?\r\n                \r\nI am trying to write a program which gives me the index of the first 1000-digit number in the Fibonacci sequence. I have set the data type as \"Double\" because I need to store the long numbers, however the output I get isn't right?\n\nI have tried setting the \"num\" data type as \"integer\", \"long\" and even \"int64\", but all these just give me an overflow error after about 2 seconds. \n\n```\nDim num, prev, temp, index As Double\nSub Main()\n    num = 1\n    prev = 1\n    temp = 1\n    index = 1\n    While Len(num) < 1000\n        Console.WriteLine(num)\n        temp = num\n        num += prev\n        prev = temp\n        index += 1\n    End While\nConsole.WriteLine(index) \nConsole.ReadLine()\nEnd Sub\n```\n\n\nI would expect the program to output the Fibonacci sequence until it finds the first 1000-digit number, and then it will output the index of it. However, I just get an output of loads of decimal numbers (to about 20 decimal points) and then it outputs 8. Forever.\n\nI am truly stumped. Any ideas?\n    ", "Answer": "\r\nThe precision of a ```\ndouble```\n data type does not allow you to store so many digits.\n\nIf you use ```\nBigInteger```\n you can store as many digits as you can, as the data type grows its storage according to your needs.\n\nAdditionally, as suggested by the comments, a quick and dirty way to stop after 1000 digits is to have the number converted to string and check its length. This way you are not using mathematical operations which would result in an overflow.\n\nYour code should look like the following:\n\n```\n   Dim num, prev, temp, index As BigInteger\n   Sub Main()\n       num = 1\n       prev = 1\n       temp = 1\n       index = 1\n       While BigInteger.Log10(num) <= 999\n           Console.WriteLine(num)\n           temp = num\n           num += prev\n           prev = temp\n           index += 1\n       End While\n       Console.WriteLine(index) \n       Console.ReadLine()\n   End Sub\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How many ways are there to describe the Fibonacci sequence in Perl 6?\r\n                \r\nI've been looking at the various ways of constructing lazy lists in Perl 6 and I would like to collect all of the concise ways of describing the Fibonacci sequence.\n\nI will start this off with the three from masak's journal:\n\n```\nmy @fibs := (0, 1, -> $a, $b { $a + $b } ... *);\n\nmy @fibs := (0, 1, { $^a + $^b } ... *);  \n\nmy @fibs := (0, 1, *+* ... *);\n```\n\n\nI was thinking something like this would also work, but I think I have the syntax wrong:\n\n```\nmy @fibs := (0, 1, (@fibs Z+ @fibs[1..*]));\n```\n\n\nSomething there is eager (the slice?) and causes Rakudo to enter an infinite loop.  It's a translation of the Haskell definition:\n\n```\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n```\n\n\nUpdate:\n\nSeems like the problem with the ```\nzipWith```\n example is the ```\n@fibs[1..*]```\n slice.  if ```\ntail```\n is defined as ```\nsub tail (@x) {my $i = 1; {@x[$i++]}...*}```\n then it works properly.  I would be interested to know why the slice isn't lazy from anyone familiar with Rakudo's internals.\n\nAnother nice one is:\n\n```\nmy @fibs := (0, [\\+] 1, @fibs);\n```\n\n    ", "Answer": "\r\nThe shortest seems to be\n\n```\nmy @fibs := ^2,*+*...*;\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How can I code Fibonacci sequences that involves two inputs, one determines the rule and the other determines the number of numbers produced?\r\n                \r\nI have a new question regarding a Fibonacci sequence that is kinda unique. It involves two input M and N and looks like this:\n\nExample :\n\n```\n2-Fibonacci sequence: {1, 1, 2, 3, 5, 8, 13, ...} \n3-Fibonacci sequence: {1, 1, 2, 4, 7, 13, 24, ...}\n```\n\n\nI need to code a Python function that can print out the first M elements of an N-Fibonacci sequence.\n\nFor example:\n\n```\nInput → N=3; M=5 Output →1 1 2 4 7\nInput → N=2; M=7 Output →1 1 2 3 5 8 13\n```\n\n\nI would really appreciate any help\n    ", "Answer": "\r\n```\nn = int(input(\"sequence: \"))\nm = int(input(\"amount of numbers: \"))\nnumbers = [1, 1]\nfor i in range(n-2):\n    numbers.append(sum(numbers))\nfor num in numbers:\n    print(num)\nfor i in range(m-len(numbers)):\n    numbers.append(sum(numbers))\n    print(numbers[-1])\n    numbers.pop(0)\n```\n\n\nIf i understood you correctly this is what you are looking for.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence using For Loop - Don't understand the loop\r\n                \r\nVery new to python and I am trying to understand how I am getting the correct answer\nWrite the code that:\n\nCalculates and prints the first 50 terms of the fibonacci sequence.\nPrint each term and number as follows:\n\n```\nterm: 0 / number: 0\nterm: 1 / number: 1\nterm: 2 / number: 1\nterm: 3 / number: 2\nterm: 4 / number: 3\nterm: 5 / number: 5\n```\n\nI got the right answer but how does the \"else\" part work?\n```\nc = a + b\nprint(f'term: {term} / number: {c}')\na = b\nb = c\n```\n\nCan someone explain to me exactly how the variable above changes each time it loops? I don't understand how c = 1 + 1 which prints c = 2 but how does it print c = 3 afterwards?\n```\na = 1\nb = 1\nfor term in range (50):\n    if term <= 1:\n        print(f'term: {term} / number: {term}')\n    elif term == 2:\n        print(f'term: {term} / number: 1')\n    else:\n        c = a + b\n        print(f'term: {term} / number: {c}')\n        a = b\n        b = c\n```\n\n    ", "Answer": "\r\nAs you noted, the first time we proceed through the else part, we have the following assignment, we apply the following assignments:\n```\nc = a + b # <-- (1) + (1) = 2\na = b     # <-- (1)\nb = c     # <-- (2)\n```\n\nSo after the first traversal through the else portion, b is the most recent fibonacci number (in this case 2) and a is the one before.  The next time, we do the following.\n```\nc = a + b # <-- (1) + (2) = 3\na = b     # <-- (2)\nb = c     # <-- (3)\n```\n\nWith this, b has been updated to become the next Fibonacci number, and a is updated to become 2, which was the most recent Fibonacci number but is now the one before.\nIn this fashion, c is always the most recent Fibonacci number, and this value is assigned to b for use in the next loop, and that value of b is eventually assigned to a.\n\nIncidentally, you can avoid the logic of the if/elif/else block if you refactor your code into any of the following:\n```\na = 1\nb = 1\nprint('term 0 / number: 0')\nprint('term 1 / number: 1')\nprint('term 2 / number: 1')\n\nfor term in range (3,50):\n    c = a + b\n    print(f'term: {term} / number: {c}')\n    a = b\n    b = c\n```\n\nAlternatively,\n```\na = 0\nb = 1\nfor term in range (50):\n    print(f'term: {term} / number: {a}')\n    c = a + b\n    a = b\n    b = c\n```\n\nThe following also works and removes the variable c:\n```\na = 0\nb = 1\nfor term in range (50):\n    print(f'term: {term} / number: {a}')\n    (a, b) = (b, a+b)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python : Fibonacci sequence using range(x,y,n)\r\n                \r\nI was interested in finding a way to make a variable that gets a value and store it in another variable then getting a new value.\nA close practical example is the Fibonacci sequence.\nI reasonably searched hard through available python code for this sequence.\nThere were tons, most often too cryptic for my basic grasp.\nI came up with this one. Simple and should do the job :\n```\na = 1  \nb = 0  \nprint (b)\nprint(a)\nfor i in range(0,100):  \n c = b  \n b = a  \n a = c + b  \n print(a)\n```\n\nIn the end, the loop should print the values passing through the variable a, as in :\n0,1,1,2,3,5,8,13,21,34,55,89\nBut that freakin i keeps going all the way to 100^10.\nAs in the final output for that code is :\n0,1,2,3,5,8,13,21,34,55,89,144,233,377, ..., 573147844013817084101\nWould someone explain what is happening ?\n    ", "Answer": "\r\nYou are running through the lines \n\n```\n c = b  \n b = a  \n a = c + b  \n print(a) \n```\n\n\n100 times. So you get the first 100 fibonacci numbers.\n\nIf you want to print fibonacci numbers up to 100, change the for loop to a while loop as such\n\n```\nwhile (a < 100):\n     c = b  \n     b = a  \n     a = c + b  \n     print(a) \n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generate Fibonacci Sequence in Compile-Time using generics [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIn C++ with template metaprogramming you can calculate the fibonacci sequence in compile-time easily in this way.\n```\ntemplate<int  N>\nconstexpr int fibonacci() {return fibonacci<N-1>() + fibonacci<N-2>(); }\ntemplate<>\nconstexpr int fibonacci<1>() { return 1; }\ntemplate<>\nconstexpr int fibonacci<0>() { return 0; }\n```\n\nBut in rust you cant just pass a constant through a generic as far as I know, also I know that sometimes rust optimizes some funcions to just constants in assmebly code. Example: https://rosettacode.org/wiki/Compile-time_calculation#Rust\nBut the conventional recursive approach of the problem is not optimized to a constant.\n```\nfn fibo(n: i32) -> i32 {\n    match n {\n        0 => 0,\n        1 => 1,\n        n => fibo(n - 1) + fibo(n - 2),\n    }\n}\n\n// Call it with\nfibo(45); // It takes around 5 secs, calculated at runtime\n```\n\nOk, to this point I can undestand that just the compiler does not know how to optimize this, but I found a way to make this calculated at compile time using Iterators!\n```\nstruct Fibo(u32, u32);\n\nimpl Iterator for Fibo {\n    type Item = u32;\n    fn next(&mut self) -> Option<Self::Item> {\n        *self = Fibo(self.1, self.1 + self.0);\n        Some(self.0)\n    }\n}\n\nfn fibo() -> Fibo {\n    Fibo(0, 1)\n}\n\n// Call it with\nfibo().take(45).collect::<Vec<_>>()[44]; // This gets the 45th element calculated at compile-time, instantly\n```\n\nAt this point I just want to know why this happens.\n    ", "Answer": "\r\nAlgorithmic Complexity\nThe naive way of computing the Fibonacci sequence has exponential complexity\n```\nfn fibo(n: i32) -> i32 {\n    match n {\n        0 => 0,\n        1 => 1,\n        n => fibo(n - 1) + fibo(n - 2),\n    }\n}\n```\n\nYou can visualize it like:\n\n```\nfibo(0)```\n: 1 call.\n```\nfibo(1)```\n: 1 call.\n```\nfibo(2)```\n: 3 calls -- ```\nfibo(2)```\n, ```\nfibo(1)```\n, ```\nfibo(0)```\n.\n```\nfibo(3)```\n: 5 calls -- ```\nfibo(3)```\n, ```\nfibo(2)```\n (which is worth 3), ```\nfibo(1)```\n.\n```\nfibo(4)```\n: 9 calls -- ```\nfibo(4)```\n, ```\nfibo(3)```\n (worth 5) and ```\nfibo(2)```\n (worth 3).\n\nThe iterator version, however, is completely different. Rewritten as a function it boils down to:\n```\nfn fibo(n: i32) -> i32 {\n    fn rec(i: i32, current: i32, next: i32) -> i32 {\n        if i == 0 { current } else { rec(i - 1, next, current + next) }\n    }\n\n    rec(n, 0, 1)\n}\n```\n\nWhich executes in exactly ```\nn + 1```\n steps... providing ```\nn >= 0```\n.\nBut in C++ it works!\nC++ compilers tend to use memoization for both template instantiations and constexpr evaluations. They do not have to, this is strictly an implementation detail, but they do for efficiency reasons.\nIn this instance, a memoized version of ```\nfibo```\n turns exponential complexity into linear complexity, which is much easier to compute.\nDoing it in Rust!\nIt's possible to compute fibonacci in Rust at compile-time with the current beta, which stabilizes branches in ```\nconst```\n functions.\nSee the playground:\n```\nconst fn fibo(n: i32) -> i32 {\n    const fn rec(i: i32, current: i32, next: i32) -> i32 {\n        if i == 0 { current } else { rec(i - 1, next, current + next) }\n    }\n\n    rec(n, 0, 1)\n}\n\nfn main() {\n    const RESULT: usize = fibo(9) as usize;\n\n    let array: [i32; RESULT] = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n        0, 1\n    ];\n    \n    println!(\"{}\", array[0]);\n}\n```\n\nThere may be a trick to express the computation at compile-time without a branch, allowing to compute ```\nfibo```\n at compile-time on stable, however I am not sure rustc wouldn't perform the recursive call regardless.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursive ConcurrentHashMap.computeIfAbsent() call never terminates. Bug or \"feature\"?\r\n                \r\nSome time ago, I've blogged about a Java 8 functional way of calculating fibonacci numbers recursively, with a ```\nConcurrentHashMap```\n cache and the new, useful ```\ncomputeIfAbsent()```\n method:\n\n```\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class Test {\n    static Map<Integer, Integer> cache = new ConcurrentHashMap<>();\n\n    public static void main(String[] args) {\n        System.out.println(\n            \"f(\" + 8 + \") = \" + fibonacci(8));\n    }\n\n    static int fibonacci(int i) {\n        if (i == 0)\n            return i;\n\n        if (i == 1)\n            return 1;\n\n        return cache.computeIfAbsent(i, (key) -> {\n            System.out.println(\n                \"Slow calculation of \" + key);\n\n            return fibonacci(i - 2) + fibonacci(i - 1);\n        });\n    }\n}\n```\n\n\nI chose ```\nConcurrentHashMap```\n because I was thinking of making this example even more sophisticated by introducing parallelism (which I didn't in the end).\n\nNow, let's increase the number from ```\n8```\n to ```\n25```\n and observe what happens:\n\n```\n        System.out.println(\n            \"f(\" + 25 + \") = \" + fibonacci(25));\n```\n\n\nThe program never halts. Inside the method, there's a loop that just runs forever:\n\n```\nfor (Node<K,V>[] tab = table;;) {\n    // ...\n}\n```\n\n\nI'm using:\n\n```\nC:\\Users\\Lukas>java -version\njava version \"1.8.0_40-ea\"\nJava(TM) SE Runtime Environment (build 1.8.0_40-ea-b23)\nJava HotSpot(TM) 64-Bit Server VM (build 25.40-b25, mixed mode)\n```\n\n\nMatthias, a reader of that blog post also confirmed the issue (he actually found it).\n\nThis is weird. I would have expected any of the following two:\n\n\nIt works\nIt throws a ```\nConcurrentModificationException```\n\n\n\nBut just never halting? That seems dangerous. Is it a bug? Or did I misunderstand some contract?\n    ", "Answer": "\r\nThis is of course a \"feature\". The ```\nConcurrentHashMap.computeIfAbsent()```\n Javadoc reads:\n\n\n  If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.\n\n\nThe \"must not\" wording is a clear contract, which my algorithm violated, although not for the same concurrency reasons.\n\nWhat's still interesting is that there is no ```\nConcurrentModificationException```\n. Instead, the program just never halts - which still is a rather dangerous bug in my opinion (i.e. infinite loops. or: anything that can possibly go wrong, does).\n\nNote:\n\nThe ```\nHashMap.computeIfAbsent()```\n or ```\nMap.computeIfAbsent()```\n Javadoc don't forbid such recursive computation, which is of course ridiculous as the type of the cache is ```\nMap<Integer, Integer>```\n, not ```\nConcurrentHashMap<Integer, Integer>```\n. It is very dangerous for subtypes to drastically re-define super type contracts (```\nSet```\n vs. ```\nSortedSet```\n is greeting). It should thus be forbidden also in super types, to perform such recursion.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence/number dynamic programming\r\n                \r\nI'm trying to improve my programming logic skills and I was watching one of the videos on how to approach Fibonacci numbers. \n\nAfter looking at the pseudo code at ```\n6:34```\n I wrote this:\n\n```\nIn [14]: def my_fib(x, memo=dict()):\n    ...:     if memo.get(x):\n    ...:         return memo[x]\n    ...:     if x == 1 or x == 2:\n    ...:         result = 1\n    ...:     else:\n    ...:         result = my_fib(x - 1, memo) + my_fib(x -2, memo)\n    ...:     memo[x] = result\n    ...:     return result\n```\n\n\nWhich works great however when I watched the video to the end when the guy reviled his python code, I discovered that it was slightly different to mine.\n\nCS Dojo code:\n\n```\nIn [68]: def fib_dyn_2(x, memo):     \n    ...:     if memo[x] is not None:\n    ...:         return memo[x]\n    ...:     if x == 1 or x == 2:\n    ...:         result = 1\n    ...:     else:\n    ...:         result = fib_dyn_2(x-1, memo) + fib_dyn_2(x-2, memo)\n    ...:     memo[x] = result\n    ...:     return result\n    ...: \n    ...: def fib_memo(x):\n    ...:     memo = [None] * (x + 1)\n    ...:     return fib_dyn_2(x, memo)\n```\n\n\nThere is \"slight\" difference I use dictionary for caching he uses list.\n\nWhat got me is that my code appears to be a little bit faster. When getting to numbers in the sequence ```\nX >= 100```\n and as well when running the same number is the sequence more than once.\n\ni.e. My code:\n\n```\nIn [4]: %time my_fib(100)\nCPU times: user 70 µs, sys: 44 µs, total: 114 µs\nWall time: 92 µs\nOut[4]: 354224848179261915075L\n```\n\n\nCS Dojo code:\n\n```\nIn [5]: %time fib_memo(100)\nCPU times: user 99 µs, sys: 128 µs, total: 227 µs\nWall time: 187 µs\nOut[5]: 354224848179261915075L\n```\n\n\nQuestion is which one is \"better\" or more desired as an answer?\n    ", "Answer": "\r\nWhile memoized version of Fibonacci numbers calculation is much better than naive, recursive approach, I encourage you to check the solution based on Matrix Form of Fibonacci numbers:\n\nhttps://stackoverflow.com/a/23462371/1570854\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "(Java) Trying to use an ArrayList to create multiples of a Fibonacci Sequence and failing\r\n                \r\nI was trying out a programming challenge I found, you can find it here if you want to know exactly what the requirements are, but what i'm basically trying to do is to get the lowest possible multiple of a Fibonacci Sequence that contains a given number. So input 13 would output [0, 1, 1, 2, 3, 5, 8, 13]. Input 6 would output [0, 2, 2, 4, 6]. \n\nMy code works fine for any number in the regular Fibonacci Sequence but for any multiple it just outputs, for exmple if the input is 16, [0, 16] and I can't quite figure out why. Any help would be massively appreciated.\n\n```\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class FibonacciMultiples{\n    public static void main(String args[]){\n\n        int target;\n        ArrayList<Integer> x = new ArrayList<Integer>();\n        x.add(0);\n\n\n        Scanner input;\n        input = new Scanner(System.in);\n\n        System.out.println(\"Please enter target: \");\n        target = input.nextInt();\n\n        int i = 0;\n        int j = 1;\n        int k = 1;\n\n        while(x.get(i) != target){\n            x.add((j*k) + x.get(i));\n            i++;\n            j = x.get(i-1);\n\n            if(x.get(i) > target){\n                x.clear();\n                x.add(0);\n                i=0;\n                j=1;\n                k++;\n            }\n        };\n\n        System.out.println(x);\n\n\n    }\n}\n```\n\n    ", "Answer": "\r\nThe problem is here :\n\n```\nj = x.get(i-1);\n```\n\n\nYou take the ```\nj```\n for the next iteration from the list, which means it's already multiplied by ```\nk```\n.\n\nThen you multiply it again by k here :\n\n```\nx.add((j*k) + x.get(i));\n```\n\n\nOne way to fix it is change \n\n```\nj = x.get(i-1);\n```\n\n\nto\n\n```\nj = x.get(i-1)/k;\n```\n\n\nEDIT :\n\nA much more elegant solution with no multiplications or divisions :\n\n```\n    while(x.get(i) != target){\n        x.add(j + x.get(i));\n        i++;\n        j = x.get(i-1);\n\n        if(x.get(i) > target){\n            x.clear();\n            x.add(0);\n            i=0;\n            j=k; // this is the key\n            k++;\n        }\n    };\n```\n\n\nNow the first elements in the sequence are initialized to 0 and k, which means each element will be k times larger than the corresponding element in the original sequence.\n\nOutput for 16 :\n\n```\n[0, 2, 2, 4, 6, 10, 16]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Solving an Inhomogeneous Recurrence Relation for Fibonacci Sequence\r\n                \r\nI am trying to solve a recurrence relation for the Fibonacci Sequence, but the problem is that it is not homogeneous.\nThe recurrence relation is as follows:\nF(n) = F(n -1) + F(n -2) + Θ(n) for n > 1, and Θ(n) = c1n + c2 , where c1, c2 > 0\nInitial conditions: F(0) = 0, F(1) = 1\nI've tried to solve it by treating it as a homogeneous linear second-ordered recurrence with constant coefficients, but I'm not sure how to solve it when I have:\nF(n) - F(n - 1) - F(n - 2) = c1n + c2\nInstead of:\nF(n) - F(n - 1) - F(n - 2) = 0\nWhat is the best method for solving this type of recurrence relation?\n    ", "Answer": "\r\nYou can find a lower and upper bound using the following inequalities:\n```\n2F(n-2) + Theta(n) < T(n) < 2F(n-1) + Theta(n)\n```\n\nYou can easily justify that the lower and upper bounds are in ```\nTheta(n 2^n)```\n. Hence, ```\nT(n) = Theta(n 2^n)```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to get the sum of Fibonacci sequence 0 to less than 500\r\n                \r\nThe question goes like this Write a program to find the Fibonacci sequence from 0 to less than a 500. Then display the sum of all the sequences.\nThe sequence goes as follows:\n```\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377\n```\n\nwith a total sum of 986.\nHere is my code:\n```\npublic class Fibonacci {\n    public static void main(String[] args) {\n        int n = 500, t1 = 0, t2 = 1;\n        while (t1 <= n)\n        {\n            System.out.print(t1 + \" , \");\n            int sum = t1 + t2;\n            t1 = t2;\n            t2 = sum;\n            sum = t1 + t2;\n            }\n             System.out.println(\"\");System.out.println(\"Sum: \"+(t2-1));\n        }\n    }\n```\n\nTo get a total sum of 986 what confuses me is I do get 987 if I haven't deducted 1.\n    ", "Answer": "\r\nyou should create a new variable that holds your sum which initially starts at 0, your code is summing using t2 which is declared as 1, that's why you are having a +1 in your total, this code should work fine:\n```\n public static void main(String []args){\n\n int n = 500, t1 = 0, t2 = 1;\n int total=0; \n \n    while (t1 <= n)\n    {\n        total+=t1;\n        System.out.print(t1 + \" , \");\n        int sum = t1 + t2;\n        t1 = t2;\n        t2 = sum;\n        sum = t1 + t2;\n     }\n        \n     System.out.println(\"\");System.out.println(\"Sum: \"+(total));\n }\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why does this Fibonacci code only allow 8 sequences?\r\n                \r\nI just coded the Fibonacci sequence and this code has a limitation that I can't enter more than 8 sequences. How can I debug this?\n```\n#include <stdio.h>\n\nvoid Fibonacci(int N);\n\nint main(){\n    int N;\n    printf(\"Enter the max term of Fibonacci sequence : \");\n    scanf(\"%d\", &N);\n    Fibonacci(N);\n}\nvoid Fibonacci(int N){\n    int fib0=0, fib1=1, fib;\n    printf(\"%d\", fib1);\n    while(fib<=N){\n        fib=fib0+fib1;\n        fib0=fib1;\n        fib1=fib;\n        printf(\"\\t%d\",fib1);\n    }\n}\n```\n\n    ", "Answer": "\r\nYou have incorrect loop in your code. Just replace:\n```\nwhile(fib<=N)\n```\n\nwith:\n```\nfor (int i=0; i< N; i++)\n```\n\nand everything works as expected.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence ,binary search\r\n                \r\nI am trying to solve the following problem:\n\nF is an infinite sequence of integers that satisfies to Fibonacci condition F(i + 2) = F(i + 1) + F(i) for any integer i. Write a program, which calculates the value of F(n) for the given values of F(i) and F(j).\n\nInput:\nThe input contains five integers in the following order: i, F(i), j, F(j), n.\n−1000 ≤ i, j, n ≤ 1000, i ≠ j,\n−2·10^9 ≤ F(k) ≤ 2·10^9 (k = min(i, j, n), …, max(i, j, n)).\n\nOutput:\nThe output consists of a single integer, which is the value of F(n).\n\nI am trying to solve this problem by finding F(min(i,j)+1) then using that two neighbors to find F(n). I was told that this can be done by implementing binary search on the interval (-2*10^9,2*10^9) ,but I don't understand how to use binary search here.Could give me a hint or explain the algorithm in a short manner.\n    ", "Answer": "\r\nOne way I can think of is like that: lets say i < j and F(i) < F(j) so we want to find F(i+1).\nWe know that F(i) < F(i+1) < F(j) so we can do binary search between [F(i),F(j)] - each time we guess F(i+1) and checks if it fits (no easy way around it I think) until you get the correct value.\n\nComplexity - each iteration can take 2000 steps (worst case), and at worst it's going to take be log(4*10^9) iterations which is about 32 so it seems reasonable.  \n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "how to fix python fibonacci sequence script?\r\n                \r\nMy assignment is to create a function that produces 3 lists of the numbers in the fibonacci sequence starting at 0. Here is my code so far.\n\n```\ndef fibList(n):\n    a = 0; b = 1; fibList = []\n    if n <= 0:\n        return\n    elif n == 1:\n        fibList = [a]\n    elif n == 2:\n        fibList = [a,b]\n    else:\n        for i in range(0,n):\n            a, b = b, a + b\n            fibList.append(b)\n\nreturn fibList\n\n\ndef main():\n    print (fibList(4))\n    print (fibList(10))\n    print (fibList(-4))\n```\n\n\nwhat i want my output to look like is  [0,1,1,2] for 4, [0,1,1,2,3,5,8,13,21,34,55] for 10, and [] for -4\n\nMy issue begins with fibList(4) currently giving an output of [1, 2, 3, 5] and fibList(10) gives an output of [1, 2, 3, 5, 8, 13, 21, 34, 55, 89] and for -4 I get \"None\" instead of a [].\nIf I type in fibList(1) I get [0] and for fibList(2) I get [0, 1], but when i test fibList(3) the first 0 and 1 are lost, giving me [1,2,3]\nHow would I go about making it so any number above 3 starts with [0, 1, 1, 2...]? My main issue is getting the 0 and 1 to be the first two numbers in the sequence and getting fibList(-4) to produce a [].\nany help or tips would be greatly appreciated :-)\n    ", "Answer": "\r\nAll that you are missing is to add an empty list in the case of less than or equal to zero, and recurse correctly over your range of Fibonacci numbers greater than 2. Making those small changes like so: \n\n```\ndef fibList(n):\n\n        if n <= 0:\n                fibnums = []\n        elif n == 1:\n                fibnums = [0]\n        elif n >= 2:\n                fibnums = [0, 1]\n                for i in range(2,n):\n                        fibnums.append(fibnums[i-1]+fibnums[i-2])\n        return fibnums \n```\n\n\nNote that this recursive method can get quite slow for large numbers, if that is of concern to you with your program. Best of luck!\n\nWith these changes, \n\n```\nprint (fibList(4)) => [0, 1, 1, 2]\nprint (fibList(10)) => [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nprint (fibList(-4)) => []\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to make a Fibonacci sequence with all the values ​below the input?\r\n                \r\nI am trying to make a Fibonacci sequence where all the values ​​are below ```\nN ```\nwhere ```\nN```\n is the input parameter. so I tried to do this but an error like this appears\n```\nTypeError: n1.slice is not a functionTypeError: n1.slice is not a function\n```\n\nthis is so far I got:\n```\nfunction fib(N){\n    let n1 = 1, n2 = 1, nextTerm;\n    for (let i= 1; i < N; i++) {\n            console.log(n1.slice(-1).pop())\n            nextTerm = n1 + n2;\n            n1 = n2;\n            n2 = nextTerm;\n        }\n  }\nfib(7)\n```\n\nmy expectations when N = 7\n```\n1,1,2,3,5\n```\n\nand when N = 13\n```\n1,1,2,3,5,8\n```\n\nHope you can help me to solve this\n    ", "Answer": "\r\nYou need to put ```\nnextTerm```\n in the condition of for loop instead of ```\ni```\n.\n\r\n\r\n```\nfunction fib(N) {\n    let n1 = 1,\n        n2 = 1,\n        nextTerm = 0;\n    console.log(n1)\n    for (let i = 1; nextTerm < N; i++) {\n        console.log(n2)\n        nextTerm = n1 + n2;\n        n1 = n2;\n        n2 = nextTerm;\n    }\n}\nfib(7);```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Java Fibonacci sequence\r\n                \r\nWrite a program to calculate the first 10 Fibonacci numbers and store the results in a one-dimensional array. In a second array calculate and store the average values of the adjacent numbers in the series. The first array should contain integer values and the second floating point values. Output the contents of both arrays in a neat format\n\n```\n public static void main(String[] args) {\n     //number of elements to generate in a series\n     int limit = 10;\n\n     long[] series = new long[limit];\n\n     //create first 2 series elements\n     series[0] = 1;\n     series[1] = 1;\n\n     //create the Fibonacci series and store it in an array\n     for(int i=2; i < limit; i++){\n         series[i] = series[i-1] + series[i-2];\n     }\n\n     //print the Fibonacci series numbers\n     System.out.println(\"Fibonacci Series upto \" + limit);\n     for (int i = 0; i < limit; i++) {\n         System.out.print(series[i] + \" \");\n     }\n}\n```\n\n\nOkay so the first part is working fine but now to create an array to calculate the average is a bit tricky for me.So far I tried this.\n\n```\nint[] numbers = new int[]{1,1,2,3,5,8,13,21,34,55};\nint sum=0;\nfor (int i = 0; i < numbers.length ; i++) {        \n     sum = (int) (sum + numbers[i]);\n     double average = (double)sum/numbers.length;\n     System.out.println(\"Average value of array elements is : \" + average);\n}\n```\n\n\nBut its not working quite well.Can someone offer me some light on this ? \n    ", "Answer": "\r\nYou should not calculate the average inside the ```\nfor loop```\n. Move your ```\naverage```\n outside of the loop so it calculates once ```\nsum```\n is accurate.\n\n```\n            int[] numbers = new int[]{1,1,2,3,5,8,13,21,34,55};\n            int sum=0;\n            for(int i=0; i < numbers.length ; i++){        \n                 sum = (int) (sum + numbers[i]);\n            }\n            double average = (double)sum/numbers.length;\n            System.out.println(\"Average value of array elements is : \" + average);\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Attempting to implement this recursive Fibonacci sequence gives wrong outputs\r\n                \r\nI am trying to implement Fibonacci sequence in assembly by using recursion. This is my first time of trying to implement recursion in x86 Assembly.\n\nThe code compiles fine but it gives wrong outputs. The output for 1 is 1, output for 2 is 0, output for 3 is 1, output for 4 is 2, output for 5 is 3.\n\nOnly output it gives correct when you plug 5 in. \n\nIs there something wrong with the algorithm?\n\n```\n.DATA\n  n1 DWORD ?\n\n  prompt1 BYTE \"Please enter the first value\", 0\n\n  prompt3 BYTE \"No negative numbers!\",0\n  string BYTE 40 DUP (?)\n  resultLbl BYTE \"The Fib is: \", 0\n  fib BYTE 40 DUP (?), 0\n\n  .CODE\n  _MainProc PROC\n\n    input prompt1, string, 40\n    atod string\n    test eax, eax \n    js signed \n    mov n1, eax\n\n    jmp procName\n    signed:\n    output prompt3, string\n    jmp end1\n\n   procName:\n     mov eax, n1\n     push n1\n     call fib1\n     add esp,4\n\n\n      dtoa fib, eax\n      output resultLbl, fib\n      end1:\n       mov eax, 0\n       ret\n\n  _MainProc ENDP\n\n  Fib1 proc\n    PUSH EBP          ; save previous frame pointer\n    MOV  EBP, ESP     ; set current frame pointer\n\n    MOV  EAX, [EBP+8] ; get argument N\n    CMP  EAX, 1       ; N<=1?\n    JA   Recurse      ; no, compute it recursively\n    MOV  ECX, 1       ; yes, Fib(1)--> 1\n    JMP  exit\n\n    Recurse:\n     DEC  EAX          ; = N-1\n     MOV  EDX, EAX     ; = N-1\n     PUSH EDX          ; save N-1\n     PUSH EAX          ; set argument = N-1\n     CALL Fib1   ; compute Fib(N-1) to ECX\n     POP  EAX          ; pop N-1\n     DEC  EAX          ; = N-2\n     PUSH ECX          ; save Fib(N-1)\n     PUSH EAX          ; set argument = N-2\n     CALL Fib1    ; compute Fib(N-2) to ECX\n     POP  EAX          ; = Fib(N-1)\n     ADD  ECX, EAX     ; = Fib(N-1)+FIB(N-2)\n     exit:\n      MOV  ESP,EBP      ; reset stack to value at function entry \n      POP  EBP          ; restore caller's frame pointer\n      RET \nFib1 endp\n\nEND             \n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why is closed form for fibonacci sequence not used in practice?\r\n                \r\nThere is a closed form for the Fibonacci sequence that can be obtained via generating functions. It is:\nf_n = 1/sqrt(5) (phi^n-\\psi^n)\nFor what the terms mean, see the link above or here.\nHowever, it is discussed here that this closed form isn't really used in practice because it starts producing the wrong answers when n becomes around a hundred and larger.\nBut in the answer here, it seems one of the methods employed is fast matrix exponentiation which can be used to get the nth Fibonacci number very efficiently in O(log(n)) time.\nBut then, the closed form expression involves a bunch of terms that are raised to the nth power. So, you could calculate all those terms with fast exponentiation and get the result efficiently that way. Why would fast exponentiation on a matrix be better than doing it on scalars that show up in the closed-form expression? And besides, looking for how to do fast exponentiation of a matrix efficiently, the accepted answer here suggests we convert to the diagonal form and do it on scalars anyway.\nThe question then is - if fast exponentiation of a matrix is good for calculating the nth Fibonacci number in O(log(n)) time, why isn't the closed form a good way to do it when it involves fast exponentiation on scalars?\n    ", "Answer": "\r\nThe \"closed form\" formula for computing Fibonacci numbers, you need to raise irrational numbers to the power n, which means you have to accept using only approximations (typically, double-precision floating-point arithmetic) and therefore inaccurate results for large numbers.\nOn the contrary, in the \"matrix exponentiation\" formula for computing Fibonacci numbers, the matrix you are raising to the power n is an integer matrix, so you can do integer calculations with no loss of precision using a \"big int\" library to do arithmetic with arbitrarily large integers (or if you use a language like Python, \"big ints\" are the default).\nSo the difference is that you can't do exact arithmetic with irrational numbers but you can with integers.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python3 translating to TI Basic Store function in for loop being weird (Fibonacci's sequence)\r\n                \r\nI just converted the Fibonacci's sequence from python3 to TI Basic but its acting kind of weird when I try to execute the function similar to \"+=\" operator to the iterator variable in python where I use the store function.\nHere is my TI code below:\n```\nInput \"Enter number of terms: \",N\n0→A\n1→B\n0→I\nIf N≤0:Then\nDisp \"Please enter a positive integer\"\nEnd\nIf N=1:Then\nDisp \"Fibonacci sequence upto\",N\nElse:\nDisp \"Fibonacci sequence:\"\nFor(I,0,N-1)\nDisp A\nA+B→C\nB→A\nC→B\nI+1→I\nEnd\nEnd \n```\n\nwhere when I input 3, it gives me an output of:\n```\n0\n1\n```\n\nrather than\n```\n0\n1\n1\n```\n\nThe code works if I either remove or change this line:\n```\nI+1→I\n```\n\nto\n```\nI→I\n```\n\nIs there a reason why this causes the for loop to ignore one iteration instead of starting from this iteration?\nHere is the corresponding python code:\n```\n#Fibonacci Sequence\n\nN = int(input(\"Enter number of terms: \"))\nA= 0\nB = 1\nI = 0\n\nif N <= 0:\n  print(\"Please enter a positive integer\")\nif N == 1:\n  print(\"Fibonacci sequence upto\",N)\nelse:\n  print(\"Fibonacci sequence:\")\n  for I in range(N):\n      print(A)\n      C = A + B\n      A = B\n      B = C\n      I += 1\n```\n\n(I know that the I += 1 is unnecessary but it just made me curious why it doesn't work in the TIBasic language)\nOriginal python fibonacci sequence code:\nhttps://www.programiz.com/python-programming/examples/fibonacci-sequence\n    ", "Answer": "\r\nThe for loop in ti basic iterates i by doing i = i+1.\nThe for loop in python sets i to a value from a sequence generated by range.\nin other words\nthe ti code is more similar to\n\r\n\r\n```\nfor(let i=0; i<n; i++){\n  \n}```\n\r\n\r\n\r\n\nand the python script is more similar to\n\r\n\r\n```\nlet n = [1,2,4,5, ... n]\n\nfor(let ni=0; ni<n.length; ni++){\n  let i=n[ni];\n}```\n\r\n\r\n\r\n\nYou can see how in the python example above, 'i' gets reset to a value from a list each iteration. where as in the ti example 'i' is used to keep track of the iteration state.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Manipulating the Fibonacci sequence\r\n                \r\nConsider the following code that prints out the first 10 Fibonacci numbers.\n\n```\npublic class Fib {\n    public static void main(String args[]) {\n        int f = 0;\n        int g = 1;\n\n        for(int i = 1; i <= 10; i++) {\n            System.out.print(f + \" \");\n            f = f + g;\n            g = f - g;\n        } \n        System.out.println();   \n    }\n}\n```\n\n\nIs there a way to make this code run only when a positive integer is given by the user and display an error message if the integer is negative? I have considered using a little IF statement or do while at the beginning, but am not sure how to implement it with this particular program.  \n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Java:: Why isn't this implementation of Fibonacci sequence with memoization not work?\r\n                \r\nI have a quick question about implementing the Fibonacci sequence using the memoization (DP). I am using a HashTable, but for some reason, the table never seems to contain the elements. I inserted a print statement to print out something whenever a value was read from the hashtable and it seems like this never happens. I feel like its a simple fix, but I don't see it. \n\n```\n  public static int getFib(int n) {\n        HashMap<Integer, Integer> dictionary = new HashMap<Integer, Integer>();\n        if (n <= 2)\n            return 1;\n        else if (dictionary.containsKey(n)) {\n            System.out.println(\"Reading From Table\");\n            return dictionary.get(n);\n        } else {\n            int val = getFib(n - 1) + getFib(n - 2);\n            dictionary.put(n, val);\n            return val;\n        }\n    }\n```\n\n    ", "Answer": "\r\nYou're calling getFib() recursively, and instantiating a new dictionary with each call. Make the dictionary a class-level variable.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence and Time/Space Complexity explanation?\r\n                \r\nI'm a self-taught programmer/boot-camp graduate, and I was just asked to code a function for the Fibonacci sequence yesterday at an interview and realized how much I didn't know when asked about performance differences between:\n\n\nusing a for loop.\nusing recursion.\n\n\nHere's my answer using a loop:\n\n```\ndef fibonacci(n)\n  first_value = 0\n  second_value = 1\n  final_value = nil\n  if n == 0\n    final_value = first_value\n  elsif n == 1\n    final_value = second_value\n  else\n    (n - 1).times do\n      final_value = first_value + second_value\n      first_value = second_value\n      second_value = final_value\n    end\n  end\n  final_value\nend\n```\n\n\nHere was my answer for recursion at the time:\n\n```\ndef fibonacci(n)\n  if n == 0\n    0\n  elsif n ==1\n    1\n  else\n    fibonacci(n-1) + fibonacci(n-2)\n  end\nend\n```\n\n\nSo he mentioned how it took ```\n2^n```\n _____ (fill in the blank) for recursion and only ```\nn```\n _____ for the loop. Then he asked about time/space complexity and I was a little lost.\n\nI haven't picked up a book on time/space complexity yet. Would I learn this stuff in an algorithms book? I recently bought the \"Algorithm Design Manual\" but haven't opened it yet.\n\nWhen he said ```\n2^n```\n something, was he talking about time or space? Could someone explain the time/space complexity theory and differences using those two functions?\n    ", "Answer": "\r\nIt will took ```\n2^n```\n time and ```\nn```\n space. Why? Because on each call it call itself twice and each of the children calls need nearly the same amount of time to complete. As of memory: each call need 1 memory unit. After call all used memory is released. So if you draw a call tree then you will see that height of this tree is linear function of ```\nn```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Algorithm task based on a variation of Fibonacci sequence [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\n\n  Being given parameters C and M, help decrypt a list of encrypted\n  integers. The former parameter is used for generating {a_n} and {s_n}\n  sequences, defined as follows:\n  \n  \n  a_1 = a_2 = 1\n  forall n>=1: a_(n+2) = C * a_(n+1) + a_n\n  forall n: s_n = a_1 + a_2 + a_3 + ... + a_n\n  \n  \n  The ciphertext consists of T natural numbers. Each of them encrypts\n  one result number. In order to restore the original x value, it is\n  necessary to determine the result of the following operation: s_x mod\n  M\n  \n  Input: two natural numbers C and M, T denoting number of tests and T\n  lines consisting of only one x number.\n  \n  1 <= C, M <= 10^18   1 <= T <= 1000   1 <= x <= 10^18\n  \n  Example input:\n  \n  1 10   5   2   3   4   10   1  \n  \n  Example output:\n  \n  2   4   7   3   1\n\n\nIt's a problem that showed up at the Deadline24 algorithmic competition which took placce this morning and for the love of all that's holy, I couldn't think of any way of pruning the calculations so that you don't have to do 10^18 operations in the worst case scenario. \n\nAny brute force approach is immediately cut out because of that, so is a naive recursion approach. We may note that the sequence is a variation on the Fibonacci sequnece but it doesn't help much as the sequences with C != 1 are divergent from the regular Fibonacci sequence and thus we can't apply any of the approximations like Binet's Fibonacci number formula to calculate F_(n+2) - 1 which would normally be the sum of the first n Fibonacci numbers.\n\nI thought of expressing the terms with C only and applying some fast modpow but it falls short both because it's slow (we still have to calculate the coefficient at each term which is a loop for every power in the final sum) and hard to compute (it looks like there is a pattern but it soon becomes tedious and hard to prove how it will progress).\n\nWhat's a good way of solving this for max inputs?\n    ", "Answer": "\r\nWe can use matrix exponentiation to get a logarithmic solution:\n\n```\nf(n) = C*f(n - 1) + f(n - 2)\n\na b       f(n)                    \n     *            = [f(n + 1)   f(n)]\nc d     f(n - 1)                        \n```\n\n\nThis results in:\n\n```\na = C\nb = 1\nc = 1\nd = 0\n```\n\n\nSo you can use this matrix to get the ```\nn```\n-th term of your function. As for the sum, notice that:\n\n```\nf(n)     = Cf(n - 1) + f(n - 2)\nf(n - 1) = Cf(n - 2) + f(n - 3)\n...\nf(3)     = Cf(2)     + f(1)\n=============================== +\ns(n) - 2 = C(s(n - 1) - 1) + s(n - 2)\ns(n) = Cs(n - 1) + s(n - 2) - (C - 2)\n```\n\n\nThis isn't as nice as what you can do for the Fibonacci numbers (expressing the sum in terms of a single Fibonacci number), but it can be solved by exponentiation by squaring using a similar (3 x 3) matrix to the one of the initial recurrence, which you can find using the same method, and with different starting conditions:\n\n```\ns(1) = 1\ns(2) = 2\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "MASM fibonacci sequence based on user input\r\n                \r\nI  was sweating half of a night to make this code and then the other half to make it work. After opening many tabs with threads on different forums regarding MASM, fibonacci, stock, division I thought to get your help.\nLooks like it got stock in infinite loop because it always displays sequence \n    0, 1, \n\nEven when I type 0 it still doesn't jump to the label specified by conditional jump. \n\nI believe that the problem is most likely in displayFib procedure or displayNum\n\n```\npage  55,80\ntitle  Fibonacci                                  [FIB.ASM]\n.model small\n.stack 100h\n\n.data\n\nmsg1 db \"Please enter the number of terms in the fibonacci sequence to display:\",0DH,0AH,\"$\" ;message to user\nmsg2 db \"Displaying Fibonacci sequence\",0DH,0AH,\"$\" ; message to user\nmsg3 db \", \",\"$\"    ; formating - coma\nnum1 dw 0        ;this is a numeric variable\nnum2 dw  0      ; this is a numeric variable\ninput dw  0         ; this is a numeric variable\nfibPrev1 DW 1       ; word numeric value n-1 value\nfibPrev2 DW 0       ; word numeric value n-2 value\nfib DW 0        ; word numeric value\ntemp    DW 0    ; word numeric value\nsaveCount DW 0  ;counter storage\n\n\n.code\nextrn clrscr:proc    \n\n\nmain proc\n        mov   ax,@data       ; set up data segment\n        mov   ds,ax\n\n        call  clrscr            ; clear the screen\n\n    mov   ah,9              ; send message with instructions for user\n    mov   dx,offset msg1\n    int   21h            \n\n        call keyin          ;gets user input\n    SUB AL, 48      ;changes ASCII value into numeric value for further processing\n    mov num1 , AX       ;saves user input to variable num1\n    call keyin          ;gets user input\n    SUB AL, 48      ;changes ASCII value into numeric value for further processing\n    mov num2 , AX       ;saves user input to variable num2, so now we have both digits\n\n    ;multiplying num1 10 times\n\n    MOV  CX, 10\n    repeat1:            ; loop 10 times\n        MOV AX, NUM1    ;copies value of num1 to AX\n        ADD input, AX   ;adds value from AX\n        DEC CX      ;decrements the counter\n        JNZ repeat1 ;loops until counter = 0\n\n    MOV AX, num2        ;adding the value from num2 so if user entered 83, so it was num1=8 num2=3, then we multiplied 8x10=80, so we add 80+3 and we get 83\n    ADD input, AX\n\n    call newLine\n    mov   ah,9              ; send informative message to user regarding displaying the sequence\n    mov   dx,offset msg2\n    int   21h \n    call newLine\n\n    call displayFib\n\n    call newLine\n    mov   ax,4C00h       ; return to DOS\n        int   21h\n\nmain endp\n\n\nnewLine proc            ;procedure displays new line\n    mov dx,0Dh      ;line feed\n    mov ah,2\n    int 21h  \n    mov dx,0Ah      ;carriage return\n    mov ah,2\n    int 21h\n    ret\nnewLine endp\n\n\n\n\nkeyin proc\n    mov ah, 1 ; getting a key from the keyboard \n    int 21h \n    ret\nkeyin endp\n\ndisplayFib proc\n    ;display zero as a 0'th term\n    MOV DX, 30h         ; move value 30 hexadecimal to DX, which represents 0\n    call display\n    MOV AX, input   \n    CMP AX, 0        ;if the input is 0 in hexadecimal ASCII value then jump to finish\n    JE finish_it\n\n    mov   ah,9              ; formating - coma\n    mov   dx,offset msg3\n    int   21h       \n\n    ;display the 1st term\n    MOV DX, 31h         ; move value 31 hexadecimal to DX, which represents 1\n    call display\n    CMP input, 1        ;if the input is 1 in hexadecimal ASCII value then jump to finish\n    JE finish_it\n\n    MOV CX, input       ;intializing counter, knowing that first 2 terms were displayed already\n    SUB CX, 2\n\n    repeat:\n        mov   ah,9              ; formating - coma\n        mov   dx,offset msg3\n        int   21h       \n\n        MOV AX, fibPrev2        ; calculating the n'th term of a sequence    n = (n-1) + (n-2) \n        ADD AX, fibPrev1\n        MOV fib, AX\n        MOV DX, fib\n        MOV saveCount, CX       ;saving the state of the counter as it will be modified in the displayNum\n        call displayNum\n        ;display the n'th term (current term)\n        MOV CX, saveCount       ;restoring state of the counter\n        MOV AX, fibPrev1        ; n-1 in the next round of a loop will be n-2\n        MOV fibPrev2, AX\n        MOV AX, fib         ;n'th term in the next round will be n-1\n        MOV fibPrev1, AX\n        DEC  CX             ;decrementing counter\n        CMP CX, 1\n        JL  repeat          ; loop until counter = 0\n\n    finish_it:\n\n    ret\ndisplayFib endp\n\n\ndisplayNum proc     ;display numbers including these with more than one digit\n\n    MOV AX, fib ;copying fib to temp\n    MOV temp, AX\n    MOV CX,0        ;initializing counter to 0\n    loop1:\n        ;dividng fib by 10 and pushing reminder on the stock\n        INC CX          ;incrementing counter\n        MOV  ax, temp\n        MOV bx, 10\n        SUB dx, dx              ;set dx to zero\n        DIV bx          ;BX will contain integer division result and DX remainder\n        PUSH DX\n        MOV temp, BX        ;temp will hold value of itself integer devided by 10\n        JNZ loop1\n\n    loop2:\n        POP DX\n        ADD DX, 30h\n        call display\n        JNZ loop2       ;loop until all digits on stack are popped and counter =0\n\n    ret\ndisplayNum endp\n\n\ndisplay proc        ; display of a single character\n    mov ah, 6\n    int 21h\n    ret\ndisplay endp\n\n\nend  main\n```\n\n    ", "Answer": "\r\nSO isn't a debugging service, as I said, learn to use a debugger yourself. \nThere are a few problems in your code:\n\n\n```\nAH```\n not being zero after ```\nkeyin```\n\nThe user's input must be 2 digit (doesn't work for 1 digit)\nWhere your comment says ```\nloop until counter = 0```\n you are not doing that. Fix: you need ```\nDEC CX; JNZ loop1```\n.\n```\nBX will contain integer division result```\n - not true, the result is in ```\nAX```\n, no matter that you used ```\nBX```\n for the divisor. Fix: you need to adjust the ```\nMOV temp, BX```\n to ```\nMOV temp, AX```\n.\n```\nJNZ loop1```\n is missing an instruction that sets the flags, as ```\nDIV```\n doesn't. Fix: insert ```\nTEST AX, AX```\n.\nYour ```\nloop2```\n is missing the decrement of the loop variable. Fix: insert ```\nDEC CX```\n.\n\n\nI believe that was all the changes I had to make to get it working.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "error C2106: '=' : left operand must be l-value in Fibonacci sequence by dynamic programming in C++\r\n                \r\nI am trying to write a program for generating Fibonacci sequence by dynamic programming approach as follows.\n\n```\n#include<iostream>\n#include<ctime>\n\nint fib(int index)\n{\n    int memo[] = {0};\n    memo[0] = 0;\n    memo[1] = 1;\n    for(int i = 2; i <= index; i++)\n    {\n        fib(index) = fib(index - 1) + fib(index - 2);   //error comes here\n    }\n    return fib(index);\n}\nint main()\n{   \n    time_t start, end, diff;\n    int index;\n    std::cout << \"Please, enter the index of fibonacci sequence\" << std::endl;\n    std::cin >> index;\n    start = time(NULL);\n    std::cout << \"calculating....\" << std::endl << fib(index) <<std::endl;\n    end = time(NULL);\n    diff = (time_t)difftime(end, start);\n    std::cout << \"Time elapsed: \" << diff << std::endl;\n    return 0;\n}\n```\n\n\nBut, in the line ```\nfib(index) = fib(index - 1) + fib(index - 2);```\n Iam getting error as \n\n```\nerror C2106: '=' : left operand must be l-value\n```\n\n\nSo, please tell me what's wrong I have done in that line. Thanks in advance.\n    ", "Answer": "\r\nYou can't assign to ```\nfib(index)```\n as others pointed out already. There is workaround by returning reference or pointer.\n\nBut the program itself is wrong as it goes into infinite loop. The line \n\n```\nfib(index) = fib(index - 1) + fib(index - 2);  \n```\n\n\nKeeps launching fib(index) if index > 1. The correct way of solving Fibonacci using DP is \n\n```\nint fib(int n)\n{\n  int a = 0, b = 1, c, i;\n  if( n == 0)\n    return a;\n  for (i = 2; i <= n; i++)\n  {\n     c = a + b;\n     a = b;\n     b = c;\n  }\n  return b;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence using iterative process in SICP, cannot completely understand\r\n                \r\nHere is an iterative example of a procedure computing the fibonacci sequence in SICP. The idea is:\n\n\na = fib(n+1) = a+b\nb = fib(n) = a\n\n\n```\n(define (fib n) \n  (fib-iter 1 0 n))\n(define (fib-iter a b count)\n  (if (= count 0)\n      b\n      (fib-iter (+ a b) a (- count 1))))\n```\n\n\nLooking at it deeper, I don't understand why continuing the computation towards fib(n+1) is necessary. I found we could have written.\n\n```\n;; a and b are first and second integers respectively\n;; in the recursive call, b would be replaced by a+b because it is the next number in the sequence\n;; so now a will be replaced by the previous value of b because it is the previous value.\n(define (fib2 n) \n  (fib-iter 1 0 n))\n(define (fib-iter a b count)\n  (if (= count 0)\n      b\n      (fib-iter b (+ a b) (- count 1))))\n```\n\n\nNow, I really think the first example, the one continuing up to n+1 is really redundant. I don't understand why is that necessary. What's wrong with my proposed iterative example?\n    ", "Answer": "\r\nBot procedures produce correct result. However, the first one retains the relationship between ```\na```\n and ```\nb```\n: ```\na```\n is ```\nFib(i+1)```\n and ```\nb```\n is ```\nFib(i)```\n where ```\ni=n-count```\n. The second method uses the first iteration to swap ```\na```\n and ```\nb```\n around, thus introducing one redundant iteration. This can be seen by taking the trace of procedures:\n\n```\n> (define (fib n) \n  (fib-iter 1 0 n))\n\n(define (fib-iter a b count)\n  (if (= count 0)\n      b\n      (fib-iter (+ a b) a (- count 1))))\n> (trace fib-iter)\n> (fib 3)\n>(fib-iter 1 0 3)\n>(fib-iter 1 1 2)\n>(fib-iter 2 1 1)\n>(fib-iter 3 2 0)\n<2\n2\n> (define (fib-iter a b count)\n  (if (= count 0)\n      b\n      (fib-iter b (+ a b) (- count 1))))\n> (trace fib-iter)\n> (fib 3)\n>(fib-iter 1 0 3)\n>(fib-iter 0 1 2)\n>(fib-iter 1 1 1)\n>(fib-iter 1 2 0)\n<2\n2\n```\n\n\nWhat you actually want is something like this:\n\n```\n> (define (fib n)\n  (if (zero? n)\n      0\n      (fib-iter 0 1 (- n 1))))\n\n(define (fib-iter a b count)\n  (if (zero? count)\n      b\n      (fib-iter b (+ a b) (- count 1))))\n\n> (trace fib-iter)\n> (fib 3)\n>(fib-iter 0 1 2)\n>(fib-iter 1 1 1)\n>(fib-iter 1 2 0)\n<2\n2\n```\n\n\nNotice, there is one less iteration. However, I'm doing extra work in procedure ```\nfib```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Writing Fibonacci sequence in Java starting from certain term\r\n                \r\nI am trying to write a Fibonacci sequence generator based on Java. I saw many examples on the Internet for instance:\n\n```\npublic class Fibonacci {\n\n    public static void main(String[] args) {\n        generateFibonacci(20);  // generate the first 20 fibonacci numbers\n    }\n\n    public static void generateFibonacci(long limit) {\n        long first = 0;\n        long second = 1;\n        System.out.print(first+\", \"+second);\n        for(long i=1;i<limit;i++) {\n            long next = first + second;\n            System.out.print(\", \"+next);\n            first = second;\n            second = next;\n        }\n        System.out.println();\n    }\n\n}\n```\n\n\nAnd it works fine. The problem is that not only I want to generate the first 20 numbers, but I also need to specify a starting point. For example:\n\n```\npublic List<Long> generateFibonacci(long startFrom, long numberTerms) {\n\n}\n```\n\n\nDoing:\n\n```\ngenerateFibonacci(5, 10);\n```\n\n\nShould output:\n8l\n13l \n21l \n34l \n55l \n89l \n144l\n233l\n377l\n\nI have tried the following code but it doesnt seem to be performing the desired action:\n\n```\npublic class example {\n    public static void main(String[] args) {\n        generateFibonacci(10, 5); \n    }\n\n    public static void generateFibonacci(long limit, long startPoint) {\n        long first = 0;\n        long second = 1;\n        long endPoint = startPoint + limit;\n        System.out.print(first + \", \" + second);\n        for (long i = 1; i < endPoint; i++) {\n            long next = first + second;\n            if (i > startPoint) {\n                System.out.print(\", \" + next);\n            }\n            ;\n            System.out.print(\", \" + next);\n            first = second;\n            second = next;\n        }\n    }\n}\n```\n\n\nAny ideas on how to achieve this in an efficient way?\n    ", "Answer": "\r\nas you said output must be like this\n\n```\n 8                                                                                                                                                                   \n [13, 21, 34, 55, 89, 144, 233, 377] \n```\n\n\nand you want to return  a list of fibonacci numbers \n\nyou can return a list as you want in this way !    \n\n```\npublic static void main(String[] args) {\n    List<Long> list = generateFibonacci(10, 5);\n    System.out.println(list.size());     \n    System.out.println(Arrays.toString(list.toArray()));     \n}\n\npublic static List<Long>  generateFibonacci(long limit, long startPoint) {\n    List<Long> list = new ArrayList<>();\n\n    long first = 0;\n    long second = 1;\n    long endPoint = startPoint + limit - 1;\n    //System.out.print(first + \", \" + second);\n    if (startPoint==0){\n            list.add(0);\n            list.add(1);\n    }else if (startPoint ==1){\n            list.add(1);\n    }\n    for (long i = 2; i < endPoint; i++) {\n        long next = first + second;\n        if (i > startPoint) {\n            // System.out.println(next);\n            list.add(next);\n        }\n\n        first = second;\n        second = next;\n    }\n\n    return list;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci procedure in Java, sequencing\r\n                \r\nI am currently trying to figure out this question right now in regards to a Fibonacci sequence. It is fairly straight forward but I don't know what i can't get it. Apologize beforehand for my incompetence.\n\nMy current code, I know it's completely wrong, it doesn't even compile.. I'm so lost can someone please explain it to me\n\n```\npublic static void fib(int n)\n{\n    int neW = 1;\n    int next = 1;\n    int old = neW - next;\n    while (neW <= n)\n    {\n        neW = next + old;\n        old = next;\n        next = neW;\n        System.out.println(neW);\n    }\n\n}\n```\n\n\nMy current code output compared to the correct one; \n    ", "Answer": "\r\nthere's a couple of things about your code that confuse me, but this is how I would do it:\n\n```\npublic static void fib(int n)\n{\n    int current = 0;\n    int old = 1;\n    int new = 0;\n    for(int i = 0; i < n; i = i+1)\n    {\n        new = current + old;\n        old = current;\n        current = new;\n        System.out.println(current);\n    }\n\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Go Fibonacci sequence generator [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThis is my fibonacci generator:\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for i, j := 0, 1; j < 100; i, j = i+j,i {\n        fmt.Println(i)\n    }\n}\n```\n\n\nIt's working, but I don't know how can I improve it, I'd like more expert approaches about it, Thanks...\n    ", "Answer": "\r\nI assume you are talking about improving the time complexity (and not the code complexity).\n\nYour solution computes the Fibonacci numbers in O(n) time. Interestingly, there exists an O(log n) solution as well. \n\nThe algorithm is simple enough: Find the nth power of matrix A using a Divide and Conquer approach and report (0,0)th element, where\n\n```\n A = |1     1 |\n     |1     0 |\n```\n\n\nThe recursion being \n\n```\n A^n = A^(n/2) * A^(n/2)\n```\n\n\nTime complexity:\n\n```\nT(n) = T(n/2) + O(1) = O(logn)\n```\n\n\nIf you think about it with a piece of paper, you'd find that the proof is simple and is based upon the principle of induction.\nIf you still need help, refer to this link\n\nNOTE: Of course, the O(logn) time is true only if you want to find the nth Fibonacci number. If, however, you intend to print ALL of the n fib numbers, theoretically, you can not have a better time complexity than you already have.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in an arraylist\r\n                \r\nI am looking for a clear explanation to my question (NOT looking for code), but if a bit of code helps to explain yourself, then please do.. thank you :)\n\nQuestion:\n\n-using Java\n\n-Main class asks user for an integer input (fibonacci N term), then proceeds to calculate all the fibonacci numbers, in order, until it reaches that term.\n\n-everything is stored into a single arraylists, of type integer. (Each digit is broken up and stored in its own index, so it is its own \"element\", so to speak.)\n\nFor example, i am aiming for it to go something like this:\n\n\"Please enter an N fibonacci term:\"\n\n10\n\nAt this point now, internally, I have stored the 2 base cases in an arraylist, that look like this:\n\nArrayList: [1, 1]\n\nNow, I am trying to make my arraylist look like this, after user input:\n\n[1, 1, 2, 3, 5, 8, 1, 3, 2, 1, 3, 4, 5, 5]\n\n(notice how it stopped at the last term, 55, and also notice how the double digit values are broken up into separate elements.)\n\nI have no problem breaking up the digits, its just the \"calculating\" that is giving me a hard time.. thanks in advance for any advice\n    ", "Answer": "\r\nI would generate Fibonacci values using ```\nint```\n values and use these results to break up digits to add to the ArrayList.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding the nth term in a Fibonacci sequence using for loops in Java\r\n                \r\nI need to specifically use for loops to find the nth term in a Fibonacci sequence. I tried to make it so that the main method tells method generateFibonnaci the nth term it needs to find and assign n as the limit of the second for loop, which will find the nth term recursively up until the limiting number n. For example, when input is 2, the plan is for the Fibonacci formula to run twice and return 1, but it's returning 5 in this case. I suspect that the problem lies within the parameters for the for loop, but I'm not completely sure.\n\n```\nclass Fibonnaci\n{\n    public static int generateFibonacci(int input)\n    {\n        int num1 = 0;\n        int num2 = 1;\n        int fibonacci = 0;\n        int n = 0;\n\n        for(int i = 0; i < input; i++)\n        {\n            n = input;\n\n            for(int j = 0; j < n; j++)\n            {\n                fibonacci = num1 + num2;\n                num1 = num2;\n                num2 = fibonacci;\n            }\n        }\n\n        return fibonacci;\n    }\n\n    public static void main(String [] args)\n    {\n        int [] inputs = {1, 2, 3, 4, 5, 6, 11, 16, 21, 31, 41, 46, 1, 1, 2, 11};\n\n        for(int i = 0; i < inputs.length; i++)\n        {\n            System.out.println(generateFibonacci(inputs[i]));\n        }\n    }\n} \n```\n\n    ", "Answer": "\r\nYou have to change the ```\nfor```\n loop.\n\n```\nfor(int i = 0; i < input - 1; i++) {\n    fibonacci = num1 + num2;\n    num1 = num2;\n    num2 = fibonacci;\n}\n```\n\n\nThis should suffice.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Code\r\n                \r\nThe Fibonacci numbers have a range of interesting uses in Mathematics and Computer Science. For example, suppose that a single mould spores falls onto a loaf of break while someone is making their breakfast one day. Suppose also that 48 hours after a spore is created it is able to clone itself, and create a further fresh one every 24 hours thereafter. Finally suppose also that 48 hours after it is created each new spore also starts cloning a fresh spore everyday.\n\nIn general F(n) = F(n-1) + F(n-2).\n\nWrite a program that prints out the number of spores present at the end of each day. Stop when the number of spores exceeds ten million. How many days does it take? \n\n```\nint days, next, first=0, second=1;\n\nprintf(\"Enter the day you want to know how many spores exists on\\n\");\nscanf(\"%d\", &days);\n\nwhile(next < 10000000) {\n\n    if(days == 1) {\n        next = 1;\n    }\n    else {\n        next = first + second;\n        first = second;\n        second = next;\n    }\n}\nprintf(\"The day %d has %d spores\\n\", days, next);\n```\n\n\nSo far I've only been able to do this. But it's taking me no where. Can someone else only using while, if and scanf functions ? \n    ", "Answer": "\r\nThe Fibonacci sequence operates as the following:\n\n1  1  2  3  5  8  13  21  34  etc....\n\nSo it comes down to the formula of F(n) = F(n-2) + F(n-1). You are missing code to increment days.\n\nTry this:\n\n```\ndays = 1;\nnext = 0;\nfirst = 0;\nsecond = 1;\n\nwhile(next < 10000000) {\n    next = first + second;\n    first = second;\n    second = next;\n    printf(\"The day %d has %d spores\\n\", days, next);\n    days++;\n}\n```\n\n\nThat should generate a proper Fibonacci number sequence.  If not, I'll correct it.\n\nEDIT:  I also noticed that your printf statement is not inside the while loop.  Furthermore, notice how I setup the variables before I entered the loop so as to not require an if statement inside the loop.  It's more of a performance issue as the less stuff there is to do inside the loop, the faster it will execute.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Array is printing with weird question mark symbols when printing fibonacci sequences\r\n                \r\nWhen printing each Fibonacci sequence the first couple of sequences print in weird symbols or not at all if printing more than 8 sequences.\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\n//n=amount of numbers in the series to compute, seq=array to store series\nvoid fibonacci(int n, int* seq){\n    // Complete this function\n    int i;\n    seq[0] = 0;\n    seq[1] = 1;\n    for(i = 2; i <= n; i++){\n        seq[i] = seq[i-2] + seq[i-1];\n    }\n\n\n\n}\n\nint main(){\n\n    int n;\n    //n, amount of series to compute\n    scanf(\"%d\",&n);\n\n    //initialize array to 1, using malloc/calloc\n    int *seq = malloc(1 * sizeof(*seq));\n\n    int i;\n    for(i = 1; i <= n; i++){\n\n            //recompute the whole series\n            fibonacci(i, seq);\n\n        //print array\n            int j;\n            for(j = 0; j < i; j++)/* complete code */\n            printf(\"%d \", seq[j]);\n\n        //resize array, with realloc\n            int newSize=i+1;\n        int *seq = realloc(seq, newSize);\n\n        printf(\"\\n\");\n    }\n    //free array\n    return 0;\n}\n```\n\n\nOutput:\n\n```\n\"7Y��yb�=\n\nUm�*/E�o 1 1 2 3 5 8 13 \n\n0 1 1 2 3 5 8 13 21 \n\n0 1 1 2 3 5 8 13 21 34 \n\n0 1 1 2 3 5 8 13 21 34 55 \n\n0 1 1 2 3 5 8 13 21 34 55 89 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 \n\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 \n```\n\n    ", "Answer": "\r\nThere are different problems in your code:\n\n\nIn your ```\nfibonacci()```\n function, you iterate using ```\ni <= n```\n, but inside the loop, you assign to ```\nseq[i]```\n. When ```\ni```\n = ```\nn```\n, this becomes a problem: you're accessing one cell out of the array.\nYou are getting ```\nn```\n from user input, but then doing ```\nint *seq = malloc(1 * sizeof(*seq))```\n. You are only allocating space for one element, not ```\nn```\n. You should do ```\nmalloc(n * sizeof(*seq))```\n instead.\nNot really an error, but inside the first ```\nfor```\n loop in your ```\nmain```\n, you're both re-defining and re-allocating the ```\nseq```\n array with ```\nint *seq = realloc(...)```\n. That is not needed at all. Your array is already ```\nn```\n cells big, so there is no need to reallocate it each time. You can use it as is.\nNot really an error, but there is no need to recompute the series each time. You can compute it only once and then partially print it on each row without a problem.\n\n\nAlso, IMPORTANT! Using ```\nint```\n to hold numbers of the Fibonacci sequence is only good until you reach ```\nn = 47```\n. More than that, and your next element will overflow the maximum positive value that an ```\nint```\n can hold, turning negative, and invalidating the rest of the calculations too. I would suggest you to use ```\nlong long unsigned int```\n instead, which would be good up to ```\nn = 94```\n (assuming 64 bits). Ultimately, you should check the value of ```\nn```\n before calculating the Fibonacci sequence to avoid an overflow.\n\n\n\nHere's a better version of your code with those problems fixed:\n\n```\nvoid fibonacci(int n, int* seq) {\n    int i;\n\n    seq[0] = 0;\n    seq[1] = 1;\n\n    for(i = 2; i < n; i++)\n        seq[i] = seq[i-2] + seq[i-1];\n}\n\nint main() {\n    int *seq;\n    int n, i, j;\n\n    scanf(\"%d\",&n);\n\n    // Allocate enough space for n elements:\n    seq = malloc(n * sizeof(*seq));\n\n    // Compute the whole series once:\n    fibonacci(n, seq);\n\n    // Print partial series on each row:\n    for(i = 1; i <= n; i++) {\n        for(j = 0; j < i; j++)\n            printf(\"%d \", seq[j]);\n\n        printf(\"\\n\");\n    }\n\n    free(seq);\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "I don't clearly see why this is the Fibonacci sequence. Am I intelligent enough to be a Haskell programmer?\r\n                \r\nThis is a way to get the Fibonacci sequence in Haskell. It's from the book haskellbook.com (supposedly for beginners):\n\n```\nfibs = 1 : scanl (+) 1 fibs\n```\n\n\nI can only \"see\" that this is Fibonacci after writing out a few of the first elements manually:\n\n```\n1 : scanl (+) 1 (1 : scanl (+) 1 (1 : scanl (+) 1 (1 : 1 ...\n1 : scanl (+) 1 (1 : scanl (+) 1 (1 : 1 : 2 : 3 ...\n1 : scanl (+) 1 (1 : 1 : 2 : 3 : 5 : 8 ...\n1 : 1 : 2 : 3 : 5 : 8 : 13 : 21 ...\n```\n\n\nOnly now do I have some intuition into why this is the Fibonacci sequence. But I had to write it out like this first. And even then it's still just an intuition, not solid proof.\n\nI have three questions:\n\n\nWas I supposed to immediately just spot the Fibonacci sequence from the original line?\nWould some of you professional Haskell programmer in here of 5-10 years, if you had for the sake of argument never before seen this particular example, immediately have seen that the original line is the Fibonacci sequence?\nI sometimes find myself wondering whether I'm intelligent enough to be a Haskell programmer. Maybe it's just not for me. Haskell makes me feel inadequate sometimes :( Never had this feeling with other programming languages. So the third question: Have any tests/methods been developed to determine whether a particular programmer is intelligent enough to be a Haskell programmer? (I'm pretty sure Haskell requires a higher IQ than most other languages!)\n\n    ", "Answer": "\r\n\n  Was I supposed to immediately just spot the Fibonacci sequence from the original line?\n\n\nHeck no! You were supposed to read the example, scratch your head, write it out manually... and thereby get an intuition for how ```\nscanl```\n works and why this can be used for Fibonacci numbers.\n\n\n  Would some of you ... have seen that the original line is the Fibonacci sequence?\n\n\nWell, it is called ```\nfibs```\n... apart from that, yeah, ```\nscanl```\n is standard enough that an experienced programmer would quickly see what's going on.\n\n\n  pretty sure Haskell requires a higher IQ\n\n\nI think Haskell requires most of all a good deal of stubbornness, and a particular sense of æsthetics. Haskell has some quirky ways of doing stuff different. Some of these are a bit hard to grasp, but most of all they're just unfamiliar to most programmers. It's all about getting used to the stuff.\n\nAnd because, if we're honest, Haskell skills are still not a terribly utilitarian thing right now (as in, any real-world task can be solved as well by some other language too), you really need some enthusiasm for the language's beauty and future potential to keep up with it.\n\nNote that Haskell's quirks and features have a tendency to slowly seep into mainstream languages. So, even if “Haskell is not for you” you may in the long term benefit from the nice things that are prototyped here, perhaps without even noticing where they come from.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "I can't get my Fibonacci sequence to pass this rspec test in Ruby. How do I go about it?\r\n                \r\nI was given a test to pass on Fibonacci sequence in Ruby and I've been searching for an answer ever since. I couldn't come up with anything satisfactory and the 'closest' I've got to solving it is (after seeing something on Fibonacci on SO):\n\n```\nclass Fibonacci\n\ndef generate( n )\n  return  n  if (0..1).include? n\n  ( fibonacci( n - 1 ) + fibonacci( n - 2 ) )\nend\n```\n\n\nThis is the test:\n\n```\ndescribe \"Fibonacci\" do\n  it \"can output the fibonacci sequence for 5 numbers\" do\n    expect(Fibonacci.generate(5)).to eql([0,1,1,2,3])\n    expect(Fibonacci.generate(5).last).to eql(3)\n    expect(Fibonacci.generate(5)[-2]).to eql(2)\n    expect(Fibonacci.generate(5)[2]).to eql(1)\n  end\n\n  it \"can output the fibonacci sequence for 20 numbers\" do\n    expect(Fibonacci.generate(20)).to eql([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181])\n    expect(Fibonacci.generate(20).last).to eql(4181)\n    expect(Fibonacci.generate(20)[-2]).to eql(2584)\n    expect(Fibonacci.generate(20)[5]).to eql(5)\n    expect(Fibonacci.generate(20)[6]).to eql(8)\n    expect(Fibonacci.generate(20)[7]).to eql(13)\n    expect(Fibonacci.generate(20)[-3]).to eql(1597)\n  end\n\n  it \"can output the fibonacci sequence for 50 numbers\" do\n    expect(Fibonacci.generate(50)).to eql([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049])\n    expect(Fibonacci.generate(50).last).to eql(7778742049)\n    expect(Fibonacci.generate(50).count).to eql(50)\n    expect(Fibonacci.generate(50)[24]).to eql(46368)\n    expect(Fibonacci.generate(50)[12]).to eql(144)\n  end\nend\n```\n\n\nWhat do I change to make it satisfy the test?\n    ", "Answer": "\r\nThe ```\ngenerate```\n method you have is an instance method, but your tests are testing for a class method. To make the method into a class method in Ruby use the ```\nself```\n keyword in the method signature like this:\n\n```\ndef self.generate(n)\n```\n\n\nor use the class name in the signature like this:\n\n```\ndef Fibonacci.generate(n)\n```\n\n\nAlso the tests themselves mostly aren't useful and need rewriting.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "generating numbers for Fibonacci sequence and write them to file\r\n                \r\nAlright, I feel like I'm very close to solving this but nothing I do to this seems to work.\nThis program has to create 47 numbers of the fibonacci sequence then store them in an array of DWORDS then write that to a file (fib.bin). The formatting got kind of screwed up but if you need any clarification I will try to help.\n\n```\nINCLUDE Irvine32.inc\n.data\nfileHandle DWORD ?\nfilename BYTE \"fib.bin\", 0\n\nFIB_COUNT = 47\narray DWORD FIB_COUNT DUP(?)\n\n.code\nmain PROC\n\n    ; Create the file\n    mov  edx,OFFSET filename\n    call CreateOutputFile\n    mov  fileHandle,eax\n\n\n    ; Generate the array of values\n    mov  esi,OFFSET array\n    mov  ecx,FIB_COUNT\n    call generate_fibonacci\n\n\n    ; Write the array to a file\n    mov  eax,fileHandle\n    mov  edx,OFFSET array\n    mov  ecx,SIZEOF array\n    call WriteToFile\n\n\n    ; Close the file\n    mov  eax,fileHandle\n    call CloseFile\n\n    exit\nmain ENDP\n\n;---------------------------------------------------\ngenerate_fibonacci PROC USES eax ebx ecx\n;\n; Generates fibonacci values and stores in an array.\n; Receives: ESI points to the array, ECX = count\n; Returns: nothing\n;---------------------------------------------------\n\n    mov ebp, 0\n    mov edx, 1\n\n    mov ebx, edx\n    mov ecx, 47             \nL1:                         \n     mov eax, edx           \n     mov ebp, eax           \n     mov edx, ebx           \n     add ebx, ebp           \n\n\n;    dec ecx\nloop L1\n     ret \ngenerate_fibonacci ENDP\n\nEND main\n```\n\n\nI the problem I see is that it's not returning anything and I cannot find out what I need it to return. I've tried it returning various registers but all of them come out with an error. \n    ", "Answer": "\r\nJust did this one in class:\n\n```\nINCLUDE Irvine32.inc\n.data\nfileHandle DWORD ?\nfileName BYTE \"myFile.bin\", 0\narrSize = 47\nmyArray DWORD arrSize DUP(?)\n\n.code\nmain PROC\n    call Clrscr\n\n    ;Create the file\n    mov edx, OFFSET fileName\n    call CreateOutputFile\n    mov fileHandle, eax\n\n    ;Call array process\n    mov esi, OFFSET myArray\n    mov ecx, arrSize\n    call GetFib\n\n    ;Write array\n    mov eax, fileHandle\n    mov edx, OFFSET myArray\n    mov ecx, SIZEOF myArray\n    call WriteToFile\n\n    ;close\n    mov eax, fileHandle\n    call CloseFile\n\n    exit\nmain ENDP\n\nGetFib PROC USES eax ebx ecx\n;--------------------------------\n;Generates fibonnaci sequence and stores in array\n;Recieves: ESI points to the array, ECX is the number of values\n;Returns: Nothing\n;--------------------------------\n\n    ;Set starting values\n    mov eax, 1\n    mov ebx, 0\nL1:\n    ;Add the second number to the first\n    add eax, ebx\n    call WriteDec\n    call CrlF\n\n    ;Move value to array, increment esi, exchange values\n    mov [esi], eax\n    add esi, TYPE myArray\n    xchg eax, ebx\nloop L1\n\nret\nGetFib ENDP\nEND main\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sqequence program, cannot figure out how to use the for loop to display the sequence [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\n```\nimport java.io.*;\n\n// Fibonacci Sequence\npublic class FibonacciSeq{ \n    // main method\n    public static void main (String[] args) throws IOException { \n        // buffered reader\n        BufferedReader keyboardInput = new BufferedReader (new InputStreamReader (System.in));\n\n        for (int x = 0 ; x < 15 ; x = x++) {\n            System.out.print (x);\n\n        }\n    }\n}\n```\n\n\nand then the output is just 0000000000.. etc and does not stop , the goal is that it is supposed to output the Fibonacci sequence up to 15\n    ", "Answer": "\r\nYour ```\nfor```\n loop, ```\nfor (x = 0 ; x < 15 ; x = x++)```\n does not increment ```\nx```\n and it doesn't declare ```\nx```\n. I think you wanted something like\n\n```\nfor (int x = 0 ; x < 15 ; x++)\n```\n\n\nwhen you use post-increment the increase doesn't happen until the next line (it evaluates to the previous value, which you then stored).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence in Haskell - only return values up to a user input value NOT index\r\n                \r\nI have seen many Haskell programs that when a user enters 5 it will return the first 5 elements of the Fibonacci sequence, however, I need it to only output the values of the Fibonacci sequence that are less than or equal to 5.\nFor example:\nFib 15 needs to output\n1 1 2 3 5 8 13\nFib 7 needs to output\n1 1 2 3 5\nThis is what I have & am trying to alter to output up to the given value and not the given index:\n```\n    -- individual fib numbers\n    fib :: Int -> Int\n    fib 0 = 1\n    fib 1 = 1\n    fib n = fib (n - 1) + fib (n - 2)\n\n    -- example run fib 6 returns the int at position 6 \n    -- so fib 6 = 13\n\n\n    -- combines individual fib numbers\n    fibonacciSequence x = map fib[1..x]\n```\n\nSome things I have tried:\n```\n    fibonacciSequence x = map (\\x -> fib[1..] > x ) [1..]\n\n    y = filter (\\y -> y > x) fib[1..x]\n\n    fibonacciSequence x = map (inRange (1,x)) [1..]\n\n    fibonaci g = map fst (iterate f (0,1)) where f (x,y) = (y,x+y) | f(y, x+y) <= g\n```\n\nI am very new to Haskell and your help would be very appreciated!\n    ", "Answer": "\r\nRather than writing a function that generates a finite sequence like:\n```\nfibonacciSequence x = map fib [1..x]\n```\n\nIt is often more useful to write it as an infinite sequence:\n```\nfibonacciSequence = map fib [1..]\n```\n\nThen you can choose which parts you want freely, for the first ```\nn```\n elements you can use:\n```\ntake n fibonacciSequence\n```\n\nAnd if you want the Fibonacci numbers up to ```\nn```\n you can do it like this:\n```\ntakeWhile (<= n) fibonacciSequence\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence generator with fork and shared memory\r\n                \r\nI'm struggling with a homework problem. I'm asked to:\nWrite a program whose main routine obtains one parameter n from the user (n<40), i.e. passed to your program when it was invoked from the shell. Your program shall then create a shared memory and a child process. The shared memory shall have a size of BUF_SZ*sizeof(unsigned short), where BUF_SZ is defined as 5 using a macro, e.g. “#define BUF_SZ 5”.\nThe child process should obtain the value of n from the parent (you actually have multiple options for doing that) and create a Fibonacci sequence of length n and whose elements are of type unsigned short. You may find more information about Fibonacci numbers at (https://en.wikipedia.org/wiki/Fibonacci_number).\nThe child process shall create the elements, one at a time, and wait for a random interval of time ( 0 <= time < 2 seconds) between generating elements of the sequence. As soon as an element is generated, the child places the element in the shared memory by organizing it as described in class.\nThe parent process shall print elements it receives on the shared butter immediately, without waiting for the child process to exit.\n```\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <stdbool.h>\n#include <sys/mman.h>\n#include <errno.h>\n#include <fcntl.h>\n\n\n#define BUF_SZ 5\n#define NAME \"buffer\"\n#define NAME2 \"inptr\"\n#define NAME3 \"outptr\"\n\nint main() {\n    int fd[2];\n    int n = atoi(argv[1]);\n    unsigned short *data;\n    int* inptr;\n    int* outptr;\n    int size = BUF_SZ * sizeof(unsigned short);\n    int size2 = sizeof(int);\n    \n    /*while(n >= 40 || n <= 0) {\n        printf(\"Enter a positive integer less than 40: \");\n        scanf(\"%i\", &n);\n    }*/\n    \n    int shmid = shm_open(NAME, O_CREAT|O_RDWR, 0666);\n    ftruncate(shmid, size);\n    data = (unsigned short*) mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, shmid, 0);\n    \n    int shmid2 = shm_open(NAME2, O_CREAT|O_RDWR, 0666);\n    ftruncate(shmid2, size2);\n    inptr = (int*) mmap(NULL, size2, PROT_READ|PROT_WRITE, MAP_SHARED, shmid2, 0);\n    \n    int shmid3 = shm_open(NAME2, O_CREAT|O_RDWR, 0666);\n    ftruncate(shmid3, size2);\n    outptr = (int*) mmap(NULL, size2, PROT_READ|PROT_WRITE, MAP_SHARED, shmid3, 0);\n    \n    memset(inptr, 0, size2); //in variable\n    memset(outptr, 0, size2); //out variable\n    \n    pipe(fd);\n    pid_t pid = fork();\n    \n    if(pid > 0) {                   \n        write(fd[1], &n, sizeof(n)); //write n value to child   \n        while (*inptr == *outptr);\n        printf(\"%i\\n\", data[*outptr]);\n        fflush(stdout);\n        *outptr = (*outptr + 1) % BUF_SZ;           \n    }\n    else if(pid == 0) {\n        read(fd[0], &n, sizeof(n)); //get n value from parent\n        int prev = 0;\n        int curr = 1;\n        int tmp;\n    \n        for(int i = 0; i <= n; i++) {       \n            while (((*inptr + 1) % BUF_SZ) == *outptr);\n    \n            if(i == 0) {\n                data[*inptr] = 0;\n                *inptr = (*inptr + 1) % BUF_SZ; \n            }\n            else if(i == 1) {\n                data[*inptr] = 1;\n                *inptr = (*inptr + 1) % BUF_SZ; \n            }\n        \n            tmp = curr;\n            curr += prev;\n            prev = tmp;\n            data[*inptr] = curr;\n            *inptr = (*inptr + 1) % BUF_SZ;\n        }\n    }\n    else {\n        printf(\"failed\");\n    }\n    \n    return 0;\n\n}\n```\n\nI created shared memory buffers for the elements of the fib sequence and in and out pointers. In writes to the buffer and out reads from the buffer. The parent process checks if the in and out pointers are equal or not. When they are not equal, it reads from the buffer. The child process outputs elements to the buffer when the in pointer is one ahead of the out pointer. The issue is that the parent process gets stuck in an infinite while loop and it doesn't switch to the child process. I'm not sure how to proceed.\n    ", "Answer": "\r\nA few issues ...\n\nYou only grab a single number in the parent. You need an outer ```\nwhile```\n loop.\nYour last ```\nshm_open```\n uses ```\nNAME2```\n instead of ```\nNAME3```\n. This causes ```\ninptr```\n and ```\noutptr```\n to point to the same memory cell. So, they \"alias\" each other and they will always be the same value.\n```\ninptr```\n and ```\noutptr```\n should have ```\nvolatile```\n on them [as dimich mentioned].\nYou need ```\nint main(int argc,char **argv)```\n\nThe parent will loop infinitely after receiving the final number from the child.\nAlthough I didn't do it in the code below, the child could send one more final value that is a sentinel (to tell the parent that it's the end). When the parent sees the sentinel, it breaks out of the outer loop (and then does a ```\nwait(NULL)```\n to reap the child).\nSince fibonacci numbers can't be 0, it makes for an okay sentinel value.\n\n\nHere is the corrected code. It is annotated. I've added some debug prints to help:\n```\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n\n#define BUF_SZ 5\n#define NAME \"buffer\"\n#define NAME2 \"inptr\"\n#define NAME3 \"outptr\"\n\n#if DEBUG\n#define dbgprt(_fmt...) \\\n    printf(_fmt)\n#else\n#define dbgprt(_fmt...) \\\n    do { } while (0)\n#endif\n\nint\nmain(int argc,char **argv)\n{\n    int fd[2];\n    int n = atoi(argv[1]);\n    unsigned short *data;\n// NOTE/BUG: without volatile the optimizer could incorrectly elide code\n#if 0\n    int *inptr;\n    int *outptr;\n#else\n    volatile int *inptr;\n    volatile int *outptr;\n#endif\n    int size = BUF_SZ * sizeof(unsigned short);\n    int size2 = sizeof(int);\n\n    /* while(n >= 40 || n <= 0) { printf(\"Enter a positive integer less than 40: \"); scanf(\"%i\", &n); } */\n\n    int shmid = shm_open(NAME, O_CREAT | O_RDWR, 0666);\n    ftruncate(shmid, size);\n    data = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, shmid, 0);\n\n    int shmid2 = shm_open(NAME2, O_CREAT | O_RDWR, 0666);\n    ftruncate(shmid2, size2);\n    inptr = mmap(NULL, size2, PROT_READ | PROT_WRITE, MAP_SHARED, shmid2, 0);\n\n// NOTE/BUG: this uses the same file as shmid2, so inptr are aliased together\n#if 0\n    int shmid3 = shm_open(NAME2, O_CREAT | O_RDWR, 0666);\n#else\n    int shmid3 = shm_open(NAME3, O_CREAT | O_RDWR, 0666);\n#endif\n    ftruncate(shmid3, size2);\n    outptr = mmap(NULL, size2, PROT_READ | PROT_WRITE, MAP_SHARED, shmid3, 0);\n\n#if 0\n    memset((void *) inptr, 0, size2);           // in variable\n    memset((void *) outptr, 0, size2);          // out variable\n#else\n    *inptr = 0;\n    *outptr = 0;\n#endif\n\n    pipe(fd);\n    pid_t pid = fork();\n\n    if (pid > 0) {\n        write(fd[1], &n, sizeof(n));    // write n value to child\n// NOTE/FIX: we need an outer loop to get all numbers from the child\n        while (1) {\n            while (*inptr == *outptr);\n            printf(\"parent: %i\\n\", data[*outptr]);\n            fflush(stdout);\n            *outptr = (*outptr + 1) % BUF_SZ;\n            dbgprt(\"parent: inptr=%d outptr=%d\\n\",*inptr,*outptr);\n        }\n    }\n    else if (pid == 0) {\n        read(fd[0], &n, sizeof(n));     // get n value from parent\n        int prev = 0;\n        int curr = 1;\n        int tmp;\n\n        dbgprt(\"child: n=%d\\n\",n);\n\n        for (int i = 0; i <= n; i++) {\n            while (((*inptr + 1) % BUF_SZ) == *outptr);\n\n            if (i == 0) {\n                data[*inptr] = 0;\n                dbgprt(\"child: i0\\n\");\n                *inptr = (*inptr + 1) % BUF_SZ;\n            }\n            else if (i == 1) {\n                dbgprt(\"child: i1\\n\");\n                data[*inptr] = 1;\n                *inptr = (*inptr + 1) % BUF_SZ;\n            }\n\n            tmp = curr;\n            curr += prev;\n            prev = tmp;\n            printf(\"curr=%d\\n\",curr);\n            data[*inptr] = curr;\n\n            *inptr = (*inptr + 1) % BUF_SZ;\n            dbgprt(\"child: inptr=%d outptr=%d\\n\",*inptr,*outptr);\n        }\n    }\n    else {\n        printf(\"failed\");\n    }\n\n    return 0;\n\n}\n```\n\n\nIn the code above, I've used ```\ncpp```\n conditionals to denote old vs. new code:\n```\n#if 0\n// old code\n#else\n// new code\n#endif\n\n#if 1\n// new code\n#endif\n```\n\nNote: this can be cleaned up by running the file through ```\nunifdef -k```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Most significant digit wrong in a dynamically allocated array using the Fibonacci sequence\r\n                \r\ni'm doing an assignment, in which I need to use a structure with an int pointer to a number, store n amounts of numbers in the pointer. add two instances of the struct together, and pass those two structures into a Fibonacci sequence function, thus being the first populated struct will be Fibonacci[0], the second populated struct will be Fibonacci[1], and those two added together will be Fibonacci[2], so on and so forth. A key note on the assignment is to make sure the dynamically allocated array does not pass a certain value of digits, for example the instructions say to have 50 digits per Fibonacci iteration, in this example I've hard coded \n\nMy issue is, I produce a near proper Fibonacci value, however, when I get to Fibonacci[4] my value is 1 digit off in the most significant digit. For the first 3 iterations of Fibonacci I produce the correct value, but from there, I believe it starts using a value that is one digit off, therefore eventually producing totally different numbers than what is expected.\n\nI've fiddled around with my Fibonacci function, however I believe the issue may be within my addFunction, there's an issue with the carry, i'm just stumped at this point, spent all day yesterday only working on Fibonacci summing issues.\n\n```\n #define MAX 3\n\ntypedef struct Integer\n{\n    int *number;\n\n} Integer;\n\nInteger *addFunction(Integer *intA, Integer *intB)\n{\n    int carry = 0, drop, i;\n\n    if (intA == NULL)\n    {\n        printf(\"Null Pointer: intA\");\n        return NULL;\n    }\n    if (intB == NULL)\n    {\n        printf(\"Null Pointer: intB\");\n        return NULL;\n    }\n\n    Integer *intSum = malloc(sizeof(Integer));\n    intSum->number = malloc(sizeof(int));\n\n    for (i=0; i<=2; i++)\n    {\n        intSum->number[i] = intA->number[i] + intB->number[i] + carry;\n\n        if (intSum->number[i] > 9)\n        {\n            drop = intSum->number[i] % 10;\n            carry = intSum->number[i] / 10;\n            intSum->number[i] = drop;\n        }\n    }\n\n    return intSum;\n}\n\nvoid printFunction(Integer *intC)\n{\n    int i;\n\n    if (intC == NULL)\n    {\n        printf(\"Null Pointer\");\n        return;\n    } \n\n    for (i=MAX-1; i>=0; i--)\n    {\n        printf(\"%d\", intC->number[i]);\n    }\n\n    printf(\"\\n\");\n}\n\nInteger *loadFirstVariable(int a[])\n{\n    int i;\n\n    Integer *intA = malloc(sizeof(Integer));\n    intA->number = malloc(sizeof(int));\n\n    for (i=0; i<=2; i++)\n    {\n        intA->number[i] = a[i];\n    }\n\n    return intA;\n}\n\nInteger *loadSecondVariable(int b[])\n{\n    int i;\n\n    Integer *intB = malloc(sizeof(Integer));\n    intB->number = malloc(sizeof(int));\n\n    for (i=0; i<=2; i++)\n    {\n        intB->number[i] = b[i];\n    }\n\n    return intB;\n}\n\nInteger *fibonacci(int n, Integer *first, Integer *second)\n{\n\n    int i, y, z;\n\n    Integer *fibSum = malloc(sizeof(Integer));\n    fibSum->number = malloc(sizeof(int));\n\n    if (n == 0)\n        return first;\n    if (n == 1)\n        return second;\n    if (n >= 2)\n    {\n        for (i=2; i<=n; i++)\n        {\n            *fibSum = (*addFunction(first, second));\n\n            for (y=0; y<=2; y++)\n            {\n                first->number[y] = second->number[y];\n                second->number[y] = fibSum->number[y];\n            }\n        }\n\n        return fibSum;\n    }\n}\n\nint main ()\n{\n    int a[3] = {7, 3, 4};\n    int b[3] = {2, 9, 5};\n\n    printf(\"Fibonacci Sequence\\n\");\n    printFunction(fibonacci(4, loadFirstVariable(a), loadSecondVariable(b)));\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Most significant digit wrong in a dynamically allocated array using the Fibonacci sequence\r\n                \r\ni'm doing an assignment, in which I need to use a structure with an int pointer to a number, store n amounts of numbers in the pointer. add two instances of the struct together, and pass those two structures into a Fibonacci sequence function, thus being the first populated struct will be Fibonacci[0], the second populated struct will be Fibonacci[1], and those two added together will be Fibonacci[2], so on and so forth. A key note on the assignment is to make sure the dynamically allocated array does not pass a certain value of digits, for example the instructions say to have 50 digits per Fibonacci iteration, in this example I've hard coded \n\nMy issue is, I produce a near proper Fibonacci value, however, when I get to Fibonacci[4] my value is 1 digit off in the most significant digit. For the first 3 iterations of Fibonacci I produce the correct value, but from there, I believe it starts using a value that is one digit off, therefore eventually producing totally different numbers than what is expected.\n\nI've fiddled around with my Fibonacci function, however I believe the issue may be within my addFunction, there's an issue with the carry, i'm just stumped at this point, spent all day yesterday only working on Fibonacci summing issues.\n\n```\n #define MAX 3\n\ntypedef struct Integer\n{\n    int *number;\n\n} Integer;\n\nInteger *addFunction(Integer *intA, Integer *intB)\n{\n    int carry = 0, drop, i;\n\n    if (intA == NULL)\n    {\n        printf(\"Null Pointer: intA\");\n        return NULL;\n    }\n    if (intB == NULL)\n    {\n        printf(\"Null Pointer: intB\");\n        return NULL;\n    }\n\n    Integer *intSum = malloc(sizeof(Integer));\n    intSum->number = malloc(sizeof(int));\n\n    for (i=0; i<=2; i++)\n    {\n        intSum->number[i] = intA->number[i] + intB->number[i] + carry;\n\n        if (intSum->number[i] > 9)\n        {\n            drop = intSum->number[i] % 10;\n            carry = intSum->number[i] / 10;\n            intSum->number[i] = drop;\n        }\n    }\n\n    return intSum;\n}\n\nvoid printFunction(Integer *intC)\n{\n    int i;\n\n    if (intC == NULL)\n    {\n        printf(\"Null Pointer\");\n        return;\n    } \n\n    for (i=MAX-1; i>=0; i--)\n    {\n        printf(\"%d\", intC->number[i]);\n    }\n\n    printf(\"\\n\");\n}\n\nInteger *loadFirstVariable(int a[])\n{\n    int i;\n\n    Integer *intA = malloc(sizeof(Integer));\n    intA->number = malloc(sizeof(int));\n\n    for (i=0; i<=2; i++)\n    {\n        intA->number[i] = a[i];\n    }\n\n    return intA;\n}\n\nInteger *loadSecondVariable(int b[])\n{\n    int i;\n\n    Integer *intB = malloc(sizeof(Integer));\n    intB->number = malloc(sizeof(int));\n\n    for (i=0; i<=2; i++)\n    {\n        intB->number[i] = b[i];\n    }\n\n    return intB;\n}\n\nInteger *fibonacci(int n, Integer *first, Integer *second)\n{\n\n    int i, y, z;\n\n    Integer *fibSum = malloc(sizeof(Integer));\n    fibSum->number = malloc(sizeof(int));\n\n    if (n == 0)\n        return first;\n    if (n == 1)\n        return second;\n    if (n >= 2)\n    {\n        for (i=2; i<=n; i++)\n        {\n            *fibSum = (*addFunction(first, second));\n\n            for (y=0; y<=2; y++)\n            {\n                first->number[y] = second->number[y];\n                second->number[y] = fibSum->number[y];\n            }\n        }\n\n        return fibSum;\n    }\n}\n\nint main ()\n{\n    int a[3] = {7, 3, 4};\n    int b[3] = {2, 9, 5};\n\n    printf(\"Fibonacci Sequence\\n\");\n    printFunction(fibonacci(4, loadFirstVariable(a), loadSecondVariable(b)));\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence algorithm in Javascript\r\n                \r\nI need to solve a Fibonacci question using JavaScript.\nThe function should have 3 parameters: 2 initial values and a final value.\nThe function should return the position of the final value in the Fibonacci series starting with the given initial values.\nFor example:\ninput: 2,5,19\noutput: 5\nBecause the series is 2,5,7,12,19 = 5\nhow?\n    ", "Answer": "\r\n```\nfunction Fibonacci(f1, f2, val) {\n    // print(\"fibanocci val:\", f1);\n    if(f1 == val) return 1;\n    return Fibonacci(f2, f1+f2, val) + 1;\n}\n\nprint(Fibonacci(2,5,19))\n```\n\nthis should be what you asked.\nEDIT: if input isn't always correct change this to avoid inf loop:\n```\nif(f1 >= val) return 1;\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence backward\r\n                \r\nHere is the code:\n\n```\nclass Fibonacci {\n    static final int MIN_INDEX = 1;\n    public static void main (String[] args){\n        int high = 1;\n        int low = 1;\n        String jel;\n        System.out.println(\"9: \" + high);\n\n    for (int i = 8; i >= MIN_INDEX; i--){\n        if (high % 2 == 0)\n            jel = \" *\";\n        else \n            jel = \" \";\n        System.out.println(i + \": \" + high + jel);\n        high = low + high;\n        low = high - low;\n\n\n    }\n}\n}\n```\n\n\nI want to make this program, to write the output numbers backward. So I want that not only the ' i ' step from the last to the first, but the numbers too.\n\nIn this example, the output is: 1, 1, 2, 3, 5, 8 , eg... But I want to show it in the sequence looks like: eg... , 8, 5, 3, 2, 1, 1.\n\nI tried to change the high and low, but I can't make this program force to run \"backward\". \n    ", "Answer": "\r\nNo Java here, but Fibonacci numbers have an explicit closed form:  \n\n```\nf[n_] := N@(GoldenRatio^n - (1 - GoldenRatio)^n)/Sqrt[5];  \n```\n\n\nWhere \n\nGoldenRatio = (1 + Sqrt[5])/2\n\nSo you can do:  \n\n```\nFor[i = 10, i > 0, i--,\n     Print[f[i]];\n  ];  \n```\n\n\nOutput:  \n\n```\n55.\n34.\n21.\n13.\n8.\n5.\n3.\n2.\n1.\n1.\n```\n\n\nEdit  \n\nAs an aside note The Golden Ratio is one of those wonderful pervasive numbers that you'll find in nature, science and the arts.  \n\nYou may find the golden ratio from Sea Shells to the Parthenon.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence with user inputting first 2 numbers\r\n                \r\nI am writing a C program to get Fibonacci number, the user needs to put the first 2 numbers and the sequence starts from there. Here is my code:\n\n```\n#include <stdio.h>\n#define MAX_SIZE 100\n\nint main()\n{\n    int i, input[MAX_SIZE];\n\n    printf(\"please Enter first 2 digit of the Sequence\\n\");\n\n    scanf(\"%d, %d\" , &input[0], &input[1]);\n\n    for (i = 2; i < MAX_SIZE; i++)\n    {\n        input[i] = input[i-2] + input[i-1];\n\n     printf(\"%d\\n\", input[i]);\n    }\n\n    return 0;    \n}\n```\n\n\nBut when i run the code with a input 2 and 3, I get a output like this ```\n1499141456```\n, which is clearly not the sequence. please help.\n    ", "Answer": "\r\nWhen you exit from the loop ```\ni```\n is equal to ```\nMAX_SIZE```\n\n\n```\nprintf(\"%d\\n\", input[i]);\n```\n\n\nyou are printing a value outside of the bounds of the array (```\ninput[MAX_SIZE]```\n).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Haskell Fibonacci sequence performance depending on methodology\r\n                \r\nI was trying out different approaches to getting a number at a given index of the Fibonacci sequence and they could basically be divided into two categories:\n\n\nbuilding a list and querying an index\nusing variables (might be separate or tupled, without a list)\n\n\nI picked an example of both:\n\n```\nfibs1 :: Int -> Integer\nfibs1 n = fibs1' !! n\n    where fibs1' = 0 : scanl (+) 1 fibs1'\n\nfib2 :: Int -> Integer\nfib2 n = fib2' 1 1 n where\n    fib2' _ b 2 = b\n    fib2' a b n = fib2' b (a + b) (n - 1)\n```\n\n\nfibs1:\n\n```\nreal    0m2.356s\nuser    0m2.310s\nsys     0m0.030s\n```\n\n\nfibs2:\n\n```\nreal    0m0.671s\nuser    0m0.667s\nsys     0m0.000s\n```\n\n\nBoth were compiled with 64bit GHC 7.6.1 and ```\n-O2 -fllvm```\n. Their core dumps are very similar in length, but they differ in the parts that I'm not very proficient at interpreting.\n\nI was not surprised that ```\nfibs1```\n failed for n = 350000 (```\nStack space overflow```\n). However, I am not comfortable with the fact that it used that much memory.\n\nI would like to clear some things up:\n\n\nWhy does the GC not take care of the beginning of the list throughout computation even though most of it quickly becomes useless?\nWhy does GHC not optimize the list version to a variable version since only two of its elements are required at once?\n\n\nEDIT: Sorry, I mixed the speed results, fixed. Two of three of my doubts are still valid, though ;).\n    ", "Answer": "\r\n\n  Why does the GC not take care of the beginning of the list throughout computation even though most of it quickly becomes useless?\n\n\n```\nfibs1```\n uses a lot of memory and is slow because ```\nscanl```\n is lazy, it doesn't evaluate the list elements, so\n\n```\nfibs1' = 0 : scanl (+) 1 fibs1'\n```\n\n\nproduces\n\n```\n0 : scanl (+) 1 (0 : more)\n0 : 1 : let f2 = 1+0 in scanl (+) f2 (1 : more')\n0 : 1 : let f2 = 1+0 in f2 : let f3 = f2+1 in scanl (+) f3 (f2 : more'')\n0 : 1 : let f2 = 1+0 in f2 : let f3 = f2+1 in f3 : let f4 = f3+f2 in scanl (+) f4 (f3 : more''')\n```\n\n\netc. So you rather quickly get a huge nested thunk. When that thunk is evaluated, it is pushed on the stack, and at some point between 250000 and 350000, it becomes too big for the default stack.\n\nAnd since each list element holds a reference to the previous while it is not evaluated, the beginning of the list cannot be garbage-collected.\n\nIf you use a strict scan,\n\n```\nfibs1 :: Int -> Integer\nfibs1 n = fibs1' !! n\n  where\n    fibs1' = 0 : scanl' (+) 1 fibs1'\n    scanl' f a (x:xs) = let x' = f a x in x' `seq` (a : scanl' f x' xs)\n    scanl' _ a [] = [a]\n```\n\n\nwhen the ```\nk```\n-th list cell is produced, its value is already evaluated, so doesn't refer to a previous, hence the list can be garbage collected (assuming nothing else holds a reference to it) as it is traversed.\n\nWith that implementation, the list version is about as fast and lean as ```\nfib2```\n (it needs to allocate list cells nevertheless, so it allocates a small bit more, and is possibly a tiny bit slower therefore, but the difference is minute, since the Fibonacci numbers become so large that the list construction overhead becomes negligible).\n\nThe idea of ```\nscanl```\n is that its result is incrementally consumed, so that the consumption forces the elements and prevents the build-up of large thunks.\n\n\n  Why does GHC not optimize the list version to a variable version since only two of its elements are required at once?\n\n\nIts optimiser can't see through the algorithm to determine that. ```\nscanl```\n is opaque to the compiler, it doesn't know what ```\nscanl```\n does.\n\nIf we take the exact source code for ```\nscanl```\n (renaming it or hiding ```\nscanl```\n from the Prelude, I opted for renaming),\n\n```\nscans                   :: (b -> a -> b) -> b -> [a] -> [b]\nscans f q ls            =  q : (case ls of\n                                []   -> []\n                                x:xs -> scans f (f q x) xs)\n```\n\n\nand compile the module exporting it (with -O2), and then look at the generated interface file with\n\n```\nghc --show-iface Scan.hi\n```\n\n\nwe get (for example, minor differences between compiler versions)\n\n```\nMagic: Wanted 33214052,\n       got    33214052\nVersion: Wanted [7, 0, 6, 1],\n         got    [7, 0, 6, 1]\nWay: Wanted [],\n     got    []\ninterface main:Scan 7061\n  interface hash: ef57dac14815e2f1f897b42a007c0c81\n  ABI hash: 8cfc8dab79de6a51fcad666f1869574f\n  export-list hash: 57d6805e5f0b5f76f0dd8dfb228df988\n  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e\n  flag hash: 1e8135cb44ef6dd330f1f56943d1f463\n  used TH splices: False\n  where\nexports:\n  Scan.scans\nmodule dependencies:\npackage dependencies: base* ghc-prim integer-gmp\norphans: base:GHC.Base base:GHC.Float base:GHC.Real\nfamily instance modules:\nimport  -/  base:Prelude 1cb4b618cf45281dc97748b1831bf0cd\nd79ca4e223c0de0a770a3b88a5e67687\n  scans :: forall b a. (b -> a -> b) -> b -> [a] -> [b]\n    {- Arity: 3, HasNoCafRefs, Strictness: LLL -}\nvectorised variables:\nvectorised tycons:\nvectorised reused tycons:\nscalar variables:\nscalar tycons:\ntrusted: safe-inferred\nrequire own pkg trusted: False\n```\n\n\nand see that the interface file doesn't expose the unfolding of the function, only its type, arity, strictness and that it doesn't refer to CAFs.\n\nWhen a module importing that is compiled, all that the compiler has to go by is the information exposed by the interface file.\n\nHere, there is no information exposed that would allow the compiler to do anything else but emit a call to the function.\n\nIf the unfolding were exposed, the compiler had a chance to inline the unfolding and analyse the code knowing the types and combination function to produce more eager code that doesn't build thunks.\n\nThe semantics of ```\nscanl```\n, however, are maximally lazy, each element of the output is emitted before the input list is inspected. That has the consequence that GHC can't make the addition strict, since that would change the result if the list contained any undefined values:\n\n```\nscanl (+) 1 [undefined] = 1 : scanl (+) (1 + undefined) [] = 1 : (1 + undefined) : []\n```\n\n\nwhile\n\n```\nscanl' (+) 1 [undefined] = let x' = 1 + undefined in x' `seq` 1 : scanl' (+) x' []\n                         = *** Exception: Prelude.undefined\n```\n\n\nOne could make a variant\n\n```\nscanl'' f b (x:xs) = b `seq` b : scanl'' f (f b x) xs\n```\n\n\nthat would produce ```\n1 : *** Exception: Prelude.undefined```\n for the above input, but any strictness would indeed change the result if the list contained undefined values, so even if the compiler knew the unfolding, it couldn't make the evaluation strict - unless it could prove that there are no undefined values in the list, a fact that is obvious to us, but not the compiler [and I don't think it would be easy to teach a compiler recognize that and be able to prove the absence of undefined values].\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence logic in Python [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to write the Fibonacci Sequence?\r\n                            \r\n                                (67 answers)\r\n                            \r\n                    \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nA tutorial I am going through had the following program\n\n```\n# This program calculates the Fibonacci sequence\na = 0\nb = 1\ncount = 0\nmax_count = 20\nwhile count < max_count:\n    count = count + 1\n    old_a = a    # we need to keep track of a since we change it\n    print(old_a,end=\" \")   # Notice the magic end=\" \" in the print function arguments that\n                           # keeps it from creating a new line\n    a = b\n    b = old_a + b\nprint() # gets a new (empty) line\n```\n\n\nThe code is perfect. However, I am not able to figure out how the sequence is calculated.\nHow are the values changed to create the sequence?\n    ", "Answer": "\r\nIt'll make more sense if you remove all of that extraneous code:\n\n```\nwhile count < max_count:\n    old_a = a\n    a = b\n    b = old_a + b\n```\n\n\nThe ```\nold_a```\n is probably confusing you. It's the long way of writing this:\n\n```\na, b = b, a + b\n```\n\n\nWhich swaps ```\na```\n with ```\nb```\n and (at the same time), ```\nb```\n with ```\na + b```\n. Note that it isn't the same as writing:\n\n```\na = b\nb = a + b\n```\n\n\nBecause by the time you re-define ```\nb```\n, ```\na```\n already holds its new value, which is equal to ```\nb```\n.\n\nI'd also run through the code manually by writing it out on paper.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "I need an explanation for the Fibonacci Sequence in a lambda expression\r\n                \r\n```\nStream.iterate(new Long[] {0L, 1L}, p -> new Long[] {p[1], p[0]+p[1]}).map(p -> p[0]);\n```\n\nCan someone explain the logic of this lambda expression to me?\nI'm trying to mentally debug the Fibonacci Sequence in a lambda expression but I'm really not getting it. There's no useful reason, I really just want to understand for my own learning, I'm learning lambda expressions in college (I wrote this code by myself and I still don't understand it)\nI know there are better ways to do this, but I want to understand the logic that I accidentally did and it worked\n    ", "Answer": "\r\nStream.iterate() takes an initial seed (here, the long array of ```\n{0,1}```\n) and a UnaryOperator.\nAfter setting the seed to the long array of ```\n{0,1}```\n, each subsequent iterative invocation of the ```\nUnaryOperator```\n creates a ```\nnew long array```\n using the values of the previous array as follows:\n\nsets new ```\np[0]```\n to previous ```\np[1]```\n.\nand  sets new ```\np[1]```\n to sum of previous ```\np[0]```\n + previous ```\np[1]```\n.\nit then maps to ```\np[0]```\n to get that value as the desired term\n\nIf you run the following you can see how it prints the successive creations of the array and the mapped value.\n```\nStream.iterate(new Long[]{0L,1L}, p -> new Long[]{p[1],p[0] + p[1]})\n       .limit(10)\n       .peek(arr -> System.out.print(\"p=\"+Arrays.toString(arr) + \" --> \"))\n       .map(p -> \"p[0] = \"+p[0]).forEach(System.out::println);\n```\n\nprints\n```\np=[0, 1] --> p[0] = 0\np=[1, 1] --> p[0] = 1\np=[1, 2] --> p[0] = 1\np=[2, 3] --> p[0] = 2\np=[3, 5] --> p[0] = 3\np=[5, 8] --> p[0] = 5\np=[8, 13] --> p[0] = 8\np=[13, 21] --> p[0] = 13\np=[21, 34] --> p[0] = 21\np=[34, 55] --> p[0] = 34\n\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "F# Recursive function using match to create a Fibonacci sequence\r\n                \r\nI have attempted to make a recursive function that utilizes match to create a Fibonacci sequence.  I got Euler2 to work, but in Euler2a I'm trying to have the entire function self-contained except for the iteration constraint, j.\nHow must Euler2a change in order for it to provide the sequence?\nAny pointers are most appreciated.  :)\nThe results from Euler2\n\nval Euler2 :    list:int list -> i:int -> j:int -> int list\nval z :         int list = [1; 2; 3; 5; 8; 13; 21; 34; 55; 89]\n\nThe results from Euler2a\n\nval Euler2a :   j:int -> (int list -> int -> int -> int list)\nval z2 :        (int list -> int -> int -> int list)\n\nEuler2\n```\nlet rec Euler2 (list: int list) i j =\n    match i with\n    | 1 | 2         ->  Euler2 list (i+1) j\n    | _ when (i<=j) ->  let newList = list @ [list.[list.Length - 1] + list.[list.Length - 2]]\n                        Euler2 newList (i+1) j\n    | _             ->  list\n\nlet z = Euler2 [1;2] 1 10\n```\n\nEuler2\n```\nlet rec Euler2a (j:int) =\n    let i = 1\n    let list = [1;2]\n    let rec Euler2b (list: int list) i j =\n        match i with\n        | 1 | 2         ->  Euler2b list (i+1) j\n        | _ when (i<=j) ->  let newList = list @ [list.[list.Length - 1] + list.[list.Length - 2]]\n                            Euler2b newList (i+1) j\n        | _             ->  list\n    Euler2b\n\nlet z2 = Euler2a 10\n```\n\n    ", "Answer": "\r\nYour Euler2a returns the value ```\nEuler2b```\n which is a function that takes a list and 2 integer arguments.  You need to actually supply the arguments by changing the line from\n\n```\nEuler2b\n```\n\n\nto\n\n```\nEuler2b list i j\n```\n\n\nso that the arguments are supplied to the function.  Then everything works.    \n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence only works within a while loop, and not \"for\" loop [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions concerning problems with code you've written must describe the specific problem — and include valid code to reproduce it — in the question itself. See SSCCE.org for guidance.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\n```\nstd::cout << \"How many fibonacci numbers do you wish to calculate\" << std::endl;\nint amount = 0;\nstd::cin >> amount;\n\nint num1 = 0;\nint num2 = 1;\n\n\nwhile(true){\nfor(int i = 0; i < amount; ++i){\n    std::cout << num1 + num2 << std::endl;\n\n    int Num2Temp = num2;\n    num2 = num1 + num2;\n    num1 = Num2Temp;\n}\n}\n```\n\n\nThe above code works exactly the way I want it. However, when I take away the while loop and leave in the for loop to loop by itself; the code stops working. The numbers printed just go up by 1 , and doesn't produce the fibonacci sequence that I wanted. \nI know there's an infinite loop with the true. However, I just wanted to know why the for loop only doesn't work. Which is the one I originally wrote.\n\nHere is the code that does not work:\n\n```\n    std::cout << \"How many fibonacci numbes do you wish to calculate\" << std::endl;\nint amount = 0;\nstd::cin >> amount;\n\nint num1 = 0;\nint num2 = 1;\n\nfor(int i = 0; i < amount; ++i){\n    std::cout << num1 + num2 << std::endl;\n\n    int Num2Temp = num2;\n    num2 = num1 + num2;\n    num1 = Num2Temp;\n}\n```\n\n\nOutput:\nHow many fibonacci numbes do you wish to calculate\n3 //I want to calculate up to 3, is user input\n\n1\n2\n3\n    ", "Answer": "\r\nYour output is to be expected for only 3 iterations.\n\nthe first Fibonacci numbers are (1), 1, 2, and 3\n\ntry running for more than 5 iterations, the one after ```\n3```\n should be ```\n5```\n and then ```\n8```\n after that\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Find/store the first 50 terms of the Fibonacci sequence via Looping\r\n                \r\nI am trying find and store the first 50 elements of the Fibonacci Sequence into an array by looping.  I am quite new to Python and I can't get past this point, I am very frustrated that I can't figure out how to do this.\n\nMy code so far:\n\n```\nx=51\n def Fibonacci(x):\n    First_Value=0\n    Second_Value=1\n    for i in range(x):\n        Next_value = First_Value\n        First_Value = Second_Value\n        Second_Value = Next_value + Second_Value\n    return Fist_Value\"\n```\n\n\nBut I can't figure out how to print this in an array where I have to show the first 50 values.\n    ", "Answer": "\r\nYou can define an empty list (or array) at the beginning of the function, and then add to it on every iteration of the for loop. \n\nHere's an example\n\n```\ndef Fibonacci(x):\n    fib_array = [None]*x\n    First_Value=0\n    Second_Value=1\n    for i in range(x):\n        Next_value = First_Value\n        First_Value = Second_Value\n        Second_Value = Next_value + Second_Value\n        fib_array[i] = First_Value\n    return fib_array\n\nFibonacci(10)\n```\n\n\nOutput\n\n```\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence calculator seems correct but can't find similar code online. Is there something wrong?\r\n                \r\nI made a simple Fibonacci sequence calculator for the first 22 terms:\n\n```\ni=1\nn=0\nwhile i<=20000:\n    i = i + n\n    n = i - n\n    print(i)\n```\n\n\nLooks like the result is correct\n\n```\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n4181\n6765\n10946\n17711\n28657\n```\n\n\nbut I can't seem to find similar code anywhere online. I think that's a big red flag. Can someone tell me what is wrong here? Is this inefficient code?\n    ", "Answer": "\r\nNo, that code is fine. The probable reason you can't find similar code online is that it's unusual to use the subtraction operator in Fibonacci, which is a purely additive function, ```\ntn = tn-2 + tn-1```\n.\n\nIt works, of course, since addition/subtraction is both commutative and associative, meaning that order and grouping of terms is unimportant:\n\n```\ni = i + n  # iNew = iOld + nOld\n\nn = i - n  # nNew = (iNew)        - nOld\n           #      = (iOld + nOld) - nOld\n           #      = iOld + (nOld  - nOld)\n           #      = iOld + (0)\n           #      = iOld\n```\n\n\nUse of subtraction allows you to bypass needing a third variable, which would be something like this in a lesser language than Python:\n\n```\nnextN = i + n\ni = n\nn = nextN\n```\n\n\nIn Python, you don't actually need that since you can use tuple assignment such as:\n\n```\n(n, i) = (i, n + i)\n```\n\n\nWith that, everything on the right of the ```\n=```\n is evaluated before any assignments to the left.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "MIPS Recursive Fibonacci Sequence\r\n                \r\nI'm having trouble dealing with stacks recursively in MIPS. I get the concept, but my program isn't reacting as I mean it to.\n\nMy goal is to take user input as n and print the Fibonacci number at n. What I have so far is below.\n\n(I'm fairly certain the problem is in the actual calculation of the number in the fib function.) Thanks for any help! :)\n\n```\n.text\nmain:\n# Prompt user to input non-negative number\nla $a0,prompt\nli $v0,4\nsyscall\nli $v0,5\nsyscall\nmove $t2,$v0\n\n\n# Call function to get fibonnacci #n\nmove $a0,$t2\nmove $v0,$t2\njal fib\nmove $t3,$v0\n\n# Output message and n\nla $a0,result\nli $v0,4\nsyscall\nmove $a0,$t2\nli $v0,1\nsyscall\nla $a0,result2\nli $v0,4\nsyscall\nmove $a0,$t3\nli $v0,1\nsyscall\nla $a0,endl\nli $v0,4\nsyscall\n\n# End program\nli $v0,10\nsyscall\n\nfib:\n# Compute and return fibonacci number\nbeqz $a0,zero\nbeq $a0,1,one\nsub $sp,$sp,4\nsw $ra,0($sp)\nsub $a0,$a0,1\n\njal fib\n\nlw $ra,0($sp)\nadd $sp,$sp,4\nsub $t8,$v0,2 # n - 2\nsub $t9,$v0,1 # n - 1\nadd $v0,$t8,$t9 # add n-2,n-1\njr $ra # decrement/next in stack\n\nzero:\nli $v0,0\njr $ra\none:\nli $v0,1\njr $ra\n\n.data\nprompt: .asciiz \"Enter a non-negative number: \"\nresult: .asciiz \"F_\"\nresult2: .asciiz \" = \"\nendl: .asciiz \"\\n\"\n```\n\n\nExample runs:\n\n```\nEnter a non-negative number: 5\nF_5 = -29\n\nEnter a non-negative number: 6\nF_6 = -61\n```\n\n\nCorrect runs:\n\n```\nEnter a non-negative number: 5\nF_5 = 5\n\nEnter a non-negative number: 6\nF_6 = 8\n```\n\n    ", "Answer": "\r\nHere is a properly working code:\n\n```\n.text\nmain:\n# Prompt user to input non-negative number\nla $a0,prompt   \nli $v0,4\nsyscall\n\nli $v0,5    #Read the number(n)\nsyscall\n\nmove $t2,$v0    # n to $t2\n\n# Call function to get fibonnacci #n\nmove $a0,$t2\nmove $v0,$t2\njal fib     #call fib (n)\nmove $t3,$v0    #result is in $t3\n\n# Output message and n\nla $a0,result   #Print F_\nli $v0,4\nsyscall\n\nmove $a0,$t2    #Print n\nli $v0,1\nsyscall\n\nla $a0,result2  #Print =\nli $v0,4\nsyscall\n\nmove $a0,$t3    #Print the answer\nli $v0,1\nsyscall\n\nla $a0,endl #Print '\\n'\nli $v0,4\nsyscall\n\n# End program\nli $v0,10\nsyscall\n\nfib:\n# Compute and return fibonacci number\nbeqz $a0,zero   #if n=0 return 0\nbeq $a0,1,one   #if n=1 return 1\n\n#Calling fib(n-1)\nsub $sp,$sp,4   #storing return address on stack\nsw $ra,0($sp)\n\nsub $a0,$a0,1   #n-1\njal fib     #fib(n-1)\nadd $a0,$a0,1\n\nlw $ra,0($sp)   #restoring return address from stack\nadd $sp,$sp,4\n\n\nsub $sp,$sp,4   #Push return value to stack\nsw $v0,0($sp)\n#Calling fib(n-2)\nsub $sp,$sp,4   #storing return address on stack\nsw $ra,0($sp)\n\nsub $a0,$a0,2   #n-2\njal fib     #fib(n-2)\nadd $a0,$a0,2\n\nlw $ra,0($sp)   #restoring return address from stack\nadd $sp,$sp,4\n#---------------\nlw $s7,0($sp)   #Pop return value from stack\nadd $sp,$sp,4\n\nadd $v0,$v0,$s7 # f(n - 2)+fib(n-1)\njr $ra # decrement/next in stack\n\nzero:\nli $v0,0\njr $ra\none:\nli $v0,1\njr $ra\n\n.data\nprompt: .asciiz \"This program calculates Fibonacci sequence with recursive functions.\\nEnter a non-negative number: \"\nresult: .asciiz \"F_\"\nresult2: .asciiz \" = \"\nendl: .asciiz \"\\n\"\n```\n\n\nHope to be usefull\n\nAdel Zare\n\nadel.zare.63 [at] gmail [dot] com\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why does BigInteger end up with StackOverflowError in Java at 19635th the integer in Fibonacci Sequence\r\n                \r\nI used the following code to calculate the Fibonacci sequence out to an arbitrarily large digit. The code worked as expected until I asked it to call the function 4,000,000 times (previously I only did a few hundred) and the computer ran for a little while, then the console in Eclipse generated the exceptions which I pasted below the code. \n\nMy question is what happened here exactly? Did my computer run completely out of memory or memory allocated to the thread? If so, why did it stop at this digit specifically? \n\nAdditional: How would I calculate further digits of the Fibonacci Sequence? \n\n```\nimport java.math.BigInteger;\n\npublic class fibonacci2 {\n\npublic static void main(String[] args) {\n\n    calculate(p,q);\n\n}\nstatic long i = 0;\nstatic BigInteger p = BigInteger.valueOf(0);\nstatic BigInteger q = BigInteger.valueOf(1);\nstatic BigInteger temp = BigInteger.valueOf(1);\n\npublic static void calculate(BigInteger s,BigInteger t){\n    while(i<4000000){       \n        System.out.printf(\"%d\\t%d\\n\", p, i);\n        temp = p;\n        p = p.add(q);\n        q = temp;\n        i++;\n        calculate(p,q);\n        }\n    }\n\n}\n```\n\n\nExceptions:\n\n```\nException in thread \"main\" java.lang.StackOverflowError\n    at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3715)\n    at java.util.regex.Pattern$GroupHead.match(Pattern.java:4556)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4502)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4500)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4500)\n    at java.util.regex.Pattern$BranchConn.match(Pattern.java:4466)\n    at java.util.regex.Pattern$GroupTail.match(Pattern.java:4615)\n    at java.util.regex.Pattern$Curly.match0(Pattern.java:4177)\n    at java.util.regex.Pattern$Curly.match(Pattern.java:4132)\n    at java.util.regex.Pattern$GroupHead.match(Pattern.java:4556)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4502)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4500)\n    at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3715)\n    at java.util.regex.Pattern$Start.match(Pattern.java:3408)\n    at java.util.regex.Matcher.search(Matcher.java:1199)\n    at java.util.regex.Matcher.find(Matcher.java:618)\n    at java.util.Formatter.parse(Formatter.java:2517)\n    at java.util.Formatter.format(Formatter.java:2469)\n    at java.io.PrintStream.format(PrintStream.java:970)\n    at java.io.PrintStream.printf(PrintStream.java:871)\n    at fibonacci2.calculate(fibonacci2.java:19)\n    at fibonacci2.calculate(fibonacci2.java:24)\n```\n\n\nLast Digit Generated:   19635 - Quite a large number.\n\n132687895548902466181366635978648936386259759626784159198471844113368720762558998439244647213670836266002193258488843538717586491362100768690744948872614655533963444005758146274483789445525832018171591705801097245938131666262491251573046333399064124825294626375827326373349437140811166679924860265434837435457566510346823522099708782762283340421872152967954697149679070291775852559319530410970741909107854532260299713987604089848331720784324541846051983900879941503950602855721502515831654718683894999456728434816859475155877430343774997661435320771926617215280039933599972465309345254567178339436280952174619541825862884767075607549690650640847821947665184588889102910848010077578318155209477877401207558117424629193877673216227666300792666026188581069615968439885076613046674989223796136897853735065950338488718459072802993894034602966485409833232527607580300466868397366391196516624465562328897666935339268449377325653828646145985110998531659421856703633111062016650375200285896034594800936872091294839900191091698699722026536243666478579994343910947620181792632830778710190311139396156735880074125397511408966605505552422864103569572257613749591889214289715689869250327711408697220359084539413697662799047739270265811002163302937592845234417596161934244642557769201791982828989296516960843921418505825929942814213639292708769436360663239620071203876284640114617617407623573142799950934154067036543593696242108211895742765733512094057256880955310857577903859564579056746531798738498941813073521535219704445493818404188856023980301868618516469829419121757591230096104147125384637901683811153945850319934065084792517083004130890910462024025472721271948569599123360701230540009715282093017067167999678658635663087411610488550002425545947760514500156025301308306327998659164369104269073668157017876181974674317395355412084217340614118259465040019942533175911244270084308389583553447943104546514782390571844604018802721936904404474688189087095735594169734604764561595142228281276547574197914091694854554413589159098499442131625356509906287285672050080215052926747681492642423016441535060701812422382650607369780485598683879561606185899006941448935168420562235626599835745827700295226714246314734017810402964725369860652473776199131459371207950362024398152881453713163784066208042563543662925682842776015262230520391615679652089970517416773429690840845145299626705629719042357249513002595223367277901469344821405379464226668034873875307681491568655204909774495913318375555411759980733171712799322946052444470529341466911138600782570876081467456539333314140771233788511026610245435362670217650351862005123494882440312897401664665221934387408681977959790208001158782272459157216112763316198348542078709999150647564964914134863576486661123746003816160948281150545905672098416477331230622651937768742259299137290941586718911557287342694235083529941819644830145463692894576389371194864252193944417249897576680296390036537160332193922853706900504472769773990832173851162215971909022315739548513111748800103501077095982227131161490400275473107114332912752011610992580490036511357042388077219595501595468366432307357375880006328534616109858423036370917076730066512411190813621221988225618801514574381383356699324113692094796970907449469370840049016526662652443809582291319790185342414255291466570332572158841433975328662164311338016851917370479429992007019036364259295950990281576909594760700939581856439476140480808306810823166903862127117572512965716293308583147623766349722954222044113540493984352460455112546555172777189839005308333201885114142111466980905352254535229665410122041438242484536491005787248286883103481601236212094585289510473442558333280384128931643793870559016908029727399281143275162091549243434338130582159038730877484562313951468088162467051046285384314515884048806797355786962180264599960373185136442715557997632215843672184608917328982657966403817121847386761897944779500570824073280196574484365145711215918884480648724038858502746307173620602683682907969598382920518177738917655303213381000153176621747937338966968659109054686337516427263532942648787865802396994723787388617964385931023490\n    ", "Answer": "\r\nThis has nothing to do with ```\nBigInteger```\n, this is happening because your ```\ncalculate()```\n method is calling itself.  Once you've gotten your call stack deep enough, you run out of memory and the JVM throws the ```\nStackOverflowError```\n.\n\nYou don't have any sort of termination condition in your ```\ncalculate()```\n method.  Each time you enter the ```\nwhile```\n loop, you kick off another call.\n\nIn fact, it seems like you are trying to solve this both iteratively and recursively at the same time.\n\nYou shouldn't need both a while loop and a recursive call in your code.  It looks to me like if you just take out the call to ```\ncalculate()```\n your program will work just fine:\n\n```\npublic static void calculate(BigInteger s, BigInteger t) {\n    while (i < 4000000) {\n        System.out.printf(\"%d\\t%d\\n\", p, i);\n        temp = p;\n        p = p.add(q);\n        q = temp;\n        i++;\n        // calculate(p, q); // you don't need this\n    }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence calculation in Python [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 8 months ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI tried to do a function that builds the Fibonacci series but when I try to check the calculation comes out wrong\n```\ndef fibo(n):\n    i=1\n    j=1\n    for n in range(1,n):\n        j=j+i\n        i=j+i\n    return i+j\nn=input('Enter number:')\nprint(fibo(int(n)))\n```\n\n    ", "Answer": "\r\n```\ni, j = 1, 1\nfor _ in range(n):\n    j = j + i\n    i = j + i\n```\n\nThis is not the fibonacci sequence. Instead, try:\n```\ni, j = 1, 1\nfor _ in range(n):\n    i, j = j, i+j\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "(C++) Program to print all prime numbers in the a Fibonacci sequence\r\n                \r\ncan someone help me out? I've been trying to get this program to print and add all prime numbers in the Fibonacci Sequence below 1000. Just typing the regular Fibonacci code works fine and will list the numbers 1 - 987.\nHowever, the moment I put in a prime number checker it all of a sudden stops at 5 (printing \"1 1 2 3 5\" which is technically correct since they all fall under what a prime is (though 1 doesn't count). However I'm looking to see ALL prime numbers from 1 - 987 in the sequence, and no matter what I do I can't seem to get it to work.\nMy code's down below, don't mind the lack of a main function, I'm making this function as a part of a bigger program, but it can stand on its own. Currently testing it by just calling it in the main function.\n```\n#include <iostream>\n\nusing namespace std;\n\nvoid primethousand() {\n    int fibo = 1;\n    int nacci = 1;\n    int fibonacci = 0;\n    int fibosum = 0; //used to get the sum of all printed numbers later, once this issue is fixed.\n    int pchk = 0; /*primecheck, used to check if a number is a prime or not. 1 means not prime, 0 means prime*/\n\n    cout << \"\\nPrime Fibonacci #s under 1000: \\n\\n\";\n\n    for (int ctr = 1; fibonacci < 987; ctr++) {\n\n        if (ctr == 1) {\n            cout << fibo << \" \";\n            continue;\n        } else if (ctr == 2) {\n            cout << nacci << \" \";\n            continue;\n        }\n\n        fibonacci = fibo + nacci;\n        fibo = nacci;\n        nacci = fibonacci;\n\n        //cout << fibonacci << \" \";\n        for (int chr = 2; chr < fibonacci; chr++) {\n            if (fibonacci % chr == 0) {\n                pchk = 1;\n            }\n        }\n\n        if (pchk == 0) {\n            cout << fibonacci << \" \";\n        }\n\n    }\n}\n```\n\n    ", "Answer": "\r\nIt looks like once pchk is set to 1, you never set it back to zero, so further primes are never noticed..\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why does BigInteger end up with StackOverflowError in Java at 19635th the integer in Fibonacci Sequence\r\n                \r\nI used the following code to calculate the Fibonacci sequence out to an arbitrarily large digit. The code worked as expected until I asked it to call the function 4,000,000 times (previously I only did a few hundred) and the computer ran for a little while, then the console in Eclipse generated the exceptions which I pasted below the code. \n\nMy question is what happened here exactly? Did my computer run completely out of memory or memory allocated to the thread? If so, why did it stop at this digit specifically? \n\nAdditional: How would I calculate further digits of the Fibonacci Sequence? \n\n```\nimport java.math.BigInteger;\n\npublic class fibonacci2 {\n\npublic static void main(String[] args) {\n\n    calculate(p,q);\n\n}\nstatic long i = 0;\nstatic BigInteger p = BigInteger.valueOf(0);\nstatic BigInteger q = BigInteger.valueOf(1);\nstatic BigInteger temp = BigInteger.valueOf(1);\n\npublic static void calculate(BigInteger s,BigInteger t){\n    while(i<4000000){       \n        System.out.printf(\"%d\\t%d\\n\", p, i);\n        temp = p;\n        p = p.add(q);\n        q = temp;\n        i++;\n        calculate(p,q);\n        }\n    }\n\n}\n```\n\n\nExceptions:\n\n```\nException in thread \"main\" java.lang.StackOverflowError\n    at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3715)\n    at java.util.regex.Pattern$GroupHead.match(Pattern.java:4556)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4502)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4500)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4500)\n    at java.util.regex.Pattern$BranchConn.match(Pattern.java:4466)\n    at java.util.regex.Pattern$GroupTail.match(Pattern.java:4615)\n    at java.util.regex.Pattern$Curly.match0(Pattern.java:4177)\n    at java.util.regex.Pattern$Curly.match(Pattern.java:4132)\n    at java.util.regex.Pattern$GroupHead.match(Pattern.java:4556)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4502)\n    at java.util.regex.Pattern$Branch.match(Pattern.java:4500)\n    at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3715)\n    at java.util.regex.Pattern$Start.match(Pattern.java:3408)\n    at java.util.regex.Matcher.search(Matcher.java:1199)\n    at java.util.regex.Matcher.find(Matcher.java:618)\n    at java.util.Formatter.parse(Formatter.java:2517)\n    at java.util.Formatter.format(Formatter.java:2469)\n    at java.io.PrintStream.format(PrintStream.java:970)\n    at java.io.PrintStream.printf(PrintStream.java:871)\n    at fibonacci2.calculate(fibonacci2.java:19)\n    at fibonacci2.calculate(fibonacci2.java:24)\n```\n\n\nLast Digit Generated:   19635 - Quite a large number.\n\n132687895548902466181366635978648936386259759626784159198471844113368720762558998439244647213670836266002193258488843538717586491362100768690744948872614655533963444005758146274483789445525832018171591705801097245938131666262491251573046333399064124825294626375827326373349437140811166679924860265434837435457566510346823522099708782762283340421872152967954697149679070291775852559319530410970741909107854532260299713987604089848331720784324541846051983900879941503950602855721502515831654718683894999456728434816859475155877430343774997661435320771926617215280039933599972465309345254567178339436280952174619541825862884767075607549690650640847821947665184588889102910848010077578318155209477877401207558117424629193877673216227666300792666026188581069615968439885076613046674989223796136897853735065950338488718459072802993894034602966485409833232527607580300466868397366391196516624465562328897666935339268449377325653828646145985110998531659421856703633111062016650375200285896034594800936872091294839900191091698699722026536243666478579994343910947620181792632830778710190311139396156735880074125397511408966605505552422864103569572257613749591889214289715689869250327711408697220359084539413697662799047739270265811002163302937592845234417596161934244642557769201791982828989296516960843921418505825929942814213639292708769436360663239620071203876284640114617617407623573142799950934154067036543593696242108211895742765733512094057256880955310857577903859564579056746531798738498941813073521535219704445493818404188856023980301868618516469829419121757591230096104147125384637901683811153945850319934065084792517083004130890910462024025472721271948569599123360701230540009715282093017067167999678658635663087411610488550002425545947760514500156025301308306327998659164369104269073668157017876181974674317395355412084217340614118259465040019942533175911244270084308389583553447943104546514782390571844604018802721936904404474688189087095735594169734604764561595142228281276547574197914091694854554413589159098499442131625356509906287285672050080215052926747681492642423016441535060701812422382650607369780485598683879561606185899006941448935168420562235626599835745827700295226714246314734017810402964725369860652473776199131459371207950362024398152881453713163784066208042563543662925682842776015262230520391615679652089970517416773429690840845145299626705629719042357249513002595223367277901469344821405379464226668034873875307681491568655204909774495913318375555411759980733171712799322946052444470529341466911138600782570876081467456539333314140771233788511026610245435362670217650351862005123494882440312897401664665221934387408681977959790208001158782272459157216112763316198348542078709999150647564964914134863576486661123746003816160948281150545905672098416477331230622651937768742259299137290941586718911557287342694235083529941819644830145463692894576389371194864252193944417249897576680296390036537160332193922853706900504472769773990832173851162215971909022315739548513111748800103501077095982227131161490400275473107114332912752011610992580490036511357042388077219595501595468366432307357375880006328534616109858423036370917076730066512411190813621221988225618801514574381383356699324113692094796970907449469370840049016526662652443809582291319790185342414255291466570332572158841433975328662164311338016851917370479429992007019036364259295950990281576909594760700939581856439476140480808306810823166903862127117572512965716293308583147623766349722954222044113540493984352460455112546555172777189839005308333201885114142111466980905352254535229665410122041438242484536491005787248286883103481601236212094585289510473442558333280384128931643793870559016908029727399281143275162091549243434338130582159038730877484562313951468088162467051046285384314515884048806797355786962180264599960373185136442715557997632215843672184608917328982657966403817121847386761897944779500570824073280196574484365145711215918884480648724038858502746307173620602683682907969598382920518177738917655303213381000153176621747937338966968659109054686337516427263532942648787865802396994723787388617964385931023490\n    ", "Answer": "\r\nThis has nothing to do with ```\nBigInteger```\n, this is happening because your ```\ncalculate()```\n method is calling itself.  Once you've gotten your call stack deep enough, you run out of memory and the JVM throws the ```\nStackOverflowError```\n.\n\nYou don't have any sort of termination condition in your ```\ncalculate()```\n method.  Each time you enter the ```\nwhile```\n loop, you kick off another call.\n\nIn fact, it seems like you are trying to solve this both iteratively and recursively at the same time.\n\nYou shouldn't need both a while loop and a recursive call in your code.  It looks to me like if you just take out the call to ```\ncalculate()```\n your program will work just fine:\n\n```\npublic static void calculate(BigInteger s, BigInteger t) {\n    while (i < 4000000) {\n        System.out.printf(\"%d\\t%d\\n\", p, i);\n        temp = p;\n        p = p.add(q);\n        q = temp;\n        i++;\n        // calculate(p, q); // you don't need this\n    }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why does the index for the fibonacci sequence need to be less or equal to 1?\r\n                \r\nFor an assignement, I need to create a code which can display an element ```\nn```\n in the fibonacci sequence. I have already figured out how to do it, you can find my code below, but I just don't get why the index value needs to be below, or equal to ```\n1```\n.\nHere is my code:\n```\nint ft_fibonacci(int index)\n{\n    if (index < 0)\n        return (-1);\n    if (index <= 1)\n        return (index);\n    else\n        return (ft_fibonacci(index - 1) + ft_fibonacci(index - 2));\n}\n```\n\n    ", "Answer": "\r\nAs you should already know, when you write a recursive function, you need to have a base case where you already know the result and can return it, to stop applying recursion.\nThe numbers of the Fibonacci sequence are: 0, 1, 1, 2, 3, 5, 8, 13, 21, [...] and so on. Now, it's pretty clear that the first number is 0. What you have to decide though, is what ```\nindex```\n you want to assign to the first number.\nIn your function, this ```\nif```\n represents your base case:\n```\nif (index <= 1)\n    return (index);\n```\n\nThis will make the function return ```\n0```\n for ```\nindex = 0```\n, and ```\n1```\n for ```\nindex = 1```\n. So, in your case, you are assigning ```\nindex = 0```\n to the first number of the sequence (i.e. you start counting from ```\n0```\n).\nYou need ```\n<= 1```\n because the recursive call is ```\nfib(index -1) + fib(index - 2)```\n, therefore if you do not have two base cases your recursion will never stop. When you reach ```\nindex = 2```\n, your function will call ```\nfib(1) + fib(0)```\n, and those two will return ```\n1```\n and ```\n0```\n respectively, stopping the recursion.\nIf you wanted to start numbering the Fibonacci numbers from 1, then you would have used:\n```\nif (index < 1) // invalid index, should not happen\n    return -1;\nif (index == 2)\n    return 1;\nif (index == 1)\n    return 0;\n```\n\nOr more concisely:\n```\nif (index < 1) // invalid index, should not happen\n    return -1;\nif (index <= 2)\n    return index - 1;\n```\n\n\nAs a rule of thumb, remember that whenever you do not need to deal with negative values (Fibonacci numbers and your indexes cannot be negative), you should use ```\nunsigned```\n types (in this case ```\nunsigned ft_fibonacci(unsigned index)```\n). This would also eliminate the need for your error check ```\nif (n < 0)```\n. You also do not need parentheses around values that are returned.\n```\nunsigned ft_fibonacci(unsigned index)\n{\n    if (index <= 1)\n        return index;\n    else\n        return ft_fibonacci(index - 1) + ft_fibonacci(index - 2);\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence using For Loop [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is not reproducible or was caused by typos. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question was caused by a typo or a problem that can no longer be reproduced. While similar questions may be on-topic here, this one was resolved in a way less likely to help future readers.\r\n                \r\n                    \r\n                        Closed 3 months ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThis qustion is to Write a program that outputs the nth Fibonacci number.\nI dont understand why do we need n-1 in the range()\n```\ndef fib_linear(n: int) -> int:\n    if n <= 1:  # first fibonacci number is 1 \n        return n\n \n    previousFib = 0\n    currentFib = 1\n \n    for i in range(n - 1):  \n        newFib = previousFib + currentFib\n        previousFib = currentFib\n        currentFib = newFib\n \n    return currentFib\n```\n\n    ", "Answer": "\r\nCause you wanna output n-th fibonacci number. If you put \"n\" instead of \"n-1\". Then you'll get n+1-th fibonacci number.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to fix overflow for fibonacci sequence in nasm assembly?\r\n                \r\nI'm an amateur in assembly and one of my assignments is to do a fibonacci sequence based on my user input. So if my user input is 5, the output will go like this\n    0\n    1\n    1\n    2\n    3\nIt is being placed in an array and then the index increases and some arithmetic operation is done to achieve the sequence. The user input is limited to 25, so if user input is to be 25, my output should appear like the above, all the way to the value of 46368. At first, I used al, bl and cl to do the arithmetic stuff, but realizing that 8 bit registers are too small, I changed to 16 bits. \n\nAt some point the number comes out as negative and i do understand that its like because of the sign bit and the number is a signed number\nhow do i make everything unsigned?\nin a way i have already tried to do PRINT_UDEC but at some point of time the number goes back to a small number and doesn't keep adding up\nand i actually had the same thing happen when i was doing coding another program and i used al, which is an 8 bit register so i just changed it to a 16 bit register and it worked\nI tried changing it to 32 bits registers too but it still doesn't work!\nas far as i know(correct me if im wrong) the biggest value of ax can be up to 65536?\nand the 25th number of the fibonacci sequence is 46368 which is still within the range of a 16 bit register.\nhow do i fix the overflow of this?\n\n```\n%include \"io.inc\"\n\nsection .bss\nfibo    resb 26 * 4; reserve an array of 25 uninitialized bytes\nuserInput   resb 4 ; reserve 4 bytes for userInput\n\nsection .text\nglobal _main\n_main:\n    mov ebp, esp ; entry point for correct debugging\n    xor edx, edx ; initializing my secondary index to 0\n    mov eax, 0 ; a = 0\n    mov ebx, 1 ; b = 1\n    mov ecx, 0 ; c = 0\n\n    PRINT_STRING \"Enter a number between 3 and 25 inclusively:\" ;prompt user for integer input\n    NEWLINE\n    GET_DEC 4, userInput ; \n\n    mov edi, userInput ; \n    mov esi, fibo ; \n    call indexInc ; \n    mov edx, 0 ; \n    call printarray ; \n\nindexInc:\n    mov [esi], eax ; moves the a = 0 in the first element of the array\n    inc esi ; increases array index\n    mov [esi], ebx ; moves the b = 1 in the second element of the array\n    inc esi ; increases array index\n    mov edx, 3 ; secondary pointer for comparison purposes\n\nforloop:\n    cmp edx, [userInput] ; \n    jg term ;\n    add ecx, eax ; \n    add ecx, ebx ; \n    mov [esi], ecx ; \n    mov eax, ebx ; \n    mov ebx, ecx ; \n    xor ecx, ecx ; \n    inc esi ; increase array index\n    inc edx ; increase secondary pointer\n    jmp forloop ; \n\nprintarray:\n    cmp edx, [userInput] ; \n    je term ; \n    PRINT_DEC 1, [fibo + edx] ; \n    NEWLINE\n    inc esi ; increase array index\n    inc edx ; increase pointer\n    jmp printarray ; \n\nterm:\n    ret ; terminate program\n```\n\n    ", "Answer": "\r\nTry using ```\nPRINT_DEC 4, [fibo + edx]```\n or ```\nPRINT_UDEC 4, [fibo + edx]```\n.\nJudging from this source.\n\n\n\nNote that assembly lines don't have to terminate with a ```\n;```\n - that's the start of a comment.\nAlso your program flow and coding style are messy: don't share ```\nret```\n across functions unless you are golfing or exploiting some trick.\nJumping forward is harder to follow than jumping back - if possible prefer ```\ndo {} while ();```\n over ```\nwhile () {}```\n.\nGive the labels meaningful names and, if needed, adopt a naming convention that make function labels stand out.\nYou comments are goods.  \n\nI found it easier to follow assembly code (code in general) if it is spatially grouped in logical block - avoiding a wall-of-text effect.\nYou are zeroing registers in two different ways - that's strange at best (suspicious at worst).  \n\nI think you can perform a fibonacci step with just two instructions:\n\n```\nxchg eax, ebx\nadd ebx, eax\n```\n\n\nif ```\neax```\n is ```\nf(n-1)```\n and ```\nebx```\n is ```\nf(n)```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Trying to write a code that will find the sum of the even numbers of the Fibonacci sequence?\r\n                \r\nI'm new to programming and I'm trying to write a program in Python that will find the sum of the even numbers of the numbers below 4,000,000 in the Fibonacci sequence. I'm not sure what I'm doing wrong but nothing will print. Thanks for any help.\n\n```\ndef fib():  \n    listx = []  \n    for x in range(4000000):  \n        if x == 0:  \n            return 1\n        elif x == 1:\n            return 1\n        else:\n            listx.append(fib(x - 1) + fib(x - 2))\n            return listx\n\ndef evens(fib):\n    y = 0\n    for x in fib():\n        if x % 2 == 0:\n            y += x\n        else:\n            continue\n        print (y)\n```\n\n    ", "Answer": "\r\nHere's an approach that uses a generator to keep memory usage to a minimum:\n\n```\ndef fib_gen(up_to):\n    n, m = 0, 1\n    while n <= up_to:\n        yield n\n        n, m = m, n + m\n\ntotal = 0\nfor f in fib_gen(4000000):\n    if f % 2 == 0:\n        total += f\n```\n\n\nAnother option:\n\n```\ndef fib_gen(up_to, filter):\n    n, m = 0, 1\n    while n <= up_to:\n        if filter(n):\n            yield n\n        n, m = m, n + m\n\nsum(fib_gen(4000000, lambda f: f % 2 == 0))  # sum of evens\nsum(fib_gen(4000000, lambda f: f % 2))       # sum of odds\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence that deletes even numbers VBA\r\n                \r\nOver the school holidays I was tasked with creating code that would output the Fibonacci sequence up to a certain number (in this case, the number I was given was 100000). Then, from that, I was ordered with deleting the cells that had even numbers, showing only cells that were odd. I have tried and tried many different method of doing both, but nothing seems to be working for me. Here is the code I was using:\n\n```\nSub fib()\n\nDim x As Long\n\nx = 100000\nRange(\"A1\") = 0\nRange(\"A2\") = 1\n\nDo\n    If Range(\"A\" & Range(\"A\" & Rows.Count).End(xlUp).Row).Value + _\n    Range(\"A\" & Range(\"A\" & Rows.Count).End(xlUp).Row).Offset(-1, 0).Value >= x _\n    Then Exit Sub\n    Range(\"A\" & Range(\"A\" & Rows.Count).End(xlUp).Row).Offset(1, 0).FormulaR1C1 = _\n    \"=R[-1]C+R[-2]C\"\nLoop\n\n        For Each Cell In Range(\"A1:A30\")\n            If Cell.Row Mod 2 = 0 Then\n                Rows(Cell.Row).ClearContents\n            End If\n        Next\nSelection.SpecialCells(xlCellTypeBlanks).Select\nSelection.EntireRow.Delete\n\nEnd Sub\n```\n\n\nNow, I understand there may be a few problems with my code. The main one I see is in the first block, where instead of just inputting the numbers in to the cell, it instead inputs the way it would be calculated (for example, cell A10's value is just given as =A9+A8). I am not sure if this would cause an error in  the second part of the code, where it looks for cell values so it can delete whether it is even. Could I please have some assistance on this matter? It would be much appreciated, as I've been struggling with it for the past few days now. Any help is appreciated! :)\n    ", "Answer": "\r\nTry the code below.\n\n```\nSub fib()\n\nDim x As Long\nDim lRow As Long\n\nx = 100000\nRange(\"A1\") = 0\nRange(\"A2\") = 1\n\nDo\n    If Range(\"A\" & Range(\"A\" & Rows.Count).End(xlUp).Row).Value + _\n    Range(\"A\" & Range(\"A\" & Rows.Count).End(xlUp).Row).Offset(-1, 0).Value >= x _\n    Then Exit Sub\n    Range(\"A\" & Range(\"A\" & Rows.Count).End(xlUp).Row).Offset(1, 0).FormulaR1C1 = _\n    \"=R[-1]C+R[-2]C\"\n\n    Columns(\"A:A\").Select\n    Selection.Copy\n    Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _\n        :=False, Transpose:=False\n\nLoop\n    With ActiveSheet\n\nlRow = WorksheetFunction.Max(Range(\"A65536\").End(xlUp).Row)\n\n    For i = lRow To 2 Step -1\n    If .Cells(i, \"A\") Mod 2 = 0 Then\n      Rows(i).Delete\n    End If\n   Next i\n   End With\n\n\nEnd Sub\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How can I recursively insert the Fibonacci sequence into a binary tree\r\n                \r\nHope someone can help, I'm not a programmer, but have been interested in exploring Fibonacci sequence and it's recursive tree...\n\nI've created a Binary Tree class, along with an associated TreeNode class, and want to generate a binary tree of the recursive calls created by:\n\n\n  f(n) = f(n-1) + f(n-2) for a given value of n\n\n\nI'd want to add it as an InsertFibonacci method of my Binary Tree class, replacing the standard Insert method:\n\n```\ndef insertNode(self, root, inputData):\n    if root == None:\n        return self.addNode(inputData)\n    else:\n        if inputData <= root.nodeData:\n            root.left = self.insertNode(root.left, inputData)\n        else:\n            root.right = self.insertNode(root.right, inputData)\n        return root\n```\n\n\nWould I add somekind of decorator to the Fib function?\n\n```\n# Fib function\ndef f(n):\n\n    def helper(n):\n        left = f(n-1)\n        right = f(n-2)\n        return left,right\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        left, right = helper(n)\n        return left + right\n```\n\n    ", "Answer": "\r\nHere's the simplest solution I can think of:\n\n```\nclass FibTree(object):\n    def __init__(self, n):\n        self.n = n\n        if n < 2:\n            self.value = n\n        else:\n            self.left = FibTree(n - 1)\n            self.right = FibTree(n - 2)\n            self.value = self.left.value + self.right.value\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to multiply matrices using 2D Array on Fibonacci Sequence?\r\n                \r\nThe problem I'm having is that I'm unsure how I can multiply matrices together by the same matrices over and over. What I'm trying to achieve is that I want to be able to update the matrices. Here is my code:\n\n```\nint fib3(int a, int b, int n) {\nint num[2][2] = { {0,1}, {1,1} };\nconst int num2[2][2] = { {0,1}, {1,1} };\nint factArray[2][1] = { {0}, {1} };\nif (n == 0) {\n    return a;\n}\nelse if (n == 1) {\n    return b;\n}\nelse {\n\n    for (int i = 0; i <= n; i++) {\n        num[0][0] = ((num2[0][0] * 0) + num2[0][1] * 1);\n        num[0][1] = ((num2[0][0] * 1) + num2[0][1] * 1);\n        num[1][0] = ((num2[1][0] * 0) + num2[1][1] * 1);\n        num[1][1] = ((num2[1][0] * 1) + num2[1][1] * 1);\n    }\n\n\n    factArray[0][0] = ((num[0][0] * factArray[0][0]) + num[0][1] * factArray[1][0]);\n    factArray[1][0] = ((num[1][0] * factArray[0][0]) + num[1][1] * factArray[1][0]);\n\n    return factArray[0][0];\n}\n```\n\n\nHere I would take the previous matrices and multiply it by a constant matrices, but I am unsure how to update the matrices as I do.\n\nSo the matrices is raised to some power. \n\nSo for example, I want to find f(5) the 5th Fibonacci sequence , which should be 5, and I am getting 1 as the result in the programming.\n    ", "Answer": "\r\nThe formula in matrix representation is mainly of interest for theoretical analysis. The trick is that you can have always two elements of the sequence in the vector instead of having to refer to earlier elements of the sequence. However, to implement it I dont see the benefit compared to using the recursive formula. Condsider that\n\n```\n | 1 1 |   | a |    | a+b |\n | 1 0 | * | b | =  | a   |\n```\n\n\nHence the matrix multiplication effectively does exactly the same: add the last two elements, remeber current one (```\na```\n).  \n\nThat being said, your code has some problems:\n\n\nyou pass ```\na```\n and ```\nb```\n but you only ever use them for the first and second element of the sequence. You dont need ```\na```\n and ```\nb```\n. The initial values are already in the starting value of the matrix.\nyou have a loop, but in each iteration you calculate the same values and write them into the same array elements.\nI cannot really follow the logic of your code. Why is there another multiplication after the loop? The matrix formula says, in a nutshell, \"take some starting vector, apply a matrix ```\nn```\n times, done\". To be honest I cannot find that anywhere in your code ;)\n\n\nIf you insist on using matrix multiplications, I would suggest to stay away from c-style arrays. They don't like to be passed around. Use ```\nstd::array```\n instead. I have a slight aversion against nesting, hence I'd suggest to use\n\n```\nconstexpr size_t N = 2;\nusing matrix = std::array<int,N*N>;\nusing vector = std::array<int,N>;\n```\n\n\n```\nstd::array```\ns can be returned with no pain:\n\n```\nvector multiply(const matrix& a,const vector& b) {\n    vector result;\n    auto ma = [&a](size_t row,size_t col) { return a[row*N+col];};    \n    result[0] = ma(0,0)*b[0] + ma(0,1)*b[1];\n    result[1] = ma(1,0)*b[0] + ma(1,1)*b[1];\n    return result;\n}\n```\n\n\nNow it should be straight-forward to implement the fibonacci sequence. \n\nSpoiler Alert\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Delphi Fibonacci Sequence\r\n                \r\ni have an assignment for school where i have to write code so that i enter the first two terms and the every time i click a certain button the next term is printed on the memo output. But here is the twist, you cannot use if/else statements because they have not been taught to us.\n```\n    implementation\n\n{$R *.dfm}\n\nvar\n  iTerm1, iTerm2: integer;\n  sOutput: String;\n\nprocedure TfrmFibonacciSequence.btnNextTermClick(Sender: TObject);\n  var\n    iTerm3: integer;\n  begin\n    iTerm3 := iTerm1 + iTerm2;\n    memOutput.Text := inttostr(iTerm3);\n    sOutput :=\n  end;\n\nprocedure TfrmFibonacciSequence.btnReadClick(Sender: TObject);\n  begin\n    iTerm1 := strtoint(edtFirst.Text);\n    iTerm2 := strtoint(edtSecond.Text);\n  end;\n\nend.\n```\n\nthat is what i have so far for the two buttons. the read button just reads the two input values(this is what the book wants) and then the next term button prints the next term in the sequence in the memo. i have no idea how i am supposed to keep it going forever and ever... especially without if/else statements.\nplease can someone help me out with this one.\nthank you.\n    ", "Answer": "\r\nYou are very close.\nWhen you click the ```\nNext```\n button, you correctly compute the next value in the sequence: ```\niTerm1 + iTerm2```\n. You put this in ```\niTerm3```\n.\nAnd the next time you click the ```\nNext```\n button, you want to use ```\niTerm2```\n as the first term and this value, ```\niTerm3```\n, as your second. So make sure that will happen:\n```\n// For the next iteration:\niTerm1 := iTerm2;\niTerm2 := iTerm3;\n```\n\nHence,\n```\nprocedure TfrmFibonacciSequence.btnNextTermClick(Sender: TObject);\nvar\n  iTerm3: Integer;\nbegin\n  iTerm3 := iTerm1 + iTerm2;\n  memOutput.Text := IntToStr(iTerm3); // or iTerm3.ToString in modern Delphi\n  // For the next iteration:\n  iTerm1 := iTerm2;\n  iTerm2 := iTerm3;\n  // Maybe you also want to put iTerm1 and iTerm2 in the input edit boxes.\nend;\n```\n\nAlso, I'd recommend you to let your variables be members of your form class. Because otherwise very bad things will happen if you create two or more instances of this form class.\nUpdate\nMore explanation:\nCurrently, your ```\niTerm1```\n and ```\niTerm2```\n are global variables, so if you create two or more instances of ```\nTfrmFibonacciSequence```\n, they will share these variables, and thus will not be able to function independently. It will be extremely confusing. So remove these global variables and instead add ```\niTerm1, iTerm2: Integer```\n to your form class.\n```\ntype\n  TfrmFibonacciSequence = class(TForm)\n    edtFirst: TEdit;\n    edtSecond: TEdit;\n    btnRead: TButton;\n    btnNext: TButton;\n    memOutput: TMemo;\n    procedure btnReadClick(Sender: TObject);\n    procedure btnNextClick(Sender: TObject);\n  private\n    iTerm1, iTerm2: Integer;\n  public\n  end;\n```\n\nThis way, each instance of the class will have their own variables.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence. Time Complexity\r\n                \r\nFirst of all - yes, I know that there are a ton kind of similar questions about this but I still don't get it. \n\nSo the Big-O Notation of this code is O(2^n)\n\n```\n public static int Fibonacci(int n)\n    {\n        if (n <= 1)\n            return n;\n        else\n            return Fibonacci(n - 1) + Fibonacci(n - 2);\n    }\n```\n\n\nAnd even though if I run it using let's say 6 , function is getting called 25 times as you can see in this picture:\n\nFibonacci\nShouldn't it be 64 because of O(2^6) = 64 ?\n    ", "Answer": "\r\nFew issues with the logic here:\n\n\nBig O notation is only giving upper asymptotic bound, not a tight bound, that's what big Theta is for.\nFibonacci is actually ```\nTheta(phi^n)```\n, if you are looking for tighter bound (where ```\nphi```\n is the \"golden ration\", ```\nphi ~= 1.618```\n.\nWhen talking about asymptotic notation, there isn't much point in talking about low numbers, and neglecting the constants - since they are omitted for the asymptotic complexity (This is not the case here though).\n\n\nIn here, the issue is fibonacci is indeed ```\nO(2^n)```\n, but that bound is not tight, so the actual number of calls is going to be lower than the estimated one (for sufficiently large ```\nn```\n, onwards).\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence \"Show the mathematical sequence\"\r\n                \r\nRight now all I got is it generating the fib sequence I want to show the mathematical sequence after the result. ex. 8+13 = 21\n\nHow can I achieve this?\n\nHTML:\n\n```\n<div id=\"genhere\"></div>\n```\n\n\nJavaScript/JQuery:\n\n```\n$(document).ready(function() {\n    console.log = function(message) {\n        $('#genhere').append('<p>' + message + '</p>');\n    };\n\n    console.error = console.debug = console.info = console.log;\n\n    var fib = function(numMax) {\n        for(a=0, b=1, c=0; c<numMax; a=b, b=x, c++){\n            x=a+b;\n            console.log(x);\n        }\n    };\n\n    fib(50);\n});\n```\n\n    ", "Answer": "\r\n```\nconsole.log(a + ' + ' + b + ' = ' + x);\n```\n\n\nHere's the fiddle: http://jsfiddle.net/9Kagz/\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to define the fibonacci sequence using a fold for natural numbers?\r\n                \r\nI am currently learning folds in the sense of structural recursion/catamorphisms. I implemented power and factorial using a fold for natural numbers. Please note that I barely know Haskell, so the code is probably awkward:\n\n```\nfoldNat zero succ = go\n  where\n    go n = if (n <= 0) then zero else succ (go (n - 1))\n\npow n = foldNat 1 (n*)\n\nfact n = foldNat 1 (n*) n\n```\n\n\nNext I wanted to adapt the fibonacci sequence:\n\n```\nfib n = go n (0,1)\n  where\n    go !n (!a, !b) | n==0      = a\n                   | otherwise = go (n-1) (b, a+b)\n```\n\n\nWith ```\nfib```\n I have a pair as second argument whose fields are swapped at each recursive call. I am stuck at this point, because I don't understand the mechanics of the conversion process.\n\n[EDIT]\n\nAs noted in the comments my ```\nfact```\n function is wrong. Here is a new implementation based on a paramorphism (hopefully):\n\n```\nparaNat zero succ = go \n  where \n    go n = if (n <= 0) then zero else succ (go (n - 1), n)\n\nfact = paraNat 1 (\\(r, n) -> n * r)\n```\n\n    ", "Answer": "\r\nLet the types guide you. Here is your ```\nfoldNat```\n, but with a type signature:\n\n```\nimport Numeric.Natural\n\nfoldNat :: b -> (b -> b) -> Natural -> b\nfoldNat zero succ = go\n  where\n    go n = if (n <= 0) then zero else succ (go (n - 1))\n```\n\n\nHaving another look at the ```\ngo```\n helper in your implementation of ```\nfib```\n, we can note the recursive case takes and returns a ```\n(Natural, Natural)```\n pair. Comparing that with the successor argument to ```\nfoldNat```\n suggests we want ```\nb```\n to be ```\n(Natural, Natural)```\n. That is a nice hint on how the pieces of ```\ngo```\n should fit:\n\n```\nfibAux = foldNat (0, 1) (\\(a, b) -> (b, a + b))\n```\n\n\n(I am ignoring the matter of strictness for now, but I will get back to that.)\n\nThis is not quite ```\nfib```\n yet, as can be seen by looking at the result type. Fixing that, though, is no problem, as Robin Zigmond notes:\n\n```\nfib :: Natural -> Natural\nfib = fst . foldNat (0, 1) (\\(a, b) -> (b, a + b))\n```\n\n\nAt this point, you might want to work backwards and substitute the definition of ```\nfoldNat```\n to picture how this corresponds to an explicitly recursive solution.\n\n\n\nWhile this is a perfectly good implementation of ```\nfib```\n, there is one major difference between it and the one you had written: this one is a lazy right fold (as is the norm for Haskell catamorphisms), while yours was clearly meant as a strict left fold. (And yes, it does make sense to use a strict left fold here: in general, if what you are doing looks like arithmetic, you ideally want strict left, while if it looks like building a data structure, you want lazy right). The good news, though, is that we can use catamorphisms to define pretty much anything that consumes a value recursively... including strict left folds! Here I will use an adapted version of the foldl-from-foldr trick (see this question for a detailed explanation of that in the case of lists), which relies on a function like this:\n\n```\nlise :: (b -> b) -> ((b -> b) -> (b -> b))\nlise suc = \\g -> \\n -> g (suc n)\n```\n\n\nThe idea is that we take advantage of function composition (```\n\\n -> g (suc n)```\n is the same as ```\ng . suc```\n) to do things in the opposite order -- it is as if we swapped ```\nsucc```\n and ```\ngo```\n in the right hand side of your definition of ```\ngo```\n. ```\nlise suc```\n can be used as the successor argument to ```\nfoldNat```\n. That means we will get a ```\nb -> b```\n function in the end rather than a ```\nb```\n, but that is not a problem because we can apply it to the zero value ourselves. \n\nSince we want a strict left fold, we have to sneak in a ```\n($!)```\n to make sure ```\nsuc n```\n is eagerly evaluated:\n\n```\nlise' :: (b -> b) -> ((b -> b) -> (b -> b))\nlise' suc = \\g -> \\n -> g $! suc n\n```\n\n\nNow we can define a strict left fold (it is to ```\nfoldNat```\n what ```\nfoldl'```\n from ```\nData.List```\n is to ```\nfoldr```\n):\n\n```\nfoldNatL' :: b -> (b -> b) -> Natural -> b\nfoldNatL' zero suc n = foldNat id (lise' suc) n zero\n```\n\n\nThere is a final, important detail to deal with: making the fold strict is of little use if we are lazily building a pair along the way, as the pair components will remain being built lazily. We could deal with that by using ```\n($!)```\n along with ```\n(,)```\n for building the pair in the successor function. However, I believe it is nicer to use a strict pair type instead so that we don't have to worry with that:\n\n```\ndata SP a b = SP !a !b \n    deriving (Eq, Ord, Show)\n\nfstSP :: SP a b -> a\nfstSP (SP a _) = a\n\nsndSP :: SP a b -> b\nsndSP (SP _ b) = b\n```\n\n\nThe ```\n!```\n mark the fields as strict (note that you don't need to enable ```\nBangPatterns```\n to use them).\n\nWith everything in place, we can at last have ```\nfib```\n as a strict left fold:\n\n```\nfib' :: Natural -> Natural\nfib' = fstSP . foldNatL' (SP 0 1) (\\(SP a b) -> SP b (a + b))\n```\n\n\n\n\nP.S.: As amalloy notes, your ```\nfac```\n calculates n^n rather than n!. That is probably a matter better left for a separate question; in any case, the gist of it is that factorial is more naturally expressed as a paramorphism on naturals, rather than as a plain catamorphism. (For more on that, see, for instance, the Practical Recursion Schemes blog post by Jared Tobin, more specifically the section about paramorphisms.)\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Visual Basic\r\n                \r\nI have a quick question about another Visual Basic assignment I'm working on. I have all the code and everything has gone smoothly so far. The app is meant to display the first 100 Fibonacci numbers in a list box, adding the two previously displayed numbers to get the next in a loop. The only problem is that when I hit the button to display the code, the loop continues, and doesn't just stop at 100 numbers. Where did I go wrong?\n\n```\nPrivate Sub btnDisplay_Click(sender As Object, e As EventArgs) Handles btnDisplay.Click\n    Dim dblA As Double = 0\n    Dim dblB As Double = 1\n    Dim dblC As Double\n    Dim intCounter As Integer\n\n    lstSequence.Items.Add(dblA.ToString)\n    lstSequence.Items.Add(dblB.ToString)\n\n    For intCounter = 1 To 100\n        dblC = dblA + dblB\n        dblA = dblB\n        dblB = dblC\n        lstSequence.Items.Add(dblC.ToString)\n    Next\nEnd Sub\n```\n\n    ", "Answer": "\r\nI just tried this.  It works fine.\n\n```\nPublic Class Form1\n    Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click\n\n        Dim a As Integer = 0\n        Dim b As Integer = 1\n        Dim fib As Integer\n        Dim userinput, i As Integer\n        userinput = InputBox(\"how many interations?\")\n        i = userinput\n        ListView1.Items.Add(1)\n        Do\n            fib = a + b\n            a = b\n            b = fib\n            ListView1.Items.Add(fib)\n            i = i + 1\n        Loop While fib < i\n\n    End Sub\nEnd Class\n```\n\n\n\n\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Adder Machine - Calculating Digits in Fibonacci Sequence\r\n                \r\nI'm working on a program that will calculate fibonacci numbers with certain digit limitations (i.e. first fibonacci number with 100 digits). The code I have below overall is running, but I am hitting a logical error that has me stumped. \n\nThe goal of the code is to calculate Fibonacci numbers in a fashion similar to binary addition. Using an array, each element is to hold a digit from 0 - 9, so each array index represents a 10's place. \n\nIt starts working and looping through fine, but it gets off between 13 and 21 because of the way the loop is handled. It adds the number sin the 10's place together and then saves a 31 number. \n\nIs there a way to break out or stop it from adding those together that I'm not seeing?\n\n```\nnum1 = [0]*100\nnum2 = [0]*100\nnum2[len(num2)-1] = 1\ncarry = 0\nflag = True\n\nwhile (flag):\n    #Main for loop to work through the array\n    for count in range (1, len(num2)):\n        carry = num2[len(num2) - count] + num1[len(num1) - count]\n        if carry > 9:\n            num2[len(num2)- (count + 1)] = num2[len(num2)- (count + 1)] + 1\n            carry = carry % 10\n            num1[len(num1) - count] = num2[len(num2) - count]\n            num2[len(num2) - count] = carry\n        else:\n            num1[len(num1) - count] = num2[len(num2) - count]\n            num2[len(num2) - count] = carry\n    print(num2)\n    if num2[0] != 0:\n        flag = False\n```\n\n\nEach time it passes the main while loop I'm hoping to see\n\n```\n[0,0,...,0,1]\n[0,0,...,0,2]\n[0,0,...,0,3]\n[0,0,...,0,5]\n[0,0,...,0,8]\n[0,0,...,1,3]\n[0,0,...,2,1]\n...\n```\n\n\nbut after it hits the [...,2,1] loop it moves on to [...,3,1]\n    ", "Answer": "\r\nHere's a bit of a cleaner version of what I believe you're trying to get at.  \n\n```\n#Init of Fib variables \na = 0\nb = 1\nnum = 10  #Change this to the number of fib calculation loops.\nx = 0\noutput_arr_len = 100 #Change this to 10 for testing, as it's easier to see.    \n\nwhile x < num:\n    #Calculate Fib Sequence\n    c = a + b \n    a = b\n    b = c \n    x += 1\n\n    #Output Array\n    print([0] * (output_arr_len - len(str(c))) + [int(i) for i in str(c)])\n```\n\n\nBelow is the output of the first 20 loops with ```\noutput_arr_len```\n set to 10.\n\n```\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 2]\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 3]\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 5]\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 8]\n[0, 0, 0, 0, 0, 0, 0, 0, 1, 3]\n[0, 0, 0, 0, 0, 0, 0, 0, 2, 1]\n[0, 0, 0, 0, 0, 0, 0, 0, 3, 4]\n[0, 0, 0, 0, 0, 0, 0, 0, 5, 5]\n[0, 0, 0, 0, 0, 0, 0, 0, 8, 9]\n[0, 0, 0, 0, 0, 0, 0, 1, 4, 4]\n[0, 0, 0, 0, 0, 0, 0, 2, 3, 3]\n[0, 0, 0, 0, 0, 0, 0, 3, 7, 7]\n[0, 0, 0, 0, 0, 0, 0, 6, 1, 0]\n[0, 0, 0, 0, 0, 0, 0, 9, 8, 7]\n[0, 0, 0, 0, 0, 0, 1, 5, 9, 7]\n[0, 0, 0, 0, 0, 0, 2, 5, 8, 4]\n[0, 0, 0, 0, 0, 0, 4, 1, 8, 1]\n[0, 0, 0, 0, 0, 0, 6, 7, 6, 5]\n[0, 0, 0, 0, 0, 1, 0, 9, 4, 6]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Possible error in very large numbers in the Fibonacci sequence (Python 2.7.6 integer math)\r\n                \r\nEdited to put questions in bold.\n\nI wrote the following Python code (using Python 2.7.6) to calculate the Fibonacci sequence. It doesn't use any extra libraries, just the core python modules.\n\nI was wondering if there was a limit to how may terms of the sequence I could calculate, perhaps due to the absurd length of the resulting integers, or if there would be a point where Python no longer performed the calculations accurately.\n\nAlso, for the fibopt(n) function, it seems to sometimes return the term under the one requested (e. g. 99th instead of 100th) but always works at lower terms (1st, 2nd, 10th, 15th). Why is that?\n\n```\ndef fibopt(n): # Returns term \"n\" of the Fibonacci sequence.\n    f = [0,1] # List containing the first two numbers in the Fibonacci sequence.\n    x = 0 # Empty integer to store the next value in the sequence. Not really necessary.\n    optnum = 2 # Number of calculated entries in the sequence. Starts at 2 (0, 1).\n    while optnum < n: # Until the \"n\"th value in the sequence has been calculated.\n        if optnum % 10000 == 0:\n            print \"Calculating index number %s.\" % optnum # Notify the user for every 10000th value calculated. This is useful because the program can take a very long time to calculate higher values (e. g. about 15 minutes on an i7-4790 for the 10000000th value).\n        x = [f[-1] + f[-2]] # Calculate the next value in the sequence based of the previous two. This could be built into the next line.\n        f.extend(x) # Append that value to the sequence. This could be f.extend([f[-1] + f[-2]]) instead.\n        optnum +=1 # Increment the counter for number of values calculated by 1.\n        del f[:-2] # Remove all values from the table except for the last two. Without this, the integers become so long that they fill 16 GB of RAM in seconds.\n    return f[:n] # Returns the requested term of the sequence.\n\ndef fib(n): # Similar to fibopt(n), but returns all of the terms in the sequence up to and including term \"n\". Can use a lot of memory very quickly.\n    f = [0,1]\n    x = 0\n    while len(f) < n:\n        x = [f[-1] + f[-2]]\n        f.extend(x)\n    return f[:n]\n```\n\n    ", "Answer": "\r\nThe good news is: integer math in Python is easy -- there are no overflows.\n\nAs long as your integers can fit within a C ```\nlong```\n, Python will use that. Once you go past that, it will auto-promote to arbitrary-precision integers (which means it'll be slower and use more memory, but the calculations will remain correct).\n\nThe only limits are:\n\n\nThe amount of memory addressable by the Python process. If you're using 32-bit Python, you need to be able to fit all of your data within 2 gigabytes or RAM (get past that and your program will fail with ```\nMemoryError```\n). If you're using 64-bit Python, your physical RAM + swapfile is the theoretical limit.\nThe time you're willing to wait while calculations are being performed. The larger your ints, the slower the calculations are. If you ever hit your swap space, your program will reach continental drift levels of slow.\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Find the sum of even valued terms in the Fibonacci Sequence(Project Euler)\r\n                \r\nI am attempting problems from Project Euler.net. The problem I am stuck on goes like this.\nBy considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\nI have come up with the following code.\n```\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n\nint main() {\nint a=1,b=1,c,sum=0;\n    while(c<4000000)\n    {\n        c=a+b;\n        if((c%2)==0)\n        sum+=c;\n\n        a=b;\n        b=c;\n    }\n     cout<<sum;\n    return 0;\n}\n```\n\nThe sum returned is always ```\nzero```\n. I have looked at the other solutions on StackOverflow but am not able to understand the problem in my solution. Any help appreciated.\n    ", "Answer": "\r\nYou haven't initialized ```\nc```\n before entering the loop. If it contains something larger than your limit, the loop won't execute, and ```\nsum```\n will remain ```\n0```\n after the loop terminates.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursive and iteration fibonacci\r\n                \r\nI am trying to make it where it prints the recursive part of the code out the same as it prints out the iteration.\nFibonacci sequence in iteration\n\n```\n1\n1\n2\n3\n5\n8\n13\n21\n34\n```\n\n\nThe ending of the fibonacci sequence at 9 is 34\nTime : 1 .     like so , but every time I try a loop to print I get some weird answers, Not really sure what to add to the method.   \n\n```\n    import java.util.Scanner;\n\n    public class fibonacciRecursive {\n\n    public static void main(String[] args) {\n        /*\n         * Dustin Willingham \n         * Class: CSCI 1302 Mon-Wed Cartersville \n         *Lets user enter the last number of a fibonacci sequence\n         *then it takes the number and runs the fibonacci sequence in recursive and iteration method\n         *It outputs the answer for both and the time\n         */\n\n        Scanner in = new Scanner(System.in);\n        System.out.println(\"Enter the number you want the Fibonacci sequence to go to:\");\n        int fibNumb = in.nextInt();\n\n        //Print and timing for the Fibonacci sequence with the Recursive method\n        System.out.println(\"Fibonacci sequence in recursion\");\n        //start of the timer\n        long start = System.currentTimeMillis();\n        System.out.println(\"The ending of the fibonacci sequence at \" + fibNumb + \" is \" + fibonacciRec(fibNumb));\n        System.out.print(\"Time : \");\n        //print out the timer\n        System.out.println(System.currentTimeMillis() - start);\n\n\n\n\n\n        //Print and timing for the Fibonacci sequence with the Iteration method\n        System.out.println(\"\\n\" + \"Fibonacci sequence in iteration\");\n        start = System.currentTimeMillis();\n        System.out.println(\"The ending of the fibonacci sequence at \" + fibNumb + \" is \" + fiboacciIte(fibNumb));\n        System.out.print(\"Time : \");\n        System.out.print(System.currentTimeMillis() - start);\n\n\n        in.close();\n    }\n\n    // Recursive method for the Fibonacci sequence\n    public static int fibonacciRec(int fibNumb) {\n\n\n        if ((fibNumb == 1) || (fibNumb == 0)) {\n            return fibNumb;\n\n\n\n         }\n        int answer = fibonacciRec(fibNumb - 1) + fibonacciRec(fibNumb - 2);\n        return answer;\n    }\n\n    //Iteration method for the Fibonacci sequence\n    static int fiboacciIte(int fibNumb) {\n        int a = 0, b = 1, c = 1;\n        for (int d = 0; d < fibNumb; d++) {\n            a = b;\n            b = c;\n            System.out.println(a);\n            c = a + b;\n        }\n        return a;   \n    }   \n}\n```\n\n    ", "Answer": "\r\nYou could add a separate argument to the recursive function, which gives the highest Fibonacci subscript (```\nfibNumb```\n) reached so far. If the current subscript is greater than this counter, update it and print the current Fibonacci number.\n\nThe counter must be passed by reference as the value will need to be updated before recursion unfolds. We can create a custom class for it:\n\n```\nprivate static class Counter\n{\n    private int value;\n    public Counter() { value = 0; }\n    public int getValue() { return value; }\n    public void increment() { value++; }\n}\n```\n\n\nPass the same instance to each recursive call and increment along the way:\n\n```\nprivate static int fibonacciRec_internal(int fibNumb_cur, Counter fibNumb_max) {\n    int answer = (fibNumb_cur <= 1) ? fibNumb_cur :\n                 fibonacciRec_internal(fibNumb_cur - 1, fibNumb_max) +\n                 fibonacciRec_internal(fibNumb_cur - 2, fibNumb_max);\n    if (fibNumb_max.getValue() < fibNumb_cur) {\n        fibNumb_max.increment();\n        System.out.println(answer);\n    }\n    return answer;\n}\n```\n\n\nAnd finally write a wrapper function to hide this counter class and its usage details:\n\n```\npublic static int fibonacciRec(int fibNumb)\n{\n    Counter max = new Counter();\n    return fibonacciRec_internal(fibNumb, max);\n}\n```\n\n\nResults are as expected:\n\n```\n// fibonacciRec(10);\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n```\n\n\n\n\nEven better, we could create a wrapper class for all of the above, and use the same object for every ```\nfibonacciRec```\n call instead of creating a new one. It's a pretty trivial modification so I'll leave it to you to figure out the what and the how.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "separate 2 digit numbers in fibonacci series\r\n                \r\nI'm trying to separate fibonacci sequence that are 2 digits long but the first digit is giving out zero's\n\n```\n    int[] fib = new int[input];\n    int[] fib2 = new int[input];\n\n    fib[0] = 0;\n    fib[1] = 1;\n    fib2[0] = 0;\n    fib2[1] = 1;\n\nfor (int i = 2; i < input; i++) {               \n            fib[i] = fib[i - 1] + fib[i - 2];  // first fibonnaci sequence to output\n            fib2[i] = fib2[i - 1] + fib2[i - 2];  // second fibonnaci sequence to output\n            fib[i] = separate(fib[i]);  //get the second digit of the fibonacci sequence\n            fib2[i] = separate2(fib2[i]);//get the first digit of the fibonacci sequence but it output zero's\n}\n\n public static int separate(int x) {\n    //int result = x;\n    x = x % 10;\n    return x;\n}\n\npublic static int separate2(int y) {\n    //int result = x;\n    y = y / 10;\n    return y;\n}\n```\n\n\nnormal fibonacci sequence is\n1,1,2,3,5,8,13,21,34,55,89\noutput should be 1,1,2,3,5,8,1,3,2,1,3,4,5,5,8,9\n    ", "Answer": "\r\nTry filling your arrays with the normal sequence before attempting to get single digits\n\n```\nfor (int i = 2; i < input; i++)\n{\n    fib[i] = fib[i - 1] + fib[i - 2];\n    fib2[i] = fib2[i - 1] + fib2[i - 2];\n}\n\nfor (int i = 2; i < input; i++)\n{\n    fib[i] = separate(fib[i]);\n    fib2[i] = separate2(fib2[i]);\n}\n```\n\n\nOr with a bit of manipulation, only one sequence needs to be calculated to start\n\n```\nfor (int i = 2; i < input; i++)\n    fib[i] = fib[i - 1] + fib[i - 2];\n\nfor (int i = 2; i < input; i++)\n{\n    fib2[i] = separate2(fib[i]);\n    fib[i] = separate(fib[i]);\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Unable to get the first two items in an array when creating a Fibonacci sequence in JS\r\n                \r\nI've been trying to create a Fibonacci sequence that always starts with [0, 1] using simple JS. However, the way it's written now, the function does not return the first two items in an array when I call the corresponding n number. So, for n = 1 and n = 2 (and ONLY those values of n), I get undefined when calling the function. However, whenever I call n larger than 2, the Fibonacci sequence returns correctly, with the correct amount of array items (so, including items 0 and 1, which I am unable to call on their own).\nHere is the code:\n```\nfunction generator(n) {\nvar output = [];\nvar num1 = 0;\nvar num2 = 1;\nvar next;\n\nif (n === 1) {\n    output = [0];\n} else if (n === 2) {\n    output = [0, 1];\n} else {\n    output = [num1, num2];\n    for (var count = 2; count < n; count++) {\n    next = num1 + num2;\n    num1 = num2;\n    num2 = next;\n    output.push(next); \n}\n\nreturn output;\n\n\n\n\n}\n\n}\n```\n\nWould anyone know what is wrong in the code? Thanks so much for any help!\n    ", "Answer": "\r\nFirst of all, there is a problem with brackets in the code you have posted above. the code should look like this.\n```\nfunction generator(n) {\nvar output = [];\nvar num1 = 0;\nvar num2 = 1;\nvar next;\n\nif (n === 1) {\n    output = [0];\n} else if (n === 2) {\n    output = [0, 1];\n} else {\n    output = [num1, num2];\n    for (var count = 2; count < n; count++) {\n    next = num1 + num2;\n    num1 = num2;\n    num2 = next;\n    output.push(next); \n}}\n\nreturn output;\n}\n```\n\nHowever, this may be just a typo issue. And secondly, if I use the corrected type of the function, there is no problem.\n\r\n\r\n```\nfunction generator(n) {\nvar output = [];\nvar num1 = 0;\nvar num2 = 1;\nvar next;\n\nif (n === 1) {\n    output = [0];\n} else if (n === 2) {\n    output = [0, 1];\n} else {\n    output = [num1, num2];\n    for (var count = 2; count < n; count++) {\n    next = num1 + num2;\n    num1 = num2;\n    num2 = next;\n    output.push(next); \n}}\n\nreturn output;\n}\n\n//testing\nfor(let i=1;i<=5;i++){\n  console.log(`${i}'th result`)\n  console.log(generator(i));\n}```\n\r\n\r\n\r\n\nTry this one, it should be OK.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Implementing alternative Fibonacci sequence\r\n                \r\n\nSo I'm struggling with Question 3. I think the representation of L would be a function that goes something like this:\n```\nimport numpy as np\ndef L(a,  b):\n    #L is 2x2 Matrix, that is \n    return(np.dot([[0,1],[1,1]],[a,b]))\n\n\ndef fibPow(n):\n    if(n==1):\n        return(L(0,1))\n    if(n%2==0):\n        return np.dot(fibPow(n/2), fibPow(n/2))\n    else:\n        return np.dot(L(0,1),np.dot(fibPow(n//2), fibPow(n//2)))\n```\n\nGiven b I'm pretty sure I'm wrong. What should I be doing? Any help would be appreciated. I don't think I'm supposed to use the golden ratio property of the Fibonacci series. What should my a and b be?\nEDIT: I've updated my code. For some reason it doesn't work. L will give me the right answer, but my exponentiation seems to be wrong. Can someone tell me what I'm doing wrong\n    ", "Answer": "\r\nWith an edited code, you are almost there. Just don't cram everything into one function. That leads to subtle mistakes, which I think you may enjoy to find.\nNow, ```\nL```\n is not  function. As I said before, it is a matrix. And the core of the problem is to compute its ```\nn```\nth power. Consider\n```\nL = [[0,1], [1,1]]\n\ndef nth_power(matrix, n):\n    if n == 1:\n        return matrix\n    if (n % 2) == 0:\n        temp = nth_power(matrix, n/2)\n        return np.dot(temp, temp)\n    else:\n        temp = nth_power(matrix, n // 2)\n        return np.dot(matrix, np.dot(temp, temp))\n\ndef fibPow(n):\n    Ln = nth_power(L, n)\n    return np.dot(L, [0,1])[1]\n```\n\nThe ```\nnth_power```\n is almost identical to your approach, with some trivial optimization. You may optimize it further by eliminating recursion.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence: Recursion depth excess\r\n                \r\nGiven the function to generate fibonacci numbers:\n\n```\ndef fibonacci(x, memory = {0:0, 1:1}):\n        if x not in memory:\n                memory[x] = fibonacci(x-1, memory)+fibonacci(x-2, memory)\n        return memory[x]\n```\n\n\nWhen I try some arbitrarily large number, say 4000th fibonacci number, I get an error:\n\n```\nRuntimeError: maximum recursion depth exceeded\n```\n\n\nWhat is the error caused by? What can be done as a work around without sacrificing the efficiency? I prefer this to iteration, since by iterating, calculating even the 50th position takes astronomically long for a computer (read: half a minute).\n    ", "Answer": "\r\nAs the others have mentioned you have hit the stack memory limit. You usually have a maximum of 50-100 maximum nested recursive calls before you hit this limit.\n\nI think you might have a misconception about iteration (unrolling recursive functions)\n\n```\ndef fib():\n    a=0\n    b=1;\n    c=1;\n    for x in range(4000):\n        c = a + b;\n        a = b;\n        b = c;\n    print c;\n\nfib();\n```\n\n\nThere is no way this function would take longer than your recursive one.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Iterative Version of Modified Fibonacci Sequence\r\n                \r\nI was just going through the iterative version of fibonacci series algorithm. I found this following code\n\n```\nint Fibonacci(int n)\n{\n   int f1 = 0;\n   int f2 = 1;\n   int fn;\n   for ( int i = 2; i < n; i++ )\n   {\n      fn = f1 + f2;\n      f1 = f2;\n      f2 = fn;\n   }\n}  \n```\n\n\nA silly question just raised in my mind. The function above adds two previous numbers and returns the third one and then get variables ready for the next iteration. What if it would be something like this. \"Return a number of series which is the sum of previous three numbers\" how we can change the above code to find such a number.u\n    ", "Answer": "\r\nAs a hint, notice that the above algorithm works by \"cycling\" the numbers through some variables.  In the above code, at each point you are storing\n\n```\n F_0    F_1\n  a      b\n```\n\n\nYou then \"shift\" them over by one step in the loop:\n\n```\n F_1    F_2\n  a      b\n```\n\n\nYou then \"shift\" them again in the next loop iteration:\n\n```\n F_2    F_3\n  a      b\n```\n\n\nIf you want to update the algorithm sum the last three values, think about storing them like this:\n\n```\n T_0    T_1    T_2\n  a      b      c\n```\n\n\nThen shift them again:\n\n```\n T_1    T_2    T_3\n  a      b      c\n```\n\n\nThen shift them again:\n\n```\n T_2    T_3    T_4\n  a      b      c\n```\n\n\nConverting this intuition into code is a good exercise, so I'll leave those details to you.\n\nThat said - there is a much, much faster way to compute the nth term of the Fibonacci and \"Tribonacci\" sequences.  This article describes a very clever trick using matrix multiplication to compute terms more quickly than the above loop, and there is code available here that implements this algorithm.\n\nHope this helps!\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Unable to print recursive fibonacci sequence correctly\r\n                \r\nI am trying to write a recursive Fibonacci generator that prints each term in C. The number of terms is user-specified; I have developed the algorithm. When I try to print, it only prints ones. Can anyone point me in the direction of where I am going wrong?\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nint Fibonacci (int n)\n{\n    if (n = 0)\n        return 0;\n    if (n = 1)\n        return 1;\n    else\n        return (Fibonacci(n-1) + Fibonacci(n-2));\n}\n\nint main()\n{\n    int terms;\n    printf(\"Enter the number of terms: \");\n    scanf(\"%d\", &terms);\n\n\n    printf(\"\\nThe Fibonacci sequence containing %d terms is:\\n\", terms);\n\n    int i = 0;\n    for (i; i < terms; i++)\n    {\n        printf(\"%d \", Fibonacci(i));\n    }\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\n```\nif (n == 0)\n```\n\n\nnot\n\n```\nif (n=0)\n```\n\n\ncheck your syntax careful.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Function-local, self-referential, lazy fibonacci sequence\r\n                \r\nI would like to create a function that returns a lazily extended infinite sequence of Fibonacci numbers.\n\nRight now, I can make my sequence available in the top-level namespace like this:\n\n```\n(def fibonacci-numbers\n  (lazy-cat [0 1] (map + fibonacci-numbers (rest fibonacci-numbers))))\n```\n\n\nHowever, this means that if I start consuming a lot of them, I lose control over the garbage collection.\n\nI am looking to do something like:\n\n```\n(defn fibonacci-numbers-fn []\n  (lazy-cat [0 1] (map + (fibonacci-numbers-fn) (rest (fibonacci-numbers-fn)))))\n```\n\n\nThis clearly will not work because I will end up creating O(2^n) sequences.  I think I am asking how to create a self-referential lazy sequence in a function-local namespace.  What should I do?\n\nEDIT:  Although I like the popular solution posted by amalloy and found all over the internet ```\ndefn fibs [] (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1])))```\n, I'm interested in a version similar to the canonical Haskell way:\n\n```\nfibonaccis = 0 : 1 : zipWith (+) fibonaccis (tail fibonaccis)\n```\n\n\nThis is what I was trying to accomplish with my original function.  To me, the map-iterate solution reads like \"add the previous two elements to create a new one\" and the lazy-cat solution reads like \"join a stream with its first lag\".  How can I \"join a stream with its first lag\" without having the sequence in the top-level namespace?\n    ", "Answer": "\r\n```\n(take 10 (map first (iterate (fn [[a b]]\n                               [b (+ a b)])\n                             [0 1])))\n\n;; (0 1 1 2 3 5 8 13 21 34)\n```\n\n\nOr if you're set on doing it with lazy-seq by hand:\n\n```\n(letfn [(fibs\n          ([]\n             (fibs 0 1))\n          ([a b]\n             (lazy-seq\n               (cons a (fibs b (+ a b))))))]\n  (take 10 (fibs)))\n\n;; (0 1 1 2 3 5 8 13 21 34)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Swift vs Objective-C Fibonacci Sequence Speed Comparison\r\n                \r\nI have a problem. I want to know which one is indeed faster(Swift or Objective-C) because I would like to choose a faster/better one when I start developing an app. According to many sources(For example Apple's WWDC, or http://www.jessesquires.com/apples-to-apples-part-two/), Swift is suppose to be faster.\n\nI just wrote a simple recursive fibonacci sequence program in both Swift and Objective-C.\n\nHowever, when I run fib(35) on the simulator, I get surprising results:\n\nObjective-C Result:\n\n:::fib::::9227465:::duration:::0.122813 seconds\n\nSwift Result\n\n:::fib::::9227465 :::duration:::0.606831073760986 seconds\n\nNow, I even ran the Swift version in all Swift Compiler Optimization level(for Debug), which is None, Fastest, Fastest-Unchecked. I also play around with the Code Generation Optimization Level to None, Fast....Fastest Aggressive Optimization.\nHowever all Swift results are something close to 0.6 milliseconds\n\nNow the last thing I can think of is may be, I am comparing an Apple to Orange?\nDo you guys see anything I am missing here? Is there anything else I have to turn on(other than Optimization levels for Swfit Compiler & Apple LLVM Code Generation) to make Swift programs run faster?\n\nAny suggestions or comments are welcome and appreciated ! ^^ !\n\nObjective-C Version\n\n```\n-(int)fib:(int)num{\n    if (num == 0) {\n        return 0;\n    }\n    if (num == 1) {\n        return 1;\n    }    \n    return [self fib:num - 1] + [self fib:num - 2];\n}\n```\n\n\nSwift Version\n\n```\nfunc fib(num: Int) -> Int{\n    if(num == 0){\n        return 0;\n    }\n    if(num == 1){\n        return 1;\n    }\n    return fib(num - 1) + fib(num - 2);\n}\n```\n\n\nObjective-C Time Measurement\n\n```\n  NSTimeInterval start = [[NSDate date] timeIntervalSince1970];\n  int result = [self fib:35];\n  NSTimeInterval end = [[NSDate date] timeIntervalSince1970];\n\n  NSTimeInterval duration = end - start;\n  NSLog(@\":::fib::::%d:::duration:::%f\",result,duration);\n```\n\n\nSwift Time Measurement\n\n```\nvar start = NSDate().timeIntervalSince1970;\nlet result = fib(35);\nvar end = NSDate().timeIntervalSince1970;\n\nvar duration = end - start;\nprintln(\":::fib::::\\(result) :::duration:::\\(duration)\");\n```\n\n    ", "Answer": "\r\nLot of things to consider when deciding which of the two programming languages are faster. I did a couple of benchmarks (https://github.com/vsco/swift-benchmarks) between Swift and Objective-C and I found that in certain cases Swift was faster and in other cases Objective-C was faster. For example, using struct objects in Swift will offer tremendous performance gains if you need to operate over a large amount of data. In contrast, using non-struct objects made Swift significantly slower than it's Objective-C counterparts.\n\nAlso how you use certain features in Swift is very crucial to how well it will perform. Take this function for example:\n\n```\nclass func shuffleGenericObjects<T>(inout array:[T]) {\n    for (var i = 0; i < array.count; i++) {\n        let currentObject: T = array[i]\n        let randomIndex = Int(arc4random()) % array.count\n        let randomObject: T = array[randomIndex]\n\n        array[i] = randomObject;\n        array[randomIndex] = currentObject\n    }\n}\n```\n\n\nSure it works great for minimizing repetitive code, but when I executed this method over 1 million Int objects, it took roughly 32 seconds to finish. As oppose to the non-generic implementation, which only took 0.181 seconds.\n\nI also recommend not to use ```\nNSDate```\n functions for benchmarking in Swift. I came across a few bugs that caused ```\nNSDate```\n to return incorrect times. It's much better to put your benchmarks in an ```\nXCTestCase```\n and use the ```\nmeasureBlock()```\n function.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Allow user input for the number of threads for Fibonacci Sequence and Factorial Calculation using multithreading\r\n                \r\nI want to use scanner for user input for the number of threads to run. So far, this java code is able to run both the number of the Fibonacci sequences and factorial calculation based on user input. How do I do allow user input for the number of threads?:\nimport java.io.IOException;\nimport java.util.Scanner;\nclass Fibonacci extends Thread {\n```\n@Override\npublic void run() {\n    \n        \n    int n1=0, n2=0, n3=1;\n    Scanner sc = new Scanner(System.in);\n    System.out.println(\"Enter the amount of Fibonacci: \");\n    int number = sc.nextInt();\n    for(int i=1; i<=number; i++) {\n        n1 = n2;                                \n        n2 = n3;\n        n3 = n1 + n2;\n        System.out.println(n1 + \"  \");\n    }\n        \n\n        \n        }\n    }\n```\n\nclass Factorial extends Thread {\n```\n@Override\npublic void run() {\n    try {\n        \n            long fact = 1;\n            int i = 1, n;\n            Scanner input = new Scanner(System.in);\n            System.out.print(\"Enter a number for the calculation of Factorial:    \");\n            n = input.nextInt();\n            input.close();\n            \n            while(i<=n)\n            {\n                fact = fact * i;\n                i++;\n            }\n            System.out.println(\"Factorial of \"+n+\" is: \"+fact);\n            \n                \n        \n            \n    } catch (NumberFormatException ex) {\n\n    }\n}\n```\n\n}\npublic class Assignment02 {\n```\npublic static void main(String args[]) throws IOException {\n    Scanner input = new Scanner(System.in);\n    System.out.println(\"1.Fibonacci\");\n    System.out.println(\"2.Factorial\");\n    System.out.println(\"Choose your Option:\");\n    String line = input.nextLine();\n    int option = Integer.parseInt(line);\n    \n    switch (option) {\n        case 1:\n            System.out.println(\"Fibonacci Sequence SELECTED\");\n            try {\n\n                Fibonacci fib = new Fibonacci();\n                fib.start();\n                fib.join();\n                \n\n            } catch (Exception e) {\n            }\n\n            break;\n\n        case 2:\n            System.out.println(\"Factorial SELECTED\");\n            try {\n                \n                Factorial fact = new Factorial();\n                fact.start();\n                fact.join();\n                \n            } catch (Exception e) {\n            }\n            break;\n\n        default:\n            System.out.println(\"Choose a valid option\");\n            break;\n    }\n    \n```\n\n}\n}\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence and issues with return?\r\n                \r\nI am trying to learn c++ having already started programming in python. This is a simple program to calculate the fibonacci numbers between two values a,b. However when i run the code only the number 1 is printed and I can not figure out why. I think it is something to do with using return inside the for loop. Any help would be greatly appreciated\n\n```\n#include <iostream>\nusing namespace std;\n\nint fibo(int b,int a=0){\n    int x=0;\n    int y=1;\n    for(int i=0; i<=b; i++){\n        int x0=x;\n        int z=x+y;\n        x=y;\n        y=z;\n        if(x>a){\n            return x0;\n        }\n    }\n}\n\nint main()\n{\n    cout << fibo(100)<<endl;\n    return 0;\n}\n```\n\n\nHere is the python function just for reference\n\n```\ndef fibo(b,a=0):\n    x=0\n    y=1\n    while x<=b:\n        z=x+y\n        x0=x\n        x=y\n        y=z\n        if x>a:\n            print x0\n```\n\n\nI have also tried the following in c++\n\n```\n#include <iostream>\nusing namespace std;\n\nint fibo(int b,int a=0){\n    int x=0;\n    int y=1;\n    for(int i=0; i<=b; i++){\n        int x0=x;\n        int z=x+y;\n        x=y;\n        y=z;\n        if(x>a){\n            cout << x0 <<endl;\n        }\n    }\n}\n\nint main()\n{\n    fibo(100);\n    return 0;\n}\n```\n\n\nHowever this gives fibonacci numbers beyond the value of b\n    ", "Answer": "\r\nHere's the exact port of your code from Python to C++\n\n```\n#include <iostream>\n\nusing namespace std;\n\nvoid fibo(int b,int a=0){\n    int x=0;\n    int y=1;\n    int z, x0;\n    while( x <= b ) {\n        z= x + y;\n        x0 = x;\n        x = y;\n        y = z;\n        if(x > a) {\n            cout << x0 << endl;\n        }\n    }\n}\n\nint main()\n{\n    fibo(100);\n    return 0;\n}\n```\n\n\nIn your Python code, if there's no explicit return, the default return value of the function will be ```\nNone```\n. In C++, that's equivalent to a ```\nvoid```\n function.\n\nWhy didn't your for loop work?\n\nThe for loop is designed to iterate a number of times. Its syntax is:\n\n```\nfor (initialization; condition; increase) statement;\n```\n\n\nLike the while-loop, this loop repeats statement while condition is true. But, in addition, the for loop provides specific OPTIONAL locations to contain an initialization and an increase expression, executed before the loop begins the first time, and after each iteration, respectively. \n\n\ninitialization is executed. Generally, this declares a counter\nvariable, and sets it to some initial value. This is executed a\nsingle time, at the beginning of the loop.\ncondition is checked. If it is true, the loop continues; otherwise,\nthe loop ends, and statement is skipped, going directly to step 5.\nstatement is executed. As usual, it can be either a single statement\nor a block enclosed in curly braces { }.\nincrease is executed, and the loop gets back to step 2.\nthe loop ends: execution continues by the next statement after it.\n\n\nRead more here: http://www.cplusplus.com/doc/tutorial/control/#for.\n\nSo let's break down your loop:\n\n```\nint x=0;    // initialize x to 0\nint y=1;    // initialize y to 1\nfor(        \n  int i=0;  // initialize i to 0\n  i<=b;     // keep looping until i is less than or equal to b (a variable passed in)\n  i++       // after every single loop iteration, increment i by 1\n) {  \n    int x0=x;  // initialize x0 to x\n    int z=x+y; // initialize z to (x + y)\n    x=y;       // assign the value of y to x\n    y=z;       // assign the value of z to y\n    if(x>a){   // if x is greater than a, print the value of x0\n        cout << x0 <<endl;\n    }\n}\n```\n\n\nIn your Python code, you don't have an ```\ni```\n, you use ```\nx```\n as your loop invariant. So that should be the ```\ncondition```\n of your for loop: ```\nx <= b```\n. The initialization part should be the variables you set before you loop, so: ```\nint x = 0, y = 1, x0, z```\n should be the ```\ninitialization```\n. The last part is the increment. In your python code, your increment is ```\nx = y```\n, but in a for loop, that part is executed after the iteration is done, so we can't just set ```\nx = y```\n in the increment part of the for loop since ```\ny = z```\n is executed before the increment part. What we can do is use a bit of algebra: ```\nz = y + x```\n, so we can get the value of ```\ny```\n by subtracting ```\nx```\n from ```\nz```\n: ```\nz - x```\n.\n\nThis makes the for loop:\n\n```\nvoid fibo2(int b,int a=0){\n    for(\n        int x = 0, y = 1, x0, z;\n        x <= b;\n        x = (z-x)\n    ) {\n        x0 = x;\n        z = x+y;\n        y = z;\n        if(x > a){\n            cout << x0 <<endl;\n        }\n    }\n}\n```\n\n\nHope this helps.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence using Python\r\n                \r\nHello I am trying to write a script that prompts the user for an integer number (n), then prints all the Fibonacci numbers that are less than or equal to the input, in that order.\nEXAMPLE:\nEnter a number : 14\noutput is: 1 1 2 3 5 8 13\nHere is what i have so far but not sure if it is the most efficient way? It is working correctly but I was wondering if there is a easier way to clean this up..\n```\nn = int(input(\"Enter a number: \"))\na = 0\nb = 1\nsum = 0\n\n\nwhile(sum <= n):\n print(sum, end = \" \")\n count += 1\n a = b\n b = sum \n sum = a + b\n\nprint(end = \" \")\n```\n\nI am fairly new to python and am doing some practice but was not able to find a solution in textbook.\n    ", "Answer": "\r\nThis way is efficient enough, but your code can do better\n```\nn = int(input(\"Enter a number: \"))\na = b = 1\n\nwhile(b <= n):\n print(b, end = \" \")\n a, b = b, a + b\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence in mips assembly\r\n                \r\nSo, I have been trying for two days to write a program in mips assembly to exercise for my exams in a few days but yeah, my brain keeps lagging and I don't understand how it should work and what I should do, very confusing. All the versions of the programs I wrote would definitely not calculate the fibonacci unfortunately.\n```\nSo this is my code as of now    \n```\n\n```\n        .data\nprompt: .asciiz \"Give me a number to find its fibonacci: \"\nresult: .asciiz \"The fibonacci is: \"\nnumber: .word   0\nanswer: .word   0\n        .text\n        .globl  main\n        .globl  fib\nmain:   li      $v0, 4\n        la      $a0, prompt\n        syscall\n        \n        li      $v0, 5\n        syscall\n        \n        sw      $v0, number\n        lw      $a0, number\n        \n        li      $v0, 0\n        jal     fib\n\n        sw      $v0, answer\n        \n        li      $v0, 4\n        la      $a0, result\n        syscall\n        \n        li      $v0, 1\n        lw      $a0, answer\n        syscall\n        \n        li      $v0, 10\n        syscall\n        \nfib:    addi    $sp, $sp, -8\n        sw      $ra, 4($sp)\n        sw      $a0, 0($sp)\n        \n        slti    $t0, $a0, 2         # if (t0=(a0 < 2))\n        beqz    $t0, fibB           # if (t0 == 0) / a0 < 2 false goto fibB\n        # if (t0 == 1)\n        add     $v0, $a0, $v0\n        addi    $sp, $sp, 8\n        jr      $ra\n        \nfibB:   addi    $a0, $a0, -1\n        jal     fib\n        addi    $a0, $a0, -2\n        jal     fib\n        lw      $a0, 0($sp)\n        lw      $ra, 4($sp)\n        addi    $sp, $sp, 8\n        jr      $ra\n        \n```\n\n    ", "Answer": "\r\nIf your choice is to use a custom/non-standard calling convention that both saves & restores ```\n$a0```\n, and passes ```\n$v0```\n as a accumulator parameter, then you are well off the mainstream track.  It is possible that your instructors are telling you to do this, but then you need to go to them for help, or at least obtain knowledge of this alteration.\nIMHO, at best this approach can be considered a very advanced optimization technique (though flawed or incomplete), so there's little advantage to learning this before you know how normal calling should work.\nI also see that you've attempted to move the addition part of  the expression ```\nfib(...) + fib(...)```\n into the base case — this is folly since it simply doesn't belong there, and is then missing from all the non-base cases, and the resulting function simply isn't a normal recursive ```\nfib()```\n.\n\nThat code is doing something like:\n```\nint altFib(int n, int acc) {\n    if (n <= 2) {\n        return n + acc;\n    }\n    acc = altFib(n-1, acc);\n    return altFib(n-2, acc);\n}\n```\n\nSo, this is only going to do addition at the base case and not at every level.\nAlso, to be clear, there are bad examples to be found on the internet, of ```\nfib()```\n using non-standard calling conventions that many educators would consider problematic, yet others don't even understand the issues.\n\nThe rest of this post will deal with standard calling convention and register usages.\nFirst, your base case has a typo (or design flaw): ```\nadd $v0, $a0, $v0```\n.  In the base case, you want to simply copy ```\n$a0```\n into ```\n$v0```\n, not a sum of whatever happens to be in ```\n$v0```\n with ```\n$a0```\n, i.e. ```\nreturn n;```\n.\nAlways test your code with the smallest numbers first so, do ```\nfib(0)```\n, then ```\nfib)(1)```\n, then ```\nfib(2)```\n.  However, you have cleverly cleared ```\n$v0```\n to 0 before invoking the function, as a non-standard band-aid — ```\n$v0```\n is not a parameter to the function, plus your band-aid is not being applied to the internal call sites within ```\nfib```\n.  We are not supposed to rely on ```\n$v0```\n having some value upon function entry: simply set it, overwriting any old value, to return a desired value to the caller.\nSecond, within the ```\nfib```\n function, you are generally not following the standard calling convention with regard to the second invocation of ```\nfib```\n inside the function.\n\nYou are using a non-standard register save & restore, ```\n$a0```\n should not be restored, and callers should not rely on it being restored by callee.  ```\n$a0```\n should be saved for your own function's benefit but there is no reason to restore it for the caller's benefit.\n\nThe return value from the first invocation to ```\nfib```\n is (supposedly) in ```\n$v0```\n, yet you make a second (recursive) call to ```\nfib```\n, which necessarily also returns its return value in ```\n$v0```\n, and as a result you no longer have access to the first invocation's return value; it is lost!  You can observe this in debugging.  (That non-standard calling convention is going to restore the ```\n$a0```\n that the invocation got, not the original parameter value you want meaning it will return to you in ```\n$a0```\n the -1 value, however the proper solutions is to use the standard calling convention.)\n\nThe parameter ```\n$a0```\n is being wiped out by the first invocation to ```\nfib```\n by your own code subtracting 1 from it in order to make that invocation=.  You can observe this in debugging, with just ```\nfib(2)```\n.\n\nYou are missing the addition in ```\nfib(..) + fib(..)```\n.  You are most likely missing this because you don't know what to add together (or perhaps due to the alternative design), which comes from not following the calling convention's requirements, and the associated loss of the first ```\n$v0```\n return value from the first invocation of ```\nfib```\n.\n\n\n\nIn order to fix this and follow the standard calling convention:\n\nYou already have prologue and epilogue that is saving ```\n$a0```\n, which is good.  You should simply remove the restoration of ```\n$a0```\n in epilogue.\n\nIn between the two invocation's of fib:\n\nYou need to restore the original ```\n$a0```\n in order to subtract 2 from it for parameter passing to the second invocation of ```\nfib```\n.  This requires a ```\nlw```\n instruction to fetch into ```\n$a0```\n from the stack memory location where it was saved in prologue (before the -2 subtraction).\n\nYou need to save ```\n$v0```\n (in between the two invocations to ```\nfib```\n), as it hold the return value from the first invocation, which will be needed to perform the proper addition.  You can save it into the same stack location that you just loaded ```\n$a0```\n from, since by analysis of the remainder of the function, you'll no longer need the original parameter value.\n\n\n(You could do items (2.) & (3.) in reverse order, but that would require an additional stack slot, since in that ordering item (3.) cannot save to the same stack slot, as the value there is not yet recovered for item (2.))\nAfter the second invocation to ```\nfib```\n, you need to add the two return values together: one of them is in ```\n$v0```\n and the other has been saved as per item (3.).  So, reload the value saved in (3.) into any available temporary register (i.e. other than $v0, say ```\n$t0```\n or even ```\n$a0```\n), and sum it's value to ```\n$v0```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "C++ Fibonacci sequence generator using a while loop. What is wrong with my logic here?\r\n                \r\nSo I tried to create a program using a while loop that asks the user to input a number and that number will be used to essentially generate the fibonacci sequence up to that number. Meaning if the user inputs the number 10 then the output should be the fibonacci numbers up to the maximum number the user inputs like 0,1,1,2,3,5,8.\n```\n   #include<iostream> \n   \n   int main(){\n\n   int F0(0), F1(1), Fnext;\n   int num;\n   \n   std::cout << \"Enter a number:\\n\"; \n   std::cin >> num;\n   \n   std::cout << F0 << \" \" << F1;\n           while(Fnext <= num){\n           Fnext = F1 + F0;\n           F0 = F1;\n           F1 = Fnext;\n           \n           }\n   std::cout << Fnext;\n   }\n    \n```\n\nSorry if my formatting is weird, firs-time user here on this website. I tried to copypaste my code and it didn't work so the code above you is manually typed.\nUPDATE:\nI updated my code and the output is so close to being right.\n```\n#include<iostream>\n\nint main(){\n\nint F0(0), F1(1), Fnext(0);\nint num;\n\nstd::cout << \"enter a number to generate the fibonacci sequence up to that number:\\n\"\nstd::cin >> num;\n\nstd::cout << F0 << \" \" << F1;\n\n        while(Fnext < num){\n         Fnext = F1 + F0;\n         F0 = F1;\n         F1 = Fnext;\n         std::cout << \" \" << Fnext;\n        }\n}\n\n    \n```\n\n    ", "Answer": "\r\n\nYou haven't initialized/defined ```\nFnext```\n, so it doesn't appear that your code will make it into your while loop, and it won't be displayed.\nYour ```\ncout```\n statements are not inside of your loop, so you won't have access to the value (specifically ```\nFnext```\n) that you're wanting to display. If you want to display the contents of ```\nFnext```\n as it's \"incremented\" it must be inside of the while loop.\n\n```\n#include<iostream> \n\nint main(){\n    int F0(0), F1(1), Fnext(0);\n    int num;\n    \n    std::cout << \"Enter a number:\\n\"; \n    std::cin >> num;\n    \n    std::cout << F0 << \" \" << F1;\n    while(Fnext <= num){\n        Fnext = F1 + F0;\n        F0 = F1;\n        F1 = Fnext;\n        std::cout << Fnext << \" \";\n    }\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "JavaScript: calculate the sum of all even numbers in Fibonacci sequence values < 10000\r\n                \r\nI have to complete this exercise, and I am not getting the results I need. \n\nThe specifications are: Calculate the sum of all even numbers in a Fibonacci sequence for values under 10,000. The first few numbers summed would be: 2, 8, 34, 144, 610.\n\nI have a fiddle that produces this output: 10, 44, 188, 798, 3382.\n\n```\nvar x = 1;\nvar y = 2;\nvar sum = 0;\nvar limit = 10000;\nvar evensum = 2;\n\nwhile ((x + y) < limit) {\n    sum = x + y;\n    x = y;\n    y = sum;\n\n    if (sum % 2 === 0) {\n        evensum += sum;\n    }\n    console.log(evensum);\n}\n```\n\n\nfiddle link\n\nCould someone please help me figuring out the part I am missing to complete this exercise?\n\nThank you much.\n\nUPDATE\nThank you everyone who posted a solution. They all worked great.\n    ", "Answer": "\r\nYou are printing out the summation of even numbers. If you want to log each even fib number you need to log ```\nsum```\n variable:\n\n```\nif (sum % 2 === 0) {\n    evensum += sum;\n    console.log(sum); // <---- log here\n}\n// console.log(evensum);\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generating the Fibonacci Sequence in Matlab using recursive function NOT using any loop\r\n                \r\nI am trying to write a recursive matlab function that takes one argument and generates the fibonacci sequence up to n. The codes I have found everywhere either output only the n-th term or use loops to output the whole sequence. Now I am not allowed to use any kind of loops, just pure recursive function. I will highly appreciate if anyone can share his/her thoughts. Thanks in advance.\nI am copying the code that gives the n-th term only for convenience.\n```\nfunction f = fibor(n)\n    if n == 1 || n == 2\n        f = 1;\n    else\n        f = fibor(n-1) + fibor(n-2);\n    end\nend\n```\n\n    ", "Answer": "\r\nMaybe you can try the code below, which saves the outputs\n```\nfunction f = fibor(n)\n    if n <= 2\n        f = ones(1,n);\n    else\n        u = fibor(n-1);\n        f = [u,sum(u(end-1:end))];\n    end\nend\n```\n\nwhich gives\n```\n>> fibor(5)\nans =\n\n   1   1   2   3   5\n\n>> fibor(10)\nans =\n\n    1    1    2    3    5    8   13   21   34   55\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fixing Fibonacci sequence script (javascript)\r\n                \r\nI am trying to write a script that will create numbers in Fibonacci order, I don't understand why this is not working.\n\n```\nvar output = [];\nvar n = output.length;\nvar nextNum = output[n-1] + output[n-2];\n\nfunction fibo (numQuantity) {\nfor (var i=1; i<numQuantity ; i++)\n{\n  if (n>1){ \n  output.push(nextNum);\n  console.log(output);\n}\nelse if (n<2)\n  {output.push(1);\n  console.log(output);}\n}\n}\n```\n\n    ", "Answer": "\r\nIn your original code your n never changes as you only assigned it on start.\n\n```\n    var output = [];\n\n\n    function fibo (numQuantity) {\n    for (var i=1; i<numQuantity ; i++)\n    {\n      var n = output.length;\n      var nextNum = output[n-1] + output[n-2];\n      if (n>1){ \n        output.push(nextNum);\n        console.log(output);\n      }\n      else if (n<2)\n      {\n        output.push(1);\n        console.log(output);\n      }\n    }\n    }\n\n    fibo(10)\n```\n\n\nIn Javascript numbers are passed by value not reference so they are not the same object in memory. So when the array length changes your n value stays at 0 because they are not the same object.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How can I complete this Fibonacci sequence evaluation in R?\r\n                \r\nGreetings good people of Stackland!\n\nRecently I was given this task\n\n\nGenerate the Fibonacci sequence in any language \nEvaluate whether each value is odd or even\nSum the even numbers such that their total is not >500,000\n\n\nI chose to do this R, as I am learning the language and thought it would be a good exercise in doing so.\n\nI have managed to complete step 2 of the task but haven't been able to proceed any further. Please see code and comments below.\n\n```\n   len <- 50\n    fibvals <- numeric(len)\n    fibvals[1] <- 1\n    fibvals[2] <- 1\n    for(i in 3:len) { fibvals[i] <- fibvals[i-1]+fibvals[i-2]}\n    fibvals\n     [1]           1           1           2           3           5\n     [6]           8          13          21          34          55\n    [11]          89         144         233         377         610\n    [16]         987        1597        2584        4181        6765\n    [21]       10946       17711       28657       46368       75025\n    [26]      121393      196418      317811      514229      832040\n    [31]     1346269     2178309     3524578     5702887     9227465\n    [36]    14930352    24157817    39088169    63245986   102334155\n    [41]   165580141   267914296   433494437   701408733  1134903170\n    [46]  1836311903  2971215073  4807526976  7778742049 12586269025\n\n    # Creates a variable called len in which the value 50 is stored\n    # Creates a var called fibvals, which is a numeric datatype, which should have len (50) vals\n    # Sets the value of the first entry in fibvals to 1\n    # Sets the value of the second entry in fibvals to 1\n    # Loop - \"for (i in 3:len)\" dictates that the loop should be executed between step 3 and step 50 (denoted by \"len\")\n    # Loop - Defines a loop step \"i\" as being the result of the (current i - the before it) + (current i - i two before it)\n    # Loop - Example 5 = (5-3) + (5-2) OR 2 + 3 = 5 | Example 21 = (21-13) + (21-8) OR  8 + 13 = 21 \n\n    is.even <- function(x){ x %% 2 == 0 }\n\n    # Creates a UDF to check if values are odd or even by using modulo. \n    If the remainder is 0 when any value is divided by 2, it is an even number \n\nis.even(fibvals)\n\n [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n[11] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE\n[21]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n[31] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n[41] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE\n\n# Evaluates all Fibonacci values on odd or even property\n```\n\n\nWhat I need is a bit of guidance as to where I should go from here.\nShould I create a data.table and query that using the SQL package, or is there a much more elegant and less cumbersome way?\n\nThanks in advance! \n    ", "Answer": "\r\nFor sorting out the even number from first 50 fibonacci numbers you can use this\n\n```\neven_numbers <- fibvals[fibvals%%2==0]\n```\n\n\nThen by computing cumulative sum of those even numbers and imposing the condition of the maximum value of the sum, you can select those even numbers by this\n\n```\ncumsum(even_numbers)<500000\n```\n\n\nTherefore your desired fibonacci numbers are\n\n```\neven_numbers[cumsum(even_numbers)<500000]\n```\n\n\nand their ```\nsum```\n is\n\n```\nsum(even_numbers[cumsum(even_numbers)<500000])\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Need explanation about this PS code computing elements < 100 in the Fibonacci sequence\r\n                \r\nI understand what this code does but not how it does.\n```\n$($c=$p=1; while ($c -lt 100) {$c; $c,$p=($c+$p),$c})\n```\n\nThis part ```\n{$c; $c,$p=($c+$p),$c}```\n is processed at every loop. I get it but I don’t understand the ```\n$c,$p=($c+$p),$c```\n part. Is it an array, here ? Can someone explain what really happens at every loop ?\nHere is what I think what happens.\n\n```\n$c;```\n allows to display the current value to output.\n```\n$c,$p=($c+$p),$c```\n computes the next value in Fibonacci sequence and update ```\n$c```\n and ```\n$p```\n that are equal. But why this array-like syntax ? How does it work ?\n\n    ", "Answer": "\r\n```\n$c= $p = 1 # $c = 1, $p = 1\n\nwhile ($c -lt 100) # while $c is lower than 100\n{\n    $c # $c to Standard Output\n\n    $c, $p = ($c+$p), $c\n    # ($c + $p) is processed first, on first iteration 1+1\n    # 2, $c this generates an array @(2, 1) on first iteration\n    # $c, $p = This assigns the position 0 of the array to $c\n    # and position 1 to $p\n}\n```\n\nIf you really want to break down the code this would be more or less (I'm sorry if this is not 100% accurate) what is happening:\n```\n$c = $p = 1\n\nwhile ($c -lt 100)\n{\n    $c\n    \n    $temp1 = $c + $p\n    $temp2 = $c\n\n    $c = $temp1\n    $p = $temp2\n}\n```\n\nFrom MS Docs about Assignment Operators\n\nIn PowerShell, you can assign values to multiple variables by using a single command. The first element of the assignment value is assigned to the first variable, the second element is assigned to the second variable, the third element to the third variable, and so on. This is known as multiple assignment.\n\nExample\n```\nPS /> $one,$two = 'one','two'\nPS /> $one\none\n\nPS /> $two\ntwo\n\nPS /> $one,$two = @(\n'one'\n'two'\n)\n\nPS /> $one\none\n\nPS /> $two\ntwo\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Print the first n numbers of the fibonacci sequence in one expression\r\n                \r\nSo I've been messing around with Python a bit lately and I'm trying to find a way to output the nth number of the fibonacci sequence in a single expression. This is the code that I've written so far:\n\n```\n(lambda f: f if f<2 else (f-1)+(f-2))(n)\n# n == 1 -> 1\n# n == 2 -> 1\n# n == 3 -> 3\n# n == 4 -> 5\n# n == 5 -> 7\n....\n```\n\n\nHowever, as I commented above this simply outputs a set of odd numbers. I'm confused as to why this is happening because if I am to re-write this as a named lambda function, it would look something like this:\n\n```\nf = lambda n: n if n<2 else f(f-1)+f(f-2)\n# f(1) -> 1\n# f(2) -> 1\n# f(3) -> 2\n# f(4) -> 3\n...\n# f(10) -> 55\n...\n```\n\n\nNow the reason I've added the Lambda Calculus tag is because I'm not sure if this question falls under the domain of simply understanding how Python handles this. I've read a tiny bit about the Y combinator in lambda calculus, but that's a foreign language to me and couldn't derive anything from resources I found for this about lambda calculus. \n\nNow, the reason I'm trying to do this in one line of code, as opposed to naming it, is because I want to try and put this lambda function into list comprehension. So do something like this:\n\n```\n[(lambda f: f if f<2 else (f-1)+(f-2))(n) for n in range(10)]\n```\n\n\nand create an array of the first x numbers in the fibonacci sequence. \n\nWhat I'm looking for is a method of doing this whole thing in one expression, and should this fall under the domain of Lambda calculus, which I believe it does, for someone to explain how this would work. \n\nFeel free to offer an answer in JavaScript, C#, or other C-like languages that support Lambda functions. \n\nEDIT: I've found the solution to what I was attempting to do: \n\n```\n[(lambda f: (lambda x: f(lambda v: x(x)(v)))(lambda x: f(lambda v: x(x)(v))))(lambda f:(lambda n: n if n<2 else f(n-1)+f(n-2)))(y) for y in range(10)]\n```\n\n\nI know that this is not at all practical and this method should never be used, but I was concerned with CAN I do this as opposed to SHOULD I ever do this. \n    ", "Answer": "\r\nYou'll need to assign your lambda to an actual variable, and then call the lambda inside the lambda:\n\n```\n>>> g = lambda f: f if f < 2 else g(f-1)+g(f-2)\n>>> [g(n) for n in range(10)]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Using While Function in a Fibonacci Sequence in R\r\n                \r\nI've written down a fibonacci code but I cant quite get the While function. Lets say I've made the sequence go up to 34 calculations, but I only want the results that are 4,000,000 or less. Here is the code that I have (bottom one is just to get prime numbers).\n\n```\n#rm (list=ls())\nlen <- 34\nfibvals <- numeric(len)\nfibvals[1] <- 1\nfibvals[2] <- 1\n\nfor (i in 3:len) { \n  fibvals[i] <- fibvals[i-1]+fibvals[i-2]\n} \n\n\nfib.mat <- as.matrix(fibvals)\nfib.mat[lapply(fib.mat, \"%%\", 2) == 0]\nsum (fib.mat)\n```\n\n\n···········\n\nIve tried using codes such as this which either it goes on an infinite loop or just get an error. Any help would be appreciated, thanks!\n\n```\nwhile (fibvals < 4000000) {\n  print(fibvals)\n}\n```\n\n    ", "Answer": "\r\nIt does not loop over the values of ```\nfibvals```\n the way you coded it (you pass a vector of TRUE/FALSE values to ```\nwhile```\n). You cold for example use an auxiliary counter variable like this:\n\n```\ncounter <- 1\nwhile (fibvals[counter] < 4000000) {\n  print(fibvals[counter])\n  counter <- counter + 1\n}\n```\n\n\nThis gives the desired result as I understood it.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python 3 Fibonacci Sequence (lists)\r\n                \r\nI'm trying to make a program in python that adds the fibonacci number in a list and then prints out the list, I don't know what I'm doing wrong but it keeps giving this error IndexError: list index out of range \n\n`\n\n```\nsize = 8\nls = [0, 1]\ncounter = 2\n\nwhile size > 0:\n    ls[counter].append(ls[counter - 1] + ls[counter - 2])\n    size -= 1\n    counter += 1\nprint(ls)\n```\n\n\n`\n    ", "Answer": "\r\nIt's just that you cannot append to ```\nls[counter]```\n but to ```\nls```\n\n\n```\nsize = 8\nls = [0, 1]\ncounter = 2\nwhile size > 0:\n    ls.append(ls[counter - 1] + ls[counter - 2])\n    size -= 1\n    counter += 1\n\nprint (ls)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Having trouble with the Fibonacci Sequence\r\n                \r\nSo I recently discovered this site (https://projecteuler.net). The second problem asks you to find the sum of all even Fibonacci numbers less than four million. I tried to use my limited JavaScript to solve this for me, but it doesn't seem to be working at all. Here is the jsfiddle: http://jsfiddle.net/ophunt/pnf24j7q/3/\n\nHere is the javascript contained therein:\n\n```\n//variables here\nvar sum = 0;\nvar fibA = 1;\nvar fibB = 1;\nvar store = 0;\n\n//main loop\nwhile (fibA < 4000000) {\n    store = fibA;\n    fibA += fibB;\n    fibB = store;\n    if (fibA % 2 === 0) {\n        sum += fibA;\n    }\n}\n\nDocument.getElementById(\"result\").innerHTML = sum;\n```\n\n    ", "Answer": "\r\nSo a few things can help you out here:\n\n\nThe sum up to fibonacci(n) =  fibonacci(n+2) - 1\nThis is nice since you don't have to manually do the sums since you are already doing the sums when you create the sequence\nEven fibonacci numbers are every third fibonacci number. This ends up meaning that the sum of the evens is equal to the sum of all divided by two.\n\n\nFor example:\n\n```\nfibs:     1, 1, 2, 3, 5,  8,  13, 21, 34, 55, 89\nsums:     1, 2, 4, 7, 12, 20, 33, 54, 88\neven_sum: 0, 0, 2, 2, 2,  10, 10, 10, 44\n```\n\n\n\nAlso give a number you can find the which fiboncacci is closest with exceeding it based on some (semi)simple math. (You can also calculate the fibonacci numbers themselves this way, but I'll leave the original function because recursive functions are cool.\n\n\nThe javascript implimentation looks like this:\n\n```\nvar findFibNum = function(num) {\n    var est = Math.log(num * Math.sqrt(5)) /(Math.log((Math.sqrt(5)+1)/2))\n    return Math.floor(est)  \n}\n```\n\n\nKnowing these three things you can make a pretty quick solution:\n\n```\nvar top = 4000000;\n\n/* function finds nth fibonacci number */\nvar fib = function(n){\n    if (n <=1) return n;\n    return fib(n-1) + fib(n-2);\n}\n\n/* given a number this finds closest n below it i.e. for 34 it give 9\n   because 34 is the nineth fibonacci number\n*/\nvar findFibNum = function(num) {\n    var est = Math.log(num * Math.sqrt(5)) /(Math.log((Math.sqrt(5)+1)/2))\n    return Math.floor(est)  \n}\n\n\nvar n = findFibNum(top) /* fib(n) is the largest fibonacci below top */\n\n/* the sum of fibonacci number n is fib(n)+2 -1 -- this beats looping and adding*/\nvar fibsum = fib(n+2) -1\n\n/* it s a nice feature of the sequence that the sum of evens is equal to the sum off all dived by 2 */\nvar evensum = fibsum/2\n```\n\n\nFiddle gives 4613732\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Assembly Language (x86): How to create a loop to calculate Fibonacci sequence\r\n                \r\nI am programming assembly language (x86) in MASM using Visual Studio 2013 Ultimate. I am trying to use an array to calculate a Fibonacci sequence for n elements using an array. In other words, I am trying to go to an array element, obtain the two elements before it, add those up, and store the result in another array. \n\nI am having trouble setting up the index registers to make this work.\n\nI have my program setup like this:\n\n```\nTITLE fibonacci.asm\n\nINCLUDE Irvine32.inc\n\n.data\n    fibInitial  BYTE 0, 1, 2, 3, 4, 5, 6\n    fibComputed BYTE 5 DUP(0)\n\n.code\nmain PROC\n\n    MOVZX si, fibInitial\n    MOVZX di, fibComputed\n    MOV   cl, LENGTHOF fibInitial\n\nL1:\n    MOV   ax, [si - 1]\n    MOV   dx, [si - 2]\n    MOV   bp, ax + dx\n    MOV   dl, TYPE fibInitial\n    MOVZX si, dl\n    MOV   [edi], bp\n    MOV   dh, TYPE fibComputed\n    MOVZX di, dl\n    loop L1\n\nexit\nmain ENDP\nEND main\n```\n\n\nI cannot compile this because of an error message that says \"error A2031: must be index or base register\" for the line ```\nMOV ebp, ax + dx```\n. However, I'm certain that there are other logic errors I am overlooking.\n    ", "Answer": "\r\nrelated: Code-golf print the first 1000 digits of Fib(10**9):  my x86 asm answer using an extended-precision ```\nadc```\n loop, and converting binary to strings.  The inner loop is optimized for speed, other parts for size.\n\nComputing a Fibonacci sequence only requires keeping two pieces of state: the current and previous element.  I have no idea what you're trying to do with ```\nfibInitial```\n, other than counting its length.  This isn't perl where you do ```\nfor $n (0..5)```\n.\nI know you're just learning asm at all, but I'm still going to talk about performance.  There's not much reason to learn asm without knowing what's fast and what's not.  If you don't need performance, let a compiler make the asm for you, from C sources.  Also see the other links at https://stackoverflow.com/tags/x86/info\nUsing registers for your state simplifies the problem of needing to look at ```\na[-1]```\n while calculating ```\na[1]```\n.  You start with ```\ncurr=1```\n, ```\nprev=0```\n, and start with ```\na[0] = curr```\n.  To produce the \"modern\" starting-with-zero sequence of Fibonacci numbers, start with ```\ncurr=0```\n, ```\nprev=1```\n.\nLucky for you, I was just thinking about an efficient loop for fibonacci code recently, so I took the time to write up a complete function.  See below for an unrolled and a vectorized version (saves on store instructions, but also makes 64bit ints fast even when compiling for a 32bit CPU):\n```\n; fib.asm\n;void fib(int32_t *dest, uint32_t count);\n; not-unrolled version.  See below for a version which avoids all the mov instructions\nglobal fib\nfib:\n    ; 64bit SysV register-call ABI:\n    ; args: rdi: output buffer pointer.  esi: count  (and you can assume the upper32 are zeroed, so using rsi is safe)\n\n    ;; locals:  rsi: endp\n    ;; eax: current   edx: prev\n    ;; ecx: tmp\n    ;; all of these are caller-saved in the SysV ABI, like r8-r11\n    ;; so we can use them without push/pop to save/restore them.\n    ;; The Windows ABI is different.\n\n    test   esi, esi       ; test a reg against itself instead of cmp esi, 0\n    jz     .early_out     ; count == 0.  \n\n    mov    eax, 1         ; current = 1\n    xor    edx, edx       ; prev    = 0\n\n    lea    rsi, [rdi + rsi * 4]  ; endp = &out[count];  // loop-end pointer\n    ;; lea is very useful for combining add, shift, and non-destructive operation\n    ;; this is equivalent to shl rsi, 4  /  add rsi, rdi\n\nalign 16\n.loop:                    ; do {\n    mov    [rdi], eax     ;   *buf = current\n    add    rdi, 4         ;   buf++\n\n    lea    ecx, [rax + rdx] ; tmp = curr+prev = next_cur\n    mov    edx,  eax      ; prev = curr\n    mov    eax,  ecx      ; curr=tmp\n ;; see below for an unrolled version that doesn't need any reg->reg mov instructions\n\n    ; you might think this would be faster:\n    ; add  edx, eax    ; but it isn't\n    ; xchg eax, edx    ; This is as slow as 3 mov instructions, but we only needed 2 thanks to using lea\n\n    cmp    rdi, rsi       ; } while(buf < endp);\n    jb    .loop           ; jump if (rdi BELOW rsi).  unsigned compare\n    ;; the LOOP instruction is very slow, avoid it\n\n.early_out:\n    ret\n```\n\nAn alternate loop condition could be\n```\n    dec     esi         ; often you'd use ecx for counts, but we had it in esi\n    jnz     .loop\n```\n\nAMD CPUs can fuse cmp/branch, but not dec/branch.  Intel CPUs can also macro-fuse ```\ndec/jnz```\n.  (Or signed less than zero / greater than zero).  ```\ndec/inc```\n don't update the Carry flag, so you can't use them with above/below unsigned ```\nja/jb```\n.  I think the idea is that you could do an ```\nadc```\n (add with carry) in a loop, using ```\ninc/dec```\n for the loop counter to not disturb the carry flag, but partial-flags slowdowns make this bad on modern CPUs.\n```\nlea  ecx, [eax + edx]```\n needs an extra byte (address-size prefix), which is why I used a 32bit dest and a 64bit address.  (Those are the default operand sizes for ```\nlea```\n in 64bit mode).  No direct impact on speed, just indirect through code size.\nAn alternate loop body could be:\n```\n    mov  ecx, eax      ; tmp=curr.  This stays true after every iteration\n.loop:\n\n    mov  [rdi], ecx\n    add  ecx, edx      ; tmp+=prev  ;; shorter encoding than lea\n    mov  edx, eax      ; prev=curr\n    mov  eax, ecx      ; curr=tmp\n```\n\nUnrolling the loop to do more iterations would mean less shuffling.  Instead of ```\nmov```\n instructions, you just keep track of which register is holding which variable.  i.e. you handle assignments with a sort of register renaming.\n```\n.loop:     ;; on entry:       ; curr:eax  prev:edx\n    mov  [rdi], eax             ; store curr\n    add  edx, eax             ; curr:edx  prev:eax\n.oddentry:\n    mov  [rdi + 4], edx         ; store curr\n    add  eax, edx             ; curr:eax  prev:edx\n\n    ;; we're back to our starting state, so we can loop\n    add  rdi, 8\n    cmp  rdi, rsi\n    jb   .loop\n```\n\nThe thing with unrolling is that you need to clean up any odd iterations that are left over.  Power-of-two unroll factors can make the cleanup loop slightly easier, but adding 12 isn't any faster than adding 16.  (See the previous revision of this post for a silly unroll-by-3 version using ```\nlea```\n to produce ```\ncurr + prev```\n in a 3rd register, because I failed to realize that you don't actually need a temp.  Thanks to rcgldr for catching that.)\nSee below for a complete working unrolled version which handles any count.\n\nTest frontend (new in this version: a canary element to detect asm bugs writing past the end of the buffer.)\n```\n// fib-main.c\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid fib(uint32_t *buf, uint32_t count);\n\nint main(int argc, const char *argv[]) {\n    uint32_t count = 15;\n    if (argc > 1) {\n        count = atoi(argv[1]);\n    }\n    uint32_t buf[count+1]; // allocated on the stack\n    // Fib overflows uint32 at count = 48, so it's not like a lot of space is useful\n\n    buf[count] = 0xdeadbeefUL;\n    // uint32_t count = sizeof(buf)/sizeof(buf[0]);\n    fib(buf, count);\n    for (uint32_t i ; i < count ; i++){\n        printf(\"%u \", buf[i]);\n    }\n    putchar('\\n');\n\n    if (buf[count] != 0xdeadbeefUL) {\n        printf(\"fib wrote past the end of buf: sentinel = %x\\n\", buf[count]);\n    }\n}\n```\n\n\nThis code is fully working and tested (unless I missed copying a change in my local file back into the answer >.<):\n```\npeter@tesla:~/src/SO$ yasm -f elf64 fib.asm && gcc -std=gnu11 -g -Og fib-main.c fib.o\npeter@tesla:~/src/SO$ ./a.out 48\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 512559680 \n```\n\n\nunrolled version\nThanks again to rcgldr for getting me thinking about how to handle odd vs. even count in the loop setup, rather than with a cleanup iteration at the end.\nI went for branchless setup code, which adds 4 * count%2 to the starting pointer.  That can be zero, but adding zero is cheaper than branching to see if we should or not.  The Fibonacci sequence overflows a register very quickly, so keeping the prologue code tight and efficient is important, not just the code inside the loop.  (If we're optimizing at all, we'd want to optimize for many calls with short length).\n```\n    ; 64bit SysV register-call ABI\n    ; args: rdi: output buffer pointer.  rsi: count\n\n    ;; locals:  rsi: endp\n    ;; eax: current   edx: prev\n    ;; ecx: tmp\n    ;; all of these are caller-saved in the SysV ABI, like r8-r11\n    ;; so we can use them without push/pop to save/restore them.\n    ;; The Windows ABI is different.\n\n;void fib(int32_t *dest, uint32_t count);  // unrolled version\nglobal fib\nfib:\n    cmp    esi, 1\n    jb     .early_out       ; count below 1  (i.e. count==0, since it's unsigned)\n\n    mov    eax, 1           ; current = 1\n    mov    [rdi], eax\n    je     .early_out       ; count == 1, flags still set from cmp\n    ;; need this 2nd early-out because the loop always does 2 iterations\n\n;;; branchless handling of odd counts:\n;;;   always do buf[0]=1, then start the loop from 0 or 1\n;;; Writing to an address you just wrote to is very cheap\n;;; mov/lea is about as cheap as best-case for branching (correctly-predicted test/jcc for count%2==0)\n;;; and saves probably one unconditional jump that would be needed either in the odd or even branch\n\n    mov    edx, esi         ;; we could save this mov by using esi for prev, and loading the end pointer into a different reg\n    and    edx, eax         ; prev = count & 1 = count%2\n\n    lea    rsi, [rdi + rsi*4] ; end pointer: same regardless of starting at 0 or 1\n\n    lea    rdi, [rdi + rdx*4] ; buf += count%2\n    ;; even count: loop starts at buf[0], with curr=1, prev=0\n    ;; odd  count: loop starts at buf[1], with curr=1, prev=1\n\nalign 16  ;; the rest of this func is just *slightly* longer than 16B, so there's a lot of padding.  Tempting to omit this alignment for CPUs with a loop buffer.\n.loop:                      ;; do {\n    mov    [rdi], eax       ;;   *buf = current\n             ; on loop entry: curr:eax  prev:edx\n    add   edx, eax          ; curr:edx  prev:eax\n\n;.oddentry: ; unused, we used a branchless sequence to handle odd counts\n    mov   [rdi+4], edx\n    add   eax, edx          ; curr:eax  prev:edx\n                            ;; back to our starting arrangement\n    add    rdi, 8           ;;   buf++\n    cmp    rdi, rsi         ;; } while(buf < endp);\n    jb    .loop\n\n;   dec   esi   ;  set up for this version with sub esi, edx; instead of lea\n;   jnz   .loop\n.early_out:\n    ret\n```\n\nTo produce the starting-with-zero sequence, do\n```\ncurr=count&1;   // and esi, 1\nbuf += curr;    // lea [rdi], [rdi + rsi*4]\nprev= 1 ^ curr; // xor eax, esi\n```\n\ninstead of the current\n```\ncurr = 1;\nprev = count & 1;\nbuf += count & 1;\n```\n\nWe can also save a ```\nmov```\n instruction in both versions by using ```\nesi```\n to hold ```\nprev```\n, now that ```\nprev```\n depends on ```\ncount```\n.\n```\n  ;; loop prologue for sequence starting with 1 1 2 3\n  ;; (using different regs and optimized for size by using fewer immediates)\n    mov    eax, 1               ; current = 1\n    cmp    esi, eax\n    jb     .early_out           ; count below 1\n    mov    [rdi], eax\n    je     .early_out           ; count == 1, flags still set from cmp\n\n    lea    rdx, [rdi + rsi*4]   ; endp\n    and    esi, eax             ; prev = count & 1\n    lea    rdi, [rdi + rsi*4]   ; buf += count & 1\n  ;; eax:curr esi:prev    rdx:endp  rdi:buf\n  ;; end of old code\n\n  ;; loop prologue for sequence starting with 0 1 1 2\n    cmp    esi, 1\n    jb     .early_out           ; count below 1, no stores\n    mov    [rdi], 0             ; store first element\n    je     .early_out           ; count == 1, flags still set from cmp\n\n    lea    rdx, [rdi + rsi*4]   ; endp\n    mov    eax, 1               ; prev = 1\n    and    esi, eax             ; curr = count&1\n    lea    rdi, [rdi + rsi*4]   ; buf += count&1\n    xor    eax, esi             ; prev = 1^curr\n    ;; ESI:curr EAX:prev  (opposite of other setup)\n  ;;\n```\n\n\n```\n  ;; optimized for code size, NOT speed.  Prob. could be smaller, esp. if we want to keep the loop start aligned, and jump between before and after it.\n  ;; most of the savings are from avoiding mov reg, imm32,\n  ;; and from counting down the loop counter, instead of checking an end-pointer.\n  ;; loop prologue for sequence starting with 0 1 1 2\n    xor    edx, edx\n    cmp    esi, 1\n    jb     .early_out         ; count below 1, no stores\n    mov    [rdi], edx         ; store first element\n    je     .early_out         ; count == 1, flags still set from cmp\n\n    xor    eax, eax  ; movzx after setcc would be faster, but one more byte\n    shr    esi, 1             ; two counts per iteration, divide by two\n  ;; shift sets CF = the last bit shifted out\n    setc   al                 ; curr =   count&1\n    setnc  dl                 ; prev = !(count&1)\n\n    lea    rdi, [rdi + rax*4] ; buf+= count&1\n\n  ;; extra uop or partial register stall internally when reading eax after writing al, on Intel (except P4 & silvermont)\n  ;; EAX:curr EDX:prev  (same as 1 1 2 setup)\n  ;; even count: loop starts at buf[0], with curr=0, prev=1\n  ;; odd  count: loop starts at buf[1], with curr=1, prev=0\n\n  .loop:\n       ...\n    dec  esi                  ; 1B smaller than 64b cmp, needs count/2 in esi\n    jnz .loop\n  .early_out:\n    ret\n```\n\n\nvectorized:\nThe Fibonacci sequence isn't particularly parallelizable.  There's no simple way to get F(i+4) from F(i) and F(i-4), or anything like that.  What we can do with vectors is fewer stores to memory.  Start with:\n```\na = [f3 f2 f1 f0 ]   -> store this to buf\nb = [f2 f1 f0 f-1]\n```\n\nThen ```\na+=b;  b+=a;  a+=b;  b+=a;```\n produces:\n```\na = [f7 f6 f5 f4 ]   -> store this to buf\nb = [f6 f5 f4 f3 ]\n```\n\nThis is less silly when working with two 64bit ints packed into a 128b vector.  Even in 32bit code, you can use SSE to do 64bit integer math.\nA previous version of this answer has an unfinished packed-32bit vector version that doesn't properly handle ```\ncount%4 != 0```\n.  To load the first 4 values of the sequence, I used ```\npmovzxbd```\n so I didn't need 16B of data when I could use only 4B.  Getting the first -1 .. 1 values of the sequence into vector registers is a lot easier, because there's only one non-zero value to load and shuffle around.\n```\n;void fib64_sse(uint64_t *dest, uint32_t count);\n; using SSE for fewer but larger stores, and for 64bit integers even in 32bit mode\nglobal fib64_sse\nfib64_sse:\n    mov eax, 1\n    movd    xmm1, eax               ; xmm1 = [0 1] = [f0 f-1]\n    pshufd  xmm0, xmm1, 11001111b   ; xmm0 = [1 0] = [f1 f0]\n\n    sub esi, 2\n    jae .entry  ; make the common case faster with fewer branches\n    ;; could put the handling for count==0 and count==1 right here, with its own ret\n\n    jmp .cleanup\nalign 16\n.loop:                          ; do {\n    paddq   xmm0, xmm1          ; xmm0 = [ f3 f2 ]\n.entry:\n    ;; xmm1: [ f0 f-1 ]         ; on initial entry, count already decremented by 2\n    ;; xmm0: [ f1 f0  ]\n    paddq   xmm1, xmm0          ; xmm1 = [ f4 f3 ]  (or [ f2 f1 ] on first iter)\n    movdqu  [rdi], xmm0         ; store 2nd last compute result, ready for cleanup of odd count\n        add     rdi, 16         ;   buf += 2\n    sub esi, 2\n        jae   .loop             ; } while((count-=2) >= 0);\n    .cleanup:\n    ;; esi <= 0 : -2 on the count=0 special case, otherwise -1 or 0\n\n    ;; xmm1: [ f_rc   f_rc-1 ]  ; rc = count Rounded down to even: count & ~1\n    ;; xmm0: [ f_rc+1 f_rc   ]  ; f(rc+1) is the value we need to store if count was odd\n    cmp esi, -1\n    jne   .out  ; this could be a test on the Parity flag, with no extra cmp, if we wanted to be really hard to read and need a big comment explaining the logic\n    ;; xmm1 = [f1 f0]\n    movhps  [rdi], xmm1         ; store the high 64b of xmm0.  There is no integer version of this insn, but that doesn't matter\n    .out:\n        ret\n```\n\nNo point unrolling this further, the dep chain latency limits throughput, so we can always average storing one element per cycle.  Reducing the loop overhead in uops can help for hyperthreading, but that's pretty minor.\nAs you can see, handling all the corner cases even when unrolling by two is quite complex to keep track of.  It requires extra startup overhead, even when you're trying to optimize that to keep it to a minimum.  It's easy to end up with a lot of conditional branches.\nupdated main:\n```\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n#ifdef USE32\nvoid fib(uint32_t *buf, uint32_t count);\ntypedef uint32_t buftype_t;\n#define FMTx PRIx32\n#define FMTu PRIu32\n#define FIB_FN fib\n#define CANARY 0xdeadbeefUL\n#else\nvoid fib64_sse(uint64_t *buf, uint32_t count);\ntypedef uint64_t buftype_t;\n#define FMTx PRIx64\n#define FMTu PRIu64\n#define FIB_FN fib64_sse\n#define CANARY 0xdeadbeefdeadc0deULL\n#endif\n\n#define xstr(s) str(s)\n#define str(s) #s\n\nint main(int argc, const char *argv[]) {\n    uint32_t count = 15;\n    if (argc > 1) {\n        count = atoi(argv[1]);\n    }\n    int benchmark = argc > 2;\n\n    buftype_t buf[count+1]; // allocated on the stack\n    // Fib overflows uint32 at count = 48, so it's not like a lot of space is useful\n\n    buf[count] = CANARY;\n    // uint32_t count = sizeof(buf)/sizeof(buf[0]);\n    if (benchmark) {\n       int64_t reps = 1000000000 / count;\n       for (int i=0 ; i<=reps ; i++)\n           FIB_FN(buf, count);\n\n    } else {\n       FIB_FN(buf, count);\n       for (uint32_t i ; i < count ; i++){\n           printf(\"%\" FMTu \" \", buf[i]);\n       }\n       putchar('\\n');\n    }\n    if (buf[count] != CANARY) {\n        printf(xstr(FIB_FN) \" wrote past the end of buf: sentinel = %\" FMTx \"\\n\", buf[count]);\n    }\n}\n```\n\n\nPerformance\nFor ```\ncount```\n just below 8192 (fitting in L1d cache), the unrolled-by-two non-vector version runs near its theoretical-max throughput of 1 store per cycle (3.5 instructions per cycle), on my Sandybridge i5-2500k.  8192 * 4B/int = 32768 = L1 cache size.  In practice, I see ~3.3 to ~3.4 insn / cycle.  I'm counting the entire program with Linux ```\nperf stat```\n, though, not just the tight loop.  (Note the repeat loop calling the Fib function, so the majority of the program's time is spent in it, even though there's some startup overhead.)\nAnyway, there's not really any point unrolling further.  And obviously this stopped being a Fibonacci sequence after count=47, since we use uint32_t.  However, for large ```\ncount```\n, the throughput is limited by memory bandwidth, down to ~2.6 insn / cycle.  At this point we're basically looking at how to optimize memset.\nThe 64-bit-integer version using ```\nmovdqu```\n stores (```\nfib64_sse```\n) runs at 3 insns per cycle (one 128b store per two clocks) up to an array size of about 1.5 times L2 cache size.  (i.e. ```\n./fib64 49152```\n).  As the array size goes up to larger fractions of L3 cache size, performance decreases down to ~2 insn per cycle (one store per 3 clocks) at 3/4 of L3 cache size.  It levels out to 1 store per 6 cycles at sizes > L3 cache.\nSo storing with vectors does better than scalar with arrays too big for L1d cache but which do fit in L2 cache.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence on 68HC11 using 4-byte numbers\r\n                \r\nI'm trying to figure out a way to implement the Fibonacci sequence using a 68HC11 IDE that uses a Motorolla as11 assembler. \n\nI've done it using 2-byte unsigned in little-endian format, now I'm attempting to change it using 4-byte variables, using big-endian\n\nMy pseudo-code (which is written in c):\n\n```\nRESULT = 1;\nPREV = 1;\nCOUNT = N;\nWHILE(COUNT > 2){\n    NEXT = RESULT + PREV;\n    PREV = RESULT;\n    RESULT = NEXT;\n    COUNT--;\n}\n```\n\n\nI'll include some of my current assembly code. Please note that count is set to unsigned int at 1-byte, and prev, next, and result are unsigned ints at 2 bytes. N is unsigned, set to 10. \n\n```\n        ORG     $C000\n        LDD     #1\n        STD     RESULT      \n        STD     PREV        \n        LDAA    N\n        STAA    COUNT       \nWHILE   LDAA    COUNT\n        CMPA    #2      \n         BLS    ENDWHILE\n         LDD    RESULT      \n        ADDD    PREV    \n         STD    NEXT           \n         LDD    RESULT  \n         STD    PREV           \n         LDD    NEXT\n         STD    RESULT         \n         DEC    COUNT          \n         BRA    WHILE       \nENDWHILE\nDONE     BRA    DONE\n    END\n```\n\n\nThe issue that I'm having is now altering this (other than the obvious variable changes/declarations) N will begin at 40 now, not 10. Would altering my pseudo-code to include pointers allow me to implement it 1 to 1 better with big-endian? Since this is in little-endian, I assume I have to alter some of the branches. Yes this is an assignment for class, I'm not looking for the code, just some guidance would be nice. \n\nThank you!\n    ", "Answer": "\r\n(Your problem description is a bit vague as to what your actual problem is, so I may be guessing a bit.)\n\nBTW, 68HC11 is big-endian.\n\nThe 68HC11 has a 16-bit accumulator, so as soon as your result overflows this, you need to do math operations in pieces.\n\nI suppose you mean that by changing N from 10 to 40 your fibonacci number becomes too big to be stored in a 16-bit variable.\n\nThe use or not of pointers is irrelevant to your problem as you can solve it both with or without them.  For example, you can use a pointer to tell your routine where to store the result.\n\nDepending on your maximum expected result, you need to adjust your routine.  I will assume you won't need to go over 32-bit result (N=47 => 2971215073).\n\nHere's a partially tested but unoptimized possibility (using ASM11 assembler):\n\n```\nSTACKTOP            equ       $1FF\nRESET_VECTOR        equ       $FFFE\n\n                    org       $100                ;RAM\n\nresult              rmb       4\n\n                    org       $d000               ;ROM\n\n;*******************************************************************************\n; Purpose: Return the Nth fibonacci number in result\n; Input  : HX -> 32-bit result\n;        : A = Nth number to calculate\n; Output : None\n; Note(s):\n\nGetFibonacci        proc\n                    push                          ;macro to save D, X, Y\n\n          ;--- define & initialize local variables\n\n                    des:4                         ;allocate 4 bytes on stack\ntmp@@               equ       5                   ;5,Y: temp number\n\n                    ldab      #1\n                    pshb\n                    clrb\n                    pshb:3\nprev@@              equ       1                   ;1,Y: previous number (initialized to 1)\n\n                    psha\nn@@                 equ       0                   ;0,Y: N\n          ;---\n                    tsy                           ;Y -> local variables\n\n                    clra\n                    clrb\n                    std       ,x\n                    std       prev@@,y\n\n                    ldd       #1\n                    std       2,x\n                    std       prev@@+2,y\n\nLoop@@              ldaa      n@@,y\n                    cmpa      #2\n                    bls       Done@@\n\n                    ldd       2,x\n                    addd      prev@@+2,y\n                    std       tmp@@+2,y\n\n                    ldaa      1,x\n                    adca      prev@@+1,y\n                    staa      tmp@@+1,y\n\n                    ldaa      ,x\n                    adca      prev@@,y\n                    staa      tmp@@,y\n\n                    ldd       ,x\n                    std       prev@@,y\n                    ldd       2,x\n                    std       prev@@+2,y\n\n                    ldd       tmp@@,y\n                    std       ,x\n                    ldd       tmp@@+2,y\n                    std       2,x\n\n                    dec       n@@,y\n                    bra       Loop@@\n\nDone@@              ins:9                         ;de-allocate all locals from stack\n                    pull                          ;macro to restore D, X, Y\n                    rts\n\n;*******************************************************************************\n; Test code\n;*******************************************************************************\n\nStart               proc\n                    ldx       #STACKTOP           ;setup our stack\n                    txs\n\n                    ldx       #result\n                    ldaa      #40                 ;Nth fibonacci number to get\n                    bsr       GetFibonacci\n                    bra       *                   ;check 'result' for answer\n\n                    org       RESET_VECTOR\n                    dw        Start\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence - using While True\r\n                \r\nI've been trying for a while to solve this Fibonacci question and to write it correctly but I always getting not the right results and its stuck at the first If in the code.\n\nCode Below:\n\n```\ndef main():\n    num = 1\n    num2 = 1\n    num3 = 2\n    Katan = True\n\n    while Katan == True:\n        if (num3 == 2):\n            print num,num2,num3\n            num3 = num2 + num3\n            num2 = num3\n        elif num3 < 10000:\n            num3 = num + num2\n            num2 = num\n            print num,num2,num3\n            num = num2\n        else:\n            Katan = False\n\nif __name__ == '__main__':\n    main()\n```\n\n    ", "Answer": "\r\nThis can be done simpler than what you are trying with something like this:\n\n```\ndef main():\n    # You don't need to store 3 numbers, 2 is enough\n    num1 = 1\n    num2 = 1\n\n    # You don't need a variable for the while condition, ...\n    while True:\n        print num1\n\n        if num2 > 10000:\n            break # ... you can just break it when some condition is met\n\n        # You can \"switch\" variables like this\n        num1, num2 = num2, num2 + num1\n\nif __name__ == '__main__':\n    main()\n```\n\n\nYou can make it even simpler by using a generator.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Recursive calls for fibonacci sequence\r\n                \r\nFor finding Fibonacci numbers recursively the relation is f(n)=f(n-1)+f(n-2).\nHow many times is f(n-i) called (in terms of n and i) for recursive function of f(n) ?\n\nI understand that while tracing the recursive calls a binary tree is made. However there does not appear to be any fixed pattern for determining number of recursive calls to f(n-i).Any advice ?\n\nFor example, in finding f(5),  \n\n```\nf(5)=f(4)+f(3)  \nf(5)=f(3)+f(2)+f(2)+f(1)  \nf(5)=f(2)+f(1)+f(1)+f(0)+f(1)+f(0)+f(1)  \nf(5)=f(1)+f(0)+f(1)+f(1)+f(0)+f(1)+f(0)+f(1)\n```\n\n\nHere number of calls to f(5)-1,f(4)-1,f(3)-2,f(2)-3,f(1)-5,f(0)-3.\n\nThanks.\n    ", "Answer": "\r\nThe sequence 1, 1, 2, 3, 5, 3 should look familiar, because ignoring the last number it is the Fibonacci sequence again.\n\nLet c(x) be the number of times fib(x) is called in the computation of fib(n).\n\n\nc(x) = 0 for all x > n, since fib(x) is never called.\nc(n) = 1, as fib(n) is called exactly once.\nc(x) = c(x + 1) + c(x + 2) for all 0 < x < n, as fib(x) is called from fib(x + 1) and fib(x + 2).\nc(0) = c(2), a special case, since fib(0) is called from fib(2) but not fib(1).\n\n\nSo the sequence c(n), c(n-1), ..., c(2), c(1) is the Fibonacci sequence and c(0) is equal to c(2).\n\nIn terms of i and n,\n\n\nfib(n - i) is called fib(i + 1) times for 0 ≤ i < n\nfib(n - n) = fib(0) is called fib(n - 1) times.\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence printing wrong value [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nImplementation of fibonacci in Java:\n\n```\n public class Fibonacci {\n\n    private int fibonacci(int n){\n        return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n    }\n\n    private void test(){\n        System.out.println(fibonacci(4));\n    }\n\n    public static void main(String[] args) {\n        Fibonacci test = new Fibonacci();\n        test.test();\n\n    }\n\n}\n```\n\n\nUsing Oracle Java 8 on Ubuntu, it prints out 3 in Eclipse. But I was expecting 5:\n\n```\n                        fibonacci(4)\n            fibonacci(3)                                 fibonacci(2)\n      fibonacci(2)      fibonacci(1)            fibonacci(1)        fibonacci(0)\nfibonacci(1) fibonacci(0)   1                      1                         1\n    1            1\n```\n\n\nSo then what's wrong with my Java implementation?\n    ", "Answer": "\r\nYour ```\nfibonacci(int n)```\n in Java will return 0 for ```\nn=0```\n. You want to always return ```\n1```\n for n<2. Replace:\n\n```\n return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n```\n\n\nwith\n\n```\n return n < 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2);\n```\n\n\nAs it currently stands, the following is evaluated: (f is short for fibonacci)\n\n```\nf(4)\nf(3)+f(2)\n(f(1)+f(2))+(f(0)+f(1))\n(1+(f(0)+f(1)))+(0+1)\n(1+0+1)+(0+1)\n2+1\n3\n```\n\n\nThe following should occur:\n\n```\nf(4)\nf(3)+f(2)\n(f(1)+f(2))+(f(0)+f(1))\n(1+(f(1)+f(1)))+(1+1)\n(1+1+1)+(1+1)\n3+2\n5\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generating incorrect Fibonacci sequences in C\r\n                \r\nI'm trying to learn C and I am struggling to see where the error is in this simple program:\n\n```\n// variable length arrays.\n\n#include <stdio.h>\n\nint main (void)\n{\n    int i, numFibs;\n\n    printf (\"How many Fibonacci numbers do you want (between 1 and 75)? \");\n    scanf (\"%i\", &numFibs);\n\n    if (numFibs < 1 || numFibs > 75) {\n        printf (\"Bad number, sorry!\\n\");\n        return 1;\n    }\n\n    unsigned long long int Fibonacci[numFibs];\n\n    Fibonacci[0] = 0;\n    Fibonacci[1] = 1;\n\n    for (i = 2; i < numFibs; ++i)\n        Fibonacci[i] = Fibonacci[i-2] + Fibonacci[i-1];\n\n    for (i = 0; i < numFibs; ++i)\n        printf (\"%i    %llu\\n\", i, Fibonacci[i]);\n\n    printf (\"\\n\");\n\n    return 0;\n\n}\n```\n\n\nThis program is from the textbook 'Programming in C'.\n\nWhy is it producing a bad sequence:\n\n```\nHow many Fibonacci numbers do you want (between 1 and 75)? 70\n```\n\n\n// removed some.\n\n```\n31    1346269\n32    2178309\n33    3524578\n34    5702887\n35    9227465\n36    14930352\n37    24157817\n38    39088169\n39    63245986\n40    102334155\n41    165580141\n42    267914296\n43    433494437\n44    701408733\n45    1134903170\n46    1836311903\n47    2971215073\n48    512559680\n49    3483774753\n50    3996334433\n51    3185141890\n52    2886509027\n53    1776683621\n```\n\n\nIt begins to go wrong. 48 should be 4807526976, according to http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibtable.html.\n\nI think it may be overflowing? But the book does not warn about that. Hmm...\n    ", "Answer": "\r\nReason: It overflows.\n\nNotice that ```\n4807526976 - 512559680 = 4294967296 = 2^32```\n, it's believed on your platform the type ```\nunsigned long long```\n is 32 bit instead of 64 bit.\n\nSolution: try using larger integer types like ```\nint64_t```\n (you may need to include ```\nstdint.h```\n) or maintain your own high precision data type.\n\nFor more info on integer overflows, see http://en.wikipedia.org/wiki/Integer_overflow\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Filtering fibonacci sequence in Haskell\r\n                \r\nI'm trying to filter a list that contains the Fibonacci numbers.\n\nWhat I need is only odd numbers, and less or equal than ```\nN```\n.\n\nThis is what I have so far:\n\n```\nfib   n | n == 0         = 0\n        | n == 1         = 1\n        | otherwise = fib (n-1) + fib (n-2)\n\nfibs n = [a | a <- [fib x | x <- [1..]], odd a, a < n]\n```\n\n\nThat will give me what I want, but at the same time that solution won't work because I don't know how to stop retrieving elements from ```\nfib```\n function. Of course, that is because of ```\nx <- [1..]```\n.\n\nI have thought about two options:  \n\n\nPlacing a limit (that depends on ```\nn```\n) in ```\nx <- [1..]```\n\nDefining ```\nfibs```\n recursive so I can know when to stop (thought about it while writing the question)\n\n\nHow could I do this?\n\nI'm not looking for an efficient way\n\nEdit:\nHere are the two solutions I had at the end:\n\n```\nfib   n | n == 0         = 0\n        | n == 1         = 1\n        | otherwise = fib (n-1) + fib (n-2)\n\nfibsAux n k xs  | a < n     = fibsAux n (k+1) (xs ++ [a])\n                | otherwise = xs\n                where \n                    a = fib k\nfibs n = filter odd $ fibsAux n 0 []\n```\n\n\nand the one using the suggestion of @hammar:\n\n```\nfibs x = takeWhile (< x) [a | a <- [fib x | x <- [1..]], odd n]\n```\n\n    ", "Answer": "\r\nHave a look at the ```\ntakeWhile```\n function from  Data.List (and re-exported by the Prelude). For example,\n\n```\ntakeWhile (< 4) [1..] == [1, 2, 3]\n```\n\n\nNote that even though the list is infinite, this terminates once it finds an element that does not satisfy the predicate.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence Pseudo-code Java\r\n                \r\nI'm trying to refresh my pseudo-code understanding and wanted to see what the correct way of writing out a Fibonacci number @ n would be.\n\nGiven the code:\n\n```\npublic class FibAtN{\n     public static void main(String args[]){\n          int j = 0;\n          int k = j;\n          int l = 1;\n          int n =; /*input*/\n\n          for(int i=0;i<n;i++){\n               j=k;\n               k=l;\n               l=j+k;\n          }\n          System.out.println(j);\n    }\n}\n```\n\n\nWould the correct use of Pseudo-code be?\n\n```\nPROGRAM FibonnacciAtN\n     INITIALIZE four integers (say: j,k,l,n)\n     SET j equal zero, k equal j, l equal 1\n     SET n equal to INPUT\n     FOR (integer count is less than n, INCREMENT count every loop) DO\n          SET j=k, k=l, l=j+k\n     PRINT integer j\n```\n\n\nThanks!\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in a vector\r\n                \r\nI was thinking about the complexity of the recursive approach to the fibonnaci sequence and i wanted to try storing the numbers in a vector so that my program can look at the last two numbers the vector contains to produce the next. I wrote a procedure that i thought would append the next number to the fibs vector using a pointer to the vectors last element, but nothing happens (when i print the vector after calling the procedure, it still only contains 0 and 1 i appended manualy as the edge condition.\n\nIs this a scope issue?\n\n```\nvector<int>fibs;\ntemplate <typename Iterator>\nvoid newfib(Iterator it) {\n   fibs.push_back(*(it-1)+*(it-2));\n }     \n\nint main () {\n\nvector<int>fibs;\nfibs.push_back(0); fibs.push_back(1);\nnewfib(fibs.end());\nreturn 0;\n}\n```\n\n\nThanks for the help!\n    ", "Answer": "\r\nYou declare two verctors with same name: one in global scope, second in main function. In function ```\nnewfib```\n you append to global vector, but in main function you print local, which stays unchanged. \n\nI suggest avoid using global variables and pass vector by refernece, for example.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in python using generator\r\n                \r\n```\ndef fibonacci_sequence():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b, a+b\n\nfor i in range(10):\n    print(fibonacci_sequence().__next__())\n```\n\n\nI tried using this in Python 3 to print out the fibonacci series. But the program just ends up printing 1 over and over again\n    ", "Answer": "\r\nYou are declaring on each iteration a new generator you need to create one outside of the loop.\n\n```\ndef fibonacci_sequence():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b, a+b\n\ngenerator = fibonacci_sequence()\nfor i in range(10):\n    print(generator.__next__())\n```\n\n\nYou could also use ```\nnext()```\n\n\n```\ngenerator = fibonacci_sequence()\nfor i in range(10):\n    print(next(generator))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Matlab: How to get the Nth element in fibonacci sequence recursively without loops or inbuilt functions\r\n                \r\nI am attempting to write a recursive code that takes an input n and outputs the nth term of the Fibonacci sequence, without using any loops or any of MATLABS inbuilt functions. \n\nfor exemple:\n\n```\nfibo(6)\n\nans = 8\n```\n\n\nI am having trouble with writing the code recursively, and would really appreciate some help.\n\nwith a loop I wrote:\n\n```\nfunction f = fib1(n)\n    if n <= 1\n        f = 1;\n    else\n        f = fib1(n-1) + fib1(n-2);\n    end\nend\n```\n\n    ", "Answer": "\r\nIf you want to get ```\n8```\n for ```\nfib1(6)```\n, that means you need to start your fibonacci sequence from ```\nn=1```\n. However, you code indicates that you start from ```\nn=0```\n. In this case, you should use ```\nn <=2```\n in your ```\nif-else```\n statement, i.e., \n\n```\nfunction f = fib1(n)\n    if n <= 2\n        f = 1;\n    else\n        f = fib1(n-1) + fib1(n-2);\n    end\nend\n```\n\n\nsuch that\n\n```\n>> fib1(6)\nans =  8\n```\n\n\n\n\nIf you don't want to use any recursion, you can try the code below\n\n```\nfunction f = fib2(n)\n  f = (((1+sqrt(5))/2)^n - ((1-sqrt(5))/2)^n)/sqrt(5);\nend\n```\n\n\nwhich gives\n\n```\n>> fib2(6)\nans =  8\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why is the Fibonacci Sequence Big O(2^n) instead of O(logn)?\r\n                \r\nI took discrete math (in which I learned about master theorem, Big Theta/Omega/O) a while ago and I seem to have forgotten the difference between O(logn) and O(2^n) (not in the theoretical sense of Big Oh). I generally understand that algorithms like merge and quick sort are O(nlogn) because they repeatedly divide the initial input array into sub arrays until each sub array is of size 1 before recursing back up the tree, giving a recursion tree that is of height logn + 1. But if you calculate the height of a recursive tree using n/b^x = 1 (when the size of the subproblem has become 1 as was stated in an answer here) it seems that you always get that the height of the tree is log(n).\nIf you solve the Fibonacci sequence using recursion, I would think that you would also get a tree of size logn, but for some reason, the Big O of the algorithm is O(2^n). I was thinking that maybe the difference is because you have to remember all of the fib numbers for each subproblem to get the actual fib number meaning that the value at each node has to be recalled, but it seems that in merge sort, the value of each node has to be used (or at least sorted) as well. This is unlike binary search, however, where you only visit certain nodes based on comparisons made at each level of the tree so I think this is where the confusion is coming from.\nSo specifically, what causes the Fibonacci sequence to have a different time complexity than algorithms like merge/quick sort?\n    ", "Answer": "\r\nThe other answers are correct, but don't make it clear - where does the large difference between the Fibonacci algorithm and divide-and-conquer algorithms come from? Indeed, the shape of the recursion tree for both classes of functions is the same - it's a binary tree.\nThe trick to understand is actually very simple: consider the size of the recursion tree as a function of the input size ```\nn```\n.\nIn the Fibonacci recursion, the input size ```\nn```\n is the height of the tree; for sorting, the input size ```\nn```\n is the width of the tree. In the former case, the size of the tree (i.e. the complexity) is an exponent of the input size, in the latter: it is input size multiplied by the height of the tree, which is usually just a logarithm of the input size.\nMore formally, start by these facts about binary trees:\n\nThe number of leaves ```\nn```\n is a binary tree is equal to the the number of non-leaf nodes plus one. The size of a binary tree is therefore 2n-1.\nIn a perfect binary tree, all non-leaf nodes have two children.\nThe height ```\nh```\n for a perfect binary tree with ```\nn```\n leaves is equal to ```\nlog(n)```\n, for a random binary tree: ```\nh = O(log(n))```\n, and for a degenerate binary tree ```\nh = n-1```\n.\n\nIntuitively:\n\nFor sorting an array of ```\nn```\n elements with a recursive algorithm, the recursion tree has ```\nn```\n leaves. It follows that the width of the tree is ```\nn```\n, the height of the tree is ```\nO(log(n))```\n on the average and  ```\nO(n)```\n in the worst case.\n\nFor calculating a Fibonacci sequence element ```\nk```\n with the recursive algorithm, the recursion tree has ```\nk```\n levels (to see why, consider that ```\nfib(k)```\n calls ```\nfib(k-1)```\n, which calls ```\nfib(k-2)```\n, and so on). It follows that height of the tree is ```\nk```\n. To estimate a lower-bound on the width and number of nodes in the recursion tree, consider that since ```\nfib(k)```\n also calls ```\nfib(k-2)```\n, therefore there is a perfect binary tree of height ```\nk/2```\n as part of the recursion tree. If extracted, that perfect subtree would have 2k/2 leaf nodes. So the width of the recursion tree is at least ```\nO(2^{k/2})```\n or, equivalently, ```\n2^O(k)```\n.\n\n\nThe crucial difference is that:\n\nfor divide-and-conquer algorithms, the input size is the width of the binary tree.\nfor the Fibonnaci algorithm, the input size is it the height of the tree.\n\nTherefore the number of nodes in the tree is ```\nO(n)```\n in the first case, but ```\n2^O(n)```\n in the second. The Fibonacci tree is much larger compared to the input size.\nYou mention Master theorem; however, the theorem cannot be applied to analyze the complexity of Fibonacci because it only applies to algorithms where the input is actually divided at each level of recursion. Fibonacci does not divide the input; in fact, the functions at level ```\ni```\n produce almost twice as much input for the next level ```\ni+1```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms\r\n                \r\ni am new to solve this type of problems using java script\n\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n\nBy considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\n\nthis is my java script\n\n```\nfunction solution()  \n{  \nvar fibno = [ 1, 2 ], sum = 0;  \n\nfunction cal(arr )  \n{  \nreturn arr[ arr.length - 1 ] + arr[ arr.length - 2 ];  \n}  \n\nwhile ( fibno[ fibno.length - 1 ] < 4e+6 )  \n{  \n  fibno.push( cal(fibno) );  \n}  \n\nfibno.forEach( function(n)   \n {  \n    if ( n % 2 === 0 )  \n    {  \n        sum += n;  \n    }  \n});  \nreturn sum;  \n}  \n\nconsole.log(solution()) \n```\n\n\nI don't understand how to print fibonacci series using html not using console for this java script\n\nplease help me.....\n    ", "Answer": "\r\nThis works for me:\n\n\r\n\r\n```\nfunction* fibonacci(){\r\n  var fn1 = 0;\r\n  var fn2 = 1;\r\n  while (true){  \r\n    var current = fn1;\r\n    fn1 = fn2;\r\n    fn2 = current + fn1;\r\n    var reset = yield current;\r\n    if (reset){\r\n        fn1 = 0;\r\n        fn2 = 1;\r\n    }\r\n  }\r\n}\r\n\r\nvar sequence = fibonacci();\r\n\r\nvar sum = 0, x = sequence.next().value;\r\n\r\nwhile(x < 4000000){\r\n    if(x % 2 === 0){\r\n         sum += x;  \r\n    } \r\n    x = sequence.next().value;\r\n}\r\n\r\nconsole.log(sum);\r\ndocument.getElementById('res').innerHTML = sum;```\n\r\n```\n<div id=\"res\"></div>```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How many numbers are in the Fibonacci sequence\r\n                \r\nAssuming I'm asked to generate Fibonacci numbers up to N, how many numbers will I generate? I'm looking for the count of Fibonacci numbers up to N, not the Nth number.\n\nSo, as an example, if I generate Fibonacci numbers up to 25, I will generate:\n\n\n1, 1, 2, 3, 5, 8, 13, 21\nthat's 8 numbers\n\n\nHow do I calculate this mathematically for an arbitrary \"n\"?\n    ", "Answer": "\r\nYou can use the following formula (see here):\n\n```\nn(F) = Floor(Log(F * Sqrt(5) + 1/2) / Log(Phi))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci recursive function with an output of the array of the sequence in JavaScript\r\n                \r\nHi I was trying to come up with a function to return a fibonacci sequence, that is an array not the usual last n-th fibonacci number.\n\n```\nfunction fib(n,arr=[0]) {\n  if (n===0||n===1) {\n    arr.push(n)\n    return arr;\n  }\n  let arr2 = fib(n-2);\n  let arr1 = fib(n-1);\n  arr1.push(arr2[arr2.length-1]+arr1[arr1.length-1]);\n  return arr1;\n}\n```\n\n\nit works fine but I am not happy with the hard coded arr=[0] here. I tried to put arr=[] instead but the sequence I ended up getting excluded the first 0 entries in the array which should've been there.\n\nI am sure there's better approaches to solve this.\n\nP.S: I want to solve this using a recursive approach and I know it has a poor exponential time complexity but I just wanted to pratice my recursive programming skills.\n    ", "Answer": "\r\n```\n  let arr2 = fib(n-2);\n  let arr1 = fib(n-1);\n```\n\n\nYou build up two arrays for each step, so you build up n! arrays... Instead just use one recursive call, e.g.:\n\n```\n function fibonacci(n){\n   if(n <= 2)\n      return [0, 1].slice(0, n);\n   const res = fibonacci(n - 1);\n   res.push(res[res.length - 1] + res[res.length - 2])\n   return res;\n }\n```\n\n\n\n\nBut do you really need recursion?:\n\n```\n function fibonacci(n){\n   const arr = [0, 1].slice(0 , n);\n   for(let i = 2; i < n; i++)\n     arr[i] = arr[i - 1] + arr[i - 2];\n   return arr;\n }\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "functional programming: recursive loop output fibonacci sequence in scala\r\n                \r\nLearning functional programming using scala. Came across this exercise. \n\nWrite a recursive function to get the nth Fibonacci number (http://mng.bz/C29s). The first two Fibonacci numbers are 0 and 1. The nth number is always the sum of the previous two—the sequence begins 0, 1, 1, 2, 3, 5. Your definition should use a local tail-recursive function.\n\n```\ndef fib(n: Int): Int\n```\n\n\nMy answer computes n+1 values and returns the nth. Can anyone show me a better implementation where the extra n+1th value is not computed?\n\n```\nobject patterns {\n\n    def fib(n : Int): Int = {\n        @annotation.tailrec\n        def go(n: Int, prev2: Int, prev: Int): Int =\n            if(n<=0) prev2 \n            else go(n-1, prev, prev2+prev)\n        go(n, 0, 1)\n      }\n}\n```\n\n\nIn case anyone is interested, this is from the book functional programming in scala by Chiusano and Bjarnason. Exercise 2.1\nLooking forward to the replies.\n    ", "Answer": "\r\nI think this:\n\n```\ndef fib2(n: Int): Int = {\n  if (n < 1) 0\n  else if (n < 2) 1\n  else {\n    @annotation.tailrec\n    def go(i: Int, prev2: Int, prev: Int): Int =\n      if (i == n) prev\n      else go(i + 1, prev, prev2 + prev)\n    go(2, 1, 1)\n  }\n}\n```\n\n\nor using ByName param:\n\n```\ndef fib3(n: Int): Int = {\n  @annotation.tailrec\n  def go(n: Int, prev2: Int, prev: => Int): Int =\n    //                            ^ ByName\n    if (n <= 0) prev2\n    else {\n      val p = prev\n      go(n - 1, p, prev2 + p)\n    }\n  go(n, 0, 1)\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Stream of fibonacci sequence in Scheme\r\n                \r\nI'm currently trying to understand the concept of streams in scheme. As an example I'm supposed to write a function ```\nfibonacci```\n that returns fibonacci numbers as a stream representation.\n\nThe desired output/usage of the function looks like this:\n\n```\n> (define a (finbonacci))\n> a\n((0 0) . #<promise>)\n> (tail a)\n((1 1) . #<promise>)\n> (tail (tail a))\n((2 1) . #<promise>)\n```\n\n\nSo each stream element represents a pair of ```\nn fib(n)```\n.\n\nA stream is pre-defined like this:\n\n```\n(define the-empty-stream '())\n\n(define-syntax cons-stream\n  (syntax-rules ()\n    ((cons-stream x y)\n     (cons x (delay y)))))\n\n(define head car)\n(define (tail s) (force (cdr s)))\n(define empty-stream? null?) \n```\n\n\nMy current very basic attempt for a solution is the following:\n\n```\n(define fibo\n    (cons-stream 1\n                 (cons-stream 1\n                              (map + fibo (tail fibo))))))\n```\n\n\nBut even if this would calculate anything, I would not know how to pass ```\nn```\n into the output or the following stream. \n    ", "Answer": "\r\nYou are on the right path. The only thing that needs to be adjusted is the precise formulation of the recursive definition.\n\nConsider the following (where --- means we are adding):\n\n```\n1 1 2 3 5   8  ...   fib\n1 2 3 5 8  13  ...   (stream-rest fib)\n------------------   ---------------------------------\n2 3 5 8 13 21  ...   (stream-rest (stream-rest fib))\n```\n\n\nNote that ```\n(stream-rest (stream-rest fib))```\n is the sum of ```\nfib```\n and ```\n(stream-rest fib)```\n.\nThat means that we can define ```\nfib```\n as:\n\n```\n(define fib (stream-cons 1 (stream-cons 1 (stream-add fib (stream-rest fib)))))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to display fibonacci sequences less than upper bound (CLISP)\r\n                \r\nI am trying to display a Fibonacci sequence less than an upper bound, but I'm having trouble printing out the series that is constrained by that upper bound.\nWithout using imperative programming principles with declaring variables such as setf, setq, and set, etc. How can I solve this problem?\nSo far I have\n```\n(defun fibonacci (n &optional (a 0) (b 1))\n  (if (or (zerop n) (< a n)\n      nil)\n      (cons a (fibonacci (1- n) b (+ a b)))))\n```\n\nExpected output of ```\n(fibonacci 100)```\n: ```\n(0 1 1 2 3 5 8 13 21 34 55 89)```\n. However, what I am getting is ```\n(0 1 1 2 3 5 8 13 21 34 55)```\n.\n    ", "Answer": "\r\nYou are decreasing upper bound for no reason. When you remove ```\n1-```\n and move one ```\n)```\n to right place, it works as expected:\n```\n(defun fibonacci (n &optional (a 0) (b 1))\n  (if (or (zerop n) (> a n))\n      nil\n      (cons a (fibonacci n b (+ a b)))))\n```\n\nTests:\n```\nCL-USER 4 > (fibonacci 10)\n(0 1 1 2 3 5 8)\n\nCL-USER 5 > (fibonacci 100)\n(0 1 1 2 3 5 8 13 21 34 55 89)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "with this Fibonacci sequence question with instruction sets used to make a assembly code\r\n                \r\nThis is a Fibonacci sequence that I recently attempted to turn into a assembly code through the use of instruction set. I am not sure how to go about testing it and was wondering could confirm if I got this right and if not where I went wrong. Also the \".\" that is used does this mean I must multiply using the instruction set. Below is the question I got and my answer I have come up with. I would also like to know if I have used the correct #.\n    ", "Answer": "\r\nThe code needs to add ```\n(F(n-1) + F(n-2))```\n before multiplying ```\nF(n) · (F(n-1) + F(n-2))```\n. Since ```\nF(n-2)```\n doesn't need to be saved, you could add the register with ```\nF(n-1)```\n to the register with ```\nF(n-2)```\n, so that the sum ends up in the register that was holding ```\nF(n-2)```\n.\n\nTrivia: ```\nF(0) = 0```\n, since ```\nF(n-2) = (F(n+1) - (F(n) · F(n-1)))/F(n)```\n. You can also calculate ```\nF(-1) = 1)```\n, but not ```\nF(-2)```\n since it that ends up as ```\n1/0```\n .\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence with unknown input [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is not reproducible or was caused by typos. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question was caused by a typo or a problem that can no longer be reproduced. While similar questions may be on-topic here, this one was resolved in a way less likely to help future readers.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThe sequence works well. But I don't want a zero in my output. e.g 112 not 0112\nThis is myy code:\n```\nn = int(input(\"Enter int > than 0:\"))\nfirst_var, second_var = 0, 1\ncurrent_count = 1\nif n <= 0:\n    print(\"Error! positive integers allowed only\")\nelse:\n    while current_count <= n:\n        print(first_var)\n        nth_term = first_var + second_var\n        first_var = second_var\n        second_var = nth_term\n        current_count += 1\n```\n\n    ", "Answer": "\r\nYou need ```\nfirst_var```\n to also equal 1, as suggested by  user @sahasrara62.\nNormally, when using the Fibonacci Sequence, you start with 1; 1, not 0; 1.\nYour code should look like this:\n```\nn = int(input(\"Enter int > than 0:\"))\nfirst_var, second_var = 1, 1\ncurrent_count = 1\nif n <= 0:\n    print(\"Error! positive integers allowed only\")\nelse:\n    while current_count <= n:\n        print(first_var)\n        nth_term = first_var + second_var\n        first_var = second_var\n        second_var = nth_term\n        current_count += 1\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "trying to create Fibonacci Sequence [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking for code must demonstrate a minimal understanding of the problem being solved. Include attempted solutions, why they didn't work, and the expected results. See also: Stack Overflow question checklist\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI don't know what I'm doing wrong. I'm trying to print \"fn\" of the sequence. I based it on someone else's code. Any thoughts?\n\nHere is my code:\n\n```\nint num = n;\nint fn = 1;\nint f1 = 0;\nint f2 = 1;\n\nfor (int i = 2; i < n; i++)\n{\n fn = f1 + f2;\n f1 = f2;\n f2 = fn;\n\n}\n\nSystem.out.print( \"fib( \" + num + \" ) is \");\nSystem.out.println( fn );\n```\n\n    ", "Answer": "\r\nI ran your code to see if there is a problem.  Here are various program outputs for values 2-10:\n\n```\nfib( 2 ) is 1\nfib( 3 ) is 1\nfib( 4 ) is 2\nfib( 5 ) is 3\nfib( 6 ) is 5\nfib( 7 ) is 8\nfib( 8 ) is 13\nfib( 9 ) is 21\n```\n\n\nThe output is close to being correct, except you are getting the result for ```\nfib(n - 1)```\n each time.  The reason is that you are stopping your ```\nfor```\n loop one iteration early.  Try modifying your condition with ```\n<=```\n:\n\n```\nfor (int i = 2; i <= n; i++)\n```\n\n\nOutput:\n\n```\nfib( 2 ) is 1\nfib( 3 ) is 2\nfib( 4 ) is 3\nfib( 5 ) is 5\nfib( 6 ) is 8\nfib( 7 ) is 13\nfib( 8 ) is 21\nfib( 9 ) is 34\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Storing values of a Fibonacci sequence w/ recursion with minimal runtime\r\n                \r\nI know my code has a lot of issues right now, but I just want to get the ideas correct before trying anything. I need to have a method which accepts an integer n that returns the nth number in the Fibonacci sequence. While solving it normally with recursion, I have to minimize runtime so when it gets something like the 45th integer, it will still run fairly quickly. Also, I can't use class constants and globals.\n\nThe normal way w/ recursion.\n\n```\npublic static int fibonacci(int n) {\n    if (n <= 2) { // to indicate the first two elems in the sequence \n        return 1;\n    } else { // goes back to very first integer to calculate (n-1) and (n+1) for (n)\n        return fibonacci(n-1) + fibonacci(n-2); \n    }\n}\n```\n\n\nI believe the issue is that there is a lot of redundancy in this process. I figure that I can create a List to calculate up to nth elements so it only run through once before i return the nth element. However, I am having trouble seeing how to use recursion in that case though.\n\nIf I am understanding it correctly, the standard recursive method is slow because there are a lot of repeats:\n\nfib(6) = fib(5) + fib(4)\n\nfib(5) = fib(4) + fib(3)\n\nfib(4) = fib(3) + 1\n\nfib(3) = 1 + 1\n\nIs this the correct way of approaching this? Is it needed to have some form of container to have a faster output while still being recursive? Should I use a helper method? I just recently got into recursive programming and I am having a hard time wrapping my head around this since I've been so used to iterative approaches. Thanks.\n\nHere's my flawed and unfinished code:\n\n```\npublic static int fasterFib(int n) {\n    ArrayList<Integer> results = new ArrayList<Integer>();\n    if (n <= 2) { // if \n        return 1;\n    } else if (results.size() <= n){ // If the list has fewer elems than \n        results.add(0, 1);\n        results.add(0, 1);\n        results.add(results.get(results.size() - 1 + results.get(results.size() - 2)));\n        return fasterFib(n); // not sure what to do with this yet\n    } else if (results.size() == n) { // base case if reached elems\n        return results.get(n);\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nI think you want to use a ```\nMap<Integer, Integer>```\n instead of a ```\nList```\n. You should probably move that collection outside of your method (so it can cache the results) -\n\n```\nprivate static Map<Integer, Integer> results = new HashMap<>();\n\npublic static int fasterFib(int n) {\n  if (n == 0) {\n    return 0;\n  } else if (n <= 2) { // if\n    return 1;\n  }\n  if (results.get(n) != null) {\n    return results.get(n);\n  } else {\n    int v = fasterFib(n - 1) + fasterFib(n - 2);\n    results.put(n, v);\n    return v;\n  }\n}\n```\n\n\nThis optimization is called memoization, from the Wikipedia article -\n\n\n  In computing, memoization is an optimization technique used primarily to speed up computer programs by keeping the results of expensive function calls and returning the cached result when the same inputs occur again.\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence Program in PHP - Trouble getting input from user and declaring them in a variable\r\n                \r\nI'm creating a program where the user enters two numbers and on the submit button it will calculate and display the fibonacci sequence. When trying to get my input values to be stored in ```\n$n1```\n and ```\n$n2```\n I get an error. Is there a more effective way to get input by doing something other then a ```\n$_POST```\n?\n\nThis is the form:\n\n```\n<div id=\"container\">\n    <h2>Fibonacci Example</h2>\n\n    <p id=\"display\"></p>\n\n    <form action=\"fibonacciDisplay.php\" method=\"post\">\n        <label>First Number:</label> <input type=\"text\" name=\"n1\"><br>\n        <label>Second Number:</label> <input type=\"text\" name=\"n2\"><br>\n        <input type=\"submit\" name=\"calculate\" class=\"btnSubmit\">\n    </form>\n</div>\n```\n\n\nThis is my function:\n\n```\n//variables\n$n1 = $_POST['Num1'];\n$n2 = $_POST['Num2'];\n\n//method to check numbers\nfunction checkFibo($n1 = 0, $n2 = 0) {\n    if ($n1 != 0 && $n2 != 1) {\n        if ($n2 < $n1) {\n            echo \"Your second number must be greater than the first. Try again\";\n            $output = \"\";\n        } else if ($n1 < $n2 || $n2 < 0) {\n            echo \"Please enter only positive numbers\";\n        } else if (!(is_numeric($n1)) || !(is_numeric($n2))) {\n            echo \"Please only enter positive numbers\";\n            $output = \"\";\n        } else {\n            echo \"The result of your request is shown below.\";\n            $output = $z->getFibo($n1, $n2);\n        }\n    } else {\n        echo \"Please enter values below\";\n        $output = \"\";\n    }\n    return $output;\n}\n\n// Method to calculate fibonacci\nfunction getFibo($n1 = 0, $n2 = 0) {\n    $max = $n2 * 100;\n    while ($z <= 0) {\n        $z = $n1 + $n2;\n        $output .= ($z.\"<br />\");\n        $n1 = $n2;\n        $n2 = $z;\n    }\n    return $output;\n}\n```\n\n    ", "Answer": "\r\nChange this \n```\n<label>First Number:</label> <input type=\"text\" name=\"n1\"><br>\n <label>Second Number:</label> <input type=\"text\" name=\"n2\"><br>```\n\n to this:\n```\n<label>First Number:</label> <input type=\"text\" name=\"Num1\"><br>\n <label>Second Number:</label> <input type=\"text\" name=\"Num2\"><br>```\n\nBecause you try to get fields ```\n$n1 = $_POST['Num1'];$n2 = $_POST['Num2'];```\n in your backend script.\nAbout second question, you can use ```\nGET```\n requests instead of ```\nPOST```\n more here, if you'd like to make it more modern, look at ajax requests.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in Ruby (recursion)\r\n                \r\nI'm trying to implement the following function, but it keeps giving me the ```\nstack level too deep (SystemStackError)```\n error.\n\nAny ideas what the problem might be ?\n\n```\ndef fibonacci( n )\n    [ n ] if ( 0..1 ).include? n\n    ( fibonacci( n - 1 ) + fibonacci( n - 2 ) ) if n > 1\nend\n\nputs fibonacci( 5 )\n```\n\n    ", "Answer": "\r\nTry this\n\n```\ndef fibonacci( n )\n  return  n  if ( 0..1 ).include? n\n  ( fibonacci( n - 1 ) + fibonacci( n - 2 ) )\nend\nputs fibonacci( 5 )\n# => 5\n```\n\n\ncheck this post too Fibonacci One-Liner\n\nand more .. https://web.archive.org/web/20120427224512/http://en.literateprograms.org/Fibonacci_numbers_(Ruby) \n\nYou have now been bombarded with many solutions :)\n\nregarding problem in ur solution\n\nyou should return ```\nn```\n if its ```\n0```\n or ```\n1```\n\n\nand ```\nadd```\n last two numbers not last and next\n\n\n  New Modified version\n\n\n```\ndef fibonacci( n )\n    return  n  if n <= 1 \n    fibonacci( n - 1 ) + fibonacci( n - 2 )\nend \nputs fibonacci( 10 )\n# => 55\n```\n\n\n\n  One liner\n\n\n```\ndef fibonacci(n)\n   n <= 1 ? n :  fibonacci( n - 1 ) + fibonacci( n - 2 ) \nend\nputs fibonacci( 10 )\n# => 55\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Why does this fibonacci sequence work? Can someone help me?\r\n                \r\nPython beginner problem\n(I am a beginner programmer)\nSo I was making a simple Fibonacci sequence generator and I made a working version, but I'm confused about how it works. In the code (lines 8-9), the first number (0) is being made the new value of the second value (1). But then that should make all the other numbers 0 as well, but it seems like the defining process is backward. Generally, the new value is on the left of the equal sign and the old value is on the right. But then that means everything should turn to 0. But actually, every number turns to 0 if I try to re-define the variables in the regular way (b = a; c = b). Why is this? I've attached my code at the bottom.\n```\ndef seq_loop():\n    a = 0\n    b = 1\n\n    for i in range(15):\n        print(a)\n        c = a + b\n        a = b\n        b = c\n\nprint(seq_loop())\n```\n\n    ", "Answer": "\r\nHave a good look at your code.  Walk through it, and write down a,b and c in each iteration (or if you know how to use a debugger, set a break point in the loop te verify your variable's values).  You'll see that your thinking is not right:  in your first iteration: ```\na = b```\n is equivalent to ```\na = 1```\n and ```\nb = c```\n is equivalent to ```\nb = 1 + 1```\n.\nI am not sure that your interpretation of assignments is correct: An assignment goes right to left.  The value (of the variable) on the right side of ```\n=```\n is assigned to the variable on the left side of ```\n=```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Code Golf\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                Locked. This question and its answers are locked because the question is off-topic but has historical significance. It is not currently accepting new answers or interactions.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n\r\n\r\n    \r\n\r\nGenerate the Fibonacci sequence in the fewest amount of characters possible. Any language is OK, except for one that you define with one operator, ```\nf```\n, which prints the Fibonacci numbers.\n\nStarting point: 25 14 characters in Haskell:\n\n  ```\nf=0:1:zipWith(+)f(tail f)```\n \n\n```\nf=0:scanl(+)1f\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Error in my Java Fibonacci sequence?\r\n                \r\n```\npublic class Arrays {\npublic static void main(String[] args){\nlong Fib[] = new long[100];\nFib[0] = 1;\nFib[1] = 1;\nint i = 0;\n    while(i <= 100){\n        Fib[i+2]= Fib[i] + Fib[i+1];\n        System.out.println(Fib[i]);\n        i++;\n    }\n\n}\n}\n```\n\n\nI used this to find Fibonacci numbers, but it starts giving me strange readings at around the 94th term. Anyone care to explain? I'm totally new to Java, so please don't hate if it's something obvious.\nHere's some snippets of the error'ed output, but everything else looks fine:\n\n```\n832040\n\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 100\n\n1346269\n```\n\n\n...\n\n```\n63245986\n\nat Arrays.main(102334155\nArrays.java:8)\n\n165580141\n```\n\n\n...\n\n```\n4660046610375530309\n\n7540113804746346429\n\n-6246583658587674878\n\n1293530146158671551\n\n-4953053512429003327\n\n-3659523366270331776\n\n-8612576878699335103\n\n6174643828739884737\n```\n\n    ", "Answer": "\r\nHere is the solution. you are trying to access 102th element  i + 2 where i = 100      \n\n```\n Fib[0] = 1;\n Fib[1] = 1;\n int i = 2;\n while(i < 100){\n      Fib[i]= Fib[i-1] + Fib[i-2];\n      System.out.println(Fib[i]);\n      i++;\n }\n```\n\n\nFurthermore, 97th Fibonacci number exceeds ```\nlong```\n range where it is between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807. 97th Fibonacci is 83,621,143,489,848,410,000 you should use ```\nBigInteger```\n instead of ```\nlong```\n\n\nBelow code prints until 1000 digit fibonacci number.\n\n```\n   BigInteger first = new BigInteger(\"0\");\n    BigInteger second = new BigInteger(\"1\");\n    BigInteger temp;// = new BigInteger(\"0\");\n    int counter = 1;\n\n     while(numberOfDigits(second) < 1000)\n     {\n         temp = new BigInteger(second.toString());\n         second = second.add(first);\n         first = new BigInteger(temp.toString());\n         counter++;\n     }\n     System.out.print(counter);\n\n\n}\n\npublic static int numberOfDigits(BigInteger number)\n{\n      return number.toString().length();\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "How to print Fibonacci sequence\r\n                \r\nI am working on a Python tutorial. I am getting an incorrect result as I try to work through an example.\nThis question does not answer my question.\nI have defined my function like so:\n```\ndef fibonaccci(sequence_length):\n    \"Return the Fibonacci sequene of length * sequence_length\"\n    sequence = [0,1]\n    if sequence_length < 1:\n        print(\"Fibonacci squence only defined fo length 1 or greater\")\n        return\n    if 0 < sequence_length < 3:\n        return sequence[:sequence_length]\n    for i in range(2, sequence_length):\n        sequence_length.append(sequence[i-1]+sequence[i-2])\n    return sequence\n```\n\nExpected:\n```\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n```\n\nActual:\n```\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n/tmp/ipykernel_35261/4107038898.py in <module>\n----> 1 fibonaccci(int(12))\n\n/tmp/ipykernel_35261/2532562687.py in fibonaccci(sequence_length)\n      8         return sequence[:sequence_length]\n      9     for i in range(2, sequence_length):\n---> 10         sequence_length.append(sequence[i-1]+sequence[i-2])\n     11     return sequence\n\nAttributeError: 'int' object has no attribute 'append'\n```\n\n    ", "Answer": "\r\nYou're trying to append to the ```\nint```\n parameter ```\nsequence_length```\n instead of the length ```\nsequence```\n. Just append to that instead:\n```\ndef fibonaccci(sequence_length):\n    \"Return the Fibonacci sequene of length sequence_length\"\n    sequence = [0, 1]\n    if sequence_length < 1:\n        print(\"Fibonacci squence only defined for length 1 or greater\")\n        return\n    if 0 < sequence_length < 3:\n        return sequence[:sequence_length]\n    for i in range(2, sequence_length):\n        sequence.append(sequence[i - 1] + sequence[i - 2])\n    return sequence\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence function producing incorrect values\r\n                \r\nI am creating a Fibonacci function that is producing unexpected and inaccurate results. What am I doing wrong here? Is there a simple way to correct this?\n```\nconst fib=(c,f=[0,1],r=0)=>c>1?(f.push(f.reduce((a,b)=>a+b,0)),f.shift(),fib(c-1,f,1)):(r?f[1]:(c<0?NaN:f[c]));\nfib(100); // -> 354224848179262000000,\n\n// Correct 100th digit where `fib(0) === 0` would be 354224848179261915075\n```\n\n    ", "Answer": "\r\nYes, this is a fairly common issue with big integers and very small/long decimal numbers. There are a few libraries out there to resolve this issue when it comes to decimal numbers, but the good news is that JavaScript has native support for big integers that will solve this issue immediately. Just use and return the BigInt type and the number will be accurate.\nUnfortunately, you cannot convert this number format back into a normal number without it rounding back to the incorrect value you mentioned, but it will stringify just fine, so it should work for almost all uses.\nUse this:\n\r\n\r\n```\nconst fib=(c,f=[0n,1n],r=0)=>c>1?(f.push(f.reduce((a,b)=>a+b,0n)),f.shift(),fib(c-1,f,1)):(r?f[1]:(c<0?NaN:f[c]));\n\nconsole.log(fib(100).toString()); // -> \"354224848179261915075\"```\n\r\n\r\n\r\n\nYou can read up more on the BigInt type here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence in mips and storing result in 2 registers\r\n                \r\ni wrote a Fibonacci program in mips and the max Int it will go up to is 1836311903 as its being stored in a $t3 register .\n\nI read that its possible to go beyond this my using 2 registers to store the fib values . \n\nHeres how my code look for the fib sequence and the max term it goes up to is 44 .\n\n```\n    .data \nfib:.word\n    .text\n    .globl  main\nmain:\n\n    # The loop\n        li      $t2, 1                  # Initialize f_old to 1\n        li      $t1, 0                  # Initialize f_older to 0\n        li      $t4, 2                  # Initialize counter i to 2\n        li  $t0 ,0          #This is the n in fib(n)\n        la  $s0,fib\n        li  $t9 , 44   #this is the max value of n that can be stored in 32bit , anything greater causes overflow.\nlp_tst: blt    $t9, $t0, done          # If $t4 > $t0 (i >  n), \n                                        #    branch out of loop.\n                                        #    Otherwise continue.\n        add     $t3, $t2, $t1           # Add f_old to f_older\n        move    $t1, $t2                # Replace f_older with f_old\n        move    $t2, $t3                # Replace f_old with f_new\n\n    sw  $t2 , 0($s0)\n\n        addi    $t4, $t4, 1             # Increment i (i++)\n        addi    $t0,$t0,1\n        j       lp_tst                  # Go to the loop test\n\n        # Done with the loop, print result\ndone:   li      $v0, 1                  # Code to print an int\n        move    $a0, $t2                # Put f_old in $a0\n        syscall                         # Print the string\n\n\n        li      $v0, 10\n        syscall\n```\n\n\nAny ideas on how to store the value in multiple registers to allow it to store 64 bit ints?\n\nTHANKS\n    ", "Answer": "\r\nAssuming that the 64-bit ```\nf_old```\n is in ```\n$t2:$t1```\n and ```\nf_older```\n is in ```\n$t4:$t3```\n:\n\n```\naddu  $t5, $t1, $t3    # f_new.lo = f_old.lo + f_older.lo \nsltu  $t0, $t5, $t1    # set \"carry\" in $t0 if f_new.lo < f_old.lo  \naddu  $t0, $t0, $t4    # f_older.hi + carry\naddu  $t6, $t0, $t2    # f_new.hi = f_old.hi + f_older.hi + carry\n```\n\n\nNow the 64-bit ```\nf_new```\n is in ```\n$t6:$t5```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Im trying to code the recursive fibonacci sequence in c++ but when I compile I get an error\r\n                \r\nWhen i try to compute the fibonacci sequence using a recursive algorithm in c++, I get an error about memory allocation. I can run a recursive algorithm that has a void return, but when and int is the return, there is an issue with memory. Is there a way around this?\n\n```\n#include <iostream>\nusing namespace std;\n\nint fib(int start);\n\nint main()\n{\n  int x,y;\n  cout << \"Enter a value for x: \";\n  cin >> x;\n\n\n  y = fib(x);\n  cout << \"Your product is: \";\n  cout << y << endl;\n  return 0;\n\n}\n\nint fib(int start){\n  if(start == 0 || start == 1){\n    return start;\n  }\n  return fib(start)*fib(start-1);\n}\n```\n\n    ", "Answer": "\r\nThe problem is that the fibonacci function is not right...\n\nif your variable ```\nstart```\n happens to be different from 0 or 1 then you can the function fib(start) over and over again\n\n```\nreturn fib(start)*fib(start-1);\n```\n\n\nthat will produce an stackoverflow since the function is calling itself infinitely.\n\non the other hand you should not multiply those values but add it instead\n\n```\n return fib(n - 1) + fib(n - 2);\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding the sum of even valued terms in Fibonacci sequence\r\n                \r\n```\n#!/usr/bin/python2\n\n\"\"\"\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\nBy considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\n\"\"\"\n\nodd, even = 0,1\ntotal = 0\nwhile True:\n    odd = odd + even  #Odd\n    even = odd + even     #Even\n    if even < 4000000:\n        total += even\n    else:\n        break\nprint total\n```\n\n\nMy algo:\n\n\nIf I take first 2 numbers as 0, 1; the number that I find first in while loop will be an odd number and first of Fibonacci series.\nThis way I calculate the even number and each time add the value of even to total.\nIf value of ```\neven```\n is greater than 4e6, I break from the infinite loop.\n\n\nI have tried so much but my answer is always wrong. Googling says the answer should be ```\n4613732```\n but I always seem to get ```\n5702886```\n\n    ", "Answer": "\r\nBasically what you're doing here is adding every second element of the fibonacci sequence while the question asks to only sum the even elements.\n\nWhat you should do instead is just iterate over all the fibonacci values below 4000000 and do a ```\nif value % 2 == 0: total += value```\n. The ```\n%```\n is the remainder on division operator, if the remainder when dividing by 2 equals 0 then the number is even.\n\nE.g.:\n\n```\nprev, cur = 0, 1\ntotal = 0\nwhile True:\n    prev, cur = cur, prev + cur\n    if cur >= 4000000:\n        break\n    if cur % 2 == 0:\n        total += cur\nprint(total)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Efficient calculation of Fibonacci series\r\n                \r\nI'm working on a Project Euler problem: the one about the sum of the even Fibonacci numbers. \n\nMy code:\n\n```\ndef Fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return Fibonacci(n-1) + Fibonacci(n-2)\n\nlist1 = [x for x in range(39)]\nlist2 = [i for i in list1 if Fibonacci(i) % 2 == 0]\n```\n\n\nThe problem's solution can be easily found by printing sum(list2). However, it is taking a lot of time to come up with the list2 I'm guessing. Is there any way to make this faster? Or is it okay even this way... \n\n(the problem: By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.) \n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "fibonacci sequence overflow, C++\r\n                \r\nI want to print the first 100 numbers in the fibonacci sequence. My program prints until around 20 numbers than the numbers turn negative.\n\nCan someone explain this to me please and provide a fix?\n\nThanks,\n\n```\n/*Fibonacci sequence*/\n\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n    long int i, fib;\n    int firstNum=0, secondNum=1;\n\n    cout << firstNum << endl; \n    cout << secondNum << endl;\n\n    for (i=0; i < 100; i++){\n        fib = firstNum + secondNum;\n        firstNum = secondNum;\n        secondNum = fib;\n        cout << fib << endl;\n    }\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nWhat you are seeing is an integer overflow problem. firstNum and secondNum are not long.\n\nThis should fix it\n\n```\n    unsigned long long i, fib;\n    unsigned long long firstNum=0, secondNum=1;\n```\n\n\nEDIT:\n\nThis will help you avoid overflow after the 20th number, but your program will still overflow. You can use unsigned long long, and you'll make it to the 100th sequence element.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Create a dynamic programming algorithm to compute the fibonacci sequence using tetranacci numbers\r\n                \r\nI have been asked to create a dynamic programming algorithm to compute a generalization of the Fibonacci sequence using Tetranacci numbers defined as follows:\n\n\n  T(0) = 0, T(1) = 1, T(2) = 1, T(3) = 2, and the recurrence relation T(n) = T(n - 1) + T(n - 2) + T(n - 3) + T(n - 4)\n\n\nThe problem is, I am unsure whether or not my algorithm is considered a \"dynamic\" algorithm, whereas there are still (many) input values that could be computed more than once. Here's what I have:\n\n```\n//n is the value being computed (Tn)\ntetranacci(n)\n    if n = 0 then\n        return 0;\n    else if n = 1 or n = 2 then\n        return 1;\n    else if n = 3 then\n        return 2\n    else\n        return tetranacci(n - 1) + tetranacci(n - 2) + tetranacci(n - 3) + tetranacci(n - 4)\n```\n\n\nIf this is correct can someone clarify for me what makes this dynamic? I'm having trouble finding a strict definition online. Thanks!\n    ", "Answer": "\r\nI think I got to the bottom of it. Simply use an array to store values as they are computed:\n\n```\n//n is the value being computed (Tn), A is an array containing already-computed values for n\ntetranacci(n)\n    if n = 0 then\n        return 0;\n    else if n = 1 or n = 2 then\n        return 1;\n    else if n = 3 then\n        return 2\n    else if A[n] != null\n        return A[n]\n    else\n        A[n] = tetranacci(n - 1) + tetranacci(n - 2) + tetranacci(n - 3) + tetranacci(n - 4)\n        return A[n]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Create a dynamic programming algorithm to compute the fibonacci sequence using tetranacci numbers\r\n                \r\nI have been asked to create a dynamic programming algorithm to compute a generalization of the Fibonacci sequence using Tetranacci numbers defined as follows:\n\n\n  T(0) = 0, T(1) = 1, T(2) = 1, T(3) = 2, and the recurrence relation T(n) = T(n - 1) + T(n - 2) + T(n - 3) + T(n - 4)\n\n\nThe problem is, I am unsure whether or not my algorithm is considered a \"dynamic\" algorithm, whereas there are still (many) input values that could be computed more than once. Here's what I have:\n\n```\n//n is the value being computed (Tn)\ntetranacci(n)\n    if n = 0 then\n        return 0;\n    else if n = 1 or n = 2 then\n        return 1;\n    else if n = 3 then\n        return 2\n    else\n        return tetranacci(n - 1) + tetranacci(n - 2) + tetranacci(n - 3) + tetranacci(n - 4)\n```\n\n\nIf this is correct can someone clarify for me what makes this dynamic? I'm having trouble finding a strict definition online. Thanks!\n    ", "Answer": "\r\nI think I got to the bottom of it. Simply use an array to store values as they are computed:\n\n```\n//n is the value being computed (Tn), A is an array containing already-computed values for n\ntetranacci(n)\n    if n = 0 then\n        return 0;\n    else if n = 1 or n = 2 then\n        return 1;\n    else if n = 3 then\n        return 2\n    else if A[n] != null\n        return A[n]\n    else\n        A[n] = tetranacci(n - 1) + tetranacci(n - 2) + tetranacci(n - 3) + tetranacci(n - 4)\n        return A[n]\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Printing the fibonacci sequence in reverse using arrays - Java\r\n                \r\nUsed to print the fibonacci in normal order, but can't figure out how to reverse it, from 4181 to 0.\n\n```\n    int[] numbers = new int[20];\n\n    numbers[0] = 0;\n    numbers[1] = 1;\n\n\n    System.out.println(\"Fibonacci sequence:\");\n    System.out.println( numbers[0] );\n    System.out.println( numbers[1] );\n\n\n    for (int i = 2; i < 20; i++) {\n\n\n        numbers[i] = numbers[i-2] + numbers[i-1];\n        System.out.println( numbers[i] );\n        for (int j = 19; j >= 0; j++) {\n            numbers[j] = numbers[j-2] + numbers[j-1];\n        System.out.println( numbers[j] );\n    }\n}\n```\n\n\n}\n}\n    ", "Answer": "\r\nThe obvious solution would be to create the Fibonacci sequence recursively (like you did) first, and then reverse it:\n\n```\nList<Integer> list = Arrays.asList(arr);\nCollections.reverse(list);\n```\n\n\nAnother (mathematically more elegant) solution would be using the explicit formula to calculate each member of the Fibonacci sequence by its index, starting from ```\nn = 20```\n and work your way down to ```\nn = 1```\n:\n\n```\np = (1 + sqrt(5)) / 2\nq = (1 - sqrt(5)) / 2\nF(n) = ((p ^ n) - (q ^ n)) / sqrt(5)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "What are the steps used in this function used to calculate the Fibonacci sequence?\r\n                \r\n\r\n\r\n```\nlet a = 0;\r\nlet b = 1;\r\nfor (let i = 1; i <= 10; i++) {\r\n  var c = a + b;\r\n  a = b;\r\n  b = c;\r\n  console.log(c);\r\n}```\n\r\n\r\n\r\n\n\nSo I have this little code that apparently works and that gives the sequence of Fibonacci but I still don't understand how the code does its thing so I think need a visual representation with numbers to understand.\n    ", "Answer": "\r\nWork through it step-by-step:\n\n```\nlet a = 0;\nlet b = 1;\n```\n\n\nSelf-explanatory variable assignment.\n\n```\nfor (let i = 1; i <= 10; i++) {...}\n```\n\n\nIterate from ```\n1```\n to ```\n10```\n with ```\ni```\n storing the current iteration\n\n```\nvar c = a + b;\n```\n\n\nMake a variable ```\nc```\n set to ```\na```\n + ```\nb```\n.\n\n```\na = b;\nb = c;\n```\n\n\nSet ```\na```\n to ```\nb```\n and ```\nb```\n to ```\nc```\n - makes new base values for next iteration.\n\nThis example shows all the variables:\n\n\r\n\r\n```\nlet a = 0;\r\nlet b = 1;\r\nfor (let i = 1; i <= 10; i++) {\r\n  var c = a + b;\r\n  a = b;\r\n  b = c;\r\n  console.log(`a: ${a}, b: ${b}, c: ${c}, i: ${i}`);\r\n}```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Haskell tail recursion for Fibonacci sequence\r\n                \r\nSo I am working on an assignment where I have to find the nth fibonacci number, and I came across this idea shown below, however this returns a list, and I would just like to return the final number, so for example fibo 3 would give me [0,1,1,2,3,5,8,13], except I just want 13 to return, is there any way I could do that? This is my first time using Haskell and I am sort of learning functional programming as well for the first time, any help is appreciated. Thanks\n```\nfibo :: Integral x => x -> [x]\nfibo n = fiboHelper [0,1] 0 1 n\nfiboHelper :: Integral x => [x]->x->x->x->[x]\nfiboHelper l x y 0 = l\nfiboHelper l x y n = fiboHelper (l ++ [y+x] ++ [y+x+y]) (x+y) (y+x+y) (n-1)\n```\n\n    ", "Answer": "\r\nYes, you can keep track of the last 2 steps as you go down the recursive stack.\n```\nfibo :: Integral x => x -> x\nfibo a\n  | a < 3      = 1\n  | otherwise  = go 2 1 1 where\n    go a' b' c'\n       | a' == a    = c'\n       | otherwise  = go (a'+1) (c') (b'+c')\n```\n\nOn a side note, a very interesting way I learned to create an infinite list of Fibonacci numbers in Haskell is as follows:\n```\nfibs = 1 : scanl (+) 1 fibs\n```\n\ncombining this with ```\ntake```\n and ```\nlast```\n you can achieve whatever solution you are looking for.\n```\ntake 5 fibs\n-- produces [1,1,2,3,5]\n\nlast $ take 5 fibs\n-- produces 5\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "MASM x86 Computing the sum of odd numbers Fibonacci sequence between 0 and 1000000\r\n                \r\nI need to make a masm program that adds all odd numbers of the fibonacci sequence between 0 to 1000000. The following code is all I have so far. When I go into debug and look at the ecx register which is where the sum is being stored, it looks like its not adding them right. The sum in the ecx register go 1,4,9, etc, but it should be 1,2,5,10,23, etc. The final result should be 1089154. When I try printing out the sum in the terminal it prints \"+1000000\" which isn't right. Please help!\n```\n.386\n.model flat, stdcall\n.stack 4096\nExitProcess PROTO, dwExitCode:DWORD\nINCLUDE irvine32.inc\n.data\n    first_num DWORD 0   \n    second_num DWORD 1  \n    odd_sum DWORD 0     \n\n.code\nmain PROC\n    \n    mov eax, 0      \n    mov ebx, 1      \n    mov ecx, 0      \n\n    \n    fibonacci_loop:\n        add eax, ebx        \n        test eax, 1     \n        jz skip_add         \n        add ecx, eax        \n    skip_add:\n        cmp eax, 1000000    \n        jl fibonacci_loop   \n\n    mov odd_sum, ecx\n    call writeint\n\n\n    INVOKE ExitProcess, 0\nmain ENDP\nEND main\n```\n\n    ", "Answer": "", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Python Fibonacci sequence- while loop is not giving me the right result. I have tried changing the iterator but to no avail?\r\n                \r\n```\n    num1 = 0\n    num2 = 1\n    find = 2\n    fib_num = 0\n\n    while find <= N:\n        fib_num = num1 + num2\n        num1 = num2\n        num2 = fib_num\n        find = find + 1\n    print(find)\n\n\nfibFind(7)\n```\n\nI have been having issues with the Fibonacci sequence- I have searched for the 7th number- the result should be 13. Where am I going wrong with the logic?\nThanks in advance for answer and explanation.\n    ", "Answer": "\r\nYou need to print ```\nfib_num```\n, not ```\nfind```\n.\n```\ndef fibFind(N):\n    num1 = 0\n    num2 = 1\n    find = 2\n    fib_num = 0\n\n    while find <= N:\n        fib_num = num1 + num2\n        num1 = num2\n        num2 = fib_num\n        find = find + 1\n\n    print(fib_num)\n\n\nfibFind(7)\n```\n\nBetter yet, return the fibonacci number from the function after the computation is done.\n```\ndef fibFind(N):\n    num1 = 0\n    num2 = 1\n    find = 2\n    fib_num = 0\n\n    while find <= N:\n        fib_num = num1 + num2\n        num1 = num2\n        num2 = fib_num\n        find = find + 1\n\n    return fib_num\n\n\nprint(fibFind(7))\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence with numbers in 1 line and without using list or array [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How do I print a fibonacci sequence to the nth number in Python?\r\n                            \r\n                                (9 answers)\r\n                            \r\n                    \r\n                Closed 2 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm very new to python and programming in general. This is the first year we have programming classes, so I'd say I started about a month ago.\nWe got our first assignment last week and I've managed to make most of the tasks, apart from the following one:\n\nGenerate n numbers from the Fibonacci sequence, where n is entered by the user.\nWrite these numbers to the screen.\nPrint the numbers on 1 single line.\nTip: ```\nprint (value, end = '')```\n\nDo not use list or array.\n\nThis is the last question and this one is significantly more difficult than the others. I tried some things but non came close to doing what is asked. I genuinely have no clue how I'd even have to start.\n    ", "Answer": "\r\nIn pseudocode:\n\nFirst you need to check, print and save the results of ```\nfibonacci(0)```\n and ```\nfibonacci(1)```\n\nThen make a loop to calculate the next fibonacci value using the last two calculated and print it.\nUpdate the variables for the last two calculated.\nIterate steps 2 and 3 for each N>2\n\nThinking in python3:\n```\n# Print Fibonacci(0)\nif n>=0:\n    print (1, end =', ')\n    f2 = 1\n# Print Fibonacci(1)\nif n>0:\n    print (1, end =', ')\n    f1=1\n# Print Fibonacci(n) ; n>1\n\nif n>1:\n    for i in range (2, n+1):\n        result = f1+f2\n        print(result, end=', ')\n        # updating last two variables\n        f2 = f1\n        f1 = result\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Writing a JVM bytecode program to calculate and print the first 20 numbers in a fibonacci sequence\r\n                \r\nThis is my code for a bytecode program to calculate the first 20 numbers of the fibonacci sequence only being able to use iconst_1.\n\n```\niconst_1    \nistore_1    \niconst_1    \nistore_2    \niconst_1    \nistore_3    \ngetstatic #2    \niconst_1    \ninvokevirtual #3    \ngetstatic #2    \niconst_1\ninvokevirtual #3    \niconst_1    \nistore_4    \niload_4    \nbipush 18    \nif_icmpgt 51    \niload_1    \niload_2    \niadd    \nistore_3    \ngetstatic #2    \niload_3    \ninvokevirtual #3    \niload_2    \nistore_1    \niload_3    \nistore_2    \niinc 4,1    \ngoto 23    \nreturn\n```\n\n\nNow my main issue is that it is in the form of a file called fibonacci.bc and I need to compile it and run it to make sure it works. Are there any issues I need to address in the program first such as syntax and such. How would I go about doing that on the JVM?\n    ", "Answer": "\r\nAn easy option is to use Jasmin. You'll need to learn its syntax. It's pretty straightforward though.\n\nThis is your what you code will look like in Jasmin (note the use of ```\nlabel```\n, ```\ninc```\n, ```\nistore 4```\n, ```\niload 4```\n):\n\n```\n.class public Fib\n.super java/lang/Object\n\n.method private static fib()V\n  .limit stack 2\n  .limit locals 5\n\n  iconst_1\n  istore_1\n  iconst_1\n  istore_2\n  iconst_1\n  istore_3\n  getstatic java/lang/System/out Ljava/io/PrintStream;\n  iconst_1\n  invokevirtual java/io/PrintStream/println(I)V\n  getstatic java/lang/System/out Ljava/io/PrintStream;\n  iconst_1\n  invokevirtual java/io/PrintStream/println(I)V\n  iconst_1\n  istore 4\nlabel23:\n  iload 4\n  bipush 18\n  if_icmpgt label51\n  iload_1\n  iload_2\n  iadd\n  istore_3\n  getstatic java/lang/System/out Ljava/io/PrintStream;\n  iload_3\n  invokevirtual java/io/PrintStream/println(I)V\n  iload_2\n  istore_1\n  iload_3\n  istore_2\n  iinc 4 1\n  goto label23\nlabel51:\n  return\n.end method\n\n.method public static main([Ljava/lang/String;)V\n  .limit stack 0\n  .limit locals 1\n\n  invokestatic Fib/fib()V\n  return\n.end method\n```\n\n\nSaving your file in e.g. ```\nfib.j```\n and running ```\njava -jar jasmin.jar fib.j```\n will give you ```\nFib.class```\n.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci sequence in Ruby\r\n                \r\n```\ndef fibonacci(n)\n    n <= 1 ? n :  fibonacci( n - 1 ) + fibonacci( n - 2 ) \n end\n puts fibonacci( 6)\n```\n\nCan somebody explain how this code works. I realise that it works due to recursion but i cannot figure it out gradually. Will be gratefull for step by step explanation.\n    ", "Answer": "\r\nDoes this help you visualise it?:\n```\ndef fibonacci(n, level = 0)\n  puts ('|   ' * level) + 'n: ' + n.to_s\n  res = n <= 1 ? n :  fibonacci(n - 1, level + 1) + fibonacci(n - 2, level + 1)\n  puts ('|   ' * level) + 'res: ' + res.to_s\n  res\nend\n```\n\n```\nirb(main):038:0> fibonacci(6)\nn: 6\n|   n: 5\n|   |   n: 4\n|   |   |   n: 3\n|   |   |   |   n: 2\n|   |   |   |   |   n: 1\n|   |   |   |   |   res: 1\n|   |   |   |   |   n: 0\n|   |   |   |   |   res: 0\n|   |   |   |   res: 1\n|   |   |   |   n: 1\n|   |   |   |   res: 1\n|   |   |   res: 2\n|   |   |   n: 2\n|   |   |   |   n: 1\n|   |   |   |   res: 1\n|   |   |   |   n: 0\n|   |   |   |   res: 0\n|   |   |   res: 1\n|   |   res: 3\n|   |   n: 3\n|   |   |   n: 2\n|   |   |   |   n: 1\n|   |   |   |   res: 1\n|   |   |   |   n: 0\n|   |   |   |   res: 0\n|   |   |   res: 1\n|   |   |   n: 1\n|   |   |   res: 1\n|   |   res: 2\n|   res: 5\n|   n: 4\n|   |   n: 3\n|   |   |   n: 2\n|   |   |   |   n: 1\n|   |   |   |   res: 1\n|   |   |   |   n: 0\n|   |   |   |   res: 0\n|   |   |   res: 1\n|   |   |   n: 1\n|   |   |   res: 1\n|   |   res: 2\n|   |   n: 2\n|   |   |   n: 1\n|   |   |   res: 1\n|   |   |   n: 0\n|   |   |   res: 0\n|   |   res: 1\n|   res: 3\nres: 8\n=> 8\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence : Sum of all numbers\r\n                \r\nI am new to Java and this is what I have to do:     \n\nThe sequence goes as follows: 1, 1, 2, 3, 5, 8, 13, 21, .... Etc.       \n\nThe next number in the sequence is the sum of the previous 2 number     \n\nWrite a program that lets the user input a number, n, and then calculates the nth number of the sequence and the sum of the numbers in the sequence.    \n\nFor Example, the 5th number is 5 and the sum up to that number is 12     \n\nThis is not a duplicate as my question is different from the rest and my code is also different. Here is what I have done so far:     \n\n```\npublic class fibonnacifinal {\n\n    public static void main(String args[]) {\n        System.out.println(\"Enter number upto which Fibonacci series to print: \");\n        int number = new Scanner(System.in).nextInt();\n        System.out.println(\"\\n Fibonacci number at location \" + number + \" is ==> \" + (fibonacciLoop(number) + \"\"));\n    }\n\n    public static int fibonacciLoop(int number) {\n        if (number == 1 || number == 2) {\n            return 1;\n        }\n\n        int fibo1 = 1, fibo2 = 1, fibonacci = 1;\n        for (int i = 3; i <= number; i++) {\n            fibonacci = fibo1 + fibo2; // Fibonacci number is sum of previous two Fibonacci number\n            fibo1 = fibo2;\n            fibo2 = fibonacci; \n        }\n        return fibonacci; // Fibonacci number\n    }\n}\n```\n\n\nThe problem I am having is that I cannot get the numbers to add and print. For example, if user inputs 7, I can get it to say that 7th number is 13 but I cant get it to print that sum upto that number is 33.\n    ", "Answer": "\r\nAs you are starting from ```\ni = 3```\n you can use the following inside your ```\nfibonacciLoop(int number)```\n:\n\n```\nint sum = 2;\nfor (int i = 3; i <= number; i++) {\n    fibonacci = fibo1 + fibo2; \n    fibo1 = fibo2;\n    fibo2 = fibonacci;\n    sum = sum + fibonacci;\n}\nSystem.out.println(\"Sum: \" +sum); //print before return fibonacci\n```\n\n\nNote, soon ```\nint sum```\n will overflow for large fibonacci number.\n\nHere is a full functional code for you!\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Finding the sum of even-valued terms in a Fibonacci sequence where the sum of those terms does not exceed 5 million\r\n                \r\nthe code below is set to perform the sum of even valued terms in a Fibonacci sequence. The first part creates the terms so the first 2 ones and the addition from that. The second part creates an array that stores all these terms. The third part seeks out only the even terms and adds them and a condition is added to only do such for those less than 5 million.\n\n\r\n\r\n```\n//The below creates Fibonacci sequence as we know it\r\nvar memo = [0, 1];\r\nfunction fib (n) {\r\n    if(memo.length-1 < n) {\r\n        memo[n] = fib(n-1)+fib(n-2);\r\n    }\r\n    return memo[n];\r\n}\r\n\r\n// creates array with elements from function that takes the index as argument while a given condition holds\r\nfunction takeWhile (fromFunc, cond, arr=[]) {\r\n    var n = arr.length;\r\n    var val = fromFunc(n);\r\n    if(cond(val)) {\r\n        arr.push(val);\r\n        return takeWhile(fromFunc, cond, arr);\r\n    }\r\n    return arr;\r\n}\r\n   //adds all the numbers in the sequence below 5 million\r\nvar sum = \r\n    takeWhile(fib, n => n < 5000000)\r\n   //the below line makes sure that only the even numbers in the sequence are added\r\n    .filter(n => n%2==0)\r\n    .reduce((acc, c) => acc+c, 0);\r\n\r\nconsole.log(sum);```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nYou need to take the index, not the value for filtering.\n\n```\n.filter((_, i) => i % 2 == 0)\n```\n\n\n\r\n\r\n```\nfunction fib(n) {\r\n    if (memo.length - 1 < n) memo[n] = fib(n - 1) + fib(n - 2);\r\n    return memo[n];\r\n}\r\n\r\nfunction takeWhile(fromFunc, cond, arr = []) {\r\n    var val = fromFunc(arr.length);\r\n    if (!cond(val)) return arr;\r\n    arr.push(val);\r\n    return takeWhile(fromFunc, cond, arr);\r\n}\r\n\r\n\r\nvar memo = [0, 1],\r\n    sum = takeWhile(fib, n => n < 5)\r\n        .filter((_, i) => i % 2 == 0)\r\n        .reduce((acc, c) => acc + c, 0);\r\n\r\nconsole.log(sum);\r\nconsole.log(...memo);```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "I created an array of ints, user is prompted to pick 2 numbers, I am trying to return the sequence of fibonacci from those 2 numbers\r\n                \r\nI created an array of ints, user is prompted to pick 2 numbers, I am trying to return the sequence of fibonacci from those 2 numbers \n\n```\n#include <stdio.h>\n\nint main ()\n{\n  int a, b;\n\n  int nums[48];\n\n  for (int i = 0; i < 47; i++)\n\n    {\n      printf (\"Pick a number between 1 - 47\\n\");\n      scanf (\"%d\", &a);\n\n      printf (\"Pick a number between 1 - 47\\n\");\n      scanf (\"%d\", &b);\n\n      if (a >= 47 || a <= 1)\n    {\n      printf (\"Out of range pick another number between 1 - 47\\n\");\n      scanf (\"%d\", &a);\n    }\n\n      if (b >= 47 || b <= 1)\n    {\n      printf (\"Out of range pick another number between 1 - 47\\n\");\n      scanf (\"%d\", &b);\n    }\n\n      nums[i] = a;\n      nums[i + 1] = b;\n\n      int c = a + b;\n\n      printf (\"The sequence is: %d\\n\", c);\n    }\n  return 0;\n}\n```\n\n\nReturn up to 47 numbers of the fibonacci sequence\n    ", "Answer": "\r\nI have modified your code, assuming what your are expecting. If you want a recursion of version of this code that is also possible.\n```\nint main ()\n{\n  int a, b;\n\n  int nums[48];\n    //input two numbers once\n    printf (\"Pick a number between 1 - 47\\n\");\n    scanf (\"%d\", &a);\n\n    printf (\"Pick a number between 1 - 47\\n\");\n    scanf (\"%d\", &b);\n\n    if (a >= 47 || a <= 1)\n    {\n      printf (\"Out of range pick another number between 1 - 47\\n\");\n      scanf (\"%d\", &a);\n    }\n\n    if (b >= 47 || b <= 1)\n    {\n      printf (\"Out of range pick another number between 1 - 47\\n\");\n      scanf (\"%d\", &b);\n    }\n\n    nums[0] = a;\n    nums[1] = b;\n    \n   //calculate the fibonnaci series\n   for (int i = 2; i <= 47; i++)\n   {\n      nums[i] = nums[i-1] + nums[i-2];\n      \n   }\n   //Then print the series\n    print(\"Fibonnacci series for a = %d and b = %d is \", a, b);\n\n    for(int i = 0; i <= 47; i++)\n        print(\"%d \", nums[i]);\n  return 0;\n}\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Generalizing Fibonacci-type sequences (performance)\r\n                \r\nToday I found the Haskell Fibonacci definition of:\n\n```\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n```\n\n\nExploring, I wrote the \"tribonacci\" numbers as:\n\n```\ntribs = 0 : 0 : 1 : zipWith (+) (zipWith (+) tribs (tail tribs)) (drop 2 tribs)\n```\n\n\nThis works fine, so I tried to generalize to any \"fibonacci-type\" sequence using the same basic idea:\n\n```\nnbonacci n   = (take n (repeat 0)) ++ [1] ++ (z n) \n   where z 1 = zipWith (+) (nbonacci n) (drop 1 (nbonacci n))\n         z x = zipWith (+) (z (x-1)) (drop x (nbonacci n))\n```\n\n\nThis works, too: it correctly gives the sequences I'm after. Unfortunately it's also horribly slow, many times slower even when generating the same fibonacci and tribonacci sequences. How can I express the same idea in a way that gets better performance?\n    ", "Answer": "\r\nYou can use the worker-wrapper transform:\n\n```\nnbonacci n = go where\n    go = take n (repeat 0) ++ [1] ++ z n\n    z 1 = zipWith (+) go (drop 1 go)\n    z x = zipWith (+) (z (x-1)) (drop x go)\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Fibonacci Sequence (JS) - Sum of Even Numbers\r\n                \r\nI started Project Euler. I am on problem 2 and came up with this code to come up with the sum of even fibonacci numbers up to 4 million. The code seems to do pretty much what I want it to. I do see the correct sum listed when the code is ran. The only part I am really confused about is the very last number displayed in the results. This is what it shows:\n\nJS CODE:\n\n```\nvar previous = 0;\nvar current = 1;\nvar sum = 0;\nvar next;\n\n   for(i = 1; i < 100; i++){\n        next = current + previous;\n        previous = current;\n        current = next; \n        if(current % 2 === 0 && current < 4000000) {\n            sum += current;\n        console.log(sum);\n        }\n   }\n```\n\n\nRESULTS:\n\n```\n2\n10\n44\n188\n798\n3382\n14328\n60696\n257114\n1089154\n4613732 (this is the number i was trying to get)\n=> 354224848179262000000 (confused as to why this number shows up and what it represents)\n```\n\n    ", "Answer": "\r\nLet me break this down:\n\nWhy does this show up?\n\nOn the console, you will see the result of any expression you execute. If you execute a block of code you will see the last expression you executed in the block. Counter intuitively, in this case it is the result of ```\ncurrent = next```\n because the if statement is not run on your last time through the for loop.\n\nWhy does next equal 354224848179262000000?\n\nThe hundredth Fibonacci number is 354224848179261915075. JavaScript however loses precision as your numbers get past a certain point and starts assuming that all of the lower part of your number is zeros. See this question for move details: Why does JavaScript think 354224848179262000000 and 354224848179261915075 are equal?.\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
{"Question": "Iteral fibonacci java code returns 0 when fibonacci sequence > 2\r\n                \r\nthe code below interates from Fibonacci 0 to 100. However after the Fibonacci number reaches 2 and moves on to 3, the resulting numbers are 0. when they should be 3, 5, 8 etc. by everything I see it should work and I am not sure why.\n\nHowever you will notice the \n\n```\nelse{\n    return 0;\n}\n```\n\n\nat the end of the code, I did that because the code yells at me that the code is to return a value of type long. If there is a way to fix that please let know thanks guys\n\n```\n public static void runFibonacci () {\n    for (int N = 0; N < 100; N++)\n        StdOut.printf (\"fibonacci(%2d)=%d\\n\", N, fibonacci (N));\n}\npublic static long fibonacci (int N) {\n    long low = 0;\n    long tempLow = 0;\n    long tempHi = 0;\n    long hi = 0;\n    if (N == 0) return 0;\n    if (N == 1) {\n        hi ++;\n        return 1;\n    }\n\n    if (N == 2){\n        low ++;\n        return 1;\n    }\n\n    if (N > 2){\n        tempLow = hi;\n        tempHi = (low + hi);\n        hi = tempHi;\n        low = tempLow;\n        return hi;\n    }\n    else{\n        return 0;\n    }\n}\n```\n\n\noutput\n\n```\nfibonacci( 0)=0\nfibonacci( 1)=1\nfibonacci( 2)=1\nfibonacci( 3)=0\nfibonacci( 4)=0\nfibonacci( 5)=0\n```\n\n\nExpected output\n\n```\nfibonacci( 0)=0\nfibonacci( 1)=1\nfibonacci( 2)=1\nfibonacci( 3)=2\nfibonacci( 4)=3\nfibonacci( 5)=5\netc\n```\n\n    ", "Answer": "\r\nAs @WannaBeCoder said, the best fix was to make my variables public as you will see at the top of the code I am posting. As stated the method called by the first method, the  variables were reset each time. Which makes sense. I learned something new and I am grateful \n\n```\n    public static long low = 0;\npublic static long tempLow = 0;\npublic static long tempHi = 0;\npublic static long hi = 0;\n\npublic static void runFibonacci () {\n    for (int N = 0; N < 100; N++)\n        StdOut.printf (\"fibonacci(%2d)=%d\\n\", N, fibonacci (N));\n}\npublic static long fibonacci (int N) {\n\n    if (N == 0) return 0;\n    if (N == 1) {\n        hi ++;\n        return 1;\n    }\n\n    if (N == 2){\n        low ++;\n        return 1;\n    }\n\n    if (N > 2){\n        tempLow = hi;\n        tempHi = (low + hi);\n        hi = tempHi;\n        low = tempLow;\n        return hi;\n    }\n    else{\n        return 0;\n    }\n}\n```\n\n\noutput\n\n```\nfibonacci( 0)=0\nfibonacci( 1)=1\nfibonacci( 2)=1\nfibonacci( 3)=2\nfibonacci( 4)=3\nfibonacci( 5)=5\nfibonacci( 6)=8\nfibonacci( 7)=13\nfibonacci( 8)=21\nfibonacci( 9)=34\nfibonacci(10)=55\nfibonacci(11)=89\nfibonacci(12)=144\nfibonacci(13)=233\nfibonacci(14)=377\nfibonacci(15)=610\nfibonacci(16)=987\nfibonacci(17)=1597\nfibonacci(18)=2584\nfibonacci(19)=4181\nfibonacci(20)=6765\nfibonacci(21)=10946\nfibonacci(22)=17711\nfibonacci(23)=28657\nfibonacci(24)=46368\nfibonacci(25)=75025\nfibonacci(26)=121393\nfibonacci(27)=196418\nfibonacci(28)=317811\nfibonacci(29)=514229\nfibonacci(30)=832040\nfibonacci(31)=1346269\nfibonacci(32)=2178309\nfibonacci(33)=3524578\nfibonacci(34)=5702887\nfibonacci(35)=9227465\nfibonacci(36)=14930352\nfibonacci(37)=24157817\nfibonacci(38)=39088169\nfibonacci(39)=63245986\nfibonacci(40)=102334155\nfibonacci(41)=165580141\nfibonacci(42)=267914296\nfibonacci(43)=433494437\nfibonacci(44)=701408733\nfibonacci(45)=1134903170\nfibonacci(46)=1836311903\nfibonacci(47)=2971215073\nfibonacci(48)=4807526976\nfibonacci(49)=7778742049\nfibonacci(50)=12586269025\nfibonacci(51)=20365011074\nfibonacci(52)=32951280099\nfibonacci(53)=53316291173\nfibonacci(54)=86267571272\nfibonacci(55)=139583862445\nfibonacci(56)=225851433717\nfibonacci(57)=365435296162\nfibonacci(58)=591286729879\nfibonacci(59)=956722026041\nfibonacci(60)=1548008755920\nfibonacci(61)=2504730781961\nfibonacci(62)=4052739537881\nfibonacci(63)=6557470319842\nfibonacci(64)=10610209857723\nfibonacci(65)=17167680177565\nfibonacci(66)=27777890035288\nfibonacci(67)=44945570212853\nfibonacci(68)=72723460248141\nfibonacci(69)=117669030460994\nfibonacci(70)=190392490709135\nfibonacci(71)=308061521170129\nfibonacci(72)=498454011879264\nfibonacci(73)=806515533049393\nfibonacci(74)=1304969544928657\nfibonacci(75)=2111485077978050\nfibonacci(76)=3416454622906707\nfibonacci(77)=5527939700884757\nfibonacci(78)=8944394323791464\nfibonacci(79)=14472334024676221\nfibonacci(80)=23416728348467685\nfibonacci(81)=37889062373143906\nfibonacci(82)=61305790721611591\nfibonacci(83)=99194853094755497\nfibonacci(84)=160500643816367088\nfibonacci(85)=259695496911122585\nfibonacci(86)=420196140727489673\nfibonacci(87)=679891637638612258\nfibonacci(88)=1100087778366101931\nfibonacci(89)=1779979416004714189\nfibonacci(90)=2880067194370816120\nfibonacci(91)=4660046610375530309\nfibonacci(92)=7540113804746346429\nfibonacci(93)=-6246583658587674878\nfibonacci(94)=1293530146158671551\nfibonacci(95)=-4953053512429003327\nfibonacci(96)=-3659523366270331776\nfibonacci(97)=-8612576878699335103\nfibonacci(98)=6174643828739884737\nfibonacci(99)=-2437933049959450366\n```\n\n    ", "Knowledge_point": "Fibonacci Sequence", "Tag": "算法分析"}
