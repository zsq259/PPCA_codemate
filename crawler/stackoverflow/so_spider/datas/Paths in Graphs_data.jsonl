{"Question": "Are paths in graph connected\r\n                \r\nI have a problem with paths in graph. We have a graph, for example:\n5 verticles and 4 edges\n1 2 first is connected to second, etc\n2 3\n3 4\n5 1  \n\nAnd now I would like answer on questions(for example): \nIf vertex 1 is conneted to \nvertex 3. Answer is YES - becauese we have path\" 1 -> 2 -> 3.\n\nWhat Do you advise me?\n\nI have no idea how to do it.\n    ", "Answer": "\r\nThis will require some research on your part. The idea is to use a graph traversal algorithm like depth-first or breadth-first. Start from a vertex (like 1 in your example) and keep traversing the graph until you either reach the target node (3 in your example) or you cannot find any more paths to follow.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "number of paths in graph\r\n                \r\nhow could the number of paths in a directed  graph calculated? Are there any algorithms for this purpose?\n\nBest wishes  \n\nEDIT: The graph is not a tree.\n    ", "Answer": "\r\nLet ```\nA```\n be the adjacency matrix of a graph ```\nG```\n. Then ```\nA^n```\n (i.e. ```\nA```\n multiplied ```\nn```\n times with itself) has the following interesting property:\n\nThe entry at position ```\n(i,j)```\n of ```\nA^n```\n equals the number of different paths of length ```\nn```\n from vertex ```\ni```\n to vertex ```\nj```\n.\n\nHence:\n\n\nrepresent the graph as an adjacency matrix ```\nA```\n\nmultiply ```\nA```\n it with itself repeatedly until you get bored\nin each step: compute the sum of all matrix elements and add it to the result, starting at 0\n\n\nIt might be wise to first check whether G contains a cycle, because in this case it contains infinitely many paths. In order to detect cycles, set all edge weights to -1 and use Bellman-Ford.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "finding paths in graphs with integer stack or array\r\n                \r\nGiven a graph (ordered DAG) represented using an adjacency matrix\n\n```\ng = [\n        [0,1,1,0,0,0,0],\n        [0,0,0,1,0,0,0],\n        [0,0,0,1,0,0,0],\n        [0,0,0,0,1,1,0],\n        [0,0,0,0,0,0,1],\n        [0,0,0,0,0,0,1],\n        [0,0,0,0,0,0,0]\n    ]\n```\n\n\nI wrote the following to figure out all the longest paths in the graph starting from the first node, node 0.\n\n```\nfrom collections import deque\nstack = deque()\nstack.append([0])\ncurrent_longest = 1\npaths = []\nN = len(g[0])\n\nwhile stack:\n    cur_path = stack.pop()\n    print(cur_path)\n    last_node = cur_path[-1]\n\n    any_n = False\n    for new_node in range(last_node + 1, N):\n        if g[last_node][new_node] == 1:\n            any_n = True\n            stack.append(cur_path + [new_node])\n\n    if any_n == False:\n        if len(cur_path) > current_longest:\n            nmb_paths = 1\n            paths = []\n            paths.append(cur_path) \n            current_longest = len(cur_path)\n        elif len(cur_path) == current_longest:\n            nmb_paths += 1\n            paths.append(cur_path)    \nprint(f\"paths = {paths}\")\n```\n\n\nThe output of this:\n\n```\n[0]\n[0, 2]\n[0, 2, 3]\n[0, 2, 3, 5]\n[0, 2, 3, 5, 6]\n[0, 2, 3, 4]\n[0, 2, 3, 4, 6]\n[0, 1]\n[0, 1, 3]\n[0, 1, 3, 5]\n[0, 1, 3, 5, 6]\n[0, 1, 3, 4]\n[0, 1, 3, 4, 6]\npaths = [[0, 2, 3, 5, 6], [0, 2, 3, 4, 6], [0, 1, 3, 5, 6], [0, 1, 3, 4, 6]]\n```\n\n\nbut I am now trying to figure out if I can do this without the luxury of an array stack. So if I can't store arrays as elements of the stack, I can only use an integer stack or a normal array. I am stuck on this, I think it's a matter of keeping track of the length of the list, as it grows, storing each path, and if it doesn't grow, storing the path, but a little stumped atm, any hints?\n    ", "Answer": "\r\nnot much interest, but thought I'd put up my solution anyway, in case it helps anyone (I was implementing this in C so it was a pain having to write an ArrayStack) this was my prototype:\n\n```\ng = [\n        [0,1,1,0,0,0,0],\n        [0,0,0,1,0,0,0],\n        [0,0,0,1,0,0,0],\n        [0,0,0,0,1,1,0],\n        [0,0,0,0,0,0,1],\n        [0,0,0,0,0,0,1],\n        [0,0,0,0,0,0,0]\n    ]\n\nN = len(g[0])\n\nnmb_paths = 1\ncurrent_longest = 1\npaths = []\narray = [0]\ncurrent_length = 1\nvisited = [0] * N\nvisited[0] = 1\npred = [-1] * N\n\n\nwhile current_length > 0:\n    last_node = array[current_length-1]\n\n    any_n = False\n    new_node = last_node + 1\n\n    print('paths = ', paths)\n\n    while not any_n and new_node < N:\n        if g[last_node][new_node] == 1 and visited[new_node] != 1:\n            if pred[new_node] != last_node:\n                pred[new_node] = last_node\n                any_n = True\n\n                array.append(new_node)\n                visited[new_node] = 1\n                current_length += 1\n                last_node = new_node\n\n                if current_length > current_longest:\n                    paths = []\n                    app = array.copy()\n                    paths.append(app)\n                    current_longest = current_length\n                    nmb_paths = 1\n                elif current_length == current_longest:\n                    app = array.copy()\n                    paths.append(app)\n                    nmb_paths += 1\n\n        new_node+=1\n\n    if any_n == False:\n        final = array[current_length - 1]\n        del array[current_length-1]\n        visited[final] = 0\n        for j in range(final+1, N):\n            pred[j] = -1\n        current_length -= 1\n```\n\n\nthe progression of paths:\n\n```\npaths =  []\npaths =  [[0, 1]]\npaths =  [[0, 1, 3]]\npaths =  [[0, 1, 3, 4]]\npaths =  [[0, 1, 3, 4, 6]]\npaths =  [[0, 1, 3, 4, 6]]\npaths =  [[0, 1, 3, 4, 6]]\npaths =  [[0, 1, 3, 4, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6], [0, 2, 3, 4, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6], [0, 2, 3, 4, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6], [0, 2, 3, 4, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6], [0, 2, 3, 4, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6], [0, 2, 3, 4, 6], [0, 2, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6], [0, 2, 3, 4, 6], [0, 2, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6], [0, 2, 3, 4, 6], [0, 2, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6], [0, 2, 3, 4, 6], [0, 2, 3, 5, 6]]\npaths =  [[0, 1, 3, 4, 6], [0, 1, 3, 5, 6], [0, 2, 3, 4, 6], [0, 2, 3, 5, 6]]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "the number of possible paths in graph\r\n                \r\nI have to calculate the number of possible paths in undirected graph\nExample: I have a undirected graph with 4 node. The vertices: 1->2; 2>3; 2->4.\nSo the number of possible paths is 12\n\n```\n(1->2;  1->2->3;  1->2->4;  2->1;  2->3;  2->4;  3->2;  3->2->4...and so on);\n```\n\n    ", "Answer": "\r\nBecause I don't know exactly how you wrote your code, all I can give you is some sort of a pseudo-code explanation :\n\n```\nfunction getPathsFromNode(node)\n    mark node\n    c = 0;\n\n    foreach neighbour in adjacent nodes of node\n        if neighbour is not marked\n            c += getPathsFromNode(neighbour) + 1\n\n    return c\n\n\nfunction main()\n    n = 0\n    foreach node in graph\n        n += getPathsFromNode(node)\n\n    print(\"paths = \", n)\n```\n\n\nBasically it's just a DFS for every node of the graph.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "shortest paths not path in graph\r\n                \r\nI was wondering if there is an algorithm which would find shortest paths in graph.\n\nLet's say that I have a graph where there are couples of path from one vertex to another. Two or more of these paths have the same cost. How can I mark, find etc all shortest paths between these vertices ? As far as I know Dijkstra or Bellman-Ford algorithms will find shortest path but they \"choose\" only one.\n    ", "Answer": "\r\nDijkstra's algorithm gives you the cost to all the possible intermediate nodes, and the cost of the shortest path to the sink.  You can get all the paths from source to sink by doing a depth first search from the sink to the source (going backwards), where you traverse an edge (backwards) only if the cost of that edge is equal to the difference between cost of the shortest path from the source to the two nodes.  Of course you get the paths in reverse order, but reversing them is easy.  \n\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Computing many shortest paths in graph\r\n                \r\nI have a large (weighted, directed) graph (>100,000 nodes) and I want to compute a large number of random shortest paths in that graph. So I want to randomly select two nodes (let's say k times) and compute the shortest path. One way to do this is using either the networkx or the igraph module and doing a for loop as in \n\n```\npairs=np.random.choice(np.arange(0,len(graph.nodes)), [k,2]) \nfor pair in pairs:\n    graph.get_shortest_paths(pair[0],pair[1], weights='weight')\n```\n\n\nThis works, but it takes a long time. Especially, compared to computing all paths for a particular source node. Essentially, in every iteration the process loads the graph again and starts the process from scratch. So is there a way to benefit from loading the graph structure in to memory and not redoing this in each iteration without computing all shortest paths (which would take too long given that those would be n*(n-1) paths).\n\nPhrased differently, can I compute a random subset of all shortest paths in an efficient way? \n    ", "Answer": "\r\nAFAIK, the operations are independent of each other, so running them in parallel could work (pseudocode):\n```\nimport dask\n\n@dask.delayed\ndef short_path(graph, pair):\n    return graph.get_shortest_paths(pair[0],pair[1], weights='weight')\n\npairs=np.random.choice(np.arange(0,len(graph.nodes)), [k,2]) \nresults = dask.compute(*[short_path(pair) for pair in pairs])\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find paths in graphs using LINQ only\r\n                \r\nThis question is about finding a LINQ-Query that extracts a path in an acyclic graph from any given node to any other given node.\n\nPlease note this is about LINQ only (to demonstrate its power or show its limitations)\n\nAssume the following classes to represent a Graph ```\nG = (V,E)```\n\n\nDataStruc\n\n```\n    internal class Vertice\n    {\n        private Int32 id;\n\n        public Vertice(Int32 id)\n        {\n            this.id = id;\n        }\n\n        public Int32 GetId()\n        {\n            return this.id;\n        }\n    }\n    internal class Edge\n    {\n        private Int32 id;\n        private Vertice v1;\n        private Vertice v2;\n\n        public Edge(Int32 id, Vertice v1, Vertice v2)\n        {\n            this.id = id;\n            this.v1 = v1;\n            this.v2 = v2;\n        }\n\n        public Vertice GetFirstVertice()\n        {\n            return this.v1;\n        }\n        public Vertice GetSecondVertice()\n        {\n            return this.v2;\n        }\n        public Int32 GetId()\n        {\n            return this.id;\n        }\n\n        public Boolean ConnectedTo(Vertice v)\n        {\n            if (v.GetId() == this.v1.GetId()) return true;\n            if (v.GetId() == this.v2.GetId()) return true;\n\n            return false;\n        }\n\n        public Boolean Connects(Vertice u, Vertice v)\n        {\n            if (!this.ConnectedTo(u)) return false;\n            if (!this.ConnectedTo(v)) return false;\n\n            return true;\n        }\n    }\n```\n\n\nNow create a graph as displayed using the code shown below the image (yes, the picture shows a digraph, but let's ignore that for now)\n\n\n\nCode to create the graph\n\n```\n        // Create Vertices\n        List<Vertice> v = new List<Vertice>();\n        v.Add(new Vertice(0));\n        v.Add(new Vertice(1));\n        v.Add(new Vertice(2));\n        v.Add(new Vertice(3));\n        v.Add(new Vertice(4));\n\n        // Create Edges\n        List<Edge> e = new List<Edge>();\n        e.Add(new Edge(0, v[0], v[1]));\n        e.Add(new Edge(1, v[1], v[2]));\n        e.Add(new Edge(2, v[1], v[3]));\n        e.Add(new Edge(3, v[1], v[4]));\n        e.Add(new Edge(4, v[2], v[4]));\n```\n\n\nand now let's query the graph (v,e)\n\nQuery to extract all edges from v0 to v1\n\n```\n        var edge_query =\n            from edge in e\n            where edge.Connects(v[0], v[1])\n            select edge;\n```\n\n\nExecuting the query gives exactly one edge (id=0). I am now curious whether it is possible to write a LINQ-query that returns multiple sets of edges where each set contains one path from a given node ```\nu```\n to another given node ```\nv```\n\n\nHere is the complete code that can be pasted into a ```\nConsoleApplication```\n.\n\nKind regards,\nBenj\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace StackOverflow\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Create Vertices\n            List<Vertice> v = new List<Vertice>();\n            v.Add(new Vertice(0));\n            v.Add(new Vertice(1));\n            v.Add(new Vertice(2));\n            v.Add(new Vertice(3));\n            v.Add(new Vertice(4));\n\n            // Create Edges\n            List<Edge> e = new List<Edge>();\n            e.Add(new Edge(0, v[0], v[1]));\n            e.Add(new Edge(1, v[1], v[2]));\n            e.Add(new Edge(2, v[1], v[3]));\n            e.Add(new Edge(3, v[1], v[4]));\n            e.Add(new Edge(4, v[2], v[4]));\n\n            // Query Set\n            var edge_query =\n                from edge in e\n                where edge.Connects(v[0], v[1])\n                select edge;\n\n            foreach (Edge edge in edge_query)\n            {\n                Console.WriteLine(\"e\" + edge.GetId() + \" connects v\" + edge.GetFirstVertice().GetId() + \" and v\" + edge.GetSecondVertice().GetId());\n            }\n\n            // Wait for the user to understand\n            Console.WriteLine();\n            Console.WriteLine(\"[ENTER] to terminate ...\");\n            Console.ReadLine();\n\n        }\n\n        internal class Vertice\n        {\n            private Int32 id;\n\n            public Vertice(Int32 id)\n            {\n                this.id = id;\n            }\n\n            public Int32 GetId()\n            {\n                return this.id;\n            }\n        }\n        internal class Edge\n        {\n            private Int32 id;\n            private Vertice v1;\n            private Vertice v2;\n\n            public Edge(Int32 id, Vertice v1, Vertice v2)\n            {\n                this.id = id;\n                this.v1 = v1;\n                this.v2 = v2;\n            }\n\n            public Vertice GetFirstVertice()\n            {\n                return this.v1;\n            }\n            public Vertice GetSecondVertice()\n            {\n                return this.v2;\n            }\n            public Int32 GetId()\n            {\n                return this.id;\n            }\n\n            public Boolean ConnectedTo(Vertice v)\n            {\n                if (v.GetId() == this.v1.GetId()) return true;\n                if (v.GetId() == this.v2.GetId()) return true;\n\n                return false;\n            }\n            public Boolean Connects(Vertice u, Vertice v)\n            {\n                if (!this.ConnectedTo(u)) return false;\n                if (!this.ConnectedTo(v)) return false;\n\n                return true;\n            }\n        }\n    }\n}\n```\n\n\nEDIT 1\n\nie. when changing the ```\nEdge.Connects```\n-method to\n\n```\n            public Boolean Connects(Vertice u, Vertice v)\n            {\n                if (this.v1.GetId() != u.GetId()) return false;\n                if (this.v2.GetId() != v.GetId()) return false;\n\n                return true;\n            }\n```\n\n\none can use the query \n\n```\n            var edge_query =\n                from u1 in v\n                from edge1 in e\n                from edge2 in e\n                where edge1.Connects(v_start, u1)\n                where edge2.Connects(u1, v_stop)\n                select new Tuple<Edge, Edge>(edge1, edge2);\n```\n\n\nto extract all paths from ```\nv_start```\n to ```\nv_stop```\n via any vertice ```\nu1```\n in V. is it possible to extend the query to consider an arbitrary amount of intermediate vertices?\n\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all possible paths in graph\r\n                \r\nI'm looking for some algorithm which will help me find all possible paths in a graph. Everything I found so far is not fully satisfying.\n\nLet's imagine we have a graph (tree) like this one:\n\n\nAnd let's use some algorithm like Breadth-First Search or Depth-First Search. In return we'll get something like \n\n```\n1, 2, 4, (2), 5, (2), 6, (2), (1), 3, 7, 8, (7), 9\n```\n\n\nWhich is how we go through this tree and this is not what I'm looking for. I'd love to get all paths, like:\n\n```\n1\n1, 2\n1, 2, 4\n1, 2, 5\n1, 2, 6\n1, 3\n1, 3, 7\n1, 3, 7, 8\n1, 3, 7, 9\n```\n\n\nThe thing is that I want just to specify ```\nroot```\n node and algorithm should be able to provide me with all possible paths of any length.\n\n\n\nSo far, the simple code I have looks like:\n\n```\nfunc dfs(_ graph: Graph, source: Node) -> [String] {\n    var nodesExplored = [source.label]\n    source.visited = true\n\n    for edge in source.neighbors {\n        if !edge.neighbor.visited {\n            nodesExplored += dfs(graph, source: edge.neighbor)\n        }\n    }\n\n    return nodesExplored\n}\n```\n\n    ", "Answer": "\r\nJust fold the result and count the new possibilities: Result = 9 (you forgott the path [1] )\n\n```\nn0  n1  n2  n3\n1,   2,  4,       +3\n    (2), 5,       +1\n    (2), 6,       +1\n    (2),          +0\n(1), 3,  7,  8,   +3\n        (7), 9    +1\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Enumerating all paths in a directed acyclic graph\r\n                \r\nIs there any standard algorithm that finds all possible paths in a directed a-cyclic graph.\nIf not, how can i make changes in BFS/Dijkstra/any other algorithm  to enumerate all paths in a DAG\n    ", "Answer": "\r\nFinding all the possible paths in any graph in Exponential. It can be solved by using Backtracking.\nFor DAG's we can do it using Depth first search(DFS).\nIn DFS code, Start at any node, Go to the extreme dead end path and note down all the nodes visited in that path using some array or list. As soon as you find a dead end print the array containing the visited nodes and pop the last stored node and start in the other path of the (n-1)th node. If all the paths of the (n-1)th node are exhausted pop that node from list and start at (n-2)node. Do this untill you reach all the dead ends and reach the first node.\nAll the Printed paths are the Paths in the given DAG.\n\nYou can check the code http://pastebin.com/p6ciRJCU\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in graph\r\n                \r\nSince last 2 days,i'm trying to find some logic for calculating longest path in graph.I know i can find it easily for DAGs and in general it is polynomial time algorithm.Formally,I want to implement heuristic for computing longest path,morever,if probability p is given with which an edge is present in graph,how can we solve the problem..help...\n    ", "Answer": "\r\nCalculating longest path cannot be done in polynomial time as far as I know. Following java implementation of the longest path algorithm finds the longest path of a positive weighted graph for a given source but it takes exponential time in its worst case.\n```\npublic class LongestPath {\n    static int times;\n\n    public double initLongestPath(ArrayList<Vertex> V, Vertex source) {\n        for (Vertex u : V) {\n            u.setVisited(false);\n        }\n        return getLongestPath(source);\n    }\n\n    public double getLongestPath(Vertex v) {\n        ++times;\n        System.out.println(times);\n        double w, dist, max = 0;\n        v.setVisited(true);\n        for (Edge e : v.getOutGoingEdges()) {\n            if (!e.getToNode().isVisited()) {\n                dist = e.getWeight() + getLongestPath(e.getToNode());\n                if (dist > max)\n                    max = dist;\n            }\n        }\n\n        v.setVisited(false);\n        return max;\n    }\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all paths in graph using neo4j\r\n                \r\nI have a DAG and I want to find all paths in it using neo4j. For doing this I am using the following query:\n\n```\nMATCH (n)-[:REL]->(leaf)\nRETURN n,leaf ;\n```\n\n\nHowever this query only return to me edges. However I want my output to be of the form: \n\n```\n  a->b->c->d->e->f->g->h->i\n  a->b1->c1->d1->e1->f1->g1->h1->i1\n```\n\n\nIs there someway that I can use to get this output?\n    ", "Answer": "\r\nI think you'll want to look at variable-length pattern matching. You'll want to add restrictions so that your start node is a root and your end node is a leaf, otherwise you'll get every subpath in the graph.\n\nAlso, you really should be using labels. For the sake of example, I'll just :Node in my Cypher snippet:\n\n```\nMATCH path = (root:Node)-[:REL*]->(leaf)\nWHERE NOT ()-[:REL]->(root) AND NOT (leaf)-[:REL]->()\nRETURN path\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Calculating paths in a graph\r\n                \r\nI have to make a method for making a list with all the paths in a graph.My graph has only one start node and one finish node. Each node has a list whith its children and other list whith its parents. I have to make another list containing all the paths (each of them in another list)\n\nAny suggestion??\n    ", "Answer": "\r\nIt depends on whether it is acyclic or not. Clearly a cycle will result in infinity paths (once round the loop, twice round, 3 times round... etc etc). If the graph is acyclic then you should be able to do a depth-first seach (DFS) (http://en.wikipedia.org/wiki/Depth-first_search) and simply count the number of times you encounter the destination node.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find path in graphs\r\n                \r\nI am trying to learn python, and started few weeks back. I was reading about graphs today and found the below code:\n\n```\nclass Graph(object):\n    def __init__(self, graph_dict=None):\n        if graph_dict == None:\n            graph_dict = {}\n        self.__graph_dict = graph_dict\n\n    def find_path(self, start_vertex, end_vertex, path=None):\n        \"\"\"Find a path from start_vertex to end_vertex in graph.\"\"\"\n        if path == None:\n            path = []\n\n        graph = self.__graph_dict\n        print(self.__graph_dict)\n\n        path = path + [start_vertex]\n        if start_vertex == end_vertex:\n            return path\n        if start_vertex not in graph:\n            return None\n        for vertex in graph[start_vertex]:\n            if vertex not in path:\n                extended_path = self.find_path(vertex, end_vertex, path)\n                if extended_path:\n                    return extended_path\n        return None\n\n\nif __name__ == \"__main__\":\n    g = {\"a\" : [\"c\"],\n         \"b\" : [\"c\", \"e\"],\n         \"c\" : [\"b\", \"d\", \"e\"]}\n\n    graph = Graph(g)\n\n    graph.find_path(\"a\", \"d\")\n```\n\n\nhere i am not able to understand when i print \n```\nprint(self.__graph_dict)```\n \ni get the below as print output:\n\n```\n{'a': ['c'], 'b': ['c', 'e'], 'c': ['b', 'd', 'e']}\n{'a': ['c'], 'b': ['c', 'e'], 'c': ['b', 'd', 'e']}\n{'a': ['c'], 'b': ['c', 'e'], 'c': ['b', 'd', 'e']}\n{'a': ['c'], 'b': ['c', 'e'], 'c': ['b', 'd', 'e']}\n{'a': ['c'], 'b': ['c', 'e'], 'c': ['b', 'd', 'e']}\n```\n\n\nWhat i am not able to understand why it is repeated 5 times and not just once which is the dictionary value of the graph. Does it have any significance also? Am i missing something here. Thanks in advance for valuable inputs and time. \n    ", "Answer": "\r\nYou are getting the print out 5 times because you are recursively calling ```\nfind_path```\n. \n\nSee the code: \n\n```\nfor vertex in graph[start_vertex]:\n    if vertex not in path:\n        extended_path = self.find_path(vertex, end_vertex, path) #this is being hit 4 times\n```\n\n\nI don't see that as an issue as far as your code working or not. It seems to make sense to me.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest paths in graph\r\n                \r\nI've got a problem with a 2-section question:\n\nG=(V,E) is undirected unweighted graph. t,s are nodes in the graph. e=(a,b) is an edge in the graph.\n\n1) Suggest an efficient algorithm that checks if e is a part of all shortest paths from s to t.\n\n2) Suggest an efficient algorithm that checks if e is a part of one of the shortest paths from s to t.\n\nI've seen in the forum suggestion to solving section 1, by using Dijkstra algorithm twice, once with the given edge and once without. Then you need to compare the results.\nHowever, I didn't managed to figure more efficient way to solve section 2. I guess it is possible, but I don't know how.\n\nAny suggestions? \n    ", "Answer": "\r\nActually for an unweighted, undirected graph, you don't need to use Dijkstra, a simple BFS shall serve the purpose.\n\nFollowing method checks whether e is a part of atleast one shortest path from s to t:\n\nCompute the shortest path from s to e and the shortest path from e to t\n\nIf the sum of the lengths of these two paths is equal to the shortest path from s to t, then e is a part of atleast one shortest path from s to t.\n\n```\ns -----> e -------> t\n```\n\n\nIf you want to know whether e is a part of exactly one shortest path from s to t, then in addition, the following link maybe be helpful. It concerns a directed graph, but our undirected graph can be thought of as a directed graph with edge from ```\nu to v```\n and ```\nv to u```\n.  \n\nHow to find the number of different shortest paths between two vertices, in directed graph and with linear-time?\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Estimate number of n-node paths in graph using only n and graph density\r\n                \r\nI have a large, dense graph (~33,000 nodes, ~345 million edges, so the graph density is approximately 0.63). I'm interested in estimating the number of 3-edge paths in this graph. Is there an accurate estimation using only this information (ie no adjacency matrices)?\n    ", "Answer": "\r\nIf a rough estimate is good enough (and the number k of edges in the paths is fix and small): let d be the density, then you have n starting nodes, about n * d possible second nodes, ... and about n * d^k end nodes. If k is small the number of paths with cycles are small opposed to the simple paths. The number of all paths would be about n^(k+1) * d^(k(k+1)/2) - so this would be a (quite) rough estimate.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to print paths in DFS manner in graphs?\r\n                \r\nI have a tree(not binary tree) in which I would like to get paths from the root node to all leaves. \nFor instance;\n\n```\n    A\n  / | \\ \n B  C  D\n/ \\ | / \\\nE F G H I\n```\n\n\nI want to get all the paths = {[A,B,E], [A,B, F], [A, C, G], [A, D, H], \n[A, D, I]}\n\nWhat I have done up to now is;\n\nI have a Graph class;\n\n```\npublic class Graph {\n    static class Node{\n       String name;\n       HashSet<Edge> inEdges;\n       HashSet<Edge> outEdges;}\n    static class Edge{\n       Node from;\n       Node to;\n       String id;} \n}    \n```\n\n\nAnd I traverse the tree with this snippet;\n\n```\nvoid printAllPaths(rootNode, list) {\n    System.out.println(rootNode.name);\n    list.add(rootNode.name);\n    int childCount = rootNode.outEdges.size();\n    if (childCount == 0) {\n        System.out.println(list);\n        list.pop();//one for node\n        list.pop();//one for edge\n    } else {\n        for (Graph.Edge e : rootNode.outEdges) {\n            System.out.println(e.id);\n            list.add(e.id);\n            printAllPaths(e.to, list, rootNodeReplica);\n        }\n    }\n}\n```\n\n\nWhat I am basically doing is; \n\n\nadd Node and Edge to the stack\nif the node has children, do the same as above\nif the node is a leaf, print the list/stack and pop the node from the list/stack\n\n\nHowever;\nWhen the algorithm finishes B Node branch and move to C; the list still keeps {A Edge B}, However when changing branch it should just include Node A. So that my path becomes ; A Edge B Edge C Edge G not A edge C edge G.\n\nHow can I solve this issue?\nThanks in advance\nKind Regards\n    ", "Answer": "\r\nLet's look at a simpler version of the problem. Say, we're given given a chain ```\nA -- B -- E```\n. We've to print the following triangular shape.\n\n```\nA\nA B\nA B C\nA B C\nA B\nA\n```\n\n\nCan we do it using recursion? Sure we can!\n\n```\nvoid printEachPath(currentRoot, stack) {\n    if (currentRoot == null) return;\n\n    stack.push(currentRoot.name);\n    print stack;\n\n    printEachPath(currentRoot->next, stack);\n\n    print stack; \n    stack.pop(currentRoot.name);\n}\n```\n\n\nI hope you've got some hints from this.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Display all the paths in a graph\r\n                \r\nI work to a java project and I want to display all the paths in a graph ( this graph is represented using adjacency matrix). I try to use DFS algorithm but how can I display all this paths? \n\nI try this \n\n```\nfor(int i=0; i<nr; i++) \n        for(int j=0; j<nr; j++)\n            dfs(i,j);\n```\n\n\nAnd the DFS algorithm is this : \n\n```\npublic static void dfs(int src, int dst) {\n\n        al.add(src);\n        size++;\n        color[src] = true;\n        if (src == dst) {       // tests for base condition to stop\n            for (Integer i : al) {\n                //     Prints the path\n                System.out.print(i + \" \");\n            }\n            System.out.println();\n            return;\n        }\n        for (int I = 0; I < nr; I++) {\n            if (matrix[src][I].contains(\"1\")  {\n                if (color[I] == false) {\n                    dfs(I, dst);        // These lines do\n                    color[I] = false;   // main job of backtracking\n                    size--;\n                    al.remove(size);\n                }\n            }\n        }\n    }\n```\n\n\nIf I call the function dfs(2,3) the result is good, but that loop seems doesn't work.\n    ", "Answer": "\r\nIt seems to me that when attempting to find a path, you are confusing two things, both stored in the ```\ncolor[I]```\n index.\n\nOne, you need something (color will do) to store whether you have visited the node.  It seems your ```\ndfs```\n routine is well poised to \"color\" visited nodes, and \"uncolor\" unvisited nodes.\n\nBut what isn't apparent, is that you don't seem to have an adjacency matrix that you are searching.  Can you please point out the line of code where you check that two nodes are connected?  Without some decision to know when it is appropriate to follow a node to another node, you run the risk of simply walking the maximum number of possible interconnections (instead of the interconnections that exist).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths in depth first search in graph\r\n                \r\nI am trying to find all the possible paths from one node in my graph that will visit all other nodes in the graph. I want the function to produce all possibilities of paths in my n*m graph. Each node in my graph has a vector of all neighbors nodes and a Boolean that check if the node is visited or not. \n\nexample:\n\n```\na  b\n\nc  d\n```\n\n\nwill produce:\n\n```\nabcd\nabdc\nacbd\n...\n```\n\n\nI tried the solution in this answer, but only return one path. How can I produce all possible paths?\n    ", "Answer": "\r\nIt seems like in some situations by your description you could have infinite paths and a path of infinite length because you didn't specify that nodes couldn't be revisited.\n\nYou should implement depth first search and pass a reference to an array of marked (visited) nodes in your recursive DFS method assuming that you have a count of the number of nodes in your graph. After you visit each node, before you leave that node make sure you set it to false again so that it can be reaccessed via another node. \n\nThe implementation of this algorithm is really going to depend on how you implemented your graph structure and without the details all I can do is speculate that you have a linked structure with an adjacency list representing the different nodes. I also have no idea how the different nodes map to characters so that is another detail I have to speculate, but say that the nodes are represented by integers.\n\nYou need to pass into a DFS method the following: array of marked nodes, a linked list which contains the path information, starting node, (i.e, current node) and final node \n\n```\n void printAllPaths(LinkedList<Integer> currentPath, boolean[] marked, int current, int last){ \n\n    for( all nodes adjacent to current, node ){\n      if(node == last){ \n         currentPath.addLast(last); \n         System.out.println(currentPath);\n         currentPath.removeLast();\n      }else if(!marked[node]){\n         currentPath.addLast(node);\n         marked[node] = true;\n         printAllPaths(currentPath, marked, node, final);\n         marked[node] = false;\n         currentPath.removeLast();\n      }\n    }\n }\n```\n\n\nThis will be the basic idea of the code. I apologize if it doesn't compile in advance, but this should print out all of the paths.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find Longest path in graph\r\n                \r\nI have one problem with my solution for finding longest path in graph. My Programm works very slow when vertices are close to each other. Here is my code please help me.\n\n\n  Test class\n\n\n```\npublic class GraphTest : MonoBehaviour {\n\n// Use this for initialization\nvoid Start () {\n\n    const int w = 5;\n    const int h = 4;\n\n\n    int[,] data = new int[h,w]{\n        {0,0,0,1,0},\n        {0,0,0,1,0},\n        {0,0,1,1,0},\n        {0,0,0,0,0}};\n\n    Map map = new Map(data,w,h);\n\n    List<Node> longest = map.longestPath();\n    Debug.Log(\"LONGEST \" + longest.Count);\n\n    //INFO this doing for printing array with steps\n    int c = longest.Count-1;\n    foreach(Node n in longest)\n        data[n.r,n.c] = c--;\n\n    string st = \"\";\n    for(int i = 0; i < h; i++ )\n    {\n        for(int j = 0; j < w; j++)\n        {\n            st += data[i,j] + \",\";\n        }\n        st += \"\\n\";\n    }\n\n    Debug.Log(st);\n}\n}\n```\n\n\n\n  Node class\n\n\n```\npublic class Node\n{\npublic int r,c;\npublic int data;\npublic Node[] neighbors;\n\npublic Node(int r, int c, int data)\n{\n    this.r = r;\n    this.c = c;\n    this.data = data;\n    neighbors = new Node[8];\n}\n}\n```\n\n\n\n  Map class for finding paths\n\n\n```\npublic class Map\n{\npublic static int[] xDir = {1,1,1,0,-1,-1,-1,0};\npublic static int[] yDir = {-1,0,1,1,1,0,-1,-1};\n\npublic Node[,] map;\npublic int[,] mapData;\n\nprivate int width,height;\nprivate int[,] marks;\npublic Map(int[,] mapData,int width,int height)\n{\n    this.mapData = mapData;\n    this.width = width;\n    this.height = height;\n\n    createNodes();\n    initNeighbors();\n}\n//INFO create nodes\nprivate void createNodes()\n{\n    map = new Node[height,width];\n    for(int i = 0; i < height; i++ )\n    {\n        for(int j = 0; j < width; j++)\n        {\n            map[i,j] = new Node(i,j,mapData[i,j]);\n        }\n    }\n}\n//INFO assign neighbor nodes\nprivate void initNeighbors()\n{\n    for(int i = 0; i < height; i++ )\n    {\n        for(int j = 0; j < width; j++)\n        {\n            for(int k = 0; k < 8; k++)\n            {\n                if(inRange(i+yDir[k],j+xDir[k]))\n                {\n                    map[i,j].neighbors[k] = map[i+yDir[k],j+xDir[k]];\n                }\n            }\n        }\n    }\n}\n\nprivate bool inRange(int r, int c)\n{\n    return r < height && r >= 0 && c < width && c >= 0;\n}\n\npublic List<Node> longestPath()\n{\n    marks = new int[height,width];\n    List<Node> nodes = new List<Node>();\n    int c = dfs(map[0,0],nodes);\n\n    //INFO Iterasions count\n    Debug.Log(\"COUNT \" + c);\n    return nodes;\n}\n\nprivate int dfs(Node node, List<Node> nodes)\n{\n    int i = 1;\n    List<Node> longest = new List<Node>();\n    List<Node> list = null;\n    marks[node.r,node.c] = 1;\n\n    for(int n = 0; n < 8; n++)\n    {\n        //INFO if the neighbor node is not null and same type with parent node do dfs for neighbor node\n        if(node.neighbors[n] != null && \n           marks[node.neighbors[n].r,node.neighbors[n].c] == 0 &&\n           node.neighbors[n].data == node.data)\n        { \n            list = new List<Node>();\n            i += dfs(node.neighbors[n],list);\n           //INFO if the found nodes count is more than previous nodes count set new nodes to best nodes\n            if(list.Count > longest.Count)\n                longest = list;\n        }\n    }\n\n    marks[node.r,node.c] = 0;\n    longest.Add(node);\n    nodes.AddRange(longest);\n\n    return i;\n}\n}\n```\n\n    ", "Answer": "\r\nAs brz mentioned, this is an NP-complete problem; you won't be able to find a solution that is both efficient and guaranteed optimal. (Or, if you do, every programmer in the world will buy you a beer.)\n\nThat's not to say you can't do anything about it. Concentrate on the general shape of your particular use case, and any peculiarities, and decide how much inaccuracy you're willing to deal with.\n\nThe first thing you can do is look for a bottleneck -- a pair of adjacent traversable cells such that there is no path between them other than the direct one, and the start and goal nodes are on opposite sides of the pair. For the grid case, you can look at the cells which have exactly two neighbors, and then check for bottlenecks against those two neighbors. If you find a bottleneck, congratulations -- you've cut your problem into two subproblems, each of which will be much faster to solve.\n\nYou can also try randomized approaches, such as simulated annealing. Start with the shortest path, then perform some simple localized perturbation on it to make it longer, such as changing a straight line into a C-shape if the two nodes to one side of a part of the path are both unused by the path. Keep doing that until you can't make it any longer, then pick two nodes from your path at random, replace the path between them with the shortest path, re-elongate it, and consider taking that as the new path.\n\nUltimately, you need to remember that this is not a problem you can solve in its most theoretical, general form. You can concentrate on special cases, and you can relax your requirement of exact optimality. Theoretical CS has abandoned you; you need to turn to practical engineering instead.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find number of paths in a graph\r\n                \r\nI tried to get a code that can calculate the number of paths in a directed graph and i ve come to get two codes. First code using a networkx graph as a parameter and the other one with the adjacency list of the graph but both of them give me the same wrong answer so i was wondering if anyone could help me. Thank in advance\n\n```\ndef caminos(G, u, v):\n  H = G.copy()\n  for x in H.node:\n    H.node[x]['caminos'] = 0\n  H.node[u]['caminos'] = 1\n  abiertos = [u]\n  while abiertos:\n    x = abiertos.pop()\n    k = H.node[x]['caminos']\n    for y in H.adj[x]:\n        H.node[y]['caminos'] += k\n       abiertos.append(y)\n       return H.node[v]['caminos']\n\ndef caminos(LA, u, v):\n# LA: adjacency list\n# Vertex numbered\n# from 0 to len(LA) - 1.\nn = len(LA)\ncaminos = n * [0]\ncaminos[u] = 1\nabiertos = [u]\nwhile abiertos:\n    x = abiertos.pop()\n    k = caminos[x]\n    for y in LA[x]:\n        caminos[y] += k\n        abiertos.append(y)\nreturn caminos[v]\n```\n\n\nEDIT: I did a try with both codes and the result is in the picture Picture of results and graph used\n    ", "Answer": "\r\nYour bug is in this line: ```\ncaminos[y] += k```\n, try incrementing by 1 to represent \"one more path leading to ```\ny```\n\".\n\nAlso, consider using a different variable name.  Having a variable ```\ncaminos```\n and a function ```\ncaminos```\n is valid, but potentially confusing.  Example:\n\n```\ndef caminos(LA, u, v):\n    # LA: adjacency list\n    # Vertex numbered\n    # from 0 to len(LA) - 1.\n    n = len(LA)\n    pathcnt = n * [0]\n    pathcnt[u] = 1\n    abiertos = [u]\n    while abiertos:\n        x = abiertos.pop()\n        k = pathcnt[x]\n        for y in LA[x]:\n            pathcnt[y] += 1\n            abiertos.append(y)\n    return pathcnt[v]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All possible paths in a cyclic undirected graph\r\n                \r\nI'm trying to develop an algorithm that identifies all possible paths between two nodes in a graph, as in this example:\n\n.\n\nin fact, i just need to know which nodes appear in all existing paths.\n\nin the web only got references about DFS, A* or dijkstra, but i think they doesn't work in this case.\n\nDoes anyone know how to solve it?\n    ", "Answer": "\r\nYou can find all paths using DFS like |Vlad described. To find which nodes appear in every path, you could just maintain an array of booleans that says whether each node has appeared in every path so far. When your DFS finds a path, go through each vertex not in the path and set the corresponding array value to false. When you are done, only the vertices with values of true will be the ones that appear in every path.\n\nPseudocode:\n\n```\nint source;\nint sink;\nint nVerts;\nbool inAllPaths[nVerts]; // init to all true\nbool visited[nVerts]; // init to all false\nstack<int> path; // init empty\n\nbool dfs(int u)\n  if (visited[u])\n    return;\n  if (u == sink)\n    for i = 0 to nVerts-1\n      if !stack.contains(i)\n        inAllPaths[i] = false;\n    return true;\n  else\n    visited[u] = true;\n    stack.push(u);\n    foreach edge (u, v)\n      dfs(v);\n    stack.pop();\n    visited[u] = false;\n    return false;\n\n\nmain()\n  dfs(source);\n  // inAllPaths contains true at vertices that exist in all paths\n  // from source to sink.\n```\n\n\nHowever, this algorithm isn't very efficient. For example, in a complete graph of n vertices (all vertices have edges to all others) the number of paths will be n! (n factorial).\n\nA better algorithm would be to check for the existence in every path of each vertex separately. For each vertex, try to find a path from the source to the sink without going to that vertex. If you can't find one, that's because the vertex appears in every path.\n\nPseudocode:\n\n```\n// Using the same initialisation as above, but with a slight modification\n// to dfs: change the foreach loop to\nforeach edge (u, v)\n  if (dfs(v))\n    return true; // exit as soon as we find a path\n\nmain()\n  for i = 0 to nVerts-1\n    set all visited to false;\n    if (inAllPaths[i])\n      visited[i] = true;\n      if (dfs(source))\n        inAllPaths[i] = false;\n      visited[i] = false;\n```\n\n\nUnfortunately, this still has exponential worst case when searching for a path. You can fix this by changing the search to a breadth-first search. If I'm not mistaken, this should give you O(VE) performance.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Compute all paths in graph that has multiple inputs and one output\r\n                \r\nI want to compute all the paths in directed acyclic graph from multiple inputs (x1, .., xn) to one output.  The graph has the same depth which d and the inputs come to the graph at the same time (the shape is like Artificial Neural Networks with many inputs and one output). Could you please tell me if there are some algorithms that can compute such paths?\n\nRegards,\n    ", "Answer": "\r\n1) Run a depth first search, starting at the output and traversing each edge in the reverse direction, to find all nodes from which you can get to the output.\n\n2) Delete all nodes from which you cannot get to the output.\n\n3) Run a recursive search on the modified graph, starting at each input node in turn, to find all paths to the output.\n\nBecause you have removed all the dead ends, this should produce all the paths as fast as you can output them, but you should be warned that there may be a very large number of different paths, even from small graphs - a graph the shape of a ladder and length n may have about 2^n paths - at each rung you have a choice as to whether to go up the left or the right hand side of the ladders, so there are 2^(number of rungs) different paths.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "\"Couldn't reach some vertices\" issue looking for shortest path in graphs\r\n                \r\nI am looking for the shortest paths in 2 different graphs. I did it in R using the ```\nigraph```\n library and the ```\nshortest.paths```\n function, then I managed to do the same running R code in SQL Server.\n\nWith the following graph it works fine and returns the shortest path from A to E:\n\n\n\nBut with the following graph something fails, going from A to G, though using the same code:\n\n\n\nIn this case, I get no errors, just a warning message:\n\n\n  \"In .Call(\"R_igraph_get_shortest_paths\", graph, as.igraph.vs(graph,  :\n    At structural_properties.c:4517 :Couldn't reach some vertices\"\n\n\nBoth graphs are solved correctly in R finding the shortest path, but the second one doesn't work well in SQL Server and I don't understand why.\n\nHere I add the weighted graphs:\n\n\n\n\nHere is the code I use. I use ```\nv = v[-1]```\n and ```\n~v = head(v,-1)```\n because I already know first and last node and just want to know to middle ones. \n\n```\nlibrary(igraph);```\n\n```\nrow.names(inp) = names(inp);```\n\n```\nm = as.matrix(inp);```\n \n```\ntrasp = t(m);```\n\n```\ngr = graph.adjacency(trasp, mode = \"directed\", weighted = T);```\n \n```\ns = shortest_paths(gr, from = \"A\", to = \"G\");```\n \n```\nv = as.vector(s$vpath[[1]]);```\n\n```\nv = v[-1];```\n\n```\nv = head(v,-1);```\n\n```\nseq = names(inp)[v];```\n\n```\nout = data.frame(seq)```\n\n\nThanks for your help!\n\nNick\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Common longest and shortest path in graphs\r\n                \r\nI need a hint were to look algo ( maybe even in python )\nSo I have huge amount of graphs some, and I need to find common shortest and longest path for this graphs. or common parts ( shortest or longest )\n\nUpd for more clear describing:\n\nBefore analysis graphs already have connections between nodes ? so they are already like a path.\nAnd as result it's needed to have common possible path for all graphs depending on connections between nodes \n    ", "Answer": "\r\nIf you have graphs with the same set of nodes (V1,...,VN) (if some nodes are unique that it does not matter, you simply ignore them as they cannot be the part of any common path) and want to find a shortest/longest path you can proceed as follows:\n\n\nGenerate the intersection of all the graphs, that is: a graph, that has  nodes (V1,...,VN) and node Vi is connected to Vj iff in all your graphs Vi is connected to Vj. If you have adjacency matrices of each graph, it is just an element-wise multiplication of this matrices\nFind the shortest/longest path in the resulting graph, it has a guarantee to be the shortest (between some two vertices I suppose?) /longest (common) among all of them.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Simple Path and Simple Cycle in Graph DataStructure\r\n                \r\nI am unable to understand that does simple path in graph always contains first and last vertices as same?Can simple path be simple cycle ? Can simple cycle be simple path in graph data structure?Please help me out!.\n    ", "Answer": "\r\nA path is a path(sequences of vertices where each vertex is adjacent to vertex next to it), simple path does not repeat vertices. So, a simple path is not a cycle. simple path does not contain same vertex as ending and starting.\nA simple cycle is a cycle in which only(no other vertices are repeated) the starting and ending vertices are repeated. so a simple cycle is a path but not simple path.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all unique paths in an undirected graph\r\n                \r\nI have a problem where I need to search for all unique paths in an undirected graph of degree <=4. The graph is basically a grid, and all connections are between direct neighbors only (4-way).\n\n\nA path cannot visit the same vertex\nmore than once. \nA path can visit any\nnumber of vertices to make a path.\nA path contains at least 2 vertices.\n\n\nHow do I go about this problem? \n\n\n    ", "Answer": "\r\nHere's the pseudocode I just came up with:\n\n\nStart at any node.\nGet all of its paths\nSee where they lead, if it's a node that has not been visited then visit it.\nCall the same function recursively for the nodes from the previous paths.\nKeep a counter for the number of paths.\n\n\nThis would be this code in Java (untested):\n\n```\npublic int getPaths (Node n, Set<Node> nodesVisited) {\n    int pathCount = 0;\n    for (Path p : n.getPaths()) {\n        Node otherSide = p.getOtherNode(n); // Where this function basically takes a node and gets the other node in the path\n        if (!(nodesVisited.contains(otherSide))) {\n            nodesVisited.add(otherSide);\n            pathCount += 1 + getPaths(otherSide, new Set<Nodes>(nodesVisited));\n        }\n    }\n    return pathCount;\n}\n```\n\n\nThis should find the paths from one starting node. You can start it on each node but you'd get some duplicates. To weed them out you'd also need to return the paths though.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all full paths in directed graph with cycles\r\n                \r\nI need to be able to find all paths in a directed graph, which can include cycles. Due to the nature of the graph, I need find the full path in the case of a cycle even after looping since I need to accumulate values along the path from src to dest. For example in the graph below, if asked for paths from 1 to 5, I'd like it to find 1,2,3,4,5 and 1,2,3,4,6,2,3,4,5.\n```\n1->2->3->4->5\n   ^      |\n   |      |\n    -6  <- \n```\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find n most different paths in a graph?\r\n                \r\nI am using the NetworkX library for Python in my application that does some graph processing. One task is to call the ```\nall_simple_paths()```\n function of NetworkX to give me all non-looping paths in the graph (up to a certain max. length of paths). This is working well.\n\nUsing this list of all simple paths in the graph the task is now to find a number of n paths out of this list, where each of these n paths should be as different from all other n paths as possible. Or in other words: any two paths from the resulting n paths should have as few common nodes as possible. Or in even other words: each path in the resulting n paths should be as unique as possible.\n\nCan you guys think of any (non brute force) algorithm to achieve this?\n    ", "Answer": "\r\nIt depends a lot on your particular needs. There are a few options. Two built-in, and one that requires a bit more work, but might be faster.\n\nIf what you really want is to find two non-intersecting paths, then you can use a filtered graph - after finding one path, induce a subgraph with the intermediate nodes removed, and find the shortest path in that graph.\n\nIf you can't guarantee that the paths won't be non-intersecting, then you are back to brute-force. Since paths don't include cycles, and they are simple lists, finding the number of intersecting nodes is as simple as generating sets from the two paths and finding the length of their difference, which is pretty fast. Check all pairs and find the one with the fewest intersection.\n\nWhich of the above two is faster depends on your particular graph - is it sparse or dense? How many nodes are there? etc. \n\nSince ```\nall_simple_paths```\n is a generator, you can actually focus that algorithm somewhat. i.e. if you graph the first two paths, and they are completely non-intersecting, then you \nalready have your minimal case and don't need to look at any more. There may be a lot of paths, but you can bound with an upper limit of how many to look at, or a threshold that is allowable (i.e. instead of absolutely 0, if these only have 1 in common, it's good enough, return it), or some other combination that uses both how many paths I've looked at and the current maximum to bound the calculation time.\n\nIf calculation time is really critical to your algorithm, also consider switching to igraph... networkx is MUCH easier to deal with, and usually performance is 'good enough', but for large brute force algorithms like this, igraph will probably be at least an order of magnitude faster.\n\nOne last possibility is to avoid using ```\nall_simple_paths```\n at all, and use the bfs tree instead. I am not sure if ```\nall_simple_paths```\n is BFS, it probably is, but that might give you a better selection of initial paths to look at with the second algorithm, not sure. E.G. if you know that your source node has multiple successors, you may get decent results by just forcing your starting two paths to start with two different successors instead of just from the initial node. Note that this can also bite you too - this greedy algorithm can lead you astray as well, unless your graph is already a good fit for it (which you may already know, or may not).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Count the number of Euler PATHs in directed graph?\r\n                \r\n\nI would like to count all Euler PATHs in a directed graph.\nCircuits are not good for me, only Paths.\n\n\nI am doing a problem, that I have derived to a point, where knowing the number of paths fast would help.\nCurrently, I have written (in c++) a recursive function that finds all of them, but it complexity grows quickly, so my algorithm gets slow fast. My algorithm is ~O(2^n). I would like a faster one, if possible.\n\nI have researched the topic, but I can only find proofs (for being NP complete, or polynomial) and algorithms for Euler Circuits in directed and undirected graphs. But again, I am looking for Euler Paths in directed graphs.\n\nMy graphs have only two nodes, but a lot of edges, that should be touched only once, like in an Euler Path.\n\nSo in summary:\n\n\nEuler Path.\nDirected Graph.\nOnly two nodes.\nHigh edge count.\nEdge costs are the same.\n\n\nHere is an image to illustrate a possible set up.\n\n\n    ", "Answer": "\r\nIf you want to generate all possible pathes, I think it's not possible to speed up, because you have to print a lot of pathes. But if you need to only count them, you can do this faster.\n\nYou have edges of 4 types. 1) 0-0; 2) 1-1; 3) 0-1; 4)1-0\n\nFirst of all, let's count how many we have edges of type 3 and 4.\n\nSuppose:\n\nS1 - total count of edges of type 1\n\nS2 - total count of edges of type 2\n\nS3 - total count of edges of type 3\n\nS4 - total count of edges of type 4\n\nIf |S3 - S4| > 1 the path does not exist.\n\nFor your graph, S3 = 1, S4 = 2. Suppose, we have a path. Let's fix edges of type 3 and 4.\n\nThen the path will look like:\n\n```\n(1-1)*, 1-0, (0-0)*, 0-1, (1-1)*, 1-0, (0-0)*\n```\n\n\n```\n(1-1)*```\n - means 0 or more times repeat edge 1-1.\n\nNow the algorithm looks obvious:\n\n\ngenerate permutation of (1-0) edges\ngenerate permutation of (0-1) edges\ngenerate permutation of (0-0) edges\ngenerate permutation of (1-1) edges\nFind all compositions of S3, and S4 in not more then S1 and S2 parts.\nWrite the answer.\n\n\nSteps 1-4 will take O(S1! * S2! * S3! * S4!) time (S1 + S2 + S3 + S4 = n).\n\nSo the algorithm will be slow.\n\nWe can find total count, using the rule of product.\n\nSteps 1-4 give us S1! * S2! * S3! * S4! combinations.\n\nIt's possible to count step 5 combinations in O(N) time. Just calculate the prefix sum in this article: https://en.wikipedia.org/wiki/Composition_(combinatorics)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "find all paths in graph without start or end node\r\n                \r\nI'm playing a game in which to proceed to the next level, we must defeat each level before it. Each level corresponds to a certain letter. \n\nI've represented this as a graph traversal problem, but I'm trying to find all paths in a graph without a start or end node.\n\nMy graph is represented as a dictionary, with the key being strings and the values being a list of strings.\n\n```\n{\n'A2': ['A1', 'B'], \n'A1': [], \n'B': [], \n'C': ['A2'],\n }\n```\n\n\nTo go to level A2, we must complete A1 and B.\n\nFor example, an example path would be A1, B, A2, C. \nAnother path could be B, A1, A2, C. \n\nImplementations of depth first search or breadth first search require a start node. I'm thinking a good start node would be any key whose values are empty: in this case, A1 and B, but I'm uncertain how to implement dfs or bfs with two start nodes. \n\nI've been working with tweaking this implementation of finding paths, but this only works with a start level and an end level.\n\n```\ndef find_path(graph, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        if start not in graph:\n            return None\n        for node in graph[start]:\n            if node not in path:\n                newpath = find_path(graph, node, end, path)\n                if newpath: return newpath\n        return None\n\nprint(find_path(course_dict, 'A1', 'PC'))\n```\n\n\nbut I'm getting None for my answer.\n    ", "Answer": "\r\nOkay, two problems.\nFirst you are trying to built a recursive algorithm but you still use a for loop. That is confusing, you can do this without the for loop. It is not wrong to use a loop in a recursive algorithm but if you change your data structure you do not need to.\n\nSecond thing is that your dictionary is wrong. I assume that every key of the dictionary is the staring node and every value is a possible end node. This is how your algorithm currently works. In that case the end node for your start ```\nA1```\n is not given. Therefore you get the None output.\n\nThe biggest problem is that you use the wrong algorithm. This algorithm finds a way from your start to your end node. But you want to ensure that every node between your start and end node is at least once visited. So you can either change the algorithm (which would be easy) or the data structure (which will lead to a lot of variations). \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Get list of parallel paths in a directed graph\r\n                \r\nI'm in need of an algorithm to find sets of all parallel paths in a directed graph. Here is a visual representation of an example I use for testing.\n\n\n\nHere is my example code in Python using networkx:\n\n```\nimport networkx as nx\n\nG = nx.MultiDiGraph()\n# relevant part of graph to my question\nG.add_edges_from([(1,2),(2,3),(3,4),(2,5),(5,6),(6,4),(4,7)])\n# subordinate part of graph to my question\nG.add_edges_from([(7,8),(8,9),(7,10),(10,11),(11,13),(11,12),(12,14)])\n\npp = get_parallel_paths(G)  # -> the function I'm looking for\n\n# pp should contain:\n# pp = [[[(2,3),(3,4)],[(2,5),(5,6),(6,4)]],[...]]\n# the procedure should list all sets of parallel paths\n# hence the [...] indicates a possible other set of parallel paths (not in example)\n```\n\n\nIt is the function \"get_parallel_paths\" I am looking for. It does not have to be in Python: a pointer to any algorithm that could help me with the implementation is very welcome.\n    ", "Answer": "\r\nThere's a built-in function to list all simple paths between two vertices. This uses it to list all sets of paths between any two vertices:\n\n```\ndef get_parallel_paths(G):\n    return [list(nx.all_simple_paths(G, i, j)) for i in G.nodes_iter() for j in G.nodes_iter() if i != j and nx.has_path(G, i, j)]\n```\n\n\nTo filter out any paths with internal vertices of degree greater than two, we can do something like this:\n\n```\ndef get_parallel_paths(G):\n    colpaths = []\n    for i in G.nodes_iter():\n        for j in G.nodes_iter():\n            if i == j:\n                continue\n            nbp = nobranchpaths(G, i, j)\n            if len(nbp) > 1:\n                colpaths += [nbp]\n    return colpaths\n\ndef nobranchpaths(G, u, v):\n    paths = []\n    for p in nx.all_simple_paths(G, u, v):\n        if len(p) == 2 or max(G.degree(i) for i in p[1:-1]) == 2:\n            paths += [p]\n    return paths\n```\n\n\nThis only includes pairs of vertices where more than one path exists; to include pairs with a unique path, change ```\nif len(nbp) > 1:```\n to just ```\nif len(nbp):```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All shortest paths in a DAG (directed acyclic graph)\r\n                \r\nI have a weighted DAG, with some negative edge weights, and want to find all shortest paths in it. Is there any algorithm with complexity better than O(n^2). (My graph is complete i.e. there is an edge (i,j),  for any i,j in {1..n} and i < j ).\n\nThanks\n    ", "Answer": "\r\nWell, a popular algorithm for Path finding is A*. But you can check this article for more information:\n\nGo to Article\n\nCheers\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "find all paths in a graph though a node/vertex\r\n                \r\nIve got a directed igraph:\n```\nlibrary( igraph )\nlinks <- data.frame( from = c(1,1, 2,2,3, 3,3,4,6,7,7, 8),\n                     to =   c(2,10,3,4,12,4,8,5,7,3,11,9) )\nnodes <- data.frame( name = 1:12 )\nnet <- graph_from_data_frame( d = links, vertices = nodes, directed = TRUE ) \nplot(net)\n```\n\n\nWhat i want is:\n\nget a subset of the graph, of all nodes that are within one step of node 3 (in and out)\nget a list of all paths in the subset, that go through node 3\n\nFor step 1, I can do:\n```\nego.list <- make_ego_graph( net, order = 1, nodes = 3, mode = \"all\")\ndesired_subset <- NULL\nfor (i in seq_along(ego.list) ){\n  x <- ego.list[[i]]\n  desired_subset <- graph.union( desired_subset, x )\n}\nplot(desired_subset)\n```\n\n\nBut now I'm stuck.. What i want, is to find all paths in the entire (directed) subset, that go through node 3,\nso:\n\n2->3->12\n2->3->4\n2->3->8\n7->3->12\n7->3->4\n7->3->8\n\nAll I've found so far is to get a list of paths from one node to another node. But I want to get a list of all paths through a certain node.\nAny ideas?\n    ", "Answer": "\r\nfound a solution!\nusing All paths in directed tree graph from root to leaves in igraph R I came to the following code:\n```\n#for shorter code\ng <- desired_subset\n# find entrynodes (nothing goes in) and exit_nodes (nothing goes out)\nexit_nodes  <- which( degree(g, v = V(g), mode = \"out\" ) == 0 )\nentry_nodes <- which( degree(g, v = V(g), mode = \"in\" ) == 0)\n# find all paths from entry to exit nodes\npaths= lapply( entry_nodes, function(x) all_simple_paths(g, from = x, to = exit_nodes))\nnamed_paths= lapply(unlist(paths, recursive=FALSE), function(x) V(g)[x])\n#filter out all paths that do not contain node 3\nanswer <- named_paths[ unlist( lapply( named_paths, function(x) 3 %in% names(x) ) ) ]\n#put in a data.table\nas.data.table(data.table::transpose( lapply(answer, names) ) )\n\n#    V1 V2 V3\n# 1:  2  3  4\n# 2:  2  3  8\n# 3:  2  3 12\n# 4:  7  3  4\n# 5:  7  3  8\n# 6:  7  3 12\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all paths in nested graphs\r\n                \r\nI've been struggling with finding a solution to what seems to be a relatively simple problem. \n\nGiven a graph g:\n\n```\ng = {'A': ['B', 'C'],\n     'B': ['A', 'C'],\n     'C': ['D'],\n     'D': [],\n     }\n```\n\n\nOne can find all paths using this solution (which I found here):\n\n```\ndef paths(graph, v):\n    path = [v]                  # path traversed so far\n    seen = {v}                  # set of vertices in path\n    def search():\n        dead_end = True\n        for neighbour in graph[path[-1]]:\n            if neighbour not in seen:\n                dead_end = False\n                seen.add(neighbour)\n                path.append(neighbour)\n                yield from search()\n                path.pop()\n                seen.remove(neighbour)\n        if dead_end:\n            yield list(path)\n    yield from search()\n\npaths(g,'A')\n\n>>  [['A', 'B', 'C', 'D'], ['A', 'C', 'D']]\n```\n\n\nTo make matters more complex, I would like to find all paths in g but when the lists become nested. For example, take g to be\n\n```\ng2 = {'A': [['B', 'C'],['D']],\n     'B': [['A'], ['C']],\n     'C': [['D']],\n     'D': [[]]}\n```\n\n\nThe solution I am looking for would be \n\n```\n[ [['A', 'B', 'C', 'D'], ['A', 'C', 'D']], ['A', 'D'] ] \n```\n\n\nwhere the first two paths are grouped together (i. e., in total I want to get two paths). However the above function is not sufficient. I have tried adapting this code to my problem but I have not been successful.\n\nThe actual graphs I am working with are quite a bit larger and many of the elements in the dictionary are these nested lists, so the number of paths may grow rather large rather quickly.\n\nI hope this example makes sense. Any help would be greatly appreciated. \n    ", "Answer": "\r\n```\n>>> {key:[ele for lst in value for ele in lst] for key, value in g2.iteritems()}\n{'A': ['B', 'C', 'D'], 'C': ['D'], 'B': ['A', 'C'], 'D': []}\n```\n\n\nIt appears to me that flattening the lists would solve your problem.\n\nOr, without a dict & list comprehension:\n\n```\nresult = {}\nfor key, value in g2.iteritems():\n    result[key] = []\n    for lst in value:\n        for ele in lst:\n            result[key].append(ele)\n```\n\n\nIf you want to sort the result via the original graph ```\ng2```\n:\n\n```\n# Sort by 2nd value in list\nres = []\nfor lst in g2['A']:\n    res.append([])\n    for reslst in res:\n        if reslst[1] in lst:\n            res[-1].append(reslst)\n    if len(res[-1]) == 0:\n        res.pop()\n\n[[['A', 'B', 'C', 'D'], ['A', 'C', 'D']], [['A', 'D']]]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "PROLOG: longest path in graph\r\n                \r\nI have this algorithm for shortest path in a graph but now I need to adapt it to get the longest path, i mean, the path with higher value of the edges\n```\npath(X,Y,[X,Y],L):- \n    edge(X,Y,L).\n\npath(X,Y,[X|W],L):- \n    edge(X,Z,L1), \n    path(Z,Y,W,L2), \n    L is L1 + L2.\n\n\nshortestPath(X,X,[X,X],0):- !.\nshortestPath(X,Y,MinP,MinD):-\n    findall([L,P],path(X,Y,P,L),Set),\n    sort(Set,Sorted),\n    Sorted = [[MinD,MinP]|_].\n```\n\nany help?\nthank you\n    ", "Answer": "\r\nIf ```\nsort/2```\n puts them in shortest-first order, then the longest should be the last entry in ```\nSorted```\n.\nSee ```\nlast/2```\n, ```\nappend/3```\n, and (more expensively) ```\nreverse/2```\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all paths in graph Python\r\n                \r\nI have adjacency matrix of some graph. I know nothing about how this graph looks like, it depends from starts conditions. It could be directed or undirected, cyclic, etc.\nSo, I need to find all paths between all vertices.\nGraph example\nFor example, in this particullar graph we have\n```\n2 0 3\n2 1 3\n2 0 1 3\n0 2 1 3\n0 1 3\n1 3\n```\n\nI know about DFS or BFS, but don't know how to implement them in this task.\n    ", "Answer": "\r\nLet's say you've defined the adjacency matrix for this graph as\n```\nadj_matrix = [[0, 1, 1, 1],\n              [0, 0, 0, 1],\n              [1, 1, 0, 0],\n              [0, 0, 0, 0]]\n```\n\nin that case, a recursive depth-first search for every path would work like this:\n```\ndef iter_paths(adj, min_length=2, path=None):\n    # different paths for starting and recurring\n    # you could use two different methods, the first calling the second and \n    #   the second calling itself, if you wanted\n    if not path:\n        for start_node in range(len(adj)):\n            yield from iter_paths(adj, min_length, [start_node])\n    else:\n        # yield a path as soon as we first encounter it\n        if len(path) >= min_length:\n            yield path\n        # if we encounter a cycle (current location has been visited before)\n        # then don't continue to recur\n        if path[-1] in path[:-1]:  \n            return\n        # search for all paths forward from the current node, recursively\n        current_node = path[-1]\n        for next_node in range(len(adj[current_node])):\n            if adj[current_node][next_node] == 1:\n                yield from iter_paths(adj, min_length, path + [next_node])\n\nprint(list(iter_paths(adj_matrix)))\n```\n\nThis produces the following list of paths:\n```\n[[0, 1],\n [0, 1, 3],\n [0, 2],\n [0, 2, 0],\n [0, 2, 1],\n [0, 2, 1, 3],\n [0, 3],\n [1, 3],\n [2, 0],\n [2, 0, 1],\n [2, 0, 1, 3],\n [2, 0, 2],\n [2, 0, 3],\n [2, 1],\n [2, 1, 3]]\n```\n\n\nA breadth-first algorithm would be very similar to a depth-first algorithm - except that, instead of using recursion, it would essentially keep a running list of ```\npath```\ns that have been visited, and when a depth-first algorithm would call itself the breadth-first algorithm would simply add the new path to the list. It would iterate in a ```\nwhile```\n loop until it reached the end of that list, then return the full list.\nThis only changes the order in which we examine nodes, in this case - you'll note that the depth-first search arranges them \"alphabetically\", whereas a breadth-first search would arrange them in ascending order of length.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Counting transversal paths in a graph\r\n                \r\nGiven a tree with n vertices, each vertex has a special value C_v. A straight path of length k >= 1 is defined as a sequence of vertices v_1, v_2, ... , v_k such that each two consecutive elements of the sequence are connected by an edge and all vertices v_i are different. The straight path may not contain any edges. In other words, for k = 1, a sequence containing a single vertex is also a straight path. There is a function S defined. For a given straight path v_1, v_2, ... , v_k we get S(v_1, v_2, ... ,v_k) = Cv_1 - Cv_2 + Cv_3 - Cv_4 + ...\nCalculate the sum of the values of the function S for all straight paths in the tree. Since the result may be very large, give its remainder when divided by 10^9 + 7.\nPaths are treated as directed. For example: paths 1 -> 2 -> 4 and 4 -> 2 -> 1 are treated as two different paths and for each one separately the value of the function S should be taken into account in the result.\nMy implementation is as follows:\n```\ndef S(path):\n    total, negative_one_pow = 0, 1\n    for node in path:\n        total += (values[node - 1] * negative_one_pow)\n        negative_one_pow *= -1\n    return total\n\n\ndef search(graph):\n    global total\n    for node in range(1, n + 1):\n        queue = [(node, [node])]\n        visited = set()\n        while queue:\n            current_node, path = queue.pop(0)\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n            total += S(path)\n            for neighbor in graph[current_node]:\n                queue.append((neighbor, [*path, neighbor]))\n\n\nn = int(input())\nvalues = list(map(int, input().split()))\ngraph = {i: [] for i in range(1, n + 1)}\ntotal = 0\n\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nsearch(graph)\nprint(total % 1000000007)\n```\n\nThe execution of the code takes too long for bigger graphs. Can you suggest ways to speed up the code?\n    ", "Answer": "\r\nIt is a tree. Therefore all straight paths start somewhere, travel up some distance (maybe 0), hit a peak, then turn around and go down some distance (maybe 0).\nFirst calculate for each node the sum and count of all odd length paths rising to its children, and the sum and count of all even length paths rising to its children. This can be done through dynamic programming.\nArmed with that we can calculate for each node the sum of all paths with that node as a peak. (Calculate the sum of all paths that rise to the peak then fall. For each child subtract out the sum of all paths that rose to that child and then fell back to that child.)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all paths in graph, Python\r\n                \r\nI have a graph, represented in a way of a dictionary with pairs ```\nkey|value - A node|Edges to other nodes```\n. Example:\n\n```\n{'5': '1 2 3 W', '0': '1 2 3 W', '2': '0 4 5 L', '1': '0 4 5 L', '4': '1 2 3 W', '3': '0 4 5 L'}\n```\n\n\n(```\nW```\n and ```\nL```\n are the marks of the nodes)\nWhat is the best approach to find all the paths ```\nW-L-W-L```\n or ```\nL-W-L-W```\n? (Python 3.+)\n    ", "Answer": "\r\nA \"breadth first search\" algorithm may be what you are looking for. You can find a good explanation and a Python implementation here.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Number of Hamilton paths in an extremely dense undirected simple graph\r\n                \r\nWhat is the fastest way (algorithm) to calculate the number of Hamilton paths in an extremely dense undirected simple graph (approximately 99.99% edges are connected)?\n\nI was thinking of the following way :\n\nFirst, calculate the number of Hamilton paths in the complete graph.\n\nRemove one edge at a time, but I am not able to figure out how many paths would be reduced on removing an edge. Also how to prevent double counting while removing the edges ?\n\nI came across a similar question on Math.SE but that was about Hamilton cycles and not paths, I hope that changes the question significantly. Also the answers were not quite clear, hence this post.\n    ", "Answer": "\r\nI don't think you can calculate the number of Hamilton paths without\nactually generating the paths or considering each path individually\nwhen counting. For special graphs -- like the complete graph -- this\nis certainly possible but not in general.\n\nYou could generate all Hamilton paths in the complete graph and check\nfor each one if it uses a subset of the edges in your graph. Of course\nyou can speed things up by already pruning certain branches while\ngenerating the Hamilton paths in the complete graph.\n\nSince your graph is very large, this approach is certainly not\nfeasible. However, you can calculate the number of all paths in the\ncomplete graph that contain one of the missing edges and then subtract\nthis number.\n\nI don't think this is trivial. Some thoughts on it: Let's consider the\nsimplest case that only one edge is missing. We can describe a path\nwith a sequence of edges or nodes. Let's say your graph has n\nnodes. There are ```\nn-1```\n possible positions of the missing edge in a\nhamilton path through the complete graph. The edge may be traversed in\ntwo directions and the nodes not adjacent to the edge can be traversed\nin ```\n(n-2)!```\n different orders. Hence we can subtract\n\n```\n2 * (n-1) * (n-2)! = 2 * (n-1)!\n```\n\n\nfrom the total number of hamilton paths through the complete graph to\nobtain the desired result.\n\nIf exactly two edges are missing we cannot just subtract twice the\nnumber because we are counting several paths twice, namely the paths\ncontaining both edges. So we have to calculate this number and add it\nagain. But now it becomes complicated: It is important how the edges\nare related. If they are adjacent, the number is smaller than it would\nbe otherwise. So in general you cannot just calculate the number of\nhamilton paths containing ```\nk```\n of of the missing edges but it is\nimportant which edges you are considering and whether they are\nadjacent or not.\n\nBut let's say you can calculate the number of paths through a certain\nselection of edges (all permutations, directions of traversal and\npositions in the paths). Let's further assume that ```\nk```\n edges are\nmissing. You can calculate the number of paths including at least one\nof the edges like this:\n\nCalculate the number of paths through any of the ```\nk```\n edges individually\nand sum them up.\n\nFor each pair of edges you have counted the paths traversing the pair\ntwice, so subtract these paths again (consider each pair\nindividually).\n\nNow consider the paths containing three of the edges. They have been\ncounted six times and subtracted three times (3 different pairs), so\nyou have to subtract them twice.\n\nThe paths containing four edges have to be subtracted 3 times (because\nthey are represented 4 times in the paths containing 3 edges). And so\non.\n\nBut again: You have to consider each combination of edges\nindividually. It is even possible that a certain set of edges is\nincompatible because a certain node occurs three times. Also take into\naccount the directions in which the edges are traversed.\n\nSo there is no simple formula but if the number of missing edges is\nreally small, you can count the paths.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Doxygen exclude path in caller graph?\r\n                \r\nGiven the example, is there a way to tell doxygen to exclude graph paths crossing the function B1()? \n\n```\nstatic void A1(unsigned char select);\nstatic void B1(int select);\nstatic void C1();\nstatic void D1();\nstatic void E1();\n\nstatic void\nA1(unsigned char select)\n{\n    switch()\n    {\n    case 'C': C1();\n    case 'D': D1();\n    case 'E': E1();\n    }\n}\n\nB1(int select)\n{\n    A1((unsigned char)select);\n}\n\nstatic void\nC1(void)\n{\n\n}\n\nstatic void\nD1(void)\n{\n    int callE = 69;\n    B1(callE);\n}\n\nstatic void\nE1(void)\n{\n\n}\n\nstatic void\nF1(void)\n{\n    A1('C');\n}\n```\n\n\n\n\nAny similar issue I have seen online suggest either it can’t be done or try excluding the function from the document. I tried excluding D1() from the documentation and  Doxygen didn’t document the function but still included it in graphs and reference lists (\\cond and \\endcond used).\n\nEdit: 'desired graph'\n\n\n\nAny hints would be appreciated.  \n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all paths in a graph with DFS\r\n                \r\nGood morning!\n\nI'm developing an algorithm to find all the paths in an undirected, not weighted graph. I'm currently using a DFS algortihm with backtracking to try and do that. Here is my current code:\n\n```\nimport java.util.*;\n\npublic class dfs {\n\n    private static Map<Integer, LinkedHashSet<Integer>> map = new HashMap<Integer, LinkedHashSet<Integer>>();\n    private int startNode;\n    private int numLinks;\n\n    public dfs(int startNode, int numLinks) {\n        super();\n        this.startNode = startNode;\n        this.numLinks = numLinks;\n    }\n\n    public void addEdge(int source, int destiny) {\n        LinkedHashSet<Integer> adjacente = map.get(source);\n        if(adjacente==null) {\n            adjacente = new LinkedHashSet<Integer>();\n            map.put(source, adjacente);\n        }\n        adjacente.add(destiny);\n    }\n\n    public void addLink(int source, int destiny) {\n        addEdge(source, destiny);\n        addEdge(destiny, source);\n    }\n\n    public LinkedList<Integer> adjacentNodes(int last) {\n        LinkedHashSet<Integer> adjacente = map.get(last);\n        System.out.println(\"adjacentes:\" + adjacente);\n        if(adjacente==null) {\n            return new LinkedList<Integer>();\n        }\n        return new LinkedList<Integer>(adjacente);\n    }\n\n\npublic static void main(String[] args) {\n\n    Scanner input = new Scanner(System.in);\n\n    int numVertices = input.nextInt();\n    int numLinks = input.nextInt();\n    int startNode = input.nextInt();\n    int endNode = startNode;\n\n    dfs mapa = new dfs(startNode, numLinks);\n\n    for(int i = 0; i<numLinks; i++){\n        mapa.addLink(input.nextInt(), input.nextInt());\n    }\n\n    List<ArrayList<Integer>> paths = new ArrayList<ArrayList<Integer>>();\n    List<Integer> visited = new ArrayList<Integer>();\n    visited.add(startNode);\n    Integer currentNode = 0;\n\n    Iterator it = map.entrySet().iterator();\n    while (it.hasNext()) {\n        Map.Entry pairs = (Map.Entry)it.next();\n        currentNode = (Integer) pairs.getKey(); \n        //System.out.println(\"Current Node:\" + currentNode);\n        mapa.findAllPaths(mapa, visited, paths, currentNode);\n\n    }\n}\n\nprivate void findAllPaths(dfs mapa, List<Integer> visited,\n        List<ArrayList<Integer>> paths, Integer currentNode) {\n\n    if (currentNode.equals(startNode)) { \n        paths.add(new ArrayList<Integer>(visited));\n\n        LinkedList<Integer> nodes = mapa.adjacentNodes(currentNode); \n        //System.out.println(\"visited:\" + visited);\n\n        for (Integer node : nodes) {\n            //System.out.println(\"nodes:\" + nodes);\n            List<Integer> temp = new ArrayList<Integer>();\n            temp.addAll(visited);\n            temp.add(node);          \n            findAllPaths(mapa, temp, paths, node);\n        }\n\n    }\n\n    else {\n        LinkedList<Integer> nodes = mapa.adjacentNodes(currentNode);  \n        System.out.println(\"currentNode:\" + currentNode);\n        //System.out.println(\"nodes:\" + nodes);\n        for (Integer node : nodes) {            \n            if (visited.contains(node)) {\n                continue;\n            } \n            List<Integer> temp = new ArrayList<Integer>();\n            temp.addAll(visited);\n            System.out.println(\"visited:\" + visited);\n            temp.add(node);          \n            findAllPaths(mapa, temp, paths, node);\n        }\n    }\n\n} \n\n}\n```\n\n\nThe program receives integers on his input. The first one is the number of nodes, the second one is the number of links and the third is the start node and end note, which are the same. All the integers that come after represent the connections between nodes.\n\nThe problem is, this algorithm is finding all the paths that visit a single node only once. What i want is the algorithm to find all the paths that visit each connection only once.\nAny idea on how i can do that?\n    ", "Answer": "\r\nYou are on the right track - backtracking is a neat way to solve it.\n\nTo get all paths that \"uses the same edge only once\":\nafter you use an edge in ```\nfindAllPaths()```\n - delete it from the set of edges [delete the connection from the ```\nLinkedHashSet```\n of each vertex of this edge] - and invoke recursively.\n\nAfter you return from the recursion - don't forget to \"clean up the environment\" and add this edge back to both vertices.\n\nYou will need to make sure you don't run into troubles of iterating collection while modifying it. [You cannot do it - the result of doing so is unexpected] - so you will probably need to send a copy of the ```\nLinkedHashSet```\ns  [without the relevant edge] - and not the original one.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths in a directed cyclic graph\r\n                \r\nI want to find all possible paths in a directed cyclic graph. I have written a program which does so, but I notice that if the number of nodes grow above 40 or 50, it starts taking infinite time. \n\nTheoretically speaking how many paths are possible for a directed cyclic graph of N nodes. Is it like factorial(N) or something? Can you give me a guess for the following example with 119 nodes. Of course, I am going over loops only once, so you can ignore the cyclic paths.\n\nGraph Image\n    ", "Answer": "\r\nLet's just take this common pattern that shows in your graph:\n\n```\nA ---> B\n|     /|\n|    / v\n|   /  C\n|  /   |\n| /    |\nvv    /\nD <---\n```\n\n\nExcuse the ASCII art. So you have three paths here: ```\nA -> D```\n, ```\nA -> B -> D```\n, and ```\nA -> B -> C -> D```\n.\n\nNow say you have the exact same figure emanating from ```\nD```\n to another node ```\nG```\n:\n\n```\nD ---> E\n|     /|\n|    / v\n|   /  F\n|  /   |\n| /    |\nvv    /\nG <---\n```\n\n\nYou have the same analogous three paths as before: ```\nD -> G```\n, ```\nD -> E -> G```\n, and ```\nD -> E -> F -> G```\n.\n\nNow, how many paths are there from ```\nA```\n to ```\nG```\n?\n\nTo get from ```\nA```\n to ```\nG```\n, you have to get from ```\nA```\n to ```\nD```\n. You can do this in one of three ways. Then you have to get from ```\nD```\n to ```\nG```\n. You can do this in one of three ways. These two choices (```\nA```\n to ```\nD```\n and ```\nD```\n to ```\nG```\n) are independent of each other. Thus you have ```\n3```\n * ```\n3```\n = ```\n9```\n possible paths from ```\nA```\n to ```\nG```\n.\n\nIf you keep repeating the figure, you multiply the number of possible paths by ```\n3```\n with each repetition. So with three figures, 27 paths; with four figures, 81 paths; etc.\n\nThat's exponential growth. Put differently: you'll have to find another way to do what it is you're doing, if you want to be efficient about it.\n\nEDIT: To get a rough estimate: only counting those figures, not even looking at the complex jumbles in the middle, I get ```\n3 * 3 * 3 * 3 * (2^8) * (4^8) * 3 * 3 * 2 * 3```\n = ```\n73383542784```\n possible paths, through just those simple nodes.\n\nEDIT: You seem to be doing code analysis. Without knowing exactly what you want to do, what I recommend is consolidating whatever information you're gathering along those nodes that must be reached (e.g. nodes ```\nA```\n, ```\nD```\n, and ```\nG```\n in my example figures). Then do a search until you get to the next node that must be reached, and gather your info there as well. This will prevent exponential blow-up. \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest paths in graph with labeled edges\r\n                \r\nProblem\n\nSuppose I have a graph with labeled nodes and edges (see figure). My goal is to get the set of all shortest paths between A and D. \n\n\n\nWhat I have so far\n\n```\nimport networkx as nx\n\nG = nx.Graph()\nG.add_edge('A', 'B')\nG.add_edge('B', 'D')\nG.add_edge('B', 'C')\n\nshortest_path = nx.shortest_path(G, 'A', 'D')\n```\n\n\nIn ```\nshortest_path```\n I get ```\n['A', 'B', 'D']```\n. Of course, this is the shortest path represented through the nodes, but what I need is to: \n\n1) add edge labels in my graph\n\n2) find the set of all possible shortest paths. Ideally, in ```\nshortest_paths```\n I would want to have an output as follows:\n ```\n[ A -> a -> B, B -> b -> D], [A -> a -> B, B -> c -> D]```\n\n\nQuestions\n\n1) Is this possible to be done with networkx? \n\n2) If not, what other graph libraries contain functions which solve problems with such scenario (doesn't have to be Python)?\n    ", "Answer": "\r\nYou can convert your edges to nodes and use the function ```\nall_shortest_paths()```\n:\n\n```\nimport networkx as nx\n\nG = nx.MultiGraph()\nG.add_edge('A', 'B', label='a')\nG.add_edge('B', 'D', label='b')\nG.add_edge('B', 'D', label='c')\nG.add_edge('B', 'C', label='d')\nG.add_edge('C', 'D', label='e')\n\n# Convert edges to nodes\ng = nx.Graph()\nfor i, j, label in G.edges(data='label'):\n    g.add_edge(i, label)\n    g.add_edge(j, label)\n\nprint(list(nx.all_shortest_paths(g, 'A', 'D')))\n# [['A', 'a', 'B', 'b', 'D'], ['A', 'a', 'B', 'c', 'D']]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Euler's path in Partially Directed Graph\r\n                \r\nEulerian Path is a path in graph that visits every edge exactly once.\n\nThere are many algorithms to find Eulerian path in both directed and undirected graphs. I am enthusiastic to know how to find Eulerian path in a partially directed graph.    \n\nA partially directed graph is a graph with some(not all) of its edges directed.\n\nThanks, in advance!\n    ", "Answer": "\r\nI suggest you to refer some research papers.\nHope this one helps :)\n\nCovering partially directed graphs with directed paths\n\nNote: I would have commented this but i do not have enough reputation yet. \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Paths in complete graph\r\n                \r\nI have a friend that needs to compute the following:\n\nIn the complete graph Kn (k<=13), there are k*(k-1)/2 edges.\nEach edge can be directed in 2 ways, hence 2^[(k*(k-1))/2] different cases.\n\nShe needs to compute ```\nP[A !-> B && C !-> D] - P[A !-> B]*P[C !-> D]```\n\n\nX !-> Y means \"there is no path from X to Y\", and P[ ] is the probability.\n\nSo the bruteforce algorithm is to examine every one of the 2^[(k*(k-1))/2] different graphes, and since they are complete, in each graph one only needs to consider one set of A,B,C,D because of symmetry.\n\nP[A !-> B] is then computed as \"number of graphs with no path between node 1 and 2\" divided by total number of graphs, i.e 2^[(k*(k-1))/2].\n\nThe bruteforce method works in mathematica up to K8, but she needs K9,K10... up to K13.\n\nWe obviously don't need to find the shortest path in the cases, just want to find if there is one.\n\nAnyone have optimization suggestions? (This sound like a typical Project Euler problem).\n\nExample:\n\nThe minimal graph K4 have 4 vertices, giving 6 edges. Hence there are 2^6 = 64 possible ways to assign directions to the edges, if we label the 4 vertices A,B,C and D.\n\nIn some graphs, there is NOT a path from A to B, (lets say X of them) and in some others, there are no path from C to D (lets say Y). But in some graphs, there is no path from A to B, and at the same time no path from C to D. These are W.\n\nSo ```\nP[A !-> B]=X/64```\n, ```\nP[C !-> D]=Y/64```\n and ```\nP[A !-> B && C !-> D] = W/64```\n.\n\nUpdate:\n\n\nA, B,C and D are 4 different vertives, hence we need at least K4.\nObserve that we are dealing with DIRECTED graphs, so normal representation with UT-matrices won't suffice.\nThere is a function in mathematica that finds the distance between nodes in a directed graph, (if it returns infinity, there is no path), but this is a little bit overkill since we dont need the distance, just if there is a path or not.\n\n    ", "Answer": "\r\nI have a theory, but I don't have mathematica to test it with, so here goes. (And please excuse my mistakes in terminology, I'm not really familiar with graph theory.)\n\nI agree that there are 2^(n*(n-1)/2) different directed Kn graphs. The question is how many of those contain a path A->B. Call that number S(n).\n\nSuppose we know S(n) for some n, and we want to add another node, X, and calculate S(n+1). We will look for paths X->A.\n\nThere are 2^n ways to connect X to the preexisting graph.\n\nThe edge X-A might point in the \"right\" direction (X->A); there are 2^(n-1) ways to connect X this way, and it will lead to a path for any of the 2^(n*(n-1)/2) different Kn graphs.\n\nIf X-A points to X, try the edge X-B. If X-B points to B (and there are 2^(n-2) such ways to connect X) then some Kn graphs will give a path B->A, S(n) of them in fact.\n\nIf X-B points to X, try X-C; there are 2^(n-3)S(n) successful graphs there.\n\nIf my math is correct, S(n+1) = 2^((n+2)(n-1)/2) + (2^(n-1)-1)S(n)\n\nSo this gives the following:\n\n\nS(2) = 1\nS(3) = 5\nS(4) = 47\nS(5) = 841\nS(6) = 28999\n\n\nCan someone check this? Or give a closed form for S(n)?\n\nEDIT:\nI see now that the hard part is this P[A !-> B && C !-> D]. But I think the recursion approach will still work: start with {A,B,C,D}, then keep adding points, keeping track of the number of graphs in which A->(a points), (b points)->B, C->(c points) and (d points)->D, keeping the desired constraint. Ugly, but tractable.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Undirected graph for k shortest paths in Dijkstra using Java\r\n                \r\nI'm trying to implement Dijkstra algorithm to calculate k-shortest paths in java so far here is the code i'm using: \n\n```\nimport java.util.List;\n\n\npublic interface AbstractKShortestPathFinder<V> {\n\n    List<Path<V>> findShortestPaths(V source, V target, Graph<V> graph, int `k);`\n\n    default void checkK(int k) {\n        if (k < 1) {\n            throw new IllegalArgumentException(\n                    String.format(\"The value of k is too small: %d, should `be at least 1.\", k));`\n        }\n    }\n}\n```\n\n\n-\n\n```\nimport java.util.*;\n\nimport static java.util.Objects.requireNonNull;\n\npublic class DefaultKShortestPathFinder<V> implements AbstractKShortestPathFinder<V> {\n\n    @Override\n    public List<Path<V>> findShortestPaths(V source, V target, Graph<V> graph, int k) {\n        requireNonNull(source, \"The source node is null.\");\n        requireNonNull(target, \"The target node is null.\");\n        requireNonNull(graph, \"The graph is null.\");\n        checkK(k);\n\n        List<Path<V>> paths = new ArrayList<>(k);\n        Map<V, Integer> countMap = new HashMap<>();\n        Queue<Path<V>> HEAP = new PriorityQueue<>(\n                Comparator.comparingDouble(Path::pathCost));\n\n        HEAP.add(new Path<>(source));\n\n        while (!HEAP.isEmpty() && countMap.getOrDefault(target, 0) < k) {\n            Path<V> currentPath = HEAP.remove();\n            V endNode = currentPath.getEndNode();\n\n            countMap.put(endNode, countMap.getOrDefault(endNode, 0) + 1);\n\n            if (endNode.equals(target)) {\n                paths.add(currentPath);\n            }\n\n            if (countMap.get(endNode) <= k) {\n                for (Edge<V> edge : graph.get(endNode)) {\n                    Path<V> path = currentPath.append(edge);\n                    HEAP.add(path);\n                }\n            }\n        }\n\n        return paths;\n    }\n}\n```\n\n\n-\n\n```\npublic class Edge<V> {\n\n    public final V from;\n    public final V to;\n    public final double weight;\n\n\n    public Edge(V from, V to, double weight) {\n        this.from = from;\n        this.to = to;\n        this.weight = weight;\n        if (Double.isNaN(weight)) {\n            throw new IllegalArgumentException(\"The weight is NaN.\");\n        }\n        if (weight < 0.0) {\n            throw new IllegalArgumentException(\"The weight is negative.\");\n        }\n    }\n\n}\n```\n\n\n-\n\n```\nimport java.util.*;\n\nimport static java.lang.String.*;\n\npublic class Graph<V> {\n\n    //could be replaced by http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Table.html\n    private Map<V,Map<V,Edge<V>>> vertexEdgeMap = new HashMap<>();\n\n    @SafeVarargs\n    public Graph(Edge<V> ... edges) {\n        for (Edge<V> edge : edges) {\n            addEdge(edge);\n        }\n    }\n\n    private void addEdge(Edge<V> edge) {\n        vertexEdgeMap.putIfAbsent(edge.from, new HashMap<>());\n        Map<V, Edge<V>> fromMap = vertexEdgeMap.get(edge.from);\n        if(fromMap.containsKey(edge.to)) {\n            throw new IllegalArgumentException(format(\"Edge between %s and %s was added twice\", edge.from, edge.to));\n        }\n        fromMap.put(edge.to, edge);\n    }\n\n    public Edge<V> get(V from, V to) {\n        return vertexEdgeMap.get(from).get(to);\n    }\n\n    public Collection<Edge<V>> get(V from) {\n        return vertexEdgeMap.getOrDefault(from, Collections.emptyMap()).values();\n    }\n\n}\n```\n\n\n-\n\n```\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport static java.lang.String.format;\n\npublic class Path<V> {\n\n    private final V node;\n    private final double totalCost;\n\n    public Path(V source) {\n        Objects.requireNonNull(source, \"The input source node is null.\");\n        node = source;\n        totalCost = 0.0;\n    }\n\n    private Path(V node, double totalCost) {\n        this.node = node;\n        this.totalCost = totalCost;\n    }\n\n\n    public Path<V> append(Edge<V> edge) {\n        if (!node.equals(edge.from)) {\n            throw new IllegalArgumentException(format(\"The edge %s doesn't extend the path %s\", edge, this.getNodeList()));\n        }\n\n        return new NonEmptyPath<>(this, edge);\n    }\n\n    public V getEndNode() {\n        return node;\n    }\n\n    public List<V> getNodeList() {\n        return new ArrayList<>();\n    }\n\n    public double pathCost() {\n        return totalCost;\n    }\n\n    private static class NonEmptyPath<V> extends Path<V> {\n        private final Path<V> predecessor;\n\n        public NonEmptyPath(Path<V> path, Edge<V> edge) {\n            super(edge.to, path.totalCost + edge.weight);\n            predecessor = path;\n\n        }\n\n        @Override\n        public List<V> getNodeList() {\n            LinkedList<V> result = new LinkedList<>();\n            Path<V> path = this;\n            while(path instanceof NonEmptyPath) {\n                result.addFirst(path.node);\n                path = ((NonEmptyPath<V>) path).predecessor;\n            }\n            result.addFirst(path.node);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return getNodeList().toString();\n        }\n    }\n\n}\n```\n\n\n-\n\n```\nimport java.util.List;\n\npublic class Execution {\n\n    public static void main(String[] args) {\n        execution();\n    }\n\n    private static void execution() {\n\n        Graph<Character> graph = new Graph<>(\n               // new Edge<>('a', 'b', 5.0),\n                new Edge<>('a', 'c', 3.0),\n                new Edge<>('b', 'c', 2.0),\n                new Edge<>('b', 'd', 1.0),\n                new Edge<>('c', 'd', 3.0)\n\n\n        );\n\n        List<Path<Character>> paths = new DefaultKShortestPathFinder<Character>().findShortestPaths('a', 'b', graph, 2);\n\n\n\n        for(Path<Character> path:paths) {\n            System.out.println('h');\n            System.out.println(path.toString() + \" cout: \" + path.pathCost());\n        }\n\n    }\n}\n```\n\n\nEverything works fine for a directed graph, but i want to modify it so it can calculate k-shortest paths for undirected graph anyone has an idea on how to achieve that, also i do know that for directed graph in adjacency matrix [a][b] = True but for [b][a] = false.\n    ", "Answer": "\r\nAn undirected graph is just a directed graph where for every edge a->b, there also exists the edge b->a. Just convert the undirected graph to a directed graph and use your existing algorithm.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "finding multiple paths in a DIRECTED networkx graph\r\n                \r\nI have a directed graph as follows:\n\nI created it with networkx and plotted it with ipycytoscape.\nThe graph is a directed graph. All the edges have One and only one direction.\nThe question is how to find from a particular node all the paths between that node and node one. Since the graph is directed only paths in which ALL THE DIRECTIONS OF THE EDGES is the same are valid. IN the figure there are two paths between 6 and one. It would be possible at a first glace to thing about the blue path but in that case the direction of the edge 4-6 is different than the other ones.\n```\nnodes = [1,2,3,4,5,6,7,8]\nchildren = [[2],[3,4],[5,6],[6,7],[8],[],[8],[]]\nG2 = nx.Graph()\nG2.add_nodes_from(nodes)\nfor i,child in enumerate(children):\n    for c in child:\n        G2.add_edge(i+1, c)\ncyto = CytoscapeWidget()\ncyto.graph.add_graph_from_networkx(G2, directed=True)\ncyto.set_layout(name='dagre', nodeSpacing=10, edgeLengthVal=10)\ndisplay(cyto)\n```\n\nWhat I am looking for is the networks method that gives me the list of paths between two nodes.\npseudocode:\n```\nfor node1 in G.nodes:\nfor node2 in G.nodes:\nlist_of_paths = networks_method???(node1,node2)\n```\n\nNOTE: The graph is such that the arrows (directionality) go always from a smaller number to a higher one. 2 can be parent of 3 but never the other way around.\n    ", "Answer": "\r\nUsually the problem of finding \"all paths\" can be an exponential task and yield infinite paths.\nHowever, you describe a graph from a special subclass of directed graphs: the directed acyclic graphs (DAGs).\nA DAG is a directed graph ```\nG```\n without cycles, i.e., for no node ```\nu```\n in ```\nG```\n exists a path u->v_1....v_n->u.\nSince you say all edges go from a smaller number to a higher number, your graph is a DAG.\nIn this case, a modified DFS search will yield you all possible paths. The topic of \"all paths in DAG\" were already discussed in the following questions\n\nlist of all paths from source to sink in directed acyclic graph\nEnumerating all paths in a directed acyclic graph\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Parallel computing in graphs\r\n                \r\nI want to do some analysis on graphs to find all the possible simple paths between all pairs of nodes in graph. With help of Networkx library I can use DFS to find all possible paths between 2 nodes with this function:\n\n```\nnx.all_simple_paths(G,source,target)\n```\n\n\nThe below code runs without any workload since my toy example contains only 6 nodes in the graph. However, in my real task, my graph contains 5,213 nodes and 11,377,786 edges and finding all possible simple paths in this graph is impossible with below solution:\n\n```\nimport networkx as nx\ngraph = nx.DiGraph()\ngraph.add_weighted_edges_from(final_edges_list) \n\nlist_of_nodes = list(graph.nodes())\n\npaths = {}\n\nfor n1 in list_of_nodes:\n    for n2 in list_of_nodes:\n        if n1 != n2:\n            all_simple_paths = list(nx.all_simple_paths(graph,n1,n2))\n            paths[n1+ \"-\"+n2] = all_simple_paths\n```\n\n\nThe \"paths\" dictionary holds the \"n1-n2\" (source node and target node respectively) as keys, and list of all simple paths as values.\n\nThe question is whether I can use of multi processing in this scenario in order to run this code on my original problem or not. My knowledge about the processors, threads, shared memory and CPU cores are very naive and I am not sure if I can really use the concurrency (running my nested loops in parallel) in my task.\nI use a windows server with 128 GB RAM and 32 core CPU.\n\nPS: Thorough searching the net (mostly StackOverFlow), I've found solutions which recommended to use threading and others recommended multiprocessing. I am not sure if I understand the distinction between these two :|\n    ", "Answer": "\r\nIf you want to use threading then use threadpool executor to submit your function call to a thread. It will return a future object. Future.result() will return the value returned by the call. If the call hasn’t yet completed then this method will wait up to timeout seconds.If call is not completed till that time it will raise the TimeoutError. \n\n```\nwith ThreadPoolExecutor() as executor:\n    for n1 in list_of_nodes:\n        for n2 in list_of_nodes:\n            if n1 != n2:\n                all_simple_paths_futures = executor.submit(nx.all_simple_paths, graph,n1,n2)\n            paths[n1+ \"-\"+n2] = all_simple_paths_futures\ntry:            \n    for key in paths.keys():\n        # get back  results from thread\n        future_obj = paths[key]\n        paths[key]= list(future_obj.result())\nexcept Exception as e:\n    print(e)\n    raise e\n```\n\n\nFor the difference between multiprocessing and threads, check this link :Multiprocessing vs Threading Python\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find the longest path in graph\r\n                \r\nI am trying to find the longest path in a graph but I'm having trouble when it comes to returning the longest path. I have the recursion figured out and can follow the outputs but I can't get the right output. The program currently returns several paths. \n\nThe expected output is when starting from Las Vegas: [Las Vegas, Salt Lake City, Denver, Helena, Winnipeg, Duluth]\n\nMy depth first search method:\n\n```\npublic void dfs(City before, ArrayList<String> listOfCities){\n\n    System.out.println(before +\"-->\"+ before.getAdjCities());\n\n    List<City> neighbours = before.getAdjCities();\n    before.setVisited(true);\n\n    for (int i = 0; i < neighbours.size(); i++) {\n\n        City n = neighbours.get(i);\n        if(!n.visited){\n            listOfCities.add(n.getCityName());\n            System.out.println(i+ \" Test: \" + listOfCities.toString());\n\n            dfs(n, listOfCities);\n        }\n    }\n}\n```\n\n\nHere is the output:\n\n\n\nHere is the graph:\n\n\n    ", "Answer": "\r\nYour ListOfCities is static across all branches of your search, which is why it ends up with all the cities. The recursive step at each city should compare the result of the DFS from each neighbor to build the result.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find \"short enough\" paths in a given graph\r\n                \r\nI need to design an algorithm to find a path in a public transportation system. In theory only the best (lowest cost) path is required, but in reality it's different. When traveling in a public transportation system, it's difficult to define the cost, it cannot be simplified to traveling time, waiting time, transfer time, bus/subway fees etc, are all need to take into consideration.\n\nFirstly I need to simplify the problem, design a cost function which is a combination of all those \"time\" and \"fee\", then use a graph algorithm to find a few paths (3~5 paths). Finally present all these paths to the end users and let them make the decision.\n\nThe reason I need to present more than one path is that, for different users/situations these \"time\" and \"fee\" are different, thus presenting a few paths is better than just giving out the \"best\" path.\n\nAlgorithms like A* are good for finding the shortest path, but how can I find those \"short enough\" paths in a graph ? or how can I find the shortest N paths ?\n\nBTW, I don't even need to find the shortest path, because in practice the end users never know the shortest path (unless the shortest path is obvious), they will be happy if the results are close to the shortest path.\n    ", "Answer": "\r\nA* star's \"cost\" is more versatile than you are thinking.  A* is typically explained with nodes who's cost is simply a distance.  We can, however, beef this up a little.\n\nI'm not seeing a language you prefer, maybe Graph?  Oh well, here's some c++:\n\n```\nnamespace Astar\n{\n  struct CostEvaluation\n  {\n    int distance_cost;\n    int transfer_cost;\n    // others\n\n    int costToTraverseNodes( const Node& first, const Node& second ) const\n    {\n      int distance = // apply distance_cost to distance between nodes\n      int transfer = // apply transfer_cost if there is a transfer between nodes\n\n      return distance + transfer;\n    }\n  }\n}\n```\n\n\nNow, the actual implementation of your A* will take a CostEvaluation object to determine the cost on the route.  If transfers don't matter, set the transfer_cost to zero.\n\nAs far as a \"good enough\" route:  I'm sure other people would be able to help you better, but I feel like you might run into a situation where the program says something like \"oh, you want to be there in an hour, but the best route only takes twenty minutes? Here, go around in circles for forty minutes, that's good enough\".\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding Path in graph( specific Length)\r\n                \r\nwe are looking for an algorithm, that can find a path in a undirected weighted graph (from 's' to 't' for instance), that the total weights of all it's edges is a fixed number ('m' for instance)\nideas.. anyone?\n    ", "Answer": "\r\nUse something like DFS and backtracking. If you exceed weight m and your not at your goal, you backtrack. I'm not sure if you allow going back and forth between two nodes, but if you do, you can't build a tree in place but have to build a stack.\n\nI have a gut feeling that first searching the shortest path and then making it longer would be a faster approach, but the same feeling tells me that it could be wrong like greedy algos are wrong for the Travelling Salesman.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Encoding paths in a graph as strings?\r\n                \r\nSuppose I have a DAG and, rather than using a graph db, the paths are encoded as ```\n{id:\"node3\", path:\"node0|node1|node2\"}```\n to represent that ```\nnode3```\n can reach ```\nnode0```\n via ```\nnode2```\n then ```\nnode1```\n. Would it be a good idea to encode the path in a string if reads are not frequent? The paths generally don't contain more than 50 nodes each.\n\nThanks\n    ", "Answer": "\r\nI think that you will find that your approach won't work as well as you want. One of the properties that makes graphs interesting are the combinatorial explosions that can occur from their structures. Storing every path for every node is going to get big very fast and I think it would cease to scale and do what you expected.\n\nConsider the following blog posts:\n\nhttp://thinkaurelius.com/2012/04/21/loopy-lattices/\n\nhttp://thinkaurelius.com/2013/06/12/loopy-lattices-redux/\n\nThe posts explore path counting on 20x20 directed lattice. It finds that a graph \"with only 441 vertices and 840 edges, has over 137 billion unique directed paths.\"\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Efficient robust algorithm for making paths in a graph\r\n                \r\nI want to write a visualization for bonds in large molecules. The bonds are given as a list of connections, e.g.:\n\n```\n[[1,2],[2,3],[3,4],[5,6],[8,9]]\n```\n\n\nUp to now I am plotting every bond seperately with a single call to my visualization toolkit. This is however very slow and it is much faster to draw fewer but longer connected lines.\n\nTherefore I would like to find as few as possible connected paths in my graph that draw all the connections. In my example I would like to convert the connection input e.g:\n\n```\n[[1,2],[2,3],[3,4],[5,6],[8,9],[6,8],[4,10]]\n```\n\n\nto\n\n```\n[[1,2,3,4],[5,6,8,9],[4,10]]\n```\n\n\nIs there an efficient algorithm for that and are there implementations? I am writing in python but an algorithmic recipe would suffice (if it is not too complicated).\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "What algorithm can I use to locate bottleneck paths in an undirected graph?\r\n                \r\nGiven an undirectional graph, how would you be able to efficiently find all of its \"bottleneck\" paths?\nA \"bottleneck\" path is defined as a path that if destroyed, causes the graph to split into 2 non-connected graphs.\nAlgorithm for finding bottleneck paths in an undirectional graph.\nCould not find such algorithm.\n    ", "Answer": "\r\nI'm not sure if this is exactly what you are looking for, but as a sub-problem, you can consider points in the graph such that if you remove the point it separates the graph into two or more connected subgraphs. These are called \"cut vertices\". Tarjan's algorithm is an algorithm for finding them.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to export/store all paths in graph\r\n                \r\nI have a read-heavy graph with a million nodes and 100 million edges. My use case is to fetch all paths (depth 2, 3 and 4) paths between any two nodes. I tried doing this in Neo4j, OrientDB, and Postgres. Though it works in all three databases, I'm facing the following issues.\n\n\nNot very fast. \nAdded slowness for supernodes. \nUnable to do pagination/sorting effectively.\n\n\nOne way to address all the issues is by pre-calculating all the paths. What is the best way to do this pre-calculation effectively and where store these paths? \n(Also, how to handle changes in the graph?)\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all the unique paths in a graph and return the cheapest\r\n                \r\nI have a school project where i need to find all the different paths in a graph. It's like driving a car between different cities (nodes) and I need to go though all of them and find the cheapest path. I don't have a destination point, the goal is just to find the fastest way to go though all the cities. Starting point is 0. I am not sure how to start and which algorithm to use. I just started learning about graphs and trees, so any help would be appreciated :)\nFor example from city 0 to city 1 it's 20 minutes.\n\n    ", "Answer": "\r\nGood that you are trying to learn! I recommend you read up on the Travelling Salesman problem.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "shortest path in graph\r\n                \r\nGiven an undirected graph G having N (1 < N ≤ 1000) vertices and positive weights. Find the shortest path from vertex 1 to vertex N, or state that such path doesn’t exist.\n\nHint: At each step, among the vertices which weren’t yet checked and for which a path from vertex 1 was found, take the one which has the shortest path, from vertex 1 to it, yet found.\n\nI found this question on topcoder, I think Dijkstra's algo should be used, but the post is regarding Dynamic programming and Dijkstra is a greedy algo.\n\nCan anyone tell me the best way to solve this problem.\n\nThanks\n    ", "Answer": "\r\nYes, although the question is categorized under dynamic programming, you can use EITHER dynamic programming or Dijkstra's Single Source Shortest path greedy algorithm. \n\nDoes the greedy algorithm work? Always think through these two steps:\n\n\nAsk yourself if your problem has the optimal substructure property. For example, if the shortest path from vertex A to G contains B, then the path from A to B must also be the shortest. This sub-structure, path AB, is optimal as it itself is also the shortest path. So yes, the problem you described as the optimal substructure property.\nDoes the algorithm have a greedy choice property? Is the first step part of the optimal solution, is the second and so on and so on. Yes, Dijkstra's algorithm does have the greedy choice property because each vertex uses the local information of all vertex pointing towards it to \"pick\" the smallest value. The algorithm only moves forwards and never moves back and only changes the min value for each vertex A if and only if the information is new (found a new vertex B of a shorter distance that also points to A) and fulfills some condition. \n\n\nHere's an overview of Dijkstra's algo:\n\nEach vertex X will have 2 components: current shortest path & the prev vertex Y associated with it that points at X.\n\n\nset all vertex current shortest path to infinity\nset a starting point - which would be 1 in this case\nfor each of vertex X's neighbors vertex Y, Y's current shortest path is the minimum of X's shortest path + the distance between the two AND Y's current shortest path. Update the prev vertex if Y's current shortest path is changed. \ndo the same for all of Y's neighbors and so on until there are no more vertexes left. \n\n\nIn your case however, you don't need to record the prev index as all you have to output is the length or if it's not possible. \n\nAt the end, you should have some sort of table/list based on your choice of data structure such that if you look up a certain vertex N, it tells you the length from vertex 1. If the length from vertex 1 is infinity then it is not possible. Of course, you could also do some book keeping such a bool value associated with each vertex. \n\nKeep in mind that Dijkstra's will have a O(V^2) running time. Dynamic programming may generate a faster running time. \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Visualize all short paths in graph using R\r\n                \r\nThe first simple data\n\n```\nm <- read.table(row.names = 1, header = TRUE, text = \n                  \"  A   B   C   D   E   F\n                A 0   1   1   1   1   5\n                B 1   0   1   1e2 1e2 1\n                C 1   1   0   1   1   1\n                D 1   1e2 1   0   1e2 1\n                E 1   1e2 1   1e2 0   1\n                F 5   1   1   1   1   0\")\nm <- as.matrix(m)\n```\n\n\nUsing igraph library\n\n```\nig <- graph.adjacency(m, mode = \"undirected\", weighted = TRUE, diag = FALSE)\nsp <- shortest.paths(ig, algorithm = \"dijkstra\")\nplot(ig)\n\nspaths <- lapply(V(ig),\n                 function(v){\n                     all_shortest_paths(ig, v,\n                                        weight = 1 / E(ig)$weight\n                     )\n                 }\n           )\n```\n\n\nNow let's check paths to all vertices spaths$C$res or spaths$B$res... How can I display only one shortest path from one point to another on the graph? 1.For example From C to A as red line 2.and the longest way from C to A as blue line\n    ", "Answer": "\r\nI will assume that you want the longest simple path from C to A.  Since your graph has cycles, there are paths of arbitrarily large lengths if you revisit nodes. Let me first answer the question, but there is a caveat at the end. \n\nYou can get all simple paths from C to A using ```\nall_simple_paths```\n. From those, it is easy to select one of the shortest paths and one of the longest paths. Then just color them. \n\n```\nSimple = all_simple_paths(ig, \"C\", \"A\")\nSP = which.min(sapply(Simple, length))\nLP = which.max(sapply(Simple, length))\n\nEL1 = rep(Simple[[LP]], each=2)[-1]\nEL1 = EL1[-length(EL1)]\nEL2 = rep(Simple[[SP]], each=2)[-1]\nEL2 = EL2[-length(EL2)]\n\nECol = rep(\"gray\", ecount(ig))\nECol[get.edge.ids(ig, EL1)] = \"blue\"\nECol[get.edge.ids(ig, EL2)] = \"red\"\n\nplot(ig, edge.color=ECol)\n```\n\n\n\n\nBut be warned! If your graph is big and well connected, there may be many paths between two nodes. ```\nall_simple_paths```\n may take a long time to run and produce a very large result. \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to write all paths in a directed graph with no cycles? (Prolog)\r\n                \r\nI'm testing out graph-searching for paths in prolog using information from https://www.irit.fr/~Jerome.Mengin/teaching/prolog/prolog-search_a4.pdf and ran into some issues with writing from recursive func.\n\nMy code can find all possible paths from node1 to node2 however the results(paths) are printed out in reverse order.\n\n```\nedge(a, c).\nedge(a, d).\nedge(c, e). \nedge(e, f).\nedge(d, f).\n\npaths(Curr,Stop) :- \n    Curr==Stop -> write(Curr);\n    edge(Curr,Next),\n    paths(Next,Stop),\n    write(Curr).\n```\n\n\nFor example paths(a,f) yields:\n    feca\n    true ;\n    fda\n    true.\n\nHowever I want the results in the correct order acef and adf written without the use of lists.\n    ", "Answer": "\r\nJust remember that you are finding the path through backtracking, so the last node you arrive to, will be the first one who printed out. This forces you to write a predicate that prints the start node at the end, which means you need to solve this problem \"upside down\". \nThe idea is to use edge(Previous,Stop) instead of edge(Curr,Next).\n\n```\nedge(a, c).\nedge(a, d).\nedge(c, e).\nedge(e, f).\nedge(d, f).\n\n\npaths(Start,Stop) :-\n    Start==Stop -> write(Start);\n    edge(Prev,Stop),\n    paths(Start,Prev),\n    write(Stop).\n```\n\n\nas you can see now, we are starting from the end and recursively trying to get to the start, when we are reaching the start the whole path is printed from start to end.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Paths in undirected graphs\r\n                \r\nWe are given an undirected graph G = (V, E) and two vertices s, t ∈ V . We consider simple\npaths between s and t. A path is simple if every vertex is visited at most once.\n\nAre the following in P or NP-complete?\n\nDoes an efficient algorithm polynomial time exist for the following?\n\n\"n\" represents the number of vertices in the graph \"V\"\n\n\nIs there a simple path from s to t of length at most n/100?\nIs there a simple path from s to t of length at least n/100?\nIs there a simple path from s to t of length exactly n/100?\nAre there two edge-disjoint paths from s to t? (Two paths are said to be edge- disjoint if they do not share an edge.)\n\n\nMy thoughts (please correct me if I'm wrong) Your input is appreciated.\n\n\nI think I can run Dijkstra's Algorithm to find the shortest path between S and T in polynomial time. So question 1 is in P.\nI think it is necessary to enumerate all the simple paths from s to t. I don't know what the running time of this would be, but I think it would be worse than polynomial.\nSimilar to 2 above. No polynomial algorithm.\nI'm not sure. I don't know of any efficient (poly-time algorithm) to find multiple paths between two nodes but that doesn't mean that they don't exist.\n\n    ", "Answer": "\r\nYou're on the right track.  I wrote another piece on NP-complete to which I'm going to refer you for some of the details, but recall that basically you need to do two things to prove something NP-complete:\n\n\nShow the problem is in NP\nShow a polynomial time reduction to\na problem already known to be\nNP-complete.\n\n\nDoing 1 is pretty easy (if something walking the graph \"knew\" all the right decision of the next edge to take, would it find an answer in polynomial time?); I'd think seriously about the \"decision TSP\" problem I describe in the other note.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find Longest Path in Graph\r\n                \r\nI have been trying hard to find out longest path in a complex network. I have been through many questions in StackOverflow and Internet, but none could help me. I have written a CQL as \n\n```\nstart n=node(*)\nmatch p = (n)-[:LinkTo*1..]->(m)\nwith n,MAX(length(p)) as L\nmatch p = (n)-[:LinkTo*1..]->(m)\nwhere length(p) = L\nreturn p,L\n```\n\n\nI don't get any solution. Neo4J would keep running for the answer, and I also tried executing it in Neo4J Cloud Hosting. I didn't any solution even there, but got an error \n\"Error undefined-undefined\"\nI am in dire need of a solution. The result for this answer will help me complete my project. So, anyone please help me in correcting the query.\n    ", "Answer": "\r\nWell for one you're doing a highly expensive operation twice when you only have to do it once.\n\nAdditionally, you are returning one path per every single node in your database, at least (as there may be multiple paths for a node that are the longest paths available for that node). But from your question it sounds like you want the single largest path in the graph, not one each for every single node.\n\nWe can also improve your match by only performing the longest-path match on nodes that are at the head of the path, and not somewhere in the middle.\n\nMaybe try this one?\n\n```\nmatch (n)\nwhere (n)-[:LinkTo]->() and not ()-[:LinkTo]->(n)\nmatch p = (n)-[:LinkTo*1..]->(m)\nreturn p, length(p) as L\norder by L desc\nlimit 1\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Print all the possible shortest paths in a graph\r\n                \r\nI'm writing some code to print all the possible shortest paths in a graph using a modified version of Dijkstra's algorithm. While in the classic implementation you have an array in which you store the predecessor of each node, I created a matrix in which you can have multiple predecessors for each node, so that you can follow more than one path from a node to the source. \nThe problem is, I just can't figure out how to print it. I wrote this code, but it does not provide the correct solution:\n\n```\nvoid print(graph grf, int node) {\n    int n;\n    if (grf->preds[node][0] == NIL) {\n        printf(\"\\n%i\", node);\n        return;\n    }\n    else {\n        for (n = 0; n<grf->number; n++) {\n            if (grf->preds[node][n] != NIL) {\n                print(grf, grf->preds[node][n]);\n                printf(\"->%i\", node);\n            }\n        }\n    }\n    return;\n}\n```\n\n\nIt prints the following solution:\n\n```\n1->0\n1->9->8\n1->3->7\n1->0->7->8->2\n1->3\n1->9->4\n1->3->5\n1->0->5\n1->3->7\n1->0->7->6\n1->9->8\n1->3->7\n1->0->7->8->6\n1->3->7\n1->0->7\n1->9->8\n1->3->7\n1->0->7->8\n1->9\n```\n\n\nWhile this is the correct one (please note that the order is not important):\n\n```\n1->9\n1->9->8\n1->9->8->6\n1->9->8->2\n1->9->4\n1->3\n1->3->7\n1->3->7->8\n1->3->7->8->6\n1->3->7->8->2\n1->3->7->6\n1->3->5\n1->0\n1->0->7\n1->0->7->8\n1->0->7->8->6\n1->0->7->8->2\n1->0->7->6\n1->0->5\n```\n\n\nI think this is because the for cycle calls again the function when you have two possible predecessors and you are coming back from another call, but I don't know how to avoid this and still have a simple and good working code.\n\nOne suggestion I had is to use a BFS or DFS to print the paths, but I haven't understood how.\n    ", "Answer": "\r\nok, if anyone is interested I solved the problem. I created a temporary array in which I store the path, and when the function reachs the ending point, it prints all the array. There is a variable which is incremented at each call, which stores the depth of the recursion and says to the function in which position of the array store the node.\nHere is the code:\n\n```\nvoid stampa(p_grafo grf, int nodo, int depth) {\nint contatore, i;\nif (grf->preds[nodo][0] == NIL) {\n    printf(\"%i\", nodo);\n    for(i=grf->numero-1;i>=0;i--)\n        if(grf->temp[i]!=NIL)\n            printf(\"->%i\", grf->temp[i]);\n    printf(\"\\n\");\n    return;\n}\nelse {\n    for (contatore = 0; contatore<grf->numero; contatore++) {\n        if (grf->preds[nodo][contatore] != NIL) {\n            grf->temp[depth]=nodo;\n            stampa(grf, grf->preds[nodo][contatore], depth+1);\n        }\n    }\n}\nreturn;\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to enable plain id query rather than using paths in api_platform graphql?\r\n                \r\nI have implemented api_platform in my symfony 4 project, the problem is that I have to use the paths provided by the Rest api to fetch data using graphql like this\n\n```\n{\n  user(id:\"api/users/1\")\n  {\n    id\n  }\n}\n```\n\n\nrather than\n\n```\n{\n  user(id:1){\n  id\n  }\n}\n```\n\n\nWent through the documentation and didn't find a solution for this. Using plain api paths in graph api isn't really worth moving to graphql. Any help.\n    ", "Answer": "\r\nlibraries like Prisma Binding allows you to query GraphQL using APIs\n\nexample on fetch user with ID of 1:\n\n```\nconst query = `\n  query ($userId: ID!){\n    user(id: $userId) {\n      id\n      name\n    }\n  }\n`\n\nconst variables = { userId: '1' }\n\nprisma.request(query, variables).then(result => console.log(result))\n// {\"data\": { \"user\": { \"id\": \"1\", \"name\": \"Sarah\" } } }\n```\n\n\nFrom here, we can write custom wrappers to translate the REST endpoints to corresponding queries\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Maximum Weighted Path in a Weighted Undirected Graph\r\n                \r\nThe modification of Dijkstra Algorithm related to maximum weighted path in a weighted undirected graph is given here. \nFinding path with maximum minimum capacity in graph\nCan anyone give a clear and easy explanation of this algorithm by some example?\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths in a graph with a time constraint\r\n                \r\nMy data looks like the following : \n\n```\n      source  target\ntime                \n0.5    96253   94861\n1.0    96652   95091\n1.5    94861   95091\n2.5    95091   95409\n3.5    95409   97221\n4.5    97221   96781\n5.5    96781   97707\n6.5    97707   98191\n7.5    98191   99096\n8.5    99096  100016\n8.5    99096  100013\n9.5   100013   98663\n9.5   100016   98658\n10.5   98658   99573\n10.5   98663   99589\n11.5   99589  100506\n11.5   99573  100490\n```\n\n\n\nEach integers inside ```\nsource```\n and ```\ntarget```\n columns reference a spots.\nEach row is a link between two spots.\nThe ```\ntime```\n index refers to the time point in which the link can be found.\n\n\nA smart algorithm would be to found all the possible trajectories contained inside the dataset.\n\nFor example in the previous example, 4 trajectories exist : \n\n```\n[96253, 94861, 95091, 95409, 97221, 97221, 96781, 97707, 98191, 99096, 100016, 98658, 99573, 100490]\n[96652, 95091, 95409, 97221, 97221, 96781, 97707, 98191, 99096, 100016, 98658, 99573, 100490]\n[96253, 94861, 95091, 95409, 97221, 97221, 96781, 97707, 98191, 99096, 100013, 98663, 99589, 100506]\n[96652, 95091, 95409, 97221, 97221, 96781, 97707, 98191, 99096, 100013, 98663, 99589, 100506]\n```\n\n\n\n\nThis problem can be resumed as a graph theory problem. See the below graph which corresponds to the data showed at the beginning.\n\n\n\nThe idea would be to find all possible paths in this graph with a constraint respecting time logic : a trajectory is an ordered list of spots (nodes) which can only go from ```\nt```\n to ```\nt+1```\n (can't go in past).\n\n\n\nThe algorithm will be implemented in Python. So any Python tricks are allowed :-)\n    ", "Answer": "\r\nApplying graph theory algorithm seems to be the smart way to resolve this. I used ```\nnetworkx```\n python library.\n\n```\nprint(spot_ids)\n```\n\n\noutput : \n\n```\n      source  target\ntime                \n0.5    96253   94861\n1.0    96652   95091\n1.5    94861   95091\n2.5    95091   95409\n3.5    95409   97221\n4.5    97221   96781\n5.5    96781   97707\n6.5    97707   98191\n7.5    98191   99096\n8.5    99096  100016\n8.5    99096  100013\n9.5   100013   98663\n9.5   100016   98658\n10.5   98658   99573\n10.5   98663   99589\n11.5   99589  100506\n11.5   99573  100490\n```\n\n\nThe algorithm : \n\n```\nimport itertools\nimport networkx as nx\n\n# Build graph\ngraph = nx.Graph()\nfor t, spot in spot_ids.iterrows():\n    graph.add_edge(int(spot['source']), int(spot['target']), attr_dict=dict(t=t))\n\n# Find graph extremities by checking if number of neighbors is equal to 1\ntracks_extremities = [node for node in graph.nodes() if len(graph.neighbors(node)) == 1]\ntracks_extremities\n\npaths = []\n# Find all possible paths between extremities\nfor source, target in itertools.combinations(tracks_extremities, 2):\n\n    # Find all path between two nodes\n    for path in nx.all_simple_paths(graph, source=source, target=target):\n\n        # Now we need to check wether this path respect the time logic contraint\n        # edges can only go in one direction of the time\n\n        # Build times vector according to path\n        t = []\n        for i, node_srce in enumerate(path[:-1]):\n            node_trgt = path[i+1]\n            t.append(graph.edge[node_srce][node_trgt]['t'])\n\n        # Will be equal to 1 if going to one time direction\n        if len(np.unique(np.sign(np.diff(t)))) == 1:\n            paths.append(path)\n\nfor path in paths:\n    print(path)\n```\n\n\noutput : \n\n```\n[100490, 99573, 98658, 100016, 99096, 98191, 97707, 96781, 97221, 95409, 95091, 96652]\n[100490, 99573, 98658, 100016, 99096, 98191, 97707, 96781, 97221, 95409, 95091, 94861, 96253]\n[96652, 95091, 95409, 97221, 96781, 97707, 98191, 99096, 100013, 98663, 99589, 100506]\n[100506, 99589, 98663, 100013, 99096, 98191, 97707, 96781, 97221, 95409, 95091, 94861, 96253]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Number of shortest paths in a graph\r\n                \r\nI need to find the number of all paths between two nodes of a graph by using BFS. I think the answer to my question can be found here:\n\nHow to find the number of different shortest paths between two vertices, in directed graph and with linear-time? \n\nBut I don't quite understand it. Could someone please write the algorithm down in other words so I can understand it better?\n    ", "Answer": "\r\nLet say you need to go from src to dest.\nWith each vertex x, associate two values count and val, where count is the number of shortest paths from src to x and val is the shortest distance from src to x. Also maintain a visited variable telling whether this is the first time visiting the node or not.\nApply usual BFS algorithm,\n```\nInitialize u = src\nvisited[u] = 1, \nval[u] = 0\ncount[u] = 1\nFor each child v of u,\n    if v is not visited \n```\n\nThe first time a node is visited, it has only one path from src to now via u, so the shortest path up to v is (1 + shortest path up to u), and number of ways to reach v via shortest path is same as count[u] because say u has 5 ways to reach from source, then only these 5 ways can be extended up to v as v is encountered first time via u, so\n```\nval[v] = val[u]+1,    \ncount[v] = count[u], \nvisited[v] = 1\n    \nif v is visited\n```\n\nIf v is already visited, which means, there exists some other path up to v via some other vertices, then three cases arise:\n\ncase ```\nval[v] == val[u]+1```\n\n\nif current val[v] (which is dist up to v via some other path) is equal to val[u]+1, i.e we have equal shortest distances for reaching v using current path through u and the other path up to v, then the shortest distance up to v remains same, but the number of paths increase by number of paths of reaching u.\n```\ncount[v] = count[v]+count[u]\n        \n```\n\n\ncase ```\nval[v] > val[u]+1```\n\n\nAs we are traversing the nodes using BFS level by level, this case cannot happen: the graph is unweighted, so the first time we set val[v], it is guaranteed that val[v] will already contain the length of the shortest path from src to v.\n\ncase ```\nval[v] < val[u]+1```\n\n\nIn this case, there is no need to change the values of val[v] and count[v] as this path does not count as a shortest path\nDo this algorithm till the BFS is complete.\nIn the end val[dest] contain the shortest distance from source and count[dest] contain the number of ways from src to dest.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in graph in CouchDB\r\n                \r\nI'm trying to calculate the shortest path in a graph stored in CouchDB. I have to do it 'in db' because my task is to compare query speeds in various situations for 3 different DBMSs. So loading the data and running dijkstra in python (or anything else) is not an option. I'm pretty new to document based databases so I may be wrong but as I see it my only option is a view.\n\nMy db structure is the following:\n\n\nOne document represents one graph.\nIn the document with a key 'edges' there is an array of objects with 3 properties: start, end, distance.\nstart and end are node IDs but there is no other interesting information about nodes so they are not stored anywhere else.\ndistance is a float\n\n\nMy idea was to create a view that returns the shortest path. I have this code for calculating it. It is based on this post. I just had to modify a bit otherwise I got syntax errors for stuff like let,foreach:\n\n```\nfunction (doc) {\n  function Graph() {\n    this.nodes = [];\n    this.adjacencyList = {};\n\n    this.addNode = function(node) {\n      if(this.nodes.indexOf(node) != -1)\n        return;\n      this.nodes.push(node); \n      this.adjacencyList[node] = [];\n    }\n\n    this.addEdge = function(node1, node2, weight) {\n      this.adjacencyList[node1].push({node:node2, weight: weight});\n      //this.adjacencyList[node2].push({node:node1, weight: weight});\n    }\n\n    this.shortestPath = function(startNode, endNode){\n      var times = {};\n      var backtrace = {};\n      var pq = new PriorityQueue();\n\n      times[startNode] = 0;\n\n      for(var i = 0; i<this.nodes.length; i++){\n        if(this.nodes[i] != startNode){\n          times[node] = Infinity;\n        }\n      }\n\n      pq.enqueue([startNode, 0]);\n\n      while (!pq.isEmpty()) {\n        var shortestStep = pq.dequeue();\n        var currentNode = shortestStep[0];\n        for(var i=0;i< this.adjacencyList[currentNode].length; i++){\n          var neighbor = this.adjacencyList[currentNode][i];\n          var time = times[currentNode] + neighbor.weight;\n          if (time < times[neighbor.node]) {\n            times[neighbor.node] = time;\n            backtrace[neighbor.node] = currentNode;\n            pq.enqueue([neighbor.node, time]);\n          }\n        }\n      }\n      var path = [endNode];\n      var lastStep = endNode;\n      while(lastStep !== startNode) {\n        path.unshift(backtrace[lastStep]);\n        lastStep = backtrace[lastStep];\n      }\n\n      return 'Path is ${path} and time is ${times[endNode]}';\n    }\n  };\n\n  function PriorityQueue() {\n    this.collection = [];\n\n    this.enqueue = function(element){\n      if (this.isEmpty()){ \n        this.collection.push(element);\n      } else {\n        var added = false;\n        for (var i = 1; i <= this.collection.length; i++){\n          if (element[1] < this.collection[i-1][1]){ \n            this.collection.splice(i-1, 0, element);\n            added = true;\n            break;\n          }\n        }\n        if (!added){\n            this.collection.push(element);\n        }\n      }\n    };\n\n    this.dequeue = function() {\n      var value = this.collection.shift();\n      return value;\n    };\n\n    this.isEmpty = function() {\n      return (this.collection.length === 0) \n    };\n  };\n\n  var graph = new Graph();\n\n  var startNode = 118;\n  var endNode = 270;\n  for (var i = 0; i < doc.edges.length; ++i) {\n    graph.addNode(doc.edges[i].start);\n    graph.addNode(doc.edges[i].end);\n    graph.addEdge(doc.edges[i].start,doc.edges[i].end,doc.edges[i].distance);\n  }\n\n  emit(\"shortest\", graph.shortestPath(startNode,endNode));\n}\n```\n\n\nHowever when querying the view I get 0 rows.\n\nEDIT:\n\nHere is an example dataset:\n\n```\n{\n  \"_id\": \"7c75c647957f57eaa47103d5795eab44\",\n  \"_rev\": \"3-4c8bc32cf6129209b1ce2fec35f6e6cd\",\n  \"edges\": [\n    {\n      \"start\": \"1609\",\n      \"end\": \"1622\",\n      \"distance\": 57.403187\n    },\n    {\n      \"start\": \"2471\",\n      \"end\": \"2479\",\n      \"distance\": 29.718756\n    },\n    {\n      \"start\": \"2463\",\n      \"end\": \"2471\",\n      \"distance\": 61.706902\n    },\n    {\n      \"start\": \"2443\",\n      \"end\": \"2448\",\n      \"distance\": 19.080025\n    },\n    ...\n}\n```\n\n    ", "Answer": "\r\nFinally I've found it. When I rewrote the foreach to a traditional for, I forgot to change this:\n\n```\nfor(var i = 0; i<this.nodes.length; i++){\n    if(this.nodes[i] != startNode){\n      times[node] = Infinity;\n    }\n}\n```\n\n\nTo this:\n\n```\nfor(var i = 0; i<this.nodes.length; i++){\n   if(this.nodes[i] != startNode){\n      times[this.nodes[i]] = Infinity;\n   }\n}\n```\n\n\nInterestingly I did not see any error in CouchDB. I had to run my code locally with node.js to find out there was an error.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "forbidden paths in a graph\r\n                \r\nWe are provided with a directed graph (data flow graph). We want to forbid the data from reaching some nodes of the graph, which means we will have forbidden paths to delete but must keep the graph connected. \n\nI propose a simple example to make the problem clear: \n\nLet us have the following graph: \n\nA ------>B-------->C-------->D\n\nI want to forbid data from reaching the node C, so the edge B-C will be removed. At the same time I want the data to reach D. So a new edge from B-D will be created.\n\nIs there an efficient algorithm for the above task? \n\nThank you.\n    ", "Answer": "\r\nEvery node X that is not allowed to be reached has i incoming edges and j outgoing edges. As we talk about a data-flow graph it is not sufficient for a node before X to only reach one of the j nodes after X. Either you can insert a dummy (Steiner) node X' that has no function except for not being labeled X where you send all i edges and also connect the j outgoing edges. Otherwise you might have to connect every node where one of the i incoming edges originates and connect it to all j nodes where the outgoing edges of X lead. (Otherwise the data flow is broken.)\n\nTo repair one to one node is a constant time operation, but repairing all relations for one such node X takes O(i*j) time, i.e., it is quadratic in the number of incident edges. \n\n\n\nData from a,b, and c flows to X and from there to either x,y, or z.\n\n\n\nThus, data from a can reach x,y, and z.\n\n\n\nTo remove the edge from a->X we have to add edges from a to all nodes that are reachable from X. Since we have to do this for every edge that reaches X we get a quadratic complexity. \n\nEDIT: (Due to the comment) For two forbidden nodes X and Y were there is an edge form X to Y, such an edge can stay. After all edges to all forbidden nodes (except from a forbidden node) are removed the forbidden nodes may form connected components of size > 1. This is not a problem as every such connected component contains only forbidden nodes and edges and can not be reached from the remaining flow-graph.\n\nAfter this, we only remove edges that lead from a valid node to a forbidden node. These edges have to be removed in order to fulfil the demand. No other edge is removed, thus this is the minimum amount that fulfils the request. (I don't think there is much else to prove here.)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find ALL Eulerian paths in directed graph\r\n                \r\nI have a directed graph and I want to find all existing eulerian paths (in my graph I actually know  that those will be circuits). \n\nI have done some research so I can use for example Hierholzer's algorithm as in here: http://stones333.blogspot.co.uk/2013/11/find-eulerian-path-in-directed-graph.html to find a path from given node but this algorithm returns only one path I believe.\n\nMy idea to solve this is to have an algorithm that will return ALL existing Eulerian paths / circuits starting from given node. Then I will run this algorithms for all nodes and get the results. This will have n^2 or n^3 complexity which is great.\n\nSo my question is if there is an algorithm that will find all Eulerian paths / circuits in directed graph from given node? Or maybe someone knows another solution to my problem.\n\nEDIT:\nafter Gassa comment I think that the solution with Euler paths might be an overkill for my problem. Problem is as follows: for given n we create a pairs of integers which sum is <= n. For those pairs find all paths that connects all of the pairs such that second value of previous pair equals to the first value from next pair (like domino). \n\nExample: n = 2, then available pairs = {(0,0), (0,1),(1,0),(1,1),(2,0),(0,2)}. One of the valid chains = (0,0)=>(0,1)=>(1,1)=> (1,0)=>(0,2)=>(2,0). I preferred algorithm using graphs because for example (0,0) might not be valid sometimes, but let's say it is valid for the sake of this question. Brute force solution to this problem is to of course create all permutations of available pairs and then see if they are valid but this is obviously O(n!) complex. I am pretty sure this could be done in some \"smart\" way.\n    ", "Answer": "\r\nIn the general case, the number of distinct Eulerian paths is exponential in the number of vertices n. Just counting the number of Eulerian circuits in an undirected graph is proven to be #P-complete (see Note on Counting Eulerian Circuits by Graham R. Brightwell and Peter Winkler). Quoting Wikipedia:\n\n\n  A polynomial-time algorithm for solving a #P-complete problem, if it\n  existed, would imply P = NP, and thus P = PH. No such algorithm is\n  currently known.\n\n\nSo perhaps you will need another approach.\n\nIf however your graph has certain properties which make the exponential number of Eulerian circuits impossible, do tell us these properties.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "path to adjacency matrix in networkx\r\n                \r\nI'm trying to convert paths in graphs in into adjacency matrix using the networkx library. \nI can convert a whole graph into an adjacency matrix:\n\n```\n>>>import networkx as nx\n>>>DG=nx.DiGraph()\n>>>DG.add_edges_from([(1,2), (2,3),(1,3)])\n>>>nx.to_numpy_matrix(DG)\n....matrix([[ 0.,  1.,  1.],\n    [ 0.,  0.,  1.],\n    [ 0.,  0.,  0.]])\n```\n\n\nHowever, after I find all simple paths from node 1 to node 3:\n\n```\n>>>list(nx.all_simple_paths(DG,1,3))\n....[[1, 2, 3], [1, 3]]\n```\n\n\nI'm unable to turn them into an adjacency matrix. \nI want to be able to choose a path and turn it into an adjacency matrix,\nfor example, the second path should return:\n\n```\n....matrix([[ 0.,  0.,  1.],\n    [ 0.,  0.,  0.],\n    [ 0.,  0.,  0.]])\n```\n\n    ", "Answer": "\r\nThat is not an adjacency matrix. But you can easily build it yourself as follows:\n\n```\nimport networkx as nx\nimport numpy as np\n\nDG=nx.DiGraph()\nDG.add_edges_from([(1,2), (2,3),(1,3)])\npaths = list(nx.all_simple_paths(DG,1,3))\n\nfor path in paths:\n    matrix = np.matrix(np.zeros((len(DG), len(DG))))\n    for i in range(len(path)-1):\n        matrix[path[i]-1], path[i+1]-1] = 1  # edit: credits to @Joel\n    print(matrix)\n```\n\n\noutput:\n\n```\n[[ 0.  1.  0.]\n [ 0.  0.  1.]\n [ 0.  0.  0.]]\n[[ 0.  0.  1.]\n [ 0.  0.  0.]\n [ 0.  0.  0.]]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Number of Paths in a Graph\r\n                \r\nI have an undirected, unweighted graph. Let us fix a vertex and find all distinct paths from that vertex which covers all vertices of the graph. The task is to find the number of possible such paths from every vertices. \n Eg: Let us take a graph of 4 vertices ```\n[ 1, 2, 3, 4]```\n. And the edges are (1,2), (2,3), (3,4), (4,2). Here answer is 4. The paths are ```\n1>2>3>4```\n, ```\n1>2>4>3```\n, ```\n3>4>2>1```\n, ```\n4>3>2>1```\n.\n\n\n\nI have come with an algorithm which uses brute-force technique to find the number of possible such paths, initialized by each vertex.Eg:\nFor the above example: \n```\nFrom vertex 1 there is 2 such path;```\n \n```\nFrom vertex 2 there is no such path;```\n \n```\nFrom vertex 3 there is 1 such path;```\n \n```\nFrom vertex 4 there is 1 such path;```\n \nSo the answer is 2+1+1=4.\n\n\n\nIs it possible to solve this problem in a better time complexity?\n    ", "Answer": "\r\nThere's an O(2^n n^2)-time algorithm obtained by modifying the Held--Karp DP. The idea is, for each subset S of vertices paired with some endpoint t in S, compute the number of paths that visit exactly the vertices in S and end at t by summing, for each neighbor u of t that is in S, the count for visiting S - {t} and ending at u. As a base case, the singleton sets all have count 1. In Python 3:\n\n```\nimport itertools\ndef count_hamilton_paths(graph):  # graph is a dict of adjacency lists\n    vertices = frozenset(graph)\n    table = {(frozenset({t}), t): 1 for t in vertices}\n    for r in range(2, len(vertices) + 1):\n        for subset_tuple in itertools.combinations(vertices, r):\n            subset = frozenset(subset_tuple)\n            for t in subset:\n                subset_minus_t = subset - frozenset({t})\n                table[(subset, t)] = sum(table[(subset_minus_t, u)]\n                                         for u in graph[t]\n                                         if u in subset_minus_t)\n    return sum(table[(vertices, t)] for t in vertices)\n\nprint(count_hamilton_paths({1: {2}, 2: {1, 3, 4}, 3: {2, 4}, 4: {2, 3}}))\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Length and Path in Graphs Prolog (avoid infinite recursion for cycles)\r\n                \r\n```\nnode(a).\nnode(b).\nnode(c).\nnode(d).\nnode(e).\nnode(f).\nnode(g).\nnode(h).\nedge(a,b).\nedge(b,c).\nedge(c,a).\nedge(c,e).\nedge(c,d).\nedge(d,e).\nedge(d,h).\nedge(e,g).\nedge(g,e).\nedge(e,f).\nedge(f,g).\nparent(X,Y):-edge(X,Y).\nchild(X,Y):-parent(Y,X).\npath(X,Y):-edge(X,Y).\npath(X,Y):-edge(X,Z),path(Z,Y).\npath(X,Y,Z):- \nlength_of_path(X,Y,1):-edge(X,Y).\nlength_of_path(X,Y,N):-edge(X,Z),length_of_path(Z,Y,N1),N is N1+1.\nconnected(X,Y):-path(X,Y); path(Y,X).\nundirected_edge(X,Y):-edge(X,Y);edge(Y,X).\nundirected_path(X,Y):-path(X,Y);path(Y,X).\ntpath(Node1,Node2):-edge(Node1, SomeNode), edge(SomeNode,Node2).\n```\n\n\nPath(X,Y) needs to find a directed path from node X to node Y. However, in my case there is a problem because there is infinite recursion (nodes e,f,g are a circle).\n\nPath(X,Y,Z) needs to find a directed path from node X to node Y and store in Z.\n\nlength_of_path(X,Y,Z), Z is length of path from X to Y.\n\nWhat makes these 3 questions difficult is that you need to take into account that there are circles in the graph. I'm not sure how to solve this problem.\n    ", "Answer": "\r\nThe straight-forward approach is to keep track of the path so far and not go to a node you've already visited. Here is one implementation: Definition of a path/trail/walk\n\nIf I take that and add your node/1 and edge/2 definitions, I get:\n\n```\n?- path(edge, Path, e, X).\nPath = [e],\nX = e ;\nPath = [e, g],\nX = g ;\nPath = [e, f],\nX = f ;\nPath = [e, f, g],\nX = g ;\nfalse.\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to plot \"graph paths\"\r\n                \r\nI spent some time researching previous stackexchange posts on how to find \"paths\" and \"shortest paths\" between points in graphs. However, I have not been able to figure out how to plot these \"paths\"\nI was able to create some fake data, create a graph and determine \"paths\" between different points:\n```\n#create some data\nData_I_Have <- data.frame(\n    \n    \"Node_A\" = c(\"John\", \"John\", \"John\", \"Peter\", \"Peter\", \"Peter\", \"Tim\", \"Kevin\", \"Adam\", \"Adam\", \"Xavier\"),\n    \"Node_B\" = c(\"Claude\", \"Peter\", \"Tim\", \"Tim\", \"Claude\", \"Henry\", \"Kevin\", \"Claude\", \"Tim\", \"Henry\", \"Claude\")\n)\n\n\n#load library\nlibrary(igraph)\n\n\n#create graph\ngraph_file <- data.frame(Data_I_Have$Node_A, Data_I_Have$Node_B)\ncolnames(graph_file) <- c(\"Data_I_Have$Node_A\", \"Data_I_Have$Node_B\")\ngraph <- graph.data.frame(graph_file, directed=F)\ngraph <- simplify(graph)\n\n#path analysis\npath_a = all_simple_paths(graph, \"Claude\", \"Adam\")\npath_b = all_simple_paths(graph, \"Claude\", c(\"Adam\", \"Kevin\"))\nsp=get.all.shortest.paths(graph, \"Claude\", \"Kevin\")\n```\n\nHowever, I have not been able to plot one of these \"paths\"\n```\n#attempt to plot one of the paths\nplot(sp$res[1])\n\nError in xy.coords(x, y, xlabel, ylabel, log) : \n  'x' is a list, but does not have components 'x' and 'y'\n```\n\nDoes anyone know what I am doing wrong?\nDo these have to be converted into an \"igraph object\"?\n```\nigraph::subgraph(sp$res[1])\n\nError in igraph::subgraph(sp$res[1]) : Not a graph object\n```\n\nThanks\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "shortest path in Directed graph in networkx\r\n                \r\nI want to use a defined graph (Org_graph) and find shortest paths between some nodes. Org_graph is a graph like this type:\n\n```\nOrg_graph =[[0, 1, 0, 0, 0, 0, 0],\n          [0, 0, 1, 0, 0, 0, 0],\n          [0, 0, 0, 0, 0, 0, 0],\n          [0, 0, 0, 0, 1, 0, 0],      \n          [0, 0, 1, 0, 0, 1, 0],\n          [0, 0, 0, 0, 0, 0, 0],\n          [0, 0, 1, 0, 0, 0, 0],\n         ]\n```\n\n\nSo at the first I have converted it to a networkx graph and then use it's function to find shortest paths. In converting I am using \"numpy\" and \"from_numpy_matrix()\" program. \n\n```\nOrg_graph2 =np.matrix(Org_graph) \n\nG=nx.DiGraph()\nG=nx.from_numpy_matrix(Org_graph2)\n\n#X is source node\n#Y is destination node\nprint (nx.shortest_path(G,X,Y)\n```\n\n\nMy problem is that, Org_graph is a directed graph but when I am using nx.shortest_path(G,X,Y), it returns paths which is for a undirected graph.\n\nIs it correct way to find shortest path from this graph? and where is wrong in my implementation ? \n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Get the longest path in a graph with OrientDB\r\n                \r\nI'm a newbie with OrientDB and Graph (database and concept). I want to understand how to find the longest path in graph.\n\nThis is my graph:\n\n\nThe shortest path is: 13:0 -> 13:1 -> 13:2 (with sst() or dijkstra())\n\nBut I want to get the longest: 13:0 -> 13:3 -> 13:1 -> 13:2\n\nHow can I do? I must create from scratch a new function?\n\nThanks in advance\n\nLuis\n    ", "Answer": "\r\nYou're asking a solution to a NP-hard problem :)\nSee here.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Source-Independent path in graph\r\n                \r\nSome years ago I read about an algorithm: it labels graph's edges so path from source node X to destination node Y is always the same sequence of labels, independently from which node you select as source X. How is it called?\n\n(I can't remember which kind of conditions should be satisfied by graph)\n\nHere an example (created by me):\n\n\n\n\nVertex 1: Red/Black/Red\nVertex 2: Red/Red/Black\nVertex 3: Red/Red/Black/Green\nVertex 4: Red/Black/Red/Green\n\n\nStarting from any vertex as source you using the path above you always reach the destination vertex. \n    ", "Answer": "\r\nThere is the Road Coloring Problem:\n\nThe problem: Given a directed graph G, colour the edges such that for every vertex, there are a set of instructions that lead to that vertex, from every other vertex.\n\n(link)\n\nIt was recently proved (Trahtman 2009) that if the graph is aperiodic and every vertex has the same out-degree, such a coloring exists:\n\nTheorem: Every finite strongly connected aperiodic directed graph of uniform out-degree has a synchronizing coloring.\n\nTrahtman also give an O(n^3) algorithm for the problem.\n\nYou should search for \"road coloring problem algorithm\" and its variants (for example one can relax the condition to aperiodicity, but I think it's an open problem so far).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Plotting career path in graph\r\n                \r\nI have the dataframe\n\n```\ntest <- structure(list(\n     y2002 = c(\"freshman\",\"freshman\",\"freshman\",\"sophomore\",\"sophomore\",\"senior\"),\n     y2003 = c(\"freshman\",\"junior\",\"junior\",\"sophomore\",\"sophomore\",\"senior\"),\n     y2004 = c(\"junior\",\"sophomore\",\"sophomore\",\"senior\",\"senior\",NA),\n     y2005 = c(\"senior\",\"senior\",\"senior\",NA, NA, NA)), \n              .Names = c(\"2002\",\"2003\",\"2004\",\"2005\"),\n              row.names = c(c(1:6)),\n              class = \"data.frame\")\n> test\n       2002      2003      2004   2005\n1  freshman  freshman    junior senior\n2  freshman    junior sophomore senior\n3  freshman    junior sophomore senior\n4 sophomore sophomore    senior   <NA>\n5 sophomore sophomore    senior   <NA>\n6    senior    senior      <NA>   <NA>\n```\n\n\nand I want to create a graph that should resemble the ugly text art below:\n\n```\nfreshman ---- junior ----------------------\\\n\nfreshman ---- junior --- sophomore -------- senior\n\nsophomore ================================/\n\nsenior ---------------------------------/\n```\n\n\nIn other words, I need to show in a graph the possible paths to \"senior\", giving weights to edges according to the number of cases using that path.\n\nFirst attempt\nThis code generates a graph, but not one similar to the text art above.\n\n```\nlibrary(igraph)\nelist <- lapply(seq_len(nrow(test)), function(i) {\n  x <- as.character(test[i,])\n  x <- unique(na.omit(x))\n  x <- rep(x, each=2)\n  x <- x[-1]\n  x <- x[-length(x)]\n  r <- matrix(x, ncol=2, byrow=TRUE)\n  if (nrow(r) > 0) { r <- cbind(r, i) } else { r <- cbind(r, numeric()) }\n  r\n})\n\nresult <- as.data.frame(do.call(rbind, elist))\nnames(result) <- c(\"vertex\",\"edge\", \"id\")\ncategories <- data.frame(name=c(\"freshman\",\"junior\",\"sophomore\",\"senior\"))\ng <- graph.data.frame(result,directed=T,vertices=categories)\ng <- set.edge.attribute(g, \"weight\", value=runif(ecount(g))*10)\nigraph.par(\"plot.layout\", layout.reingold.tilford)\nplot(g, vertex.label=categories$name, vertex.label.dist=7, \n     edge.width=get.edge.attribute(g,\"weight\"), edge.arrow.size=1.5)\n```\n\n\nResult (not what I wanted)\n\n\n\n**This question is related to this post*\n\n**And this post is a necessary step for solving this question*\n    ", "Answer": "\r\nThis is a completely worked out solution. One has to read the graph bottom up, bearing in mind that each individual is represented as a vertical line that represents their career path. Yes, I did ditch iGraph for this task. \\o/\n\n\n\n```\nrequire(reshape2)\n\nmeltpath <- function(x){\n  require(data.table)\n  x <- melt(data = x, id.vars = 'id', measure.vars = names(x)[-1])\n  names(x) <- c('id','year','category')\n  x$year <- factor(x$year)\n  id <- unique(x$id)\n  idtable <- data.table(id = id, count = 1:length(id))\n  x <- x[order(x$id), ]\n  x <- merge(x, idtable, by='id')\n  return(x)\n}\n\ncarpath <- function(datatable, max_x = max(datatable$count)){\n  require(ggplot2)\n  p = ggplot(datatable, aes(x = count, y = year, fill = category)) + \n    geom_tile() +\n    scale_y_discrete(name = \"year\\n\", \n                     breaks = rev(levels(datatable$year))) + \n    scale_x_continuous(name = \"cumulative count\", \n                      limits = c(0,max_x)) +\n    guides(fill = guide_legend(title=\"Career stage\\n\",\n                               reverse=TRUE)) +\n    theme(panel.grid.major = element_blank(), \n         panel.background = element_blank(), \n         axis.ticks = element_blank(),\n         plot.title = element_text(vjust = 1.2, face=\"bold\", size=20),\n         axis.title.y = element_text(size=15, face=\"bold\"),\n         axis.text.y = element_text(size=15, colour=\"black\"),\n         legend.title = element_text(size = 15),\n         legend.text = element_text(size = 15)) +\n         scale_fill_brewer(palette = \"Dark2\") +\n    ggtitle(\"Career path of individual Students by year\")\n  p\n}\n\ntest <- structure(list(\n  id = 1:6,\n  y2002 = c(\"freshman\",\"freshman\",\"freshman\",\"sophomore\",\"sophomore\",\"senior\"),\n  y2003 = c(\"freshman\",\"junior\",\"sophomore\",\"sophomore\",\"sophomore\",\"senior\"),\n  y2004 = c(\"junior\",\"sophomore\",\"sophomore\",\"senior\",\"senior\",NA),\n  y2005 = c(\"senior\",\"senior\",\"senior\",NA, NA, NA)), \n                  .Names = c(\"id\",\"2002\",\"2003\",\"2004\",\"2005\"),\n                  row.names = c(c(1:6)),\n                  class = \"data.frame\")\n# Grow dataset\ntestg = data.frame()\nfor (i in rownames(test)) {\n  test0 <- test[rep(i, each=abs(floor(rnorm(1)*100))),]\n  testg <- rbind(testg, test0)\n}\ntestg$id <- 1:nrow(testg)\n# Munge\ntest0 <- testg\ntest1 <- melt(data = test0, id.vars = 'id', measure.vars = names(test0)[-1])\nnames(test1) <- c('id','year','category')\ntest1$category[test1$category == 'freshman'] <- 1\ntest1$category[test1$category == 'junior'] <- 2\ntest1$category[test1$category == 'sophomore'] <- 3\ntest1$category[test1$category == 'senior'] <- 4\ntest1$category <- factor(test1$category, levels=1:4, labels = c('1. freshman','2. junior','3. sophomore','4. senior'))\ntest1 <- test1[order(test1$category), ]\ntest1 <- dcast(test1, id ~ year)\ntest1 <- test1[order(test1$'2005',test1$'2004',test1$'2003',test1$'2002'), ]\ntest2 <- meltpath(test1)\ncarpath(test2)\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding shortest path in the dynamic graph\r\n                \r\nHere is my problem: I have a directed weighted graph with a substantial amount of vertices (few thousands), no cycles, in fact, it includes a starting node, a final node and a grid (m*n) between them, where edges can be directed from the left to the right only.\nThe weights of the edges depend on the path in which they are included (for example, if the path includes v.15, then the weights of several edges change).\n\nI tried to get all possible paths and then calculate their final sum post factum, but that turned out to be very inefficient method due to the number of paths. Is there an effective method which allows to find shortest paths in these kind of graphs? Thanks. \n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Heaviest path in special graph (PHP)\r\n                \r\nI have to search the heaviest path in graph what like:\n\n```\n        1\n\n      2  1\n\n    4  5  8\n\n  2  2  3  4\n```\n\n\n(1,1,8,4 in this example)\nThe graph like this ever.\nSo it is an element who has two children except lowermosts. Who has children they has a common child e.g. (in above graph) 5 (in 3. row) is a common child to 2 and 1 (in 2. row.).\nSo these are nodes and not edges and them have a value.\n\nI wrote an algorithm in php:\n\n```\nclass node{\n    public $children = array();\n    public $value;\n    public $_heavier = null;\n    public $_value = null;\n\n    function __construct($value, $children) {\n        $this->value = $value;\n        $this->children = $children;\n    }\n\n    function heavier() {\n        if (null !== $this->_value) {\n            echo 'b' . $this->value . '<br>';\n            return $this->_value;\n        }\n\n        $val = $this->value;\n\n        if ($this->children[0]) {\n            $c1 = $this->children[0]->heavier();\n            $c2 = $this->children[1]->heavier();\n\n            if ($c1 > $c2) {\n                $this->_heavier = 0;\n                $val += $c1;\n            } else {\n                $this->_heavier = 1;\n                $val += $c2;\n            }\n        }\n\n        echo 'a' . $this->value . '<br>';\n        $this->_value = $val;\n\n        return $val;\n    }\n\n    function getPath() {\n        if (null !== $this->_heavier) {\n            echo $this->children[$this->_heavier]->getPath();\n        }\n        return $this->value;\n    }\n}\n\n$exists = array();\nfunction a($row, $item) {\n    global $input, $exists;\n\n    $nextRow = $row + 1;\n    $child1No = $item;\n    $child2No = $item + 1;\n\n    $child1 = null;\n    if (isset($input[$nextRow][$child1No])) {\n        $child1 = a($nextRow, $child1No);\n    }\n\n    $child2 = null;\n    if (isset($input[$nextRow][$child2No])) {\n        $child2 = a($nextRow, $child2No);\n    }\n\n    if (!isset($exists[$row][$item])) {\n        $obj = new node($input[$row][$item], array($child1, $child2));\n        $exists[$row][$item] = &$obj;\n    } else {\n        $obj = &$exists[$row][$item];\n    }\n    return $obj;\n}\n\n$nodes = a(0, 0);\n$nodes->heavier();\necho $nodes->getPath();\necho '<br>';\n```\n\n\nIt is works, but too much time.\nHow to speed up?\n\nThx.\n    ", "Answer": "\r\nYour algorithm is the most optimal possible - you take ```\nO(n)```\n time where ```\nn```\n is the number of nodes. It can easily be proved that nothing faster can be done.\n\nI think the slow part of your algorithm is the ```\necho```\n-ing - this is a very heavy operation and might slow your algorithm quite a bit as you ```\necho```\n too much.\n\nPS: By the way on how many nodes you execute your algorithm? Is it really on only 10?\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Sum paths in weighed graph\r\n                \r\nI have a bi-directional graph, similar to this: https://gremlify.com/6zxjsbstb5f, where out edges have a weighted property.\nThere is a closeness relationship between ```\narticles```\n, the ```\nweight```\n total of all paths between 2 ```\narticles```\n\nSo far I've been able to get the paths between articles, but the weighting is only the ```\nweight```\n value of the unique path. I would like the aggregate (sum) ```\nweight```\n of all paths between the starting ```\narticle```\n from the set returned by: ```\nrepeat(outE().inV().simplePath()).until(hasLabel('article'))```\n\n```\ng.V('70679').\n  repeat(outE().inV().simplePath()).\n  until(hasLabel('article')).as('a').\n  path().as('p').\n  map(unfold().coalesce(values('weight'),constant(0)).sum()).as('weighting').\n  select('weighting', 'p')\n```\n\nSteps to create the sample graph (taken from Gremlify)\n```\ng.addV('article').as('1').\n  addV('brand').as('2').\n  addV('article').as('3').\n  addV('category').as('4').\n  addV('zone').as('5').\n  addV('article').as('6').\n  addV('article').as('7').\n  addE('zone').from('1').to('5').  property('weight', 0.1).\n  addE('category').from('1').to('4').property('weight', 0.5).\n  addE('brand').from('1').to('2').property('weight', 0.8).\n  addE('article').from('2').to('6').\n  addE('article').from('2').to('1').\n  addE('article').from('2').to('3').  \n  addE('zone').from('3').to('5').property('weight', 0.1).  \n  addE('category').from('3').to('4').property('weight', 0.3).\n  addE('brand').from('3').to('2').property('weight', 0.4).\n  addE('article').from('4').to('1').\n  addE('article').from('4').to('3').\n  addE('article').from('5').to('6').\n  addE('article').from('5').to('7').\n  addE('article').from('5').to('1').\n  addE('article').from('5').to('3').\n  addE('zone').from('6').to('5').property('weight', 0.1).\n  addE('brand').from('6').to('2').property('weight', 0.6).\n  addE('zone').from('7').to('5').property('weight', 0.1)   \n```\n\nI've been able to get this query which is close to what we require, where ```\n8630```\n is an article Id in the graph\n```\ng.V('8630')\n    .repeat(outE().inV().simplePath())\n    .until(hasLabel('article')).as('foundArticle')\n    .path()\n    .map(unfold().coalesce(values('weight'), constant(0)).sum()).as('pathWeight')\n    .group().by(select('foundArticle').id()).as('grouping')\n```\n\nThis produces results similar to:\n```\n[\n  {\n    \"8634\": [0.1, 0.5, 0.8]\n  },\n  {\n    \"8640\": [0.1, 0.8]\n  },\n  {\n    \"8642\": [0.1]\n  }\n]\n```\n\nMore desirable would be a result set similar to:\n```\n[\n  {\n    \"8634\": 1.4\n  },\n  {\n    \"8640\": 0.9\n  },\n  {\n    \"8642\": 0.1\n  }\n]\n```\n\n    ", "Answer": "\r\nJust to make it easier I gave each article a custom ID. The ID ```\nA1```\n corresponds to the example output you showed for ID ```\n8630```\n.\n```\ng.addV('article').as('1').property(id,'A1').\n  addV('brand').as('2').\n  addV('article').as('3').property(id,'A2').\n  addV('category').as('4').\n  addV('zone').as('5').\n  addV('article').as('6').property(id,'A3').\n  addV('article').as('7').property(id,'A4').\n  addE('zone').from('1').to('5').  property('weight', 0.1).\n  addE('category').from('1').to('4').property('weight', 0.5).\n  addE('brand').from('1').to('2').property('weight', 0.8).\n  addE('article').from('2').to('6').\n  addE('article').from('2').to('1').\n  addE('article').from('2').to('3').  \n  addE('zone').from('3').to('5').property('weight', 0.1).  \n  addE('category').from('3').to('4').property('weight', 0.3).\n  addE('brand').from('3').to('2').property('weight', 0.4).\n  addE('article').from('4').to('1').\n  addE('article').from('4').to('3').\n  addE('article').from('5').to('6').\n  addE('article').from('5').to('7').\n  addE('article').from('5').to('1').\n  addE('article').from('5').to('3').\n  addE('zone').from('6').to('5').property('weight', 0.1).\n  addE('brand').from('6').to('2').property('weight', 0.6).\n  addE('zone').from('7').to('5').property('weight', 0.1) \n```\n\nThe query you had produced, was actually very close to having the result you wanted. I just added a second ```\nby```\n step to the ```\ngroup```\n to sum up the values.\n```\ng.V('A1').\n  repeat(outE().inV().simplePath()).\n  until(hasLabel('article')).as('foundArticle').\n  path().\n  map(unfold().coalesce(values('weight'), constant(0)).sum()).as('pathWeight').\n  group().\n    by(select('foundArticle').id()).\n    by(sum()).\n  unfold()\n```\n\nWhich yields\n```\n{'A2': 1.4}\n{'A3': 0.9}\n{'A4': 0.1}\n```\n\nI think your query can also be simplified. If I come up with something simpler I will add it to this answer,\nUPDATED\nHere's a version of the query that uses ```\nsack```\n and avoids needing to collect the ```\npath```\n and post process it.\n```\ng.withSack(0).\n  V('A1').\n  repeat(outE().sack(sum).by(coalesce(values('weight'),constant(0))).\n         inV().simplePath()).\n  until(hasLabel('article')).\n  group().\n    by(id()).\n    by(sack().sum()).\n  unfold()\n```\n\nwhich again yields\n```\n{'A2': 1.4}\n{'A3': 0.9}\n{'A4': 0.1}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Is there any algorithm which can find all critical paths in DAG?\r\n                \r\nI'm writing a paper about some graph algorithms (which are used in CPM), and I need name of some algorithm which can find all critical paths in a DAG. I have looked at Floyd - Warshall algorithm, and I don't know if it could be helpful for finding all of critical paths in a DAG. If critical path and longest path are the same thing, then Floyd - Warshall algorithm could be modified in a way of finding all longest, not shortest, paths in a graph. And even if it can be modified, is there any better way of finding all critical paths?\n    ", "Answer": "\r\nFor finding one critical path, Floyd--Warshall with minus weights is markedly inferior to the following folklore (?) algorithm, which computes in linear time the length of the longest path from each vertex.\n\n```\nfor vertices v in topological order (sinks before sources):\n    set longest-path(v) := the maximum of 0 and length(v->w) + longest-path(w) for all arcs v->w\n```\n\n\nThe Floyd--Warshall version would set ```\nlongest-path(v) := the maximum of -distance(v, w) for all vertices w```\n after computing the ```\ndistance```\n array.\n\nTo find all of the critical paths, compute the ```\nlongest-path```\n array and, retaining only those arcs ```\nv->w```\n such that ```\nlongest-path(v) = length(v->w) + longest-path(w)```\n, enumerate all paths in the residual DAG using recursion.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Access sharepoint Directory using path in graph api\r\n                \r\nAs I have tried to fetch the data of a directory using the path in the the graph api as shown below\nhttps://graph.microsoft.com/v1.0/sites/{site-id}/drive/root:/{directory or file path}\nand got the following error :\nimage\n    ", "Answer": "\r\nYou can try following api\n```\nGET /drives/{drive-id}/root:/{item-path}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "What is a minimal path in a graph?\r\n                \r\nIn graph theory, what is the distinction between minimal distance (which Dijkstra's algorithm finds), and minimal path (which I'm not sure what it is)?\n    ", "Answer": "\r\nMinimal path is the set of edges which when traversed cover the least amount of distance between two edges.  Minimal distance is the sum of the distance between the edges of a minimal path.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding paths in a Undirected Graph\r\n                \r\nConsider the following graph:\n\n\n\nRepresented by the following array structure:\n\n```\n$graph = array\n(\n    'a' => array(),\n    'b' => array('a'),\n    'c' => array('a', 'b'),\n    'd' => array('a'),\n    'e' => array('d'),\n    'f' => array('a', 'b', 'c', 'd'),\n    'g' => array('d'),\n    'h' => array('c'),\n    'i' => array('c', 'g'),\n    'j' => array(),\n);\n```\n\n\nWhat is the most efficient algorithm to find all paths (not just the shortest one) from node X to node Y in either direction without repeating nodes? For instance, the paths that lead from node ```\nC```\n to node ```\nA```\n are:\n\n```\nC --> A\nC --> B --> A\nC --> F --> A\nC --> F --> B --> A\nC --> F --> D --> A\nC --> I --> G --> D --> A\n```\n\n\nFinding all the paths using the parent nodes of node ```\nX```\n (```\nA```\n and ```\nB```\n, in the example for node ```\nC```\n) is trivial, but I am having a really hard time traversing the nodes in a descendant / hybrid direction.\n\nCan someone help me out?\n\n\n\nUPDATE: Following @JackManey advice, I tried to port IDDFS (Iterative Deepening Depth-First Search) based on the Wikipedia pseudo-code and this is more or less what my code looks like:\n\n```\n$graph = directed2Undirected($graph);\n\nfunction IDDFS($root, $goal) {\n    $depth = 0;\n\n    while ($depth <= 2) { // 2 is hard-coded for now\n        $result = DLS($root, $goal, $depth);\n\n        if ($result !== false) {\n            return $result;\n        }\n\n        $depth++;\n    }\n}\n\nfunction DLS($node, $goal, $depth) {\n    global $graph;\n\n    if (($depth >= 0) && ($node == $goal)) {\n        return $node;\n    }\n\n    else if ($depth > 0) {\n        foreach (expand($node, $graph) as $child) {\n            return DLS($child, $goal, $depth - 1);\n        }\n    }\n\n    else {\n        return false;\n    }\n}\n```\n\n\nAnd here are the helper functions used by it:\n\n```\nfunction directed2Undirected($data) {\n    foreach ($data as $key => $values) {\n        foreach ($values as $value) {\n            $data[$value][] = $key;\n        }\n    }\n\n    return $data;\n}\n\nfunction expand($id, $data, $depth = 0) {\n    while (--$depth >= 0) {\n        $id = flatten(array_intersect_key($data, array_flip((array) $id)));\n    }\n\n    return array_unique(flatten(array_intersect_key($data, array_flip((array) $id))));\n}\n\nfunction flatten($data) {\n    $result = array();\n\n    if (is_array($data) === true) {\n        foreach (new RecursiveIteratorIterator(new RecursiveArrayIterator($data)) as $value) {\n            $result[] = $value;\n        }\n    }\n\n    return $result;\n}\n```\n\n\nCalling the above yields weird or incomplete results:\n\n```\nvar_dump(IDDFS('c', 'a')); // a -- only 1 path?\nvar_dump(IDDFS('c', 'd')); // NULL -- can't find this path?!\n```\n\n\nI think I'm overlooking something from the pseudo-code, but I'm not sure what it is.\n\n\n\nI also tried this DFS class that was recommended in another question, although it seems to always find one path from node X to node Y, I can't get it to return all paths (demo for ```\nC```\n -> ```\nA```\n and ```\nC```\n -> ```\nD```\n).\n\n\n\nSince I don't need to know the path actually taken, only how many paths exist that require ```\nn```\n number of steps to get from node X to node Y, I came up with this function (uses ```\ndirected2Undirected```\n above):\n\n```\n$graph = directed2Undirected($graph);\n\nfunction Distance($node, $graph, $depth = 0) {\n    $result = array();\n\n    if (array_key_exists($node, $graph) === true) {\n        $result = array_fill_keys(array_keys($graph), 0);\n\n        foreach (expand($node, $graph, $depth - 1) as $child) {\n            if (strcmp($node, $child) !== 0) {\n                $result[$child] += $depth;\n            }\n        }\n\n        $result[$node] = -1;\n    }\n\n    return $result;\n}\n\nfunction expand($id, $data, $depth = 0) {\n    while (--$depth >= 0) {\n        $id = flatten(array_intersect_key($data, array_flip((array) $id)));\n    }\n\n    // no array_unique() now!\n    return flatten(array_intersect_key($data, array_flip((array) $id)));\n}\n```\n\n\nFor ```\nDistance('c', $graph, 0)```\n, ```\nDistance('c', $graph, 1)```\n and ```\nDistance('c', $graph, 2)```\n this correctly returns the sum of the distance between ```\nC```\n and any other node. The problem is, with ```\nDistance('c', $graph, 3)```\n (and higher) it start repeating nodes and returning wrong results:\n\n```\nArray\n(\n    [a] => 12\n    [b] => 9\n    [c] => -1\n    [d] => 9\n    [e] => 3\n    [f] => 12\n    [g] => 3\n    [h] => 3\n    [i] => 6\n    [j] => 0\n)\n```\n\n\nThe index ```\na```\n should only be 6 (3 + 3), since the only ways I can get from ```\nC```\n to ```\nA```\n using 3 steps are:\n\n```\nC --> F --> B --> A\nC --> F --> D --> A\n```\n\n\nYet, it seems to be considering two (only?) additional paths that repeat nodes:\n\n```\nC --> A --> C --> A\nC --> B --> C --> A\nC --> F --> C --> A\nC --> H --> C --> A\nC --> I --> C --> A\n```\n\n\nOf course, index ```\na```\n isn't the only wrong one. The problem seems to be ```\nexpand()```\n but I'm not sure how to fix it, ```\narray_diff(expand('c', $graph, $i), expand('c', $graph, $i - 2))```\n seems to fix this particular error, but that ain't a proper fix... Help?\n\n\n\n\nagain, so you don't have to scroll\n    ", "Answer": "\r\nIn general, you can do a depth-first search or a breadth-first search, although neither one is superior to the other (since it's easy to come up with examples for which one is superior to the other).\n\nEdit:  Upon rereading the question and thinking a bit, since you want all paths from ```\nC```\n to ```\nA```\n, a DFS starting at ```\nC```\n would probably make the most sense.  Along the way, you'd have to store sequences of edges and throw sequences away if they don't end up at ```\nA```\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "BFS traversal of all paths in graph using adjacency list\r\n                \r\nI am currently trying to traverse all paths from source to destination in a graph which uses adjacency matrix. I have been trying to do it in BFS way.Thanks for the help. I am getting only one path. How do I get to print other paths as well ?\n\n```\npublic class AllPossiblePaths {\n    static int v;\n    static ArrayList<Integer> adj[];\n\n    public AllPossiblePaths(int v) {\n        this.v = v;\n        adj = new ArrayList[v];\n        for (int i = 0; i < v; i++) {\n            adj[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public static void addEdge(int u, int v) {\n        adj[u].add(v);\n    }\n\n    public static void findpaths(int source, int destination) {\n        LinkedList<ArrayList<Integer>> q = new LinkedList<>();\n        boolean visited[] = new boolean[v];\n\n        LinkedList<Integer> queue = new LinkedList<Integer>();\n\n        queue.add(source);\n        visited[source] = true;\n        ArrayList<Integer> localPath = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            // Dequeue a vertex from queue and print it\n            int src = queue.poll();\n            if (!localPath.contains(src)) {\n                localPath.add(src);\n            }\n            if (src == destination) {\n                System.out.println(localPath);\n                localPath.remove(localPath.size() - 1);\n                visited[src] = false;\n            }\n\n            Iterator<Integer> i = adj[src].listIterator();\n            while (i.hasNext()) {\n                int n = i.next();\n                if (!visited[n]) {\n                    queue.add(n);\n                }\n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nUsing the following class you can run a BFS to find a single path (```\nfindPath```\n) or find multiple paths (```\nfindAllPaths```\n). See comments: \n\n```\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class AllPossiblePaths {\n\n    private  boolean[] visited;\n    //keep track of nodes already included in a path\n    private  boolean[] includedInPath;\n    private LinkedList<Integer> queue;\n    private int numberOfNodes;\n    private List<Integer>[] adj;\n    //to find a path you need to store the path that lead to it\n    private List<Integer>[] pathToNode;\n\n    public AllPossiblePaths(int numberOfNodes) {\n\n        this.numberOfNodes = numberOfNodes;\n        adj = new ArrayList[numberOfNodes];\n        pathToNode = new ArrayList[numberOfNodes];\n\n        for (int i = 0; i < numberOfNodes; i++) {\n            adj[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public AllPossiblePaths addEdge(int from, int to) {\n        adj[from].add(to);\n        //unless unidirectional: //if a is connected to b\n        //than b should be connected to a\n        adj[to].add(from);\n        return this; //makes it convenient to add multiple edges\n    }\n\n    public void findPath(int source, int destination) {\n\n        System.out.println(\"------------Single path search---------------\");\n        initializeSearch(source);\n\n        while (!queue.isEmpty()) {\n            // Dequeue a vertex from queue and print it\n            int src = queue.poll();\n            visited[src] = true;\n\n            if (src == destination) {\n                System.out.println(\"Path from \"+source+\" to \"\n                        + destination+ \" :- \"+ pathToNode[src]);\n                break; //exit loop if target found\n            }\n\n            Iterator<Integer> i = adj[src].listIterator();\n            while (i.hasNext()) {\n                int n = i.next();\n                if (! visited[n] && ! queue.contains(n)) {\n                    queue.add(n);\n                    pathToNode[n].addAll(pathToNode[src]);\n                    pathToNode[n].add(src);\n                }\n            }\n        }\n    }\n\n    public void findAllpaths(int source, int destination) {\n\n        System.out.println(\"-----------Multiple path search--------------\");\n        includedInPath = new boolean[numberOfNodes];\n        initializeSearch(source);\n        int pathCounter = 0;\n\n        while(! allVisited() && !queue.isEmpty()) {\n\n            while (!queue.isEmpty()) {\n                // Dequeue a vertex from queue and print it\n                int src = queue.poll();\n                visited[src] = true;\n\n                if (src == destination) {\n\n                    System.out.println(\"Path \" + ++pathCounter + \" from \"+source+\" to \"\n                            + destination+ \" :- \"+ pathToNode[src]);\n                    //mark nodes that are included in the path, so they will not be included\n                    //in any other path\n                    for(int i=1; i < pathToNode[src].size(); i++) {\n                        includedInPath[pathToNode[src].get(i)] = true;\n                    }\n                    initializeSearch(source); //initialize before restarting\n                    break; //exit loop if target found\n                }\n\n                Iterator<Integer> i = adj[src].listIterator();\n                while (i.hasNext()) {\n                    int n = i.next();\n                    if (! visited[n] && ! queue.contains(n)\n                            && ! includedInPath[n] /*ignore nodes already in a path*/) {\n                        queue.add(n);\n                        pathToNode[n].addAll(pathToNode[src]);\n                        pathToNode[n].add(src);\n                    }\n                }\n            }\n        }\n    }\n\n    private void initializeSearch(int source) {\n\n        queue = new LinkedList<>();\n        queue.add(source);\n        visited = new boolean[numberOfNodes];\n        for (int i = 0; i < numberOfNodes; i++) {\n            pathToNode[i]= new ArrayList<>();\n        }\n    }\n\n    private boolean allVisited() {\n\n        for( boolean b : visited) {\n            if(! b ) return false; \n        }\n        return true;\n    }\n}\n```\n\n\nFor testing it, consider this graph:\n\n\n\nRun test:\n\n```\npublic static void main(String[] args){\n\n    AllPossiblePaths app = new AllPossiblePaths(6);\n    app.addEdge(0, 4)\n    .addEdge(0, 1)\n    .addEdge(1, 2)\n    .addEdge(1, 4)\n    .addEdge(4, 3)\n    .addEdge(2, 3)\n    .addEdge(2, 5)\n    .addEdge(3, 5);\n\n    app.findPath(0,5);\n    app.findPath(5,0);\n    app.findAllpaths(0,5);\n}\n```\n\n\noutput:\n\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Build a random Hamiltonian path in a graph\r\n                \r\nIn my code I find hamiltonian paths in a graph to solve another problem.\nI am now testing my code and I want to take a general graph without edges and construct a hamiltonian path in it. On that graph (that now has edges that form a hamiltonian path) I will add random edges according to Erdős–Rényi model.\nThis way I can see how fast will my code handle graphs with variant amount of edges.\nHow a valid graph I can handle look like: \n\nFor every cell in the matrix I add a vertex.\nVertices u and v can be connected if they are adjacent in the matrix.\n\nAnd my goal is to generate a random valid graph with a hamiltonian path.\n\n\nThe problem is that I can't find an efficient way to construct a hamiltonian path without recurring all possible paths and finding one that passes through all vertex once.\n\nFor example:\n```\nThe matrix:        Possible path:    Not possible:\n-------------       \n| 1 | 2 | 3 |        1 - 2 - 3         1 - 2 - 3 _\n-------------                |                    |\n| 4 | 5 | 6 |        4 - 5 - 6         4 - 5 - 6  |\n-------------        |                 |          |\n| 7 | 8 | 9 |        7 - 8 - 9         7 - 8 - 9_/\n-------------       \n```\n\nThe second path is not possible because 3 and 9 are not adjacent in the matrix.\nIs there a way to construct a hamiltonian path in linear time given the matrix alone?\n    ", "Answer": "\r\n```\npackage hamiltonian_path;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\n\n\n\npublic class Main {\n\n    int[] solution;\n    HashMap<Integer, List<Integer>> candidates;\n\n    public static void main(String args[]) {\n        Main main = new Main();\n        main.solution = new int[10];//stores the solution; index 0 is not used, i will use indexes from 1 to 9\n        main.candidates = new HashMap<Integer, List<Integer>>();//for each position (1 to 9) in the solution, stores a list of candidate elements for that position\n\n        List<Integer> oneToNine = new LinkedList<Integer>(Arrays.asList(1,2,3,4,5,6,7,8,9));\n        /*\n         * because no solution can start from matrix elements 2,4,6 or 8, \n         * for the sake of optimization, the above list can be written as\n         * Arrays.asList(1,3,5,7,9)\n         * the way it is right now is useful to follow the way the program \n         * does the backtracking, when it accidentally starts with either 2,4,6 or 8\n         */\n        Collections.shuffle(oneToNine);//a random permutation of the list\n        main.candidates.put(1, oneToNine);\n        main.buildSol(1);\n\n    }\n\n    //backtracking\n    public void buildSol(int k)\n    {\n        if(k==10)\n        {\n            System.out.print(\"the solution is \");\n            printSolution();\n            return;\n        }\n\n        List<Integer> candList = candidates.get(k);\n        if(candList.isEmpty())\n        {\n            cleanSolution(k);\n            buildSol(k-1); //if no candidates for current step, go one step back\n        }\n        else\n        {\n            int firstCandidate = candList.get(0);\n            candList.remove(0);\n            candidates.put(k, candList);\n            solution[k] = firstCandidate;//for the position k in the solution, pick the first element in the candidates list\n\n            List<Integer> neighbors = getNeighbors(solution[k]);\n            List<Integer> prevElems = getPreviousElementsInSolution(k);\n            candidates.put(k+1, generateCandidates(neighbors, prevElems));//while being at step k, generate candidate elements for step k+1\n            //these candidates are the neighbors (in the matrix) of the current element (solution[k]), \n            //which are not already part of the solution at an earlier position\n\n            System.out.println(\"step \"+k);\n            System.out.print(\"partial solution: \");\n            printSolution();\n            System.out.println();\n\n\n            buildSol(k+1);//go to next step\n        }\n    }\n\n\n\n    //candidates are those elements which are neighbors, and have not been visited before\n    public List<Integer> generateCandidates(List<Integer> neighbors, List<Integer> previousElements) \n    {\n        List<Integer> cnd = new ArrayList<Integer>();\n        for(int i=0;i<neighbors.size();i++)\n            if(!previousElements.contains(neighbors.get(i)))\n                cnd.add(neighbors.get(i));\n\n        return cnd;\n    }\n\n    //get the set of previous elements in the solution, up to  solution[k]\n    public List<Integer> getPreviousElementsInSolution(int step)\n    {\n        List<Integer> previousElements = new ArrayList<Integer>();\n        for(int i=1; i<=step-1;i++)\n            previousElements.add(solution[i]);\n\n        return previousElements;\n    }\n\n    //get neighbors of the matrix element which corresponds to solution[k]\n\n    public  List<Integer> getNeighbors(int element) {\n\n        List<Integer> neighboursList = new ArrayList<Integer>();\n\n        switch (element) {\n\n            case 1: neighboursList = Arrays.asList(2, 4);\n                    break;\n\n            case 2: neighboursList = Arrays.asList(1, 3, 5);\n                    break;\n\n            case 3: neighboursList = Arrays.asList(2, 6);\n                    break;\n\n            case 4: neighboursList = Arrays.asList(1, 5, 7);\n                    break;\n\n            case 5: neighboursList = Arrays.asList(2, 4, 6, 8);\n                    break;\n\n            case 6: neighboursList = Arrays.asList(3, 5, 9);\n                    break;\n\n            case 7: neighboursList = Arrays.asList(4, 8);\n                    break;\n\n            case 8: neighboursList = Arrays.asList(5, 7, 9);\n                    break;\n\n            case 9: neighboursList = Arrays.asList(6, 8);\n                    break;\n\n            default: neighboursList = new ArrayList<Integer>();\n                    break;\n        }\n\n        return neighboursList;\n    }\n\n\n\n    public void printSolution()\n    {\n        for(int i=1;i<solution.length;i++)\n            System.out.print(solution[i]+\" \");\n    }\n\n    public void cleanSolution(int k)\n    {\n        for(int i=k;i<solution.length;i++)\n            solution[i]=0;\n    }\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "graph path in prolog\r\n                \r\nI've made the rules to obtain a path of a graph with the edges defined as follows:\n\n```\ngraph(a,b).\ngraph(a,a).\ngraph(b,c).\n```\n\n\nbut now I need to do it when the facts being, for example:\n\n```\ngraph(a,[a,b,e]).\ngraph(b,[c,d]).\ngraph(d,[]).\n```\n\n\nI had this:\n\n```\npath(Origin, Dest, List) :- path(Origin, Dest, List, [Origin]).\npath(X, X, List, Temp) :- reverse(Temp, List).\npath(Origin, Dest, List, Temp) :- graph(Origin, Inter),\n                                 not(member(Inter, Temp)),\n                                 path(Inter, Dest, List, [Inter|Temp]).\n```\n\n\nand I know that problem is in graph(Origin, Inter), but I don't know how to tweak it so it can go inside the list, I've tried ```\ngraph(Origin, [Inter|_])```\n but obviously it just checks the first one. Any help (even if it's not code) would be greatly appreciated.\n    ", "Answer": "\r\nAssuming directed graphs:\n\n```\nedge(X,Y) :- graph(X,Nodes), member(Y,Nodes).\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Python method for returning all possible paths in a graph class (DAG)\r\n                \r\nI have a question surrounding find all the paths in a directed acyclic graph from a source to a destination. For this, I made two custom classes that act as Node and Graph.\nThe Graph class reads a proximity matrix to create the nodes and add the connections in a dictionary. \nAfter this, I want to be able to find all the possible paths from a source to a destination using a recursion and returning them with a generator but I am having problems with the recursive call, as its not properly navigating the paths.\nThe AllPathUtils method is not moving past the first method call. This is pretty much my code and I would really appreciate if one of you could point the dumb mistake that Im missing.\nAt the bottom I will leave some example inputs, so you can check the exact behaviour. Thanks a lot.\n```\nclass Node:\n    def __init__(self, identity):\n       self.name = identity\n\n    def get_name(self):\n        return self.name\n\n    def __hash__(self):\n        return hash(self.get_name())\n\n    def __eq__(self, other):\n       return self.get_name() == other.get_name()\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __str__(self):\n        return f\"Node -> {self.get_name()}\"\n\n    def __repr__(self):\n        return f\"Node -> {self.get_name()}\"\n\n\nclass Graph:\n    def __init__(self, matrix_graph):\n        self.graph = {}\n        self.V = len(matrix_graph)\n        i = 0\n        for node in matrix_graph:\n            x = Node(i)\n            self.graph[x] = []\n            j = 0\n            for adj in node:\n                if matrix_graph[i][j] != 0:\n                    self.graph[x].append(Node(j))\n                j += 1\n            i += 1\n\n    def AllPathsUtil(self, u, d, visited, path):\n        visited[u.get_name()] = True\n        path.append(u)\n        if u == d:\n            yield path\n        else:\n            for i in self.graph[u]:\n                if visited[i.get_name()] is False:\n                    self.AllPathsUtil(i, d, visited, path)\n        path.pop()\n        visited[u.get_name()] = False\n\n    def printAllPaths(self, s, d):\n        visited = [False] * (self.V)\n        path = []\n        for el in self.AllPathsUtil(s, d, visited, path):\n            print(el)\n\n\n\nmatrix2 = [[0, 1, 0, 0, 0, 0],\n       [0, 0, 1, 1, 0, 0],\n       [0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0]]\n\nz = Graph(matrix2)\nz.printAllPaths(Node(0), Node(4))\n```\n\n    ", "Answer": "\r\nFor anyone having the same problem as me, the mistake was that I needed to yield from the recursive call, otherwise it wouldnt work.\nThis was the problematic line:\n```\nself.AllPathsUtil(i, d, visited, path)\n```\n\nWhile this is the correct one:\n```\nyield from self.AllPathsUtil(i, d, visited, path)\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find 2 vertex-disjoint paths in a graph with both paths having same source but different destination?\r\n                \r\nLet's consider this graph:\n\nLet's say\nI want first path with source as A, destination as H and\nI want second path with source as A, destination as D.\nI am not able to apply suurballe algorithm as it works for paths with same source and same destination only.\nExpected O/p is first path => A-E-F-G-H, second path => A-B-C-D. These two are vertex disjoint paths.\nHow to calculate 2 vertex disjoint paths in this situation?\n    ", "Answer": "\r\nAn approach that works quite well for many problems is to think about how to transform it into one you can solve.\nIn this case: You already know the Suurballe algorithm that can solve the problem of vertex disjoint paths if the target vertex of both is the same.\nSo to solve your problem, you can just add a vertex X to your graph and connect D and H to it. Then execute Suurballe's algorithm with start A and target X and remove X from the end of the returned paths. As the only way to reach X is via D and H, those must be the last ones in the path before X.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in Graph with time limit\r\n                \r\nLet's say I have a graph ```\nG```\n with ```\nN```\n vertices and ```\nM```\n edges. Each edge has its length and time (let's say in minutes), which it takes to traverse that edge. I need to find the shortest path in the graph between the vertices ```\n1```\n and ```\nN```\n, which is performed in under ```\nT```\n minutes time.\nSince time is the more valuable resource and we care about traversing the graph in time, and only then with minimal length, I decided to use Dijkstra's algorithm, for which I considered the time of each edge as its weight. I added a vector to store the durations. Thus, the algorithm returns the least time, not the least length. A friend suggested this addition to my code:\n```\nint answer(int T) {\n    int l = 1;\n    int r = M; // a very big number\n    int answer = M;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        int time = dijkstra(mid); // the parameter mid serves as an upper bound for dijkstra and I relax the edge only if its length(not time) is less than mid\n        if (time <= T) {\n            answer = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    if (best == M) {\n        return -1; // what we return in case there is no path in the graph, which takes less than T minutes\n    }\n    return answer;\n}\n```\n\nHere is the ```\ndijkstra```\n method (part of class ```\nGraph```\n with ```\nstd::unordered_map<int, std::vector<Node>> adjacencyList member```\n):\n```\nint dijkstra(int maxLength) {\n        std::priority_queue<Node, std::vector<Node>, NodeComparator> heap;//NodeComparator sorts by time of edge\n        std::vector<int> durations(this->numberOfVertices + 1, M);\n        std::set<int> visited;\n        // duration 1->1 is 0\n        durations[1] = 0;\n        heap.emplace(1, 0, 0);\n        while (!heap.empty()) {\n            int vertex = heap.top().endVertex;\n            heap.pop();\n            // to avoid repetition\n            if (visited.find(vertex) != visited.end()) {\n                continue;\n            }\n            for (Node node: adjacencyList[vertex]) {\n                // relaxation\n                if (node.length <= maxLength && durations[node.endVertex] > durations[vertex] + node.time) {\n                    durations[node.endVertex] = durations[vertex] + node.time;\n                    heap.emplace(node.endVertex, durations[node.endVertex], 0);\n                }\n            }\n            // mark as visited to avoid going through the same vertex again\n            visited.insert(vertex);\n        }\n        // return path time between 1 and N bounded by maxKilograms\n        return durations.back();\n    }\n```\n\nThis seems to work but seems inefficient to me. To be frank, I don't understand his idea completely. It appears to me like randomly trying to find the best answer(because nobody said that the time of an edge is tied proportionally to its length). I tried searching for ```\nshortest path in graph with time limit```\n but I found algorithms that find the fastest paths, not the shortest with a limit. Does an algorithm for this even exist? How can improve my solution?\n    ", "Answer": "\r\nWhat is this?\n```\nint time = dijkstra(mid);\n```\n\nIt certainly isnt an implementation of the Dijkstra algorithm!\nThe Dijkstra algorithm requires the starting node and returns THE shortest path from the starting node to every other.\nYou are going to need a function that returns all the distinct paths between start and end nodes that take less than T.  Then you can search them for the one that is cheapest.\n```\nSearch graph for all distinct paths from start to end\nDiscard paths that take more then T\nSelect cheapest path.\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding Paths in Directed Graph with Greedy Approach With At Least K Nodes and a Given Starting Node\r\n                \r\nI have a non-weighted DAG graph. What I want to do is to find \nall the paths in a greedy way and the path should contain at least K nodes,\nand a given starting node.\n\nIs there any existing algorithm/implmentation that does that?\n\nFor example I have the following graph:\n\n```\nmy %graph =(36=>[31],31=>[30,22],30=>[20],22=>[20,8],20=>[1],8=>[5],5=>[2],2=>[1,20]);\n```\n\n\n\n\nSo if I define K=5 and starting node 36, I hope to get:\n\n```\n{1,20,22,31,36}\n{1,20,2,5,8,22,31,36}\n{1,20,30,31,36}\n{1,2,5,8,22,31,36}\n```\n\n    ", "Answer": "\r\nThat's not very dificult.\n\n```\nuse warnings;\nuse strict;\nuse Data::Dumper;\n\nmy @stack = ();\n\nmy %graph = (36=>[31],31=>[30,22],30=>[20],22=>[20,8],\n             20=>[1],8=>[5],5=>[2],2=>[1,20]);\n\n# add begin to stack\npush(@stack, { node => 36, way => [36] });\n\nwhile (@stack > 0) {\n\n    my $node = pop(@stack);\n\n    # way\n    my $way = $node->{way};\n\n    # complete way\n    if ($node->{node} == 1) {\n        print Dumper($node->{way});\n    }\n\n    # add next nodes\n    my $nextArr = $graph{$node->{node}};\n\n    for my $nextNod (@$nextArr) {\n        # add way\n        my @tmpWay = @$way;\n        push(@tmpWay, $nextNod);\n\n        # add to stack\n        push(@stack, { node => $nextNod, way => \\@tmpWay });\n    }\n}\n```\n\n\nSo you can test, if node the end node and save all path (ways) out.\nYou must optimase this script\n\nedit\n\nAdd endless save protection.\n\nedit 2\n\nYou don't need a endless protection. Add shift to pop, then you search more than one way to end note :)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Recursion find all paths in graph matrix DFS\r\n                \r\nI'm trying to implement a two functions based on Depth First Search using a recursion method. I'm ultimately trying to compare the runtime against warshall's algorithm (which I already have working). When I print my matrix it's off by a couple off paths.\n\nThe recursion is what may be throwing me off, it's my weakness. Because of the top if statement ```\nif(iIndex1 == iIndex2) return TRUE;```\n, when I try to find if there is a path from (A,A), (B,B), (C,C), etc. I will always get ```\n1```\n even if there is no path from A to A.\n\n```\ntypedef enum { FALSE, TRUE } bool;\n\n/* Recursive function will determine if there is a path from index 1 to 2\n * Based of DFS\n */\nbool recPathExists( Graph G, int iIndex1, int iIndex2 )\n{\n    int j;\n    G.nodeArray[iIndex1].visited = TRUE;\n    if(iIndex1 == iIndex2){\n            return TRUE;\n    }\n    for(j = 0; j < G.iNumNodes; j++){\n        if(!G.nodeArray[j].visited && G.adjMatrix[iIndex1][j]==1){\n            if(recPathExists(G, j, iIndex2))\n                return TRUE;\n        }\n    }\n    return FALSE;\n}\n\n/* Write a function to find all pairs of nodes which have paths between them.\n * Store this information in the provided pathMatrix.\n */\nvoid allPathsRecFunc( Graph G , int **pathMatrix )\n{\n    int i, j;\n    for(i = 0; i < G.iNumNodes; i++){\n        for(j = 0; j < G.iNumNodes; j++){\n            if(recPathExists(G, i , j)== TRUE){\n                pathMatrix[i][j] = 1;\n            }\n            resetVisited(G); //resets all nodes to FALSE\n        }\n    }\n}\n```\n\n\nwhat it should be \n\n```\nA   0 1 1 1 1 1 1 1 \nB   0 1 0 0 1 1 1 1 \nC   0 1 0 0 1 1 1 1 \nD   0 0 0 0 0 0 0 0 \nE   0 0 0 0 0 0 0 0 \nF   0 1 0 0 1 1 1 1 \nG   0 1 0 0 1 1 1 1 \nH   0 1 0 0 1 1 1 1 \n```\n\n\nwhat I get\n\n```\nA   1 1 1 1 1 1 1 1 \nB   0 1 0 0 1 1 1 1 \nC   0 1 1 0 1 1 1 1 \nD   0 0 0 1 0 0 0 0 \nE   0 0 0 0 1 0 0 0 \nF   0 1 0 0 1 1 1 1 \nG   0 1 0 0 1 1 1 1 \nH   0 1 0 0 1 1 1 1\n```\n\n    ", "Answer": "\r\nYour issue may be here:\n\n```\nfor(j = 0; j < G.iNumNodes; j++)\n{\n    if(!G.nodeArray[j].visited && G.adjMatrix[iIndex1][j] == 1)\n    {\n        return recPathExists(G, j, iIndex2);\n    }\n}\n```\n\n\nBy ```\nreturn```\ning the result of recursing on ```\nrecPathExists```\n, you're not checking the other possible nodes that could be reachable in the loop (in essence, you're returning failure too early, and missing possible paths).\n\nI believe you want just a little modification:\n\n```\nfor(j = 0; j < G.iNumNodes; j++)\n{\n    if(!G.nodeArray[j].visited && G.adjMatrix[iIndex1][j] == 1)\n    {\n        if (recPathExists(G, j, iIndex2))\n            return TRUE;\n    }\n}\n```\n\n\nThat is, \"if a path does exist, return as we've found it. If not, keep looking\".\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all paths in graph from A to N\r\n                \r\nI'm trying to port the following example python code to Java:\n\n```\ndef find_all_paths(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return [path]\n    if not graph.has_key(start):\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_paths(graph, node, end, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths\n```\n\n\nThe problem being, the base case to stop recursing:\n\n```\nif start == end:\n    return [path]\n```\n\n\nIt doesn't support my requirement of allowing both A and N to be the same node.\n\nFor example:\n\nIf I have the following digraph:\n\n```\nA -> [B, C], \nB -> [C, E], \nC -> [D, A]\n```\n\n\nAnd I want all paths between A and A, I should have the result:\n\n```\nA -> B -> C -> A\n```\n\n\nThe above python code will just give me:\n\n```\nA\n```\n\n    ", "Answer": "\r\nA path from A to A must go through a neighbor of A.  Thus, one way to implement this is to enumerate all of the outward neighbors:\n\n```\n[[[\"A\"]+y for y in find_all_paths(G,x,\"A\")] for x in graph[\"A\"]]\n```\n\n\nFor your graph, the result should be\n\n```\n[[['A', 'B', 'C', 'A']], [['A', 'C', 'A']]]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Confusion regarding definition of path in Graph theory\r\n                \r\nI am having confusion regarding the definition of path.\n\nIn wikipedia the definition of path is given as follows\n\nA path is a trail in which all vertices (except possibly the first and last) are distinct.\n\nDefinition of path in wikipedia\n\nBut what I knew was\n\nA path is a trail in which all vertices are distinct.\n\nPlease tell me which one is the correct definition of Path.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Graph theory: paths in a tree in python\r\n                \r\nthe adjacency list (for example): adj = [ [1,2],[2,3],[ ],[4],[ ] ] the assumption is that the graph is always a directed tree\nI need to make a path recursion and store each path in a variable called full_path\npseudo-code:\nfor i in range(0, len(adj), 1):\n\nuse each path possible until you reach a dead end\nthe variable path contains the nodes you've just visited and re-initialise every time we reach a dead end, before re-initialising we save it as a nested list in full_path\n\nfor our example that would give:\n\n0->1->2->[ ]      so path = [0,1,2]\n0->1->3->4->[ ]   so path = [0,1,3,4]\n0->2->[ ]         so path = [0,2]\n1->2->[ ]         so path = [1,2]\n1->3->4->[ ]      so path = [1,3,4]\n2->[ ]            so path = [2]\n3->4->[ ]         so path = [3,4]\n4->[ ]            so path = [4]\n\nAnd therefore full_path = [ [0,1,2], [0,1,3,4], [0,2], [1,2], [1,3,4], [2], [3,4], [4] ]. This is the output the function must give to match the teacher's expectations.\n('[ ]' means it has reached a dead end)\n```\nfor i in range(0,len(adj),1):\n    for j in range(0,len(adj[i]),1):\n        path += [i]\n        current_node= j# , True\n        a = len(adj[current_node])\n        while a >0:      # to stop when a node leads to nowhere:  adj[j] = [] and so len(adj[j])==0\n            for k in range(0,len(adj[current_node]),1):\n                current_node = adj[current_node][k]\n                path += [current_node]\n                a = len(adj[current_node])\n            final_path += [list(dict.fromkeys(path))]\n            path = []\n```\n\nAbove is what I did so far but it does not works at all\n    ", "Answer": "\r\nIt's better to use backtracking in this problem because of the recursive nature of the problem using directed trees.\n```\nadj = [ [1,2],[2,3],[ ],[4],[ ] ]\n\ndef getAllPath(adj):\n  pathes = [] # list of all pathes reached <- what you want\n  path = [] # to hold the current path\n  def dfs(node):\n    if not adj[node]: # if current node has no children\n      pathes.append(path.copy()) # append a copy of current path to pathes\n    else:\n      for next_node in adj[node]:\n        if next_node not in path: # if current node is not visited (useless if it's a directed tree)\n          path.append(next_node) # push the next_node to the current path\n          dfs(next_node)         # build the rest of the path\n          path.pop()             # remove it from the path.\n        \n  for node in range(len(adj)): # loop over all nodes in the graph\n    path.append(node) # add current start node to the path\n    dfs(node)         # build the rest of the path\n    path.pop()        # remove the start node\n  return pathes\n```\n\noutput\n```\n[[0, 1, 2], [0, 1, 3, 4], [0, 2], [1, 2], [1, 3, 4], [2], [3, 4], [4]]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find maximum cost path in a directed graph\r\n                \r\nIs there a good solution to find the maximum cost path in a directed graph from source to destination? I tried to use \"all_simple_paths\" method from netwrkx and then find the maximum cost path from retrieved paths. However, the method itself did not scale and not even finish due to a large number of node ~ 700 and ~ 600 edges. Any suggestion?\nI looked at this solution but did not know how to come up with the distance method mentioned in relax. \nhttps://cs.stackexchange.com/questions/78154/maximum-weighted-paths-in-a-dag\n\nNote: my graph has already a start and end node and all edges are out in start node and in in the end node\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find all the paths in a undirected graph touching all the nodes of a given set\r\n                \r\nI have an undirected graph and i'd like to find all the possible paths in it connecting all the nodes of a given set.\nIs it an NP problem? Is there an algorithm to doing it, or a good way to accomplish it?  I don't care about the order by which each paths touches the nodes in the set, i just need it to go through each of them.\n    ", "Answer": "\r\nIt's called Hamiltonian Path Problem and it is NP-complete. \n\nFor detailed info: https://en.wikipedia.org/wiki/Hamiltonian_path_problem\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Identify the path in Graph traversing\r\n                \r\nIn the graph database, I want to know from which route I traverse\n\ne.g.\n\nPath-1. a-1-2-3-4-5-b\n\nPath-2. a-1-2-7-4-5-b\n\nIn both the above examples, it traverses from point a to point b through different routes.\nHere I want to identify from which route I reach to point b.\n    ", "Answer": "\r\nYou can use the ```\nNODES```\n function to list the nodes in a path. There is also a ```\nRELATIONSHIPS```\n function for listing the relationships.\n\nFor example, if this query finds the 2 paths in your question, it will return the nodes in each path:\n\n```\nMATCH path = (a:A)-[*]->(b:B)\nRETURN NODES(path) AS nodesInPath\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Complexity of a recursive function that counts paths in graph\r\n                \r\nI have found a function for a directed graph, which for vertices ‘u’ and ‘v’ in it, it counts all possible walks from ‘u’ to ‘v’ with exactly k edges on the walk.\nThe code and the algorithm are from here. So,\n\n```\n// C++ program to count walks from u to v with exactly k edges\n#include <iostream>\nusing namespace std;\n\n// Number of vertices in the graph\n#define V 4\n\n// A naive recursive function to count walks from u to v with k edges\nint countwalks(int graph[][V], int u, int v, int k)\n{\n   // Base cases\n   if (k == 0 && u == v)      return 1;\n   if (k == 1 && graph[u][v]) return 1;\n   if (k <= 0)                return 0;\n\n   // Initialize result\n   int count = 0;\n\n   // Go to all adjacents of u and recur\n   for (int i = 0; i < V; i++)\n       if (graph[u][i])  // Check if is adjacent of u\n           count += countwalks(graph, i, v, k-1);\n\n   return count;\n}\n```\n\n\nI am trying to find and prove the complexity of this algorithm. According to the post:\n\n\n  \"The worst case time complexity of the above function is O(V^k) where V\n  is the number of vertices in the given graph. We can simply analyze\n  the time complexity by drawing recursion tree. The worst occurs for a\n  complete graph. In worst case, every internal node of recursion tree\n  would have exactly n children.\"\n\n\nBut, I cannot find the recursion that leads to a tree I can analyze in order to prove that this algorithm is ```\nO(V^k)```\n. Also, I suppose that the best case is ```\nTheta(1)```\n. Is that true? What about the average case?\n    ", "Answer": "\r\nFor a complete graph, each node is connected to each other node, so your ```\nfor```\n loop will make ```\n|V|```\n recursive calls. This will happen at every recursive call, until ```\nk```\n becomes 1, so ```\nO(|V|^k)```\n recursive calls in total.\n\nYou can express it like this:\n\n```\nT(V, k) = |V|*T(V, k - 1)\n        = |V|*|V|*T(V, k - 2)\n        = |V|^2*|V|*T(V, k - 3)\n        = ...\n```\n\n\nIt's always ```\nT(V, _)```\n because a node can be visited multiple times.\n\nThe best case is indeed ```\nO(1)```\n when one of the first three if conditions fires during the first call.\n\nThe average case I'm not sure about, but it should still be pretty bad I think. Consider a linked list graph and a huge ```\nk```\n: you will travel the same edges multiple times in order to get ```\nk```\n to 0 or 1. This gets progressively worse as you add more paths.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest acyclic path in a directed unweighted graph\r\n                \r\nWhat algorithm can be used to find the longest path in an unweighted directed acyclic graph?\n    ", "Answer": "\r\nDynamic programming.  It is also referenced in Longest path problem, given that it is a DAG.\n\nThe following code from Wikipedia:\n\n```\nalgorithm dag-longest-path is\n    input: \n         Directed acyclic graph G\n    output: \n         Length of the longest path\n\n    length_to = array with |V(G)| elements of type int with default value 0\n\n    for each vertex v in topOrder(G) do\n        for each edge (v, w) in E(G) do\n            if length_to[w] <= length_to[v] + weight(G,(v,w)) then\n                length_to[w] = length_to[v] + weight(G, (v,w))\n\n    return max(length_to[v] for v in V(G))\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all paths in directed cyclic graph as regular expression\r\n                \r\nLet G = (V,E,r) a rooted directed graph, defined by a set of vertices V and a set of edges E with a designated root node r. The graph may contain cycles. The task: Given two vertices x and y from V, find all paths from x to y.\n\nSince cycles are allowed, the set of paths may obviously be infinite. Therefore, I want to find the set of paths in the form of a regular expression (Kleene Algebra). Here are a few examples: Examples graphs. Multiplication means sequence, so a path abc means first a, then b, then c. A set of paths a(b+c+d) means first a, then either b, c, or d. The kleene star a* means that a is repeated zero or more, a+ that a repeated one or more times.\n\nNow I am looking for a way to construct these expressions algorithmically. What I have come up with so far:\n\n\nConstruct new expression tree T.\nStart search at end node y.\nFind all predecessors p to y.\nfor each p:\n\nAdd p as a child node to y in T.\nBacktrack the path up the tree from p towards the root. If y is found along the way, then there is a cycle from y to p. Therefore, not only is p is a predecessor to y, but\n(path)* is also a predecessor to p. Therefore, add (path)* as a child node to p.\nFor all non-looping predecessors, recursive call with y := p as the new end node.\n\n\n\nAnd finally:\n\n\nInvert tree so it ends with the end node\nConvert expression tree to expression (straightforward)\n\n\nNot sure whether this will work, however, also worst case complexity will be somewhere above 2^n I guess. Does anyone know an algorithm for this or a similar problem?\n    ", "Answer": "\r\nThe general idea of your algorithm seems sound. However, I'm guessing that there may be many special cases in that back-tracking step that you'll have to code for. In particular, I don't see an easy way for that step to account for cycles within cycles, i.e. (path)* itself contains a term that needs a Kleene star.\n\nI have separate suggestion though. The graph could be converted to an NFA, which would allow use of any of the well known algorithms to convert the NFA into a regular expression. \n\nTo convert the graph to an NFA:\n\n\nSet node x as the start state.\nSet node y as the only accept state.\nFor every node a, label all its incoming edges a.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to isolate these (image included) paths in a graph?\r\n                \r\nI have a graph and want to isolate distinct paths from it. Since I can't phrase this easily in graph jargon, here is a sketch:\n\n\n\nOn the left side is a highly simplified representation of my source graph. The graph has nodes with only 2 neighbors (shown as blue squares). Then it has intersection and end nodes with more than 2 neighbors or exactly 1 neighbor (shown as red dots).\n\nOn the right side, coded in three different colors, are the paths I want to isolate as a result. I want to isolate alls paths connecting the red dots. The resulting paths must not cross (go through) any red dots. Each edge may only be part of one distinct result path. No edges should remain (shortest path length is 1).\n\nI am sure this is a known task in the graph world. I have modeled the graph in NetworkX, which I'm using for the first time, and can't find the proper methods to do this. I'm sure I could code it the hard way, but would be glad to use a simple and fast method if it existed. Thanks!\n\nEdit: After randomly browsing the NetworkX documentation I came across the all_simple_paths method. My idea is now to\n\n\niterate all nodes and identify the red dots (number of neighbors != 2)\nuse all_simple_paths() pairwise for the red dots, collect the resulting paths\ndeduplicate the resulting paths, throw away everything that contains a red dot except as the start and end node\n\n\nStep 2, of course, won't scale well. With ~2000 intersection nodes, this seems still possible though.\n\nEdit 2: all_simple_paths appears to be way too slow to use it this way.\n    ", "Answer": "\r\nI propose to find all straight nodes (i. e. nodes which have exactly two neighbors) and from the list of those build up a list of all your straight paths by picking one straight node by random and following its two leads to their two ends (the first non-straight nodes).\n\nIn code:\n\n```\ndef eachStraightPath(g):\n  straightNodes = { node for node in g.node if len(g.edge[node]) == 2 }\n  print straightNodes\n  while straightNodes:\n    straightNode = straightNodes.pop()\n    straightPath = [ straightNode ]\n    neighborA, neighborB = g.edge[straightNode].keys()\n    while True:  # break out later if node is not straight\n      straightPath.insert(0, neighborA)\n      if neighborA not in straightNodes:\n        break\n      newNeighborA = (set(g.edge[neighborA]) ^ { straightPath[1] }).pop()\n      straightNodes.remove(neighborA)\n      neighborA = newNeighborA\n    while True:  # break out later if node is not straight\n      straightPath.append(neighborB)\n      if neighborB not in straightNodes:\n        break\n      newNeighborB = (set(g.edge[neighborB]) ^ { straightPath[-2] }).pop()\n      straightNodes.remove(neighborB)\n      neighborB = newNeighborB\n    yield straightPath\n\ng = nx.lollipop_graph(5, 7)\n\nfor straightPath in eachStraightPath(g):\n  print straightPath\n```\n\n\nIf your graph is very large and you do not want to hold a set of all straight nodes in memory, then you can iterate through them instead, but then the check whether the next neighbor is straight will become less readable (though maybe even faster).  The real problem with that approach would be that you'd have to introduce a check to prevent straight paths from being yielded more than once.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Number of shortest paths in weighted graph\r\n                \r\nThis is the question:\n   Given a directed graph G=(V,E), a source vertex s $epsilon V, we know that all cycles in G are of positive weight ( > 0). Also we are given the graph after Bellman-Ford was run on it, meaning that for each v in V we know both d[v] (shortest path from s to v) and pi[v] (v's predecessor)\n\nDescribe an algorithm to find the number of shortest path from s to v for all v in V. The algorithm must run in O(V+E) \n\n*We cannot edit the Bellman-Ford run on the algorithm \n\nThis is what i thought of:\nWe run a modified DFS, \n\nAlgorithm(G,s):\n\n```\n1.DFS-Visit(G,s)\n2. return count[v] foreach v in V\n```\n\n\nDFS-Visit(G,u):\n\n```\n1.foreach v in Adj[u]\n   2.if d[v] == d[u] + w(u,v) && (u,v) is not a backedge\n      3.count[v] = count[v] + 1\n      4.DFS-visit(G,v)\n```\n\n\n*It seems like the algorithm can get stuck in an infinite loop, maybe i can ignore back-edges? (since a shortest path will always be simple)\n\n*This is not a duplicate of \nHow to find the number of different shortest paths between two vertices, in directed graph and with linear-time?\n\nin that question the graph is unweighted here it is weighted ( edges)\nDo you think this is correct?\nThanks\n    ", "Answer": "\r\n\n  ```\nif d[v] == d[u] + w(u,v) && (u,v) is not a backedge```\n\n\n\nThe condition ```\nd[v]==d[u]+w(u,v)```\n is the most important here. If guarantees that this is never a backedge and, moreover, it guarantees that you will never return to the vertex where you have been. \n\nIndeed, assume you returned to a vertex where you have been. Then you have\n\n```\nd[v1]==d[v0]+w(v0,v1)\nd[v2]==d[v1]+w(v1,v2)\n...\nd[v0]==d[vn]+w(vn,v0)\n```\n\n\nsumming it all, we find that\n\n```\nw(v0,v1)+w(v1,v2)+...+w(vn,v0)==0\n```\n\n\nthat is a zero-weight loop, but we are told there is no such loops.\n\nSo this algorithm will never stuck into a infinite loop; moreover, if you leave only the edges satisfying ```\nd[v]==d[u]+w(u,v)```\n (making graph directed even if it has not been), the resulting graph will be acyclic.\n\nTherefore you can run the standard algorithm of finding a number of ways in an acyclic graph. In fact this is what you have already written (your ```\nDFS```\n), just note that\n\n```\ncount[v] = count[v] + 1\n```\n\n\nshould be\n\n```\ncount[v] = count[v] + count[u]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in graph without repetitions\r\n                \r\nI have a directed graph that every node contain a letter and every edge has weight. I want to find the shortest path from a start node to an end node, that doesn't have letters showing not in sequence and has all the letters in it.\nFor example:\n```\nI have those nodes: 1 - start node, 2- end node, 3 - 'A' letter, 4 - 'B' letter, 5 - 'B' letter, 6 - 'A' letter, 7 - 'B' letter.\nAnd the edges are: 1 -> 3, 1 -> 4, 3 -> 5, 4 -> 5, 5 -> 6, 5-> 7, 6 -> 2, 7 -> 2.\n```\n\nthe graph looks like this:\n\nThe only valid paths for me are:\n```\n1 -> 3 -> 5 -> 7 -> 2 ('ABB'), 1 -> 4 -> 5 -> 6 -> 2 ('BBA').\n```\n\nI want to get the option of 'BBA' because it is the shortest.\nIf I'll try using dijkstra, when i get to node number 6, my path will go through nodes number 3 and 5. Then i will set the weight of the edge (5 -> 6) to be Infinity for this path so it won't take this path.\nBut, because it already got that the shortest path to node number 5 is through node number 3, it will choose the path 'ABB'.\nHow can i get the correct path?\nedit:\nwhat I want to find is a path, that the same letter can only be visited in 1 group. I mean, if I visit an 'A' group already and then went to 'B' group, i can't travel to another 'A' again. I can travel like this:\n```\nA->A->C->B->B\n```\n\n    ", "Answer": "\r\nConstraints\nOk, I believe the two constraints are as follows:\n\nThe path must contain every letter in the alphabet at least once, and\nThe entire path must either visit nodes in alphabetical order OR in reverse alphabetical order.\n\nAnd I believe the alphabet can be substantially bigger, e.g. A-Z.\nSo first, let's just solve it for alphabetical order. If we can do that, then we only need to do the equivalent algorithm for reverse alphabetical order.\nModified Graph\nSo we modify the graph to have the following rules:\n\nEach node N's outgoing edges can only connect to a node with the same letter or the letter that immediately follows (e.g. an \"A\" node can only send you to an \"A\" node or a \"B\" node, never a \"C\" node, \"D\" node, etc), otherwise we could visit nodes in non-alphabetical order and / or skip a letter in the path.\nThe start node's outgoing edges can only connect to a node with the first letter of the alphabet (e.g. an \"A\" node), otherwise we could not include \"A\" in our entire alphabetical path.\nThe end node's ingoing edges can only come from nodes with the last letter of the alphabet (e.g. a \"B\" node in your example), otherwise we could not include the last letter in our entire alphabetical path.\n\nSo in the above graph, we only keep the following edges for the alphabetical graph: 1 -> 3, 3 -> 5, 5 -> 7, and 7 -> 2.\nSimilarly, for the reverse alphabetical graph we only keep the following edges: 1 -> 4, 4 -> 5, 5 -> 6, 5 -> 7, 6 -> 2. Note that node 7 would no longer have any outgoing edge.\nOnce you've done this, any path (in the modified graph) from start to end must be a valid path, because:\n\nThe path must contain every letter in the alphabet at least once (no letters were skipped AND the first node was the first letter AND and the last node was the last letter), and\nThe entire path visited nodes in alphabetical order (since each individual edge was alphabetical).\n\nGiven this, regular Dijkstra should work perfectly on this modified graph.\nFinal Framework\nGiven the above, your entire algorithm is as follows:\n\nCreate the two modified graphs: one alphabetical, one reverse alphabetical.\nRun Dijkstra on each modified graph.\nPick the best solution between the two.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Fastest way to find all paths in a directed acyclic graph (DAG) with multiple starting nodes?\r\n                \r\nI am trying to find all paths in a directed acyclic graph (DAG) with multiple starting nodes. I already have the DAG represented by a list of lists, together with each level of nodes from starts to terminations:\n```\ndag = [[4, 6, 7], [5, 6, 7], [4, 5, 6], [4, 5, 7],\n       [], [], [], [], [1, 3], [1, 2], [0, 2, 3]]\nlevels = [[8, 9, 10], [0, 1, 2, 3], [4, 5, 6, 7]]\n```\n\nThe example DAG colored by levels looks like this:\n\nSince I have 3 starting nodes ```\n[8, 9, 10]```\n, my first thought is performing 3 DFSs. Below is my code:\n```\ndef get_all_paths(dag, sources):\n\n    def dfs(data, path, paths=None):\n        if paths is None:\n            paths = []\n        prev = path[-1]\n        if data[prev]:\n            for val in data[prev]:\n                new_path = path + [val]\n                paths = dfs(data, new_path, paths)\n        else:\n            paths += [path]\n        return paths\n\n    all_paths = []\n    for i in sources:\n        paths = dfs(data=dag, path=[i], paths=[])\n        all_paths += paths\n\n    return all_paths\n\nall_paths = get_all_paths(dag, sources=levels[0])\nprint(all_paths)\n```\n\nOutput:\n```\n[[8, 1, 5], [8, 1, 6], [8, 1, 7], [8, 3, 4], [8, 3, 5], [8, 3, 7], \n [9, 1, 5], [9, 1, 6], [9, 1, 7], [9, 2, 4], [9, 2, 5], [9, 2, 6], \n [10, 0, 4], [10, 0, 6], [10, 0, 7], [10, 2, 4], [10, 2, 5], \n [10, 2, 6], [10, 3, 4], [10, 3, 5], [10, 3, 7]]\n\n%timeit 24.6 µs ± 577 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)\n```\n\nHowever, when the graph is large or there are many starting nodes, my code becomes very slow. As we all know, the DFS time complexity of finding all paths in a DAG ```\nG(V,E)```\n is O(V+E). So my approach has the time complexity of O(m(V+E)), where m is the number of starting nodes. In my code, each node is visited m times, but I feel like it is possible to still visit each node only once, especially given the ```\nlevels```\n and I'm not utilizing it. Maybe a BFS will do, but I'm not sure how to write it. Any suggestions?\nEdit\nHere are some benchmarking of the answers\nI have adjusted my BFS code based on @chepner's comment.\n```\ndef get_all_paths(dag, sources):\n\n    def dfs(data, path, paths=None):\n        if paths is None:\n            paths = []\n        prev = path[-1]\n        if data[prev]:\n            for val in data[prev]:\n                new_path = path + [val]\n                paths = dfs(data, new_path, paths)\n        else:\n            paths.append(path[1:])\n\n        return paths\n\n    dag.append(sources)\n    \n    return dfs(data=dag, path=[len(dag)-1], paths=[])\n\n%timeit get_all_paths(dag, sources=levels[0])\n```\n\nOutput:\n```\n9.73 µs ± 112 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n```\n\nTesting @aminrd's answer:\n```\nfrom collections import defaultdict\n\ndef aminrd(dag, levels):\n    paths = defaultdict(list)\n    levels_reversed = levels[::-1]\n\n    for node in levels_reversed[0]:\n        paths[node] = [[node]]\n\n    for lvl in levels_reversed[1:]:\n        for src in lvl:\n            for dst in dag[src-1]:\n                paths[src] += [[src] + p for p in paths[dst]]\n\n    result = []\n    for lvl_0 in levels[0]:\n        result += paths[lvl_0]\n        \n%timeit aminrd(dag, levels)\n```\n\nOutput\n```\n10.7 µs ± 164 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n```\n\n    ", "Answer": "\r\nLook for paths in a single augmented graph. If your set of starting nodes is ```\nS```\n, add a new starting node ```\nS0```\n and edges ```\n(S0, s)```\n for each ```\ns```\n in ```\nS```\n. Once your single DFS completes, you can simply remove ```\nS0```\n from each path, leaving you with the paths in your original graph.\nThis may reduce some of the duplication created by running ```\ndfs```\n multiple times, but won't address the unavoidable fact that your running time is proportional to the number of paths to be found.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in graph without repetitions\r\n                \r\nI have a directed graph that every node contain a letter and every edge has weight. I want to find the shortest path from a start node to an end node, that doesn't have letters showing not in sequence and has all the letters in it.\nFor example:\n```\nI have those nodes: 1 - start node, 2- end node, 3 - 'A' letter, 4 - 'B' letter, 5 - 'B' letter, 6 - 'A' letter, 7 - 'B' letter.\nAnd the edges are: 1 -> 3, 1 -> 4, 3 -> 5, 4 -> 5, 5 -> 6, 5-> 7, 6 -> 2, 7 -> 2.\n```\n\nthe graph looks like this:\n\nThe only valid paths for me are:\n```\n1 -> 3 -> 5 -> 7 -> 2 ('ABB'), 1 -> 4 -> 5 -> 6 -> 2 ('BBA').\n```\n\nI want to get the option of 'BBA' because it is the shortest.\nIf I'll try using dijkstra, when i get to node number 6, my path will go through nodes number 3 and 5. Then i will set the weight of the edge (5 -> 6) to be Infinity for this path so it won't take this path.\nBut, because it already got that the shortest path to node number 5 is through node number 3, it will choose the path 'ABB'.\nHow can i get the correct path?\nedit:\nwhat I want to find is a path, that the same letter can only be visited in 1 group. I mean, if I visit an 'A' group already and then went to 'B' group, i can't travel to another 'A' again. I can travel like this:\n```\nA->A->C->B->B\n```\n\n    ", "Answer": "\r\nConstraints\nOk, I believe the two constraints are as follows:\n\nThe path must contain every letter in the alphabet at least once, and\nThe entire path must either visit nodes in alphabetical order OR in reverse alphabetical order.\n\nAnd I believe the alphabet can be substantially bigger, e.g. A-Z.\nSo first, let's just solve it for alphabetical order. If we can do that, then we only need to do the equivalent algorithm for reverse alphabetical order.\nModified Graph\nSo we modify the graph to have the following rules:\n\nEach node N's outgoing edges can only connect to a node with the same letter or the letter that immediately follows (e.g. an \"A\" node can only send you to an \"A\" node or a \"B\" node, never a \"C\" node, \"D\" node, etc), otherwise we could visit nodes in non-alphabetical order and / or skip a letter in the path.\nThe start node's outgoing edges can only connect to a node with the first letter of the alphabet (e.g. an \"A\" node), otherwise we could not include \"A\" in our entire alphabetical path.\nThe end node's ingoing edges can only come from nodes with the last letter of the alphabet (e.g. a \"B\" node in your example), otherwise we could not include the last letter in our entire alphabetical path.\n\nSo in the above graph, we only keep the following edges for the alphabetical graph: 1 -> 3, 3 -> 5, 5 -> 7, and 7 -> 2.\nSimilarly, for the reverse alphabetical graph we only keep the following edges: 1 -> 4, 4 -> 5, 5 -> 6, 5 -> 7, 6 -> 2. Note that node 7 would no longer have any outgoing edge.\nOnce you've done this, any path (in the modified graph) from start to end must be a valid path, because:\n\nThe path must contain every letter in the alphabet at least once (no letters were skipped AND the first node was the first letter AND and the last node was the last letter), and\nThe entire path visited nodes in alphabetical order (since each individual edge was alphabetical).\n\nGiven this, regular Dijkstra should work perfectly on this modified graph.\nFinal Framework\nGiven the above, your entire algorithm is as follows:\n\nCreate the two modified graphs: one alphabetical, one reverse alphabetical.\nRun Dijkstra on each modified graph.\nPick the best solution between the two.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in graph using SQL\r\n                \r\nI've a graph which is saved as two tables with names Edge and Node as follows in SQL:\n\n```\nNode table:\nId Name\n10 A\n11 B\n12 C\n\nEdge Table:\nFrom To Weight\n10 11 0.3\n10 14 0.2\n10 12 0.5\n11 12 0.6\n12 10 0.8\n```\n\n\nFor example one possible solution for path from node 10 to node 12 is as follows:\n\n```\nFrom    To  Weight  Path\n10  12  0.9 10,11,12\n```\n\n\nNow, I want to find out the longest path between nodes of the graph (for any possible path).\n\nI've changed dijkstra with negative edges and it looped and doesn't return any result.\n\nIs there any procedure or algorithm to find out the desired result?\n    ", "Answer": "\r\nRecently I had a similar issue and tried to find the longest path using SQL recursive CTE query. Please refer to given article.\n\nI tried to modify the above solution for your problem, and get a list of all possible paths as seen in following output screen\n\n\n\nIf this is the result you want to achive, I can continue describing my solution on SQL Server\n\nThe referred SQL query calculates the longest path for given two nodes.\nSo first of all we need to define all possible starting and destination nodes \n\nBelow query lists the combination of all possible sets\n\n```\nselect Nodes_From.Id as [From], Nodes_To.Id as [To]\nfrom LongestPath_Nodes as Nodes_From\ninner join LongestPath_Nodes as Nodes_To\n    on Nodes_From.Id <> Nodes_To.Id\n```\n\n\nPlease note that this excludes \"14\" for example since it is not in the nodes table (so there is a consistency problem here actually in given test data)\n\nSo by creating a SQL cursor, I can loop through each node set (from-to node combination) and execute the stored procedure which includes SQL codes calculating longest path for given two nodes from referred article\n\nI also created a table to store a path's total weight\n\n```\nCreate Table LongestPath_Routes ([weight] decimal(10,1), path varchar(100))\n```\n\n\nAs seen in below SQL script, I clear this table at the beginning.\nThen populate it for each from-to node set within the stored procedure \nFinally after cursor execution is completed I query the table by sorting according to weight column for the longest path (also for the shortest path is possible)\n\n```\ntruncate table LongestPath_Routes\n\nDECLARE @From TinyInt\nDECLARE @To TinyInt\n\nDECLARE PathCursor CURSOR FAST_FORWARD FOR\n    select Nodes_From.Id as [From], Nodes_To.Id as [To]\n    from LongestPath_Nodes as Nodes_From\n    inner join LongestPath_Nodes as Nodes_To\n        on Nodes_From.Id <> Nodes_To.Id\n\nOPEN PathCursor\n\nFETCH NEXT FROM PathCursor INTO @From, @To\n\nWHILE @@FETCH_STATUS = 0\nBEGIN\nset nocount on\n EXEC LongestPath_Calculate_for_Nodes @From, @To\nset nocount off\n\n FETCH NEXT FROM PathCursor INTO @From, @To\nEND\n\nCLOSE PathCursor\nDEALLOCATE PathCursor \n\nselect * from LongestPath_Routes order by [weight] desc\n```\n\n\nI hope this solution helps you \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Recursive search of all viable paths in graph by edge length\r\n                \r\nI have school assigment to create a program which gets a graph and finds out mininal spanning tree with condition that path between two points (which are preselected on run start) will be shortest by NUMBER OF EDGES between them.\n\nThe task itself is OK but where I struggle is optimization. When I find my path between A and B (preselected points) I try to recursively find all other possible options by DFS and then do MSTs and choose the smallest. Since the path must be of lowest number of edges and I found one of those paths by first BFS I know that I can cut of my DFS search after X recursions where X is number of edges between A in B found in the BFS. It works very fast in certain types of graphs (where number of edges is to 3 times number of vertexes) but when edges are for example 10 times bigger it just runs without stopping.\n\nI asked my friend for a hint and he said me he uses BFS for recursively finding the other paths, and he is okay, but what is the performance difference? DFS will try first to run down and stops when reach the certain point or wastes hops avaiable, BFS goes wide first and then ends all paths at the same depth step but still I do same ammount of hopping right?\n\nWhat am I missing here? Or did I understand him wrong? Thanks for any ideas.\n\nEDIT: I tried to check which edges I already visited in the particular DFS run to avoid going opposite direction, back to the point where i was and so on but it only generated delay on certain group of graphs while not helping noticably with others.\n\nEDIT2: swapped edge and vertex quantity (cant be more vertexes than edges)\n    ", "Answer": "\r\nSo I finished my assigment and when looking for other paths/all paths between two points A/B, DFS and BFS gets the same result as far as I found out.\n\nThe key for me was right optimization of solution. My final solution combines going wide with going deep and works like this (maybe it can be done faster but I doubt it):\n\n\nWe know the length (in number of edges) between points A/B (we\n    ran BFS once to find out path).\nWe run something like BFS from\n    end point B and in every vertex we make mark how much hops we did\n    from the end and call this again on all outgoing edges (we stop when\n    hops == lengthOfPath(A,B)).\nThen we do DFS from source point A\n    and combine all vertexes which hold proper hop value into the path\n    by recursion.\n\n\nIn other words we mark all point by their reachability from B and then from A we go over those accessible (with set value other than default and with proper value of hops from A) and combine all possible paths together.\n\nThere are our paths. (I left this vague intentionally because task is still active). If anyone would need better explanation in future, post comment and I will elaborate. If someone finds better solution, post it as your answer and if right I will tick it as right answer.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all paths in graph from one node to another node\r\n                \r\nI'm trying to find all the paths between two nodes of the graph. My graph is defined as:\n\n```\n(define-struct graph (nodes neighbors node=?))\n\n(define G1 (make-graph '(A B C D E F G)\n              (lambda (n)\n                (cond [(symbol=? n 'A) '(B E)]\n                      [(symbol=? n 'B) '(E F)]\n                      [(symbol=? n 'C) '(D)]\n                      [(symbol=? n 'D) '()]\n                      [(symbol=? n 'E) '(C F A)]\n                      [(symbol=? n 'F) '(D G)]\n                      [(symbol=? n 'G) '()]))\n              symbol=?)))\n```\n\n\nMy algorithm is:\n1. the main function return a list of list, so I make a recursion on the graph\n2. join the source to the paths from its neighbors to the destination.\n\n```\n(define (find-paths origination destination G)\n  (cond\n    [(symbol=? origination destination) (list (list destination))]\n    [else (local ((define neighbor ((graph-neighbors G) origination))\n                  (define candidate (find-paths/list neighbor destination G)))\n            (join origination candidate))]))\n\n(define (find-paths/list lo-Os d g)\n  (cond\n    [(empty? lo-Os) empty]\n    [else (local ((define candidate (find-paths (first lo-Os) d g)))\n            (cond\n              [(empty? candidate) (find-paths/list (rest lo-Os) d g)]\n              [else (append (find-paths (first lo-Os) d g)\n                            (find-paths/list (rest lo-Os) d g))]))]))\n\n(define (join node list-of-node)\n  (map (lambda (n) (cons node n)) list-of-node))\n```\n\n\nWhen I test ```\n(find-paths 'A 'E G1)```\n it returns exactly what I want, which is ```\n(list (list 'A 'E) (list 'A 'B 'E))```\n. But when I test to ```\n(find-paths 'A 'C G1)```\n the code stuck and the IDE said it runs out of memory.\n\nCan someone please explain to me why?\n    ", "Answer": "\r\nYou have an infinite loop, between 'A and 'E. Because your function tests for every possible path, when you\ntry to go from 'A to 'C, It will test all the neighbors of 'E getting it back to 'A and from there to 'E again. I have added a ```\ndisplayln```\n to show this. \n\n```\n(find-pahts A C)\n(find-pahts B C)\n(find-pahts E C)\n(find-pahts C C)\n(find-pahts C C)\n(find-pahts F C)\n(find-pahts D C)\n(find-pahts G C)\n(find-pahts A C)\n(find-pahts B C)\n(find-pahts E C)\n(find-pahts C C)\n(find-pahts C C)\n(find-pahts F C)\n(find-pahts D C)\n(find-pahts G C)\n```\n\n\nAs you can see, you have fallen in an infinite loop. It tries 'E 'C, Which leads to 'C 'C which is a path. Then it goes to 'E 'F in turn from 'F it tries 'D and 'G which are both dead ends. And then for the last neighbor of 'E which is 'A, starting all over again.\n\n```\n(define (find-paths origination destination G)\n  (local ((define (find-paths-ac orig seen)\n            (cond\n              [(symbol=? orig destination) (list (list destination))]\n              [(member orig seen) empty]   ; you can also return an error here. \n              [else (local \n                      ((define neighbor ((graph-neighbors G) orig))\n                       (define candidate \n                         (find-paths/list neighbor (cons orig seen))))\n                      (join orig candidate))]))\n\n          (define (find-paths/list lo-Os seen)  \n            (cond [(empty? lo-Os) empty]\n                  [else (local ((define candidate (find-paths-ac (first lo-Os) seen)))\n                          (cond [(empty? candidate) (find-paths/list (rest lo-Os) seen)]\n                                [else \n                                  (append candidate\n                                    (find-paths/list (rest lo-Os) seen))]))]))) \n    (find-paths-ac origination empty)))\n```\n\n\nIn this version, I have added an argument to keep track of the nodes I have already seen. And it will\nsignal an error if it gets to the same node twice (loop).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Generate paths in using Networkx graph\r\n                \r\nI am trying to generate some random paths for a pair of nodes. My networkx graph has 44012 nodes and 84154 edges. Following is my code to generate the paths:\n\n```\n   for n1 in G.nodes_iter():\n#        print (G.node[n1]['id'])\n        i+=1\n        if (i > 10):\n            break;\n        for n2 in G.nodes_iter():\n#            print (G.node[n2]['id'])\n            if(G.node[n1]['id']==G.node[n2]['id']):\n                continue\n            i += 1\n            if(i>10):\n                break;\n            if(nx.has_path(G,n1,n2)):\n                shortest_path_length = nx.shortest_path_length(G,n1,n2)\n                paths= (nx.all_simple_paths(G,n1,n2,cutoff=shortest_path_length+1))\n                print(paths)\n                for path in paths:\n                    print(\"hello\")\n```\n\n\nI get the following output:\n\n```\n<generator object _all_simple_paths_graph at 0x03690F60>\nhello\n```\n\n\nI think the execution is stuck in the last for loop. I am not sure what is wrong actually.\n\nAny suggestions to generate 20 simple paths for a pair of nodes?\n\nThanks! \n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find the common path among all possible paths in a directed graph\r\n                \r\nI'm trying to find the common nodes that are always visited by each and every possible path in a cyclic directed graph. My idea would be to compute all possible paths and then search for the common elements. However, a) that does not seem to be very efficient and b) it does not account for cycles. \n\nThe goal: is to implement oblivious hashing perimeter as a tamper-resistance method. For that I need to identify a set of common basic blocks that are input agnostic in a control flow graph. Put another way, I want to find deterministic chunks of a program (set of basic blocks) that will be executed for any given input.\n    ", "Answer": "\r\nTo do what you want to do, you need to provide a set of start vertices and end vertices for the paths. So your statement would be:\n\n\n  Find all vertices that are always passed when traversing from any vertex in set S to any vertex in set E.\n\n\nThen you will notice that the vertices you are searching for are Vertex Separators. Algorithms exist to compute a minimum vertex separator.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Saving the shortest paths in a graph using the Floyd Warshall algorithm in java\r\n                \r\nI am trying to write a Betweeness Centrality method for a undirected, unweighted (weight = 1) Graph in Java. The way I have gone about it is by finding all of the shortest paths in the graph, and then iterating through those paths and counting how often a vertex is a step in that path. I have used the Floyd Warshall algorithm to find the shortest paths, and used another array to reconstruct the paths, similar to the pseudo code on the Wikipedia. \n\nHowever, my results are not correct, and I have tried figuring out where the problem lies but I can't. I will just post the whole code in here for completeness sake, however it is messy so I apologize. I will comment the bits where I think the problems would occur.\n\n```\npublic void calculateBetweenessCentrality() {\n    // Floyd warshall algorithm, storing paths with R\n    int noPath = Integer.MAX_VALUE / 4;\n    int[][] adjMatrix = getAdjacencyMatrix();\n    int distances[][] = new int[numVertices][numVertices];\n    int[][] R = new int[numVertices][numVertices];\n\n    // Initialize the arrays, setting \"-5000\" as null instead. Possible error here?\n    for (int i = 0; i < numVertices; i++) {\n        for (int j = 0; j < numVertices; j++) {\n            if (adjMatrix[i][j] == 0) { \n                distances[i][j] = noPath;\n                R[i][j] = -5000; // null\n            }\n            else {\n                distances[i][j] = adjMatrix[i][j];\n                R[i][j] = j;\n            }\n\n        }\n    }\n    // Do the algorithm, and save in R, possible error here?\n    for (int k = 0; k < numVertices; k++) {\n        for (int i = 0; i < numVertices; i++) {\n            for (int j = 0; j < numVertices; j++) {\n                if (distances[i][j] > distances[i][k] + distances[k][j]) {\n                    distances[i][j] = distances[i][k] + distances[k][j];\n                    R[i][j] = R[i][k];\n                }\n\n            }\n        }\n    }\n\n    // Go through R and construct the shortest paths, record the frequency for each node (indexs). Possible error here?\n    HashMap<Integer, Integer> frequencies = new HashMap<>(); // Key = index, Value = frequency\n    for (int i = 0; i < numVertices; i++) {\n        for (int j = 0; j < numVertices; j++) {\n            ArrayList<Integer> path = findShortestPath(R, i, j);\n            for (int p : path) {\n                int freq = frequencies.containsKey(p) ? frequencies.get(p) : 0;\n                frequencies.put(p, freq + 1);\n            }\n        }\n    }\n\n    HashMap<Integer, Integer> temp = new HashMap<Integer, Integer>(); // Instead of printing the vertex's adjacency matrix index value, get the actual value for displaying purposes.\n    for (Entry<Integer, Integer> freq : frequencies.entrySet()) {\n        temp.put(verticesIndexValue.get(freq.getKey()), freq.getValue());\n\n    }\n    System.out.println(\"Top 5 nodes: \\nNode - Count\");\n    frequencies.entrySet().stream().sorted(Map.Entry.comparingByValue(Collections.reverseOrder())).limit(5)\n            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new))\n            .forEach((node, frequency) -> System.out.println(node + \" - \" + frequency));\n\n}\n\nprivate ArrayList<Integer> findShortestPath(int[][] R, int u, int v) {\n\n    ArrayList<Integer> paths = new ArrayList<>();\n\n    if(R[u][v] == -5000)\n        return paths;\n\n    paths.add(u);\n    while(u != v) {\n        u = R[u][v];\n        paths.add(u);\n    }\n\n    return paths;\n}\n```\n\n\nThe graph that I am testing this on is from this input here, where each line is an edge. The graph in that pastebin creates two connected components. The output I get for the first component is as follows:\n\n```\nTop 5 nodes: \nNode - Count\n11336782 - 11393\n50393960 - 9047\n627363 - 4079\n849131 - 3799\n5676102 - 3351\n```\n\n\nThe answer is actually that 50393960 is the top node. If anybody could please guide me to where I am going wrong, I'd appreciate it massively. Thanks =)\n    ", "Answer": "\r\nYour code contains mistake in the place where it calculates frequencies - according to definition of Betweenness centrality when calculating it for particular vertex ```\nV```\n  you should exclude shortest paths which start or end with vertex ```\nV```\n. Basically it means that when iterating over shortest paths you shoud not add start and end vertexes to frequencies. Try this instead:\n\n```\nHashMap<Integer, Integer> frequencies = new HashMap<>(); // Key = index, Value = frequency\nfor (int i = 0; i < numVertices; i++) {\n    for (int j = 0; j < numVertices; j++) {\n        ArrayList<Integer> path = findShortestPath(R, i, j);\n        for (int p : path) {\n            if (p == i || p == j) {\n               continue;\n            }\n            int freq = frequencies.containsKey(p) ? frequencies.get(p) : 0;\n            frequencies.put(p, freq + 1);\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All possible paths in an undirected graph with some restrictions\r\n                \r\nI should find all paths with a graph (24 nodes and 42 vertices). My starting nodes are 1, 2 or 3, and the final nodes are 10, 12, 13, 16, 17, 18, 20, 21, 22 and the rest are intermediate nodes. The sparse adjacency matrix of my graphs A is as follow. \nI found the following Matlab code to find the all paths from a starting point to a target point, but the problem is that for example if the starting point is 1, we should not have node 2 in path. In the other words, only one starting point should appear in a path. Can anyone help me with this? \n\n```\nfunction paths = findpaths(Adj, nodes, currentPath, start, target)\n     paths = {};\n     nodes(start) = 0;\n     currentPath = [currentPath start];\n     childAdj = Adj(start,:) & nodes;\n     childList = find(childAdj);\n     childCount = numel(childList);\n    if childCount == 0 || start == target\n      if start == target\n        paths = [paths; currentPath];\n     end\n    return;\n   end\n   for idx = 1:childCount\n       currentNode = childList(idx);\n       newNodes = nodes;\n       newNodes(currentNode) = 0;\n       newPaths = findpaths(Adj, newNodes, currentPath, currentNode, target);\n       paths = [paths; newPaths];\n   end\n  end\n```\n\n\nExample graph:\n\n```\n  A =\n\n  (4,1)         1\n  (5,1)         1\n  (9,1)         1\n  (10,1)        1\n  (12,1)        1\n  (5,2)         1\n  (7,2)         1\n  (8,2)         1\n  (8,3)         1\n  (1,4)         1\n  (5,4)         1\n  (6,4)         1\n  (9,4)         1\n  (15,4)        1\n  (1,5)         1\n  (2,5)         1\n  (4,5)         1\n (14,5)         1\n (17,5)         1\n  (4,6)         1\n (16,6)         1\n (19,6)         1\n (20,6)         1\n (22,6)         1\n  (2,7)         1\n (20,7)         1\n (23,7)         1\n  (2,8)         1\n  (3,8)         1\n (23,8)         1\n  (1,9)         1\n  (4,9)         1\n (13,9)         1\n (1,10)         1\n(12,10)         1\n(13,10)         1\n(14,11)         1\n(17,11)         1\n (1,12)         1\n(10,12)         1\n(16,12)         1\n(18,12)         1\n (9,13)         1\n(10,13)         1\n(16,13)         1\n(18,13)         1\n (5,14)         1\n(11,14)         1\n(17,14)         1\n (4,15)         1\n (6,16)         1\n(12,16)         1\n(13,16)         1\n(18,16)         1\n (5,17)         1\n(11,17)         1\n(14,17)         1\n(12,18)         1\n(13,18)         1\n(16,18)         1\n(19,18)         1\n(21,18)         1\n(22,18)         1\n (6,19)         1\n(18,19)         1\n(21,19)         1\n (6,20)         1\n (7,20)         1\n(18,21)         1\n(19,21)         1\n(24,21)         1\n (6,22)         1\n (19,22)        1\n (24,22)        1\n  (7,23)        1\n  (8,23)        1\n (19,24)        1\n (21,24)        1\n (22,24)        1\n```\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths in a tree\r\n                \r\nWhat's the best way to find all possible paths in a given tree? Let's say I have a graph where a path exists between the following nodes\n\n1,2\n\n1,3\n\n2,5\n\n2,6\n\nSo I should get an output somewhat like this:-\n1\n\n1,2\n\n1,3\n\n1,2,5\n\n1,2,6\n\n2\n\n2,5\n\n2,6\n\n2,1,3\n\nand so on..\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find path in graph with weighted vertices\r\n                \r\nI have the following graph, where each vertex has an associated \"probability\"\n(graph with weighted nodes).\n\n\n\nI want to find the path from node 0 to the last node (highest index, here 5), which has the highest multiplied probability. In this graph, the best path is 0-1-4-5, which gives 0.72 probability.\n\nI've thought about using BFS to find all paths between the start and end node, and then multiplying the probability for each node, but I think it's too näive of an approach to work for all graphs. How could I solve this using python?\n    ", "Answer": "\r\nAs Julien suggested, Dijkstra's algorithm would be a good start here.  There are two differences between your problem and normal Dijkstra's.\n\n\nDijkstra's algorithm minimizes the sum of weights.  To maximize the product of probabilities, you can map each weight ```\np```\n to ```\n-log(p)```\n.  Quick proof: maximizing the product of ```\n(x1*x2*...*xn)```\n is the same as maximizing ```\nlog(x1*x2*...*xn)```\n since ```\nlog```\n is monotonically increasing.  ```\nargmax(log(x1*x2*...*xn)) = argmax(log(x1)+log(x2)+...+log(xn)) = argmin(-log(x1)-log(x2)-...-log(xn)))```\n.  Note that if you want the resulting probability, you would invert your result by taking ```\n10^(-c)```\n where ```\nc```\n is the minimum cost as returned by Dijkstra's using the above reduction (assuming you took the log with base 10).  Note also that if any probabilities are 0, ```\nlog(0)```\n is undefined, so you should handle this by making the weight infinite (so a path would never go through that node).\nDijkstra's uses weighed edges, whereas you have weighted nodes.  But it is a simple reduction from weighted nodes to weighted edges.  Define the weight of an edge from ```\nu```\n to ```\nv```\n with ```\nedge_weight(u,v) = vertex_weight(v)```\n.  Judging by your picture, you have an undirected graph, so you would need to replace each undirected edge with two directed edges, using the same weights as described above (note that the two edges between two vertices ```\nu```\n and ```\nv```\n will have different weights, unless ```\nvertex_weight(u) == vertex_weight(v)```\n).  Also, if you want to return the value of the shortest path, you will need to add ```\nvertex_weight(source_vertex)```\n to the final cost, since this cost is skipped in the reduction.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all Paths in Graph given the Vertices and some Restrictions\r\n                \r\nI try to come up with an algorithm for the following problem, but until now I was not able to solve it. I guess this problem falls into the category of graph problems. Maybe someone can give me a hint to the right keywords/algorithms. :)\n\nSo my problem: I have a set of vertices and a number of restrictions. I try to find all the edges between the vertices in regard of the restrictions.\n\n\nI have a nxn matrix of vertices\nI have a start (S) and an end (E) (sound's like a network/flow)\nThe vertices in the column and row of S and E can be ignored\nS is located at (1,1) in the matrix and E is located at (n,n)\nThe graph is directed from S to E, i.e. I have to find a way from the top left to the bottom right. I can not go back.\nFor each step through the matrix I have to increase the row and the column\nI have to cross at least one vertex between S and E \n\n\nLet's take a look at this example:\n\n```\nS - - -\n- 1 2 -\n- 3 4 -\n- - - E\n```\n\n\nI can identify the paths\n\n\nS > 1 > 4 > E\nS > 3 > E\nS > 2 > E\nS > 4 > E (which will be in our use case the same as S14E, but this doesn't matter rn. If we can filter it out through the algorithm it would be nice, but not a must.)\n\n\nA more complex example\n\n```\nS - - - -\n- 1 2 3 -\n- 4 5 6 -\n- - - - E\n```\n\n\nWith the following paths:\n\n\nS > 1 > 5 > E\nS > 1 > 6 > E\nS > 1 > E\nS > 2 > 6 > E\nS > 2 > E (which is the same as S26E)*\nS > 3 > E\nS > 4 > E\nS > 5 > E (which is the same as S15E)*\nS > 6 > E\n\n\n*in our use case\n\nOne can also think of the problem of dividing a rectangle with height B and width T into equally sized rectangles. The number of separations of B and T should be modifiable in our use case. See the picture for an example\n    ", "Answer": "\r\nIn comment I hinted on dynamic programming, which is way to solve this problem if only number of solutions are needed. I misread question.\n\nTo print all solutions you have to calculate all solutions and that is done by recursion. Step of recursion has property gcd(x, y)=1, since if it is not a case than step would 'jump' over some node(s).\n\nHere is simple python solution that prints results in format you specified.\n\n```\nfrom fractions import gcd\n\ndef valid_steps(max_x, max_y):\n    for x in xrange(1, max_x+1):\n        for y in xrange(1, max_y+1):\n            if gcd(x, y) == 1:\n                yield x, y\n\ndef _solve(n, m, path, xy_2_name):\n    x, y = path[-1]\n    if x == n and y == m:\n        print [xy_2_name[xy] for xy in path]\n        return\n    for sx, sy in valid_steps(n - x, m - y):\n        _solve(n, m, path + [(x+sx, y+sy)], xy_2_name)\n\ndef solve(n, m):\n    xy_2_name = dict()\n    xy_2_name[(1, 1)] = 'S'\n    xy_2_name[(n, m)] = 'E'\n    c = 1\n    for y in xrange(2, m):\n        for x in xrange(2, n):\n            xy_2_name[(x, y)] = c\n            c += 1\n    _solve(n, m, [(1, 1)], xy_2_name)\n\nsolve(5, 4)\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to restrict certain paths in NetworkX graphs?\r\n                \r\nI am trying to calculate shortest path between 2 points using Dijkstra and A Star algorithms (in a directed NetworkX graph). \n\nAt the moment it works fine and I can see the calculated path but I would like to find a way of restricting certain paths.\n\nFor example if we have following nodes:\n\nnodes = [1,2,3,4]\n\nWith these edges:\n\nedges = ( (1,2),(2,3),(3,4) )\n\nIs there a way of blocking/restricting  1 -> 2 -> 3 but still allow 2 -> 3 & 1 -> 2.\n\nThis would mean that: \n\n\ncan travel from 1 to 2\ncan travel from 2 to 3\ncannot travel from 1 to 3 .. directly or indirectly (i.e. restrict 1->2->3 path).\n\n\nCan this be achieved in NetworkX.. if not is there another graph library in Python that would allow this ?\n\nThanks.\n    ", "Answer": "\r\nInteresting question, I never heard of this problem, probably because I don't have much background in this topic, nor much experience with NetworkX. However, I do have a idea for a algorithm. This may just be the most naive way to do this and I'd be glad to hear of a cleverer algorithm.\n\nThe idea is that you can use your restriction rules to transform you graph to a new graph where all edges are valid, using the following algorithm. \n\nThe restriction of path (1,2,3) can be split in two rules: \n\n\nIf you came over (1,2) then remove (2,3)\nIf you leave over (2,3) then remove (1,2)\n\n\nTo put this in the graph you can insert copies of node 2 for each case. I'll call the new nodes 1_2 and 2_3 after the valid edge in the respective case. For both nodes, you copy all incoming and outgoing edges minus the restricted edge.\n\nFor example:\n\n```\nNodes = [1,2,3,4]\nEdges = [(1,2),(2,3),(4,2)]\n```\n\n\nThe valid path shall only be 4->2->3 not 1->2->3. So we expand the graph:\n\n```\nNodes = [1,1_2,2_3,3,4] # insert the two states of 2\nEdges = [ # first case: no (1_2,3) because of the restriction \n          (1,1_2), (4, 1_2)\n          # 2nd case, no (1,2_3)\n          (2_3,3), (4,2_3)]\n```\n\n\nThe only valid path in this graph is 4->2_3->3. This simply maps to 4->2->3 in the original graph.\n\nI hope this answer can at least help you if you find no existing solution. Longer restriction rules would blow up the graph with a exponentially growing number of state nodes, so either this algorithm is too simple, or the problem is hard ;-)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding maximum number of edge-disjoint path in a directed graph\r\n                \r\nHow can I find the maximum number of edge-disjoint path in a directed graph . the graph is unweighted.\nSuppose the graph is like follow ...\n\n```\n1 - 2 , 1 - 3 , 4 - 1 , 5 - 1```\n\n\nSo there is two edge disjoint paths in the graph, ```\n4->1->2```\n and ```\n5->1->3```\n\n\nHow can I solve the problem using matching algorithm ?\n\nMy problem is ... suppose i have a directed graph(may contain cycle).\nif i put a 'guard' at a node it can start it's journey from that node.\nThe guard may visit any city multiple times even the cities that are already visited by other guards.\nThe objective is to find the minimum number of guards to secure all the nodes.\n    ", "Answer": "\r\nCounting all paths:\n\n\nStart with all the edges in the graph as your list of available edges.\nWhile there are still available edges, keep extracting paths and counting them.\n\n\nExtracting a path:\n\n\nRemove the first (or any) available edge and call it your current path.\nTry to match your current path's start or end to an available edge's end or start.\nIf no available edge matches, then this path is finished.\nIf an available edge can lengthen the path, then add it to your current path, remove that edge from the list of available edges, and keep trying to lengthen the path.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "K longest paths in a DAG\r\n                \r\nI want to find K longest paths in a Directed Acyclic Graph (DAG). I have read few articles about it but I couldn't find any actual code that has implemented it. Can somebody help me with a python or pseudo code?\n\nHere is one interesting algorithm explanation:\nhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC3009499/\n    ", "Answer": "\r\nTry https://baoilleach.blogspot.ca/2013/11/the-shortest-route-to-longest-path.html\n\nAlso you can negate weights and apply some existing package for k shortest paths in weighted graph, granted negative weights are supported.\n\nIf negatives are not supported you can resort to graph weight rewriting as in Johnson algorithm (see wikipedia or/and https://www.researchgate.net/publication/275645125_Weighted_graph_algorithms_with_Python and then apply k shortest paths, say Dijkstra's  Python Dijkstra k shortest paths\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to implement the search for all paths inside a directed graph in JavaScript?\r\n                \r\nI would like to find all distinct paths without cycles in following graph:\n\n\n\nFrom this graph, i composed the adjacency list, starting from node 0 and going to the right (in the picture above):\n\n```\nvar rightAdjacent = [[1,7],[2],[3,9],[4],[5],[6,10],[8],[2],[5],[11],[12]];\n```\n\n\nAs i am a noob in graphs, i started from a canonical algorithm for BFS, which seems to me the cheapest way to get what i need:\n\n```\n...    \nvar paths = []  \nqueue.push(0); // Starting node\nparents[0] = null;\n\nwhile (queue.length > 0) {\n    u = queue.splice(0, 1)[0];\n    for (i = 0, l= rightAdjacent.length; i < l; i++) { // Explore edge(u, v).\n        v = rightAdjacent[u][i];\n        if (rightAdjacent[v]) {\n            if(rightAdjacent[v].status === 'unexplored') {\n                rightAdjacent[v].status = 'exploring'; // Node u has been discovered\n                queue.push(v);\n                parents[v] = u;\n            }\n        } else {\n            paths.push(collectPath(parents));\n        }\n    }\n    rightAdjacent[u].status = 'explored'; \n}\n```\n\n\n... but in my first attempt i was able to collect only the list of the connected components, after which and until now, only garbage. \n\nI have also composed the left-adjacency list, not knowing if this could be useful to speed up the search or to back-trace the discovered path. Any clue about this?\n\nFor the graph in the picture, i'm expecting following result (please correct me if i'am wrong):\n\n```\n[0,1,2,3,4,5,6],\n[0,1,2,9,5,6],\n[0,1,2,9,5,10,11,12],\n[0,7,8,2,3,4,5,6],\n[0,7,8,2,9,5,10,11,12]\n```\n\n\nwhere each single path has the nodes ordered from the starting node, through the first encountered, until the last.\n\nStarting from an adjacency list, and without using recursion, wouldn't it be this the simplest way to collect all this paths, (the ordered parent nodes of all the parent paths) in my example, starting from node 0 and ending at nodes 6 and 12?\n\nWhat is wrong in this piece of code?\n    ", "Answer": "\r\nYour rightAdjacent is missing the neighbours of node 6, which should be an empty array. An easy solution to implement is to do bfs but deep copy the visited and current path when you add a node to your path. When you have no neightbours, you can output/save the current path\n\n\r\n\r\n```\n\t\tvar rightAdjacent = [[1,7],[2],[3,9],[4],[5],[6,10],[],[8],[2],[5],[11],[12]];\r\n\r\n    var queue = [{visited:{0:true},path:[0]}] // start with node 0\r\n\r\n    function bfs(){\r\n       while(queue.length){\r\n           obj = queue.pop() // get last added path\r\n           node = obj.path[obj.path.length-1] // get last visited node from that path\r\n           visited = obj.visited\r\n           if(node >= rightAdjacent.length || rightAdjacent[node].length == 0){ // we reached a leaf node\r\n               console.log(obj.path)\r\n           }else{\r\n             for(var i=0;i<rightAdjacent[node].length;i++){ // we need to add the neighbours not visited\r\n                 if(!visited[rightAdjacent[node][i]]){\r\n                     visited[rightAdjacent[node][i]] = true\r\n                     arr = obj.path.slice(0);\r\n                    arr.push(rightAdjacent[node][i]); queue.push({visited:JSON.parse(JSON.stringify(visited)),path:arr}) // deep copy of both\r\n                 }\r\n             }\r\n           }\r\n       }\t\r\n    }\r\n\r\n    bfs()```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to print the paths in Dijkstra's shortest path algorithm\r\n                \r\nCan anyone help me, How to print the paths in Dijkstra's Shortest Path Algorithm?\nI have worked on the Undirected Weighted graph and found the shortest path in int. but printing their paths is quite complicated. How to print their paths ?????\nI was working on a program that prints the distance and the path. I got the distance working well, but the problem I am having comes when I try to print the path.\n\nVertex, Edge.\n\n```\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<string>\n#include<map>\n\nusing namespace std;\nmap<char,int> m = {{'A',1}, {'B',2}, {'C',3}, {'D',4}, {'E',5}};\nvector<char> vec;\n\nint main()\n{\n    int Vertex,Edges;\n    char Source_station;\n    cout<<\"Vertex and Edges : \";\n    cin>>Vertex>>Edges;\n    vector<pair<int,int>> graph[Vertex+1];\n    \n    int Distance;\n    char Starting_station,Ending_station;\n    cout<<\"Starting_station , Ending_station , Distance:\";\n    for(int i=0;i<Edges;++i)\n    {\n        cin>>Starting_station>>Ending_station>>Distance;\n        graph[m[Starting_station]].push_back(make_pair(m[Ending_station],Distance));\n        graph[m[Ending_station]].push_back(make_pair(m[Starting_station],Distance));\n    }\n\n    char Passenger_destination;\n    cout<<\"Enter the Source_station and Passenger Destination : \"<<endl;\n    cin>>Source_station>>Passenger_destination;\n\n    priority_queue< pair<int,int> , vector<pair<int,int>> , greater<pair<int,int>>> pq;\n\n    vector<int> distTo (Vertex+1, INT32_MAX);\n    distTo[m[Source_station]]=0;\n    pq.push(make_pair(0,m[Source_station]));\n\n\n    while(!pq.empty())\n    {\n        int dist = pq.top().first;\n        int prev = pq.top().second;\n        pq.pop();\n\n        vector<pair<int,int>> :: iterator it;\n        for(it=graph[prev].begin(); it!=graph[prev].end(); it++)\n        {\n            int next = it->first;\n            int nextDist = it->second;\n            if(distTo[next] > distTo[prev] + nextDist)\n            {\n                distTo[next] = distTo[prev] + nextDist;\n                pq.push(make_pair(distTo[next] , next));\n            }\n        }\n    }\n\n    cout<<\"The distance from source, \"<<Source_station <<\" are : \"<<endl;\n    for(int i=1;i<=Vertex; i++)\n    {\n        if(i==m[Passenger_destination])\n            cout<<distTo[i]<<\" \";\n    }\n    cout<<endl;\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nYou can update your code to store parent pointers and recover the shortest path using parent pointers.  More specifically, for each node v, you can store its parent p[v], which can be initialized to nil.  If the condition (distTo[next] > distTo[prev] + nextDist) is satisfied, besides updating distTo[next], you can also store that the parent of next is prev, i.e. something like p[next]=prev.  In other words, you keep a record of which predecessor node gave you the current best shortest path to a node next.\nAfter the shortest distances have been calculated, you can print the shortest path to a node x by starting from x and following parent pointers p[x], p[p[x]], etc, until you hit the source.  This gives the shortest path.\nIt's a common practice to augment dynamic programming algorithms to store parent pointers.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "finding the shortest path in a graph from start to end vertex\r\n                \r\nI am trying to find the shortest path among all possible paths in a graph. I wrote the below program, and when I try to search path from vertex 'A' to 'D', it returns ['A', 'B', 'C', 'D']. But the shortest distance is ['A', 'B', 'D']. Is there a way to find it given that I have already found all the possible nodes?\n\n```\nfrom collections import defaultdict\n\n\ndef find_path(graph,start,end,path=[]):\n    path = path + [start]\n    print \"intermediate\", path\n    if start == end:\n        return path\n    if not graph.has_key(start):\n        return None\n    for node in graph[start]:\n        print \"node\",node\n        if node[1] not in path:\n            newpath = find_path(graph,node[1],end,path)\n            if newpath :\n                return newpath\n    return None\n\nif __name__ == '__main__':\n    graph = defaultdict(list)\n    graph = { \n            'A': [('A','B'),('A','C')],\n            'B' : [('B','C'),('B','D')],\n            'C' : [('C','D')],\n            'D' : [('D','C')],\n            'E' : [('E','F')],\n            'F' : [('F','C')]\n            }\n\n    path = find_path(graph,'A','D')\n```\n\n    ", "Answer": "\r\nI have now added a new function, which is typically a greedy algorithm. It closes the recursion, if its sees a node connected to 'end' node. Thanks @Jonathan for your advice. Will appreciate any criticism towards this approach.\n\n```\ndef shortest_path(graph,start,end,short_path=[]):\n    short_path = short_path + [start]\n    #print \"Initial short path\",short_path\n    if start == end:\n        return short_path\n    if not graph.has_key(start):\n        return None\n    for node in graph[start]:\n        #print \"short node\",graph[start]\n        vend = [x[1] for x in graph[start] if x[1] == end]\n        print \"v_end\",vend\n        if vend :\n            if vend[0] == end:\n                #print \"printing end nodes\",vend,start\n                tmp_path = shortest_path(graph,end,end,short_path)\n                if tmp_path:\n                    #print \"shortest intermediate path\",tmp_path\n                    return tmp_path\n\n        elif node[1] not in short_path:\n            tmp_path = shortest_path(graph,node[1],end,short_path)\n            #print tmp_path, \"start\",node[1], \"end\",end\n            if tmp_path:\n                #print \"shortest intermediate\",tmp_path\n                return tmp_path\n        else:\n            return None\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Python: List all possible paths in graph represented by dictionary\r\n                \r\nI have a dictionary with keys representing nodes and values representing possible nodes that the key can traverse to. \n\nExample: \n\n```\ndependecyDict = { 'A': ['D'], 'B': ['A', 'E'], 'C': ['B'], 'D': ['C'], 'G':['H']}\n```\n\n\nI want to create a new dicitonary, ChainsDict, that will contain all 'values' that each 'key' can traverse to by means of dependecyDict.\n\nFor example, the output of the program with this example will be:\n\n```\nChainsDict = {'A': ['D', 'C', 'B','E'], 'B':['A','D','C','E'], 'C':['B','A','D','E'], 'D':['C','B','A','E'], 'G': ['H']}\n```\n\n\nI think using a recursive algorithm is the best way to go about making a solution and I tried modifying a shortest path traversing algorithm as follows:\n\n```\ndef helper(dependencyDict, ChainsDict):path = []\n    for key in dependencyDict:\n        path = path + [(recursiveRowGen(dependencyDict,key))]\n    for paths in path:\n        ChainsDict[paths[0]] = paths[1:]\n    print(finalLineDict)\ndef recursiveRowGen(dependencyDict,key,path = []):\n    path = path + [key]\n\n        if not key in dependencyDict:\n        print(\"no key: \",key)\n        return path\n        print(dependencyDict[key])\n        for blocking in dependencyDict[key]:\n            if blocking not in path:\n                newpath = recursiveRowGen(dependencyDict,blocking,path)\n                if newpath:\n                    return newpath             \n    return path\n```\n\n\nThis code however is having problems capturing the correct output when a key in dependecyDict has more than one value.\nI found a hacky solution but it doesn't feel very elegant. Any help is appreciated, thanks!\n    ", "Answer": "\r\nHere is a recursive solution:\n\nCode\n\n```\ndef get_chain_d(argDict):\n    def each_path(i,caller_chain):\n        a=[]\n        caller_chain.append(i)\n        b = argDict.get(i,[])\n        for j in b:\n            if j not in caller_chain:\n                a.append(j)\n                a.extend(each_path(j,caller_chain))\n        return a\n\n    return {i:each_path(i,[]) for i in argDict}\n\ndependecyDict = { 'A': ['D'], 'B': ['A', 'E'], 'C': ['B'], 'D': ['C'], 'G':['H']}\n\nprint(get_chain_d(dependecyDict))\n```\n\n\nOutput:\n\n```\n{'B': ['A', 'D', 'C', 'E'], 'A': ['D', 'C', 'B', 'E'], 'D': ['C', 'B', 'A', 'E'], 'C': ['B', 'A', 'D', 'E'], 'G': ['H']}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All unique paths in a directed acyclic graph, in randomized order, via Python generator?\r\n                \r\nI have a Directed Acyclic Graph (DAG), which consists of layers, with two subsequent layers being completely bipartite (much like a neural net), like the following:\n\n\n\nI want to stream all paths in the DAG, in an iterative manner, via some generator, in a randomized order. Because, output must not be in order, textbook DFS approaches are out of question. Memory is an issue, so I don't want to store any paths that I have yielded before, except the DAG alone, which could be modified however is needed.\n\nExample, the desired output for the above DAG is:\n\n```\n(1, 4, 6, 8)\n(3, 4, 5, 8)\n(2, 4, 7, 8)\n(3, 4, 6, 8)\n(1, 4, 5, 8)\n(3, 4, 7, 8)\n(1, 4, 7, 8)\n(2, 4, 6, 8)\n(2, 4, 5, 8)\n```\n\n\ninstead of the following produced by DFS:\n\n```\n(1, 4, 5, 8)\n(1, 4, 6, 8)\n(1, 4, 7, 8)\n(2, 4, 5, 8)\n(2, 4, 6, 8)\n(2, 4, 7, 8)\n(3, 4, 5, 8)\n(3, 4, 6, 8)\n(3, 4, 7, 8)\n```\n\n\nThanks for your help.\n\nUpdate:\n\nI have the following code\n\n```\ngraph = {\n    1: set([4]),\n    2: set([4]),\n    3: set([4]),\n    4: set([5, 6, 7]),\n    5: set([8]),\n    6: set([8]),\n    7: set([8])\n}\n\ndef dfs_paths(graph, start, goal):\n    stack = [(start, [start])]\n    while stack:\n        (vertex, path) = stack.pop()\n        for next in graph[vertex] - set(path):\n            if next == goal:\n                yield path + [next]\n            else:\n                stack.append((next, path + [next]))\n\ndef run_paths():\n    for start in [1, 2, 3]:\n        for path in dfs_paths(graph, start, 8):\n            print path\n```\n\n\nFinding all paths and then randomly streaming them will not work for me, as I do not want to store any paths I will be generating.\n    ", "Answer": "\r\nPlease note that you're contradicting yourself: you want output to be \"strictly unordered\", but you have no state or memory for the sequence.  This is simply not possible via information theory.  However, if your goal is simply to have a \"shuffle\" -- a different sequence that a casual observer won't recognize as a predetermined sequence, then you have a chance.\n\nFirst, determine your choice points and sizes.  For instance, your choices above are [1, 2, 3] x [5, 6, 7].  This gives you 3*3 = 9 paths to generate.  Let's add a third choice for illustration, a [T, F] on the end.  This gives 3*3*2 = 18 paths.\n\nNow, use your favorite \"perfect sequence generator\" to create a simple function for you.  I'm assuming that something int he RNG process is allowed to recall the previous value or seed.  For ridiculous simplicity, let's use a trivial linear sequence ```\nf(n) = f(n-1) + 5 (mod 18)```\n.  This will give the sequence ```\n0 5 10 15 2 7 12 17 ...```\n\n\nNow have your path generator call this function on each iteration.  Simply convert the returned \"random\" number to digits in the given base sequence -- 3|3|2 in this case.  Let's look at the value 7, taking the conversion from left to right, using the bases in order:\n\n```\n7 divmod 3 => mod 1, quotient 2\n2 divmod 3 => mod 2, quotient 0\n0 divmod 2 => mod 0\n```\n\n\nThus, you choose the path with elements 1, 2, 0 of your three choice arrays.  The resulting path is (chosen nodes in bold):\n\n2 4 6 8 T\n\nIs that clear?  Does it solve your problem?\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding All Paths in this Directed Graph\r\n                \r\nI have recently discovered graphs and algorithms and am trying to solve a specific problem involving two different types of vertices: Users and Entities.  Details are as follows:\n\n\nThe graph is directed\nI am trying to find all paths from A to B\nA is always a User\nB can be a User or an Entity\nIf B is a User, maximum depth for the search is 3 edges\nIf B is an Entity, maximum depth is 2 edges\nI can not traverse any edges which are outbound from a User, unless the user is A\n\n\nAlthough the graph has two types of vertices, it is not bipartite.\n\nSo far I have managed to create a graph object which holds a vertex-indexed array of adjacency lists.  The adjacency lists are based on linked lists.\n\nI think I require some kind of variation on an All Paths algorithm, but I'm not quite sure.  In addition, not sure whether I should be looking at DFS or BFS.\n\nI am working in PHP, which complicates matters, since most examples are in Java.  What I'd really like is the pseudo code.\n\nAny ideas?  Thanks!\n    ", "Answer": "\r\nIt sounds like you're traversing some sort of LDAP implementation.  If you need a generic algorithm, just use a DFS, since it's easier to code.  Doing this is overkill though unless the depth will change.\n\nMost generic way\n\n```\n dfs(A,B):\n     return dfs(A,B,1);\n\n dfs_(u,B,depth):\n     if u == B:\n          return u;\n\n     if (u is User and depth > 3) or (u is Group and depth > 2):\n          return None;       \n\n     out = [];\n     for children of thing:\n          return max( dfs_(children,depth+1) ) # take the non-null one\n     out.append(u);\n     return out;\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "SQL - postgres - shortest path in graph - recursion\r\n                \r\nI have a table which contains the edges from node x to node y in a graph.\n\n```\nn1 | n2\n-------\na  | a\na  | b\na  | c\nb  | b\nb  | d\nb  | c\nd  | e\n```\n\n\nI would like to create a (materialized) view which denotes the shortest number of nodes/hops a path contains to reach from x to node y:\n\n```\nn1 | n2 | c\n-----------\na  | a  | 0\na  | b  | 1\na  | c  | 1\na  | d  | 2\na  | e  | 3\nb  | b  | 0\nb  | d  | 1\nb  | c  | 1\nb  | e  | 2\nd  | e  | 1\n```\n\n\nHow should I model my tables and views to facilitate this? I guess I need some kind of recursion, but I believe that is pretty difficult to accomplish in SQL. I would like to avoid that, for example, the clients need to fire 10 queries if the path happens to contain 10 nodes/hops.\n    ", "Answer": "\r\nThis works for me, but it's kinda ugly:\n\n```\nWITH RECURSIVE paths (n1, n2, distance) AS (\n    SELECT\n        nodes.n1,\n        nodes.n2,\n        1\n    FROM\n        nodes\n    WHERE\n        nodes.n1 <> nodes.n2\n\n    UNION ALL\n\n    SELECT\n        paths.n1,\n        nodes.n2,\n        paths.distance + 1\n    FROM\n        paths\n        JOIN nodes\n        ON\n            paths.n2 = nodes.n1\n    WHERE\n        nodes.n1 <> nodes.n2\n)\nSELECT\n   paths.n1,\n   paths.n2,\n   min(distance)\nFROM\n    paths\nGROUP BY\n    1, 2\n\nUNION\n\nSELECT\n    nodes.n1,\n    nodes.n2,\n    0\nFROM\n    nodes\nWHERE\n    nodes.n1 = nodes.n2\n```\n\n\nAlso, I am not sure how good it will perform against larger datasets. As suggested by Mark Mann, you may want to use a graph library instead, e.g. ```\npygraph```\n.\n\nEDIT: here's a sample with ```\npygraph```\n\n\n```\nfrom pygraph.algorithms.minmax import shortest_path\nfrom pygraph.classes.digraph import digraph\n\n\ng = digraph()\n\ng.add_node('a')\ng.add_node('b')\ng.add_node('c')\ng.add_node('d')\ng.add_node('e')\n\ng.add_edge(('a', 'a'))\ng.add_edge(('a', 'b'))\ng.add_edge(('a', 'c'))\ng.add_edge(('b', 'b'))\ng.add_edge(('b', 'd'))\ng.add_edge(('b', 'c'))\ng.add_edge(('d', 'e'))\n\nfor source in g.nodes():\n    tree, distances = shortest_path(g, source)\n    for target, distance in distances.iteritems():\n        if distance == 0 and not g.has_edge((source, target)):\n            continue\n        print source, target, distance\n```\n\n\nExcluding the graph building time, this takes 0.3ms while the SQL version takes 0.5ms.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find the shortest path in a graph which visits certain nodes\r\n                \r\nI have a undirected graph with about 100 nodes and about 200 edges.  One node is labelled 'start', one is 'end', and there's about a dozen labelled 'mustpass'.\n\nI need to find the shortest path through this graph that starts at 'start', ends at 'end', and passes through all of the 'mustpass' nodes (in any order).\n\n( http://3e.org/local/maize-graph.png / http://3e.org/local/maize-graph.dot.txt is the graph in question - it represents a corn maze in Lancaster, PA)\n    ", "Answer": "\r\nEveryone else comparing this to the Travelling Salesman Problem probably hasn't read your question carefully. In TSP, the objective is to find the shortest cycle that visits all the vertices (a Hamiltonian cycle) -- it corresponds to having every node labelled 'mustpass'.\n\nIn your case, given that you have only about a dozen labelled 'mustpass', and given that 12! is rather small (479001600), you can simply try all permutations of only the 'mustpass' nodes, and look at the shortest path from 'start' to 'end' that visits the 'mustpass' nodes in that order -- it will simply be the concatenation of the shortest paths between every two consecutive nodes in that list.\n\nIn other words, first find the shortest distance between each pair of vertices (you can use Dijkstra's algorithm or others, but with those small numbers (100 nodes), even the simplest-to-code Floyd-Warshall algorithm will run in time). Then, once you have this in a table, try all permutations of your 'mustpass' nodes, and the rest.\n\nSomething like this:\n\n```\n//Precomputation: Find all pairs shortest paths, e.g. using Floyd-Warshall\nn = number of nodes\nfor i=1 to n: for j=1 to n: d[i][j]=INF\nfor k=1 to n:\n    for i=1 to n:\n        for j=1 to n:\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n//That *really* gives the shortest distance between every pair of nodes! :-)\n\n//Now try all permutations\nshortest = INF\nfor each permutation a[1],a[2],...a[k] of the 'mustpass' nodes:\n    shortest = min(shortest, d['start'][a[1]]+d[a[1]][a[2]]+...+d[a[k]]['end'])\nprint shortest\n```\n\n\n(Of course that's not real code, and if you want the actual path you'll have to keep track of which permutation gives the shortest distance, and also what the all-pairs shortest paths are, but you get the idea.) \n\nIt will run in at most a few seconds on any reasonable language :)\n[If you have n nodes and k 'mustpass' nodes, its running time is O(n3) for the Floyd-Warshall part, and O(k!n) for the all permutations part, and 100^3+(12!)(100) is practically peanuts unless you have some really restrictive constraints.]\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "The shortest path in graph with increasing edges\r\n                \r\nI have oriented graph and I have to find the shortest path between Q pairs of nodes (A,B). But the path must go over max. N edges and length of these edges must be increasing (from A to B (1,3,5,9)).\nOutput is length of this path. (If it doesn't exist, output -1).\n\nI tried to represent the graph as 3D arraylist and then recursive find the shortest path, which fill conditions, but I don't know what is wrong.\nThis code don't work, it is infinity recursion:\n\n```\npublic static int path(int v, int c, int mv, int dc, int pv) {\n    if (pv==mv) {\n        if (Gi.get(v).contains(c)) {\n            return G.get(v).get(c).get(0);\n        }\n        return -1;\n    }\n    bol[v]=true;\n    for (int i=0; i<G.get(v).size(); i++) {\n        for (int j=0; j<G.get(v).get(i).size(); j++) {\n            if (!bol[Gi.get(v).get(i)]) {\n                if (G.get(v).get(i).get(j)>dc) {\n                    int ce=path(Gi.get(v).get(j),c,G.get(v).get(i).get(j),dc,pv+1);\n                    if (ce!=-1) return ce;\n                }\n            }\n            else {\n                return -1;\n            }\n        }   \n    }\n    return vz;\n}\n```\n\n\nCan someone help me?\n\nThanks, Ferko\n    ", "Answer": "\r\nYou can do it with a Min Priority Queue and a single-linked-list data structure representing the path:\n\n```\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\n\npublic class DijkstraTest\n{\n  public static PathSegment Dijkstra(\n      final Vertex from,\n      final Vertex to,\n      final int maxSize\n  )\n  {\n    if ( from == null )\n      throw new IllegalArgumentException( \"From vertex cannot be null\" );\n    if ( to == null )\n      throw new IllegalArgumentException( \"To vertex cannot be null\" );\n    if ( maxSize <= 0 )\n      throw new IllegalArgumentException( \"Maximum size must be at least 1\" );\n    final PriorityQueue<PathSegment> queue = new PriorityQueue<>();\n\n    for ( final Edge e : from.outEdges )\n      queue.add( new PathSegment( e, null ) );\n\n    while ( !queue.isEmpty() )\n    {\n      final PathSegment p = queue.poll();\n      final Edge e   = p.edge;\n      final Vertex v = e.to;\n      if ( v == to )\n      {\n        // Found a path to destination\n        return p;\n      }\n      if ( p.size == maxSize )\n      {\n        // Not reached the destination but at max length so discard this path\n        continue;\n      }\n      for ( final Edge o : v.outEdges )\n      {\n        if ( o.length > e.length ) // Increasing edges\n        {\n          queue.add( new PathSegment( o, p ) );\n        }\n      }\n    }\n\n    return null;\n  }\n\n  public static class Vertex{\n    public final int index;\n    public final LinkedList<Edge> outEdges = new LinkedList<>();\n    public Vertex( final int i )\n    {\n      index = i;\n    }\n  }\n\n  public static class Edge{\n    public final Vertex from;\n    public final Vertex to;\n    public final int length;\n    public Edge( final Vertex f, final Vertex t, final int l )\n    {\n      from = f;\n      to = t;\n      length = l;\n      from.outEdges.add( this );\n    }\n  }\n\n  public static class PathSegment implements Comparable<PathSegment>{\n    public final Edge edge;\n    public final PathSegment prev;\n    public final int length;\n    public final int size;\n    public PathSegment( final Edge e, final PathSegment p )\n    {\n      edge = e;\n      prev = p;\n      size   = ( prev == null ? 0 : prev.size ) + 1;\n      length = ( prev == null ? 0 : prev.length ) + edge.length;\n    }\n\n    @Override\n    public int compareTo( final PathSegment p )\n    {\n      return Integer.compare( length, p.length );\n    }\n\n    @Override\n    public String toString(){\n      return ( prev == null ? Integer.toString( edge.from.index ) : prev.toString() )\n             + ','\n             + Integer.toString( edge.to.index );\n    }\n  }\n\n  public static void main( final String[] args )\n  {\n    final Vertex[] vertices = {\n      new Vertex(1), new Vertex(2), new Vertex(3), new Vertex(4), new Vertex(5), new Vertex(6)\n    };\n\n    final Edge[] edges = {\n      new Edge(vertices[0],vertices[1],2),\n      new Edge(vertices[0],vertices[2],7),\n      new Edge(vertices[0],vertices[5],5),\n      new Edge(vertices[1],vertices[0],11),\n      new Edge(vertices[1],vertices[2],3),\n      new Edge(vertices[2],vertices[3],8),\n      new Edge(vertices[2],vertices[4],1),\n      new Edge(vertices[3],vertices[1],10),\n      new Edge(vertices[3],vertices[4],6),\n      new Edge(vertices[5],vertices[3],4),\n      new Edge(vertices[5],vertices[3],7)\n    };\n\n    PathSegment p;\n\n    p = Dijkstra( vertices[0], vertices[3], 2 );\n    System.out.println( p + \" - length: \" + (p==null?\"null\":p.length) );\n\n    p = Dijkstra( vertices[2], vertices[0], 2 );\n    System.out.println( p + \" - length: \" + (p==null?\"null\":p.length) );\n\n    p = Dijkstra( vertices[2], vertices[0], 3 );\n    System.out.println( p + \" - length: \" + (p==null?\"null\":p.length) );\n  }\n}\n```\n\n\nThis outputs:\n\n```\n1,6,4 - length: 12\nnull - length: null\n3,4,2,1 - length: 29\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "PROLOG / All paths in a directed graph with loops\r\n                \r\nI've got the following diagram given:\n\nDiagram here\n\nThe first gateway/connector is an OR-gateway/connector (it has a circle in it). The gateway/connector with a 'x' in it is a XOR-gateway/connector. \n\nAn OR-gateway specifies that one or more of the available paths will be taken. \nAn XOR-gateway represents a decision to take exactly one path in the flow.\n\nI need to transform this diagram to PROLOG in order to get all possible paths from node 1 to node 8 but I have problems to code the OR-gateway and to find all possible paths. \n\nHow can I transform this diagram easily to Prolog and how can i find all possible paths respecting the gateways between two nodes? \n\nThank you for answers in advance. \n    ", "Answer": "\r\nAs you should know, a Prolog program is basically a set of rules.  From your graph, each node could begin a rule where each directed edge gives an explicit rule.  By encoding your graph as a set of rules, a query on what satisfies say, (1, X, 8), would give you every possible path, even infinitely.\n\nEncoding the rules should be easy (basic Prolog).  Maybe I'm not understanding the special functions behind the OR and XOR.  Please explain more if this isn't as trivial as it seems.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "What is wrong with printing a path in graph?\r\n                \r\ni am trying to print a solution path in a maze.Every cell has a parent from where we go to that cell.I am printing the path with the following code.\n\n```\n                do{\n                System.out.print(\"The parent of \"+index1+\",\"+index2+\"=\");\n                System.out.println(theParents[index1][index2][0]+\",\"+theParents[index1][index2][1]);\n                index1=theParents[index1][index2][0];\n                index2=theParents[index1][index2][1];\n                }while(!(index1==2 && index2==1));\n```\n\n\nthe problem is that is skips some cells.I couldn't figure out why?\n\nThe parent of 7,7=6,7\n\nThe parent of 6,7=5,7\n\nThe parent of 5,7=4,7\n\nThe parent of 4,7=3,7\n\nThe parent of 3,7=2,7\n\nThe parent of 2,7=1,7 // as you see we should now print 1,7 but it skips 1,7 and goto 1,6\n\nThe parent of 1,6=1,5\n\nThe parent of 1,5=2,5 // it skips 2,5 and go to 2,3 directly\n\nThe parent of 2,4=2,3\n\nThe parent of 2,3=1,3\n\nThe parent of 1,2=1,1\n\nThe parent of 1,1=0,1\n\nThe parent of 0,0=1,0\n\nThe parent of 1,0=2,0\n\nWhat is wrong with the code?\n    ", "Answer": "\r\n```\nindex1=theParents[index1][index2][0];\nindex2=theParents[index1][index2][1]; // the index1 here is already reassigned!\n```\n\n\nYou've already reassigned index1 when you go to use it in the assignment of index2.\n\nYou need something like\n\n```\nint newindex1 = theParents[index1][index2][0];\nint newindex2 = theParents[index1][index2][1];\n\nindex1 = newindex1;\nindex2 = newindex2;\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm to find top K paths in graph, with no common vertices, negative weights?\r\n                \r\nI'm using Bellman-Ford to find the shortest path through a graph with some negative weights.  The graph has no possibility of loops and no bi-directional connections.  I'd like to find the K shortest paths through the graph, where the paths share no nodes in common.  Is there an algorithm I can look up to learn how to do this?  Simple implementation is more important than speed at the moment.\n\nAdded:  Thanks for comments.  To be clear, I'm looking for the top K ways to get from a specified start node to a specified end node, with no other nodes in common.  I need a global optimum; sequentially finding the best and deleting nodes does not give a satisfactory result.  This one: https://en.wikipedia.org/wiki/Yen%27s_algorithm, gives the flavor of what I'm talking about, but in this case it requires non-negative edge costs and it also allows nodes to be shared.\n    ", "Answer": "\r\nI think that the problem can be solved finding a Minimum Cost Flow. \n\nLet's transform the graph in the following way:\n\n\nReplace each node v other than source and sink with two nodes v1\nand v2 connected by an edge of weight 0 from v1 to v2. The\nincoming edges of the former v enter to v1 and the outgoing\nleave from v2. With this the problem is equivalent to not using\nthose edges more than once.\nSet capacity 1 to all the edges.\n\n\nFinding a flow of value K will give you K paths that don't share a node (because of putting the capacity to 1 in those new edges). So if this flow is a minimum cost flow, you will have that those K paths also have the minimum possible sum of costs.\n\nThis is assuming that you don't have an edge connecting the source and the sink directly. Check for that corner case separately.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to implement simulated annealing to find longest path in graph\r\n                \r\nI've found a piece of pseudocode which explains simulated annealing for longest path problem, but there are a few details which I do not understand.\n\nCurrently I have implemented a structure representing graph, and method to generate random graph and random path in the graph - both uniform.\n\nHere's the pseudocode of simulated annealing:\n\n```\nProcedure Anneal(G, s, t, P)\nP = RandomPath(s, t, G)\ntemp = TEMP0\nitermax = ITER0\nwhile temp > TEMPF do\n  while iteration  < itermax do\n    S = RandomNeighbor(P, G)\n    delta = S.len - P.len\n    if delta > 0 then\n       P = S\n    else\n      x = random01\n      if x < exp(delta / temp) then\n        P = S\n      endif\n    endif\n    iteration = iteration + 1\n  enddo\n  temp = Alpha(temp)\n  itermax = Beta(itermax)\nenddo\n```\n\n\nThe details which I do not find clear enough to understand are:\n\nRandomNeighbor(P, G)\n\nAlpha(temp)\n\nitermax = Beta(itermax)\n\nWhat are these methods supposed to do ?\n    ", "Answer": "\r\nRandomNeighbor(P, G): This is probably the function that creates a new solution (or new neighboring solution) from your current solution (the neighbor is chosen randomly).\n\nAlpha(temp): That's the function that reduces the temperature (probably ```\ntemp *= alpha```\n)\n\nitermax = Beta(itermax): I can only assume that this one is changing (most probably, resetting) the counter on iterations since it's being used on the inner ```\nwhile```\n. So, when your counter for iteration reaches its max, it's reset.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "MapReduce length 3 paths in directed graph\r\n                \r\nI am trying to solve an exercise but I still have not found the solution. \n\nDesign a MapReduce algorithm that, given as input a directed graph represented as a list of arcs, lists all pairs of nodes (x, y) such that there exists three arcs (x, a), (a, b) and (b, y). the length of the lists of the values received by the reducers should never be longer that the number of nodes in the graph. Please provide the pseudocode. \n\nSo long I found the paths with length 2 in the following way:\n\n```\nmap (k, v): \n   write (k, (v, \"out\"))\n   write (v, (k, \"in\"))\n\nreduce(k ,list(v)):\n   // write all pairs of nodes such that one has an arc exiting and the other has an arc entering\n```\n\n\nBut from here on I cannot understand how to find the path with length 3, satisfying the property on the length of the lists.\n    ", "Answer": "\r\nI am not expert in hadoop syntax but lets solve this theoretically.\n\nConsider G=(V,E) - ARCS is ours E contains element such as (x,a), (a,b), (b,y)\n\nYou Found a way to extract all node with distance of 2. let call this set 2-LEN. In your short example it will contains (x,b) and (a,y). \n\nLet create new set which define like this (pseudo code): \n\n```\nNEW_SET = new set\nfor each ((x,y) in ARCS)\n     NEW_SET.add(x,y,1)\nfor each ((x,y) in 2-LEN)\n     NEW_SET.add(x,y,2)\n```\n\n\nAs you probably understand the third parameter is the distance. \nSo now, for your example NEW_SET will contains: (x,a,1), (a,b,1), (b,y,1), (x,b,2), (a,y,2).\n\nNow use the same logic in your 2-distance algorithm - mapreduce NEW_SET with:\n\n```\nmap(k,v,d):\n   write (k, (v, \"out\", d))\n   write (v, (k, \"in\" , d))\n\nreduce(k , list (v)):\n   //write all pairs of nodes such that one has an 'in' and the other has an 'out' AND have different d\n```\n\n\nFor the example after the map we will have the following: \n\n\n(x, (a,out,1))\n(a, (x,in,1))\n(a, (b,out,1))\n(b, (a,in,1))\n(b, (y,out,1))\n(y, (b,in,1))\n(x, (b,out,2))\n(b, (x,in,2))\n(a, (y,out,2))\n(y, (a,in,2))\n\n\nSo now you connect 2 distance node with 1 distance node resulting in all pairs with distance 3.\n\nNotice that you will need to execute uniq on that set because you will get (x,y) twice - once from ((x,a),(a,y)) and one from ((x,b),(b,y))\n\nAs I mention, I am not expert on hadoop syntax but I believe there should be a way to implement that.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All pairs shortest paths in graph directed with non-negative weighted edges\r\n                \r\nI have a directed graph with non-negative weighted edges where there are multiple edges between two vertices.\n\nI need to compute all pairs shortest path.\nThis graph is very big (20 milion vertices and 100 milion of edges).\nIs Floyd–Warshall the best algorithm ? There is a good library or tool to complete this task ?\n    ", "Answer": "\r\nThere exists several  all-to-all shortest paths algorithms for directed graphs with non-negative cycles, Floyd-Warshall being probably the most famous, but with the figures you gave, I think you will have in any case memory issues (time could be an issue, but you can find all-to-all algorithm that can be easily and massively parallelized).\nIndependently of the algorithm you use, you will have to store the result somewhere. And storing 20,000,000² = 400,000,000,000,000 paths length (if not the full paths themselves) would use hundreds of terabytes, at the very least.\nAccessing any of these results would probably be longer than calculating one shortest path (memory wall), which can be done in less than a milisecond (depending on the graph structure, you can find techniques that are much, much faster than Dijkstra or any priority queue based algorithm).  \n\nI think you should look for an alternative where computing all-to-all shortest paths is not required, to be honnest. Or, to study the structure of your graph (DAG, well structured graph easy to partition/cluster, geometric/geographic information ...) in order to apply different algorithms, because in the general case, I do not see any way around.  \n\nFor example, with the figures you gave, an average degree of about 5 makes for a decently sparse graph, considering its dimensions. Graph partitioning approaches could then be very useful.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in a Direct Acyclic Graph\r\n                \r\nHow can I find the longest path in a DAG with no weights?\n\nI know that the longest path from A to B can be found in linear time if the DAG is topologically sorted, but I need to find the longest path in all the graph. Is there any way faster than searching for the longest path between all pairs of vertices( which would be O(n^3))?\n    ", "Answer": "\r\nThis is the same as finding the critical path.\n\nThere's an easy O(n) DP solution:\n\n\nTopologically sort the vertices.\nFor each vertex ```\ni```\n we will record ```\nearliest(i)```\n, the earliest possible start time (initially 0 for all vertices).  Process each vertex ```\ni```\n in topologically-sorted order, updating (increasing) ```\nearliest(j)```\n for any successor vertex ```\nj```\n of ```\ni```\n whenever ```\nearliest(i) + length(i, j) > earliest(j)```\n.\n\n\nAfter this is done, the maximum value of ```\nearliest(i)```\n over all vertices will be the length of the critical path (longest path).  You can construct a (there may in general be more than one) longest path by tracing backwards from this vertex, looking at its predecessors to see which of them could have produced it as a successor (i.e. which of them have ```\nearliest(i) + length(i, j) == earliest(j)```\n), iterating until you hit a vertex with no predecessors.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all paths in a directed graph with cycles\r\n                \r\nI am working on a problem which requires finding all paths between two nodes in a directed graph. The graph may have cycles.\n\nNotice that this particular implementation approach is an iterative DFS. \n\nSeveral approaches I've considered are as follows - \n\n\nBFS does not appear to have a way to neatly manage this kind of pathing relationships between nodes.\nI don't see an easy mechanism for a DFS recursive algorithm to pass up the path when the terminating node is found. (Likely enough it could be done, if I implement a Maybe monad kind of thing). \nCreating a GRAPH-PARENT routine. That would add a decent amount of churn (& bugs) in the existing code.\n\n\nAbstractly, what needs to happen is a tree needs to be generated, with the start node as root, and all leafs are the terminating nodes. Each path from leaf to root is a legal path. That is what a recursive DFS would trace out. \n\nI'm reasonably sure it can be done here, but I don't see exactly how to do it.\n\nI've defined a protocol for this algorithm where GRAPH-EQUAL and GRAPH-NEXT can be defined for arbitrary objects. \n\nThe debug node type is a SEARCH-NODE, and it has the data accessor SEARCH-NODE-DATA.\n\n```\n(defun all-paths (start end)\n  (let ((stack (list start))\n        (mark-list (list start))   ;I've chosen to hold marking information local to all-paths, instead of marking the objects themselves.\n        (all-path-list '()))       ; Not used yet, using debug statements to think about the problem\n    (do  ()  ;; intializing no variables\n     ;; While Stack still has elements\n         ((not stack))          \n      (let ((item (pop stack)))\n    ;; I'm looking at the item.\n    (format t \"I: ~a~%\" (search-node-data item)) \n    (cond ((graph-equal item end)\n           (format t \"*Q: ~a~%\" (loop for var in stack collect (search-node-data var)))\n           ;;Unmark the terminal node so we can view it it next time.\n           (setf mark-list (remove item mark-list))))\n\n        (loop for next in (graph-next item)\n           do        \n            (cond ((not (in next mark-list :test #'graph-equal))\n                    ;; mark the node\n                    (push next mark-list)\n                    ;;Put it on the stack\n                    (push next stack))))))))\n```\n\n    ", "Answer": "\r\nSee A Very General Method for Computing Shortest Paths for an algorithm that can return all paths in a graph (even when there are cycles) as regular expressions over the alphabet of edges in finite time (assuming a finite graph).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find shortest path in graph algorithm\r\n                \r\nI have just seen this video: https://youtu.be/2E7MmKv0Y24?t=1335\nIt talks about an algorithm that finds the shortest distance between a source and a given vertex in a DAG:\n\n1.Sort the graph in topological order and express the graph in its linear form\n2.Initialize all of the vertex to infinity except the source, which is initialized to 0\n3.Iterate from the source to the rightmost vertex. For every vertex u, update the distance of all of its neighbor v to min((distance between source and v), (distance between source and u) + (distance between u and v))\n\nAt about 22:00, the professor said that this algorithm works for negative edges but the graph cannot contain cycle, but i think the algorithm works for graphs that contain non-negative cycle. Am I right?\n    ", "Answer": "\r\n\n  ..., but i think the algorithm works for graphs that contain non-negative cycle. Am I right?\n\n\nYes, you're right. See this post for more information.\n\n\n  Another question is why do I need to topologically sort the array first? Why can't I just loop through every neighbour and calculate the distance to them?\n\n\nIf I understood the question correctly you can't go to just any next node because there could be a shorter way to this node using another node first (e.g. the cost to reach a node is 5 and there is another way to the node using two nodes that uses a cost of 1 + 1 = 2; If you don't sort first in this case you would use the wrong path)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find All paths in a Directed Cyclic Graph\r\n                \r\nActually I am working on a text based Directed Graph having each word as a node in the graph and edges are between 2 adjacent words in a sentence of the text.\n\nI need to find all the paths from a START node to END node.\n\nIs there any library for Python which can help me with the task?\n\nI actually tried doing it with networkx, but problem with networkx is that it outputs only simple paths (Simple paths are pretty short for a long sentence in input and don't contain much information of the sentence). And I need more complex paths for my task.\n    ", "Answer": "\r\nYou need to write the algorithm for ```\nDFS```\n(depth first search) or ```\nBFS```\n(Breadth first search) to collect all paths. below is the example to collect all possible paths from ```\nsource```\n to ```\ndestination```\n written in java. \n\n```\n    package com.nirav.modi;\n\n    import java.util.ArrayList;\n    import java.util.Collections;\n    import java.util.HashMap;\n    import java.util.Iterator;\n    import java.util.LinkedHashSet;\n    import java.util.List;\n    import java.util.Map;\n    import java.util.NoSuchElementException;\n    import java.util.Set;\n\n    class Graph<T> implements Iterable<T> {\n\n        /*\n         * A map from nodes in the graph to sets of outgoing edges. Each set of\n         * edges is represented by a map from edges to doubles.\n         */\n        private final Map<T, Map<T, Double>> graph = new HashMap<T, Map<T, Double>>();\n\n        /**\n         * Adds a new node to the graph. If the node already exists then its a\n         * no-op.\n         * \n         * @param node\n         *            Adds to a graph. If node is null then this is a no-op.\n         * @return true if node is added, false otherwise.\n         */\n        public boolean addNode(T node) {\n            if (node == null) {\n                throw new NullPointerException(\"The input node cannot be null.\");\n            }\n            if (graph.containsKey(node))\n                return false;\n\n            graph.put(node, new HashMap<T, Double>());\n            return true;\n        }\n\n        /**\n         * Given the source and destination node it would add an arc from source to\n         * destination node. If an arc already exists then the value would be\n         * updated the new value.\n         * \n         * @param source\n         *            the source node.\n         * @param destination\n         *            the destination node.\n         * @param length\n         *            if length if\n         * @throws NullPointerException\n         *             if source or destination is null.\n         * @throws NoSuchElementException\n         *             if either source of destination does not exists.\n         */\n        public void addEdge(T source, T destination, double length) {\n            if (source == null || destination == null) {\n                throw new NullPointerException(\"Source and Destination, both should be non-null.\");\n            }\n            if (!graph.containsKey(source) || !graph.containsKey(destination)) {\n                throw new NoSuchElementException(\"Source and Destination, both should be part of graph\");\n            }\n            /* A node would always be added so no point returning true or false */\n            graph.get(source).put(destination, length);\n        }\n\n        /**\n         * Removes an edge from the graph.\n         * \n         * @param source\n         *            If the source node.\n         * @param destination\n         *            If the destination node.\n         * @throws NullPointerException\n         *             if either source or destination specified is null\n         * @throws NoSuchElementException\n         *             if graph does not contain either source or destination\n         */\n        public void removeEdge(T source, T destination) {\n            if (source == null || destination == null) {\n                throw new NullPointerException(\"Source and Destination, both should be non-null.\");\n            }\n            if (!graph.containsKey(source) || !graph.containsKey(destination)) {\n                throw new NoSuchElementException(\"Source and Destination, both should be part of graph\");\n            }\n            graph.get(source).remove(destination);\n        }\n\n        /**\n         * Given a node, returns the edges going outward that node, as an immutable\n         * map.\n         * \n         * @param node\n         *            The node whose edges should be queried.\n         * @return An immutable view of the edges leaving that node.\n         * @throws NullPointerException\n         *             If input node is null.\n         * @throws NoSuchElementException\n         *             If node is not in graph.\n         */\n        public Map<T, Double> edgesFrom(T node) {\n            if (node == null) {\n                throw new NullPointerException(\"The node should not be null.\");\n            }\n            Map<T, Double> edges = graph.get(node);\n            if (edges == null) {\n                throw new NoSuchElementException(\"Source node does not exist.\");\n            }\n            return Collections.unmodifiableMap(edges);\n        }\n\n        /**\n         * Returns the iterator that travels the nodes of a graph.\n         * \n         * @return an iterator that travels the nodes of a graph.\n         */\n        @Override\n        public Iterator<T> iterator() {\n            return graph.keySet().iterator();\n        }\n    }\n\n    /**\n     * Given a connected directed graph, find all paths between any two input\n     * points.\n     */\n    public class GraphTester<T> {\n\n        private final Graph<T> graph;\n\n        /**\n         * Takes in a graph. This graph should not be changed by the client\n         */\n        public GraphTester(Graph<T> graph) {\n            if (graph == null) {\n                throw new NullPointerException(\"The input graph cannot be null.\");\n            }\n            this.graph = graph;\n        }\n\n        private void validate(T source, T destination) {\n\n            if (source == null) {\n                throw new NullPointerException(\"The source: \" + source + \" cannot be  null.\");\n            }\n            if (destination == null) {\n                throw new NullPointerException(\"The destination: \" + destination + \" cannot be  null.\");\n            }\n            if (source.equals(destination)) {\n                throw new IllegalArgumentException(\"The source and destination: \" + source + \" cannot be the same.\");\n            }\n        }\n\n        /**\n         * Returns the list of paths, where path itself is a list of nodes.\n         * \n         * @param source\n         *            the source node\n         * @param destination\n         *            the destination node\n         * @return List of all paths\n         */\n        public List<List<T>> getAllPaths(T source, T destination) {\n            validate(source, destination);\n\n            List<List<T>> paths = new ArrayList<List<T>>();\n            recursive(source, destination, paths, new LinkedHashSet<T>());\n            return paths;\n        }\n\n        // so far this dude ignore's cycles.\n        private void recursive(T current, T destination, List<List<T>> paths, LinkedHashSet<T> path) {\n            path.add(current);\n\n            if (current == destination) {\n                paths.add(new ArrayList<T>(path));\n                path.remove(current);\n                return;\n            }\n\n            final Set<T> edges = graph.edgesFrom(current).keySet();\n\n            for (T t : edges) {\n                if (!path.contains(t)) {\n                    recursive(t, destination, paths, path);\n                }\n            }\n\n            path.remove(current);\n        }\n\n        public static void main(String[] args) {\n            Graph<String> graphFindAllPaths = new Graph<String>();\n            graphFindAllPaths.addNode(\"A\");\n            graphFindAllPaths.addNode(\"B\");\n            graphFindAllPaths.addNode(\"C\");\n            graphFindAllPaths.addNode(\"D\");\n\n            graphFindAllPaths.addEdge(\"A\", \"B\", 10);\n            graphFindAllPaths.addEdge(\"A\", \"C\", 10);\n            graphFindAllPaths.addEdge(\"B\", \"D\", 10);\n            graphFindAllPaths.addEdge(\"C\", \"D\", 10);\n\n            graphFindAllPaths.addEdge(\"B\", \"C\", 10);\n            graphFindAllPaths.addEdge(\"C\", \"B\", 10);\n\n            GraphTester<String> findAllPaths = new GraphTester<String>(graphFindAllPaths);\n            List<List<String>> allPaths = findAllPaths.getAllPaths(\"A\", \"D\");\n            System.out.println(allPaths);\n\n            // assertEquals(paths, findAllPaths.getAllPaths(\"A\", \"D\"));\n        }\n    }\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Fetching specific paths from neo4j Graph database\r\n                \r\nWe are using Neo4j 2.1.4 Community edition. \n\nWe are facing some issues in getting the specific paths in neo4j.\n\nBelow is the csv file used.\n\n\n\nIn graph database we are creating Product, Company,Country and Zipcode nodes along with the relationship type as ‘MyRel’ at each level.In the above data we wanted to differentiate each path , \n\nthat is \n\nMobile, Google,US,88888 -- as path1\n\nMobile,Goolge,US -- as path2\n\nMobile,Goolge -- as path3 \n\nThat’s why we created one more column called ```\nPath```\n in data file and maintaining the ```\nPath```\n value as a relatioship property. So whenever someone wants to see the different paths he can query based on Relationship property either 1 or 2 or 3. For eample , whenever we query for the relationship property, we should get ```\nMobile,Google ,US```\n \n\nBut whenever I do this , in graph it is creating dummy node for Country and Zipcode. This is due to in 2nd and 3rd row the zip and country values are empty(null).\n\nQuery used:\n\n```\nLOAD CSV WITH HEADERS FROM \"file:C:\\\\WorkingFolder\\\\Neo4j\\\\EDGE_Graph_POC\\\\newdata\\\\trial1.csv \" as file\nMERGE (p:Product {Name:file.Product})\nMERGE (comp:Company {Name:file.Company})\nMERGE (c:Country {Name:file.Country})\nMERGE (zip:Zipcode{Code:file.Zipcode})\nCREATE (p)-[:MyRel{Path:file.Path}]->(comp)-[:MyRel{Path:file.Path}]->(c)-[:MyRel{Path:file.Path}]->(zip)\n```\n\n\nResultant graph:\n\n\n\nSo how can I avoid creating dummy nodes ?\n\nIs there any better alternative option to get the proper path?\n\nThanks,\n    ", "Answer": "\r\nFirst, A simple solution is to follow the LOAD CSV query with others that clean up your graph. Run the queries\n\n```\nMATCH (zip:Zipcode { Code : ''})<-[r]-()\nDELETE zip, r\n```\n\n\nand\n\n```\nMATCH (c:Country { Name : ''})<-[r]-()\nDELETE c, r\n```\n\n\nYou will then have the graph you desire.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Algorith which finds shortest path with negative edges and without negative cycles\r\n                \r\nWhich of the following algorithms finds the shortest path in graphs with negative edges and without negative cycles?\n1)Bellman-Ford algorithm\n2)Dijkstra's algorithm\n3)A* search algorithm\n4)Floyd-Warshall algorithm\n5)Dijkstra's algorithm with a binary heap \n    ", "Answer": "\r\nAfter a search -- Bellman–Ford algorithm\n\nhttps://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding best paths in a fully connected graph\r\n                \r\nI have a fully connected graph (undirected) with 500 vertices. This results in a matrix with 250,000 entries (only 125,000 are necessary because its undirected). \n\nEach edge has a specific weight. If I can only visit n vertices where n < 500 is it possible to find which starting vertex and which path would result in the highest total weights.\n\nIs this possible to solve in any reasonable amount of time? \n\nThanks!\n    ", "Answer": "\r\nThe problem you're describing ends up being NP-hard (via a reduction from the longest path problem), so unless P = NP there aren't going to be any algorithms that are correct on all inputs and efficient on all inputs. You'll either need to be willing to accept answers that aren't always correct (but might be approximately close) or will need to consider algorithms that are quick in some cases but quite slow in others.\n\nThere are some algorithms that work well for this problem as long as the paths aren't too long. The color-coding algorithm, for example, works well if the maximum path length isn't too long, but I'm concerned that length 500 is going to be way too large here. A quick Google search turned up this paper, which contains an algorithm for finding reasonably long paths in a graph and might be applicable here. But barring that, you may need to just do some random sampling and hope that everything works out.\n\nIf you know more about your graph - for example, if the edges obey the triangle inequality or if the edges all have values in some small finite range - you might be able to use other approaches. But barring that, I'm afraid you're not going to have many options open to you.\n\nSorry about that, but hope this helps!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in a Graph with Dijkstra\r\n                \r\nI was just wondering: can you inverse all the weights in a graph and then do a Dijkstra? As we are minimizing the reciprocal values of the weights, the obtained path would maximize it all in all, right?\nSo, in that way, we can obtain the longest path in a graph using Dijkstra!\nIt seems too easy, am I mistaken? Please, enlighten me.\n    ", "Answer": "\r\nIt is not possible to do so because the ```\nlongest path problem```\n doesn't have the optimal substructure problem as the ```\nshortest path```\n one. \n\nSay that you can consider any path as longest path (so it can have cycles) but if there is a cycle and the weights are positive the algorithm will never end since it can always improve the longest path by looping through the cycle. \n\nNow say that we want to have only simple paths (without cycle) as candidates for the longest path. Consider, without loss of generality, the following graph with unitary weights for all edges:\n\n```\nA------B\n|      |\n|      |\nC------D\n```\n\n\nAnd consider the longest path from ```\nA```\n to ```\nD```\n (```\nA->B->D```\n). For the problem to have optimal substructure property it must be the case that longest path from ```\nA```\n to ```\nB```\nis ```\nA -> B```\n but clearly it isn't because path ```\nA->C->D->B```\n is longer. Similar argument can be done for the path from ```\nB```\n to ```\nD```\n. So we can see why this problem can't be solved with Dijkstra algorithm. As a matter of fact this problem is ```\nNP```\n, there isn't a reasonable time complexity solution.  \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "What algorithm should I use to get all possible paths in a directed weighted graph, with positive weights?\r\n                \r\nI have a directed weighted graph, with positive weights, which looks something like this :-\n\nWhat I am trying to do is:-\n\nFind all possible paths between two nodes.\nArrange the paths in ascending order, based on their path length (as given by the edge weights), say top 5 atleast.\nUse an optimal way to do so, so that even in cases of larger number of nodes, the program won't take much time computing.\n\nE.g.:- Say my initial node is d, and final node is c.\nSo the output should be something like\n```\nd to c = 11\nd to e to c = 17\nd to b to c = 25\nd to b to a to c = 31\nd to b to a to f to c = 38\n```\n\nHow can I achieve this?\n    ", "Answer": "\r\nThe best approach would be to take the ```\nDijkstra’s shortest path```\n algorithm, we can get a shortest path in ```\nO(E + VLogV)```\n time.\nTake this basic approach to help you find the shortest path possible:\nLook at all nodes directly adjacent to the starting node. The values carried by the edges connecting the start and these adjacent nodes are the shortest distances to each respective node.\nRecord these distances on the node - overwriting infinity - and also cross off the nodes, meaning that their shortest path has been found.\nSelect one of the nodes which has had its shortest path calculated, we’ll call this our pivot. Look at the nodes adjacent to it (we’ll call these our destination nodes) and the distances separating them.\nFor every ending (destination node):\nIf the value in the pivot plus the edge value connecting it totals less than the destination node’s value, then update its value, as a new shorter path has been found.\nIf all routes to this destination node have been explored, it can be crossed off.\nRepeat step 2 until all nodes have been crossed off. We now have a graph where the values held in any node will be the shortest distance to it from the start node.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest Path in Boost Graph\r\n                \r\nSorry if this is a very basic questions for some of you but I'm new to C++ (let alone Boost Graph Library) and couldn't figure out this problem. So far I've been able to formulate/gather code to create a graph using the code below. \n\nNow I'm trying to figure out the code to find the longest path in this graph. \n\nCan someone please help with what would the code be? I was having trouble trying to figure out if/how to traverse through each node and/or edge when trying to find the path? \n\nI have to try to return all the nodes and edges in the longest path.\n\nAny help will be greatly appreciated. \n\nP.S. does anyone know if C++ has organized documentation like Javadoc?? \n\n```\n    #include <boost/graph/dag_shortest_paths.hpp>\n#include <boost/graph/adjacency_list.hpp>\n#include <windows.h>\n#include <iostream>\n\n\n\nint main()\n{\n  using namespace boost;\n  typedef adjacency_list<vecS, vecS, directedS, property<vertex_distance_t, double>, property<edge_weight_t, double> > graph_t;\n  graph_t g(6);\n  enum verts { stationA, stationB, stationC, stationD, stationE, stationF };\n  char name[] = \"rstuvx\";\n\n\n  add_edge(stationA, stationB, 5000.23, g);\n  add_edge(stationA, stationC, 3001, g);\n  add_edge(stationA, stationD, 2098.67, g);\n  add_edge(stationA, stationE, 3298.84, g);\n  add_edge(stationB, stationF, 2145, g);\n  add_edge(stationC, stationF, 4290, g);\n  add_edge(stationD, stationF, 2672.78, g);\n  add_edge(stationE, stationF, 11143.876, g);\n  add_edge(stationA, stationF, 1, g);\n\n\n\n\n//Display all the vertices\n  typedef property_map<graph_t, vertex_index_t>::type IndexMap;\n  IndexMap index = get(vertex_index, g);\n  std::cout << \"vertices(g) = \";\n\n  typedef graph_traits<graph_t>::vertex_iterator vertex_iter;\n  std::pair<vertex_iter, vertex_iter> vp;\n  for (vp = vertices(g); vp.first != vp.second; ++vp.first)\n      std::cout << index[*vp.first] <<  \" \";\n  std::cout << std::endl;\n  // ...\n\n   // Display all the edges\n    // ...\n  std::cout << \"edges(g) = \" << std::endl;\n    graph_traits<graph_t>::edge_iterator ei, ei_end;\n    for (tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)\n  std::cout << \"(\" << index[source(*ei, g)] << \",\" << index[target(*ei, g)] << \") \\n\";\n    std::cout << std::endl;\n    // ...\n```\n\n    ", "Answer": "\r\nI think you should check the example in your boost distribution.\nOnline : http://www.boost.org/doc/libs/1_38_0/libs/graph/example/dijkstra-example.cpp\n\nTo make it find the longest path you need to simply inverse the weight (W), either use a Constant - W, or 1/W. If the constant is 0, then it means it's a negation (-W).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding paths in undirected graph with specific cost\r\n                \r\nSuppose we have undirected, weighted graph. Our task is to find all paths beetween two vertices (source and destination) which total cost equal = N.\nI think it can be done with modified Dijkstra's algorithm combined with BFS or DFS, but I have no idea how implement such thing. Thanks for any help.\n    ", "Answer": "\r\nAssuming you have a framework / library to create a graph data structure and to traverse it, you could do a backtracking depth-first search with an early return if you cross your resource constraint. In pseudo-code:\n\n```\nvoid DFS(Vertex current, Vertex goal, List<Vertex> path, int money_left) {\n  // oops\n  if (money_left < 0) \n     return;\n\n  // avoid cycles\n  if (contains(path, current)\n     return;\n\n  // got it!\n  if (current == goal)) {\n     if (money_left == 0)\n         print(path);\n     return;\n  }\n\n  // keep looking\n  children = successors(current); // optionally sorted from low to high cost\n  for(child: children)          \n      DFS(child, add_path(path, child), money_left - cost(child));      \n}\n```\n\n\nand you can then call it as ```\nDFS(start, goal, List<Vertex>(empty), N)```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All chains in graph\r\n                \r\nWhich algorithm I need to use to find all possible chains maximal length?\n```\n1) Main->Foo1->Foo2->Foo3->Foo4\n2) Main->Foo2->Foo3->Foo4\n3) Main->Foo6->Foo7\n```\n\nFind all possible paths in the graph and then exclude all that are less than the largest?\n\n    ", "Answer": "\r\nYou can go backwards from the leaf nodes.\nThe goal is to label every node with the length of the longest path that starts at this node.\n\nFirst, label all leaves (Foo4 and Foo7 in your example) as ```\n1```\n;\nWhile there is a node ```\nu```\n such that all children of ```\nu```\n have been labeled:\n\nLabel ```\nu```\n as ```\n1 + max(labels of children of u)```\n\n\n\n\nNote: this assumes there are no cycles in the graph. Otherwise, nodes which are part of a cycle will never get a label.\nNow, the length of the longest path is marked on your root node. If you have more than one root node or don't know who the root node is: find the node with highest label.\nTo retrace the longest path:\n\nStart at the root node\nWhile the current node has at least one child:\n\nMove to the child who has the highest label\n\n\n\nWith your examples, the labels will be:\n```\nFoo4, Foo7: 1\nFoo3, Foo6: 2\nFoo2:       3\nFoo1:       4\nMain:       5\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Path finding in an undirected graph\r\n                \r\nI'm trying to list all the paths in an undirected graph, and my question is similar to this question. I've tried to run this code, but it loops indefinitely -- I ran it with 60 nodes. Any ideas on how to produce the correct solution?\n\nI added such a random graph and the code is now like:\n\n```\n    #include<stdio.h>\n\nstatic struct {\n  int value1;\n  int value2;\n  int used;\n} data[] = {\n  { 1, 2 },\n  { 1, 5 },\n  { 2, 3 },\n  { 2, 6 },\n  { 3, 7 },\n  { 4, 0 },\n  { 0, 4 },\n  { 7, 3 },\n  { 2, 1 },\n\n};\n\nenum { DATA_SIZE = sizeof data / sizeof *data };\n\nstatic int output[DATA_SIZE];\n\nint traverse(int from, int to, int depth) {\n  output[depth++] = from;\n\n  int i;\n  if (from == to) {\n    for (i = 0; i < depth; i++) {\n      if (i) {\n        printf(\"-\");\n      }\n      printf(\"%d\", output[i]);\n    }\n    printf(\"\\n\");\n  } else {\n    for (i = 0; i < DATA_SIZE; i++) {\n      if (!data[i].used) {\n        data[i].used = 1;\n\n        if (from == data[i].value1) {\n          traverse(data[i].value2, to, depth);\n        } else if (from == data[i].value2) {\n          traverse(data[i].value1, to, depth);\n        }\n\n        data[i].used = 0;\n      }\n    }\n  }\n}\n\nint main() {\n  traverse(1, 7, 0);\n}`\n```\n\n\nAnd the output is:\n1-2-3-7\n1-2-3-7\n1-2-3-7\n1-2-3-7\n\nWhy do I get that path 4 times? Is it possible to fix? thanks\n    ", "Answer": "\r\nYou can not fix it. The number of paths in graph (not counting sparse graphs) is exponential by itself and only outputting will take forever. Clearly, it's impossible. Even if your graph is sparse (but connected) there will be at least O(N^2) paths.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Tracing paths in a Graph between two nodes\r\n                \r\nHow to trace the paths between two nodes in a given graph once if we know or donot know the length of the path between them?( By considering Adjacency matrix)\n\nBetween Adjacency matrix and breadth first search in finding the paths which one is efficient?\n\nCan you please give the algorithm steps.\n\nThank you in Advance,\nKamala.\n    ", "Answer": "\r\nActually, the answer would depend on what kind of path you're searching for.\n\nIf you are searching for a shortest path, then you can try implementing Dijkstra's algorithm, which also runs very fast.\n\nIf you are just trying to find a path, no matter it's length, then BFS is a nice solution, since it will find it in the \"shallowest\" place, though it doesn't guarantee that it is the shortest one.\n\nOther options for you are DFS, which will search first for the deepest paths and Bellman-Ford, which will also give the shortest path, but in more general scenarios than Dijkstra's, so it will be slower.\n\nIf you want all possible paths, then any of these algorithms can be reimplemented to perform a marking of the graph, and so get all possible paths.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find longest path in graph?\r\n                \r\nWe are given an Adjacency list of the form\n\n```\nU -> (U,V,C) -> (U,V,C) ...  \nU2 -> ...  \nU3 -> ...  \n.  \n.  \netc\n```\n\n\n```\n(U,V,C)```\n means there's an edge from U to V with cost C.\n\nThe given Adjacency list is for a single connected tree with N nodes thus containing N-1 edges.\n\nA set of nodes ```\nF=F1,F2,F3...Fk```\n are given.\n\nNow the question is what is the best way to find the longest path amongst the nodes in F?\nIs it possible to do it in O(N)?\n\nIs DFS from each node in F the only option? \n    ", "Answer": "\r\nI understood your question as asking to find a pair of nodes from the set F so that the unique path between those two nodes is as long as it can be. The path is unique because your graph is a tree.\n\nThe problem can be solved trivially by doing DFS from every node in F as you mention, for an O(n k) solution where n is the size of the graph and k is the size of the set F.\n\nHowever, you can solve it potentially faster by a divide and conquer approach. Pick any node R from the graph, and use a single DFS to tabulate distances Dist(R, a) to every other node a a and at the same time partition the nodes to subtrees S1,...,Sm where m is the number of edges from R; that is, these are the m trees hanging at the root R. Now, for any f and g that belong to different subtrees it holds that the path between them has Dist(R, f) + Dist(R, g) edges, so it is possible to search for the longest such path in O(k^2) time. In addition, you have then to recurse to the subproblems S1,...,Sm to cover the case where the longest path is inside one of those trees. The overall complexity can be lower than O(n k) but the math is left as an exercise to the reader.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find shortest path in graph by following orders to visit node\r\n                \r\nThe source is A. The order of the nodes is [\"C\", \"D\", \"E\"], which must be processed to reach the goal.\nI found the solution using Dijkstra's algorithm by finding the shortest path from A-C, C-D, D-E. Is there an optimised way to find the shortest path in one move. Can we do better with A*? If A* increases the performance, how can we define a heuristic function?\nHere is my graph.\nShortest Path: A - B - C - D - C - E . Here we can revisit node again if it contributes to shortest path.\n\n    ", "Answer": "\r\nDijkstra's Algorithm is the best option for finding the shortest path in a graph. Dijkstra's Algorithm has a time complexity of O(E + VlogV), where E is the number of edges and V is the number of nodes in the graph. The A* Algorithm has a slower time complexity.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest Paths in undirected cyclic graphs\r\n                \r\nCan someone please explain how given an undirected graph G = (V; E); edge lengths le > 0; and edge edges in E.\n\nWe can generate the length of the shortest cycle containing edge e.\n\nI understand how to do this in directed graphs, but im not sure how to approach the problem with an undirected graph.\n    ", "Answer": "\r\nWithout modifying the graph: Let e be an edge (u, v). Choose one of the two nodes—I'll choose u—and run an ordinary Dijkstra/BFS starting from u with one minor modification: When making the first hop, you must not add v to the queue. Now search for v.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Tracing paths in a Graph between two nodes\r\n                \r\nHow to trace the paths between two nodes in a given graph once if we know or donot know the length of the path between them?( By considering Adjacency matrix)\n\nBetween Adjacency matrix and breadth first search in finding the paths which one is efficient?\n\nCan you please give the algorithm steps.\n\nThank you in Advance,\nKamala.\n    ", "Answer": "\r\nActually, the answer would depend on what kind of path you're searching for.\n\nIf you are searching for a shortest path, then you can try implementing Dijkstra's algorithm, which also runs very fast.\n\nIf you are just trying to find a path, no matter it's length, then BFS is a nice solution, since it will find it in the \"shallowest\" place, though it doesn't guarantee that it is the shortest one.\n\nOther options for you are DFS, which will search first for the deepest paths and Bellman-Ford, which will also give the shortest path, but in more general scenarios than Dijkstra's, so it will be slower.\n\nIf you want all possible paths, then any of these algorithms can be reimplemented to perform a marking of the graph, and so get all possible paths.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Retrieving all paths in an OWL class hierarchy with SPARQL and Jena\r\n                \r\nI have an RDF graph of with a hierarchy three levels deep.  I want to retrieve all the paths starting from the root of the class hierarchy (i.e., ```\nowl:Thing```\n) down to classes in the third level without using a reasoner.  For instance, I would like the path\nC1 &rightarrow;\nC2 &rightarrow;\nC3 \nis a path, where each \nCi\nis a class at the ith level of the hierarchy.\n\nI need to retrieve all the paths in the RDF graph using the breadth first search algorithm with no considerations to the object properties in the graph.\n    ", "Answer": "\r\nGiven some data like this (where length of the class name is an indication of the depth of the class in the hierarchy):\n\n```\n@prefix : <http://example.org/> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n\n:a a rdfs:Class .\n\n:aa rdfs:subClassOf :a .\n:ab rdfs:subClassOf :a .\n:ac rdfs:subClassOf :a .\n\n:aaa rdfs:subClassOf :aa .\n:aab rdfs:subClassOf :aa .\n:aac rdfs:subClassOf :aa .\n\n:aaba rdfs:subClassOf :aab .\n:aabb rdfs:subClassOf :aab .\n\n:aba rdfs:subClassOf :ab .\n:abb rdfs:subClassOf :ab .\n```\n\n\nYou can use a SPARQL query to select the paths that you're looking for.\n\nUsing a SPARQL query\n\nYou can write a SPARQL query like this to get the following results:\n\n```\nprefix : <http://example.org/>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n\nselect ?c1 ?c2 ?c3 where { \n  values ?c1 { :a }\n  ?c1 ^rdfs:subClassOf ?c2 .\n  OPTIONAL {\n    ?c2 ^rdfs:subClassOf ?c3 .\n  }\n}\norder by ?c3 ?c2 ?c1\n```\n\n\n\n\n```\n-------------------\n| c1 | c2  | c3   |\n===================\n| :a | :ac |      |\n| :a | :aa | :aaa |\n| :a | :aa | :aab |\n| :a | :aa | :aac |\n| :a | :ab | :aba |\n| :a | :ab | :abb |\n-------------------\n```\n\n\nUsing the camera ontology\n\nThis approach works with the camera ontology that has been mentioned in the comments, though the query requires a little extension to handle deeper class paths.  Thus:\n\n```\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX : <http://www.xfront.com/owl/ontologies/camera/#>\n\nselect * where { \n  values ?c1 { owl:Thing } \n  ?c1 ^rdfs:subClassOf ?c2 .\n  OPTIONAL { \n    ?c2 ^rdfs:subClassOf ?c3 .\n    OPTIONAL { \n      ?c3 ^rdfs:subClassOf ?c4 .\n    }\n  }\n}\norder by ?c4 ?c3 ?c2\n```\n\n\n\n\n```\n-----------------------------------------------------------\n| c1        | c2                | c3      | c4            |\n===========================================================\n| owl:Thing | :Money            |         |               |\n| owl:Thing | :Range            |         |               |\n| owl:Thing | :Window           |         |               |\n| owl:Thing | :PurchaseableItem | :Body   |               |\n| owl:Thing | :PurchaseableItem | :Lens   |               |\n| owl:Thing | :PurchaseableItem | :Camera | :Digital      |\n| owl:Thing | :PurchaseableItem | :Camera | :Large-Format |\n-----------------------------------------------------------\n```\n\n\nUsing the Jena API\n\nWhile the above SPARQL query produces the paths in the order that would expected from a breadth first traversal, there is actually no guarantee on how ARQ generates the results.  We can also implement a Breadth First Search directly, using the Jena Model API to retrieve subclasses.  Here's a straightforward implementation:\n\n```\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\nimport com.hp.hpl.jena.rdf.model.Model;\nimport com.hp.hpl.jena.rdf.model.ModelFactory;\nimport com.hp.hpl.jena.rdf.model.Resource;\nimport com.hp.hpl.jena.rdf.model.StmtIterator;\nimport com.hp.hpl.jena.vocabulary.OWL;\nimport com.hp.hpl.jena.vocabulary.RDFS;\n\npublic class BFSInRDFWithJena {\n\n    public static List<List<Resource>> BFS( final Model model, final Queue<List<Resource>> queue, final int depth ) {\n        final List<List<Resource>> results = new ArrayList<>();\n        while ( !queue.isEmpty() ) {\n            final List<Resource> path = queue.poll();\n            results.add( path );\n            if ( path.size() < depth ) {\n                final Resource last = path.get( path.size() - 1 );\n                final StmtIterator stmt = model.listStatements( null, RDFS.subClassOf, last );\n                while ( stmt.hasNext() ) {\n                    final List<Resource> extPath = new ArrayList<>( path );\n                    extPath.add( stmt.next().getSubject().asResource() );\n                    queue.offer( extPath );\n                }\n            }\n        }\n        return results;\n    }\n\n    public static void main( final String[] args ) throws IOException {\n        final Model model = ModelFactory.createDefaultModel();\n        try ( final InputStream in = BFSInRDFWithJena.class.getClassLoader().getResourceAsStream( \"camera.owl\" ) ) {\n            model.read( in, null );\n        }\n\n        // setup the initial queue\n        final Queue<List<Resource>> queue = new LinkedList<>();\n        final List<Resource> thingPath = new ArrayList<>();\n        thingPath.add( OWL.Thing );\n        queue.offer( thingPath );\n\n        // Get the paths, and display them\n        final List<List<Resource>> paths = BFS( model, queue, 4 );\n        for ( List<Resource> path : paths ) {\n            System.out.println( path );\n        }\n    }\n}\n```\n\n\n\n\n```\n[http://www.w3.org/2002/07/owl#Thing]\n[http://www.w3.org/2002/07/owl#Thing, http://www.xfront.com/owl/ontologies/camera/#PurchaseableItem]\n[http://www.w3.org/2002/07/owl#Thing, http://www.xfront.com/owl/ontologies/camera/#Window]\n[http://www.w3.org/2002/07/owl#Thing, http://www.xfront.com/owl/ontologies/camera/#Range]\n[http://www.w3.org/2002/07/owl#Thing, http://www.xfront.com/owl/ontologies/camera/#Money]\n[http://www.w3.org/2002/07/owl#Thing, http://www.xfront.com/owl/ontologies/camera/#PurchaseableItem, http://www.xfront.com/owl/ontologies/camera/#Camera]\n[http://www.w3.org/2002/07/owl#Thing, http://www.xfront.com/owl/ontologies/camera/#PurchaseableItem, http://www.xfront.com/owl/ontologies/camera/#Lens]\n[http://www.w3.org/2002/07/owl#Thing, http://www.xfront.com/owl/ontologies/camera/#PurchaseableItem, http://www.xfront.com/owl/ontologies/camera/#Body]\n[http://www.w3.org/2002/07/owl#Thing, http://www.xfront.com/owl/ontologies/camera/#PurchaseableItem, http://www.xfront.com/owl/ontologies/camera/#Camera, http://www.xfront.com/owl/ontologies/camera/#Digital]\n[http://www.w3.org/2002/07/owl#Thing, http://www.xfront.com/owl/ontologies/camera/#PurchaseableItem, http://www.xfront.com/owl/ontologies/camera/#Camera, http://www.xfront.com/owl/ontologies/camera/#Large-Format]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "K edge disjoint paths in a directed graph\r\n                \r\nGive two vertices u and v in G = (V,E) and a positive integer k, describe an algorithm to decide if there exists a k edge disjoint paths from u to v. If the answer to the decision problem is yes, describe how to compute a set of k edge disjoint paths.\n\nSolution : Run max flow from u to v (giving all edges in the Graph G a weight of 1 so that one edge can be part of only one path from u to v) and get the value of flow. If the value of the flow is k then we have the answer to the decision problem as yes.\n\nNow for finding all such paths find the min cut by doing BFS from u and hence I will have the partition of vertices which will separate the vertices into 2 sets one on each side of min cut.\n\nThen do I need to again do a DFS from u to v looking for all the paths which have only these vertices which are there in the two partition set that I got from the min cut.\n\nOr is there any other cleaner way ? to get all the k edge disjoint paths.\n    ", "Answer": "\r\nOnce you have the flow you can extract the edge disjoint paths by following the flow.  \n\nThe start node will have a flow of k leaving u along k edges.\n\nFor each of these edges you can keep moving in the direction of outgoing flow to extract the path until you reach v.  All you need to do is to mark the edges you have already used to avoid duplicating edges.\n\nRepeat for each of the k units of flow leaving u to extract all k paths. \n\nPseudocode\n\n```\nrepeat k times:\n  set x to start node\n  set path to []\n  while x is not equal to end node:\n      find a edge from x which has flow>0, let y be the vertex at the far end\n      decrease flow from x->y by 1 unit\n      append y to path\n      set x equal to y\n  print path\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Updating the matrix of paths in the graph\r\n                \r\nI have this matrix that hold path between vertexes.for example for 4 vertex we have the matrix like this :\n\n0 0 1 1\n\n1 0 1 1\n\n0 0 0 1\n\n0 0 0 0\n\nThat shows us we have path between (1,3) & (1,4) & (2,1) & (2,3) & (2,4) & (3,4).\n\nThe input of my problem is new path between two vertex and the output is the update of that matrix .\n\nFor example :\n\nInput:(3,2)\n\nOutput:\n\n1 1 1 1\n\n1 1 1 1\n\n1 1 1 1\n\n0 0 0 0\n\nI want to do it with this order : O(V^2)\n    ", "Answer": "\r\nN = number of vertex.\n\nYou have your new edge : Input (A,B).\n\n1 Then you iterate through B:\nfor every existing edge (B,X), you get a (possible new) edge (A,X)\n=> si N operations\n\n2 Same thing with A:\nfor every existing edge (Y,A), you get a (possible new) edge (Y,B)\n=> si N operations\n\nYou do the same thing with X, and Y (maximum 2 N).\n\n3 For every (Y,A) and (B,X),\n you add (Y,X), so NxN operations.\n\nSo it is O(N^2)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "NGX-Graph: Anchor Paths in Center of Nodes\r\n                \r\ngot a problem with ngx-graph. Is it possible to point the beginning and the end of the connecting path to the center of a node? My svg nodes are bigger than the sub-element e.g:\n\n\nI tried to implement a custom curve, implement a custom layout and tried to override the child (GraphComponent) method \"generateLine()\". Nothing leads to success, everytime i got artefacts and new problems. Do you have a simple solution for this problem?\n    ", "Answer": "\r\nFor anyone, who wants a \"simple\" answer to this question. It is not that easy to get things working, but you can override the two specific methods to achieve the results. First override the calculation of the endpoints while dragging, this is done in updateEdge. Next, override the method that draws the lines within the graph and add only different values to position if it was not moved (initial draw). After that initial draw you calculate your movement in updateEdge method und you skip the extra values in the generateLine-method because you already have computed the right start/endpoints (nothing to do anymore). We have to do this in the generateLine method because the initial position calculation of the edges is not done by the lib-authors, it is done by the library called \"dagre\" (search npm for this). So, we can only modify the initial draw endpoints, while drawing the first time (generateLine-method). If you have any other possiblity without reimplementing the whole Layout and GraphComponent part, share your solution here please. :)\n\n```\n@ViewChild(GraphComponent) child: GraphComponent;\n\nngAfterViewInit(): void {\n\n    /* Recalculate Positions of endpoints while moving / dragging, added i as an identifier that it was moved */\n\n    // tslint:disable-next-line:only-arrow-functions\n    (this.child.layout as Layout).updateEdge = function(graph: Graph, edge: Edge): Graph {\n\n      const sourceNode = graph.nodes.find(n => n.id === edge.source);\n      const targetNode = graph.nodes.find(n => n.id === edge.target);\n\n      // centered so i do not bother if its up oder downwards bot -1\n      const dir = sourceNode.position.y <= targetNode.position.y ? -1 : -1;\n      // Compute positions while dragging here\n      const startingPoint = {\n        x: sourceNode.position.x - dir * (sourceNode.dimension.height / 2),\n        i: true,\n        y: sourceNode.position.y,\n\n      };\n      const endingPoint = {\n        x: targetNode.position.x - dir * (targetNode.dimension.height / 2),\n        i: true,\n        y: targetNode.position.y,\n\n      };\n\n      // generate new points\n      edge.points = [startingPoint,  endingPoint ];\n      return graph;\n    };\n\n    /* Calculate Initial position of the Arrows, on first draw and add only amount of x if not modified or not dragged*/\n    this.child.generateLine = function(points: any): any {\n\n      const lineFunction = shape\n        .line<any>()\n        .x(d => {\n          let addVal = 0;\n          if (d.i === undefined){\n             addVal = 60;\n          }\n          const xval =  d.x + addVal;\n          return xval;\n        })\n        .y(d => d.y)\n        .curve(this.curve);\n      return lineFunction(points);\n    };\n\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Scala: Recursively building all paths in a graph?\r\n                \r\nTrying to build all existing paths for an udirected graph defined as a map of edges using the following algorithm:\n\n```\nStart: with a given vertice A \nFind an edge (X.A, X.B) or (X.B, X.A), add this edge to path if not already in path\nFind all edges Ys for which either (Y.C, Y.B) or (Y.B, Y.C) is true \nFor each Ys: A=B, goto Start\n```\n\n\nProviding edges are defined as the following map, where keys are tuples consisting of two vertices:\n\n```\n    val edges = Map(\n      (\"n1\", \"n2\") -> \"n1n2\",\n      (\"n1\", \"n3\") -> \"n1n3\",\n      (\"n3\", \"n4\") -> \"n3n4\",\n      (\"n5\", \"n1\") -> \"n5n1\",\n      (\"n5\", \"n4\") -> \"n5n4\")\n```\n\n\nAs an output I need to get a list of ALL pathes where each path is a list of adjecent edges like this:  \n\n```\n  val allPaths = List(\n    List((\"n1\", \"n2\") -> \"n1n2\"),\n    List((\"n1\", \"n3\") -> \"n1n3\", (\"n3\", \"n4\") -> \"n3n4\"),\n    List((\"n5\", \"n1\") -> \"n5n1\"),\n    List((\"n5\", \"n4\") -> \"n5n4\"),\n    List((\"n2\", \"n1\") -> \"n1n2\", (\"n1\", \"n3\") -> \"n1n3\", (\"n3\", \"n4\") -> \"n3n4\", (\"n5\", \"n4\") -> \"n5n4\"))\n    //...\n    //... more pathes to go\n}\n```\n\n\nNote: Edge XY = (x,y) -> \"xy\" and  YX = (y,x) -> \"yx\" exist as one instance only, either as XY or YX \n\nSo far I have managed to implement code that duplicates edges in the path, which is wrong and I can not find the error:\n\n```\nobject Graph2 {\n  type Vertice = String\n  type Edge = ((String, String), String)\n  type Path = List[((String, String), String)]\n\n  val edges = Map(\n    //((\"v1\", \"v2\") , \"v1v2\"),\n    ((\"v1\", \"v3\") , \"v1v3\"),\n    ((\"v3\", \"v4\") , \"v3v4\")\n    //((\"v5\", \"v1\") , \"v5v1\"),\n    //((\"v5\", \"v4\") , \"v5v4\")\n    )\n\n  def main(args: Array[String]): Unit = {\n\n    val processedVerticies: Map[Vertice, Vertice] = Map()\n    val processedEdges: Map[(Vertice, Vertice), (Vertice, Vertice)] = Map()\n    val path: Path = List()\n    println(buildPath(path, \"v1\", processedVerticies, processedEdges))\n\n  }\n\n  /**\n   * Builds path from connected by edges vertices starting from given vertice\n   * Input: map of edges\n   * Output: list of connected edges like:\n   List((\"n1\", \"n2\") -> \"n1n2\"),\n    List((\"n1\", \"n3\") -> \"n1n3\", (\"n3\", \"n4\") -> \"n3n4\"),\n    List((\"n5\", \"n1\") -> \"n5n1\"),\n    List((\"n5\", \"n4\") -> \"n5n4\"),\n    List((\"n2\", \"n1\") -> \"n1n2\", (\"n1\", \"n3\") -> \"n1n3\", (\"n3\", \"n4\") -> \"n3n4\", (\"n5\", \"n4\") -> \"n5n4\"))\n   */\n  def buildPath(path: Path,\n    vertice: Vertice,\n    processedVerticies: Map[Vertice, Vertice],\n    processedEdges: Map[(Vertice, Vertice), (Vertice, Vertice)]): List[Path] = {\n    println(\"V: \" + vertice + \" VM:  \" + processedVerticies + \" EM: \" + processedEdges)\n    if (!processedVerticies.contains(vertice)) {\n      val edges = children(vertice)\n      println(\"Edges: \" + edges)\n      val x = edges.map(edge => {\n        if (!processedEdges.contains(edge._1)) {\n          addToPath(vertice, processedVerticies.++(Map(vertice -> vertice)), processedEdges, path, edge)\n        } else {\n          println(\"ALready have edge: \"+edge+\" Return path:\"+path)\n          path\n        }\n      })\n      val y = x.toList\n      y\n    } else {\n      List(path)\n    }\n  }\n\n  def addToPath(\n    vertice: Vertice,\n    processedVerticies: Map[Vertice, Vertice],\n    processedEdges: Map[(Vertice, Vertice), (Vertice, Vertice)],\n    path: Path,\n    edge: Edge): Path = {\n\n    val newPath: Path = path ::: List(edge)\n    val key = edge._1\n    val nextVertice = neighbor(vertice, key)\n\n    val x = buildPath (newPath, \n             nextVertice, \n             processedVerticies, \n             processedEdges ++ (Map((vertice, nextVertice) -> (vertice, nextVertice)))\n          ).flatten // need define buidPath type \n    x\n  }\n\n  def children(vertice: Vertice) = {\n    edges.filter(p => (p._1)._1 == vertice || (p._1)._2 == vertice)\n  }\n\n  def containsPair(x: (Vertice, Vertice), m: Map[(Vertice, Vertice), (Vertice, Vertice)]): Boolean = {\n    m.contains((x._1, x._2)) || m.contains((x._2, x._1))\n  }\n\n  def neighbor(vertice: String, key: (String, String)): String = key match {\n    case (`vertice`, x) => x\n    case (x, `vertice`) => x\n  }\n\n}  \n```\n\n\nRunning this results in:\n\n```\nList(List(((v1,v3),v1v3), ((v1,v3),v1v3), ((v3,v4),v3v4)))\n```\n\n\nWhy is that?\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Depth first search to find path in graph\r\n                \r\nI am trying to find a path between two points in a graph using a depth first search in Python. The idea is to return a path (not necessarily the shortest) from point a to point b or an empty list if a path does not exist. I have a class which contains an adjacency list (dictionary called graph), a dictionary of visited nodes and a stack (a list called path) to track the current path. The recursive function I am using to do this is a method called getPath(self,a,b). The issue I am having is that I am unable to return the stack once I have found the target node, I think because the stack is just returned as part of a recursive call and the function continues running. What can I change to make this work? The code is as follows:\n```\ndef getPath(self,a,b):\n        self.visited[\"{}\".format(a)]=1 #mark a as visited\n        self.path.append(\"{}\".format(a)) #add a to current path\n        if (\"{}\".format(a)==\"{}\".format(b)): #check to see if we've reached our destination\n            return self.path #here is where I would like the function to return the path\n        else:\n            for v in self.graph[\"{}\".format(a)]:\n                if self.visited[v]==0:\n                    self.getPath(v,b)\n            self.path.pop #remove v from our current path if we only find dead ends from its edges\n```\n\n    ", "Answer": "\r\nIn the above code in the else block, you are returning nothing for the recursive call.\nSo, what if the children call:\n```\nself.getPath(v,b)\n```\n\nreturns self.path but in the parent call of that function gonna return nothing.\nSo, you have to make some changes in the else block to keep track of these return values.\n```\ndef getPath(self,a,b):\n        self.visited[\"{}\".format(a)]=1 #mark a as visited\n        self.path.append(\"{}\".format(a)) #add a to current path\n        if (\"{}\".format(a)==\"{}\".format(b)): #check to see if we've reached our destination\n            return self.path #here is where I would like the function to return the path\n        else:\n            for v in self.graph[\"{}\".format(a)]:\n                if self.visited[v]==0:\n                    result = self.getPath(v,b)\n                    if(result != None):\n                        return result\n            self.path.pop #remove v from our current path if we only find dead ends from its edges\n            return None\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find all vertex-disjoint paths in a graph?\r\n                \r\nSuppose there are 3 target nodes in a graph. \n\nA vertex-disjoint path means there is not any same node except the end nodes during the path. \n\nFor any one single node, say node i, how to find all vertex-disjoint paths from node i to the three target nodes?\n    ", "Answer": "\r\nYou can solve this problem by reducing it to a max-flow problem in an appropriately-constructed graph.  The idea is as follows:\n\n\nSplit each node v in the graph into to nodes: vin and vout.\nFor each node v, add an edge of capacity one from vin to vout.\nReplace each other edge (u, v) in the graph with an edge from uout to vin of capacity 1.\nAdd in a new dedicated destination node t.\nFor each of the target nodes v, add an edge from vin to t with capacity 1.\nFind a max-flow from sout to t.  The value of the flow is the number of node-disjoint paths.\n\n\nThe idea behind this construction is as follows.  Any flow path from the start node s to the destination node t must have capacity one, since all edges have capacity one.  Since all capacities are integral, there exists an integral max-flow.  No two flow paths can pass through the same intermediary node, because in passing through a node in the graph the flow path must cross the edge from vin to vout, and the capacity here has been restricted to one.  Additionally, this flow path must arrive at t by ending at one of the three special nodes you've identified, then following the edge from that node to t.  Thus each flow path represents a node-disjoint path from the source node s to one of the three destination nodes.  Accordingly, computing a max-flow here corresponds to finding the maximum number of node-disjoint paths you can take from s to any of the three destinations.\n\nHope this helps!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Better Way to remove cycles from a path in neo4j graph\r\n                \r\nI am using neo4j graph database version 2.1.7. Brief Details around data:\n2 million nodes with 6 different type of nodes, 5 million relationships with only 5 different type of relationships and mostly connected graph but contains a few isolated subgraphs.\n\nWhile resolving paths, i get cycles in path. And to restrict that, i used the solution shared in below:\nReturning only simple paths in Neo4j Cypher query\n\nHere is the Query, i am using:\n\n```\nMATCH (n:nodeA{key:905728}) \nMATCH path = n-[:rel1|rel2|rel3|rel4*0..]->(c:nodeA)-[:rel5*0..1]->(b:nodeA) \nWHERE ALL(a in nodes(path) where 1=length (filter (m in nodes(path) where m=a))) \nand (length(EXTRACT (p in NODES(path)| p.key)) > 1) \nand ((exists ((c)-[:rel5]->(b)) and (not exists((b)-[:rel1|rel2|rel3|rel4]->(:nodeA)) OR ANY (x in nodes(path) where (b)-[]->(x))))\n    OR (not exists ((c)-[:rel5]->()) and (not exists ((c)-[:rel1|rel2|rel3|rel4]->(:nodeA)) OR ANY (x in nodes(path) where (c)-[]->(x))))) \nRETURN distinct EXTRACT (rp in Rels(path)| type(rp)), EXTRACT (p in NODES(path)| p.key);\n```\n\n\nThe above query solves mine requirement but is not cost effective and keeps running if is run for huge subgraph. I have used 'Profile' command to improve query performance from what i started with. But, now stuck at this point. The performance has improved but, not what i expected from neo4j :(\n    ", "Answer": "\r\nI don't know that I have a solution, but I have a number of suggestions.  Some might speed things up, some might just make the query easier to read.\n\nFirstly, rather than putting ```\nexists ((c)-[:rel5]->(b))```\n in your ```\nWHERE```\n, I believe you can put it in your ```\nMATCH```\n like this:\n\n```\nMATCH path = n-[:rel1|rel2|rel3|rel4*0..]->(c:nodeA)-[:rel5*0..1]->(b:nodeA), (c)-[:rel5]->(b)\n```\n\n\nI don't think you need the ```\nexists```\n keyword.  I think you can just say, for example, ```\n(NOT (b)-[:rel1|rel2|rel3|rel4]->(:nodeA))```\n\n\nI'd also suggest thinking about the ```\nWITH```\n clause for potential performance improvements.\n\nA couple of notes about your variable paths: In ```\n*0..```\n the ```\n0```\n means that your potentially looking for a self-reference.  That may or may not be what you want.  Also, leaving the variable path open ended can often cause performance problems (as I think you're seeing).  If you can possibly cap it that may help.\n\nAlso, if you upgrade to 2.2.1, there are a number of built-in performance improvements with the 2.2.x line, but you also get visual ```\nPROFILE```\ning in the console and a new ```\nEXPLAIN```\n command which both profiles and tells you the real performance of the query after running it.\n\nOne thing to consider too is that I don't think you're hitting performance boundaries of Neo4j but rather, perhaps, you're potentially hitting some boundaries of Cypher.  If so, I might suggest you do your querying with the Java APIs that Neo4j provides for better performance and more control.  This can either be via embedding your database if you're using a JVM-compatible language or by writing an unmanaged extension which lets you do your own querying in java but provide a custom REST API from the server\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm to find the number of distinct paths in a directed graph [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Graph Algorithm To Find All Connections Between Two Arbitrary Vertices  \n\n\n\n\nI have a directed graph, what algorithm can i use to find the number of distinct acyclic paths between 2 particular vertices, and count the maximum times any path is used in these distinct paths? \nTwo paths are distinct if they either visit a different number of vertices or visit vertices in a different order.\n    ", "Answer": "\r\nIf you follow a slightly modified Dijkstra's algorithm, you can have an all-pair solution.\n\nExplanation: Paths from ```\nu```\n to ```\nv```\n is the sum of the following:\n\n\nPaths from ```\nu```\n to ```\nv```\n which doesn't pass through ```\nw```\n\nPaths which go through ```\nw```\n = number of paths from ```\nu```\n to ```\nw```\n times number of paths from ```\nw```\n to ```\nv```\n \n\n\nInitialise the matrix with zeros except when there is an edge from ```\ni```\n to ```\nj```\n (which is 1).\nThen the following algorithm will give you the result (all-pair-path-count)\n\n```\nfor i = 1 to n:\n    for j = 1 to n:\n        for k = 1 to n:\n            paths[i][i] += paths[i][k] * paths[k][j]\n```\n\n\nNeedless to say : ```\nO(n^3)```\n\n\nEager to read a single pair solution. :)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all paths between source and target in graph-tool, return edges instead of vertices\r\n                \r\nStack Overflow!\n\nI have a directed graph and need to find all paths between a source and target vertex. Between several vertices, there are multiple edges. Using graph-tool, one may suggest using ```\ngraph_tool.topology.all_paths(g, source, target)```\n, however, the lists contained in this vertex iterator are for vertices only; see some of the output below. Due to there being multiple edges between vertices, there are multiple occurrences of paths such as ```\n[ 0 4 8 13]```\n and ```\n[0 4 13]```\n and I am not able to distinguish between these paths.  \n\n```\niterator, paths:  [ 0  4  8 13]\niterator, paths:  [ 0  4 13]\niterator, paths:  [ 0  4  8 13]\niterator, paths:  [ 0  4 13]\niterator, paths:  [ 0  4  8 13]\niterator, paths:  [ 0  4 13]\n```\n\n\nI need the paths in the form of edges, to be able to iterate over edge properties along each path. To solve this issue, I can only think of one method (apart from rewriting large amounts of code): creation of intermediary vertices to avoid occurrences of multiple edges between any two vertices. For any parallel edges between two vertices, they would be connected to each their own, unique intermediary vertex as to uniquely define the paths returned from ```\ngraph_tool.topology.all_paths(g, source, target)```\n. \n\nIs there a way to return all paths in the form of edges between a source and destination vertex?\n    ", "Answer": "\r\nThis has been added to graph-tool recently: https://git.skewed.de/count0/graph-tool/commit/5457d04f5f37c7a49e87b67c666c1a865e206b9a\n\nYou just need to pass the ```\nedges=True```\n parameter:\n\n```\nfor p in all_paths(g, u, v, edges=True):\n    for e in p:\n        print(e)  # e is an edge descriptor\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find possible paths in a graph using neo4j\r\n                \r\nDisclaimer: I'm a beginner with graph data modeling, any help, tips or guidance will be appreciated. Forgive my lack of knowledge.\n\n10 thousand feat idea is to be able to translate texts from one language to another in a certain quality level.\n\nI have the following domain models:\n\n\nAn activity (aka. ```\nactivity```\n)\nA source language (aka. ```\nlanguage_from```\n)\nA destination language (aka. ```\nlanguage_to```\n)\nA quality level (aka. ```\nlevel```\n)\n\n\nI have modeled the following graph to allow a user to ask for a translation from X to Y with a quality level Z.\n\n\n\nNow let's say a user wants to translate from ```\nen-us```\n to ```\nde-de```\n. There are no links between the two nodes because business does not allow this path for domain reasons.\n\nHowever it is possible to achieve such translation going through ```\nen-us```\n->```\nfr-fr```\n then ```\nfr-fr```\n->```\nde-de```\n.\n\nMy questions are:\n\n\nIs the above graph model appropriate for such query?\nWhat would the query look like using neo4j cyphers?\n\n\nAny tips to get me on the right track would be appreciated.\n    ", "Answer": "\r\nI think you can model your data in a more straight-forward way.\n\nYou could use ```\nLanguage```\n nodes directly connected by ```\nTRANSLATE```\n relationships with the ```\nlevel```\n as a property on the relationship. It's simpler, directly maps to your domain problem and you don't need other nodes for your query.\n\n```\n(Language {name: 'de-de'})-[:TRANSLATE {level: 7}]->(Language {name: 'fr-fr'})\n```\n\n\nA variable length query finds translations through mulitple languages:\n\n```\nMATCH path=(lang:Languag {name: 'de-de'})-[:TRANSLATE*1..3]-(other_lang:Language {name: 'en-us'})\nRETURN nodes(path)\n```\n\n\nHere you could also filter for a certain level:\n\n```\nMATCH path=(lang:Languag {name: 'de-de'})-[:TRANSLATE*1..3]-(other_lang:Language {name: 'en-us'})\nWHERE all(x IN relationships(path) WHERE x.level > 5)\nRETURN nodes(path)\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find possible paths in a graph using neo4j\r\n                \r\nDisclaimer: I'm a beginner with graph data modeling, any help, tips or guidance will be appreciated. Forgive my lack of knowledge.\n\n10 thousand feat idea is to be able to translate texts from one language to another in a certain quality level.\n\nI have the following domain models:\n\n\nAn activity (aka. ```\nactivity```\n)\nA source language (aka. ```\nlanguage_from```\n)\nA destination language (aka. ```\nlanguage_to```\n)\nA quality level (aka. ```\nlevel```\n)\n\n\nI have modeled the following graph to allow a user to ask for a translation from X to Y with a quality level Z.\n\n\n\nNow let's say a user wants to translate from ```\nen-us```\n to ```\nde-de```\n. There are no links between the two nodes because business does not allow this path for domain reasons.\n\nHowever it is possible to achieve such translation going through ```\nen-us```\n->```\nfr-fr```\n then ```\nfr-fr```\n->```\nde-de```\n.\n\nMy questions are:\n\n\nIs the above graph model appropriate for such query?\nWhat would the query look like using neo4j cyphers?\n\n\nAny tips to get me on the right track would be appreciated.\n    ", "Answer": "\r\nI think you can model your data in a more straight-forward way.\n\nYou could use ```\nLanguage```\n nodes directly connected by ```\nTRANSLATE```\n relationships with the ```\nlevel```\n as a property on the relationship. It's simpler, directly maps to your domain problem and you don't need other nodes for your query.\n\n```\n(Language {name: 'de-de'})-[:TRANSLATE {level: 7}]->(Language {name: 'fr-fr'})\n```\n\n\nA variable length query finds translations through mulitple languages:\n\n```\nMATCH path=(lang:Languag {name: 'de-de'})-[:TRANSLATE*1..3]-(other_lang:Language {name: 'en-us'})\nRETURN nodes(path)\n```\n\n\nHere you could also filter for a certain level:\n\n```\nMATCH path=(lang:Languag {name: 'de-de'})-[:TRANSLATE*1..3]-(other_lang:Language {name: 'en-us'})\nWHERE all(x IN relationships(path) WHERE x.level > 5)\nRETURN nodes(path)\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Descending order of shortest paths in networkx\r\n                \r\nI have a weighted Graph using networkx and the topology is highly meshed. I would like to extract a number of paths between two nodes with distance minimization.\n\nTo clarify, the dijkstra_path function finds the weighted shortest path between two nodes, I would like to get that as well as the second and third best option of shortest weighted paths between two nodes.\n\nI tried using all_simple_paths and then ordering the paths in distance minimization order but it is extremely time consuming when the network is meshed with 500 nodes or so.\n\nAny thoughts on the matter? Thank you for your help!\n    ", "Answer": "\r\nTry networkx's ```\nshortest_simple_paths```\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "pseudo code for finding closed paths in a graph\r\n                \r\nI have an adjaceny matrix for a graph which tracks the edges between the nodes by having a 1 in the corresponding adjMat[i,j] = 1;\nThrough this adjaceny matrix i wish to find out all the closed paths of length 4 which exists in the graph. Can anyone please provide me with a pseudo code. thank u\n    ", "Answer": "\r\nThis sounds like homework, so I won't give the whole thing away. But here's a hint: since you are interested in finding cycles of length 4, take the 4th power of the adjacency matrix and scan along the diagonal. If any entry M[i,i] is nonzero, there is a cycle containing vertex i.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "variable length matching over paths in Cypher\r\n                \r\nIs it possible to allow variable length matching over multiple paths in Cypher?  By a path I mean something like two KNOWS traversals or three BLOCKS traversals, where KNOWS and BLOCKS are relationship types in my graph.  For example, I'd like to be able to write something like:\n\n```\nMATCH (s)-[r*]->(t) \nWHERE ALL (x in type(r) WHERE x=KNOWS/KNOWS OR x= BLOCKS/BLOCKS/BLOCKS)\nRETURN s, t\n```\n\n\nwhere by \"KNOWS/KNOWS\" I mean something like (a)-[:KNOWS]->(b)-[:KNOWS]->(c).  I want to do this without changing the data itself, by adding relationships such as KNOWS/KNOWS, but rather just as a cypher query.\n    ", "Answer": "\r\nYes, you can do this.  It's actually much easier than you think:\n\n```\nMATCH p=(s)-[r:KNOWS|BLOCKS*]->(t) \nRETURN s, t;\n```\n\n\nWhen you specify the ```\nr```\n, with a colon you can indicate which types you want to traverse, and separate them by a pipe for ```\nOR```\n.   The asterisk just operates the way you expect.\n\nIf you only want one type of relationship at a time you can do this:\n\n```\nOPTIONAL MATCH p1=(s1)-[r1:KNOWS*]->(t1)\nOPTIONAL MATCH p2=(s2)-[r2:BLOCKS*]->(t2)\nRETURN p1, p2;\n```\n\n\nIf you want exactly two knows and 3 blocks, then it's:\n\n```\nOPTIONAL MATCH p1=(s1)-[:KNOWS]->()-[:KNOWS]->(t1)\nOPTIONAL MATCH p2=(s2)-[:BLOCKS]->()-[:BLOCKS]->()-[:BLOCKS]->(t2)\nRETURN p1, p2;\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Directed Graph: Euler Path\r\n                \r\nBased on standard defination, Eulerian Path is a path in graph that visits every edge exactly once.\n\nNow, I am trying to find a Euler path in a directed Graph. I know the algorithm for Euler circuit. Its seems trivial that if a Graph has Euler circuit it has Euler path.  \n\n[image source: geeksforgeeks.org]\n\nSo for above directed graph which has a Euler circuit also has Euler path. \n\nNow if i remove an Edge lets say from 4 to 0 it is no more an Euler circuit. \n\n\nif start my DFS from vertex 0 i still have Euler Path. \nif start from vertex 3 i do not have Euler path\n\n\nSo, is it a requirement, that a directed graph has to be in Euler circuit to be an Euler path? I thought, Euler path should be less restrictive then Euler circuit.\n\nIs there any directed graph which can be Euler path but not Euler circuit. \n    ", "Answer": "\r\n\n  So, is it a requirement, that a directed graph has to be in Euler\n  circuit to be an Euler path?\n\n\nNo\n\n\n  I thought, Euler path should be less restrictive than Euler circuit.\n\n\nCorrect\n\n\n  Is there any directed graph which can be Euler path but not Euler\n  circuit.\n\n\nYes\n\nI believe that your confusion is derived from the fact that when you DFS a directed graph starting from different nodes, you might get different results because some nodes might not be accessible when you start from different nodes. This has nothing to do with the definition of  Eulerian path/trail. In order to \"implement\" the search for  Eulerian path in a directed graph, you should run DFS from every node - and only if all the results returned False (no  Eulerian path was found) then you know for sure that there is no  Eulerian path. If there is an  Eulerian cycle, there must be a node from which you can start DFS and find an Eulerian path.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find SECOND shortest path in directred graph\r\n                \r\nI need a way to find second shortest path in directed graph, on top of that second shortest path cannot include the shortest path entirely. I am aware of dijkstra algoritm, but I am unable to figure out a simple way on how to change that algorithm to give me a second shortest path in a reasonable amount of time. Algorithm, sudo-code or c++ example, one of the three will be greatly appreciated.\n    ", "Answer": "\r\nNot sure if the following is correct and works, but its just an idea....\n\nThe second shortest path has at least one edge different from the shortest path. If no node is visited twice, this also means, that there is at least one edge in the shortest path that is not used by the second shortest path. \n\nIf that is correct, you could first search the shortest path. Then for each edge in the shortest path: set its weight to infinity (ie exclude it from the graph) and search for the shortest path in the resulting graph. The shortest path among those should be the second shortest in the original graph. \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Number of edge distinct paths in bipartite graph\r\n                \r\nWe have a bipartite graph, where set A have n vertices and set B have n vertices.\n\nAlso each vertices in set A have k edges to set B and each vertices in set B have k edges to set A.\n\nThere is a special vertex s that has edges to all vertices to set A, and a special vertex t that has edges to all vertices in B. \n\nHow can I prove that there are k edge distinct paths from s to t?\n\n\n\nThe problem that I am facing is that it asks given the graph mentioned above(Minus the vertices s and t), I need to prove that if at each round I remove all edges from A to B in a way that I can’t remove more than 1 edge from same vertices, there is a way to do this removal so that A and B will become disconnected in k rounds.\n    ", "Answer": "\r\n\n  Also each vertices in set A have k edges to set B and each vertices in\n  set B have k edges to set A.\n\n\n=> There exist at least ```\nk```\n vertices in A and there exist at least ```\nk```\n vertices in B. (I)\n\nNow we use:\n\n\n  There is a special vertex s that has edges to all vertices to set A,\n  and a special vertex t that has edges to all vertices in B.\n\n\n(which we'll call (II)) to show there must be at least ```\nk```\n edge disjoint path from ```\ns```\n to ```\nt```\n.\n\nConsider the following removal-process:\n\n\nGo from ```\ns```\n to a vertex ```\nv_a```\n in A.\nGo from  ```\nv_a```\n to a vertex ```\nv_b```\nin B.\nGo from ```\nv_b```\n to ```\nt```\n.\nRemove all the edges along this path (to make sure we are not reusing them later on)\n\n\nNote: one such removal round corresponds to exactly a path from ```\ns```\n to ```\nt```\n.\n\nNow: we can repeat this removal-process at least ```\nk```\n times. Why? \n\nBecause after ```\nk-1```\n rounds, there must remain at least one vertex ```\nv_a_last```\n in A because of (I). This vertex can be reached from ```\ns```\n because of (II). This vertex ```\nv_a_last```\n must have at least one adjacent vertex ```\nv_b_last```\n in B which we have not come along yet (```\nv_a_last```\n has ```\nk```\n neighbors in ```\nB```\n but we have come across at most ```\nk-1```\n of them so far since we have only made ```\nk-1```\n removal-rounds so far). Since we haven't come along ```\nv_b_last```\n so far, the edge from  ```\nv_b_last```\n to ```\nt```\n must still be in the graph. Hence in round ```\nk```\n we can go from ```\ns```\n to ```\nv_a_last```\n to ```\nv_b_last```\n to ```\nt```\n which is the ```\nk-th```\n edge-disjoint paths from ```\ns```\n to ```\nt```\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding N shortest paths in a graph\r\n                \r\nI need to find the ```\nN```\n shortest path between two nodes.\nAs example, the following code create three nodes and four edges, and the two shortest paths are ```\n(1, 3) and (1, 2, 3)```\n\n\n```\nimport networkx as nx\n\nG = nx.MultiDiGraph()\nG.add_edge(1, 2, **{'weight': 15, 'max': 3})\nG.add_edge(1, 3, **{'weight': 30, 'max': 4})\nG.add_edge(2, 3, **{'weight': 20, 'max': 3})\nG.add_edge(2, 3, **{'weight': 20, 'max': 5})\n```\n\n\nIs there a method in NetworkX to find them?\n\nI'm aware of the method ```\nnx.all_shortest_paths(rete,1, 3, weight='weight')```\n, but in cases like this one the method returns only the shortest path, (1,3).\n\nThank you! \n    ", "Answer": "\r\nFrom the documentation, it looks like you can generate all simple paths between two vertices starting from the shortest paths with ```\nshortest_simple_paths```\n:\n\nhttps://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.simple_paths.shortest_simple_paths.html#\n\nEdit: answer for multigraphs\n\nThis is a very crude solution to get the answer you're looking for. I assume it will only work well for small graphs:\n\n```\nG = nx.MultiDiGraph()\nG.add_edge(1, 2, **{'weight': 15, 'max': 3})\nG.add_edge(1, 3, **{'weight': 30, 'max': 4})\nG.add_edge(2, 3, **{'weight': 20, 'max': 3})\nG.add_edge(2, 3, **{'weight': 20, 'max': 5})\n\n# get all paths and convert them to tuples so that we can\n# deduplicate them\npaths = [tuple(p) for p in nx.all_simple_paths(G, 1, 3)]\n\n# sort the paths according to the number of nodes in the path\nprint(sorted(set(paths), key=lambda x:len(x)))\n```\n\n\nEdit 2: answer for weighted multigraphs\n\nThis is a bit more complicated, you need to write your own \"path score\" function and pass it to the sorter.\n\n```\nG = nx.MultiDiGraph()\nG.add_edge(1, 2, **{'weight': 15, 'max': 3})\nG.add_edge(1, 3, **{'weight': 30, 'max': 4})\nG.add_edge(2, 3, **{'weight': 20, 'max': 3})\nG.add_edge(2, 3, **{'weight': 20, 'max': 5})\n\n\ndef get_edge_weight(u, v):\n    \"\"\"Return the minimum weight of all edges between nodes u and v.\"\"\"\n    return min([e['weight'] for e in G.get_edge_data(u, v).values()])\n\n\ndef weighted_path_score(path):\n    \"\"\"Sum of edge weights in path.\"\"\"\n    edges = zip(path, path[1:])\n    return sum(get_edge_weight(u, v) for u, v in edges)\n\n\npaths = [tuple(p) for p in nx.all_simple_paths(G, 1, 3)]\n\n# sort using the weighted path score\nprint(sorted(set(paths), key=weighted_path_score))\n```\n\n\nYou can play around with edge weights and check that the order of returned paths respects it (e.g. setting a high weight to edge 1-3 will result in the path ```\n(1,2,3)```\n being listed first).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Minimum number of total paths in a connected graph\r\n                \r\nI was looking at the PenLift problem on TopCoder, after reading this editorial I now understand how to do it, however there's one thing I don't understand. \n\n\n  A fairly well known theorem states that to go over all of the edges in a connected graph requires numOfOddVertices/2 total paths.\n\n\nWhich theory is this? Also why is it so? My first thought is to find an Eulerian path by adding edges, to make all the vertices have even degrees except 2, since that would allow an Eulerian path. I'm not sure if this is correct, also if it was, how would I know that would be the best way of doing it, it seems greedy but I don't see any proof. Could someone please link me to the theory or explain how it works? Thanks in advance. \n    ", "Answer": "\r\n\n  Which theory is this?\n\n\nGraph theory.\n\n\n  Also why is it so?\n\n\nWe need to assume at least one pair of odd-degree vertices.\n\nLower bound: prove inductively that a graph with 2k odd-degree vertices requires at least k paths. Base case k = 1: trivial. Step k > 1: removing a path from a graph with 2k odd-degree vertices leaves at least 2k-2 = 2(k-1) odd-degree vertices.\n\nUpper bound: augment the graph with k edges connecting pairwise disjoint pairs of odd-degree vertices. Now all vertices have even degree, so there exists an Euler circuit. Delete the new edges from this circuit; k paths remain.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to Find Number of Hamiltonian Paths in a graph?\r\n                \r\nI am trying out this Google Codejam problem which says to find out number of hamiltonian paths if we remove k edges from a complete graph\n\nlink to Question\n\nhttps://code.google.com/codejam/contest/32004/dashboard#s=p2\n\nI figured out we can use inclusion exclusion principle to find out the number \n\nbut my problem is how to determine the number of path when we are considering that some 'x' number of edges have been removed from the complete graph(the edges removed are given)\n    ", "Answer": "\r\nThe idea is to count permutations instead of counting paths. This way, each path would be taken into account 2*n times. \n\nThe total number if permutations is n!.\n\nLet's use the inculsion-exlusion principle to count bad cycles. If one edge is banned, there are 2*n * (n-2)! paths that contain this edge (we place two adjacent vertices together and the rest goes anywhere). \n\nIf there are several banned edges, all vetrices are divided into several independent groups (they form chains connected by these edges). There are two ways to place each group (as it can be reversed). All groups can be arbitrarily permuted with each other. The rest of the elements can be placed anywhere (it would contribute as a binomial coefficient times some factorial). There is one more caveat: a chain can wrap around. But there can be at most one such chain. So we can iterate over the chain that wraps and count the number of ways to place the rest using the algorithm described above.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths in a python graph data structure without using recursive function\r\n                \r\nI have a serious issue with finding all possible paths in my csv file that looks like this :\n\n\n\n\nSource\nTarget\nSource_repo\nTarget_repo\n\n\n\n\nSOURCE1\nTarget2\nrepo-1\nrepo-2\n\n\nSOURCE5\nTarget3\nrepo-5\nrepo-3\n\n\nSOURCE8\nTarget5\nrepo-8\nrepo-5\n\n\n\n\nThere a large amount of lines in the datasets, more than 5000 lines. I want to generate all possible paths like this in and return a list (Target5 is equal to SOURCE5):\n\nSOURCE1 Target2\nSOURCE8 Target5 Target3\n\nI want to implement this solution without using recursive functions, since causes problems (maximum recursion depth exceeded).\nThis is the current code example :\n```\ndef attach_co_changing_components(base_component):\n    co_changes = df_depends_on.loc[df_depends_on[\"Source_repo\"] ==\n                                   base_component, \"Target_repo\"].values\n    result = {base_component: list(co_changes)}\n    return result\n\n\ndef dfs(data, path, paths):\n    datum = path[-1]\n    if datum in data:\n        for val in data[datum]:\n            new_path = path + [val]\n            paths = dfs(data, new_path, paths)\n    else:\n        paths += [path]\n    return paths\n\n\n\ndef enumerate_paths(graph, nodes=[]):\n    nodes = graph.keys()\n    all_paths = []\n    for node in nodes:\n        node_paths = dfs(graph, [node], [])\n        all_paths += node_paths\n    return all_paths\n\n\nif __name__ == \"__main__\":\n\n    df = pd.read_csv(\"clean_openstack_evolution.csv\")\n\n    co_changing_components = df[[\"Source\"]].copy()\n\n    co_changing_components = co_changing_components.drop_duplicates(\n    ).reset_index(drop=True)\n\n    co_changing_components = co_changing_components[\"Source\"].map(\n        attach_co_changing_components)\n\n    co_changing_components = co_changing_components.rename(\"Path\")\n\n    co_changing_components = co_changing_components.reset_index(drop=True)\n\n    newdict = {}\n    for k, v in [(key, d[key]) for d in co_changing_components for key in d]:\n        if k not in newdict: newdict[k] = v\n        else: newdict[k].append(v)\n\n    graph_keys = df_depends_on[\"Source_repo\"].drop_duplicates().to_dict(\n    ).values()\n    graph_keys = {*graph_keys}\n    graph_keys = set([\n        k for k in graph_keys\n        if len(df_depends_on[df_depends_on[\"Target\"] == k]) > 0\n    ])\n\n    result = enumerate_paths(new_dict)\n\n```\n\nHere is the output after executing the preceding code :\n\nHere is the data link Google drive\nI tried to solve the problem using recursive function, but the code failed with the problem of depth exceeded. I aim to solve it without recursive functions.\n    ", "Answer": "\r\nI'm not sure if you want all paths or paths specifically from node to another node. Either way this looks like a job for ```\nnetworkx```\n.\nSetup (```\nnx.from_pandas_edgelist```\n)\n```\nimport networkx as nx\nimport pandas as pd\n\n\ndf = pd.read_csv(\"...\")\n\ngraph = nx.from_pandas_edgelist(df, create_using=nx.DiGraph)\n```\n\nAll paths (```\nnx.all_simple_paths```\n)\n```\nfrom itertools import chain, product, starmap\nfrom functools import partial\n\n\nroots = (node for node, d in graph.in_degree if d == 0)\n\nleaves = (node for node, d in graph.out_degree if d == 0)\n\nall_paths = partial(nx.all_simple_paths, graph)\n\npaths = list(chain.from_iterable(starmap(all_paths, product(roots, leaves))))\n```\n\nFrom one node to another\n```\nsource_node = \"some_node_in_graph\"\ntarget_node = \"some_other_node_in_graph\"\nlist(nx.all_simple_paths(graph, source=source_node, target=target_node))\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all shortest paths in an unweighted graph from a source to a destination\r\n                \r\nI'd like to find all shortest path in an unweighted graph. In my first attempt I managed to find only one short path using BFS. \nI used a stack to save the shortest path and a queue for BFS.\nThe ```\nvisited```\n vector is used to mark if a node is visited or not.\nThis is what I've done in Java:\n\n```\npublic ArrayList<Integer> BFS(int source, int dest) {\n        ArrayList<Integer> shortestPathList = new ArrayList<Integer>();\n        boolean[] visited = new boolean[100];\n\n        Queue<Integer> q = new LinkedList<Integer>();\n        Stack<Integer> pathStack = new Stack<Integer>();\n\n        q.add(source);\n        pathStack.add(source);\n        visited[source] = true;\n\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            for (int v : graph.getNeighboursOf(u)) {\n                if (!visited[v]) {\n                    q.add(v);\n                    visited[v] = true;\n                    pathStack.add(v);\n                    if (u == dest)\n                        break;\n                }\n            }\n        }\n\n        // To find the path\n        int node, currentSrc = dest;\n        shortestPathList.add(dest);\n        while (!pathStack.isEmpty()) {\n            node = pathStack.pop();\n            if (graph.isNeighbor(currentSrc, node)) {\n                shortestPathList.add(node);\n                currentSrc = node;\n                if (node == source)\n                    break;\n            }\n        }\n\n        return shortestPathList;\n    }\n```\n\n\nThe ArrayList ```\nshortestPathList```\n contains only one short path. Can I modify this BFS to find all the shortest paths or I need to make another algorithm?\n    ", "Answer": "\r\nIn your code, \n\n```\nif (!visited[v]) {...}\n```\n\n\nensures you'll only use the first shortest path to each v. Instead of ignoring the others, you'll need to consider all of them (and you'll need to when the source is reached as long as paths of the same length are possible).\n\nIf you keep track of the minimal distance of visited nodes from the source, then this will find all shortest paths to the destination:\n\n```\nfunction shortest_paths_to(dest):\n\n    if dest == source:\n        yield path([n])\n        return\n\n    for each vertex n in neighbours(dest):\n\n        if distance_from_source(n) < distance_from_source(dest):\n           for each path p in shortest_paths_to(n):\n               p.append(dest)\n               yield p\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Get path in graph with weighted vertices and edges\r\n                \r\nIf i have the following undirected graph with weighted vertices and edges:\n\n\nI am trying to come up with a ruby algorithm to find a best shortest path within a defined limit (sum of edges) with the highest value (sum of vertices). \n\nThe start point will also be the ending point.\n\nfor e.g. finding a path with a maximum of 20 with the highest total value.\n\nThis problem seems like a np hard problem and it is hard to find the best solution. \n\nIs there a modified algorithm of dijkstra? I tried using a greedy algorithm but it did not give me a optimal solution. and by using bruteforce on all poosible path will work, but it will take very long if the number of nodes increases. \n\nWas wondering if there is any combination of algorithms that i can use to improve my solution?\n\nThanks.\n    ", "Answer": "\r\nYou can find an example of Djikstra's algorithm here. What I would do is add a variable to count the number of vertices in the shortest path, and evaluate if the shortest path has too many vertices or is too long once determining what the shortest path even is.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Infinite loop when trying to find the shortest path in a graph\r\n                \r\nI have adapted the below code to fit my needs for finding the paths in a graph\n\n```\n//H-File\n#include<iostream>\n#include <list>\nusing namespace std;\n#ifndef _Graph__\n#define _Graph__\n\n\nclass Graph\n{\n    int V; // No. of vertices in graph\n    list<int> *adj; // Pointer to an array containing adjacency lists\n\n    // A recursive function used by printAllPaths()\n    void printAllPathsUtil(int , int , bool [], int [], int &);\n\npublic:\n    Graph(int V); // Constructor\n    void addEdge(int u, int v);\n    void printAllPaths(int s, int d);\n};\n\nvoid solveMaze(string name, int start, int end);\n\n\n\n#endif /* defined(__Graph__) */\n\n    //CPP FILE\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n}\n\nvoid Graph::addEdge(int u, int v)\n{\n    adj[u].push_back(v); // Add v to u’s list.\n}\n\n// Prints all paths from 's' to 'd'\nvoid Graph::printAllPaths(int s, int d)\n{\n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n\n    // Create an array to store paths\n    int *path = new int[V];\n    int path_index = 0; // Initialize path[] as empty\n\n    // Initialize all vertices as not visited\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n\n    // Call the recursive helper function to print all paths\n    printAllPathsUtil(s, d, visited, path, path_index);\n}\n\n\nvoid Graph::printAllPathsUtil(int u, int d, bool visited[], int path[], int &path_index){\n    // Mark the current node and store it in path[]\n    visited[u] = true;\n    path[path_index] = u;\n    path_index++;\n\n    // If current vertex is same as destination, then print\n    // current path[]\n    if (u == d)\n    {\n        int steps;\n        for (int i = 0; i<path_index; i++){\n            cout << path[i] << \" \";\n            steps = i;\n        }\n\n        cout << endl;\n        cout << \"Length of path is \" << steps << endl;\n    }\n    else // If current vertex is not destination\n    {\n        // Recur for all the vertices adjacent to current vertex\n        list<int>::iterator i;\n        for (i = adj[u].begin(); i != adj[u].end(); ++i)\n            if (!visited[*i])\n                printAllPathsUtil(*i, d, visited, path, path_index);\n    }\n\n    // Remove current vertex from path[] and mark it as unvisited\n    path_index--;\n    visited[u] = false;\n}\n\nvoid solveMaze(string name, int start, int end){\n    vector<int> graphData;\n    ifstream f(name);\n    if (f.is_open()) {\n        string line;\n        getline(f, line);\n        char c;\n        while (f >> c) {\n            if (c == '1') {\n                graphData.push_back(1);\n            }\n            else if (c =='0') {\n                graphData.push_back(0);\n            }\n        }\n        f.close();\n    }\n\n\n    int numRooms = int(graphData.size()/4);\n    int numCols = sqrt(graphData.size()/4);\n    cout << \"numCols: \" << numCols << endl;\n    cout << \"rooms: \"<< numRooms << endl;\n    cout << endl;\n    cout << endl;\n\n    Graph maze(numRooms);\n    for(int room = 0; room < numRooms; ++room){\n        //if room is on top row and left corner\n        if(room == 0){\n\n            if(graphData[(room*4+1)] == 1){//You are at room 0, checking room 1\n                maze.addEdge(room, room+1);\n                cout << \"a \";\n                cout << \"room \" << room << \" to \" << room+1 << endl;\n            }\n            if(graphData[(room*4+2)] == 1){//Checking below room zero\n               maze.addEdge(room, room+numCols);\n                cout << \"b \";\n                cout << \"room \" << room << \" to \" << room+numCols << endl;\n            }\n        }\n\n        //if room is on top row\n        if(room < numCols && room !=0){\n            if(graphData[(room*4+1)] == 1){//Check to east\n                maze.addEdge(room, room+1);\n                cout << \"c \";\n                cout << \"room \" << room << \" to \" << room+1 << endl;\n            }\n            if(graphData[(room*4+2)] == 1){//Checking to south\n                maze.addEdge(room, room+numCols);\n                cout << \"d \";\n                cout << \"room \" << room << \" to \" << room+numCols << endl;\n            }\n\n        }\n\n        //if room is on top row and right corner\n        if(room == numCols-1){\n            if(graphData[(room*4+2)] == 1){//Checking to south\n                maze.addEdge(room, room+numCols);\n                cout << \"e \";\n                cout << \"room \" << room << \" to \" << room+numCols << endl;\n            }\n\n        }\n        //if room is on middle row and left room\n        if((room >= numCols) && (room%numCols == 0)){\n            if(graphData[(room*4+1)] == 1){//Check to east\n                maze.addEdge(room, room+1);\n                cout << \"f \";\n                cout << \"room \" << room << \" to \" << room+1 << endl;\n            }\n            if(graphData[(room*4+2)] == 1){//Checking to south\n                maze.addEdge(room, room+numCols);\n                cout << \"g \";\n                cout << \"room \" << room << \" to \" << room+numCols << endl;\n            }\n\n        }\n\n        //if room is on middle row and right room\n        if((room > numCols) && (room%numCols == numCols-1)){\n            if(graphData[(room*4+2)] == 1){//Checking to south\n                maze.addEdge(room, room+numCols);\n                cout << \"h \";\n                cout << \"room \" << room << \" to \" << room+numCols << endl;\n            }\n\n        }\n\n        //if room is on bottom row but not the room on the right corner\n        if(room > numCols && (room == numRooms-numCols)){\n            if(graphData[(room*4+1)] == 1){//Check to east\n                maze.addEdge(room, room+1);\n                cout << \"i \";\n                cout << \"room \" << room << \" to \" << room+1 << endl;\n            }\n\n        }\n        //else room is just in middle rows\n        if((room > numCols) && (room%numCols != numCols-1) && (room%numCols != 0)){\n            if(graphData[(room*4+1)] == 1){//Check to east\n                maze.addEdge(room, room+1);\n                cout << \"j \";\n                cout << \"room \" << room << \" to \" << room+1 << endl;\n            }\n            if(graphData[(room*4+2)] == 1){//Checking to south\n                maze.addEdge(room, room+numCols);\n                cout << \"k \";\n                cout << \"room \" << room << \" to \" << room+numCols << endl;\n            }\n\n        }\n    }\n    cout << endl;\n    cout << endl;\n    cout << \"Finding all paths from \" << start << \" to \" << end << \"...\" << endl;\n\n    maze.printAllPaths(start, end);\n}\n```\n\n\nIt is working pretty nicely except for when I have a situation where I hit a dead end in the graph and have to circle back. It continues to take the same path so it gets stuck in an infinite loop. I am not sure how I can combat this issue. Just to be clear: if I have a connection like\n\n```\nA--B--C--D--E\n   |\n   F\n```\n\n\nIt will travel from A to B to F and then back to B then to F repeatedly. I would like it to travel from A to B to F then back to B then to C. Any ideas?\n    ", "Answer": "\r\nIn ```\nprintAllPathsUtil```\n:\n\n```\n// Recur for all the vertices adjacent to current vertex\nlist<int>::iterator i;\n  for (i = adj[u].begin(); i != adj[u].end(); ++i)\n    if (!visited[*i])\n      printAllPathsUtil(*i, d, visited, path, path_index);\n\n// Remove current vertex from path[] and mark it as unvisited\nvisited[u] = false;\n```\n\n\nSo you don't mark B as visited until after you've finished exploring F. And you don't mark F as visited until after you've finished exploring B.\nSo you go back and forth between those two rooms, as if charging down an endless corridor.\n\nMark B as visited before you explore adjacent rooms.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest Path in Graph, when it is obligatory to jump over every second edge\r\n                \r\nI`ve been preparing myself for programming competition and I stumbled upon this problem, in which I have to find shortest path from source to destination in weighted and undirected graph, but I have to skip every second edge (so its weight is not important). Weight in graph are positive integers.\n\nOriginal statement:\n\n\n  Clara and Jake are on trip. They are driving in turns and car driver is being changed after every city. Find shortest path from source to destination, that Clara drove least miles. Write who should be car driver first.\n\n\nWhat is the best approach to solve this problem? Is there any modification of any algorithm to solve it easy? \n\nEdit: jumped edges has weight equal to 0, if edge can be skipped or not I have to check both options.\n    ", "Answer": "\r\nIf I understood correctly you want to find the shortest path in a weighted graph with the additional complexity that the weight of a path is the sum of the weight of the odd edges (1, 3, ...) or the even edges (2, 4, ...) along the path.\n\nYou can do this by first creating a new graph:\n\n\nfor each vertex ```\nv```\n in the original graph, create two vertices in the new graph, one will be called ```\neven v```\n and the other one ```\nodd v```\n\nif ```\n(u, v)```\n is an edge of weight ```\nw```\n in the original graph, add the following edges to the new graph: ```\n(even u, odd v)```\n with weight ```\nw```\n and ```\n(odd u, even v)```\n with weight ```\n0```\n\n\n\nThen do two usual Dijkstra to find the shortest path reaching ```\nodd destination```\n and ```\neven destination```\n from ```\neven source```\n. The one with the smallest weight is the shortest path if Clara is first to drive.\n\nDo the same procedure, starting from ```\nodd source```\n to find the shortest path if Clara is driving second.\n\nProof\n\nThe invariant we want to have in the new graph is:\n\n\n```\neven v```\n is a vertex reached through a path whose last edge is even numbered\n```\nodd v```\n is a vertex reached through a path whose last edge is odd numbered\n\n\nAs we only add edges from ```\neven```\n to ```\nodd```\n and from ```\nodd```\n to ```\neven```\n this invariant is true for the whole new graph. We use a weight of ```\n0```\n for even numbered edges to accomodate the special weighting function for paths.\n\nThe ```\nsource```\n in the original graph maps to the ```\neven source```\n in the new graph has it is reached by a path containing ```\n0```\n edges if Clara drive firsts. When Clara drives second, ```\nsource```\n maps to ```\nodd source```\n.\n\n```\ndestination```\n in the original graph may map to either ```\neven destination```\n or ```\nodd destination```\n depending on the number of edges on the path. By taking the shortest weighted path to either we are sure to find the shortest path using the special weighting function in the original graph.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all possible paths in a graph without cycle\r\n                \r\nI'm trying to write a Prolog program to give me all possible paths between two points in a graph (with cycle).\n\n```\nedge(a,b).\nedge(a,c).\nedge(a,d).\nedge(b,e).\nedge(c,e).\nedge(c,f).\nedge(d,f).\nedge(f,g).\nedge(g,e).\nedge(e,a).\n\nshow_path(X,Y,[X,Y]) :- edge(X,Y).\nshow_path(X,Z,[X|T]) :- edge(X,Y), not(member(Y, T)), show_path(Y,Z,T).\n```\n\n\nI'm trying to use ```\nnot(member())```\n to exclude the cycles and avoid infinite loop but it doesn't yield all possible solutions. How can I alter the program to get the all possible paths between two points in a graph with cycle?\n    ", "Answer": "\r\nYour program does not work because ```\nnot(member(Y, T))```\n will always be false: at this point, ```\nT```\n is not instantiated so it's always possible to find a list which contains ```\nY```\n.\n\nYou can fix your program by adding an accumulator:\n\n```\nshow_path(X,X,T,P) :- reverse([X|T],P).\nshow_path(X,Z,T,P) :- edge(X,Y), not(member(X,T)), show_path(Y,Z,[X|T],P).\n\nshow_path(X,Y,P) :- show_path(X,Y,[],P).\n```\n\n\nIt's not clear what you mean by avoiding cycles. Here, it will avoid passing twice on the same point, unlike @coder's answer. For example:\n\n```\n?- show_path(a,e,Z).\nZ = [a, b, e] ;\nZ = [a, c, e] ;\nZ = [a, c, f, g, e] ;\nZ = [a, d, f, g, e] ;\nfalse.\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest Path in Graph, when it is obligatory to jump over every second edge\r\n                \r\nI`ve been preparing myself for programming competition and I stumbled upon this problem, in which I have to find shortest path from source to destination in weighted and undirected graph, but I have to skip every second edge (so its weight is not important). Weight in graph are positive integers.\n\nOriginal statement:\n\n\n  Clara and Jake are on trip. They are driving in turns and car driver is being changed after every city. Find shortest path from source to destination, that Clara drove least miles. Write who should be car driver first.\n\n\nWhat is the best approach to solve this problem? Is there any modification of any algorithm to solve it easy? \n\nEdit: jumped edges has weight equal to 0, if edge can be skipped or not I have to check both options.\n    ", "Answer": "\r\nIf I understood correctly you want to find the shortest path in a weighted graph with the additional complexity that the weight of a path is the sum of the weight of the odd edges (1, 3, ...) or the even edges (2, 4, ...) along the path.\n\nYou can do this by first creating a new graph:\n\n\nfor each vertex ```\nv```\n in the original graph, create two vertices in the new graph, one will be called ```\neven v```\n and the other one ```\nodd v```\n\nif ```\n(u, v)```\n is an edge of weight ```\nw```\n in the original graph, add the following edges to the new graph: ```\n(even u, odd v)```\n with weight ```\nw```\n and ```\n(odd u, even v)```\n with weight ```\n0```\n\n\n\nThen do two usual Dijkstra to find the shortest path reaching ```\nodd destination```\n and ```\neven destination```\n from ```\neven source```\n. The one with the smallest weight is the shortest path if Clara is first to drive.\n\nDo the same procedure, starting from ```\nodd source```\n to find the shortest path if Clara is driving second.\n\nProof\n\nThe invariant we want to have in the new graph is:\n\n\n```\neven v```\n is a vertex reached through a path whose last edge is even numbered\n```\nodd v```\n is a vertex reached through a path whose last edge is odd numbered\n\n\nAs we only add edges from ```\neven```\n to ```\nodd```\n and from ```\nodd```\n to ```\neven```\n this invariant is true for the whole new graph. We use a weight of ```\n0```\n for even numbered edges to accomodate the special weighting function for paths.\n\nThe ```\nsource```\n in the original graph maps to the ```\neven source```\n in the new graph has it is reached by a path containing ```\n0```\n edges if Clara drive firsts. When Clara drives second, ```\nsource```\n maps to ```\nodd source```\n.\n\n```\ndestination```\n in the original graph may map to either ```\neven destination```\n or ```\nodd destination```\n depending on the number of edges on the path. By taking the shortest weighted path to either we are sure to find the shortest path using the special weighting function in the original graph.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Python: all simple paths in a directed graph\r\n                \r\nI am working with a (number of) directed graphs with no cycles in them, and I have the need to find all simple paths between any two nodes. In general I wouldn't worry about the execution time, but I have to do this for very many nodes during very many timesteps - I am dealing with a time-based simulation.\n\nI had tried in the past the facilities offered by NetworkX but in general I found them slower than my approach. Not sure if anything has changed lately.\n\nI have implemented this recursive function:\n\n```\nimport timeit\n\ndef all_simple_paths(adjlist, start, end, path):\n\n    path = path + [start]\n\n    if start == end:\n        return [path]\n\n    paths = []\n\n    for child in adjlist[start]:\n\n        if child not in path:\n\n            child_paths = all_simple_paths(adjlist, child, end, path)\n            paths.extend(child_paths)\n\n    return paths\n\n\nfid = open('digraph.txt', 'rt')\nadjlist = eval(fid.read().strip())\n\nnumber = 1000\nstmnt  = 'all_simple_paths(adjlist, 166, 180, [])'\nsetup  = 'from __main__ import all_simple_paths, adjlist'\nelapsed = timeit.timeit(stmnt, setup=setup, number=number)/number\nprint 'Elapsed: %0.2f ms'%(1000*elapsed)\n```\n\n\nOn my computer, I get an average of 1.5 ms per iteration. I know this is a small number, but I have to do this operation very many times.\n\nIn case you're interested, I have uploaded a small file containing the adjacency list here:\n\nadjlist\n\nI am using adjacency lists as inputs, coming from a NetworkX DiGraph representation.\n\nAny suggestion for improvements of the algorithm (i.e., does it have to be recursive?) or other approaches I may try are more than welcome.\n\nThank you.\n\nAndrea.\n    ", "Answer": "\r\nYou can save time without change the algorithm logic by caching result of shared sub-problems here. \n\nFor example, calling ```\nall_simple_paths(adjlist, 'A', 'D', [])```\n in following graph will compute ```\nall_simple_paths(adjlist, 'D', 'E', [])```\n multiple times:\n\n\nPython has a built-in decorator ```\nlru_cache```\n for this task. It uses hash to memorize the parameters so you will need to change ```\nadjList```\n and ```\npath```\n to ```\ntuple```\n since ```\nlist```\n is not hashable.\n\n```\nimport timeit\nimport functools\n\n@functools.lru_cache()\ndef all_simple_paths(adjlist, start, end, path):\n\n    path = path + (start,)\n\n    if start == end:\n        return [path]\n\n    paths = []\n\n    for child in adjlist[start]:\n\n        if child not in path:\n\n            child_paths = all_simple_paths(tuple(adjlist), child, end, path)\n            paths.extend(child_paths)\n\n    return paths\n\n\nfid = open('digraph.txt', 'rt')\nadjlist = eval(fid.read().strip())\n\n# you can also change your data format in txt\nadjlist = tuple(tuple(pair)for pair in adjlist)\n\nnumber = 1000\nstmnt  = 'all_simple_paths(adjlist, 166, 180, ())'\nsetup  = 'from __main__ import all_simple_paths, adjlist'\nelapsed = timeit.timeit(stmnt, setup=setup, number=number)/number\nprint('Elapsed: %0.2f ms'%(1000*elapsed))\n```\n\n\nRunning time on my machine:\n  - original: 0.86ms\n  - with cache: 0.01ms  \n\nAnd this method should only work when there's a lot shared sub-problems.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "c# linq graph database based path search\r\n                \r\nSituation example (oriented cyclic graph with some edge restrictions):\n\n4 different entity Types (A, B, C, D), 7 Relations (directed graph edges: A <-> B, A -> D, B -> D, B <-> C, C -> D). Graph dynamically changes.\nThe only graph function is to list all objects of one type, where path exists from selected vertices.\n\n\n\nI'm looking for design pattern, which can be used in realtime queries on (MS) SQL (best using c# linq). I know some base algorithms for path search in graphs, but I can't imagine performance on database.\nBasically it's used for security purposes. I read about some interesting security access patterns (lattice-based access control), but I'm not sure about solution and mainly about performance (1kk object of each of 15 entity types per user).\n\nAny literature, thesis, ideas, blogs are welcomed.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "printing the paths in Dijkstra's shortest path algorithm when the shortest path is not unique\r\n                \r\nSuppose we have a weighted graph. by the code implemented here, We can print the shortest path in the graph but what if we have more than one shortest path?\nI thought that the nodes can have multiple parents instead of one parent and then for printing them if the node had more than one parent we copy the paths in the size of the node's parent and do the rest as it is, but I don't know if this works or not and how to modify the code mentioned in the link to work like this.\nAny help would be appreciated.\n    ", "Answer": "\r\nBasically the current implementation serves the purpose of a single smallest path and discards any possible ties. In order to make sure that all parents are being processed, change your condition from the strict\n```\nif edge_distance > 0 and shortest_distance + edge_distance < shortest_distances[vertex_index]:\n```\n\nto the not-strict\n```\nif edge_distance > 0 and shortest_distance + edge_distance <= shortest_distances[vertex_index]:\n```\n\nBut you will need to be careful, because here you will have two cases:\nCase 1: edge_distance < shortest_distances[vertex_index]\nIn this case you will need to create a new collection and fill it with the single element that's closer than all earlier elements and assign this 1-element collection to the parents graph.\nCase 2: edge_distance equals shortest_distances[vertex_index]\nIn this case you should already have a collection of parents of the node and you should append the current one there\nYou should thoroughly test your solution, it's quite possible that you will stumble into recursion problems while you apply the solution, but the basic idea you need to use as your starting point is that, when a given shortest path of D is found from a node to the other, then you will need a collection of that element and whenever you find equally short paths, you just append their representative data to your collection.\nOkay. So, I changed the code to allow multiple parents. I create an empty array for the parents of each elements and whenever I find a shorter path, I recreate the parent array for that element and each time when I find a path that's not longer than any previous path, then I add it to the array, so ties end up being inside the array.\nFor the sake of simplicity, I used a graph of the form of\n```\n0 -> 1\n|    |\nv    v\n2 -> 3\n```\n\nWhere all vertices are of a length of 1 and there is a tie from 0 to 3, as 0 -> 1 -> 3 has a path length of 2, the same as for 0 -> 2 > 3.\n\r\n\r\n```\nconst NO_PARENT = -1;\n\nfunction dijkstra(adjacencyMatrix, startVertex) {\nconst nVertices = adjacencyMatrix[0].length;\n\n// shortestDistances[i] will hold the shortest distance from startVertex to i\nconst shortestDistances = new Array(nVertices).fill(Number.MAX_SAFE_INTEGER);\n\n// added[i] will true if vertex i is included in shortest path tree\n// or shortest distance from startVertex to i is finalized\nconst added = new Array(nVertices).fill(false);\n\n// Initialize all distances as infinite and added[] as false\nfor (let vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) {\n    shortestDistances[vertexIndex] = Number.MAX_SAFE_INTEGER;\n    added[vertexIndex] = false;\n}\n\n// Distance of source vertex from itself is always 0\nshortestDistances[startVertex] = 0;\n\n// Parent array to store shortest path tree\nconst parents = new Array(nVertices).fill([]);\n\n// The starting vertex does not have a parent\nparents[startVertex] = [];\n\n// Find shortest path for all vertices\nfor (let i = 1; i < nVertices; i++) {\n    // Pick the minimum distance vertex from the set of vertices not yet processed.\n    // nearestVertex is always equal to startVertex in first iteration.\n    let nearestVertex = -1;\n    let shortestDistance = Number.MAX_SAFE_INTEGER;\n\n    for (let vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) {\n    if (!added[vertexIndex] && shortestDistances[vertexIndex] < shortestDistance) {\n        nearestVertex = vertexIndex;\n        shortestDistance = shortestDistances[vertexIndex];\n    }\n    }\n\n    // Mark the picked vertex as processed\n    added[nearestVertex] = true;\n\n    // Update dist value of the adjacent vertices of the picked vertex.\n    for (let vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) {\n    const edgeDistance = adjacencyMatrix[nearestVertex][vertexIndex];\n\n        if (edgeDistance > 0 && shortestDistance + edgeDistance <= shortestDistances[vertexIndex]) {\n            if (shortestDistance + edgeDistance < shortestDistances[vertexIndex]) parents[vertexIndex] = [];\n            if ((parents[vertexIndex].indexOf(nearestVertex) < 0) && (adjacencyMatrix[nearestVertex][vertexIndex] > 0)) parents[vertexIndex].push(nearestVertex);\n            shortestDistances[vertexIndex] = shortestDistance + edgeDistance;\n    }\n    }\n}\n\nprintSolution(startVertex, shortestDistances, parents);\n}\n\n// A utility function to print the constructed distances array and shortest paths\nfunction printSolution(startVertex, distances, parents) {\nconst nVertices = distances.length;\n        document.write(\"Vertex<pre> Distance<pre>Path\");\n\nfor (let vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) {\n    if (vertexIndex !== startVertex) {\n    document.write(`<br>${startVertex} -> ${vertexIndex}\\t\\t ${distances[vertexIndex]}<pre><pre>`);\n    let results = printPath(vertexIndex, parents);\n    for (let r of results) document.write(r + \"<br>\");\n    }\n}\n}\n\n// Function to print shortest path from source to currentVertex using parents array\nfunction printPath(currentVertex, parents, text = \"\") {\n    if (currentVertex === 3) debugger;\n    let results = [];\n    if (text === \"\") text = currentVertex;\n    else text = currentVertex + \" -> \" + text;\n    for (let p of parents[currentVertex]) {\n        let innerResults = printPath(p, parents, text);\n        for (let ir of innerResults) results.push(ir);\n    }\n    if (results.length === 0) results = [text];\n    return results;\n}\n\n// Driver code\n\nconst adjacencyMatrix = /*[ [0, 4, 0, 0, 0, 0, 0, 8, 0],\n[4, 0, 8, 0, 0, 0, 0, 11, 0],\n[0, 8, 0, 7, 0, 4, 0, 0, 2],\n[0, 0, 7, 0, 9, 14, 0, 0, 0],\n[0, 0, 0, 9, 0, 10, 0, 0, 0],\n[0, 0, 4, 14, 10, 0, 2, 0, 0],\n[0, 0, 0, 0, 0, 2, 0, 1, 6],\n[8, 11, 0, 0, 0, 0, 1, 0, 7],\n[0, 0, 2, 0, 0, 0, 6, 7, 0]\n]*/\n[\n    [0, 1, 1, 0],\n    [0, 0, 0, 1],\n    [0, 0, 0, 1],\n    [0, 0, 0, 0]\n];\n\ndijkstra(adjacencyMatrix, 0);```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Prolog: Order of clauses for finding path in graph\r\n                \r\nI have a cyclic graph with entry and exit nodes for which I want to find out all paths leading from any entry to any exit node.\n\n```\nentry(a).\nexit(e).\nexit(f).\n\nnext(a, b).\nnext(b, c).\nnext(b, d).\nnext(c, e).\nnext(d, f).\n\n/* Cycle */\nnext(c, d).\nnext(d, b). \n\n/* path(entrynode, exitnode, pathtrace) */\npath(X, Y, P)       :- entry(X), path2(X, Y, P).\npath2(X, Y, [Y])    :- next(X, Y), exit(Y).\npath2(X, Y, [P|PS]) :- next(X, P), path2(P, Y, PS).\n```\n\n\nMy path2 predicate works great on a non cyclic graph. Now I want to extend it to cyclic ones. All I would have to do is check if a new possible node is already in my list of visited nodes. For this I would add ```\nnot(member(X, PS))```\n to my last rule. \n\nIf I add it before the recursion, it always returns false. If I add it after the recursion Prolog tries to find the paths first and runs out of stack. It returns the correct answers but it tries to find more and gets stuck.\n\nTherefore: Where should I add the check or what did I do wrong/what can I do better?\n    ", "Answer": "\r\nYou need an additional argument for your ```\npath2/3```\n predicate as your third argument is the path being constructed, not a list of visited nodes. I.e. you cannot simply add the ```\n\\+ member(X,Ps)```\n goal to the last rule of the predicate as ```\nPs```\n is bound by the recursive call. Try instead:\n\n```\npath(X, Y, P) :-\n    entry(X),\n    path2(X, Y, [], P).\n\npath2(X, Y, _Visited, [Y]) :-\n    next(X, Y),\n    exit(Y).\npath2(X, Y, Visited, [P|PS]) :-\n    next(X, P),\n    \\+ member(P, Visited),\n    path2(P, Y, [P| Visited], PS).\n```\n\n\nSample calls:\n\n```\n| ?- path(X, Y, P).                        \n\nP = [b,c,e]\nX = a\nY = e ? ;\n\nP = [b,c,d,f]\nX = a\nY = f ? ;\n\nP = [b,d,f]\nX = a\nY = f ? ;\n\nno\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all simple paths in a graph using NetworkX\r\n                \r\nI have to analyze some simple graphs with on the order of 20 nodes or so. I need to find all possible paths starting from an arbitrary node in the graph. ```\nall_simple_paths```\n looked like what I need, except I have to specify an end node. I would like the algorithm to traverse the graph until it finds the end node itself, where end node means it either has no neighbor or it is the last one before an already visited node.\nHere is an example:\n```\nimport networkx as nx\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnodes = [[0, 1], [1, 2], [2, 3], [1, 4], [3, 1], [0, 2]]\n\n# Build the graph. Start with the nodes.\nrl_graph = nx.DiGraph()\nfor link in nodes:\n    rl_graph.add_node(link[0])\n    rl_graph.add_node(link[1])\n\n# Add the edges.\nrl_graph.add_edges_from(nodes)\n\n# Draw.\npositions = {}\nfor idx, node in enumerate(rl_graph.nodes):\n    phi = 2 * np.pi / len(rl_graph.nodes) * idx\n    positions[node] = [np.cos(phi), np.sin(phi)]\nnx.draw(rl_graph, pos=positions)\n\nnx.draw_networkx_labels(rl_graph, positions)    \nplt.show()\n```\n\nThe output I would like to get is all the possible paths starting from a particular node, let's say node 0. The paths I would expect are:\n```\n0, 1, 2, 3\n0, 2, 3, 1\n0, 1, 4\n0, 2, 3, 1, 4\n```\n\nStarting from node 1, for example, I would expect:\n```\n1, 4\n1, 2, 3\n```\n\n    ", "Answer": "\r\nYou can use a custom recursive generator:\n```\ndef find_paths(G, start=0, path=None, seen=None):\n    if path is None:\n        path = [start]\n    if seen is None:\n        seen = {start}\n    \n    # get direct descendants\n    desc = nx.descendants_at_distance(G, start, 1)\n    if not desc:          # no descendants: STOP\n        yield path\n    else:\n        for n in desc:\n            if n in seen: # we already visited this node: STOP\n                yield path\n            else:\n                yield from find_paths(G, n, path+[n], seen.union([n]))\n                \nlist(find_paths(rl_graph, 0))\n# [[0, 1, 2, 3], [0, 1, 4], [0, 2, 3, 1], [0, 2, 3, 1, 4]]\n\nlist(find_paths(rl_graph, 1))\n# [[1, 2, 3], [1, 4]]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Best way to find the most costly path in graph\r\n                \r\nI have a directed acyclic graph on which every vertex has a weight >= 0. There is a vertex who is the \"start\" of the graph and another vertex who is the \"end\" of the graph. The idea is to find the path from the start to the end whose sum of the weights of the vertices is the greater. For example, I have the next graph:\n\n```\nI(0) -> V1(3) -> F(0)\nI(0) -> V1(3) -> V2(1) -> F(0)\nI(0) -> V3(0.5) -> V2(1) -> F(0)\n```\n\n\nThe most costly path would be I(0) -> V1(3) -> V2(1) -> F(0), which cost is 4.\n\nRight now, I am using BFS to just enumerate every path from I to F as in the example above, and then, I choose the one with the greatest sum. I am afraid this method can be really naive. \n\nIs there a better algorithm to do this? Can this problem be reduced to another one? \n    ", "Answer": "\r\nSince your graph has no cycles* , you can negate the weights of your edges, and run Bellman-Ford's algorithm.\n\n\n*  Shortest path algorithms such as Floyd-Warshall and Bellman-Ford do not work on graphs with negative cycles, because you can build a path of arbitrarily small weight by staying in a negative cycle.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Printing the longest path in an undirected graph\r\n                \r\nI am using this code https://www.geeksforgeeks.org/longest-path-undirected-tree/ to find the longest path in an undirected graph. The code uses two times BFS search to find the longest path and then it outputs the start and end of the path and the length. \nHow could I save the path in a list and print it? I save the predecessors in an array ```\nint predecessors[n]```\n, but of course this doesn't give the path. I know somehow I should modify the ```\npred[V]```\n so it stores a list of predecessors but I don't know how to implement it. \nAny help is appreciated.\n\n```\n// C++ program to find longest path of the tree \n#include <bits/stdc++.h> \nusing namespace std; \n// This class represents a undirected graph using adjacency list \nclass Graph { \n    int V;              // No. of vertices \n    list<int> *adj;     // Pointer to an array containing adjacency lists \n\npublic: \n    Graph(int V);              // Constructor \n    void addEdge(int v, int w);// function to add an edge to graph \n    void longestPathLength();  // prints longest path of the tree \n    pair<int, int> bfs(int u); // function returns maximum distant \n                               // node from u with its distance \n}; \nGraph::Graph(int V) \n{ \n    this->V = V; \n    adj = new list<int>[V]; \n} \nvoid Graph::addEdge(int v, int w) \n{ \n    adj[v].push_back(w);    // Add w to v’s list. \n    adj[w].push_back(v);    // Since the graph is undirected \n} \n```\n\n\n//  method returns farthest node and its distance from node u \n\n```\npair<int, int> Graph::bfs(int u) \n{ \n    //  mark all distance with -1 \n    int dis[V]; \n    int pred[V];  \\\\ I added this to store predecessors\n    memset(dis, -1, sizeof(dis)); \n    queue<int> q; \n    q.push(u);\n\n    dis[u] = 0;       //  distance of u from u will be 0 \n    pred[u] = {u};  // I added this line\n\n    while (!q.empty()) \n    { \n        int t = q.front();       q.pop(); \n        //  loop for all adjacent nodes of node-t \n        for (auto it = adj[t].begin(); it != adj[t].end(); it++) \n        { \n            int v = *it; \n            cout << \"adjacent node:\" << v << endl;\n            // push node into queue only if it is not visited already \n            if (dis[v] == -1) \n            { \n                q.push(v); \n                // make distance of v, one more than distance of t \n                dis[v] = dis[t] + 1; \n                cout << \"parent of adjacent node:\" << t << endl;\n                pred[v] = t // store the predecessor of v\n            } \n        } \n    } \n    int maxDis = 0; \n    int nodeIdx; \n    //  get farthest node distance and its index \n    for (int i = 0; i < V; i++) \n    { \n        if (dis[i] > maxDis) \n        { \n            maxDis = dis[i]; \n            nodeIdx = i; \n        } \n    } \n    return make_pair(nodeIdx, maxDis); \n}\n\n```\n\n\n//  method prints longest path of given tree \n\n```\nvoid Graph::longestPathLength() \n{ \n    pair<int, int> t1, t2; \n\n    // first bfs to find one end point of longest path\n    t1 = bfs(0); \n\n    //  second bfs to find actual longest path \n    t2 = bfs(t1.first); \n\n    cout << \"Longest path is from \" << t1.first << \" to \"\n         << t2.first << \" of length \" << t2.second; \n}\n```\n\n\n// Driver code to test above methods \n\n```\nint main() \n{ \n    // Create a graph given in the example \n    Graph g(10); \n    g.addEdge(0, 1); \n    g.addEdge(1, 2); \n    g.addEdge(2, 3); \n    g.addEdge(2, 9); \n    g.addEdge(2, 4); \n    g.addEdge(4, 5); \n    g.addEdge(1, 6); \n    g.addEdge(6, 7); \n    g.addEdge(6, 8); \n\n    g.longestPathLength(); \n    return 0; \n}\n```\n\n\n// Result:\n\n```\nLongest path is from 5 to 7 of length 5\n```\n\n    ", "Answer": "\r\n```\nV```\n is not a constant so ```\nint dis[V];```\n is invalid. This is C++, not C.\n\nYou need to find a way to return ```\npred```\n from ```\nbfs()```\n. You can either:\n\n\ndeclare ```\npred```\n in ```\nGraph```\n\nlocally in ```\nlongestPathLength()```\n and modify ```\nbfs()```\n to accept an additional argument ```\npred```\n\nlocally in ```\nbfs()```\n and return it together with ```\npair<int, int>```\n: ```\npair<pair<int, int>, PRED_T>```\n or ```\ntuple<int, int, PRED_T>```\n\n\n\nImo declare ```\npred```\n inside ```\nbfs()```\n is best way to do this. Here I use  ```\nvector<int>```\n for ```\ndis```\n and ```\npred```\n.\n\n```\nclass Graph {\n...\n    pair<pair<int, int>, vector<int>> bfs(int u);\n};\n\npair<pair<int, int>, vector<int>> Graph::bfs(int u) \n{ \n    //  mark all distance with -1 \n    vector<int> dis(V, -1);\n\n    vector<int> pred(V);\n\n    queue<int> q;\n    ...\n                dis[v] = dis[t] + 1;\n                pred[v] = t; // store the predecessor of v\n            }\n    ...\n    return make_pair(make_pair(nodeIdx, maxDis), pred);\n}\n\nvoid Graph::longestPathLength() \n{ \n    pair<int, int> t1, t2;\n\n    // first bfs to find one end point of longest path\n    t1 = bfs(0).first;\n\n    //  second bfs to find actual longest path \n    auto res = bfs(t1.first); // or  pair<pair<int, int>, vector<int>> res\n    t2 = res.first; \n\n    cout << \"Longest path is from \" << t1.first << \" to \"\n         << t2.first << \" of length \" << t2.second << endl;\n\n    // Backtrack from t2.first to t1.first\n    for (int t = t2.first; t != t1.first; t = res.second[t]) // `res.second` is `pred`\n        cout << t << \" \";\n    cout << t1.first << endl;\n}\n\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm for finding shortest \"k stride\" path in graph\r\n                \r\nThe graph is unweighted and undirected.\n\nGiven two vertices s and t, and stride k, I want to find the shortest path between them that is:\n\n\nOf length divisible by k\nEvery k \"steps\" in the path, counting from the first, are a simple path.\n\n\nMeaning, the shortest non-simple path that can only \"jump\" k vertices at every step (exactly k), and every \"jump\" must be a simple sub-path.\n\nI think this problem is equal to constructing a second graph, G', where (u, v) are an edge in G' if there exists a path of length k in G, because a BFS scan would give the required path -- but I haven't been able to construct such a graph in reasonable time (apparently it's an NP problem). Is there an alternative algorithm?\n    ", "Answer": "\r\nThe problem you're describing is NP-hard overall because you can reduce the Hamiltonian path problem to it. Specifically, given an n-node graph and a pair of nodes s and t, you can determine whether there's a Hamiltonian path from s to t by checking if the shortest (n-1)-stride path from s to t has length exactly n-1, since in that case there's a simple path from s to t passing through every node once and exactly once. As a result, if k is allowed to be large relative to n, you shouldn't expect there to be a particularly efficient algorithm for solving this problem.\n\nIn case it helps, there are some fast algorithms for finding long simple paths in graphs that might work really well for reasonable values of k. Look up the color-coding technique, in particular, as an example of this.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm to test collision for paths in undirected graph\r\n                \r\nI am working on a simulator for a railway that is represented by a undirected graph where the edges are the train tracks and the vertices are the switches.\n\nhere is what the railway looks like\n\nThere is only one track between each switch which lets the train drive both directions.\n\nFor every train I calculate their directions by using Dijkstra single shortest path algorithm. But now I need to be able to detect collision with that result.\n\nFor example let's say there are 2 trains A and B\n\nthe path of A = (Gt Mx Lg Nm Lg) \nwith current track being Gt\n\nand for B = (Gk Lg Nm Bx A1)\n\nYou can easily see these trains will hit each other at a certain point and I am looking for a way to predict and prevent this.\n\nHave looked into union find or maybe Knuth Algorithm x, but I hope any of you has a better idea of solving this.\n    ", "Answer": "\r\nIf you are not interested by time constraints, then you can use mixed integer programming applied to networks.\n\nEach train has one origin and one destination. \nFor each train:\n\n\ncreate one 'product' that can flow through your network.\ncreate a 'source' at the origin node, outputting the product (capacity is 1)\ncreate a 'sink' at the destination node, that eats this same product (capacity is 1)\n\n\nThen set each edge's capacity to 1.\nProduct flowing through each source and edge is an integer variable.\n\nThen ask your maxflow solver to maximize the amount of product flowing through sinks.\nThis will let you know the maximum amount of trains that can circulate on the network, as well as the paths used by each train to reach destination.\n\nOnce you have this information, you will know which tracks should be 'locked'.\n\nLinear/Mixed integer programming for network modelling : http://home.ubalt.edu/ntsbarsh/opre640a/partIII.htm\n\nFor implementation details, you can use Google OR tools, which is fairly easy to bootstrap, and works for java, C#, C++: https://developers.google.com/optimization/\n\nIf you want to go Python, you can see this post : Python Mixed Integer Linear Programming\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all paths in DAG from starting node\r\n                \r\nI am trying to find all paths in DAG from selected node.\n\nSo I am randomly generating list of tuples that looks like:\n\n```\nglavnaLista = [(6, 7), (6, 15), (15, 16), (16, 21), (15, 9), (9, 13), (13, 4), (4, 1), (1, 5)]\n```\n\n\nFrom this list we can see that node \"6\" is starting point of graph\n\nNow I am creating graph:\n\n```\nG = nx.DiGraph() \n    G.add_edges_from(glavnaLista)\n```\n\n\nSo it looks like this picture\n\nNow I am trying to find all paths (completed) from starting node with code:\n\n```\ndef find_all_paths(graph, start, path=[]):\n\n    path = path + [start]\n    if start not in graph:\n        return [path]\n    paths = [path]\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_paths(graph, node, path)\n            for newpath in newpaths:\n                print (newpath)\n                paths.append(newpath)        \n    return paths\n```\n\n\nResult is list of all paths:\n\n```\n[[6], [6, 7], [6, 15], [6, 15, 16], [6, 15, 16, 21], [6, 15, 9], [6, 15, 9, 13], [6, 15, 9, 13, 4], [6, 15, 9, 13, 4, 1], [6, 15, 9, 13, 4, 1, 5]]\n```\n\n\nBut my problem is that I don't need paths that are not full (not going to the ending node), my list should have only full paths:\n\n```\n[6, 7]\n[6, 15, 9, 13, 4, 1, 5]\n[6, 15, 16, 21]\n```\n\n\nMy idea is to check if the node has both neighbours, and if it doesn't than add path to list but I am not sure how to implement this as I am fairly new to python.\n    ", "Answer": "\r\nwhat you are trying to create is actually the tree created from ```\nBFS```\n or ```\nDFS```\n traversal over a ```\nDAG```\n. You can do this by changing your code a bit.\n\nFirst of all notice that you have some unnecessary code parts:\n\n```\ndef find_all_paths(graph, start, path=[]):\n    path = path + [start]\n    paths = [path]\n    for node in graph[start]:\n        newpaths = find_all_paths(graph, node, path)\n        for newpath in newpaths:\n            print (newpath)\n            paths.append(newpath)        \n    return paths\n```\n\n\nSince we assume this is a ```\nDAG```\n we can get rid of some conditions...\n\nNow we want to generate the paths of a ```\nDFS```\n traversal. The print here will print a path after each iteration but we would like to print the path after we reached an end.\nSo we will add a simple ```\nif```\n statement to check if this is the end of the path and if it is we will print the path:\n\n```\ndef find_all_paths(graph, start, path=[]):\n    path = path + [start]\n    paths = [path]\n    if len(graph[start]) == 0:  # No neighbors\n        print(path)\n    for node in graph[start]:\n        newpaths = find_all_paths(graph, node, path)\n        for newpath in newpaths:\n            paths.append(newpath)\n    return paths\n```\n\n\nResult:\n\n```\n[6, 7]\n[6, 15, 16, 21]\n[6, 15, 9, 13, 4, 1, 5]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Creating the number of shortest paths in a directed Graph\r\n                \r\nmy homework is Creating the number of shortest paths from S to any other vertex in a directed Graph using c language\n\nthe graph is shown as a txt file like this:\n\n```\n3 // number of vertex in G\n{2,3},{1},{} // in the first {} we can see the neighbors for V1 , in the second for V2 and so on\n```\n\n\nand i have to print an array of number of shortest path for s \n\nthe algorithm i use is like BFS with some adds:\nnumOfShortest(G,S)\n\n```\nfor vertex x which belongs to gropu V-S \ndo color[x]=white, d[x]=0, F[x]=0\ncolor[s]=gray,d[s]=0,F[s]=1\nwhile Q is not empty //= let Q be a queue\n do u=dequeue(Q)\n  for each vertex v = N(u) // = for every neighbor of u\n   do if color[v] = white \n    then color[v]= gray, d[v]=d[u]+1 \n       F[v]=f[v]+f[u] // = v must have atleast the same number of paths as u\n       enqueue(Q,v)\n      else if color[v]=gray \n       then if d[u] < d[v]\n        then f[v]=f[v]+f[u]\n  color[u]=black // = when finished with every N(u) \n```\n\n\nnow i have to take a few things into account ( correct me if im wrong)\n\n\nimplement a enqueue using a linked list\nmake a struct called vertex for each v which contains the neightbors\n( using a dynamic array )\ni need somehow to scan the neighbors written on the file to the\nneighbors on the struct vertex\n\n\nperhaps i took it too far with the preparations and there is a more simple way to do that, i got some mess in my mind. \nthanks to whoever can help \n    ", "Answer": "\r\nYou should start having a look at the Dijkstra algorithm to get the shortest path from one vertex S to every other vertex in the graph.\n\nThen maybe mixing it with a BFS-like algorithm will help you counting what you mean.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find two non overlapping paths in undirected graph [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI've been struggling on how to approach a problem for over two weeks now. I am supposed to generate an undirected graph which represents a map of streets, and I am supposed to divide the map into two sets of non overlapping streets and both paths should be roughly the same distance.\n\nWhat kind of algorithm should I use to solve it?\n\nI'm just looking for a general direction here on what kind of algorithm should I use to do that. \n\nEdit: (Test Case)\n\nLets assume that we have a non weighted, undirected Graph with Vertices A,B,C,D,E \n\n```\nA --- B \n|   / | \\\n|  /  |  C\n| /   | / \nD --- E \n```\n\n\nWhich means an adjacency matrix like this one: \n\n```\n  A  B  C  D  E\nA -  1  0  1  0\nB 1  -  1  1  1\nC 0  1  -  0  1\nD 1  1  0  -  1\nE 0  1  1  1  -\n```\n\n\nAssuming all edges are undirected, we have the following edges:\n\n```\n(a,b) (a,d) (b,d) (b,e) (b,c) (e,d) (e,c)\n```\n\n\nWhat I want is that through AI, I can take that graph and generate two groups of edges of roughly the same size. (In this particular case, since we have 7 edges, we would get a group of 3 edges and another one of 4 edges.\n\n```\nGroup 1: (a,b) (a,d) (b,d) (e,d)\nA --- B \n|   / \n|  /  \n| /     \nD --- E \n\nGroup 2: (b,e) (b,c) (e,c)\nB \n| \\\n|  C\n| / \nE \n```\n\n\nNotice that all edges in each group are connected by at least one node, that is a requirement.\n\nAnother valid solution could be, for example:\n\n```\nGroup 1: (d,a) (a,b) (b,c) (c,e)\nA --- B \n|       \\\n|       C\n|       / \nD     E \nGroup 2: (d,b) (b,e) (e,d)\n      B \n    / |\n   /  |\n  /   | \nD --- E \n```\n\n\nAnd so on, as you see there are many valid solutions but I want an algorithm to find one and I will keep the first one found. How would I do that? \n\nI'm sure that theres a formal way to state this problem, and I will very much appreciate if you tell me how should I do that.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding All Possible Paths On A Graph Data Structure\r\n                \r\nI have been searching for days for a way to find all paths in a graph data structure in JavaScript.\nMy data structure is like this and I use this implementation to get ```\nshortestPath```\n\n\r\n\r\n```\nconst data = [[\"a\", \"b\"], [\"b\", \"c\"], [\"d\", \"e\"], [\"a\", \"e\"]];\n\nfunction Graph() {\n  var neighbors = this.neighbors = {}; // Key = vertex, value = array of neighbors.\n\n  this.addEdge = function (u, v) {\n    if (neighbors[u] === undefined) {  // Add the edge u -> v.\n      neighbors[u] = [];\n    }\n    neighbors[u].push(v);\n    if (neighbors[v] === undefined) {  // Also add the edge v -> u so as\n      neighbors[v] = [];               // to implement an undirected graph.\n    }                                  // For a directed graph, delete\n    neighbors[v].push(u);              // these four lines.\n  };\n\n  return this;\n}\n\n\nfunction shortestPath(graph, source, target) {\n  var queue = [ source ],\n      visited = { source: true },\n      predecessor = {},\n      tail = 0;\n  while (tail < queue.length) {\n    var u = queue[tail++],  // Pop a vertex off the queue.\n        neighbors = graph.neighbors[u];\n    for (var i = 0; i < neighbors.length; ++i) {\n      var v = neighbors[i];\n      if (visited[v]) {\n        continue;\n      }\n      visited[v] = true;\n      if (v === target) {   // Check if the path is complete.\n        var path = [ v ];   // If so, backtrack through the path.\n        while (u !== source) {\n          path.push(u);\n          u = predecessor[u];          \n        }\n        path.push(u);\n        path.reverse();\n        return path;\n      }\n      predecessor[v] = u;\n      queue.push(v);\n    }\n  }\n}\n\nlet graph = new Graph();\ndata.forEach(cur => graph.addEdge(cur[0], cur[1]));\nconsole.log(shortestPath(graph, \"a\", \"c\").join(\" -> \"));\nconsole.log(shortestPath(graph, \"e\", \"c\").join(\" -> \"));```\n\r\n\r\n\r\n\nBut ```\nshortestPath```\n only returns one path and I want to get all paths with a ```\nmax-length```\n variable. Any help would be much appreciated\n```\ngetAllPaths({from: \"a\", maxLen: 10}); // Something like this\n```\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "how to find shortest path and longest path in an undirected graph?\r\n                \r\nI have a general question regarding how to find shortest path and longest path in an undirected graph with simple edges  where edges have no weights.\nIs it a correct conclusion that we need to use DFS algorithm to find the longest path in a graph, while we need to use BFS algorithm to find shortest path in a graph.\nI understand that when we use BFS we visit the nodes layer by layer, and we can use it for shortest path finding (that is probably why Dijkstra is BFS-based or similar to BFS). But i do not see how efficiently we can find the longest path from using BFS. Can somebody elaborate?\nAlso, I understand that using DFS to find the longest path might not efficient and we may need to use Dynamic programming idea to enhance the time complexity, but lets ignore it for the sake of functionality for this discussion.\n    ", "Answer": "\r\nMade this for you. Hope you find it easier now.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Most rewarding path in a graph\r\n                \r\nI'm faced with the following problem:\n\nGiven \n\n\nAn undirected graph, where each edge E has:\n\nEt - the time it takes to traverse E\nEr - the reward for traversing E\n\n\n\nGoal:\n\n\nProblem 1: Given time period T, find the most rewarding path in the graph\nProblem 2: Given time period T, find the most rewarding cycle in the graph (after period T, the agent must be at the start-point again).\n\n\nNotes: \n\n\nIf an edge is partially traversed, the reward is proportional the the portion traversed\nReward can be claimed only once for each edge traversed (or portion of)\nA path/cycle may start at any given point (either on a vertex, or along an edge)\n\n\nMy questions:\n\n\nIs this a known problem (Does it has a name? Has it been studied before?).\nIs it NP-hard?\nAny ideas how to approach it?\n\n\nKnown Related Problems:\n\n\nThe orienteering problem - Rewards are vertex-based (). In my case, the rewards are edge-based.\nProfitable Arc Tour Problem - The objective is to find a set of cycles in the graph that maximizes the collection of profit minus travel costs.\nEdit: The Undirected Capacitated Arc Routing Problem with Profits - Quite similar to my problem, but a depot vertex (start,end of each cycle) is given, the triangle inequality is satisfied, and the problem is generalized to a set of agents, all starting and ending at the same depot).\n\n    ", "Answer": "\r\nThis one reminded me this well known NP-hard problem\nhttp://en.wikipedia.org/wiki/Longest_path_problem\n\nThe problem you denoted must be NP-hard too.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find all unique paths of a graph from a source point to a destination\r\n                \r\nI want to try to find all unique possible paths in a graph from a source to destination node.  For context, I have turn a 2D array into a graph (an adjacency list) and now I want to find all unique paths in that adjacency list. I have tried DFS so far, but I feel that it may not be comprehensive.\nUnique is such that a path from source to destination does not share a a vertex or node with another path that is also source to destination.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Reconstructing the shortest path in a graph in BFS\r\n                \r\nI am implementing a function in ruby using BFS, and I would like to know how to print the shortest path in an undirected graph, between a start value and end value\nGraph\nIn this example the graph has ten vertices. Each node represents a vertex and it has an array that stores adjacent nodes (edges).\n```\n$ irb\ngraph.to_s\n1. 1 -> [2 3 4 5 8 9 10]\n2. 2 -> [1 4 5 6 7 8 10]\n3. 3 -> [1 4 6]\n4. 4 -> [1 2 3 6 7 8 9 10]\n5. 5 -> [1 2 8 9 10]\n6. 6 -> [2 3 4 7 8 9 10]\n7. 7 -> [2 4 6 8 9]\n8. 8 -> [1 2 4 5 6 7 9 10]\n9. 9 -> [1 4 5 6 7 8]\n10. 10 -> [1 2 4 5 6 8]\n=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\nExpected Output\n2,1,9 or 2,4,9, etc.\nBFS\n```\ndef bfs_shortest_path(graph, start=2, search=9)\n    if graph.nodes[start].nil? || graph.nodes[search].nil?\n        return nil\n    end\n    visited = Set.new\n    search_queue = Queue.new\n    search_queue.enq(start)\n    while !search_queue.empty? do      \n        current_node_key = search_queue.deq  \n        current_node = graph.nodes[current_node_key]         \n        visited.add(current_node_key)\n        if current_node.value == search\n            return current_node # I would like to return the PATH Eg. 2,1,9\n        end\n        adjacent_nodes_array = current_node.adjacent_nodes.map{|x| x.value}\n        adjacent_nodes_array.each do |value|\n            if !visited.include?(value)                   \n                search_queue.enq(value)\n                graph.nodes[value].concat_to_path(current_node.path_from_start)                \n            end\n        end        \n    end\nend\n```\n\nNode\n```\nclass Node\n    attr_reader :value\n    attr_reader :adjacent_nodes\n    def initialize(value)\n        @value = value\n        @adjacent_nodes = []\n    end\n\n    def add_edge(node)\n        @adjacent_nodes.push(node)\n    end\n\n    def to_s\n        \"#{@value} -> [#{@adjacent_nodes.map(&:value).sort.join(\" \")}]\"\n    end\nend\n```\n\nGraph\n```\nclass Graph\n    attr_reader :nodes    \n    def initialize\n        @nodes = {}\n    end\n\n    def add_node(node)        \n        @nodes[node.value] = node\n    end\n\n    def add_edge(node1,node2)\n        if @nodes[node1.value].adjacent_nodes.map(&:value).include? (node2.value)        \n            puts \"#{node1.value} and #{node2.value} already have an edge\"\n        elsif node1.value == node2.value\n            puts \"node1.value == node2.value\"\n        else\n            @nodes[node1.value].add_edge(@nodes[node2.value])\n            @nodes[node2.value].add_edge(@nodes[node1.value])\n        end\n    end\n\n    def to_s\n        @nodes.keys.sort.each_with_index do |key,index|\n            puts \"#{index + 1}. #{@nodes[key].to_s}\" \n        end\n    end\nend\n```\n\nGenerating a Graph\n```\ndef generate_random_graph\n    g = Graph.new\n    [*1..10].shuffle.each do |node_value|\n        g.add_node(Node.new(node_value))\n    end\n    40.times do \n        key1 = g.nodes.keys.sample\n        key2 = g.nodes.keys.sample\n        g.add_edge(g.nodes[key1],g.nodes[key2])\n    end\n    return g\nend\n```\n\nTest\n```\ngraph = generate_random_graph    \ngraph.to_s\nbfs_shortest_path(graph,2,9)\n```\n\n    ", "Answer": "\r\nThanks for the comments\nWorking Version\n```\nclass Node\n    attr_reader :value\n    attr_reader :adjacent_nodes\n    attr_reader :path_from_start\n    def initialize(value)\n        @value = value\n        @adjacent_nodes = []\n        @path_from_start = []\n    end\n\n    def add_edge(node)\n        @adjacent_nodes.push(node)\n    end\n\n    def add_to_path(value)\n        @path_from_start.push(value)\n    end\n\n    def concat_to_path(value_array)\n        @path_from_start.concat(value_array)\n    end\n\n    def to_s\n        \"#{@value} -> [#{@adjacent_nodes.map(&:value).sort.join(\" \")}]\"\n    end\nend\n\nclass Graph\n    attr_reader :nodes    \n    def initialize\n        @nodes = {}\n    end\n\n    def add_node(node)        \n        @nodes[node.value] = node\n    end\n\n    def add_edge(node1,node2)\n        if @nodes[node1.value].adjacent_nodes.map(&:value).include? (node2.value)        \n            puts \"#{node1.value} and #{node2.value} already have an edge\"\n        elsif node1.value == node2.value\n            puts \"node1.value == node2.value\"\n        else\n            @nodes[node1.value].add_edge(@nodes[node2.value])\n            @nodes[node2.value].add_edge(@nodes[node1.value])\n        end\n    end\n\n    def to_s\n        @nodes.keys.sort.each_with_index do |key,index|\n            puts \"#{index + 1}. #{@nodes[key].to_s}\" \n        end\n    end\nend\n\n\ndef generate_random_graph\n    g = Graph.new\n    [*1..10].shuffle.each do |node_value|\n        g.add_node(Node.new(node_value))\n    end\n    40.times do \n        key1 = g.nodes.keys.sample\n        key2 = g.nodes.keys.sample\n        g.add_edge(g.nodes[key1],g.nodes[key2])\n    end\n    return g\nend\n\ndef bfs(graph, start_node_value=2, search_value=9)\n    if graph.nodes[start_node_value].nil? || graph.nodes[search_value].nil?\n        return nil\n    end\n    visited = Set.new\n    search_queue = Queue.new\n    search_queue.enq(graph.nodes[start_node_value])    \n    while !search_queue.empty? do                \n        current_node = search_queue.deq        \n        visited.add(current_node)\n        if current_node.value == search_value\n            return current_node\n        end\n        current_node.adjacent_nodes.each do |node|\n            if !visited.include?(graph.nodes[node.value])                \n                search_queue.enq(graph.nodes[node.value])\n            end\n        end        \n    end\nend\n\ndef bfs_shortest_path(graph, start=2, search=9)\n    if graph.nodes[start].nil? || graph.nodes[search].nil?\n        return nil\n    end\n    visited = Set.new\n    visited.add(start)\n    search_queue = Queue.new\n    search_queue.enq(start)\n    while !search_queue.empty? do      \n        current_node_key = search_queue.deq  \n        current_node = graph.nodes[current_node_key]                 \n        current_node.add_to_path(current_node.value)\n        if current_node.value == search\n            return current_node.path_from_start\n        end\n        adjacent_nodes_array = current_node.adjacent_nodes.map{|x| x.value}\n        adjacent_nodes_array.each do |value|\n            if !visited.include?(value)                   \n                search_queue.enq(value)\n                visited.add(value)\n                graph.nodes[value].concat_to_path(current_node.path_from_start)                \n            end\n        end        \n    end\nend\n\n\ndef test_graph\n    graph = generate_random_graph    \n    graph.to_s\n    bfs_shortest_path(graph,2,9)\nend\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Visit all edges in a graph with minimum number of paths\r\n                \r\nI am trying to find an algorithm or a way to find paths in a directed graph to visit all edges exactly once with minimum number of paths possible. Then, print the results found.\nFor example in this graph, the minimum number of paths to cover all edges exactly once is 2 that are ( 1 → 3 → 4 → 3 → 2 ) and ( 1 → 2 )\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest and longest path in a topologically sorted unweighted directed acyclic graph using an adjacency matrix (Python, or pseudo-code)\r\n                \r\nI'm trying to solve a problem I was given for homework and really feel like I'm overthinking the algorithm and hoping someone here can push me in the right direction. \n\nI'm going to be given an input txt file which will look like this :\n\n```\n1    // n number of graphs\n4    // n number of vertices for graph 1\n4    // n number of edges for graph 1\n1 2  // edges given in pairs\n2 3\n2 4\n3 4 \n```\n\n\nAnd I'm supposed to use this data to crate n number of adjacency matrices representing the graphs. I then need to implement 3 methods on the data in the adjacency matrices:\n\n\nfindLongestPath() which will return the longest path in the graph\nfindShortestPath() which will return the shortest path in the graph\ntotalNumberPaths() which will return distinct number of paths in graph \n\n\nI'm having difficulty implementing the first two parts fine. This is what I have so far:\n\n```\ndef main():\n\n\nnumGraphs = input()\n\nfor x in xrange(0, numGraphs):\n    numVerts = input()\n    numEdges = input()\n    adjMat = [[0 for x in xrange(numVerts)] for x in xrange(numVerts)] \n    for x in xrange(0, numEdges):\n        edges = raw_input()\n        i, padding, j = edges.rpartition(\" \")\n\n        i = int(i)\n        j = int(j)\n\n        i -= 1\n        j -= 1\n\n        adjMat[i][j] = 1\n\n\n    numPaths = [0 for x in xrange(numVerts)]\n    numPaths[0] = 1 \n\n    longest_path = 1\n    shortest_path = numVerts\n\n    for i in xrange(0, numVerts):\n        current_path = 0\n        for j in xrange(0, numVerts):\n            if adjMat[i][j] == 1:\n                numPaths[j] += numPaths[i]\n                current_path += 1\n\n        if current_path > longest_path:\n            longest_path = current_path\n        if current_path < shortest_path:\n            shortest_path = current_path\n\n    print \"shortest: %d, longest: %d, total %d\" % (shortest_path, longest_path, numPaths[numVerts-1])\n\n if __name__ == \"__main__\":\n     main()\n```\n\n\nObviously when it hits a row of 0s the shortest_path updates to 0 and doesn't work. Plus it won't work when initialized to a 0. If I could get some pseudo code or maybe help with the longer or shorter method I'm sure I could write the opposite or maybe I'm totally off base.\n\nThanks for any input.\n\nEdit:\n\nSo i figured it out. Here's my finished code in case anyone has a similar problem and needs help.\n\n```\nnumGraphs = input()\n\nfor x in xrange(0, numGraphs):\n    numVerts = input()\n    numEdges = input()\n    adjMat = [[0 for x in xrange(numVerts)] for x in xrange(numVerts)] \n    for x in xrange(0, numEdges):\n        edges = raw_input()\n        i, padding, j = edges.rpartition(\" \")\n\n        i = int(i)\n        j = int(j)\n\n        i -= 1\n        j -= 1\n\n        adjMat[i][j] = 1\n\n\n    numPaths = [0 for x in xrange(numVerts)]\n    numPaths[0] = 1 \n\n    currentPath = [0 for x in xrange(numVerts)]\n    maxPath = 1\n    minPath = numVerts -1\n\n    for i in xrange(0, numVerts):\n        for j in xrange(1, numVerts):\n            if adjMat[i][j] == 1:\n                numPaths[j] += numPaths[i]\n                currentPath[j-i] += 1\n            if (currentPath[j-i] is not 0):\n                minPath = currentPath[j-i]\n            maxPath = max(currentPath)\n\n    print \"shortest: %d, longest: %d, total %d\" % (minPath, maxPath, numPaths[numVerts-1])\n```\n\n    ", "Answer": "\r\nFigured it out. Here is my final solution.\n\n```\nnumGraphs = input()\n\nfor x in xrange(0, numGraphs):\n    numVerts = input()\n    numEdges = input()\n    adjMat = [[0 for x in xrange(numVerts)] for x in xrange(numVerts)] \n    for x in xrange(0, numEdges):\n        edges = raw_input()\n        i, padding, j = edges.rpartition(\" \")\n\n        i = int(i)\n        j = int(j)\n\n        i -= 1\n        j -= 1\n\n        adjMat[i][j] = 1\n\n\n    numPaths = [0 for x in xrange(numVerts)]\n    numPaths[0] = 1 \n\n    currentPath = [0 for x in xrange(numVerts)]\n    maxPath = 1\n    minPath = numVerts -1\n\n    for i in xrange(0, numVerts):\n        for j in xrange(1, numVerts):\n            if adjMat[i][j] == 1:\n                numPaths[j] += numPaths[i]\n                currentPath[j-i] += 1\n            if (currentPath[j-i] is not 0):\n                minPath = currentPath[j-i]\n            maxPath = max(currentPath)\n\n    print \"shortest: %d, longest: %d, total %d\" % (minPath, maxPath, numPaths[numVerts-1])\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all paths in directed graph with specific cost\r\n                \r\nSuppose we have the directed, weighted graph. Our task is to find all paths beetween two vertices (source and destination) which cost is less or equal =< N. We visit every vertex only once. In later version I'd like to add a condition that the source can be the destination (we just make a loop).\n\nI think it can be done with modified Dijkstra's algorithm, but I have no idea how implement such thing. Thanks for any help.\n    ", "Answer": "\r\nYou could use recursive backtracking to solve this problem. Terminate your recursion when:\n\n\nYou get to the destination\nYou visit a node that was already visited\nYour path length exceeds N.\n\n\nPseudocode:\n\n```\nlist curpath := {}\nint dest, maxlen\ndef findPaths (curNode, dist):\n    if curNode = dest:\n        print curpath\n        return\n    if curNode is marked:\n        return\n    if dist > maxlen:\n        return\n    add curNode to curpath\n    mark curNode\n    for nextNode, edgeDist adjacent to curNode:\n        findPaths(nextNode, dist + edgeDist)\n    remove last element of curpath\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Why finding the longest path in a graph is NP-hard\r\n                \r\nThis link mentions:\n\n\n  A longest path between two given vertices s and t in a weighted graph\n  G is the same thing as a shortest path in a graph −G derived from G by\n  changing every weight to its negation. Therefore, if shortest paths\n  can be found in −G, then longest paths can also be found in G.\n\n\nSo why is finding the longest path an NP-hard problem if this transformation can reduce it to the shortest path problem?\n\nAfter the transformation, we have have these cases:\n\n\n```\n-G```\n has a negative cycle, in which case the shortest path in ```\n-G```\n cannot be found\n```\n-G```\n does not have a negative cycle, in which case Floy-Warshall or Bellman-Ford algorithm can find the shortest path in ```\n-G```\n in polynomial time\n\n\nQuestions: \n\n\nIs it correct to say if there is no negative cycle, the problem of finding longest path is not NP-hard?\nIs it correct to say in the presence of negative cycles, there is still a longest ```\nsimple path```\n between nodes which is NP-hard to be found?\nIf so, is it more accurate to say finding the longest simple path in a graph is NP-hard?\nIf so, because of ```\n-G```\n transformation is it also correct to say that finding the shortest simple path in a graph is also NP-hard?\n\n\nEdit\n\nThis link explains the confusion about longest path problem in more details:\nhttps://hackernoon.com/shortest-and-longest-path-algorithms-job-interview-cheatsheet-2adc8e18869\n    ", "Answer": "\r\nThe confusion here is that the Longest Path Problem generally asks for the longest simple path, i.e., the longest path without repeated vertices. For this reason, it can be reduced to the Hamiltonian Path problem, which is known to be NP-hard.\n\nBellman-Ford and similar algorithms, on the other hand, compute the shortest path in a graph (note: without simple), i.e. vertices can be repeated.\n\nSo your four questions:\n\n\nNo. If there is a negative cycle in ```\n-G```\n, a longest path does not exist at all in ```\nG```\n, because you can just continue walking around the cycle forever. A longest ```\nsimple```\n path might still exist, but with or without negative cycle, the problem can be reduced to Hamiltonian Path and is therefore still NP-hard.\nIndeed! (If the graph is undirected.)\nYup\nYup\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding top X shortest path in complete graph\r\n                \r\nI understand that Dijikstra algorithm would give me the shortest path in the graph. However, say i would like to find the top x number of shortest path in the graph. Would there be any algorithms to solve that issue?\n\nI have found a solution but i didnt really understand the data files. \n\nheres a link to my question\n\nhttps://stackoverflow.com/questions/28017527/yen-implementation-of-shortest-path\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Bfs modification to find compatible paths in a directed graph\r\n                \r\nI have the following directed graph and every node has one or more attributes. I try to modify bfs algorithm to find all possible paths from a starting node until the given attributes are covered. I also want the path that i found to not be a part of a cycle. \n\nFor this graph if i start from node 1 and i want to cover attr 4 the paths that my algorithm will find are:\n\n```\n1-2-3\n1-2-5-3\n1-2-5-6-8\n```\n\n\nIf i add the edge ```\n3-1```\n then the paths ```\n1-2-3```\n and ```\n1-2-5-3```\n i want not to be accepted because are part of a cycle. So in my algorithm i try to check the neighbors of the last visited node and if the neighbor has already visited then i try to discard this path but my algorithm doesnt work in this case. If i add the edge ```\n3-1```\n it returns the same paths. How can i fix this?\nHere is my code:\n\n```\nG = nx.DiGraph()\n\nG.add_edge(1,2)\nG.add_edge(2,3)\nG.add_edge(2,5)\nG.add_edge(3,4)\nG.add_edge(5,3)\nG.add_edge(5,6)\nG.add_edge(5,7)\nG.add_edge(6,8)\nG.add_edge(3,1)\n\ndef checkIfRequiredAttrsAreCovered(path, attrsToBeCovered):\n    coveredAttrs = []\n    counter = 0\n    for node in path:\n        coveredAttrs.extend(G.node[node]['attrs'])\n    for i in attrsToBeCovered:\n        if i in coveredAttrs:\n            counter = counter + 1\n    if counter == len(attrsToBeCovered):\n        return True\n    else:\n        return False\n\n\ndef bfs(G, startingNode, attrsToBeCovered):\n    paths = []\n    q = queue.Queue()\n    q.put([startingNode])\n    while not q.empty():\n        v = q.get()\n        if checkIfRequiredAttrsAreCovered(v, attrsToBeCovered) == True:\n            for i in G.neighbors(v[-1]):\n                if i in v:\n                    break\n            paths.append(v) #print(v)\n        else:\n            for node in G.neighbors(v[-1]):\n                if node not in v:\n                    path = []\n                    path.extend(v)\n                    path.append(node)\n                    q.put(path)\n\n    print(paths)\n```\n\n    ", "Answer": "\r\nI'll assume that you don't care if nodes are part of a bigger cycle. E.g. if 4 is connected to 1 and 3 is in a cycle 1-2-3-4. If you want to handle this, you may start a dfs from each matching node, with the current path set as visited.\n\nFirst, you should use snake case in Python   \n\nSecond, you should use ```\nset```\ns to compare the attributes covered to the attributes to be covered. For a path, compute the set of covered attributes and compare the sets:\n\n```\ndef check_if_required_attrs_are_covered(G, path, attrs_to_be_covered): # be sure to pass G as an argument here\n    covered_attrs = set([G.node[n]['attrs'] for n in path])\n    return covered_attrs >= attrs_to_be_covered\n```\n\n\nThird, some remarks on the ```\nbfs```\n function:\n\n\nA test ```\nif b == True:```\n is equivalent to ```\nif b:```\n, because for a boolean ```\nb == (b == True)```\n (try with True and False to convince yourself)\nThe way you append a path to ```\nq```\n may be shortened to ```\nq.put(v+ [node])```\n\nYou probably do not need a synchonized ```\nqueue```\n: use a list\nUse return instead of print or even better, create a generator that yields paths when they are found.\n\n\nFour: what is the problem? Look at the ```\nfor i in G.neighbors(v[-1]):```\n loop. \nWhether you ```\nbreak```\n or not, you go to the line ```\npaths.append(v)```\n. \nThat's why you do not exclude the paths with cycles. You want to distinguish the normal end of the loop from the break. \nThat's a perfect case for confidential loop syntax in Python: the ```\nfor...else```\n loop.\nI quote the doc: \"a loop’s else clause runs when no ```\nbreak```\n occurs\". This gives the following code:\n\n```\nfor i in G.neighbors(v[-1]):\n    if i in v:\n        break\nelse: # no neighbor from v[-1] in v\n    yield v # instead of paths.append(v)\n```\n\n\nBut you can also use ```\nany```\n for a more natural expression:\n\n```\nif not any(i in v for i in G.neighbors(v[-1])):\n    yield v # instead of paths.append(v)\n```\n\n\nThis gives the following code:\n\n```\ndef bfs(G, starting_node, attrs_to_be_covered):\n    q = [[starting_node]]\n    while q:\n        v = q.pop()\n        if check_if_required_attrs_are_covered(G, v, attrs_to_be_covered): # be sure to pass G as an argument\n            if not any(i in v for i in G.neighbors(v[-1])):\n                yield v\n        else:\n            for node in G.neighbors(v[-1]):\n                if node not in v:\n                    q.append(v+ [node])\n```\n\n\nTry it with:\n\n```\nprint (list(bfs(G, 1,  set([\"attr4\"]))))\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All shortest paths in a graph with one alteration\r\n                \r\nLet's say i have a directed graph G(V,E) with positive integer weights on it's edges.What i need to do is find the minimum distance between some of it's nodes.In this minimum distance path i can use at most K reverse edges.\nFor example, for this input:\n\n6 (nodes)\n\n9 (edges)\n\n2 (positive integer K)\n\n10 (number of edge pairs i need to find the minimum distance)\n\n2 1 2 (edge for 2->1 with weight 2)\n\n3 2 7 (edge for 3->2 with weight 7)\n\n4 5 6\n\n1 3 8\n\n1 4 4\n\n5 2 8\n\n5 6 10 (edge 7)\n\n1 5 5 (edge 8)\n\n4 2 5 (edge 9)\n\n1 6 1 (question 1:find minimum distance from 1->6 using 1 reverse edge)\n\n3 5 0  (question 2:find minimum distance from 3->5 using 0 reverse edge)\n\n1 2 0\n\n3 5 1\n\n1 2 1\n\n4 3 1\n\n6 4 0\n\n2 6 2\n\n6 4 1\n\n6 4 2 (question 10)\n\nThe different parts of the input can be separated using the number of edges(9,first 9 lines containing 3 numbers) and numbers of questions asked(10,the 10 lines following after the edges)\n\nOutput has to be:\n\n15 (Answer to question 1:minimum distance from 1->6 using 1 reverse edge is 15)\n\n14\n\n9\n\n13\n\n2\n\n12\n\nIMPOSSIBLE (there is no path between these two edges using 0 reverse edges)\n\n17\n\n24\n\n16\n\nI thought about running Dijkstra for each question and for each edge instead of just calculating the single minimum distance from source use reverse edges too and updating the value as much as possible without using more than K reverse edges.(The label would be something like (node number,minimum distance from source,reverse edges used).But dijkstra finds shortest paths from source to all other nodes and i think this is probably an overkill for my instance.Could this somehow be done more efficiently?\n    ", "Answer": "\r\nYou can run dijkstra on each node considering the graph as undirected graph. You need to keep track of minimum distance and the number of reversed nodes used. For example,let's take starting node to be 3.\n\nSuppose we need to find (3 1 0) and (3 1 1) in the question.\n\nWe initialize node 3 as (0,0) and all other nodes as (INFINITY,0). From node 3, we can go to either node 2 in straight direction or node 1 in reverse direction. So we get\n\n\n  Node 1(8,1) and Node 2(7,0)\n\n\nFrom Node 2, we go to Node 1 in straight direction. Hence we get\n\n\n  Node1(8,1)(9,0). This means Minimum value from node 3 to node 1 is 9 if 0 edges are reversed and 8 if 1 edge is reversed.\n\n\nFor each Node you can track these in HashMap and the answer would be Minimum distance between 0 to k. For example we may get Node2(7,0)(10,2). here the answer will when two edges are allowed to be reversed is still 7 as 10>7.\n\nThe complexity of this algorithm will be O(n*(n+m)).   \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Efficient algorithm to find All paths between two nodes in less time\r\n                \r\nHi I am searching for all possible paths in directed graph has cycles in it. \nBut I am looking for paths which will not have repeated nodes in it.\nI have modified BFS and could able to find paths also, but since graph has more than 1000  nodes its running for longer time to extracts all paths.\n~~: In graph there are some nodes which has number of clones present in it.\n\nCan you please help me to find efficient algorithm which can find all paths between two nodes in short duration.\n    ", "Answer": "\r\nI am afraid what you are asking for is impossible.\n\n\n  But I am looking for paths which will not have repeated nodes in it\n\n\nThis is called \"simple paths\" There are exponential number of those.\nFor example, let's imagine we have a graph with 50 vertices, and there is an edge between every pair. There are 49!~=6*10^62  simple paths between ```\nu```\n and ```\nv```\n. This is more than the number of atoms on earth.\n\nIf you have much smaller graphs, you can do it with a variation of DFS, that maintains a ```\nvisited```\n set for nodes in the current path.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How can I specify paths in Fuseki?\r\n                \r\nI have a Fuseki server running (```\nfuseki-server --mem /ds```\n) with a dataset at path /ds. So far I can upload new models to that dataset and execute queries on it. When I browse to ```\nhttp://localhost:3030/ds/```\n, it has all the triple from the model (as expected):\n\n```\n<http://localhost:3030/ds/person/5>\n        a          foaf:Person ;\n        foaf:name  \"Borys\" .\n\n<http://localhost:3030/ds/person/6>\n        a          foaf:Person ;\n        foaf:name  \"Andy\" .\n```\n\n\nMy question is: is it possible to upload portions of this model to customized paths in the Fuseki server? For example, a way of browsing to ```\n<http://localhost:3030/ds/person/5>```\n and obtaining only the following triples.\n\n```\n<http://localhost:3030/ds/person/5>\n            a          foaf:Person ;\n            foaf:name  \"Borys\" .\n```\n\n\nI may be a bit confused but it would be interesting to query individual instances like:\n\n```\nSELECT ?p ?o\nWHERE { <http://localhost:3030/ds/person/5> ?p ?o }\n```\n\n\nAnd so far the closest I got to this solution was to create named graphs for each person.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find shortest path in a directed graph that has edge weights either 0 or 1 in linear time?\r\n                \r\nI am looking for a way to augment the BFS method used to find the single source shortest paths in an unweighted directed graph and solve the above problem in O(N+M) time. \nwhere N is the number of vertices, M is the number of edges\n\nI have thought the following:\n\n\nContract the vertices of the graph that have an edge weight 0 between them. But this would definitely be wrong as then I would be changing the graph's properties and adding new edges to vertices that originally had none.\nChanging the edge weights to 1 and 2. And then creating dummy vertices in the paths that are of length 2 to convert those edges to edges of weight 1. But this would give the wrong answer.\n\n\nIn more generality, how can I find single source shortest paths in a directed graph when the edge weights are between 0 and MAX in linear time. (MAX is the maximum edge weight)\n    ", "Answer": "\r\nYou can use bfs with some modifications: maintain a deque instead of a queue and add a vertex to the front of the deque if 0 edge is used and to the back of the deque otherwise.(I mean 0-1 case now)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "What is minimal path in graph after Dijkstra's Algorithm?\r\n                \r\nMy result graph after appling algorithm is:\n\nenter image description here\n\nWhat does vector P mean in this grapth? ```\nР = {1, 1, 5, 5, 1}.```\n Also what is short path from vertex 1 to 4?\n    ", "Answer": "\r\nVector P indicates the parent for each node in the graph, that is, the previous state in the optimal path from the start to the node.\n\n\nNode 1 is the start state and has 1 (itself) as its parent.\nNode 2 is reached optimally from 1, so 1 is the parent of 2.\nNode 3 is reached through the path 1-5-3, so 5 is the parent of 3.\nNode 4 is reached through the path 1-5-4, so 5 is the parent of 4.\nNode 5 is reached optimally from 1, so 1 is the parent of 5.\n\n\nFollowing the parents, 4 is reached from 5 and 5 is reached from 1.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Algorithms to find the number of Hamiltonian paths in a graph\r\n                \r\nI'm trying to solve a slightly modified version of the Hamiltonian Path problem. It is modified in that the start and end points are given to us and instead of determining whether a solution exists, we want to find the number of solutions (which could be 0).\n\nThe graph is given to us as a 2D array, with the nodes being the elements of the array. Also, we can only move horizontally or vertically, not diagonally. Needless to say, we can't go from one city to two cities because to do that we would need to visit a city twice. \n\nI wrote a brute force solution that tries all 4 (3 or 2 for nodes on the edges) possible moves at each node and then counts the number of solutions (which is when it reaches goal and has seen all the other nodes too), but it ran for ridiculous amounts of time on inputs of modest size (like, say a 7x7 array). \n\nI also thought of using bidirectional search since we know the goal, but this didn't really help, since we don't just want the fringes to meet, we want to also ensure that all the nodes have been visited. Moreover, it could be that when all nodes have been exhausted between the two fringes, they end in a way such that they can't be joined. \n\nI feel like there is something I don't know that's leaving me with only a brute force solution. I know that the problem itself is NP-complete, but I'm wondering if there are any improvements over brute force. Can someone suggest something else?\n\n--Edit--\n\nI mentioned that using bidirectional search doesn't really help and I'd like to clarify why I thought so. Consider a 2x3 graph with the top left and bottom right nodes being the start and goal respectively. Let the fringes for bidirectional search move right from start and left from goal. After 2 moves, all the nodes would have been visited but there is no way to join the fringes, since we can only go in one direction from one node. However, it might be possible to make the algorithm work with some modifications, as David pointed out in his answer below. \n    ", "Answer": "\r\nAccording to Wolfram Alpha,\n\n\n  ... the only known way to determine\n  whether a given general graph  has a\n  Hamiltonian path is to undertake an\n  exhaustive search\n\n\nI believe you would want to start by finding a single hamiltonian path, and then splitting it into two paths, making the split point one that clearly separates the two paths as much as possible. Then you can find the permutations in the subgraphs (and recurse, of course!)\n\nI don't know the exact algorithm, but that sort of divide and conquer method is where I would start.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Unvisited neigbours in graph path\r\n                \r\nI am trying to find distance in an undirected graph, but when navigating to different path, the count cannot be calculated properly. \n\nI am not sure what is the best approach for:\n\n1) To count the path values excluding unnecessary paths.\n\n2) To keep the path (I think to use LinkedList or ArrayList, etc.  what is the best choices for this situation. \n\nAny help would be appreciated. \n    ", "Answer": "\r\nHere is a code that solves this problem:\n\n```\nvoid Measure(Node node)\n{\n    path.Add(node);\n    node.IsVisited = true;\n\n    if (node != destination)\n    {\n        foreach (var neighbor in node.Neighbors.Where(n=>!n.IsVisited))\n        {\n            Measure(neighbor);\n        }\n        path.RemoveAt(path.Count - 1);\n    }\n}\n```\n\n\nYou can use any dynamic length structure such as List or LinkedList for storing the path. List is recommended for simplicity.\n\nusage:\n\n```\nvar path = new List<Node>()\nMeasure(firstNode);\nPrint(path.Count);\n```\n\n\nthis works if there is a path between the two nodes. otherwise the path is empty.\n\n```\nclass Node\n{\n     public string Name { get; set; }\n     public bool IsVisited { get; set; }\n     public List<Node> Neighbors { get; set; } = new List<Node>();\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find two disjoint paths in a bidirectional graph?\r\n                \r\nI have a graph with 14 nodes and 21 links. This graph shows an optical network. The links are bidirectional and there are some resources on each link. Assume there is a working path from a source to a destination which carry a packet containing data and uses some resources(some amount of bandwidth of the link that it is traversed by). for each source and destination, I must establish a working and a protection path simultaneously in advance in case of a link failure but they muse be link disjoint.(they cannot traverse any common link)\n\nFor example I send a packet from node1 to node4 through route<1,2,3,4> as the working path.\n If link 1-2 fails, I have to send the packet through a protection path that has been established in advance and is disjoint with the working path. for example my protection path may be <1,9,3,4>.\n\nThe purpose is write a code in C/C++ to find the protection path which is link disjoint with the working path. Actualy I couldn't get an idea for doing that. Any help would be greatly appreciated.\n\nThis is a piece of my code where I have allocate resources to working paths, I don't know how I can do the same for establishing protection path under condition that it must be disjoint with the working path.\n\n```\n int required_fs;\n    int des;\n    int idpk;\n    double holding;\n    int src;\n\n  //get the information about the packet that is sent from source to destination.    \n    Packet *pkptr;\n    pkptr = op_pk_get (0);\n    op_pk_nfd_get(pkptr,\"bw_fs\",&required_fs);\n    op_pk_nfd_get(pkptr,\"des\",&des);\n    op_pk_nfd_get(pkptr,\"src\",&src);\n    op_pk_nfd_get(pkptr,\"id\",&idpk);\n    op_pk_nfd_get(pkptr,\"ht\",&holding);\n\n\n    bw_req=bw_req + required_fs;\n    number_of_req=number_of_req+1;\n\n    if (number_of_req > 1000000)\n        {\n            FILE* file1=fopen(\"C:/400f_rsa.txt\",\"a+\");\n            fprintf(file1,\"\\n\");\n            fprintf(file1,\"number_of_req ,number_of_nack,number_of_ack , bw_req , bw_nack , bw_ack \" );\n            fprintf(file1,\"\\n\");\n            fprintf(file1,\"  %d , %d , %d , %d , %d , %d   \", number_of_req, number_of_nack ,number_of_ack,bw_req,bw_nack,bw_ack );\n            fprintf(file1,\"\\n\");\n            fprintf(file1,\"------------------------------- \");\n            fclose (file1);\n            op_sim_end(\"1000000 paket\",\"\",\"\",\"\");\n\n        }\n\n //  Allocate the resources on each link to the working path, This part must be the same for the protection path too.\n    int determined_t=0;\n    int determined_r=0;\n    int determined_p_f=0;\n    int determined_p_e=0;\n    int determined_k=0;\n\n    for ( int i=1; i<=10; i++)\n        {\n            if (transmitter[src][i]==0)\n                {\n                    determined_t=i;\n                    break;\n                }\n        }\n\n    if (determined_t!=0)\n        {\n            for ( int i=1; i<=10; i++)\n                {\n                    if (reciever[des][i]==0)\n                        {\n                            determined_r=i;\n                            break;\n                        }\n                }\n\n            if (determined_r!=0)\n                {\n\n                    for ( int k=1; k<=2 ; k++)\n                        {\n\n                            determined_p_f=0;\n                            determined_p_e=0;\n                            int count = paths_node[src][des][k][2][14];\n\n                            zero_array();\n\n                            for (int i=1; i<=count; i++)\n                                {\n                                    finding_fs( k, i, des, src );\n                                }\n                            if ( ff_rr==0)\n                                {//ff\n                                    ////checking gap\n                                    determined_p_f=find_first_free_gap(required_fs);\n                                    if (determined_p_f!=0)\n                                        {   \n                                            determined_p_e=determined_p_f+required_fs-1;\n                                            if (determined_p_e != 1000)\n                                                {\n                                                    determined_p_e=determined_p_e+1;\n                                                }\n                                            determined_k=k;\n                                            break;\n                                        }\n\n\n                                }\n                            else if (ff_rr==1)\n                                {//rr\n                                    clear_rr_gap();\n                                    find_rr_gap(required_fs);\n                                    int index=rr_spectrum();\n                                    determined_p_f=ary_rr[index].first;\n                                    if (determined_p_f!=0)\n                                        {\n                                            determined_p_e=ary_rr[index].last;\n                                            determined_k=k;\n                                            break;\n                                        }\n\n                                }\n\n\n                        }\n\n                    if (determined_p_f!=0)\n                        {\n                            //add to ls , applying\n                         int count_link = paths_node[src][des][determined_k][2][14];\n\n                         for ( int i=1; i<=count_link ; i++)\n                             {\n                                int num_link_p=paths_node[src][des][determined_k][2][i];\n\n                                for ( int j=determined_p_f ; j<=determined_p_e; j++)\n                                    {\n                                        links_fs[num_link_p][j]=1;\n\n                                    }\n                             }\n\n                         reciever[des][determined_r]=1;\n                         transmitter[src][determined_t]=1;\n                         ls(determined_p_f,determined_p_e,determined_r,determined_t,determined_k,src,des,idpk);\n\n                            number_of_ack= number_of_ack +1 ;\n                            bw_ack= bw_ack + required_fs;\n                            op_intrpt_schedule_self(op_sim_time ()+ holding,idpk);\n                            op_pk_destroy(pkptr);\n                        }\n                    else\n                        {\n                            number_of_nack=number_of_nack+1;\n                            bw_nack= bw_nack + required_fs;\n                            op_pk_destroy(pkptr);\n                        }\n                }\n            else\n                {\n                    number_of_nack=number_of_nack+1;\n                    bw_nack= bw_nack + required_fs;\n                    op_pk_destroy(pkptr);\n                }\n        }\n    else\n        {\n            number_of_nack=number_of_nack+1;\n            bw_nack= bw_nack + required_fs;\n            op_pk_destroy(pkptr);\n        }\n```\n\n    ", "Answer": "\r\n\n  I have a graph with 14 nodes and 21 links. [...] for each source and destination, I must establish a working and a\n  protection path simultaneously in advance in case of a link failure\n  but they muse be link disjoint.(they cannot traverse any common link)\n\n\nNote well in the first place that the information you have presented in no way ensures that there will be even one path between any two particular nodes, much less two disjoint ones.  If your graph is structured in such a way that it is guaranteed to have two disjoint paths between each pair of nodes, however, then your best bet is probably to use your knowledge of that structure to find the wanted pairs of paths.  For example, if you know that the graph contains a loop that traverses all nodes, then you can obtain two disjoint paths between each node pair by traversing that loop in opposite directions from one to the other.\n\nOn the other hand, if you're trying to find such disjoint path pairs where they exist, and elsewhere to determine that no such pair exists, then you have some options.\n\nConceptually easiest would be to determine for each pair of nodes all non-looping paths between them, and then to look for two that have only the start and end nodes in common.  You could use either a depth-first or a breadth-first search for the path enumeration.  This is computationally challenging on general graphs because the number of paths scales exponentially, but with the relatively small and fairly sparse graph you describe, it would probably work.\n\nYou could refine that approach by testing each new path, as you discover it, against all the previously-discovered ones.  You may that way sometimes discover usable pairs without enumerating every path.  If you do this then a BFS-based approach will tend to find a usable pair more quickly than DFS-based one.  This will still enumerate all the paths between your nodes when there is no disjoint pair.\n\nI can imagine more elaborate approaches in which you search disjoint pairs together, instead of searching individual paths, but I'm inclined to think that these would tend to be inefficient on account of involving a lot of duplicate work.  That suggests a possible resolution via dynamic programming, but at this point I'm indulging fairly heavily in speculation.\n\nWhat you cannot reliably do is simply choose one path and and then look for another that traverses the remaining nodes.  It is entirely possible that there are suitable path pairs, but the first path you choose is not a member of such a pair.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Printing all paths in a directed graph using lists\r\n                \r\nI will start this off by saying that I am relatively new to python so forgive me if the answer is obvious. I made a class for a directed graph and I need to add a method to print all of the non-cyclical paths from a starting vertex to an ending vertex. I have tried a few times, but the way I am trying to do it has me a little bit confused.\n\nHere is my class:\n\n```\nimport string\n\nclass Graph(object):\n    def __init__(self):\n        self.vertexlist = []\n        self.edgelist = []\n        self.numedges = 0\n        self.numvertices = 0\n\n    def add_vertex(self, name):\n        check = False\n        for item in self.vertexlist:\n            if name == item:\n                check = True\n                break\n\n        if check is False:\n            self.vertexlist.append(name)\n            self.numvertices = self.numvertices + 1\n        else:\n            print \"A vertex with that name already exists.\"\n\n    def add_edge(self, start, end):\n        if start not in self.vertexlist:\n            self.vertexlist.append(start)\n            self.numvertices += 1\n\n        if end not in self.vertexlist:\n            self.vertexlist.append(end)\n            self.numvertices += 1\n\n        tempedge = [start, end]\n\n        self.edgelist.append(tempedge)\n        self.numedges += 1\n\n    def remove_vertex(self, name):\n        if name in slef.vertexlist:\n            self.vertexlist.remove(name)\n            self.numvertices = self.numvertices - 1\n        else:\n            pass\n\n    def remove_edge(self, start, end):\n        for item in self.edgelist:\n            if item[0] is start and item[1] is end:\n                self.edgelist.remove(item)\n                self.numedges = self.numedges - 1\n\n    def vertices(self):\n        return self.vertexlist\n\n    def print_edges(self):\n        for x in self.edgelist:\n            print x[0] + \" -> \" + x[1]\n\n    def is_connected(self, start, end):\n        for item in self.edgelist:\n            if item[0] is start and item[1] is end:\n                return True;\n\n        return False\n\n    def pathFinder(self, begin, fin, p = None): # print_paths helper function\n        if p is None:\n            p = []\n\n        p = p + [begin]\n\n        if begin == fin:\n            return [p]\n\n        pathing = []\n        for item in self.edgelist:\n            if item[0] not in p:\n                newpath = self.pathFinder(item[0], fin, p)\n\n                for i in newpath:\n                    pathing.append(i)\n\n        return pathing\n\n    def print_paths(self, start, end):\n        temp = self.pathFinder(start, end)\n\n        print temp\n```\n\n\nThe last two functions are the ones that I am having trouble with (```\nprint_paths```\n and ```\npathFinder```\n). The goal is to have ```\npathFinder```\n return a list of lists, where each inner list is a path sequence.\n\nFor example, if A -> B, A -> C, B -> D, C -> D\n\nthen there are two paths from A to D and pathFinder should return:\n```\n[ ['A','B','D'] , ['A','C','D'] ]```\n\n\nI have seen some other implementations/questions about a similar goal, but I haven't seen anything that uses lists as the underlying data structure like I am trying to. The other ways might be better, but I would like to continue the way I have it now if that is possible.\n\nEdit - adding code to test the class below:\n\n```\nfrom graph import Graph\n\ng = Graph()\ng.add_vertex('A')\ng.add_vertex('A')\ng.add_vertex('B')\ng.add_vertex('C')\n\nprint \"\\nVertices:\", g.vertices()\n\ng.add_edge('A', 'B')\ng.add_edge('B', 'C')\ng.add_edge('C', 'D')\ng.add_edge('C', 'B')\ng.add_edge('B', 'D')\ng.add_edge('D', 'A')\n\nprint\"\\nEdges:\"\ng.print_edges()\n\nprint \"\\nA->B?\", g.is_connected('A', 'B')\nprint \"B->A?\", g.is_connected('B', 'A')\nprint \"C->D?\", g.is_connected('C', 'D')\n\nprint \"\\nAll non-cyclical paths from A to D:\"\ng.print_paths('A', 'D')\n```\n\n\nCurrent Output:\n\n```\nA vertex with name 'A' already exists.\n\nVertices: ['A', 'B', 'C']\n\nEdges:\nA -> B\nB -> C\nC -> D\nC -> B\nB -> D\nD -> A\n\nA->B? True\nB->A? False\nC->D? True\n\nPaths from A to D:\n[['A', 'B', 'C', 'D'], ['A', 'B', 'C', 'D'], ['A', 'B', 'D'], ['A', 'C', \n'B', 'D'], ['A', 'C', 'B', 'D'], ['A', 'C', 'D'], ['A', 'C', 'B', 'D'], \n['A', 'C', 'B', 'D'], ['A', 'C', 'D'], ['A', 'B', 'C', 'D'], ['A', 'B', 'C', \n'D'], ['A', 'B', 'D'], ['A', 'D']]\n```\n\n\nIt gives 13 possible paths, but really only 2 exist\n    ", "Answer": "\r\n```\ngraph.py```\n\n\n```\nimport string\nimport copy\n\nclass Graph(object):\n    ...\n    def print_paths(self, start, end):\n    # Initialise a dict mapping nodes to whether they've been \n    # visited or not. Each path must maintain state about which \n    # nodes have been visited, and one path must not clash with \n    # another.\n        visited = {v : False for v in self.vertexlist} \n        temp = self.pathFinder(start, end, visited)\n        print temp\n\n    def pathFinder(self, begin, fin, visited, p=None):\n        # Mark this node as visited.\n        visited[begin] = True \n        if p is None:\n            p = []\n\n        p = p + [begin]\n        # Stopping condition - Success.\n        if begin == fin: \n            return [p]\n\n        pathlist = []\n        # Since you're using a list to store edges, \n        # this makes things a little messy.\n        #  We need to check for a couple of things.\n        for item in self.edgelist: \n            # First, make sure that we are following a valid path\n            # and second, make sure the end of this edge has not \n            # already been visited. If not, we're ready to jump in\n            if begin == item[0] and not visited[item[1]]: \n                # The next recursive call will take a \n                # fresh copy of visited and attempt to repeat \n                # the process until it has found the end.\n                newpath = self.pathFinder(item[1], fin, copy.copy(visited), p)     \n                pathlist.extend(newpath)\n\n        return pathlist # Stopping condition - Failure.\n```\n\n\nCase 1\n\n```\nA -> B\nA -> C\nB -> D\nC -> D\n```\n\n\n\n\n```\nAll non-cyclical paths from A to D:\n[['A', 'B', 'D'], ['A', 'C', 'D']]\n```\n\n\nCase 2\n\n```\nA -> B\nB -> C\nC -> D\nC -> B\nB -> D\nD -> A\n```\n\n\n\n\n```\nAll non-cyclical paths from A to D:\n[['A', 'B', 'C', 'D'], ['A', 'B', 'D']]\n```\n\n\nExplanation in comments.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all cyclic paths in a directed graph\r\n                \r\nThe title is self explanatory. Here's a solution that I found in the internet that can help do this. Here's the link\n\nI don't understand why not visiting a vertex having weight below the given threshold will solve the problem. \n\nAdditionally, I have no idea how to solve this using/not using this.\n    ", "Answer": "\r\nLet's restrict this to simple cycles - those which contain no subcycles. For each node in the graph, begin a depth-first search for that node. record each branch of the recursion tree which results in a match. While searching, never cross over nodes already traversed in the branch.\n\nConsider the complete directed graph on n vertices. There are n(n-1) arcs and n! simple cycles of length n. The algorithm above isn't much worse than this at all. Simply constructing a new copy of the answer would take nearly as much time as running the above algorithm to do it, in the worst case at least.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Smallest path in graph theory (social network analysis)\r\n                \r\nThis is the scenario:\nThere is an undirected graph with n nodes and e edges, all nodes are connected.\n\nThe question in the scenario:\nEvery node can be considered as a person in a social network that shares or reads a content. It means that if A is connected to B, C and D, if A shares a content with the network, it will reach directly BCD. It means that to reach all the nodes in the network, it's just necessary that they are adjacent to a node which shared the content.\n\nQ1: is there a way to find the best starting point to reach the entire network?\nQ2: is there a way to find a smallest path from that point?\n\nI've already looked at salesman problem and prim'algorithm.\n\nThanks!\n    ", "Answer": "\r\nThe wikipedia page on Centrality describes several different forms of centrality in a graph, and has links to algorithms for some of them.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Control Flow Graphs - find all linearly independent paths\r\n                \r\nI want to find all the possible linearly independent paths in a CFG.\nAs per my limited knowledge of algorithms, a CFG would essentially be a directed graph containing cycles.\nThe formula for cyclomatic complexity is simple.\nI was wondering if there is way to get all the linearly independent paths from the start to the end node (given by the cyclomatic complexity)\n\nThanks!\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Optimize Neo4j Cypher path finding with limited paths in an undirected graph\r\n                \r\nAs a follow-up from the question \"Neo4j Cypher path finding slow in undirected graph\". Michael Hunger and Wes Freeman kindly helped but I failed to adapt the techniques learned to path finding queries that should return the paths.\n\nThe issue:\n\nThe below query takes roughly 3s and returns 13 rows (the paths found) from a database. I find it slow and would like to have it execute faster but don't know how to optimize it. (This is an example of course but I find similar other queries slow too.)\n\n```\nSTART n=node:NodeIds('id:4000'), t=node:NodeIds('id:10778')   \nMATCH path = (n)-[:ASSOCIATIVY_CONNECTION*1..3]-(t)   \nRETURN nodes(path) AS Nodes\n```\n\n\nAnd the same with profile data:\n\n```\nneo4j-sh (0)$ profile START n=node:NodeIds('id:4000'), t=node:NodeIds('id:10778')    MATCH path = (n)-[:ASSOCIATIVY_CONNECTION*1..3]-(t)    RETURN nodes(path) AS Nodes;\n==> +-------------------------------------------------------------------------------------------+\n==> | Nodes                                                                                     |\n==> +-------------------------------------------------------------------------------------------+\n==> | [Node[3984]{Id:4000},Node[986]{Id:1001},Node[18536]{Id:18552},Node[10763]{Id:10778}]      |\n==> | [Node[3984]{Id:4000},Node[1085]{Id:1100},Node[9955]{Id:9970},Node[10763]{Id:10778}]       |\n==> | [Node[3984]{Id:4000},Node[133348]{Id:133364},Node[9955]{Id:9970},Node[10763]{Id:10778}]   |\n==> | [Node[3984]{Id:4000},Node[111409]{Id:111425},Node[18536]{Id:18552},Node[10763]{Id:10778}] |\n==> | [Node[3984]{Id:4000},Node[64464]{Id:64480},Node[18536]{Id:18552},Node[10763]{Id:10778}]   |\n==> | [Node[3984]{Id:4000},Node[64464]{Id:64480},Node[9955]{Id:9970},Node[10763]{Id:10778}]     |\n==> | [Node[3984]{Id:4000},Node[64464]{Id:64480},Node[10763]{Id:10778}]                         |\n==> | [Node[3984]{Id:4000},Node[64464]{Id:64480},Node[64455]{Id:64471},Node[10763]{Id:10778}]   |\n==> | [Node[3984]{Id:4000},Node[79152]{Id:79168},Node[18536]{Id:18552},Node[10763]{Id:10778}]   |\n==> | [Node[3984]{Id:4000},Node[69190]{Id:69206},Node[18536]{Id:18552},Node[10763]{Id:10778}]   |\n==> | [Node[3984]{Id:4000},Node[25893]{Id:25909},Node[18536]{Id:18552},Node[10763]{Id:10778}]   |\n==> | [Node[3984]{Id:4000},Node[31683]{Id:31699},Node[18536]{Id:18552},Node[10763]{Id:10778}]   |\n==> | [Node[3984]{Id:4000},Node[6965]{Id:6980},Node[18536]{Id:18552},Node[10763]{Id:10778}]     |\n==> +-------------------------------------------------------------------------------------------+\n==> 13 rows\n==> 2824 ms\n==> \n==> ColumnFilter(symKeys=[\"path\", \"n\", \"t\", \"  UNNAMED3\", \"Nodes\"], returnItemNames=[\"Nodes\"], _rows=13, _db_hits=0)\n==> Extract(symKeys=[\"n\", \"t\", \"  UNNAMED3\", \"path\"], exprKeys=[\"Nodes\"], _rows=13, _db_hits=0)\n==>   ExtractPath(name=\"path\", patterns=[\"  UNNAMED3=n-[:ASSOCIATIVY_CONNECTION*1..3]-t\"], _rows=13, _db_hits=0)\n==>     PatternMatch(g=\"(n)-['  UNNAMED3']-(t)\", _rows=13, _db_hits=0)\n==>       Nodes(name=\"t\", _rows=1, _db_hits=1)\n==>         Nodes(name=\"n\", _rows=1, _db_hits=1)\n==>           ParameterPipe(_rows=1, _db_hits=0) \n```\n\n\nThe setup:\n\nThe Neo4j graph database has 165k nodes and 266k relationships where all the relationships are undirected (bidirectional) and have the label \"ASSOCIATIVY_CONNECTION\". None of the nodes are connected to the root node. Apart from the nodes and relationships only one integer value is stored for each node (the graph database is not used to store the actual data, but just for the structure).\n\nThe memory configuration for this database is as following:\n\n```\nwrapper.java.initmemory=1024\nwrapper.java.maxmemory=1024\n\nneostore.nodestore.db.mapped_memory=225M\nneostore.relationshipstore.db.mapped_memory=250M\nneostore.propertystore.db.mapped_memory=290M\nneostore.propertystore.db.strings.mapped_memory=330M\nneostore.propertystore.db.arrays.mapped_memory=330M\n```\n\n\nThe dataset is a graph generated by following interconnections between Wikipedia articles and is downloadable from here.\n\nI run Neo4j 1.9.M05 community on a Windows 8 machine by starting from Neo4j.bat. I don't think hardware can be an issue as the query only causes a short 10% CPU spike. There are GBs of free RAM available.\n\nI'd be very thankful for pointers on how to make this query run faster.\n\nEdit: tried the same query in a slightly enhanced version of the same graph with 283k nodes and 538k relationships. It now takes 20 seconds!\n\nEdit 2, increasing memory limits:\nAs advised by Michael I upped the wrapper.java.initmemory and wrapper.java.maxmemory settings to 8192 (8GB). It indeed increased the memory footprint to 2,25GB of the java process running Neo4j and also it increased the performance of the query: now it's about 1s on warmed up queries (after the third run).\nI also upped the memory settings in the neo4j.properties config file to 2GB each but it doesn't have any noticeable effect.\nFor all this to work I needed the 64b Java runtime (the default one you can easily download for your browser is a 32b version) so I downloaded the manual installer for it. After it's installed Neo4j will automatically start with it instead of the 32b version.\n    ", "Answer": "\r\nAs you are running on windows please increase your heap sizes as MMIO direct memory is part of the java heap on Windows.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in a giant graph\r\n                \r\nNowadays I study on graphs that usually don't fit into any type of memory or storage devices. And my problem is that I need to find a shortest path between two particular vertices in such graphs.\n\nI aware of boost graph library for C++ and I'm a big fun of it. Usual concept to use boost's graph library (and others as well) is that\n\n\ncreate vertex list in the memory\ncreate edge connectivity list in the memory\ncall the graph algorithm that you desire\n\n\nThis approach works well for graphs which fit into RAM:\n\n```\ntypedef adjacency_list<\n    vecS,\n    vecS,\n    undirectedS,\n    no_property,\n    property<edge_weight_t, uint32_t> \n> TGraph;\n\nvoid FindShortestPath(const TGraph& g, const uint32_t from, const uint32_t to)\n{\n    vector<TGraph::edge_descriptor> path;\n    TGraph::vertex_descriptor v = vertex(to, g); // We want to start at the destination and work our way back to the source\n\n\n    vector<TGraph::vertex_descriptor> p(num_vertices(g));\n    vector<uint32_t> d(num_vertices(g));\n\n    dijkstra_shortest_paths(g, vertex(from, g),\n                            predecessor_map(make_iterator_property_map(p.begin(), get(vertex_index, g)))\n                            .distance_map(make_iterator_property_map(d.begin(), get(vertex_index, g))));\n\n    for(auto u = p[v]; u != v; v = u, u = p[v])\n    {\n        path.push_back(edge(u, v, g).first);\n    }\n\n    //// Write shortest path\n    cout << \"Distance: \" << d[to] << endl;\n    for(auto i = path.rbegin() + 1; i != path.rend(); ++i)\n    {\n        cout << source(*i, g) << \" \";\n    }\n\n    cout << endl;\n}\n```\n\n\nBut since my graph is huge, above approach doesn't suit my requirements. The graph that I study currently has 16! vertices and each vertices have same degree which is 64. And also, what I believe that maximum of shortest distances between any vertex pairs is less than 20.\n\nWell the good thing about the graph is that it's vertices and edges are mathematically perfectly defined. With that knowledge, It shouldn't be necessary to create whole graph in the memory apriori to run certain shortest path algorithms on it.\n\nMy idea is that there should be a way of doing that with boost library, whenever I need to provide edge connections of a specific vertex, I can provide or calculate it instantly by using this mathematical definition, only at the time of shortest path calculation when it is necessary and then once job finishes, release it.\n\nI'm stuck here and it is beyond my boost library or shortest path algorithm implementation knowledge. \n\n\nDo you think that above dynamic approach is possible with boost graph library? If yes, how? Please provide some examples or documentations.\nDo you think that if I implement shortest path algorithm with dynamic approach, is there a chance to solve shortest path in acceptable times comparing to create whole graph in memory and than running the algorithm?\nIf \"1\" is not possible but \"2\" is, then what do you suggest to go with?\n\n\nThanks.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Are there internal algorithms in neo4j for community detection?\r\n                \r\n```\nGephi```\n uses ```\nLouvain```\n algorithm for detection community detection in graphs. Are there built-in algorithms in ```\nneo4j```\n like ```\nGephi's Louvain```\n for community detection? As I have found in ```\nneo4j's```\n help docs, there are only shortest path algorithms.\n    ", "Answer": "\r\nNo it doesn't.\n\nHowever there's also Dijkstra and A* and the traversal framework provides facilities for writing such algorithms (something that at least the Dijkstra algo uses).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest Path in a weighed non directed graph\r\n                \r\n\n\nI need to find the longest path in the graph based on edge weights. For the graph on image it should be 4,5,3,2,1 (order doesn't matter) What is the best algorithm to solve this? What if you know that in your graph, every node has a reference(edge) to any other node in the graph. Should the algorithm be changed?\n    ", "Answer": "\r\n\nThe longest path problem is NP-complete which means that it cannot be solved in polynomial time.\nFor directed acyclic graphs it has a linear solution, but since the question is about undirected graphs, that won't work.\nA \"valid\" solution can be to simply brute-force the graph by traversing in a depth-first manner multiple times in order to generate all possible paths from A to B. When you have generated all paths, find the one with the maximum distance.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding the hamiltonian path in a directed cyclic graph\r\n                \r\ni want to know if there is an algorithm to find the longest cyclic path in a directed weighted graph (i think this i a problem of finding the largest Hamiltonian sub-graph).\n\nI need to start from one vertex and return to the same vertex, whit the most possible nodes traversed.\n\nThanks\n    ", "Answer": "\r\nThis problem is a special case of the optimal euler circuit problem where all edge weights are 1; the original problem is NP-complete. Moreover, this problem can be used to solve the Hamiltonian Graph problem (a Hamiltonian cycle exists if and only if the optimal circuit traverses all nodes), so it remains NP-complete even with the special case restriction. Any exact solution will (unless P = NP) require exponential time. You may find this paper helpful; it describes a polynomial-time approximation algorithm for this problem, as well as a polynomial-time algorithm for cases where the graph has at most degree 4:\n\n\n  Qiao, Yu. \"Optimal Euler Circuit of Maximum Contiguous Cost.\" IEICE Trans. Fundamentals E90-A, no. 1 (2007): 274-280.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find the best path in graph with weighted nodes and vertices\r\n                \r\nLet's say I have this graph\n\n\n\n\nalways a full graph\none start node - also the finish node\nweighted nodes and vertices\n\n\nI want to find a path short as possible but with the best score (sum of points of nodes) - in other words a path that can't be longer then some defined constant but give me the best amount of points. And I want to start and stop in the same node and don't want to go over already visited nodes.\n\nAre there any algorithms which could help me with this problem or do you have any ideas how to solve it?\n\nOh, and it's not a homework, I just want to create a special path finder.\n\nEDIT\n\nSo far I've been able to construct a working algorithm which can find some path in a few seconds. But I don't get the amount of points I'd like to - I get only about 85% of the desired score. And if I change the algoritm's parameters then time will be in hours and more...\n    ", "Answer": "\r\nI don't think this is solvable in better than brute force time.  You could calculate all paths up to a certain constraint length.  However, for an arbitrarily large graph that would be extremely slow.  If you're looking for a solid guess, I'd start with a greedy algorithm that picks the step with the highest Points per Length value, until the limit is reached.  You can then add things such as reversing in the case of premature filling (say, if you've gone 5, but your limit is 6, and your current node has no paths of length one connected) to find out how that works.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in ordered graph pseudocode\r\n                \r\nI try to create an algorithm to find the longest path in an ordered graph.\nThe properties of the ordered graph are:\n\n\nEach edge goes from a node with lower index to a node with a higher index. That is, every directed edge has the form (v_i, v_j) with i < j.\nEach node except v_n has at least one edge leaving it. That is, for every node v_i, there is at least one edge of the form (v_i, v_j).\n\n\nMy first attempt is the following:\n\n```\nset w = v1 and L = 0\nWhile there is edge that leaves from w\n    Choose the edge (w, vj) with j as small as possible\n    set w = vj and L = L + 1\nreturn L\n```\n\n\nI cant understand why this algorithm is wrong for some cases. Can you give me an example?\n    ", "Answer": "\r\nMy intuition tells me that just choosing the smallest ```\nj```\n doesn't mean that somewhere else down the line the ```\nj```\n will be continue to be the smallest.\n\nImagine you have a graph ```\n1-> 3```\n and ```\n1 -> 5```\n, but ```\n3 -> 9```\n and ```\n5 -> 7 -> 9```\n, where 9 is the last node. Your algorithm will go ```\n1 -> 3 -> 9```\n which is shorter than ```\n1 -> 5 -> 7 -> 9```\n.\n\nIn fact, I don't think you can really just \"pick\" a branch and continue to follow it to the end and be correct in any case: you must check the other branches.\n\nRecursive Approach\n\nHere is an approach that uses a simple recursive algorithm where at each branch you calculate the length of the path and then at nodes where there are multiple branches you just return the longest.\n\nSimple pseudocode example (in the style of Python)\n\n```\nclass node:\n    def longest_path(self):\n        if len(self.children) == 0: # No children in this node\n            return 1\n        child_lengths = []\n        for child in self.children:\n            child_lengths.append(child.longest_path())\n        return max(child_lengths) + 1\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Graph algorithm involving chess: possible paths in k moves\r\n                \r\nI'm trying to solve an algorithm problem involving chess.\n\nSuppose I have a king in A8 and want to move it to H1 (only with allowed moves).\nHow could I find out how many possibilities (paths) there is making exactly any given k moves?\n(e.g. How many paths/possibilities there is if I want to move the king from A8 to H1 with 15 moves?)\n\nOne trivial solution is to see it as a graph problem and use any standard\npath finding algorithm counting each move as having cost 1. So, let's say I want to move my king from A8 to H1 in 10 moves. I would simply search all paths which sum up to 10.\n\nMy question is, if there are other more clever and efficient ways of doing this?\nI was also wondering, if there could be something more \"mathematical\" and straightforward to find this number and not so \"algorithmic\" and \"brute-force-like\"?\n    ", "Answer": "\r\nThis is a straight-forward O(N^3) dynamic programming problem.\n\nSimply assign a 3D array as follows:\n\nLet Z[x][y][k] be the number of moves of k steps to reach the destination from position (x,y) on board.\n\nThe base cases are:\n\n```\nforeach x in 0 to 7,\n   foreach y in 0 to 7,\n       Z[x][y][0] = 0 // forall x,y: 0 ways to reach H1 from\n                      // anywhere else with 0 steps\n\nZ[7][7][0] = 1 // 1 way to reach H1 from H1 with 0 steps\n```\n\n\nThe recursive case is:\n\n```\nforeach k in 1 to K,\n   foreach x in 0 to 7,\n      foreach y in 0 to 7,\n          Z[x][y][k+1] = Z[x-1][y][k]\n              + Z[x+1][y][k]\n              + Z[x][y-1][k]\n              + Z[x][y+1][k]\n              + ...; // only include positions in\n                     // the summation that are on the board\n                     // and that a king can make\n```\n\n\nYour answer is then:\n\n```\nreturn Z[0][0][K]; // number of ways to reach H1(7,7) from A8(0,0) with K moves\n```\n\n\n(There is a faster way to do this in O(n^2) by decomposing the moves into two sets of horizontal and vertical moves and then combining these and multiplying by the number of interleavings.)\n\nSee this related question and answer: No of ways to walk M steps in a grid\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Graph algorithm involving chess: possible paths in k moves\r\n                \r\nI'm trying to solve an algorithm problem involving chess.\n\nSuppose I have a king in A8 and want to move it to H1 (only with allowed moves).\nHow could I find out how many possibilities (paths) there is making exactly any given k moves?\n(e.g. How many paths/possibilities there is if I want to move the king from A8 to H1 with 15 moves?)\n\nOne trivial solution is to see it as a graph problem and use any standard\npath finding algorithm counting each move as having cost 1. So, let's say I want to move my king from A8 to H1 in 10 moves. I would simply search all paths which sum up to 10.\n\nMy question is, if there are other more clever and efficient ways of doing this?\nI was also wondering, if there could be something more \"mathematical\" and straightforward to find this number and not so \"algorithmic\" and \"brute-force-like\"?\n    ", "Answer": "\r\nThis is a straight-forward O(N^3) dynamic programming problem.\n\nSimply assign a 3D array as follows:\n\nLet Z[x][y][k] be the number of moves of k steps to reach the destination from position (x,y) on board.\n\nThe base cases are:\n\n```\nforeach x in 0 to 7,\n   foreach y in 0 to 7,\n       Z[x][y][0] = 0 // forall x,y: 0 ways to reach H1 from\n                      // anywhere else with 0 steps\n\nZ[7][7][0] = 1 // 1 way to reach H1 from H1 with 0 steps\n```\n\n\nThe recursive case is:\n\n```\nforeach k in 1 to K,\n   foreach x in 0 to 7,\n      foreach y in 0 to 7,\n          Z[x][y][k+1] = Z[x-1][y][k]\n              + Z[x+1][y][k]\n              + Z[x][y-1][k]\n              + Z[x][y+1][k]\n              + ...; // only include positions in\n                     // the summation that are on the board\n                     // and that a king can make\n```\n\n\nYour answer is then:\n\n```\nreturn Z[0][0][K]; // number of ways to reach H1(7,7) from A8(0,0) with K moves\n```\n\n\n(There is a faster way to do this in O(n^2) by decomposing the moves into two sets of horizontal and vertical moves and then combining these and multiplying by the number of interleavings.)\n\nSee this related question and answer: No of ways to walk M steps in a grid\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "number of shortest paths between 2 vertex of a graph\r\n                \r\n1) Anyone has an idea to get the number of shortest paths in an undirected unweighted graph?\nI wanna fill a 2 dimensional matrix which has the number of shortest paths for any i,j vertex,\n2) another question is how to get number of shortest paths between two vertex i,j in a way that the path must pass a certain vertex.\nThanks in advance.\n    ", "Answer": "\r\nLet admat be the adjacency matrix for your graph.  Then\n\nadmat gives the length 1 paths between vertices;\n\nadmat^2 gives the length 2 paths between vertices;\n\nadmat^3 gives the length 3 paths between vertices;\n\nspot the pattern yet ?\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in small graph with small degree\r\n                \r\nthis is a problem I've got from my class (I assure you it's not homework). I'm still pondering about it until now. You will receive a graph with at most 25 nodes and 25 edges. Additionally, each node will have degree of at most 3. The task is to find the longest path in this graph. However, you won't only receive 1 graph, but 15,000 graphs, and you'll need to find the longest path in all of them in 1 second. Could anyone please give me a solution (or better yet, just a hint) to this problem? Thank you very much!\n\nInfo:- Nodes can be revisited, the only constraints are the edges.- The graphs are given by the edges. So the first line states how many nodes and edges there are, and the lines after that represent the edges, each edge by a pair of integers.- The edges are unweighted.- The only answer required is the length of the path, not the path itself.- This might be important: the graph isn't necessarily connected.\n    ", "Answer": "\r\nAfter I saw that \"nodes can be revisited\", I realised that this is in some ways a trick question.  To satisfy those seemingly unbelievable time constraints, what you actually need here is not an algorithm for constructing such a path (usually called a trail, BTW, if vertices can be reused), but rather, for each connected component of the graph, a way of quickly detecting whether all or nearly all edges in that component can be included in a single trail.\n\nSo here is my hint: Did you know that there are seven bridges in Königsberg?  ;-)\n\nThat might seem cryptic, but I think some quick searching around will point you in the right direction, and you will soon find a way to quickly detect whether all edges in a component can form part of the same trail.  (You'll need to do some more thinking to figure out how many edges can be included when the answer to the above question is \"no\".)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "2 Shortest Paths in Weighted Directed Graph without Intersection\r\n                \r\nI will try to make clear analogy:\n\nThere is a city with N destinations. It is represented by weighted and directed graph where weights are distances as minutes. \n\nThere are 2 people which don't want to be in same destination at same time. They are located in different destinations. They are going to go to another destinations using shortest paths without being in same destination at all. They will stay M minutes in each visited destination.\n\nHow to find shortest path while keeping them distant?\n\nNOTE: I have looked shortest path algorithm, traveling salesman algorithm and thier variations. But I can't figure out how to solve it effectively. Finding all paths and comparing intersections doesn't look cost efficient. \n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in a graph\r\n                \r\nGiven a undirected graph with vertices form 0 to n-1, write a function that will find the longest path (by number of edges) which vertices make an increasing sequence.\n\nWhat kind of approach would you recommend for solving this puzzle? \n    ", "Answer": "\r\nYou can transform the original graph into a Directed Acyclic Graph by replacing each of the (undirected) edges by a directed edge going towards the node with bigger number.\n\nThen you end up with this: https://www.geeksforgeeks.org/find-longest-path-directed-acyclic-graph/\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Python igraph: get all possible paths in a directed graph\r\n                \r\nI am using igraph (Python) and would like to get all possible paths between two nodes in a directed graph. I am aware of the function ```\nget_all_shortest_paths```\n, which is for shortest paths, but could not find a general one.\n\nUpdate:\n\nMy main goal is to get all nodes in these paths, so that I can then get a subgraph of these nodes.\n    ", "Answer": "\r\nSince you mentioned in your question that your ultimate goal is to get only the nodes that are in these paths and not the paths themselves, I think you don't even have to calculate the paths.\n\nThe ```\nGraph```\n object in igraph has a method called ```\nsubcomponent```\n. By default, it gives you all the nodes that are in the same (weakly connected) component as a given input node. However, it also has a ```\nmode```\n argument. When you set ```\nmode```\n to ```\n\"out\"```\n, it will give you all the nodes that are reachable from a certain node. When you set ```\nmode```\n to ```\n\"in\"```\n, it will give you all the nodes from where you can reach a certain node. So, you'll probably need the intersection of the set of reachable nodes from your source vertex and the set of nodes that can reach your target vertex:\n\n```\ns=set(graph.subcomponent(source, mode=\"out\"))\nt=set(graph.subcomponent(target, mode=\"in\"))\ns.intersection(t)\n```\n\n\nThis is probably way faster than calculating all the paths anyway.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in a directed graph with incorporating global path weight\r\n                \r\nConsider a directed edge-weighted graph G = (V,E), with edge-weights in modeling the local relationship between two nodes. \n\nI want to find a shortest path in that graph with additional global constraints on the paths, for example formulated in a global path weight. for example a node in path needs to be evaluated with respect to the complete path's history.\n\nIs there an (efficient) algorithm for finding such a path, at best the globally optimal one?\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "find total distinct paths in a graph with given constraints\r\n                \r\nYou are given a graph with k+1 nodes with one of the node marked as origin and a number N which is the required path length.\n\nAssume all the nodes at unit distance from each other.   \n\nFind the number of different distinct paths possible when you have to start from origin and return to origin at the end of the journey.\n\nyou may visit any of the k+1 nodes as many times as you wish satisfying the condition that ending must happen at origin. \n\nwrite an algorithm for the problem .with k and N as 2 inputs.\n    ", "Answer": "\r\ngot it simplified to a series problem. \n\nassume M = 4 and K = 2. { M is the total path length }   \n\nso we can have adjacency matrix as \n\n\n\ntotal number of paths of length 2 starting and ending from A[0][0] will be the top left element of the square of this matrix. which is \n\n\n\nso by raising it to power N we will get the answer . by some trying this is the formula I am getting\n\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Can I use relative path in Open Graph? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Open graph can resolve relative url?\r\n                            \r\n                                (3 answers)\r\n                            \r\n                    \r\n                Closed 12 days ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm trying to set a relative path to ```\nog:image```\n metadata like this:\n\n```\n<meta name=\"og:image\" content=\"/images/view.png\">\n```\n\n\nOn Sharing Debugger I have the following warning:\n\n\n  Inferred Property The 'og:image' property should be explicitly\n  provided, even if a value can be inferred from other tags.\n\n\nThere is any way to use a relative path in Open Graph?\n    ", "Answer": "\r\nNo, og:image won't work with a  relative path.\nMore info here:\nhttps://stackoverflow.com/a/9858694/7068514\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Unique paths undirected cyclic graph\r\n                \r\nI am working on a problem in graphs and trying to figure out on finding unique paths\nlet me give an example, let us consider a graph with 4 nodes and 6 edges with edges as follows -\n1 2 \n2 3\n3 4\n4 1\n1 3\n2 4\nthe unique cyclic paths of length 5 will be -\n\n1 -> 2 -> 3 -> 4 -> 1\n\n1 -> 3 -> 2 -> 4 -> 1\n\n1 -> 2 -> 4 -> 3 -> 1\nTwo paths are considered equal if the set of edges of the path are equal. consider the two paths 1 -> 2 -> 3 -> 4 -> 1 and 1 -> 3 -> 2 -> 4 -> 1 The first path is just the set = [(1,2), (2,3), (3,4), (4,1)], while the second is = [(1,3), (3,2), (2,4), (4,1)]\nClearly, the two sets are different, and hence so are the paths. The ordering of the edges are irrelevant as you're only comparing for the presence of the common edges between any two sets (paths).\n\n\nOnce I get the cyclic paths, how do i check if the paths have the same set of nodes in the path? i.e , 1 -> 2 -> 3 -> 4 -> 1  and 1 -> 4 -> 3 -> 2 -> 1 have the same sets, i.e [(1,2), (2,3), (3,4), (4,1)] in a different order.I thought of implementing a map of pair of sets and checking for duplicates.. still looking for better options.\nAny help is appreciated on how to proceed?\n    ", "Answer": "\r\nHave you considered using Python Patterns - Implementing Graphs. Its an excellent resource. I used it to solve for a programming contest question on unique paths in a graph from vertex x to y.enter link description here\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Python: all shortest paths in disconnected components of a graph\r\n                \r\nI am computing all the possible shortest paths between any two nodes in a regular network. If the network is connected (e.g., largest component = entire network), I have no problems.\n\nThe problem arises when I have disconnected components: given that there is no path between node ```\nn```\n and node ```\nj```\n, a ```\nNetworkXNoPath```\n error is raised.\n\nMy problem: I want to skip all pairs of nodes that are not connected. I know I need an ```\nif```\n to check for the presence of the error being raised, but I don't know how to add it to my code.\n\nMy code for computing all the possible shortest paths between any two nodes in the graph:\n\n```\n    import networkx as nx\n    counts=OrderedDict()\n    for n in F.nodes(): counts[n]=0\n    for n in F.nodes():\n        for j in F.nodes():\n            if (n!=j):\n                gener=nx.all_shortest_paths(F,source=n,target=j)\n                for p in gener:\n                    for v in p: counts[v]+=1\n```\n\n\nTo recap: I can use ```\nnx.bidirectional_dijkstra(F, n, j)```\n to check for the existence of an edge between node ```\nn```\n and node ```\nj```\n, and it raises the ```\nNetworkXNoPath```\nerror if such edge is missing, but how can I check for this error so to skip a pair of non-connected nodes?\n    ", "Answer": "\r\nJust do the calculations for each connected component.  The test to see if there isn't a path between two nodes can be expensive.\n\n```\nconnected_components = nx.connected_component_subgraphs(G)\nfor component in connected_components:\n    #your code here.                            \n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Graph longest path\r\n                \r\nHow can I find the longest path in a graph? I thought I can use depth first search but I couldn't find any easier implementation for it ?\n    ", "Answer": "\r\nAs brainjam pointed out in the comments this is NP complete. it is only polynomial if the graph is acyclic. if its a DAG its even linear. again see the wikipage for more info.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Is there an open source implementation of shortest path algorithm with distance labeling a la Gavoille et al.?\r\n                \r\nIf you are allowed to precompute linear in ```\n|V|```\n amount of data on graph then there are a family of algorithms which have sublinear query times for shortest paths in a graph.\n\n\nGavoille et al. Distance labeling in graphs.\nCohen et al. Reachability and distance queries via 2-hop labels\nAbraham, Goldberg et al. Hierarchical Hub Labellings for Shortest Paths\n\n\nSome of them are used in Bing Maps for extremely fast shortest routes calculations. \n\nThe basic idea is to precompute for each vertex forward labels ```\nL_f(v)```\n and backward labels ```\nL_b(v)```\n which poses a cover property. Each label is a pair of a vertex and the distance to it, e.g. ```\nL_f(v) = { (u, dist(v, u)) }```\n and ```\nL_r(v) = { (u, dist(u, v)) }```\n. And the cover property asserts that for any vertices s and t ```\nL_f(s)```\n 'Union' ```\nL_r(t)```\n contains at least one vertex on the shortest path from s to t.\n\nIs there an open source implementation of one of those algorithms (C++, C#, F#, D, Go, Java)?\n    ", "Answer": "\r\nI have not found any code that implements those algorithms but you could look at the Karlsruhe homepage where you can find code for Contraction Hierarchies, which form the basis of the (original) Hub Labeling. You could use that to create your own implementation of HL but you should know they filed a patent for it.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find minimum weighted path in a vector of tuples representing a graph\r\n                \r\nI am still new to graphs and am building a weighted directed graph for a school project. I was able to complete all the functions except the one that find the minimum weighted path from a node to another. I am able to find a path, but don't know how I would store all the paths then get the minimum weighted one. \nMy graph is represented by a vector .\n\nI have created a helper function that gives me a path from the source to the destination and a function that finds the weight of the path. They both work but I can't get the one that find the path to find all the paths instead of the first one it finds.\n\n```\nint WeightedDigraph::Myhelp(int to) const{\n    for (mytup::const_iterator k = adjList.begin(); k != adjList.end(); ++k) {\n        if(get<1>(*k) == to){ //destination\n                return get<0>(*k); //source\n        }\n    }\n    return 10000;\n}\n\nlist<int> WeightedDigraph::FindMinimumWeightedPath(int from, int to) const {\n    list<int> minpath;\n    minpath.push_front(to);\n    int src = Myhelp(to);\n    while(src != from){\n        minpath.push_front(src);\n            src = Myhelp(src);\n    }\n    return minpath;\n}\n```\n\n\nThis code returns a list for \"a\" path from \"from\" to \"to\". Instead, I want it to return the one with the least weight. I have to function getPathWeight(const list& path ) already setup to find the weight of each path and compare them but how can I get all paths in one place?\n\nUpdate for minimum, working example with includes:\n\nMain.cpp\n\n```\n    #include \"WeightedDigraph.h\"\n#include <iostream>\n#include <string>\n#include <list>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n\n    if(argc != 4) {\n        cerr << \"Incorrect number of command line arguments.\" << endl;\n        cerr << \"Usage: \" << argv[0] << \" <filename> <start vertex> <dest vertex>\" << endl;\n        exit(EXIT_FAILURE);\n    }\n\n    WeightedDigraph graph(argv[1]);\n\n    cout << \"The graph has \" << graph.GetOrder() << \" vertices and \" << graph.GetSize() << \" arcs\" << endl;\n\n    int source = atoi(argv[2]);\n    int dest = atoi(argv[3]);\n\n    if (graph.DoesPathExist(source, dest)) {\n        list<int> path = graph.FindMinimumWeightedPath(source, dest);\n        //then the path will be used for other functions\n    return 0;\n}\n```\n\n\nWeightedDiagraph.cpp:\n\n```\n#include \"WeightedDigraph.h\"\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <limits>\n#include<list>\n\nusing namespace std;\n\n\nvoid WeightedDigraph::InsertArc(int from, int to, double weight) {\n    tuple<int, int, double> newtup (from, to, weight); \n    adjList.push_back(newtup);\n}\n\ndouble WeightedDigraph::GetPathWeight(const list<int> & path) const {\n    //working\n}\n\n//other functions that are not needed for my question\n```\n\n\nWeightedDiagraph.h:\n\n```\n#ifndef WeightedDigraph_H\n#define WeightedDigraph_H\n\n#include<list>\n#include<string>\n#include<vector>\n#include<tuple>\n\nusing namespace std;\n\ntypedef vector<tuple<int,int,double>> mytup;\n\nclass WeightedDigraph {\npublic:\n    mytup adjList;\n    //all methods\n\nprivate:\n    int numVertices;\n    int numArcs;\n\n    int from;\n    int to;\n    double weight;\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "issus in code to find the total number of distinct nodes visited, considering all possible paths in undirected patt\r\n                \r\nHi i am facing a problem -\n\nGiven a undirected graph, source and destination, write the code to find the total number of distinct nodes visited, considering all possible paths.\n\nand i have a recursive solution but i am not sure about its CORRECTNESS .\n\n```\nHashSet<String> mConnectedNodes;\nStack<String> stack;\n\npublic void findNodesOnAllConnectingPaths(Node startNode, Node endNode) {\n    stack.push(startNode.getValue());\n\n    // Check for the base case = finding destination node on path\n    if (startNode.getValue() == endNode.getValue()) {\n        Enumeration<String> currentElements = stack.elements();\n        while(currentElements.hasMoreElements()) {\n            mConnectedNodes.add(currentElements.nextElement());\n        }\n        stack.pop();\n        return;\n    }\n\n    //Recurse if any connected nodes aren't on the current path\n    ArrayList<Node> nodes = startNode.getConnectedNodes();\n    for (Node node : nodes) {\n        if (!stack.contains(node.getValue())) {\n            findNodesOnAllConnectingPaths(node, endNode);\n        }\n    }\n    stack.pop();\n    return;\n}\n```\n\n\nplease suggest me test cases where it can fail and a good source for the algorithm for  ALL SIMPLE PATHS IN UNDIRECTED GRAPHS.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Calculate shortest path in graph with weighted Vertices\r\n                \r\nI am currently working on a kattis problem: Treasure Hunt, Link. The goal is to find the path which will cost the least amount of days to reach the treasure.  \n\nI currently use Dijkstra's algorithm with weighted vertexes to calculate the shortest route to the treasure. I have defined a class 'Node' in which I define it's weight and the previous Node if assigned. I use a heapq and needed to override the lt method in my Node class. \n\nWhen the shortest route is defined I try to calculate the number of days that it will take to complete this shortest route.\n\nI know it is not the fines code, I am sorry.\n\nDefining neighbor nodes and the pathfinding\n\n```\n   def createNode(row):\n        rl = list()\n        for x in row:\n            rl.append(Node(x))\n        return rl\n\n    rows, columns, stamina = map(int, input().split(' '))\n    treasure_map = list()\n    for row in range(rows):\n        treasure_map.append(list(input()))\n    treasure_map = list(map(createNode, treasure_map))\n    for x in range(len(treasure_map)):\n        for y in range(len(treasure_map[x])):\n            tile = treasure_map[x][y]\n            # add tile to south link\n            if x - 1 >= 0 and treasure_map[x - 1][y] is not None:\n                tile.add_neighbour(treasure_map[x - 1][y])\n            if y + 1 < len(treasure_map[x]) and treasure_map[x][y + 1] is not None:\n                tile.add_neighbour(treasure_map[x][y + 1])\n            if x+1 < len(treasure_map) and treasure_map[x + 1][y] is not None:\n                tile.add_neighbour(treasure_map[x + 1][y])\n            if y - 1 >= 0 and treasure_map[x][y - 1] is not None:\n                tile.add_neighbour(treasure_map[x][y - 1])\n\n    visited = list()\n    nodes = list()\n    for x in treasure_map:\n        for y in x:\n            if y.name is not '#':\n                nodes.append(y)\n    heapq.heapify(nodes)\n    endpoint = None\n\n    if len(nodes) < 2:\n        print(-1)\n\n    # Search route with minimum load\n    while nodes:\n        curr = heapq.heappop(nodes)\n        if curr.name is 'G':\n            endpoint = curr\n            break\n        for node in curr.get_neighbours():\n            if node not in visited and not node.load > stamina:\n                if curr.weight + curr.load < node.weight:\n                    node.add_previous(curr)\n        visited.append(curr)\n        heapq.heapify(nodes)\n\n```\n\n\nThe code of calculating the days it will take to get from the start to end: (once again I know it can be better)\n\n```\n   if endpoint is not None:\n        nexNode = endpoint.previous\n        found = False\n        stamina_to_use = list()\n        while nexNode:\n            if nexNode.name == \"S\":\n                # Maybe count the day here\n                found = True\n            stamina_to_use.append(nexNode.load)\n            nexNode = nexNode.previous\n        days = 1\n        curr = stamina\n        counter = 0\n        stamina_to_use.reverse()\n        # Count the number of days needed for finishing\n        while stamina_to_use:\n            tocheck = stamina_to_use.pop()\n            # print(\"Current days: {}, current stamina: {},stamina to withdraw {}\".format(\n            #    days, curr, tocheck))\n            if curr > stamina:\n                print(-1)\n                break\n            if (curr - tocheck) < 0:\n                days += 1\n                curr = stamina\n            curr -= tocheck\n        if found:\n            print(days)\n        else:\n            print(-1)\n\n    else:\n        print(-1)\n\n```\n\n\nThe results are actually as I expected, I get the shortest path and get the right number of days according to my own test cases and also to the ones on kattis. But for some reason when I submit the project to kattis the first 8 or so test cases pass and then I suddenly get: \"Wrong answer\", I don't know where the mistake in my thinking or code is. Is my approach the right one or should I use a different one. Or is there just a simple mistake made in counting the days?\n\nThanks in advance\n    ", "Answer": "\r\nHere is a solution that almost works, there is a small check missing.\n\nThis way you need to figure out what it does :)\n\n```\nBIG_NUMBER = 9999\nSTAMINA_COST = {'F': 2, 'M': 3}\n\ndef maybe_update(field1, field2, maze, time_taken, n, m, k, updated_fields):\n    i1, j1 = field1\n    i2, j2 = field2\n    if not (0 <= i2 < n and 0 <= j2 < m):\n        # Out of bounds\n        return\n    field = maze[i2][j2]\n    if field == '#':\n        # Can not walk on river\n        return\n    days_taken, stamina_taken = time_taken[i1][j1]\n    stamina_to_move = STAMINA_COST.get(field, 1)\n    stamina_taken += stamina_to_move\n    if k < stamina_taken:\n        days_taken += 1\n        stamina_taken = stamina_to_move\n    new_time_taken = (days_taken, stamina_taken)\n    if new_time_taken < time_taken[i2][j2]:\n        time_taken[i2][j2] = new_time_taken\n        updated_fields.add((i2, j2))\n\ndef main():\n    # Read input\n    n, m, k = map(int, input().split())\n    maze = []\n    for i in range(n):\n        line = input()\n        maze.append(line)\n\n    # Create map of how long it takes to get somewhere\n    # Each field has (days_spent, stamina_spent)\n    time_taken = []\n    for i in range(n):\n        time_taken.append([(BIG_NUMBER, BIG_NUMBER) for j in range(m)])\n\n    # Look for the start and mark it as (1, 0), also look for the gold\n    updated_fields = set()\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == 'S':\n                time_taken[i][j] = (1, 0)\n                updated_fields.add((i, j))\n            elif maze[i][j] == 'G':\n                gold_at = (i, j)\n\n    # BFS to propagate time_taken\n    while updated_fields:\n        i, j = updated_fields.pop()\n        maybe_update((i, j), (i + 1, j), maze, time_taken, n, m, k, updated_fields)\n        maybe_update((i, j), (i - 1, j), maze, time_taken, n, m, k, updated_fields)\n        maybe_update((i, j), (i, j + 1), maze, time_taken, n, m, k, updated_fields)\n        maybe_update((i, j), (i, j - 1), maze, time_taken, n, m, k, updated_fields)\n\n    # Print days taken to get to the gold\n    i, j = gold_at\n    days_taken = time_taken[i][j][0]\n    print(-1 if days_taken == BIG_NUMBER else days_taken)\n\nif __name__ == '__main__':\n    main()\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Most efficient way to index and query paths in a graph\r\n                \r\nI have a table representing a graph: Edges(from, to).\n\nI'd like to query this table with \"path queries\", retrieving only the source and destination of the path. \n\nFor example, assume my table consists of the following rows:\n\n```\n+------+----+\n| from | to |\n+------+----+\n| a    | b  |\n| b    | c  |\n| c    | d  |\n| f    | g  |\n| b    | f  |\n| c    | a  |\n+------+----+ \n```\n\n\nAssume I execute the following (pseudo-)query:\n\n```\nSELECT ?v1, ?v2 WHERE ?v1 to ?t1, ?t1 to ?t2, ?t2 to ?v2;\n```\n\n\nThis means I want all the pairs of source and destination that exist in all paths consisting of 4 nodes. Executing this query should return the following results:\n\n```\n+-----+-----+\n| ?v1 | ?v2 |\n+-----+-----+\n| a   | a   |\n| a   | g   |\n| a   | d   |\n+-----+-----+\n```\n\n\nOf course, paths consisting of a different number of nodes might be needed as well, the number 4 isn't hardcoded :-)\n\nMy questions are:\n\n\nWhat's the best way to build such an SQL query (note that I'm using SQLite, so recursive queries can't be used).\nI currently have one index for the from column and one for the to column. Is this optimal? Should I create an index for the \"from, to pair as well? Instead?\n\n\nAssumptions\n\n\nThere are no self-edges (E.G \"a - a\").\nThere are no two identical rows.\n\n\nThanks in advance!\n    ", "Answer": "\r\nad 1.)\nunless you know in advance that your paths will always be of a given length (or a small set of given lengths), you cannot express your query in pure sql. however, you may choose to incrementally maintain the transitive closure of your graph, in particular if\n\n\nchanges to your graph are infrequent \nand/or are mostly edge insertions (instead of deletions)\nor mostly occur as bulk changes at times that allow for some preprocessing.\n\n\nthe technique is outlined in a paper by dong et al., doi://10.1.1.103.3314; don't be daunted by the theory and the math, they also provide sql code ready-to-use and their basic ideas are straightforward.\n\nad 2.)\n\nif maintaining a transitive closure table is an option for you it wpould lend to one index on the pair of columns representing start and end vertices of paths.\n\nif it isn't you might be able exploit the structure of your graph: for average fan-outs that are high (small) in comparison to fan-ins you should be better of with an index on the 'to' ('from') column.\n\nif you cannot make an assumption on fan-out/fan-in ratios you're probably best off with an index on each column.\n\nhope it helps,\n\nbest regards, carsten\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "find all possible path in graph using function in js\r\n                \r\nI am creating a graph, and in that graph I want to find all possible paths. For example, in that graph, if I want to go from 1 to 3, it will take two ways. 1->2->3 or 1->4->3, so I have created a generated function for finding all possible paths. Is there any good approach for finding all possible paths for a graph? code is given below\n```\nlet graph = {\n    1: [2, 4],\n    2: [1, 3],\n    3: [2, 4],\n    4: [1, 4]\n  };\nfunction findAllPath(graph, start, end) {\n    let queue = [];\n    queue.push([start]);\n    let paths = [];\n    while (queue.length > 0) {\n        let curPath = queue.shift();\n        let lastNode = curPath[curPath.length - 1];\n        if (lastNode === end) {\n            paths.push(curPath);\n        } else {\n            for (let i = 0; i < graph[lastNode].length; i++) {\n                let nextNode = graph[lastNode][i];\n                let newPath = [...curPath, nextNode];\n                queue.push(newPath);\n            }\n        }\n    }\n    return paths;\n}\nconsole.log(findAllPath(graph,1,3))\n```\n\n    ", "Answer": "\r\nAlgorithm:\n```\nSet cost of every link to 1\nApply Dijkstra to find cheapest path\nIncrement cost of links in path\nRepeat until no new path found\n```\n\nImplementation in C++:\nhttps://github.com/JamesBremner/PathFinder/blob/2fdae739a4a4dad3b6ad4c510719078edd3e228b/src/GraphTheory.cpp#L120-L168\nSmall test run:\n\nThe complete PathFinder documentation for the finding all paths option:\nhttps://github.com/JamesBremner/PathFinder/wiki/All-Paths\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Check if exists any path, in DI-Graph\r\n                \r\nIf i have a Di-Graph, how to check if all pairs (a,b) of nodes create a path?\nExample:\nInput:\n```\nv1 v2\nv5 v6\nv2 v3\nv3 v4\nv4 v5\nv0 v1\n```\n\nAnd i need check if exist atleast one path through this graph, without visiting each node more then once.\n\nI have already tried backtracking, but for biggest input it will took hours...\nSpecific example:\nOn input i have edges:\n```\n{m,a}, {a,c}, {a,m} \n```\n\nand i have to check, if there is a path, in this case it will return True, because exist\n```\n{a,m} -> {m, a} -> {a,c}\n```\n\n    ", "Answer": "\r\nA relatively naive, quadratic algorithm\nPop a path from your list of path. Pop another path in the list to concatenate it with. Push the concatenated path back into the list. If at any time we cannot find another path to concatenate it with, it means the answer is no, all pairs of nodes do not combine into a single path, so we return ```\nNone```\n.\n```\ndef combine_into_one_path(list_of_paths):\n  path = list_of_paths.pop()\n  while list_of_paths:\n    path2 = pop_adjacent_path(list_of_paths, path[0], path[-1])\n    if path2 is None:\n      return None\n    elif path[-1] == path2[0]:\n      path = path[:-1] + path2\n    elif path2[-1] == path[0]:\n      path = path2[:-1] + path\n    else:\n      assert(False)\n  return path\n\ndef pop_adjacent_path(list_of_paths, a, b):\n  for i,p in enumerate(list_of_paths):\n    if p[0] in (a, b) or p[-1] in (a,b):\n      return list_of_paths.pop(i)\n  return None\n\nprint(combine_into_one_path([[1, 2], [5, 6], [2, 3], [3, 4], [4, 5], [0, 1]]))\n# [0, 1, 2, 3, 4, 5, 6]\n\nprint(combine_into_one_path([[1, 2], [5, 6], [2, 3], [3, 7], [4, 5], [0, 1]]))\n# None\n```\n\nThis algorithm is quadratic in the number of paths because the ```\nwhile```\n-loop in ```\ncombine_into_one_path```\n has one iteration per path in the list, and function ```\npop_adjacent_path```\n iterates through the list as well.\nNote that this code doesn't check that nodes are unique; for instance, ```\n[v1, v2, v3, v2, v4, v1, v5]```\n would be considered a valid path. You could add a check just before the final return in ```\ncombine_into_one_path```\n to make sure every element in the path is unique.\nMaking it linear\nWhat slow the algorithm down is having to iterate through the whole list to find a pair of nodes to combine our current path with. One way to avoid that would be to store the pairs in a dictionary, so we can answer the questions \"does a pair end with ```\na```\n?\" and \"does a pair start with ```\nb```\n?\" in constant time.\n```\ndef combine_into_one_path(list_of_paths):\n  path = list_of_paths.pop()\n  forwards = {p[0]:p for p in list_of_paths}\n  backwards = {p[-1]:p for p in list_of_paths}\n  while forwards:\n    if path[-1] in forwards:\n      p2 = forwards[path[-1]]\n      del forwards[path[-1]]\n      del backwards[p2[-1]]\n      path = path[:-1] + p2\n    elif path[0] in backwards:\n      p2 = backwards[path[0]]\n      del backwards[path[0]]\n      del forwards[p2[0]]\n      path = p2[:-1] + path\n    else:\n      return None\n    print('\\npath     =', path)\n    print('forwards =', forwards)\n    print('backwards=', backwards)\n  return path\n\nprint(combine_into_one_path(['manta', 'alcats', 'random']))\n# randomantalcats\n```\n\nThis is almost the same algorithm, but we replaced function ```\npop_adjacent_path```\n with a dictionary check, which is constant time instead of linear.\nJust to understand how the algorithm works:\n```\nlist_of_paths = [[1, 2], [5, 6], [3, 4], [4, 5], [0, 1], [2, 3]]\n\npath     = [2, 3]\nforwards = {1: [1, 2], 5: [5, 6], 3: [3, 4], 4: [4, 5], 0: [0, 1]}\nbackwards= {2: [1, 2], 6: [5, 6], 4: [3, 4], 5: [4, 5], 1: [0, 1]}\n\npath     = [2, 3, 4]\nforwards = {1: [1, 2], 5: [5, 6], 4: [4, 5], 0: [0, 1]}\nbackwards= {2: [1, 2], 6: [5, 6], 5: [4, 5], 1: [0, 1]}\n\npath     = [2, 3, 4, 5]\nforwards = {1: [1, 2], 5: [5, 6], 0: [0, 1]}\nbackwards= {2: [1, 2], 6: [5, 6], 1: [0, 1]}\n\npath     = [2, 3, 4, 5, 6]\nforwards = {1: [1, 2], 0: [0, 1]}\nbackwards= {2: [1, 2], 1: [0, 1]}\n\npath     = [1, 2, 3, 4, 5, 6]\nforwards = {0: [0, 1]}\nbackwards= {1: [0, 1]}\n\npath     = [0, 1, 2, 3, 4, 5, 6]\nforwards = {}\nbackwards= {}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Hamiltonian paths & social graph algorithm\r\n                \r\nI have a random undirected social graph. \n\nI want to find a Hamiltonian path if possible. Or if not possible (or not possible to know if possible in polynomial time) a series of paths. In this \"series of paths\" (where all N nodes are used exactly once), I want to minimize the number of paths and maximize the average length of the paths. (So no trivial solution of N paths of a single node). \n\nI have generated an adjacency matrix for the nodes and edges already.\n\nAny suggestions? Pointers in the right direction? I realize this will require heuristics because of the NP-complete (?) nature of the problem, and I am OK with a \"good enough\" answer.  Also I would like to do this in Java. \n\nThanks!\n    ", "Answer": "\r\nIf I'm interpreting your question correctly, what you're asking for is still NP-hard, since the best solution to the \"multiple paths\" problem would be a Hamiltonian path, and determining whether one exists is known to be NP-hard.  Moreover, even if you're guaranteed that a Hamiltonian path doesn't exist, solving this problem could still be NP-hard, since I could give you a graph with a single disconnected node floating in space, for which the best solution is a trivial path containing that node and a Hamiltonian path in the remaining graph.  As a result, unless P = NP, there isn't going to be a polynomial-time algorithm for your problem.\n\nHope this helps, and sorry for the negative result!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to calculate the shortest path between two vertices in Graph with given parameters?\r\n                \r\nWe need to compute the minCost(), which has follwing parameters:\n\n\ngNodes - no of Nodes in graph g.\nan array of int's, gFrom, where each gfrom[i] denotes a node connected by ith edge in graph g.\nan array of int's, gTo, where each gTo[i] denotes a node connected by ith edge in graph g.\nan array of int's, gWeight, denoting the respective weights of each edge in graph g.\nan int, start, denoting the start node index.\nan int, end, denoting the end node index.\nan integer, wExtra, denoting the weight of optional extra edge.\n\n\nWe need to find the path from start to end having minimum possible weight. We can add at most one extra edge(ie. zero or one) having wExtra weight between any two distinct nodes that are not already connected by an edge. The function must return an int denoting the minimum path weight from start to end.\n\nI was able to come up with following code (Dijkstra algorithm) but it doesn't give the expected output.\n\n```\n    public static int minCost(int gNodes, int[] gFrom, int[] gTo, int[] gWeights, int start, int end) {\n//making a array to store shortest length and filling it with infinity except the first one\n            int[] shortest = new int[gNodes];\n            for (int i = 0; i < gNodes; i++) {\n                shortest[i] = Integer.MAX_VALUE;\n            }\n            shortest[start]=0;\n//filling the Queue with all vertices\n        Queue<Integer> theQ = new PriorityQueue<>();\n        for (int i = 0; i < gNodes; i++) {\n            theQ.add(i + 1);\n        }\n//following the algorithm\n        while (!theQ.isEmpty()) {\n            int u = theQ.poll();\n//making a list of adjacent vertices\n\n            List<Integer> adjacent = new ArrayList<>();\n            for (int i = 0; i < gFrom.length; i++) {\n                if (gFrom[i] == u) {\n                    adjacent.add(gTo[i]);\n                } else if (gTo[i] == u) {\n                    adjacent.add(gFrom[i]);\n                }\n            }\n            for (int v: adjacent) {\n                int weight=0;\n                for (int i = 0; i < gFrom.length; i++) {\n                    if ((gFrom[i] == u && gTo[i] == v) || (gFrom[i] == v && gTo[i] == u)) {\n                        weight = gWeights[i];\n                    }\n                }\n\n//relaxing the verices\n                if (shortest[v] > shortest[u] + weight) {\n                    shortest[v] = shortest[u] + weight;\n                }\n                if (v == end) {\n                    return shortest[v];\n                }\n                theQ.add(v);\n            }\n        }\n        return -1;\n    }\n\n\n    public static void main(String[] args) {\n        int gNodes = 4;\n        int[] gFrom = {1, 2, 2, 3};\n        int[] gTo = {2, 3, 4, 4};\n        int[] gWeights = {2, 1, 2, 3};\n        int start =1;\n        int end = 4;\n        System.out.println(shortestDistance(gNodes, gFrom, gTo, gWeights, start, end));\n    }\n}\n```\n\n\nIt's not giving the expected output which I think is because I can't think of how to use that wExtra. Also, the code is quite messy. Please let me know what's wrong or feel free to provide any robust code that does it well. Thanks.\n    ", "Answer": "\r\nA possible idea to integrate ```\nwExtra```\n is the following:\n\nDuplicate the graph, such that you have two nodes for every input node. The original graph represents the state before introducing the new edge. The copy represents the state after the introduction. For every node ```\nn```\n in the original graph, you should then introduce directed edges with weight ```\nwExtra```\n to all nodes ```\nm```\n in the copy, where the original of ```\nm```\n is not adjacent to ```\nn```\n. This basically represents the fact that you can introduce a new edge between any two non-adjacent edges. But once you have done this, you cannot go back. Then, run usual Dijkstra on the modified graph between ```\nstart```\n and either the original ```\nend```\n or the copy of ```\nend```\n and you should get the correct result.\n\nThe best way to visualize this is probably to interpret the two sub graphs as layers. You start at the original layer and want to get to one of the two ```\nend```\n nodes (whichever is closer). But you may switch layers only once.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How do I find the longest path in a weighted graph?\r\n                \r\nIf I am given a data structure with currency conversion rates:\na list of currency relationships with exchange values. (INR - USD)\nThen how can I find the best exchange rate from currency1 to currency2?\nMy thought process:\nMethod 1:\nif I take the list of exchange values and convert it to a graph - adjacency list and a weight list ( since this seems to be like a weighted graph problem), I can use DFS to find all possible paths and then keep a track of the path that generates the highest exchange rate (so I will multiply every conversion rate that comes in the path and store it. whenever a path generates a better conversion rate then I update this variable, therefore I have the max)\nPlease comment on the correctness of this algorithm. Am I thinking correctly? Would this generate the correct result?\nA problem I see right away is that this is very inefficient since it would take exponential time.\nMethod 2: Can I just negate all the conversions and use Bellman Ford? Since Bellman Ford is used to find least costing paths in a weighted graph.\nThanks. Any guidance would be truly appreciated\n    ", "Answer": "\r\nYour intuition is correct- you could use DFS, and it would give you the best exchange rate (the shortest path by weight), but it would be extremely slow for large graphs.\nYour second method (Bellman Ford) is a much better idea. As you mention, you'll have to multiply the exchange rates / edge weights, rather than add them, but this shouldn't pose any issues.\nI assume you already worked this out, but for anyone referencing this in the future- you cannot use Dijkstra's algorithm nor its descendants like A*, because the graph, in spirit, has negative cycles. You could find a conversion rate less than ```\n1```\n, and potentially exploit this to get an overall lower minimum conversion rate (which you then just invert the two currencies, for a a maximum conversion rate in the opposite direction).\nA mathematical digression:\nA way to see this more clearly- imagine we have a few conversion rates, between 3 pairs of currencies- ```\nA```\n, ```\nB```\n, and ```\nC```\n. Assuming the units check out, the overall conversion rate ```\nR```\n across these three exchanges would be ```\nR = A * B * C```\n. Another way we could write this would be ```\nR = e ^ log(A * B * C)```\n, where ```\ne```\n is Euler's number, and ```\nlog()```\n is the natural logarithm (we could just as well have used ```\n10```\n and ```\nlog10()```\n, or any other base). Rewriting this using the rules of logarithms, we can get ```\nR = e ^ (log(A) + log(B) + log(C))```\n, and finally ```\nlog(R) = log(A) + log(B) + log(C)```\n.\nNow, if we don't care about the actual value of ```\nR```\n, just which is largest / smallest (or we're willing to perform some exponentiation to get it), we can just settle for computing ```\nlog(R)```\n, or the log of the exchange rate. The benefit to this is that the weights, while transformed to their logarithms, are added together, not multiplied. This allows us to use traditional implementations of graph algorithms unchanged (we just give them ```\nlog(weight)```\n instead of ```\nweight```\n). If we try to give it something that would normally be between ```\n0```\n and ```\n1```\n, we see that ```\nlog(x)```\n actually becomes negative, exposing the true nature of that edge, and the potential negative cycles it may create.\nSummary\nYou'll want to probably use Bellman-Ford, and you should be fine just replacing addition with multiplication. If you have an existing implementation at hand, but which utilizes addition to combine edge weights, you can easily cheat by passing it the ```\nlog()```\n of the edge weight instead, and things will work \"automagically\".\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find path in graph by backtracking using prolog\r\n                \r\nI have the following graph:\n```\nmaniere(v11,h11).\nmaniere(h11,v12).\nmaniere(h11,h21).\nmaniere(v12,v22).\nmaniere(v22,h13).\nmaniere(v22,h23).\nmaniere(h13,v21).\nmaniere(v22,h23).\nmaniere(h12,h22).\nmaniere(h23,v23).\nmaniere(h33,v23).\nmaniere(v13,h32).\nmaniere(v23,h32).\n```\n\nThe required output is:\n```\n?- traverser(v11, v23).\nv11 to h11\nh11 to v12 \nv12 to v22 \nv22 to h13 \nh13 to v21 \nv22 to h23 \nh23 to v23 \ntrue .\n```\n\nI'm having trouble when I don't format the output as requested.\n    ", "Answer": "\r\nThe general rule for traversing a graph is pretty simple:\n\nThe simple/special case:\nWe can get from ```\nA```\n to ```\nB```\n if ```\nA```\n and ```\nB```\n are directly connected.\n\nThe more general/recursive case:\nWe can get from ```\nA```\n to ```\nB```\n if ```\nA```\n is connected to some intermediate node ```\nX```\n, and we can then get from ```\nX```\n to ```\nB```\n.\n\n\nCorrect?\nThat can be expressed directly in Prolog.\nFor the sake of argument we will use ```\nedge/2```\n to define our graph, so ```\nedge(a,b).```\n is a fact that tell us that we can travel from ```\na```\n to ```\nb```\n (but not from ```\nb```\n to ```\na```\n — our graph is a directed graph.\n```\ntraverse(A,B) :- edge(A,B).\ntraverse(A,B) :- edge(A,X), traverse(X,B).\n```\n\nTo get what you need, though, you'll want to track your path through the graph. To do that, you need to use a helper predicate that takes additional arguments to carry state and return results, The other reason for tracking your path through the graph is so that you can detect cycles in the graph — if you wind up back at a node you've already visited, you'll wind up going into an infinite loop (or at least, until the stack overflows). That gets you to this:\n```\ntraverse(A,B) :-       % we can get from A to B iff...\n    traverse(A,B,[A]). % - we invoke the helper, seeding the list of visited nodes with A, the origin node\n\n% ---------------------------------------\n% traverse(Origin, Destination, Visited )\n% ---------------------------------------\ntraverse( A , B , _ ) :- % we can get from A to B iff...\n    edge(A,B).           % - A and B are directly connected.\ntraverse( A , B , V ) :- % Otherwise, we can get from A to B iff...\n    edge(A,X),           % - An edge exists from A to X, and\n    not_visited(X,V),    % - We have not yet visited X, and\n    traverse(X,B,[X|V]). % - We can get from X to B\n\nnot_visited(N,V) :- % we haven't visited node N... \n    \\+ member(N,V). % - if N is not contained in the list of visited nodes (V).\n```\n\nBut you need to return the complete path, which is just a matter of adding an additional argument to the helper predicate:\n```\ntraverse(A,B,P) :-         % we can get from A to B iff...\n    traverse(A,B,[A],P). % - we invoke the helper, seeding the list of visited nodes with A, the origin node\n\n% ---------------------------------------\n% traverse(Origin, Destination, Visited )\n% ---------------------------------------\ntraverse( A , B , V, [B|V] ) :- % we can get from A to B iff...\n    edge(A,B).                  % - A and B are directly connected.\ntraverse( A , B , V, P     ) :- % Otherwise, we can get from A to B iff...\n    edge(A,X),                  % - An edge exists from A to X, and\n    not_visited(X,V),           % - We have not yet visited X, and\n    traverse(X,B,[X|V],P).      % - We can get from X to B\n\nnot_visited(N,V) :- % we haven't visited node N... \n    \\+ member(N,V). % - if N is not contained in the list of visited nodes (V).\n```\n\nAnd then, you need a way to display the path.\nYou might notice that the path is returned in reverse order. You can use recursion to deal with that:\n```\ndisplay_path([]).\ndisplay_path([_]).\ndisplay_path([To,From|Ns]) :-\n  display_path([From|Ns]),\n  display_leg(From,To).\n\ndisplay_leg(From,To) :- write(From), write(' --> '), write(To), nl.\n```\n\nBut that's a little counter-intuitive. Better to have the helper reverse the list on success:\n```\ntraverse(A,B,P) :-       % we can get from A to B iff...\n    traverse(A,B,[A],P). % - we invoke the helper, seeding the list of visited nodes with A, the origin node\n\n% ---------------------------------------\n% traverse(Origin, Destination, Visited )\n% ---------------------------------------\ntraverse( A , B , V, P ) :- % we can get from A to B iff...\n    edge(A,B),              % - A and B are directly connected,\n    reverse([B|V],P).\ntraverse( A , B , V, P ) :- % Otherwise, we can get from A to B iff...\n    edge(A,X),              % - An edge exists from A to X, and\n    not_visited(X,V),       % - We have not yet visited X, and\n    traverse(X,B,[X|V],P).  % - We can get from X to B\n\nnot_visited(N,V) :- % we haven't visited node N... \n    \\+ member(N,V). % - if N is not contained in the list of visited nodes (V).\n```\n\nThat makes ```\ndisplay_path/1```\n much more intuitive:\n```\ndisplay_path([]).\ndisplay_path([_]).\ndisplay_path([From,To|Ns]) :-\n  display_leg(From,To),\n  display_path([To|Ns]).\n\ndisplay_leg(From,To) :-\n    write(From),\n    write(' --> '),\n    write(To),\n    nl.\n```\n\nAnd we can wrap our ```\ntraverse/3```\n up with ```\ndisplay_path/1```\n:\n```\nvisit(A,B) :- traverse(A,B,P), display_path(P). \n```\n\nWrapping it all up, we get this (you can fiddle with it at https://swish.swi-prolog.org/p/rmEdFAqE.pl):\n```\nedge(a,b).\nedge(a,c).\nedge(b,c).\nedge(c,d).\n\nvisit(A,B) :- traverse(A,B,P), display_path(P). \n\ntraverse(A,B,P) :-       % we can get from A to B iff...\n    traverse(A,B,[A],P). % - we invoke the helper, seeding the list of visited nodes with A, the origin node\n\n% ---------------------------------------\n% traverse(Origin, Destination, Visited )\n% ---------------------------------------\ntraverse( A , B , V, P ) :- % we can get from A to B iff...\n    edge(A,B),              % - A and B are directly connected,\n    reverse([B|V],P).\ntraverse( A , B , V, P ) :- % Otherwise, we can get from A to B iff...\n    edge(A,X),              % - An edge exists from A to X, and\n    not_visited(X,V),       % - We have not yet visited X, and\n    traverse(X,B,[X|V],P).  % - We can get from X to B\n\nnot_visited(N,V) :- % we haven't visited node N... \n    \\+ member(N,V). % - if N is not contained in the list of visited nodes (V).\n\ndisplay_path([]).\ndisplay_path([_]).\ndisplay_path([A,B|Ns]) :-\n  display_leg(A,B),\n  display_path([B|Ns]).\n\ndisplay_leg(From,To) :-\n    write(From),\n    write(' --> '),\n    write(To),\n    nl.\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find heaviest path in grid like graph\r\n                \r\nI have an input graph of ```\nN by N```\n edges, where each vertex has a certain weight to it\nand each vertex ```\n[i,j]```\n is connected only to ```\n[i+1,j] and [i,j+1]```\n, meaning that each vertex is connected to the one on its right and the one above it.\nheres an example of such a graph where ```\nN=4```\n:\nexample graph\ngiven this type of grid graph, what do you think is the fastest way to calculate the heaviest path in it?\n(the one in which the summery of all vertices values in it is maximized)\n    ", "Answer": "\r\nI know this problem on its opposite side, finding the shortest distance to travel from A to B inside a graph.\nPopular algorithms for it are Dijkstra (https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) and A* (https://en.wikipedia.org/wiki/A*_search_algorithm) the latter being faster, but not computing necessarily the \"optimal\" way.\nI'd bet that with some adjustments, you could tweak one of these algorithms to compute the opposite. Not 100% sure though, give it a shot a share your solution with us !\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find total cost of each path in graph using dictionary in python\r\n                \r\nMy task is to find total cost associated with each path and then tell the shortest cost path.\nIn the given graph dict I had to assign random cost to each node and then when finding all the paths i also have to find the total cost associated with that path print the cost along with the path and then print the shortest cost path.\nProblem is that I can print all the paths but I am unable to find the total cost associated with that path.\nMy code is\n```\nenter code hgraph = {'A': {'B':2, 'C':3},\n     'B': {'C':2, 'D':5},\n     'C': {'D':4, 'G':2},\n     'D': {'C':6, 'E':4},\n     'E': {'F':1},\n     'F': [],\n     'G': []}\n\n\ndef find_all_paths(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return [path]\n    if start not in graph:\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            paths += find_all_paths(graph, node, end, path)\n\n    return paths\n\nprint(\"Path : \",find_all_paths(graph, 'A', 'F'))\n```\n\nI tried using this but it return cost of that node only and I its impossible to integrate it in the loop\n```\ncost= cost + (str(graph['A'].get('B')+(graph['A'].get('C'))))\n```\n\n    ", "Answer": "\r\nSince Python 3.10 you can write it for a given ```\npath```\n like:\n```\nfrom itertools import pairwise\n\ncost = sum(graph[f][t] for f, t in pairwise(path))\n```\n\nSee the docs how to replace pairwise before 3.10.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Conversation ID leads to unkown path in graph-api\r\n                \r\nI have a code that fetches conversations and the messages inside them (a specific number of pages). It works most of the time, but for certain conversations it throws an exception, such as:\n\n```\nException in thread \"main\" com.restfb.exception.FacebookOAuthException: Received Facebook error response of type OAuthException: Unknown path components: /[id of the message]/messages (code 2500, subcode null)\nat com.restfb.DefaultFacebookClient$DefaultGraphFacebookExceptionMapper.exceptionForTypeAndMessage(DefaultFacebookClient.java:1192)\nat com.restfb.DefaultFacebookClient.throwFacebookResponseStatusExceptionIfNecessary(DefaultFacebookClient.java:1118)\nat com.restfb.DefaultFacebookClient.makeRequestAndProcessResponse(DefaultFacebookClient.java:1059)\nat com.restfb.DefaultFacebookClient.makeRequest(DefaultFacebookClient.java:970)\nat com.restfb.DefaultFacebookClient.makeRequest(DefaultFacebookClient.java:932)\nat com.restfb.DefaultFacebookClient.fetchConnection(DefaultFacebookClient.java:356)\nat test.Test.main(Test.java:40)\n```\n\n\nAfter debugging I found the ID that doesn't work and tried to access it from graph-api, which results in an \"unknown path components\" error. I also attempted to manually find the conversation in me/conversations and click the next page link in the graph api explorer which also lead to the same error.\n\nIs there a different way to retrieve a conversation than by ID? And if not, could someone show me an example to verify first if the conversation ID is valid, so if there are conversations I can't retrieve I could skip them instead of getting an error. Here's my current  code:\n\n```\nConnection<Conversation> fetchedConversations = fbClient.fetchConnection(\"me/Conversations\", Conversation.class);\n\n    int pageCnt = 2;\n\n    for (List<Conversation> conversationPage : fetchedConversations) {\n\n        for (Conversation aConversation : conversationPage) {\n            String id = aConversation.getId();\n\n            //The line of code which causes the exception\n            Connection<Message> messages = fbClient.fetchConnection(id + \"/messages\", Message.class, Parameter.with(\"fields\", \"message,created_time,from,id\"));\n\n            int tempCnt = 0;\n            for (List<Message> messagePage : messages) {\n                for (Message msg : messagePage) {\n                    System.out.println(msg.getFrom().getName());\n                    System.out.println(msg.getMessage());\n                }\n                if (tempCnt == pageCnt) {\n                    break;\n                }\n                tempCnt++;\n\n            }\n        }\n\n    }\n```\n\n\nThanks in advance!\n\nUpdate: Surrounded the problematic part with a try catch as a temporary solution, also counted the number of occurrences and it only effects 3 out of 53 conversations. I also printed all the IDs, and it seems that these 3 IDs are the only ones that contain a \"/\" symbol, I'm guessing it has something to do with the exception. \n\nThe IDs that work look something like this: t_[text] (sometimes a \".\" or a \":\" symbol) and the ones that cause an exception are always t_[text]/[text]\n    ", "Answer": "\r\nconv_id/messages is not a valid graph api call.\nmessages is a field of conversation.\n\nHere is what you do (single call to api):\n\n```\nConnection<Conversation> conversations = facebookClient.fetchConnection(\"me/conversations\", Conversation.class);\n\n                    for (Conversation conv : conversations.getData()) {\n\n                       // To get list of messages for given conversation\n                       LinkedList<Message> allConvMessagesStorage = new LinkedList<Message>();\n\n                       Connection<Message> messages25 = facebookClient.fetchConnection(conv.getId()+\"/messages\", Message.class);\n\n                     //Add messages returned\n                     allConvMessagesStorage.addAll(messages25.getData());\n                       //Check if there is next page to fetch\n                       boolean progress = messages25.hasNext();\n                       while(progress){\n                          messages25 = facebookClient.fetchConnectionPage(messages25.getNextPageUrl(), Message.class);\n                          //Append next page of messages\n                          allConvMessagesStorage.addAll(messages25.getData());\n                       progress = messages25.hasNext();\n        }\n\n\n                    }\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest Path in an undirected unweighted graph\r\n                \r\nI came across a problem where I have to find out the longest path in a given graph. I have list of edges ( eg.{AB, BC} ) which states there is an edge between vertices/nodes (A,B,C). Now i want to figure out the longest path possible (not repeating the vertex) such that it covers maximum nodes starting from any vertex/node.   \n\nWhat can be the best way to solve this?\nI have to implement this as a program.\n\nI looked up google for\nMinimum Spanning Tree, Dijkstra's Alogorithms , and many more. but can't figure out what would suit best for this problem.\n\nAny help or reading references would be much appreciated.\n    ", "Answer": "\r\nSince your question doesn't speak whether the Graph is Cyclic or Not you have two options:\n\nOption1:Graph is DAG\n\nYou are Lucky, you can use topological sort on the graph and get the longest path!\n\nOption 2:Graph is NOT DAG:\n\nUse the Hamiltonian Algorithm as mentioned in the Comments!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Findings common paths in two graphs using python-networkx\r\n                \r\nI have two DiGraphs, say G and H, and I would like to count how many paths of G are part of H.\nFor any node pairs (src, dst) I can generate the paths between them using the 'all_simple_paths' function to get the generators:\nG_gen = nx.all_simple_paths(G, src, dst)\nH_gen = nx.all_simple_paths(H, src, dst)\nSince the amount of paths is considerably high (the graphs have typically 100 nodes) I cannot resort to building lists etc.. (e.g. list(G_gen)) so I am wondering if there are smarter ways to deal with it. In addition, I would also like to distinguish based on the path lengths.\n.. or maybe a better solution can be found with a different module ?\nThanks in advance for any help on this.\nThierry\n    ", "Answer": "\r\nI wonder if there is some reason why ```\nnx.intersection```\n (see here) wouldn't work here? I'm not sure if it checks for direction under the hood but it doesn't seem to force outputs to standard ```\nGraph```\n output either. Below might work:\n```\n# Create a couple of random preferential attachment graphs\nG = nx.barabasi_albert_graph(100, 5)\nH = nx.barabasi_albert_graph(100, 5)\n\n# Convert to directed\nG = G.to_directed()\nH = H.to_directed()\n\n# Get intersection\nintersection = nx.intersection(G, H)\n\n# Print info for each\nprint(nx.info(G))\nprint(nx.info(H))\nprint(nx.info(intersection))\n```\n\nwhich outputs:\n```\n>>> DiGraph with 100 nodes and 950 edges\n>>> DiGraph with 100 nodes and 950 edges\n>>> DiGraph with 100 nodes and 176 edges\n```\n\nThe nodes are all shared in the example since the node ids are just simple integers and so they follow the same generation index. With real data I suppose your node sets might not be equivalent like here and you probably will see differences there too.\nOn the path lengths I'm not quite sure how you would go about that. The intersection just checks which nodes and edges are shared between two graphs and returns those that are in both, unaware of any other conditions I suspect. There might be a way to impose some additional constraints by adapting the source code with of the intersection function with some conditional checks.\nI guess this doesn't check the number of paths but rather the number of edges, so I suppose you're looking for something more specific than this. But at the very least no path can exist outside of the intersection, since all shared paths must contain the same edges in both (since if an edge is missing from a path in either, it cannot exist as a path in the shared solution).\nHope this helps in some way shape or form, though I feel I've oversimplified your question quite a bit.\nEDIT: Intuitively, the full solution to your question might be to simply enumerate all possible paths in the intersection.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Filter and sort alternativ paths in a graph based environment\r\n                \r\nSince I don't know how to ask the question directly, I'd like to introduce the problem step by step:\n\nImagine a vector of (wrapping) objects and you need to sort and filter.\nNormally, I'd do something like this:\n\n```\nclass Foo\n{\n   Bar* bar\n   int CalcDistance();            // operates on bar;\n   std::vector<int> GetObjects(); // operates on bar;\n};\n\nstd::vector<Foo*> process()\n{\n  std::vector<Foo*> foos = GetFoosFromSomewhere();\n  std::vector<Foo*> potentialFoos;\n\n  auto the_filter = [&](auto foo){ \n    return foo->CalcDistance() < MAGIC_NUMBER && !foo->GetObjects().empty(); \n  };\n  std::copy_if(foos.begin(), foos.end(), potentialFoos.begin(), the_filter);\n\n  auto the_sorter = [&](auto lhs, auto rhs){ return lhs->CalcDistance() > rhs->CalcDistance(); };\n  std::sort(potentialFoos.begin(), potentialFoos.end(), the_sorter);\n\n  return potentialFoos;\n}\n```\n\n\nUnfortunatly, I don't need to filter a vector of Foos. Instead, the individual queries operate on a graph and return multiple results when given a target (vertex in the graph).\n\nIf there are three possiblities to get to the target, you get three distances and three vectors of objects, respectively.\n\n```\nclass Foo\n{\n   Bar* bar\n   std::vector<int> CalcDistance(Vertex target);            // operates on bar, based on a graph;\n   std::vector<std::vector<int>> GetObjects(Vertex target); // operates on bar, based on a graph;\n};\n```\n\n\nI'd like to have an easy (expressive) way to sort and filter alternative paths, leading to the same target. What I can imagine is something like this:\n\n```\n// pseudo-code\nFoo foo = GetFooFromSomewhere();\nstd::vector<Vertex> targets = GetTargetsFromSomewhere();\n\nauto the_filter = [](Distance d, Objects o){ return d < MAGIC_NUMBER && !o.empty() };\nauto the_sorter = [](Distances d){ return d.lhs < d.rhs; }\nauto alternatives = SortAndFilter(foo, targets, \n  filter<Distance, Objects>(the_filter), \n  sorter<Distance>(the_sorter));\n```\n\n\nI've already made some progress using variadic templates and fold expressions to decompose the individual Query objects (here Distance and Objects) of the lambdas (see http://coliru.stacked-crooked.com/a/3a095f1adcf61de4), but it's (a) not complete, (b) not as expressive as I'd like to have it and (c) certainly the \"reinvention of the year\".\n\nThe ultimate goal is to hide the complexity of the underlying method calls to the wrapped bar object from the end user with being able to extend the queries e.g. by template specialization.\n\nThe problem is my feeling about reinventing the wheel and I'm pretty sure, that there are some better ways to do that (e.g. some nice stuff on top of boost graph).\n\nAny ideas (improvements)?\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "average shortest path in unweighted undirected graph\r\n                \r\ncan somebody help me? I'm a bit lost. Well, i'm not an expert in Java for sure.\n\nI need to write java code algorithm to calculate an average shortest path in unweighted undirected graph (network). This graph is a grid of 100 nodes (10 x 10) and would like to search all shortest paths between all pairs (nodes) in network and then divide by number of shortest paths to get an average shotrest path. Is this posible by modifying Dijstra's algorithm? Can someone show me how, please?\n\ndijkstra's alghoritm\n\n```\npublic static void dijkstra(int s, int[][] A, int N, int[] d) {\n    int mini;  int[] visit = new int[N];\n    for (int i=0;i<N;i++) {\n        d[i] = N*N;    \n        visit[i] = 0;  \n    }\n    d[s] = 0;           \n    for (int k=0;k<N;k++) {\n        mini = -1;\n        for (int i=0;i<N;i++)\n            if ((visit[i]==0) && ((mini == -1) || (d[i] < d[mini])))\n                mini = i;\n        visit[mini] = 1;\n        for (int i=0;i<N;i++)\n            if (A[mini][i]==1)\n                if (d[mini] + A[mini][i] < d[i]) \n                    d[i] = d[mini] + A[mini][i];\n    }\n}\n```\n\n    ", "Answer": "\r\nDijkstra's algorithm will give you the shortest path from a given node to all other nodes in the connected graph.  One way to get your average is to iterate through each node of the graph, running Dijkstra's algorithm to get the shortest distance from that node to each of the others, and taking the average of paths starting from that node.  Accumulate the \"average of paths starting from current node\" as you iterate.  Divide by number of nodes when you finish iterating.\n\nThis is a brute force approach, and will calculate each distance twice, but it should give you the correct average.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "find the maximum number of vertex-disjoint paths in a graph with a constraint\r\n                \r\nGiven a undirected graph G=(V,E), each edge is associated with a non-negative value.\n\nHow to find the maximum number of vertex-disjoint paths from s to t on the graph G, with a constraint that the sum of paths length is not greater than a predefined value T.\n    ", "Answer": "\r\nYou can start with transforming a vertex-disjoint paths problem to edge-disjoint paths problem. See this answer to other question for details.\n\nNow you can solve Minimum-cost flow problem on this graph to find any number of disjoint paths having minimal sum of path lengths. Do do this, assign flow capacity for each edge equal to 1, then search for a minimum-cost flow between s and t with flow equal to the needed number of paths.\n\nTo find the maximum number of paths, apply minimum-cost flow procedure on each step of binary search, starting from some initial number of paths, which may be determined by one of the following procedures:\n\n\nIf you expect the maximum number of paths to be large, solve Maximum flow problem for this graph.\nIf you expect the maximum number of paths to be small, use one-sided binary search (also with minimum-cost flow procedure on each step).\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to automate creating directed graph using networkx or graphviz in Python for all possible paths in a travelling salesman problem?\r\n                \r\nI want to create a directed graph showing all possible paths in a travelling salesman problem for four cities I want to explore.\n```\ncities = [\"Berlin\",\"Hamburg\",\"Dusseldorf\",\"Munich\"]\n```\n\nFirst, I created a skeleton using the graphviz package. The nodes are integers (but in the form of strings). The code looks as follows:\n```\nimport graphviz\n\nnodes = np.arange(0, 21)\n\ncities = [\"Berlin\",\"Dusseldorf\",\"Hamburg\",\"Munich\"]\n\n\nf = graphviz.Digraph()\n\n#Stop 1\nfor i in range(1, 4):\n    f.edge(str(0), str(i))\n    \n#Stop 2 add edges\nfor i in range(1,4):   \n    for j in range(4,10):\n        if j==i*2+2 or j == i*2+3:\n            f.edge(str(i), str(j))\n            \nfor i in range(4, 10):\n    for j in range(10, 16):\n        if j == i+6:\n            f.edge(str(i), str(j))\n\nfor i in range(10, 16):\n    for j in range(16, 22):\n        if j == i+6:\n            f.edge(str(i), str(j))\n            \nf\n```\n\nThis returned me a following directed graph:\n\nIn place of nodes, I want to give the name of cities as labels. The route in travelling salesman problem is assumed to start and end at Berlin. I provided the name (labels) to nodes manually in the code below.\n```\nimport graphviz\n\nnodes = np.arange(0, 21)\n\ncities = [\"Berlin\",\"Dusseldorf\",\"Hamburg\",\"Munich\"]\n\n\nf = graphviz.Digraph()\n\n#Stop 1\nfor i in range(1, 4):\n    f.edge(str(0), str(i))\n    \n#Stop 2 add edges\nfor i in range(1,4):   \n    for j in range(4,10):\n        if j==i*2+2 or j == i*2+3:\n            f.edge(str(i), str(j))\n            \nfor i in range(4, 10):\n    for j in range(10, 16):\n        if j == i+6:\n            f.edge(str(i), str(j))\n\nfor i in range(10, 16):\n    for j in range(16, 22):\n        if j == i+6:\n            f.edge(str(i), str(j))\n\n#Root node\nf.node(\"0\",\"Berlin\")\n\n#Leaves\nfor i in range(16, 22):\n    f.node(str(i), \"Berlin\")\n\n#Stop 1\nfor i in range(1,4):\n    f.node(str(i), cities[i])\n\n#Stop 2 add nodes\nf.node(str(4), \"Hamburg\")\nf.node(str(9), \"Hamburg\")\nf.node(str(11), \"Hamburg\")\nf.node(str(14), \"Hamburg\")\n\nf.node(str(5), \"Munich\")\nf.node(str(7), \"Munich\")\nf.node(str(10), \"Munich\")\nf.node(str(12), \"Munich\")\n\nf.node(str(6), \"Dusseldorf\")\nf.node(str(8), \"Dusseldorf\")\nf.node(str(13), \"Dusseldorf\")\nf.node(str(15), \"Dusseldorf\")\n            \nf\n```\n\nThe resulting plot is as shown, which has all possible paths starting from Berlin and ending at Berlin visiting all rest of the cities once:\n\nI have provided labels to each of the nodes manually. But is there a process I can automate it to give the labels to the individual nodes for this kind of graph? Is it possible to do it using graphviz, NetworkX or with the help any other packages such as pandas in Python?\n    ", "Answer": "\r\nnetworkx seems to have a function for everything:\n```\nfrom itertools import permutations\nimport networkx as nx\n\ndef make_tsp_tree(cities):\n    start, *rest = cities\n    paths = [(start, *path, start) for path in permutations(rest)]\n    G = nx.prefix_tree(paths)\n    # remove synthetic root and leaf nodes\n    G.remove_nodes_from([0, -1])\n    return G\n```\n\nThe root node is ```\n1```\n, and the city names are stored in the node attribute ```\nsource```\n. It should be straightforward to convert it to graphviz or whatever you need.\nA quick usage example:\n```\npos = nx.nx_agraph.graphviz_layout(G, \"dot\", root=1)\nnx.draw_networkx_nodes(G, pos, node_color=\"C1\")\nnx.draw_networkx_edges(G, pos)\nnx.draw_networkx_labels(G, pos, labels=dict(G.nodes(data=\"source\")))\n```\n\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Undirected graph into Minimum cost union of paths\r\n                \r\nI have to create a solution for a weighted undirected graph, passing through all the nodes, with a total minimum cost. Several paths, with no defined starting nodes, should end up and meet at one intersecting node. The number of the paths, and the number of the nodes included in a path are not pre-determined. The nodes can be passed more than once.\n\nWhat kind of problem am I dealing with, possible algorithms as solution?\nI suppose it should be a variation of a Minimum spanning tree (meaning using the intersection node as a starting point for the paths in stead of ending point)\n    ", "Answer": "\r\nIt's called Minimum Cost Hamiltonian Circuit problem.\n\nHere you can read more about it.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "finding all paths in a graph including a vertex\r\n                \r\nI have a directed simple graph (named tutti) and a list of vertex (named risultato).  \n\nI want to find the full set of subgraph extracted by \"tutti\" that includes a vertex in the array risultato. \n\nAs example in the included picture the graph tutti  \n\n\n\nGiven the vertex 609 (that is one vertex present in risultato) (in red on the left) i need to plot the graph in picture \n\n\nHow can i extract all those graphs?\n    ", "Answer": "\r\nThe vertexes to be taken in consideration are in the array risultato.\nreturn all path in \"tutti\"  graph arriving to each element in risultato:\nsottografierrorisopra<-graph.neighborhood (tutti,vcount(tutti),risultato, \"in\")\nreturn all path in \"tutti\" graph starting from the vertex in the risultato #array\nsottografierrorisotto<-graph.neighborhood (tutti,vcount(tutti),risultato, \"out\")\nunion of the graphs\nzz<- graph.union (sottografierrorisopra, sottografierrorisotto)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Is there an efficient way to find shortest paths in a functional graph?\r\n                \r\nMy task is to process ```\nQ```\n shortest path queries in a functional graph with ```\nV```\n nodes. ```\nQ```\n and ```\nV```\n are integers that can be up to ```\n100000```\n.\nMy first idea was to use the Floyd-Warshall algorithm to answer queries efficiently, but this algorithm takes ```\nO(V^3)```\n time to calculate the shortest paths, which is way too slow.\nMy second idea runs in ```\nO(QV)```\n time, because for every query I start at the starting node and traverse through the graph until I discover a cycle or reach the destination node.\nHowever, this solution is still too slow; it has no chance of quickly processing queries when ```\nV```\n and ```\nQ```\n become large. I think that there is some pre-processing or another technique that I could use to solve this, but I haven't been able to find any online resources to help guide me. Can somebody please help me out?\n    ", "Answer": "\r\nA functional graph means that each node has only a single out-edge, so the maximum number of steps between A and B couldn't be more than the number of vertices without encountering a cycle.  You should be O(V).\nSince there are no choices, you could readily build a CostMap[V][V] which recorded the distance between two nodes, and lazily fill it as you encounter queries; thus successive queries would approach constant time.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Match Only Full Paths in Neo4J with Cypher (not sub-paths)\r\n                \r\nIf I have a graph like the following (where the nesting could go on for an arbitrary number of nodes):\n\n```\n(a)-[:KNOWS]->(b)-[:KNOWS]->(c)-[:KNOWS]->(d)-[:KNOWS]->(e)\n               |             |\n               |            (i)-[:KNOWS]->(j)\n               |\n              (f)-[:KNOWS]->(g)-[:KNOWS]->(h)-[:KNOWS]->(n)\n                             |\n                            (k)-[:KNOWS]->(l)-[:KNOWS]->(m)\n```\n\n\nHow can I retrieve all of the full-length paths (in this case, from ```\n(a)-->(m)```\n, ```\n(a)-->(n)```\n ```\n(a)-->(j)```\n and ```\n(a)-->(e)```\n? The query should also be able to return the nodes with no relationships of the given type.\n\nSo far I am just doing the following (I only want the ```\nid```\n property):\n\n```\nMATCH path=(a)-[:KNOWS*]->(b)\nRETURN collect(extract(n in nodes(path) | n.id)) as paths\n```\n\n\nI need the paths so that in the programming language (in this case clojure) I can create a nested map like this:\n\n```\n{\"a\" {\"b\" {\"f\" {\"g\" {\"k\" {\"l\" {\"m\" nil}}\n                     \"h\" {\"n\" nil}}}\n           \"c\" {\"d\" {\"e\" nil}\n                \"i\" {\"j\" nil}}}}}\n```\n\n\nIs it possible to generate the map directly with the query? \n    ", "Answer": "\r\nJust had to do something similar, this worked on your example, finds all nodes which do not have outgoing ```\n[:KNOWS]```\n:\n\n```\nmatch p=(a:Node {name:'a'})-[:KNOWS*]->(b:Node)\noptional match (b)-[v:KNOWS]->()\nwith p,v\nwhere v IS NULL\nreturn collect(extract(n in nodes(p) | n.id)) as paths\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest Path in a graph\r\n                \r\nMy graph is implemented in the following way:\n\n```\nstruct node{\n    string ID;\n    vector<string> neighbors;\n\n}\n\nstruct graph{\n    vector<string> nodes;\n}\n```\n\n\nnodes is a vector of nodes. Each node contains its ID and a vector of all of its neighbor's (Nodes it is pointing to) IDs\n\nIs there a way I can apply Dijkstra's algorithm or Bellman-Ford to find the shortest path between two nodes? Find a duplicate cycle? How would I do that?\n\nEDIT: sturcts were accidental named the same. \n    ", "Answer": "\r\nYou didn't mention anything about the edge weight.\n\nDijkstra algorithm works if you don't have a negative edge weight.\n\nBellman-ford algorithm works if you don't have a negative cycle. But you can also use Bellman-Ford algorithm to check if you have a negative cycle.\n\nIf it's a weightless edged-graph, you can just use BFS.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Spark: GraphX fails to find connected components in graphs with few edges and long paths\r\n                \r\nI'm new to Spark and GraphX and did some experiments with its algorithm to find connected components. I noticed that the structure of the graph seems to have a strong impact on the performance.\n\nIt was able to compute graphs with millions of vertices and edges, but for a certain group of graphs, the algorithm did not finish in time, but eventually fails with an ```\nOutOfMemoryError: GC overhead limit exceeded```\n.\n\nThe algorithm seems to have problems with graphs that contain long paths. For instance, for this graph ```\n{ (i,i+1) | i <- {1..200} }```\n the computation fails. However, when I added transitive edges, the computation finished immediately:\n\n```\n{ (i,j) | i <- {1..200}, j <- {i+1,200} }\n```\n\n\nAlso graphs like this were no problem:\n\n```\n{ (i,1) | i <- {1..200} }\n```\n\n\nHere is a minimal example to reproduce the problem:\n\n```\nimport org.apache.spark._\nimport org.apache.spark.graphx._\nimport org.apache.spark.graphx.lib._\nimport org.apache.spark.storage.StorageLevel\n\nimport scala.collection.mutable\n\nobject Matching extends Logging {\n\n  def main(args: Array[String]): Unit = {\n    val fname = \"input.graph\"\n    val optionsList = args.drop(1).map { arg =>\n      arg.dropWhile(_ == '-').split('=') match {\n        case Array(opt, v) => opt -> v\n        case _ => throw new IllegalArgumentException(\"Invalid argument: \" + arg)\n      }\n    }\n    val options = mutable.Map(optionsList: _*)\n\n    val conf = new SparkConf()\n    GraphXUtils.registerKryoClasses(conf)\n\n    val partitionStrategy: Option[PartitionStrategy] = options.remove(\"partStrategy\")\n      .map(PartitionStrategy.fromString(_))\n    val edgeStorageLevel = options.remove(\"edgeStorageLevel\")\n      .map(StorageLevel.fromString(_)).getOrElse(StorageLevel.MEMORY_ONLY)\n    val vertexStorageLevel = options.remove(\"vertexStorageLevel\")\n      .map(StorageLevel.fromString(_)).getOrElse(StorageLevel.MEMORY_ONLY)\n\n    val sc = new SparkContext(conf.setAppName(\"ConnectedComponents(\" + fname + \")\"))\n    val unpartitionedGraph = GraphLoader.edgeListFile(sc, fname,\n      edgeStorageLevel = edgeStorageLevel,\n      vertexStorageLevel = vertexStorageLevel).cache()\n    log.info(\"Loading graph...\")\n    val graph = partitionStrategy.foldLeft(unpartitionedGraph)(_.partitionBy(_))\n    log.info(\"Loading graph...done\")\n\n    log.info(\"Computing connected components...\")\n    val cc = ConnectedComponents.run(graph)\n    log.info(\"Computed connected components...done\")\n\n    sc.stop()\n  }\n}\n```\n\n\nThe ```\ninput.graph```\n file can look this this (10 nodes, 9 edges connecting them):\n\n```\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n```\n\n\nWhen it fails, it hangs in ```\nConnectedComponents.run(graph)```\n. The error message is:\n\n```\nException in thread \"dag-scheduler-event-loop\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n    at java.util.regex.Pattern.compile(Pattern.java:1054)\n    at java.lang.String.replace(String.java:2239)\n    at org.apache.spark.util.Utils$.getFormattedClassName(Utils.scala:1632)\n    at org.apache.spark.storage.RDDInfo$$anonfun$1.apply(RDDInfo.scala:58)\n    at org.apache.spark.storage.RDDInfo$$anonfun$1.apply(RDDInfo.scala:58)\n    at scala.Option.getOrElse(Option.scala:121)\n    at org.apache.spark.storage.RDDInfo$.fromRdd(RDDInfo.scala:58)\n    at org.apache.spark.scheduler.StageInfo$$anonfun$1.apply(StageInfo.scala:80)\n    at org.apache.spark.scheduler.StageInfo$$anonfun$1.apply(StageInfo.scala:80)\n    at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)\n    at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)\n    at scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:59)\n    at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:48)\n    at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)\n    at scala.collection.AbstractTraversable.map(Traversable.scala:104)\n    at org.apache.spark.scheduler.StageInfo$.fromStage(StageInfo.scala:80)\n    at org.apache.spark.scheduler.Stage.<init>(Stage.scala:99)\n    at org.apache.spark.scheduler.ShuffleMapStage.<init>(ShuffleMapStage.scala:44)\n    at org.apache.spark.scheduler.DAGScheduler.newShuffleMapStage(DAGScheduler.scala:317)\n    at org.apache.spark.scheduler.DAGScheduler.org$apache$spark$scheduler$DAGScheduler$$newOrUsedShuffleStage(DAGScheduler.scala:352)\n    at org.apache.spark.scheduler.DAGScheduler$$anonfun$org$apache$spark$scheduler$DAGScheduler$$getShuffleMapStage$1.apply(DAGScheduler.scala:286)\n    at org.apache.spark.scheduler.DAGScheduler$$anonfun$org$apache$spark$scheduler$DAGScheduler$$getShuffleMapStage$1.apply(DAGScheduler.scala:285)\n    at scala.collection.Iterator$class.foreach(Iterator.scala:742)\n    at scala.collection.AbstractIterator.foreach(Iterator.scala:1194)\n    at scala.collection.IterableLike$class.foreach(IterableLike.scala:72)\n    at scala.collection.mutable.Stack.foreach(Stack.scala:170)\n    at org.apache.spark.scheduler.DAGScheduler.org$apache$spark$scheduler$DAGScheduler$$getShuffleMapStage(DAGScheduler.scala:285)\n    at org.apache.spark.scheduler.DAGScheduler$$anonfun$visit$1$1.apply(DAGScheduler.scala:389)\n    at org.apache.spark.scheduler.DAGScheduler$$anonfun$visit$1$1.apply(DAGScheduler.scala:386)\n    at scala.collection.immutable.List.foreach(List.scala:381)\n    at org.apache.spark.scheduler.DAGScheduler.visit$1(DAGScheduler.scala:386)\n    at org.apache.spark.scheduler.DAGScheduler.getParentStages(DAGScheduler.scala:398)\n```\n\n\nI am running a local Spark node and start the JVM with the following options:\n\n```\n-Dspark.master=local -Dspark.local.dir=/home/phil/tmp/spark-tmp -Xms8g -Xmx8g\n```\n\n\nCan you help me understand why it has problem with this toy graph (201 nodes and 200 edges), but on the other hand can solve a realistic graph with multiple millions of edges in about 80 seconds? (In both examples, I use the same setup and configuration.)\n\nUPDATE:\n\nCan also be reproduced in the spark-shell:\n\n```\nimport org.apache.spark.graphx._\nimport org.apache.spark.graphx.lib._\n\nval graph = GraphLoader.edgeListFile(sc, \"input.graph\").cache()\nConnectedComponents.run(graph)\n```\n\n\nI created a bug report: SPARK-15042\n    ", "Answer": "\r\nAccording to SPARK-15042, the problem still exists in 2.1.0-snapshot.\n\nThe progress toward fixing the bug can be seen in SPARK-5484.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding second shortest path in a graph(With Backtracking)\r\n                \r\nI found a problem in LightOJ where the problem was to find the second shortest path in a graph from node 1 to node n(There are n nodes in the graph marked from 1 to n). Now, the problem stated that I can backtrack to find a second shortest path. One of the sample cases is like this:\n\n\nEdge from node 1 to 2, cost 100. \nEdge from node 2 to 3, cost 300.\nEdge from node 1 to 3, cost 50.\n\n\nThe answer for this test is 150, for this path 1->2->1->3.\nI am aware of Dijkstra algorithm. But I could not find anything on how to do this. I am sorry if this is and old topic but I when I googled it I could not find anything.\n\nUpdate: I read this question. Which algorithm can I use to find the next to shortest path in a graph?\nMy question is different from it because in this problem, I can use an edge twice. I am going from node 1 to 2 once, then coming back to 1. This using edge 1->2 twice. \n    ", "Answer": "\r\nI think this might work:\n\nMaintain two arrays: ```\nshortest[i]```\n and ```\nsec_shortest[i]```\n which denote the shortest and the second shortest path lengths of vertex ```\ni```\n respectively.\n\nNow, all you need is to modify the method in the ```\nupdate```\n part of Dijkstra's algorithm in a slightly different way:\n\n```\nfor v in adj(u):\n    if shortest[u] + cost(u, v) < shortest[v]:\n        sec_shortest[v] = shortest[v]\n        shortest[v] = shortest[u] + cost(u, v)\n    else if shortest[u] + cost(u, v) < sec_shortest[v]:\n            sec_shortest[v] = shortest[u] + cost(u, v)\n```\n\n\nIn the end, ```\nsec_shortest[i]```\n will contain the second shortest path length from the fixed source to vertex ```\ni```\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding first meeting point of paths in directed acyclic graph\r\n                \r\nI currently have a directed, acyclic graph with a single end vertex. Vertices are represented as objects with one or more references to vertices which they can direct to. I have the ability to find all of the paths of nodes from any given start to the end node where the path is represented as a list of node objects.\n\nNow, say for example I am examining a node which has more than one exit. I want to find the first node at which all paths from the current node meet.I could get every path to the end then iterate through the nodes of one path, then iterate through each other path until I find this node and if I don't find it then I go to the next node of path one. However, this seems horribly inefficient as I could have to check every node in every path the length of the first path number of times. Below is my solution. Is there a way to make this more efficient?\n\n```\nfor each (exitNode){\n    pathList.addAll(exitNode.getPathsToSink());\n}\nfor each (node in pathList(0)){\n    bool isMeetNode = true;\n    int i = 1;\n    while (i < pathList.size && isMeetNode){\n        i++\n        isMeetNode = pathList(i).contains(node)//checks each node in the path\n    }\n    if (isMeetNode){\n        return node;\n    }\n}\n```\n\n    ", "Answer": "\r\nAssign a positive flow to each edge of your subgraph. It's probably easiest to work with rational numbers. Start with your starting vertex being the source of flow 1. Divide evenly between out-edges. Work your way down to the sink.\n\nNow each vertex with a flow of 1 through it lies on all paths.  You only have to find one that is closest to the source \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "construct graph nodes and edges from points and paths\r\n                \r\nI have an xml file (openstreetmap exported file) that has two types of elements called node (it is not node of graph) and way (a path in graph). Each point has a 64-bit identifier and coordinate and each path has a 64-bit identifier and a list of points references. for example:\n\n```\n<node id=\"1\" lat=\"...\" lon=\"...\" />\n<node id=\"2\" lat=\"...\" lon=\"...\" />\n<node id=\"3\" lat=\"...\" lon=\"...\" />\n<node id=\"4\" lat=\"...\" lon=\"...\" />\n<node id=\"5\" lat=\"...\" lon=\"...\" />\n<node id=\"6\" lat=\"...\" lon=\"...\" />\n<node id=\"7\" lat=\"...\" lon=\"...\" />\n<node id=\"8\" lat=\"...\" lon=\"...\" />\n<node id=\"9\" lat=\"...\" lon=\"...\" />\n<node id=\"10\" lat=\"...\" lon=\"...\" />\n<node id=\"11\" lat=\"...\" lon=\"...\" />\n<node id=\"12\" lat=\"...\" lon=\"...\" />\n<node id=\"13\" lat=\"...\" lon=\"...\" />\n<node id=\"14\" lat=\"...\" lon=\"...\" />\n<way>\n    <nd ref=\"1\" />\n    <nd ref=\"2\" />\n    <nd ref=\"3\" />\n    <nd ref=\"4\" />\n    <nd ref=\"5\" />\n</way>\n<way>\n    <nd ref=\"6\" />\n    <nd ref=\"7\" />\n    <nd ref=\"2\" />\n    <nd ref=\"8\" />\n</way>\n<way>\n    <nd ref=\"9\" />\n    <nd ref=\"10\" />\n    <nd ref=\"4\" />\n    <nd ref=\"11\" />\n</way>\n<way>\n    <nd ref=\"6\" />\n    <nd ref=\"12\" />\n    <nd ref=\"9\" />\n    <nd ref=\"14\" />\n</way>\n<way>\n    <nd ref=\"5\" />\n    <nd ref=\"13\" />\n    <nd ref=\"14\" />\n</way>\n```\n\n\nHow can I structure the graph using the above data?\n\nFor above example, the output should be as follows:\n\n```\n<node id=\"1\" lat=\"...\" lon=\"...\" />\n<node id=\"2\" lat=\"...\" lon=\"...\" />\n<node id=\"4\" lat=\"...\" lon=\"...\" />\n<node id=\"8\" lat=\"...\" lon=\"...\" />\n<node id=\"9\" lat=\"...\" lon=\"...\" />\n<node id=\"11\" lat=\"...\" lon=\"...\" />\n<node id=\"14\" lat=\"...\" lon=\"...\" />\n<edge>\n     <n1 ref=\"1\" />\n     <n2 ref=\"2\" />\n</edge>\n<edge>\n     <n1 ref=\"2\" />\n     <n2 ref=\"4\" />\n</edge>\n<edge>\n     <n1 ref=\"2\" />\n     <n2 ref=\"9\" />\n</edge>\n<edge>\n     <n1 ref=\"2\" />\n     <n2 ref=\"8\" />\n</edge>\n<edge>\n     <n1 ref=\"4\" />\n     <n2 ref=\"11\" />\n</edge>\n<edge>\n     <n1 ref=\"4\" />\n     <n2 ref=\"9\" />\n</edge>\n<edge>\n     <n1 ref=\"4\" />\n     <n2 ref=\"9\" />\n</edge>\n```\n\n\nIs there a software or an algorithm that can solve this problem?\n\nthanks.\n    ", "Answer": "\r\nIf you're comfortable using Java, consider taking a look at Atlas. Atlas is an in memory representation of OSM data that will allow you to create a graph like the one you're describing above. It will also provide you with APIs for connectivity, routing and spatial searches.\n\nHere's a common pattern from our test implementation, that shows how to create an Atlas from a .osm file. Code snippet:\n\n```\npublic class TestAtlasTestRule extends CoreTestRule \n{\n    @TestAtlas(loadFromJosmOsmResource = \"yourOsmFile.osm\")\n    private Atlas yourAtlasFile;\n\n    public Atlas getAtlasFile()\n    {\n        return this.yourAtlasFile;\n    }\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to create relationships among similar/parallel paths in neo4j?\r\n                \r\nI'm looking for a way to batch create relationships among similar/parallel paths in neo4j. \n\nA sample graph may look like this:\n\n\n\nAs you can see, the pink node(the one in the center) ```\n:WRAPS```\n 3 yellow nodes, and each yellow node ```\n:WRAPS```\n 2 red nodes. I'm trying to create 3 ```\n:PARALLEL```\n relationship between each possible pair of 3 nodes. I tried this Cypher statement:\n\n```\nMATCH (pink:Slide)-[:WRAPS]->(yellow:GroupBox)-[:WRAPS*]->(red:Content)\nWHERE pink.uuid = \"ca7e1d47-1fbe-4008-9617-ef41c8a04316\"\nMATCH path = (yellow)-[rel]->(red)\nRETURN path\n```\n\n\nIt returns all yellow nodes and the associated red nodes. The graph looks like this:\n\n\n\nHowever, since path's class is ```\nPath```\n, not ```\nList```\n, I can't use unwind/foreach to loop through them. I also tried ```\nrelationships(path)```\n but it's returning a bunch of empty arrays. I intend to compare the length of and labels of nodes in each path, but can't find a way to do so. Could you help with it?\n    ", "Answer": "\r\nCreating your graph\n\nFor the ease of possible further answers and solutions I note my graph creating statement:\n\n```\nCREATE\n  // left bunch\n  (pink:PinkNode {name: '369'})-[:WRAPS]->(yellow1:YellowNode {name: '190'}),\n  (yellow1)-[:WRAPS]->(red1:RedNode {name: '201'}),\n  (yellow1)-[:WRAPS]->(red2:RedNode {name: '198'}),\n  (pink)-[:WRAPS]->(red1),\n  (pink)-[:WRAPS]->(red2),\n\n  // upper bunch\n  (pink)-[:WRAPS]->(yellow2:YellowNode {name: '195'}),\n  (yellow2)-[:WRAPS]->(red3:RedNode {name: '204'}),\n  (yellow2)-[:WRAPS]->(red4:RedNode {name: '208'}),\n  (pink)-[:WRAPS]->(red3),\n  (pink)-[:WRAPS]->(red4),\n\n  // lower bunch\n  (pink)-[:WRAPS]->(yellow3:YellowNode {name: '192'}),\n  (yellow3)-[:WRAPS]->(red5:RedNode {name: '208'}),\n  (yellow3)-[:WRAPS]->(red6:RedNode {name: '210'}),\n  (pink)-[:WRAPS]->(red5),\n  (pink)-[:WRAPS]->(red6),\n\n  // \"free\" red ones\n  (pink)-[:WRAPS]->(red7:RedNode {name: '255'}),\n  (pink)-[:WRAPS]->(red8:RedNode {name: '166'}),\n  (pink)-[:WRAPS]->(red9:RedNode {name: '264'}),\n  (pink)-[:WRAPS]->(red10:RedNode {name: '269'});\n```\n\n\nSolution\n\nAll possible relationships between your three nodes pairs you will achieve with the following Cypher statement:\n\n```\nCALL apoc.periodic.COMMIT('\nMATCH\n  (pink:PinkNode)-[:WRAPS]->(yellow:YellowNode)-[:WRAPS]->(red:RedNode)\nWITH yellow AS startNode, yellow AS endNode WHERE NOT (startNode)-[:PARALLEL]->(endNode) AND id(startNode) < id(endNode)\nCREATE (startNode)-[:PARALLEL]->(endNode)\nRETURN count(*)\n', {limit: 10000});\n```\n\n\nUnderlying Idea\n\nBased on the identification and selection of your three-nodes-pairs in line 3, I check in line 4 if your desired ```\n:PARALLEL```\n relationship already exists. If not, I create it (line 5). By means of the APOC library I rerun this statement until all relationships are created.\n\n\n  Especially for graph processing it is useful to run a query repeatedly\n  in separate transactions until it doesn’t process and generates any\n  results anymore. So you can iterate in batches over elements that\n  don’t fulfill a condition and update them so that they do afterwards.\n  \n  The query is executed repatedly in separate transactions until it\n  returns 0.\n\n\n(taken from Neo4j APOC procedure index at GitHub)\n\nThe id comparison in line 4 avoids having two relationships per pair (one in each direction) and prevents creating the relationship from nodes to themselves.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Dijkstra algorithm alternatives - shortest path in graph, bus routes\r\n                \r\ni am using slightly modified Dijkstra algorithm in my app but it`s quite slow and i know there have to be a lot better approach. My input data are bus stops with specified travel times between each other ( ~ 400 nodes and ~ 800 paths, max. result depth = 4 (max 4 bus changes or nothing). \n\nInput data (bus routes) :\n\n```\nbus_id | location-from | location-to | travel-time | calendar_switch_for_today\nXX | A | B | 12 | 1\nXX | B | C | 25 | 1\nYY | C | D | 5  | 1\nZZ | A | D | 15 | 0\n\ndijkstraResolve(A,D, '2012-10-10') -> (XX,A,B,12),(XX,B,C,25),(YY,C,D,5) \n=> one bus change, 3 bus stops to final destination\n* A->D cant be used as calendar switch is OFF\n```\n\n\nAs you can imagine, in more complicated graphs where e.g. main city(node) does have 170 connections to different cities is Dijkstra slower (~ more then 5 seconds) because compute all neighbours first one by one as it`s not \"trying\" to reach target destination by some other way...\n\nCould you recommend me any other algorithm which could fit well ? \n\nI was looking on :  \n\n\nhttp://xlinux.nist.gov/dads//HTML/bellmanford.html (is it faster ?)\nhttp://jboost.sourceforge.net/examples.html (i do not see\nstraightforward example here...)\n\n\nWould be great to have (just optional things) : \n- option to prefer minimal number of bus changes or minimal time\n- option to look on alternatives way (if travel time is similar)\n\nThank you for tips\n    ", "Answer": "\r\nSounds like you're looking for A*.  It's a variant of Djikstra's which uses a heuristic to speed up the search.  Under certain reasonable assumptions, A* is the fastest optimal algorithm.  Just make sure to always break ties towards the endpoint.\n\nThere are also variants of A* which can provide near-optimal paths in much shorter time.  See for example here and here.\n\n\n\nBellman-Ford (as suggested in your question) tends to be slower than either Djikstra's or A* - it is primarily used when there are negative edge-weights, which there are not here.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "print possible all path in graph in python using dictionaries\r\n                \r\ni try to make a graph program using python to print all possible path from x to y. i want to show all path from 9 to 29, but the program did not print it. maybe anyone can help to fixed it. here the code.\n```\ngraph =     {'0': ['3', '10','1'],\n             '1': ['10', '0','4'],\n             '2': ['8','6','3'],\n             '3': ['17','2','9','0'],\n             '4': ['1','5'],\n             '5': ['4','12','7'],\n             '6': ['17','2'],\n             '7': ['5','22'],\n             '8': ['13','2'],\n             '9': ['3','17','10'],\n             '10': ['9','17','0','1','11'],\n             '11': ['20','12'],\n             '12': ['5','11'],\n             '13': ['8','14','16'],\n             '14': ['13'],\n             '15': ['16','17'],\n             '16': ['13','15','17'],\n             '17': ['16','6','3','9','10','15','18','23','24'],\n             '18': ['17','25','19'],\n             '19': ['26','18','20'],\n             '20': ['28','19','21'],\n             '21': ['28','20','22'],\n             '22': ['7'],\n             '23': ['17','24'],\n             '24': ['17','23','27'],\n             '25': ['27','18','26'],\n             '26': ['25','19'],\n             '27': ['24','25','29'],\n             '28': ['29','20','21'],\n             '29': ['27','28']}\n\ndef find_path(graph, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        if start not in graph:\n            return None\n        for node in graph[start]:\n            if node not in path:\n                newpath = find_path(graph, node, end, path)\n                if newpath: return newpath\n        return None\nfind_path(graph,'9','29')\n```\n\ni'm not sure in part of method to find it. i need your opinion where did I go wrong?. thanks\n    ", "Answer": "\r\nIf you use ```\nnetworkx```\n package, the problem  become much more straightforward. Even if you do not want to use ```\nnetworkx```\n, you have the solution yet to fix your code.\n```\n# Python env: pip install networkx\n# Anaconda env: conda install network\nimport networkx as nx\n\nG = nx.from_dict_of_lists(graph)\nall_paths = nx.all_simple_paths(G, '9', '29'))\n\nfor path in all_paths:  # <- # 1060 paths!!!\n    print(path)\n```\n\n```\n['9', '3', '0', '10', '1', '4', '5', '12', '11', '20', '19', '18', '17', '23', '24', '27', '29']\n['9', '3', '0', '10', '1', '4', '5', '12', '11', '20', '19', '18', '17', '24', '27', '29']\n['9', '3', '0', '10', '1', '4', '5', '12', '11', '20', '19', '18', '25', '27', '29']\n['9', '3', '0', '10', '1', '4', '5', '12', '11', '20', '19', '26', '25', '18', '17', '23', '24', '27', '29']\n['9', '3', '0', '10', '1', '4', '5', '12', '11', '20', '19', '26', '25', '18', '17', '24', '27', '29']\n...\n['9', '10', '11', '12', '5', '7', '22', '21', '28', '20', '19', '18', '25', '27', '29']\n['9', '10', '11', '12', '5', '7', '22', '21', '28', '20', '19', '26', '25', '18', '17', '23', '24', '27', '29']\n['9', '10', '11', '12', '5', '7', '22', '21', '28', '20', '19', '26', '25', '18', '17', '24', '27', '29']\n['9', '10', '11', '12', '5', '7', '22', '21', '28', '20', '19', '26', '25', '27', '29']\n['9', '10', '11', '12', '5', '7', '22', '21', '28', '29']\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All shortest paths in a graph using K reverse edges\r\n                \r\nLet's say i have a directed graph G(V,E) with positive integer weights at it's edges.What i need to do is find the shortest paths between all vertices using at most K(integer) reverse edges.What i mean by that is:If we are at edge u and there is only a directed edge from v to u we can use it as long as we have not used K reverse edges for this path.This has to be implemented in C++ and give the shortest paths as a result.\n\nI thought about running dijkstra V times(something like Johnson's algorithm)but i am not sure how to take advantage of the reverse edge property.Any ideas?\n    ", "Answer": "\r\nThe common approach to problems like this is usually described as \"layering\".  You (conceptually) make K+1 copies of the graph, G0 to GK, and then connect a vertex ui in Gi to a vertex vi+1 in Gi+1 if there is an edge from v to u in G.\n\nA path from s0 in G0 to ti in Gi then represents a path from s to t in G that uses i reverse edges, where i is at most K.\n\nYou can just use Dijkstra's algorithm on this new layered graph.\n\nWhen you get used to this you can think about it in an even simpler way: you just use Dijkstra's algorithm, but instead of having states in the queue like [reached v, with cost c], you use states like [reached v, with cost c, having used i reverse edges].  Often, when we use Dijkstra's in real life, there is no actual graph given, so it helps to think of it as a search through states and their transitions.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All shortest paths in a graph using K reverse edges\r\n                \r\nLet's say i have a directed graph G(V,E) with positive integer weights at it's edges.What i need to do is find the shortest paths between all vertices using at most K(integer) reverse edges.What i mean by that is:If we are at edge u and there is only a directed edge from v to u we can use it as long as we have not used K reverse edges for this path.This has to be implemented in C++ and give the shortest paths as a result.\n\nI thought about running dijkstra V times(something like Johnson's algorithm)but i am not sure how to take advantage of the reverse edge property.Any ideas?\n    ", "Answer": "\r\nThe common approach to problems like this is usually described as \"layering\".  You (conceptually) make K+1 copies of the graph, G0 to GK, and then connect a vertex ui in Gi to a vertex vi+1 in Gi+1 if there is an edge from v to u in G.\n\nA path from s0 in G0 to ti in Gi then represents a path from s to t in G that uses i reverse edges, where i is at most K.\n\nYou can just use Dijkstra's algorithm on this new layered graph.\n\nWhen you get used to this you can think about it in an even simpler way: you just use Dijkstra's algorithm, but instead of having states in the queue like [reached v, with cost c], you use states like [reached v, with cost c, having used i reverse edges].  Often, when we use Dijkstra's in real life, there is no actual graph given, so it helps to think of it as a search through states and their transitions.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Java - Finding the shortest path in a graph\r\n                \r\nSo I'm attempting to implement Floyd Warshalls algorithm to find the shortest path in a graph. I'm reading in the values from a text file that looks like this:\n\n```\nLocation1 0 0 0 \nLocation2 5 0 0 \nLocation3 5 5 0 \nLocation4 0 5 0\n```\n\n\nAnd then I'd store these values in a hash table using this class:\nhttp://algs4.cs.princeton.edu/34hash/SeparateChainingHashST.java.html \n\nHere's what I have so far:\n\n```\npublic class Edge {\n\n    private String location;\n    private int point1;\n    private int point2;\n    private int point3;\n\n    public Edge( In in ) {\n        n = in.readInt();\n        this.location = location;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.point3 = point3;\n        int [][] G = new int [n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++){\n                G[i][j] = in.readInt();\n            }\n        }\n\n        int V = G.length;\n        int dist[][] = new int [V][V];\n\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n```\n\n\nThe problem is I am not sure if I am reading in the values correctly and I don't know how to store these values in a hash table and then put them in a 2d array to use with Warshall's algorithm. Here's my ```\nmain```\n method:\n\n```\n public static void main(String[] args) {\n      In in = new In( args[0] );\n      int T = in.readInt();\n      for (int t=1; t<=T; t++) {\n         System.out.println(\"Case \" + t + \":\") ;\n         Edge w = new Edge( in );\n         int Q = in.readInt();\n         for (int i=0; i<Q; i++) {\n            String p1s = in.readString();\n            String p2s = in.readString();\n         }\n      }\n   }\n}\n```\n\n\nAnd here's the ```\nIn```\n class:\nhttp://algs4.cs.princeton.edu/12oop/In.java.html\n    ", "Answer": "\r\nI recommend you use Djikstra's algorithm for finding shortest path.  Here's some pseudocode to implement it\n\n```\nfunction Dijkstra(Graph, source):\n\n      create vertex set Q\n\n      for each vertex v in Graph:             // Initialization\n          dist[v] ← INFINITY                  // Unknown distance from source to v\n          prev[v] ← UNDEFINED                 // Previous node in optimal path from source\n          add v to Q                          // All nodes initially in Q (unvisited nodes)\n\n      dist[source] ← 0                        // Distance from source to source\n\n      while Q is not empty:\n          u ← vertex in Q with min dist[u]    // Source node will be selected first\n          remove u from Q \n\n          for each neighbor v of u:           // where v is still in Q.\n              alt ← dist[u] + length(u, v)\n              if alt < dist[v]:               // A shorter path to v has been found\n                  dist[v] ← alt \n                  prev[v] ← u \n\n      return dist[], prev[]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest Partial Path in a Graph\r\n                \r\nI have a network that is defined by a matrix, where [i,j] element in the matrix is the cost of getting from node i to node j. If there is no path between i and j then [i,j] is Infinite.\n\nI fill up the matrix with the negative values, so that if the distance between i and j is short then I put very small value in [i,j], for example -50, if the distance is long I put bigger value, for example -5.\n\nI wonder how it's possible to find partial shortest path in network, the only constrains is the path should go in the predefined order, just like elements occur in matrix i,i+1,i+2,..\n\nfor simplified example,\n\n```\n╔═══╦═══╦═════╦═══╦═══╦═════╗\n║   ║ 1 ║  2  ║ 3 ║ 4 ║  5  ║\n╠═══╬═══╬═════╬═══╬═══╬═════╣\n║ 1 ║ 0 ║ -20 ║   ║   ║ -10 ║\n║ 2 ║   ║   0 ║   ║   ║     ║\n║ 3 ║   ║     ║ 0 ║   ║     ║\n║ 4 ║   ║     ║   ║ 0 ║ -50 ║\n║ 5 ║   ║     ║   ║   ║     ║\n╚═══╩═══╩═════╩═══╩═══╩═════╝\n```\n\n\nHere, the complete path form 1-to-5 equals -10, but if we take path 1-to-2 and then 4-to-5 we get better score -50, so here we skipped 3 and it's ok for partial path.\n\nSo the partial path - is a path that doesn't have to visit every node, it might be just short segment 1-to-2, bu the shortest partial path has to the shortest among all partial paths.\n\nThe constraint about the order is very simple, we always start searching path from node 1 and go in ascending order, so for all segments [i,j] [i1,j1] in the paths, j>i and i1>=j.\n\nI wonder if there is a good way to find best score partial path in the network,  I think exhaustive search is also good solution, the number of nodes is around 15-20.\n    ", "Answer": "\r\nYou basically have a Directed Acyclic Graph (DAG) here, and you are looking for a longest path in it, according to ```\nw(u,v)```\n - where ```\nw(u,v)```\n is the positive weight of each connection (edge). If there is no edge between ```\nu```\n to ```\nv```\n we'll denote it's weight with negative infinity: ```\nw(u,v)=-infinity```\n.\n\nThe graph is ```\nG=(V,E)```\n where ```\nV```\n is a set containing all your nodes, and ```\nE = { (u,v,w(u,v) | u<v}```\n is the edges set.\n\nIn general, Longest Path Problem is NP-Complete. Fortunately, your problem is a DAG, and there is an efficient Dynamic Programming solution to it. First topologically sort the nodes, and then - from last to first:\n\n```\nd(v) = max { d(u) + w(v,u) | for all edges (v,u) }\n```\n\n\nWhen you are done, for each node ```\nv```\n d(v) will denote the longest path that starts with this node, you will only have to find the maximal value out of these to get the desired node and maximal value.\n\nYou can reconstruct the path later on by:\n\n```\nv <- startNode //the node just found to be starting the desired path\nlist <- [v]\nwhile (d(v) != 0):\n   for each edge (v,u):\n        if d(v) - w(v,u) == d(u):\n             list.append(u)\n             break\nreturn list\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Optimal solution for: All possible acyclic paths in a graph problem\r\n                \r\nI am dealing with undirected graph. I need to find all possible acyclic paths within a graph:\n\n```\nwith G(V,E)\nfind all subsets of V that are acyclic paths\n```\n\n\nI am using either python scipy or matlab - whichever would be appropriate.\nIs there any clever solution for this?\n\nI'm trying to achieve it with a breadth-first search (see wiki)\n\nI also have this toolbox in matlab: http://www.mathworks.com/matlabcentral/fileexchange/4266-grtheory-graph-theory-toolbox but it seems there's no straightforward solution for my problem.\n\nPS. The problem practically is stated as: Transit Network Design Problem: Find such a transport network that minimizes cost of passangers and operators (i.e. optimal subway network for urban area)\n\nThanks in advance\nRafal\n    ", "Answer": "\r\nI think the problem as stated in your PS may be a NP problem. If so, there are straightforward solutions only for graphs with very limited numbers of nodes (N ~ <= 20). Other solutions will be approximate, giving rise to only local optimums. The solution to your problem as stated in the question will simply be to calculate all the permutations of the node orders. Again this will become computationally infeasible with comparatively low numbers of nodes (possibly higher than 20 but not much).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding minimal paths that cover all edges at least once in directed graphs with cycles\r\n                \r\nI have a graph that's finite, directed, and strongly connected. I'd like to find paths of minimal length through this graph that visit every edge at least once.\nIs there an isomorphism between this problem and any \"standard\" problem such as Travelling Salesman or finding Eulerian Paths in undirected graphs?\n    ", "Answer": "\r\nThis is a well known problem, called the Route inspection problem, (also often called the \"Chinese Postman Problem\" in the literature) which in the general case finds a minimum length closed walk on an undirected graph that visits every edge at least once. This can be done in polynomial time; your specific problem asks for a strongly connected directed graph solution that does not need to return to its starting point (i.e. an open walk).\nThere are a few papers describing algorithms for the directed, closed walk problem based on reductions from Eulerian Tours, or from Minimum-cost flow problems, which result in O(|V|^3) solutions. This paper on the directed Chinese postman problem gives full Java code for both the open and closed walk version, and gives the basic idea for how they modified the closed walk program for the open walk variant:\n\nImagine that the optimal open solution starts at vertex u and finishes at v. The open solution\ncan be obtained from a closed solution, found by introducing a new ‘virtual’ arc (v,u), provided\nthe cost associated with this arc is so high that it is used only once in the closed tour\n\nThe paper does not mention the runtime of the algorithm beyond it being polynomial; however the closed walk version is O(n^3), and the open version is O(n^5). A lot of the complexity comes from how general the algorithm is: it can handle multiple edges and real numbered weights (including some negative edges), so more specific problems can be solved more efficiently. The start of the paper also gives a link to the author's website with a Mathematica implementation.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Floyd Warshall (all-pairs shortest paths) on weighted undirected graph - Boost Graph\r\n                \r\nI'm having some trouble with Floyd Warshall (all pairs shortest paths) in Boost graph. Is there any way to directly provide a directed weighted graph to ```\nfloyd_warshall_all_pairs_shortest_paths```\n? It seems like all its function overloadings require some extra parameters which I don't completely understand. Following is a test code I'm writing (it would not compile because my call to ```\nfloyd_warshall_all_pairs_shortest_paths```\n is incomplete)\n\n```\n#include <iostream>\n\n#include <map>\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/graph/floyd_warshall_shortest.hpp>\n\ntypedef boost::property<boost::edge_weight_t, double> EdgeWeightProperty;\ntypedef boost::adjacency_list<boost::vecS, boost::vecS, \n                              boost::undirectedS, boost::no_property, \n                              EdgeWeightProperty> Graph;\ntypedef unsigned long t_indx;\n\nint main()\n{\n  typedef boost::graph_traits<Graph>::vertex_descriptor vertex_des;\n  std::map<vertex_des, std::map<vertex_des, int> > matrix;\n  Graph sp_graph;\n\n  int edgelet_sp[] = { 1,     2,\n                       1,     3,\n                       1,     4,\n                       2,     5,\n                       3,     4,\n                       3,     6,\n                       4,     5,\n                       4,     6,\n                       4,     7,\n                       5,     7,\n                       6,     7 };\n  double edgelet_vals[] = {  4,\n                            10,\n                             3,\n                             1,\n                            12,\n                            20,\n                             6,\n                             3,\n                             0,\n                             3,\n                             9};\n  int num_edges = 11;\n\n  /* make the superpixel graph */\n  for (t_indx i = 0; i < num_edges; ++i) {\n    add_edge(edgelet_sp[i]-1, edgelet_sp[i+num_edges]-1, edgelet_vals[i], sp_graph);\n  }\n\n  std::cout << num_vertices(sp_graph) << std::endl;\n\n  bool floyd2 =\n        boost::floyd_warshall_all_pairs_shortest_paths\n          (sp_graph, matrix);\n  return 0;\n}\n```\n\n\nI'm new to BGL so any help would be much appreciated. For instance, are there more elegant ways to write this code (sans the declaration of ```\nedgelet_sps```\n and ```\nedgelet_vals```\n, both of which will be replaced)? Thanks.\n    ", "Answer": "\r\nI figured (with the help of the inter-webs) that I need to use ```\nboost::get(boost::edge_weight, g)```\n to directly supply an undirected weighted graph to floyd warshall. The following code compiles and works (here is a figure of the graph for the example below)\n\n```\n#include <iostream>\n#include <boost/graph/undirected_graph.hpp>\n#include <boost/graph/exterior_property.hpp>\n#include <boost/graph/floyd_warshall_shortest.hpp>\n\n// type for weight/distance on each edge\ntypedef double t_weight;\n\n// define the graph type\ntypedef boost::property<boost::edge_weight_t, t_weight> EdgeWeightProperty;\ntypedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS, \n                              boost::no_property, EdgeWeightProperty> Graph;\n\ntypedef boost::property_map<Graph, boost::edge_weight_t>::type WeightMap;\n\n// Declare a matrix type and its corresponding property map that\n// will contain the distances between each pair of vertices.\ntypedef boost::exterior_vertex_property<Graph, t_weight> DistanceProperty;\ntypedef DistanceProperty::matrix_type DistanceMatrix;\ntypedef DistanceProperty::matrix_map_type DistanceMatrixMap;\n\n\nint main()\n{\n  Graph g;\n\n  const int num_edges = 11;\n\n  // define edges\n  int edges[] = { 1,     2,\n                  1,     3,\n                  1,     4,\n                  2,     5,\n                  3,     4,\n                  3,     6,\n                  4,     5,\n                  4,     6,\n                  4,     7,\n                  5,     7,\n                  6,     7 };\n\n  // define the weight on edges\n  t_weight weight[] = {  4,\n                        10,\n                         3,\n                         1,\n                        12,\n                        20,\n                         6,\n                         3,\n                         0,\n                         3,\n                         9 };\n\n  // iterate over all edges and insert them in the graph\n  for (std::size_t k = 0; k < num_edges; ++k)\n    boost::add_edge(edges[k*2]-1, edges[k*2+1]-1, weight[k], g);\n\n  WeightMap weight_pmap = boost::get(boost::edge_weight, g);\n\n  // set the distance matrix to receive the floyd warshall output\n  DistanceMatrix distances(num_vertices(g));\n  DistanceMatrixMap dm(distances, g);\n\n  // find all pairs shortest paths\n  bool valid = floyd_warshall_all_pairs_shortest_paths(g, dm, \n                                            boost::weight_map(weight_pmap));\n\n  // check if there no negative cycles\n  if (!valid) {\n    std::cerr << \"Error - Negative cycle in matrix\" << std::endl;\n    return -1;\n  }\n\n  // print upper triangular part of the distance matrix\n  std::cout << \"Distance matrix: \" << std::endl;\n  for (std::size_t i = 0; i < num_vertices(g); ++i) {\n    for (std::size_t j = i; j < num_vertices(g); ++j) {\n      std::cout << \"From vertex \" << i+1 << \" to \" << j+1 << \" : \";\n      if(distances[i][j] == std::numeric_limits<t_weight>::max())\n        std::cout << \"inf\" << std::endl;\n      else\n        std::cout << distances[i][j] << std::endl;\n    }\n    std::cout << std::endl;\n  }\n\n  return 0;\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find the Minimum Variance Path in Directed Acyclic graph\r\n                \r\nGiven a DAG, in which every node has a numeric value. I would like to obtain the path through the graph which has the minimum variance in the value of the nodes.\n\nTo recap, which is the best algorithm to find the minimum variance path in a Directed Acyclic Path?\n\nThanks, Piero\n    ", "Answer": "\r\nFrom the paper: \"Routing with Confidence: A Model for Trustworthy Communication\"\n\nDefinition 6.7. Minimum Variance Simple-Path Problem (MVSPP) : Given a graph G = (V, E), with positive vertex weights w(v) for each vertex v ∈ V , and nonadjacent vertices s, t ∈ V , find an s, t -path p that minimizes the variance of weights for the set of vertices in p .\n\nWe assume that s, t are not directly connected by a single edge, because then the solution is trivial. The path 〈s, t〉 has variance 0 and is the minimum variance path.\n\nTheorem 6.8. The Minimum Variance Simple-Path Problem (MVSPP) is NP- hard.\n\nThis is what i found out... I think that this answers my question.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to get the shortest path in a weighted graph with NetworkX?\r\n                \r\nI'm trying to get the shortest path in a weighted graph defined as\n```\nimport networkx as nx\nimport matplotlib.pyplot as plt\ng = nx.Graph()\ng.add_edge(131,673,weight=673)\ng.add_edge(131,201,weight=201)\ng.add_edge(673,96,weight=96)\ng.add_edge(201,96,weight=96)\nnx.draw(g,with_labels=True,with_weight=True)\nplt.show()\n```\n\nto do so I use\n```\nnx.shortest_path(g,source=131,target=96)\n```\n\nThe expected answer is 131,201,96 because for that path I have the least sum of weights. I'm getting 131,673,96 instead. I tried changing the weights but ```\nshortest_path```\n always returns the longest path apparently. What is going on?\n    ", "Answer": "\r\nfrom the documentation of nx.shortest_path:\n\n\n```\nshortest_path(G, source=None, target=None, weight=None, method='dijkstra')[source]\nCompute shortest paths in the graph.\n\nParameters\nG (NetworkX graph)\n\nsource (node, optional) – Starting node for path. If not specified, compute shortest paths for each possible starting node.\n\ntarget (node, optional) – Ending node for path. If not specified, compute shortest paths to all possible nodes. \n```\n\n  \n  >     weight \n  (None or string, optional (default = None)) – If None, every edge has weight/distance/cost 1. If a string, use this edge\n      attribute as the edge weight. Any edge attribute not present defaults\n      to 1.\n\n```\nmethod (string, optional (default = ‘dijkstra’)) – The algorithm to use to compute the path. Supported options: ‘dijkstra’,\n```\n\n\n\n(emphasis mine)\n\nIf you do not explictly state that you want to find the shortest weighted path (by specifying the ```\nweight```\nargument), all weights are taken to be one. \n\nTo fix your problem, do:\n\n```\nprint(nx.shortest_path(g,source=131,target=96, weight='weight'))\n```\n\n\noutput:\n\n```\n[131, 201, 96]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all possible paths in a fully connected graph in python\r\n                \r\nI have a fully connected graph as shown below:\n\n```\ngraph = {'A': set(['B','C','D','E']),\n         'B': set(['A','C','D','E']),\n         'C': set(['A','B','D','E']),\n         'D': set(['A','B','C','E']),\n         'E': set(['A','B','C','E'])}\n```\n\n\nI want to be able to find ALL the possible paths from the start node to the goal node using a DFS and BFS algorithm. I wrote two functions out to do it. Here's the code:\n\n```\ndef dfs_paths(graph, start, goal):\n    stack = [(start, [start])]\n    while stack:\n        (vertex, path) = stack.pop()\n        for next in graph[vertex] - set(path):\n            if next == goal:\n                yield path + [next]\n            else:\n                stack.append((next, path + [next]))\n```\n\n\nThis should return all possible paths and if I write\n\n```\nlist(dfs_paths(graph, 'A', 'A')\n```\n\n\nI should get the output:\n\n```\n[['A',B,'A'],['A','B','C',A'],['A','B','C','D','A']...['A','E','D','C','B','A']]\n```\n\n\nBut what I am getting is an empty list\n\n```\n[]\n```\n\n\nThe same occurs for my BFS algorithm below\n\n```\ndef bfs_paths(graph, start, goal):\n    queue = [(start, [start])]\n    while queue:\n        (vertex, path) = queue.pop(0)\n        for next in graph[vertex] - set(path):\n            if next == goal:\n                yield path + [next]\n            else:\n                queue.append((next, path + [next]))\n```\n\n\nAny help would be greatly appreciated.\n    ", "Answer": "\r\nI think you a missing a logical step near ```\nstack.pop()```\n. If you add a few statements for inspecting your code you can learn a lot about what happens:\n\n```\ndef dfs_paths(graph, start, goal):\n    wstep, forstep = 0,0\n    stack = [(start, [start])]\n    while stack:\n        wstep+=1\n        print(\"{}:{} before (vertex, path) = stack.pop():{}\".format(wstep, forstep, stack))\n        (vertex, path) = stack.pop()\n        print(\"{}:{} after (vertex, path) = stack.pop(): {}\".format(wstep, forstep, stack))\n        forstep=0\n        for next in graph[vertex] - set(path):\n            forstep+=1\n            if next == goal:\n                yield path + [next]\n            else:\n                stack.append((next, path + [next]))\n                print(\"{}:{} after stack.append((next, path + [next])):{}\".format(wstep, forstep, stack))\n\ngraph = {'A': set(['B','C','D','E']),\n         'B': set(['A','C','D','E']),\n         'C': set(['A','B','D','E']),\n         'D': set(['A','B','C','E']),\n         'E': set(['A','B','C','E'])}\n\nlist(dfs_paths(graph=graph, start='A', goal='A'))\n```\n\n\nThese modest changes produce a neat output so that you can see what the state is before an after certain operations. Here is the output if you do that.\n\nThe first number shows what iteration of the ```\nwhile loop```\n you're in. The second shows what iteration of the ```\nfor loop```\n you've reached. The rest is copied from your code.\n\n```\n1:0 before (vertex, path) = stack.pop():[('A', ['A'])]\n1:0 after (vertex, path) = stack.pop(): []\n1:1 after stack.append((next, path + [next])):[('D', ['A', 'D'])]\n1:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B'])]\n1:3 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E'])]\n1:4 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('C', ['A', 'C'])]\n2:4 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('C', ['A', 'C'])]\n2:4 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E'])]\n2:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D'])]\n2:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B'])]\n2:3 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B']), ('E', ['A', 'C', 'E'])]\n3:3 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B']), ('E', ['A', 'C', 'E'])]\n3:3 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B'])]\n3:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B']), ('B', ['A', 'C', 'E', 'B'])]\n4:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B']), ('B', ['A', 'C', 'E', 'B'])]\n4:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B'])]\n4:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B']), ('D', ['A', 'C', 'E', 'B', 'D'])]\n5:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B']), ('D', ['A', 'C', 'E', 'B', 'D'])]\n5:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B'])]\n6:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('B', ['A', 'C', 'B'])]\n6:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D'])]\n6:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('D', ['A', 'C', 'B', 'D'])]\n6:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('D', ['A', 'C', 'B', 'D']), ('E', ['A', 'C', 'B', 'E'])]\n7:2 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('D', ['A', 'C', 'B', 'D']), ('E', ['A', 'C', 'B', 'E'])]\n7:2 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('D', ['A', 'C', 'B', 'D'])]\n8:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('D', ['A', 'C', 'B', 'D'])]\n8:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D'])]\n8:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('E', ['A', 'C', 'B', 'D', 'E'])]\n9:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D']), ('E', ['A', 'C', 'B', 'D', 'E'])]\n9:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D'])]\n10:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('D', ['A', 'C', 'D'])]\n10:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E'])]\n10:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('B', ['A', 'C', 'D', 'B'])]\n10:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('B', ['A', 'C', 'D', 'B']), ('E', ['A', 'C', 'D', 'E'])]\n11:2 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('B', ['A', 'C', 'D', 'B']), ('E', ['A', 'C', 'D', 'E'])]\n11:2 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('B', ['A', 'C', 'D', 'B'])]\n11:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('B', ['A', 'C', 'D', 'B']), ('B', ['A', 'C', 'D', 'E', 'B'])]\n12:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('B', ['A', 'C', 'D', 'B']), ('B', ['A', 'C', 'D', 'E', 'B'])]\n12:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('B', ['A', 'C', 'D', 'B'])]\n13:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('B', ['A', 'C', 'D', 'B'])]\n13:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E'])]\n13:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('E', ['A', 'C', 'D', 'B', 'E'])]\n14:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E']), ('E', ['A', 'C', 'D', 'B', 'E'])]\n14:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E'])]\n15:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('E', ['A', 'E'])]\n15:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B'])]\n15:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B'])]\n15:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('C', ['A', 'E', 'C'])]\n16:2 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('C', ['A', 'E', 'C'])]\n16:2 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B'])]\n16:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('D', ['A', 'E', 'C', 'D'])]\n16:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('D', ['A', 'E', 'C', 'D']), ('B', ['A', 'E', 'C', 'B'])]\n17:2 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('D', ['A', 'E', 'C', 'D']), ('B', ['A', 'E', 'C', 'B'])]\n17:2 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('D', ['A', 'E', 'C', 'D'])]\n17:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('D', ['A', 'E', 'C', 'D']), ('D', ['A', 'E', 'C', 'B', 'D'])]\n18:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('D', ['A', 'E', 'C', 'D']), ('D', ['A', 'E', 'C', 'B', 'D'])]\n18:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('D', ['A', 'E', 'C', 'D'])]\n19:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('D', ['A', 'E', 'C', 'D'])]\n19:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B'])]\n19:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('B', ['A', 'E', 'C', 'D', 'B'])]\n20:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B']), ('B', ['A', 'E', 'C', 'D', 'B'])]\n20:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B'])]\n21:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('B', ['A', 'E', 'B'])]\n21:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B'])]\n21:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('D', ['A', 'E', 'B', 'D'])]\n21:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('D', ['A', 'E', 'B', 'D']), ('C', ['A', 'E', 'B', 'C'])]\n22:2 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('D', ['A', 'E', 'B', 'D']), ('C', ['A', 'E', 'B', 'C'])]\n22:2 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('D', ['A', 'E', 'B', 'D'])]\n22:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('D', ['A', 'E', 'B', 'D']), ('D', ['A', 'E', 'B', 'C', 'D'])]\n23:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('D', ['A', 'E', 'B', 'D']), ('D', ['A', 'E', 'B', 'C', 'D'])]\n23:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B']), ('D', ['A', 'E', 'B', 'D'])]\n24:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('D', ['A', 'E', 'B', 'D'])]\n24:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B'])]\n24:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('B', ['A', 'B']), ('C', ['A', 'E', 'B', 'D', 'C'])]\n25:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B']), ('C', ['A', 'E', 'B', 'D', 'C'])]\n25:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('B', ['A', 'B'])]\n26:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('B', ['A', 'B'])]\n26:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D'])]\n26:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('D', ['A', 'B', 'D'])]\n26:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E'])]\n26:3 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E']), ('C', ['A', 'B', 'C'])]\n27:3 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E']), ('C', ['A', 'B', 'C'])]\n27:3 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E'])]\n27:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E']), ('D', ['A', 'B', 'C', 'D'])]\n27:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E']), ('D', ['A', 'B', 'C', 'D']), ('E', ['A', 'B', 'C', 'E'])]\n28:2 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E']), ('D', ['A', 'B', 'C', 'D']), ('E', ['A', 'B', 'C', 'E'])]\n28:2 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E']), ('D', ['A', 'B', 'C', 'D'])]\n29:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E']), ('D', ['A', 'B', 'C', 'D'])]\n29:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E'])]\n29:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E']), ('E', ['A', 'B', 'C', 'D', 'E'])]\n30:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E']), ('E', ['A', 'B', 'C', 'D', 'E'])]\n30:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E'])]\n31:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('E', ['A', 'B', 'E'])]\n31:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('D', ['A', 'B', 'D'])]\n31:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('C', ['A', 'B', 'E', 'C'])]\n32:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('C', ['A', 'B', 'E', 'C'])]\n32:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('D', ['A', 'B', 'D'])]\n32:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('D', ['A', 'B', 'E', 'C', 'D'])]\n33:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('D', ['A', 'B', 'D']), ('D', ['A', 'B', 'E', 'C', 'D'])]\n33:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('D', ['A', 'B', 'D'])]\n34:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('D', ['A', 'B', 'D'])]\n34:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D'])]\n34:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('E', ['A', 'B', 'D', 'E'])]\n34:2 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('E', ['A', 'B', 'D', 'E']), ('C', ['A', 'B', 'D', 'C'])]\n35:2 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('E', ['A', 'B', 'D', 'E']), ('C', ['A', 'B', 'D', 'C'])]\n35:2 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('E', ['A', 'B', 'D', 'E'])]\n35:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('E', ['A', 'B', 'D', 'E']), ('E', ['A', 'B', 'D', 'C', 'E'])]\n36:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('E', ['A', 'B', 'D', 'E']), ('E', ['A', 'B', 'D', 'C', 'E'])]\n36:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D']), ('E', ['A', 'B', 'D', 'E'])]\n37:0 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('E', ['A', 'B', 'D', 'E'])]\n37:0 after (vertex, path) = stack.pop(): [('D', ['A', 'D'])]\n37:1 after stack.append((next, path + [next])):[('D', ['A', 'D']), ('C', ['A', 'B', 'D', 'E', 'C'])]\n38:1 before (vertex, path) = stack.pop():[('D', ['A', 'D']), ('C', ['A', 'B', 'D', 'E', 'C'])]\n38:1 after (vertex, path) = stack.pop(): [('D', ['A', 'D'])]\n39:0 before (vertex, path) = stack.pop():[('D', ['A', 'D'])]\n39:0 after (vertex, path) = stack.pop(): []\n39:1 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B'])]\n39:2 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E'])]\n39:3 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('C', ['A', 'D', 'C'])]\n40:3 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('C', ['A', 'D', 'C'])]\n40:3 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E'])]\n40:1 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('B', ['A', 'D', 'C', 'B'])]\n40:2 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('B', ['A', 'D', 'C', 'B']), ('E', ['A', 'D', 'C', 'E'])]\n41:2 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('B', ['A', 'D', 'C', 'B']), ('E', ['A', 'D', 'C', 'E'])]\n41:2 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('B', ['A', 'D', 'C', 'B'])]\n41:1 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('B', ['A', 'D', 'C', 'B']), ('B', ['A', 'D', 'C', 'E', 'B'])]\n42:1 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('B', ['A', 'D', 'C', 'B']), ('B', ['A', 'D', 'C', 'E', 'B'])]\n42:1 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('B', ['A', 'D', 'C', 'B'])]\n43:0 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('B', ['A', 'D', 'C', 'B'])]\n43:0 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E'])]\n43:1 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('E', ['A', 'D', 'C', 'B', 'E'])]\n44:1 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E']), ('E', ['A', 'D', 'C', 'B', 'E'])]\n44:1 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E'])]\n45:0 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('E', ['A', 'D', 'E'])]\n45:0 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B'])]\n45:1 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('B', ['A', 'D', 'E', 'B'])]\n45:2 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('B', ['A', 'D', 'E', 'B']), ('C', ['A', 'D', 'E', 'C'])]\n46:2 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('B', ['A', 'D', 'E', 'B']), ('C', ['A', 'D', 'E', 'C'])]\n46:2 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B']), ('B', ['A', 'D', 'E', 'B'])]\n46:1 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('B', ['A', 'D', 'E', 'B']), ('B', ['A', 'D', 'E', 'C', 'B'])]\n47:1 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('B', ['A', 'D', 'E', 'B']), ('B', ['A', 'D', 'E', 'C', 'B'])]\n47:1 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B']), ('B', ['A', 'D', 'E', 'B'])]\n48:0 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('B', ['A', 'D', 'E', 'B'])]\n48:0 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B'])]\n48:1 after stack.append((next, path + [next])):[('B', ['A', 'D', 'B']), ('C', ['A', 'D', 'E', 'B', 'C'])]\n49:1 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B']), ('C', ['A', 'D', 'E', 'B', 'C'])]\n49:1 after (vertex, path) = stack.pop(): [('B', ['A', 'D', 'B'])]\n50:0 before (vertex, path) = stack.pop():[('B', ['A', 'D', 'B'])]\n50:0 after (vertex, path) = stack.pop(): []\n50:1 after stack.append((next, path + [next])):[('E', ['A', 'D', 'B', 'E'])]\n50:2 after stack.append((next, path + [next])):[('E', ['A', 'D', 'B', 'E']), ('C', ['A', 'D', 'B', 'C'])]\n51:2 before (vertex, path) = stack.pop():[('E', ['A', 'D', 'B', 'E']), ('C', ['A', 'D', 'B', 'C'])]\n51:2 after (vertex, path) = stack.pop(): [('E', ['A', 'D', 'B', 'E'])]\n51:1 after stack.append((next, path + [next])):[('E', ['A', 'D', 'B', 'E']), ('E', ['A', 'D', 'B', 'C', 'E'])]\n52:1 before (vertex, path) = stack.pop():[('E', ['A', 'D', 'B', 'E']), ('E', ['A', 'D', 'B', 'C', 'E'])]\n52:1 after (vertex, path) = stack.pop(): [('E', ['A', 'D', 'B', 'E'])]\n53:0 before (vertex, path) = stack.pop():[('E', ['A', 'D', 'B', 'E'])]\n53:0 after (vertex, path) = stack.pop(): []\n53:1 after stack.append((next, path + [next])):[('C', ['A', 'D', 'B', 'E', 'C'])]\n54:1 before (vertex, path) = stack.pop():[('C', ['A', 'D', 'B', 'E', 'C'])]\n54:1 after (vertex, path) = stack.pop(): []\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Matching paths to graph using branch & bound\r\n                \r\nI am working on an approximate matching problem, where I have a set of paths in an unknown graph (A) and a partial graph (B), where B is incrementally generated and growing.\n\nThe problem is to match the edges in the paths to the graph B, while preserving the ordering of edges across the paths & graph. In my problem, the graph nodes are immaterial and the edges have non-unique labels upon which matching is performed. Also, the paths to be matched can have arbitrary edges added/deleted while matching is to the graph B. If I am not satisfied with the current solution, I can query an oracle, that gives me a more complete (bigger) graph (that's what I mean by growing) but I want to minimize the queries as the graph can potentially be infinite.\n    ", "Answer": "\r\nI tried to lookup standard solutions from assignment and graph isomorphism but didn’t find anything similar. So, here is a solution I came up with:\n\n\nI am using a branch and bound algorithm to match every edge in the paths to every edge in the graph (M X N table). For each possible assignment, I am keeping track of which other assignments are possible containing with the particular assignment\nThe bounding condition (& feasibility) is defined by the same ordering of the edges in the graph as it is in the paths. Also, two paths cannot be mapped such that they violate each others ordering.\nIf we are not happy with this solution, we can query the oracle, get a bigger graph and repeat 1 & 2. Otherwise, the technique outputs the possible edge mappings.\n\n\nI am not sure if my solution still falls under branch & bound algorithms, as it no longer follows the standard branch & bound tree structure. Also, it would be great if anyone can point out optimizations or a better way to do this.\n\nNote: At every iteration, N changes and the table grows horizontally. The biggest inefficiency is in step #2, which needs to be recomputed at every stage for safety (e.g., a loop being added in the graph invalidates previous solutions)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Determine the Longest Unidirectional Path in a Directed Disconnected Graph\r\n                \r\nI have a directed disconnected graph in which some vertices (nodes) can be connected by multiple unidirectional relationships of different types. It is possible that the graph has loops.\n\nHow can I determine the length of the longest unidirectional path in my graph? I have been trying the following query with no success:\n\n```\nSTART n=node(*)\nMATCH p=n<-[rels]-m \nWITH COLLECT(p) AS paths, MAX(length(p)) AS maxLength \nRETURN FILTER(path IN paths \n  WHERE length(path)= maxLength) AS longestPaths\n```\n\n\nThanks in advance,\n    ", "Answer": "\r\nWhat about:\n\n```\nMATCH p=(n)<-[:RELTYPE*]-(m)\nRETURN length(p)\nORDER BY LENGTH(p) DESC\nLIMIT 1\n```\n\n\nBe aware that this kind of query might be expensive depending the structure and size of your graph.\n\nFor Neo4j 1.9 use:\n\n```\nSTART n=node(*)\nMATCH p=(n)<-[:RELTYPE*]-(m)\nRETURN length(p)\nORDER BY LENGTH(p) DESC\nLIMIT 1\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find path between two nodes in graph, according to given criteria - optimization task\r\n                \r\nI have the following problem. I have cyclic, undirected, weighted graph G=(V,E). I need to find the simple path (without cycles) between two given nodes according to these rules:\n\n\nFinding minimal weight value in edges set of each possible path\nSelect this path, which has maximal min value among selected minimal values from found paths\n\n\nE.g we have graph presented below:\n\n\n\nWe can try to find simple path from node 1 to node 8. There are two possible pathes, listed below:\n\n\n1 -> 3 -> 5 -> 8, minimal edge weight on this path is 2\n1 -> 3 -> 5 -> 6 -> 7 -> 8, minimal edge weight on this path is 283\n\n\nAccording to presented criteria, wanted path is path number 2, because it has greater minimal value, than path no 1.\n\nOne important assumption: the number of nodes in graph are very small: less than 15.\n\nI thought about Dijkstra or Bellman-Ford algorithm modification, but the challenge is, that we don't have local criteria (the min distance) - we cannot find minimal weight of edge, until we don't obtain whole path...\n\nMy second think was to use modification of Nearest-Neighbor algorithm, but it's used for solving so called travelling salesman problem, which is a little different case comparing to mine.\n\nMy question is following. Is it better way to solve this problem, than use Depth-First Algorithm to obtain all direct acyclic simple paths between two given nodes and next select max value of min weight values of each found path?\n\nIn such case I'm a little worried about complexity of DFS algorithm, especially due to recursion and number of possible connections (edges) in graph.\n\nThank you for any ideas.\n    ", "Answer": "\r\nUse binary search on the minimal edge weight:\n\nAssume your search interval is ```\n[m, M]```\n. For a set value ```\nL = (m + M) / 2```\n, use BFS or DFS to find a path from ```\nsource```\n to ```\ndestination```\n such that all edges have weight ```\n>= L```\n. If you can do this, set ```\nm = L + 1```\n and repeat the search. If you cannot do this, set ```\nM = L - 1```\n and repeat the search.\n\nThis will be ```\nO((edges + nodes) log maxEdgeWeight)```\n. Should be very fast for your small number of nodes.\n\nNote that there is a way to do it without the log factor as well, by using the ideas of Dijkstra's algorithm and counting sort. But you definitely do not need this for so few nodes.\n\nUpdate 1:\n\nHere is how this would work on your example. First of all, your search interval will be ```\n[2, 9000]```\n, since these are your min and max edge weights, respectively.\n\n```\nL = (2 + 9000) / 2 = 4501\n=> Find a path from 1 to 8 such that all of its edges have weight >= 4501.\n   This is not possible, so reduce the search interval to [2, 4500].\n\nL = (2 + 4501) / 2 = 2251\n=> Find a path from 1 to 8 such that all of its edges have weight >= 2251.\n   This is not possible, reduce the search interval to [2, 2250]\n\nL = (2 + 2250) / 2 = 1126\n=> Not possible to find a path, reduce to [2, 1125]\n\nL = (2 + 1125) / 2 = 563\n=> Not possible, reduce to [2, 562]\n\nL = (2 + 562) / 2 = 282\n=> Success! We can find 1 -> 3 -> 5 -> 6 -> 7 -> 8\nMark 282 as the current best answer, and keep searching in [283, 562].\n```\n\n\nEventually, you will be left with ```\n283```\n as the answer, which is what you want. Then just print any path with all edge weights ```\n>= 283```\n (only one in your case).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding the shortest path in a colored graph\r\n                \r\nThe problem I am trying to solve is:\n\nGiven a graph where each edge is colored in either red or blue:\n\na) Give an algorithm that produces the path that between two vertices (s,t) that goes over a minimal amount of red edges.\n\nb) Give an algorithm that produces the path that between two vertices (s,t) that goes over a minimal amount of blue edges, out of all the paths that go from s to t that pass through a minimal amount of red edges.\n\nSo far:\nFor a) I can use a modified BFS algorithm. When looking at a vertex, v, put all the vertices that are connected by a blue edge to v first in the queue, and then add the rest to the end of the queue. Thus, the first time the algorithm will encounter t will be the path in question. \n\nHow do I prove correctness of this algorithm? It seems very greedy. How do I expand this to answer b)?\n\nThanks for your time.\n    ", "Answer": "\r\nThere are two important details about your algorithm that you need to keep in mind:\n\n\nNodes can be added to the queue multiple times in your scenario. You are only allowed to explore them once, though. You can enforce that by maintaining a boolean flag per node that tells you whether you have already explored a node.\nYou can only stop the algorithm as soon as you take ```\nt```\n out of the queue, not as soon as you put it in.\n\n\nIf you do it this way (and your question doesn't indicate you don't), your algorithm is indeed correct.\n\n\n  How do I prove correctness of this algorithm?\n\n\nIf you assign edge weight ```\n1```\n to red edges and edge weight ```\n0```\n to blue edges, the problem reduces to find the shortest path in the transformed graph. Let's apply Dijkstra to this problem. I will show that your algorithm in fact implements Dijkstra, which proves its correctness.\n\nWe can show that we only ever have nodes of two different distances in the priority queue: If ```\nm```\n is the minimum distance of a node in the priority queue, then we can't have a node of distance ```\nm + 2```\n in the queue, because that would mean that we must already have explored a node with distance ```\nm + 1```\n, which is impossible because we explore nodes in order of increasing distance.\n\nYour modified BFS in fact implements the Dijkstra algorithm using a double-ended queue as the 2-value priority queue: If ```\nQ```\n is your queue, then there is an index ```\ni```\n, such that ```\nQ[1..i]```\n contains only nodes of distance ```\nm```\n and ```\nQ[i+1..]```\n contains only nodes of distance ```\nm + 1```\n.\n\n\n  How do I expand this to answer b)?\n\n\nYou can extend the concept by maintaining a 4-value priority queue, for example implemented as two double-ended queue. One queue will hold nodes of distance ```\nm```\n red edges, the other will hold nodes of distance ```\nm + 1```\n red edges. Both are ordered by increasing number of blue edges (there will also only be two different distance values in each of these).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Networkx - find the most appearing paths in weighted network\r\n                \r\nI have a directed graph with 481 nodes and 6817 edges (weight is the number of times the edge appears, otherwise it would be around 4 million edges). The graph is shown here:\n\n\n\nI want to find the paths from the outer most nodes that enter to the center of the graph most of the times (perhaps the paths with the overall highest weight?). I have calculated the eigenvector centrality of the nodes and made a top 20. Those nodes are the ones that appear in the center. What i have tried:\n\n```\nd = g.successors(top20nodes[0])\nh = g.subgraph(d)\n```\n\n\nThis is a way to only get the nodes that eventually end at the node with in this case, the highest eigenvector centrality. However, I do not know how to get the n most appearing (most weighted) paths leading to that node. \n\nMy end result would ideally be this, the gray nodes are only to make it clear that I am only interested in the n most appearing paths. In this case, those 4 red paths to the center:\n\n\n\nI am not necessarily looking for the exact code, I just do not know how to proceed from here. Anybody has a clue how to achieve this?\n    ", "Answer": "\r\nNote, that my solution is not not fully optimal, in some cases it can return not-the-best paths\n\nI thought up an algorithm for you. It has several assumptions so it is not best-of-the best. But it should return pretty good results.\n\nFirstly, you should define your graph center (I left it beyond my algorithm). Once you defined it, you should replace all your center nodes to only one - The Main Center Node (don't forget about edges). After it, my algorithm begins.\n\nIt starts the BFS tree from the center node with the defined depth. Here is the main imperfect part: if you will have two paths between two nodes - long-heavy and short-light, the short-light will be chosen. I am not sure if it will be critical for your graph, but looks like it will not (the picture is not very informative).\n\nAfter the BFS tree is built, it summarizes all weigths of BFS paths and sorts them. Then you can just choose the first X paths.\n\nI hope it will help you to solve your problem :)\n\n```\nimport networkx as nx\n\n# Create graph\nG = nx.DiGraph()\nG.add_nodes_from([1,6,7,8,9,10,11,12,13,14,15,16,17])\nG.add_weighted_edges_from([\n    (6,1,2),\n    (7,1,5),\n    (10,1,7),\n    (12,1,1),\n    (15,1,4),\n    (17,1,6),\n    (8,6,5),\n    (8,7,8),\n    (9,8,2),\n    (11,10,1),\n    (13,12,5),\n    (14,13,6),\n    (16,15,3),\n    (16,14,4),\n    (14,16,1),\n])\n\n# Get the BFS tree. 1 is the center, 100 is the BFS length. Note, that\n# long lengths MAY waste a lot of computing time\nB = nx.bfs_tree(G, 1, 100)\n# Get our center\nroot = list(v for v, d in B.in_degree() if d == 0)[0]\n# Get all leaves _in_BFS_tree\nleaves = (v for v, d in B.out_degree() if d == 0)\n# Get all paths\nall_paths = [nx.shortest_path(B, root, l) for l in leaves]\n# Get all sorted pairs [path, path_length]\nresult = sorted(\n    [\n        (\n            path, sum((G.edges[path[i+1], path[i]]['weight'])\n            for i in range(len(path) - 1))\n        )\n        for path in all_paths\n    ],\n    key=lambda x: x[1],\n    reverse=True\n)\n\nresult\n[([1, 12, 13, 14], 12),\n ([1, 6, 8, 9], 9),\n ([1, 10, 11], 8),\n ([1, 15, 16], 7),\n ([1, 17], 6),\n ([1, 7], 5)]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "The shortest path between nodes in graph\r\n                \r\nI don't know if I should be asking this here or not, the question is about algorithm. Imagine you have an undirected graph. Edges have different values. Imagine that some vertice are \"good\" and some are \"bad\". Now I want to determine two good nodes, so that path between them is shortest possible (if path include bad nodes that's not a problem).\n    ", "Answer": "\r\nWhat you want to do is start growing paths from all good nodes at once, and then stop shortly after you find that two meet.  Then you have found your shortest path.\n\nThere is a subtle complication.  Consider a triangle ABC.  If the weights of A-B and B-C are both 2, and A-C is 3, you look at the edges A-B and B-C before A-C.  Which means that you find the path A-B-C (weight 4) before A-C (weight 3).  However in all such cases you will have seen that the edge exists before you found the first one.\n\nHere is pseudocode.\n\n```\nnode_path_info is is a dictionary of vertex to information about the path\nupcoming is priority queue of vertices to consider next, sorted on .cost\n\ninitialize node_path_info and upcoming\nfor node in list of good nodes:\n    upcoming.add( {\n        \"node\": node,\n        \"node_from\": None,\n        \"cost\": 0,\n        \"good_node\", node,\n    } )\n\nbest_path_cost = None\nbest_middle1 = None\nbest_middle2 = None\nwhile upcoming:\n    current = upcoming.pop()\n    if current.node in good_node_from:\n        if current.good_node == good_node_from[current.node]:\n            pass # We found a loop\n        else:\n            cost = current.cost + node_path_info[current.node].cost\n            if best_path_cost is None or cost < best_path_cost < best_path_cost:\n                best_path_cost = cost\n                best_middle1 = current.node\n                best_middle1 = current.node_from\n    else:\n        node_path_info[current.node] = current\n        if best_path_cost is not None: # still looking for first path\n            for (next_node, weight) in get_connected_weight(current.node):\n                upcoming.add({\n                    \"node\": next_node,\n                    \"node_from\": current.node,\n                    \"cost\": current.cost + weight,\n                    \"good_node\", current.good_node,\n                })\n\npath1 = path from best_middle1 back\npath2 = path from best_middle2 back\npath1 + reversed(path2) is your answer.\n```\n\n\nIn the worst case you will need to visit all edges twice.  With a random connected graph and 2 good nodes, you will visit all edges connected to ```\nO(sqrt(n))```\n vertices.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all pair shortest path in a large scale of graph\r\n                \r\nI want to find all pair shortest path in a large scale of graph. What can I do? In the mean time, is there any kind of stream algorithm to solve all pair shortest path problem in stream graph?\n    ", "Answer": "\r\nAccording to the hint of @sudomakeinstall2, I find something interesting to solve dynamical graph problem. Camil Demetrescu's page A New Approach to Dynamic All Pairs Shortest Paths is great one for this problem. They yield a fully dynamic algorithm for general directed graphs with non-negative real- valued edge weights that supports any sequence of operations in O(n2log3n) amortized time per update and unit worst-case time per distance query, where n is the number of vertices \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding the longest path in a complete directed graph\r\n                \r\nI was thinking on how to find a longest possible path in a complete, directed graph for every single vertex.\nExample of such a graph\nSo for every single vertex I want to find the maximum possible amount of vertices that one can travel through (not going through any vertex more than once) and the specific path that has that specific length.\nFor example in the given graph, for starting vertex nr.1, the maximum length is 4 and the path:\n1,4,2,3 ,or 1,2,3,4 (I just need to get one of them, not all).\nWhat kind of algoritm could handle that?\nIn case it matters I use C++.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to make a recursive function for find all Euler path in a graph?\r\n                \r\nI'm trying to find all Euler paths in a graph. For doing this, I'm using a java code based on this: http://www.sanfoundry.com/java-program-implement-euler-circuit-problem/ (this example finds just one euler path).\n\nBasically, I made some changes in PrintEulerUtil method (below), but that brings me some problems in the algorithm, and I can't find a solution that works.\n\nHere is the code:\n\n```\npublic void printEulerTourUtil(int vertex, int[][] adjacencyMatrix, String trail) {\n\n        // variable that stores (in every recursive call) the values of the adj matrix\n        int[][] localAdjacencyMatrix = new int[this.numberOfNodes + 1][this.numberOfNodes + 1];\n        // verifies if there is some edge unvisited. if not, then the euler path is in variable \"trail\"\n        int verificationSum = 0;\n\n        // copy values of variable, not only reference\n        for (int i = 0; i <= numberOfNodes; i++) {\n            for (int j = 0; j <= numberOfNodes; j++) {\n                localAdjacencyMatrix[i][j] = adjacencyMatrix[i][j];\n                verificationSum += localAdjacencyMatrix[i][j];\n            }\n        }\n\n        Integer destination = 1;\n\n        // if verificationSum != 0, then, at least one edge is in the adj matrix\n        if (verificationSum != 0) {\n           // test for every destination possible if is valid (isValidNextEdge) and if has connection between the actual vertex and the destination.\n            for (destination = 1; destination <= numberOfNodes; destination++) {\n                if (localAdjacencyMatrix[vertex][destination] == 1 && isValidNextEdge(vertex, destination, localAdjacencyMatrix)) {\n                    // remove the edge for the next recursion call (and not loop the program)\n                    removeEdge(vertex, destination, localAdjacencyMatrix);\n                    trail = trail.concat(destination.toString());\n                    // recursive call \n                    printEulerTourUtil(destination, localAdjacencyMatrix, trail);\n                }\n            }\n        } else {\n            System.out.println(\"Euler path: \" + trail);\n        }\n    }\n```\n\n\nThe problem is: when the recursive call returns, and destination increments, the graph (adjacency matrix) suffers some changes that impossible to find new (nexts) Euler paths. It easier with an example, so:\n\n\n\nAs you can see, for example, in the second level of the three, when destination is equals to 4, the edges 1-2 and 1-3 are already removed by previous recursive calls. Then, the graph is not the same of the beggining... which make impossible to find the Euler paths after the first one (because the graph isn't correct).\n\nAny thoughts? If someone wants my entire code, just ask. Any help will be very useful. Thank you so much and sorry the size of the post. \n    ", "Answer": "\r\nYou have already identified the problem!\n\n\n  when the recursive call returns, and destination increments, the graph (adjacency matrix) suffers some changes \n\n\nAt the start of the recursive function, you are currently taking a copy of the ```\nadjacencyMatrix```\n that has been passed in to you. However, you then corrupt this local copy as you loop through the possible destination edges. As you have observed, after the return from the recursive call along the first destination edge, your ```\nlocalAdjacencyMatrix```\n has already been changed - it's no longer correct to pass it to the recursive call for the second destination edge.\n\nTo resolve your problem, you need to keep better track of the adjacency matrix that was passed in to you, and the multiple different adjacency matrices you pass down.\n\nI haven't checked this, but I'd say you need to:\n\n\nchange the test just after ```\n// test for every destination possible if is valid (isValidNextEdge) and if has connection between the actual vertex and the destination```\n so that it works on ```\nadjacencyMatrix```\n, the invariant matrix that was passed in\ncopy the code that copies values from ```\nadjacencyMatrix```\n to ```\nlocalAdjacencyMatrix```\n to just before ```\n// remove the edge for the next recursion call (and not loop the program)```\n. This will ensure that when you remove an edge, you do it from a fresh copy of the input adjacency matrix\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths in undirected graph between 2 nodes\r\n                \r\nI am a newbie to php and i am doing a project about undirected graph.\nI wrote a function to find out the shortest path between two nodes (A & G) in this case.\nthe code is right below. And i want to modify the code so that i can list out all the possible paths between A -G, so I add one line to the function and try to make it become recursive\n\n```\n$this->findTheShortestPath($vertex, $destination);\n```\n\n\nbut it turns out run into infinite loop. But I do understand why:( Does anyone have any idea what is going on? or does anyone know how to modify the code so that it can list our all the paths?\nthanks so much\n\n```\n<?PHP\nclass Graph\n\n{\n    protected $graph;\n    protected $visited = array();\n\npublic function __construct($graph)\n{\n    $this->graph = $graph;\n}\n\n\n// find least number of hops (edges) between 2 nodes\n// (vertices)\npublic function findTheShortestPath($origin, $destination)\n{\n    // mark all nodes as unvisited\n    foreach ($this->graph as $vertex => $adj) {\n        $this->visited[$vertex] = false;\n    }\n\n    // create an empty queue\n    $q = new SplQueue();\n\n    // enqueue the origin vertex and mark as visited\n    $q->enqueue($origin);\n    $this->visited[$origin] = true;\n\n    // this is used to track the path back from each node\n    $path          = array();\n    $path[$origin] = new SplDoublyLinkedList();\n    $path[$origin]->setIteratorMode(SplDoublyLinkedList::IT_MODE_FIFO | SplDoublyLinkedList::IT_MODE_KEEP);\n\n    $path[$origin]->push($origin);\n\n    // while queue is not empty and destination not found\n\n    // print_r($q);\n    while (!$q->isEmpty() && $q->bottom() != $destination) {\n\n        $t = $q->dequeue();\n\n        if (!empty($this->graph[$t])) {\n\n            foreach ($this->graph[$t] as $vertex) {\n\n                if (!$this->visited[$vertex]) {\n\n                    $q->enqueue($vertex);\n                    $this->visited[$vertex] = true;\n                    // add vertex to current path\n                    $path[$vertex] = clone $path[$t];\n                    $path[$vertex]->push($vertex);\n                    //$this->findTheShortestPath($vertex, $destination);\n                }\n            }\n\n        }\n\n    }\n\n    if (isset($path[$destination])) {\n        echo \"$origin to $destination in \", count($path[$destination]) - 1, \" hops \\n\";\n        $sep = '';\n        foreach ($path[$destination] as $vertex) {\n            echo $sep, $vertex;\n            $sep = '->';\n        }\n        echo \"n\";\n    } else {\n        echo \"No route from \", $origin, \" to \", $destination, \"\\n\";\n    }\n}\n\n\n\n\n}\n\n$graph = array(\n'A' => array(\n    'B',\n    'C',\n    'F'\n),\n'B' => array(\n    'A',\n    'C',\n    'E'\n),\n'C' => array(\n    'A',\n    'B',\n    'D',\n    'F'\n),\n'D' => array(\n    'C',\n    'F'\n),\n'E' => array(\n    'B',\n    'F'\n),\n'F' => array(\n    'A',\n    'C',\n    'D',\n    'E',\n    'G'\n),\n'G' => array(\n    'F'\n)\n);\n\n$g = new Graph($graph);\n\n// least number of hops between D and C\n$g->findTheShortestPath('A', 'G');\n\n?>\n```\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Recursion Function in Graph Path Finding\r\n                \r\nI scripted the following recursion function to calculate all of the possible paths from a target node to a start node in a graph using adjacency matrix.\n\n```\nprivate Stack<string> TestCaseGeneration(int TargetStateIndex, double[,] adjacancy, Stack<string> TotalResults = null, Stack<string> CarrierStack = null, int StartStateIndex = 0)\n{\n    Stack<string> Result = CarrierStack;\n    Result.Push(TargetStateIndex.ToString() + \" - \");\n\n    if (TargetStateIndex == StartStateIndex)\n    {\n       TotalResults.Push(StackToSingleString(Result));\n       return TotalResults;\n    }\n    else\n    {\n       List<string> neighbours = ListNeighbourLeadingToTargetNode(TargetStateIndex, adjacancy, EventIndex);\n       int NumberOfNeighbours = neighbours.Count;\n       if (NumberOfNeighbours != 0)\n       {\n           for (int i = 0; i < NumberOfNeighbours; i++)\n           {\n              return TestCaseGeneration(int.Parse(neighbours[i].ToString()), adjacancy, TotalResults, Result, StartStateIndex);\n           }\n        }\n     }\n     else return null;\n  }\n```\n\n\nThe issue is ```\nreturn```\n int the ```\nfor```\n loop, how can I fix it?\n    ", "Answer": "\r\nIf you don't want to return anything set the ```\nreturn null;```\n before the last ```\n}```\n\n\nIf you put the ```\nreturn null;```\n in a if else statement the compiler knows not all code paths return a value!\n\nEDIT\n\nI see your problem now sorry.\n\nYou need to create a variable wich you return at the end.\nIn the if statement you can edit the variable.\n\nIf the variable is never edited the default value of the variable is returned!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to Highlight any given path in pyvis network graph visualization?\r\n                \r\nI'm working on a project in which first i had to detect the shortest path in a huge network graph using a-star algorithm followed by visualizing the same graph using pyvis network. However in this pyvis network the path that I've calculated should be highlighted as shortest path.\neg: consider this code for game of thrones character network\n```\nfrom pyvis.network import Network\nimport pandas as pd\n\ngot_net = Network(height='750px', width='100%', bgcolor='#222222', font_color='white')\n\n# set the physics layout of the network\ngot_net.barnes_hut()\ngot_data = pd.read_csv('https://www.macalester.edu/~abeverid/data/stormofswords.csv')\n\nsources = got_data['Source']\ntargets = got_data['Target']\nweights = got_data['Weight']\n\nedge_data = zip(sources, targets, weights)\n\nfor e in edge_data:\n    src = e[0]\n    dst = e[1]\n    w = e[2]\n\n    got_net.add_node(src, src, title=src)\n    got_net.add_node(dst, dst, title=dst)\n    got_net.add_edge(src, dst, value=w)\n\nneighbor_map = got_net.get_adj_list()\n\n# add neighbor data to node hover data\nfor node in got_net.nodes:\n    node['title'] += ' Neighbors:<br>' + '<br>'.join(neighbor_map[node['id']])\n    node['value'] = len(neighbor_map[node['id']])\n\ngot_net.show('gameofthrones.html')\n\n```\n\n\nNow how do i highlight a specific path in this graph? i've gone through the documentation but there isn't anything similar\n    ", "Answer": "\r\nHere's an example using NetworkX to create the graph and gravis to visualize it. I had to use a different URL, hope it's the same data. I've used the weight as edge widths and colored some with large weights. Alternatively you can calculate a shortest path between two nodes of interest and then color that path or assign edge widths so it stands out.\nDisclosure: I'm the author of gravis. I don't know if the same can be achieved with pyvis, but since I know that gravis supports the requirements well, I provided this solution and hope it's useful.\n```\nimport gravis as gv\nimport networkx as nx\nimport pandas as pd\n\nurl = 'https://raw.githubusercontent.com/pupimvictor/NetworkOfThrones/master/stormofswords.csv'\ngot_data = pd.read_csv(url)\n\ng = nx.Graph()\nfor i, (source, target, weight) in got_data.iterrows():\n    width = weight/10\n    g.add_edge(source, target, size=width, color='blue' if width > 3 else 'black')\n    \ngv.d3(g)\n```\n\nEdit: Here's the output if you use this code inside a Jupyter notebook. You can also use a regular Python interpreter and display the plot inside a browser window that pops up with ```\nfig = gv.d3(g)```\n followed by ```\nfig.display()```\n.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All shortest paths for weighted graphs with networkx?\r\n                \r\nI have a graph composed by two different sets of edges. The first set is made by edges of weight 1 (list 1). The second set is made by edges of weight 2 (list 2). First, I create the graph with networkx and then use add_edges_from to add list 1 and list 2. I would like to compute all the shortest paths in this weighted graph. Basically I'm looking for the analogous of \"all_shortest_paths\" but with weights (looks like \"dijkstra\" module does not allow you to know all the possible routes between a given source and a given target). If I try to use \"all_shortest_path\" with weighted links (3-tuples, the two nodes and the weight) I get the error . Can anybody help me?\nThanks a lot!\n    ", "Answer": "\r\nHere is a simple example to show how all_shortest_paths() works\n\n```\nimport networkx as nx\nimport StringIO\nedges = StringIO.StringIO(\"\"\"\na b 1\na bb 1\nb c 2\nbb c 2\nc d 1\na d 10\"\"\")\nG = nx.read_weighted_edgelist(edges, nodetype=str)\nprint list(nx.all_shortest_paths(G, 'a', 'd', weight='weight'))\n# [['a', 'b', 'c', 'd'], ['a', 'bb', 'c', 'd']]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Dijktra algorithm vs breath first search for shortest path in graph\r\n                \r\nI need some clarifications and inputts regarding ```\nDijktra's algorithm```\n vs ```\nbreath first search```\n in directed graphs, if these are correct.\n\n```\nDijktra's```\n algorithm finds the shortest path from Node ```\nA```\n to Node ```\nF```\n in a ```\nweighted```\n graph regardless of if there is a cycle or not (as long as there are no negative weights)\n\nbut for that, All paths from ```\nA to all other Nodes in the graph are calculated and we grab the path from```\nA```\nto```\nF```\nby reversing the sequences of nodes in```\nprev`.\n\nBFS: finds the shortest path from ```\nNode A```\n to ```\nNode F```\n in a non-weighted graph, but if fails if  a cycle detected. \n\nhowever, ```\nBFS```\n just calculates the path from Node A to Node F and not necessarily all path from Node A.\nif Node F is reached early, it just returns the path.\n\n\n    ", "Answer": "\r\nDijkstra doesn't search all nodes of the graph. When it has found a way from A to F and is sure there is no shorter one (because the outer border of the already visited nodes is farther away), it stops. This is possible without negative weights.\n\nSo to answer your question \"if these are correct\": They are not.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "d3 update paths and circles in Graph\r\n                \r\ni want to update the graph but it does not work. I want to update the line and the circles. I tried to add \n\n```\n.exit().remove()\n```\n\n\nto update the circle and \n\n```\n  g.selectAll(\"path\").attr(\"d\", line);\n```\n\n\nto update the paths. \n\nHowever it does not work.\n\nUpdating the outside group with exit().remove() works fine. (Checkbox in this example).\n\nUpdating only the path and circle does not work. (Update Button in this example)\n\nI dont want to remove all lines in the graph and append it again, because i want to add transition when data changes.\n\nHere is a JS Fiddle: LINK\nHere is my code:\n\n```\nvar data = [\n  [{\n    point: {\n      x: 10,\n      y: 10\n    }\n  }, {\n    point: {\n      x: 100,\n      y: 30\n    }\n  }],\n  [{\n      point: {\n        x: 30,\n        y: 100\n      }\n    }, {\n      point: {\n        x: 230,\n        y: 30\n      }\n    },\n    {\n      point: {\n        x: 50,\n        y: 200\n      }\n    },\n    {\n      point: {\n        x: 50,\n        y: 300\n      }\n    },\n  ]\n];\n\nvar svg = d3.select(\"svg\");\n\nvar line = d3.line()\n  .x((d) => d.point.x)\n  .y((d) => d.point.y);\n\nfunction updateGraph() {\n  console.log(data)\n  var allGroup = svg.selectAll(\".pathGroup\").data(data);\n  var g = allGroup.enter()\n    .append(\"g\")\n    .attr(\"class\", \"pathGroup\")\n  allGroup.exit().remove()\n\n  g.append(\"path\")\n    .attr(\"class\", \"line\")\n    .attr(\"stroke\", \"red\")\n    .attr(\"stroke-width\", \"1px\")\n    .attr(\"d\", line);\n\n  g.selectAll(\"path\").attr(\"d\", line);\n\n  g.selectAll(null)\n    .data(d => d)\n    .enter()\n    .append(\"circle\")\n    .attr(\"r\", 4)\n    .attr(\"fill\", \"teal\")\n    .attr(\"cx\", d => d.point.x)\n    .attr(\"cy\", d => d.point.y)\n    .exit().remove()\n\n}\nupdateGraph()\n\ndocument.getElementById('update').onclick = function(e) {\n\n  data = [\n    [{\n      point: {\n        x: 10,\n        y: 10\n      }\n    }, {\n      point: {\n        x: 100,\n        y: 30\n      }\n    }],\n    [{\n        point: {\n          x: 30,\n          y: 100\n        }\n      }, {\n        point: {\n          x: 230,\n          y: 30\n        }\n      },\n      {\n        point: {\n          x: 50,\n          y: 300\n        }\n      },\n    ]\n  ];\n  updateGraph()\n}\n\n\n$('#cb1').click(function() {\n  if ($(this).is(':checked')) {\n    data = [\n      [{\n        point: {\n          x: 10,\n          y: 10\n        }\n      }, {\n        point: {\n          x: 100,\n          y: 30\n        }\n      }],\n      [{\n          point: {\n            x: 30,\n            y: 100\n          }\n        }, {\n          point: {\n            x: 230,\n            y: 30\n          }\n        },\n        {\n          point: {\n            x: 50,\n            y: 200\n          }\n        },\n        {\n          point: {\n            x: 50,\n            y: 300\n          }\n        },\n      ]\n    ];\n\n  } else {\n    data = [\n      [{\n        point: {\n          x: 10,\n          y: 10\n        }\n      }, {\n        point: {\n          x: 100,\n          y: 30\n        }\n      }]\n    ];\n  }\n  updateGraph()\n});\n```\n\n    ", "Answer": "\r\nProblem\n\nThe reason why ```\nallGroup.exit().remove()```\n does nothing is that the updated dataset still has the same number of items as the original one. The exit selection is therefore empty.\n\nThe variable ```\ndata```\n contains lines, not points. The one defined at page load, and the one inside ```\nupdate```\n listener contain two lines, only the number of points in them differs.\n\nYou can check this by putting a ```\nconsole.log(data.length)```\n inside function ```\nupdateGraph```\n.\n\nSolution 1\n\nChange your data structure. You can assign an ```\nid```\n property to each line, and use ```\n.data```\n's, ```\nkey```\n function. cf. d3-selection documentation.\n\nUpdated jsFiddle implementing solution 1: see here.\n\nThis solution requires less changes.\n\nSolution 2\n\nIn case you have no control over the data structure, you can transition the line drawing inside the ```\nupdate```\n selection, rather than the ```\nexit```\n one.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "BFS for finding ALL shortest paths in a grid?\r\n                \r\nI am trying to implement BFS to find ALL shortest paths in a grid. Note that this means not one, not two, but all.\nLet's take a graph of 9 nodes for example. The connections are undirected, and the nodes are placed in nodes of a grid-like format, like below:\n0 1 2 \n3 4 5 \n6 7 8\nEach number denotes a node's placement, and there are links between all nodes either directly above, below, to the left, or to the right of each other.\nThis means that 0 is connected to 1 and 3, while 4 is connected to 1, 3, 5, and 7, and so on.\nI am trying to get ALL the shortest paths from 0 to 8, which would mean 6 paths in total. When I implemented the traditional BFS algorithm, I noticed that I was missing a few paths because of the manner in which the code places nodes into the set of seen nodes.\nFor example, after visiting 1 and 3 from 0, the code moved on to 0 - 1 - 2 and 0 - 1 - 4, after which it only looked at 0 - 3 - 6 and not 0 - 3 - 4 because 4 had already been parsed through with node 1.\nIs there a way to get around this through BFS? Or should I be using a different searching algorithm? Thank you in advance.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding path with maximum minimum capacity in graph\r\n                \r\nI am helping a friend with a work related project where, he needs to calculate the maximum capacity from a node a to a node b, where the edge has a capacity. However the maximum capacity in a path from a to b is limited by the edge with the lowest capacity.\n\nLet me try to explain with a simple sample\n\n\nSo the graph is a directed graph with weighted edges, and it can be cyclic. The path with the highest capacity would be s->b->t and have the capacity of 250, since that edge is setting the limit.\n\nI have done a bit of reading and found out that this type of problem is a \"Widest path problem\" or I would call it something like a path with maximum minimum capacity, but I haven't found any examples or any pseudo code explaining how to tackle this.\n\nI was thinking something in the lines of finding all paths from s to t, using BFS and somehow only to allow visiting a node once in a path, and then find the minimum value in the path, would that work?\n    ", "Answer": "\r\nI would use some variant of Dijkstra's. I took the pseudo code below directly from Wikipedia and only changed 5 small things:\n\n\nRenamed ```\ndist```\n to ```\nwidth```\n (from line 3 on)\nInitialized each ```\nwidth```\n to ```\n-infinity```\n (line 3)\nInitialized the width of the source to ```\ninfinity```\n (line 8)\nSet the finish criterion to ```\n-infinity```\n (line 14)\nModified the update function and sign (line 20 + 21)\n\n\n\n\n```\n1  function Dijkstra(Graph, source):\n2      for each vertex v in Graph:                                 // Initializations\n3          width[v] := -infinity  ;                                // Unknown width function from \n4                                                                  // source to v\n5          previous[v] := undefined ;                              // Previous node in optimal path\n6      end for                                                     // from source\n7      \n8      width[source] := infinity ;                                 // Width from source to source\n9      Q := the set of all nodes in Graph ;                        // All nodes in the graph are\n10                                                                 // unoptimized – thus are in Q\n11      while Q is not empty:                                      // The main loop\n12          u := vertex in Q with largest width in width[] ;       // Source node in first case\n13          remove u from Q ;\n14          if width[u] = -infinity:\n15              break ;                                            // all remaining vertices are\n16          end if                                                 // inaccessible from source\n17          \n18          for each neighbor v of u:                              // where v has not yet been \n19                                                                 // removed from Q.\n20              alt := max(width[v], min(width[u], width_between(u, v))) ;\n21              if alt > width[v]:                                 // Relax (u,v,a)\n22                  width[v] := alt ;\n23                  previous[v] := u ;\n24                  decrease-key v in Q;                           // Reorder v in the Queue\n25              end if\n26          end for\n27      end while\n28      return width;\n29  endfunction\n```\n\n\nSome (handwaving) explanation why this works: you start with the source. From there, you have infinite capacity to itself. Now you check all neighbors of the source. Assume the edges don't all have the same capacity (in your example, say ```\n(s, a) = 300```\n). Then, there is no better way to reach ```\nb```\n then via ```\n(s, b)```\n, so you know the best case capacity of ```\nb```\n. You continue going to the best neighbors of the known set of vertices, until you reach all vertices.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in unweighted graph using DFS and stack\r\n                \r\nIm new at coding in java, im trying to code a program that can find the shortest path in an unweighted graph using DFS method and a stack. Im looking forward for a recursive DFS method that can find the shortes path between two nodes. I dont know how to implement DFS im searching for help, here is my code. \n\n```\n    import java.util.ArrayList;\n    import java.util.LinkedList;\n    import java.util.Stack;\n\n    import javax.swing.JOptionPane;\n\n    public class pruebaGrafosinpesos {\n\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    int opcion=0, i=0, origen=0, destino=0, contador=0, n=-1;\n    boolean[] visitados= new boolean[10];//arreglo que indica los nodos visitados\n    Stack<Integer> camino= new Stack();//stack que guarda el camino recorrido\n    Stack<Integer> temp= new Stack();//stack que guarda el camino recorrido\n    LinkedList<Integer>[] nodo = new LinkedList[10];//arreglo de las conexiones de cada nodo\n\n    for(i=0; i<10; i++) {\n        nodo[i]= new LinkedList<Integer>();\n    }\n\n    for(i=0; i<10; i++) {\n        visitados[i]=false;\n    }\n\n    //inicializo el grafo\n    nodo[0].add(1); nodo[0].add(2);\n    nodo[1].add(0); nodo[1].add(2); nodo[1].add(3);\n    nodo[2].add(1); nodo[2].add(5); nodo[2].add(6);\n    nodo[3].add(1); nodo[3].add(4); nodo[3].add(7);\n    nodo[4].add(3); nodo[4].add(5); nodo[4].add(7);\n    nodo[5].add(2); nodo[5].add(4); nodo[5].add(6); nodo[5].add(8);\n    nodo[6].add(2); nodo[6].add(5); nodo[6].add(8);\n    nodo[7].add(3); nodo[7].add(4); nodo[7].add(8);\n    nodo[8].add(4); nodo[8].add(5); nodo[8].add(6); nodo[8].add(9);\n    nodo[9].add(7); nodo[9].add(8);\n\n    ///////////////// Matriz //////////////////////\n    /*|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n      | 0 | / | * | * |   |   |   |   |   |   |   |\n      | 1 | * | / | * | * |   |   |   |   |   |   |\n      | 2 |   | * | / |   |   | * | * |   |   |   |\n      | 3 |   | * |   | / | * |   |   | * |   |   |\n      | 4 |   |   |   | * | / | * |   | * |   |   |\n      | 5 |   |   | * |   | * | / | * |   | * |   |\n      | 6 |   |   | * |   |   | * | / |   | * |   |\n      | 7 |   |   |   | * | * |   |   | / | * |   |\n      | 8 |   |   |   |   | * | * | * |   | / | * |\n      | 9 |   |   |   |   |   |   |   | * | * | / |*/\n    ///////////////////////////////////////////////\n\n    do {\n        opcion=Integer.parseInt(JOptionPane.showInputDialog(\"1.-Encontrar el camino mas corto\\n 2.-Salir\\n Escoge una opcion\"));\n        switch(opcion) {\n            case 1:\n                origen=Integer.parseInt(JOptionPane.showInputDialog(\"Dame el nodo origen\"));\n                destino=Integer.parseInt(JOptionPane.showInputDialog(\"Dame el nodo destino\"));\n\n                n=origen;\n\n                while(contador<=10) {\n                    if(visitados[n]==false) {//si el nodo no ha sido visitado\n                        visitados[n]=true;//se visita\n                        camino.push(n);//se agrega al stack del camino recorrido\n                        contador++;\n                    }\n\n\n\n\n                }\n\n                break;\n\n            case 2:\n                break;\n\n        }\n    }while(opcion!=2);\n\n}\n```\n\n\n}\n    ", "Answer": "\r\nIf you are happy to use a recursive method then you really don't need your stack variables. You just need a single field to store the shortest path found so far\n\nI can provide some pseudocode here for you to convert to Java\n\n```\nshortest = null\ndfs({start})\n\ndfs(path):\n    if end of path is destination\n        if shortest is null or path is shorter than shortest\n            shortest = path\n    else\n        for each node reachable from end of path\n            if node not in path\n                dfs(path + node)\n```\n\n\nThat algorithm will perform a DFS of the entire graph and find the shortest path from start to destination nodes. You could also have it return the shortest path instead of storing it as a side effect of the search.\n\n\n\nFor your interest, here's a solution using a slightly different data structure. The path essentially acts as a stack.\n\n```\npublic class Network {\n    private final List<Node> nodes;\n\n    private class Node {\n        private final List<Node> links = new ArrayList<>();\n    }\n\n    public class Path {\n        private final Optional<Path> previous;\n        private final Node end;\n\n        private Path(Optional<Path> previous, Node node) {\n            this.previous = previous;\n            this.end = node;\n        }\n\n        public String toString() {\n            return nodes().map(n -> Integer.toString(nodes.indexOf(n))).collect(Collectors.joining(\", \"));\n        }\n\n        private Stream<Node> nodes() {\n            return Stream.concat(previous.stream().flatMap(Path::nodes), Stream.of(end));\n        }\n    }\n\n    public Network(int nodeCount) {\n        this.nodes = IntStream.range(0, nodeCount).mapToObj(i -> new Node()).collect(Collectors.toList());\n    }\n\n    public void linkNodes(int from, int to) {\n        assert from != to : \"link to self\";\n        getNode(from).links.add(getNode(to));\n        getNode(to).links.add(getNode(from));\n    }\n\n    public Optional<Path> shortest(int from, int to) {\n        return shortest(new Path(Optional.empty(), getNode(from)), getNode(to));\n    }\n\n    private Optional<Path> shortest(Path path, Node to) {\n        if (path.end.equals(to))\n            return Optional.of(path);\n        else\n            return path.end.links.stream()\n                    .filter(ln -> path.nodes().noneMatch(ln::equals))\n                    .flatMap(ln -> shortest(new Path(Optional.of(path), ln), to).stream())\n                    .min(Comparator.comparingLong(p -> p.nodes().count()));\n    }\n\n    private Node getNode(int id) {\n        assert id >= 0 && id < nodes.size(): \"illegal node id\";\n        return nodes.get(id);\n    }\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to count the different paths in a graph given a source node and a path length\r\n                \r\nI have a simple graph with 4 nodes ```\nA```\n,```\nB```\n,```\nC```\n,```\nD```\n as well as the following edges:\n\n```\n[A,B]\n[B,D]\n[B,C]\n```\n\n\nI want to find paths that start at the node C given a certain length ```\nn```\n. For example:\n\nfor ```\nn = 1```\n I will only have ```\n[C]```\n as a possible path. Result is 1\n\nfor ```\nn = 2```\n we only have ```\n[C,B]```\n. Result is 1\n\nfor ```\nn = 3```\n we have ```\n[C,B,C]```\n , ```\n[C,B,D]```\n, ```\n[C,B,A]```\n. Result is 3\n\netc.\n\nI have written the following (python) code:\n\n```\ndg = {'A':['B'],\n      'B':['C','D','A'],\n      'D':['B'],\n      'C':['B']}\n\nbeg = ['C']\n\n\ndef makePath(n):\n    count = 0\n    curArr = beg\n    for i in range(n):\n        count = len(curArr)\n        tmp = []\n        for i in curArr:\n            tmp.extend(dg[i])\n        curArr = tmp\n    return count\n```\n\n\nHowever it gets extremely slow above ```\nn=12```\n. Is there a better algorithm to solve this and more importantly. one that can be generalized for any undirected graph (i.e. with up to 20 nodes)?\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding shortest path in a cyclic weighted graph\r\n                \r\nI am trying to find shortest path in a cyclic weighted graph. I have the following recursive function that is able to find shortest path between 2 points if they are not cyclic. For instance my graph looks like this:\n\n```\ngraph = {\n          'A': {'B': 5, 'D': 5, 'E': 7 },\n          'B': {'C': 4},\n          'C': {'D': 8, 'E': 2},\n          'D': {'C': 8, 'E':  6},\n          'E': {'B': 3}\n        }\n```\n\n\nAnd now my find shortestRoute function looks like this \n\n```\ndef findShortestRoute(self, start, end , weight, shortestRoute):\n    # sys.setrecursionlimit(10000)\n    visited = []\n    # Check if start and end nodes exists in route table\n    if start in self.routesTable and end in self.routesTable:\n        visited.append(start) # mark start to visited\n\n        for adj in self.routesTable[start]:\n            if(adj == end or adj not in visited):\n                weight += self.routesTable[start][adj]\n\n            '''\n            If destination matches, we compare\n            weight of this route to shortest route\n            so far, and make appropriate switch\n            '''\n\n            if adj == end:\n                if shortestRoute == 0 or weight < shortestRoute:\n                    shortestRoute = weight\n                visited.remove(start)\n                return shortestRoute\n            '''\n            If destination does not match, and\n            destination node has not yet been visited,\n            we recursively traverse destination node\n            '''\n            if adj not in visited:\n                shortestRoute = self.findShortestRoute(adj, end, weight, shortestRoute)\n                weight -= self.routesTable[start][adj]\n\n    else:\n        return \"No such route exists\"\n\n    if start in visited:\n        visited.remove(start)\n\n    return shortestRoute\n```\n\n\nNow for non-cyclic cases if I do something like\n\n```\nfindShortestRoute('A', 'C', 0, 0)\n```\n\n\nthis will return 9 which is what expected. However, if I do something like this \nfindShortestRoute('B', 'B', 0, 0)\n\nThe function will reach stack overflow. however, since the graph is cyclic there is a way to start from B and get back to B. In this case B-C-E-B which weights 9.\nBut my function is reaching maximum recursion. I would really appreciate if someone can help me with this. Thanks in advance\n    ", "Answer": "\r\nYour problem is that you do not pass the ```\nvisited```\n list through your recursion, so your algorithm gets stuck in cycles. If you pass down the predecessors nodes you can detect cycles and return if you hit one.\nBelow is how I would change your code to achieve this:\n```\ndef findShortestRoute(start, end , weight, shortestRoute, visited, routesTable):\n# sys.setrecursionlimit(10000)\n# Check if start and end nodes exists in route table\n\nif start in routesTable and end in routesTable:\n    if start in visited:\n        return 99999\n    visited.append(start) # mark start to visited\n\n    for adj in routesTable[start]:\n        if(adj == end or adj not in visited):\n            weight += routesTable[start][adj]\n\n        '''\n        If destination matches, we compare\n        weight of this route to shortest route\n        so far, and make appropriate switch\n        '''\n\n        if adj == end:\n            if shortestRoute == 0 or weight < shortestRoute:\n                shortestRoute = weight\n            visited.remove(start)\n            return shortestRoute\n        '''\n        If destination does not match, and\n        destination node has not yet been visited,\n        we recursively traverse destination node\n        '''\n        if adj not in visited:\n            shortestRoute = findShortestRoute(adj, end, weight, shortestRoute, visited, routesTable)\n            weight -= routesTable[start][adj]\nelse:\n    return \"No such route exists\"\n\n\nreturn shortestRoute\n\ngraph = {'A': {'B': 5, 'D': 5, 'E': 7 },'B': {'C': 4},'C': {'D': 8, 'E': 2},'D': {'C': 8, 'E':  6},'E': {'B': 3}}\n\nprint(findShortestRoute('B', 'B', 0, 0, [], graph))\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find a path in a complete graph with cost limit and max reward\r\n                \r\nI'm looking for an algorithm to solve this problem. I have to implement it (so I need a not np solution XD)\n\nI have a complete graph with a cost on each arch and a reward on each vertex. I have only a start point, but it doesn't matter the end point, becouse the problem is to find a path to see as many vertex as possible, in order to have the maximum reward possible, but subject to a maximum cost limit.  (for this reason it doesn't matter the end position).\n\nI think to find the optimum solution is a np-hard problem, but also an approximate solution is apprecciated :D\n\nThanks\n\nI'm trying study how to solve the problem with branch & bound... \n\nupdate: complete problem dscription\n\nI have a region in which there are several areas identify by its id and x,y,z position. Each vertex identifies one ot these areas. The maximum number of ares is 200. \nFrom a start point S, I know the cost, specified in seconds and inserted in the arch (so only integer values), to reach each vertex from each other vertex (a complete graph).\nWhen I visit a vertex I get a reward (float valiues).\n\nMy objective is to find a paths in a the graph that maximize the reward but I'm subject to a cost constraint on the paths. Indeed I have only limited minutes to complete the path (for example 600 seconds.)\n\nThe graph is made as matrix adjacency matrix for the cost and reward (but if is useful I can change the representation).\n\nI can visit vertex more time but with one reward only!\n    ", "Answer": "\r\nSince you're interested in branch and bound, let's formulate a linear program. Use Floyd–Warshall to adjust the costs minimally downward so that ```\ncost(uw) ≤ cost(uv) + cost(vw)```\n for all vertices ```\nu, v, w```\n.\n\nLet ```\ns```\n be the starting vertex. We have 0-1 variables ```\nx(v)```\n that indicate whether vertex ```\nv```\n is part of the path and 0-1 variables ```\ny(uv)```\n that indicate whether the arc ```\nuv```\n is part of the path. We seek to maximize\n\n```\nsum over all vertices v of reward(v) x(v).\n```\n\n\nThe constraints unfortunately are rather complicated. We first relate the ```\nx```\n and ```\ny```\n variables.\n\n```\nfor all vertices v ≠ s,  x(v) - sum over all vertices u of y(uv) = 0\n```\n\n\nThen we bound the cost.\n\n```\nsum over all arcs uv of cost(uv) y(uv) ≤ budget\n```\n\n\nWe have (pre)flow constraints to ensure that the arcs chosen look like a path possibly accompanied by cycles (we'll handle the cycles shortly).\n\n```\nfor all vertices v,  sum over all vertices u of y(uv)\n                       - sum over all vertices w of y(vw)\n                         ≥ -1 if v = s\n                            0 if v ≠ s\n```\n\n\nTo handle the cycles, we add cut covering constraints.\n\n```\nfor all subsets of vertices T such that s is not in T,\n  for all vertices t in T,\n    x(t) - sum over all vertices u not in T and v in T of y(uv) ≥ 0\n```\n\n\nBecause of the preflow constraints, a cycle necessarily is disconnected from the path structure.\n\nThere are exponentially many cut covering constraints, so when solving the LP, we have to generate them on demand. This means finding the minimum cut between ```\ns```\n and each other vertex ```\nt```\n, then verifying that the capacity of the cut is no greater than ```\nx(t)```\n. If we find a violation, then we add the constraint and use the dual simplex method to find the new optimum (repeat as necessary).\n\nI'm going to pass on describing the branching machinery – this should be taken care of by your LP solver anyway.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in a graph in ES6\r\n                \r\nThis is my implementation of a graph, to get the shortest path between A and B.\n\n\r\n\r\n```\nclass Queue {\r\n  constructor() {\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.size = 0;\r\n\r\n  }\r\n  offer(item) {\r\n    const p = new QueueNode(item);\r\n    this.size++;\r\n    if (this.head === null) {\r\n      this.head = p;\r\n      this.tail = p;\r\n      return;\r\n    }\r\n    this.tail.next = p;\r\n    this.tail = p;\r\n\r\n  }\r\n  poll() {\r\n    if (this.size === 0) {\r\n      throw TypeError(\"Can't deque off an empty queue.\");\r\n    }\r\n    this.size--;\r\n    const item = this.head;\r\n    this.head = this.head.next;\r\n    return item.val;\r\n\r\n  }\r\n  peek() {\r\n    if (this.size === 0) {\r\n      throw TypeError(\"Empty Queue.\")\r\n    }\r\n    return this.head.val;\r\n  }\r\n  isEmpty() {\r\n    return this.head === null;\r\n\r\n  }\r\n\r\n}\r\nclass QueueNode {\r\n  constructor(item) {\r\n    this.val = item;\r\n    this.next = null;\r\n  }\r\n\r\n\r\n}\r\nclass Graph {\r\n\r\n  constructor(directed = false) {\r\n    this.numVertices = 0;\r\n    this.directed = directed;\r\n    this.dict = {}\r\n  }\r\n  addEdge(v1, v2, weight = 1) {\r\n    let p, q;\r\n    if (v1 in this.dict) {\r\n      p = this.dict[v1];\r\n    } else {\r\n      p = new GraphNode(v1);\r\n      this.dict[v1] = p;\r\n      this.numVertices++;\r\n    }\r\n    if (v2 in this.dict) {\r\n      q = this.dict[v2];\r\n    } else {\r\n      q = new GraphNode(v2);\r\n      this.dict[v2] = q;\r\n      this.numVertices++;\r\n    }\r\n    p.addEdge(q);\r\n    if (!this.directed) {\r\n      q.addEdge(p);\r\n    }\r\n\r\n  }\r\n\r\n  stringify() {\r\n    for (const [key, value] of Object.entries(this.dict)) {\r\n      console.log(`${key}: ${[...value.adjacencySet].map(x => x.data)}`);\r\n    }\r\n\r\n  }\r\n\r\n\r\n\r\n  buildDistanceTable(source) {\r\n    let p;\r\n    if (this.dict[source] === undefined) {\r\n      throw TypeError('Vertex not present in graph')\r\n    } else {\r\n      p = this.dict[source];\r\n    }\r\n    const distanceTable = {};\r\n    for (const [key, value] of Object.entries(this.dict)) {\r\n      distanceTable[key] = [-1, -1];\r\n    }\r\n    distanceTable[p.data] = [0, p.data];\r\n\r\n    const queue = new Queue();\r\n    queue.offer(p);\r\n\r\n    while (!queue.isEmpty()) {\r\n      let curr = queue.poll();\r\n\r\n      let curr_distance = distanceTable[curr.data][0];\r\n\r\n      curr.adjacencySet.forEach((item) => {\r\n\r\n        if (distanceTable[item.data] === -1) {\r\n          distanceTable[item.data] = [1 + curr_distance, curr.data];\r\n          console.log(distanceTable);\r\n          if (item.adjacencySet.length > 0) {\r\n            queue.offer(item);\r\n          }\r\n        }\r\n      })\r\n\r\n    }\r\n    return distanceTable;\r\n  }\r\n\r\n  shortestPath(source, destination) {\r\n    const distanceTable = this.buildDistanceTable(source);\r\n    const path = [destination];\r\n    let prev = distanceTable[destination][1];\r\n    while (prev !== -1 && prev !== source) {\r\n      path.unshift(prev);\r\n      prev = distanceTable[prev][1];\r\n    }\r\n    if (prev === null) {\r\n      console.log(\"There's no path from source to destination\");\r\n    } else {\r\n      path.unshift(source);\r\n      path.map(item => {\r\n        console.log(item);\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nclass GraphNode {\r\n  constructor(data) {\r\n    this.data = data;\r\n    this.adjacencySet = new Set();\r\n  }\r\n  addEdge(node) {\r\n    this.adjacencySet.add(node)\r\n  }\r\n}\r\n\r\ngraph = new Graph(directed = false);\r\ngraph.addEdge(0, 1);\r\ngraph.addEdge(1, 2);\r\ngraph.addEdge(1, 3);\r\ngraph.addEdge(2, 3);\r\ngraph.addEdge(1, 4);\r\ngraph.addEdge(3, 5);\r\ngraph.addEdge(5, 4);\r\ngraph.addEdge(3, 6);\r\ngraph.addEdge(6, 7);\r\ngraph.addEdge(0, 7);\r\n\r\ngraph.stringify();\r\ngraph.shortestPath(1, 7);```\n\r\n\r\n\r\n\n\nWhen I run this it give 1, 7 however that's not the shortest path. What am I doing wrong here.\n    ", "Answer": "\r\nYou have 2 issue in your code (that sabotage the building of the distance table):\n\n\nYou missing index in: ```\nif (distanceTable[item.data] === -1) {```\n -> each item in the distance table is of array therefor it need to be: ```\nif (distanceTable[item.data][0] === -1) {```\n\nSet size in ```\nnode js```\n checked with ```\nsize```\n and not ```\nlength```\n (as in documentation) therefor ```\nitem.adjacencySet.length```\n is always ```\nundefined```\n so you need to change: ```\nif (item.adjacencySet.length> 0) {```\n to ```\nif (item.adjacencySet.size > 0) {```\n   \n\n\nAfter those 2 changes your code return me path of ```\n1 -> 0 -> 7```\n\n\nJust small side issue: you missing some ```\n;```\n and \"new\" before throwing ```\nTypeError```\n...\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all paths in a directed, unweighted graph for a selected node\r\n                \r\nThere have been a few similar questions around this topic but I am having trouble finding something that matches my requirements. I am working on a food web program (in Javascript) and am interested in finding all the possible food chains (paths) that involve a selected species (node). In other words, when someone selects a species in the graph, I want to list or highlight each of the individual food chains that involve the selected species. See an EOL Food Web for an example of the type of graph I am working on.\n\nI'm hoping this shouldn't be too complicated because the edges are unweighted (have no value) but do have a direction. I don't need shortest or longest path - just all possible variations involving the species in question.\n\nI was thinking that a clever solution might involve finding all the \"down\" (towards prey) paths from the selected node first and then do the same for \"up\" (towards predators) paths. Then just concatenate the downs and ups for all possible combinations. But that likely isn't very elegant.\n\nMany thanks for your ideas!\n    ", "Answer": "\r\nYour solution is roughly correct.\n\n\nRecursively traverse the graph \"downwards\" recording all paths.\nRecursively traverse the graph \"upwards\" recording all paths.\nProduce all path combinations from the previous two sets.\n\n\nThis assumes that the graph has no cycles (i.e. no creature feeds on itself or on any of its predators or predators of predators, etc.)\n\nHere is some pseudocode for traversal. Starting at the node of interest using a recursive approach:\n\n```\npaths := []\nfor all children\n    extendPath(paths, child)\n\n\nfunction extendPath(NodeList[] paths, Node node)    \n    for path in paths\n        path.add(node)\n\n    for child in node.children\n        extendPath(paths, child)\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Validate a given path and find total number of valid paths in an undirected and unweighted graph\r\n                \r\nI have a non-directed and unweighted graph as attached to this post. You can traverse on this graph only once on each edges. No repetitions. Challenge is to write a program that validates path on a given string as valid or invalid path. And also to find number of all valid path from one point to another.\n\nE.g. for Valid paths:\n\n\nABCDE\nABDE\nABCDBCDBCDE\nABCDBDE\n\n\nE.g. for Invalid paths:\n\n\nABE\nABA\nABCDBCDBCDBCDBCDE\n\n\nNumber of possible paths from A to B: 1\nNumber of possible paths from A to E: 2501\n\nThis is the question I got for a programming interview. I know to validate given string with below python code:\n\n```\n# Adjacent Graph vertices with number of paths between those vertices\nroute_counter_config ={\n    ('A', 'B'): 1,\n    ('B', 'C'): 3,\n    ('B', 'D'): 2,\n    ('C', 'D'): 3,\n    ('D', 'E'): 1,\n}\n\n# Below dict keeps same keys as above dict but updates count while validating\ninput_route_counter = {}\n\ndef reset_input_route_counter():\n    \"\"\"\n    Resets counter for all the edges.\n    \"\"\"\n    for key in route_counter_config.keys():\n        input_route_counter[key] = 0\n\ndef valid_route(route):\n    reset_input_route_counter()\n    for i in range(len(route) - 1):\n        # Grab current and next vertice in user input and make sorted tuple of it to match the keys set in dict.\n        adjacent_route = tuple(sorted(route[i]+route[i+1])) \n        try:\n            input_route_counter[adjacent_route] += 1\n        except KeyError:\n            # if edge is invalid\n            return False\n        else:\n            # When number of possible path crosses the limit\n            if input_route_counter[adjacent_route] > route_counter_config[adjacent_route]:\n                return False\n    return True\n\n# valid paths\nvalid_route(\"ABC\")\nvalid_route(\"ABCDBCDBCDE\")\n\n# invalid paths\nvalid_route(\"ABA\")\nvalid_route(\"AE\")\n```\n\n\nBut do not know how to find number of paths. Can use DFS for vertices that have maximum of one edge between adjacent vertices. But how to solve for multi-path graphs like this?\n\nNote: Mathematical and computer-graph theories are welcome in answers but I am preferably looking for a python solution. I have cross-checked with cstheory and math stackexhange sites already. However I am not good creating python code from the given algorithms as I am weak in maths. Also I did not find similar graph questions. I only found questions related to single-pathed graphs in those sites.\n\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding paths in (DAG) directed acyclic graph given destination\r\n                \r\nLet's say I have this array:\n\n```\nlet reportStructure = [|(2, 1); (3, 2); (4, 2); (5, 3); (6, 4); (7, 3)|]\n```\n\n\nwhere the first ```\nint```\n in a tuple reports to the second ```\nint```\n.\n\nI can map that really easily with \n\n```\nlet orgMap = Map.ofArray reporting\n```\n\n\nFrom there, I could easily get a list of all the ints that report to 2 with \n\n```\norgMap \n|> Map.filter (fun _ key -> key = 2)\n```\n\n\nwhich returns \n\n```\nmap [(3, 2); (4, 2)]\n```\n\n\nWhat I'd really like to see, however, is the entire structure, from 2 all the way down.  For example, I'd like to find a way that could give me the sample output\n\n```\nmap [(3, 2); (4, 2); (5, 3); (6, 4); (7, 3)]\n```\n\n\nif I'm looking for person 2 or \n\n```\nmap [(5, 3); (7, 3)]\n```\n\n\nif I'm interested in person 3.\n\nCan I do this?  If so, how?  Is there another structure other than a ```\nmap```\n that would be a better way to make this happen?\n\nThanks in advance for your help.\n    ", "Answer": "\r\nSince OCaml is close to F# and trying to find Topological sort in F# was not turning up anything useful I looked for OCaml code.\n\nI found An Introduction to Objective Caml which had a solution to your problem using Depth First Search and used it as the basis for this answer. Also because you are new to F# you can review the document and see how the code is derived. Oddly I took a look at the remainder of the document after posting this and he has a more advanced version of DFS latter in the document.\n\nYour input is an array ```\n[| |]```\n but your answer is a list ```\n[]```\n so I did most of the work as list. \n\nThe answers are not in the same order as you had, but they are in the same format.\n\n```\n    let reportStructure = [|(2, 1); (3, 2); (4, 2); (5, 3); (6, 4); (7, 3)|]\n\n    //\n    //  6 -> 4 -> 2\n    //  5 -> 3 -> 2 -> 1 \n    //  7 -> 3\n\n    // val revStructure : tl:('a * 'b) list -> ('b * 'a) list\n    let revStructure tl = List.map (fun (a,b) -> (b,a)) tl\n\n    // val mem : item:'a -> list:'a list -> bool when 'a : equality\n    let mem item list = List.exists (fun x -> x = item) list \n\n    // val successors : n:'a -> edges:('a * 'b) list -> 'b list when 'a : equality\n    let successors n edges = \n        let matching (s,_) = s = n\n        List.map snd (List.filter matching edges)\n\n    // val dist : pred:'a -> succs:'b list -> ('a * 'b) list\n    let dist pred succs = List.map (fun y -> (pred,y)) succs\n\n    // val dfsPairs : edges:('a * 'a) list -> start:'a -> ('a * 'a) list when 'a : equality\n    let dfsPairs edges start =\n        let rec dfsPairsInner edges visited start result = \n            match start with \n            | [] -> List.rev (revStructure result) \n            | n::nodes -> \n                if mem n visited then \n                    dfsPairsInner edges visited nodes result\n                else \n                    let predecessors = dist n (successors n edges)\n                    let result =\n                        match predecessors with\n                        | [] -> result\n                        | _ -> predecessors @ result\n                    dfsPairsInner edges (n::visited) ((successors n edges) @ nodes) result\n        dfsPairsInner edges [] [start] []\n\n    let revEdges = revStructure (List.ofArray reportStructure)\n\n    let result = dfsPairs revEdges 2\n    // val result : (int * int) list = [(4, 2); (3, 2); (7, 3); (5, 3); (6, 4)]\n\n    let result = dfsPairs revEdges 3\n    // val result : (int * int) list = [(7, 3); (5, 3)]\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "using STDistance in SQL server to find shortest path in graph\r\n                \r\nI have a table which contain information about edges of the graph in form of ```\ngeometry linestring```\n. Spatial result of query ```\nselect * from edge```\n look like this\n\nEACH ```\nlinestring```\n is created always from two ```\ngeometry points```\n with insert statement like:\n\n```\nINSERT INTO edge VALUES( geometry::Parse('LINESTRING(1 1 ,1 2)'))\n```\n\n\nIn order to finding shortest path between two points I have implemented ```\nDijkstra```\n algorith according to Dijkstra in c#, However I have found out about STDistance() function which is ment to do the same thing just by executing simple query. Could anyone give me a hint how could I use ```\nSTDistance```\n with objects created like I described? Every example I find use ```\nlinestrings```\n created from 3 points. \n\nI have difficulty using example in the situation I have lets say 3 ```\nlinestrings```\n as bellow:\n\n```\nINSERT INTO edge VALUES( geometry::Parse('LINESTRING(1 1 ,1 2)'))\nINSERT INTO edge VALUES( geometry::Parse('LINESTRING(1 2 ,1 3)'))\nINSERT INTO edge VALUES( geometry::Parse('LINESTRING(1 3 ,1 4)'))\n```\n\n\nand finding shortest path from ```\n1 1```\n to ```\n1 4```\n\n\nEdit:\nI have suceeded with combining all linestrings into one shape by:\n\n```\nSELECT geometry::UnionAggregate(linestring) FROM edge\n```\n\n\ni get shape :\n\n\n  0x000000000104160000002242C0E56A32834050D72864D98D714000000000003082400000000000B0784000000000000071400000000000A075402242C0E56A32834050D72864D98D7140CFB591AC8CBA83402B7FD245B3976B400000000000F087400000000000806F402242C0E56A32834050D72864D98D7140CFB591AC8CBA83402B7FD245B3976B40000000000000854000000000004053400000000000E06940000000000080504000000000009076400000000000C06340F89FD09A6BDC8140A4AC72B9CEDB69404AAD03D8122784408FC4879BE4996540CFB591AC8CBA83402B7FD245B3976B40F89FD09A6BDC8140A4AC72B9CEDB694000000000000071400000000000A075400000000000E06940000000000080504000000000001073400000000000C05E4000000000009076400000000000C06340000000000000854000000000004053404AAD03D8122784408FC4879BE49965400000000000688B40000000000040504004000000010000000001040000000108000000010A00000005000000FFFFFFFF0000000005000000000000000002000000000100000002000000000200000002000000000300000002\n\n\nNow I use ```\nSTDistance```\n as follows: \n\n```\nSELECT (geometry::UnionAggregate(linestring)).STDistance(geometry::STGeomFromText('POINT(0 0)', 0)) FROM edge\n```\n\n\nHowever the return value is about distance between point (0,0) and presented shape, when my intend is to count edges length from one point to the other, any clues?\n    ", "Answer": "\r\nCode Kata. As others have said in comments STDistance will give you the minimum straight line distance between two geometry objects, not a path through a graph. Implementing Dijkstra in Sql is beyond me, but the brute force method is  acceptable for small numbers of nodes such as you've demonstrated. This code calculates all paths within the graph from A to B and then selects the shortest.\n\nPlease note that this is a only a proof that it can be done, not a recommendation that it should be done. Your existing code in c# is probably simpler and quicker.\n\nThanks for giving me an opportunity to learn about geometry functions in sql server. \n\n```\n-- Declare and set parameters.\nDECLARE @start geometry, @end geometry\n\nSET @start = geometry::STGeomFromText('POINT(-1 1)', 0);\nSET @end = geometry::STGeomFromText('POINT(1 3)', 0);\n\n-- Caching of ST function results and for reversibility.\nDECLARE @segments TABLE  (\nedge geometry,\nstart_point geometry,\nend_point geometry,\n[weight] float\n)\nINSERT @segments\n        ( edge, start_point, end_point, [weight])\nSELECT e, e.STStartPoint(), e.STEndPoint(),  e.STLength() FROM edge UNION ALL \n-- Can traverse edges both ways unless we're in a directed graph?\nSELECT e, e.STEndPoint(), e.STStartPoint(),  e.STLength() FROM edge \n\n-- We need to know number of edges for some bookkeeping later.\nDECLARE @total_edges INT\nSELECT @total_edges = COUNT(*) FROM edge;\n\n-- Meat of the procedure. Find all sensible paths from @start to @end allowed by the graph, using a recursive common table expression.\nWITH cte (path, start_point, end_point, [weight], segments_traversed) AS (\nSELECT \n    edge AS path,\n    start_point, \n    end_point, \n    [weight] ,\n    1 AS segments_traversed\nFROM \n    @segments \nWHERE \n    @start.STEquals(start_point) = 1 UNION ALL \nSELECT \n    c.path.STUnion(s.edge) AS PATH,\n    s.start_point, \n    s.end_point, \n    s.[weight] + c.[weight] AS weight,\n    c.segments_traversed + 1 AS segments_traversed\nFROM cte c \n    INNER JOIN @segments s ON \n        -- next edge must start where this one ended.\n        s.start_point.STEquals(c.end_point) = 1 AND \n        -- terminate paths that hit the endpoint.\n        c.start_point.STEquals(@end) = 0 AND\n        -- if we traveled more than the number of edges there's surely a better path that doesn't loop!    \n        -- also acts as a guarantee of termination.  \n        c.segments_traversed < @total_edges\n)\nSELECT TOP 1\n    path \nFROM \n    cte c\nWHERE \n    -- Restrict to paths ending at end point.\n    c.end_point.STEquals(@end) = 1\nORDER BY \n    weight ASC\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding the shortest path in a maze graph using adjacency matrix\r\n                \r\nI have some troubles with solving of a particular problem that is to find the shortest path in the maze graph. Probably, I'm stucked because of the fact that the maze is initialized by a four dimensional array like \n```\nadjacent = new boolean[height][width][height][width];```\n \nThe first and second pair of indices specify a location in the graph in row/column formation. The graph looks like this:\n\n```\nXXXXXXXXXXXXX\n..........X.X\nX.XXX.XXX.X.X\nX.X.X...X.X.X\nX.X.XXX.XXX.X\nX...X.....X..\nXXXXXXXXXXXXX\n```\n\n\nThe ArrayList must hold the locations of the vertices in the path, in order from start to end inclusive.\n\nI've already written the constructor and connection method; however, I have trouble with the finding shortest path method.\nHere is the example of how I create the maze graph:\n\n```\nfinal int edges[][] = {{1, 0, 1, 1}, {1, 1, 1, 2}, {1, 1, 2, 1}, \n                {1, 2, 1, 3}, {1, 3, 1, 4}, {1, 4, 1, 5}, {1, 5, 1, 6}, \n                {1, 5, 2, 5}, {1, 6, 1, 7}, {1, 7, 1, 8}, {1, 8, 1, 9}, \n                {1, 9, 2, 9}, {1, 11, 2, 11}, {2, 1, 3, 1}, {2, 5, 3, 5}, \n                {2, 9, 3, 9}, {2, 11, 3, 11}, {3, 1, 4, 1}, {3, 3, 4, 3}, \n                {3, 5, 3, 6}, {3, 6, 3, 7}, {3, 7, 4, 7}, {3, 11, 4, 11}, \n                {4, 1, 5, 1}, {4, 3, 5, 3}, {4, 7, 5, 7}, {4, 11, 5, 11}, \n                {5, 1, 5, 2}, {5, 2, 5, 3}, {5, 5, 5, 6}, {5, 6, 5, 7}, \n                {5, 7, 5, 8}, {5, 8, 5, 9}, {5, 11, 5, 12}};\n\n        MazeGraph maze = new MazeGraph(13, 7); \n\n        for (int[] edge : edges) \n            maze.connect(new Location(edge[0], edge[1]), new Location(edge[2], edge[3]));\n```\n\n    ", "Answer": "\r\nFirst of all, this\n```\nadjacent = new boolean[height][width][height][width];\n```\n\ncontradicts with this:\n\nThe first and second pair of indices specify a location in the graph\nin row/column formation.\n\nIt is column/row, not row/column.\nDijkstra's algorithm should be implemented for your matrix. Quote:\n\nLet the node at which we are starting be called the initial node. Let\nthe distance of node Y be the distance from the initial node to Y.\nDijkstra's algorithm will assign some initial distance values and will\ntry to improve them step by step.\n\nAssign to every node a tentative distance value: set it to zero for\nour initial node and to infinity for all other nodes.\n\nSet the initial node as current. Mark all other nodes unvisited. Create a set of all the unvisited nodes called the unvisited set.\n\nFor the current node, consider all of its unvisited neighbors and calculate their tentative distances. Compare the newly calculated\ntentative distance to the current assigned value and assign the\nsmaller one. For example, if the current node A is marked with a\ndistance of 6, and the edge connecting it with a neighbor B has length\n2, then the distance to B (through A) will be 6 + 2 = 8. If B was\npreviously marked with a distance greater than 8 then change it to 8.\nOtherwise, keep the current value.\n\nWhen we are done considering all of the neighbors of the current node, mark the current node as visited and remove it from the\nunvisited set. A visited node will never be checked again.\n\nIf the destination node has been marked visited (when planning a route between two specific nodes) or if the smallest tentative\ndistance among the nodes in the unvisited set is infinity (when\nplanning a complete traversal; occurs when there is no connection\nbetween the initial node and remaining unvisited nodes), then stop.\nThe algorithm has finished.\n\nOtherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new \"current node\", and go\nback to step 3.\n\n\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths in a directed acyclic graph in MATLAB\r\n                \r\nI have a directed acyclic graph (DAG) with edges defined by the following vectors:\n\n```\n 1     2\n 1     3\n 1     4\n 2     5\n 3     5\n 4     6\n 5     7\n```\n\n\nwhere the left vector is the \"from\" node and the right vector is the \"to\" node.\n\nI need a simple way in Matlab to extract all the paths starting at node 1 and terminating at a leaf node.\n\nThe output should be like this:\n\n```\n 1     1     1\n 2     3     4\n 5     5     6\n 7     7     \n```\n\n\nI made the following code to achieve this:\n\n```\nclc\nclear all\nfilename = 'pre-paths.xlsx';\nplans = xlsread(filename)\n\nPaths = zeros(0,0);\nPathNo = 1;\nwhile(1)\n    plan = plans;\n    x = 1;\n    j = 1;\n    Activity = plan(PathNo, 1);\n    Predecessor = plan(PathNo, 2);\n    while(1)\n        NewPath(j) = Activity;\n        j = j + 1;\n        NewPath(j) = Predecessor;\n        j = j + 1;\n        if(any(plan(:,1) == Predecessor) == 0)\n            break;\n        end\n        ActivityIndex = find(plan(:,1) == Predecessor);\n        Activity = plan(ActivityIndex(1), 1);\n        Predecessor = plan(ActivityIndex(1), 2);\n        x = x + 1;\n        plan = plan(2:size(plan,1), :);\n    end\n    NewPath = unique(NewPath);\n    for index = 1 : size(NewPath(:))\n        Paths(index, PathNo) = NewPath(index);\n    end\n    PathNo = PathNo + 1;\n    n = plans(PathNo, 1);\n    anyn = any(plans(:,2) == n);\n    if(anyn)\n        break;\n    end\nend\nfor i = find(Paths == 0)\n    Paths(i) = max(Paths(:)) + 1;\nend\nPaths\nxlswrite('paths.xlsx',Paths);\n```\n\n\nBut the problem is the code above works only on the test case I mentioned earlier. When I use it on different vectors the output resulted is wrong.\n\nI'm not very strong in MATLAB and not a professional coder. Can someone help me understand a better way to do this?\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Using BFS/DFS To Find Path With Maximum Weight in Directed Acyclic Graph\r\n                \r\nYou have a 2005 Honda Accord with 50 miles (weight max) left in the tank. Which McDonalds locations (graph nodes) can you visit within a 50 mile radius? This is my question.  \n\nIf you have a weighted directed acyclic graph, how can you find all the nodes that can be visited within a given weight restriction? \n\nI am aware of Dijkstra's algorithm but I can't seem to find any documentation of its uses outside of min-path problems. In my example, theres no node in particular that we want to end at, we just want to go as far as we can without going over the maximum weight. It seems like you should be able to use BFS/DFS in order to solve this, but I cant find documentation for implementing those in graphs with edge weights (again, outside of min-path problems).   \n    ", "Answer": "\r\nFinding the longest path to a vertex V (a McDonald's in this case) can be accomplished using topological sort. We can start by sorting our nodes topologically, since sorting topologically will always return the source node U, before the endpoint, V, of a weighted path. Then, since we would now have access to an array in which each source vertex precedes all of its adjacent vertices, we can search through every path beginning with vertex U and ending with vertex V and set a value in an array with an index corresponding to U to the maximum edge weight we find connecting U to V. If the sum of the maximal distances exceeds 50 without reaching a McDonalds, we can backtrack and explore the second highest weight path going from U to V, and continue backtracking should we exhaust every path exiting from vertex U. Eventually we will arrive at a McDonalds, which will be the McDonalds with the maximal distance from our original source node while maintaining a total spanning distance under 50. \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding shared edges in two paths in a Boost Graph\r\n                \r\nI'm new to the Boost Graph Library and have hit a conceptual roadblock. Instead of creating a likely very hacky fix I'm turning here for ideas that respect good practices. \n\nI have a directed multigraph implemented as a boost adjacency_matrix. I have defined custom edge and vertex structs along these lines, with a few more entries:\n\n```\nstruct Vertex\n{\n    int id;\n    std::pair <double, double> coords;\n};\n\nstruct Edge\n{\n    double distance;\n    double cost;\n    std::string name;\n};\n```\n\n\nThen the graph is constructed from information read from a csv containing station coordinates and distances grabbed from graphhopper. I define a graph as shown in the adjacency_matrix documentation using my vertex and edge structs\n\n```\ntypedef boost::adjacency_matrix<boost::directedS, Vertex, Edge> Graph;\n```\n\n\nThe problem: I have std::vectors of edge objects corresponding to cycles in the graph. I would like to compute the intersection of the two cycles as sets of edges.  \n\nInitially I wanted to use set_intersection, but to do that I'd have to write comparators for my edge objects. I realised that doing that would probably be duplicating functionality already in Boost.  I had a look through the documentation, but didn't find an obvious answer. \n\nCurrently I'm thinking of defining a property map for edges and getting the edge indices then comparing those, then translating the indices back to edges and adding them to an unsorted_set, that seems like a bad solution and it feels like there's probably a better way. Any ideas would be appreciated, thanks!\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Count all possible paths in a graph database for multiple vertices\r\n                \r\nI have a graph db and I need to get all the vertices that doesn't have any out edges and count how many vertices lead to each one\n\nex.\n\nI have 8 vertices A,B1,B2,D, X,Y1,Y2,Z\n\nD->B1->A\n\nB2->A\n\nZ->Y1->X\n\nY2->X\n\nI would like to get a list the would have [A = 3, X = 3] plus the properties of each vertex\n\nwhy 3? cause you can get to A from D, B1, and B2\n\nwhat I have so far is to get the count of paths of one vertex but doing that query for each one is a bit slow, so I would like one query that will give me all that info\n\n```\ng.V().not(outE()).repeat(inE().outV().simplePath()).emit().dedup().count().next()\n```\n\n    ", "Answer": "\r\nIt looks like you had the right query, just need to add ```\ngroup```\n to it:\n\n```\ng.V().not(outE()).group()\n.by(label())\n.by(repeat(inE().outV().simplePath()).emit().dedup().count())\n```\n\n\nI tested it here.  seems to work as expected\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm to compare similarity of directed paths through directed graph\r\n                \r\nI have a directed graph with two directed paths in it. \n\nI want an algorithm to determine the similarity between the two paths. \n\nThis post mentions using the Levenshtein distance to determine an approximate similarity. I also realize that the Hamming distance uses a similar metric.\n\nMy question is:\n\nHow do you handle the case where two paths run parallel to each other. That is if the two paths have no similar nodes, yet would be considered 'similar' because their paths travel in the same direction very close to each other.\n\nThanks\n    ", "Answer": "\r\nThe simple answer is that this is a very hard question, and relies a lot on your definition of what 'similar' means in a graph. In most graphs you could rearrange the nodes of two disjoint paths in a planar fashion so as to appear to run 'parallel'.\n\nA good place to start looking at more advanced similarity metrics would be to consider the graph's adjacency matrix, and look at various matrix similarity algorithms.\n\nEdit: Restricting the question to Euclidian graphs\n\nThere's plenty of active research on this question when restricting the domain to Euclidian graphs, as this is an applicable topic to areas like GIS, machine learning applications to robotics, and collaborative filtering on social networks / artificial networks like the web. Check out the articles on google scholar.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find the shortest paths in a graph from s to all Vertices\r\n                \r\nGiven the following problem : \n\n\n  Given the directed graph G=(V,E) with the weight function W:V→R , describe an algorithm \n  that find the shortest paths from S to all other Vertices , where the length of the \n  path equals to the SUM of all the vertices.You need to change an existing algorithm , \n  to make that work , so there's no need to write a new algorithm.\n\n\nPlease notice that the weight function is on the Vertices and NOT(!!) on the Edges .\nWhat I was thinking is to change the Bellman-Ford algorithm and change the Relax check to the following :\n\n```\n1.if d[v]>d[u]+w[u]\n 1.1 d[v] <<--  d[u]+w[u]\n 1.2 PI[v] <<-- u\n```\n\n\nI don't think this works good enough , any idea what might be the problem ? \n\nthanks ,Ron\n    ", "Answer": "\r\nlet ```\nw:V->R```\n be your weight function. \n\nCreate a weightening function: ```\nw':E->R```\n as follows: ```\nw'(u,v) = w(v)```\n\n\nRun dijkstra/bellman-ford with w'. let d'[v] be the minimal path's weight to v, according to w'.\n\nThen if the shortest path is ```\ns->u1->u2->...->un->v```\n, you get: ```\nd'[v] = w'(s,u1) + w'(u1,u2)  + ... + w'(un,v)```\n [by correctness of dijkstra/bellman fofrd] and thus ```\nd'[v] = w(u1) + w(u2) + ... + w(un) + w(v)```\n [by definition of w'].\n\nso, at overall you get: ```\nd[v] = w(s) d'[v]```\n and d[v] is the shortest path for vertices.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Better performance for the shortest paths in undirected unweighted graph\r\n                \r\nI got the undirected unweighted graph. Where every node represents one city. Every city produces one type of grocery (does not have to be unique).\nThen you will have on the input a number of type groceries which has to be delivered to every city. You can transport every grocery separately and it has to be the shortest way. The distance between every node is 1.\n\nActually, I'm using BFS for every node. But there should be a better solution.\n\n```\nExample: \nINPUT:\n\n5(number of nodes) 5(number of edges) \n4(number of groceries) 3(required number of groceries in every city)\n0 1 3 2 1 ( city(node number) has grocery 0->0 1->1 2->3 3->2 4->1)\n0 1 (edges)\n2 1 (edges)\n2 3 (edges)\n3 0 (edges)\n4 3 (edges)\n\nOUTPUT:\n11 (total distance)\n2(total distance for town) 0 1 2 (groceries in the city)\n2 1 0 3\n2 3 1 2\n2 2 0 1\n3 1 2 0\n```\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in ordered graph\r\n                \r\nLet G = (V, E) be a directed graph with nodes v_1, v_2,..., v_n. We say that G is an ordered graph if it has the following properties.\n\n\nEach edge goes from a node with lower index to a node with a higher index. That is, every directed edge has the form (v_i, v_j) with i < j.\nEach node except v_n has at least one edge leaving it. That is, for every node v_i, there is at least one edge of the form (v_i, v_j). \n\n\nGive an efficient algorithm that takes an ordered graph G and returns the length of the longest path that begins at v_1 and ends at v_n. \n\nIf you want to see the nice latex version: here\n\nMy attempt:\n\nDynamic programming. Opt(i) = max {Opt(j)} + 1. for all j such such j is reachable from i. \n\nIs there perhaps a better way to do this? I think even with memoization my algorithm will still be exponential. (this is just from an old midterm review I found online)\n    ", "Answer": "\r\nYour approach is right, you will have to do \n\n```\nOpt(i) = max {Opt(j)} + 1} for all j such that j is reachable from i\n```\n\n\n\n\nHowever, this is exponential only if you run it without memoization. With memoization, you will have the memoized optimal value for every node j, j > i, when you are on node i.\n\nFor the worst case complexity, let us assume that every two nodes that could be connected are connected. This means, ```\nv_1```\n is connected with ```\n(v_2, v_3, ... v_n)```\n; ```\nv_i```\n is connected with ```\n(v_(i+1), v_(i+2), ... v_n)```\n.\n\nNumber of Vertices (```\nV```\n) = n\n\nHence, number of edges (```\nE```\n) = ```\nn*(n+1)/2 = O(V^2)```\n\n\nLet us focus our attention on a vertex ```\nv_k```\n. For this vertex, we have to go through the already derived optimal values of ```\n(n-k)```\n nodes.\n\nNumber of ways of reaching ```\nv_k```\n directly = (k-1)\n\nHence worst case time complexity => ```\nsigma((k-1)*(n-k)) from k=1 to k=n```\n, which is a sigma of power 2 polynomical, and hence will result in ```\nO(n^3)```\n Time complexity.\n\nSimplistically, the worst case time complexity is ```\nO(n^3) == O(V^3) == O(E) * O(V) == O(EV)```\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in precedence graph\r\n                \r\nI'm looking for an algorithm to determine the shortest path of a precedence graph with consideration of a connection graph. I looked into Dijkstra and Bellman Ford, but I don't think that they are viable for a precedence graph, because they only go outwards through one edge at every vertex.\nBut In a precedence graph there are also cases where you have to go through two or more edges to reach the next vertex. For example to disassemble you have to remove parts A and B first befor you can reach part C.\n\nWhat I try to solve: \nI have a simple precedence graph representing how to disassemble a product. Every vertex has a cost (time units). In this graph I have a start and destination. The result should be the minimum amount of time needed for disassembly.\n\nAlso to consider is that you could disassemble moules as a whole to reach a specific part depending on the connection graph. This graph shows how the parts are actually connected with each other. Like A,B and C have to be removed to reach D. A has to be removed first. Then you could remove B and C as a whole (removing C while B is still attached to it).\n    ", "Answer": "\r\nI now used the Deep-first search algorithm with some modifications to fit my purpose for the first part. The second part, where also modules should be considered to be disassembled instead of every single peace, is still missing. Maybe with some more modifications to the algorithm it could be possible as well.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All paths in a graph between 2 nodes after implementing Dijkstra\r\n                \r\nI am working on a huge optical networks project where the networks are represented as undirected graphs where cycles may exist. At some point i want to find all minimum hop paths between two nodes in the graph that represent an arbitrary optical connection. I successfully implemented Djikstra with weight 1 to all edges to find minimum hop paths instead of minimum weights and modified the relaxation step to save all parents of a node instead of one (added code to save when distance is equal instead of just smaller). So now in the example network below i have going from node 0 to node 4: node 1 has parent 0, node 2 has parent 0, node 3 has parents 1,2 and node 4 has parent 3. Each node combination is an object cell in a 2d array and one of many attributes of each cell is a list of its parents (that is, a search for a parent in cell 0,3 gives the parent(s) of 3 when going from 0 to 3) \n\n```\n0 ---- 1\n|      |\n2 ---- 3 --- 4\n```\n\n\nNow I'm stuck. I want to save in a way all minimum hop paths from all sources to all destinations in the graph so i can provide minimum hop paths to any possible arbitrary connection. Can you please recommend a solution to this? I'm working on it for days and I'm truly stuck.\nThank you in advance.\n    ", "Answer": "\r\nYour main problem is going to be storage.\n\nSay that you have 10000 nodes. Then for each node N(i), you want to store the next minimum hop towards all possible destinations. This means 9999 nodes for each node in the graph, that is, you need to store at 3*N^2 node values.\n\nAt that point, going from node N(i) to node N(j) will mean:\n\n```\nk = i\nwhile k is not j:\n    h = 0\n    while h < length(N(k).NextHops)\n        if N(k).NextHops(h).Destination is j:\n           k = N(k).NextHops(h).NextNode\n           break\n        else:\n           h = h+1\n    # if h == length of NextHops, \"No Route To Host\"\n```\n\n\nYou can initialize NextHops using Dijkstra (without terminating it once the shortest path has been found): start with first node and explore the whole graph storing in each node the distance to the first node, and the previous-node supplying that distance. At the end, the tuple { Dest: i; Cost: ?; Next: ? } will be initialized for all nodes. If the graph is connected, you will have N-1 entries for each node, so you can use a 2-tuple { Cost, Next } at position i of the array.\n\nFor a connected graph the route-finding algorithm becomes then\n\n```\ndef findpath(i, j):\n    k = i\n    p = []\n    c = 0\n    while k is not j:\n        p += i\n        c += N[k].NextHops[j].Cost\n        k =  N[k].NextHops[j].Next\n\n    return { 'path': p, 'cost': c }\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in precedence graph\r\n                \r\nI'm looking for an algorithm to determine the shortest path of a precedence graph with consideration of a connection graph. I looked into Dijkstra and Bellman Ford, but I don't think that they are viable for a precedence graph, because they only go outwards through one edge at every vertex.\nBut In a precedence graph there are also cases where you have to go through two or more edges to reach the next vertex. For example to disassemble you have to remove parts A and B first befor you can reach part C.\n\nWhat I try to solve: \nI have a simple precedence graph representing how to disassemble a product. Every vertex has a cost (time units). In this graph I have a start and destination. The result should be the minimum amount of time needed for disassembly.\n\nAlso to consider is that you could disassemble moules as a whole to reach a specific part depending on the connection graph. This graph shows how the parts are actually connected with each other. Like A,B and C have to be removed to reach D. A has to be removed first. Then you could remove B and C as a whole (removing C while B is still attached to it).\n    ", "Answer": "\r\nI now used the Deep-first search algorithm with some modifications to fit my purpose for the first part. The second part, where also modules should be considered to be disassembled instead of every single peace, is still missing. Maybe with some more modifications to the algorithm it could be possible as well.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in directed acyclic graph in jgrapht library\r\n                \r\nI want to find the longest path in directed (acyclic) graph. Let's say that I know starting node - sink. The path should begin from this point. \nI was thinking that I can set weights of edges to -1. There is many methods of finding all shortest path but you have to pass ending point. Is it possible to get the shortest path (no matter the end node)?\n\n```\nDirectedAcyclicGraph graph = new DirectedAcyclicGraph<Integer, DefaultEdge>(DefaultEdge.class);\ngraph.addVertex(1);\ngraph.addVertex(2);\ngraph.addVertex(3);\ngraph.addVertex(4);\ngraph.addVertex(5);\ngraph.addVertex(6);\ngraph.addVertex(7);\ngraph.addVertex(8);\ntry {\n    graph.addDagEdge(1, 2);\n    graph.addDagEdge(2, 3);\n    graph.addDagEdge(3, 4);\n    graph.addDagEdge(5, 6);\ngraph.addDagEdge(2, 7);\ngraph.addDagEdge(7, 8);\n} catch(Exception e) {\n\n}\n//????????????????\n```\n\n\nLet's say that I'd like to find longest path for node nr 1 (sink). So this algoritm shoud give me 1-2-3-4-5-6. \n    ", "Answer": "\r\nI was looking for an answer to a similar question to calculate parallel build groupings in Jenkins from a DAG of Git repos.  To solve it, I applied the algorithm described here and here.  The code below is written in Groovy, so you'll have to convert to Java.  The result is a Map of vertices to their respective max depths.  From that you can get the single largest value.  If instead you want to know the max depth from a specific vertex in the graph, you can first prune the graph into a subgraph rooted by your desired source vertex and then run the method below on the subgraph.\n\n```\ndef calcDepths(g) {    \n\n    Map<String, Integer> vertexToDepthMap = new HashMap<>()\n\n    Iterator<String> iterator = new TopologicalOrderIterator<String, DefaultEdge>(g)\n    iterator.each { v ->\n\n        Set<String> predecessors = Graphs.predecessorListOf(g, v).toSet()\n        Integer maxPredecessorDepth = -1\n        predecessors.each { predecessor ->\n\n            maxPredecessorDepth = Math.max(maxPredecessorDepth, vertexToDepthMap.get(predecessor))\n        }\n\n        vertexToDepthMap.put(v, maxPredecessorDepth + 1)\n    }\n\n    return vertexToDepthMap\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "find the shortestS paths in an unweighted graph by a max flow constraint\r\n                \r\nMy problem is that I want to find the shortestS(most possible paths) between a vertex S and T in a graph, but I have a flow constraints too, because the problem state:\n\n-you have a number of ants(or whatever) / a number of rooms / and a number of links between them, I've to send my ants one turn at a time, from S through my graph, to reach T, but all rooms can contains only one ants at a time except for S and T and the ants may not get stuck in a room during several turn.\n\nso I've a flow graph with all the edges with capacity of one (to respect the no more than one ants in each room).\n\nAnd here I end up with a problem which is between max flow and shortest path, because some shortcuts between two paths could exists, sometimes if I've only one or a little number of ants, that'll be better to take just one path (take the shortcut) and send my ants in single file, but at a certain number of ants it'll be better to take two path, not use the shortcut and send my ants two by two, one in each path, by doing so i'll end up with fewest turn for pass all my ants from S to T.\n\nSo far I've found some good algorithms for shortests path, but they always gave me the wrong answer, because they could find blocking flows, meaning take one shortest path instead of two which could have been better, to avoid this problem I've look to max flow problem, with algo like ford fulkerson, because I can track blocking flow and reverse them by looking precisely at if it's worth to reverse a shortcut according to my ants, but there's no notion of weight, so all the shortcut (which will be reverse by max flow algo, because shortcuts are the only things that could cause blocking flow), will be reverse but randomly, so that's harder to prove but i'm pretty sure that that's wrong too, I think it's a better and more precise way to do it than only a shortest path algo, but I'm sure it's again not correct at 100% specifically with graph containing a lot of shorcuts.\n\nSo yes it's school work, and I don't want my homework to be done by you, but I really want to go into this subject in depths, and I'm a beginner in all the graph stuff, so I'm interested into any algorithm that could help me, or whatever that could help!\n    ", "Answer": "\r\nI think you are on the right path looking at maximum flow algorithms. You could try the following three step approach:\n\n\nRebuild your graph in order to incorporate your (only one ant per room constraint). This can be done by replacing each room vertex v by two vertices v_1, v_2 and a directed edge e(v_1, v_2) with capacity 1. All incoming edges to v are connected to v_1 instead. All outgoing edges of v are connected to v_2 instead. This way only one ant can go through v (e(v_1, v_2)) at any point in time. Each initial edge between two rooms also gets a capacity of 1.\nRun the Ford–Fulkerson algorithm. This should tell you which edges to use in order to maximize the flow. In fact this should give you all distinct paths (where no two paths share a room) from S to T.\nOnce you have the distinct paths, you can calculate their lengths and from that it should be straightforward to calculate the necessary number of steps to get all ants from S to T.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find k shortest paths with graph-tool\r\n                \r\nI have a directed graph for which I am trying to find the top k shortest paths. At the moment I have implemented the network in graph-tool which provides a shortest path algorithm but no k shortest paths algorithm by what I can tell. I have come across this post (All shortest paths using graph_tool) but I am not after all paths connecting two nodes.\n\nIt seems as if NetworkX has a function implemented for this (https://networkx.readthedocs.org/en/stable/reference/generated/networkx.algorithms.shortest_paths.generic.all_shortest_paths.html?highlight=all_shortest_paths). Is there a way to somehow do this in graph-tool too or am I better off switching toolboxes and using NetworkX?\n    ", "Answer": "\r\nThis is available in the git version: https://graph-tool.skewed.de/static/doc/dev/topology.html#graph_tool.topology.all_shortest_paths\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm for finding undirected graph path\r\n                \r\nWhat is a simple algorithm for finding a path in an undirected graph?\n    ", "Answer": "\r\nThe simplest way to find whether a path exists is to implement depth-first search. If you've done other kinds of recursive programming in Scheme, depth-first search will be pretty natural. The idea is that for each node, if it's the destination you're done; otherwise you recur on each of its children.\n\nThe only catch is that you need to keep track of nodes that have already been visited during your traversal so you can avoid visiting the same node twice; otherwise if you have a graph A <--> B <--> C and you're checking to see if A connects to C, you might loop infinitely going from A to B, then B to A, then A to B, and so on forever.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all paths in undirected acyclic graph using Prolog\r\n                \r\n`I want to print all the ways to reach Node e from Node a in a weighted unidrected acyclic graph. but my program misses a few long routes.\nThis is my program.\n```\n%Declare all the edges\nedge(a,b,1). \nedge(a,c,6). \nedge(b,c,4). \nedge(b,d,3). \nedge(b,e,1). \nedge(c,d,1). \nedge(d,e,1).\n\n% Two nodes are adjacent if there exists a edge between them\nadj(X, Y, W) :- edge(X, Y, W).\nadj(Y, X, W) :- edge(Y, X, W).\n\n% return 0 weight and empty path because path is empty to reach the same node \n% from the node itself and therefor no wirght as well.\nfindpath(X, X, 0, []).\n\n% if X and Y are adjacent then append Y to X into the Path Variable\nfindpath(X,Y,Weight,Path) :- adj(X,Y,Weight),\n                             append([X],[Y],Path). \n\n% if X and Y are not adjacent, then consider nodes who are adjacent to Y with \n% weight W2 ,  recursively call path predicate replacing Y with A and W1 with W2\n% add their weight - W as W1 + W2 and append to Path. \nfindpath(X,Y,Weight,Path) :- not(adj(X,Y,Weight)), \n                             edge(A,Y,Weight1), \n                             findpath(X,A,Weight2,P1),\n                             Weight is Weight1+Weight2, \n                             append(P1,[Y],Path).\n```\n\n```\nOutput\n\n`2 ?- findpath(a, e, W, P).\nW = 2,\nP = [a, b, e] ;\nW = 2,\nP = [a, b, e] ;\nW = 5,\nP = [a, b, d, e] ;\nW = 5,\nP = [a, b, d, e] ;\nW = 8,\nP = [a, c, d, e] ;\nW = 8,\nP = [a, c, d, e] ;\nfalse.\n```\n\nMy program missed a, b, c, e and a, b, c, d ,e. I dont understand why ?\nAlso , it repeats the output as well.`\n    ", "Answer": "\r\n(There is no path \"abce\" since there is no connection between ```\nc```\n and ```\ne```\n)\n```\nadj/3```\n describes the very same solutions that ```\nedge/3```\n does.  You exchanged arguments both in the head and the goal. Exchange them only once.  Using ```\npath/4```\n gives you all acyclic paths. Then you need to add a weight.\n```\n:- set_prolog_flag(double_quotes, chars).\n\nadj(X, Y, W) :- edge(X, Y, W).\nadj(X, Y, W) :- edge(Y, X, W).\n\nadj(X,Y) :-\n   adj(X,Y,_).\n\n?- path(adj, Path, a,e).\n   Path = \"abcde\"\n;  Path = \"abde\"\n;  Path = \"abe\"\n;  Path = \"acde\"\n;  Path = \"acdbe\"\n;  Path = \"acbde\"\n;  Path = \"acbe\"\n;  false.\n\n?- setof(t,path(adj, Path, a,e),_).\n   Path = \"abcde\"\n;  Path = \"abde\"\n;  Path = \"abe\"\n;  Path = \"acbde\"\n;  Path = \"acbe\"\n;  Path = \"acdbe\"\n;  Path = \"acde\".\n?- path(adj, Path, a,Y).\n   Path = \"a\", Y = a\n;  Path = \"ab\", Y = b\n;  Path = \"abc\", Y = c\n;  Path = \"abcd\", Y = d\n;  Path = \"abcde\", Y = e\n;  Path = \"abd\", Y = d\n;  Path = \"abde\", Y = e\n;  Path = \"abdc\", Y = c\n;  Path = \"abe\", Y = e\n;  Path = \"abed\", Y = d\n;  Path = \"abedc\", Y = c\n;  Path = \"ac\", Y = c\n;  Path = \"acd\", Y = d\n;  Path = \"acde\", Y = e\n;  Path = \"acdeb\", Y = b\n;  Path = \"acdb\", Y = b\n;  Path = \"acdbe\", Y = e\n;  Path = \"acb\", Y = b\n;  Path = \"acbd\", Y = d\n;  Path = \"acbde\", Y = e\n;  Path = \"acbe\", Y = e\n;  Path = \"acbed\", Y = d\n;  false.\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find Minimum Cost Path in a directed graph\r\n                \r\nI was researching code about finding Minimum Cost Path in a directed graph online and I came across this code in geeksforgeeks here is the code.\n```\n// C++ Program to implement\n// the above approach\n#include <bits/stdc++.h>\nusing namespace std;\n \n// Stores minimum-cost of path from source\nint minSum = INT_MAX;\n \n// Function to Perform BFS on graph g\n// starting from vertex v\nvoid getMinPathSum(unordered_map<int,\n                                 vector<pair<int,\n                                             int> > >& graph,\n                   vector<bool>& visited,\n                   vector<int> necessary,\n                   int source, int dest, int currSum)\n{\n    // If destination is reached\n    if (source == dest) {\n        // Set flag to true\n        bool flag = true;\n \n        // Visit all the intermediate nodes\n        for (int i : necessary) {\n \n            // If any intermediate node\n            // is not visited\n            if (!visited[i]) {\n                flag = false;\n                break;\n            }\n        }\n \n        // If all intermediate\n        // nodes are visited\n        if (flag)\n \n            // Update the minSum\n            minSum = min(minSum, currSum);\n        return;\n    }\n    else {\n \n        // Mark the current node\n        // visited\n        visited = true;\n \n        // Traverse adjacent nodes\n        for (auto node : graph) {\n            if (!visited[node.first]) {\n \n                // Mark the neighbour visited\n                visited[node.first] = true;\n \n                // Find minimum cost path\n                // considering the neighbour\n                // as the source\n                getMinPathSum(graph, visited,\n                              necessary, node.first,\n                              dest, currSum + node.second);\n \n                // Mark the neighbour unvisited\n                visited[node.first] = false;\n            }\n        }\n \n        // Mark the source unvisited\n        visited = false;\n    }\n}\n \n// Driver Code\nint main()\n{\n    // Stores the graph\n    unordered_map<int, vector<pair<int,\n                                   int> > >\n        graph;\n    graph[0] = { { 1, 2 }, { 2, 3 }, { 3, 2 } };\n    graph[1] = { { 4, 4 }, { 0, 1 } };\n    graph[2] = { { 4, 5 }, { 5, 6 } };\n    graph[3] = { { 5, 7 }, { 0, 1 } };\n    graph[4] = { { 6, 4 } };\n    graph[5] = { { 6, 2 } };\n    graph[6] = { { 7, 11 } };\n \n    // Number of nodes\n    int n = 7;\n \n    // Source\n    int source = 0;\n \n    // Destination\n    int dest = 6;\n \n    // Keeps a check on visited\n    // and unvisited nodes\n    vector<bool> visited(n, false);\n \n    // Stores intemediate nodes\n    vector<int> necessary{ 2, 4 };\n \n    getMinPathSum(graph, visited, necessary,\n                  source, dest, 0);\n \n    // If no path is found\n    if (minSum == INT_MAX)\n        cout << \"-1\\n\";\n    else\n        cout << minSum << '\\n';\n    return 0;\n}\n```\n\nbut when the code is ran there were errors like this (this is just a small snipped of errors of the code)\n```\nmain.cpp:68:19: error: no match for ‘operator=’ (operand types are ‘std::vector’ and ‘bool’)\nmain.cpp:60:45: error: no match for ‘operator+’ (operand types are ‘int’ and ‘std::vector >’)\nmain.cpp:46:19: error: no match for ‘operator=’ (operand types are ‘std::vector’ and ‘bool’)\n```\n\nCan someone show me how to fix this im not that good at debugging good\n    ", "Answer": "\r\n```\nminPathSum```\n is implemented incorrectly. Seems as if it was improperly refactored at some point and was not even attempted to be compiled.\nThe lone ```\nvisited```\n occurrences should be ```\nvisited[source]```\n. and ```\nfor (auto node : graph)```\n should be ```\nfor (auto node : graph[source])```\n. Altogether:\n```\nvoid getMinPathSum(unordered_map<int,\n                                 vector<pair<int,\n                                             int> > >& graph,\n                   vector<bool>& visited,\n                   vector<int> necessary,\n                   int source, int dest, int currSum)\n{\n    // If destination is reached\n    if (source == dest) {\n        // Set flag to true\n        bool flag = true;\n \n        // Visit all the intermediate nodes\n        for (int i : necessary) {\n \n            // If any intermediate node\n            // is not visited\n            if (!visited[i]) {\n                flag = false;\n                break;\n            }\n        }\n \n        // If all intermediate\n        // nodes are visited\n        if (flag)\n \n            // Update the minSum\n            minSum = min(minSum, currSum);\n        return;\n    }\n    else {\n \n        // Mark the current node\n        // visited\n        visited[source] = true;\n \n        // Traverse adjacent nodes\n        for (auto node : graph[source]) {\n            if (!visited[node.first]) {\n \n                // Mark the neighbour visited\n                visited[node.first] = true;\n \n                // Find minimum cost path\n                // considering the neighbour\n                // as the source\n                getMinPathSum(graph, visited,\n                              necessary, node.first,\n                              dest, currSum + node.second);\n \n                // Mark the neighbour unvisited\n                visited[node.first] = false;\n            }\n        }\n \n        // Mark the source unvisited\n        visited[source] = false;\n    }\n}\n```\n\nExample\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Is there an algorithm to extend the shortest path in a graph until it cannot be extended further?\r\n                \r\nI want to find the longest path in a graph this graph is created from grid.\n\nGraph\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All possible path in a graph\r\n                \r\nGiven a graph G(V, E), a source vertex s and destination vertex d, the problem is to find all possible paths from s to d where G may contain loops and cycles. I want to get all simple paths, no cycle is allowed.\n\nWhat would be the complexity of this problem?  \n    ", "Answer": "\r\nThis problem is NP-hard, since its output may have an exponential size w.r.t its input.  \n\nFinding the longest path between two points is already NP-hard (reduction to hamiltonian path problem), so finding all of them is as well.  \n\nYou can also see that this problem has an exponential complexity by seeing that there might be an exponential number of paths between two vertices in a graph.\nHere is a small example:\nLet ```\nG```\n be a graph with ```\n3n+2```\n vertices. Let ```\nV = {s,d} U {a1, ..., an} U {b1, ..., bn} U {c1, ..., cn}```\n be its vertex set.\nWe build edges as follow:\n-from ```\ns```\n to ```\na1```\n\n- for ```\ni in 1...n```\n, we build an edge from ```\nai to bi```\n, from ```\nai to ci```\n\n- for ```\ni in 1..n-1```\n, we build an edge from ```\nbi to ai+1```\n, from ```\nci to ai+1```\n.\n- from ```\nbn to d```\n, from ```\ncn to d```\n.\nAs you can see, there are about ```\n2^n```\n paths from ```\ns```\n to ```\nd```\n.  \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Why graph doesn't find correct path?\r\n                \r\nI've tried to create graph with the help of the following link but when I used find_path method I got incorrect path returned. Link:\n\nhttp://www.python-course.eu/graphs_python.php\n\nCode:\n\n```\nclass Graph(object):\n    def __init__(self, graph_dict=None):\n        \"\"\" initializes a graph object\n            If no dictionary or None is given, an empty dictionary will be used\n        \"\"\"\n        if graph_dict is None:\n            graph_dict = {}\n        self.__graph_dict = graph_dict\n\n    def find_path(self, start_vertex, end_vertex, path=[]):\n        \"\"\" find a path from start_vertex to end_vertex\n            in graph \"\"\"\n        graph = self.__graph_dict\n        path = path + [start_vertex]\n        if start_vertex == end_vertex:\n            return path\n        if start_vertex not in graph:\n            return None\n        for vertex in graph[start_vertex]:\n            if vertex not in path:\n                extended_path = self.find_path(vertex,\n                                               end_vertex,\n                                               path)\n                if extended_path:\n                    return extended_path\n        return None\n\ng = {\"a\": [\"c\", \"d\"],\n     \"b\": [\"a\", \"c\"],\n     \"c\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n     \"d\": [\"c\", \"e\"],\n     \"e\": [\"c\", \"f\"],\n     \"f\": [\"c\"]\n     }\n\ngraph = Graph(g)\n\n\"\"\"\ngraph:\n\na<----b         <-- one way\n|\\   /          --- two way\n| \\ /\n|  c <-- f\n| / \\    ^\nv/   \\   |\nd---->e--/\n\n\"\"\"\nprint graph.find_path(\"b\", \"f\")\n\nOutput: ['b', 'a', 'c', 'd', 'e', 'f']\nShould be: ['b', 'a', 'd', 'e', 'f']\n```\n\n\nWhat is wrong with find_path method in Graph class?\n    ", "Answer": "\r\nYour code is finding the path by following the first node in each node's adjacency list that does not already belong in the graph. It starts at ```\n'b'```\n and then goes to the first node in the adjacency list (```\n['a', 'c']```\n) node ```\n'a'```\n. Then it goes from ```\n'a'```\n to ```\n'c'```\n. Once it is at ```\n'c'```\n, it sees that ```\n'a'```\n, ```\n'b'```\n, and ```\n'c'```\n are already in the path so it goes to ```\n'd'```\n. If you changed the order of your adjacency list in the graph to this, it will print out the order your looking for:\n\n```\ng = {\"a\": [\"d\", \"c\"],\n     \"b\": [\"a\", \"c\"],\n     \"c\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n     \"d\": [\"e\", \"c\"],\n     \"e\": [\"f\", \"c\"],\n     \"f\": [\"c\"]\n     }\n```\n\n\nAlternatively, you can implement a shortest path algorithm such as Djikstra's to find the shortest path through a graph.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in a particular type of graph\r\n                \r\nI know that the longest path problem is NP-hard for a general graph. However, I am considering a particular kind of graph, consisting of one cycle, plus one additional edge incident on each vertex of the cycle. For example, for a cycle of length 7, we have the graph:\n\n\n\nAll the edges are weighted (the weight is a real number and can be positive or negative). I want to find the largest simple path on this graph, where the size of a path is the sum of the weights of the edges on the path. \n\nThe algorithm should be linear in the size of the cycle. But any ideas are appreciated.\n    ", "Answer": "\r\nThis could be reduced to Maximum subarray problem and solved in linear time.\n\n\nDisconnect the cycle (at any node).\nAppend second copy of the remaining graph to the point where cycle was disconnected (we may skip the last node).\nApply modified Kadane's algorithm to the resulting list of nodes.\nIf the found path has no edges, search greatest-weight edge in the graph. If this edge has non-negative weight, report this single-edge path. If not, report this single-edge path anyway if empty paths are not allowed, or report empty path if they are allowed.\n\n\n -> \n\nNecessary Kadane's algorithm modifications:\n\n\nKeep track of the number of nodes in current path (subarray). Trim nodes from tail when subarray has ```\nN```\n or more \"cycle\" nodes. To trim these nodes efficiently, we need a queue that can report minimum value of its elements. Push elements to this queue wherever head of the path is advanced (add leaf edge weight if non-negative), pop elements when tail of the path is trimmed, and reset the queue wherever current path is reset to empty path. This queue contains prefix lengths of (not necessarily simple) path, where minimum value gives proper position to advance tail of the path. Such a queue may be implemented either as a deque holding only non-decreasing values, or as a pair of stacks as mentioned in this answer.\nReset path length to ```\nmax(0, leaf_edge_weight)```\n wherever length of current path is below zero (instead of resetting it to zero as in original Kadane's algorithm).\nAdd non-negative leaf edge weight (corresponding to head node) when current (non-empty) path is compared to the best-so-far path.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All shortest paths in networkx subject to routing criteria\r\n                \r\nI have a weighted undirected graph (~90 nodes, ~120 edges) in which I want to find the shortest path between all combinations of a subset of nodes, stored as list 'endPoints'. The shortest paths are subject to a few criteria:\n\nFor each combination of (s)ource and (d)estination nodes in endPoints there is a different set of intermediary nodes in the graph that I require the shortest path to include.\nFor each combination of s and d there is a different set of intermediary nodes that I require the shortest path to exclude.\nFor each combination of s and d any other node in the graph not specified in either 1) or 2) can optionally be traversed.\n\ne.g. For a graph containing nodes A-E I want to find the shortest paths between AB, AC, AD, AE, BC, BD, BE, CD, CE, DE. For AE the path must go via B and C but must not pass through D;  For BD the path must go via A, must not go via C, can optionally go via E, etc.\nI think the approach to use is to find all simple paths in the graph between each s and d, then to iterate over them excluding those that do not meet criteria 1) and 2) and then to find the shortest path for each remaining s and d combination using nx.shortest_path.\nFinding all simple paths returns generator objects for each s-d pair and I'm not sure how to iterate over these s,d generators to apply criteria 1) and 2)\nCan anyone help with next steps (or suggest an alternative approach) please?\n```\nfrom itertools import combinations\n\nallPaths = []\nfor s, d in combinations(endPoints, 2):\n    allPaths.append((s, d, nx.all_simple_paths(G, s, d, cutoff=999)))\n\nallPaths \n```\n\nreturns\n```\n[('ep01',\n  'ep02',\n  <generator object _all_simple_paths_graph at 0x0000025656C91BC8>),\n ('ep01',\n  'ep03',\n  <generator object _all_simple_paths_graph at 0x0000025656C91C48>),\n etc.\n```\n\n    ", "Answer": "\r\nYou could do something like this:\n```\nimport networkx as nx\nfrom itertools import combinations\n\ndef check_criteria(path, include, exclude):\n    path_set = set(path)\n    return include <= path_set and exclude.isdisjoint(path_set)\n\nmin_paths = {}\nfor s, d in combinations(end_points, 2):\n    min_len = None\n    paths = []\n    for path in nx.all_simple_paths(G, s, d):\n        if check_criteria(path, includes[s, d], excludes[s, d]):\n            path_len = nx.path_weight(G, path, \"weight\")\n            if min_len is None:\n                min_len = path_len\n            if path_len == min_len:\n                paths.append(path)\n            elif path_len < min_len:\n                paths = [path]\n                min_len = path_len\n    min_paths[s, d] = paths\n```\n\nEDIT:\nIf you want to to collect the length of the paths too, then you could pack both, path and length, into a tuple:\n```\n            ...\n            if path_len == min_len:\n                paths.append((path, path_len))\n            elif path_len < min_len:\n                paths = [(path, path_len)]\n            ...\n```\n\nAssumptions:\n\nThe required \"inclusions\"/\"exclusions\" are stored in dictionaries called ```\nincludes```\n/```\nexcludes```\n.\nThe path length is the sum of the edge weights (edge attribute ```\n\"weight\"```\n) and can therefore be calculated by ```\nnx.path_weight```\n. If that's not the case then adjust accordingly (e.g. by replacing ```\nnx.path_weight(...)```\n with ```\nlen(path)```\n etc.).\n\nThe following example will hopefully illustrate that:\n```\nimport networkx as nx\nfrom itertools import combinations\nfrom random import seed, random, sample, randint\n\nseed(12345)\nn = 20\nG = nx.gnp_random_graph(n, 0.2, seed=12345)\nfor edge in G.edges:\n    G.edges[edge][\"weight\"] = random()\nend_points = [0, 1, 2]\ncombos = list(combinations(end_points, 2))\nnodes = set(G.nodes)\nincludes = {\n    c: set(sample(nodes - set(c), randint(1, 3))) for c in combos\n}\nexcludes = {\n    c: set(sample(nodes - includes[c].union(c), randint(1, 3))) for c in combos\n}\n```\n\n```\nincludes = {(0, 1): {10}, (0, 2): {18, 6, 15}, (1, 2): {7}}\nexcludes = {(0, 1): {2, 6}, (0, 2): {8}, (1, 2): {8, 9, 13}}\n```\n\nResult is\n```\n{(0, 1): [[0, 9, 11, 10, 7, 4, 1]],\n (0, 2): [[0, 6, 15, 1, 4, 18, 2]],\n (1, 2): [[1, 4, 7, 5, 11, 18, 2]]}\n```\n\nor with length\n```\n{(0, 1): [([0, 9, 11, 10, 7, 4, 1], 2.062744452478362)],\n (0, 2): [([0, 6, 15, 1, 4, 18, 2], 1.2822628572757941)],\n (1, 2): [([1, 4, 7, 5, 11, 18, 2], 1.2624381263403164)]}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to apply dynamic programming to compute shortest path in graph?\r\n                \r\nI'm trying to compute the shortest path using dynamic programming in Python. I have all data properly stored as weighted segments (road) and nodes (cities) of a graph so this is not a problem as I was able to implement classical algorithms (BFS,DFS...), the case is that I do not know how to apply dynamic programming to solve this. I only know that for going from A to B, I have to divide the problem in subproblems but I do not know how to create an algorithm that works, I mean the steps that the algorithm should follow as well as how I should divide the problems into small problems.\n\nThanks for your help!\n    ", "Answer": "\r\nas suggested, you can look at the Bellman Ford algorithm. If you want to implement it yourself, wikipedia provides a nice pseudo code: https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\n\nOtherwise, you could use the networkx package in Python (https://de.wikipedia.org/wiki/Bellman-Ford-Algorithmus#Software).\n\n```\nimport networkx as nx\nG = nx.Graph()\ne = [('a', 'b', 3), ('b', 'c', 9), ('a', 'c', 5), ('c', 'd', 12)]\nG.add_weighted_edges_from(e)\nprint(nx.bellman_ford_path(G, 'a', 'd'))\nprint(nx.bellman_ford_path_length(G, 'a', 'd'))\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find edge-disjoint paths (not the number, the paths)\r\n                \r\ngiven a directed graph we can use edmonds-karp or ford-fulkerson algorithms to find the maximum number of edge disjoint paths in a directed graph. \n\nSay there are k edge-disjoint paths in G, how can one find the actual paths in polynomial time? My best choice is BFS and once a path is found mark those edges as used.\n\nThanks a lot!\n    ", "Answer": "\r\nYou can use flow decomposition. It goes like this:\n\n\nLet's run a depth-first search from the start node and ignore the edges that have a zero or a negative flow.\nOnce you reach the terminal node, subtract one from the flow through all edges on the path from the start node to the terminal one and print them (they form a path).\nKeep doing this as long as the terminal node is reachable.\n\n\nEach run uses a polynomial amount of time and finds and removes one path from the graph. The number of disjoint paths is clearly polynomial, so this algorithm has a polynomial time complexity. \n\nYou can also use breadth-first search, too (you still need to ignore edges with a non-positive flow).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding a single path in a graph using dfs\r\n                \r\nI am currently trying to find a single path in a graph leading from source to sink. I am trying to implement a method using dfs to achieve this. However, i can't seem to figure out how to make the method to stop the recursion. For example, i have this graph (in matrix form)\n\n0 1 1 0\n\n0 0 0 1\n\n0 0 0 1\n\n0 0 0 0\n\nSo i have an edge from node 0 (the source) to node 1 and 2 respectively, and then an edge from 1 and 2 leading to 3 (the sink). The path i would want to have would be 0>1>3, instead i'm getting 0>1>3>2>3. How can i make the recursion stop as soon as a path to the sink is found?\n\nHere is the code for the method:\n\n```\npublic void dfsPath(int i) {\n\n    boolean[] visited = new boolean[this.edgeCapacities.length];\n    visited[i] = true;\n    this.path.add(i); //Integer ArrayList containing the nodes in the path\n\n            //loop through all of the nodes in the matrix to find adjacency\n            for (int j = 0; j < this.edgeCapacities.length; j++) {\n                //check if edge exists and node has not been visited\n                if (this.edgeCapacities[i][j] != 0 && !visited[j]) {\n                    //here is the problem, i want the recursion to stop once the sink is found\n                    //it does not work however.\n                    if(j == this.sink) {\n                        visited[j] = true;\n                        this.path.add(j);\n                        return;\n                    } else {\n                        //recursion\n                        dfsPath(j);\n                    }\n                }\n        }\n```\n\n\nAny help would be greatly appreciated. Thanks in advance.\n    ", "Answer": "\r\nThere seem to be several problems with your DFS algorithm:\n\n\nby creating a new ```\nvisited```\n list in each recursive call, it always contains only the current node\nyou are only adding nodes to ```\nthis.path```\n, but never removing nodes that did not lead to the goal\nyou never check whether one of your recursive calls reached the goal, thus adding more nodes to a perfectly good path\n\n\nTo fix this, you should remove the current node from ```\nthis.path```\n at the end of the method, i.e. in case no path has been found. Also, you can just drop the ```\nvisited```\n array and just check whether the next node is already in the path. That's not quite as fast, but should suffice for your case and make the code less complex. Also, the method should return ```\ntrue```\n or ```\nfalse```\n depending on whether it found a path.\n\nTry this (not tested, but should work).\n\n```\npublic boolean dfsPath(int i) {\n    this.path.add(i); // add current node to path\n    if (i == this.sink) {\n        return true; // if current node is sink, return true\n                     // this.path contains nodes from source to sink\n    }\n    for (int j = 0; j < this.edgeCapacities.length; j++) {\n        if (this.edgeCapacities[i][j] != 0 && ! this.path.contains(j)) {\n            if (dfsPath(j)) {\n                return true; // found a path -> search no further\n            }\n        }\n    }\n    this.path.remove(this.path.size() - 1); // pop last node\n    return false; // no path found\n}\n```\n\n\nNote that I also moved the ```\nsink```\n-check out of the loop. This is purely a matter of taste, but it makes the code a bit simpler, as you don't have to add the ```\nsink```\n node separately to the path.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How do I find eulerian paths in a mixed directed/undirected graph?\r\n                \r\nHow do I find paths that traverse all edges in a graph of vertices and edges where some edges are directed and some aren't? I want the minimum number of paths that will cover the graph.\n\nI know about Heirholtz's algorithm and I know how to apply it to a graph that has only directed edges or only undirected edges. But I don't know how to do it on a graph that has both types of edges.\n    ", "Answer": "\r\nYou convert the undirected edges into two directed edges, and then run it on a directed graph. \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Describing graph with constriants from physical world\r\n                \r\nThe graph nodes are datacenters with only two unique paths from street into them. In graph theory multiple edges don't take this constraint into consideration. e.g.\n```\nG.add_edge(1,2)\nG.add_edge(2,5)\nG.add_edge(1,3)\nG.add_edge(3,5)\nG.add_edge(1,4)\nG.add_edge(4,5)\n```\n\nThe above declaration automatically describes the graph edge to node relationship through 3 unique edges which defys the physical world constraint of only 2 possible path in/out of node 1 and node 5 respectively.\n```\n+----- 2 -----+\n|             |\n+----- 3 -----+\n1             5\n+----- 4 -----+\n```\n\nthe above is more like the correct physical representation which I need to describe in graph as well but all I am getting is 3 unique edges from node 1 and node 5.\n```\n  +--- 2 ---+\n /           \\\n1----- 3 -----5\n \\           /\n  +--- 4 ---+\n```\n\nCan someone please enlighten me how can I define the physical world constraint of only 2 possible paths in/out of 1 & 5 (instead of the 3 that graph implementation is producing) by default. Thank you.\n    ", "Answer": "\r\nRealizing someone may look it up in future, so here is how I was able to describe my constraints...\n```\nG.add_edge(1,2, {overlap: '1_3'})\nG.add_edge(2,5, {overlap: '3_5'})\nG.add_edge(1,3, {overlap: '1_2'})\nG.add_edge(3,5, {overlap: '2_5'})\nG.add_edge(1,4, {overlap: ''})\nG.add_edge(4,5, {overlap: ''})\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding longest cyclic path in a graph with Gremlin\r\n                \r\nI am trying to construct Gremlin queries to use within DSE Graph with geo-searches enabled (indexed in Solr). The problem is the graph is so densely interconnected that the cyclic path traversals time out. Right now the prototype graph I'm working with has ~1600 vertices and ~35K edges. The number of triangles passing through each vertex also summarised:\n\n```\n+--------------------+-----+                                                    \n|                 gps|count|\n+--------------------+-----+\n|POINT (-0.0462032...| 1502|\n|POINT (-0.0458048...|  405|\n|POINT (-0.0460680...|  488|\n|POINT (-0.0478356...| 1176|\n|POINT (-0.0479465...| 5566|\n|POINT (-0.0481031...| 9896|\n|POINT (-0.0484724...|  433|\n|POINT (-0.0469379...|  302|\n|POINT (-0.0456595...|  394|\n|POINT (-0.0450722...|  614|\n|POINT (-0.0475904...| 3080|\n|POINT (-0.0479464...| 5566|\n|POINT (-0.0483400...|  470|\n|POINT (-0.0511753...|  370|\n|POINT (-0.0521901...| 1746|\n|POINT (-0.0519999...| 1026|\n|POINT (-0.0468071...| 1247|\n|POINT (-0.0469636...| 1165|\n|POINT (-0.0463685...|  526|\n|POINT (-0.0465805...| 1310|\n+--------------------+-----+\nonly showing top 20 rows\n```\n\n\nI anticipate the graph growing to a massive size eventually but I will limit the searches for cycles to geographic regions (say of radius ~ 300 meters).\n\nMy best attempt so far has been some versions of the following:\n\n```\ng.V().has('gps',Geo.point(lon, lat)).as('P')\n.repeat(both()).until(cyclicPath()).path().by('gps')\n\nScript evaluation exceeded the configured threshold of realtime_evaluation_timeout at 180000 ms for the request\n```\n\n\nFor the sake of illustration, the map below shows a starting vertex in green and a terminating vertex in red. Assume that all the vertices are interconnected. I am interested in the longest path between green and red, which would be to circumnavigate the block. \n\n\nA few links I've read through to no avail:\n\n1) http://tinkerpop.apache.org/docs/current/recipes/#cycle-detection\n\n2) Longest acyclic path in a directed unweighted graph\n\n3) https://groups.google.com/forum/#!msg/gremlin-users/tc8zsoEWb5k/9X9LW-7bCgAJ\n\nEDIT\n\nUsing Daniel's suggestion below to create a subgraph, it still times out:\n\n```\ngremlin> hood = g.V().hasLabel('image').has('gps', Geo.inside(point(-0.04813968113126384, 51.531259899256995), 100, Unit.METERS)).bothE().subgraph('hood').cap('hood').next()\n==>tinkergraph[vertices:640 edges:28078]\ngremlin> hg = hood.traversal()\n==>graphtraversalsource[tinkergraph[vertices:640 edges:28078], standard]\ngremlin> hg.V().has('gps', Geo.point(-0.04813968113126384, 51.531259899256995)).as('x')\n==>v[{~label=image, partition_key=2507574903070261248, cluster_key=RFAHA095CLK-2017-09-14 12:52:31.613}]\ngremlin> hg.V().has('gps', Geo.point(-0.04813968113126384, 51.531259899256995)).as('x').repeat(both().simplePath()).emit(where(both().as('x'))).both().where(eq('x')).tail(1).path()\nScript evaluation exceeded the configured threshold of realtime_evaluation_timeout at 180000 ms for the request: [91b6f1fa-0626-40a3-9466-5d28c7b5c27c - hg.V().has('gps', Geo.point(-0.04813968113126384, 51.531259899256995)).as('x').repeat(both().simplePath()).emit(where(both().as('x'))).both().where(eq('x')).tail(1).path()]\nType ':help' or ':h' for help.\nDisplay stack trace? [yN]n\n```\n\n    ", "Answer": "\r\nThe longest path, based on the number of hops, will be the last one you can find.\n\n```\ng.V().has('gps', Geo.point(x, y)).as('x').\n  repeat(both().simplePath()).\n    emit(where(both().as('x'))).\n  both().where(eq('x')).tail(1).\n  path()\n```\n\n\nThere's no way to make this query perform well in OLTP, unless you have a very tiny (sub)graph. So, depending on what you see as a \"city block\" in your graph, you should probably extract that first as a subgraph and then apply the longest path query (in memory).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Single destination shortest-path in a graph\r\n                \r\nGiven a graph and a destination node, how do you find all the shortest paths from all other vertices to the destination vertex.\n    ", "Answer": "\r\nDijkstra's algorithm. You can work it backwards as if your destination is your starting vertex. This will give you the distance and path to any other node.\n\n*PS: Just one thing to remember. You need to reverse the edges BEFORE applying Dijkstra with your destination as your starting vertex in order for that to work.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Total number of paths in directed acyclic graph containing a specific link\r\n                \r\nI've been trying to code up an algorithm that takes a directed set of nodes (I have expressed as a sparse directed adjacency matrix, for now) say, A, B, C, and D, that, when called, gives me all possible paths that contain a given path (such as AB or AD). A node cannot connect to itself, and all nodes are directed to flow from A to D, eventually.\n\nI've made an attempt at coding a recursive python script with limited success so far -- my graph theory isn't strong (I actually have zero background). Any help anyone could provide as far as the direction I should go would be appreciated.\n\nAs a disclaimer- this isn't homework (I'm just trying process a large data set and build a personal library for some research), and I've looked at \"similar questions\" for several hours, but largely to no avail (except for the aforementioned recursive python script).\n\nThanks.\n    ", "Answer": "\r\nStart by solving the simpler problem: given two points A and B in a DAG can you count all the paths that start with A and end with B? (A \"path\" is defined as a list of edges where the end node of one is equal to the start node of the next.)\n\nSounds hard. Can we simplify it?\n\nWell clearly the most trivial case is where A and B are actually the same node. In that case there are zero paths because the graph is acyclic. \n\nSuppose then that A and B are different. WOLOG suppose A has exactly two neighbours C and D, neither of which are B.  The number of paths from A to B must be equal to the number of paths from C to B, plus the number of paths from D to B.  \n\nMore generally: if A has n neighbours none of which are B then find the number of paths from each neighbour to B and sum them.\n\nIf A does have neighbour B then don't forget to add one to the total for the path A->B.\n\nNow we've split this up into many sub-problems, and each is strictly smaller than the previous problem. \n\nYou'd think then that a straightforward recursive solution would do the trick, but unfortunately it does not.  Consider this graph:\n\n```\n                    A\n                   / \\\n                  C   D\n                   \\ /\n                    E\n                   / \\\n                  F   G\n                   \\ /\n                    H\n                   / \\\n                  I   J\n                   \\ /\n                    B\n```\n\n\n\nPaths from A to B equals paths from C to B plus paths from D to B. So calculate those.\nPaths from C to B equals paths from E to B.  \nPaths from D to B equals paths from E to B.\n\n\nAnd... we just calculated paths from E to B twice. Which will in turn calculate paths from H to B twice, for a total of four times. The algorithm that I have sketched can end up calculating the same things 2n times where n is proportional to the number of nodes in the graph! \n\nWhat you need to do is make a memoizer, so that once the answer is calculated once, it is never calculated again.\n\nSo, solve the simpler problem by making a recursive, memoized algorithm that computes the total number of paths between two given nodes. \n\nSo let's try it out. How many paths are there from A to B? Let's denote that ```\nab```\n. We calculate:\n\n```\nab = cb + db, but we don't know them...\n  cb = eb, but we don't know it...\n    eb = fb + gb, but we don't know them...\n      fb = hb, but we don't know it...\n        hb = ib + jb, but we don't know them...\n          ib = 1\n          jb = 1\n        therefore hb = 2\n      therefore fb = 2\n    gb = hb, but we already know that is 2\n    therefore eb = 4\n  therefore cb = 4\n  db = eb, but we already know that is 4\ntherefore ab is 8\n```\n\n\nAnd we're done.\n\nOnce you can find the number of paths between two nodes then it is straightforward to calculate all paths that contain a given edge.  Paths from A to B that pass through E-G for example, is equal to number of paths from A to E multiplied by number of paths from G to B.  \n\nLet's try it.\n\n```\nae = ce + de\n  ce = 1\n  de = 1\nso ae = 2\n\ngb = hb\n  hb = ib + jb\n    ib = 1\n    jb = 1\n  so hb = 2\nso gb = 2\n```\n\n\nand there are ae * gb = 4 paths from A to B that go through EG. Let's check our work. The paths are\n\n```\nAC-CE-EG-GH-HI-IB\nAC-CE-EG-GH-HI-JB\nAD-DE-EG-GH-HI-IB\nAD-DE-EG-GH-HI-JB\n```\n\n\nYep, there are four.\n\nMake sense?\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding longest path in a Directed Cyclic Graph\r\n                \r\nI have a Directed Cyclic Graph and need to find longest path from point A to point B. The graph is a 2D array. I already wrote code that can find longest path in Acyclic Graph, but when I change the graph to the Cyclic one it doesn't work. Here's the code:\n```\n#include <iostream>\n#include <queue>\n#include <list>\n#include <stack>\n#include <limits.h>\n\n#define NINF INT_MIN\n//#define NINF -1 \n\nstruct vec2 {\n    int x, y;\n};\n\nclass AdjListNode {\n    vec2 v;\n    int weight;\n\npublic:\n    AdjListNode(vec2 _v, int _w)\n    {\n        v.x = _v.x;\n        v.y = _v.y;\n\n        weight = _w;\n    }\n    vec2 getV() { return {v.x, v.y}; }\n    int getWeight() { return weight; }\n};\n\nclass Graph {\n    vec2 V;\n\n    std::list<AdjListNode> adj[8][8];\n\n    void topologicalSortUtil(vec2 v, bool visited[8][8], std::stack<vec2>& Stack);\n\npublic:\n    Graph(int V_x, int V_y);\n    ~Graph();\n\n    void addEdge(vec2 u, vec2 v, int weight);\n\n    void longestPath(vec2 s);\n};\n\nGraph::Graph(int V_x, int V_y)\n{\n    V.x = V_x;\n    V.y = V_y;\n}\n\nGraph::~Graph()\n{\n}\n\nvoid Graph::addEdge(vec2 u, vec2 v, int weight)\n{\n    if (v.x == 0 && v.y == 0) //So we have no edge back to the root node\n        return;\n\n    AdjListNode node(v, weight);\n    adj[u.x][u.y].push_back(node);\n}\n\nvoid Graph::topologicalSortUtil(vec2 v, bool visited[8][8], std::stack<vec2>& Stack)\n{\n    visited[v.x][v.y] = true;\n\n    std::list<AdjListNode>::iterator i;\n    for (i = adj[v.x][v.y].begin(); i != adj[v.x][v.y].end(); i++) {\n        AdjListNode node = *i;\n        if (!visited[node.getV().x][node.getV().y])\n        {\n            topologicalSortUtil({ node.getV().x, node.getV().y }, visited, Stack);\n        }\n    }\n\n    Stack.push(v);\n}\n\nvoid Graph::longestPath(vec2 s)\n{\n    std::stack<vec2> Stack;\n    int dist[8][8];\n\n    std::vector<vec2> path;\n    vec2 pred[8][8];\n\n    bool visited[8][8];\n    for (int i = 0; i < V.x; i++)\n        for (int j = 0; j < V.y; j++)\n            visited[i][j] = false;\n\n    for (int i = 0; i < V.x; i++)\n        for (int j = 0; j < V.y; j++)\n            if (visited[i][j] == false)\n                topologicalSortUtil({ i, j }, visited, Stack);\n\n    for (int i = 0; i < V.x; i++)\n        for (int j = 0; j < V.y; j++)\n            dist[i][j] = NINF;\n    dist[s.x][s.y] = 0;\n\n    for (int i = 0; i < V.x; i++)\n        for (int j = 0; j < V.y; j++)\n            pred[i][j] = {NINF, NINF};\n\n    while (Stack.empty() == false) {\n        vec2 u = Stack.top();\n        Stack.pop();\n\n        std::list<AdjListNode>::iterator i;\n        if (dist[u.x][u.y] != NINF) {\n            for (i = adj[u.x][u.y].begin(); i != adj[u.x][u.y].end(); i++) {\n                if (dist[i->getV().x][i->getV().y] < dist[u.x][u.y] + i->getWeight())\n                {\n                    dist[i->getV().x][i->getV().y] = dist[u.x][u.y] + i->getWeight();\n\n                    pred[i->getV().x][i->getV().y].x = u.x;\n                    pred[i->getV().x][i->getV().y].y = u.y;\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < V.x; i++)\n        for (int j = 0; j < V.y; j++)\n            (dist[i][j] == NINF) ? std::wcout << \"INF \" : std::wcout << \"dist[\" << i << \"][\" << j << \"] :\" << dist[i][j] << \" \";\n\n    int maxDist = 0;\n    vec2 nodeIdx;\n\n    for (int i = 0; i < V.x; i++)\n        for (int j = 0; j < V.y; j++)\n        {\n            if (dist[i][j] > maxDist)\n            {\n                maxDist = dist[i][j];\n                nodeIdx.x = i;\n                nodeIdx.y = j;\n            }\n        }\n\n    std::wcout << \"\\nmaxDist: \" << maxDist << \"\\n\";\n    std::wcout << \"nodeIdx: {\" << nodeIdx.x << \",\" << nodeIdx.y << \"} \\n\";\n\n    for (int i = 0; i < V.x; i++)\n        for (int j = 0; j < V.y; j++)\n            std::wcout << \"pred[\" << i << \"][\" << j <<\"] :\" << \"{\" << pred[i][j].x << \",\" << pred[i][j].y << \"}\\n\";\n\n    vec2 crawl = {nodeIdx.x, nodeIdx.y};\n    path.push_back(crawl);\n    while ((pred[crawl.x][crawl.y].x != NINF) &&\n        (pred[crawl.x][crawl.y].y != NINF))\n    {\n        path.push_back(pred[crawl.x][crawl.y]);\n        crawl = pred[crawl.x][crawl.y];\n    }\n\n    std::wcout << \"\\nPath is::\\n\";\n    for (int i = path.size() - 1; i >= 0; i--)\n        std::wcout << \"{\" << path[i].x << \",\" << path[i].y << \"} \";\n}\n\nint main()\n{\n    Graph g(8, 8);\n\n    //This is a test graph\n    //This acyclic graph works just fine and returns the longest path\n    g.addEdge({ 0, 0 }, { 1, 1 }, 1);\n    g.addEdge({ 0, 0 }, { 3, 3 }, 1);\n    g.addEdge({ 0, 0 }, { 7, 7 }, 1);\n    g.addEdge({ 1, 1 }, { 2, 2 }, 1);\n    g.addEdge({ 3, 3 }, { 4, 4 }, 1);\n    g.addEdge({ 3, 3 }, { 7, 7 }, 1);\n    g.addEdge({ 4, 4 }, { 5, 5 }, 1);\n    g.addEdge({ 4, 4 }, { 6, 6 }, 1);\n    g.addEdge({ 4, 4 }, { 7, 7 }, 1);\n    g.addEdge({ 5, 5 }, { 6, 6 }, 1);\n    g.addEdge({ 6, 6 }, { 7, 7 }, 1);\n\n    //But when I add this and make the graph cyclic it doesn't work as intended\n    //g.addEdge({ 2, 2 }, { 0, 0 }, 1);\n    //g.addEdge({ 2, 2 }, { 3, 3 }, 1);\n    //g.addEdge({ 3, 3 }, { 2, 2 }, 1);\n\n    vec2 s = {0, 0};\n    std::wcout << \"Following are longest distances from source vertex {\"\n        << s.x << \",\" << s.y << \"}\\n\";\n    g.longestPath(s);\n\n    return 0;\n}\n```\n\nThe code was taken from: https://www.geeksforgeeks.org/find-longest-path-directed-acyclic-graph/\nand modified to take 2D points as input instead of 1D points. The code was also modified based on: https://www.geeksforgeeks.org/shortest-path-unweighted-graph/ and https://www.geeksforgeeks.org/longest-path-undirected-tree/ to show the actual path instead of distance\nThat is my final graph/2D array that I need to get the longest path from\n```\ng.addEdge({0,0}, {1,1},1);\ng.addEdge({0,0}, {2,2},1);\ng.addEdge({0,0}, {3,3},1);\ng.addEdge({0,0}, {4,4},1);\ng.addEdge({0,0}, {5,5},1);\ng.addEdge({0,0}, {6,6},1);\ng.addEdge({0,0}, {7,7},1);\ng.addEdge({0,1}, {1,0},1);\ng.addEdge({0,2}, {1,2},1);\ng.addEdge({0,2}, {2,2},1);\ng.addEdge({0,2}, {3,2},1);\ng.addEdge({0,2}, {4,2},1);\ng.addEdge({0,2}, {5,2},1);\ng.addEdge({0,2}, {6,2},1);\ng.addEdge({0,2}, {7,2},1);\ng.addEdge({0,3}, {0,4},1);\ng.addEdge({0,3}, {0,5},1);\ng.addEdge({0,3}, {0,6},1);\ng.addEdge({0,3}, {0,7},1);\ng.addEdge({0,4}, {1,4},1);\ng.addEdge({0,4}, {2,4},1);\ng.addEdge({0,4}, {3,4},1);\ng.addEdge({0,4}, {4,4},1);\ng.addEdge({0,4}, {5,4},1);\ng.addEdge({0,4}, {6,4},1);\ng.addEdge({0,4}, {7,4},1);\ng.addEdge({0,5}, {0,6},1);\ng.addEdge({0,5}, {0,7},1);\ng.addEdge({0,6}, {1,5},1);\ng.addEdge({0,6}, {2,4},1);\ng.addEdge({0,6}, {3,3},1);\ng.addEdge({0,6}, {4,2},1);\ng.addEdge({0,6}, {5,1},1);\ng.addEdge({0,6}, {6,0},1);\ng.addEdge({0,7}, {1,7},1);\ng.addEdge({0,7}, {2,7},1);\ng.addEdge({0,7}, {3,7},1);\ng.addEdge({0,7}, {4,7},1);\ng.addEdge({0,7}, {5,7},1);\ng.addEdge({0,7}, {6,7},1);\ng.addEdge({0,7}, {7,7},1);\ng.addEdge({1,0}, {1,1},1);\ng.addEdge({1,0}, {1,2},1);\ng.addEdge({1,0}, {1,3},1);\ng.addEdge({1,0}, {1,4},1);\ng.addEdge({1,0}, {1,5},1);\ng.addEdge({1,0}, {1,6},1);\ng.addEdge({1,0}, {1,7},1);\ng.addEdge({1,1}, {1,2},1);\ng.addEdge({1,1}, {1,3},1);\ng.addEdge({1,1}, {1,4},1);\ng.addEdge({1,1}, {1,5},1);\ng.addEdge({1,1}, {1,6},1);\ng.addEdge({1,1}, {1,7},1);\ng.addEdge({1,2}, {0,2},1);\ng.addEdge({1,3}, {2,3},1);\ng.addEdge({1,3}, {3,3},1);\ng.addEdge({1,3}, {4,3},1);\ng.addEdge({1,3}, {5,3},1);\ng.addEdge({1,3}, {6,3},1);\ng.addEdge({1,3}, {7,3},1);\ng.addEdge({1,4}, {0,4},1);\ng.addEdge({1,5}, {2,5},1);\ng.addEdge({1,5}, {3,5},1);\ng.addEdge({1,5}, {4,5},1);\ng.addEdge({1,5}, {5,5},1);\ng.addEdge({1,5}, {6,5},1);\ng.addEdge({1,5}, {7,5},1);\ng.addEdge({1,6}, {2,7},1);\ng.addEdge({1,7}, {0,6},1);\ng.addEdge({2,0}, {2,1},1);\ng.addEdge({2,0}, {2,2},1);\ng.addEdge({2,0}, {2,3},1);\ng.addEdge({2,0}, {2,4},1);\ng.addEdge({2,0}, {2,5},1);\ng.addEdge({2,0}, {2,6},1);\ng.addEdge({2,0}, {2,7},1);\ng.addEdge({2,1}, {3,1},1);\ng.addEdge({2,1}, {4,1},1);\ng.addEdge({2,1}, {5,1},1);\ng.addEdge({2,1}, {6,1},1);\ng.addEdge({2,1}, {7,1},1);\ng.addEdge({2,2}, {2,1},1);\ng.addEdge({2,2}, {2,0},1);\ng.addEdge({2,3}, {3,2},1);\ng.addEdge({2,3}, {4,1},1);\ng.addEdge({2,3}, {5,0},1);\ng.addEdge({2,4}, {1,3},1);\ng.addEdge({2,4}, {0,2},1);\ng.addEdge({2,5}, {2,6},1);\ng.addEdge({2,5}, {2,7},1);\ng.addEdge({2,6}, {3,6},1);\ng.addEdge({2,6}, {4,6},1);\ng.addEdge({2,6}, {5,6},1);\ng.addEdge({2,6}, {6,6},1);\ng.addEdge({2,6}, {7,6},1);\ng.addEdge({2,7}, {2,6},1);\ng.addEdge({2,7}, {2,5},1);\ng.addEdge({2,7}, {2,4},1);\ng.addEdge({2,7}, {2,3},1);\ng.addEdge({2,7}, {2,2},1);\ng.addEdge({2,7}, {2,1},1);\ng.addEdge({2,7}, {2,0},1);\ng.addEdge({3,0}, {4,1},1);\ng.addEdge({3,0}, {5,2},1);\ng.addEdge({3,0}, {6,3},1);\ng.addEdge({3,0}, {7,4},1);\ng.addEdge({3,1}, {4,2},1);\ng.addEdge({3,1}, {5,3},1);\ng.addEdge({3,1}, {6,4},1);\ng.addEdge({3,1}, {7,5},1);\ng.addEdge({3,2}, {4,3},1);\ng.addEdge({3,2}, {5,4},1);\ng.addEdge({3,2}, {6,5},1);\ng.addEdge({3,2}, {7,6},1);\ng.addEdge({3,3}, {2,2},1);\ng.addEdge({3,3}, {1,1},1);\ng.addEdge({3,4}, {4,4},1);\ng.addEdge({3,4}, {5,4},1);\ng.addEdge({3,4}, {6,4},1);\ng.addEdge({3,4}, {7,4},1);\ng.addEdge({3,5}, {2,5},1);\ng.addEdge({3,5}, {1,5},1);\ng.addEdge({3,5}, {0,5},1);\ng.addEdge({3,6}, {4,5},1);\ng.addEdge({3,6}, {5,4},1);\ng.addEdge({3,6}, {6,3},1);\ng.addEdge({3,6}, {7,2},1);\ng.addEdge({3,7}, {2,7},1);\ng.addEdge({3,7}, {1,7},1);\ng.addEdge({3,7}, {0,7},1);\ng.addEdge({4,0}, {3,0},1);\ng.addEdge({4,0}, {2,0},1);\ng.addEdge({4,0}, {1,0},1);\ng.addEdge({4,1}, {4,2},1);\ng.addEdge({4,1}, {4,3},1);\ng.addEdge({4,1}, {4,4},1);\ng.addEdge({4,1}, {4,5},1);\ng.addEdge({4,1}, {4,6},1);\ng.addEdge({4,1}, {4,7},1);\ng.addEdge({4,2}, {3,3},1);\ng.addEdge({4,2}, {2,4},1);\ng.addEdge({4,2}, {1,5},1);\ng.addEdge({4,2}, {0,6},1);\ng.addEdge({4,3}, {3,2},1);\ng.addEdge({4,3}, {2,1},1);\ng.addEdge({4,3}, {1,0},1);\ng.addEdge({4,4}, {5,5},1);\ng.addEdge({4,4}, {6,6},1);\ng.addEdge({4,4}, {7,7},1);\ng.addEdge({4,5}, {5,6},1);\ng.addEdge({4,5}, {6,7},1);\ng.addEdge({4,6}, {3,5},1);\ng.addEdge({4,6}, {2,4},1);\ng.addEdge({4,6}, {1,3},1);\ng.addEdge({4,6}, {0,2},1);\ng.addEdge({4,7}, {5,7},1);\ng.addEdge({4,7}, {6,7},1);\ng.addEdge({4,7}, {7,7},1);\ng.addEdge({5,0}, {4,0},1);\ng.addEdge({5,0}, {3,0},1);\ng.addEdge({5,0}, {2,0},1);\ng.addEdge({5,0}, {1,0},1);\ng.addEdge({5,1}, {5,2},1);\ng.addEdge({5,1}, {5,3},1);\ng.addEdge({5,1}, {5,4},1);\ng.addEdge({5,1}, {5,5},1);\ng.addEdge({5,1}, {5,6},1);\ng.addEdge({5,1}, {5,7},1);\ng.addEdge({5,2}, {6,1},1);\ng.addEdge({5,2}, {7,0},1);\ng.addEdge({5,3}, {6,3},1);\ng.addEdge({5,3}, {7,3},1);\ng.addEdge({5,4}, {4,4},1);\ng.addEdge({5,4}, {3,4},1);\ng.addEdge({5,4}, {2,4},1);\ng.addEdge({5,4}, {1,4},1);\ng.addEdge({5,4}, {0,4},1);\ng.addEdge({5,5}, {6,5},1);\ng.addEdge({5,5}, {7,5},1);\ng.addEdge({5,6}, {4,6},1);\ng.addEdge({5,6}, {3,6},1);\ng.addEdge({5,6}, {2,6},1);\ng.addEdge({5,6}, {1,6},1);\ng.addEdge({5,6}, {0,6},1);\ng.addEdge({5,7}, {5,6},1);\ng.addEdge({5,7}, {5,5},1);\ng.addEdge({5,7}, {5,4},1);\ng.addEdge({5,7}, {5,3},1);\ng.addEdge({5,7}, {5,2},1);\ng.addEdge({5,7}, {5,1},1);\ng.addEdge({5,7}, {5,0},1);\ng.addEdge({6,0}, {6,1},1);\ng.addEdge({6,0}, {6,2},1);\ng.addEdge({6,0}, {6,3},1);\ng.addEdge({6,0}, {6,4},1);\ng.addEdge({6,0}, {6,5},1);\ng.addEdge({6,0}, {6,6},1);\ng.addEdge({6,0}, {6,7},1);\ng.addEdge({6,1}, {6,2},1);\ng.addEdge({6,1}, {6,3},1);\ng.addEdge({6,1}, {6,4},1);\ng.addEdge({6,1}, {6,5},1);\ng.addEdge({6,1}, {6,6},1);\ng.addEdge({6,1}, {6,7},1);\ng.addEdge({6,2}, {6,3},1);\ng.addEdge({6,2}, {6,4},1);\ng.addEdge({6,2}, {6,5},1);\ng.addEdge({6,2}, {6,6},1);\ng.addEdge({6,2}, {6,7},1);\ng.addEdge({6,3}, {6,4},1);\ng.addEdge({6,3}, {6,5},1);\ng.addEdge({6,3}, {6,6},1);\ng.addEdge({6,3}, {6,7},1);\ng.addEdge({6,4}, {6,5},1);\ng.addEdge({6,4}, {6,6},1);\ng.addEdge({6,4}, {6,7},1);\ng.addEdge({6,5}, {5,4},1);\ng.addEdge({6,5}, {4,3},1);\ng.addEdge({6,5}, {3,2},1);\ng.addEdge({6,5}, {2,1},1);\ng.addEdge({6,5}, {1,0},1);\ng.addEdge({6,6}, {6,5},1);\ng.addEdge({6,6}, {6,4},1);\ng.addEdge({6,6}, {6,3},1);\ng.addEdge({6,6}, {6,2},1);\ng.addEdge({6,6}, {6,1},1);\ng.addEdge({6,6}, {6,0},1);\ng.addEdge({6,7}, {5,7},1);\ng.addEdge({6,7}, {4,7},1);\ng.addEdge({6,7}, {3,7},1);\ng.addEdge({6,7}, {2,7},1);\ng.addEdge({6,7}, {1,7},1);\ng.addEdge({6,7}, {0,7},1);\ng.addEdge({7,0}, {6,1},1);\ng.addEdge({7,0}, {5,2},1);\ng.addEdge({7,0}, {4,3},1);\ng.addEdge({7,0}, {3,4},1);\ng.addEdge({7,0}, {2,5},1);\ng.addEdge({7,0}, {1,6},1);\ng.addEdge({7,0}, {0,7},1);\ng.addEdge({7,1}, {6,1},1);\ng.addEdge({7,1}, {5,1},1);\ng.addEdge({7,1}, {4,1},1);\ng.addEdge({7,1}, {3,1},1);\ng.addEdge({7,1}, {2,1},1);\ng.addEdge({7,1}, {1,1},1);\ng.addEdge({7,1}, {0,1},1);\ng.addEdge({7,2}, {6,2},1);\ng.addEdge({7,2}, {5,2},1);\ng.addEdge({7,2}, {4,2},1);\ng.addEdge({7,2}, {3,2},1);\ng.addEdge({7,2}, {2,2},1);\ng.addEdge({7,2}, {1,2},1);\ng.addEdge({7,2}, {0,2},1);\ng.addEdge({7,3}, {6,3},1);\ng.addEdge({7,3}, {5,3},1);\ng.addEdge({7,3}, {4,3},1);\ng.addEdge({7,3}, {3,3},1);\ng.addEdge({7,3}, {2,3},1);\ng.addEdge({7,3}, {1,3},1);\ng.addEdge({7,3}, {0,3},1);\ng.addEdge({7,4}, {6,4},1);\ng.addEdge({7,4}, {5,4},1);\ng.addEdge({7,4}, {4,4},1);\ng.addEdge({7,4}, {3,4},1);\ng.addEdge({7,4}, {2,4},1);\ng.addEdge({7,4}, {1,4},1);\ng.addEdge({7,4}, {0,4},1);\ng.addEdge({7,5}, {7,6},1);\ng.addEdge({7,5}, {7,7},1);\ng.addEdge({7,6}, {7,5},1);\ng.addEdge({7,6}, {7,4},1);\ng.addEdge({7,6}, {7,3},1);\ng.addEdge({7,6}, {7,2},1);\ng.addEdge({7,6}, {7,1},1);\ng.addEdge({7,6}, {7,0},1);\n```\n\nThe graph has 64 points each having from 1 to 7 edges (connections). Last point {7, 7} has no connections going out and only connections going to that point. Some points have connections to each other, for example point {5, 2} connects to point {7, 0} and point {7, 0} connects to point {5, 2}. Also the path needs to go from Point {0, 0} to Point {7, 7} and ideally reach every point.\nThe fact that the longest path is from point {0, 0} to point {7, 7} and that the path goes through every point is sure. But I need to get the exact path\nNow the program show that the longest path from point {0, 0} is to point {0, 4} which isn't true.\nAlready tried to find solution online, found some Stack Overflow questions, but the answers didn't satisfy my because most of them were very general and explaining only concepts which I couldn't in 100% understand and thus implement.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding a pair of edge disjoint paths in a graph, such that the lengths of each one of the paths is smaller than a given constant\r\n                \r\nI know how to find a pair of disjoint paths with the minimum sum of lengths (Surballe's algorithm).\nI also have a formulation of an ILP that solves the following problem, which generalizes my problem:\nGiven two vertices u and v in a graph G, out of all of the disjoint pairs of paths connecting u and v in G, find a pair with the minimal length of the longer path in the pair.\n(Of course, this problem may be reformulated for groups of more than two disjoint paths).\n\nDoes anyone have an idea for an efficient (polynomial?) algorithm for solving any of these problems (The problem in the title or the generalized problem?)\n\nThanks!\n    ", "Answer": "\r\nI think it's an NP problem, because I could reduce knapsack problem to this and according to this article knapsack problem is NP-complete. indeed knapsack problem has a Pseudo-polynomial time algorithm in the value of the knapsack size, but it has no polynomial time algorithm in the size of the input.\n\nreducing knapsack problem to the problem you specified:\n\n-specification of my knapsack problem:\n\n1- assume you have two knapsacks which both have size c.\n\n2- you have n items, with volumes v1, v2, .. vn.\n\n3- you want to disturb all of these n items into your knapsacks.\n\n-reducing this knapsack problem to your problem:\n\n1- make a graph with (n + 1) vertices.\n\n2- vertex i is connected to the vertex (i + 1) using two edges. one with cost vi (the volume \nof i'th item) and one with cost zero.\n\n3- you want to find two edge disjoint path from vertex 1 to vertex (n + 1) with upper bound equal to knapsack size.\n\nso if you could solve your problem in polynomial, the knapsack problem is solved in polynomial and you have proved P=NP. :D\n\nof course according to above description, you may solve your problem in polynomial time in the edge weight of the graph, but it's a Pseudo-polynomial time algorithm, not a real one unlike Surballe's algorithm.\nsorry for bad English.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Constrained shortest path in a graph\r\n                \r\nHere is my problem I found in an online judge website: \n\nI have an undirected graph (with loops). We have k different classes of vertices in the graph. You can think of class 1 vertex being colored green, class 2 vertices colored red and so on. There is also a special class of vertices colored white (more later).\n\nNow, the user will specify a source vertex, a destination vertex, and a sequence of distinct vertex classes (non-white) eg.\n\nWe are given source vertex 10, destination vertex 40, and a sequence: red->blue->black.\n\nWe have to find the shortest path such that the path starts from vertex 10, touches 1 red vertex followed by 1 blue and 1 black vertex and then reaches vertex 40. The path, however, can have as many white vertices as needed. It can also traverse a white vertex twice. \n\nSo a solution can be: 10->20(white)->35(red)->21(white)->22(white)->30(blue)->34(black)->40\n\nIncorrect:\n\n10->20(white)->30(blue)->21(white)->22(white)->35(red)->34(black)->40 (goes to blue before red)\n\n10->20(white)->35(red)->56(red)->21(white)->22(white)->30(blue)->34(black)->40 (goes through red twice)\n    ", "Answer": "\r\nI can suggest an O(n*(n+m)) solution based on a simple graph modification completed with a bfs modification. Let me describe it step by step. \n\nGraph modification.\n\n\nTo avoid any troubles, color source and white vertexes in some unique color.\nMake graph weighted. Weight of originally present edges is 1.\nFor each pair of colored vertexes u, v add an edge (u,v) which has a weight equal to the shortest white path from u to v. A white path is a path which passes only over white vertexes. If there is no such white path, don't add an edge.\nRemove all white vertexes and their adjacent edges. \n\n\nThe second point can be accomplished by running a bfs from each vertex that passes only over white vertexes. This will run in O( n*(n+m)).\n\nEquivalence.\n\nNow we have a weighted colored graph without white vertexes, and it's easy to see that the problem remains unchanged after modification - we still have to find a shortest path (now in terms of edges weight sum) from source to target vertex. \n\nSearch algorithm.\n\nTo solve the problem on this graph, run a variation of bfs, which layers correspond the provided path's colors. This means, if you're given path red->blue->black, the first moves bfs will do into all red vertexes adjacent to source, then to all blue adjacent to those red marked, then to all black adjacent to those blue marked, and finally to the target. When some vertex is pushed into bfs queue, remember the length of path to it for future use. \n\nPseudocode.\n\n\ncurrentVertexes = { (source,0) } // vertex and path length\nfor i from 0 to sizeof( givenPath ) do\n\nnextColor = givenPath[ i ]\nnextVertexes = {}\nfor (v,len) in currentVertexes do \nfor all u s.t. exists edge e := (v,u) and u.color = nextColor \nnextVertexes.insert( (u,  len + e.length))\ncurrentVertexes = nextVertexes\n\nchoose the minimum of lengths stored in currentVertexes, as there are only (target, length) pairs.\n\n\nComplexity:\n\nGraph modification takes O(n*(n+m)) running time and the second part will run O(n*n), because the length of given path can be no longer than n (there's no color duplicates as said in statement), and on each step there can be at most n vertexes in currentVertexes. Total complexity is O(n*(n+m)) + O(n*n) = O(n*(n+m))\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all paths in a directed graph that pass a single node (NetworkX)\r\n                \r\nLet's assume I have this directed graph:\n\nWhat's the optimal (complexity and simplicity) way to get every path that passes through a given node?\nLet's say I choose ```\nnode = 4```\n I want to get this sub-graph:\n\nCurrently I am using NetworkX python library, however I am open to choosing another one if it has this capability.\n    ", "Answer": "\r\nLet me propose an \"ugly\" solution (and I am sure there is a better way). First, find all descendants and ancestors of the node:\n```\ndesc = nx.descendants(G, 4)\nanc = nx.ancestors(G, 4)\n```\n\nNext, find the simple paths from each ancestor to the node and from the node to each descendant:\n```\npaths = [path for p in desc for path in nx.all_simple_paths(G, 4, p)]\npaths.extend([path for p in anc for path in nx.all_simple_paths(G, p, 4)])\n```\n\nFinally, reconstruct the digraph from the paths:\n```\nQ = nx.DiGraph()\nfor p in paths:\n    nx.add_path(Q, p)\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "longest path in directed acyclic unweighted graph in linear time\r\n                \r\nhow can I find in linear time the longest path in a graph like this one:\n\n3 -> 2\n\n4 -> 3\n\n2 -> 5\n\nI know that the longest path here is 4 -> 3 -> 2 So it has 3 veticles but i dont know how to find it in O(N) time. Please help.\nthank you in advance.\n    ", "Answer": "\r\nTop sort the graph and pick vertices in topologically sorted order. \n\n```\nFor each vertex u\n    For each edge (u,v)\n       if(d[v] < d[u] + weight(u,v))\n          d[v] = d[u] + weight(u,v) \n```\n\n\nWhere, d[u] for any vertex u, is the longest distance from the source. For each vertex u, d[u] is initialized to minimum value and d[source]=0. \n\nSince it is a DAG hence we ned to traverse and relax each edge only once. It's basically simplified Bellman Ford algorithm for longest path instead. \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Depth First Search and the Longest Path in a Graph\r\n                \r\nI am working on a problem in which you have to find the longest path in a graph. The graph is unique in that it is directed (traffic only goes one way) and you can travel from a node to only one other node in the graph. I wrote some code using a depth first search algorithm to find the answer. My algorithim gives the correct answer for certain graphs and an incorrect answer for others. It also is taking longer than I would like to run.\n\nHere's the code.\n\n```\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Martians { // 12442\n\n    static int max = 0; // longest chain length\n    static int tMax = 0; // longest current chain\n    static int starter = 0; // starting Martian of longest length\n    static int tStarter = 0;\n    static boolean[] visited;\n    static boolean[] tVisited;\n    static ArrayList<Edge>[] graph;\n\n    static class Edge {\n        public int dest = -1; // destination\n\n        public Edge() {\n        }\n\n        public Edge(int v) {\n            dest = v;\n        }\n    }\n\n    public static void dfs(int start) { // RECURSIVEEEEE!!!!\n        tVisited[start] = true;\n        visited[start] = true;\n        tMax++;\n        if (tMax > max) {\n            max = tMax;\n            starter = tStarter;\n        } \n        else if (tMax == max && tStarter < starter) {\n            max = tMax;\n            starter = tStarter;\n        }\n\n        ArrayList<Edge> edges = graph[start];\n\n        for (Edge e : edges) {\n            if (!tVisited[e.dest] && !visited[e.dest]) {// propagates out into graph if the current\n                                    // // node has not been visited\n                dfs(e.dest);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        int r = in.nextInt();\n        for (int q = 1; q <= r; ++q) {\n            tMax = 0;\n            tStarter = 0;\n            int N = in.nextInt();\n            graph = new ArrayList[N + 1];\n            visited = new boolean[N + 1];\n            tVisited = new boolean[N + 1];\n            for (int i = 1; i <= N; ++i) {\n                graph[i] = new ArrayList<Edge>();\n                visited[i] = false;\n                tVisited[i] = false;\n            }\n\n            for (int i = 1; i <= N; ++i) {\n                int u = in.nextInt();\n                int v = in.nextInt();\n                graph[u].add(new Edge(v));\n            }\n\n            for (int i = 1; i <= N; ++i) {\n                if (!visited[i]) {\n                    tStarter = i;\n                    dfs(i);\n                }\n            }\n\n            System.out.println(\"Case \" + q + \": \" + starter);\n        }\n        in.close();\n    }\n\n}\n```\n\n\nInput looks like this:\n\n```\n3\n3\n1 2\n2 3\n3 1\n4\n1 2\n2 1\n4 3\n3 2\n5\n1 2\n2 1\n5 3\n3 4\n4 5\n```\n\n\nThe first integer is the number of graphs. After that each lone integer is the number of nodes and the paired integers are the node and the node traveled to respectively. Output is the node at which one should start in order to travel the longest distance in the graph without visiting any nodes more than once (no repeats).\n\nOutput:\n\n```\nCase 1: 1\nCase 2: 4\nCase 3: 3\n```\n\n\nDoes anybody have any advice on what I am doing wrong here?\n    ", "Answer": "\r\nIf you are getting incorrect values for some graphs, but not for others, your issue is likely related to how you are keeping track of what nodes you have visited.\n\nI have 2 suggestions:\n\n\nGive your variables more descriptive names. ```\ntVisited```\n looks functionally equivalent to ```\nvisited```\n and makes reading your code more difficult.\nCreate a very, very simple graph and add instrumentation to print out the nodes that are visited so that you can track the behavior of your algorithm to make sure that it matches what you are expecting.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find longest path in graph where each node has at most two incoming and two outgoing edges\r\n                \r\nAs the title says I have to find longest path in directed graph where each node has at most two incoming edges and two outgoing edges. I don't know if that fact helps anything.. The graph will have at most 10000 nodes. And I need to find the longest path from node 0 to node 'Exit' which will be 10001.\n\nI tried to code dijkstra but it didn't work.\n\nThanks in advance.\n    ", "Answer": "\r\nYou could preprocess your graph and set edge weights to very high values for edges that are connected to nodes that break your rules and then use a modified version of dijkstra that returns longest path.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths in a graph using Matlab Brute Force Search\r\n                \r\nI need to find all paths with a graph, and save these paths. My starting nodes are A, B or C, and the final node is G. My graphs have maximum 16 unweighted vertices. \n\nI made the Matlab code below, but this has problems with bifurcations. Also, I don't know how to impose the starting and the final nodes. Can anyone help me with this? \n\n```\npath       = cell(1,10) ;  % initialize\n% one_graph  ={'AH','BO','CN','EG','EN','EO','HO','KN'} % (Graph example)\none_graph  ={'AH','BN','DH','DN','GN'} % (Graph example)\n\nfor p = 1:length(one_graph)\n\nedge  = one_graph(p);\n% In each graph there is only 1:1 conections\n% detect node 1\nexisting_node1 = edge{1}(1) ;\nIndex_existing_node1 = strfind(allnodes, existing_node1) ;\n[row1,col1] = find(ismember(allnodes, existing_node1));\n % detect node 2\nexisting_node2 = edge{1}(2) ;\nIndex_existing_node2 = strfind(allnodes, existing_node2);\n[row2,col2] = find(ismember(allnodes, existing_node2));\n\npath_nonz = path(~cellfun('isempty',path))   ;\nt         = length(path_nonz)                ;\nif t>0  % save the first 2 nodes in the path\nttt = strcmp(allnodes(row1), path{t});\nttt2 = strcmp(allnodes(row2), path{t});       \nend;\nif t==0\n    path{t+1} = allnodes{row1}  ; \n    path{t+2} = allnodes{row2}  ;\nelseif ttt == 1\n    % disp('connect right')\n    path{t+1} = allnodes{row2}  ;\nelseif ttt2 == 1\n    % disp('connect right')\n    path{t+1} = allnodes{row1}  ;\nelse \n    disp('Not next vertex') \nend\nend\n```\n\n\nFor example, for\n\n```\none_graph  ={'AH','BN','DH','DN','GN'} % (Graph example)\n```\n\n\nI should save the following paths:\n\npath1 = AHDNG\n\npath2 = BNG\n\nand for \n\n```\none_graph  ={'AH','BO','CN','EG','EN','EO','HO','KN'} % (Graph example)\n```\n\n\nI should save the following paths:\n\npath1 = AHOEG\n\npath2 = BOEG\n\npath3 = CNEG\n\nUPDATE 1: \n\nFrom the adjacency matrix ```\nB(:,:,1)```\n \n\n```\nB =\n\n 0     0     0     0     0     0     0     1     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     1     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     1     0     0     0     0     0     1     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     1     0     0\n 1     0     0     1     0     0     0     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n 0     1     0     1     0     0     1     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n 0     0     0     0     0     0     0     0     0     0     0     0     0     0     0     0\n```\n\n\nI derive the proper adjacency list:\n\n```\nAsparse = sparse(B(:,:,1));\nAsparse =\n\n (8,1)        1\n(14,2)        1\n (8,4)        1\n(14,4)        1\n(14,7)        1\n (1,8)        1\n (4,8)        1\n (2,14)       1\n (4,14)       1\n (7,14)       1\n```\n\n\nThen, I tried to use the BFS algorithm found on Matlab Website\n\n```\n [distances,times,pred] = bfs(Asparse,1);\n```\n\n\nBut, this doesn't save the paths. It just saves the previous node of each current node (in ```\npred```\n) and the distance from the initial node to each node (in ```\ndistances```\n). Any idea, how to save each path?\n    ", "Answer": "\r\nI've had to write a custom function to do this since 1) most BFS/DFS functions stop when the goal is reached and 2) they explicitly ignore cycles, which are required for multiple paths to the same target.\n\nI believe this will get you what you need. I've made a slight modification to the adjacency matrix in your example to create an edge from ```\n{2,7}```\n and ```\n{7,2}```\n so that there would be two paths from ```\n2```\n to ```\n14```\n. Note that this is a recursive function, so if you get around 500 nodes or so you're going to have problems and we'll have to come up with a version that uses an explicit stack.\n\n```\nfunction paths = findpaths(Adj, nodes, currentPath, start, target)\n   paths = {};\n   nodes(start) = 0;\n   currentPath = [currentPath start];\n   childAdj = Adj(start,:) & nodes;\n   childList = find(childAdj);\n   childCount = numel(childList);\n   if childCount == 0 || start == target\n      if start == target\n         paths = [paths; currentPath];\n      end\n      return;\n   end\n   for idx = 1:childCount\n      currentNode = childList(idx);\n      newNodes = nodes;\n      newNodes(currentNode) = 0;\n      newPaths = findpaths(Adj, newNodes, currentPath, currentNode, target);\n      paths = [paths; newPaths];\n   end\nend\n```\n\n\nIf you call this function like this:\n\n```\nA =[\n 0  0  0  0  0  0  0  1  0  0  0  0  0  0; \n 0  0  0  0  0  0  1  0  0  0  0  0  0  1; \n 0  0  0  0  0  0  0  0  0  0  0  0  0  0; \n 0  0  0  0  0  0  0  1  0  0  0  0  0  1; \n 0  0  0  0  0  0  0  0  0  0  0  0  0  0; \n 0  0  0  0  0  0  0  0  0  0  0  0  0  0; \n 0  1  0  0  0  0  0  0  0  0  0  0  0  1; \n 1  0  0  1  0  0  0  0  0  0  0  0  0  0; \n 0  0  0  0  0  0  0  0  0  0  0  0  0  0; \n 0  0  0  0  0  0  0  0  0  0  0  0  0  0; \n 0  0  0  0  0  0  0  0  0  0  0  0  0  0; \n 0  0  0  0  0  0  0  0  0  0  0  0  0  0; \n 0  0  0  0  0  0  0  0  0  0  0  0  0  0; \n 0  1  0  1  0  0  1  0  0  0  0  0  0  0];\n\nunusedNodes=ones(1,size(A,1));\nstart=2;\ntarget=14;\nemptyPath=[];\n\nallPaths = findpaths(A, unusedNodes, emptyPath, start, target)\n```\n\n\nthe output should be:\n\n```\nallPaths =\n{\n  [1,1] =\n\n      2    7   14\n\n  [2,1] =\n\n      2   14\n\n}\n```\n\n\nNaturally, you need to call this for each starting node.\n\n\n\nActually, you don't have to call this multiple times. There was one more tip I forgot to tell you. If your graph has ```\nn```\n nodes and you introduce a new node ```\nn+1```\n that has edges only to your candidate start nodes, you can call the function once with the new node as the start.\n\nSo if I add node ```\n15```\n to the graph above with edges:\n\n```\n{15,1}, {15,2} \n%// I wouldn't bother with {1,15} and {2,15}, they're totally unnecessary\n```\n\n\nand call the function with ```\nstart = 15```\n, here's what I get:\n\n```\nallPaths = \n{\n  [1,1] =\n\n     15    1    8    4   14\n\n  [2,1] =\n\n     15    2    7   14\n\n  [3,1] =\n\n     15    2   14\n\n}\n```\n\n\nYou now have all of the paths with one call, although you need to remove the new node ```\n15```\n from the head of each path.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path algorithm in graph for queries\r\n                \r\nI have a weighted undirected Graph. Its vertices are part of two sets - S and T. Firstly, the edges are entered. Then it's specified which vertices are part of the T set (the rest are part of the S set). Then q queries follow. For every query(consists of a source vertex), the program must print the shortest path between the specified source vertex and any vertex of the set T.\nI implemented the program using Dijkstra's algorithm. I call it for each query on the source vertex(dijkstra returns the distance between source and all other vertices) and then return the minimum of these numbers.\n```\nconst int M = 1000000;\nstd::unordered_set<int> T;\nclass Node {\npublic:\n    int endVertex;  // stores the second vertex of the edge\n    int weight;     // stores the weight required, it is the weight of the edge\n    Node(int end, int weight) {\n        this->endVertex = end;\n        this->weight = weight;\n    }\n};\n\nstruct NodeComparator {\n    bool operator()(const Node &first, const Node &second) {\n        return first.weight > second.weight;\n    }\n};\n\n\nclass Graph {\nprivate:\n    std::unordered_map<int, std::vector<Node>> adjacencyList; // it's a vector because there may be repeated Nodes\n    int numberOfVertices;\n\n    std::vector<int> dijkstra(int source) {\n        std::priority_queue<Node, std::vector<Node>, NodeComparator> heap;\n        std::vector<int> distances(this->numberOfVertices, M);\n        std::unordered_set<int> visited;\n        // distance source->source is 0\n        distances[source] = 0;\n        heap.emplace(source, 0);\n        while (!heap.empty()) {\n            int vertex = heap.top().endVertex;\n            heap.pop();\n            // to avoid repetition\n            if (visited.find(vertex) != visited.end()) {\n                continue;\n            }\n            for (Node node: adjacencyList[vertex]) {\n                // relaxation\n                if (distances[node.endVertex] > distances[vertex] + node.weight) {\n                    distances[node.endVertex] = distances[vertex] + node.weight;\n                    heap.emplace(node.endVertex, distances[node.endVertex]);\n                }\n            }\n            // mark as visited to avoid going through the same vertex again\n            visited.insert(vertex);\n        }\n        return distances;\n    }\n\n    int answer(int source) {\n        std::vector<int> distances = this->dijkstra(source);\n        std::set<int> answer;\n        for (int i: T) {\n            answer.insert(distances[i]);\n        }\n        return *answer.begin();\n    }\n// other methods\n};\n// main()\n```\n\nHowever, my solution does not pass half the tests due to timeout. I replaced my dijkstra method with a Floyd-Warshall algorithm, which directly overrides the starting adjacency matrix, because I thought that the method would be called only once, and then each query would just find the minimum element in the source line of the matrix. This time the timeouts are even worse.\nIs there a specific algorithm for efficient queries on shortest path? How can I improve my algorithm?\n    ", "Answer": "\r\nYou can reverse all edges and find the shortest path from the set of T (run Dijkstra from all T vertices together) to some vertex S. And precalculate all distances to each S and answer to query in O(1).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "graph - Dijkstra for The Single-Source Longest Path\r\n                \r\nOk, I posted this question because of this exercise:\n\n\n  Can we modify Dijkstra’s algorithm to solve the single-source longest path problem by changing minimum to maximum? If so, then prove your algorithm correct. If not, then provide a counterexample. \n\n\nFor this exercise or all things related to Dijkstra's algorithm, I assume there are no negative weights in the graph. Otherwise, it makes not much sense, as even for shortest path problem, Dijkstra can't work properly if negative edge exists. \n\n\n\nOk, my intuition answered it for me:\n\nYes, I think it can be modified. \n\nI just \n\n\ninitialise distance array to MININT\nchange ```\ndistance[w] > distance[v]+weight```\n to ```\ndistance[w] < distance[v]+weight```\n\n\n\n\n\nThen I did some research to verify my answer. I found this post:\n\nLongest path between from a source to certain nodes in a DAG\n\nFirst I thought my answer was wrong because of the post above. But I found that maybe the answer in the post above is wrong. It mixed up The Single-Source Longest Path Problem with The Longest Path Problem. \n\nAlso in wiki of Bellman–Ford algorithm, it said correctly :\n\n\n  The Bellman–Ford algorithm computes single-source shortest paths in a weighted digraph. For graphs with only non-negative edge weights, the faster Dijkstra's algorithm also solves the problem. Thus, Bellman–Ford is used primarily for graphs with negative edge weights. \n\n\nSo I think my answer is correct, right? \nDijkstra can really be The Single-Source Longest Path Problem and my modifications are also correct, right?\n    ", "Answer": "\r\nNo, we cannot1 - or at the very least, no polynomial reduction/modification is known - longest path problem is NP-Hard, while dijkstra runs in polynomial time!\n\nIf we can find a modfication to dijsktra to answer longest-path problem in polynomial time, we can derive ```\nP=NP```\n\n\n\n  If not, then provide a counterexample.\n\n\nThis is very bad task. The counter example can provide a specific modification is wrong, while there could be a different modification that is OK.\nThe truth is we do not know if longest-path problem is solveable in polynomial time or not, but the general assumption is - it is not.\n\n\n\nregarding just changing the relaxation step:\n\n```\n        A\n       / \\\n      1   2\n     /     \\\n    B<--1---C\nedges are (A,B),(A,C),(C,B)\n```\n\n\ndijkstra from A will first pick B, and then B is never reachable - because it is out of the set of ```\ndistances```\n.\n\nAt the very least, one will have also to change min heap into max heap, but it will have a different counter-example why it fails.\n\n\n\n(1) probably, maybe if P=NP it is possible, but it is very unlikely.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Kth shortest path in undirected graph\r\n                \r\nIs there any way with polynomial complexity(or better than that) to get kth or k shortest path of an undirected graph?\n\nor can Yen's k shortest path algorithm modified for undirected graphs?\n    ", "Answer": "\r\nTry to find the permutations of paths from source vertex to final vertex (taking all vertex atleast once) upto ```\nk```\n permutations but this would also mean if the total permutations of paths from source vertex to final vertex (taking all vertex atleast once) are finite but that wouldnt be the case as in case of NP hard problems. if you can find this heuristic in polynomial time then you can select ```\nkth```\n shortest path. so apply brute force dfs bfs then find the shortest path via dynamic programming and compare your permutations with kth case\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Display path in a weighted graph\r\n                \r\nI have a weighted graph.I have assigned three keys to each node in the graph.I want a code that, given two unique nodes in the graph, that will display all the paths connecting the two nodes if there exists a common key . The nodes can be connected in multi hop fashion also.\n\n```\nkeypool = randint(n,n,[1,10]) %key pool generation\nfor l = 1:n\nfor k = 1:3\n    nodekey(l,k) = keypool(l,k);%Selects key from key pool\nend;\nend;\nfor i=1:n\nfprintf('%s %d \\t =  %d  %d  %d \\n','key_node',i,nodekey(i,:));\nend\n```\n\n\nThis is the code i have written to generate random keys to all the nodes.  I do not know how to find the path between the two nodes only when there is a common key.       Enter the number of nodes:5\n\n```\nkeypool =\n\n 5     3     1     7     7\n 3     7     8     4     3\n 9     3    10     7    10\n 2     5     2     7     8\n 7    10     7     3     5\n\nkey_node 1   =  5  3  1 \nkey_node 2   =  3  7  8 \nkey_node 3   =  9  3  10 \nkey_node 4   =  2  5  2 \nkey_node 5   =  7  10  7 \n```\n\n\nthe value of n is the number of nodes entered by the user.the above code will generate such random keys for five nodes.  if i want to find the path between node1 and node5,assuming  possible paths are: 1->2->3->5,  1->5,  1->2->5. the path which has the common key alone should be printed. that is 1->2->3->5, 1->2->5.\n\n```\nwt=zeros(n,n);\nwhile(1)\n    i=input('enter the starting node:(0 to quit):');\n    if (i==0)    \n        break;\n    end\n    j=input('enter the destination node:');\n    wt(i,j)=input('Enter the cost: '); \nend\ndisp('Adjacency Matrix');\nfor i=1:n\nfprintf('           %d',i);\nend\nfor i=1:n\nfprintf('\\n%d          ',i);\nfor j=1:n\n    fprintf('%d          ',wt(i,j));\nend\nend\nAdjacency Matrix\n       1           2           3           4           5\n1          0          1          1          0          0          \n2          0          0          0          0          0          \n3          1          0          0          1          0          \n4          0          0          1          0          0          \n5          0          0          0          0          0     \n```\n\n\nthis means node (1,2) (1,3) (3,4) (4,3) are connected.\n\nThe user enters connectivity in the graph.the numbers in the keypool are randomly generated. the key assigned to node1 are 5,3,1 and to node5 7,10,7. these two nodes do not have a common key.Hence this path should not be printed. if a common key exists from the source (node1) the route should be traversed to the destination(node 5)\n    ", "Answer": "\r\nYou can break the problem down into two steps:\n\n\nDetermine which nodes are connected and share the same key.\nThis information would be stored in a matrix (let's denote it by ```\nM```\n), which I will refer to as the modified adjacency matrix.\nFind all possible paths from one node to another based on the modified adjacency matrix.\n\n\nThe first part can be solved like so:\n\n```\n%// Obtain matrix 'sh' where each element at position (i, j) indicates if\n%// node i and node j share a key\npairs = nchoosek(1:n, 2);                %// All possible pairs of nodes\nsh = zeros(n);\nfor k = 1:size(pairs, 1)\n    node1 = pairs(k, 1);\n    node2 = pairs(k, 2);\n    sh(node1, node2) = any(ismember(nodekey(node1, :), nodekey(node2, :)));\n    sh(node2, node1) = sh(node1, node2); %// Matrix must be symmetrical\nend\n\n%// Obtain the modified adjacency matrix\nM = sh & (wt > 0);\n```\n\n\nI will leave the second part to you. Finding all possible paths from node A to node B using the given (modified) adjacency matrix ```\nM```\n is a well-known problem. Here's a link to one possible implementation of it.\n\nHope this helps!\n\nP.S:\nYou can simplify the generation of ```\nnodekey```\n by writing:\n\n```\nnodekey = keypool(:, 1:3);\n```\n\n\nMATLAB's vectorized operations can really help making the code more efficient and elegant!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "simple path in Graph with special nodes with max amount of special nodes\r\n                \r\nI have this problem:\nGiven a graph G = (V,E), that has a subset of the nodes called, R, that are \"special\" nodes. The amount of special nodes can very from case to case. The graph can be directed, undirected, does not have weights, and can contain cycles.\nNow, I need a algorithm that can find a path from a node s to a node t, that passes through a maximum amount of the \"special\" nodes in R.\nIm aware that this problem is np-hard, and is easily reducible from hamiltionian path, but I i've been looking for different ways of solving it without having to bruteforce all paths.\nFirst attempt\nFirst I tried doing some preprocessing of the graph, where every edge that goes to a \"normal\" node, gets a weight of 2, and every edge to a node in R gets a weight of 0.\nThen I would just run dijkstra on the graph.\nA counterexample this could however look like this:\n\nIn this graph, dijkstra would pick path [s,4,t] even though path [s,1,2,3,t] is a actual simple path with the maximum amount of red nodes\nSecond Attempt\nMy second attempt was a bit more convoluted. In this attempt I would run a bfs from the s-node and each R-node in the graph. I would then createa a new reachabilitygraph that could model which R-nodes that are connected to each other.\nThis approach would run into major issues in any graph that has cycles or is not directed, as connections between R-nodes that did not exist in the original graph would be included in the new graph.\nSo if anyone has any bids on any smart preprocessing steps that I could take, I would be cery happy\n    ", "Answer": "\r\nYour first method seems good, for example:\n\nweigh of all edges to some node v in R = 1\nweigh of rest of edges = 0\n\nThen run Dijkstra with a cutoff = max special nodes\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How can I find all 'long' simple acyclic paths in a graph?\r\n                \r\nLet's say we have a fully connected directed graph ```\nG```\n. The vertices are ```\n[a,b,c]```\n. There are edges in both directions between each vertex.\n\nGiven a starting vertex ```\na```\n, I would like to traverse the graph in all directions and save the path only when I hit a vertex which is already in the path.\n\nSo, the function ```\nfull_paths(a,G)```\n should return:\n\n```\n- [{a,b}, {b,c}, {c,d}]\n- [{a,b}, {b,d}, {d,c}]\n- [{a,c}, {c,b}, {b,d}]\n- [{a,c}, {c,d}, {d,b}]\n- [{a,d}, {d,c}, {c,b}]\n- [{a,d}, {d,b}, {b,c}]\n```\n\n\nI do not need 'incomplete' results like ```\n[{a,b}]```\n or ```\n[{a,b}, {b,c}]```\n, because it is contained in the first result already.\n\nIs there any other way to do it except of generating a powerset of G and filtering out results of certain size?\n\nHow can I calculate this?\n\nEdit: As Ethan pointed out, this could be solved with depth-first search method, but unfortunately I do not understand how to modify it, making it store a path before it backtracks (I use Ruby Gratr to implement my algorithm)\n    ", "Answer": "\r\nHave you looked into depth first search or some variation? A depth first search traverses as far as possible and then backtracks. You can record the path each time you need to backtrack.  \n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Point to point path in a Graph\r\n                \r\nI want an algorithm to be able to find an optimal path between two vertices on a graph (with positive int weights).The thing is my graph is relatively big (up to 100 vertices). I have considered the dijkstra algorithm but as I searched  the net most implementions use the adjacency matrix which in my case will be 100x100. \n\nIf you could recommend me a certain source to read and learn from , or even better provide me with a c++ implementaion it will be great.\n\nPS: The algorithm needs to output the required route and not just the shortest distance between two points.\n\nThank you for your time.\n    ", "Answer": "\r\nHave you looked into A*?\n\nHere's a good article to start reading: http://www.redblobgames.com/pathfinding/a-star/introduction.html\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find shortest path in a directed graph that goes through some specified vertices\r\n                \r\nThere is a weighted directed graph.How to get the shortest path in the directed graph that goes through some specified vertices.\n    ", "Answer": "\r\nActually this problem falls into the class of NP, because Hamiltonian path, the well-known NP problem, can be reduced to this problem. So you might use brute force search or some approximation algorithm.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find two paths in a graph that are in distance of at least D(constant)\r\n                \r\nInstance of the problem:\nUndirected and unweighted graph G=(V,E).\ntwo source nodes a and b, two destination nodes c and d and a constant D(complete positive number).(we can assume that lambda(c,d),lambda(a,b)>D, when lambda(x,y) is the shortest path between x and y in G).\nwe have two peoples standing on the nodes a and b.\n\nDefinition:scheduler set-\nA scheduler set is a set of orders such that in each step only one of the peoples make a move from his node v to one of v neighbors, when the starting position of them is in the nodes a,b and the ending position is in the nodes c,d.A \"scheduler set\" is missing-disorders if in each step the distance between the two peoples is > D.\n\nI need to find an algorithm that decides whether there is a \"missing-disorders scheduler set\" or not.\n\nany suggestions?\n    ", "Answer": "\r\nOne simple solution would be to first solve all-pairs shortest paths using n breadth-first searches from every node in O(n * (n + m)).\n\nThen create the graph of valid node pairs (x,y) with lambda(x, y) > D, with edges indicating the possible moves. There is an edge {(v,w), (x,y)} if v = x and there is an edge {w, y} in the original graph or if w = y and there is an edge {v, x} in the original graph. This new graph has O(n^2) nodes and O(nm) edges.\n\nNow you just need to check whether (c, d) is reachable from (a, b) in the new graph. This can be achieved using DFS or BFS. \n\nThe total runtime be O(n * (n + m)).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "most visited node after travelling q paths in a graph\r\n                \r\nI have a tree with n vertices and n-1 edges.I have q queries.In each query I travel the shortest path from a source node to a destination node. Here q,n<=10^5 .I want to know the most visited node after finishing all the queries.I just want to know some algorithm which is fastest in this particular problem.I tried with bfs but it is giving TLE,is there any better approach?\n    ", "Answer": "\r\nSee there is a single path between 2 nodes in a tree(where nodes don't get repeated). So first do Euler Tour on Tree and then update is like:\nsay x is lca(u,v)\nupdate-> start(x)->start(u), end(u)->start(v), end(v)->end(x) by +1 where start(u)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding a path in a graph in prolog\r\n                \r\nLet's assume I have facts in Prolog as follows:\n\n```\npath(a,b).  \npath(a,c).  \n```\n\n\nand I want to code the the function ```\nispath(X,Y)```\n which returns true if there is a path from ```\nX```\n to ```\nY```\n in one or more steps. It fails if ```\nX=Y```\n. Assume\nan acyclic graph.\n\nSolution  \n\n```\nisPath(X,Y) :- arrow(X,Y).  \nisPath(X,Y) :- arrow(X,R), arrow(R,Y).\n```\n\n\nMy question is if prolog returns some element for R in the first call of arrow and there is no path from R to y in the second call, does prolog return false? or keep searching for all the possible paths until one is found.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Highlighting the shortest path in a Networkx graph\r\n                \r\nI have a network of people. I can display how they are connected by creating a directed graph using Networkx.\n\nHere is a code sample:\n\n```\nedges = edglist\nnodes = nodelist\ndg.add_weighted_edges_from(edges)\n#print dg.nodes()\nprint nx.shortest_path(dg, source='Freda', target='Levi', weight=None)\nnx.draw(dg)\nplt.savefig(\"path.png\")\n```\n\n\nWhich produces:\n\n\nI can also calculate a shortest path between two nodes. However what I am stuck on is how to highlight this 'shortest path'. Any pointers would be greatly appreciated. BTW, I am a newbie\n    ", "Answer": "\r\n```\nimport matplotlib.pyplot as plt\nG = nx.karate_club_graph()\npos = nx.spring_layout(G)\nnx.draw(G,pos,node_color='k')\n# draw path in red\npath = nx.shortest_path(G,source=14,target=16)\npath_edges = list(zip(path,path[1:]))\nnx.draw_networkx_nodes(G,pos,nodelist=path,node_color='r')\nnx.draw_networkx_edges(G,pos,edgelist=path_edges,edge_color='r',width=10)\nplt.axis('equal')\nplt.show()\n```\n\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "shortest path in colored-edge graph\r\n                \r\nin undirected and connected graph, each edge has a color (red, green or blue).\na valid path is a path with at least one edge of each color.\nthe problem is how to find the shortest valid path or determine that none exists.\n\nI tried to use BFS but could not figure out the solution.\nany ideas on how to start?\n    ", "Answer": "\r\nFirst, i assume that the number of colors is fixed.\nThen I would propose a label-setting Dijkstra algorithm (compare with Pareto Dijkstra) resulting in a running time of O(n log(n) + m):\n\nUse a generalized Dijkstra to find the shortest path:\nEach node has a list of labels, one label consists of a length from the start node and all colors yet visited.\nOne label dominates another label in this node if (1) it has less length and (2) it includes all colors of the other label. A dominated label is directly removed.\nSimilar to dijkstra you mantain a priority queue from which you relax always the node with less length. Taking an edge to a node v will increase the length of the label by the endge length and add the color of the edge to the label. The label is added to the list of labels of node v.\nWhen settling the target node with a label containing all three colors, you have found the shortest path.\nNote that you must save the predecessor node for each label if you want to reconstruct the shortest path at the end.\n\nYou start with an initial label at the start node with (0,{}) (zero length and no color).\n\nEach node can be settled at most once per color set combination, as there exist only 8 (fixed) such combinations in this case, the running time is equal to Dijkstra's algorithm \n which is O(n*log(n)+m) for the best implementation.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Path of Length N in graph with constraints\r\n                \r\nI want to find number of path of length N in a graph where the vertex can be any natural number. However two vertex are connected only if the product of the two vertices is less than some natural number P. If the product of two vertexes are greater than P than those are not connected and can't be reached from one other.\n\nI can obviously run two nested loops (<= P) and create an adjacency matrix, but P can be extremely large and this approach would be extremely slow. Can anyone think of some optimal approach to solve the problem? Can we solve it using Dynamic Programming?\n    ", "Answer": "\r\nI agree with Ante's recurrence, although I used a slightly simplified version. Note that I'm using the letter P to name the maximum product, as it is used in the original problem statement:\n\n```\nf(1,x) = 1\nf(i,x) = sum(f(i-1, y) for y in {1, ..., floor(P/x)})\n```\n\n\nf(i,x) is the number of sequences of length i that end with x. The answer to the question is then f(n+1, 1).\n\nOf course since P can be up to 10^9 in this task, a straightforward implementation with a DP table is out of the question. However, there are only up to m < 70000 possible different values of floor(P/i). So let's find the maximal segments aj ... bj, where floor(P/aj) = floor(P/bj). We can find those segments in O(number of segments * log P) using binary search.\n\nImagine the full DP table for f. Since there are only m different values for floor(P/x), every row of f consists of m contiguous ranges that have the same value.\n\nSo let's compute the compressed DP table, where we represent the rows as list of (length, value) pairs. We start with f(1) = [(P, 1)] and we can compute f(i+1) from f(i) by processing the segments in increasing order and computing prefix sums of the lengths stored in f(i).\n\nThe total runtime of my implementation of this approach is O(m (log P + n)). This is the code I used:\n\n```\nusing ll=long long;\nconst int mod = 1000000007;\nvoid add(int& x, ll y) { x = (x+y)%mod; }\nint main() {\n    int n, P;\n    cin >> n >> P;\n    int x = 1;\n    vector<pair<int,int>> segments;\n    while(x <= P) {\n        int y = x+1, hi = P+1;\n        while(y<hi) {\n            int mid = (y+hi)/2;\n            if (P/mid < P/x) hi=mid;\n            else y=mid+1;\n        }\n        segments.push_back(make_pair(P/x, y-x));\n        x = y;\n    }\n    reverse(begin(segments), end(segments));\n    vector<pair<int,int>> dp;\n    dp.push_back(make_pair(P,1));\n    for (int i = 1; i <= n; ++i) {\n        int j = 0;\n        int sum_smaller = 0, cnt_smaller = 0;\n        vector<pair<int,int>> dp2;\n        for (auto it : segments) {\n            int value = it.first, cnt = it.second;\n            while (cnt_smaller + dp[j].first <= value) {\n                cnt_smaller += dp[j].first;\n                add(sum_smaller,(ll)dp[j].first*dp[j].second);\n                j++;\n            }\n            int pref_sum = sum_smaller;\n            if (value > cnt_smaller)\n                add(pref_sum, (ll)(value - cnt_smaller)*dp[j].second);\n            dp2.push_back(make_pair(cnt, pref_sum));\n        }\n        dp = dp2;\n        reverse(begin(dp),end(dp));\n    }\n    cout << dp[0].second << endl;\n}\n```\n\n\nI needed to do some micro-optimizations with the handling of the arrays to get AC, but those aren't really relevant, so I left them away.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Using Breadth First Search to Find All Possible Paths in an Undirected Graph\r\n                \r\n```\n$grph = array(                                                      \n    array(1,2),\n    array(0,2,3),\n    array(0,1,4),\n    array(1,5,4),\n    array(2,3,5),\n    array(3,4));\n\n//The $grph[0] is all the nodes connected to node 0 etc\n```\n\n\nI need a code in PHP to calculate all possible paths from a Source to a Destination in this Graph say Source=0 and Destination=5 using the Breadth First Search\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "the shortest path in cycle directed Graph\r\n                \r\ni need an example of the shortest path of directed graph cycle bye one node (it should reach to all nodes of graph from anode will be the input) please if there is an example i need it in c++ or algorithm thanks very much.........\n    ", "Answer": "\r\nYou require to find the minimum spanning tree  for it.\n\nFor directed graph according to wikipedia you can use this algorithm.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "splitting of a graph into cycles and then into paths\r\n                \r\nFirst of all, I should say I am not familiar with the Graph theory and also my mathematics knowledge is very poor. Anyhow I am using graph concepts for my analysis.\n\nBasically, I am decomposing an undirected graph (say G) into cycles (closed graph). The specialty of my cycle is that they are the shortest cycles that one can traverse between two vertices (as they are cycle, starting and ending are same though). According to my example graph, my cycles are (1,4,5,1)(1,2,3,4,1)(7,9,8,7) (I neglect the cycles whose length is less than 3). \n\nEdit: I use depth first search to get the cycles and then got the smallest cycles.\n\nLater, I am further braking those cycles into directed paths. In here, I broke the cycles through the edges (through red lines in figure), so that I inserted starting and ending nodes for my new path graphs. So for the cycle (7,9,8,7)=> new directed paths are (a,9,c)(d,8,7,b)\nEdit: the further breaking is done only for selected cycles. It is just inserting a new vector and updating the elements. Any graph theory related algorithms doesn't involve here.\n\nThen I do some analysis with my data.\n\n\n  I did all above things. So, my problem is how to describe the entire\n  things with mathematical notations (without example like I said). This is very hard for me as I do not have even basics.\n\n\nI was trying and googling but still cannot find a way to describe what I did. I guess, the thing what I did is clear for you.\n\n\n  \n    \n      So, Could you please help me, How to describe \n      \n      \n      decomposing a undirected graph into cycles (shortest cycles)\n      Cycle breaking via edges and make directed path graphs (as shown in figure)\n      \n    \n  \n  \n  with mathematical notation (according to graph theory)\n\n\nI have seen many authors use different notations and symbols to define graphs and their sub graphs, but for me, I can not define such things as my basic are too poor. So, Please help me to say these things in a formal, mathematical way. Thanks in advance.\n\nI have inserted sample figures to get idea also.\n\n\nNote: I have add c++ tag as many computer scientists use graph theories and would like to have a response.\n    ", "Answer": "\r\nThe first problem you might encounter in an attempt to put your operations in a mathematical description is your definition of the \"shortest cycles\" as cycles are typically defined as a sequence of vertices connected by edges in which the first one is also the last one.\n\nMath crashcourse\n\nIn math a graph is typcally described by two sets V (like vertices) and E (like edges)\nThe set E consisting of sets with two elements each of them being a vertex.\nSuch as\n\n\nV = { v1, v2, ...., vn }\nE = { ..., {vi, vk}, ... }\n\n\nEvery set in E correspends to one edge in your graph.\n\nAs such a (connected) path is typcially defined as: \n\nA sequence of vertices v1, ...., vn  with the property that for every two consecutive vertexes in the sequence vi and vi+1 the set { vi, vi+1 } is an element of the set E.\n\n(practically speaking: there is an edge from vertex vi to vertex vi+i)\n\nA cycle is typically defined as a path with the property: v1 = vn (thus the first vertex is also the last one)\n\nWhith this definition an your example already the sequence: 1, 4, 1 forms a cycle (in the mathematical sense)\n\nAs such every edge in your graph would count as a \"shortest\" cycle, while the examples given are definately longer!\n\nYou told that you \n\n\n  ... neglect the cycles whose length is less than 3\n\n\nthis doesn't look to bad as a starting point for your description. Unfortunately I didn't completely understand the next steps you want to perform.\n\nAdvice\n\nMy advice, or the least the way I would approach the problem is to convert the rather long description to some kind of shorter algorithmic description while refining on exactly how you try to perform the task. This way getting to your final description shouldn't be too hard to accomplish. Especially don't forget to tell what exactly the input to your algorithm is. Even that doesn't seem to be too clear from your description.\n\n\nare you starting with a already known set of \"shortest\" cycles?\nor are you just given a graph as input and have to determine the \"shortest\" cycles yourself?\nif you detect them yourself how exactly is this done?\nEspecially don't forget to tell about this part of the story if it applies as it seems to be one of the most crucial ones to your problem.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "minimum penalty path in weighted graph\r\n                \r\nConsider an undirected graph containing N nodes and M edges. Each edge Mi has an integer cost, Ci, associated with it.\n\nThe penalty of a path is the bitwise OR of every edge cost in the path between a pair of nodes, A and B. In other words, if a path contains edges M1,M2,...,Mk then the penalty for this path is C1 OR C2 OR ... OR Ck.\n\nGiven a graph and two nodes, A and B, find the path between A and B having the minimal possible penalty and print its penalty; if no such path exists, print ```\n−1```\n to indicate that there is no path from A to B.\n\nNote: Loops and multiple edges are allowed.\n\nconstraints:\n\n1≤N≤103\n\n1≤M≤103\n\n1≤Ci<1024\n\n1≤Ui,Vi≤N\n\n1≤A,B≤N\n\nA≠B\n\nthis question is asked in a contest and its over I went through the tutorial but could not get it. can anyone explain or give the answer how to proceed?\n    ", "Answer": "\r\nIt can be solved using Dynamic programming by following the recursive formula:\n\n```\nD(s,0) = true\nD(v,i) = false OR D(v,i) OR { D(u,j) | (u,v) is an edge, j or c(u,v) = i }\n```\n\n\nWhere ```\ns```\n is the source node.\n\nThe idea is ```\nD(v,i) == true```\n if and only if there is a path from ```\ns```\n to ```\nv```\n with weight of exactly ```\ni```\n.\nNow, you iteratively modify the graph in your dynamic programming, until it converges (which is at most after ```\nn```\n iterations).\nThis is basically a variant of Bellman-Ford algorithm.\nWhen you are done creating the DP table for the solution, the minimal path is ```\nmin { x | D(t,x) = true}```\n (where ```\nt```\n is the target node).\n\nTime complexity is ```\nO(m*n*log_2(R))```\n, where ```\nR```\n is the maximal weight allowed (1024 in your case).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Trouble with Dijkstra , finding all minimum paths\r\n                \r\nWe have a problem here, we're trying to find all the shortest paths in graph from one node to another. We have already implemented dijkstra but we really dont know how to find them all.\n\nDo we have to use BFS?\n\n```\n#include <vector>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef pair <int, int> dist_node;\ntypedef pair <int, int> edge;\nconst int MAXN = 10000;\nconst int INF = 1 << 30;\nvector <edge> g[MAXN];\nint d[MAXN];\nint p[MAXN];\n\nint dijkstra(int s, int n,int t){\n    for (int i = 0; i <= n; ++i){\n        d[i] = INF;  p[i] = -1;\n    }\n    priority_queue < dist_node, vector <dist_node>,greater<dist_node> > q;\n    d[s] = 0;\n    q.push(dist_node(0, s));\n    while (!q.empty()){\n        int dist = q.top().first;\n        int cur = q.top().second;\n        q.pop();\n        if (dist > d[cur]) continue;\n        for (int i = 0; i < g[cur].size(); ++i){\n            int next = g[cur][i].first;\n            int w_extra = g[cur][i].second;\n            if (d[cur] + w_extra < d[next]){\n                d[next] = d[cur] + w_extra;\n                p[next] = cur;\n                q.push(dist_node(d[next], next));\n            }\n        }\n    }\n    return d[t];\n}\n\nvector <int> findpath (int t){\n    vector <int> path;\n    int cur=t;\n    while(cur != -1){\n        path.push_back(cur);\n        cur = p[cur];\n    }\n    reverse(path.begin(), path.end());\n    return path;\n}\n```\n\n\nThis is our code, we believe we have to modify it but we really don't know where.\n    ", "Answer": "\r\nCurrently, you are only saving/retrieving one of the shortest paths that you happen to find. Consider this example:\n\n```\n4 nodes\n0 -> 1\n0 -> 2\n1 -> 3\n2 -> 3\n```\n\n\nIt becomes clear that you cannot have a single ```\np[]```\n value for each position, as in fact the 4th node (```\n3```\n) has 2 previous valid nodes: ```\n1```\n and ```\n2```\n.\n\nYou could thus replace it with a ```\nvector<int> p[MAXN];```\n and work as follows:\n\n```\nif (d[cur] + w_extra < d[next]){\n    d[next] = d[cur] + w_extra;\n    p[next].clear();\n    p[next].push_back(cur);\n    q.push(dist_node(d[next], next));\n}\nelse if(d[cur] + w_extra == d[next]){\n    p[next].push_back(cur); // a new shortest way of hitting this same node\n}\n```\n\n\nYou will also need to update your ```\nfindpath()```\n function as it will need to deal with \"branches\" resulting in several multiple paths, possibly an exponentially huge amount of paths depending on the graph. If you just need to print the paths, you could do something like this:\n\n```\nint answer[MAXN];\n\nvoid findpath (int t, int depth){\n    if(t == -1){ // we reached the initial node of one shortest path\n        for(int i = depth-1; i >= 0; --i){\n            printf(\"%d \", answer[i]);\n        }\n        printf(\"%d\\n\", last_node); // the target end node of the search\n        return;\n    }\n    for(int i = p[t].size()-1; i >= 0; --i){\n        answer[depth] = p[t][i];\n        findpath(p[t][i], depth+1);\n    }\n}\n```\n\n\nNote you'll need to do ```\np[s].push_back(-1)```\n at the beginning of your dijkstra, besides clearing this vector array between cases.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding the shortest path with only passing specific edge less or equal to one time in Graph\r\n                \r\n\nGiven a undirected graph that it has ordinary edges and specific edges, our goal is to find the sum of the shortest path's weight between two vertices(start vertex to end vertex) with only walk through specific edge equal or less than one time. In other words, there are multiple specific edges, and only at most one of them can be used.\n\nThis is a problem that I faced in my Data-Structure homework, and I stuck at the first step of the way to storage the weights of the edge in Graph. Because there are two kinds of edge in Graph, I have no idea that how to solve this problem.\nI know that I can obtain the shortest path by using Dijkstra’s Algorithm, but during the process, how can I modify the Algorithm to meet the requirement of the restriction?\nThanks a lot for answering my question!\n    ", "Answer": "\r\nThe solution is to duplicate the graph as follows:\n\nDuplicate the vertices, such that for each original vertex A, you have an A and an A'.\n\nIf in the original graph there is a normal edge between A and B, then in the new graph, place an edge between A and B and also between A' and B'\n\nIf in the original graph there is a specific edge between A and B, then in the new graph place a (directed) edge from A to B' (not the inverse!) and from B to A' (again: not the inverse!). These edges should be directed.\n\n\nIf now the task was to find the shortest path between S and D, then solve in the new graph the problem of finding the shortest path between S and D or S and D', which ever is shortest. You can use a standard implementation of Dijkstra's algorithm for that, starting in S and ending when you find either D or D'.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in a complement graph algorithm\r\n                \r\nI had a test today (Data Structures course), and one of the questions was the following:\nGiven an undirected, non-weighted graph G=(V,E), you need to write an algorithm that for a given node s, returns the shortest path from s to all the nodes v' in the complement graph.\n\nA Complement Graph G'=(E',V') contains an edge between any to nodes in G that don't share an edge, and only those.\n\nThe algorithm needs to run in O(V+E) (of the original graph).\n\nI asked 50 different students, and not even one of them solved it correctly.\n\nany Ideas?\nThanks a lot,\nBarak.\n    ", "Answer": "\r\nThe course staff have published the official answers to the test.\n\nThe answer is:\n\n\"The algorithm is based on a BFS with a few adaptations.\nFor each node in the graph we will add 2 fields - next and prev. Using these two fields we can maintain two Doubly-Linked lists of nodes: L1,L2.\nAt the beginning of every iteration of the algorithm, L1 has all the while nodes in the graph, and L2 is empty.\nThe BFS code (without the initialization) is:\n\n\n\nAt the ending of the loop at lines 3-5, L1 contains all the white nodes that aren't adjacent to u in G, or in other words, all the white nodes that are adjacent to u in the complement graph.\nTherefore the runtime of the algorithm equals to the runtime of the original BFS on the complement graph.\nThe time is O(V+E) because lines 4-5 are executed at most 2E times, and lines 7-9 are executed at most V times (Every node can get out of L1 only once).\"\n\nNote: this is the original solution translated from Hebrew.\n\nI Hope you find it helpful, and thank you all for helping me out,\n\nBarak.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Graph Paths Abstraction Algorithm Needed\r\n                \r\nI have a data structure holding a graph like the one in the following picture:\n\nIn this tree, a node can have any number of unique children from the levels below it.\nIn tree in the picture represents a set of paths.\nWhere every path should begin with a node from Level 1, and ends with a node of \"*\" mark.\nSo the paths of the tree in the picture are:\n```\nA then C then G\n\nA then C then G then J\n\nA then D then G\n\nA then D then G the J\n\nA then D then K, and so on...\n```\n\nActually my original tree is huge (around 2 Million sequences) and the maximum number of nodes per level is 61 (of 11 levels). So it causes many memory consumption problems in my application (a computer vision application for SAMSUNG).\nMy target is to have an iterative algorithm that represents these paths in a more compact string format. So I think we the problem is divided into three steps as follows. I have built the tree data structure (step 2), but still can not derive an iterative algorithm that gets the output string/sequence in step 3 from the tree.\n1- Input String:\n```\n(A C G) | (A C G J) | (A D G) | (A D G J ) | (A D K) | ....```\n,\nWhere \"|\" represents alternatives.\n2- Building Tree Data Structure of These Paths.\n3- Required Output String:\n```\n(A (C G [J]) | (D (G [J]) | K))  | (B ....)```\n.\nWhere where \"|\" represents alternatives and \"[ ]\" encloses options. The target output string should be optimized like there are not more common factors that can be taken to more simplify it.\n    ", "Answer": "\r\nYou can use a modification of iterative DFS, which utilizes a stack to keep track of unprocessed nodes. This algorithm never stores more than 6 characters on the stack* for any one node, and there are always fewer than N nodes on the stack (where N is the number of nodes in the graph). You've indicated that N will be at most 61*11=671, so there will be a maximum of about 4000 elements possible on the stack.\n\nIn the pseudocode below, a \"destination\" node is a starred node in the example above, e.g. G*.\n\nInitialization:\n\nA dummy node Φ is introduced with an edge from Φ to each of the \"root\" nodes, e.g. nodes A and B above. The token for Φ is assumed to be a non-printing character, or you can explicitly check before adding it to the output string. The node Φ is pushed onto the stack before calling the function.\n\n```\noutString := \"\"\nwhile stack not empty\n   pop token\n   if token is node\n      outString := outString + node(token)  // Line 5 - explanation below\n      if node(token) has children\n         if node(token) is destination\n            outString := outString + \"[\"\n            push \"]\"\n         end\n         if node(token) has multiple children\n            for each child of node(token), from right to left\n               push \")\"\n               push child\n               push \"(\"\n               push \"|\"\n            end\n            pop // remove last \"|\"\n         else\n            push child\n         end\n      end\n\n   else // token is ()[]|\n      outString := outString + token\n   end\nend\n```\n\n\nThe output of this algorithm for the first part of your graph (A and its children) is (with extra spaces added for clarity; the spaces can be easily added to the code):\n\n```\nA (C G [J]) | (D (G [J]) | (K))\n```\n\n\nYou'll notice a deviation between your result and mine: the final node K is enclosed in parentheses in my solution. If this is undesirable (it could result in ugliness like ```\nA[(B)|(C)]```\n), you can eliminate it by performing an additional check when you pop a node token off of the stack at the cost of some additional overhead. Simply replace Line 5 above with:\n\n```\nif (node(token) has no children\n    AND last character of outString is \"(\"\n    AND next token on stack is \")\")\n      remove trailing \"(\" from outString\n      concatenate token to outString\n      pop \")\" from stack and ignore\nelse\n   outString := outString + node(token) // as above\nend\n```\n\n\nLet me know if you have any questions or I've missed anything.\n\n* This will happen in the (probably highly unlikely) case of a node being written as ```\n|[(A)]```\n. Most nodes will take up 4 or fewer characters in the stack.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find path of exact length in graph\r\n                \r\nI would like to find path of fixed length (given while running the program) in undirected graph. I'm using adjacency matrix of my graph.\nI tried to use some algorithms like DFS or A*, but they only return the shortest path.  \n\nNodes can't be visited again.  \n\nSo let's say that my graph have 9 nodes and the shortest path is built from 4 nodes.\nI want to have additional variable that will \"tell\" the algorithm that I want to find path which have 7 nodes (for example) and it will return nodes which are included in my expected path {1,2,4,5,6,7,8}.\nOf course, if there is no solution for path that I want, it will return nothing (or it will return path close to my expactations, let's say 19 instead of 20).\n\nSomeone told be about DFS with backtracking, but I don't know anything about it.\nCould someone explain how to use DFS with backtracking or recommend some other algorithms to solve that problem?\n    ", "Answer": "\r\nBacktracking indeed seems like a reasonable solution. The idea is to recursively find a path of the required length. \n\nPsuedo code:\n\n```\nDFS(depth,v,path):\n  if (depth == 0 && v is target): //stop clause for successful branch\n       print path\n       return\n  if (depth == 0): //stop clause for non successful branch\n       return\n  for each vertex u such that (v,u) is an edge:\n       path.append(v) //add the current vertex to the path\n       DFS(depth-1,u,path) //recursively check all paths for of shorter depth\n       path.removeLast() // clean up environment\n```\n\n\nThe above algorithm will generate all paths of required depth.\ninvokation with ```\nDFS(depth,source,[])```\n (where ```\n[]```\n is an empty list).\n\nNote:\n\n\nThe algorithm will generate paths that might not be simple. If you need only simple paths - you also need to maintain ```\nvisited```\n set, and add each vertex when you append it to the found path, and remove it when you remove it from the path.\nIf you want to find only one such path - you should return value from the function, (true if such a path was found), and break the loop (and return true) when the return value is true.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Get all paths in a graph from a node, but only ones which terminate\r\n                \r\nI have written the following query which returns all paths possible from the specified node.\n```\ng.V(<some_id>).repeat(bothE().bothV().simplePath()).emit().dedup().path()\n```\n\nIf we had a simple graph of 3 nodes in this structure:\n```\nA -- edge_1 -> B -- edge_2 -> C\n```\n\nthis query would return two paths:\n```\nA, edge_1, B\nA, edge_1, B, edge_2, C\n```\n\nHowever, I only want to return all paths that terminate (i.e. there is no further nodes to traverse), which in this example would only return\n```\nA, edge_1, B, edge_2, C\n```\n\nIs this possible?\n    ", "Answer": "\r\nYou can try to do the ```\nrepeat```\n without the ```\nemit```\n step and use ```\nuntil```\n to stop at the end of the path.\n```\ng.V().hasLabel('A').repeat(bothE().bothV().\n    simplePath()).\n  until(bothE().simplePath().\n    count().is(eq(0))).dedup().path()\n```\n\nexample: https://gremlify.com/jqr8y7p24wb\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in unweighted undirected graph\r\n                \r\n\n\nHaving this graph as reference let's say i want the longest path between 0 and 5.\n\nThat would be: 0->1->3->2->4->6->5\n\nIs there any good algorithm for this? I've searched and haven't found anything that i was able to understand.\nI've found plenty algorithms for the shortest path (0->1->2->4->6->5) and i've implemented them successfully.\nMaybe i'm the problem, but i would like to think otherwise :)\n\nAny help would be welcome\n    ", "Answer": "\r\nThis problem is NP-Hard (there is a simple reduction from a Hamiltonian path to your problem, and a Hamiltonian path search is known to be NP-hard). It means that there is no polynomial solution for this problem (unless P = NP).\n\nIf you need an exact solution, you can use dynamic programming (with exponential number of states): the state is ```\n(mask of visited vertices, last_vertex)```\n, the value is true or false. A transition is adding a new vertex which is not in the ```\nmask```\n if there an edge between the ```\nlast_vertex```\n and the new vertex. It has ```\nO(2^n * n^2)```\n time complexity, which is still better than ```\nO(n!)```\n backtracking. \n\nHere is pseudo code of a dynamic programming solution:\n\n```\nf = array of (2 ^ n) * n size filled with false values\nf(1 << start, start) = true\nfor mask = 0 ... (1 << n) - 1:\n    for last = 0 ... n - 1:\n        for new = 0 ... n - 1:\n            if there is an edge between last and new and mask & (1 << new) == 0:\n                f(mask | (1 << new), new) |= f(mask, last)\nres = 0\nfor mask = 0 ... (1 << n) - 1:\n    if f(mask, end):\n        res = max(res, countBits(mask))\nreturn res\n```\n\n\nAnd a little bit more about reduction from Hamiltonian path to this problem:\n\n```\ndef hamiltonianPathExists():\n    found = false\n    for i = 0 ... n - 1:\n        for j = 0 ... n - 1:\n            if i != j:\n                path = getLongestPath(i, j) // calls a function that solves this problem\n                if length(path) == n:\n                    found = true\n    return found\n```\n\n\nHere is a Java implementation (I did not test properly, so it can contain bugs):\n\n```\n/**\n * Finds the longest path between two specified vertices in a specified graph.\n * @param from The start vertex.\n * @param to The end vertex.\n * @param graph The graph represented as an adjacency matrix.\n * @return The length of the longest path between from and to.\n */\npublic int getLongestPath(int from, int to, boolean[][] graph) {\n    int n = graph.length;\n    boolean[][] hasPath = new boolean[1 << n][n];\n    hasPath[1 << from][from] = true;\n    for (int mask = 0; mask < (1 << n); mask++)\n        for (int last = 0; last < n; last++)\n            for (int curr = 0; curr < n; curr++)\n                if (graph[last][curr] && (mask & (1 << curr)) == 0)\n                    hasPath[mask | (1 << curr)][curr] |= hasPath[mask][last];\n    int result = 0;\n    for (int mask = 0; mask < (1 << n); mask++)\n        if (hasPath[mask][to])\n            result = Math.max(result, Integer.bitCount(mask));\n    return result;\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find number of shortest paths in an unweighted, undirected graph using adejacency-matrix\r\n                \r\nI am trying to write an algorithm that takes an adjacency-matrix A and gives me the number of shortest paths between all pairs of nodes from length 1 to 20. For example, if there are 4 nodes that have a direct neighbor and 2 nodes that are connected by a shortest path of length two (and no paths longer than 2) the algorithm should return a vector [4 2 0 ... ].\n\nMy Idea is to use the fact that A^N gives to number of paths of length N between nodes.\n\nHere is how my code looks so far:\n\n```\nfunction separations=FindShortestPaths(A)\n\n#Save the original A to exponentiate \nB = A; \n\n#C(j,k) will be non-zero if there is a shorter path between nodes j and k                               \nC = sparse(zeros(size(A)));\n\nn = size(A,1);\n\n#the vector in which i save the number of paths\nseparations = zeros(20,1);\n\nfor i = 1:20\n    #D(j,k) shows how many paths of length i there are from j to k\n    #if there is a shorter path it will be saved in C, \n    #so every index j,k that is non-zero in C will be zero in D.\n    D = A;\n    D(find(C)) = 0;\n\n    #Afterwards the diagonal of D is set to zero so that paths from nodes to themselves are not counted. \n    D(1:n+1:n*n) = 0;\n\n    #The number of remaining non-zero elements in D is the number of shortest paths of length i \n    separations(i) = size(find(D),1);\n\n    #C is updated by adding the matrix of length-i paths.\n    C = C + A;\n\n    #A is potentiated and now A(j,k) gives the number of length i+1 paths from j to k\n    A = A*B;\nendfor\n\nendfunction\n```\n\n\nI tried it with some smaller graphs of length 5 to 8 and it worked (each pair is counted twice though) but when I tried it with a larger graph it gave me odd numbers for some lengths, which can't be right as every pair is counted twice.\n\nEdit:\n\nHere is an example of one of the graphs I tried and with which it worked: Graph\nThe adjacency Matrix of this graph is\n[010000\n101010\n010101\n001000\n010000\n001000]\n\nAnd the number of shortest paths of length n from any Node is:\n\nn: 1 2 3 4 5 6\n\nA: 1 2 2 0 0 0\n\nB: 3 2 0 0 0 0\n\nC: 3 2 0 0 0 0\n\nD: 1 2 2 0 0 0\n\nE: 1 2 2 0 0 0 \n\nF: 1 2 2 0 0 0\n\n\n\nTotal: 10 12 8 0 0 0\n\nSo the algorithm should (and in this case does) return a vector where the first 3 elements are 10 12 8 and the rest are zeros. However, with this bigger matrix it doesn't work.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "finding longest path in a graph\r\n                \r\nI am trying to solve a program, where in I have to find the max number of cities connected for a given list of routes.\n\nfor eg:\n    if the given route is ```\n[['1', '2'], ['2', '4'], ['1', '11'], ['4', '11']]```\n\n    then max cities connected will be ```\n4```\n\nconstraint is  I can't visit a city which I already have visited.\n\nI need ideas, as in how to progress.\n\nFor now, What I have thought is if I could be able to create a dictionary with cities as a key and how many other cities its connected to as its value, i get somewhere near to the solution(I hope).\nfor eg: My dictionary will be ```\n{'1': ['2', '11'], '4': ['11'], '2': ['4']}```\n\nfor the above given input.\nI want help to proceed further and guidance if I am missing anything.\n    ", "Answer": "\r\nYou can use a ```\ndefaultdict```\n to create your \"Graph\" from your list of edges/paths:\n\n```\nedges = [['1', '2'], ['2', '4'], ['1', '11'], ['4', '11']]\n\nG = defaultdict(list)\nfor (s,t) in edges:\n    G[s].append(t)\n    G[t].append(s)\n\nprint G.items()\n```\n\n\nOutput:\n\n\n[\n  ('1', ['2', '11']), \n  ('11', ['1', '4']), \n  ('2', ['1', '4']), \n  ('4', ['2', '11'])\n]\n\n\nNote that I added the edges in both directions, since you're working with an undirected graph.  So with the edge (a,b), ```\nG[a]```\n will include ```\nb```\n and ```\nG[b]```\n will include ```\na```\n.\n\nFrom this, you can use an algorithm like depth-first search or breadth-first search to discover all the paths in the graph.\n\nIn the following code, I used DFS:\n\n```\ndef DFS(G,v,seen=None,path=None):\n    if seen is None: seen = []\n    if path is None: path = [v]\n\n    seen.append(v)\n\n    paths = []\n    for t in G[v]:\n        if t not in seen:\n            t_path = path + [t]\n            paths.append(tuple(t_path))\n            paths.extend(DFS(G, t, seen[:], t_path))\n    return paths\n```\n\n\nWhich you can use  with:\n\n```\nG = defaultdict(list)\nfor (s,t) in edges:\n    G[s].append(t)\n    G[t].append(s)\n\nprint DFS(G, '1')\n```\n\n\nOutput:\n\n\n[('1', '2'), ('1', '2', '4'), ('1', '2', '4', '11'), ('1', '11'), ('1', '11', '4'), ('1', '11', '4', '2')]\n\n\nSo the full code, with the final bit that shows the longest path:\n\n```\nfrom collections import defaultdict\n\ndef DFS(G,v,seen=None,path=None):\n    if seen is None: seen = []\n    if path is None: path = [v]\n\n    seen.append(v)\n\n    paths = []\n    for t in G[v]:\n        if t not in seen:\n            t_path = path + [t]\n            paths.append(tuple(t_path))\n            paths.extend(DFS(G, t, seen[:], t_path))\n    return paths\n\n\n# Define graph by edges\nedges = [['1', '2'], ['2', '4'], ['1', '11'], ['4', '11']]\n\n# Build graph dictionary\nG = defaultdict(list)\nfor (s,t) in edges:\n    G[s].append(t)\n    G[t].append(s)\n\n# Run DFS, compute metrics\nall_paths = DFS(G, '1')\nmax_len   = max(len(p) for p in all_paths)\nmax_paths = [p for p in all_paths if len(p) == max_len]\n\n# Output\nprint(\"All Paths:\")\nprint(all_paths)\nprint(\"Longest Paths:\")\nfor p in max_paths: print(\"  \", p)\nprint(\"Longest Path Length:\")\nprint(max_len)\n```\n\n\nOutput:\n\n\nAll Paths:\n   [('1', '2'), ('1', '2', '4'), ('1', '2', '4', '11'), ('1', '11'), ('1', '11', '4'), ('1', '11', '4', '2')]\nLongest Paths:\n   ('1', '2', '4', '11')\n   ('1', '11', '4', '2')\nLongest Path Length:\n   4\n\n\nNote, the \"starting point\" of your search is specified by the second argument to the ```\nDFS```\n function, in this case, it's ```\n'1'```\n.\n\n\n\nUpdate:  As discussed in the comments the above code assumes you have a starting point in mind (specifically the code uses the node labelled ```\n'1'```\n).\n\nA more general method, in the case that you have no such starting point, would be to perform the search starting at every node, and take the overall longest.\n  (Note: In reality, you could be smarter than this)\n\nChanging the line\n\n```\nall_paths = DFS(G, '1')\n```\n\n\nto\n\n```\nall_paths = [p for ps in [DFS(G, n) for n in set(G)] for p in ps]\n```\n\n\nwould give you the longest path between any two points.\n\n(This is a silly list comprehension, but it allows me to update only a single line.  Put more clearly, it's equivalent to the following:\n\n```\nall_paths = []\nfor node in set(G.keys()):\n    for path in DFS(G, node):\n        all_paths.append(path)\n```\n\n\nor\n\n```\nfrom itertools import chain\nall_paths = list(chain.from_iterable(DFS(G, n) for n in set(G)))\n```\n\n\n).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Discover All Paths in Single Source, Multi-Terminal (possibly cyclic) Directed Graph\r\n                \r\nI have a graph ```\nG = (V,E)```\n, where \n\n\n```\nV```\n is a subset of ```\n{0, 1, 2, 3, …}```\n \n```\nE```\n is a subset of ```\nVxV```\n\nThere are no unconnected components in ```\nG```\n \nThe graph may contain cycles\nThere is a known node ```\nv```\n in ```\nV```\n, which is the source; i.e. there is no ```\nu```\n in ```\nV```\n such that ```\n(u,v)```\n is an edge\nThere is at least one sink/terminal node ```\nv```\n in ```\nV```\n; i.e. there is no ```\nu```\n in ```\nV```\n such that ```\n(v,u)```\n is an edge. The identities of the terminal nodes are not known - they must be discovered through traversal\n\n\nWhat I need to do is to compute a set of paths ```\nP```\n such that every possible path from the source node to any terminal node is in ```\nP```\n. Now, if the graph contains cycles, it is possible that by this definition, ```\nP becomes an infinite set. This is not what I need. Rather, what I need is for```\nP```\nto contain a path that doesn't explore the loop and at least one path that does explore the loop.\nI say \"at least one path that does explore the loop\", as the loop may contain branches internally, in which case, all of those branches will need to be explored as well. Thus, if the loop contains two internal branches, each with a branching factor of 2, then I need a total of four paths in```\nP` that explore the loop.\n\nFor example, an algorithm run on the following graph:\n\n```\n         +-------+\n         |       |\n         v       |\n1->2->3->4->5->6 |\n         |  |  | |\n         v  |  v |\n         9  +->7-+\n               |\n               v\n               8\n```\n\n\nwhich can be represented as:\n\n```\n1:{2}\n2:{3}\n3:{4}\n4:{5,9}\n5:{6,7}\n6:{7}\n7:{4,8}\n8:{}\n9:{}\n```\n\n\nShould produce the set of paths:\n\n```\n1,2,3,4,9\n1,2,3,4,5,6,7,8\n1,2,3,4,5,6,7,4,9\n1,2,3,4,5,7,8\n1,2,3,4,5,7,4,9\n1,2,3,4,5,7,4,5,6,7,8\n1,2,3,4,5,7,4,5,7,8\n```\n\n\nThus far, I have the following algorithm (in python) that works in some simple cases:\n\n```\ndef extractPaths(G, s=None, explored=None, path=None):\n    _V,E = G\n    if s is None: s = 0\n    if explored is None: explored = set()\n    if path is None: path = [s]\n    explored.add(s)\n\n    if not len(set(E[s]) - explored):\n        print path\n    for v in set(E[s]) - explored:\n        if len(E[v]) > 1:\n            path.append(v)\n            for vv in set(E[v]) - explored:\n                extractPaths(G, vv, explored-set(n for n in path if len(E[n])>1), path+[vv])\n        else:\n            extractPaths(G, v, explored, path+[v])\n```\n\n\nbut it fails horribly in the more complex cases. \n\nI'd appreciate any help as this is a tool to validate an algorithm that I have developed for my Master's thesis.\nThank you in advance\n    ", "Answer": "\r\nI've though about this for a couple of hours, and have come up with this algorithm. It doesn't quite give the result you're asking for, but it's similar (and might be equivalent).\n\nObservation: If we try to go to a node that has been seen before, the most recent visit, up until the current node, can be considered a loop. If we have seen that loop, we cannot go to that node.\n\n```\ndef extractPaths(current_node,path,loops_seen):\n    path.append(current_node)\n    # if node has outgoing edges\n    if nodes[current_node]!=None:\n        for thatnode in nodes[current_node]:\n            valid=True\n            # if the node we are going to has been\n            # visited before, we are completeing\n            # a loop.\n            if thatnode-1 in path:\n                i=len(path)-1\n                # find the last time we visited\n                # that node\n                while path[i]!=thatnode-1:\n                    i-=1\n                # the last time, to this time is\n                # a single loop.\n                new_loop=path[i:len(path)]\n                # if we haven't seen this loop go to\n                # the node and node we have seen this\n                # loop. else don't go to the node.\n                if new_loop in loops_seen:\n                    valid=False\n                else:\n                    loops_seen.append(new_loop)\n            if valid:\n                extractPaths(thatnode-1,path,loops_seen)\n    # this is the end of the path\n    else:\n        newpath=list()\n        # increment all the values for printing\n        for i in path:\n            newpath.append(i+1)\n        found_paths.append(newpath)\n    # backtrack\n    path.pop()\n\n# graph defined by lists of outgoing edges\nnodes=[[2],[3],[4],[5,9],[6,7],[7],[4,8],None,None]\n\nfound_paths=list()\nextractPaths(0,list(),list())\nfor i in found_paths:\n    print(i)\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Creating a tree graph in R that maps frequency of paths\r\n                \r\nI struggled titling this post, but hopefully the example and explanation below will help. I would like to create a tree graph that shows the frequency of different \"paths\" in my data. I have the following dataframe:\n\n```\nzed = data.frame(\n  node1 = c(\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\"),\n  node2 = c(\"A\", \"B\", \"A\", \"B\", \"A\", \"B\", \"A\", \"B\"),\n  node3 = c(\"B\", \"C\", \"D\", \"D\", \"C\", \"D\", \"C\", \"C\"),\n  node4 = c(\"C\", \"C\", \"D\", \"D\", \"D\", \"D\", \"D\", \"C\"),\n  stringsAsFactors = FALSE\n)\n```\n\n\nand I would like to create a graph in R that looks something along these lines (really rough sketch made quickly in excel): \n\n\n\nEssentially, each row in the dataframe is a path. All paths start at \"A\", which is why \"A\" is the single top node, and then (in this example) they progress to B, C and D. Certain paths occur more frequently than others (A -> B -> C -> C shows up twice, whereas some other paths show up once), and I think I would like this reflected in the size of the nodes. \n\nI am not sure if i should reformat my data for this, and also which R graphing library is best for this. Happy to add more context - any help is appreciated!!\n    ", "Answer": "\r\nThe advice I'm going to give is for the ```\nigraph```\n package:\n\nTo create a graph from a data frame your data has to be in long format where the first two columns represents the nodes links are coming from (the first column) and where the links are going to (the second column). Also, the names of the nodes have to be unique, so an edge from 'A' to 'A' is simply a node pointing to itself. Your data has different nodes named 'A'. Using your data, you will need to do something like this:\n\n```\nzed$node1 <- paste0(zed$node1, '_1')\nzed$node2 <- paste0(zed$node2, '_2')\nzed$node3 <- paste0(zed$node3, '_3_', 1:nrow(zed))\nzed$node4 <- paste0(zed$node4, '_4_', 1:nrow(zed))\n\nedgelist <- rbind(\n  as.matrix(zed[c('node1', 'node2')]),\n  as.matrix(zed[c('node2', 'node3')]),\n  as.matrix(zed[c('node3', 'node4')])\n)\n```\n\n\nWhich will give you:\n\n\n\nTo plot it  you will need to do something like this:\n\n```\nlibrary(igraph)\ng <- graph_from_data_frame(edgelist)\nplot(g, layout = layout_as_tree(g))\n```\n\n\n\n\nIf you want to learn more, then I highly recommend taking a look at Katya Ognyanova's tutorials: http://kateto.net/tutorials/\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Efficiently finding the shortest path in large graphs\r\n                \r\nI'm looking to find a way to in real-time find the shortest path between nodes in a huge graph. It has hundreds of thousands of vertices and millions of edges. I know this question has been asked before and I guess the answer is to use a breadth-first search, but I'm more interested in to know what software you can use to implement it. For example, it would be totally perfect if  it already exist a library (with python bindings!) for performing bfs in undirected graphs.\n    ", "Answer": "\r\npython-graph\n\nadded:\n\nThe comments made me curious as to how the performance of pygraph was for a problem on the order of the OP, so I made a toy program to find out. Here's the output for a slightly smaller version of the problem:\n\n```\n$ python2.6 biggraph.py 4 6\nbiggraph generate 10000 nodes     00:00:00\nbiggraph generate 1000000 edges   00:00:00\nbiggraph add edges                00:00:05\nbiggraph Dijkstra                 00:01:32\nbiggraph shortest_path done       00:04:15\nstep: 1915 2\nstep: 0 1\nbiggraph walk done                00:04:15\npath: [9999, 1915, 0]\n```\n\n\nNot too bad for 10k nodes and 1M edges. It is important to note that the way Dijkstra's is computed by pygraph yields a dictionary of all spanning trees for each node relative to one target (which was arbitrarily node 0, and holds no privileged position in the graph). Therefore, the solution that took 3.75 minutes to compute actually yielded the answer to \"what is the shortest path from all nodes to the target?\". Indeed once ```\nshortest_path```\n was done, walking the answer was mere dictionary lookups and took essentially no time. It is also worth noting that adding the pre-computed edges to the graph was rather expensive at ~1.5 minutes. These timings are consistent across multiple runs.\n\nI'd like to say that the process scales well, but I'm still waiting on ```\nbiggraph 5 6```\n on an otherwise idled computer (Athlon 64, 4800 BogoMIPS per processor, all in core) which has been running for over a quarter hour. At least the memory use is stable at about 0.5GB. And the results are in:\n\n```\nbiggraph generate 100000 nodes    00:00:00\nbiggraph generate 1000000 edges   00:00:00\nbiggraph add edges                00:00:07\nbiggraph Dijkstra                 00:01:27\nbiggraph shortest_path done       00:23:44\nstep: 48437 4\nstep: 66200 3\nstep: 83824 2\nstep: 0 1\nbiggraph walk done                00:23:44\npath: [99999, 48437, 66200, 83824, 0]\n```\n\n\nThat's a long time, but it was also a heavy computation (and I really wish I'd pickled the result). Here's the code for the curious:\n\n```\n#!/usr/bin/python\n\nimport pygraph.classes.graph\nimport pygraph.algorithms\nimport pygraph.algorithms.minmax\nimport time\nimport random\nimport sys\n\nif len(sys.argv) != 3:\n    print ('usage %s: node_exponent edge_exponent' % sys.argv[0])\n    sys.exit(1)\n\nnnodes = 10**int(sys.argv[1])\nnedges = 10**int(sys.argv[2])\n\nstart_time = time.clock()\ndef timestamp(s):\n    t = time.gmtime(time.clock() - start_time)\n    print 'biggraph', s.ljust(24), time.strftime('%H:%M:%S', t)\n\ntimestamp('generate %d nodes' % nnodes)\nbg = pygraph.classes.graph.graph()\nbg.add_nodes(xrange(nnodes))\n\ntimestamp('generate %d edges' % nedges)\nedges = set()\nwhile len(edges) < nedges:\n    left, right = random.randrange(nnodes), random.randrange(nnodes)\n    if left == right:\n        continue\n    elif left > right:\n        left, right = right, left\n    edges.add((left, right))\n\ntimestamp('add edges')\nfor edge in edges:\n    bg.add_edge(edge)\n\ntimestamp(\"Dijkstra\")\ntarget = 0\nspan, dist = pygraph.algorithms.minmax.shortest_path(bg, target)\ntimestamp('shortest_path done')\n\n# the paths from any node to target is in dict span, let's\n# pick any arbitrary node (the last one) and walk to the\n# target from there, the associated distance will decrease\n# monotonically\nlastnode = nnodes - 1\npath = []\nwhile lastnode != target:\n    nextnode = span[lastnode]\n    print 'step:', nextnode, dist[lastnode]\n    assert nextnode in bg.neighbors(lastnode)\n    path.append(lastnode)\n    lastnode = nextnode\npath.append(target)\ntimestamp('walk done')\nprint 'path:', path\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Given a list of paths through a graph, efficiently find the ones that use each edge\r\n                \r\nI have a graph and a list of paths in this graph.  For each edge ```\ne```\n, I need to find the paths that use ```\ne```\n, then do some other work based on these paths.  The size of the graph and a restriction on memory usage are such that I can't just iterate once over all of the paths building up an array of sets, where set ```\ni```\n contains the paths that use edge ```\ni```\n.\n\nThe brute force approach that will work is:\n\n```\nfor edge in edges:\n    x = []\n    for path in paths:\n        if edge in path:\n          x.append(path)\n    f(x)\n```\n\n\nHow can I get better time efficiency while maintaining memory efficiency?\n    ", "Answer": "\r\nYour specification is not clear. Where do you get the graph and the path from? Are they already pre-calculated and stored in a disk? Do you need to maintain the path set for all edges in the graph in the RAM at the same time or can you process them one by one, and then release the memory? Do you store copies of the path when you create the sets or can you index into a single copy?\n\nIf you do not have enough RAM you could use some data-structures which operate on disks. The STXXL library is one such library.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in graph where cost depends on the history of traversing\r\n                \r\nMy goal is to find the shortest path (lowest cost) between given cities (vertices) connected with roads (edges).\nEach road and each city has charge (cost) that has to be paid before entering that road/city.\n\nIf that would be whole task, I would use Dijkstra algorithm to find the shortest path (and add city cost to the cost of the road connected right before it).\n\nBUT :\n\nCities have something like partnership agreements - when you visit and pay charge in one of them, entering rest of the cities in this particural partnership is free.\n\nSo, cost of the vertex (edge connected before it) depends on vertices that has been already traversed.\n\nIs there any algorithm for that kind of problem?\n\nThank you.\n    ", "Answer": "\r\nYou can reduce the set cover problem to this one. That means your problem is NP hard, and you shouldn't expect to find an efficient solution (in general).\n\nThat means you should hope that the number of partnerships is small, and perhaps then you can get away with considering all possible subsets of non-singleton road/city partnerships, and finding the shortest path for each (assuming that your path will go through only roads/cities in the given subset you're considering). Then your algorithm will run in 2^P * (N+M) time where P is the number of partnerships, and N and M are the number of cities and roads respectively.\n\nFor completeness, here's the reduction from set cover to your graph problem:\n\nThe set cover problem is that you're given a finite set S = {s[1], ..., s[n]}, and subsets of S: S[1], S[1], S[2], ..., S[N]. You're asked to find the minimal number of these subsets that cover S.\n\nTo use your city problem to find the minimal cover, construct a graph like this. Let the vertices of the graph be START, END, and pairs (S[i], t) where and t is in S[i]. Add edges in the graph between:\n\n\nSTART and (S[i], s[1]) for each S[i] with s[1] in S[i]\n(S[i], s[n]) and END for each S[i] with s[n] in S[i].\n(S[i], s[k]) and (S[i'], s[k+1]) for each k in 1...n-1 and for each S[i] and S[i'] which contain the corresponding elements.\n\n\nLet the edge weights be all 1, and let the cost of entering (S[i], s) also be 1. All cities/vertices (S[i], s), (S[i], t) share the same cost. No two roads/edges share a cost.\n\nNow, a lowest-cost path from START to END corresponds to finding the minimal set of S[i] that cover S. The cost of that path will be 1 + n + p where p is the size of the minimal cover.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "search all paths and the shortest path for a graph - Prolog\r\n                \r\nI have a problem in my code with turbo prolog which searches all paths and the shortest path in a graph between 2 nodes.\nThe problem that i have is to test if the node is in the list or not (exactly in the clause of member)\n\n```\n           1    ---- b ----   3\n           ---       |        ---\n        ---          |             -----\n      a              |5                  d\n        ---          |             -----\n            ---      |         ---\n             2  ---  |     ---   4\n                  -- c  --\n\nfor example we have for b--->c \n([b,c],5) , ([b,a,c],3) and ([b,d,c],7) : possible paths.\n([b,a,c],3) : the shortest path.\n```\n\n\nand this is my code : \n\n```\nDOMAINS\n    list=Symbol *\n\nPREDICATES\n    distance(Symbol, Symbol)\n    path1(Symbol, Symbol, list, integer)\n    path(Symbol, Symbol,list, list, integer)\n    distance(Symbol, list, integer)\n    member(Symbol, list)\n    shortest(Symbol, Symbol, list, integer)\n\nCLAUSES\n    distance(a, b, 1).\n    distance(a, c, 2).\n    distance(b, d, 3).\n    distance(c, d, 4).\n    distance(b, c, 5).\n    distance(b, a, 1).\n    distance(c, a, 2).\n    distance(d, b, 3).\n    distance(d, c, 4).\n    distance(c, b, 5).\n\n    member(X, [X|T]).\n    member(X, [Y|T]) :- member(X, T).\n\n    absent(X, L) :-\n        member(X, L),\n        !,\n        fail.\n    absent(_, _).\n\n    /* find all paths */\n    path1(X, Y, L, C) :- path(X, Y, L, I, C).\n    path(X, X, [X], I, C) :- absent(X, I).\n    path(X, Y, [X|R], I, C) :-\n        distance(X, Z, A),\n        absent(Z, I),\n        path(Z, Y, R, [X|I], C1),\n        C = C1 + A\n        .\n\n    /* to find the shortest path */\n    shortest(X, Y, L, C) :-\n        path(X, Y, L, C),\n        path(X, Y, L1, C1),\n        C < C1.\n```\n\n    ", "Answer": "\r\nThis shows the shortest path and it's weight:\n\n```\nedge(a,b,6).\nedge(a,c,1).\nedge(b,d,5).\nedge(c,e,4).\nedge(c,f,1).\nedge(d,h,3).\nedge(e,h,7).\nedge(f,g,2).\nedge(g,h,1).\n\npath(X,Y,M,[Y]) :- edge(X,Y,M).\npath(X,Y,P,[Z|T]) :- edge(X,Z,M),path(Z,Y,N,T),\n            P is M+N.\n\npravilo(X,Y,Z) :-  assert(min(100)),assert(minpath([])),!,\n                path(X,Y,K,PATH1),\n                (min(Z),K<Z,\n                retract(min(Z));assert(min(K))),\n                minpath(Q),retract(minpath(Q)),\n                assert(minpath([X|PATH1])),\n                fail.\n\n?- pravilo(a,h,X);\n    write(\"Minimal Path:\"),\n    minpath(PATH),\n    write(PATH),\n    nl,\n    write(\"Path weight:\"),\n    min(Z),\n    write(Z).\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all possible paths between all vertices of a graph\r\n                \r\nI have a directed graph with 13 vertices and would like to examine all possible simple paths of all lengths (max=12). I tried the FindPath[Graph,Vertex1,Vertex2,12,All] formula, but had to enter this function 13*12 times due to the fact that I don’t know how to extract the paths in a quicker and simpler way. Is there a way to extract all the paths (from every vertex to every other vertex) with just one formula instead of 156 formulas?\nI also have access to the Adjacency-Matrix, which might hint to another possible way, but I don’t know how to extract paths from the adjacency Matrix.\nI know that there have been a lot of questions about how to find all possible paths between two vertices, but I need a bigger image.\n    ", "Answer": "\r\nThe main thing is that you don't know the primitives for mapping a function on a two-dimensional array  or triangle.  Lookup ```\nMap```\n, ```\nOuter```\n, ```\nTable```\n, ```\nScan```\n, ```\nMapThread```\n, etc. in Mathematica Documentation.\n\nOne way to do it is (adapted to your case) :  \n\n```\nFlatten[ Table[ Table[ \n  FindPath[ mygraph, vertexlist[[i]],  vertexlist[[j]], 12, All ],\n    {j,i+1, Length[vertexlist] }], {i, 1, Length[vertexlist]-1 }], 1]\n```\n\n\nassuming you put in vertexlist the identifications of your vertices. If these are just integers from 1 to 13, you can just put i in place of vertexlist[[i]] etc.\n\nYou will get n*(n-1)/2 lists of paths between two different vertices, sorted by starting vertex. If your graph is oriented, you might want the whole n*(n-1) instead. Simple modifications of the code above will give you that.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Cycle detection in graphs containing multiple cycles\r\n                \r\nI have the following graph:\n\n\n\nIs there a way I can identify all cycles in this graph? I know that DFS can be used to detect cycles by simply doing DFS until a back edge is found, but I was wondering if there is a computationally efficient way to return the individual cycles, considering that there are actually 3 cycles in the graph (1-2-3-4-5-6, 4-5-7-8-9, 1-2-3-4-9-8-7-5-6). I am a bit stuck because it seems like the carbon atom belongs to multiple graphs and I can't think of any way other than brute-forcing all possible paths originating from every vertex. \n    ", "Answer": "\r\nYou don't have to find all pathes from EVERY vertex.\n\nOnly vertex refering to 3 or more other may belong to multiple cycles \n\nYou have to check only 4,5,6(,9)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths w/o loops in Graph in Prolog\r\n                \r\nI got an homework assignment for my logic course, but more or less don't have any clue how to solve it...\nWith a query like\n\n```\n  ?- find(a,[r(a,[b,d]),r(b,[a,c,e]),r(c,[b]),r(d,[a,e]),\n  r(e,[b,d,f]),r(f,[e,g]),r(g,[f])],Path).\n```\n\n\nProlog should return all possible paths in the given graph. The terms r(X,List) define the graph, meaning that the nodes in List can be reached from node X. In this case, the output would be:\n\n```\nPath = [a,b,c] ;\nPath = [a,b,e,d] ;\nPath = [a,b,e,f,g] ;\nPath = [a,d,e,b,c] ;\nPath = [a,d,e,f,g] ;\nfalse.\n```\n\n\nAlthough I get the hang of the numerous solutions here on SE and on the web in general to similar problems, I'm somehow too dumb to figure out how to work with the definition of the graph in this assignment. \n\nI figure that find(Start,...) should be called recursively with all members of the list in r(Start,List), but as a total newbie to Prolog(we just did the standard family tree stuff...) I don't know how to do that.\n\nAny help would be really appreciated. I'm aware of the fact that I don't have much to start with, but I already spent half a night trying to figure something out and up to now I don't have a clue.\n\n/Edit:\n\nFor starters, I think I'll need some kind of base case to abort the recursion.\nI think it should be either\n\n```\nfind([],_,_).\n```\n\n\nbecause I guess that the last recursive call wouldn't have anything to start with, or\n\n```\nfind(_,[],_).\n```\n\n\nassuming that the list of the terms defining adjacent nodes should be empty when the program finished processing it.\n\nNow the actual call. Probably something like\n\n```\nfind(Start,[r(Start,[Adjacent|Restadj])|Rest],Path):-\n           find(???).\n```\n\n\nMy problems here are the following:\n\n-How do I make the program use the members of the list in the r(...) term as the next   Start?\n\n-How do I check if a node has already been \"visited\"/ How can I remove a node from a specific list in r\n\n-How do I put the found nodes into the Path list? Simply append? Or execute the recursive call with something like [Path|Start]?\n\nAs you see, it's not much. Some suggestive questions would be nice, since Prolog seems quite interesting and therefore fun to learn...\n\n\n\nAfter spending some time with the neat PDT-Eclipse trace tool, I think I understood what the program is doing. What I dont't get at this point is why the last node always gets lost. After backtracking fails, for example because r(c,[b]) is the next found term and memberchk(b,[b]) fails because of the negation(that's what I thing + does) and no other term with r(c,X) can be found, it starts over with looking for other possibilities to go from node b, which has adjacent nodes left in r(b,[...]). But why does the program forget to put node c into the Path list? Is there a possibility to do some kind of if-then-else in case \n\n```\n member(r(Node, Adjacent), Graph),\nmember(AdjNode, Adjacent),\n\\+ memberchk(AdjNode, Seen),\n```\n\n\nfails, to still append the last node to Path?\n    ", "Answer": "\r\nI suspect what's tripping you up here is that instead of getting the data out of the database, you're having to find it from within an explicit data structure. A first crack at this might look like this:\n\n```\nfind(_, _, []).\nfind(Node, Graph, [Node|Path]) :-\n    member(r(Node,Adjacent), Graph),\n    member(AdjNode, Adjacent),\n    find(AdjNode, Graph, Path).\n```\n\n\nSee how I'm using ```\nmember/2```\n to find data from within the graph. This solution isn't correct though, because it loops. An improvement might be this:\n\n```\nfind(Node, Graph, Path) :- find(Node, Graph, Path, []).\n\nfind(_, _, [], _).\nfind(Node, Graph, [Node|Path], Seen) :-\n    member(r(Node, Adjacent), Graph),\n    member(AdjNode, Adjacent),\n    \\+ memberchk(AdjNode, Seen),\n    find(AdjNode, Graph, Path, [Node|Seen]).\n```\n\n\nThis one is basically the same as the above version except it has a \"seen\" list to track where it has already been. This still doesn't produce the output you want, but I think it will be enough to get you on the right track.\n\nEdit in response to your edit,\n\n\n  For starters, I think I'll need some kind of base case to abort the recursion.\n\n\nYes. I chose your first case because I don't think you can safely \"consume\" the graph during traversal. I suppose you could use ```\nselect/3```\n in lieu of ```\nmember/2```\n and pass the graph-without-this-node onward. That might be an interesting thing to try (suggestion!).\n\n\n  \n  How do I make the program use the members of the list in the r(...) term as the next Start?\n  \n\n\nAs demonstrated, use ```\nmember/2```\n to retrieve things from the graph. It's funny, because you used the exact word for the predicate you need. :)\n\n\n  \n  How do I check if a node has already been \"visited\"/ How can I remove a node from a specific list in r\n  \n\n\nAs demonstrated in my second set of code, you have another parameter for your auxiliary predicate, and use ```\nmemberchk/3```\n or ```\nmember/3```\n.\n\n\n  \n  How do I put the found nodes into the Path list? Simply append? Or execute the recursive call with something like [Path|Start]?\n  \n\n\nI went with the recursive call. ```\nappend/3```\n would be more expensive.\n\nEdit: Using ```\nfindall/3```\n per Will's comment, we can find all the paths at once:\n\n```\nall_paths(From, Graph, Paths) :- findall(Path, find(From, Graph, Path), Paths).\n```\n\n\nYou can invoke this like so:\n\n```\n?- all_paths(a, [r(a,[b,d]),r(b,[a,c,e]),r(c,[b]),r(d,[a,e]),\n                 r(e,[b,d,f]),r(f,[e,g]),r(g,[f])], AllPaths).\n```\n\n\nI haven't tested that but it should work.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in Directed Acyclic Graph\r\n                \r\nI am given a string of characters, in which every consequent pair of characters comprises an edge. What I mean by that is this is the string: ABBCAD. Edges of the string are:\n\n```\nA->B\nB->C\nA->D\n```\n\n\nShortest path distance is A->D\n\nThe task at hand is to build up a Directed Acyclic Graph in memory from the string using the above rule and find the shortest path staring at the root node(in the example given it's A label) ending at terminal node.\n\nNJKUUGHBNNJHYAPOYJHNRMNIKAIILFGJSNAICZQRNM \n\nI gather one of the approaches that suites the task is to use the Depth First Search algo.\n\nThis is not homework...\n    ", "Answer": "\r\nThis is a job for Djikstra's Algorithm. Once you build a representation of your graph it should be easy enough to produce the lowest cost traversal ... since in your case it seems that all paths have an equal cost (1).\n\nYou can look here on CodeProject for a reasonably decent implementation of Djikstra in C#.\n\n\n  could you present me with a pseudo code of your version of the graph representation for this case?\n\n\nThere are multiple ways to represent a graph in such a problem. If the number of vertices in your graph are likely to be small - it would be sufficient to use an adjacency matrix for the representation of edges. In which case, you could just use a .NET multidimensional array. The trick here is that you need to convert vertices labelled with characters to ordinal values. One approach would be to write a wrapper class that maps character codes to indices into the adjacency matrix:\n\n```\nclass AdjacencyMatrix\n{\n    // representation of the adjacency matrix (AM)\n    private readonly int[,] m_Matrix;\n    // mapping of character codes to indices in the AM\n    private readonly Dictionary<char,int> m_Mapping;\n\n    public AdjacencyMatrix( string edgeVector )\n    {\n        // using LINQ we can identify and order the distinct characters\n        char[] distinctChars = edgeVector.Distinct().OrderBy(x => x);\n\n        m_Mapping = distinctChars.Select((c,i)=>new { Vertex = c, Index = i })\n                                 .ToDictionary(x=>x.Vertex, x=>x.Index);\n\n        // build the adjacency cost matrix here...\n        // TODO: I leave this up to the reader to complete ... :-D\n    }\n\n    // retrieves an entry from within the adjacency matrix given two characters\n    public int this[char v1, char v2]\n    {\n        get { return m_Matrix[m_Mapping[v1], m_Mapping[v2]];\n        private set { m_Matrix[m_Mapping[v1], m_Mapping[v2]] = value; }\n    }\n}\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find all paths in a graph that start with some initial partial path?\r\n                \r\nThere is the following part of the code:\n```\nSimpleDirectedGraph<String, DefaultEdge> multigraph = new SimpleDirectedGraph<>(DefaultEdge.class);\nmultigraph.addVertex(\"a\");\nmultigraph.addVertex(\"b\");\nmultigraph.addVertex(\"c\");\nmultigraph.addVertex(\"1\");\nmultigraph.addEdge(\"a\", \"b\");\nmultigraph.addEdge(\"b\", \"c\");\nmultigraph.addEdge(\"c\", \"1\");\n```\n\nDependencies:\n```\ngradle: implementation group: 'org.jgrapht', name: 'jgrapht-core', version: '1.5.1'\n```\n\nI also have only a part of the path (\"abc\"). And I need to get on this part all possible paths that include this part, that is, in this case: \"abc1\".\n\nHow can i do this? AsSubgraph, AllDirectedPaths, GraphWalk, BFSShortestPath - this all does not give the desired result, it just outputs the part that I know.\nThanks in advance.\n    ", "Answer": "\r\nFrom what I understand, you are looking to find all paths in a graph that start with some initial partial path ```\np1=[v_1,v_2,...,v_n]```\n. To do so, we must find every path ```\np2```\n that starts at vertex ```\nv_n```\n (the last vertex of ```\np1```\n) and ends in some other vertex not yet visited by ```\np1```\n.\nThere are two alternative ways to accomplish this:\n\nRun a shortest path algorithm from vertex v_n in a graph that does not contain any of the vertices in ```\np1```\n except ```\nv_n```\n.\nRun a BFS from vertex ```\nv_n```\n in a graph that does not contain any of the vertices in ```\np1```\n except ```\nv_n```\n.\n\nBoth solutions in code:\n```\npublic static void shortestPathSolution(){\n    Graph<String, DefaultEdge> graph=getGraph();\n\n    List<String> partialPathP1=List.of(\"a\",\"b\",\"c\"); //some partial path\n    String source=partialPathP1.get(partialPathP1.size()-1); //the last vertex of P1\n    List<List<String>> completePaths = new ArrayList<>();\n\n    //To prevent P2 from revisiting vertices in P1, create a graph which hides all but the last vertex in P1.\n    Set<String> vertexSubset=new HashSet<>(graph.vertexSet());\n    vertexSubset.removeAll(partialPathP1);\n    vertexSubset.add(source);\n    Graph<String,DefaultEdge> inducedSubgraph = new AsSubgraph<>(graph, vertexSubset);\n\n    //Find the shortest paths from the end of P1 to all reachable vertices in the graph\n    ShortestPathAlgorithm.SingleSourcePaths<String,DefaultEdge> shortestPaths=new DijkstraShortestPath<>(inducedSubgraph).getPaths(source);\n    //Iterate over the reachable vertices and construct all extensions\n    for(String vertex : inducedSubgraph.vertexSet()){\n        if(vertex.equals(source)) continue;\n        GraphPath<String, DefaultEdge> gp = shortestPaths.getPath(vertex);\n        if(gp == null) continue; //No path exists from the end of P1 to the given vertex\n\n        //Obtain path P2\n        List<String> partialPathP2 = gp.getVertexList();\n        //Construct path P by concatenating P1 and P2\n        List<String> pathP = new ArrayList<>(partialPathP1);\n        pathP.addAll(partialPathP2.subList(1, partialPathP2.size()));\n        completePaths.add(pathP);\n    }\n\n    System.out.println(completePaths);\n}\n\npublic static void bfsSolution(){\n    Graph<String, DefaultEdge> graph = getGraph();\n\n    List<String> partialPathP1 = List.of(\"a\", \"b\", \"c\"); //some partial path\n    String source = partialPathP1.get(partialPathP1.size() - 1); //the last vertex of P1\n    List<List<String>> completePaths = new ArrayList<>();\n\n    //To prevent P2 from revisiting vertices in P1, create a graph which hides all but the last vertex in P1.\n    Set<String> vertexSubset = new HashSet<>(graph.vertexSet());\n    vertexSubset.removeAll(partialPathP1);\n    vertexSubset.add(source);\n    Graph<String, DefaultEdge> inducedSubgraph = new AsSubgraph<>(graph, vertexSubset);\n\n    //Run a BFS from the source vertex. Each time a new vertex is encountered, construct a new path.\n    BreadthFirstIterator<String, DefaultEdge> bfs = new BreadthFirstIterator<>(inducedSubgraph, source);\n    while(bfs.hasNext()){\n        String vertex=bfs.next();\n        //Create path P2 that ends in the vertex by backtracking from the new vertex we encountered\n        Stack<String> partialPathP2 = new Stack<>();\n        while(vertex != null) {\n            partialPathP2.push(vertex);\n            vertex=bfs.getParent(vertex);\n        }\n        partialPathP2.pop(); //Remove the source vertex\n        List<String> pathP = new ArrayList<>(partialPathP1.size()+partialPathP2.size());\n        pathP.addAll(partialPathP1);\n        while(!partialPathP2.isEmpty())\n            pathP.add(partialPathP2.pop());\n        completePaths.add(pathP);\n    }\n\n    System.out.println(completePaths);\n}\n\npublic static Graph<String,DefaultEdge> getGraph(){\n    Graph<String, DefaultEdge> graph = new SimpleDirectedGraph<>(DefaultEdge.class);\n    Graphs.addAllVertices(graph, List.of(\"a\",\"b\",\"c\",\"1\",\"2\",\"3\"));\n    graph.addEdge(\"a\", \"b\");\n    graph.addEdge(\"b\", \"c\");\n    graph.addEdge(\"c\", \"1\");\n    graph.addEdge(\"c\", \"2\");\n    graph.addEdge(\"1\", \"3\");\n    graph.addEdge(\"2\", \"3\");\n    return graph;\n}\n```\n\nResult:\n```\n[[a, b, c], [a, b, c, 1], [a, b, c, 2], [a, b, c, 1, 3]]\n```\n\nNote:\nFor performance reasons, it is always best to choose the graph type that best suits your application. If you don't need self-loops and multiple edges, instead of choosing a ```\nDirectedPseudograph```\n, it would be better to use a ```\nSimpleDirectedGraph```\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Time complexity of the generic algorithm for finding shortest path in a graph\r\n                \r\nI am studying MIT's introduction to algorithms course, and I came across the analysis of the time complexity for a generic algorithm for finding the shortest path in a graph.\nhere is the pseudocode of the algorithm:\n\nand here is the relaxation process on a graph:\n\nI just could not understand why does relaxation process takes exponential time in the worst case as expressed by the O(2 ^(N/2)).\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "find minimum bottleneck path in a graph\r\n                \r\nconsider we have a complete graph with n vertexes. Each vertex has a value. weight of the edge between two vertexes i and j is equal to value[i] xor value[j].\nthe question is to find a path from vertex 1 to vertex n which the maximum of weighes of edges in the path is minimum. I already modified Dijkstra's algorithm and found an algorithm of O(n ^ 2 lg(n)). can someone help me find a more efficient algorithm?\n    ", "Answer": "\r\nMinimum bottleneck value cannot be less than the number determined by the most significant bit (```\nM```\n) of this value: ```\nvalue[1] XOR value[n]```\n. If you find two nodes ```\nA```\n and ```\nB```\n, such that ```\nM```\n and higher bits of nodes ```\n1```\n and ```\nA```\n are equal as well as equal are ```\nM```\n and higher bits of nodes ```\nn```\n and ```\nB```\n, with minimal edge weight between ```\nA```\n and ```\nB```\n, the minimum bottleneck path would be 1-A-B-n (or it may be shorter if A=1 and/or B=n).\n\nTo choose ```\nA/B```\n pair with minimal edge weight, construct a binary trie for all node values with high order bits (```\nM```\n and higher) coinciding with node ```\n1```\n. Then for all node values with high order bits coinciding with node ```\nn```\n, try to search these values in this trie. If exact match is not found, choose deepest partial match.\n\nTime complexity is O(n * M).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Additional constraints during searching shortest path in weighted graph using NetworkX\r\n                \r\nI've question to You about adding additional constraints during searching shortest path in weighted graph using NetworkX\n\nExample graph:\n\n```\nG.add_edge(A, B, weight=1)\nG.add_edge(B, C, weight=2)\nG.add_edge(A, C, weight=1)\n..\n..\n..\nG.add_edge(Y, Z, weight=6)\n```\n\n\nSo, now I want to find shortest path from A to F including some points eg: C, L, G, R (ordering has no meaning). How do that using NetworkX.\n\nThank you!\n    ", "Answer": "\r\n\nThis probably isn't the best solution, but anyway:\n\n```\nimport networkx as nx\nfrom string import letters\nfrom random import sample, randint\nfrom itertools import permutations\n\n# generate random graph    \nG = nx.Graph()\n\nnodes = list(letters[:20])\n\nfor anode in nodes:\n   G.add_node(anode, weight=randint(1,20))\n\nfor edge in [sample(nodes, 2) for i in range(60)]:\n   G.add_edge(*edge)\n```\n\n\nNow, let's define our path-searching functionality:\n\n```\ndef multiple_dijkstra(G, apath, result, n=0, i=1):\n   \"\"\"For a path of: a - b - c - d, search recursively for the shortest\n   paths between 'a' and 'b', then 'b' and 'c', then 'c' and 'd'.\n   Return a list which is a path from 'a' to 'd' through 'b' and 'c'.\"\"\"\n   try:\n      result.extend(nx.dijkstra_path(G, apath[n], apath[i])[:-1])\n      multiple_dijkstra(G, apath, result, n+1, i+1)\n      return result\n   except IndexError:\n      result.extend(nx.dijkstra_path(G, apath[n], apath[i-1]))\n      return result\n\ndef possible_paths(start_node, end_node, *between):\n   \"\"\"Generate all possible paths based on permutations of *between\"\"\"\n   for permutation in permutations(between, len(between)):\n      yield [start_node] + list(permutation) + [end_node]\n\ndef gothrough_possible_paths(start_node, end_node, *between):\n   \"\"\"Test all permutations for shortest path\"\"\"\n   for apath in possible_paths(start_node, end_node, *between):\n      result = []\n      shortest_path = multiple_dijkstra(G, apath, result)\n      print 'Testing path: {}\\nResult: {} (length: {})'.format(\n                             ' - '.join(apath),\n                             ' - '.join(shortest_path),\n                             len(shortest_path))\n```\n\n\nNow, we can search for the shortest path:\n\n```\n# let's pick 5 random nodes: a start node, end node and three in-between nodes\nn1, n2, n3, n4, n5 = sample(nodes, 5)\n\n# ...and search for the shortest paths between 'n1' and 'n2'\n# such that 'n3', 'n4' and 'n5' are in-between nodes\ngothrough_possible_paths(n1, n2, n3, n4, n5)\n```\n\n\nA possible results:\n\n```\nTesting path: e - h - g - j - t\nResult: e - k - h - k - g - k - b - j - b - t (length: 10)\nTesting path: e - h - j - g - t\nResult: e - k - h - k - b - j - o - c - g - k - b - t (length: 12)\nTesting path: e - g - h - j - t\nResult: e - k - g - k - h - k - b - j - b - t (length: 10)\nTesting path: e - g - j - h - t\nResult: e - k - g - k - b - j - b - k - h - l - t (length: 11)\nTesting path: e - j - h - g - t\nResult: e - j - b - k - h - k - g - k - b - t (length: 10)\nTesting path: e - j - g - h - t\nResult: e - j - o - c - g - k - h - l - t (length: 9)\n```\n\n\nSo, the shortest path from ```\ne```\n to ```\nt```\n is through ```\nj```\n, ```\ng```\n and ```\nh```\n (in this order), and the actual path is: ```\ne - j - o - c - g - k - h - l - t```\n.\n\nI am no expert on this, so I am curious of better solutions. Hope this helps, though.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in the Bidirectional Weighted Graph\r\n                \r\nEach node is connected to the other.\nConnection from Node1 to Node2 is not the same in the cost as connection from Node2 to Node1.\nGiven the graph connection Weight.\nIs there any effective algorithm to calculate the fastest(lowest cost) path of two nodes?\nWhat's the name of this type of Graph in Math?\n    ", "Answer": "\r\n\nIs there any effective algorithm to calculate the fastest(lowest cost)\npath of two nodes?\n\nDijkstra\n\nWhat's the name of this type of Graph in Math?\n\nDirected\n\nConnection from Node1 to Node2 is not the same in the cost as\nconnection from Node2 to Node1.\n\nTo handle this, you can construct a directed graph with two edges between every connected pair of vertices, costed according to the direction of travel.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "SQL Graph, shortest path Algorithm?\r\n                \r\nI found this link about algorithms in SQL, but none of them solved my problem: I must find shortest path between all nodes in given list. (and not only the shortest distance between the start and end node). \nAs an example, I give a graph. I have to start from \"A\" point and visit all the red nodes, but with such an order that the total distance is the shortest. I have defined distance between every two nodes in graph.\nLooking for an idea or a guideline?\n\n\n    ", "Answer": "\r\nThis is a answer (or an idea, or a guideline, as asked), not the answer.\n\nCalculate shortest paths between all of the ```\nred```\n nodes and keep the paths and their lengths for later.\nConstruct new graph with only the ```\nred```\n nodes where distance between two nodes is their shortest path from the step 1.\nIn the new graph you have to solve the ```\ntraveling salesman problem```\n\n\nBy those three steps the original, specific, problem has been converted to a well known, well studied, general problem (that is NP, so no optimal solution for you for an arbitrary subset of nodes using a classical hardware).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Path between two nodes in graph\r\n                \r\nFrom an adjacency matrix I have to get the vertex of a path between two nodes doesn't care the weight \n\n\n\nNot sure how to do it well.\n\n```\n    /// <param name=\"start\"></param>\n    /// <param name=\"end\"></param>\n    /// <returns>Returns the path in vertice</returns>\n    /// <Complexity>O(n)</Complexity>\n\n    public string[] GetPath(string start, string end)\n    {\n        int startPosition = 0; //start position \n        int endPosition = 0;  //end position\n\n        for (int i = 0; i < Vertices.Length; i++)\n        {                \n            if(Vertices[i] == start)\n            {\n                startPosition = i;\n            }\n            if (Vertices[i] == end)\n            {\n                endPosition = i;\n            }\n        }\n\n        string[] path = new string[0];\n\n        for (int j = 0; j < Vertices.Length; j++)\n        {\n            if (j >= startPosition && j <= endPosition) {\n            }\n        }\n        return path;\n    }\n```\n\n\nand shortest path \n\n```\npublic string[] GetShortestPath(string start, string end)\n{\n //In this one must return the vertex of shortest path between the nodes but checking the weight\n}\n```\n\n\nHope you can help me.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Vertex disjoint paths with specific length in graph\r\n                \r\nInput: directed graph G with no cycles, nodes s & t, natural number k.\nOutput: true, if there are at least two vertex disjoint paths from s to t with maximum path length k. Otherwise - return false.\nRun time should be polynomial.\nMy idea was to assign each edge capacity = 1 and find max flow. If max flow >= 2, return true. But max flow searches for shortest augmentation path, which is not always the optimal solution if you need 2 and more paths. I have a feeling that Breadth-first search or Depth-first search can help, but I don't know how to put the things together.\nDoes anyone have an algorithm for that problem?\n    ", "Answer": "\r\nThere is a Suurballe algorithm for finding two disjoint paths in a graph of minimal length. It works for O (|E|+|V|*log|V|).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Determine maximal path in a directed graph\r\n                \r\nI'm facing the problem of finding if all the maximal paths of a directed graph satisfy a certain condition: all the maximal paths (starting from a given \"u\" vertex) have to \"contain\" a vertex to whom is associated an even number. The definition my professor gave is \"a path is maximal when you can't expand it anymore, i.e. when it's infinite or ends in a sink\" which it may be a little confusing, at least for me, and I need a clarification for starting to think about the algorithm. For example, in the given graph, when u=0, how many maximal path are there? Which are them? 0-1-3 and 0-1-2 ? Could anyone, after that, also give me suggestions for the algorithm I need to write? Thanks.\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Graph - Non Simple Path , Longest Path\r\n                \r\nI am trying to solve finding longest path in a Graph. Even in wikipedia its mentioned that we are trying to find longest simple path . \n\nSimple Path is a path where no vertices/edges repeats. \n\nNon-Simple Path is a path where vertices/edges can repeat. I can think of either cycle or circuit as non-simple path . And since circuit is always have cycle. \n\nQuestions : \n\n\nCan i say for a directed/un-directed graph. A non simple path always have cycle? \nAnd because there is a cycle in non-simple path , longest non-simple path or a graph is not possible? (Just like we don't have an algorithm to find shortest distance for a graph with negative edge?)\n\n\nAm i missing anything here?\n    ", "Answer": "\r\nYour understanding is correct: a non-simple path will always contain a cycle. Take the first instance of the first repeated node on the non-simple path and follow the path until you revisit that node; that's your cycle!\n\nAnd yes, for that reason the longest nonsimple path in a graph is not always defined. In fact, it's never defined in any graph containing at least one edge.\n\nNote that finding the longest simple path in a graph is known to be NP-hard, and there are no known efficient algorithms for the problem. However, there are some nice dynamic programming solutions that reduce the runtime over true brute-force, and clever algorithms like color-coding can be used to find long paths somewhat efficiently.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Is there an algorithm to get all minimal paths between all nodes in a weight graph but with updates in edges?\r\n                \r\nI would like to know if exists an algorithm capable to get all minimal paths in a weight graph, I know it is possible to use Bellman-Ford for getting all minimal paths, but my problems is that I have queries in the edges, each time a particular edge's weight changes.\n\nI know a lot of algorithms capable to get certain values with queries, like Segment Tree or Sparse Table. \n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in directed graph with cycles of negative length\r\n                \r\nIs there an algorithm for finding the shortest path in a directed graph which includes cycles of negative length? The constraint is that each node can only be visited once, so the solution exists.\n\nI'm aware of the Bellman-Ford algorithm, but it fails when negative cycles are present. It's also clear that traversing negative cycles forever makes the problem ill-defined, so I'm constraining the path to visit each node at most once.\n\nIs there such an algorithm? And is there an off-the-shelf implementation I can use?\n\n---EDIT---\n\nAs requested below, here's the actual application:\n\nGiven an input image containing handwriting, I can estimate probabilities of stroke directions at each pixel:\n\n\nThen, I can put the pixels into a graph, and find the path of the pen:\n\n\nSee how the \"l\" is missed out? If I can set the adjacent weights to be negative, the optimal path will traverse all letters. But negative weights create negative cycles.\n    ", "Answer": "\r\nYou are right that the Bellman-Ford algorithm fails in this case. You can refer section 2 of this resource. It discusses the problem for an undirected graph and works based on Edmonds' Minimum Weight Perfect Matching Algorithm. In fact, you might be interested in this question, which is very similar to yours.\n\nWhen the graph is a directed one, then as @SaiBot pointed out, the problem reduces to an NP Hard problem, and there is no efficient solution possible.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Update path when point in graph is moving\r\n                \r\nI'm working in a graph with 3 points in it.  (0,0), (5,5), (10,10). The user is able to move the points across the y axis. Currently I'm able to move the points across the Y axis but not to  \"update\" the path between the points when one of it is moving.\n\nI'll apreciate any kind of help, thanks!\n\nHere is the code, I'm using d3js v4:\n\n```\n<script>\n    // Set the dimension of the canvas / graph\n    var margin = { top: 30, right: 20, bottom: 30, left: 50 };\n    var width = 600 - margin.left - margin.right;\n    var height = 500 - margin.top - margin.bottom;\n\n    // Add the svg canvas\n    var svg = d3.select(\"body\")\n        .append(\"svg\")\n        .attr(\"width\", width + margin.left + margin.right)\n        .attr(\"height\", height + margin.top + margin.bottom)\n        .append(\"g\")\n        .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    // Set the linear scale and the range for the axes\n    var xRange = d3.scaleLinear().range([0, width]).domain([0, 10]);\n    var yRange = d3.scaleLinear().range([height, 0]).domain([0, 10]);\n\n    var line = d3.line()\n        .x(d => xRange(d.x))\n        .y(d => yRange(d.y))\n        .curve(d3.curveLinear);\n\n    var drag = d3.drag()\n        .on(\"drag\", function (d) {\n            var dragPoint = d3.select(this);\n            dragPoint.attr(\"cy\", d.y = d3.event.y);\n        });\n\n    // Points dataset\n    var radius = 6;\n    var points = [{ x: 0, y: 0 }, { x: 5, y: 5 }, { x: 10, y: 10 }];\n\n    // Add the X axis\n    svg.append(\"g\")\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\n        .call(d3.axisBottom(xRange));\n\n    // Add the Y axis\n    svg.append(\"g\")\n        .call(d3.axisLeft(yRange));\n\n    // Add points to the svg\n    var circles = svg.attr(\"class\", \"circle\")\n        .selectAll(\"circle\")\n        .data(points)\n        .enter()\n        .append(\"circle\")\n        .attr(\"cx\", d => xRange(d.x))\n        .attr(\"cy\", d => yRange(d.y))\n        .attr(\"r\", radius)\n        .attr(\"fill\", \"teal\")\n        .style(\"cursor\", \"pointer\");\n\n    // Add the path\n    var path = svg.append(\"path\")\n        .attr(\"d\", line(points));\n\n    drag(circles);\n</script>\n```\n\n    ", "Answer": "\r\nYour ```\ndrag```\n needs little adjustment.\n\nUsing https://stackoverflow.com/a/38650810/9938317 I changed the starting object so we start dragging at the circle position.\n\nThen we need to invert the y-value for this point and fill it in the datum object. To limit the drag beyond the axis domain we first clamp it to the domain.\n\nThen we update the ```\npath```\n based on the updated ```\npoints```\n array.\n\n```\nvar drag = d3.drag()\n    .subject(function() { \n        var t = d3.select(this);\n        return {x: t.attr(\"cx\"), y: t.attr(\"cy\")};\n    })\n    .on(\"drag\", function (d) {\n        var domain = yRange.domain();\n        d.y = Math.max(domain[0], Math.min(yRange.invert(d3.event.y), domain[1]))\n        d3.select(this).attr(\"cy\", yRange(d.y));\n        path.attr(\"d\", line(points));\n    });\n```\n\n\nA complete example\n\n\r\n\r\n```\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>Document</title>\r\n<script src=\"https://d3js.org/d3.v5.min.js\"></script>\r\n<style>\r\n.line {stroke:steelblue; fill:none;}\r\n</style>\r\n</head>\r\n<body>\r\n<script>\r\n    // Set the dimension of the canvas / graph\r\n    var margin = { top: 30, right: 20, bottom: 30, left: 50 };\r\n    var width = 600 - margin.left - margin.right;\r\n    var height = 500 - margin.top - margin.bottom;\r\n\r\n    // Add the svg canvas\r\n    var svg = d3.select(\"body\")\r\n        .append(\"svg\")\r\n        .attr(\"width\", width + margin.left + margin.right)\r\n        .attr(\"height\", height + margin.top + margin.bottom)\r\n        .append(\"g\")\r\n        .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\r\n\r\n    // Set the linear scale and the range for the axes\r\n    var xRange = d3.scaleLinear().range([0, width]).domain([0, 10]);\r\n    var yRange = d3.scaleLinear().range([height, 0]).domain([0, 10]);\r\n\r\n    var line = d3.line()\r\n        .x(d => xRange(d.x))\r\n        .y(d => yRange(d.y))\r\n        .curve(d3.curveLinear);\r\n\r\n    var drag = d3.drag()\r\n        .subject(function() { \r\n            var t = d3.select(this);\r\n            return {x: t.attr(\"cx\"), y: t.attr(\"cy\")};\r\n        })\r\n        .on(\"drag\", function (d) {\r\n            var domain = yRange.domain();\r\n            d.y = Math.max(domain[0], Math.min(yRange.invert(d3.event.y), domain[1]))\r\n            d3.select(this).attr(\"cy\", yRange(d.y));\r\n            path.attr(\"d\", line(points));\r\n        });\r\n\r\n    // Points dataset\r\n    var radius = 6;\r\n    var points = [{ x: 0, y: 0 }, { x: 5, y: 7 }, { x: 10, y: 10 }];\r\n\r\n    // Add the X axis\r\n    svg.append(\"g\")\r\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\r\n        .call(d3.axisBottom(xRange));\r\n\r\n    // Add the Y axis\r\n    svg.append(\"g\")\r\n        .call(d3.axisLeft(yRange));\r\n\r\n    // Add points to the svg\r\n    var circles = svg.attr(\"class\", \"circle\")\r\n        .selectAll(\"circle\")\r\n        .data(points)\r\n        .enter()\r\n        .append(\"circle\")\r\n        .attr(\"cx\", d => xRange(d.x))\r\n        .attr(\"cy\", d => yRange(d.y))\r\n        .attr(\"r\", radius)\r\n        .attr(\"fill\", \"teal\")\r\n        .style(\"cursor\", \"pointer\");\r\n\r\n    // Add the path\r\n    var path = svg.append(\"path\")\r\n        .attr(\"class\", \"line\")\r\n        .attr(\"d\", line(points));\r\n\r\n    drag(circles);\r\n</script>\r\n</body>\r\n</html>```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Create a list of all possible paths in a graph given a starting and ending point\r\n                \r\nGiven the following Graph class which takes a graph object and outputs it's adjacency list:\n\n```\nclass Graph:\ndef __init__(self, graph_str):\n    self.graph_str = []\n    graph_str = graph_str.splitlines()\n    for i in graph_str:\n        i = (i.split())\n        self.graph_str.append(i)\n    directed_helper = self.graph_str[0]\n    directed_score = directed_helper[0]\n    weighted_helper = self.graph_str[0]\n    weighted_score = weighted_helper[1]\n    self.weighted = weighted_score\n    self.directed = directed_score\n    self.graph_str.pop(0)\n    if self.directed == (\"D\"):\n        self.directed = True\n    elif self.directed == (\"U\"):\n        self.directed = False\n    if self.weighted == (\"W\"):\n        self.weighted = True\n    elif self.weighted != (\"W\"):\n        self.weighted = False\n    if self.weighted == False:\n        self.edge_number = graph_str[0]\n        self.edge_number = list(self.edge_number)\n        self.edge_number = self.edge_number[2]\n        self.edge_number = int(self.edge_number)\n        self.adjacency_list = [[] for _ in range(self.edge_number)]  \n    elif self.weighted == True:\n        self.edge_number = graph_str[0]\n        self.edge_number = list(self.edge_number)\n        self.edge_number = self.edge_number[4]\n        self.edge_number = int(self.edge_number)\n        self.adjacency_list = [[] for _ in range(self.edge_number)]             \n    if self.weighted == False:\n        if self.directed == True:\n            for s in self.graph_str:\n                self.first_element = s[0]\n                self.first_element = int(self.first_element)\n                self.second_element = s[1]\n                self.second_element = int(self.second_element)\n                self.adjacency_list[self.first_element].append((self.second_element, None))\n        elif self.directed == False:\n            for t in self.graph_str:\n                self.first_element = t[0]\n                self.first_element = int(self.first_element)\n                self.second_element = t[1]\n                self.second_element = int(self.second_element)\n                self.adjacency_list[self.first_element].append((self.second_element, None))\n                self.adjacency_list[self.second_element].append((self.first_element, None))\n    elif self.weighted == True:\n        if self.directed == True:\n            for t in self.graph_str:\n                self.first_element = t[0]\n                self.first_element = int(self.first_element)\n                self.second_element = t[1]\n                self.second_element = int(self.second_element)\n                self.third_element = t[2]\n                self.third_element = int(self.third_element)\n                self.adjacency_list[self.first_element].append((self.second_element, self.third_element))\n        if self.directed == False:\n            for t in self.graph_str:\n                self.first_element = t[0]\n                self.first_element = int(self.first_element)\n                self.second_element = t[1]\n                self.second_element = int(self.second_element)\n                self.third_element = t[2]\n                self.third_element = int(self.third_element)\n                self.adjacency_list[self.first_element].append((self.second_element, self.third_element))\n                self.adjacency_list[self.second_element].append((self.first_element, self.third_element))\n    (self.adjacency_list)\n```\n\n\nAnd the following function which performs a breadth first search on the same graph object:\n\n```\ndef bfs_tree(graph, start):\ngraph = Graph(graph_str)\nparent_array = []\nfound_parent = []\nempty_list = []\nfor _ in graph.adjacency_list:\n    parent_array.append(None)\n    found_parent.append(False)\nempty_list. append(start)\nfound_parent[start] = True\nwhile len(empty_list) != 0:\n    element = empty_list.pop()\n    for i in graph.adjacency_list[element]:\n        if found_parent[i[0]] == False:\n            found_parent[i[0]] = True\n            parent_array[i[0]] = element\n            empty_list.insert(0, i[0])\nreturn parent_array\n```\n\n\nI wish to Use backtracking to write a function allpaths(graph, source, destination) that takes a graph object, a source vertex (integer), and a destination vertex (integer), and returns a list of all possible paths from the source vertex to the destination vertex that do not contain any cycle. A path is list of vertices where the first element is the source vertex, the last element is the destination vertex, and the elements in between (if any) are vertices along the path.\n\nFor example:\n\n```\n# triangle graph\ngraph_str = \"\"\"\\\nU 3\n0 1\n1 2\n2 0\n\"\"\"\n\nprint(sorted(allpaths(Graph(graph_str), 0, 2)))\n```\n\n\nwhich should output:\n\n```\n[[0, 1, 2], [0, 2]]\n```\n\n\nand this:\n\n```\ngraph_str = \"\"\"\\\nU 5\n0 2\n1 2\n3 2\n4 2\n1 4\n\"\"\"\n\nprint(sorted(allpaths(Graph(graph_str), 0, 1)))\n```\n\n\nwhich should output:\n\n```\n[[0, 2, 1], [0, 2, 4, 1]]\n```\n\n\nSo far I have:\n\n```\ndef allpaths (graph, source, destination):\n    graph = Graph(graph_str)\n    parents = bfs_tree(graph, 0)\n    counter = 0\n    array_a = []\n    array_a_2 = []\n    for i in parents:\n        if len(parents) >= counter:\n            if parents[counter] == source:\n                if len(parents) > counter+1:\n                    a = counter\n                else:\n                    a = (counter)\n            else:\n                counter+=1\n    for a in parents[counter:]:\n        array_a.append(a)\n    for c in parents:\n        if destination not in parents and parents[0] != None:\n            if c not in array_a:\n                array_a.append(c)\n    array_a.append(destination)\n    if None in array_a:\n        array_a.remove(None)\n    for b in array_a:\n        if b not in array_a_2:\n            array_a_2.append(b)\n    return (array_a_2)\n```\n\n\nWhich only outputs one path, not all, and I am unsure how to continue with this.\n\nAny help with this problem would be much appreciated :)\n    ", "Answer": "\r\nDo you want to write this algorithm yourself? I am only asking because it looks like what you are looking for is the all_simple_paths function in the wonderful graph library networkx.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path(s) in linked graphs\r\n                \r\nI'm working on applying graphing algorithms to a possibly non-standard application.  I have graphs that are linked together and am trying to find the top K shortest node-disjoint paths through them.  Hopefully I can explain this:  As an example, say I have two fairly simple graphs with a start and end. In my case, the graphs go through stages (left to right) and both have the same number of stages.  I can use Dijkstra or something to find the shortest path in each, but they are linked together such that some nodes in the first graph are linked to a matching node in the second graph.  Selecting one requires selecting the other.  My first idea was to merge the two graphs into one with all possible combinations getting a node.  So if at a certain stage in graph one the nodes are A,B,C and graph two had D,E,F, and if C and F are linked, the options are AD,AE,BD,BE,CF.  This works fine for finding the single best path.  The problem comes when I apply Suurballe's algorithm to find the K best node disjoint paths because two node disjoint paths could, for example, select AD and AE.  These are node disjoint in the combined graph, but not in the original problem (they share A).  Is there any prior art in this type of problem, or can anyone think of a straightforward solution?\n\nPicture example:  Find K minimum cost paths (sum of both paths) through these two graphs under the constraint that if you pick the colored node in one graph you have to pick the same color node in the other.  Edges are weighted even though not shown.\n\n\n\nAnother example (example 2) in response to the answer below:\n\n    ", "Answer": "\r\nI'm not sure about 'prior art' in this domain, but I guess I can think of a 'straightforward solution'.\n\n\nFind the best path in the Graph 1 (the first graph)\nseparately, as shown in the 'Picture Example'. Compute the cost\nfunction for this path, say CF1.\nFind the number of coloured nodes in Graph 1's optimal path.\nFor all coloured nodes in Graph 1, remove all alternate connection\nfrom Graph 2, i.e, ensure that a path in Graph 2 has to go through\nthe coloured nodes used in Graph 1.\nFind the optimal path in Graph 2 and compute its cost function, say\nCF2.\nCompute CF1 + CF2\nRepeat steps 1 to 5, but this time start with Graph 2 and then match\nGraph 1's coloured nodes with Graph 2's initial optimal path.\n\n\nThe lowest value of CF1+CF2 would give you a set of feasible path.\n\nBasically, you plan the path for one of the graph and get the other graph to comply with its set of linked nodes and the check the combined cost function. Then repeat for the other graph. Find the best combination that works.\n\nIn general, for n graphs, you would have to perform n^2 shortest path computations, which is obviously very bad. But it should work, as a naive idea.\n\n++++++++++++++++++++\n\nHere's my modified version of the previous algorithm for weighted graph:\n\nAssumption : We are working with 'n' graphs, all of them are weighted and all of them contains equal and fixed number of 'stages'.\n\nAll the starting nodes are described as S1, S2, S3…. Sn.\nAll the terminal nodes are described as e1, e2, e3….. en.\n\n\nInitiate an empty priority queue (PQ) [preferably using binary/fibonacci min heap] that will contain paths (collection of nodes) and their corresponding priority will be denoted by the cumulative sum of their path weights]\nInsert all starting nodes - S1, S2, S3…. Sn into PQ, the priority of each individual nodes set to zero.\nPop the path with the lowest weight (say it belongs to graph number 'k') and expand it's children. Let there be 'p' children nodes. [If there are no more stages to expand into, delete that path from the priority queue. This way, if the total size of the queue becomes zero, then there are no feasible path between S and e]\nFor i = 1 to n for all i not equal to k, repeat:\n\n4a. Check which of the p paths are feasible in the remaining (n-1) graphs.\n\n4b. Insert all the feasible paths to PQ (after computing their priorities). \n\n4c. If one of the feasible paths end up in ek : then mark that path as 'PathOptimal' and go to 5.\n        else : go to 3.\nFor i = 1 to n for all i not equal to k : find the corresponding paths in each graph against 'PathOptimal' and report them as the output.\n\n\nHere, the concept of path weights has to be implemented correctly. \nPath weight will be equal to: sum of weights of the edges contained in that path + sum of weights of edges contained in all sibling paths in the remaining (n-1) graph.\n\nThe concept of feasibility will be your business rule, i.e if a children is a coloured node, the corresponding children of the previous path in all other (n-1) graphs has to be of the same colour. If it not a coloured node, it's sibling children will have to be non-coloured.\n\n[Please let me know if you figure out any obvious flaw in the algorithm since I just made it up. Also, since this has been heavily borrowed from Dijkstra's, let me know if you could figure a method for speeding this up.]\n\nP.S:- However, I must mention that given the scope of your problem, I'd rather use genetic algorithm for solving this than going by a deterministic method.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to get the shortest path in graph between two vertexes?\r\n                \r\nI have a class WeightedAdjacencyMatrix. It contains matrix:\n```\nclass WeightedAdjacencyMatrix:\n    \"\"\"A weighted graph represented as a matrix.\"\"\"\n\n    __slots__ = ['_W']\n\n    def __init__(self, size, edges=[], weights=[]):\n        \"\"\"Initializes a weighted adjacency matrix for a graph with size nodes.\n\n        Graph is initialized with size nodes and a specified set of\n        edges and edge weights.\n\n        Keyword arguments:\n        size -- Number of nodes of the graph.\n        edges -- a list of ordered pairs (2-tuples) indicating the\n                 edges of the graph.  The default value is an empty list\n                 which means no edges by default.\n        weights -- a list of weights for the edges, which should be the same\n                   length as the edges list.  The position of a value in\n                   the weights list corresponds to the edge in the same\n                   position of the edges list.\n        \"\"\"\n        self._W = [[math.inf] * size for _ in range(size)]\n\n        for i in range(size):\n            self._W[i][i] = 0\n\n        for edge, weight in zip(edges, weights):\n            self.add_edge(edge[0], edge[1], weight)\n\n    def add_edge(self, u, v, weight):\n        \"\"\"Adds an undirected edge between u to v with the specified weight.\n\n        Keyword arguments:\n        u -- vertex id (0-based index)\n        v -- vertex id (0-based index)\n        weight -- edge weight\n        \"\"\"\n\n        self._W[u][v] = weight\n        self._W[v][u] = weight\n\n    def floyd_warshall(self):\n        \"\"\"Floyd Warshall algorithm for all pairs shortest paths.\n\n        Returns a matrix D consisting of the weights of the shortest\n        paths between all pairs of vertices, and a matrix P for\n        the predecessors matrix (what the textbook called PI).\n        This method MUST NOT change the weight matrix of the graph\n        itself.\n        \"\"\"\n        # Your return statement will look something like this one\n        # in the comment on the following line.  That returns\n        # the two matrices, with the D matrix first.  The return None\n        # is just a placeholder so that this is valid Python syntax before\n        # you've completed the assignment.  This comment line is\n        # more like what it should look like:\n        # return D, P\n\n        n = len(self._W)\n\n        # Create a deep copy of the weight matrix.\n        D = copy.deepcopy(self._W)\n\n        # Initialize the predecessor matrix to None.\n        P = [[None]*n for _ in range(n)]\n\n        # Compute shortest paths between all pairs of vertices.\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    if D[i][k] + D[k][j] < D[i][j]:\n                        D[i][j] = D[i][k] + D[k][j]\n                        P[i][j] = k\n\n        return D, P\n```\n\nAlso I have to implement pair_shortest_path() function:\n```\ndef pair_shortest_path(D, P, s, t):\n    \"\"\"EXTRA CREDIT: This function takes D and P matrices (i.e., what is generated\n    by floyd_warshall), and a source vertex (where you want to start) and\n    destination or target vertex t (where you want to end up) and\n    returns a pair: w, path, such that w is the weight of the shortest\n    path from s to t (just a simple lookup in the D matrix) and\n    path is a Python list of vertex ids starting at s and ending at t\n    derived from the P matrix. If no path exists from s to t, then returns\n    math.inf for w (which is what D[s][t] should be in that case), and an\n    empty list for the path.\n\n    Keyword arguments:\n    D - the D matrix\n    P - the Pi matrix\n    s - the source vertex\n    t - the destination vertex\n    \"\"\"\n\n    if D[s][t] == math.inf:\n        # No path exists from s to t.\n        return math.inf, []\n\n    # Build the path from s to t using the predecessors matrix P.\n    path = [s]\n    while s != t:\n        s = P[s][t]\n        path.append(s)\n    # Compute the weight of the path.\n    w = D[path[0]][path[-1]]\n    return w, path\n\n```\n\nBut when I try to test this function errors happen\n```\nG = WeightedAdjacencyMatrix(4)\nG.add_edge(0, 1, 2)\nG.add_edge(1, 2, 3)\nG.add_edge(2, 3, 1)\n\nD, P = G.floyd_warshall()\nw, path = pair_shortest_path(D, P, 0, 3)\n\nprint(\"Shortest path weight:\", w)  # Output: Shortest path weight: 6\nprint(\"Shortest path:\", path)  # Output: Shortest path: [0, 1, 2, 3]\n```\n\n```\ns = P[s][t]\n```\n\nTypeError: list indices must be integers or slices, not NoneType\nI think that problem is in predecessors matrix called P in my code or I implement wrongly my shortest_path function.\n    ", "Answer": "\r\nThere are a few issues in your code:\n\n```\nP[i][j]```\n should be initialised to ```\ni```\n when there is an edge between ```\ni```\n and ```\nj```\n or when ```\ni```\n and ```\nj```\n are equal (See Wikipedia). So extend that initialisation code as follows:\n```\n    P = [[None] * n for _ in range(n)]\n    # Complete initialisation\n    for i in range(n):\n        for j in range(n):\n            if D[i][j] < math.inf:\n                P[i][j] = i\n```\n\n\nIn the loop the improvement ```\nP[i][j] = k```\n is not correct. Note that when execution gets here, we know that the path via ```\nk```\n is shorter than what we had so far, but that doesn't mean ```\nk```\n is the one-but-last node to visit on the shortest path from ```\ni```\n to ```\nj```\n. It only means that ```\nk```\n is somewhere along that path. The correct assignment is ```\nP[i][j] = P[k][j]```\n (See again the Wikipedia link above), where we say that the last-but-one node on the path is the last-but-one one on the path from ```\nk```\n to ```\nj```\n (since we will pass via ```\nk```\n). Make that correction here:\n```\n                if D[i][k] + D[k][j] < D[i][j]:\n                    D[i][j] = D[i][k] + D[k][j]\n                    P[i][j] = P[k][j]  # corrected\n```\n\n\nIn ```\npair_shortest_path```\n you should not take ```\nP[s][t]```\n, because that is a predecessor, i.e. the one-but-last node on the path from ```\ns```\n to ```\nt```\n. Instead we need the successor of ```\ns```\n on that path. To get that info, we should look at the inverse -- at ```\nP[t][s]```\n. The corrected code:\n```\npath = [s]\nwhile s != t:\n    s = P[t][s]  # corrected: look at reverse path\n    path.append(s)\n```\n\n\n\nWith those corrections it should work.\nOne final remark: the Floyd-Warschall algorithm is more useful with directed graphs that can have negative weights. As your graph construction code always adds the same edge in both directions, making it an undirected graph, the graph cannot have negative weights -- this would create cycles that would make a path infinitely lighter. And thus this algorithm cannot show its strength in comparison with other algorithms, like Dijkstra's which will perform better for such graphs.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Scala: how to find and return a loopy path in a directed graph [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI wrote a function in Scala to find out and return a loopy path in a directed graph. The program is as followed, one of the arguments is a graph presented in an adjacent list, and the other is a start node. It returns a pair including a loopy path by a list of nodes.\n\nI wonder there are more elegant ways to do so. Please share your thoughts if you would like to. Thanks.\n\n```\n  def GetACycle(start: String, maps: Map[String, List[String]]): (Boolean, List[String]) = {\n    def explore(node: String, visits: List[String]): (Boolean, List[String]) = {\n      if (visits.contains(node)) (true, (visits.+:(node)).reverse)\n      else {\n        if (maps(node).isEmpty) (false, List())\n        else {\n          val id = maps(node).indexWhere(x => explore(x, visits.+:(node))._1)\n          if (id.!=(-1))\n            explore(maps(node)(id), visits.+:(node))\n          else\n            (false, List())\n        }\n      }\n    }\n    explore(start, List())\n  }\n```\n\n\nI felt I had to use the indexWhere in this situation, but I suppose it would have other ways to do that.\n    ", "Answer": "\r\nYou should use an array to check if you have already visited a node and not ```\nvisits.contains(node)```\n, it would give you the answer in constant time instead of linear time.\n\nThe overall complexity of your algorithm is exponential. For instance, if you run your algorithm on this graph:\n\n```\n0 -> 1, 2, ..., n\n1 -> 2, ..., n\n...\n```\n\n\nwhere there are ```\nn```\n nodes and there are edges from ```\ni```\n to ```\nj```\n iff ```\ni<j```\n then the node ```\ni```\n will be explored ```\n2^i```\n times.\n\nAgain you can solve this problem using an array (one array for all nodes) to ensure that each node is explored at most one time.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Max-weight set of disjoint paths of length k in a graph G\r\n                \r\nSuppose you have a graph G with vertices V and edges E. The edges are weighted. You are given a number k. Find the set of paths in G where each path has exactly k edges and the sum of the weights of all edges in the set is maximized. Also, these paths must be disjoint (they can't share any vertex) In other words, I am trying to find the max weight set of disjoint paths of length k in G. Also, I can assume G is a rooted tree. I thought reversing Dijkstra's would be a good start but I don't think that actually gets me anywhere. Any advice/help?\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all possible paths in a graph with multiple edges between two neighbor nodes\r\n                \r\nI have this graph:\nGraph with 3 nodes and 5 edges\nI have this adjacency matrix resulting from it:\n```\n[0, 2, 1]\n[2, 0, 2]\n[1, 2, 0]\n```\n\nAfter converting the adjacency matrix to a graph:\n```\n{0: [1, 2], 1: [0, 2], 2: [0, 1]}\n```\n\nI tried this code:\n```\n    def find_all_paths(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return [path]\n    if start not in graph:\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_paths(graph, node, end, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths\n```\n\nAnd I get this paths:\n```\n[1, 3]\n[1, 2, 3]\n```\n\nWhat I'm trying to achieve and can't wrap my head around, is to achieve something like this:\n```\n['e', 'ac', 'ad', 'bc', 'bd']\n```\n\nOr:\n```\n[['e'], ['a','c'], ['a','d'], ['b','c'], ['b','d']]\n```\n\nThe problem seems to be that this function just doesn't work properly on graphs that have multiple edges between two neighbor nodes.\nI should be getting 5 paths, not 2.\nI generated an adjacency matrix from the graph that looks like this:\n```\n['', 'ab', 'e']\n['ab', '', 'cd']\n['e', 'cd', '']\n```\n\nAnd converted it to a graph:\n```\n{0: [{1: 'ab'}, {2: 'e'}], 1: [{0: 'ab'}, {2: 'cd'}], 2: [{0: 'e'}, {1: 'cd'}]}\n```\n\nBut I just don't understand how should I modify the find_all_pahts function to be able to generate the paths as I described above.\nDoes anyone know how?\n    ", "Answer": "\r\nYou can run the find_all_paths multiple times to get the extra paths provided by the multiple edges\npseudo-code:\n```\nLOOP\n    find_all_paths\n    IF no paths found\n       STOP\n    LOOP over paths found previously\n        LOOP over paths found in this find_all_paths call\n           IF paths are identical\n               remove new path\n    ADD remaining paths to total paths found\n    LOOP over edges in remaining paths found this loop\n       IF edge has a parallel edge\n          remove edge\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How do I find the '5' most weighty paths in a directed acyclic graph?\r\n                \r\nI have a directed acyclic graph (DAG) with a weight associated with each node. I want to find the top 'n' (e.g. 5) most weighty paths, where a path's weight is defined as the sum of all the weights of it's nodes. How can I accomplish this?\n\nAccuracy is desirable, but can be sacrificed for performance. Potentially, the graph can have 10,000+ nodes and/or edges.\n\nEdit: Weights will be numbers greater than or equal to zero.\n    ", "Answer": "\r\n\nTopologically sort the graph.\nAssociate each graph's node with n-element priority queue (min-heap).\nFor each node (in sorted order), pop path weights from the priority queue, add node's weight, and pass them to every descendant. When a node receives weight from its parent, it should insert it into associated priority queue.\nFor each leaf node, pop path weights from the priority queue, add node's weight, and insert them into one common priority queue. After last node is processed, this priority queue contains weights for 'n' most weighty paths. If along with weight, you store back pointers, you can restore these paths.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in unweighted undirected graph - each node visited only once [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nhow can I get longest path in unweighted undirected graph if each node can be visited only once? Thanks for help! // I am new to graphs.I've found out that each edge can be visited only once,not node.Node can be visited more times.Does it mean that my graph is directed? Thanks\n    ", "Answer": "\r\nThis is obviously an NP-complete problem, as Hamiltonian path problem can be reduced to this one. So you will most probably have no polynomial solution here. For non-polynomial you can just use brute force, or try to adapt numerous Hamiltonian path approaches.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in weighted directed graph\r\n                \r\ni need to find the shortest path between two node s,t in a weighted directed graph. \nHere are the limitations:\n\n\nThe weights can be negative.\nThe path has to go through a specific edge lets call her e and shes from node u to v.\nThe output path must be simple, i.e we only pass through a node once.\n\n\nNow i have an idea for a solution but i don't know if the output will be a simple path or not.\n\nMy solution is to run bellman ford algorithm twice, once from s, second from v. the shortest path will be s to u, u to v, v to t.\n\nBecause i want it to be simple i will not use nodes i already used in the second bellman ford run.\n\nBecause i want it to be shortest i will check if running bellman ford from v to t before running from s to u is quicker than the other way around ( if there is a node both use where is the best place to put it).\n\nThanks for the helpers! \n    ", "Answer": "\r\nEven finding such a path is NP-complete. This is because two vertex/edge disjoint paths problem is NPC in directed graphs. Suppose edge e=(u,v) then you are looking for an (s,u), (v,t) disjoint paths but this is NP-complete in digraphs. \n\nHere you can find the hardness result:\nhttps://www.sciencedirect.com/science/article/pii/0304397580900092\n\nYour current algorithm based on Bellman-ford does not give the right answer for all cases (it may fail to find a path while there is a path), however, it might be a good heuristics. If your graph was undirected then the task was much easier. \n\nIf you allow repeating vertices then any shortest path algorithm is a right way to do it.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in weighted directed graph\r\n                \r\ni need to find the shortest path between two node s,t in a weighted directed graph. \nHere are the limitations:\n\n\nThe weights can be negative.\nThe path has to go through a specific edge lets call her e and shes from node u to v.\nThe output path must be simple, i.e we only pass through a node once.\n\n\nNow i have an idea for a solution but i don't know if the output will be a simple path or not.\n\nMy solution is to run bellman ford algorithm twice, once from s, second from v. the shortest path will be s to u, u to v, v to t.\n\nBecause i want it to be simple i will not use nodes i already used in the second bellman ford run.\n\nBecause i want it to be shortest i will check if running bellman ford from v to t before running from s to u is quicker than the other way around ( if there is a node both use where is the best place to put it).\n\nThanks for the helpers! \n    ", "Answer": "\r\nEven finding such a path is NP-complete. This is because two vertex/edge disjoint paths problem is NPC in directed graphs. Suppose edge e=(u,v) then you are looking for an (s,u), (v,t) disjoint paths but this is NP-complete in digraphs. \n\nHere you can find the hardness result:\nhttps://www.sciencedirect.com/science/article/pii/0304397580900092\n\nYour current algorithm based on Bellman-ford does not give the right answer for all cases (it may fail to find a path while there is a path), however, it might be a good heuristics. If your graph was undirected then the task was much easier. \n\nIf you allow repeating vertices then any shortest path algorithm is a right way to do it.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find least colorful path in a graph\r\n                \r\nThe problem i'm trying to solve is this:\n\nGiven a graph G = (V,E) such that every edge is colored in one of 10 colors, and two vertices: s, t.\n\nI need to find an algorithm that produces a (shortest) path from s to t, that goes over a minimal amount of colors.\n\nMy idea was to duplicate the graph 10 times:\n\nThe first duplicate will include only edges of one color\n\nThe second will include only edges of two colors... and so on.\n\nAlso, I connect an outer node: s' to every \"s\" node in every duplicate.\n\nBut, it has occurred to me that for this approach I need to duplicate the graph not 10 times but around 10! (or maybe even 2^10?) times for every combination of  colors.\n\nSo what would be an efficient algorithm to solve this?\n    ", "Answer": "\r\nI don't believe there's an easy algorithm to solve this, since the general form of the problem is NP hard. That is, in an arbitrarily colored graph, finding a shortest path between two vertices which touches a minimal set of colors is NP hard.\n\nThus, while it's possible there's slightly better algorithms, your idea of solving 1024 variants of the graph (one for each subset of of your 10 colors) is likely to be reasonable.\n\nProof\n\nThe proof works by reducing the hitting set problem to it. The hitting set problem is NP complete, so the reduction to your problem shows your problem is NP hard.\n\nRecall that the hitting set problem takes sets X1...Xn, each with elements from some universe U and one is asked to find a minimal set {x1, ..., xk} such that for all i, there's a j such that xj in Xi.\n\nThe colors in the graph will be elements of U. Let the graph itself consist of n+1 vertices. These will be X0 (a start node, named only for notational convenience below) and vertices representing X1 ... Xn.\n\nFor each x in Xi+1, connect Xi to Xi+1 with an edge of color x.\n\nThen in this graph, all paths from X0 to Xn have length n, but one that uses a minimal number of colors corresponds exactly a minimum hitting set.\n\nNote that this expands the definition of graph to include multiple edges between nodes. If that's not ok then one add an extra node in the middle of each edge of the constructed graph.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding a cycle path in directed graph\r\n                \r\nI am making a directed Graph class. I want find if there is any Cycle and update a vector with it's path accordingly. My Function some times work but others add two times the last edge of the path.So i guess it needs to be tydied up.\nExample: having a Graph with these paths\n0->1, 0->2, 1->2, 2->3, 3->4, 4->0, 4->6, 1->5, 5->6\nshould set the vector to [0 2 3 4] or anything else valid.\nWhat I have tried:\n```\n#include <iostream>  \n#include <vector>  \n#include <list>  \n#include <algorithm>  \nusing namespace std;  \n  \nclass Graph {  \nprivate:  \n    int V;  \n    list<int> *adj;  \n    bool isCyclicHelp(int v, bool visited[], bool *rs, vector<int> &path) const{  \n        if(visited[v] == false) {  \n            visited[v] = true;  \n            rs[v] = true;  \n  \n            list<int>::iterator i;  \n            for(i=adj[v].begin(); i!=adj[v].end(); i++) {  \n                if(!visited[*i] && isCyclicHelp(*i, visited, rs, path)) {  \n                    path.push_back(*i);  \n                    return true;  \n                }  \n                else if(rs[*i]) {  \n                    return true;  \n                }  \n            }  \n        }  \n        rs[v] = false;  \n        path.pop_back();  \n        return false;  \n    }  \npublic:  \n    Graph(int V) {  \n        this->V = V;  \n        adj = new list<int>[V];  \n    }  \n    ~Graph() {  \n  \n    }  \n    void addEdge(int v, int w) {  \n        if(v != w) {  \n            adj[v].push_back(w);  \n        }  \n    }  \n    bool cycle(vector<int> &path) const {  \n        bool *visited = new bool[V];  \n        bool *recStack = new bool[V];  \n        for(int i=0; i<V; i++) {  \n            visited[i] = false;  \n            recStack[i] = false;  \n        }  \n  \n        for(int i=0; i<V; i++) {  \n            path.push_back(i);  \n            if(Graph::isCyclicHelp(i, visited, recStack, path)) {  \n                reverse(path.begin(), path.end());  \n                return true;  \n            }  \n            path.clear();  \n        }  \n        path.clear();  \n        return false;  \n    }  \n};\n```\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "JAVA Find the shortest reverse path in a graph using Dijkstra\r\n                \r\nI come here with a small problem. I have to find the shortest path in a graph, but also the shortest reverse path. I am having trouble computing the reverse path. For example I have to find a route from B to D, but I can't seem to figure out how to find the shortest path from D to B. The paths are unidirectional.\n\nThis is my code down here:\nTo run this, just use something like \"2, B20, D\" where the first char is the number of passengers, the second item is the airport and miles from home to airport and finally, D is the destination. \n\n```\nimport java.util.*;\nimport java.util.jar.JarOutputStream;\n\nclass Vertex implements Comparable<Vertex>\n{\n    public final String name;\n    public Edge[] adjacencies;\n    public double minDistance = Double.POSITIVE_INFINITY;\n    public Vertex previous;\n    public Vertex(String argName) { name = argName; }\n    public String toString() { return name; }\n    public int compareTo(Vertex other)\n    {\n        return Double.compare(minDistance, other.minDistance);\n    }\n\n}\n\n\nclass Edge\n{\n    public final Vertex target;\n    public final double weight;\n    public Edge(Vertex argTarget, double argWeight)\n    { target = argTarget; weight = argWeight; }\n}\n\npublic class Flights\n{\n    public static void computePaths(Vertex source)\n    {\n        source.minDistance = 0.;\n        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n            Vertex u = vertexQueue.poll();\n\n            // Visit each edge exiting u\n            for (Edge e : u.adjacencies)\n            {\n                Vertex v = e.target;\n                double weight = e.weight;\n                double distanceThroughU = u.minDistance + weight;\n                if (distanceThroughU < v.minDistance) {\n                    vertexQueue.remove(v);\n\n                    v.minDistance = distanceThroughU ;\n                    v.previous = u;\n                    vertexQueue.add(v);\n                }\n            }\n        }\n    }\n\n\n    public static List<Vertex> getShortestPathTo(Vertex target)\n    {\n        List<Vertex> path = new ArrayList<Vertex>();\n        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)\n            path.add(vertex);\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    public static void main(String[] args)\n    {\n        Vertex v0 = new Vertex(\"0\");\n        Vertex v1 = new Vertex(\"1\");\n        Vertex v2 = new Vertex(\"2\");\n        Vertex v3 = new Vertex(\"3\");\n        Vertex v4 = new Vertex(\"4\");\n        Vertex v5 = new Vertex(\"5\");\n        Vertex v6 = new Vertex(\"6\");\n        v0.adjacencies = new Edge[]{ new Edge(v1,  800),//AB800\n                                     new Edge(v5,  200)};//AF200\n        v1.adjacencies = new Edge[]{ new Edge(v0,  700),//BA700\n                                     new Edge(v2,  900),//BC900\n                                     new Edge(v5,  400),//BF400\n                                     new Edge(v6,  800)};//BG800\n        v2.adjacencies = new Edge[]{ new Edge(v3,  400),//CD400\n                                     new Edge(v4,  300),//CE300\n                                     new Edge(v4,  200)};//CE200\n        v3.adjacencies = new Edge[]{ new Edge(v4,  400),//DE400\n                                     new Edge(v4,  300),//DE300\n                                     new Edge(v2,  700) };//DC700\n        v4.adjacencies = new Edge[]{ new Edge(v1,  600) };//EB600\n        v5.adjacencies = new Edge[]{ new Edge(v0,  300),//FA300\n                                     new Edge(v3,  200),//FD200\n                                     new Edge(v4,  500),//FE500\n                                     new Edge(v6,  700) };//FG700\n        v6.adjacencies = new Edge[]{ new Edge(v3,  600),//GD600\n                                     new Edge(v5,  400) };//GF400\n\n\n\n\n        String[] nameNumber = {\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"};\n        Vertex[] vertices = { v0, v1, v2, v3, v4, v5, v6 };\n        HashMap<String, Vertex> dict = new HashMap<String, Vertex>();\n        for (int i = 0; i < nameNumber.length; i++)\n        {\n            dict.put(nameNumber[i], vertices[i]);\n        }\n\n        Scanner k = new Scanner(System.in);\n        System.out.println(\"Enter input journey:\");\n        String inputJourney = k.nextLine();\n\n        String homeToAirport = inputJourney.split(\", \")[1];\n        String airport = String.valueOf(homeToAirport.charAt(0));\n        String airportdestination = inputJourney.split(\", \")[2];\n\n        int passengers = Integer.parseInt(inputJourney.split(\", \")[0]);\n        String modifiedString= inputJourney.substring(1);\n\n        int milesToAirport= Integer.parseInt(modifiedString.replaceAll(\"\\\\D+\",\"\"));\n        int car = ((20 * Integer.parseInt(String.valueOf(milesToAirport)))) / 100;\n        int parking = 3;\n        int taxi = (40 * Integer.parseInt(String.valueOf(milesToAirport)))/100;\n\n\n\n        if (dict.containsKey(airport)) {\n\n            computePaths(vertices[Integer.parseInt(String.valueOf(dict.get(airport)))]);\n            double outboundFlightCost= (10 * vertices[Integer.parseInt(String.valueOf(dict.get(airportdestination)))].minDistance * passengers)/100;\n            System.out.println(\"Outbound Flight cost: \" + outboundFlightCost);\n\n            computePaths(vertices[Integer.parseInt((String.valueOf(dict.get(airportdestination))))]);\n            double inboundFlightCost = (10 * vertices[Integer.parseInt(String.valueOf(dict.get(airport)))].minDistance * passengers)/100;\n            System.out.println(\"Inbound flight cost\" + inboundFlightCost);\n            List<Vertex> path = getShortestPathTo(dict.get(airportdestination));\n                System.out.println(\"Path is: \" + path);\n            }\n\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Optimizations for longest path problem in cyclic graph\r\n                \r\nWhat optimizations exist for trying to find the longest path in a cyclic graph?\nLongest path in cyclic graphs is known to be NP-complete. What optimizations or heuristics can make finding the longest path faster than DFSing the entire graph? Are there any probabilistic approaches?\nI have a graph with specific qualities, but I'm looking for an answer to this in the general case. Linking to papers would be fantastic. Here is a partial answer:\n\nConfirm it is cyclic. Longest path in acyclic graphs is easily computed using dynamic programming.\n\nFind out if the graph is planar (which algorithm is best?). If it is, you might see if it is a block graph, ptolemaic graph, or cacti graph and apply the methods found in this paper.\n\nFind out how many simple cycles there are using Donald B Johnson's algorithm (Java implementation). You can change any cyclic graph into an acyclic one by removing an edge in a simple cycle. You can then run the dynamic programming solution found on the Wikipedia page. For completeness, you would have to do this N times for each cycle, where N is the length of the cycle. Thus, for an entire graph, the number of times you have to run the DP solution is equal to the product of the lengths of all cycles.\n\nIf you have to DFS the entire graph, you can prune some paths by computing the \"reachability\" of each node in advance. This reachability, which is mainly applicable to directed graphs, is the number of nodes each node can reach without repetitions. It is the maximum the longest path from that node could possibly be. With this information, if your current path plus the reachability of the child node is less than the longest you've already found, there is no point in taking that branch as it is impossible that you would find a longer path.\n\n\n    ", "Answer": "\r\nHere is a O(n*2^n) dynamic programming approach that should be feasible for up to say 20 vertices:\n\n```\nm(b, U)```\n = the maximum length of any path ending at ```\nb```\n and visiting only (some of) the vertices in ```\nU```\n.\n\nInitially, set ```\nm(b, {b}) = 0```\n.\n\nThen, ```\nm(b, U)```\n = max value of ```\nm(x, U - x) + d(x, b)```\n over all ```\nx```\n in ```\nU```\n such that ```\nx```\n is not ```\nb```\n and an edge ```\n(x, b)```\n exists.  Take the maximum of these values for all endpoints ```\nb```\n, with ```\nU```\n = ```\nV```\n (the full set of vertices).  That will be the maximum length of any path.\n\nThe following C code assumes a distance matrix in ```\nd[N][N]```\n.  If your graph is unweighted, you can change every read access to this array to the constant ```\n1```\n.  A traceback showing an optimal sequence of vertices (there may be more than one) is also computed in the array ```\np[N][NBITS]```\n.\n\n```\n#define N 20\n#define NBITS (1 << N)\n\nint d[N][N];       /* Assumed to be populated earlier.  -1 means \"no edge\". */\nint m[N][NBITS];   /* DP matrix.  -2 means \"unknown\". */\nint p[N][NBITS];   /* DP predecessor traceback matrix. */\n\n/* Maximum distance for a path ending at vertex b, visiting only\n   vertices in visited. */\nint subsolve(int b, unsigned visited) {\n    if (visited == (1 << b)) {\n        /* A single vertex */\n        p[b][visited] = -1;\n        return 0;\n    }\n\n    if (m[b][visited] == -2) {\n        /* Haven't solved this subproblem yet */\n        int best = -1, bestPred = -1;\n        unsigned i;\n        for (i = 0; i < N; ++i) {\n            if (i != b && ((visited >> i) & 1) && d[i][b] != -1) {\n                int x = subsolve(i, visited & ~(1 << b));\n                if (x != -1) {\n                    x += d[i][b];\n                    if (x > best) {\n                        best = x;\n                        bestPred = i;\n                    }\n                }\n            }\n        }\n\n        m[b][visited] = best;\n        p[b][visited] = bestPred;\n    }\n\n    return m[b][visited];\n}\n\n/* Maximum path length for d[][].\n   n must be <= N.\n   *last will contain the last vertex in the path; use p[][] to trace back. */\nint solve(int n, int *last) {\n    int b, i;\n    int best = -1;\n\n    /* Need to blank the DP and predecessor matrices */\n    for (b = 0; b < N; ++b) {\n        for (i = 0; i < NBITS; ++i) {\n            m[b][i] = -2;\n            p[b][i] = -2;\n        }\n    }\n\n    for (b = 0; b < n; ++b) {\n        int x = subsolve(b, (1 << n) - 1);\n        if (x > best) {\n            best = x;\n            *last = b;\n        }\n    }\n\n    return best;\n}\n```\n\n\nOn my PC, this solves a 20x20 complete graph with edge weights randomly chosen in the range [0, 1000) in about 7s and needs about 160Mb (half of that is for the predecessor trace).\n\n(Please, no comments about using fixed-size arrays.  Use ```\nmalloc()```\n (or better yet, C++ ```\nvector<int>```\n) in a real program.  I just wrote it this way so things would be clearer.)\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How can i Analyse and Discover all possible paths in an activity network\r\n                \r\nHey , i have been developing this kind of a \"project management tool\" for study it is supposed to calculate tasks durations and cost to determine a critical path for any given project like this for example :\n\nen example of a project and tasks relations\n\n**until now i calculated all the durations and starts and finishes but i'm stuck with how to discover all the possible paths in such a graph and how to traverse this structure from the initial node to the final node and determine witch path will take the longest duration and i have no idea how to continue so thanks in advance for helping me **\n\nI implemented a Task Class as follow :\n\n```\npublic class Task {\n\n    private String name;\n    private int duration;\n    private int earlyStart;\n    private int earlyFinish;\n    private int lateStart;\n    private int lateFinish;\n    private int totalFloat;\n    private HashSet<Task> predecessors;\n    private HashSet<Task> successors;\n    private String[] dependencies;\n\n    public Task(String taskName, int taskDuration, String[] dependencies) {\n        // Initialize Attributes\n        this.name = taskName;\n        this.duration = taskDuration;\n        this.dependencies = dependencies;\n        this.predecessors = new HashSet<Task>();\n        this.successors = new HashSet<Task>();\n    }\n}\n```\n\n\nPs : i didn't include the getters and setters \n\nand i have also a class called project implemented as follow :\n\n```\npublic class Project {\n\nprivate HashSet<Task> tasks;\nprivate HashSet<Task> initialTasks;\nprivate HashSet<Task> finalTasks;\nprivate int maxDuration;\n\npublic Project() {\n    this.tasks = new HashSet<Task>();\n}\n\npublic void initialize(){\n\n    this.calculateTasksRelation();\n    this.calculateInitialTasks();\n    this.calculateInitialTasksEarlies();\n    this.forwardPass();\n\n    this.calculateFinalTasks();\n    this.calculateMaxDuration();\n    this.calculateFinalTasksLates();\n    this.backwardPass();\n\n}\n\n\n\n\npublic void addTask(Task task) {\n    this.tasks.add(task);\n}\n\npublic Task getTaskByName(String taskName) {\n    for (Task task : tasks) {\n        if(task.getName().equals(taskName)){\n            return task;\n        }\n    }\n    return null;\n}\n\npublic HashSet<Task> getAllTasks() {\n    return tasks;\n}\n\n/**\n * Private Methods internal Usage Only\n * */\nprivate void calculateTasksRelation() {\n    for (Task current : tasks) {\n        if ( current.getDependencies() != null ) {\n            for (String string : current.getDependencies() ) {\n                if (this.getTaskByName(string) != null) {\n                    Task dependencie = this.getTaskByName(string);\n                    current.addPredecessor(dependencie);\n                    dependencie.addSuccessor(current);\n                }\n            }\n        }\n    }\n}\n\n// Return only the tasks that dosn't have predecessors\nprivate void calculateInitialTasks(){\n    HashSet<Task> remaining = new HashSet<Task>(this.tasks);\n    // itertare over the remaining and remove all tasks \n    // that are successors = they have predecessor\n    for (Task current : tasks) {\n        for (Task successor : current.getSuccessors()) {\n            remaining.remove(successor);\n        }\n    }\n    this.initialTasks = new HashSet<>(remaining);\n}\n\nprivate void calculateInitialTasksEarlies() {\n    for (Task initialTask : this.initialTasks) {\n        initialTask.setEarlyStart(0);\n        initialTask.setEarlyFinish(initialTask.getEarlyStart() + initialTask.getDuration());\n    }\n}\n\nprivate void calculateMaxDuration() {\n\n    for (Task task : finalTasks) {\n        if(task.getEarlyFinish() > this.maxDuration) {\n            this.maxDuration = task.getEarlyFinish();\n        }\n    }\n}\n\n// Return only the tasks that dosn't have any successors\nprivate void calculateFinalTasks() {\n    HashSet<Task> remaining = new HashSet<Task>(this.tasks);\n    // itertare over the remaining and remove all tasks \n    // that are predecessors = they have successor\n    for (Task current : tasks) {\n        for (Task predecessor : current.getPredecessors()) {\n            remaining.remove(predecessor);\n        }\n    }\n    this.finalTasks = new HashSet<>(remaining);\n}\n\nprivate void calculateFinalTasksLates() {\n    for (Task endTask : this.finalTasks) {\n        endTask.setLateFinish(this.maxDuration);\n        endTask.setLateStart(endTask.getLateFinish() - this.maxDuration);\n    }\n}\n\nprivate void forwardPass() {\n    // tasks whose early starts has been calculated\n    HashSet<Task> completed = new HashSet<Task>(initialTasks);\n    // tasks whose early starts has not been calculated yet\n    HashSet<Task> remaining = new HashSet<Task>(tasks);\n    remaining.removeAll(initialTasks);\n\n    // Backflow algorithm\n    // while there are tasks whose early start isn't calculated.\n    while (!remaining.isEmpty()) {\n        boolean progress = false;\n        for (Task currentTask : this.tasks) {\n            if(completed.containsAll(currentTask.getPredecessors())){\n                int temp = 0 ;\n                for ( Task dependencie : currentTask.getPredecessors() ) {\n                    if( dependencie.getEarlyFinish() > temp ){\n                        // update the temp variable\n                        temp = dependencie.getEarlyFinish();\n                    }\n                }\n                currentTask.setEarlyStart(temp);\n                currentTask.setEarlyFinish(currentTask.getEarlyStart() + currentTask.getDuration());\n                // set the task as completed and remove it from the remaining\n                completed.add(currentTask);\n                remaining.remove(currentTask);\n                // note that we are making a progress\n                progress = true;\n            }\n        }\n        // If we haven't made any progress then a cycle must exist in\n        // the graph and we wont be able to calculate the critical path\n        if (!progress)\n            throw new RuntimeException(\"Cyclic dependency, algorithm stopped!\");\n    }\n}\n\nprivate void backwardPass() {\n    // tasks whose early starts has been calculated\n    HashSet<Task> completed = new HashSet<Task>(this.finalTasks);\n    // tasks whose early starts has not been calculated yet\n    HashSet<Task> remaining = new HashSet<Task>(tasks);\n    remaining.removeAll(finalTasks);\n\n    // Backflow algorithm\n    // while there are tasks whose early start isn't calculated.\n    while (!remaining.isEmpty()) {\n        boolean progress = false;\n        for (Task currentTask : this.tasks) {\n            if(completed.containsAll(currentTask.getSuccessors())){\n                int temp = this.maxDuration;\n                for ( Task successor : currentTask.getSuccessors() ) {\n                    if( successor.getLateStart() < temp ){\n                        // update the temp variable\n                        temp = successor.getLateStart();\n                    }\n                }\n                currentTask.setLateFinish(temp);\n                currentTask.setLateStart(currentTask.getLateFinish() - currentTask.getDuration());\n                // set the task as completed and remove it from the remaining\n                completed.add(currentTask);\n                remaining.remove(currentTask);\n                // note that we are making a progress\n                progress = true;\n            }\n        }\n        // If we haven't made any progress then a cycle must exist in\n        // the graph and we wont be able to calculate the critical path\n        if (!progress)\n            throw new RuntimeException(\"Cyclic dependency, algorithm stopped!\");\n    }\n}\n}\n```\n\n\nPs : Sorry for the long code :)\n    ", "Answer": "\r\nFinding the longest path from one source node to another one is an NP-hard problem in the general form, so there is no polynomial solution to it. \nContrary to it, finding the shortest path is kind of easy to solve using Dijkstra's or Bellman-Ford's algorithm.\nI am not an expert, but I would really suggest to reconsider what you can and what you cannot do in the exercise.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Depth search of a path in tree or graph data structures\r\n                \r\nI'm trying to creare a Tree or a Graph data structure that allow me to quickly search (depth search) if exists a specific path. In particular, starting from a list of strings:\n```\nArrayList<String> data = new ArrayList<String>();\ndata.add(\"2.2.3.3.3\");\ndata.add(\"2.3.4.3.4\");\ndata.add(\"2.2.2.4.4\");\n\nString pathToFind1 = \"2.3.4.X.4\"\nString pathToFind2 = \"2.X.X.2.4\"\nString pathToFind3 = \"2.3.X.4.4\"\n```\n\nand a path to find (e.g., \"X.2.X.4.4\"), I would check if exist a path that:\n\npathToFind1: links the nodes 2 (At depth 1), 3 (At depth 2), 4 (at depth 3), and 4 (at depth 5);\npathToFind2: links the nodes 2 (At depth 1), 2 (at depth 4), and 4 (at depth 5);\npathToFind3: links the nodes 2 (At depth 1), 3 (at depth 2), 4 (at depth 4), and 4 (at depth 5);\n\nThe value X represents a generic value.\n```\n/*\n            2\n          /   \\\n         2     3\n        / \\     \\\n       2   3     4\n      /     \\     \\  \n     4       3     3\n      \\       \\     \\     \n       4       3     4     \n*/\n\npublic static boolean findPath(String path) {\n    //...\n}\n\nfindPath(pathToFind1); //return true\nfindPath(pathToFind2); //return false\nfindPath(pathToFind3); //return false\n```\n\nI've thought to use a Trie, but the main problem of this structure is that I should consider a full path to find (i.e., a path with all the elements).\nCan you suggest a data structure or a solution to solve my problem? Notice that, it is not necessary to use a tree or graph, but my goal is to perform a quick search of paths.\n    ", "Answer": "\r\nThere are two main algorithms that you can use to do the work. I mean DLS and IDS.\nThese two are stable for Unconscious search. it means they search in specified level, not all of the graph and it is really quicker and needs less memory.\nTry them may solve your problem.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Graph path finder\r\n                \r\ni am trying to find a path in between  two nodes(sourcenode and targetnode). i came up with this code but i cant seem to make it recursively find a path. i even set the nodes to null if the target node is found but i keep getting a stack overflow error.\n\n```\npublic void findPathBetween(Node sourceNode, Node targetNode){\n    //find a path between the sourceNode and targetNode\n    //select the nodes and edges along the path if one exists.\n\n    ArrayList<Node> nodesToSearch = new ArrayList<Node>();\n    nodesToSearch.add(sourceNode);\n\n    //basis\n    if(sourceNode == null || targetNode == null) return;\n\n    //recursion\n    ArrayList<Node> newNodesToSearch = new ArrayList<Node>(); //get nodes for next level to search\n    for(Node aNode : nodesToSearch) {\n        for (Node neighbour : aNode.getNeighbours()) {\n            if (neighbour != targetNode && newNodesToSearch.isEmpty()) {\n                newNodesToSearch.add(neighbour);\n                neighbour.setSelected(true);\n                edgeBetween(aNode, neighbour).setSelected(true);\n                sourceNode = neighbour;\n            }\n            if (neighbour == targetNode) {\n                sourceNode = null;\n                targetNode = null;\n                return;\n            }\n        }\n    }\n    if(sourceNode != null &&targetNode != null) {\n        findPathBetween(sourceNode, targetNode);\n    }\n}\n```\n\n    ", "Answer": "\r\nYou are storing the state inside the recursion function, and don't pass it to the next iteration. Thus you are simply running one function over and over without changing its arguments and the state that affects its execution. \n\nI do not want to correct your code because I would have to guess you intents in order to provide a good explanation. \n\nAnyway I think that you were trying to implement DFS, so I suggest you to take a look at some working implementations. Just google them, there are plenty, e.g. this one comes with a piece of theory, is simple, and was written by Robert Sedgewick, so it can be trusted.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest non repetitive path in a graph?\r\n                \r\nI was working on to find the shortest path between two nodes in undirected acyclic graph using Dijkstra's algorithms. I wanted to find the longest path that is possible by the same algorithm. I also want to avoid few routes with 0 edge values. How do I do that using Dijkstra's algorithm? \n\nNow after searching through Stackoverflow I came across one given solution which just states that we need to modify the relaxation part to find the longest path.\n\nLike:\n\n```\nif(distanceValueOfNodeA< EdgeValueofNodeBtoA )\n\n{\n\ndistanceValueOfNodeA = EdgeValueofNodeBtoA;\n\n}\n```\n\n\nBut we are not considering adding ```\ndistanceValueOfNodeB```\n \n\nBut for shortest paths we calculate:\n\n```\ndistanceValueOfNodeA = distanceValueOfNodeB+EdgeValueofNodeBtoA\n```\n\n\nShould we ignore ```\ndistanceValueOfNodeB```\n to calculate ```\ndistanceValueOfNodeA```\n ?\n    ", "Answer": "\r\nI am sorry to disappoint you but that problem is known as Longest path in a graph and there isn't an efficient algorithm to solve it, so niether Djikstra algorithm with any modification can. \n\nIt belongs to a class of problems known as NP-hard,those are problems for which there isn't (at the moment) an algorithm to solve them in faster time complexity compared to exponential.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find every paths in any direction with specified labels and hops\r\n                \r\nI have the following graph:\n\n\n\nVertices and edges have been added like this:\n\n```\ndef graph=ConfiguredGraphFactory.open('Baptiste');def g = graph.traversal();\ngraph.addVertex(label, 'Group', 'text', 'BNP Paribas');\ngraph.addVertex(label, 'Group', 'text', 'BNP PARIBAS');\ngraph.addVertex(label, 'Company', 'text', 'JP Morgan Chase');\ngraph.addVertex(label, 'Location', 'text', 'France');\ngraph.addVertex(label, 'Location', 'text', 'United States');\ngraph.addVertex(label, 'Location', 'text', 'Europe');\ndef v1 = g.V().has('text', 'JP Morgan Chase').next();def v2 = g.V().has(text, 'BNP Paribas').next();v1.addEdge('partOf',v2);\ndef v1 = g.V().has('text', 'JP Morgan Chase').next();def v2 = g.V().has(text, 'United States').next();v1.addEdge('doesBusinessIn',v2);\ndef v1 = g.V().has('text', 'BNP Paribas').next();def v2 = g.V().has(text, 'United States').next();v1.addEdge('doesBusinessIn',v2);\ndef v1 = g.V().has('text', 'BNP Paribas').next();def v2 = g.V().has(text, 'France').next();v1.addEdge('partOf',v2);\ndef v1 = g.V().has('text', 'BNP PARIBAS').next();def v2 = g.V().has(text, 'Europe').next();v1.addEdge('partOf',v2);\n```\n\n\nAnd I need a query that returns me every paths possible given specific vertex labels, edge labels and number of possible hops.\nLet's say I need paths with maximum hops of 2 and every labels in this example. I tried this query:\n\n```\ndef graph=ConfiguredGraphFactory.open('TestGraph');\ndef g = graph.traversal();\ng.V().has(label, within('Location', 'Company', 'Group'))\n.repeat(bothE().has(label, within('doesBusinessIn', 'partOf')).bothV().has(label, within('Location', 'Company', 'Group')).simplePath())\n.emit().times(2).path();\n```\n\n\nThis query returns 20 paths (supposed to return 10 paths). So it returns paths in the 2 possible directions. Is there a way to specify that I need only 1 direction? I tried adding ```\ndedup()```\n in my query but it returns 7 paths instead of 10 so it's not working?\n\nAlso whenever I try to find paths with 4 hops, it doesn't return me the \"cyclic\" paths such as ```\nFrance -> BNP Paribas -> United States -> JP Morgan Chase -> BNP Paribas```\n. Any idea what to add in my query to allow returning those kind of paths?\n\nEDIT:\nThanks for your solution @DanielKuppitz. It seems to be exactly what I'm looking for.\n\nI use JanusGraph built on top of Apache Tinkerpop:\nI tried the first query:\n\n```\ng.V().hasLabel('Location', 'Company', 'Group').\n  repeat(bothE('doesBusinessIn', 'partOf').otherV().simplePath()).\n    emit().times(2).\n  path().\n  dedup().\n    by(unfold().order().by(id).fold())\n```\n\n\nAnd it threw the following error:\n\n```\nError: org.janusgraph.graphdb.relations.RelationIdentifier cannot be cast to java.lang.Comparable\n```\n\n\nSo I moved the ```\ndedup```\n command. into the repeat loop like so:\n\n```\ng.V().hasLabel('Location', 'Company', 'Group').\n      repeat(bothE('doesBusinessIn', 'partOf').otherV().simplePath().dedup().by(unfold().order().by(id).fold())).\n      emit().times(2).\n      path().\n```\n\n\nAnd it only returned 6 paths :\n\n```\n[\n  [\n    \"JP Morgan Chase\",\n    \"doesBusinessIn\",\n    \"United States\"\n  ],\n  [\n    \"JP Morgan Chase\",\n    \"partOf\",\n    \"BNP Paribas\"\n  ],\n  [\n    \"JP Morgan Chase\",\n    \"partOf\",\n    \"BNP Paribas\",\n    \"partOf\",\n    \"France\"\n  ],\n  [\n    \"Europe\",\n    \"partOf\",\n    \"BNP PARIBAS\"\n  ],\n  [\n    \"BNP PARIBAS\",\n    \"partOf\",\n    \"Europe\"\n  ],\n  [\n    \"United States\",\n    \"doesBusinessIn\",\n    \"JP Morgan Chase\"\n  ]\n]\n```\n\n\nI'm not sure what's going on here... Any ideas?\n    ", "Answer": "\r\n\n  Is there a way to specify that I need only 1 direction?\n\n\nYou kinda need a bidirected traversal, so you'll have to filter duplicated paths in the end (\"duplicated\" in this case means that 2 paths contain the same elements). In order to do that you can ```\ndedup()```\n paths by a deterministic order of elements; the easiest way to do it is to order the elements by their ```\nid```\n.\n\n```\ng.V().hasLabel('Location', 'Company', 'Group').\n  repeat(bothE('doesBusinessIn', 'partOf').otherV().simplePath()).\n    emit().times(2).\n  path().\n  dedup().\n    by(unfold().order().by(id).fold())\n```\n\n\n\n  Any idea what to add in my query to allow returning those kinds of paths  (cyclic)?\n\n\nYour query explicitly prevents cyclic paths through the ```\nsimplePath()```\n step, so it's not quite clear in which scenarios you want to allow them. I assume that you're okay with a cyclic path if the cycle is created by only the first and last element in the path. In this case, the query would look more like this:\n\n```\ng.V().hasLabel('Location', 'Company', 'Group').as('a').\n  repeat(bothE('doesBusinessIn', 'partOf').otherV()).\n    emit().\n    until(loops().is(4).or().cyclicPath()).\n  filter(simplePath().or().where(eq('a'))).\n  path().\n  dedup().\n    by(unfold().order().by(id).fold())\n```\n\n\nBelow is the output of the 2 queries (ignore the extra ```\nmap()```\n step, it's just there to improve the output's readability).\n\n```\ngremlin> g.V().hasLabel('Location', 'Company', 'Group').\n......1>   repeat(bothE('doesBusinessIn', 'partOf').otherV().simplePath()).\n......2>     emit().times(2).\n......3>   path().\n......4>   dedup().\n......5>     by(unfold().order().by(id).fold()).\n......6>   map(unfold().coalesce(values('text'), label()).fold())\n==>[BNP Paribas,doesBusinessIn,United States]\n==>[BNP Paribas,partOf,France]\n==>[BNP Paribas,partOf,JP Morgan Chase]\n==>[BNP Paribas,doesBusinessIn,United States,doesBusinessIn,JP Morgan Chase]\n==>[BNP Paribas,partOf,JP Morgan Chase,doesBusinessIn,United States]\n==>[BNP PARIBAS,partOf,Europe]\n==>[JP Morgan Chase,doesBusinessIn,United States]\n==>[JP Morgan Chase,partOf,BNP Paribas,doesBusinessIn,United States]\n==>[JP Morgan Chase,partOf,BNP Paribas,partOf,France]\n==>[France,partOf,BNP Paribas,doesBusinessIn,United States]\n\ngremlin> g.V().hasLabel('Location', 'Company', 'Group').as('a').\n......1>   repeat(bothE('doesBusinessIn', 'partOf').otherV()).\n......2>     emit().\n......3>     until(loops().is(4).or().cyclicPath()).\n......4>   filter(simplePath().or().where(eq('a'))).\n......5>   path().\n......6>   dedup().\n......7>     by(unfold().order().by(id).fold()).\n......8>   map(unfold().coalesce(values('text'), label()).fold())\n==>[BNP Paribas,doesBusinessIn,United States]\n==>[BNP Paribas,partOf,France]\n==>[BNP Paribas,partOf,JP Morgan Chase]\n==>[BNP Paribas,doesBusinessIn,United States,doesBusinessIn,JP Morgan Chase]\n==>[BNP Paribas,doesBusinessIn,United States,doesBusinessIn,BNP Paribas]\n==>[BNP Paribas,partOf,France,partOf,BNP Paribas]\n==>[BNP Paribas,partOf,JP Morgan Chase,doesBusinessIn,United States]\n==>[BNP Paribas,partOf,JP Morgan Chase,partOf,BNP Paribas]\n==>[BNP Paribas,doesBusinessIn,United States,doesBusinessIn,JP Morgan Chase,partOf,BNP Paribas]\n==>[BNP PARIBAS,partOf,Europe]\n==>[BNP PARIBAS,partOf,Europe,partOf,BNP PARIBAS]\n==>[JP Morgan Chase,doesBusinessIn,United States]\n==>[JP Morgan Chase,doesBusinessIn,United States,doesBusinessIn,JP Morgan Chase]\n==>[JP Morgan Chase,partOf,BNP Paribas,doesBusinessIn,United States]\n==>[JP Morgan Chase,partOf,BNP Paribas,partOf,France]\n==>[JP Morgan Chase,partOf,BNP Paribas,partOf,JP Morgan Chase]\n==>[JP Morgan Chase,doesBusinessIn,United States,doesBusinessIn,BNP Paribas,partOf,France]\n==>[JP Morgan Chase,doesBusinessIn,United States,doesBusinessIn,BNP Paribas,partOf,JP Morgan Chase]\n==>[France,partOf,BNP Paribas,doesBusinessIn,United States]\n==>[France,partOf,BNP Paribas,partOf,France]\n==>[France,partOf,BNP Paribas,partOf,JP Morgan Chase,doesBusinessIn,United States]\n==>[United States,doesBusinessIn,JP Morgan Chase,doesBusinessIn,United States]\n==>[United States,doesBusinessIn,BNP Paribas,doesBusinessIn,United States]\n==>[United States,doesBusinessIn,JP Morgan Chase,partOf,BNP Paribas,doesBusinessIn,United States]\n==>[Europe,partOf,BNP PARIBAS,partOf,Europe]\n```\n\n\nUPDATE (based on latest comments)\n\nSince JanusGraph has non-comparable edge identifiers, you'll need a unique comparable property on all edges. This can be as simple as a random UUID.\n\nThis is how I updated your sample graph:\n\n```\ng.addV('Group').property('text', 'BNP Paribas').as('a').\n  addV('Group').property('text', 'BNP PARIBAS').as('b').\n  addV('Company').property('text', 'JP Morgan Chase').as('c').\n  addV('Location').property('text', 'France').as('d').\n  addV('Location').property('text', 'United States').as('e').\n  addV('Location').property('text', 'Europe').as('f').\n  addE('partOf').from('c').to('a').\n    property('uuid', UUID.randomUUID().toString()).\n  addE('doesBusinessIn').from('c').to('e').\n    property('uuid', UUID.randomUUID().toString()).\n  addE('doesBusinessIn').from('a').to('e').\n    property('uuid', UUID.randomUUID().toString()).\n  addE('partOf').from('a').to('d').\n    property('uuid', UUID.randomUUID().toString()).\n  addE('partOf').from('b').to('f').\n    property('uuid', UUID.randomUUID().toString()).\n  iterate()\n```\n\n\nNow, that we have properties that can uniquely identify an edge, we also need unique properties (of the same data type) on all vertices. Luckily the existing ```\ntext```\n properties seem to be good enough for that (otherwise it would be the same story as with the edges - just add a random UUID). The updated queries now look like this:\n\n```\ng.V().hasLabel('Location', 'Company', 'Group').\n  repeat(bothE('doesBusinessIn', 'partOf').otherV().simplePath()).\n    emit().times(2).\n  path().\n  dedup().\n    by(unfold().values('text','uuid').order().fold())\n\ng.V().hasLabel('Location', 'Company', 'Group').as('a').\n  repeat(bothE('doesBusinessIn', 'partOf').otherV()).\n    emit().\n    until(loops().is(4).or().cyclicPath()).\n  filter(simplePath().or().where(eq('a'))).\n  path().\n  dedup().\n    by(unfold().values('text','uuid').order().fold())\n```\n\n\nThe result are, of course, the same as above.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Enumerate all paths in a weighted graph from A to B where path length is between C1 and C2\r\n                \r\nGiven two points A and B in a weighted graph, find all paths from A to B where the length of the path is between C1 and C2.\n\nIdeally, each vertex should only be visited once, although this is not a hard requirement. I suppose I could use a heuristic to sort the results of the algorithm to weed out \"silly\" paths (e.g. a path that just visits the same two nodes over and over again)\n\nI can think of simple brute force algorithms, but are there any more sophisticed algorithms that will make this more efficient? I can imagine as the graph grows this could become expensive.\n\nIn the application I am developing, A & B are actually the same point (i.e. the path must return to the start), if that makes any difference.\n\nNote that this is an engineering problem, not a computer science problem, so I can use an algorithm that is fast but not necessarily 100% accurate. i.e. it is ok if it returns most of the possible paths, or if most of the paths returned are within the given length range.\n\n[UPDATE]\nThis is what I have so far. I have this working on a small graph (30 nodes with around 100 edges). The time required is < 100ms\n\nI am using a directed graph.\nI do a depth first search of all possible paths.\n\n\nAt each new node\n\nFor each edge leaving the node\n\nReject the edge if the path we have already contains this edge (in other words, never go down the same edge in the same direction twice)\nReject the edge if it leads back to the node we just came from (in other words, never double back. This removes a lot of 'silly' paths)\nReject the edge if (minimum distance from the end node of the edge to the target node B + the distance travelled so far) > Maximum path length (C2)\nIf the end node of the edge is our target node B:\n\nIf the path fits within the length criteria, add it to the list of suitable paths.\nOtherwise reject the edge (in other words, we only ever visit the target node B at the end of the path. It won't be an intermediate point on a path)\n\nOtherwise, add the edge to our path and recurse into it's target node\n\n\n\n\nI use Dijkstra to precompute the minimum distance of all nodes to the target node.\n    ", "Answer": "\r\nI wrote some java code to test the DFS approach I suggested: the code does not check for paths in range, but prints all paths. It should be simple to modify the code to only keep those in range. I also ran some simple tests. It seems to be giving correct results with 10 vertices and 50 edges or so, though I did not find time for any thorough testing. I also ran it for 100 vertices and 1000 edges. It doesn't run out of memory and keeps printing new paths till I kill it, of which there are a lot. This is not surprising for randomly generated dense graphs, but may not be the case for real world graphs, for example where vertex degrees follow a power law (specially with narrow weight ranges. Also, if you are just interested in how path lengths are distributed in a range, you can stop once you have generated a certain number.\n\nThe program outputs the following:\na) the adjacency list of a randomly generated graph.\nb) Set of all paths it has found till now.\n\n```\npublic class AllPaths {\n\n    int numOfVertices;\n    int[] status;\n    AllPaths(int numOfVertices){\n        this.numOfVertices = numOfVertices;\n        status = new int[numOfVertices+1];\n    }\n\n    HashMap<Integer,ArrayList<Integer>>adjList = new HashMap<Integer,ArrayList<Integer>>(); \n    class FoundSubpath{\n          int pathWeight=0;\n          int[] vertices;\n\n        }\n\n\n    // For each vertex, a a list of all subpaths of length less than UB found.\n    HashMap<Integer,ArrayList<FoundSubpath>>allSubpathsFromGivenVertex = new HashMap<Integer,ArrayList<FoundSubpath>>();\n\n    public void printInputGraph(){\n\n        System.out.println(\"Random Graph Adjacency List:\");\n\n        for(int i=1;i<=numOfVertices;i++){\n            ArrayList<Integer>toVtcs = adjList.get(new Integer(i));\n            System.out.print(i+ \" \");\n            if(toVtcs==null){\n                continue;\n            }\n            for(int j=0;j<toVtcs.size();j++){\n                System.out.print(toVtcs.get(j)+ \" \");\n            }\n            System.out.println(\" \");\n        }\n\n    }\n\n    public void randomlyGenerateGraph(int numOfTrials){\n\n        Random rnd = new Random();\n\n        for(int i=1;i < numOfTrials;i++){\n            Integer fromVtx = new Integer(rnd.nextInt(numOfVertices)+1);\n            Integer toVtx = new Integer(rnd.nextInt(numOfVertices)+1);\n            if(fromVtx.equals(toVtx)){\n                continue;\n            }\n            ArrayList<Integer>toVtcs = adjList.get(fromVtx);\n            boolean alreadyAdded = false;\n            if(toVtcs==null){\n                toVtcs = new ArrayList<Integer>();\n            }else{\n                for(int j=0;j<toVtcs.size();j++){\n                    if(toVtcs.get(j).equals(toVtx)){\n                        alreadyAdded = true;\n                        break;\n                    }\n                }\n            }\n            if(!alreadyAdded){\n            toVtcs.add(toVtx);\n            adjList.put(fromVtx, toVtcs);\n            }\n        }\n\n    }\n\n    public void addAllViableSubpathsToMap(ArrayList<Integer>VerticesTillNowInPath){\n        FoundSubpath foundSpObj;\n        ArrayList<FoundSubpath>foundPathsList;\n        for(int i=0;i<VerticesTillNowInPath.size()-1;i++){\n                Integer startVtx = VerticesTillNowInPath.get(i);\n            if(allSubpathsFromGivenVertex.containsKey(startVtx)){\n                foundPathsList = allSubpathsFromGivenVertex.get(startVtx);\n            }else{\n                foundPathsList = new ArrayList<FoundSubpath>(); \n            }\n\n            foundSpObj = new FoundSubpath(); \n            foundSpObj.vertices = new int[VerticesTillNowInPath.size()-i-1];\n            int cntr = 0;\n            for(int j=i+1;j<VerticesTillNowInPath.size();j++){\n                foundSpObj.vertices[cntr++] = VerticesTillNowInPath.get(j);\n            }\n            foundPathsList.add(foundSpObj);\n            allSubpathsFromGivenVertex.put(startVtx,foundPathsList);\n        }\n\n    }\n\n    public void printViablePaths(Integer v,ArrayList<Integer>VerticesTillNowInPath){\n\n        ArrayList<FoundSubpath>foundPathsList;\n        foundPathsList = allSubpathsFromGivenVertex.get(v);\n\n        if(foundPathsList==null){\n            return;\n        }\n\n            for(int j=0;j<foundPathsList.size();j++){\n                for(int i=0;i<VerticesTillNowInPath.size();i++){\n                    System.out.print(VerticesTillNowInPath.get(i)+ \" \");\n                }\n                FoundSubpath fpObj = foundPathsList.get(j) ;\n                for(int k=0;k<fpObj.vertices.length;k++){\n                    System.out.print(fpObj.vertices[k]+\" \");\n                }\n                System.out.println(\"\");\n            }\n    }\n\n    boolean DfsModified(Integer v,ArrayList<Integer>VerticesTillNowInPath,Integer source,Integer dest){\n\n\n        if(v.equals(dest)){\n          addAllViableSubpathsToMap(VerticesTillNowInPath);\n          status[v] = 2;\n          return true;\n        }\n\n        // If vertex v is already explored till destination, just print all subpaths that meet criteria, using hashmap.\n        if(status[v] == 1 || status[v] == 2){\n          printViablePaths(v,VerticesTillNowInPath);\n          }\n\n        // Vertex in current path. Return to avoid cycle.\n        if(status[v]==1){\n          return false;\n        }\n\n        if(status[v]==2){\n              return true;\n            }\n\n        status[v] = 1;\n        boolean completed = true;\n\n        ArrayList<Integer>toVtcs = adjList.get(v);\n\n        if(toVtcs==null){\n            status[v] = 2;\n            return true;\n        }\n\n        for(int i=0;i<toVtcs.size();i++){\n\n          Integer vDest = toVtcs.get(i);\n\n           VerticesTillNowInPath.add(vDest);\n\n           boolean explorationComplete =  DfsModified(vDest,VerticesTillNowInPath,source,dest);\n\n           if(explorationComplete==false){\n           completed = false;\n           }\n\n           VerticesTillNowInPath.remove(VerticesTillNowInPath.size()-1);\n\n        }\n\n        if(completed){\n            status[v] = 2;\n        }else{\n            status[v] = 0;\n        }\n\n        return completed;\n\n    }\n\n\n}\n\n\npublic class AllPathsCaller {\n\n    public static void main(String[] args){\n\n        int numOfVertices = 20;\n        /* This is the number of attempts made to create an edge. The edge is usually created but may not be ( eg, if an edge already exists between randomly attempted source and destination.*/\n        int numOfEdges = 200;\n        int src = 1;\n        int dest = 10;\n        AllPaths allPaths = new AllPaths(numOfVertices);\n\n        allPaths.randomlyGenerateGraph(numOfEdges);\n        allPaths.printInputGraph();\n\n        ArrayList<Integer>VerticesTillNowInPath = new ArrayList<Integer>();\n        VerticesTillNowInPath.add(new Integer(src));\n        System.out.println(\"List of Paths\");\n        allPaths.DfsModified(new Integer(src),VerticesTillNowInPath,new Integer(src),new Integer(dest));\n\n        System.out.println(\"done\");\n\n\n\n\n    }\n\n\n\n}\n```\n\n\n\n\nI think you are on the right track with BFS. I came up with some rough vaguely java-like pseudo-code for a proposed solution using BFS. The idea is to store subpaths found during previous traversals, and their lengths, for reuse. I'll try to improve the code sometime today when I find the time, but hopefully it gives a clue as to where I am going with this. The complexity, I am guessing, should be order O(E).  \n\n,\n\n\n\nFurther comments:\n\nThis seems like a reasonable approach, though I am not sure I understand completely. I've constructed a simple example to make sure I do. Lets consider a simple graph with all edges weighted 1, and adjacency list representation as follows:\n\nA->B,C\n\nB->C\n\nC->D,F\n\nF->D\n\nSay we wanted to find all paths from A to F, not just those in range, and destination vertices from a source vertex are explored in alphabetic order. Then the algorithm would work as follows:\n\nFirst starting with B:\nABCDF\nABCF\n\nThen starting with C:\nACDF\nACF\n\nIs that correct?\n\nA simple improvement in that case, would be to store for each vertex visited, the paths found after the first visit to that node. For example, in this example, once you visit C from B, you find that there are two paths to F from C: CF and CDF. You can save this information, and in the next iteration once you reach C, you can just append CF and CDF to the path you have found, and won't need to explore further.\n\nTo find edges in range, you can use the conditions you already described for paths generated as above.\n\nA further thought: maybe you do not need to run Dijkstra's to find shortest paths at all. A subpath's length will be found the first time you traverse the subpath. So, in this example, the length of CDF and CF the first time you visit C via B. This information can be used for pruning the next time C is visited directly via A. This length will be more accurate than that found by Dijkstra's, as it would be the exact value, not the lower bound.\n\n\n\nFurther comments:\nThe algorithm can probably be improved with some thought. For example, each time the relaxation step is executed in Dijkstra's algorithm (steps 16-19 in the wikipedia description), the rejected older/newer subpath can be remembered using some data structure, if the older path is a plausible candidate (less than upper bound). In the end, it should be possible to reconstruct all the rejected paths, and keep the ones in range. \n\nThis algorithm should be O(V^2).\n\n\n\nI think visiting each vertex only once may be too optimistic: algorithms such as Djikstra's shortest path have complexity v^2 for finding a single path, the shortest path. Finding all paths (including shortest path) is a harder problem, so should have complexity at least V^2.\n\nMy first thought on approaching the problem is a variation of Djikstra's shortest path algorithm. Applying this algorithm once would give you the length of the shortest path. This gives you a lower bound on the path length between the two vertices. Removing an edge at a time from this shortest path, and recalculating the shortest path should give you slightly longer paths. \n\nIn turn, edges can be removed from these slightly longer paths to generate more paths, and so on. You can stop once you have a sufficient number of paths, or if the paths you generate are over your upper bound.\n\nThis is my first guess. I am a newbie to stackoverflow: any feedback is welcome.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Is there a counter-example for this algorithm finding the Euler Path in a Eulerian Graph?\r\n                \r\nThe following is the given algorithm for finding a Euler Path in a Eulerian Graph. However, it is said that there is an counter example with less than 10 vertices. The given Eulerian Graph is undirected and every vertex has even degree and it will start and end at the same vertex.\n\n```\n1. Perform a DFS traversal of G and number the vertices in DFS-preorder.\n2. Re-initialize all vertices and edges of G as unused.\n3. Produce a cycle as follows:\n    Start from the vertex with preorder number 1 (computed in step 1), and\n    repeatedly go to the vertex with highest preorder number possible along \n    an unused edge.\n    Stop when all edges incident to the current vertex are used.\n```\n\n\nI have been trying vertices from 6 to 9 for the last 3 days and I really couldn't come up with one example. Any help is appreciated! Thank you.\n    ", "Answer": "\r\nIt's a little pedantic based on the definition that a Euler graph is a graph where each vertex has even degrees, so what if we considered that the graph was unconnected?\n```\nA---C   E---G\n|   |   |   |\nB---D   F---H\n```\n\nTo run DFS on different components - there would need to be a step prior to #1 which discovers the complete graph.\nThe following graph would also not work as the algo would take the path: {0,3,4,7,1,3,2,1,0} missing 5,6.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Printing the shortest path in a directed graph\r\n                \r\nI have a directed, cyclic graph without weights. I want to find the shortest route between A and B (i.e. the one with the least hops).\n\nThis is the code i got so far:\n\n```\npath(A,B) :- walk(A,B,[]).\n\nwalk(A,B,V) :- edge(A,X), not(member(X,V)), (B=X); walk(X,B,[A|V]).\n\nedge(a, b).\nedge(b, c).\nedge(a, d).\nedge(c, a).\n```\n\n\nThis code prints true, once for every route it finds. How can i print the path? And what would i have to do to find the path with the least hops?\n    ", "Answer": "\r\nYou need to unify an extra argument with what you have accumulated in ```\nV```\n once you reach your termination condition:\n\n```\npath(A,B,P) :- walk(A,B,[],P).\n\nwalk(B,B,V,P) :- reverse(V,P).\nwalk(A,B,V,P) :- dif(A,B), edge(A,X), maplist(dif(X),V), walk(X,B,[A|V],P).\n```\n\n\nOnce ```\nA```\n and ```\nB```\n are the same, it means that we don't have to walk the graph anymore. In that case we reverse the path that we accumulated in ```\nV```\n as ```\nP```\n, which gets \"returned\" from ```\npath/3```\n.\n\nNote: it is almost always clearer to put the code that checks the recursion termination as a separate rule, instead of using ```\n;```\n.\n\nTo find the path with the least hops, you can find all paths from the two points you want, and then take the smallest one:\n\n```\nshortest_path(A,B,S) :-\n    findall(P, path(A,B,P), Ps),\n    maplist(prepend_length, Ps, Ls),\n    sort(Ls, [[_,S]|_]).\n\nprepend_length(P, [L,P]) :-\n    length(P,L).\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to cover maximum number of nodes via given path in a graph?\r\n                \r\nI am trying to find out the maximum number of covered nodes via a path in a given graph. I have made a program using recursion but it is giving answer only for some simple graph not on complicated graph.\n\nInput is given in a string array like 1#2: means node 1 is connected to node 2 or vice-versa.\n\nI have made a matrix of total nodes size and if node is connected set 1 else -1 in matrix. This matrix is used to calculate maximum covered node in path.\n\nCode:\n\n```\nimport java.io.*;\nimport java.util.*; \n\npublic class Medium \n{ \n public static int node_covered;\n public static int big=0;\n public static boolean[] visited;\n public static int matrix_length;\n public static String[][] matrix;\n\n public static String[] input=new String[]\n //answer is 7.\n{\"1#2\", \"2#3\",\"3#4\",\"3#5\",\"5#6\",\"5#7\",\"6#7\",\"7#8\"};\n\npublic static void main(String[] args){\n      int total_nodes=maxno_city(input);\n      System.out.println(total_nodes);\n  }\n\npublic static int maxno_city(String[] input1)\n{\nint ln=input1.length;\nHashSet hs = new HashSet();\n\nfor(int i=0; i<ln;i++)\n{\n    String[] temp=input1[i].split(\"#\");     \n    hs.add(temp[0]);        \n    hs.add(temp[1]);    \n}\n\nmatrix_length=hs.size();\nhs.clear();\nmatrix=new String[matrix_length][matrix_length];\n//initialize matrix\nfor (String[] row : matrix)\n     Arrays.fill(row, \"-1\");\n\n//System.out.println(Arrays.deepToString(matrix));\n\nfor(int i=0;i<matrix_length;i++)\n{\n    for(int j=0; j<matrix_length;j++)\n    {\n        String[] temp=input1[i].split(\"#\");\n        int first=Integer.parseInt(temp[0])-1;\n        int second=Integer.parseInt(temp[1])-1;\n        matrix[first][second]=\"1\";\n        matrix[second][first]=\"1\";\n    }\n}\n//System.out.println(Arrays.deepToString(matrix));\n//initialized\n//now start work on matrix\nfor(int i=0;i<matrix_length;i++)\n{\n    for(int j=0; j<matrix_length;j++)\n    {\n        visited=new boolean[matrix_length];\n        if(matrix[i][j].equals(\"1\"))\n        {\n            node_covered=0;\n            getNextPath(j,i);\n            //visited[i]=true;\n        }   \n    }\n}\n    return big;\n}\n\n//recursive method\npublic static void getNextPath(int path,int visited_node)\n{\n    boolean flag=false;\n    visited[visited_node]=true;\n    node_covered++;\n    for(int i=0;i<matrix_length;i++)\n    {\n        if(matrix[path][i].equals(\"1\") && visited[i]==false)\n        {\n            //visited[i]=true;\n            flag=true;\n            getNextPath(i,path);\n            //visited[i]=false;\n        }\n    }\n    if(flag==false)\n    {\n        if(big<node_covered)\n        {\n            big=node_covered;\n            //System.out.println(big);\n        }\n    }\n    else\n    {\n        node_covered--;\n    }\n    //visited[path]=false;\n }\n}\n```\n\n\nWhere I am doing mistake in above code?\n    ", "Answer": "\r\nYour main issue is that you do not store the complete matrix. This loop:\n\n```\nfor(int i=0;i<matrix_length;i++)\n{\n    for(int j=0; j<matrix_length;j++)\n    {\n        String[] temp=input1[i].split(\"#\");\n        int first=Integer.parseInt(temp[0])-1;\n        int second=Integer.parseInt(temp[1])-1;\n        matrix[first][second]=\"1\";\n        matrix[second][first]=\"1\";\n    }\n}\n```\n\n\ndoes not correctly iterate over ```\ninput1```\n to populate ```\nmatrix```\n. By consequent, the last inputs are ignored (you can also see that ```\nj```\n is not used at all within the inner loop). You should thus change it to a correct iteration:\n\n```\nfor (int i = 0; i < input1.length; i++)\n{\n    String[] temp = input1[i].split(\"#\");\n    int first = Integer.parseInt(temp[0]) - 1;\n    int second = Integer.parseInt(temp[1]) - 1;\n    matrix[first][second] = \"1\";\n    matrix[second][first] = \"1\";\n}\n```\n\n\n(You may also want to improve it further to a foreach loop since you don't need the value of ```\ni```\n)\n\nI discovered this by debugging your code and figuring out that it does not recurse into some nodes, and then I figured that ```\nmatrix```\n was incomplete. You should print ```\nmatrix```\n to check whether it is correct.\n\nSome other issues:\n\n\nYou must reset your ```\nvisited```\n array when backtracking, otherwise you will not evaluate 2 different paths that go through the same node (uncomment ```\nvisited[path]=false;```\n)\nYou do not need the ```\nflag```\n: in both cases, you should check if you have a new \"high score\" and decrease ```\nnode_covered```\n before leaving the loop\nYour code will fail if there is a city that is not connected to the rest of the graph, because your ```\nSet hs```\n will be too small. Try to look for the node with the highest number instead.\n\n\nSome possible improvements:\n\n\nConvert ```\nmatrix```\n to a ```\nboolean```\n matrix. This will also remove the need to initialize it.\nYou do not need 2 parameters for ```\ngetNextPath()```\n. Try to do everything you need with ```\nvisited_node```\n at the calling place. You should then be able to simplify it further.\nIf you manage to reduce it to 1 parameter, you will not need 2 nested ```\nfor```\n loops to initiate the recursion.\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "determine if the shortest path in a graph is unique\r\n                \r\nSay I have a cyclic graph containing bi-directional and parallel edges e.g.\n\nAssume all edge weights equal 1.\n\nHow would I determine if the shortest path is a unique path?\nHow would I determine if the shortest path that satisfies an edge or node invariant is a unique path? (e.g. Artemis to Egglesberg, only blue edges)\nHow would I determine if the shortest path that satisfies a path invariant is a unique path? (e.g. Artemis to Egglesberg, must go through Dentana)\n\nPotential solution:\n\nSet all the edge weights in the shortest path equal to the total number of edges in the graph\nIf the new shortest path is identical to the old path, then the path is unique.\n\nHowever, I haven't tested this solution and it may not be optimal.\nEDIT: this approach seems to work with the caveat that it will throw away cycles back to the starting node e.g. class-> material is considered unique b/c class->professor->address->student->class_student->class->material introduces a cycle back to the starting node.  this cyclic path is treated as invalid.\n\nNon-goals: finding all paths, finding the longest path.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Enumerate all paths from a single source in a graph\r\n                \r\nI was wondering if you are aware of an algorithm to enumerate all possible simple paths in a graph from a single source, without repeating any of the vertices. keep in mind that the graph will be very small (16 nodes) and relatively sparse (2-5 edges per node). \n\nTo make my question clear:\n\nVertices: A,B,C\n\n```\nA connects to B, C\nB connects to A, C\nC connects to A, B\n```\n\n\nPaths (from A):\n\n```\nA,B\nA,C\nA,B,C\nA,C,B\n```\n\n\nVertices: A,B,C,D\n\n```\nA connects to B, C\nB connects to A, C, D\nC connects to A, B, D\n```\n\n\nPaths (from A):\n\n```\nA,B\nA,C\nA,B,C\nA,B,D\nA,C,B\nA,C,D\nA,B,C,D\nA,C,B,D\n```\n\n\nIt is surely not BFS or DFS, although one of their possible variants might work. Most of the similar problems I saw in SO, were dealing with pair of nodes graphs, so my problem is slightly different. \n\nAlso this Find all possible paths from one vertex in a directed cyclic graph in Erlang is related, but the answers are too Erlang related or it is not clear what exactly needs to be done. As I see, the algorithm could be alternatively be decribed as find all possible simple paths for a destined number of hops from a single source. Then for number of hops (1 to N) we could find all solutions.\n\nI work with Java but even a pseudocode is more than enough help for me. \n    ", "Answer": "\r\nIn Python style, it is a BFS with a different tracking for visited:\n\n```\nMultiplePath(path, from):\n  from.visited = True\n  path.append(from)\n  print(path)\n\n  for vertex in neighbors(from):\n    if (not vertex.visited):\n      MultiplePath(path, vertex)\n\n  from.visited = False\nReturn\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Breadth First Search for searching all paths between any two nodes in a cyclic Graph\r\n                \r\nI am trying to use BFS for getting all paths between two nodes in a cyclic Graph.\nI found BFS doesnt't keep track its previous node, so need to add some other collection to achieve the same.\n\n\n  Question is - Should we avoid using BFS to get all paths in a node and\n  use DFS or BFS can  as well give a potential solution.\n\n\nIf its there please provide me the logic for the same.\n    ", "Answer": "\r\nI'll assume you only want to find simple paths (with no cycles), otherwise there could be infinite paths. If this is not a requirement, either BFS or DFS would theoretically work (though DFS would just keep exploring one cycle and never find other shorter paths), but lifting this requirement doesn't really make sense.\n\nWith both BFS and DFS you should have a processed flag per node to prevent infinitely many paths in cyclic graphs.\n\nConsider the following:\n\n```\nA with children B, C\nB with children C, D\nC with children B, D\n```\n\n\nWith BFS, you'd miss A -> C -> B -> D because B would have been marked as processed before processing C.\n\nWith DFS, this wouldn't be a problem, because the processed flag should be reset when ascending back up the tree.\n\nYou could keep track of the entire path so far for each node, but this is not viable since it would require a lot of extra storage space and time.\n\nYou could get rid of the processed flag for BFS and stop processing when number of nodes in the path > number of nodes in the tree, and remove all non-simple paths from the output.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Efficient calculations of paths with shared subpaths in directed graph\r\n                \r\nI need a recommendation for an efficient datastructure that suits my problem of calculating the path costs inside a directed graph under the contraint, that many paths sometimes share a same subpath for which I do not want to make the calculations twice.\n\nEach number in these lists are refering to a node inside a directed graph. Each line describes one path:\n\n```\n[121, 85, 135, 99, 141, 134, 4, 33, 65, 131, 18, 127],\n[121, 85, 135, 99, 141, 134, 65, 33, 4, 127],\n[121, 85, 135, 99, 141, 134, 65, 33, 4, 131, 18, 127],\n[121, 85, 135, 99, 141, 134, 65, 33, 4, 107, 127],\n[121, 85, 135, 99, 141, 134, 65, 23, 18, 127],\n[121, 85, 135, 99, 141, 134, 65, 23, 18, 131, 4, 127],\n[121, 85, 135, 99, 141, 134, 65, 23, 18, 131, 4, 107, 127],\n[121, 85, 135, 99, 141, 134, 65, 107, 4, 127],\n[121, 85, 135, 99, 141, 134, 65, 107, 4, 131, 18, 127],\n[121, 85, 135, 99, 141, 134, 65, 107, 127],\n[121, 85, 135, 99, 141, 134, 65, 131, 18, 127],\n[121, 85, 135, 99, 141, 134, 65, 131, 4, 127],\n[121, 85, 135, 99, 141, 134, 65, 131, 4, 107, 127],\n[121, 85, 135, 99, 141, 4, 127],\n...\n```\n\n\nAs one can see in this example many paths share the same subset of nodes along the way. (And many other paths [not shown here] do not share a subpath.)\n\nI want to compute the 'optimality' of each path, i.e. the sum OR products of the weights along the way. These weights can be seen as constant for my graph while traversing each path.\n\nTo be clear: I want to avoid calculating the weight of the path from node 121 to node 141 for all shown paths in this example, as these multiplications / additions of the weights between two nodes is the same (up to node 141) in each of the shown paths...\n\nI am satisfied with a datastructure recommendation and explanation why the mentioned datastructure is best suited for my needs.\nIf you also have a library recommendation I would prefer one in C/C++ or Python.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "how to merge multipath in one single path to create a Graph [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have this multipath:\n\n```\n[4876,12282,19222]\n[4876,12282,19240]\n[4876,12282,19254]\n[4876,12282,19681]\n[4876,12282,20222]\n[4876,12282,20347]\n[4876,12282,2401,159]\n[4876,12282,2401,14174]\n[4876,12282,2401,18407]\n[4876,12282,14691,7865]\n[4876,12282,7318,10314]\n[4876,12282,17452,12152]\n[4876,12282,14917,794]\n[4876,12282,2401,9463]\n[4876,12282,2401,18576]\n[4876,12282,14691,7865,9496]\n[4876,12282,14691,3722]\n[4876,12282,14691,4216]\n```\n\n\nI want to merge them in a single path with keeping the edges incident order to create a graph. I am a pretty new in Graph and Network Algorithms area. any help will be highly appreciated  \n    ", "Answer": "\r\nI used ```\nsparse```\n to create an adjacency matrix:\n\n```\nmp{1} = [4876,12282,19222];\nmp{2} = [4876,12282,19240];\nmp{3} = [4876,12282,19254];\nmp{4} = [4876,12282,19681];\nmp{5} = [4876,12282,20222];\nmp{6} = [4876,12282,20347];\nmp{7} = [4876,12282,2401,159];\nmp{8} = [4876,12282,2401,14174];\nmp{9} = [4876,12282,2401,18407];\nmp{10} = [4876,12282,14691,7865];\nmp{11} = [4876,12282,7318,10314];\nmp{12} = [4876,12282,17452,12152];\nmp{13} = [4876,12282,14917,794];\nmp{14} = [4876,12282,2401,9463];\nmp{15} = [4876,12282,2401,18576];\nmp{16} = [4876,12282,14691,7865,9496];\nmp{17} = [4876,12282,14691,3722];\nmp{18} = [4876,12282,14691,4216];\n% get all connections\nidx1 = cell2mat(cellfun(@(x) x(1:end-1),mp,'UniformOutput',0));\nidx2 = cell2mat(cellfun(@(x) x(2:end),mp,'UniformOutput',0));\n% remove duplicates\nidxs = unique([idx1(:),idx2(:)],'rows');\n% get max element index\nmaxIdx = max(idxs(:));\n% create adjacency matrix and undirected graph\nA = sparse( idxs(:,1),idxs(:,2),ones(size(idxs,1),1),maxIdx,maxIdx );\nG = graph(A | A');\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Program to find number of hamiltonian paths in a graph given start and end points\r\n                \r\nGiven a graph with n² pathing nodes, and given that the starting node is always in the top right corner (point A) and the ending node is always in the bottom right corner (point B), I need to write a C# program that will determine the number of hamiltonian paths from A to B given n (assuming n <=10). In other words, I need to find every path starting at A and ending at B, where each node is visited once and only once, and movement among the nodes is restricted to left, right, up, down (no diagonals).\n\nFor example, if n = 5, then one possible path would be the one shown in this image:\n\n\n\nIdeally, I would like to develop an intelligent algorithm that utilizes some heuristics, but for now I just need to develop a brute force method to start with. I am assuming that I use a breadth first search, but I really don't know where to begin in implementing that using C#.\n    ", "Answer": "\r\nSome bruteforce thing\n\nBuild the Graph.\nBuild a Graph runner.\nCache all Runinformation.\nMake the runner rerun the graph and exclude all decisions from the Runinformation.\nWhen the runner cant run anymore filter the cached data and count the result.\n\nImplementing in C#\n\nInstall a testframework like nunit.\nwrite a list of features you need.\n\nrepeat until featurelist is empty:\n\n\nselect the smallest feature\nwrite a failing test\nwrite code to pass the test\nensure all tests pass\nrefactor to make pritty\nclear item from featurelist\n\n\ndone\n\n\n\nEdited to answer some of the questions in the comments\n\n\nYou can download nunit from the internet. Unpack it to a folder of your choice.\nCreate an empty console application. \nExplore the NUnit directory to find the framework, add that framework to your project.\nExplore the NUnit directory to find the gui runner, add it to your project. \nWe actually dont want to run the project with a console, we just dont want a form to be autocreated, open the properties and redeclare your project to be a windows application.\nreplace your program.cs with the code below.\ncompile and run. click run in the gui and press F5 if exceptions come up\ncongratulations - you just used nunit\n\n\nHere is the program:\n\n```\nusing System;\nusing NUnit.Framework;\nnamespace EC_Connect_Test\n{\n    class Program\n    {\n        [STAThread]\n        static void Main(string[] args)\n        {\n            string fullPath = System.Reflection.Assembly.GetAssembly(typeof(Program)).Location;\n            NUnit.Gui.AppEntry.Main(new string[] { fullPath });\n        }\n    }\n        public class MathClass\n        {\n            internal static double Divide(int A, int B)\n            {\n                if (B == 0) throw new DivideByZeroException();\n                return (Double)A / (Double)B;\n            }\n        }\n\n        [TestFixture]\n        class MyFirstTestClass\n        {\n            [Test]\n            public void DividingTwoIntegersResultIsDouble()\n            {\n                Double expected = 3.3;\n                Double actual = MathClass.Divide(33, 10);\n                Assert.AreEqual(expected, actual);\n            }\n\n            [Test]\n            public void DividingByZeroShouldThrow()\n            {\n                Assert.Throws<DivideByZeroException>(\n                    () => { MathClass.Divide(33, 0); }\n                );\n            }\n        }\n\n    }\n```\n\n\nYou can also start Nunit externally and give it your debugproject as a directory. That way exceptions dont come up and testing gets easier.\n\nA featurelist is simply the things you want your software to do. In your case you are supplied with a given graph in some form. That could be a file or a piece of paper. So one feature is to loading that information and making a graph from it. The next feature you mentioned is that your program should check n<=10 and refuse to work if it isnt so, thats a feature too. Another one is to return the results through a given interface. And last not least is the ability to actually find all connections. If you list those for yourself you can select the one you think is easiest and start with that one. \n\nWhen testing dont forget to create end to end tests for known cases. so fixed graph in, known number out.\n\nUsing the wild assumption your graph is in a textfile where each line lists ist connections to other lines you could write tests like this:\n\n```\n    [TestFixture]\n    class graphloadingSpex\n    {\n        String[] lines = new String[] {\n        \"2,3,4\",\n        \"1\",\n        \"1,4\",\n        \"1,3\"\n        };\n\n        [Test]\n        public void ShouldShowConnectionsAfterLoading()\n        {\n            Graph tested = new Graph(lines);\n            Assert.AreEqual(new String[] { \"2\", \"3\", \"4\" }, tested[\"1\"].GetConnextions());\n            Assert.AreEqual(new String[] { \"1\"}, tested[\"2\"].GetConnextions());\n            Assert.AreEqual(new String[] { \"1\", \"4\" }, tested[\"3\"].GetConnextions());\n            Assert.AreEqual(new String[] { \"1\", \"3\" }, tested[\"4\"].GetConnextions());\n        }\n    }\n```\n\n\nThis will not compile since Graph does not exist yet. But getting it to compile and making the test pass would satisfy your first feature and you could go on implementing the next one by writing the test first.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "infinite loop while looking for all the paths in a graph in python\r\n                \r\nthis is the dictionary I'm using:\n\n```\n{\n    'timar': ['rimar', 'timas'], \n    'lares': ['pares', 'mares', 'laves'], \n    'lomas': ['lamas', 'limas', 'lemas'], \n    'gemas': ['lemas', 'remas', 'gimas'], \n    'lamas': ['lavas', 'latas', 'limas', 'lomas', 'lemas'], \n    'rimar': ['remar', 'timar', 'rimas'], \n    'lavas': ['laves', 'latas', 'lamas'], \n    'rimas': ['rimar', 'remas', 'timas', 'gimas', 'limas'], \n    'lemas': ['lomas', 'lamas', 'remas', 'limas', 'gemas'], \n    'mesas': [], \n    'remas': ['remos', 'rezas', 'remar', 'lemas', 'gemas', 'rimas'], \n    'pares': ['mares', 'lares'], \n    'teñir': ['reñir', 'tañir'], \n    'ceras': [], \n    'regar': ['rogar', 'regir', 'retar', 'rezar', 'remar'], \n    'remos': ['rezos', 'remas'], \n    'moras': [], \n    'regir': ['regar', 'reñir'], \n    'rezar': ['regar', 'rezas', 'retar', 'remar'], \n    'rezos': ['rezas', 'remos'], \n    'broma': [], \n    'lapiz': [], \n    'reñir': ['regir', 'teñir'], \n    'mares': ['pares', 'lares'], \n    'tocas': [], \n    'remar': ['remas', 'regar', 'rezar', 'retar', 'rimar'], \n    'timas': ['timar', 'limas', 'gimas', 'rimas'], \n    'laves': ['lares', 'lavas'], 'tañir': ['teñir'], \n    'bogar': ['rogar'],\n    'gimas': ['gemas', 'timas', 'limas', 'rimas'], \n    'latas': ['lavas', 'lamas'], \n    'rogar': ['bogar', 'regar'], \n    'rezas': ['rezar', 'rezos', 'remas'], \n    'retar': ['regar', 'rezar', 'remar'], \n    'limas': ['lamas', 'lomas', 'lemas', 'timas', 'gimas', 'rimas']\n}\n```\n\n\nAnd this is the code I'm using to find the paths\n\n```\ndef busqueda(self, start_vertex, end_vertex, path=[]):\n    \"\"\" find all paths from start_vertex to end_vertex in graph \"\"\"\n    print (start_vertex)\n    graph = self.diccionario\n    path = path + [start_vertex]\n    if start_vertex == end_vertex:\n        return [path]\n    if start_vertex not in graph:\n        return []\n    paths = []\n    for vertex in graph[start_vertex]:\n        if vertex not in path:\n            extended_paths = self.busqueda(vertex, end_vertex, path)\n            for p in extended_paths: \n                paths.append(p)\n    return paths\n```\n\n    ", "Answer": "\r\nI find these search problems to be easier to do with a stack than recursively.\nWith very connected graphs you will find the number of paths increases exponentially with the number of nodes.\n\nBut here's a quick ```\ndfs```\n on your graph:\n\n```\ndef dfs(graph, start, end):\n    stack = [[start]]\n    while stack:\n        path = stack.pop()\n        if path[-1] == end:\n            yield path\n            continue\n        for next_state in graph[path[-1]]:\n            if next_state in path: # Stop cycles\n                continue\n            stack.append(path+[next_state])\n\n>>> paths = list(dfs(graph, 'mares', 'tañir'))\n>>> len(paths)\n12012\n>>> paths[0]\n['mares', 'lares', 'laves', 'lavas', 'lamas', 'lemas', 'gemas', 'gimas',\n 'rimas', 'limas', 'timas', 'timar', 'rimar', 'remar', 'retar', 'rezar',\n 'regar', 'regir', 'reñir', 'teñir', 'tañir']\n>>> max(paths, key=len)\n['mares', 'pares', 'lares', 'laves', 'lavas', 'latas', 'lamas', 'lemas',\n 'lomas', 'limas', 'rimas', 'rimar', 'timar', 'timas', 'gimas', 'gemas',\n 'remas', 'remos', 'rezos', 'rezas', 'rezar', 'remar', 'retar', 'regar',\n 'regir', 'reñir', 'teñir', 'tañir']\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Ancestry path with 'path_id' or 'group_id\" and 'level' in graph SQL Server 2008\r\n                \r\nI have the following table:\n\n```\npairID  source_issue_id   destination_issue_id\n----------------------------------------------\n1          J                I\n2          B                C\n3          J                M\n4          F                I\n5          A                B\n6          A                E\n7          N                O\n8          J                L\n9          C                D\n10         P                Q\n11         G                H\n12         B                F\n13         L                K\n14         C                N\n15         A                G\n16         E                F\n```\n\n\nRepresenting nodes in a graph. \n\nI'm not using ```\npairID```\n, since does not seem useful.\n\nI want to get the ancestor path for all nodes, the level at which each pair occurs, the full path, and the 'path group'\n\nSo far I've used the following code:\n\n```\n;with auxPairs as \n(\n    select \n        1 as lvl, \n        b.source_issue_id, \n        b.destination_issue_id, \n        cast((b.source_issue_id+ '|' + b.destination_issue_id) as varchar(50)) as \"full_path\"\n    from \n        Pairs2 b\n    where\n        b.source_issue_id not in (select destination_issue_id from Pairs2)\n\n    union all\n\n    select \n        lvl+1 as lvl, \n        c.source_issue_id, \n        c.destination_issue_id,\n        CAST((a.full_path + '|' + c.destination_issue_id) as varchar(50)) as \"full_path\" \n    from \n        Pairs2 c\n    join \n        auxPairs a on a.destination_issue_id = c.source_issue_id\n)\n```\n\n\nThat returns the 'connection level' of two nodes (e.g. A|B is level 1) in ```\nlvl```\n, the source and destination nodes and the full path (up to that pair), e.g. \n\n```\nlvl   source   destination   full_path\n--------------------------------------\n1     A        B             A|B\n2     B        C             A|B|C\n3     C        N             A|B|C|N\n4     N        O             A|B|C|N|O\n1     A        B             A|B\n2     B        C             A|B|C\n3     C        D             A|B|C|D\n....\n```\n\n\nand so on for each path in the tree.\n\nI need to add to this a ```\nPath_id```\n or ```\ngroup_id```\n so I get:\n\n```\npath_id   lvl   source   destination   full_path\n------------------------------------------------\n1         1     A        B             A|B\n1         2     B        C             A|B|C\n1         3     C        N             A|B|C|N\n1         4     N        O             A|B|C|N|O\n2         1     A        B             A|B\n2         2     B        C             A|B|C\n2         3     C        D             A|B|C|D\n....\n```\n\n\nmeaning that the nodes with the same path_id are connected in a given order\n\nNOTE: The alphabetical 'fake\" order will not work with actual data. I need to use the ```\npath_id```\n and ```\nlvl```\n to establish the partial order within the path.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find all distinct paths in a directed graph and compute minimal cost\r\n                \r\nWe have the following Oracle table:\n\n```\nCREATE TABLE graph\n( company VARCHAR2(10)\n, from VARCHAR2(15)\n, to VARCHAR2(15)\n, cost NUMBER(18,2));\n```\n\n\nWith the following data:\n\n```\nINSERT INTO graph VALUES('Lufthansa', 'San Francisco', 'Denver', 1000);\nINSERT INTO graph VALUES('Lufthansa', 'San Francisco', 'Dallas', 10000);\nINSERT INTO graph VALUES('Lufthansa', 'Denver', 'Dallas', 500);\nINSERT INTO graph VALUES('Lufthansa', 'Denver', 'Chicago', 2000);\nINSERT INTO graph VALUES('Lufthansa', 'Dallas', 'Chicago', 600);\nINSERT INTO graph VALUES('Lufthansa', 'Dallas', 'New York', 2000);\nINSERT INTO graph VALUES('Lufthansa', 'Chicago', 'New York', 3000);\nINSERT INTO graph VALUES('Lufthansa', 'Chicago', 'Denver', 2000);\n```\n\n\nWe are asked to create a table:\n\n```\nCREATE TABLE paths\n( from VARCHAR2(15)\n, to VARCHAR2(15)\n, minimal_cost NUMBER);`\n```\n\n\nWhere a row in table ```\npaths```\n should indicate that \"I can reach ```\nX```\n from ```\nY```\n and in the lowest cost ```\nC```\n.\n\nWhat I've tried so far:\n\n```\nINSERT INTO paths (\"from\", \"to\")\nSELECT     DISTINCT CONNECT_BY_ROOT \"from\" AS \"From\", \"to\" AS \"To\"\nFROM       graph\nSTART WITH \"from\" in (SELECT \"from\" FROM graph) \nCONNECT BY NOCYCLE PRIOR \"to\" = \"from\";\n```\n\n\n(I have renamed table names and attributes from my language, so there might be syntax errors if you try to run the statements directly.)\n\nTo above statement creates duplicates in almost every way. Also, I've got no idea, how ```\ncost```\n should be computed. Do I need to create a ```\nPL/SQL```\n procedure? Does Oracle support these kind of queires?\n    ", "Answer": "\r\nThrough a little abuse of ```\nSYS_CONNECT_BY_PATH```\n and a function to use regular expressions to extract numbers from a list you can do:\n\nSQL Fiddle\n\nOracle 11g R2 Schema Setup:\n\n```\nCREATE TABLE graph\n( company VARCHAR2(10)\n, \"from\" VARCHAR2(15)\n, \"to\" VARCHAR2(15)\n, cost NUMBER(18,2))\n/\n\nBEGIN\n  INSERT INTO graph VALUES('Lufthansa', 'San Francisco', 'Denver', 1000);\n  INSERT INTO graph VALUES('Lufthansa', 'San Francisco', 'Dallas', 10000);\n  INSERT INTO graph VALUES('Lufthansa', 'Denver', 'Dallas', 500);\n  INSERT INTO graph VALUES('Lufthansa', 'Denver', 'Chicago', 2000);\n  INSERT INTO graph VALUES('Lufthansa', 'Dallas', 'Chicago', 600);\n  INSERT INTO graph VALUES('Lufthansa', 'Dallas', 'New York', 2000);\n  INSERT INTO graph VALUES('Lufthansa', 'Chicago', 'New York', 3000);\n  INSERT INTO graph VALUES('Lufthansa', 'Chicago', 'Denver', 2000);\nEND;\n/\n\nCREATE TABLE paths\n( \"from\" VARCHAR2(15)\n, \"to\" VARCHAR2(15)\n, minimal_cost NUMBER)\n/\n\nCREATE OR REPLACE FUNCTION sum_costs (\n  vals VARCHAR2\n) RETURN NUMBER\nAS\n  num_vals SIMPLE_INTEGER := REGEXP_COUNT( vals, '\\d+' );\n  total graph.cost%TYPE := 0;\nBEGIN\n  FOR i IN 1 .. num_vals LOOP\n    total := total + TO_NUMBER( REGEXP_SUBSTR( vals, '\\d+', 1, i ) );\n  END LOOP;\n  RETURN total;\nEND;\n/\n```\n\n\nQuery 1:\n\n```\nWITH costs AS (\n  SELECT     CONNECT_BY_ROOT \"from\" AS \"from\",\n             \"to\",\n             sum_costs( SYS_CONNECT_BY_PATH ( cost, ',' ) ) AS total_cost\n  FROM       graph\n  WHERE      CONNECT_BY_ROOT \"from\" <> \"to\"\n  CONNECT BY NOCYCLE PRIOR \"to\" = \"from\"\n)\nSELECT \"from\",\n       \"to\",\n       MIN( total_cost )\nFROM   costs\nGROUP BY \"from\", \"to\"\n```\n\n\nResults:\n\n```\n|          FROM |       TO | MIN(TOTAL_COST) |\n|---------------|----------|-----------------|\n|        Dallas |  Chicago |             600 |\n|       Chicago | New York |            3000 |\n|       Chicago |   Denver |            2000 |\n| San Francisco |   Denver |            1000 |\n|        Dallas | New York |            2000 |\n|        Denver |  Chicago |            1100 |\n| San Francisco | New York |            3500 |\n|        Denver |   Dallas |             500 |\n|        Dallas |   Denver |            2600 |\n|        Denver | New York |            2500 |\n| San Francisco |   Dallas |            1500 |\n| San Francisco |  Chicago |            2100 |\n|       Chicago |   Dallas |            2500 |\n```\n\n\nAnd this gets an optimal route for each pair of destinations as well:\n\nQuery 2:\n\n```\nWITH costs AS (\n  SELECT     CONNECT_BY_ROOT \"from\" AS \"from\",\n             \"to\",\n             SUBSTR( SYS_CONNECT_BY_PATH ( \"from\", ',' ), 2 ) || ',' || \"to\" AS route,\n             sum_costs( SYS_CONNECT_BY_PATH ( cost, ',' ) ) AS total_cost\n  FROM       graph\n  WHERE      CONNECT_BY_ROOT \"from\" <> \"to\"\n  CONNECT BY NOCYCLE PRIOR \"to\" = \"from\"\n)\nSELECT\n       \"from\",\n       \"to\",\n       MIN( route ) KEEP ( DENSE_RANK FIRST ORDER BY total_cost ) AS optimal_route,\n       MIN( total_cost ) AS minimum_cost\nFROM   costs\nGROUP BY \"from\", \"to\"\n```\n\n\nResults:\n\n```\n|          FROM |       TO |                        OPTIMAL_ROUTE | MINIMUM_COST |\n|---------------|----------|--------------------------------------|--------------|\n|        Dallas |   Denver |                Dallas,Chicago,Denver |         2600 |\n|        Dallas |  Chicago |                       Dallas,Chicago |          600 |\n|        Dallas | New York |                      Dallas,New York |         2000 |\n|        Denver |   Dallas |                        Denver,Dallas |          500 |\n|        Denver |  Chicago |                Denver,Dallas,Chicago |         1100 |\n|        Denver | New York |               Denver,Dallas,New York |         2500 |\n|       Chicago |   Dallas |                Chicago,Denver,Dallas |         2500 |\n|       Chicago |   Denver |                       Chicago,Denver |         2000 |\n|       Chicago | New York |                     Chicago,New York |         3000 |\n| San Francisco |   Dallas |          San Francisco,Denver,Dallas |         1500 |\n| San Francisco |   Denver |                 San Francisco,Denver |         1000 |\n| San Francisco |  Chicago |  San Francisco,Denver,Dallas,Chicago |         2100 |\n| San Francisco | New York | San Francisco,Denver,Dallas,New York |         3500 |\n```\n\n\nAnd a pure SQL solution:\n\nQuery 3:\n\n```\nWITH Routes AS (\n  SELECT     CONNECT_BY_ROOT \"from\" AS \"from\",\n             \"to\",\n             SUBSTR( SYS_CONNECT_BY_PATH ( \"from\", ',' ), 2 ) || ',' || \"to\" AS route,\n             cost\n  FROM       graph\n  WHERE      CONNECT_BY_ROOT \"from\" <> \"to\"\n  CONNECT BY NOCYCLE PRIOR \"to\" = \"from\"\n),\ncosts AS (\n  SELECT r.\"from\",\n         r.\"to\",\n         r.route,\n         SUM( s.cost ) AS total_cost\n  FROM   Routes r\n         INNER JOIN\n         Routes s\n         ON (    r.\"from\" = s.\"from\"\n             AND LENGTH( r.route ) >= LENGTH( s.route )\n             AND SUBSTR( r.route, 1, LENGTH( s.route ) ) = s.route )\n  GROUP BY r.\"from\", r.\"to\", r.route\n)\nSELECT \"from\",\n       \"to\",\n       MIN( route ) KEEP ( DENSE_RANK FIRST ORDER BY total_cost ) AS optimal_route,\n       MIN( total_cost )\nFROM   costs\nGROUP BY \"from\", \"to\"\n```\n\n\nResults:\n\n```\n|          FROM |       TO |                        OPTIMAL_ROUTE | MIN(TOTAL_COST) |\n|---------------|----------|--------------------------------------|-----------------|\n|        Dallas |   Denver |                Dallas,Chicago,Denver |            2600 |\n|        Dallas |  Chicago |                       Dallas,Chicago |             600 |\n|        Dallas | New York |                      Dallas,New York |            2000 |\n|        Denver |   Dallas |                        Denver,Dallas |             500 |\n|        Denver |  Chicago |                Denver,Dallas,Chicago |            1100 |\n|        Denver | New York |               Denver,Dallas,New York |            2500 |\n|       Chicago |   Dallas |                Chicago,Denver,Dallas |            2500 |\n|       Chicago |   Denver |                       Chicago,Denver |            2000 |\n|       Chicago | New York |                     Chicago,New York |            3000 |\n| San Francisco |   Dallas |          San Francisco,Denver,Dallas |            1500 |\n| San Francisco |   Denver |                 San Francisco,Denver |            1000 |\n| San Francisco |  Chicago |  San Francisco,Denver,Dallas,Chicago |            2100 |\n| San Francisco | New York | San Francisco,Denver,Dallas,New York |            3500 |\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding Longest Path in Directed Acyclic Graph\r\n                \r\nI need to find the longest path from node 0 for a set of Directed Acyclic Graphs. I am using the Longest Path Problem algorithm from Wikipedia. I have got the algorithm working for most graphs, but for others it doesn't give a correct result. The algorithm is:\n\n```\nprivate static int DAGLongestPath(Graph G) {\nint n = G.order();\nint[] topOrder = new int[n];\ntopOrder = topSort2(G);\n\nfor (int i = 0; i < topOrder.length; i++) {\n    topOrder[i] -= 1;\n}   \n\nint[] lengthTo = new int[n];\nfor (int i = 0; i < n; i++) lengthTo[i] = 0;\n\nfor (int i = 0; i < topOrder.length; i++) { //for each vertex v in topOrder(G) do\n    ArrayList<Integer> neighbors = new ArrayList<Integer>();\n    neighbors = G.neighbors(topOrder[i]);\n    int v = topOrder[i];\n    for (int j = 0; j < neighbors.size(); j++) {\n        int w = neighbors.get(j);\n        if(lengthTo[w] <= lengthTo[v] + 1) {\n            lengthTo[w] = lengthTo[v] + 1;\n        }\n    }   \n}   \n\nint max = 0;\nfor (int i = 0; i < n; i++ ) {\n    max = Math.max(max, lengthTo[i]);\n}\nreturn max;\n}\n```\n\n\nThe graph implementation uses an Adjacency List to store the graphs. If I pass a graph like:\n\n```\n9 // Number of nodes\n0: 1 2 \n1: 2 3 4\n2: 4 8\n3: 5 6\n4: 6 7 8\n5:\n6:\n7:\n8: 7\n```\n\n\nI get the answer 5, which is correct. However, if I pass the graph:\n\n```\n8 // Number of nodes\n0: 2 3\n1:\n2:\n3: 5\n4: 5\n5: 2\n6: 7\n7: 4\n```\n\n\nThen I get 2, when the correct answer should be 3.\n\nThe TopSort2 algorithm I am using is:\n\n```\npublic static int[] topSort2(Graph G){\n    int n = G.order();\n    int[] sort = new int[n];\n\n    int[] inDeg = new int[n];\n    for (int i=0; i<n; i++) inDeg[i] = G.inDegree(i);\n\n    int cnt = 0;\n    boolean progress = true;\n    //\n    while (progress){\n        progress = false;\n\n        for (int v=0; v<n; v++){\n            if (inDeg[v] == 0){\n                sort[v] = ++cnt;\n                progress = true;\n                inDeg[v] = -1;\n\n                ArrayList<Integer> nbrs = G.neighbors(v);\n                for (int u : nbrs){\n                    inDeg[u] = inDeg[u] - 1;\n                }\n            }\n        } // for v\n\n    } // while nodes exist with inDegree == 0.\n\n    return sort;\n}\n```\n\n\nDFS algorithms are:\n\n```\nprivate static int doDFS(Graph G, int v, int[] PreOrder, int[] PostOrder, countPair cnt){\n    PreOrder[v] = cnt.inc1();\n    int dfsTotal = 0;\n\n    ArrayList<Integer> nbrs = G.neighbors(v);\n    for (int i : nbrs) {\n        if (PreOrder[i] == 0) {\n            int dfsTemp = doDFS(G, i, PreOrder, PostOrder, cnt);\n            dfsTotal = Math.max(dfsTotal, dfsTemp);\n        }\n    }\n    PostOrder[v] = cnt.inc2();\n    if(nbrs.size() > 0 ) {\n        dfsTotal++;\n    }\n    return dfsTotal;\n}\n\npublic static int DFS(Graph G, int v, int[] PreOrder, int[] PostOrder){\n    int n = G.order();\n    int total = 0;\n    for (int i=0; i<n; i++) PreOrder[i] = PostOrder[i] = 0;\n\n    countPair cnt = new countPair();\n    total = doDFS(G, v, PreOrder, PostOrder, cnt);\n\n    return total;\n}\n\nprivate static class countPair {       // private counters for DFS search\n    int cnt1, cnt2;\n    int inc1() { return ++cnt1; }\n    int inc2() { return ++cnt2; }\n}\n```\n\n    ", "Answer": "\r\nI think the problem is your ```\ntopSort2()```\n function\n\nIn the ```\nint[] sort```\n returned by the function, the index denotes the vertex and the content denotes the order. i.e. if you have ```\nsort[1] = 2```\n, you mean vertex 1 is the second vertex\n\nHowever when you use it, you take the content as the vertex. i.e. you take ```\ntopOrder[i]```\n as a vertex, while actually ```\ni```\n should be the vertex\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "shortest Path in directed graph G\r\n                \r\nI had an exam yesterday and I would like to check if I was answering correctly on one of the questions.\n\nThe question:\n\nG = (V, E, w) is a directed, simple graph (V: set of vertices, E: set of edges, w: non-negative weight function). There is a non-empty subset of G denoted E(red).\nA path p in G will be called n-red if there are n red edges on p. d_red(u, v) will be the lightest path from vertex u to vertex v that is at least 1-red. If all paths from u to v are 0-red, d_red(u, v) = Infinity.\nThe weight of a path p is the sum of all edges that are part of p.\n\nInput:\nG = (V, E, w)\ns, t that are elements of V\nf_red: E -> { true, false }\nf_red(red edge) = true\nf_red(non-red edge) = false\n\nOutput:\nd_red(s, t) (the lightest path that includes at least one red edge).\n\nRuntime Constraint: O(V log V + E)\n\nIn a few words, my solution was to use Dijkstra's algorithm. A Boolean variable that is initially false is used to keep track of whether at least one red edge has been encountered. This is checked for every iteration with f_red and the variable is set to true if f_red(current edge) = true. If the variable is still false at the end, return d_red(u, v) = Infinity.\n\nWhat do you think about that?\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "SPARQL How can I find the shortest path through multiple nodes in a RDF graph\r\n                \r\nHow to use sparql to set multiple nodes and find the shortest path through each node? Cypher can be used achieve this function. However, I do not know how to achieve it by Sparql so that I can query paths in Jena.\n    ", "Answer": "\r\nThanks so much for your kindly help! Finally, I modified the java api function of jena (findShortestPath) to achieve this feature.\nFirst, in order to achieve the shortest path query between any two nodes (regardless of the direction of relationships), I modified the java api function of jena (findShortestPath) as follows.\n```\nprivate JSONObject findShortestPath(Model m, Resource start, Resource end) {\n        int shortestLength = 20;\n        JSONObject pathResult = new JSONObject();\n        pathResult.put(\"length\", shortestLength);\n        pathResult.put(\"paths\", new JSONArray());\n\n        List<OntTools.Path> bfs = new LinkedList<>();\n        ArrayList<ExtendedIterator> nodeStatementIter = new ArrayList<>();\n        nodeStatementIter.add(m.listStatements(start, null, (RDFNode)null));\n        nodeStatementIter.add(m.listStatements(null, null, start));\n        for (var iter : nodeStatementIter) {\n            while(iter.hasNext()) {\n                Statement statement = (Statement) iter.next();\n                if (! statement.getObject().isLiteral())\n                bfs.add((new OntTools.Path()).append(statement));\n            }\n        }\n        nodeStatementIter.clear();\n\n        HashSet<Resource> passedNodes = new HashSet<>();\n        passedNodes.add(start);\n\n        while(!bfs.isEmpty()) {\n            OntTools.Path candidate = bfs.remove(0);\n            if (candidate.size() > shortestLength) {\n                break;\n            }\n\n            Resource subject = candidate.getStatement(candidate.size() - 1).getSubject();\n            Resource object = candidate.getStatement(candidate.size() - 1).getObject().isResource() ? candidate.getStatement(candidate.size() - 1).getObject().asResource() : null;\n            ArrayList<Resource> resources = new ArrayList<>();\n            resources.add(subject);\n            if (object != null) {\n                resources.add(object);\n            }\n\n            if (resources.contains(end)) {\n//                solution = candidate;\n                shortestLength = candidate.size();\n                pathResult.put(\"length\", shortestLength);\n                pathResult.getJSONArray(\"paths\").add(pathToTriples(candidate));\n            } else {\n\n                for (Resource resource : resources) {\n                    if (! passedNodes.contains(resource)) {\n                        nodeStatementIter.add(m.listStatements(resource, null, (RDFNode)null));\n                        nodeStatementIter.add(m.listStatements(null, null, resource));\n                        passedNodes.add(resource);\n                        for (var iter : nodeStatementIter) {\n                            while(iter.hasNext()) {\n//                                Statement link = (Statement)iter.next();\n                                Statement statement = (Statement) iter.next();\n                                if (!candidate.contains(statement))\n                                    bfs.add(candidate.append(statement));\n                            }\n                        }\n                        nodeStatementIter.clear();\n                    }\n                }\n            }\n        }\n\n        if (pathResult.getJSONArray(\"paths\").size() == 0) {\n            pathResult.put(\"length\", Integer.MAX_VALUE);\n        }\n\n        return pathResult;\n    }\n\n```\n\nIn this function, another function is used to convert paths to triples\n```\nprivate ArrayList<ArrayList<String>> pathToTriples(OntTools.Path path) {\n        ListIterator<Statement> statementListIterator = path.listIterator();\n        ArrayList<ArrayList<String>> statements = new ArrayList<>();\n        while (statementListIterator.hasNext()) {\n            Statement next = statementListIterator.next();\n            statements.add(new ArrayList<>(){{\n                add(next.getSubject().toString());\n                add(next.getPredicate().toString());\n                add(next.getObject().toString());\n            }});\n        }\n        return statements;\n    }\n```\n\nFinally, in order to achieve the shortest path query through multiple specified nodes, I enumerated the possible combinations of the sequence of the nodes. Then, calculate the sum of the shortest path between every two nodes of each combination, and select all the combinations with the shortest total length as the final result.\n```\npublic JSONObject findShortestPathBetweenMultipleNodes(Model m, List<Resource> nodes) {\n        ArrayList<ArrayList<JSONArray>> nodePairPathMatrix = new ArrayList<>();\n        ArrayList<ArrayList<Integer>> nodePairLengthMatrix = new ArrayList<>();\n\n        for (int i = 0; i < nodes.size(); i++) {\n            nodePairPathMatrix.add(new ArrayList<>(){{\n                for (int j = 0; j < nodes.size(); j++) {\n                    add(null);\n                }\n            }});\n            nodePairLengthMatrix.add(new ArrayList<>(){{\n                for (int j = 0; j < nodes.size(); j++) {\n                    add(Integer.MAX_VALUE);\n                }\n            }});\n        }\n\n\n        for (int i = 0; i < nodes.size()-1; i++) {\n            for (int j = i+1; j < nodes.size(); j++) {\n                Resource source = nodes.get(i);\n                Resource target = nodes.get(j);\n                JSONObject shortestPath = findShortestPath(m, source, target);\n                JSONArray paths = shortestPath.getJSONArray(\"paths\");\n\n                nodePairPathMatrix.get(i).set(j, paths);\n                nodePairPathMatrix.get(j).set(i, paths);\n                nodePairLengthMatrix.get(i).set(j, shortestPath.getInteger(\"length\"));\n                nodePairLengthMatrix.get(j).set(i, shortestPath.getInteger(\"length\"));\n            }\n        }\n\n        ArrayList<ArrayList<Integer>> permutationsOfNodes = permutationByMaxNum(nodes.size());\n        Integer minLength = Integer.MAX_VALUE;\n        ArrayList<ArrayList<JSONArray>> nodePairPathListWithMinLength = new ArrayList<>();\n        for (var permutation : permutationsOfNodes){\n            Integer length = 0;\n            ArrayList<JSONArray> nodePairPathList = new ArrayList<>();\n            for (int permutationItemIndex = 1; permutationItemIndex < permutation.size(); permutationItemIndex++) {\n                int end = permutation.get(permutationItemIndex);\n                int start = permutation.get(permutationItemIndex-1);\n                Integer curNodePairLength = nodePairLengthMatrix.get(start).get(end);\n                if (curNodePairLength.equals(Integer.MAX_VALUE) || nodePairLengthMatrix.get(start).get(end).equals(Integer.MAX_VALUE)){\n                    length = Integer.MAX_VALUE;\n                    break;\n                }\n                length += nodePairLengthMatrix.get(start).get(end);\n                nodePairPathList.add(nodePairPathMatrix.get(start).get(end));\n            }\n            if (length < minLength) {\n                minLength = length;\n                nodePairPathListWithMinLength.clear();\n                nodePairPathListWithMinLength.add(nodePairPathList);\n            } else if (length.equals(minLength)) {\n                nodePairPathListWithMinLength.add(nodePairPathList);\n            }\n        }\n\n        Set<List<String>> tripleResults = new HashSet<>();\n        for (var equalTotalLengthNodePairPathListWithMinLength : nodePairPathListWithMinLength) {\n            for (var nodePairPathList : equalTotalLengthNodePairPathListWithMinLength) {\n                for (int i = 0; i < nodePairPathList.size(); i++) {\n                    JSONArray nodePairPathWithEqualLength = nodePairPathList.getJSONArray(i);\n                    for (int j = 0; j < nodePairPathWithEqualLength.size(); j++) {\n                        JSONArray nodePairPath = nodePairPathWithEqualLength.getJSONArray(j);\n                        List<String> triple = nodePairPath.toJavaList(String.class);\n                        tripleResults.add(triple);\n                    }\n                }\n            }\n        }\n        JSONObject result = new JSONObject();\n        result.put(\"triples\", tripleResults);\n        result.put(\"length\", minLength);\n\n        return result;\n    }\n```\n\nThe permutations of nodes are generated by the following functions.\n```\n    private ArrayList<ArrayList<Integer>> permutationByMaxNum (int maxNum) {\n        Stack<Integer> stack = new Stack<>();\n        ArrayList<ArrayList<Integer>> results = new ArrayList<>();\n\n        ArrayList<Integer> sourceList = new ArrayList<>();\n        for (int i = 0; i < maxNum; i++) {\n            sourceList.add(i);\n        }\n        permutateFunction(results, sourceList, maxNum, 0, stack);\n        return results;\n    }\n\n    private static void permutateFunction(ArrayList<ArrayList<Integer>> results, ArrayList<Integer> sourceList, int targetNumber, int curNumber, Stack<Integer> stack) {\n        if(curNumber == targetNumber) {\n//            System.out.println(stack);\n            results.add(new ArrayList<>(stack));\n            return;\n        }\n\n        for (int j : sourceList) {\n            if (!stack.contains(j)) {\n                stack.add(j);\n                permutateFunction(results, sourceList, targetNumber, curNumber + 1, stack);\n                stack.pop();\n            }\n        }\n    }\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "DFS and lexicographic path in directed graph?\r\n                \r\n\nGiven directed graph have N(1<=N<=10^5) vertices and M(1<=M<=10^6) edges, no loop-self. Given source vertex s and destination vertex t. Print lexicographical smallest path from s to t (Note: All nodes in this path are distinguish)\n\n\nFor example: We have N=4 and M=4 and E={{1,4},{4,2},{1,2},{2,3}}, s=1 and t=3. So the answer is 1->2->3.\n\n\nThis is my attemp: I used DFS-Algorithm to list all path from s to t. And add them into vector<vector>. Then, I sort it and print the first path. But I got TLE.\n\n\nNow, I don't know how to optimize this problem, can you help me this stuck\n\n\nThis is my code\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define maxn (ll)(1e5+5)\n#define pb push_back\nvector<ll> adj[maxn];\nvector<vector<ll>> poi;\nvector<ll> really;\nll n,m,i,j,s,d,u,v;\nvoid candy(vector<ll> yui){\n   poi.push_back(yui);\n   for(i=0;i<poi[0].size();i++) cout<<poi[0][i]+1<<\" \";\n   exit(0);\n\n}\nvoid aka(ll u, ll d, bool visited[], ll path[], ll &path_index){\n   visited[u]=true;\n   path[path_index]=u;\n   path_index++;\n   if(u==d){\n      really.clear();\n      for(ll i=0;i<path_index;i++)\n      really.push_back(path[i]);\n      candy(really);\n      return ;\n   }\n   else{\n    sort(adj[u].begin(),adj[u].end());\n    for(ll i=0;i<adj[u].size();i++)\n        if(!visited[adj[u][i]]) aka(adj[u][i],d,visited,path,path_index);\n   }\n   path_index--;\n   visited[u]=false;\n}\nvoid solve(ll s, ll d){\n   bool visited[maxn];\n   ll path[maxn];\n   ll path_index = 0;\n   for(ll i=0;i<n;i++) visited[i]=false;\n   aka(s,d,visited,path,path_index);\n}\nint main(){\n     ios_base::sync_with_stdio(false);\n\n cin.tie(NULL);\n\n cout.tie(NULL);\n    cin>>n>>m>>s>>d;\n    s--;\n    d--;\n    while(m--){\n        cin>>u>>v;\n        u--;v--;\n        adj[u].pb(v);\n    }\n    solve(s,d);\n   \n}\n```\n\n    ", "Answer": "\r\nInstead of getting all paths from ```\ns```\n to ```\nt```\n, you may try the following:\nOn every DFS call, assuming current node is ```\nn```\n, get all undiscovered neighbors of ```\nn```\n, sort them in increasing order and recursively call them starting from the smallest one.\nNote that there is no need to reset ```\nvisited```\n status prior to returning because the very first found path from ```\ns```\n to ```\nt```\n is the one we need (so we don't need to inspect any other paths)\nTwo base cases to consider:\n\none of neighbors of ```\nn```\n is ```\nt```\n\n```\nn```\n has no undiscovered neighbors\n\nTime complexity is ```\nO(V * VlogV + E)```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to keep track of path in BFS Graph search JavaScript\r\n                \r\nI am working on BFS algorithms and I'm having a hard time figuring out how to keep track of the shortest path.\nBelow the code I've used :\n```\nconst graph = {\n  1: [2, 3, 4],\n  2: [5, 6],\n  3: [10],\n  4: [7, 8],\n  5: [9, 10],\n  7: [11, 12],\n  11: [13],\n};\n\nfunction bfs(graph, start, end) {\n  let queue = [...graph[start]];\n  let path = [start];\n  let searched = [];\n  while (queue.length > 0) {\n    let curVert = queue.shift();\n    if (curVert === end) {\n      return path;\n    } else if (searched.indexOf(curVert) === -1 && graph[curVert]) {\n      queue = [...queue, ...graph[curVert]];\n      searched.push(curVert);\n      path.push(curVert);\n    }\n  }\n}\n\nconsole.log(bfs(graph, 1, 13));\n```\n\nwhat I would to get in return of the function call is the shortest path. In this case ```\n[1, 4, 7, 11, 13]```\n.\n    ", "Answer": "\r\nYou need to store the path for each visited node as well.\n\r\n\r\n```\nconst graph = { 1: [2, 3, 4], 2: [5, 6], 3: [10], 4: [7, 8], 5: [9, 10], 7: [11, 12], 11: [13] };\n\nfunction bfs(graph, start, end) {\n    let queue = [[start, []]],\n        seen = new Set;\n\n    while (queue.length) {\n        let [curVert, [...path]] = queue.shift();\n        path.push(curVert);\n        if (curVert === end) return path;\n\n        if (!seen.has(curVert) && graph[curVert]) {\n            queue.push(...graph[curVert].map(v => [v, path]));\n        }\n        seen.add(curVert);\n    }\n}\n\nconsole.log(bfs(graph, 1, 13));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Claims on shortest path between two node in graph?\r\n                \r\nif the shortest path between two vertex on weighted and directed graph ```\nG```\n (maybe has negative edge), is shown by ```\nD(u, v)```\n, the following claims is always false. \n\n\n  with having negative edges, but didn't have any negative cycle, then\n  Sigma on D(u,v) (sum on all vertex pairs) cannot be negative.\n\n\n```\nWhy this claims is False? \n```\n\n\n\n  what is ```\nD(u,v)```\n where there's no path from u to v is not given in my\n  notes, but I think ```\nD(u,v)=0```\n in this case.\n\n    ", "Answer": "\r\nAssuming ```\nD(u,v) = infinity```\n if there is no path from ```\nu```\n to ```\nv```\n (I really see no reason to assume otherwise, it is weird to assume ```\nD(u,v)=0```\n in this case), the claim is true.\n\nProof:\n\nFirst, assume there is a path for each pair ```\nu,v```\n - otherwise sum of all pairs is infinity, and we are done.\n\nFor each pair of vertices ```\nu,v```\n:\n\n\nIf ```\nD(u,v)>0```\n and ```\nD(v,u)>0```\n this pair contribute positive number to the summation\nOtherwise, and without loss of generality, assume ```\nD(u,v)<0```\n. Since there are no negative cycles, ```\nD(u,v) + D(v,u) >= 0```\n and thus ```\nD(v,u) >= -D(u,v)```\n. And as we see, ```\nD(v,u) + D(u,v)```\n  contribute a non negative number for the summation.\n\n\nSince the above is true for each pair ```\nu,v```\n - there is no pair that can contribute a negative number, and the summation cannot be negative.\n\nQED\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding the longest path In an unweighted graph\r\n                \r\ni'm having a really tough time with this issue.\nIf I have a graphh, directed or undirected, unweighted and no cycles. How do I find the longest path?\nMany algorithms I have seen rely on the graph being weighted, and reverse the weights and use bellman ford.\nI ahve also seen dynamic programming solutions, but here people were simply looking for any path, I'm looking for one from s-t.\nIve been trying to break down the graph into subproblems, where I add one node a a time and give it a value of the parent that it is coming from plus one, but I just canoot get the logic right\ncan anyone provide an algorithm, exponential time would do, pseudopolynomial would be fantastic?\n    ", "Answer": "\r\nIf the graph can be directed or undirected lets reduce the problem only to directed graphs. If it's undirected then you should make edges from v -> w and from w -> v. You can use modified DFS to measure the longest path starting from the node you pass to this function.\nThen run this function to every node and get the maximum value.\nPseudocode for DFS:\n```\nDFS(Node v):\n  if (v.visited?) return 0;\n  v.visited = true;\n  longestPath = 0;\n  foreach(Node n : v.neighbours):\n    longestPath = max(longestPath, DFS(n) + 1)\n  return longestPath\n```\n\nPseudocode for the problem:\n```\nlongestPath(Node[] verticies):\n  longestPath = 0\n  foreach(Node v : vertices):\n    foreach(Node w: vertices):\n      w.visited = false;\n    longestPath = max(longestPath, DFS(v))\n  return longestPath;\n```\n\nIt works in O(n^2) but I think this solution is straight forward.\nJust to let you know, there is a solution which works O(n).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Invalid Request trying to get Sharepoint Site resource by Path in Graph API\r\n                \r\nI'm trying to get a Site resource by path using the Rest Graph API as explained in the docs and I'm getting an error message indicating: \n\n\n  Provided identifier is malformed - site collection id is not valid\n\n\nI'm able to access the SharePoint site through the browser accessing to this URL:\n\n```\nhttps://<tenant>.sharepoint.com/sites/<site name>\n```\n\n\nThe endpoint I'm forming has the following shape:\n\n```\nhttps://graph.microsoft.com/v1.0/sites/<tenant>.sharepoint.com:/<site name>\n```\n\n\nI am able to successfully retrieve Site information by id but not by path. \nHere is a screenshot of how the request I'm trying to make looks like in Postman.\n\n\n\nThis is the response when getting site information by id:\n\n\n\nIs the endpoint URL correctly formed for retrieving the site resource information?\n    ", "Answer": "\r\nWhen addressing sites by path, the format as follows: \n\n\n  SharePoint hostname, followed by a colon and the relative path to the\n  site\n\n\nIt appears in your example site name specified instead of relative site path:\n\n```\nhttps://graph.microsoft.com/v1.0/sites/<tenant>.sharepoint.com:/<site name>\n                                                                ^^^^^^^^^^ \n                                                      should refer to relative path to the site\n```\n\n\ninstead it should be like this:\n\n```\nhttps://graph.microsoft.com/v1.0/sites/<tenant>.sharepoint.com:/sites/<site name>\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding the shortest path in a graph with teleports\r\n                \r\nI have this graph problem I'm not sure how to approach.\nI have an undirected graph with N vertices numbered ```\n1```\n-```\nN```\n. Every vertex numbered ```\ni```\n has an arbitrary \"rank\" that can be anywhere from ```\n1```\n-```\ni```\n. Multiple vertices can have the same rank.\nWhen traversing the graph, any vertex with rank ```\nr```\n can instantly teleport/traverse to another vertex with the same rank ```\nr```\n. This means unconnected components are still \"connected\" if at least one vertex from component A has the same rank as a vertex from component B.\nHow do I calculate the minimum amount of vertices needed to traverse from vertex A to vertex B?\n\nMy very naive solution is to add every edge that connects every equal-ranked vertex together to the graph, then applying a standard path-finding algorithm. This has a ridiculously long time complexity but I can't figure out a more efficient way to solve this.\nAny help please?\n    ", "Answer": "\r\nadding all edges between same rank nodes is too slow as you have noticed - in worst case as close to all nodes are same rank it goes to ```\nO(n^2)```\n\nA way to solve this is to introduce new nodes for each rank and connect all nodes of same rank to one of new nodes (i.e. for nodes with rank 1 connect to node n+1 and so on).\nThen you can consider new nodes to be of weight 0 when traversing to them - that way you can simply do 0-1 BFS with a dequeue (adding 0 weight nodes to front and other ones to the end once encountered) - this is linear so its solve-able in ```\nO(n)```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to get all paths from leaf to the root in a special graph\r\n                \r\nI am trying to implement an algorithm in a special data structure in graph form. my goal ist to get all paths from leaf (Target element) to the root.\nThis is how the graph looks like the image below.\n    ", "Answer": "\r\nWe need to remember all of the path that we had in order to traverse in all of the different ways on the graph, therefore only a states list isn't enough, we need a paths list. For every path we will make it longer by one if it has one parent and if it has two or more we will duplicate this list and add the parent to each one.\n\nWell I am not great at Java and I can not run this code so I can't guarantee this will run but the algorithm is ok. \n\n```\npublic static List<ARGState> getAllErrorStatesReversed(ReachedSet reachedSet) {\n  ARGState pIsStart =\n      AbstractStates.extractStateByType(reachedSet.getFirstState(), ARGState.class);\n  ARGState pEnd = targetStates.get(0);\n\n  List<List<ARGState>> results = new ArrayList<>();\n  List<List<ARGState>> paths = new ArrayList<>();\n\n  paths.add(new ArrayList<ARGState>(pEnd));\n\n  // This is assuming from each node there is a way to go to the start\n  // Go on until all the paths got the the start\n  while (!paths.empty()) {\n    // Expand the last path on your list\n    List<ARGState> curPath = paths.remove(paths.size() - 1);\n    // If there is no more to expand - add this path and continue\n    if (curPath.get(curPath.size() - 1) == pIsStart) {\n      results.append(curPath);\n      continue;\n    }\n\n    // Expand the path\n    Iterator<ARGState> parents = curPath.get(curPath.size() - 1).getParents().iterator();\n    // Add all parents\n    while (parentElement.hasNext()) {\n      ARGState parentElement = parents.next();\n      List<ARGState> tmp = new ArrayList<ARGState>(List.copyOf(curPath));\n      tmp.add(parentElement);\n      paths.add(tmp);\n    }\n  }\n  return results;\n}\n```\n\n\nHope you understand, more than welcome to ask.\nGood Luck\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Unique path in an undirected graph\r\n                \r\nTo tell whether there is a path between two vertices or not is efficient, such as DFS or BFS, it will be done within O(V+E). How about deciding whether there are more than one paths between two given vertices? The path should be simple path, i.e with no repeated vertex. It is not necessarily the shortest path. Will it be done with O(V+E)? Just tell the existence, no need to give the exact path. \n    ", "Answer": "\r\nApproach 1:\n\nDo a regular BFS from the source node, but continue until you've explored the entire graph, not just until you've found the target.\n\nThis should give you a path from the source to the target.\n\nIf you get multiple paths, these will be paths that have no vertices apart from the source and target in common (and, if this happens, you can stop here).\n\nNow do another search from the source node.\n\nIf we're currently on a node in the path found above, explore all neighbours (recursively, in a DFS fashion) except the one following that node in the path above. After that explore that node.\n\nSome pseudo-code to explain better:\n\n```\npath = bfs(source, target)\n\ndfs(n)\n  visited[n] = true\n  if path.contains(n)\n    next = path[path.indexOf(n) + 1]   // next node in path after n\n    for each neighbour n2 of n\n      if n2 != next and !visited[n2]\n        if path.contains(n2)\n          found multiple paths\n        dfs(n2)\n    dfs(next)\n  else\n    for each neighbour n2 of n\n      if path.contains(n2)\n        found multiple paths\n      dfs(n2)\n```\n\n\nThe running time should still be ```\nO(|V| + |E|)```\n.\n\nApproach 2:\n\n(not a good approach, just look at the running time - perhaps someone sees an efficient variation)\n\nDo a BFS from the source node with the following modification:\n\nContinue until you've explored the entire graph, not just until you've found the target.\n\nIf you encounter an already visited node that's not on the same path (i.e. would form a cycle) [1], rather than simply skipping it, instead set a flag on that node.\n\nWhen you've finished doing the BFS, go through the found path and if any nodes have their flag set, we know that there exists multiple paths.\n\nThe running time should still be ```\nO(|V||E|)```\n.\n\n\n\n[1]: Checking whether a node is on the same path is not exactly easy to do efficiently. Basically you want a set of nodes.\n\nOne option is a literal set of nodes - the problem here is that you have to copy it at each step, which is really expensive.\n\nBuilding on this, a bitset of nodes would be more efficient. For 1000 nodes, we only take 1000 bits to store a path. For really sparse graphs (graphs with few edges), this is actually worse than a literal set.\n\nAnother option is to assign a unique prime number to each node. When doing the BFS, maintain a product of all nodes for each path. To check whether an already visited node is on the same path, simply check if the product is divisible by the node's value.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Querying a Graph path in SPARQL\r\n                \r\nI am trying to write a SPARQL query to return a path from a source to a destination.\nBelow is the Turtle file representing the data set.\n\n```\n@prefix node: <http://prism.uvsq.fr/>.\n@prefix edge: <http://prism.uvsq.fr#>.\nnode:a edge:p node:b.\nnode:a edge:q node:f.\nnode:a edge:p node:g.\nnode:b edge:p node:c.\nnode:c edge:q node:h.\nnode:c edge:p node:i.\nnode:c edge:p node:d.\nnode:d edge:p node:e.\nnode:f edge:p node:g.\nnode:f edge:q node:l.\nnode:f edge:p node:k.\nnode:g edge:p node:c.\nnode:g edge:p node:f.\nnode:h edge:p node:n.\nnode:i edge:q node:j.\nnode:j edge:p node:o.\nnode:j edge:q node:n.\nnode:k edge:p node:l.\nnode:l edge:p node:g.\nnode:m edge:q node:g.\nnode:n edge:p node:m.\n```\n\n\nThe image next presents the same information, for easier visualization.\n\n\n\nThe query I wrote so far is the following:\n\n```\nprefix graph: <http://prism.uvsq.fr/>\nprefix node: <http://prism.uvsq.fr/>\nprefix edge: <http://prism.uvsq.fr#>\nSELECT * FROM graph: WHERE {\n   node:a (edge:p|edge:q) ?des.\n   ?des (edge:p|edge:q)* node:h.\n}\n```\n\n\nThe returned information only shows one level of the solution (it shows the possible neighbor nodes for reaching the destination).\nThanks in advance for your help.\nBest Regards\n    ", "Answer": "\r\nProperty paths in SPARQL are not things that you can query directly, but you can use property paths to help extract the edges along a path between two nodes.  For instance, the following query returns the edges in paths from a to h.  The basic idea is to use a property path to from a to some node u which has an edge to some node v from which there is a path to h.  The values block just limits the value of e to be either p or q.\n\n```\nprefix node: <http://prism.uvsq.fr/>\nprefix edge: <http://prism.uvsq.fr#>\n\nselect distinct ?u ?e ?v where {\n  values ?e { edge:p edge:q }\n  node:a (edge:p|edge:q)* ?u .\n  ?u ?e ?v .\n  ?v (edge:p|edge:q)* node:h .\n}\n```\n\n\n```\n----------------------------\n| u      | e      | v      |\n============================\n| node:a | edge:p | node:g |\n| node:a | edge:p | node:b |\n| node:g | edge:p | node:f |\n| node:g | edge:p | node:c |\n| node:f | edge:p | node:k |\n| node:f | edge:p | node:g |\n| node:k | edge:p | node:l |\n| node:l | edge:p | node:g |\n| node:c | edge:p | node:i |\n| node:n | edge:p | node:m |\n| node:h | edge:p | node:n |\n| node:b | edge:p | node:c |\n| node:a | edge:q | node:f |\n| node:f | edge:q | node:l |\n| node:c | edge:q | node:h |\n| node:i | edge:q | node:j |\n| node:j | edge:q | node:n |\n| node:m | edge:q | node:g |\n----------------------------\n```\n\n\nThat doesn't give you the actual paths, but it gives you all and only the edges that are on paths from a to h.  From that you can reconstruct paths by putting the graph back together and performing a depth first traversal to enumerate the paths.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find alternative (redundant) shortest paths with graph-tool\r\n                \r\nConsider this graph\n\nI'm using Dijkstra's shortest path algorithm to find the shortest paths from all vertices to all other vertices. Then, I am using an edge filter to take the first edge and \"hide\" it, then recomputing the shortest path again to get an alternate, backup path. I only want a single alternate path, I do not wish to find all paths.\n\n```\ndef compute_paths(source, dest):\n    results = graph_tool.topology.shortest_path(g, source, dest, weights=weight)\n    filteredge[results[1][0]] = 0\n    g.set_edge_filter(filteredge)\n    s_results = graph_tool.topology.shortest_path(g, source, dest, weights=weight)\n    print \"PRIMARY PATH:   %s\" % ([g.vertex_index[x] for x in results[0]])\n    print \"SECONDARY PATH: %s\" % ([g.vertex_index[x] for x in s_results[0]])\n    g.set_edge_filter(None)\n```\n\n\nThis works great if I call the function in a standalone manner, supplying it with a single pair of vertices, I get the output I would expect:\n\n```\ncompute_paths(g.vertex(9), g.vertex(8))\n```\n\n\nProduces:\n\n```\nPRIMARY PATH:   [9, 3, 8]\nSECONDARY PATH: [9, 4, 8]\n```\n\n\nHowever, attempting to get backup paths in a loop produces many empty backup paths where there should not be any. For example:\n\n```\nfor v in g.vertices():\n    for vv in g.vertices():\n        if v == vv:\n            continue\n        else:\n            compute_paths(v, vv)\n```\n\n\nFor the shortest primary and backup paths between vertex 9 and vertex 8 will yield:\n\n```\nPRIMARY PATH:   [9, 3, 8]\nSECONDARY PATH: []\n```\n\n\nI'm kind of stuck. I've tried creating a copy of the graph, using the GraphView class, and a couple other things, but I can't seem to make the backup path happen whenever I'm trying to compute it inside of a loop.\n    ", "Answer": "\r\nI discovered the problem.\n\nRather than setting the edge filter to ```\nNone```\n, I should have been resetting the boolean property map on the desired edge back to True.\n\nThe following yields me the results I need:\n\n```\ndef compute_paths(source, dest):\n    results = graph_tool.topology.shortest_path(g, source, dest, weights=weight)\n    filteredge[results[1][0]] = 0\n    g.set_edge_filter(filteredge)\n    s_results = graph_tool.topology.shortest_path(g, source, dest, weights=weight)\n    print \"PRIMARY PATH:   %s\" % ([g.vertex_index[x] for x in results[0]])\n    print \"SECONDARY PATH: %s\" % ([g.vertex_index[x] for x in s_results[0]])\n    filteredge[results[1][0]] = 1\n```\n\n\nI suppose I could still be setting the edge filter to ```\nNone```\n but that appears to be superfluous.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "longest path in undirected vs directed graph\r\n                \r\nI need to solve a longest path problem for graphs that are both directed and non-directed (unweighted in both cases).\nFor directed graph, it is pretty easy to find dynamic programming algorithms that are able to solve the problem in pseudopolynomial time, starting at some node, and calculating the longest path for subproblems until every problem has been looked at.\nCan I do a similar thing for at non-directed graph? I cant seem to find any litterature about it?\n    ", "Answer": "\r\nEvery directed graph algorithm works on undirected graphs.  Simply treat each edge as two directed edges with the same weight.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in a graph ( how to return to origin ? )\r\n                \r\nI'm working on a project for a transport company. Essentially I get, let's say , 200 city's and 7 trucks and I need to compute best weight distribution over the 7 trucks and the shortest path overall (km).\n\nBefore I actually communicate with Google Maps API I do my own computation. For 7 trucks I can compute about 30 milion routes in about 2 hours. ( weight distribution is done with backtracking / dynamic programing and \"next city\" is chosed with some math formulas )\n\nI need to compare those routes and remember the best one ( smallest km over the 7 trucks ).\n\nI get something like this : \n\n```\nTruck 1\n    City 1 (x,y)\n    City 2 (x,y)\n    City 3 (x,y)\n    City 4 (x,y)\n    .....\n\nTruck 2\n    City 1 (x,y)\n    City 2 (x,y)\n    City 3 (x,y)\n    City 4 (x,y)\n    .....\n\nTruck 3\n    City 1 (x,y)\n    City 2 (x,y)\n    City 3 (x,y)\n    City 4 (x,y)\n    .....\n\netc ...\n```\n\n\nWhere (x,y) are longitude and latitude. I can compute the distance between each city with the Euclidean distance d = sqrt((x1 - x2)^2 + (y1 - y2)^2) so I end up with a graph.\n\n\n  I was thinking to use A* algorithm to order the city's of each truck\n  and after get the distance between the ordered city's. The problem is\n  that in real life the trucks are going to return to the starting point\n  ... can A* take that in to account ?\n\n\nI am aware that the shortest path in longitude/latitude will not always be the shortest in km , but is OK, let's say 90% accuracy will do. \n\n\n  Any idea how I can compute a \"score\" for each route ( all 7 trucks )\n  so it can map as close as possible to the actual km ?\n\n\n( I can do limited calls to Google Maps API and I want to rule out the worst options locally )\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Do the shortest paths in from a node in a graph to all others form a tree?\r\n                \r\nGiven a graph G with root node r, do the shortest paths from the root to all other vertices form a tree? In another words, if you take the shortest path from r to all other vertices and combine them, do you get a tree?\n    ", "Answer": "\r\nYes, almost.\nA shortest paths tree is a tree rooted at a node v that traces out the shortest paths from v to each other node.\nIf you take shortest paths from a node v to each other node, it might not form a tree, but it will be always be a DAG. It won’t always be a tree if two or more different shortest paths exist from v to some node u. But in that case you can remove some of the edges to convert it into a tree.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Unweighted, directed graph path finding (fastest?)\r\n                \r\nI'm developing a PHP class able to calculate the route from two points in a unweighted and directed graph system (for EVE Online in particular). I've never developed graph solutions, so I don't really know what's the fastest way of calculating graph paths, so I looked around on the net, even if I found nothing but math-centric discussions or too particular solutions.\n\nMy first idea was to find all the paths from node A to node B and compare their length. I later noticed that that was unnecessary, as I don't need to compare, but to find the first, shortest path.\n\nThen I created a recursive system which implements the Deepening Depth-First Search algorithm (which I'm proposing here), but it's still too heavy for using it when the distance between the two nodes increase. I've successfully traced paths in 16 steps or less in few seconds. When it comes to search for more distant nodes, it won't finish in 90 seconds.\n\nMay you please help me finding a faster solution? I thought about creating a table containing all the distances and paths between the various nodes, but we're talking about thousand of nodes, it'd make forever to build it (and maintain it).\n\nhttp://hastebin.com/tilusubeli.coffee\n\nClass \"jumps\".\n\n\nThe construct accepts the origin (from) and goal (to) nodes, in the form of string or intege. In the former case, it will resolve its ID (integer) and use it (method getSystemID, you can ignore it). The \"jumpsTable\" initialiser creates an array in this form:\n\n\n```\n$this->jumpsTable[node_id] = array(next_node_id_1, next_node_id_2, ...)```\n\n\njumpsTable is the data representation of the graph.\n\n\nThe public method \"analyse\" will simply call IDDFS\n\n\nTHE ALGORITHM:\n\n\nIDDFS calls DLS starting with a depth of 0 and continues up to (max depth) until DLS returns a valid path. In this way it won't choose between two routes of the same length, but it will choose the first.\nDLS is a recursive method and looks for its \"children\" nodes: if one of the children is the goal node, it returns the path, otherwise it calls itself with each child as \"starting node\" with a decreased value of depth. If any call of DLS returns a path, exit the cycle. If no DLS returns a path, return null.\n\n    ", "Answer": "\r\nIf you do a depth-first search, you have no guarantee the first path you find is the the shortest one. You should instead perform a breadth-first search, since your graph is unweighted (otherwise, the standard algorithm would be A*). \n\nHowever, you'll need a complete rework of your implementation, since the recursive approach is not suited for the breadth-first search. Note this is a very classic algorithm, it should be easier for you to find an existing PHP implementation such as this one and adapt it to your own data structure. \n\nPS: another way of dealing with your problem would be to use a depth-first search with iterative deepening, which is basically a depth-first search applied using a deep limit, and repeatedly applied with an increasing limit (until the targetted node is found).\n\nPPS: if time is the main issue, be sure to check you don't process several times the same node.\n\nPPPS: you might be interested by this question: Given a directed graph, find out whether there is a route between two nodes.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Runtime of singe-source shortest paths in the directed acyclic graphs algorithm\r\n                \r\nHere is the Algorithm:\n\n```\nTopologically sort the Vertices of G\nInitialize - Single - Source(G,s)\nfor each vertex u, taken in topologically sorted order\n     for each vertex v in G.Adjacent[u]\n         Relax(u,v,w) \n```\n\n\n\nTopological sort has Runtime O(V + E), where V - is the number of\nVertices and E - is a number of edges\nInitialize - Single - Source(G,s) has runtime O(V)\nThe main question is double for Loop: The running time of the double for Loop is O(V + E). But I cannot understand, why it's not O(V*E)? Because for every Vertices we go through every edge and normally one nested Loop(all together 2 for Loops) have complexity O(N^2), but in this case it's not true.\n\n    ", "Answer": "\r\nFor each vertex u, you only iterate through the edges that go out from u.  Each distinct edge is visited only once, and that's why the algorithm takes O(V+E) time.\n\nThis assumes you are using a graph representation (like adjacency lists, not a matrix) that allows quick access to every vertex's adjacent edges.  The topological sort also requires this.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest path in weighted cycle directed graph\r\n                \r\nStackOveflow!\n\nI am trying to create an Arbitrage strategy to get a better understanding of how to work with graphs. I am using python.\n\nGraph:\n\nTable format:\n\n\nTask: find path of currency trading where we will get max profit. For example: ```\nUSD->EUR(0.75), EUR->GBP(2),GBP->USA(0.7): 0.75*2*0.7=1.05```\n, so we are getting 5% profit.\nI thought that I can modify Floyd–Warshall algorithm or the Dijkstra algorithm to find not the shortest but the longest path. But it failed...\n\nWhat algos are used for such tasks?\n    ", "Answer": "\r\nThe path that is the most expensive is found by\n\nfind most expensive edge\nloop E over edges\n\nsubtract cost of most expensive edge from cost of E\nset cost of edge to absolute value\nend loop\n\n\nloop over all pairs of vertices\n\napply Dijkstra and keep best result.\nend loop\n\n\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All Non-Cyclic Paths In A Directed Graph Between Source & Destination Using Memoization\r\n                \r\nI'm working on a research problem which involves storing all non-cyclic paths from a source vertex to a destination vertex in a general directed graph (may or may not be cyclic). The input consists of a directed graph, a source vertex and a destination vertex.\n\nI've written a method in Java to perform this action. I've used the concept of memoization, by storing all non-cyclic paths from a source vertex to the destination, so that if I ever reach the same vertex during my method's recursive calls, I can just use the stored 'Routes', and save lots of computation.\n\nI'm going wrong somewhere in the recursive step of my algorithm (I think), and I've spent some time thinking what could be the mistake, but I'm unable to find that out. I'd appreciate any help in this regard. Thanks in advance!\n\nOh, and if anyone wants any clarification regarding the purpose of any of the blocks of code, please comment!\n\nI've basically used DFS in my approach to solve the problem. My code is as follows:\n\n```\n//'allEdges' is an ArrayList of all edges of the input graph\n\n/*'Route' is a class that stores the 'src', 'dest' and 'edgeIndices' of 'allEdges'\nthat comprise the route from 'src' to 'dest'*/\n\n/*'hashMap' is a HashMap<Integer, ArrayList<Route>>. It maps an integer source vertex\n to a list of all routes from that vertex to the actual destination vertex to which\nthe method is initialized from main()*/\n\n\nstatic void findPaths(int source, int dest)\n{\n    int i,j,k;\n    for(i=0;i<allEdges.size();i++)\n    {\n        if(allEdges.get(i).getStartNode()==source)\n        {\n            ArrayList stack = new ArrayList();\n            stack.add(i);   //pushing edge index to stack\n            if(allEdges.get(i).getEndNode()==dest)\n            {\n                ArrayList<Route> list1 = hashMap.get(source);   \n\n                if(list1!=null)\n                {\n                    list1.add(new Route(source,dest,stack));\n                    hashMap.put(source, list1);\n                }\n                else\n                {\n                    ArrayList<Route> list2 = new ArrayList();\n                    list2.add(new Route(source,dest,stack));\n                    hashMap.put(source, list2);\n                }\n\n            }\n            else\n            {\n                int nextNode = allEdges.get(i).getEndNode();\n                ArrayList<Route> temp = hashMap.get(nextNode);\n                if(temp!=null)\n                {\n    for1:           for(j=0;j<temp.size();j++)\n                    {\n                        ArrayList path = temp.get(j).getEdgeIndices();\n\n                        for(k=0;k<path.size();k++)\n                        {\n                            int edgeIndex = (int)path.get(k);\n                            Edge ed = allEdges.get(edgeIndex);\n                            if(ed.getStartNode()==source)\n                            {\n                                continue for1;\n                            }\n                        }\n\n                        stack.addAll(path);\n\n                        ArrayList<Route> list3 = hashMap.get(source);\n                        if(list3!=null)\n                        {\n                            list3.add(new Route(source,dest,stack));\n                            hashMap.put(source,list3);\n                        }\n                        else\n                        {\n                            ArrayList<Route> list4 = new ArrayList();\n                            list4.add(new Route(source,dest,stack));\n                            hashMap.put(source,list4);\n                        }\n\n\n                        stack.removeAll(path);\n                    }\n                }\n                else\n                {\n                    findPaths(nextNode, dest);\n                }\n            }    \n        } \n    }\n\n}\n```\n\n\nEDIT 1:\n\nFor the following input graph:\n\nNumber of vertices = 5\n\nSource Vertex = 1\n\nDestination Vertex = 5\n\nDirected edges: 1 -> 2, 1 -> 3, 1 -> 4, 2 -> 4, 4 -> 5\n\nAll the paths from 1 to 5 are:\n\n1 -> 2 -> 4 -> 5\n\n1 -> 4 -> 5\n\nThe output 'hashMap' on calling findPaths(1, 5) is as follows:\n\nFor vertex '1', the 'hashMap' has just one 'Route' stored, and that route has only one 'Edge': 1 -> 4\n\nFor vertex '2', the 'hashMap' has no 'Route's stored, i.e., it maps to 'null'.\n\nFor vertex '3', the 'hashMap' has no 'Route's stored, i.e., it maps to 'null'.\n\nFor vertex '4', the 'hashMap' has just one 'Route' stored, and that route has only one 'Edge': 4 -> 5\n\nFor vertex '5', the 'hashMap' has no 'Route's stored, i.e., it maps to 'null'.\n\nClearly, the 'hashMap' is storing wrong 'Route's.\n\nEDIT 2:\n\nOk, so after making the modifications that Brainstorm suggested, the program works for acyclic graphs. I'm looking to make it work for cyclic graphs as well. I tried out a couple\nof inputs and interestingly, I noted that with the modifications suggested by Brainstorm, the program works for some cyclic graphs if the cyclic edges belong to the end of the ```\nArrayList 'allEdges'```\n. In other words, the order in which the edges appear in the input makes a difference, which isn't ideal.\n\nNow, I've realized that I forgot to label the nodes which are currently 'in process' in the recursion, and hence the code got stuck in infinite recursive call sequences. So what I did was to create a global stack ```\ninProcess```\n, which would contain the nodes which are acting as ```\nsource```\n in one of the recursive calls, so that the same node is not traversed again during the processing of those recursive calls. But I still don't get the right output. Here's the modification I did:\n\nINITIAL CODE BLOCK:\n\n```\nif(temp==null)\n{\n   findPaths(nextNode,dest);\n   temp = hashMap.get(nextNode);\n}\n```\n\n\nNOW MODIFIED THE ABOVE BLOCK TO THE FOLLOWING:\n\n```\nif(temp==null)\n{\n\n      if(!inProcess.contains(nextNode))\n      {\n           inProcess.add(nextNode);\n           findPaths(nextNode,dest);\n           inProcess.remove(inProcess.indexOf(nextNode));\n           temp = hashMap.get(nextNode);\n      }\n      else\n      {\n           continue main_for1;  //main_for1 labels the very first for() loop of this method\n      }\n\n\n}\n```\n\n\nI feel that this modification is insufficient in some way. Can anyone tell me what's wrong and correct me?\n    ", "Answer": "\r\nI think your problem might be the first line of the main else statement:\n\n\n  int nextNode = allEdges.get(i).getEndNode();\n\n\nWhat exactly does this do? It seems to me that it would return null when you are going through the paths the first time, when you haven't figure out the end node of i.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find longest path in directed acyclic graph\r\n                \r\nFind a longest path between two nodes in an edge-weighted DAG.\nInput: An edge-weighted graph, a source node source, and a sink node sink.\nOutput: The length of the longest path from source to sink, followed by a longest path.\n```\nInput:\n0\n4\n0->1:7\n0->2:4\n2->3:2\n1->4:1\n3->4:3\n\nOutput:\n9\n0->2->3->4\n```\n\nThe current solution passes for most test cases but there is an edge case that's not being accounted for (input is not available).\n```\nimport sys\nfrom collections import defaultdict\n\n\ndef topological_sort(graph):\n    indegree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor, _ in graph[node]:\n            indegree[neighbor] += 1\n\n    nodes_with_no_indegree = []\n    for node in graph:\n        if indegree[node] == 0:\n            nodes_with_no_indegree.append(node)\n\n    ordering = []\n    while len(nodes_with_no_indegree) > 0:\n        node = nodes_with_no_indegree.pop()\n        ordering.append(node)\n        for neighbor, _ in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                nodes_with_no_indegree.append(neighbor)\n    return ordering\n\n\ndef longest_path(source, sink, edges):\n    graph = defaultdict(list)\n    for edge in edges:\n        u, v, weight = edge.split(\n            \"->\")[0], edge.split(\"->\")[1].split(\":\")[0], edge.split(\"->\")[1].split(\":\")[1]\n        graph[u].append((v, -int(weight)))\n    graph[str(sink)]\n    ordering = topological_sort(graph)\n    dist = {node: float('inf') for node in ordering}\n    dist[str(source)] = 0\n\n    pred = {}\n    while len(ordering) > 0:\n        u = ordering.pop(0)\n\n        for v, weight in graph[u]:\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                pred[v] = u\n\n    # Reconstruct the longest path\n    longest_path = []\n    u = str(sink)\n    while u in pred:\n        longest_path.append(u)\n        u = pred[u]\n    longest_path.append(str(source))\n    longest_path.reverse()\n\n    return -dist[str(sink)], '->'.join(longest_path)\n\n\nif __name__ == \"__main__\":\n    source = int(sys.stdin.readline().strip())\n    sink = int(sys.stdin.readline().strip())\n    edges = [line.strip() for line in sys.stdin]\n    max_val, path = longest_path(source, sink, edges)\n    print(max_val)\n    print(path)\n```\n\n    ", "Answer": "\r\nFixed code:\n```\nimport sys\nfrom collections import defaultdict\n\ndef longest_path(source, sink, edges):\n    graph = defaultdict(list)\n    for edge in edges:\n        u, v_w = edge.split(\"->\")\n        v, w = v_w.split(\":\")\n        graph[int(u)].append((int(v), int(w)))\n\n    dist = {i: float('-inf') for i in range(sink+1)}\n    dist[source] = 0\n    path = {i: [] for i in range(sink+1)}\n\n    for u in range(source, sink):\n        for v, w in graph[u]:\n            if dist[v] < dist[u] + w:\n                dist[v] = dist[u] + w\n                path[v] = path[u] + [u]\n\n    longest_path = path[sink] + [sink]\n    longest_path_str = \"->\".join(map(str, longest_path))\n    return f\"{dist[sink]}\\n{longest_path_str}\"\n\nif __name__ == \"__main__\":\n    source = int(sys.stdin.readline().strip())\n    sink = int(sys.stdin.readline().strip())\n    edges = [line.strip() for line in sys.stdin]\n\n    print(longest_path(source, sink, edges))\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All paths in directed tree graph from root to leaves in igraph R\r\n                \r\nGiven is a tree:\n\n```\nlibrary(igraph)\n\n# setup graph\ng= graph.formula(A -+ B,\n                 A -+ C,\n                 B -+ C,\n                 B -+ D,\n                 B -+ E\n)\nplot(g, layout = layout.reingold.tilford(g, root=\"A\"))\n```\n\n\n\n\nVertex ```\n\"A\"```\n is the root of the tree, while vertices ```\n\"C\", \"D\", \"E\"```\n are considered as terminal leaves.\n\nProblem:\n\nThe task is to find all paths between root and leaves. I fail with following code, as it only provides the shortest paths: \n\n```\n# find root and leaves\nleaves= which(degree(g, v = V(g), mode = \"out\")==0, useNames = T)\nroot= which(degree(g, v = V(g), mode = \"in\")==0, useNames = T)\n\n# find all paths\npaths= lapply(root, function(x) get.all.shortest.paths(g, from = x, to = leaves, mode = \"out\")$res)\nnamed_paths= lapply(unlist(paths, recursive=FALSE), function(x) V(g)[x])\nnamed_paths\n```\n\n\nOutput:\n\n```\n$A1\nVertex sequence:\n[1] \"A\" \"C\"\n\n$A2\nVertex sequence:\n[1] \"A\" \"B\" \"D\"\n\n$A3\nVertex sequence:\n[1] \"A\" \"B\" \"E\"\n```\n\n\nQuestion:\n\nHow can I find all paths including the vertex sequence: ```\n\"A\" \"B\" \"C\"```\n?\n\nMy understanding is, that the missing sequence ```\n\"A\" \"B\" \"C\"```\n is not provided by ```\nget.all.shortest.paths()```\n as the path from ```\n\"A\"```\n to ```\n\"C\"```\n via the vertex sequence: ```\n\"A\" \"C\"```\n (which is found in list element ```\n$A1```\n) is shorter. So ```\nigraph```\n works properly.\nNevertheless I am looking for a code solution to get all paths from the root to all leaves in form of a ```\nR list```\n. \n\nComment:\n\nI am aware that for large trees the algorithm covering all combinations might become expensive, but my real application is relatively small.\n    ", "Answer": "\r\nBased on Gabor's comment:\n\n```\nall_simple_paths(g, from = root, to = leaves)\n```\n\n\nyields:\n\n```\n[[1]]\n+ 3/5 vertices, named:\n[1] A B C\n\n[[2]]\n+ 3/5 vertices, named:\n[1] A B D\n\n[[3]]\n+ 3/5 vertices, named:\n[1] A B E\n\n[[4]]\n+ 2/5 vertices, named:\n[1] A C\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Networkx finding common nodes between different shortest paths in a graph - Is there a alternate solution?\r\n                \r\nI am writing a tool for recognizing nodes in a network that are causing delays when given a set of two or more sources and destinations experiencing network problems or delay. I am using networkx python library to build the network graph.\nConsider this graph -\n```\na -- b -- c -- d  \n     |    |\n     e -- f\n```\n\nSay, these are the sets of source and destination facing network issues. Meaning traffic between a and d is experiencing delay and traffic between e and d is experiencing delay and so on.\n```\n| source | destination |\n|--------|-------------|\n| a      | d           |\n| e      | d           |\n| f      | a           |\n```\n\n\nI find the shortest path for these pairs of source and destination. I take an intersection between those two lists and check for errors on those devices. If I have 100 pairs of (source, dest) sets, then I would be finding the common nodes between 100 lists representing the paths between those two pairs.\n\n```\nShortest path host a to host d: \n     ['a', 'b', 'c', 'd']\nShortest path host e to host d: \n     ['e', 'b', 'c', 'd']\nShortest path host f to host a: \n     ['f', 'c', 'b', 'a']\n```\n\n^^ common nodes are 'c' and 'b' and hence check these for errors.\n\nMy question is if there is a better way to do this in networkx, where I can take multiple paths between source and dest and find a common set of nodes?\nI have very limited knowledge of network/graph theory, but this seems like a common problem that's solved using graphs.\n\n    ", "Answer": "\r\nI think what you're looking for is the nodes of maximal degree, which have the lowest average weight per edge. We can get the info needed for sorting the nodes like this:\n```\ndef avg_weight(graph, node):\n    all_edges = graph.edges(data=True)\n    edges = list(filter(lambda e: node in e, all_edges))\n    avg = 0\n    for e in edges:\n        avg += e[2]['weight'] / len(edges)\n    return avg\n\ndef weight_and_degree(G):\n    degrees = dict(G.degree)\n    weights = dict(map(lambda n: (n, avg_weight(G, n)), G.nodes))\n    return dict(map(lambda p: (p[0], (p[1], weights[p[0]])), degrees.items()))\n```\n\nNow here's a (weighted) graph that has the same properties as you specified above. The weights represent delay times.\n```\nimport networkx as nx\n\nG = nx.Graph()\nG.add_edge('a','b', weight=0.1)\nG.add_edge('b','c', weight=0.1)\nG.add_edge('d','c', weight=0.1)\nG.add_edge('b','e', weight=0.1)\nG.add_edge('f','e', weight=0.3)\nG.add_edge('f','c', weight=0.2)\n```\n\nIf we run the above function on the graph, we can sort by degree and average weight at once like this:\n```\ns = dict(sorted(weight_and_degree(G).items(), key=lambda x: (-x[1][0], x[1][1])))\nprint(' '.join(s.keys())) # b c e f a d\n```\n\nThen you can check the top ```\nn```\n results of this list according to the resources you have available, or you can modify the code to only return maximal degree nodes, etc.\nReferences:\n\nhttps://networkx.org/documentation/stable/auto_examples/drawing/plot_weighted_graph.html\nSorting a Python list by two fields\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Dijkstra: Find Shortest path in directed graph\r\n                \r\nConsider the directed graph shown in the figure below. There are multiple shortest paths between vertices S and T. Which one will be reported by Dijstra?s shortest path algorithm? Assume that, in any iteration, the shortest path to a vertex v is updated only when a strictly shorter path to v is discovered.\n\n\nMy Answer is  SBDT but in solutions it is giving SACET I am not able figure out why..\n    ", "Answer": "\r\nDijkstra's Algorithm picks nodes as follows:\n\n```\nB(3) from S\nA(4) from S\nC(5) from A\nE(6) from C\nD(7) from S or B\nG(8) from E\nT(10) from D or E\n```\n\n\nThus the shortest path to ```\nT```\n is ```\nSBDT```\n, ```\nSDT```\n or ```\nSACET```\n.\n\nBut because of ```\n\"the shortest path to a vertex v is updated only when a strictly shorter path to v is discovered\"```\n, when ```\nE```\n is visited, ```\nT```\n's prior node for the shortest path will be set as ```\nE```\n and not changed again.\n\nThus the answer is ```\nSACET```\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Travelling salesman problem for a tree graph (no hamiltonian path)\r\n                \r\nAlmost broken my head while trying to find algorithm that finds fastest route in graph that pass through ALL graph vertices from start vertex (with no need to return to start edge).\n\nI have checked all the main algorithms for graphs and similar problems on stackoverflow. \n\nAlmost all TSP examples I googled was for complete graphs. \n\nTSPLIB not looks like can solve my problem.\n\nSorry if I missed something.\n\nInput graph (check images):\n\n• Weighted \n\n• Undirected\n\n• Planar\n\n• No hamiltonian path\n\n• No negative edges\n\n• Size: up to 100 vertices (but usually  50-70)\n\nEdge length almost the same in graph, so we can say that this is an unweighted graph and take 1 as a length of edge.\n\nShould solve with \"dead end\" cases:\n\n\nReal input graphs looks like this (start from vertex 0):\n\n\nBig graph: \n\n\n\nExpected result:\n\n• Shortest path (a set of vertices indices) through all the edges from start edge.\n\n• No need to return to start edge at the end\n\nGot only one idea:\n\n1) Check all possible combinations of path, measure the distance and find the path with smallest distance.\n\n1a) Use Depth-First Search or Breadth-First Search\n\n1b) If while iterating the current vertex have more than one edge - make a separate combinations for all of them (try all possible ways).\n\n1c) In my case there are a lot of “dead end” in graph, so algorithm should find the way (the fastest ofc) from there and iterate through already passed vertices and not get stuck.\n\n2) Reconstruct the path\n\nMaybe I should use Minimum Spanning Trees algorithm here too…\n\nOr maybe for faster calculation I should split my graph to multiple smallest that are linked only with single edge (like 49-52, 40-41 on screenshot)\n\nAny help will be appreciated.\n\nPrefer C# examples (libs) but I can port code from any language.\n    ", "Answer": "\r\nI  my case this NP-hard problem should be solved fast as possible and not so perfectly, so I used the best solution for me (simplified version) (best case scenario should be O(n+n*m), n - nodes, m - edges):\n\nUse Breadth-first search (BFS) to find the deepest (far) node from start (let's call it FAR_NODE)\nUse Djkstra algorithm to calculate distance from FAR_NODE to all the other nodes (actually I was using BFS algorithm here too because for euclidian space it is faster and gives the same result)... so just save distance in all nodes from FAR_NODE.\nStart walking through the graph from start node to nearest not passed, prefer nodes with bigger \"distance from FAR_NODE\"\nIf there is no not passed nodes linked to current node- chose the nearest not passed node (preferred with with biggest \"distance\" value)(can use BFS too).\n\nAlgorithm is published and documented here(with animations): https://github.com/Stridemann/TravelShortPathFinder\n===================================================\nUsing Branch&Bound way:\nAs I mentioned in comment to my question I almost solved this in branch&bound way. The idea is to give a score to each permutation and process only with bigger score.\nIf someone interesting this is example code:\n\r\n\r\n```\nusing System.Collections.Generic;\nusing System.Linq;\nusing GraphFastPath.GraphData;\n\nnamespace GraphFastPath\n{\n    public class BranchNBound\n    {\n        public static BranchNBound Instance;\n        private readonly Graph _graph;\n        public bool _ignoreDeadEnds;\n        public SortedDictionary<float, List<BbIterationStep>> _iterations = new SortedDictionary<float, List<BbIterationStep>>();\n        public List<BbIterationStep> BestPath = new List<BbIterationStep>();\n        public int IdCounter;\n        public int MaxNodesVisited;\n        public BbIterationStep PathNode;\n\n        public BranchNBound(Graph graph, bool ignoreDeadEnds)\n        {\n            _graph = graph;\n            _ignoreDeadEnds = ignoreDeadEnds;\n            Instance = this;\n\n            var nodesCount = ignoreDeadEnds ? _graph.Nodes.Count(x => !x.IsDeadEnd) : _graph.Nodes.Count;\n\n            foreach (var edge in _graph.Nodes[0].Edges)\n                AddStep(new BbIterationStep(edge, nodesCount), 1000);\n        }\n\n        public int IterationsCount => _iterations.Sum(x => x.Value.Count);\n\n        public void RegisterGoodPath(BbIterationStep step)\n        {\n            if (step._uniqPassedNodesCount < MaxNodesVisited)\n                return;\n\n            if (step._uniqPassedNodesCount > MaxNodesVisited)\n            {\n                BestPath.Clear();\n                MaxNodesVisited = step._uniqPassedNodesCount;\n            }\n\n            BestPath.Add(step);\n        }\n\n\n        public void DoStep()\n        {\n            var min = _iterations.Last();\n            var list = min.Value;\n            _iterations.Remove(min.Key);\n\n            foreach (var step in list)\n                step.DoStep();\n        }\n\n        public void AddStep(BbIterationStep step, float cost)\n        {\n            step.VariantId = IdCounter++;\n\n            if (!_iterations.TryGetValue(cost, out var list))\n            {\n                list = new List<BbIterationStep>();\n                _iterations.Add(cost, list);\n            }\n\n            list.Add(step);\n        }\n    }\n\n    public class BbIterationStep\n    {\n        private readonly int _totalNodesCount;\n        private readonly Edge _currentEdge;\n        private int _totalPassedNodesCount;\n        public int _uniqPassedNodesCount;\n\n        public string Debug;\n        public List<Node> LocalPath = new List<Node>();\n        public Node Node;\n        public BbIterationStep Parent;\n        public float Score;\n\n        public int VariantId;\n\n        public BbIterationStep(Edge currentEdge, int nodesCount)\n        {\n            _currentEdge = currentEdge;\n            _totalNodesCount = nodesCount;\n            Node = _currentEdge.From;\n            _uniqPassedNodesCount++;\n            _totalPassedNodesCount++;\n        }\n\n        public BbIterationStep(BbIterationStep from, Edge currentEdge, string debug, float score)\n        {\n            Parent = from;\n            Score = score;\n            _currentEdge = currentEdge;\n            Debug = debug;\n\n            Node = _currentEdge.From;\n            _uniqPassedNodesCount = from._uniqPassedNodesCount;\n            _totalPassedNodesCount = from._totalPassedNodesCount;\n            _totalNodesCount = from._totalNodesCount;\n        }\n\n        public int Id => _currentEdge.From.Id;\n        public Node NodeTo => _currentEdge.To;\n\n        public void DoStep()\n        {\n            _currentEdge.Pass(false);\n            _currentEdge.To.SetProcessed();\n            var passed = CheckPassed(_currentEdge.To);\n\n            if (!passed)\n            {\n                _uniqPassedNodesCount++;\n\n                if (BranchNBound.Instance.MaxNodesVisited < _uniqPassedNodesCount)\n                    BranchNBound.Instance.RegisterGoodPath(this);\n\n                if (_uniqPassedNodesCount == _totalNodesCount)\n                    BranchNBound.Instance.PathNode = this;\n            }\n\n            _totalPassedNodesCount++;\n\n            var totalDistFromStartMin = float.MaxValue;\n            var totalDistFromStartMax = float.MinValue;\n\n            foreach (var edge in _currentEdge.To.Edges)\n            {\n                var dist = edge.To.DistanceFromStart;\n                var nextNodePassedCount = CountPassed(edge.To);\n\n                if (nextNodePassedCount > 0)\n                    dist *= nextNodePassedCount + 2;\n\n                if (totalDistFromStartMin > dist)\n                    totalDistFromStartMin = dist;\n\n                if (totalDistFromStartMax < dist)\n                    totalDistFromStartMax = dist;\n            }\n\n            var delta = totalDistFromStartMax - totalDistFromStartMin;\n\n            if (delta == 0)\n                delta = totalDistFromStartMax;\n\n            foreach (var edge in _currentEdge.To.Edges)\n            {\n                if (BranchNBound.Instance._ignoreDeadEnds && edge.To.IsDeadEnd)\n                    continue;\n\n                var deltaGoodFromStart = 1 - (edge.To.DistanceFromStart - totalDistFromStartMin) / delta; // + float.Epsilon;\n\n                if (float.IsNaN(deltaGoodFromStart))\n                {\n                    var test = 1;\n                }\n\n                MoveNextEdge(edge, deltaGoodFromStart);\n            }\n        }\n\n        private void MoveNextEdge(Edge edge, float deltaGoodFromStart)\n        {\n            var nextNodePassedCount = CountPassed(edge.To);\n\n            var progressScale = (float) _uniqPassedNodesCount / _totalNodesCount; //weight 200    :Total path search progress (how much it is completed/finished)\n            var nextNodeScoreScale = 1f / (nextNodePassedCount * nextNodePassedCount + 1); //weight 200    :Lower value if next node was visited more times\n\n\n            var pc = _uniqPassedNodesCount;\n\n            if (nextNodePassedCount == 0)\n                pc++;\n\n            var pathNoRepeatedNodesScoreScale = (float) pc / (_totalPassedNodesCount + 1); //weight 400    :Higher value if all nodes was visited less times\n\n            var progressScaleValue = progressScale * 1;\n            var nextNodeScoreValue = nextNodeScoreScale * 300;\n            var deltaGoodFromStartValue = deltaGoodFromStart * 500 * nextNodeScoreScale;\n            var pathNoRepeatedNodesScoreValue = pathNoRepeatedNodesScoreScale * 800;\n\n             //iterations with bigger score will be processed earlier\n            var totalScore = progressScaleValue +\n                             nextNodeScoreValue +\n                             deltaGoodFromStartValue +\n                             pathNoRepeatedNodesScoreValue;\n\n\n            var dbg = $\"Progress: {progressScaleValue} NextNode({edge.To.Id}): {nextNodeScoreValue} GoodStart: {deltaGoodFromStartValue} NoRepeat: {pathNoRepeatedNodesScoreValue}\";\n\n            var newStep = new BbIterationStep(this, edge, dbg, totalScore);\n            BranchNBound.Instance.AddStep(newStep, totalScore);\n        }\n\n        public bool CheckPassed(Node node)\n        {\n            var checkStep = this;\n\n            do\n            {\n                if (checkStep.Node == node)\n                    return true;\n\n                checkStep = checkStep.Parent;\n            } while (checkStep != null);\n\n            return false;\n        }\n\n        public void GetPathEdges(List<Edge> result)\n        {\n            var checkStep = this;\n\n            do\n            {\n                result.Add(checkStep._currentEdge);\n                checkStep = checkStep.Parent;\n            } while (checkStep != null);\n        }\n\n        private int CountPassed(Node node)\n        {\n            var passedCount = 0;\n            var checkStep = this;\n\n            do\n            {\n                if (checkStep.Node == node)\n                    passedCount++;\n\n                checkStep = checkStep.Parent;\n            } while (checkStep != null);\n\n            return passedCount;\n        }\n\n        public override string ToString()\n        {\n            return Parent == null ? Id.ToString() : $\"({Score}) ({VariantId}), {Debug}\";\n        }\n\n        public string GetPath()\n        {\n            return Parent == null ? Id.ToString() : $\"{Parent.GetPath()}-{Id}\";\n        }\n    }\n}```\n\r\n\r\n\r\n\nMost interesting part is MoveNextEdge function that calculates a score for each permutation.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "get all the paths between 2 nodes in a directed graph\r\n                \r\nI am trying to get all the paths in a directed graph between two nodes. I have a problem with a cycle and I cannot find the reason.\nHere is my graph (taken from http://www.technical-recipes.com) :\n\n\n\nThe problem appears because of the [1,2] edge : 1->2 . If I remove it, I have no problems. In this particular test, I want all the paths from 2 to 5. I will provide the small code at the end.\n\nCase 1 : the output when I do NOT have [1,2] :\n\n```\n//g.addEdge( 1, 2 );    \ng.addEdge( 1, 3 );    \ng.addEdge( 1, 4 );    \ng.addEdge( 2, 1 );    \ng.addEdge( 2, 4 );    \ng.addEdge( 2, 3 );    \ng.addEdge( 3, 5 );    \ng.addEdge( 4, 5 );    \ng.addEdge( 5, 3 ); \n```\n\n\nThe output is ok :\n\n```\n2 1 3 5    \n2 1 4 5  \n2 3 5  \n2 4 5\n```\n\n\nCase 2 : I introduce g.addEdge( 1, 2 ); => the output is :\n\n```\n2 3 5 \n2 4 5\n```\n\n\nSo when the current node is 1 and is taking 2 as child it does not work. \nNote: when I erase visited[], visited[] is still containing 2 (that is introduced in main, and I think it should be there)...I think because of context saving.\n\nMy code is pretty small and it looks like this:\n\nMAIN function\n\n```\n    Graph g(5);         //graph with 5 nodes\n    std::vector<int> visitedmain;\n    visitedmain.push_back(2);    //introduce the start node 2 in the vector\n\ng.addEdge( 1, 2 );    //this is wrong \ng.addEdge( 1, 3 );    \ng.addEdge( 1, 4 );    \ng.addEdge( 2, 1 );    \ng.addEdge( 2, 4 );    \ng.addEdge( 2, 3 );    \ng.addEdge( 3, 5 );    \ng.addEdge( 4, 5 );    \ng.addEdge( 5, 3 );  \n\ng.DFS(5, visitedmain);    // 5 is the required (target) node\n```\n\n\nDFS function\n\n```\nvoid Graph::DFS(int required, std::vector<int>& visited) {\n    int i, j;\n    //the current node, where I am in recursivity\n    int x = visited.back();  \n\n    int ok = 1;\n\n    for (i = 1; i <= n; i++) {\n        //for all children\n        if (isConnected(x, i)) { \n            //need this for ok, explanation down\n            for (j = 0; j < visited.size(); j++) \n                    {\n                if (i == visited[j])\n                    ok = 0;\n            }\n            //if it is in the vector already, exit for\n            if (!ok)  \n                continue;\n\n            ok = 1;\n            //If I reached the target, I have the vector containing the nodes from the path\n            if (i == required) { \n                //introduce the target node in the path\n                visited.push_back(i); \n\n                for (j = 0; j < visited.size(); j++) {\n                    //print the path\n                    errs() << visited[j] << \" \"; \n                }\n                errs() << \"\\n\";\n                //delete the vector. create one vector every time when traversing the graph\n                visited.erase(visited.begin() + visited.size() - 1); \n                break;\n            }\n        }\n    }\n    //the case when I still have to traverse undiscovered nodes\n    for (i = 1; i <= n; i++) { \n        //for all children\n        if (isConnected(x, i)) { \n\n            for (j = 0; j < visited.size(); j++) {\n                if (i == visited[j])\n                    ok = 0;\n            }\n            //if it is already in the vector OR I reached the target, I exit the for\n            if (!ok || i == required) \n                continue;\n            ok = 1;\n            //introduce the child in the vector\n            visited.push_back(i); \n            //recursive for this child\n            Graph::DFS(required, visited);  \n            //delete the old vector\n            visited.erase(visited.begin() + visited.size() - 1); \n        }\n    }\n}\n```\n\n\nThank you for every suggestion ! \n    ", "Answer": "\r\nYour logic regarding ok looks suspicious.\n\nYou set ok=1 at the start of the function, and after tests which will only pass if ok=1 already.\n\nI would recommend setting ok=1 just before the for loops that set it to 0.\n\ni.e. change\n\n```\nfor(j=0; j<visited.size(); j++) \n```\n\n\nto\n\n```\nok=1;\nfor(j=0; j<visited.size(); j++) \n```\n\n\nin both places where this occurs.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding a path in a directed graph in Python\r\n                \r\nI am a Python beginner. As I wish to learn from the bottom up please keep any suggestions in line with my level, avoiding advanced constructs or graphing libraries.\n\nI have a directed graph, below:\n\n```\ntest= {\n'a':    [['b'],     ['Starfleet Commander', 'Ninja Hamsters', 'Seahorse Adventures']], \n'b':    [['c'],     ['Call of Arms', 'Dwarves and Swords', 'The Movie: The Game']], \n'c':    [['e','d'],     ['Seven Schemers', 'Pirates in Java Island', 'Dwarves and Swords']], \n'd':    [[],    ['Seahorse Adventures', 'Ninja Hamsters', 'Super Mushroom Man']],\n'e':    [[],            ['Seven Schemers', 'Pirates in Java Island', 'Dwarves and Swords']], \n}\n```\n\n\nNow I create a recursive method to return the path between a source and a destination:\n\n```\ndef path_to_friend(network, source, destination):\nif source == destination:\n    return [destination]\nelse:\n    for new_source in network[source][0]:\n\n            #print 'source> '+ source + '; new source> ' + new_source\n            try:\n                return [source] + path_to_friend(network, new_source, destination)\n            except TypeError, e:\n                print source, new_source, destination, e\n                pass\n```\n\n\nAnd make a function call:\n\n```\nprint path_to_friend(test, 'a', 'd')\n```\n\n\nThis fails for the case where the recursion follows the node/key 'e' which has no value. The error returned is:\n\n\n  can only concatenate list (not \"NoneType\") to list\n\n\nif the graph entry for 'c' is changed to:\n\n```\n'c':    [['d','e'],     ['Seven Schemers', 'Pirates in Java Island', 'Dwarves and Swords']]\n```\n\n\nSo 'd' is reached before 'e' then no error is raised.\n\nProblem this is not enough information for me to understand why my code is creating this error. I have failed to understand something basic about the language.\n\nPlease advise.\n    ", "Answer": "\r\nYour code has many issues here. First of all, if no path exists between a Node(A) and a Node(B),\nthe function returns None. \n\nAnd since on the next recusrion, you try to add ```\n[source] + path_to_friend(network, new_source, destination)```\n which basically is equivalent to ```\n[source] + None```\n it will simply fail and raise the error you just had. To solve this, we will simply test the result of path_to_friend before we append it to the result\n\n```\ndef path_to_friend(network, source, destination):\n    if source == destination:\n        return [destination]\n    else:\n        for new_source in network[source][0]:\n\n                #print 'source> '+ source + '; new source> ' + new_source\n                sub_path = path_to_friend(network, new_source, destination)\n                if sub_path is not None:\n                    return [source] + sub_path\n```\n\n\nThe second problem you will probably encounter, is in the case there are cycles in the network. In which case, you might find yourself in an infinite loop:\n\nNode A visits Node B which in turn visits Node A....\n\nTo fix that, we will use a set that keeps track of the visited nodes and pass it along the function\n\n```\ndef path_to_friend(network, source, destination, visited=None):\n    if source == destination:\n        return [destination]\n    else:\n        visited = visited or set()\n        for new_source in network[source][0]:\n                if new_source not in visited: # check if the next node was already visited\n                    visited.add(new_source) # add the next node to the list of visited nodes\n                    #print 'source> '+ source + '; new source> ' + new_source\n                    sub_path = path_to_friend(network, new_source, destination, visited)\n                    if sub_path is not None:\n                        return [source] + sub_path\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Genetic algorithm - shortest path in weighted graph\r\n                \r\nI want to make a genetic algorithm that solves a shortest path problem in weighted, connected graph. Similar to travelling salesman, but instead of fully-connected graph, it's just connected.\n\nMy idea is to randomly generate a path consisting of n-1 nodes for each chromosome in binary form, where numbers indicate nodes in a path. Then I will choose the best depending on sum of weights (if cant go from A to B i would give it penalty) and crossover/mutate bits in it. Will it work? It feels a little like smaller version of bruteforce. Is there a better way?\n\nThanks!\n    ", "Answer": "\r\nGenetic algorithm is pretty much \"smaller version of bruteforce\". It is just a metaheuristic, not an optimization method which has decent convergence guarantees. It basically depends on randomness to provide new solutions, thus it is a \"slightly better random search\". \n\nSo \"will it work\"? Yes, it will do something, as long as you have enough randomness in mutation it will even (eventually) converge to optimum. Will it work better than a random search? Hard to say, this depends on dozens of factors, not only your encoding, but also all the hyperparameters used etc. in general genetic algorithms are about trials and errors. In particular representation of chromosomes which does not loose any information (yours does not) does not matter, meaning that everything depends on clever implementation of crossover and mutation (as long as chromosomes do not loose any information they are all equivalent).\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Manual analysis to determine if the path taken in the graph is the shortest path\r\n                \r\nPathfinding algorithms such as A* 100% guarantees the shortest path. But can we can manually analyze if a given path in the graph is the shortest path?\nSuppose that we have this weighted graph\nWeighted Graph\nLet's say that our starting node is NODE 1 and we want to go to NODE 2. The path that we took is node 1 -> node 2. Obviously this is the shortest path. How can we manually prove or determine whether this path is the shortest route without any computers?\n    ", "Answer": "\r\nOne can go with ```\nDijkstra```\n Algorithm to find the shortest path.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Vocabulary: path in a graph of objects?\r\n                \r\nI'm having trouble with the following sentence:\n\n\n  ```\nDeepClone```\n performs a deep clone of\n  the target object, stopping the cloning process\n  when all <dependency paths> have\n  reached a value type or an ```\nITransactionalObject```\n.\n\n\nWhat I mean by \"dependency path\" is the chain of references you follow in the cloning process: object A has a reference to B, B to C, C to D,... and N to an ```\nITransactionalObject```\n, and then you stop there and don't clone the ```\nITransactionalObject```\n. Then you go back to M and follow that path, and so on, until all branches run into value types or ```\nITransactionalObjects```\n.\n\nWhat term would you use rather than dependency path? I have the feeling there must already be a name for it.\n\nThanks :)\n    ", "Answer": "\r\nPath is the standard term for a walk through a graph, so unless you want to add more domain-specific terminology I think that's okay.\n\nYou could say \"... until the dependency tree is fully resolved (i.e. all paths have terminated in ```\nITransactionalObject```\ns or value types)\".\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding shortest path in non-weighted graphs\r\n                \r\nDuring a course in University concerning graph theory, we were talking about finding shortest paths thus Dijkstra's algorithm came up, at that point I should mention that the edges of the graph were weighted, with weights>0. Then the professor asked how we could find the shortest path if the edges weren't weighted, I thought the same algorithm would do, since the edges had the \"same\" non-negative weight. But he suggested BFS. Is this true? wouldn't Dijkstra work correct? I'm not questing BFS finding the path but since it is exhaustive I thought maybe it would be better to avoid it.\n    ", "Answer": "\r\nDijsktra worked fine for me even with  non-wighted graphs. Every connection just has weight 1.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How can I find the shortest path in a graph, with adding the least number of new nodes?\r\n                \r\nI need to find the shortest path in a graph with the least number of added nodes. The start and end nodes are not important. If there is no path in a graph just between specified n-nodes, I can add some nodes to complete the shortest tree but I want to add as few new nodes as possible.\n\nWhat algorithm can I use to solve this problem?\n    ", "Answer": "\r\nStart with the start node. \n\nif it is the target node, you are done.\n\nCheck every connected node, if it is the target node. If true you are done\n\nCheck if any of the connected nodes is connected to the target node. If true you are done.\n\nElse add a node that is connected to start and end node. done.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Retrieving all pair shortest path of a dynamic graph efficiently\r\n                \r\nI'm studying shortest paths in directed graphs currently. There are many efficient algorithms for finding the shortest path in a network, like dijkstra's or bellman-ford's. But what if the graph is dynamic? By saying dynamic I mean that we can insert edges during the execution of program. I'm trying to find an efficient algorithm for updating the shortest paths from a vertex v to every other vertex u, after inserting an edge e, without needing to run the shortest path algorithm in the new graph again. How can I do this? I discussed with my professor the approach given in this question Link. It initially runs floyd warshall on initial graph. Then when an edge is added between vertex u and vertex v, we do the following:\nFor every pair of nodes x and y,check if d(x,u)+c(u,v)+d(v,y),  this can be done in O(n^2) since you are comparing every pair of nodes.  //d(x,y) is the distance between vertex x and vertex y computed by Floyd Warshall algorithm initially.\n\nMy doubt is  that can we optimize above step so that we should not have to check for all pairs? Can we do better or not? If yes, what is the approach? And if no, what is the proof that we have to check for all pairs? \n\nI draw some graphs and intuitively feels that we have to check for all pairs and we can't do better but still any proof will be helpful.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find the minimum weighted path in a graph with additional conditions\r\n                \r\nI have a problem as below and I am really stuck with it as it run with more than the time I desired (about 1 second). I really want your help to build up a more efficient algorithms than mine\n\nGiven an undirected graph G = (V, E) with two parameter of weights w1 and w2 for each edges. This graph has N vertices and M edges. A K-Elementary path S is a sub-graph of G which must be an elementary graph and it does have exactly K edges.\nFind a K-elementary path S with the sum of w1 of all edges as minimum value and the sum of w2 of all edges of S must be smaller than a given value Q. If it does not exist any path satisfied, print out the value -1\nInput:\nThe first line with four values N, M, K, Q (2 <= N, K <= 50, 1 <= M <= 2*N, 1 <= Q <= 10^9)\nThe next M lines show the edges of the graph: V1 V2 W1 W2 (1 <= V1, V2 <= N, 1 <= W1 <= 10^4, 1 <= W2 <= 10^4)\nOutput: One integer to show the minimum weight of the k-elementary graph found. -1 if non-exists\nSample test case:\nInput:\n```\n5 7 3 6\n1 2 1 2\n1 4 2 2\n1 5 3 6\n2 3 3 2\n2 4 4 4\n3 4 5 1\n4 5 4 7\n```\n\nOutput:\n```\n6\n```\n\n\nFirst of all, I want to quote the definition of an elementary path.\nIn short, for this problem, we need to find an k-elementary path S such that the weight to w1 is minimum, the sum of all edges to w2 is less than or equal to Q and it does have exactly K edges.\nI do have a Backtracking approach, in which I tried to build up all the graph satisfying the second condition (w2) and then find the minimum of the first condition (w1) but, as you have known, the time complexity is quite high. However, I find it hard to convert it to dynamic programming or any other methods to reduce to time complexity. I do add some Branch-bound condition but it is still slow.\nBelow is my source code which you can refer but I do not think it is useful\n```\n#include <bits/stdc++.h>\nusing namespace std;\n#define N 51\n#define INF 1e9\nint n, m, K, Q;\nbool appear[N];\nint W1[N][N];\nint W2[N][N];\nint currentSum1 = 0;\nint currentSum2 = 0;\nint source = 0;\nint res = INF;\nint Log[N];\nint minElement = INF;\nbool check(int k, int v)\n{\n    return !appear[v] && W1[Log[k - 1]][v] != 0 && W2[Log[k - 1]][v] != 0;\n}\nvoid solution()\n{\n    if(currentSum1 != 0 && currentSum1 < res)\n    {\n        res = currentSum1;\n        // for(int i = 0; i <= K; i++)\n        //     cout << Log[i] << \" \";\n        // cout << endl;\n    }\n}\nvoid solve(int k)\n{\n    for(int v = 1; v <= n; v++)\n    {\n        if(check(k, v) && currentSum2 + W2[source][v] <= Q && currentSum1 + (K - k) * minElement <= res) //Branch-bound condition\n        {\n            Log[k] = v;\n            currentSum2 += W2[Log[k - 1]][v];\n            currentSum1 += W1[Log[k - 1]][v];\n            appear[v] = true;\n            if(k == K)\n                solution();\n            else\n                solve(k + 1);\n            currentSum1 -= W1[Log[k - 1]][v];\n            currentSum2 -= W2[Log[k - 1]][v];\n            appear[v] = false;\n        }\n    }\n}\nint main()\n{\n    fast;\n    // freopen(\"data.txt\", \"r\", stdin);\n    cin >> n >> m >> K >> Q;\n    for(int i = 0; i < m; i++)\n    {\n        int x, y, w1, w2;\n        cin >> x >> y >> w1 >> w2;\n        minElement = min(minElement, w1);\n        W1[x][y] = w1;\n        W1[y][x] = w1;\n        W2[x][y] = w2;\n        W2[y][x] = w2;\n    }\n    for(int v = 1; v <= n; v++)\n    {\n        source = v;\n        currentSum2 = 0;\n        currentSum1 = 0;\n        Log[0] = v;\n        for(int i = 1; i <= n; i++)\n            appear[i] = false;\n        appear[source] = true;\n        solve(1);\n    }\n    if(res != INF)\n        cout << res << endl;\n    else \n        cout << -1 << endl;\n}\n```\n\n    ", "Answer": "\r\nFirstly, finding a resource constrained shortest path is NPHard. Most approaches to this problem employ a labelling scheme, which is a specialization of dynamic programming. You could use available libraries to accomplish this. See here for a boost implementation. This implementation will help you find (possibly) a non-elementary path from s to t as long all of the w_2 weights are positive. If the weights w_2's are negative, then it is possible that with negative w_1 weights and positive Q, the problem is unbounded.\nNow, coming to the need for a k-elementary shortest path, as far as I know, there is no off-the shelf algorithm that could help accomplish this. First, forget about k. Finding an elementary shortest path subject to additional resource constraints can be done using the labelling schemed presented in the papers referred to in the boost link above. In this case, the state space of the dynamic program should increase to allow for the storage of the indicator vector of all previously visited nodes in the path. This make the problem much harder to solve as compared to the basic resource constrained shortest path problem.\nNow, getting to your need of a k-elementary shortest path, one would have to embed the above scheme of finding an elementary shortest path recursively inside another function that keeps checking whether the elementary path returned has k edges or not. If it does have k edges, then you are done. If not, you would have to somehow place restrictions on the algorithm to prevent this particular path. That can be accomplished by using prelabels. As far as I know, this was first done in this work.\nGood luck, but this problem is doubly/triply difficult (because of possible need for multiple iterations). You should refer to the work mentioned in the boost link and subsequent papers in this area to understand the state-of-the-art. I suspect the state-of-the-art to not be able to solve problems beyond 10-15 nodes.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Using SciPy's minimize to find the shortest path in a graph\r\n                \r\nI am trying to find the shortest path in the following graph from G to C and I wrote the following code to accomplish that.  \n\n\n\nFirst I give the equations and constraints I believe I should use:\n\nWe maximize dc subject to:\n\ndb-da <= 8 \n\ndf-da <= 10\n\ndc-db <= 4\n\ndd-dc <= 3\n\nde-dd <= 25\n\ndf-dd <= 18\n\ndd-de <= 9\n\ndg-de <= 7\n\nda-df <= 5\n\ndb-df <= 7\n\ndc-df <= 3\n\nde-df <= 2\n\ndd-dg <= 2\n\ndh-dg <= 3\n\nda-dh <= 4\n\ndb-dh <= 9\n\n```\nimport numpy as np\nimport scipy as scp\nfrom scipy.optimize import minimize\n\na,b,c,d,e,f,g,h = 0,1,2,3,4,5,6,7\n\ndef objective(x, sign = -1.0):\n    return sign*x[c]\n\ndef c1(x, sign = -1.0):\n    return sign*(x[b]-x[a]-8)\ndef c2(x, sign = -1.0):\n    return sign*(x[f]-x[a]-10)\ndef c3(x, sign = -1.0):\n    return sign*(x[c]-x[b]-4)\ndef c4(x, sign = -1.0):\n    return sign*(x[d]-x[c]-3)\ndef c5(x, sign = -1.0):\n    return sign*(x[e]-x[d]-25)\ndef c6(x, sign = -1.0):\n    return sign*(x[f]-x[d]-18)\ndef c7(x, sign = -1.0):\n    return sign*(x[d]-x[e]-9)\ndef c8(x, sign = -1.0):\n    return sign*(x[g]-x[e]-7)\ndef c9(x, sign = -1.0):\n    return sign*(x[a]-x[f]-5)\ndef c10(x, sign = -1.0):\n    return sign*(x[b]-x[f]-7)\ndef c11(x, sign = -1.0):\n    return sign*(x[c]-x[f]-3)\ndef c12(x, sign = -1.0):\n    return sign*(x[e]-x[f]-2)\ndef c13(x, sign = -1.0):\n    return sign*(x[d]-x[g]-2)\ndef c14(x, sign = -1.0):\n    return sign*(x[h]-x[g]-3)\ndef c15(x, sign = -1.0):\n    return sign*(x[a]-x[h]-4)\ndef c16(x, sign = -1.0):\n    return sign*(x[b]-x[h]-9)\n\ndef c17(x, sign = -1.0):\n    return x[g]\n\ncs = [c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17]\n\nx0 = [0 for i in range(8)]\n\nb = (0,None)\nbs = tuple([b for i in range(8)])\n\ncons = []\nfor i in range(16):\n    cons.append({'type': 'ineq', 'fun':cs[i]})\ncons.append({'type': 'eq', 'fun':c17})\n\nsol = minimize(objective, x0, method = 'SLSQP', bounds=bs, constraints=cons)\nfor val in sol['x']:\n    print(round(val))\n```\n\n\nIt is possible to merely use algebra to solve for each of the variables but it is supposed to be efficient to use LP to do it instead.\n\nI believe just by a manual trace through the graph that the optimal path is G-H-B-C with a total cost of 16.  However, the code above indicates that the optimal path is G-H-A-F-C with costs that make sense until they don't: 3-4-1-3.  It says that the optimal path length is 11.  It seems so close to a valid answer, except that it thinks you can go from A to F with a cost of 1.\n\n[Edit: I just noticed I missed the edge from B to E but it doesn't seem to matter, and indeed when I add it in the algorithm's answer doesn't change.]\n    ", "Answer": "\r\nThis (working) code is:\n\n\nsomewhat ugly (no careful analysis of nicely usable graph data-structures for this task)\nuses scipy's linprog(method='simplex'), which i do not trust anymore (see issues at github)\nfollows the LP described at wikipedia\nis not for real-world usage\n\n\ninefficient data-structures\ninefficient and dense-only solver\n\n\n\nPlease make sure to read my comment above!\n\nCode\n\n```\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\"\"\" DATA\"\"\"\nedges = [('A', 'B', 8),\n         ('A', 'F', 10),\n         ('B', 'C', 4),\n         ('B', 'E', 10),\n         ('C', 'D', 3),\n         ('D', 'E', 25),\n         ('D', 'F', 18),\n         ('E', 'D', 9),\n         ('E', 'G', 7),\n         ('F', 'A', 5),\n         ('F', 'B', 7),\n         ('F', 'C', 3),\n         ('F', 'E', 2),\n         ('G', 'D', 2),\n         ('G', 'H', 3),\n         ('H', 'A', 4),\n         ('H', 'B', 9)]\ns, t = 'G', 'C'\n\n\"\"\" Preprocessing \"\"\"\nnodes = sorted(set([i[0] for i in edges]))  # assumption: each node has an outedge\nn_nodes = len(nodes)\nn_edges = len(edges)\n\nedge_matrix = np.zeros((len(nodes), len(nodes)), dtype=int)\nfor edge in edges:\n    i, j, v = edge\n    i_ind = nodes.index(i)  # slow\n    j_ind = nodes.index(j)  # \"\"\"\n    edge_matrix[i_ind, j_ind] = v\n\nnnz_edges = np.nonzero(edge_matrix)\nedge_dict = {}\ncounter = 0\nfor e in range(n_edges):\n    a, b = nnz_edges[0][e], nnz_edges[1][e]\n    edge_dict[(a,b)] = counter\n    counter += 1\n\ns_ind = nodes.index(s)\nt_ind = nodes.index(t)\n\n\"\"\" LP \"\"\"\nbounds = [(0, 1) for i in range(n_edges)]\nc = [i[2] for i in edges]\n\nA_rows = []\nb_rows = []\nfor source in range(n_nodes):\n    out_inds = np.flatnonzero(edge_matrix[source, :])\n    in_inds = np.flatnonzero(edge_matrix[:, source])\n\n    rhs = 0\n    if source == s_ind:\n        rhs = 1\n    elif source == t_ind:\n        rhs = -1\n\n    n_out = len(out_inds)\n    n_in = len(in_inds)\n\n    out_edges = [edge_dict[a, b] for a, b in np.vstack((np.full(n_out, source), out_inds)).T]\n    in_edges = [edge_dict[a, b] for a, b in np.vstack((in_inds, np.full(n_in, source))).T]\n\n    A_row = np.zeros(n_edges)\n    A_row[out_edges] = 1\n    A_row[in_edges] = -1\n\n    A_rows.append(A_row)\n    b_rows.append(rhs)\n\nA = np.vstack(A_rows)\nb = np.array(b_rows)\nres = linprog(c, A_eq=A, b_eq=b, bounds=bounds)\nprint(res)\n```\n\n\nOutput:\n\n```\nfun: 16.0\nmessage: 'Optimization terminated successfully.'\nnit: 11\nslack: array([1., 1., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 1., 0.])\nstatus: 0\nsuccess: True\n  x: array([0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 1.])\n```\n\n\nThe LP is then looking like:\n\n```\nbounds\n[(0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (0, 1)]\n\nobjective / c\n[8, 10, 4, 10, 3, 25, 18, 9, 7, 5, 7, 3, 2, 2, 3, 4, 9]\n\nconstraint-matrix A_eq / A\n[[ 1.  1.  0.  0.  0.  0.  0.  0.  0. -1.  0.  0.  0.  0.  0. -1.  0.]\n [-1.  0.  1.  1.  0.  0.  0.  0.  0.  0. -1.  0.  0.  0.  0.  0. -1.]\n [ 0.  0. -1.  0.  1.  0.  0.  0.  0.  0.  0. -1.  0.  0.  0.  0.  0.]\n [ 0.  0.  0.  0. -1.  1.  1. -1.  0.  0.  0.  0.  0. -1.  0.  0.  0.]\n [ 0.  0.  0. -1.  0. -1.  0.  1.  1.  0.  0.  0. -1.  0.  0.  0.  0.]\n [ 0. -1.  0.  0.  0.  0. -1.  0.  0.  1.  1.  1.  1.  0.  0.  0.  0.]\n [ 0.  0.  0.  0.  0.  0.  0.  0. -1.  0.  0.  0.  0.  1.  1.  0.  0.]\n [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0. -1.  1.  1.]]\n\nrhs / b\n[ 0  0 -1  0  0  0  1  0]\n```\n\n\nwhich shows that one really should use a solver exploiting sparsity!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Breaking relationship cycles when constructing paths in Cypher\r\n                \r\n\n\nThe graph above can be created with this Cypher script:\n\n```\nCREATE\n    (t1:Token {content: \"Jake\"}),\n    (t2:Token {content: \"wanted\"}),\n    (det:Token {content: \"the\"}),\n    (t3:Token {content: \"dog\"}),\n    (t4:Token {content: \"neighbours\"}),\n    (t5:Token {content: \"had\"}),\n    (t1)-[:PRECEDES {index: 0}]->(t2),      \n    (t2)-[:PRECEDES {index: 1}]->(det),      \n    (det)-[:PRECEDES {index: 2}]->(t3),      \n    (t3)-[:PRECEDES {index: 3}]->(det),      \n    (det)-[:PRECEDES {index: 4}]->(t4),\n    (t4)-[:PRECEDES {index: 5}]->(t5);\n```\n\n\nThis is the graph of the sentence \"Jake wanted the dog the neighbours had\".  Note that the word 'the' appears twice.  In this model each node represents a particular word (not an instance of a word).  However, we should be able to reconstruct the individual sentence, given that we have the index of the sentence in the word encoded in a property on the ```\n:PRECEDES```\n relationship.\n\nIs there any way to query this sentence as a path in Cypher, using the ```\nindex```\n property to avoid entering a cycle on the node representing ```\nthe```\n?\n    ", "Answer": "\r\nI'd like to propose an alternate schema, as the one you have will fall apart and/or perform horribly once you add more sentences.\n\n1) For each sentence, create a node to represent that sentence.\n\n2) Create a relation from that node to each word node in the sentence, and add an index property on the relationship. (You may use a first/end relationship for the first and last element, or add that as a property for easier Cyphers)\n\n3) Run Cyphers on your \"sentence\" nodes instead. Order words by relation Index\n\nThis will make your data much easier to read, query, and write.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path in an undirected and complete graph?\r\n                \r\nI have a question which may be very simple but when deadline is looming the brain stops working so there goes:\n\nI have an undirected complete graph with N nodes in it. I have a starting node and I have the distance matrix from each node to the other nodes. I want to run Dijkstra's algorithm or any other algorithm that would work  to find the shortest way of visiting all the nodes from the starting node. I want to visit each node only once.\nI believe the fact that it is a complete graph where each node is connected to the others would make the problem much easier but I cannot wrap my head around coding it.\nI am using C#. I have already asked another question earlier but this was at an earlier stage where I didn't know much about the problem. \nAre there any code snippets or pseudo codes available out there or if anyone could start me out I would be very thankful.\n\nI have been looking at QuickGraph and its documentation and other online sources but I can't figure out what I need to have as parameters to run the algorithm. more precisely I don't understand the below code:\n\n```\nIVertexAndEdgeListGraph<TVertex, TEdge> graph = ...;\nFunc<TEdge, double> edgeCost = e => 1; // constant cost\nTVertex root = ...;\n// compute shortest paths\nTryFunc<TVertex, TEdge> tryGetPaths = graph.ShortestPathDijkstra(edgeCost, root);\n```\n\n\nThe above code snippet was taken from: http://quickgraph.codeplex.com/wikipage?title=Dijkstra%20Shortest%20Distance%20Example\nif anybody with experience in quickgraph could explain it to me in simple terms what I need to have to make  use the below functions that would save me.\n\nTo explain what I have is I have a list of Points (x,y) from which I want to build a graph but only showing the edges of the shortest path.\n\nlink to my old post:\n    Run Dijkstra's Algorithm on a List<Point> in C#\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Optimal Path in a Graph with Node and Edge Weights\r\n                \r\nConsider the following Directed graph with Node and Edge Weights.\n\nIs there a non NP-Hard algorithm to find out the path of maximal score, where\n```\nscore = sum(node weights) - sum(edge weights)\n```\n\nFor the example graph, maximal score path is along path A -> B -> C -> D. Maximal score being 164 ((77 + 27 + 32 + 84) - (44 + 12 + 0)).\n    ", "Answer": "\r\nI think that there isn't any algorithm that can find the solution in polynomial time, I'm trying to prove that this problem is NP-Hard because we can reduce it to the longest path problem and the longest path problem can be reduced to it.\nHere's my attempt (assuming that both edge and node weights are positive):\n\nReduction from this problem to the longest path problem:\n\nThis problem can be reduced to the longest path problem by splitting each node A into two nodes A-IN and A-OUT, such that these nodes doesn't have any weights, we link incoming edges to A into A-IN, and outgoing edges from A to A-OUT, and add an edge between A-IN and A-OUT with weight equal to -1 times node A's original weight. Now to find a solution to the problem you have to find the longest path in this graph.\n\nReduction from the longest path problem to this problem (and here I'm not sure that I didn't do any mistakes):\n\nThe longest path problem can be reduced to this problem by taking each negative weight edge E between two nodes A and B and create a virtual node AB in the middle of it, we remove E from the graph then add an edge from A to AB with weight 0, and an edge from AB to B with weight 0, and give node AB weight equal to -1 times the weight of the original E.\nSo that was hopefully a proof that you can solve the longest path problem by reducing it to your problem, so if there is a polynomial time solution to your problem then P = NP.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find probability of path in a directed graph?\r\n                \r\nI have a directed weighted graph G=(V,E).\n\nIn this graph the weight of edge(v[i],v[j]) is the count of transition between v[i] and v[j]. \n\nI am trying to determine the best way to accomplish task: how to find the probability P of path from node A to node B \n\nAll weights are positive integers.\n\nFor example, \n\n```\nweight(A,B)=count of transition from A to B\nweight(B,C)=count of transition from B to C\nweight(B,D)=count of transition from B to D\nweight(D,C)=count of transition from D to C\n```\n\n\nAnd we have several paths:\n\n```\nA->B->C \nA->B->D->C\n```\n\n\nSo, how to calculate probability P of these paths and choose the best one?\n    ", "Answer": "\r\nIt can be solved by reducing the problem to shortest path problem, assuming we are indeed discussing probabilities (that means, each weight is in range ```\n[0,1]```\n).\n\nLet the graph be ```\nG=(V,E)```\n, and the probability between two vertices denoted as ```\nw(u,v)```\n.\n\nDefine:\nw'(u,v) = -log(w(u,v))\n\nThe shortest path from some node ```\ns```\n to some node ```\nt```\n is then the shortest path in the graph when using ```\nw'```\n as weight function. You can find the shortest path using Dijkstra's algorithm or Bellman-Ford algorithm\n\nProof:\n\nFor a path ```\nv1->v2->...->vn```\n, its probability is ```\nw(v1,v2) * w(v2,v3) * ... * w(vn-1,vn)```\n.\n\nWhen using ```\nw'```\n as the weight, the cost of this path when using any shortest path algorithm is:\n\n```\nd(v1,vn) = w'(v1,v2) + w'(v2,v3) + ... + w'(vn-1,vn) = \nd(v1,vn) = -log(w(v1,v2)) + -log(w(v2,v3) + ... + -log(w(vn-1,vn)) = \nd(v1,vn) = -1* [ log(w(v1,v2)) + log(w(v2,v3)) + ... + log(w(vn-1,vn)) =\nd(v1,vn) = -1* log(w(v1,v2) * w(v2,v3) * ... * w(vn-1,vn)) \n```\n\n\nThis obviously applies also for the minimal path found from ```\ns```\n to ```\nt```\n.\nThis means that this path have minimal value of: \n\n```\ns(s,t) = -1* log(w(s,v2) * w(v2,v3) * ... * w(vn-1,t)) \n```\n\n\nAnd since log is monotonic function, it is also minimal value of ```\n-1 * w(s,v2) * w(v2,v3) * ... * w(vn-1,t)```\n, which is the maximal value of ```\nw(s,v2) * w(v2,v3) * ... * w(vn-1,t)```\n, and that's exactly the probability.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Can we find all paths from source to destination in an undirect graph without DFS recursion?\r\n                \r\nI am trying to retrieve all possible paths based on some conditions from source to destination using iterative depth-first search (not recursion). I already solved the problem using recursion.\nNow, I am wondering if we can retrieve all paths in an undirected graph from source to destination without help of recursion..\nCan you please help me clarify and explain me what I should do to this problem? Or do you need to stick with recursion for the ease?\n    ", "Answer": "\r\nI'd say you can't do what you are asking even with recursion ... the question does not restrict the graph to being acyclic, and it is undirected, so the simplest counterexample would be two nodes, A and B and if you remove \"acyclic\" and directed from the graph, there are infinite paths from A to B by extending the depth infinitely.\nIf the graph is acyclic, the answer becomes yes, even if you use a brute force method. The breadth first search would be the obvious counterpart to DFS.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Path with the minimum number of alterations in graph with colored edgest\r\n                \r\nI have a directed graph with colored edges (red & blue) that may contain cycles. The question is to write an algorithm given two vertices (s,t) that finds the path with the minimal number of color changes between s and t (if such path exists).\n\nI have found a solution using a variation of Dijkstra (I created a new graph where each vertex correspond to an edge of the previous graph, and contains the color of the edge. For example: if (1,2) is an edge in the old graph, then (1/2) is a vertex in the new one. I connected \"adjacent edges\" vertices, and edges in the new graph that change color got a weight of 1, where same color transition is 0).\n\nI am looking for a solution in linear time (of V and E). The above one uses VxE edges in the new graph. \n\nIs there such solution to find the minimal path?\n    ", "Answer": "\r\nFirst phase: Reduction to the shortest path problem.\n\n\nFor every node ```\ni```\n we create two nodes ```\ni_red```\n and ```\ni_blue```\n. \nFor every blue edge ```\ni->j```\n we create two edges ```\ni_red->j_blue```\n with weight ```\n1```\n and ```\ni_blue->j_blue```\n with weight ```\n0```\n. \nWe handle red edges in similar fashion.  \nWe also need a start node which is connected with ```\nstart_red```\n and ```\nstart_blue```\n with connection weight of ```\n0```\n.\nSimilar to the target node, which is connected with ```\ntarget_red```\n and ```\ntarget_blue```\n with weight ```\n0```\n-connections.\n\n\nNow, search for the shortest path from newly created start node to the newly created target node. There are twice as many nodes and twice as many edges as in the original graph, so the reduction is linear.\n\nAfter you reduced the problem to the shortest path search, you could do the following:\n\n\nStep: use only edges with weight 0, treat the graph as undirected one and with help of bfs you can find all components in this 0-edge-graph in linear time.\nStep: run bfs on the graph where the components from the prior step are glued together as super-nodes, so all edges have weight 1 and bfs will find the shortest path.\n\n\nObviously all three parts of this algorithm (bfs in 0-edge-graph, glueing the components to super-nodes and the bfs in the resulting graph) run in linear time.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Graph theory, all paths with given distance\r\n                \r\nSo I found a problem where a traveller can travel a certain distance in a graph and all bidirectional edges have some length(distance). Suppose when travelling a certain edge(either direction) you get some money/gift (it's given in question for all edges)so you have to find the max money you can collect for the given distance you can travel. Basic problem is how do I find all possible paths with given distance (there might be loops in graph) and after finding all possible paths, path with max money collected will simply be the answer. Note: any possible paths you come up with should not have a loop (straight path).  \n    ", "Answer": "\r\nYou are given an undirected connected graph with double weight on the edges (distance and reward).\nYou are given a fixed number d corresponding to a possible distance.\n\nFor each couple of nodes (u,v), u not equal to v, you are looking for\n\n\nAll the paths {P_j} connecting u and v with no repeating nodes whose total distance is d.\nThe paths {P_hat(j)} subset of {P_j} whose reward is maximal.\n\n\nTo get the first, I would try to use a modified version of the Floyd-Warshall algorithm, where you do not look for the shortest, but for any path. \nFloyd-Warshall uses a strategy based on considering a \"middle node\" w between u and v and recursively finds the path minimising the distance between u and v.\n\nYou can do the same, while taking all path instead of excluding the minimisation, taking care of putting to ```\ninf```\n the nodes where you have already b visited in the distance matrix and excluding at runtime every partial path in the recursion whose distance is longer than d or that arrives to an end (they connects u and v) and whose distance is shorter than d.\n\nCan be generalised if an interval of possible distances [d, D] is given, instead of a single value d, as in this second case you would probably get the empty set all the time.\n\nFor the second step, you simply compare the reward of each of the path found in solving the first step, and you take the best one.\n\nIs more a suggested direction rather than a complete answer, but I hope it helps!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find the longest path in an acyclic directed graph using OGDF library?\r\n                \r\nI'm new to OGDF library and need to find the longest path in an acyclic directed graph (I want to use OGDF built in functions).\nI know, it is possible to find longest path using shortest path algorithms with negative weights for edges, but also could not find a proper function for it.\nDoes OGDF has a specific function to do that?\nIf yes, how can I use it?\n    ", "Answer": "\r\nIn OGDF, you can find the shortest path between node ```\ns```\n and other nodes using ```\nShortestPathWithBFM```\n. The lengths (weights) of edges should be passed to the function, using ```\nEdgeArray<int>```\n. Here is the class definition from its source code:\n\n```\nnamespace ogdf {\n\nclass OGDF_EXPORT ShortestPathWithBFM : public ShortestPathModule\n{\npublic:\n ShortestPathWithBFM() { }\n\n // computes shortest paths\n // Precond.:\n //\n // returns false iff the graph contains a negative cycle\n bool call(\n const Graph          &G,      // directed graph\n const node           s,       // source node\n const EdgeArray<int> &length, // length of an edge\n NodeArray<int>       &d,      // contains shortest path distances after call\n NodeArray<edge>      &pi\n );\n\n\n};\n\n\n} // end namespace ogdf\n```\n\n\nThe algorithm would compute the longest path if you pass lengths in negative.\nFor more information, please refer to: http://www.ogdf.net/doc-ogdf/classogdf_1_1_shortest_path_with_b_f_m.html\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Python Dijkstra Algorithm\r\n                \r\nI am trying to write Dijkstra's Algorithm, however I am struggling on how to 'say' certain things in code.\nTo visualize, here are the columns I want represented using arrays:\n\n```\n   max_nodes  \n   A  B  C         Length       Predecessor       Visited/Unvisited\nA 0  1   2             -1                                              U\nB 1  0   1             -1                                              U\nC 2  1   0             -1                                              U\n```\n\n\nSo, there will be several arrays, as seen in my code below:\n\n```\ndef dijkstra (graph, start, end)\n\nnetwork[max_nodes][max_nodes]\nstate  [max_nodes][length]\nstate2 [max_nodes][predecessor]\nstate3 [max_nodes][visited]\ninitialNode = 0\n\n    for nodes in graph:\n      D[max_nodes][length] = -1\n      P[max_nodes][predecessor] = \"\"\n      V[max_nodes][visited] = false\n\n      for l in graph:\n\n       length = lengthFromSource[node] + graph[node][l]\n          if length < lengthFromSourceNode[w]:\n             state[l][length] = x\n             state2[l][predecessor] \n             state3[l][visited] = true\n          x +=1\n```\n\n\nThe part in bold is where I am stuck on - I am trying to implement this section of the algorithm:\n\n3. For current node, consider all its unvisited neighbors and calculate their tentative distance. For example, if current node (A) has distance of 6, and an edge connecting it with another node (B) is 2, the distance to B through A will be 6+2=8. If this distance is less than the previously recorded distance, overwrite the distance\n4. When we are done considering all neighbors of the current node, mark it as visited. A visited node will not be checked ever again; its distance recorded now is final and minimal\n\nI think I am on the right track, i'm just stuck on how to say 'start at a node, get the length from source to a node, if length is smaller, overwrite previous value, then move to next node\n    ", "Answer": "\r\nI also used a dictionary to store the network.\nData is in the following format:\n```\nsource: {destination: cost}```\n\ncreate a network dictionary (user provided)\n```\nnet = {'0':{'1':100, '2':300},\n       '1':{'3':500, '4':500, '5':100},\n       '2':{'4':100, '5':100},\n       '3':{'5':20},\n       '4':{'5':20},\n       '5':{}\n       }\n```\n\nshortest path algorithm (user needs to specify start and terminal nodes)\n```\ndef dijkstra(net, s, t):\n    # sanity check\n    if s == t:\n        return \"The start and terminal nodes are the same. Minimum distance is 0.\"\n    if s not in net:    # python2: if net.has_key(s)==False:\n        return \"There is no start node called \" + str(s) + \".\"\n    if t not in net:    # python2: if net.has_key(t)==False:\n        return \"There is no terminal node called \" + str(t) + \".\"\n    # create a labels dictionary\n    labels={}\n    # record whether a label was updated\n    order={}\n    # populate an initial labels dictionary\n    for i in net.keys():\n        if i == s: labels[i] = 0 # shortest distance form s to s is 0\n        else: labels[i] = float(\"inf\") # initial labels are infinity\n    from copy import copy\n    drop1 = copy(labels) # used for looping\n    ## begin algorithm\n    while len(drop1) > 0:\n        # find the key with the lowest label\n        minNode = min(drop1, key = drop1.get) #minNode is the node with the smallest label\n        # update labels for nodes that are connected to minNode\n        for i in net[minNode]:\n            if labels[i] > (labels[minNode] + net[minNode][i]):\n                labels[i] = labels[minNode] + net[minNode][i]\n                drop1[i] = labels[minNode] + net[minNode][i]\n                order[i] = minNode\n        del drop1[minNode] # once a node has been visited, it's excluded from drop1\n    ## end algorithm\n    # print shortest path\n    temp = copy(t)\n    rpath = []\n    path = []\n    while 1:\n        rpath.append(temp)\n        if temp in order: temp = order[temp]    #if order.has_key(temp): temp = order[temp]\n        else: return \"There is no path from \" + str(s) + \" to \" + str(t) + \".\"\n        if temp == s:\n            rpath.append(temp)\n            break\n    for j in range(len(rpath)-1,-1,-1):\n        path.append(rpath[j])\n    return \"The shortest path from \" + s + \" to \" + t + \" is \" + str(path) + \". Minimum distance is \" + str(labels[t]) + \".\"\n\n# Given a large random network find the shortest path from '0' to '5'\nprint dijkstra(net, s='0', t='5')\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding all possible simple path in an undirected graph is NP hard/ NP complete\r\n                \r\nThe proof is needed:\nFinding all possible simple path in an undirected graph is NP hard/ NP complete. The graph may contain multiple edges between same pair of nodes, and loops.\nI have searched over, got some idea or discussion. But I need a direct proof/link stating the complexity is NPC/ NP-Hard.\n    ", "Answer": "\r\nProblems of the form \"find all objects of some type\" aren't NP-complete, because NP consists purely of decision problems, questions that have a yes/no answer. So this problem can't be NP-complete.\nIf you specifically have to list the paths in descending order of size, then the problem would be NP-hard. If you can list all paths in descending size order, then you can just check the first path to see if it passes through all nodes. If so, great! Your graph has a Hamiltonian path, and finding Hamiltonian paths is NP-hard.\nOn the other hand, if you listed the paths in ascending order of length, then assuming you're working with Turing machines the cost of simply reading all the paths to get to the last one would take more than polynomial time, so this reduction wouldn't work. A similar argument shows that this reduction won't work if the paths come back in arbitrary order. I suspect, but am not fully sure, that it's unknown whether that version of the problem is NP-hard, but I'm open to being corrected on that.\nThis is all the more interesting given that the number of simple paths in a graph can be O(n!), which happens when the graph is a complete graph (all pairs of nodes are linked by edges). The fact that something takes a long time to complete doesn’t immediately mean that it’s NP-hard or NP-complete.\nHope this helps!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "What is the best way to route paths in a large grid?\r\n                \r\nI'm working on an algorithm to find a set of non intersected paths in a grid for a \ngiven pairs of points..\nLike this for these pairs:\n(9,4) and (12,13)\n\n\nThe output should be something like this:\n\n```\n    9,10,11,7,3,4\n\n    13,14,15,16,12\n```\n\n\nand print \"Blocked\" if it can't route all paths\n\nFirst I searched for an already made algorithm to find all simple paths between 2 \npoints in a graph or a grid. and I found this one by @Casey Watson and @svick here.. \nIt works really well but for small graphs only.\n\nI converted it to C#.NET and enhanced it a little bit to be able to find paths of \nmaximum length X. and build on it my total algorithm.\n\nThe one I built works fine in small graphs..\nHere is routes 9 pairs in a 8x8 grid..\n\n\nbut it takes a huge time in larger ones like the 16x16 or even the final one I intended to do which is a 3D model of 16x16x2\nLike this\n\n\n\nThe algorithm was developed to be a depth first search RECURSIVE algorithm, but it \ntook a huge time to return value to the user. so I decided to convert it to loops instead of the recursive calls so that I can benefit from yield return feature in .NET\nbut still it didn't help any better.\n\nThe loops version of the algorithm find a route for a pair of points in less than a second but the recursive one took more than 90 seconds.\n\n\n\nwhen I tried with 2 pairs, the loops version took around 342 seconds but the recursive one took around 200..\n\n\n\nSo I can't know which is faster..!? the recursive or the loops one..\n\nI really want to know the best way to do this..\n\nNote : the first digit in the number of the node determine the layer (Starts at 1)..\n\nHere is the code\n\n```\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.Diagnostics;\n    using System.IO;\n    using System.Linq;\n\n    namespace AlgorithmTest\n    {\n     struct Connection\n    {\n    public int FirstNode;\n    public int SecondNode;\n\n    public Connection(int N1,int N2)\n    {\n        FirstNode = N1;\n        SecondNode = N2;\n    }\n}\nenum Algorithm\n{ Recursion, Loops }\n\npublic class Search\n{\n\n    private const int MAX = 15;\n\n    private const int Width = 16;\n    private const int Length = 16;\n    private const int Height = 2;\n\n\n\n    private static void Main(string[] args)\n    {\n\n\n        var graph = new Graph();\n\n\n        var str = new int[Height,Length, Width];\n        var level = ((int)Math.Pow(10, (Length * Width).ToString().Length) >= 100) ? (int)Math.Pow(10, (Length * Width).ToString().Length) : 100;              \n        for (var i = 0; i < Height; i++)\n        {\n            int num = 0;\n            for (var j = 0; j < Length; j++)\n                for (var k = 0; k < Width; k++)\n            {\n                str[i, j, k] = ++num + level;\n\n            }\n            level += level;\n        }\n\n\n        for (var i = 0; i < Height; i++)\n        {\n            for (var j = 0; j < Length; j++)\n            {\n                for (var k = 0; k < Width; k++)\n                {\n\n                    if (i < Height - 1) graph.addEdge(str[i, j, k], str[i + 1, j, k]);\n                    if (i > 0) graph.addEdge(str[i, j, k], str[i - 1, j, k]);\n\n                    if (k < Width - 1) graph.addEdge(str[i, j, k], str[i, j, k + 1]);\n                    if (k > 0) graph.addEdge(str[i, j, k], str[i, j, k - 1]);\n\n                    if (j < Length - 1) graph.addEdge(str[i, j, k], str[i, j + 1, k]);\n                    if (j > 0) graph.addEdge(str[i, j, k], str[i, j - 1, k]);\n\n\n                }\n            }\n        }\n\n\n\n        var wt = new Stopwatch();\n\n       wt.Start();\n        var connectedNodes = new List<Connection>()\n                                 {\n\n\n\n                                     new Connection(1030, 1005),\n       //                              new Connection(1002, 1044),\n    //                                         new Connection(1015, 1064),\n    //                                        new Connection(1041, 1038),\n    //                                         new Connection(1009, 1027),\n    //                                         new Connection(1025, 1018),\n    //                                         new Connection(1037, 1054),\n    //                                         new Connection(1049, 1060),\n    //                                         new Connection(1008, 1031),\n    //                                         new Connection(1001, 1035),\n\n                                 };\n        wt.Start();\n        Console.WriteLine(\"Using Loops:\");\n        Console.WriteLine();\n        var allPaths = new Search().FindAllPaths(connectedNodes, graph, MAX, Algorithm.Loops);\n        wt.Stop();\n        foreach (var path in allPaths)\n        {\n            PrintPath(path);\n        }\n        Console.WriteLine(\"Total Seconds: \" + wt.Elapsed.TotalSeconds + \", Number of paths: \" + allPaths.Count());\n        Console.WriteLine(\"***************************************************************************************************\");\n        Console.WriteLine(\"Using Recursion:\");\n        Console.WriteLine();\n        wt.Reset();\n        wt.Start();\n        allPaths = new Search().FindAllPaths(connectedNodes, graph, MAX, Algorithm.Recursion);\n        wt.Stop();\n        foreach (var path in allPaths)\n        {\n            PrintPath(path);\n        }\n        Console.WriteLine(\"Total Seconds: \" + wt.Elapsed.TotalSeconds + \", Number of paths: \" + allPaths.Count());\n        Console.WriteLine();\n\n    }\n\n    private IEnumerable<List<int>> FindAllPaths(List<Connection> connectedNodes, Graph graph, int max, Algorithm algorithm)\n    {\n        var paths=new Stack<List<int>>();\n        var blocked=new List<int>();\n\n        for (var i = 0; i < connectedNodes.Count; i++)\n        {\n            if (!blocked.Contains(connectedNodes[i].FirstNode)) blocked.Add(connectedNodes[i].FirstNode);\n            if (!blocked.Contains(connectedNodes[i].SecondNode)) blocked.Add(connectedNodes[i].SecondNode);\n        }\n\n        if (algorithm == Algorithm.Recursion)\n        {\n            if (FindAllPaths(connectedNodes, 0, max, graph, paths, blocked))\n            {\n                Console.WriteLine(\"BLOCKED\");\n                return new List<List<int>>();\n            }\n        }\n        else if(algorithm==Algorithm.Loops)\n        {\n            if (!FindAllPaths2(connectedNodes, 0, max, graph, paths, blocked))\n            {\n                Console.WriteLine(\"BLOCKED\");\n                return new List<List<int>>();\n            }\n        }\n\n        return paths;\n\n    }\n    private static bool FindAllPaths(List<Connection> connectedNodes,int order,int max, Graph graph, Stack<List<int>> allPaths, List<int> blocked)\n    {\n\n        if (order >= connectedNodes.Count) return false;\n\n\n        var paths = SearchForPaths(graph, connectedNodes[order].FirstNode, connectedNodes[order].SecondNode, max, blocked);\n        if (paths.Count == 0) return true;\n        int i;\n        for (i = 0; i < paths.Count; i++)\n        {\n            var path = paths[i];\n            allPaths.Push(path);\n            blocked.AddRange(path);\n\n\n            if (!FindAllPaths(connectedNodes, order + 1,max, graph, allPaths, blocked)) break;\n\n            allPaths.Pop();\n            foreach (var j in path)\n            {\n                blocked.RemoveAll(num => num==j);\n            }\n\n            paths.RemoveAll(list => IsListsSimilar(list,path));\n\n            i--;\n\n        }\n        if (i == paths.Count) return true;\n\n\n        return false;\n\n    }\n\n    private static bool IsListsSimilar(List<int> L1,List<int> L2)\n    {\n        if (L2.Count > L1.Count) return false;\n\n        for (int i = 0; i < L2.Count - 1; i++)\n        {\n            if (L1[i] != L2[i]) return false;\n        }\n        return true;\n    }\n\n    private static List<List<int>> SearchForPaths(Graph graph, int start, int end, int max, List<int> blocked)\n    {\n        blocked.Remove(start);\n        blocked.Remove(end);\n\n\n\n\n        var nodePaths = new List<List<int>>();\n        var visited = new LinkedList<int>();\n        visited.AddLast(start);\n        DepthFirstSearch(graph, visited, end, max, blocked, nodePaths);\n\n\n\n        nodePaths = nodePaths.OrderBy(list => list.Count).ToList();\n\n        return nodePaths;\n\n    }\n    private static void DepthFirstSearch(Graph graph, LinkedList<int> visited, int end, int max, List<int> blocked, List<List<int>> paths)\n    {\n        var nodes = graph.adjacentNodes(visited.Last.Value);\n        // examine adjacent nodes\n        var nodeCount = blocked.Count;\n        for (int i = 0; i < nodeCount; i++)\n        {\n            if (visited.Contains(blocked[i])) return;\n        }\n\n        if (visited.Count > max) return;\n\n\n        nodeCount = nodes.Count;\n        for (var i = 0; i < nodeCount; i++)\n        {\n            if (visited.Contains(nodes[i]) || nodes[i] != end) continue;\n\n            visited.AddLast(nodes[i]);\n\n            {\n                paths.Add(new List<int>(visited));\n\n            }\n            visited.RemoveLast();\n            break;\n        }\n\n\n\n        nodeCount = nodes.Count;\n        for (var i = 0; i < nodeCount; i++)\n        {\n            if (visited.Contains(nodes[i]) || nodes[i] == end) continue;\n\n            visited.AddLast(nodes[i]);\n            DepthFirstSearch(graph, visited, end, max, blocked, paths);\n            visited.RemoveLast();\n        }\n\n    }\n\n    private static bool FindAllPaths2(List<Connection> connectedNodes, int order, int max, Graph graph, Stack<List<int>> allPaths, List<int> blocked)\n    {\n\n        if (order >= connectedNodes.Count) return false;\n\n\n        foreach (var path in SearchForPaths2(graph, connectedNodes[order].FirstNode, connectedNodes[order].SecondNode, max, blocked))\n        {\n\n            allPaths.Push(path);\n            blocked.AddRange(path);\n\n\n            if (!FindAllPaths2(connectedNodes, order + 1, max, graph, allPaths, blocked)) break;\n\n            allPaths.Pop();\n            foreach (var j in path)\n            {\n                blocked.RemoveAll(num => num == j);\n            }\n\n\n        }\n\n\n\n\n        return true;\n\n    }\n    private static IEnumerable<List<int>> SearchForPaths2(Graph graph, int start, int end, int max, List<int> blocked)\n    {\n        blocked.Remove(start);\n        blocked.Remove(end);\n\n\n        var visited = new LinkedList<int>();\n        visited.AddLast(start);\n        foreach (var VARIABLE in DepthFirstSearch(graph, visited, end, max, blocked))\n        {\n            yield return VARIABLE;\n        }\n\n    }\n    private static IEnumerable<List<int>> DepthFirstSearch(Graph graph, LinkedList<int> visited, int end, int max, List<int> blocked)\n    {\n\n\n\n\n\n        var nodes = graph.adjacentNodes(visited.Last.Value);\n\n\n        var nodeCount = blocked.Count;\n        for (int i = 0; i < nodeCount; i++)\n        {\n            if (visited.Contains(blocked[i])) yield break;\n        }\n\n\n        if (visited.Count > max) yield break;\n\n        nodeCount = nodes.Count;\n        for (var i = 0; i < nodeCount; i++)\n        {\n            if (visited.Contains(nodes[i]) || nodes[i] != end) continue;\n\n            visited.AddLast(nodes[i]);\n\n            yield return (new List<int>(visited));\n            visited.RemoveLast();\n            break;\n        }\n\n\n\n\n        nodeCount = nodes.Count;\n        for (var i = 0; i < nodeCount; i++)\n        {\n            if (visited.Contains(nodes[i]) || nodes[i] == end) continue;\n\n            visited.AddLast(nodes[i]);\n            foreach (var P in DepthFirstSearch(graph, visited, end, max, blocked))\n            {\n\n                yield return P;\n\n            }\n\n            visited.RemoveLast();\n\n        }\n\n\n\n\n\n\n    }\n\n\n    private static void PrintPath(List<int> visited)\n    {\n\n        for (int i = 0; i < visited.Count()-1; i++)\n        {\n            Console.Write(visited[i]);\n            Console.Write(\" --> \");\n        }\n        Console.Write(visited[visited.Count() - 1]);\n\n        Console.WriteLine();\n        Console.WriteLine();\n\n    }\n\n\n}\npublic class Graph\n{\n    private readonly Dictionary<int, HashSet<int>> map = new Dictionary<int, HashSet<int>>();\n\n    public void addEdge(int node1, int node2)\n    {\n        HashSet<int> adjacent = null;\n\n        map.TryGetValue(node1, out adjacent);\n\n        if (adjacent == null)\n        {\n            adjacent = new HashSet<int>();\n            map.Add(node1, adjacent);\n        }\n        adjacent.Add(node2);\n    }\n\n    public List<int> adjacentNodes(int last)\n    {\n        HashSet<int> adjacent = null;\n\n        map.TryGetValue(last, out adjacent);\n\n        if (adjacent == null)\n        {\n            return new List<int>();\n        }\n        return new List<int>(adjacent);\n    }\n}\n    }\n```\n\n    ", "Answer": "\r\nI think the answer lies in how you have numbered the nodes in your grid.  For a simple 2-dimensional grid, 4 nodes by 4, you would number them : 00, 01, 02, 03, 10, 11, 12 ... 30, 31, 32, 33. Think of them as composite number strings (not decimal values) acting as dimension-based node addresses.\nIn a 3-dimensional grid, they would be numbered 000, 001, 002, etc. up to 330, 331, 332, 333.\nIf you want to find all routes between two points 10 and 22 you can quickly calculate their distance by adding the dimensional differences: 1y is one away from 2y, and x0 is two away from x2. Therefore the node distance is 3, you will need to travel over 3 edges (connecting 4 nodes in total) to reach the destination.\nThe solution space (the only nodes that could ever be involved in a solution route) can be enumerated by creating a set of embedded FOR/NEXT loops, one for each dimension. In this case, the start and end values of 10 and 22 would produce: 10, 11, 12, 20, 21 and 22.\nNow comes the clever bit. You can precompute (prepare) a table of 'forwarding' connections between the nodes in your array. Node 10 connects to 20 and 11 (both 1 dimensional difference away). From that you can generate a sequence of valid pathways from 10 to 22 by adding one to a dimension difference in which ever direction you plan to move (in a 2-D array you only get to choose one of two ways. In 3-D you get three choices).\nEach answer should be the shortest possible distance. The computation time for this approach should be milliseconds. On a steam powered ZX81!\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Longest Simple Path In Sparse Cyclic Graphs\r\n                \r\nGiven: An unweighted, directed Graph (G=(E,V)), which can contain any number of cycles.\n\nGoal: For all vertices I want the longest simple path to some target vertex X in V\n\nAlgorithm Idea:\n\n```\nFor each v in V\n  v.distanceToTarget = DepthFirstSearch(v)\nNext\n\nDepthFirstSearch(v as Vertex)\n  if v = target then\n    'Distance towards target is 0 for target itself\n    return 0\n  elseif v.isVisitedInCurrentDFSPath then\n    'Cycle found -> I wont find the target when I go around in cycles -> abort\n    return -infinity\n  else\n    'Return the maximum Distance of all Successors + 1\n    return max(v.Successors.ForEach(Function(v) DepthFirstSearch(v) )) + 1\n  end if\n```\n\n\nIs this correct for all cases? (Assuming, that the target can be reached from every vertex)\n\nThe number of edges in my graphs is very small. \nAssume |E| <= 3*|V| holds. How would I compute the average time complexity?\n\nThanks!\n    ", "Answer": "\r\nTime complexity is about what values influence your runtime most. In your case your evaluating all possible paths between v and target. That is basically O(number of routes). Now you need to figure out how to express number of all possible routes in terms of E and V.\n\nMost likely result with be something like O(exp(E)) or O(exp(V)) because number of routes going through each node/vertex goes exponentially when you add new possible routes.\n\nEDIT: I missed a detail that you were asking for average time complexity that would mean amortized complexity. But as your algorithm is always evaluates all possible routes worst case complexity is same as average complexity.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest path Graph BFS python\r\n                \r\nTrying to return the int for shortest path in a graph, using BFS. The idea is to use a q, append into the q as [node,distance] and then when we traverse increase distance and keep track of the count and when we hit our destination first time that means we found shortest path so we return that. But I got error \"   currNode,distance = q.popleft()\nValueError: not enough values to unpack (expected 2, got 1)\"\n```\ndef shortestPath(graph,nodeA,nodeB):\n    q = deque((nodeA,0))\n    visited = set(nodeA)\n\n    while q:\n        currNode,distance = q.popleft()\n        if currNode == nodeB:\n            return distance\n        for neighbor in graph[currNode]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                q.append([neighbor,distance+1])\n            \n\n    return -1\n\ngraph_three = {\n    'w':['x','v'],\n    'x':['w','y'],\n    'y':['x','z'],\n    'z':['y','v'],\n    'v':['z','w']\n}\n\nprint(shortestPath(graph_three,'w','z'))\n```\n\n    ", "Answer": "\r\nDeque takes an iterable of elements as input, you gave it a tuple so your deque will contains two elements instead of the expected one tuple of two elements.\nfix line 2 into:\n```\nq = deque([(nodeA,0)])\n```\n\nalso here is a cleaner implementation of BFS:\n```\ndef shortestPath(graph, root, target):\n    if root == target: return 0\n    q = collections.deque(root)\n    visited = set(root)\n    distance = 0\n    while q:\n        for _ in range(len(q)):\n            node = q.popleft()\n            for neighbor in graph[node]:\n                if neighbor == target:\n                    return distance + 1\n                elif neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        distance += 1\n    return -1\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding Hamiltonian path in an undirected sparse graph\r\n                \r\nI have an undirected graph that I know will always have a hamiltonian path\n\nSo I've implemented DFS with backtracking to find one solution and return it.\n\n\nThe problem is that it takes a lot of time to find a solution when I have a sparse graph.\n\nFor example:\n\nI have 50 nodes with 1000 edges, it will take 100 ms to find a solution\n\nI have 50 nodes with 100 edges, it will take 10000 ms to find a solution\n\nI have 100 nodes with 3000 edges, it will take 100 ms to find a solution\n\nI have 100 nodes with 200 edges, it will take several hours to find a solution\n\nIs there any better way to find only one hamiltonian path for sparse graphs? It's already really fast in dense graphs since I'm looking for only one solutions among severals, but in sparse graphs, since there are way less solutions, DFS with backtracking doesn't seem like a good choice (I have to be really lucky to find the solution rapidly).\n\nThank you!\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All the paths between 2 nodes in graph\r\n                \r\nI have to make an uninformed search (Breadth-first-Search) program which takes two nodes and return all the paths between them. \n\n```\npublic void BFS(Nod start, Nod end) {\n            Queue<Nod> queue = new Queue<Nod>();\n            queue.Enqueue(start);\n            while (queue.Count != 0)\n            {\n                Nod u = queue.Dequeue();\n                if (u == end)  break;\n                else\n                {\n                    u.data = \"Visited\";\n                    foreach (Edge edge in u.getChildren())\n                    {\n                        if (edge.getEnd().data == \"\")\n                        {\n                            edge.getEnd().data = \"Visited\";\n                            if (edge.getEnd() != end)\n                            {\n                                edge.getEnd().setParent(u);\n                            }\n                            else\n                            {\n                                edge.getEnd().setParent(u);\n                                cost = 0; \n                                PrintPath(edge.getEnd(), true);\n                                edge.getEnd().data = \"\";\n                                //return;\n                            }\n                        }\n                        queue.Enqueue(edge.getEnd());\n                    }\n                }\n            }\n        }\n```\n\n\nMy problem is that i only get two paths instead of all and i don't know what to edit in my code to get them all. The input of my problem is based on this map :   \n    ", "Answer": "\r\nIn the BFS algorithm you must not stop after you find a solution. One idea is to set data null for all the cities you visited except the first one and let the function run a little bit longer. I don't have time to write you a snippet but if ou don't get it i will write at least a pseudocode. If you didn't understood my idea post a comment with your question and i will try to explain better.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "All the paths between 2 nodes in graph\r\n                \r\nI have to make an uninformed search (Breadth-first-Search) program which takes two nodes and return all the paths between them. \n\n```\npublic void BFS(Nod start, Nod end) {\n            Queue<Nod> queue = new Queue<Nod>();\n            queue.Enqueue(start);\n            while (queue.Count != 0)\n            {\n                Nod u = queue.Dequeue();\n                if (u == end)  break;\n                else\n                {\n                    u.data = \"Visited\";\n                    foreach (Edge edge in u.getChildren())\n                    {\n                        if (edge.getEnd().data == \"\")\n                        {\n                            edge.getEnd().data = \"Visited\";\n                            if (edge.getEnd() != end)\n                            {\n                                edge.getEnd().setParent(u);\n                            }\n                            else\n                            {\n                                edge.getEnd().setParent(u);\n                                cost = 0; \n                                PrintPath(edge.getEnd(), true);\n                                edge.getEnd().data = \"\";\n                                //return;\n                            }\n                        }\n                        queue.Enqueue(edge.getEnd());\n                    }\n                }\n            }\n        }\n```\n\n\nMy problem is that i only get two paths instead of all and i don't know what to edit in my code to get them all. The input of my problem is based on this map :   \n    ", "Answer": "\r\nIn the BFS algorithm you must not stop after you find a solution. One idea is to set data null for all the cities you visited except the first one and let the function run a little bit longer. I don't have time to write you a snippet but if ou don't get it i will write at least a pseudocode. If you didn't understood my idea post a comment with your question and i will try to explain better.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Graph theory - Start from vertex A, go through all paths in both directions and end up in A again the shortest way\r\n                \r\nI am trying to find the name of this problem but don't really know how to search for it. The problem is the following:\n\n\n  Find the path in a graph where you start from vertex A, go\n  through all edges exactly two times per edge in BOTH directions (one\n  time in one direction, second time in the opposite) and end up in\n  vertex A again as a last step.\n\n\nWould love it if somebody gave me some hints as to how this problem is called (because it sounds like a well-known one) and maybe some directions for its solution.\n    ", "Answer": "\r\nIf you just want to traverse each edge of a connected graph once in each direction then you can use a depth-first search:\n\n\nPick any vertex as the starting point.\nFrom the current vertex and pick any unvisited incident edge.\n\n\nMark that edge as visited.\nIf the other end of the edge is an unvisited vertex then move to that new vertex, mark it as visited and then repeat the process from that new vertex.\nIf the other end of the edge is a visited vertex then immediately backtrack (traversing the edge a second time but in the opposite direction) and continue processing edges connected to the current vertex.\nOnce all incident edges to the current vertex have been visited then backtrack along the edge which initially brought you to that vertex and return to processing the edges connected to that previous vertex.\n\n\n\nOnce the DFS has completed then you will have traversed each edge exactly once in each direction.\n\nYou could equally use a breadth-first search instead of a depth-first search.\n\nIf you want to visit all the edges in a cycle (without backtracking in the middle of the path) then you are looking for an Eulerian circuit/tour and can use Hierholzer's 1873 algorithm:\n\nWikipedia\n\n\n  \n  Choose any starting vertex v, and follow a trail of edges from that vertex until returning to v. It is not possible to get stuck at any vertex other than v, because the even degree of all vertices ensures that, when the trail enters another vertex w there must be an unused edge leaving w. The tour formed in this way is a closed tour, but may not cover all the vertices and edges of the initial graph.\n  As long as there exists a vertex u that belongs to the current tour but that has adjacent edges not part of the tour, start another trail from u, following unused edges until returning to u, and join the tour formed in this way to the previous tour.\n  \n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Algorithm to determine optimal path in weighted graph\r\n                \r\nThis is my practice questions for test, i checked about weighted graph and some related materials but got stuck to start so need some ideas on this to start with.\n\nSuppose that you want to get from your house at node s to your mate’s\nhouse at node t in a weighted graph G = (V,E,w). But you would like to stop by the local Fish’n\nChips place at node u if it is possible to do so without increasing the length of your path by more\nthan 20%.\n\n(a) Describe an efficient algorithm that would determine an optimal s → t path given your preference for stopping at u along the way if doing so is not prohibitively costly. (It should either\nreturn the shortest path from s to t or the shortest path from s to t containing u, depending\non the situation.) You should make your algorithm run as efficiently as possible\n    ", "Answer": "\r\nTry this Dijkstra algorithm. Find shortest path from s to t, s to u, and u to t. Then, with a little help of mathematics(s to u + u to t > s to t * 1.20) you can see your answer. Cheers.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to get the longest path in Python for an undirected graph, limited by specified weight?\r\n                \r\nMy objective is to determine a way to find the longest path in a given graph, limited by the maximum total weight of the visited edges. Edges cannot be visited twice.\n```\nimport networkx as nx\n\nG = nx.Graph()\n\nG.add_edge(0,1, weight=10)\nG.add_edge(0,2, weight=10)\nG.add_edge(1,2, weight=10)\nG.add_edge(2,3, weight=10)\nG.add_edge(3,4, weight=10)\nG.add_edge(1,5, weight=20)\nG.add_edge(4,1, weight=10)\nG.add_edge(5,6, weight=10)\n```\n\nMy objective here is to write a function in Python to identify the longest path. The function must take the arguments ```\nmaximum_total_weight```\n which limits the length of the longest path, and ```\nstarting_node```\n which is where the path starts.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Finding paths that cover every node once in weighted directed graph (any language)\r\n                \r\nI have a directed, weighted graph.  It may or may not be connected, and the components may or may not be connected as well.  I have two goals:\n\n\nAt the very least, come up with a list of paths (may have to be combination of paths if entire graph is not connected) that visits every node once and only once.\nIf possible, find the shortest path (or combination of paths in the case that the graph is not connected) that visits every node once and only once.\n\n\nCurrently, I'm thinking the simplest way would just be to find all of the connected components (using dfs, right?) and then within each component recurse through every possible choice of node and sort through the paths that I'm left with to find the shortest one.\n\nAny other ideas?\n    ", "Answer": "\r\nExactly as you said, I would start discovering the connected components using BFS and inside each graph you can apply TSP(Traveling Salesman Problem) algorithm.  \n\nYou can find enought details about the algorithm on here\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to find the longest simple path in a graph?\r\n                \r\nI know that for non-directed graph this problem is NP-complete hence we should do Brute Force in order to check all possible paths. How we can do that? Please suggest a pseudo code and tell me the complexity of that algorithm.\n\nIf there are optimizations, then that would be awesome!\n    ", "Answer": "\r\nA naïvem approach could run through all possible vertex permutations.\n\nFor every permutation ```\n{v1, ..., vN}```\n you check if you can get from ```\nv1```\n to ```\nv2```\n, then from ```\nv2```\n to ```\nv3```\n etc. If you can, add corresponding edge length to the current path length. If not, go to the next permutation.\n\nThe longest of such paths is your answer.\n\n\n\nOr, you could do pretty much the same using recursion.\n\n```\npath = 0\nbestPath = 0\nused = new bool[N] // initialize with falses\nfor(u = 0; u < N; u++)\n    Path(u); // build paths starting from u\nprint bestPath\n```\n\n\nwhere\n\n```\nPath(u)\n    used[u] = true\n    foreach v in neighborhood(u)\n        if(!used[v])\n            path += distance(u, v)\n            bestPath = max(bestPath, path)\n            Path(v)\n            path -= distance(u, v)\n    used[u] = false\n```\n\n\nTime complexity is horrible ```\nO(N * N^N)```\n.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Getting SIGSEGV error in shortest path finding in graph\r\n                \r\nThe question is to calculate the length of the shortest path to each vertex starting from 0 to all other vertices and store them inside a array and then print that array.\nI have written the following code but the code is giving me SIGSEGV in all of the online compliers\n```\n   #include<bits/stdc++.h>\nusing namespace std;\n\nclass Graph\n{\n    private :\n    int v;\n    vector<int>*adj;\n    \n    public:\n      Graph(int v){\n          this->v = v;\n          adj = new vector<int>[v];\n      }\n      \n      void insert(int x,int y)\n      {\n         adj[x].push_back(y);\n         adj[y].push_back(x);\n      }\n      \n      void print()\n      {\n        for(int i=0;i<v;i++)\n        {\n         for(int j=0;j<adj[i].size();j++)\n          cout<<adj[i][j]<<\" \";\n          \n          cout<<endl;\n        }\n      }\n      \n      void shortestPath(int source)\n      {\n          cout<<\"v here is \"<<v<<endl;\n        bool visited[v];\n        int dist[v];\n        for(int i=0;i,v;i++)\n         visited[i] = false;\n        \n        for(int i=0;i<v;i++)\n         dist[i] = INT_MAX;\n         \n        queue<int>q;\n        \n        q.push(0);\n        visited[0] = true;\n        dist[0] = 0;\n        \n        while(!q.empty())\n        {\n            cout<<\"i am here\"<<endl;\n          int j = q.front();\n           q.pop();\n           \n          for(int i : adj[j])\n          {\n             if(!visited[i])\n             {\n                 visited[i] = true;\n                 dist[i] = dist[j]+1;\n                 q.push(i);\n             }\n          }\n          \n        }\n  \n       cout<<\"the output array for the shortest path is\"<<endl;        \n        for(int i=0;i<v;i++)\n          cout<<dist[i]<<\" \";\n          \n      }\n};\n\n\nint main()\n{\n    Graph g(4);\n    g.insert(0,1);\n    g.insert(1,2);\n    g.insert(2,3);\n    g.insert(0,2);\n    g.insert(1,3);\n    \n    g.shortestPath(0);\n    \n}\n\n```\n\nplease help me identify my mistake\nmy code basically has an adjacency list for my graph\nthanks a lot in advance.\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Find path in an undirected graph BFS - Java\r\n                \r\nI'm making a program to deal with an undirected graph with unweighted edges and since I'm a learner I'm having some issues.\n\nI have to make a method (in the same class as the main) which receives the graph, a initial vertex and an end vertex. Then I have to find if there is a  path from vertex1 to the vertex2 and store the intermediate vertices in a queue to then print it (it doesn't have to be the shortest, ofc it's better if that's possible but don't really need it).\n\nLet's say I have:\n\nGraph\n\nAnd I wanna get the only ONE path from\n\nI have implemeted a bfs method, which is the following and is used for other methods I have also, but I don't know how to start with this method I need.\nMy bfs method:\n\n```\n    public static Queue<DecoratedInmate> bfs (Graph gr, Vertex<DecoratedInmate> v){\n    Queue<Vertex<DecoratedInmate>> vertices = new LinkedList<Vertex<DecoratedInmate>>();   //temporal queue\n    Queue<DecoratedInmate> traversal = new LinkedList<DecoratedInmate>();   //traversal queue\n    Vertex<DecoratedInmate> u;  //vertex taken from queue\n    Vertex<DecoratedInmate> z;  //opposite vertex of u\n    Edge e; //edge between vertices\n    Iterator<Edge<DecoratedInmate>> it; //to store incident edges\n    v.getElement().setVisited(true);    //set received vertex to visited\n    vertices.offer(v); //add origin vertex to queue\n    while (!vertices.isEmpty()) {  //if queue isn't empty\n        u = vertices.remove(); //take vertex from queue\n        traversal.offer(u.getElement());    //add element to list\n        it = gr.incidentEdges(u);   //get incident edges of u\n        while (it.hasNext()) {  //check if there are incident edges\n            e = it.next();      //assign the edge\n            z = gr.opposite(u, e);  //assign opposite vertex of u\n            if (!z.getElement().getVisited()) { //check if the opposite is not visited\n                z.getElement().setVisited(true);    //set to visited\n                vertices.offer(z); //add to queue\n            }\n        }\n    }\n    return traversal;\n}\n```\n\n\nThanks in advance\n    ", "Answer": "\r\nMy understanding of your problem is that you are trying to find a path from one node to another and not necessarily how they are visited. So here is an implementation. When running bfs, store each vertex parents i.e\n\n```\n    public static void Bfs(Vertex source) {\n    vertex = GraphifyGUI.getNode();\n    reset();\n    q = new LinkedList<>(); // FIFO\n    source.wasVisited = true; // marked as visited\n    q.add(source); // put into queue\n    source.parent = source; // set parent\n    conn = new ArrayList<>();\n    while (!q.isEmpty()) { // source\n        Vertex current = q.poll(); // remove first \n        conn.add(current.getId());\n        Iterator<Vertex> currentList = current.vList().iterator();\n        while (currentList.hasNext()) {\n            Vertex next = currentList.next();\n            if (next.wasVisited == false) {\n                next.wasVisited = true;\n                q.add(next);\n                next.parent = current;\n                GG.printlnConsole(next.getName() + \" has type of \" + next.getType());\n            }\n        }\n    }\n    GG.printlnConsole(\"Order is \" + conn);\n}\n```\n\n\nAnd then method to get shortest path will look like this \n\n```\n   public void shortestPath(int v, int e) {\n    if (e == v) {\n        GG.printlnConsole(v + \"-->\" + v);\n        return;\n    }\n    for (int i = e; i >= 0; i = vertex.get(i).getParent().getId()) {\n        if (i == v) {\n            break;\n        }\n        if (vertex.get(i).getParent().getId() != -1) {\n            set.put(vertex.get(i).getParent().getId(), i);\n        }\n    }\n}\n```\n\n\nExplanation of shortestPath above\n\n```\nif this source is the same as destination then that is shortest path\nfor(i = destination; i >= 0; i = parent of i){\n    if(i == source) we are done;\n    if(parent of i is a node) add as path;\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "how to save shortest path in dijkstra algorithm\r\n                \r\nSo first let's define Dijkstra algorithm:\nDijkstra's algorithm finds single-source shortest paths in a directed graph with non-negative edge weights.\nI want to know how can I save the shortest path form s to t with Dijkstra algorithm.\nI searched on google, but I couldn't find anything particular; I also changed Dijkstra algorithm, but I could't get any answer. How can I save the shortest path from s to t with Dijkstra?\nI know my question is basic and unprofessional, but any help would be appreciated. Thanks for considering my question.\n    ", "Answer": "\r\nIf you look at the pseudocode from the Wikipedia link you gave, you'll see an array in there called ```\nprev[]```\n. This array contains, for each node v in the graph, the previous node u in the shortest path between the source node s and v. (This array is also called the predecessor or parent array.)\n\nIn other words, the shortest path between s and v is:\n\n```\ns -> u -> v\nwhere u = prev[v]\n```\n\n\nThe path from s to u might have several nodes in between, so to reconstruct the path from s to v, you just walk back along the path defined by the ```\nprev[]```\n array using the code snippet below the main pseudocode (target is v):\n\n```\n1  S ← empty sequence\n2  u ← target\n3  while prev[u] is defined:                 // Construct the shortest path with a stack S\n4      insert u at the beginning of S          // Push the vertex onto the stack\n5      u ← prev[u]                             // Traverse from target to source\n6  end while\n```\n\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How to generate graphs with a Hamiltonian path?\r\n                \r\nI need to create a ```\ngraph generator```\n for my next project. Generally algorithms are trying to find a Hamiltonian path in a graph. So I can create a graph generator then I can decide whether a graph has a Hamiltonian path or not. If not, I can regenerate the graph but this is not a cool way.\n\nI want my generated ```\ngraph has always Hamiltonian path```\n.\n\nIn addition, my graph has two meet two specific condition\n\n\nvertices can only have 2,3 or 4 edges. \npossible number of vertices follows this sequence: 6, 10, 15, 20, 25...n-5, n where ```\nn % 5 = 0```\n\n\n\nCould you explain me how should I start and which way I should follow to achieve this easily?\n    ", "Answer": "\r\nIf you want to make sure that your graph has a Hamiltonian path, start by creating a graph that consists of a single path connecting all vertices. This is going to be your Hamiltonian path.\n\n\n\nOnce the edges of the Hamiltonian path are added to the graph, proceed by generating additional edges connecting pairs of random vertices, until you satisfy the additional conditions on your graph.\n\n\n\nThe result is guaranteed to have a Hamiltonian path, because your initial graph has it.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "How would I take the sum of different paths in a graph with Haskell\r\n                \r\n\n  Problem\n  \n  ```\nrelatedQuestions```\n calculates the question with the shortest reading\n  time. Given the number of questions, an array of each questions\n  reading time, and and array of edges between questions. \n\n```\nquestions = 5\nreadingTimes = [2, 1, 13, 1, 12]\nedges = [[3,0], [3,2], [4,1], [3,1]]\n\nanswer: 3\n```\n\n  \n  To calculate the \"shortest reading time\" of a question you need to\n  take the sum of reading times of each path a child node makes and divide it by the number of direct children the question has (question\n  being the current node). Then add this number to the current\n  questions reading time.\n  \n  Ex using inputs above:\n\n```\n      (paths)\n current question          children       #direct    #readingTime\n 0 -> 3 -> 1 -> 4      2   + (1 + 1 + 12) / 1        = 30 \n        -> 2               + (1 + 13)     / 1          \n\n 1 -> 4                 1  + (12)         / 1        = 13\n\n 2 -> 3 -> 0           13  + (1 + 2)      / 1        = 28\n        -> 1 -> 4          + (1 + 12)     / 1\n\n 3 -> 0                 1  + (2)          / 3        = 10.3 \n   -> 1 -> 4               + (1 + 12)     / 3\n   -> 2                    + (13)         / 3\n```\n\n\n\nIssue and Request\n\nMy code works for the given test cases below, but it may fail for others. My code depends on Data.Graph's reachable to get all nodes that a current node can reach and sum all its children divided by the total direct children, but I need to divide each individual child nodes tree sum by the total direct children. So what I'm doing is taking the sum of all paths and dividing by the number of direct children when I should be dividing each path sum.\n\nI want to use Data.Graph's component function to fold the tree accordingly and accumulate the smallest sum. I was having issues with working on a ```\nForest Vertex```\n type, but using ```\nsequence```\n I got a type of ```\nTree [Vertex]```\n making it a bit easier for me to work with regardless I have not been able to wrap my mind around the recursion/traversing necessary.\n\n```\n *Main> :t graph1\n graph1 :: Graph\n *Main> :t components graph1\n components graph1 :: Forest Vertex\n *Main> :t sequence . components $ graph1\n sequence . components $ graph1 :: Tree [Vertex]\n *Main> sequence . components $ graph1\n Node {rootLabel = [0], subForest = [Node {rootLabel = [3], subForest= [Node {rootLabel = [2], subForest = []},Node {rootLabel = [1], subForest = [Node {rootLabel = [4], subForest = []}]}]}]}\n```\n\n\nI'd really appreciate some help on either optimizing my current code to be a full solution or explanations on how I can use ```\nData.Graph```\n's component function to fold/traverse a ```\n[Forest Vertex]```\n.\n\n```\nimport Data.Graph\nimport Data.List\nimport qualified Data.Vector as V\n\nrelatedQuestions :: Int -> [Int] -> [[Int]] -> Int\nrelatedQuestions n t edges = snd smallest\n     where \n           smallest = minimum [(price (snd q) (related (snd q) edges) (fst q) , snd q) | q <- zip t (vertices graph)] \n           price q r i = (fromIntegral (reach q) / fromIntegral r) + fromIntegral i\n           reach q = V.sum . V.tail $ V.fromList [ (V.fromList t) V.! x | x <- reachable graph q]\n           graph = createGraph n createEdges\n           createEdges = concat [permutations x | x <- edges] -- makes sure edge [1,0] has edge [0,1]\n\n\n-- | helper functions \n\n-- | number of children at node   \nrelated :: Int -> [[Int]] -> Int\nrelated n = length . filter (==n) . concat\n\ncreateGraph :: Int -> [[Int]] -> Graph\ncreateGraph e = buildG (0, e-1) . map (\\[x,y] -> (x,y))\n```\n\n\nTest Cases\n\n```\n-- | test cases \nmain :: IO ()\nmain = hspec $ do\n   describe \"relatedQuestions\" $ do \n         it \"test case 1\" $ do \n       relatedQuestions n1 t1 edges1 `shouldBe` (3 :: Int)  \n         it \"test case 2\" $ do \n       relatedQuestions n2 t2 edges2 `shouldBe` (4 :: Int)  \n         it \"test case 3\" $ do \n       relatedQuestions n3 t3 edges3 `shouldBe` (2 :: Int)  \n\nn1 :: Int   \nn1 =  5\n\nt1 :: [Int]\nt1 = [2, 1, 13, 1, 12]\n\nedges1 :: [[Int]]\nedges1 = [[3,0], [3,2], [4,1], [3,1]]\n\nn2 :: Int\nn2 = 5\n\nt2 :: [Int]\nt2 = [3, 11, 3, 18, 3]\n\nedges2 :: [[Int]]\nedges2 = [[3,1], [4,2], [0,3], [4,1]]\n\nn3 :: Int\nn3 = 10\n\nt3 :: [Int]\nt3 = [9, 2, 7, 14, 4, 26, 21, 18, 39, 33]\n\nedges3 :: [[Int]]\nedges3 = [[2,7], [0,9], [3,5], [4,7], [0,2], [8,5], [3,6], [2,1], [5,0]]\n```\n\n    ", "Answer": "", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shouldn't we consider duplicate paths in a cheapest first-graph search algorithm?\r\n                \r\nPlease watch this 16 second video demonstration of a decision made during the cheapest first search.\nhttp://www.youtube.com/watch?v=LVCMMPXaQlE&feature=bf_prev&list=PL7D40B622BF0A97BC\nAt 00:08, the speaker chooses not to expand the path from Oradea to Sibiu since Sibiu has already been explored. I feel this is a wrong choice, because we are looking for the path with the least cost. Although Sibiu has already been explored, we still need to check this new path because it might potentially offer a path to Sibiu which is of lesser cost than the previously explored path to Sibiu. Please explain if I am right here or tell me where I am going wrong.\n    ", "Answer": "\r\nIf you make a duplicate decision you will get in a loop and never come out. That's why you keep visited nodes and never go back to them.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest Path with multiple \"must have\" Nodes in Graph\r\n                \r\nI do have an Graph (~250 Nodes). To connect to an Node I have to buy it with Points ->weighted Graph. \nThere are Nodes which are always taken (\"claimed Nodes\") and from those I can begin to connect to other Nodes. Furthermore I do have an limited amount of Points. All Nodes can be connected together.\n\nWhat way is there to get an Graph where all must have Nodes are connected together, with the least Points? If possible with a given maximum Points.\n\n2nd) Is there an way that it´s not necessary an completely connected Graph? e.g.: One Node which is a \"must have Node\" is directly connected to an \"claimed Node\", so the cheapest Way to get it would be just get the must have Node and not connect it with the remaining Graph.\n\nEDIT (regarding the first three questions): I do have to buy the Node itself, not the Connection. So, I do not count the Travel Distance but the Node cost. e.g.: If I have an Graph from A to B, B to C and A to C and B is an \"must have Node\" I can \"travel\" from A to B then from B to A and from A to C (if it´s shorter than B to C) because there is no additional cost from B to A because B is already claimed.\n\nI came up with this Algorithm:\nI do make an Table with all the \"must have Nodes\" and begin form one of those. I use either an Breath First Search or an  Depth First Search (what would be better?) and let it branch as long as it not find an \"must have Node\" and will - if needed - update the shortest Distance. When it find an \"must have Node\" it ends this Branch and stores it´s Path. The Distance will be registered in the Table. It will run as long as it find´s no \"must have Node\". When it´s done I will go ahead in the Table and take the next \"must have Node\", do the same and built the table.\nWhen I am done with all the Nodes I will run an Minimum Spanning Tree Algorithm over the Table and should get my optimal Graph. \n\nAnyone does see an Problem with this one?\n    ", "Answer": "\r\nYour problem corresponds to Node Weighted Steiner Tree.\n\n(tinLoaf's link is to the edge-weighted version, which is very-much the default for Steiner Tree.)\n\nNode Weighted Steiner Tree ​ -> ​ your problem ​ ​ :\n\nIf S is empty then the empty subgraph is a solution, else let any one element of S be\n\nthe unique claimed Node and let the \"must have\" Nodes be the other elements of S.\n\nyour problem ​ -> ​ Node Weighted Steiner Tree ​ ​ :\n\nIf you mean the claimed Nodes also need to be connected to each other, then there's no difference between those and the must-have nodes, so let S be the union of [the set of claimed Nodes]\n\nwith [the set of must-have Nodes]. ​ If you mean that each must-have Node just needs to be connected to at least one claimed Node, then collapse the claimed Nodes into each other\n\nand let S be the union of {resulting_node} with [the set of \"must have\" Nodes].\n\n\n\nNote that the uni-bonn link (from the beginning of this answer)\n\nhas at least one wrong result about approximation -\n\nThe actual main positive result is ​ ​ ​ \"The node weighted Steiner tree problem can\n\nbe approximated to a factor of ​ 1.35 (1+epsilon') ln k ​ for any ​ epsilon' > 0 .\" ​ .\n(They left out the ​ 1+epsilon' ​ factor.)\n\nAlso, the uni-bonn link's reference for hardness-of-approximation makes no claim on that aspect,\n\nalthough the result is known - It's at least as hard to approximate as set cover.\n\nWhen parameterized by [number of nodes in solution that are neither claimed nor must-have],\n\nthe reduction from set cover still applies, so if that number is small then you're\n\nyou're unlikely to do significantly better in the worst case than brute force.\n\nI haven't found anything else applicable applicable from parameterized complexity, although\n\nedge-weighted Steiner tree is known to be FPT when parameterized by number of terminals.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
{"Question": "Shortest positive path in a directed acyclic graph\r\n                \r\nWe are given a directed acyclic graph with arbitrary weights on edges and two specific nodes, s and t, where in-degree of s and out-degree of t is 0. How to determine the shortest path from s to t that has positive cost?\n    ", "Answer": "\r\nUse a modified Bellman-Ford, which removes edges from the graph if a resulting shortest path cost is <0 until you reach a cost, that is not <0.\n    ", "Knowledge_point": "Paths in Graphs", "Tag": "算法分析"}
