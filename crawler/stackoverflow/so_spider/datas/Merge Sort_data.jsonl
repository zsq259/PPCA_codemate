{"Question": "How to sort in-place using the merge sort algorithm?\r\n                \r\nI know the question is not too specific. \n\nAll I want is someone to tell me how to convert a normal merge sort into an in-place merge sort (or a merge sort with constant extra space overhead). \n\nAll I can find (on the net) is pages saying \"it is too complex\" or \"out of scope of this text\". \n\n\n  The only known ways to merge in-place (without any extra space) are too complex to be reduced to practical program.  (taken from here)\n\n\nEven if it is too complex, what is the basic concept of how to make the merge sort in-place?\n    ", "Answer": "\r\nKnuth left this as an exercise (Vol 3, 5.2.5). There do exist in-place merge sorts. They must be implemented carefully.\nFirst, naive in-place merge such as described here isn't the right solution. It downgrades the performance to O(N2).\nThe idea is to sort part of the array while using the rest as working area for merging.\nFor example like the following merge function.\n\n```\nvoid wmerge(Key* xs, int i, int m, int j, int n, int w) {\n    while (i < m && j < n)\n        swap(xs, w++, xs[i] < xs[j] ? i++ : j++);\n    while (i < m)\n        swap(xs, w++, i++);\n    while (j < n)\n        swap(xs, w++, j++);\n}  \n```\n\nIt takes the array ```\nxs```\n, the two sorted sub-arrays are represented as ranges ```\n[i, m)```\n and ```\n[j, n)```\n respectively. The working area starts from ```\nw```\n. Compare with the standard merge algorithm given in most textbooks, this one exchanges the contents between the sorted sub-array and the working area. As the result, the previous working area contains the merged sorted elements, while the previous elements stored in the working area are moved to the two sub-arrays.\nHowever, there are two constraints that must be satisfied:\n\nThe work area should be within the bounds of the array. In other words, it should be big enough to hold elements exchanged in without causing any out-of-bound error.\nThe work area can be overlapped with either of the two sorted arrays; however, it must ensure that none of the unmerged elements are overwritten.\n\nWith this merging algorithm defined, it's easy to imagine a solution, which can sort half of the array; The next question is, how to deal with the rest of the unsorted part stored in work area as shown below:\n```\n... unsorted 1/2 array ... | ... sorted 1/2 array ...\n```\n\nOne intuitive idea is to recursive sort another half of the working area, thus there are only 1/4 elements haven't been sorted yet.\n```\n... unsorted 1/4 array ... | sorted 1/4 array B | sorted 1/2 array A ...\n```\n\nThe key point at this stage is that we must merge the sorted 1/4 elements B\nwith the sorted 1/2 elements A sooner or later.\nIs the working area left, which only holds 1/4 elements, big enough to merge\nA and B? Unfortunately, it isn't.\nHowever, the second constraint mentioned above gives us a hint, that we can exploit it by arranging the working area to overlap with either sub-array if we can ensure the merging sequence that the unmerged elements won't be overwritten.\nActually, instead of sorting the second half of the working area, we can sort the first half, and put the working area between the two sorted arrays like this:\n```\n... sorted 1/4 array B | unsorted work area | ... sorted 1/2 array A ...\n```\n\nThis setup effectively arranges the work area overlap with the sub-array A. This idea\nis proposed in [Jyrki Katajainen, Tomi Pasanen, Jukka Teuhola. ``Practical in-place mergesort''. Nordic Journal of Computing, 1996].\nSo the only thing left is to repeat the above step, which reduces the working area from 1/2, 1/4, 1/8, … When the working area becomes small enough (for example, only two elements left), we can switch to a trivial insertion sort to end this algorithm.\nHere is the implementation in ANSI C based on this paper.\n```\nvoid imsort(Key* xs, int l, int u);\n\nvoid swap(Key* xs, int i, int j) {\n    Key tmp = xs[i]; xs[i] = xs[j]; xs[j] = tmp;\n}\n\n/* \n * sort xs[l, u), and put result to working area w. \n * constraint, len(w) == u - l\n */\nvoid wsort(Key* xs, int l, int u, int w) {\n    int m;\n    if (u - l > 1) {\n        m = l + (u - l) / 2;\n        imsort(xs, l, m);\n        imsort(xs, m, u);\n        wmerge(xs, l, m, m, u, w);\n    }\n    else\n        while (l < u)\n            swap(xs, l++, w++);\n}\n\nvoid imsort(Key* xs, int l, int u) {\n    int m, n, w;\n    if (u - l > 1) {\n        m = l + (u - l) / 2;\n        w = l + u - m;\n        wsort(xs, l, m, w); /* the last half contains sorted elements */\n        while (w - l > 2) {\n            n = w;\n            w = l + (n - l + 1) / 2;\n            wsort(xs, w, n, l);  /* the first half of the previous working area contains sorted elements */\n            wmerge(xs, l, l + n - w, n, u, w);\n        }\n        for (n = w; n > l; --n) /*switch to insertion sort*/\n            for (m = n; m < u && xs[m] < xs[m-1]; ++m)\n                swap(xs, m, m - 1);\n    }\n}\n```\n\nWhere wmerge is defined previously.\nThe full source code can be found here and the detailed explanation can be found here\nBy the way, this version isn't the fastest merge sort because it needs more swap operations. According to my test, it's faster than the standard version, which allocates extra spaces in every recursion. But it's slower than the optimized version, which doubles the original array in advance and uses it for further merging.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Git workflow and rebase vs merge questions\r\n                \r\nI've been using Git now for a couple of months on a project with one other developer. I have several years of experience with SVN, so I guess I bring a lot of baggage to the relationship.\n\nI have heard that Git is excellent for branching and merging, and so far, I just don't see it. Sure, branching is dead simple, but when I try to merge, everything goes all to hell. Now, I'm used to that from SVN, but it seems to me that I just traded one sub-par versioning system for another.\n\nMy partner tells me that my problems stem from my desire to merge willy-nilly, and that I should be using rebase instead of merge in many situations. For example, here's the workflow that he's laid down:\n\n```\nclone the remote repository\ngit checkout -b my_new_feature\n..work and commit some stuff\ngit rebase master\n..work and commit some stuff\ngit rebase master\n..finish the feature\ngit checkout master\ngit merge my_new_feature\n```\n\n\nEssentially, create a feature branch, ALWAYS rebase from master to the branch, and merge from the branch back to master. Important to note is that the branch always stays local.\n\nHere is the workflow that I started with\n\n```\nclone remote repository\ncreate my_new_feature branch on remote repository\ngit checkout -b --track my_new_feature origin/my_new_feature\n..work, commit, push to origin/my_new_feature\ngit merge master (to get some changes that my partner added)\n..work, commit, push to origin/my_new_feature\ngit merge master\n..finish my_new_feature, push to origin/my_new_feature\ngit checkout master\ngit merge my_new_feature\ndelete remote branch\ndelete local branch\n```\n\n\nThere are two essential differences (I think): I use merge always instead of rebasing, and I push my feature branch (and my feature branch commits) to the remote repository.\n\nMy reasoning for the remote branch is that I want my work backed up as I'm working. Our repository is automatically backed up and can be restored if something goes wrong. My laptop is not, or not as thoroughly. Therefore, I hate to have code on my laptop that's not mirrored somewhere else.\n\nMy reasoning for the merge instead of rebase is that merge seems to be standard and rebase seems to be an advanced feature. My gut feeling is that what I'm trying to do is not an advanced setup, so rebase should be unnecessary. I've even perused the new Pragmatic Programming book on Git, and they cover merge extensively and barely mention rebase.\n\nAnyway, I was following my workflow on a recent branch, and when I tried to merge it back to master, it all went to hell. There were tons of conflicts with things that should have not mattered. The conflicts just made no sense to me. It took me a day to sort everything out, and eventually culminated in a forced push to the remote master, since my local master has all conflicts resolved, but the remote one still wasn't happy.\n\nWhat is the \"correct\" workflow for something like this? Git is supposed to make branching and merging super-easy, and I'm just not seeing it.\n\nUpdate 2011-04-15\n\nThis seems to be a very popular question, so I thought I'd update with my two years experience since I first asked.\n\nIt turns out that the original workflow is correct, at least in our case. In other words, this is what we do and it works:\n\n```\nclone the remote repository\ngit checkout -b my_new_feature\n..work and commit some stuff\ngit rebase master\n..work and commit some stuff\ngit rebase master\n..finish the feature, commit\ngit rebase master\ngit checkout master\ngit merge my_new_feature\n```\n\n\nIn fact, our workflow is a little different, as we tend to do squash merges instead of raw merges. (Note: This is controversial, see below.) This allows us to turn our entire feature branch into a single commit on master. Then we delete our feature branch. This allows us to logically structure our commits on master, even if they're a little messy on our branches. So, this is what we do:\n\n```\nclone the remote repository\ngit checkout -b my_new_feature\n..work and commit some stuff\ngit rebase master\n..work and commit some stuff\ngit rebase master\n..finish the feature, commit\ngit rebase master\ngit checkout master\ngit merge --squash my_new_feature\ngit commit -m \"added my_new_feature\"\ngit branch -D my_new_feature\n```\n\n\nSquash Merge Controversy - As several commenters have pointed out, the squash merge will throw away all history on your feature branch. As the name implies, it squashes all the commits down into a single one. For small features, this makes sense as it condenses it down into a single package. For larger features, it's probably not a great idea, especially if your individual commits are already atomic. It really comes down to personal preference.\n\nGithub and Bitbucket (others?) Pull Requests - In case you're wondering how merge/rebase relates to Pull Requests, I recommend following all the above steps up until you're ready to merge back to master. Instead of manually merging with git, you just accept the PR. Note that this will not do a squash merge (at least not by default), but non-squash, non-fast-forward is the accepted merge convention in the Pull Request community (as far as I know). Specifically, it works like this:\n\n```\nclone the remote repository\ngit checkout -b my_new_feature\n..work and commit some stuff\ngit rebase master\n..work and commit some stuff\ngit rebase master\n..finish the feature, commit\ngit rebase master\ngit push # May need to force push\n...submit PR, wait for a review, make any changes requested for the PR\ngit rebase master\ngit push # Will probably need to force push (-f), due to previous rebases from master\n...accept the PR, most likely also deleting the feature branch in the process\ngit checkout master\ngit branch -d my_new_feature\ngit remote prune origin\n```\n\n\nI've come to love Git and never want to go back to SVN. If you're struggling, just stick with it and eventually you'll see the light at the end of the tunnel.\n    ", "Answer": "\r\nTL;DR\n\nA git rebase workflow does not protect you from people who are bad at conflict resolution or people who are used to a SVN workflow, like suggested in Avoiding Git Disasters: A Gory Story. It only makes conflict resolution more tedious for them and makes it harder to recover from bad conflict resolution. Instead, use diff3 so that it's not so difficult in the first place.\n\n\n\nRebase workflow is not better for conflict resolution!\n\nI am very pro-rebase for cleaning up history. However if I ever hit a conflict, I immediately abort the rebase and do a merge instead! It really kills me that people are recommending a rebase workflow as a better alternative to a merge workflow for conflict resolution (which is exactly what this question was about).\n\nIf it goes \"all to hell\" during a merge, it will go \"all to hell\" during a rebase, and potentially a lot more hell too! Here's why:\n\nReason #1: Resolve conflicts once, instead of once for each commit\n\nWhen you rebase instead of merge, you will have to perform conflict resolution up to as many times as you have commits to rebase, for the same conflict!\n\nReal scenario\n\nI branch off of master to refactor a complicated method in a branch. My refactoring work is comprised of 15 commits total as I work to refactor it and get code reviews. Part of my refactoring involves fixing the mixed tabs and spaces that were present in master before. This is necessary, but unfortunately it will conflict with any change made afterward to this method in master. Sure enough, while I'm working on this method, someone makes a simple, legitimate change to the same method in the master branch that should be merged in with my changes.\n\nWhen it's time to merge my branch back with master, I have two options:\n\ngit merge: \nI get a conflict. I see the change they made to master and merge it in with (the final product of) my branch. Done.\n\ngit rebase: \nI get a conflict with my first commit. I resolve the conflict and continue the rebase. \nI get a conflict with my second commit. I resolve the conflict and continue the rebase. \nI get a conflict with my third commit. I resolve the conflict and continue the rebase. \nI get a conflict with my fourth commit. I resolve the conflict and continue the rebase. \nI get a conflict with my fifth commit. I resolve the conflict and continue the rebase. \nI get a conflict with my sixth commit. I resolve the conflict and continue the rebase. \nI get a conflict with my seventh commit. I resolve the conflict and continue the rebase. \nI get a conflict with my eighth commit. I resolve the conflict and continue the rebase. \nI get a conflict with my ninth commit. I resolve the conflict and continue the rebase. \nI get a conflict with my tenth commit. I resolve the conflict and continue the rebase. \nI get a conflict with my eleventh commit. I resolve the conflict and continue the rebase. \nI get a conflict with my twelfth commit. I resolve the conflict and continue the rebase. \nI get a conflict with my thirteenth commit. I resolve the conflict and continue the rebase. \nI get a conflict with my fourteenth commit. I resolve the conflict and continue the rebase. \nI get a conflict with my fifteenth commit. I resolve the conflict and continue the rebase.\n\nYou have got to be kidding me if this is your preferred workflow. All it takes is a whitespace fix that conflicts with one change made on master, and every commit will conflict and must be resolved. And this is a simple scenario with only a whitespace conflict. Heaven forbid you have a real conflict involving major code changes across files and have to resolve that multiple times.\n\nWith all the extra conflict resolution you need to do, it just increases the possibility that you will make a mistake. But mistakes are fine in git since you can undo, right? Except of course...\n\nReason #2: With rebase, there is no undo!\n\nI think we can all agree that conflict resolution can be difficult, and also that some people are very bad at it. It can be very prone to mistakes, which why it's so great that git makes it easy to undo!\n\nWhen you merge a branch, git creates a merge commit that can be discarded or amended if the conflict resolution goes poorly. Even if you have already pushed the bad merge commit to the public/authoritative repo, you can use ```\ngit revert```\n to undo the changes introduced by the merge and redo the merge correctly in a new merge commit.\n\nWhen you rebase a branch, in the likely event that conflict resolution is done wrong, you're screwed. Every commit now contains the bad merge, and you can't just redo the rebase*. At best, you have to go back and amend each of the affected commits. Not fun. \n\nAfter a rebase, it's impossible to determine what was originally part of the commits and what was introduced as a result of bad conflict resolution.\n\n*It can be possible to undo a rebase if you can dig the old refs out of git's internal logs, or if you create a third branch that points to the last commit before rebasing.\n\nTake the hell out of conflict resolution: use diff3\n\nTake this conflict for example:\n\n```\n<<<<<<< HEAD\nTextMessage.send(:include_timestamp => true)\n=======\nEmailMessage.send(:include_timestamp => false)\n>>>>>>> feature-branch\n```\n\n\nLooking at the conflict, it's impossible to tell what each branch changed or what its intent was. This is the biggest reason in my opinion why conflict resolution is confusing and hard.\n\ndiff3 to the rescue!\n\n```\ngit config --global merge.conflictstyle diff3\n```\n\n\nWhen you use the diff3, each new conflict will have a 3rd section, the merged common ancestor.\n\n```\n<<<<<<< HEAD\nTextMessage.send(:include_timestamp => true)\n||||||| merged common ancestor\nEmailMessage.send(:include_timestamp => true)\n=======\nEmailMessage.send(:include_timestamp => false)\n>>>>>>> feature-branch\n```\n\n\nFirst examine the merged common ancestor. Then compare each side to determine each branch's intent. You can see that HEAD changed EmailMessage to TextMessage. Its intent is to change the class used to TextMessage, passing the same parameters. You can also see that feature-branch's intent is to pass false instead of true for the :include_timestamp option. To merge these changes, combine the intent of both:\n\n```\nTextMessage.send(:include_timestamp => false)\n```\n\n\nIn general:\n\n\nCompare the common ancestor with each branch, and determine which branch has the simplest change\nApply that simple change to the other branch's version of the code, so that it contains both the simpler and the more complex change\nRemove all the sections of conflict code other than the one that you just merged the changes together into\n\n\nAlternate: Resolve by manually applying the branch's changes\n\nFinally, some conflicts are terrible to understand even with diff3. This happens especially when diff finds lines in common that are not semantically common (eg. both branches happened to have a blank line at the same place!). For example, one branch changes the indentation of the body of a class or reorders similar methods. In these cases, a better resolution strategy can be to examine the change from either side of the merge and manually apply the diff to the other file.\n\nLet's look at how we might resolve a conflict in a scenario where merging ```\norigin/feature1```\n where ```\nlib/message.rb```\n conflicts.\n\n\nDecide whether our currently checked out branch (```\nHEAD```\n, or ```\n--ours```\n) or the branch we're merging (```\norigin/feature1```\n, or ```\n--theirs```\n) is a simpler change to apply. Using diff with triple dot (```\ngit diff a...b```\n) shows the changes that happened on ```\nb```\n since its last divergence from ```\na```\n, or in other words, compare the common ancestor of a and b with b.\n\n```\ngit diff HEAD...origin/feature1 -- lib/message.rb # show the change in feature1\ngit diff origin/feature1...HEAD -- lib/message.rb # show the change in our branch\n```\n\nCheck out the more complicated version of the file. This will remove all conflict markers and use the side you choose.\n\n```\ngit checkout --ours -- lib/message.rb   # if our branch's change is more complicated\ngit checkout --theirs -- lib/message.rb # if origin/feature1's change is more complicated\n```\n\nWith the complicated change checked out, pull up the diff of the simpler change (see step 1). Apply each change from this diff to the conflicting file.\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Quick Sort Vs Merge Sort [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Why is quicksort better than mergesort?\r\n                            \r\n                                (29 answers)\r\n                            \r\n                    \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nWhy might quick sort be better than merge sort ?\n    ", "Answer": "\r\nSee Quicksort on wikipedia:\n\n\n  Typically, quicksort is significantly\n  faster in practice than other Θ(nlogn)\n  algorithms, because its inner loop can\n  be efficiently implemented on most\n  architectures, and in most real-world\n  data, it is possible to make design\n  choices which minimize the probability\n  of requiring quadratic time.\n\n\nNote that the very low memory requirement is a big plus as well.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why Collections.sort uses merge sort instead of quicksort?\r\n                \r\nWe know that quick sort is the fastest sorting algorithm.\n\nThe JDK6 ```\ncollections.sort```\n uses the merge sort algorithm instead of quick sort. But Arrays.sort uses quick sort algorithm.\n\nWhat is the reason Collections.sort uses merge sort instead of quick sort? \n    ", "Answer": "\r\nHighly likely from Josh Bloch §:\n\n\n  I did write these methods, so I suppose I'm qualified to answer. It is\n  true that there is no single best sorting algorithm.  QuickSort has\n  two major deficiencies when compared to mergesort:\n  \n  \n  It's not stable (as parsifal noted).\n  It doesn't guarantee n log n performance; it can degrade to quadratic performance on pathological inputs. \n  \n  \n  Stability is a non-issue for primitive types, as there is no notion of\n  identity as distinct from (value) equality. And the possibility of\n  quadratic behavior was deemed not to be a problem in practice for\n  Bentely and McIlroy's implementation (or subsequently for Dual Pivot\n  Quicksort), which is why these QuickSort variants were used for\n  the primitive sorts.\n  \n  Stability is a big deal when sorting arbitrary objects. For example,\n  suppose you have objects representing email messages, and you sort\n  them first by date, then by sender.  You expect them to be sorted by\n  date within each sender, but that will only be true if the sort is\n  stable.  That's why we elected to provide a stable sort (Merge Sort)\n  to sort object references. (Techincally speaking, multiple sequential\n  stable sorts result in a lexicographic ordering on the keys in the\n  reverse order of the sorts: the final sort determines the most\n  significant subkey.)\n  \n  It's a nice side benefit that Merge Sort guarantees n log n (time)\n  performance no matter what the input.  Of course there is a down side:\n  quick sort is an \"in place\" sort: it requies only log n external space\n  (to maintain the call stack).  Merge, sort, on  the other hand,\n  requires O(n) external space.  The TimSort variant (introduced in Java\n  SE 6) requires substantially less space (O(k)) if the input array is\n  nearly sorted.\n\n\nAlso, the following is relevant:\n\n\n  The algorithm used by java.util.Arrays.sort and (indirectly) by \n  java.util.Collections.sort to sort object references is a \"modified\n  mergesort (in which the merge is omitted if the highest element in the\n  low sublist is less than the lowest element in the high sublist).\"  It\n  is a reasonably fast stable sort that guarantees O(n log n)\n  performance and requires O(n) extra space.  In its day (it was written\n  in 1997 by Joshua Bloch), it was a fine choice, but today but we can\n  do much better.\n  \n  Since 2003, Python's list sort has used an algorithm known as timsort\n  (after Tim Peters, who wrote it). It is a stable, adaptive, iterative\n  mergesort that requires far fewer than n log(n) comparisons when\n  running on partially sorted arrays, while offering performance\n  comparable to a traditional mergesort when run on random arrays. Like\n  all proper mergesorts timsort is stable and runs in O(n log n) time\n  (worst case). In the worst case, timsort requires temporary storage\n  space for n/2 object references; in the best case, it requires only a\n  small constant amount of space. Contrast this with the current\n  implementation, which always requires extra space for n object\n  references, and beats n log n only on nearly sorted lists.\n  \n  Timsort is described in detail here:\n  http://svn.python.org/projects/python/trunk/Objects/listsort.txt.\n  \n  Tim Peters's original implementation is written in C. Joshua Bloch\n  ported it from C to Java and end tested, benchmarked, and tuned the\n  resulting code extensively. The resulting code is a drop-in\n  replacement for java.util.Arrays.sort. On highly ordered data, this\n  code can run up to 25 times as fast as the current implementation (on\n  the HotSpot server VM). On random data, the speeds of the old and new\n  implementations are comparable. For very short lists, the new\n  implementation is substantially faster that the old even on random\n  data (because it avoids unnecessary data copying).\n\n\nAlso, see Is Java 7 using Tim Sort for the Method Arrays.Sort?.\n\nThere isn't a single \"best\" choice. As with many other things, it's about tradeoffs.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How can I preview a merge in git?\r\n                \r\nI have a git branch (the mainline, for example) and I want to merge in another development branch. Or do I?\n\nIn order to decide whether I really want to merge this branch in, i'd like to see some sort of preview of what the merge will do. Preferably with the ability to see the list of commits that are being applied.\n\nSo far, the best I can come up with is ```\nmerge --no-ff --no-commit```\n, and then ```\ndiff HEAD```\n.\n    ", "Answer": "\r\n\n```\ngit log ..otherbranch```\nlist of changes that will be merged into current branch.\n```\ngit diff ...otherbranch```\ndiff from common ancestor (merge base) to the head of what will be merged. Note the three dots, which have a special meaning compared to two dots (see below).\n```\ngitk ...otherbranch```\ngraphical representation of the branches since they were merged last time.\n\n\nEmpty string implies ```\nHEAD```\n, so that's why just ```\n..otherbranch```\n instead of ```\nHEAD..otherbranch```\n.\n\nThe two vs. three dots have slightly different meaning for diff than for the commands that list revisions (log, gitk etc.). For log and others two dots (```\na..b```\n) means everything that is in ```\nb```\n but not ```\na```\n and three dots (```\na...b```\n) means everything that is in only one of ```\na```\n or ```\nb```\n. But diff works with two revisions and there the simpler case represented by two dots (```\na..b```\n) is simple difference from ```\na```\n to ```\nb```\n and three dots (```\na...b```\n) mean difference between common ancestor and ```\nb```\n (```\ngit diff $(git merge-base a b)..b```\n).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "why is merge sort preferred over quick sort for sorting linked lists\r\n                \r\nI read the following in a forum :\n\n\n  Merge sort is very efficient for\n  immutable datastructures like linked\n  lists\n\n\nand\n\n\n  Quick sort is typically faster than\n  merge sort when the data is stored in\n  memory. However, when the data set is\n  huge and is stored on external devices\n  such as a hard drive, merge sort is\n  the clear winner in terms of speed. It\n  minimizes the expensive reads of the\n  external drive\n\n\nand \n\n\n  when operating on linked lists, merge sort only requires a small constant amount of auxiliary storage\n\n\nCan someone help me understand the above argument? why is merge sort preferred for sorting huge linked lists? and how does it minimize expensive reads to an external drive? basically i want to understand why one would choose merge sort for sorting a big linked list.\n    ", "Answer": "\r\nQuick sort works well for sorting in-place. In particular, most of the operations can be defined in terms of swapping pairs of elements in an array. To do that, however, you normally \"walk\" through the array with two pointers (or indexes, etc.) One starts at the beginning of the array and the other at the end. Both then work their way toward the middle (and you're done with a particular partition step when they meet). That's expensive with files, because files are oriented primarily toward reading in one direction, from beginning to end. Starting from the end and seeking backwards is usually relatively expensive.\n\nAt least in its simplest incarnation, merge sort is pretty much the opposite. The easy way to implement it only requires looking through the data in one direction, but involves breaking the data into two separate pieces, sorting the pieces, then merging them back together.\n\nWith a linked list, it's easy to take (for example) alternating elements in one linked list, and manipulate the links to create two linked lists from those same elements instead. With an array, rearranging elements so alternating elements go into separate arrays is easy if you're willing to create a copy as big as the original data, but otherwise rather more non-trivial.\n\nLikewise, merging with arrays is easy if you merge elements from the source arrays into a new array with the data in order -- but to do it in place without creating a whole new copy of the data is a whole different story. With a linked list, merging elements together from two source lists into a single target list is trivial -- again, you just manipulate links, without copying elements.\n\nAs for using Quicksort to produce the sorted runs for an external merge sort, it does work, but it's (decidedly) sub-optimal as a rule. To optimize a merge-sort, you normally want to maximize the lengths of each sorted \"run\" as you produce it. If you simply read in the data that will fit in memory, Quicksort it and write it out, each run will be restricted to (a little less than) the size of the available memory.\n\nYou can do quite a bit better than that as a rule though. You start by reading in a block of data, but instead of using a Quicksort on it, you build a heap. Then, as you write each item out from the heap into the sorted \"run\" file, you read another item in from your input file. If it's larger than the item you just wrote to disk, you insert it into your existing heap, and repeat.\n\nItems that are smaller (i.e., belong before items that have already been written) you keep separate, and build into a second heap. When (and only when) your first heap is empty, and the second heap has taken over all the memory, you quit writing items to the existing \"run\" file, and start on a new one.\n\nExactly how effective this will be depends on the initial order of the data. In the worst case (input sorted in inverse order) it does no good at all. In the best case (input already sorted) it lets you \"sort\" the data in a single run through the input. In an average case (input in random order) it lets you approximately double the length of each sorted run, which will typically improve speed by around 20-25% (though the percentage varies depending on how much larger your data is than the available memory).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Non-Recursive Merge Sort\r\n                \r\nCan someone explain in English how does Non-Recursive merge sort works ?\n\nThanks\n    ", "Answer": "\r\nNon-recursive merge sort works by considering window sizes of 1,2,4,8,16..2^n over the input array. For each window ('k' in code below), all adjacent pairs of windows are merged into a temporary space, then put back into the array.\n\nHere is my single function, C-based, non-recursive merge sort.\nInput and output are in 'a'. Temporary storage in 'b'. \nOne day, I'd like to have a version that was in-place:\n\n```\nfloat a[50000000],b[50000000];\nvoid mergesort (long num)\n{\n    int rght, wid, rend;\n    int i,j,m,t;\n\n    for (int k=1; k < num; k *= 2 ) {       \n        for (int left=0; left+k < num; left += k*2 ) {\n            rght = left + k;        \n            rend = rght + k;\n            if (rend > num) rend = num; \n            m = left; i = left; j = rght; \n            while (i < rght && j < rend) { \n                if (a[i] <= a[j]) {         \n                    b[m] = a[i]; i++;\n                } else {\n                    b[m] = a[j]; j++;\n                }\n                m++;\n            }\n            while (i < rght) { \n                b[m]=a[i]; \n                i++; m++;\n            }\n            while (j < rend) { \n                b[m]=a[j]; \n                j++; m++;\n            }\n            for (m=left; m < rend; m++) { \n                a[m] = b[m]; \n            }\n        }\n    }\n}\n```\n\n\nBy the way, it is also very easy to prove this is O(n log n). The outer loop over window size grows as power of two, so k has log n iterations. While there are many windows covered by inner loop, together, all windows for a given k exactly cover the input array, so inner loop is O(n). Combining inner and outer loops: O(n)*O(log n) = O(n log n).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "2-way Merge Sort and Merge Sort\r\n                \r\nHow 2-way Merge Sort are different from Merge Sort recursively?\n\n\n\nSuppose there are 5 number to be sorted 8,9,1,6,4\nIn Merge Sort we divide like this\nStep1:   {8,9,1}             {6,4}\n\nStep2: {8,9}     {1}     {6}      {4}\n\nStep3:{8} {9}    {1}      {6}      {4}\n\nNow Merge\n\nStep4:  {8,9}    {1}         {4,6}\n\nStep5:    {1,8,9}            {4,6}\n\nStep6:          {1,4,6,8,9}\n\nBut in 2 way merge sort, we divide the array in 2 elements each(but according to wikipedia , before merging every 2 element parts need to be sorted.https://en.wikipedia.org/wiki/K-way_merge_algorithm )So, it also starts from single element and merge them\nright?\nSo, steps for array :8,9,1,6,4\n\nStep1:{8,9}  {1,6}    {4} [that is odd element merge at last]\n\nStep2:  {1,6,8,9}.    {4}\n\nStep3:     {1,4,6,8,9}\n\nSo, number of steps reduces here. Then what will be algorithm for it? Is 2-way merge sort merge sort more efficient than merge sort?\n    ", "Answer": "\r\n\n  Is 2-way merge sort merge sort more efficient than merge sort?\n\n\nAnother name for an iterative 2-way merge sort is bottom up merge sort, while another name for recursive merge sort is top down merge sort.\n\nGenerally, an optimized bottom up merge sort is slightly more efficient than an optimized top down merge sort. Top down merge sort performs O(n) stack operations on indexes generated by the recursive \"splitting\" of the array. If n is not a power of 2, then bottom up merge sort does more compare and moves, but it's less than top down merge sort's stack operation overhead. For large arrays, the difference is less than 5%.\n\nFor a hybrid insertion / merge sort, that uses insertion sort on n / m groups of m elements, bottom up merge sort can adjust m to deal with n not being a power of 2.\n\nTop down merge sort is mostly for learning. Despite the small difference in performance and stack space, most libraries use some variation of bottom up merge sort for a stable sort.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort time and space complexity\r\n                \r\nLet's take this implementation of Merge Sort as an example\n```\nvoid mergesort(Item a[], int l, int r) {\nif (r <= l) return;\nint m = (r+l)/2;\nmergesort(a, l, m);   ------------(1)\nmergesort(a, m+1, r); ------------(2)\nmerge(a, l, m, r);\n```\n\na) The time complexity of this Merge Sort is ```\nO(n lg(n))```\n. Will parallelizing (1) and (2) give any practical gain? Theorotically, it appears that after parallelizing them also you would end up in ```\nO(n lg(n))```\n. But practically can we get any gains?\nb) Space complexity of this Merge Sort here is ```\nO(n)```\n. However, if I choose to perform in-place merge sort using linked lists (not sure if it can be done with arrays reasonably) will the space complexity become ```\nO(lg(n))```\n, since you have to account for recursion stack frame size?\nCan we treat ```\nO(lg(n))```\n as constant since it cannot be more than 64? I may have misunderstood this at couple of places. What exactly is the significance of 64?\nc) Sorting Algorithms Compared - Cprogramming.com says merge sort requires constant space using linked lists. How? Did they treat ```\nO(lg(n))```\n constant?\nd) Added to get more clarity. For space complexity calculation is it fair to assume the input array or list is already in memory? When I do complexity calculations I always calculate the \"Extra\" space I will be needing besides the space already taken by input. Otherwise space complexity will always be ```\nO(n)```\n or worse.\n    ", "Answer": "\r\nMergeSort time Complexity is O(nlgn) which is a fundamental knowledge.\nMerge Sort space complexity will always be O(n) including with arrays.\nIf you draw the space tree out, it will seem as though the space complexity is O(nlgn). However, as the code is a Depth First code, you will always only be expanding along one branch of the tree, therefore, the total space usage required will always be bounded by O(3n) = O(n).\nFor example, if you draw the space tree out, it seems like it is O(nlgn)\n```\n                             16                                 | 16\n                            /  \\                              \n                           /    \\\n                          /      \\\n                         /        \\\n                        8          8                            | 16\n                       / \\        / \\\n                      /   \\      /   \\\n                     4     4    4     4                         | 16\n                    / \\   / \\  / \\   / \\\n                   2   2 2   2.....................             | 16\n                  / \\  /\\ ........................\n                 1  1  1 1 1 1 1 1 1 1 1 1 1 1 1 1              | 16\n```\n\nwhere height of tree is O(logn) => Space complexity is O(nlogn + n) = O(nlogn).\nHowever, this is not the case in the actual code as it does not execute in parallel. For example, in the case where N = 16, this is how the code for mergesort executes. N = 16.\n```\n                           16\n                          /\n                         8\n                        /\n                       4\n                     /\n                    2\n                   / \\\n                  1   1\n```\n\nnotice how number of space used is 32 = 2n = 2*16  < 3n\nThen it merge upwards\n```\n                           16\n                          /\n                         8\n                        /\n                       4\n                     /  \\\n                    2    2\n                        / \\                \n                       1   1\n```\n\nwhich is 34 < 3n.\nThen it merge upwards\n```\n                           16\n                          /\n                         8\n                        / \\\n                       4   4\n                          /\n                         2\n                        / \\ \n                       1   1\n```\n\n36 < 16 * 3 = 48\nthen it merge upwards\n```\n                           16\n                          / \\\n                         8  8\n                           / \\\n                          4   4\n                             / \\\n                            2   2\n                                /\\\n                               1  1\n```\n\n16 + 16 + 14 = 46 < 3*n = 48\nin a larger case, n = 64\n```\n                     64\n                    /  \\\n                   32  32\n                       / \\\n                      16  16\n                          / \\\n                         8  8\n                           / \\\n                          4   4\n                             / \\\n                            2   2\n                                /\\\n                               1  1\n```\n\nwhich is 643 <= 3n = 3*64\nYou can prove this by induction for the general case.\nTherefore, space complexity is always bounded by O(3n) = O(n) even if you implement with arrays as long as you clean up used space after merging and not execute code in parallel but sequential.\nExample of my implementation is given below:\n```\ntemplace<class X> \nvoid mergesort(X a[], int n) // X is a type using templates\n{\n    if (n==1)\n    {\n        return;\n    }\n    int q, p;\n    q = n/2;\n    p = n/2;\n    //if(n % 2 == 1) p++; // increment by 1\n    if(n & 0x1) p++; // increment by 1\n        // note: doing and operator is much faster in hardware than calculating the mod (%)\n    X b[q];\n\n    int i = 0;\n    for (i = 0; i < q; i++)\n    {\n        b[i] = a[i];\n    }\n    mergesort(b, i);\n    // do mergesort here to save space\n    // http://stackoverflow.com/questions/10342890/merge-sort-time-and-space-complexity/28641693#28641693\n    // After returning from previous mergesort only do you create the next array.\n    X c[p];\n    int k = 0;\n    for (int j = q; j < n; j++)\n    {\n        c[k] = a[j];\n        k++;\n    }\n    mergesort(c, k);\n    int r, s, t;\n    t = 0; r = 0; s = 0;\n    while( (r!= q) && (s != p))\n    {\n        if (b[r] <= c[s])\n        {\n            a[t] = b[r];\n            r++;\n        }\n        else\n        {\n            a[t] = c[s];\n            s++;\n        }\n        t++;\n    }\n    if (r==q)\n    {\n        while(s!=p)\n        {\n            a[t] = c[s];\n            s++;\n            t++;\n        }\n    }\n    else\n    {\n        while(r != q)\n        {\n            a[t] = b[r];\n            r++;\n            t++;\n        }\n    }\n    return;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort comparisons?\r\n                \r\nI don't think the number of comparisons using merge sort is correct in my merge sort 2 class/method that returns the number of comparisons. Merge sort 2 is like merge sort but just returns the amount of comparisons.  Below is my demo, I have an array of 4 integers {2,55,1,45} and when I run the program it returns 8 comparisons. Can anyone verify if this correct or what I am doing wrong?\n\nMy demo:\n\n```\n    ArrayInts[] myInts2 = new ArrayInts[4];\n\n    myInts2[0] = new ArrayInts(2);\n    myInts2[1] = new ArrayInts(55);\n    myInts2[2] = new ArrayInts(1);\n    myInts2[3] = new ArrayInts(45);\n\n    MergeSort.mergeSort(myInts2, 0, 3);\n\n    System.out.println(\"Sorted using Merge Sort: \");\n\n\n    for (int index = 0; index < myInts2.length; index++) {\n        System.out.println(myInts2[index]);\n    }\n\n    System.out.println(\"Number of comps using Merge Sort: \" + MergeSort2.mergeSort2(myInts2, 0, 3));\n    System.out.println(\" \");\n```\n\n\nMy merge sort 2 class/method:\n\n```\n public class MergeSort2 {\n private static long comp=0;\n\npublic static <T extends Comparable<? super T>> long mergeSort2(T[] data, int min, int max) {\n    T[] temp;\n    int index1, left, right;\n\n\n    //return on list of length one\n\n    if (min == max) {\n        return comp;\n    }\n\n    //find the length and the midpoint of the list\n\n    int size = max - min + 1;\n    int pivot = (min + max) / 2;\n    temp = (T[]) (new Comparable[size]);\n\n    mergeSort2(data, min, pivot); //sort left half of list\n    mergeSort2(data, pivot + 1, max); //sort right half of list\n\n    //copy sorted data into workspace\n\n    for (index1 = 0; index1 < size; index1++) {\n        temp[index1] = data[min + index1];\n    }\n\n    //merge the two sorted lists\n\n    left = 0;\n    right = pivot - min + 1;\n    for (index1 = 0; index1 < size; index1++) {\n        comp++;\n        if (right <= max - min) {\n\n            if (left <= pivot - min) {\n\n                if (temp[left].compareTo(temp[right]) > 0) {\n\n                    data[index1 + min] = temp[right++];\n                } else {\n                    data[index1 + min] = temp[left++];\n                }\n            } else {\n                data[index1 + min] = temp[right++];\n            }\n        } else {\n            data[index1 + min] = temp[left++];\n        }\n    }\n\n\n    return comp;\n\n    }\n\n    }\n```\n\n    ", "Answer": "\r\nyou are getting 8 because you are incrementing each time the merge loop executes whether there is a comparison or not.\n\nif you change \n\n```\nfor (index1 = 0; index1 < size; index1++) {\n    comp++;\n    if (right <= max - min) {\n\n        if (left <= pivot - min) {\n```\n\n\nto\n\n```\nfor (index1 = 0; index1 < size; index1++) {\n    if (right <= max - min) {\n\n        if (left <= pivot - min) {\n            comp++;\n```\n\n\nyou will get the number of comparisions made rather than the number of loop iterations.\n\n[0,1,2,3] should yield 4 comparisons\n[3,2,1,0] should yield 4 comparisons\n[0,2,1,3] should yield 5 comparisons\n[0,4,1,5,2,6,3,7] should yield 16 comparisons\n\nmerge sort is an O(nlog2n) worst case algorithm.\n\nyou also need to change this bit\n\n```\nMergeSort.mergeSort(myInts2, 0, 3);\n\nSystem.out.println(\"Sorted using Merge Sort: \");\n\n\nfor (int index = 0; index < myInts2.length; index++) {\n    System.out.println(myInts2[index]);\n}\n\nSystem.out.println(\"Number of comps using Merge Sort: \" + MergeSort2.mergeSort2(myInts2, 0, 3));\nSystem.out.println(\" \");\n```\n\n\nto\n\n```\nint result = MergeSort.mergeSort(myInts2, 0, 3);\n\nSystem.out.println(\"Sorted using Merge Sort: \");\n\n\nfor (int index = 0; index < myInts2.length; index++) {\n    System.out.println(myInts2[index]);\n}\n\nSystem.out.println(\"Number of comps using Merge Sort: \" + result);\nSystem.out.println(\" \");\n```\n\n\nas myInts will be sorted when you output the count so you get the sorted complexity.\n\nto demonstrate the effect of calling sort more than once.\n\n```\npublic static void main(String[] args) {\n    Integer[] myInts2 = new Integer[4];\n\n    myInts2[0] = new Integer(0);\n    myInts2[1] = new Integer(2);\n    myInts2[2] = new Integer(1);\n    myInts2[3] = new Integer(3);\n\n    System.out.println(new MergeSort2().mergeSort2(myInts2, 0, 3)); // will output 5\n    System.out.println(new MergeSort2().mergeSort2(myInts2, 0, 3)); // will output 4\n}\n```\n\n\nCalling the sort a second time will use sorted data not unsorted data so you will get\na different result. sorting the array can modify the array so calling the sort multiple\ntimes can get different behaviour.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort with insertion sort\r\n                \r\nI was implementing a merge sort in Algorithms in Java 4th edition.\nMy basic merge sort works, and I want to improve the algorithm by using insertion sort when the array size is less than 7.\nI thought it is obvious an efficient improvement, but actually the original one is faster than the improved one for large data.\n\nHere is my improved merge sort, CUTOFF = 7:\n\n```\nprivate static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n\n  // Copy to aux[]\n  for (int i = lo; i <= hi; i++) {\n    aux[i] = a[i];\n  }\n\n  // Merge back to a[]\n  int i = lo, j = mid + 1;\n  for (int k = lo; k <= hi; k++) {\n    if      (i > mid)              a[k] = aux[j++];\n    else if (j > hi)               a[k] = aux[i++];\n    else if (less(aux[i], aux[j])) a[k] = aux[i++];\n    else                           a[k] = aux[j++];\n  }\n}\n\nprivate static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\n\n  // #1 improvement\n  // Stop condition for this recursion.\n  // This time we add a CUTOFF, when the items in array\n  // is less than 7, we will use insertion sort.\n  if (hi <= lo + CUTOFF - 1) {\n    Insertion.sort(a, lo, hi);\n    return;\n  }\n\n  int mid = lo + (hi - lo) / 2;\n  sort(a, aux, lo, mid);\n  sort(a, aux, mid + 1, hi);\n  if (!less(a[mid+1], a[mid])) return;\n  merge(a, aux, lo, mid, hi);\n}\n\npublic static void sort(Comparable[] a) {\n  Comparable[] aux = new Comparable[a.length];\n  sort(a, aux, 0, a.length - 1);\n}\n```\n\n\nThe insertion sort code:\n\n```\npublic static void sort(Comparable[] a, int lo, int hi) {\n  for (int i = lo; i <= hi; i++) {\n    for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {\n      exch(a, j, j - 1);\n    }\n  }\n}\n```\n\n\nI used a SortCompare.java to compare the execute time:\n\n```\npublic class SortCompare {\n\n  public static double time(String alg, Comparable[] a) {\n    Stopwatch timer = new Stopwatch();\n    if (alg.equals(\"Insertion\")) Insertion.sort(a);\n    if (alg.equals(\"Selection\")) Selection.sort(a);\n    if (alg.equals(\"Shell\")) Shell.sort(a);\n    if (alg.equals(\"Merge\")) Merge.sort(a);\n    if (alg.equals(\"MergeWithImprovements\")) MergeWithImprovements.sort(a);\n    //if (alg.equals(\"Quick\")) Quick.sort(a);\n    //if (alg.equals(\"Heap\")) Heap.sort(a);\n    if (alg.equals(\"InsertionWithSentinel\")) InsertionWithSentinel.sort(a);\n    return timer.elapsedTime();\n  }\n\n  public static double timeRandomInput(String alg, int N, int T) {\n    // Use alg to sort T random arrays of length N.\n    double total = 0.0;\n    Double[] a = new Double[N];\n    for (int t = 0; t < T; t++) {\n      for (int i = 0; i < N; i++) {\n        a[i] = StdRandom.uniform();\n      }\n      total += time(alg, a);\n    }\n    return total;\n  }\n\n  public static void main(String[] args) {\n    String alg1 = args[0];\n    String alg2 = args[1];\n    int N = Integer.parseInt(args[2]);\n    int T = Integer.parseInt(args[3]);\n    double t1 = timeRandomInput(alg1, N, T);  // Total for alg1\n    double t2 = timeRandomInput(alg2, N, T);\n    StdOut.printf(\"For %d random Doubles\\n   %s is\", N, alg1);\n    StdOut.printf(\" %.1f times faster than %s\\n\", t2/t1, alg2);\n  }\n}\n```\n\n\nI generated 100 arrays with 10000 elements each. The original merge sort is 30 times faster than the improved one!\n    ", "Answer": "\r\nYou insertion sort function is definitely wrong. Note the ```\nj > 0```\n end condition. You pass in ```\n[lo..hi]```\n but your code can iterate ```\nj```\n all the way down to ```\n1```\n. I think you want something like:\n\n```\npublic static void sort(Comparable[] a, int lo, int hi) {\n  for (int i = lo + 1; i <= hi; i++) {\n    for (int j = i; j > lo && less(a[j], a[j - 1]); j--) {\n      exch(a, j, j - 1);\n    }\n  }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Binary Merge sort & Natural Merge sort\r\n                \r\nI know that homework questions are not the most popular on here, but I am at a total loss. I am doing an assignment which requires us to make multiple sorting algorithms. One of them however, is driving me insane. I can find no examples of it online anywhere, and he did not go over it fully in class. We have to make a merge sort that looks like this: \n\n```\nvoid mergeSort(int * a, int s, bool n = false)\n```\n\n\nWhere a is the array, s is the size of said array, and n is false for binary merge sort, and true for natural merge sort. The problem is, I cant find what natural merge sort and binary merge sort are. I just find mergesort. And all of them ask for far more variables.\n\nI am simply asking if anyone knows where I can find a good explanation of those two different types of mergesort.\n    ", "Answer": "\r\nI'm no expert on the topic, but the wikipedia page seems to be a good starting point\nhttp://en.wikipedia.org/wiki/Merge_sort\n\nIt contains a section on natural merge sort with an example. \n\nAbout binary merge sort:\n\n\n  A variant named binary merge sort uses a binary insertion sort to sort\n  groups of 32 elements, followed by a final sort using merge sort. It\n  combines the speed of insertion sort on small data sets with the speed\n  of merge sort on large data sets\n\n\nAnd insertion sort may be read about here: http://en.wikipedia.org/wiki/Insertion_sort\n\nwhich contains a selection on binary insertion sorting.\n\nAbout the variables. The wikipedia example of 'bottom up merge sort' (of which natural merge sort is a variant) has this signature:\n\n```\nvoid BottomUpSort(A[], B[], n)\n```\n\n\nwhere A is the array to be sorted, n its length. B is a work array, and if a read the algoritm right it needs be of length n too. Anyway, it can be created in the beginning of the algoritm and deleted in the end.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to convert merge sort to parallel merge sort\r\n                \r\nThis is what I have so far, the regular merge sort works perfectly but I'm not sure if what I've done for the parallel merge sort with the openMP is correct or not. The goal is to optimize the merge sort by incorporating openMP into it and using data taken from a class of applications. For the data taken I figured I'd make it be threads since the use of multiple threads should optimize it for the better. Any advice on where I should implement the threads here or tips?\n\n```\nvoid mergeSort(int arr[], int start, int end) \n{\n    if(start < end) \n    {\n        int middle = (start + end) / 2;\n        /* sort left half */\n        mergeSort(arr, start, middle);\n        /* sort right half */\n        mergeSort(arr, middle + 1, end);\n        /* merge the two halves */\n        merge(arr, start, end);\n    }\n}\n\nvoid mergesort_parallel_omp(int a[], int start, int end)//parallelized version\n{                                    \n    int threads = 2;\n    if(start < end) \n    {\n        int middle = (start + end) / 2;\n        omp_set_nested(1);                               /////\n        omp_set_num_threads(threads);\n        #pragma omp parallel sections\n        {\n            #pragma omp section\n                mergesort_parallel_omp(a, start, middle);\n            #pragma omp section\n                mergesort_parallel_omp(a, middle + 1, end);\n        }\n        merge(a, start, end);\n    }  \n}\n```\n\n    ", "Answer": "\r\nRefer to this documentation, you need to use omp_set_nested as shown in the link. To have parallelism, declare it where you've done ```\n#pragma omp parallel sections```\n and also don't forget to set ```\nOMP_NUM_THREADS```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Stability of Merge sort [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nIs merge sort stable? I read it in a book which says merge sort is stable as long as the merge operation implemented properly. Is that true?\n    ", "Answer": "\r\ntrue. It depends on how you properly implement the merge sort. http://en.wikipedia.org/wiki/Stable_sort#Stability \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort a Linked List\r\n                \r\nI was recently brushing up on some fundamentals and found merge sorting a linked list to be a pretty good challenge. If you have a good implementation then show it off here.\n    ", "Answer": "\r\n\nWonder why it should be big challenge as it is stated here, here is a straightforward implementation in Java with out any \"clever tricks\".\n```\n//The main function\npublic static Node merge_sort(Node head) \n{\n    if(head == null || head.next == null) \n        return head;\n        \n    Node middle = getMiddle(head);      //get the middle of the list\n    Node left_head = head;\n    Node right_head = middle.next; \n    middle.next = null;             //split the list into two halfs\n\n    return merge(merge_sort(left_head), merge_sort(right_head));  //recurse on that\n}\n\n//Merge subroutine to merge two sorted lists\npublic static Node merge(Node a, Node b)\n{\n    Node dummyHead = new Node();\n    for(Node current  = dummyHead; a != null && b != null; current = current.next;)\n    {\n        if(a.data <= b.data) \n        {\n            current.next = a; \n            a = a.next; \n        }\n        else\n        { \n            current.next = b;\n            b = b.next; \n        }\n        \n    }\n    dummyHead.next = (a == null) ? b : a;\n    return dummyHead.next;\n}\n\n//Finding the middle element of the list for splitting\npublic static Node getMiddle(Node head)\n{\n    if(head == null) \n        return head;\n    \n    Node slow = head, fast = head;\n    \n    while(fast.next != null && fast.next.next != null)\n    {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in c++\r\n                \r\nIn competitive coding i got a question to code merge sort\nI know how to code merge sort with three arguments ie \n\n```\nmerge_sort(int arr[],int left,int right)\n{\n     \\\\rest of code\n}\n```\n\n\nBut the question was \n\n```\nmerge_sort(int arr[],int size)\n{\n     \\\\rest of code\n}\n```\n\n\nHow to perform merge sort for 2 arguments?\n    ", "Answer": "\r\nYou can call this function \n\n```\nmerge_sort(int arr[],int size)\n{\n     \\\\rest of code\n}\n```\n\n\nfrom this function\n\n```\nmerge_sort(int arr[],int left,int right)\n{\n     \\\\rest of code\n}\n```\n\n\nlike\n\n```\nmerge_sort( arr + left, right - left + 1 );\n```\n\n\nIn this case relative to the second function the parameter ```\nleft```\n will be equal to ```\n0```\n while the parameter right will be equal to ```\nright - left + 1```\n due to moving the pointer to the required part of the array.\n\nSo the first function can substitute the second function by using appropriate arguments and the pointer arithmetic.\n\nOr the second function can be called from the first function like\n\n```\nmerge_sort( arr, 0, size - 1 );\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Modification to merge sort to implement merge sort with insertion sort Java\r\n                \r\nI want to implement a  modification to merge \nsort, where n/k sublists of length k are sorted using insertion sort and then merged using \nthe standard merging mechanism of merg sort.\nI'm wondering what the value k has to equal for the modified version of merge sort to equal the original version of merge sort in terms of rum time complexity.  This is a conceptual exercise by myself for myself.  Code and or an explanation is appreciated.\n    ", "Answer": "\r\nYour n/k-way merge is O(n^2/k) (explanation here). Each of your individual insertion sorts are O(k^2). Observe that for any value of k, your overall running complexity will remain O(n^2); therefore, no value of k will allow your modified merge sort to be O(nlogn)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "implementing merge sort in C++\r\n                \r\nI have studied the theory of the merge sort but don't have any idea of how to implement it in C++. My question is, merge sort creates arrays in recursion. But when implementing, how do we create arrays in runtime? or what is the general approach for this? \n\nThanks. \n    ", "Answer": "\r\nTo answer the question: Creating dynamically sized arrays at run-time is done using ```\nstd::vector<T>```\n. Ideally, you'd get your input using one of these. If not, it is easy to convert them. For example, you could create two arrays like this:\n\n```\ntemplate <typename T>\nvoid merge_sort(std::vector<T>& array) {\n    if (1 < array.size()) {\n        std::vector<T> array1(array.begin(), array.begin() + array.size() / 2);\n        merge_sort(array1);\n        std::vector<T> array2(array.begin() + array.size() / 2, array.end());\n        merge_sort(array2);\n        merge(array, array1, array2);\n    }\n}\n```\n\n\nHowever, allocating dynamic arrays is relatively slow and generally should be avoided when possible. For merge sort you can just sort subsequences of the original array and in-place merge them. It seems, ```\nstd::inplace_merge()```\n asks for bidirectional iterators.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "What type of merge sort is this?\r\n                \r\nThis is for an assignment and this is the sort example provided in the book. Is this a binary merge sort or a natural merge sort? \n\n```\n #include <iostream>\n\n    #include \"util.h\"\n\n    /** \n      Merges two adjacent ranges in a vector\n     @param a the vector with the elements to merge\n    @param from the start of the first range\n   @param mid the end of the first range\n   @param to the end of the second range\n*/\nvoid merge(vector<int>& a, int from, int mid, int to)\n{  \n   int n = to - from + 1; // Size of the range to be merged \n   // Merge both halves into a temporary vector b \n   vector<int> b(n);\n\n   int i1 = from;\n      // Next element to consider in the first half \n   int i2 = mid + 1;\n      // Next element to consider in the second half \n   int j = 0; // Next open position in b \n\n   // As long as neither i1 nor i2 is past the end, move the smaller\n   // element into b\n\n   while (i1 <= mid && i2 <= to)\n   {  \n      if (a[i1] < a[i2])\n      {  \n         b[j] = a[i1];\n         i1++;\n      }\n      else\n      {  \n         b[j] = a[i2];\n         i2++;\n      }\n      j++;\n   }\n\n   // Note that only one of the two while loops below is executed\n\n   // Copy any remaining entries of the first half\n   while (i1 <= mid)\n   {  \n      b[j] = a[i1];\n      i1++;\n      j++;\n   }\n   // Copy any remaining entries of the second half\n   while (i2 <= to)\n   {  \n      b[j] = a[i2];\n      i2++;\n      j++;\n   }\n\n   // Copy back from the temporary vector\n   for (j = 0; j < n; j++)\n      a[from + j] = b[j];\n}\n\n/**  \n   Sorts the elements in a range of a vector.\n   @param a the vector with the elements to sort\n   @param from start of the range to sort\n   @param to end of the range to sort\n*/\nvoid merge_sort(vector<int>& a, int from, int to)\n{  \n   if (from == to) return;\n   int mid = (from + to) / 2;\n   // Sort the first and the second half\n   merge_sort(a, from, mid);\n   merge_sort(a, mid + 1, to);\n   merge(a, from, mid, to);\n}\n```\n\n\nI know a natural merge sort uses recursion and that does appear to be the method used here. However, I am not sure. We have to use a natural merge sort and a binary merge sort and report the results and discuss the findings. \n    ", "Answer": "\r\nThe sort in your post is a natural merge sort.  The binary merge sort works like a merge sort with the additional step of using a binary insertion sort before the merge sort.  \n\nThis is done to combine the efficiency of insertion sort on small sets of data with the efficiency of merge sort on large sets of data.\n\nCheck out the 'Variants' section here: https://en.wikipedia.org/wiki/Insertion_sort#Variants\n\nHere is a related SO question, as well: Binary Merge sort & Natural Merge sort\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Hybrid sorting using insertion sort and merge sort\r\n                \r\nI wish to implement a hybrid algorithm that switches from insertion sort to merge sort once the input array size becomes too big.\nThis is my main function (I fixed my input array size at 30 currently as I wish to test my merge sort function) :\n```\n    public static void main(String[] args) { \n        int[] a = genrandarray(30);\n        \n        long bgn, end;\n        bgn = System.currentTimeMillis();\n        \n        imsort(a, 0, a.length, 30);\n        \n        end = System.currentTimeMillis();\n        \n        for(int i = 1; i < a.length; i++){\n            if(a[i-1] > a[i]){\n                System.out.println(\"failed\");\n                break;\n            }\n        }\n        System.out.println(\"milliseconds \" + (end-bgn));\n    }\n```\n\nInsertion sort is called when the array size is <20, else merge sort is called:\n```\n    public static void imsort(int [] slot, int b, int e, int size) {\n        \n        //if smaller than 20, use insertion sort\n        if (e-b<=20) {\n            insertionSort(slot, e);  //e is the length of slot[]\n            System.out.println(\"imsort entered!\");\n        }\n        \n\n        else {\n            mergesort(b, e, slot);\n            \n            System.out.println(\"mergesort entered!\");\n        }\n    }\n```\n\nThere is a Index 30 out of bounds error for my merge sort function currently.\n```\n    public static int merge(int n, int m, int[] slot) {\n        int mid = (n+m)/2;\n        int a = n, b = mid+1, i, tmp, cmp=0, comp=0;\n        \n        //sanity check \n        if (m-n <= 0) return -1000;\n        \n        while (a <= mid && b <= m) {\n            cmp = compare(slot[a], slot[b]); \n            comp++;\n            \n            if (cmp > 0) { //slot[a] > slot[b]\n                tmp = slot[b++];\n                for (i = ++mid; i > a; i--)\n                    slot[i] = slot[i-1];\n                    slot[a++] = tmp;\n            } \n            \n            else if (cmp < 0) //slot[a] < slot[b] \n                    a++;\n            \n            else {\n                //slot[a] == slot[b]\n                if (a == mid && b == m) break;\n                tmp = slot[b++];\n                a++;\n                for (i = ++mid; i > a; i--)\n                slot[i] = slot[i-1]; slot[a++] = tmp;\n            }\n        } // end of while loop;\n        \n        return comp;\n    } // end of merge   \n```\n\n```\n    public static int mergesort(int s, int e, int[] slot) {\n        //int comp =0;\n        int mid = (s+e)/2;  \n        int right=0, left=0;\n        \n        if(e-s>0) {\n            //comp++;\n            left = mergesort(s,mid, slot);\n            //comp++;\n            right = mergesort(mid+1,e, slot);\n        }\n        return right + left + merge(s,e,slot);\n    }\n```\n\nI am unsure of the error in my merge / mergesort function. Can I get some further advice?\n    ", "Answer": "\r\na.length returns you 30 which is the length of your random array from the genrandarray method i believe. And your array is indexed 0 through 29. Try changing the main method like this and it will work out\n```\npublic static void main(String[] args) { \n        int[] a = genrandarray(30);\n        \n        long bgn, end;\n        bgn = System.currentTimeMillis();\n        \n        imsort(a, 0, a.length-1, 30);\n        \n        end = System.currentTimeMillis();\n        \n        for(int i = 1; i < a.length; i++){\n            if(a[i-1] > a[i]){\n                System.out.println(\"failed\");\n                break;\n            }\n        }\n        System.out.println(\"milliseconds \" + (end-bgn));\n    }\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort running time\r\n                \r\nI know that the running time of merge sort is O(n*lg(n)) and that merge sort is a comparision sort, which also means that it takes Ω(n logn) in the worst case to sort a list.\n\nCan I therefore conclude that the running time of merge sort is theta(n*lg n)? \n    ", "Answer": "\r\nIf something is ```\nO(X)```\n and ```\nOmega(X)```\n, this implies it is ```\nTheta(X)```\n. And ```\nlog_b1(...)```\n is the same as ```\nlog_b2(...)```\n times a conversion factor constant.\n\nWhat you said was (translated):\n\n\n  I know that the running time of merge sort is, in the worst case, no worse than ```\nn log(n)```\n. [You arrived at this conclusion somehow with math.] But comparison sorts take at least ```\nn log(n)```\n in the worst case.\n\n\nThus it makes sense that the worst-case behavior of merge sort is exactly ```\nn log(n)```\n.\n\nThis is of course with the implicit assumption that you have no information about your sequence.\n\nedit: You could also prove it from first principles. The thing to note is that you can merge two sorted arrays in linear Theta(N1+N2) time while keeping them merged (by scanning across them kind of in parallel). (Subdividing the array, nomatter what sequence you get, will always take Theta(log(N)) time, which is small so we just ignore that.) We now note that each element has to be merged Theta(log(N)) times (the depth of the tree, if you draw it out). Thus the Theta(N log(N)).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Recursion\r\n                \r\nThis is a code from Introduction to Java Programming about Merge Sort. This method uses a recursion implementation.\n\n```\npublic class MergeSort {\n  2    /** The method for sorting the numbers */\n  3    public static void mergeSort(int[] list) {\n  4      if (list.length > 1) {\n  5        // Merge sort the first half\n  6        int[] firstHalf = new int[list.length / 2];\n  7        System.arraycopy(list, 0, firstHalf, 0, list.length / 2);\n  8        mergeSort(firstHalf);\n  9  \n 10        // Merge sort the second half\n 11        int secondHalfLength = list.length - list.length / 2;\n 12        int[] secondHalf = new int[secondHalfLength];\n 13        System.arraycopy(list, list.length / 2,\n 14          secondHalf, 0, secondHalfLength);\n 15        mergeSort(secondHalf);\n 16  \n 17        // Merge firstHalf with secondHalf into list\n 18        merge(firstHalf, secondHalf, list);\n 19      }\n 20    }\n```\n\n\nMy question: is in Line 8 calls the recursion method back to \"mergeSort\"? If running from the beginning of the method, the \"firstHalf\" array will be created again and the length will be half short. I think the \"firstHalf\" can not created again and the length should not be changed if an array is defined already.\n\nHere is the whole code link: Merge Sort Java.\n    ", "Answer": "\r\nThis is beginner's way of thinking. Yes, exactly I thought the same when I encountered this before. I couldn't believe that the same array size can change dynamically. Understand this, in the below code, ```\narray l and array r```\n are created with different sizes for ```\nevery recursive call```\n. Don't confuse on this.\n\nYes, this is never possible that the same array size changes dynamically for a beginner like you and me. But, there is an exception, well, there are exceptions. We will see them very often as we move forward.\n\n\n  Its recursion, in recursion things change dynamically and all this\n  changes are stored in a call stack.\n\n\nIts confusing but its really interesting if you ponder over it. Its profound. Merge sort can be implemented in quite different ways, but the underlying concept of recursion is same. Don't get confused here, Its better you follow another way to do it, video:\n\nMerge sort first takes a list or an array. Lets imagine the\n\n```\na.length; #lenght of an array is 8\n```\n\n\nNow the end goal is to split the array recursively, till it reaches to a point where there are no-elements (only-one). And a ```\nsingle element is always sorted```\n.\n\nSee the base case in the below code:\n\n```\nif(a.length<2) /*Remember this is the base case*/\n        {\n            return;\n        }\n```\n\n\nOnce it reaches to single element, sort and merge them back. This way you get a complete sorted array which is easy to merge. The only reason we are doing all this non-sense is to get a better run-time algorithm which is O(nlogn). \n\nBecause, all the other sorting algos (```\ninsertion, bubble, and selection```\n) will take O(n2), which is alot, too much indeed. So, humanity must figure out the better solution. Its a need for humanity, very important. I know its annoying, I had gone through this non-sense.\n\nPlease do some research on recursion before you attempt on this. Understand recursion clearly. Keep all this away. Take a simple recursion example and start working on it. Take a factorial example. Its a bad example but its easy to understand.\n\nTop-down MergeSort\n\nSee my code, its nice and easy. Again, both are not easy to understand on your first attempt. You must get in touch with recursion before you attempt to understand these things. All the very best.\n\n```\npublic class MergeSort \n{\n    private int low;\n    private int high;\n    private int mid;\n    public static int[] a;\n\n    public MergeSort(int x)\n    {\n        a = new int[x];\n        a[0]=19;\n        a[1]=10;\n        a[2]=0;\n        a[3]=220;\n        a[4]=80;\n        a[5]=2000;\n        a[6]=56001;\n        a[7]=2;\n\n    }\n\n    public void division(int[] a)\n    {\n        low=0;\n        int p;\n        high = a.length;\n        mid = (high+low)/2;\n        if(a.length<2) /*Remember this is the base case*/\n        {\n            return;\n        }\n        else\n        {\n            int[] l = new int[mid];\n            int[] r = new int[high-mid];\n            /*copying elements from a into l and r*/\n            for(p=0;p<mid;p++)\n                l[p]=a[p];\n            for(int q=0;q<high-mid;q++, p++)\n                r[q]=a[p];\n            /*first recursive call starts from here*/\n            division(l);\n            division(r); \n            sortMerge(a, l, r);\n        }\n    }\n\n    public void sortMerge(int[] a, int[] l, int[] r)\n    {\n\n        int i=0, j=0, k=0;\n        /*sorting and then merging recursively*/\n        while(i<l.length && j<r.length)\n            {\n                if(l[i]<r[j])\n                    {\n                        a[k] = l[i]; /*copying sorted elements into a*/ \n                        i++;\n                        k++;\n                    }\n                else\n                    {\n                        a[k] = r[j];\n                        j++;\n                        k++;\n                    }\n            }\n\n        /*copying remaining elements into a*/\n        while(i<l.length)\n            {\n                a[k] = l[i];\n                i++;\n                k++;\n            }\n\n        while(j<r.length)\n            {\n                a[k] = r[j];\n                j++;\n                k++;\n            }\n\n    }\n    /*method display elements in an array*/\n    public void display()\n    {\n        for(int newIndex=0;newIndex<a.length;newIndex++)\n        {\n        System.out.println(a[newIndex]);\n        }\n    }\n\n\n    public static void main(String[] args) \n    {\n        MergeSort obj = new MergeSort(8);\n        obj.division(a);\n        obj.display();\n    }\n\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort vs Quick Sort Implemenation\r\n                \r\nI have to measure the time it takes quick-sort and merge-sort to sort out integers in a file with random numbers.\nI read online that for a large amount of data merge-sort is supposed to be faster than quick-sort but my measurements say the opposite, merge-sort takes almost twice the time that quick-sort takes.\nIs my implementation of these algorithms the problem?\nResults of the measurements:\nQuick-Sort:\n\n5 milion int - 715,194,000 ns\n10 milion int - 1,383,187,400 ns\n50 milion int - 6,819,586,800 ns\n100 milion int - 14,159,986,000 ns\n150 milion int - 22,431,202,200 ns\n\nMerge-Sort:\n\n5 milion int - 1,644,349,000 ns\n\n10 milion int - 2,186,410,800 ns\n\n50 milion int - 14,427,917,500 ns\n\n100 milion int - 26,487,337,400 ns\n\n150 milion int - 42,229,109,700 ns\n```\n //Quick Sort Implementation\n public static void quickSort(int[] a, int start, int end){\n     if(end - start < 2){\n        return;\n     }\n\n     int pivtIndex = partition(a, start, end);\n     quickSort(a, start, pivtIndex);\n     quickSort(a, pivtIndex + 1, end);\n\n }\n\n public static int partition(int[] a, int start, int end){\n\n     int pivot = a[start];\n     int i = start;\n     int j = end;\n\n     while(i < j){\n         while(i < j && a[--j] >= pivot);\n         if(i < j){\n             a[i] = a[j];\n         }\n\n         while(i < j && a[++i] <= pivot);\n\n         if(i < j){\n             a[j] = a[i];\n         }\n     }\n\n     a[j] = pivot;\n\n     return j;\n }\n\n\n\n //Merge Sort Implementation\n\n public static void mergeSort(int[] input, int start, int end){\n     if(end - start < 2){\n         return;\n     }\n\n     int mid = (start + end)/2;\n     mergeSort(input, start, mid);\n     mergeSort(input, mid, end);\n\n     merge(input, start, mid, end);\n\n }\n\n public static void merge(int[] input, int start, int mid, int end){\n     if(input[mid-1] <= input[mid]){\n         return;\n     }\n\n     int i = start, j = mid, tempIndex = 0;\n\n     int[] temp = new int[end - start];\n\n     while(i < mid && j < end){\n          temp[tempIndex++] = input[i] <= input[j] ? input[i++] : input[j++];\n     }\n\n     System.arraycopy(input, i, input, start + tempIndex, mid - i);\n     System.arraycopy(temp, 0, input, start, tempIndex);\n }\n```\n\n\n\n    ", "Answer": "\r\nI think even, though the size of the array is of the range 150 * 10^6, the Quicksort must have gained an advantage due to the following reason:\nAssuming the size of integer in JAVA to be 4 bytes,\n(((150 * 10^6 * 4 bytes ) / 1024 bytes ) / 1024 mega bytes) ~ 572 MB.\nSize of L3 cache is around 50 MB.\nTherefore, (572 - 50) ~ 522 MB memory has to be taken care with the use of main memory (excluding L1 and L2 as their size is relatively low).\nNow, for the extra 522 MB, Merge Sort has to take help of main memory.\nTherefore, it is also obvious that Merge Sort will have to use the main memory, which is required for the accessory arrays.\nAccessing main memory is a heavy operation and Merge Sort need more access to main memory than the Quick Sort because of its accessory arrays.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Understanding Merge Sort\r\n                \r\nFollowing is my java implementation of merge sort, which I did after attending a tutorial on merge sort algorithm. \n\n```\npackage com.test.sort;\n\nimport java.util.Scanner;\n\n\n    ////100 80 90 70 60 40 50 30 10 20 //1 3 5 4 2\n    public class MergeSortTest {\n\n        private static int[] dataIntAry;\n\n        public static void main(String[] args) {\n\n            System.out.println(\"Enter data to be sorted : \");\n            Scanner scanner = new Scanner(System.in);\n            String data = scanner.nextLine();\n\n\n            String[] dataAry = data.split(\"\\\\ \");\n\n            dataIntAry = new int[dataAry.length];\n\n            int cnt = 0;\n            for (String dataEntity : dataAry) {\n                dataIntAry[cnt] = Integer.parseInt(dataEntity);\n                cnt++;\n            }\n            System.out.println(\"Array to operate on.\");\n            print(dataIntAry);\n            System.out.println(\"===================================================================\");\n\n            sort(dataIntAry);\n\n\n            System.out.println(\"###############################FINAL################################\");\n\n            print(dataIntAry);\n\n\n        }\n\n\n\n        private static void sort(int[] array) {\n\n            performMergeSort(0, array.length-1);\n\n        }\n\n        private static void performMergeSort(int lowerIndex, int higherIndex) {\n            System.out.println(\"Operating on array: \");\n            print(dataIntAry, lowerIndex, higherIndex);\n\n            //sort only if there is more than one elment in the array\n            if(lowerIndex < higherIndex) {\n                int middle = lowerIndex + ((higherIndex-lowerIndex)/2);\n\n\n                performMergeSort(lowerIndex,middle);\n\n                performMergeSort(middle+1, higherIndex);\n\n                merge(lowerIndex,higherIndex);\n\n            }\n\n\n        }\n\n        private static void merge(int lowerIndex, int higherIndex) {\n\n            System.out.println(\"Merging array: \");\n            print(dataIntAry, lowerIndex, higherIndex);\n\n            for(int i=lowerIndex; i<=higherIndex; i++) {\n                for(int j=i+1; j<=higherIndex; j++) {\n                    if(dataIntAry[i] > dataIntAry[j]) {\n                        int temp = dataIntAry[i];\n                        dataIntAry[i] = dataIntAry[j];\n                        dataIntAry[j] = temp;\n                    }\n                }\n            }\n\n            System.out.println(\"After Merge: \");\n            print(dataIntAry, lowerIndex, higherIndex);\n\n        }\n\n\n        private static void print(int[] dataIntAry){\n            System.out.println();\n            for(int val: dataIntAry){\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n\n        private static void print(int[] dataIntAry, int startIndex, int endIndex){\n            Systegivingrintln();\n\n            int index = 0;\n            for(int val: dataIntAry){\n                if(index >= startIndex && index <= endIndex)\n                    System.out.print(val + \" \");\n\n                index++;\n            }\n            System.out.println();\n        }\n\n    }\n```\n\n\nThis code sorts the array provided at run time. First of all I doubt if the implementation is corect or not!. If the implementation is correct, I am really suspicious about its performance. How do i really ensure that the implementation is giving a worst case performance of O(n log n)?\nThe main fishy part here is the merge() method where I do a comapre and swap!. \n    ", "Answer": "\r\nFrom your code I think your merging part is incorrect. You should merge based on lower, middle and higher index. Use below method call \n\n```\nmergeParts(lowerIndex, middle, higherIndex);\n```\n\n\ninstead of \n\n```\nmerge(lowerIndex,higherIndex);\n```\n\n\nUser below function\n\n```\nprivate void mergeParts(int lowerIndex, int middle, int higherIndex) {\n\n        for (int i = lowerIndex; i <= higherIndex; i++) {\n            tempMergArr[i] = array[i];\n        }\n        int i = lowerIndex;\n        int j = middle + 1;\n        int k = lowerIndex;\n        while (i <= middle && j <= higherIndex) {\n            if (tempMergArr[i] <= tempMergArr[j]) {\n                array[k] = tempMergArr[i];\n                i++;\n            } else {\n                array[k] = tempMergArr[j];\n                j++;\n            }\n            k++;\n        }\n        while (i <= middle) {\n            array[k] = tempMergArr[i];\n            k++;\n            i++;\n        }\n\n    }\n```\n\n\nComplexity of Merge sort is O(nlogn)\n\nBecause merge sort divides the array in two halves at each stage which gives it log(n) component and the other N component comes from its comparisons that are made at each stage. So combining it becomes nearly O(nlog n). \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Comparisons in merge-sort\r\n                \r\nI have this homework problem asking for the asymptotic worst case of comparisons for merge-sort when sorting 0s and 1s.\n\nThis is confusing to me because it looks like merge-sort has the same number of comparisons for whatever is placed in it with n elements. I probably don't fully understand merge-sort. Can someone enlighten me?\n    ", "Answer": "\r\nThe worst case according to me would be when 0's and 1's would come alternatively and when the total number of elements is a factor of 4. This is because merging takes max time because of this. This way Merge sort has O(nlogn)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort vs Selection Sort\r\n                \r\nI have written these 2 sorting algorithms and it appears that selection sort is faster than merge sort, surely this can't be right? My test data is 10 random arrays of size 5000 to 50000 where the largest possible numbers in the array is 100.\nHere is my selection sort implementation:\n```\nint i, j, iMin;\nint n = c.length;\n\nstartTime = System.currentTimeMillis();\nfor (i = 0; i < n - 1; i++) {\n    iMin = i;\n    for (j = i + 1; j < n; j++)\n        if (c[j] < c[iMin]) {\n            iMin = j;\n            if (sorting) {\n                theDelay();\n            }\n        }\n\n    if (iMin != i) {\n        swap(c, iMin, i);\n        if (sorting) {\n            theDelay();\n        }\n    }\n}\nendTime = System.currentTimeMillis();\noverallTime = endTime - startTime;\n// System.out.println(overallTime);\n```\n\nThe ```\ntheDelay()```\n method is simply to delay the thread that the sorting algorithm runs within so that a visual graph can draw to the JPanel to show the sort in action, in this test case it is being ignored so wont affect my sort time.\nHere is my merge sort implementation:\n```\npublic void mergeSort(int[] d) throws InterruptedException {\n    startTime = System.currentTimeMillis();\n    MergeSort(d, 0, d.length - 1);\n    endTime = System.currentTimeMillis();\n    overallTime = endTime - startTime;\n    //System.out.println(\"Merge\" +overallTime);\n}\n\nprivate void MergeSort(int[] array, int low, int high) throws InterruptedException {\n    int[] temp = new int[array.length];\n    if (low < high) {\n        int middle = low + (high - low) / 2;\n        MergeSort(array, low, middle);\n        MergeSort(array, middle + 1, high);\n        ReMerge(array, temp, low, middle, high);\n    }\n}\n\nprivate void ReMerge(int[] array2, int[] temp, int low, int middle, int high) throws InterruptedException {\n    for (int i = low; i <= high; i++) {\n        temp[i] = array2[i];\n    }\n    int i = low;\n    int j = middle + 1;\n    int k = low;\n\n    while (i <= middle && j <= high) {\n        if (temp[i] <= temp[j]) {\n            array2[k] = temp[i];\n            i++;\n            if (sorting) {\n                theDelay();\n            }\n        } else {\n            array2[k] = temp[j];\n            j++;\n            if (sorting) {\n                theDelay();\n            }\n        }\n        k++;\n    }\n    while (i <= middle) {\n        array2[k] = temp[i];\n        k++;\n        i++;\n        if (sorting) {\n            theDelay();\n        }\n    }\n}\n```\n\nis there something in my implementation affecting the time it should take for a merge sort to complete???\n    ", "Answer": "\r\nYou have:\n\n```\nprivate void MergeSort(int[] array, int low, int high) throws InterruptedException\n{\n    int[] temp = new int[array.length];\n```\n\n\nOf course allocating an array of length ```\n5000```\n to ```\n50000```\n at each step of the recursion will make the algorithm much slower. Try to reuse the same temp array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Buggy merge sort implementation\r\n                \r\nMy merge sort implementation is buggy since i am not getting two sorted list before calling merge.I am not sure what is wrong with it.\n\n```\ndef mergeSort(arr):\n    if len(arr) == 1 : return arr\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    mergeSort(left_half)\n    mergeSort(right_half)\n    return merge(left_half,right_half)\n\ndef merge(list1,list2):\n  res = []\n  i = 0\n  j = 0\n  while i < len(list1) and j < len(list2):\n    if list1[i] < list2[j]:\n      res.append(list1[i])\n      i += 1\n    elif list1[i] > list2[j]:\n      res.append(list2[j])\n      j += 1\n  #Add remaining to res if any\n  while i < len(list1):\n    res.append(list1[i])\n    i += 1\n  while j < len(list2):\n    res.append(list2[j])\n    j += 1\n  return res\n\nA = [5,1,2,15]\nprint(mergeSort(A))\n```\n\n\nMy understanding of merge sort is that the space complexity is O(n) since n items in memory (in the final merge).Is quick sort preferred over merge sort just because quick sort is in-place? \n    ", "Answer": "\r\nI not python expert, but you should write\n\n```\nleft_half = arr[:mid]\nright_half = arr[mid:]\n\nleft_half = mergeSort(left_half)\nright_half = mergeSort(right_half)\n```\n\n\nBecause your mergeSort return copy of sorted array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort output - scheme\r\n                \r\nI have a merge sort function that takes a predicate and a list of real values, it then sorts them according to the predicate. e.g.\n\n```\n(merge-sort > '(1 7 4 6)) \n    ---> (7 6 4 1)\n```\n\n\nMy question is given the association lists:\n\n```\n(define *Mark*\n    '( (age . 20)\n       (gender . male))\n\n(define *Judith*\n    '( (age . 30)\n       (gender . female))\n\n(define *Elliot*\n    '( (age . 40)\n       (gender . male))\n```\n\n\nwhich have been used to create an unordered list (Mark Elliot Judith), how, using their ages in the merge sort \n\n```\n(merge-sort > '(20 40 30)) ---> (40 30 20)\n```\n\n\ncan I output the ordered list \n\n```\n(Elliot Judith Mark)\n```\n\n    ", "Answer": "\r\n```\n(merge-sort (lambda (a b)\n              (define (get-age x)\n                (cdr (assq 'age x)))\n              (> (get-age a) (get-age b)))\n            (list *Mark* *Judith* *Elliot*))\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Modification to merge sort to sort using Insertion sort and then merge normally\r\n                \r\nGiven this merge sort code I am not sure how to modify the code to sort with insertion sort so that we divide the data length n into k intervals with insertion sort and then merge these sorted k intervals with the normal merge sort method.\nHere is my merge sort code\npublic class hw4class1 extends Sorter{\n\n```\npublic static void printArray(int[] array) {\n            if (array.length <= 100) {\n                for(int i=0; i < array.length; ++i) {\n                    System.out.print(array[i]+\" \"); // print out values\n                }\n                System.out.println();\n            } else {\n                System.out.println(\"array too large to print (\"+array.length+\" elements).\");\n            }\n\n        }\n\n        public void sort(int[] values) {\n        System.out.print(\"call to \"+this.getClass().getName()+\" with \");\n            printArray(values);\n            if (values==null || values.length <=1) { // check for termination condition\n                System.out.print(\"returning from \"+this.getClass().getName()+\" with \");\n                printArray(values);\n                return;\n            } else {\n                int middle = values.length/2; // divide array into two arrays of half size\n                int[] left = new int[middle];\n                for (int i=0; i<middle; i++) {\n                    left[i] = values[i];\n                }\n                int[] right = new int[values.length-middle];\n                for (int i=0; i<values.length-middle; i++) {\n                    right[i] = values[middle+i];\n                }\n                sort(left); // recursively call sorting function on each smaller arry\n                sort(right);\n\n                int l=0, r=0; // combine sorted arrays\n                for (int i=0; i<values.length; i++) {\n                    if (r>=right.length || (l<left.length && left[l]<right[r])) {\n                        values[i]=left[l];\n                        l++;\n                    } else {\n                        values[i]=right[r];\n                        r++;\n                    }\n                }\n                System.out.print(\"returning from \"+this.getClass().getName()+\" with \");\n            printArray(values);\n                return;\n            }\n        }\n\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "python merge sort issue [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nNot sure where I am going wrong with my implementation of merge sort in python.\n\n```\nimport sys\n\nsequence = [6, 5, 4, 3, 2, 1]\n\ndef merge_sort(A, first, last):\n    if first < last:\n        middle = (first + last) / 2\n        merge_sort(A, first, middle)\n        merge_sort(A, middle+1, last)\n        merge(A, first, middle, last)\n\ndef merge(A, first, middle, last):\n    L = A[first:middle]\n    R = A[middle:last]\n\n    L.append(sys.maxint)\n    R.append(sys.maxint)\n\n    i = 0\n    j = 0\n    for k in xrange(first, last):\n        if L[i] <= R[j]:\n            A[k] = L[i]\n            i = i + 1\n        else:\n            A[k] = R[j]\n            j = j + 1\n\nmerge_sort(sequence, 0, len(sequence))\nprint sequence\n```\n\n\nI would really appreciate it if someone could point out what is breaking my current implementation of merge sort.\n    ", "Answer": "\r\nThe problem is here:\n\n```\n    merge_sort(A, first, middle)\n    merge_sort(A, middle+1, last) # BEEP\n```\n\n\nYou only sort the second part from middle + 1, when you should start at middle. In fact, you never reorder the element at middle.\n\nOf course you cannot write either\n\n```\n    merge_sort(A, first, middle)\n    merge_sort(A, middle, last) # BEEP, BEEP\n```\n\n\nbecause when last = first + 1, you get middle == first and dive in an endless recursion (stopped by a ```\nRuntimeError: maximum recursion depth exceeded```\n)\n\nSo the way to go is:\n\n```\n    merge_sort(A, first, middle)\n    if middle > first: merge_sort(A, middle, last)\n```\n\n\nAfter that little change, your implementation gives correct results.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Modification to merge sort to sort using Insertion sort and then merge normally\r\n                \r\nGiven this merge sort code I am not sure how to modify the code to sort with insertion sort so that we divide the data length n into k intervals with insertion sort and then merge these sorted k intervals with the normal merge sort method.\nHere is my merge sort code\npublic class hw4class1 extends Sorter{\n\n```\npublic static void printArray(int[] array) {\n            if (array.length <= 100) {\n                for(int i=0; i < array.length; ++i) {\n                    System.out.print(array[i]+\" \"); // print out values\n                }\n                System.out.println();\n            } else {\n                System.out.println(\"array too large to print (\"+array.length+\" elements).\");\n            }\n\n        }\n\n        public void sort(int[] values) {\n        System.out.print(\"call to \"+this.getClass().getName()+\" with \");\n            printArray(values);\n            if (values==null || values.length <=1) { // check for termination condition\n                System.out.print(\"returning from \"+this.getClass().getName()+\" with \");\n                printArray(values);\n                return;\n            } else {\n                int middle = values.length/2; // divide array into two arrays of half size\n                int[] left = new int[middle];\n                for (int i=0; i<middle; i++) {\n                    left[i] = values[i];\n                }\n                int[] right = new int[values.length-middle];\n                for (int i=0; i<values.length-middle; i++) {\n                    right[i] = values[middle+i];\n                }\n                sort(left); // recursively call sorting function on each smaller arry\n                sort(right);\n\n                int l=0, r=0; // combine sorted arrays\n                for (int i=0; i<values.length; i++) {\n                    if (r>=right.length || (l<left.length && left[l]<right[r])) {\n                        values[i]=left[l];\n                        l++;\n                    } else {\n                        values[i]=right[r];\n                        r++;\n                    }\n                }\n                System.out.print(\"returning from \"+this.getClass().getName()+\" with \");\n            printArray(values);\n                return;\n            }\n        }\n\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Type Of Merge Sort Confusion\r\n                \r\nI am asked to write two types of merge sorts. One is a binary merge sort with time theta(n lgn) and a natural merge sort with time O(n lgn). I have searched everywhere to understand what each of them do. I am having trouble understanding the differences, I just need some explanation or examples would be great. I have written a merge sort but what I have is it a natural or binary merge sort?\n\n```\nbool compareElements(int i, int j)\n{\n    ++COMPARE_COUNT;\n    //int *t = i;\n     return i < j;\n}\nvoid merge(int values[], int left[], int right[], int middle, int total)  \n{\nint left_size = middle, right_size = total - middle;\nint i = 0, j = 0;\n\n// Loop through values array\nfor (int k = 0; k < total; k++)\n{\n    // If elements left on left and either no elements on right \n    // or left is larger than right, then use next left value\n    if (i < left_size && (j >= right_size || left[i] <= right[j]))\n    {\n        values[k] = left[i];\n        i++;\n    }\n    // else use next right value\n    else\n    {\n        values[k] = right[j];\n        j++;\n    }\n  }\n}\nvoid mergeSort(int values[], int n,bool result)  \n{\nif(result == false)\n{\n    if (n < 2)\n    {\n        return;\n    }\n    int middle = n / 2;\n    int *left = new int [middle];\n    int *right = new int [n - middle];\n\n    for (int i = 0; i < n; i++)\n    {\n        //COMPARE_COUNT++;\n        if(compareElements(i,middle))        //(i < middle)\n        {\n            SWAP_COUNT++;\n            left[i] = values[i];\n        }\n        else if(!compareElements(i,middle))\n        {\n            SWAP_COUNT++;\n            right[i - middle] = values[i];\n        }\n    }\n    mergeSort(left, middle,result);\n    mergeSort(right, n - middle,result);\n    merge(values, left, right, middle, n);\n}\n}\n```\n\n    ", "Answer": "\r\nA binary merge sort has a very simple recursive definition: split the input array into two halves, sort the two halves using binary merge sort, merge the two halves into a sorted sequence. This is what you implemented.\n\nA different version is a bottom-up merge sort. This first splits a sequence up into subsequences of length 1, and then starts merging them.\n\nA natural merge sort has a different first step. It doesn't split the input sequence into halves, but into runs. A run is a sequence of elements that are increasing or decreasing. For example the following array:\n\n```\n0 1 4 2 3 9 8 7 5 2 1 3 4 2 4 3 4\n```\n\n\nCan be split into runs like this:\n\n```\n0 1 4 | 2 3 9 | 8 | 7 | 5 | 2 | 1 3 4 | 2 4 | 3 4\n```\n\n\nWhere each run is is already ascending. Then you start merging runs as if you would in merge sort, except you merge from the bottom up.\n\nThe reason this is called a natural merge sort is that if your input is already (partially) pre-sorted, the algorithm will start to approach a O(n) best case performance.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Is this a merge sort?\r\n                \r\nI'm trying to understand the merge sort  and O( Log n) algorithms better. I want to know if this is a merge sort that I have written, and if I can improve it. I tested this program and it does indeed work.\n\n```\npublic class MyMergSort {\n    public void PrintArray(int[] arr) {\n        for (int i = 0; i < arr.length; ++i) {\n            System.out.print(\"\\t\" + arr[i]);\n        }\n    }\n\n    public void Proccess(int[] arr, int low, int median) {\n        low = 0;\n        median = arr.length / 2;\n        Sort(arr, low, median, median);\n        low = median;\n        median = arr.length - 1;\n        Sort(arr, low, median, median);\n        low = 0;\n        Sort(arr, low, arr.length - 1, arr.length);\n        // median = arr.length-1;\n        // Sort(arr,low,median);\n    }\n\n    public void Sort(int[] arr, int low, int end, int counter) {\n        if (arr.length == 1) {\n            System.out.println(\"Only one item is in the list, it is sorted!\");\n            return;\n        }\n        for (int i = low; i < end; ++i) {\n            if (arr[i] > arr[i + 1]) {\n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n            }\n        }\n        if (counter >= 0) {--counter;\n            Sort(arr, low, end, counter);\n        }\n    }\n\n    public static void main(String[] args) {\n        // TODO code application logic here\n        int[] array = {\n            14,\n            33,\n            27,\n            10,\n            35,\n            19,\n            42,\n            44\n        };\n        MyMergSort sort = new MyMergSort();\n        System.out.println(\"My Custom MergSort\");\n        sort.Proccess(array, 0, 0);\n        sort.PrintArray(array);\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge-sort for Stacks\r\n                \r\nAny idea why my Stack merge-sort isn't working? It's pretty identical to my merge-sort for arrays, yet that one works. Is my recursion setup wrong? \n\nThanks!\n\n```\ndef sort(stack):\n    if len(stack) > 1:\n        middle = len(stack) // 2\n        stack_len = len(stack)\n        left = Stack()\n        right = Stack()\n        for i in range(middle):\n            left.push(stack.pop())\n        for i in range(middle, stack_len):\n            right.push(stack.pop())\n        sort(left)\n        sort(right)\n        while(not left.is_empty() and not right.is_empty()):\n            if (left.top() < right.top()):\n                stack.push(right.pop())\n            else:\n                stack.push(left.pop())\n        while(not left.is_empty()):\n            stack.push(left.pop())\n        while(not right.is_empty()):\n            stack.push(right.pop())\n```\n\n\nHere is my Stack ADT implementation:\n\n```\nclass Stack:\n\n    def __init__(self):\n        self._data = []\n\n    def __len__(self):\n        return len(self._data)\n\n    def is_empty(self):\n        return len(self) == 0\n\n    def push(self, i):\n        self._data.append(i)\n\n    def pop(self):\n        if not self.is_empty():\n           return self._data.pop()\n        raise IndexError('Cannot pop an empty Stack.')\n\n    def top(self):\n        if not self.is_empty():\n            return self._data[len(self) - 1]\n        raise IndexError('Cannot check the top of an empty Stack.')\n```\n\n\nMy test case is:\n\n```\nif __name__ == '__main__':\n    s = Stack()\n    s.push(8)\n    s.push(0)\n    s.push(-4)\n    s.push(11)\n    s.push(19)\n    s.push(21)\n    s.push(3)\n    s.push(14)\n    s.push(1)\n    s.push(14)\n    print(s._data)\n    sort(s)\n    print(s._data)\n```\n\n\nwhich gives:\n\n```\n[8, 0, -4, 11, 19, 21, 3, 14, 1, 14]\n\n[19, 14, 1, 21, 3, 14, -4, 8, 0, 11]\n```\n\n    ", "Answer": "\r\nI assume you are doing this to learn merge sort or LIFO, but if not, since your ```\nstack```\n is just a python list (array), the functions ```\nsorted(s._data)```\n or ```\ns._data.sort()```\n both accomplish what you need.  If you need to continue with stack then...\n\nFirst, debug:\n\nIf you want to learn your error, you can place some ```\nprint()```\n statements to view what your stack looks like at each phase of your code.  Your sort function is good, and does separate your arrays properly.  The flaw is in the merge section.  The merge section of your algorithm occurs after your recursive calls to ```\nsort()```\n in the section with the 3 while loops.  With your example input, eventually, these arrays will be merged:\n\n```\nMERGING\nL [19]\nR [11, -4]\n```\n\n\nSince you are doing this with a stack LIFO, using ```\npop()```\n based on this conditional: ```\nleft.top() < right.top()```\n, the resultant new stack array becomes:\n ```\n[19, -4, 11]```\n.  Last in, First, out, means -4 is added second once the Left array is empty, since Right is emptied.  However, with a proper merge, this array would be merged sorted, and should be merged like this:\n\n```\n[-4, 11, 19]\n```\n\n\nYour next merge is this:\n\n```\nMERGING\nL [8, 0]\nR [19, -4, 11]\n```\n\n\nWhich results in the new stack being: ```\n[11, 0, 8, -4, 19]```\n, which eventually leads to 19 being added first to your final stack, thus 19 is in the place of index 0 in your results, and you get this: ```\n[19, 14, 1, 21, 3, 14, -4, 8, 0, 11]```\n\n\nResolution:\n\nTo resolve this, you should use a ```\nqueue```\n instead, which would be FIFO, and you would always add the lowest number first to your queue, which would be at index 0 of your array (i.e. moving from left to right).  If you absolutely must use a ```\nstack```\n and continue with the ```\nappend```\n and ```\n.pop()```\n methodology, then, I suggest:\n\nFirst, in the merge section, merge the lesser number with higher precedence over the higher number.  Then, before you add from either the Left or Right arrays to the stack in the merging section, you need to ensure that the number you are adding is greater than the current head (Last in) of the stack.  If it is not greater, then you need to ```\npop()```\n the stack into a new array or the left / right array (whichever array you are not working on) until the next added value is actually greater than the head of the stack.  Then, continue with the same method only adding values to the stack that are greater than the head of the stack, remembering to add the pop'd values back to the stack also in proper order.\n\nCode updated solution\n\nHere is the added code as a solution maintaining the stack methodology:\n\n```\nwhile(not left.is_empty() and not right.is_empty()):\n    if (left.top() > right.top()):\n        if stack.is_empty() or stack.top() <= right.top():\n            stack.push(right.pop())\n        else:\n            left.push(stack.pop())\n    else:\n        if stack.is_empty() or stack.top() <= left.top():\n            stack.push(left.pop())\n        else:\n            right.push(stack.pop())\nwhile(not left.is_empty()):\n    if stack.is_empty() or stack.top() <= left.top():\n        stack.push(left.pop())\n    else:\n        right.push(stack.pop())\nwhile(not right.is_empty()):\n    if stack.is_empty() or stack.top() <= right.top():\n        stack.push(right.pop())\n    else:\n        left.push(stack.pop())\nwhile(not left.is_empty()):\n    stack.push(left.pop())\n```\n\n\nSolution with updates: ```\n[-4, 0, 1, 3, 8, 11, 14, 14, 19, 21]```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Not Working?\r\n                \r\nI'm having some trouble getting my Merge Sort function to work with the specifications given to me by my professor. Been staring at VS and Google for an eternity trying to figure this guy out.\n\nThe algorithm provided:\n\n\n\narrayFunctions.h\n\n```\ntemplate<class T>\nvoid printArray(T arr[], int numElements)\n{\n    cout << \"(\";\n\n    for (int i = 0; i < numElements; i++)\n    {\n\n        cout << arr[i];\n\n        if (i < numElements - 1)\n            cout << \", \";\n    }\n\n    cout << \")\" << \"\\n\\n\";\n}\n\ntemplate <class T>\nvoid setArray(T to[], T from[], int size)\n{\n    for (int i = 0; i < size; i++)\n        to[i] = from[i];\n}\n\ntemplate <class T>\nvoid setArray(T to[], T from[], int size1, int size2)\n{\n    int size = size1;\n    if (size2 < size1) size = size2;\n\n    setArray(to, from, size);\n}\n```\n\n\nmain\n\n```\nconst int NUM = 5;\n\nint originalArray[NUM] = { 4, 2, 5, 3, 1 };\nint newArray[NUM];\n\ncout << \"Original:\\n\";\nprintArray(originalArray, NUM); //prints an array with formatting\n\n// Merge Sort\nsetArray(newArray, originalArray, NUM); //set's newArray to the same values of originalArray\nmergeSort(newArray, 0, NUM - 1);\n\ncout << \"Merge Sort:\\n\";\nprintArray(newArray, NUM);\n\npause();\n```\n\n\nThe output when running main is:\n\nOriginal:\n(4, 2, 5, 3, 1 )\n\nMerge Sort:\n(0, 0, 0, -33686019, 1)\n\nmerge:\n\n```\ntemplate <class T>\nvoid merge(T L[], int lowerBound, int mid, int upperBound)\n{\n    // Get size for new arrays\n    int size1 = mid - lowerBound;\n    int size2 = upperBound - mid;\n\n    // Create Temporary Arrays\n    T * tmp1 = new T[size1 + 1]();\n    T * tmp2 = new T[size2 + 1]();\n\n\n    // Populate both arrays from original\n    for (int i = 0; i < size1; i++)\n        tmp1[i] = L[lowerBound + i];\n\n    for (int j = 0; j < size2; j++)\n        tmp2[j] = L[mid + j];\n\n    tmp1[size1] = numeric_limits<T>::max();\n    tmp2[size2] = numeric_limits<T>::max();\n\n    int i = 0;\n    int j = i;\n\n    for (int k = lowerBound; k < upperBound; k++)\n    {\n        if (tmp1[i] <= tmp2[j])\n        {\n            L[k] = tmp1[i];\n            i++;\n        }\n        else\n        {\n            L[k] = tmp2[j];\n            j++;\n        }\n    }\n\n    delete[] tmp1;\n    delete[] tmp2;\n}\n```\n\n\nmergeSort:\n\n```\ntemplate<class T>\nvoid mergeSort(T L[], int lowerBound, int upperBound)\n{\n    if (lowerBound < upperBound)\n    {\n        int mid = (lowerBound + upperBound) / 2;\n\n        mergeSort(L, lowerBound, mid);\n        mergeSort(L, mid + 1, upperBound);\n\n        merge(L, lowerBound, mid, upperBound);\n    }\n}\n```\n\n\nSo... what am I doing wrong? A bump in the right direction would be GREATLY appreciated.\n    ", "Answer": "\r\nIt's a simple off by one error.\n\n```\nT * tmp1 = new T[size1 + 1]();\n...\ntmp1[size1 + 1] = numeric_limits<T>::max();\n           ^^^\n```\n\n\nArray indexes go from ```\n0```\n to ```\nn-1```\n, not to ```\nn```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Is this Quick sort or Merge sort?\r\n                \r\nHere is the function:\n\n```\ndef sort(unsorted):\n    less = []\n    equal = []\n    greater = []\n\n    if len(unsorted) < 1:\n        return unsorted\n\n    pivot = unsorted[-1]\n\n    for element in unsorted:\n        if element < pivot:\n            less.append(element)\n        if element == pivot:\n            equal.append(element)\n        if element > pivot:\n            greater.append(element)\n\n    return sort(less)+equal+sort(greater)\n\n\nunsorted = [7 ,2, 1, 8, 6, 3, 5, 4]\nprint sort(unsorted)\n```\n\n\nI am having hard time defining it as either Quick sort or Merge sort. Conceptually, I think it fits the definition of Quick sort: it uses a pivot to separate elements into smaller and bigger than pivot subsets and then sorts them recursively. But on the other hand it very much reminds me of Merge sort, since it recursively breaks down given list into smaller chunks and them assembles them back together (although around the \"pivot\").\n\nSo is this a Quick sort or Merge sort?\n    ", "Answer": "\r\nQuicksort partitions, MergeSort merges.\n\nThere is clearly a partitioning process (small keys on one side, large keys on the other), and there is clearly no merging (two sorted sequences intertwined in a single one).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort C++ Incorrectly Sorting\r\n                \r\nI'm writing a program that will do 5 different sorting functions and compare times across them. I'm outputting the 1000th element of each array to see if it's sorted correctly, all of my other sorts except merge sort are producing the correct number. Merge sort is close but off, it is within an element or two of getting the correct answer (outputting 25011 rather than 25034 for the 1000th element.) Here is the code for my merge sort:\n```\n//Zach Heesaker. CS3. Project 4\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <ctime>\n#include <cstdio>\n#include <time.h>\n#include <stdint.h>\n#include<list>\n#include<cmath>\n\nusing namespace std;\n\nconst int n = 10000;\nint numswaps, numcompares;\n\nvoid swap(int& a, int& b);\nvoid print(int arr[], int n, ofstream& outf, double time);\nvoid read(int arr[], int size);\nvoid mergepass(int arr[], int y[], int& n, int& L);\nvoid mergeSort(int arr[], int n);\nvoid merge(int arr[], int y[], int L, int m, int n);\n\nint main()\n{\n    int numsorts = 5;\n    string whichsort;\n    ofstream outf(\"output.ot\");\n    int arr[n + 1];\n    clock_t start, end;\n    double time;\n\n    outf << \"Sort Name: \" << setw(5) << \" \" << \"1000th Element: \" << setw(1) << \" \" << \"Number of Moves: \" << setw(1) << \" \" << \"Time taken: \" << endl;\n    read(arr, n);\n    numcompares = 0;\n    numswaps = 0;\n    start = clock();\n    mergeSort(arr, n);\n    end = clock();\n    time = double(end - start) / double(CLOCKS_PER_SEC);\n}\n\nvoid mergeSort(int arr[], int size)\n{\n    int L = 1;\n    int y[n + 1];\n    while (L < n)\n    {\n        mergepass(arr, y, size, L);\n        L = 2 * L;\n        mergepass(y, arr, size, L);\n        L = 2 * L;\n    }\n}\n\nvoid merge(int arr[], int y[], int L, int m, int n)\n{\n    int i, j, k, t;\n    i = L;\n    k = L;\n    j = m + 1;\n    while ((i <= m) && (j <= n))\n    {\n        numcompares++;\n        if (arr[i] <= arr[j])\n        {\n            numswaps++;\n            y[k++] = arr[i++];\n        }\n        else\n        {\n            numswaps++;\n            y[k++] = arr[j++];\n        }\n    }\n    if (i > m)\n    {\n        for (t = j; t <= n; t++)\n        {\n            numswaps++;\n            y[k + t - j] = arr[t];\n        }\n    }\n    else\n    {\n        for (t = i; t <= m; t++)\n        {\n            numswaps++;\n            y[k + t - i] = arr[t];\n        }\n    }\n}\n\nvoid mergepass(int arr[], int y[], int& n, int& L)\n{\n    int i, t;\n    i = 1;\n    while (i <= n - 2 * L + 1)\n    {\n        merge(arr, y, i, i + L - 1, i + 2 * L - 1);\n        i = i + 2 * L;\n    }\n    if ((i + L - 1) < n)\n    {\n        merge(arr, y, i, i + L - 1, n);\n    }\n    else\n    {\n        for (t = i; t <= n; t++)\n        {\n            numswaps++;\n            y[t] = arr[t];\n        }\n    }\n}\n\nvoid swap(int& a, int& b)\n{\n    int temp;\n    temp = a;\n    a = b;\n    b = temp;\n    numswaps += 3;\n}\n\nvoid print(int arr[], int n, ofstream& outf, double time)\n{\n    outf << left  << setw(6) << \" \" << left  << arr[1000] << setw(12) << \" \" << left <<  numswaps << setw(10) << \" \" << left << \"\\t\" << time << endl;\n}\n\nvoid read(int arr[], int size)\n{\n    ifstream ifs(\"input.txt\");\n    int i = 0;\n    while (!ifs.eof())\n    {\n        ifs >> arr[i];\n        i++;\n    }\n}\n\nint merge(int arr[], int left, int right)\n{\n    int pivot = arr[right];\n    int k = (left - 1);\n    for (int j = left; j <= right - 1; j++)\n    {\n        numcompares++;\n        if (arr[j] < pivot)\n        {\n            k++;\n            swap(arr[k], arr[j]);\n        }\n    }\n    swap(arr[k + 1], arr[right]);\n    return (k + 1);\n}\n```\n\nAny ideas as to what is going wrong in here? Thank you.\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How do I write a correct micro-benchmark in Java?\r\n                \r\nHow do you write (and run) a correct micro-benchmark in Java?\n\nI'm looking for some code samples and comments illustrating various things to think about.\n\nExample: Should the benchmark measure time/iteration or iterations/time, and why?\n\nRelated: Is stopwatch benchmarking acceptable?\n    ", "Answer": "\r\nTips about writing micro benchmarks from the creators of Java HotSpot:\nRule 0: Read a reputable paper on JVMs and micro-benchmarking. A good one is Brian Goetz, 2005. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics.\nRule 1: Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timing phase(s). (Fewer iterations is OK on the warmup phase. The rule of thumb is several tens of thousands of inner loop iterations.)\nRule 2: Always run with ```\n-XX:+PrintCompilation```\n, ```\n-verbose:gc```\n, etc., so you can verify that the compiler and other parts of the JVM are not doing unexpected work during your timing phase.\nRule 2.1: Print messages at the beginning and end of timing and warmup phases, so you can verify that there is no output from Rule 2 during the timing phase.\nRule 3: Be aware of the difference between ```\n-client```\n and ```\n-server```\n, and OSR and regular compilations. The ```\n-XX:+PrintCompilation```\n flag reports OSR compilations with an at-sign to denote the non-initial entry point, for example: ```\nTrouble$1::run @ 2 (41 bytes)```\n. Prefer server to client, and regular to OSR, if you are after best performance.\nRule 4: Be aware of initialization effects. Do not print for the first time during your timing phase, since printing loads and initializes classes. Do not load new classes outside of the warmup phase (or final reporting phase), unless you are testing class loading specifically (and in that case load only the test classes). Rule 2 is your first line of defense against such effects.\nRule 5: Be aware of deoptimization and recompilation effects. Do not take any code path for the first time in the timing phase, because the compiler may junk and recompile the code, based on an earlier optimistic assumption that the path was not going to be used at all. Rule 2 is your first line of defense against such effects.\nRule 6: Use appropriate tools to read the compiler's mind, and expect to be surprised by the code it produces. Inspect the code yourself before forming theories about what makes something faster or slower.\nRule 7: Reduce noise in your measurements. Run your benchmark on a quiet machine, and run it several times, discarding outliers. Use ```\n-Xbatch```\n to serialize the compiler with the application, and consider setting ```\n-XX:CICompilerCount=1```\n to prevent the compiler from running in parallel with itself. Try your best to reduce GC overhead, set ```\nXmx```\n(large enough) equals ```\nXms```\n and use ```\nUseEpsilonGC```\n if it is available.\nRule 8: Use a library for your benchmark as it is probably more efficient and was already debugged for this sole purpose. Such as JMH, Caliper or Bill and Paul's Excellent UCSD Benchmarks for Java.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Fast functional merge sort\r\n                \r\nHere's my implementation of merge sort in Scala:\n\n```\nobject FuncSort {\n  def merge(l: Stream[Int], r: Stream[Int]) : Stream[Int] = {\n    (l, r) match {\n      case (h #:: t, Empty) => l\n      case (Empty, h #:: t) => r\n      case (x #:: xs, y #:: ys) => if(x < y ) x #:: merge(xs, r) else y #:: merge(l, ys)\n    }\n  }\n\n  def sort(xs: Stream[Int]) : Stream[Int] = {\n    if(xs.length == 1) xs\n    else {\n      val m = xs.length / 2\n      val (l, r) = xs.splitAt(m)\n      merge(sort(l), sort(r))\n    }\n  }\n}\n```\n\n\nIt works correctly and it seems that asymptotically it is fine as well but it is way slower (approx 10 times) than Java implementation from here http://algs4.cs.princeton.edu/22mergesort/Merge.java.html and uses a lot of memory. Is there a faster implementation of merge sort which is functional? Obviously, it's possible to port Java version line by line but that's not what I'm looking for.\n\nUPD: I've changed ```\nStream```\n to ```\nList```\n and ```\n#::```\n to ```\n::```\n and the sorting routine became faster, only three to four times slower than Java version. But I don't understand why doesn't it crashes with stack overflow? ```\nmerge```\n isn't tail-recursive, all arguments are strictly evaluated...how is it possible?\n    ", "Answer": "\r\nYou have raised multiple questions. I try to answer them in a logical order:\n\nNo stack overflow in the Stream version\n\nYou did not really ask this one, but it leads to some interesting observations.\n\nIn the Stream version you are using ```\n #:: merge(...)```\n inside the ```\nmerge```\n function. Usually this would be a recursive call and might lead to a stack overflow for big enough input data. But not in this case. The operator ```\n#::(a,b)```\n is implemented in ```\nclass ConsWrapper[A]```\n (there is an implicit conversion) and is a synonym for ```\ncons.apply[A](hd: A, tl: ⇒ Stream[A]): Cons[A]```\n. As you can see, the second argument is call by name, meaning it is evaluated lazily. \n\nThat means ```\nmerge```\n returns a newly created object of type ```\ncons```\n which will eventually call merge again. In other words: The recursion does not happen on the stack, but on the heap. And usually you have plenty of heap.\n\nUsing the heap for recursion is a nice technique to handle very deep recursions. But it is much slower than using the stack. So you traded speed for recursion depth. This is the main reason, why using ```\nStream```\n is so slow. \n\nThe second reason is, that for getting the length of the ```\nStream```\n, Scala has to materialize the whole ```\nStream```\n. But during sorting the ```\nStream```\n it would have to materialize each element anyway, so this does not hurt very much.\n\nNo stack overflow in List version\n\nWhen you are changing Stream for List, you are indeed using the stack for recursion. Now a Stack overflow could happen. But with sorting, you usually have a recursion depth of ```\nlog(size)```\n, usually the logarithm of base ```\n2```\n. So to sort 4 billion input items, you would need a about 32 stack frames. With a default stack size of at least 320k (on Windows, other systems have larger defaults), this leaves place for a lot of recursions and hence for lots of input data to be sorted.\n\nFaster functional implementation\n\nIt depends :-)\n\nYou should use the stack, and not the heap for recursion. And you should decide your strategy depending on the input data:\n\n\nFor small data blocks, sort them in place with some straight forward algorithm. The algorithmic complexity won't bite you, and you can gain a lot of performance from having all data in cache. Of course, ou could still hand code sorting networks for the given sizes.\nIf you have numeric input data, you can use radix sort and handle the work to the vector units on you processor or your GPU (more sophisticated algorithms can be found in GPU Gems).\nFor medium sized data blocks, you can use a divide-and-conquer strategy to split the data to multiple threads (only if you have multiple cores!)\nFor huge data blocks use merge sort and split it of in blocks that fit in memory. If you want, you can distribute these blocks on the network and sort in memory.\n\n\nDon't use swap and use your caches. Use mutable data structures if you can and sort in place. I think that functional and fast sorting does not work very well together. To make sorting really fast, you will have to use stateful operations (e.g. in-place mergesort on mutable arrays).\n\nI usually try this on all my programs: Use pure functional style as far as possible but use stateful operations for small parts when feasible (e.g. because it has better performance or the code just has to deal with lots of states and becomes much better readable when I use ```\nvar```\ns instead of ```\nval```\ns).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge part in merge sort\r\n                \r\nwe have merge sort for two arrays or linked list how can I write merge part for more than two linked lists?\nplease help me thanks\n    ", "Answer": "\r\nEither merge two at a time and merge the result with the third or alter the merging logic to take the min element from all three lists.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort not working properly\r\n                \r\nWithin my merge sort method I also have a merge function which I believe to be working correctly as I tested it elsewhere. However when I try the merge sort as a whole the numbers do not sort properly.\nEDIT: added merge\n\nCode:\n\n```\nvoid mergeSort( int A[], int p, int q )\n// PRE: p >= 0; q >= 0; A[p..q] is initialized\n// POST: A[p..q] is sorted in ascending order\n{\n    int i;                                     //  counter used to initialize L and R\n    int j;\n    int m;                                     // midpoint of A\n    int L[100];                                // lower half of A\n    int R[100];                                // upper half of A\n\n    if ( p < q )                               // if list contains more than one value\n    {\n        m = ( p + q ) / 2;                     // find midpoint\n\n        j = 0;\n\n        for ( i = p; i <= m; i++ )             // initialize lower half of array\n        {\n            L[j] = A[i];\n            j++;\n        }\n\n        j = 0;\n\n        for ( i = m + 1; i <= q; i++ )         // initialize upper half of array\n        {\n            R[j] = A[i];\n            j++;\n        } \n\n        mergeSort( A, p, m );                  // call mergeSort for lower half of array\n\n        mergeSort( A, m + 1, q );              // call mergeSort for upper half of array\n\n        merge( L, R, m - p + 1, q - m, A );    // merge both sides\n    }   \n}\n\nvoid merge( int L[], int R[], int l_size, int r_size, int A[] )\n// PRE: l_size > 0; r_size > 0; L[0..l_size-1] is in ascending order;\n//      R[0..r_size-1] is in ascending order; A is allocated to l_size + r_size\n// POST: A[0..l_size+r_size-1] contains all elements of L[0..l_size-1] and          \n         R[0..r_size-1]\n{\n    int i;                                 // counter used to fill A at end of algorithm\n    int l_ctr;                             // counter used to traverse L\n    int r_ctr;                             // counter used to traverse R\n    int a_ctr;                             // counter used to traverse A\n\n    l_ctr = 0;\n    r_ctr = 0;                             // set all counters equal to zero\n    a_ctr = 0;\n\n    while ( l_ctr < l_size && r_ctr < r_size ) // loop runs until reaching end of a list\n    {\n        if ( L[l_ctr] < R[r_ctr] )            // if lowest remain ing value in L is\n        {                                     // lower than lowest remaining value in R;\n            A[a_ctr] = L[l_ctr];              // set next index of A to L[l_ctr]\n            l_ctr++;                          // increment l_ctr by one\n        }\n        else                                       // else do the same for r_ctr\n        {\n            A[a_ctr] = R[r_ctr];\n            r_ctr++;\n        }\n        a_ctr++;                                   // increment a_ctr by one\n    }\n\n    if ( l_ctr < l_size )                          // if all of L has not been seen yet\n    {\n        for ( i = l_ctr; i < l_size; i++ )         // loop sets remaining values in L\n        {                                          // to the last values of A\n            A[a_ctr] = L[i];\n            a_ctr++;\n        }\n    }\n    else                                           // else do the same for R\n    {\n        for ( i = r_ctr; i < r_size; i++ )\n        {\n            A[a_ctr] = R[i];\n            a_ctr++;\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nYour merge step always uses ```\nA[0]```\n as the destination to merge the two ranges. You want the ranges described by indices ```\n[p..m]```\n and ```\n[m+1..q]```\n to go back into ```\nA[p..q]```\n. There are at least two simple fixes.\n\n\nPass ```\nA+p```\n as the last parameter to ```\nmerge```\n (or use ```\n&A[p]```\n, they're the same).\nPass ```\np```\n as an additional parameter to ```\nmerge```\n and use it to initialize ```\na_ctr```\n.\n\n\nPick either one and test it.\n\nEdit:\n\nI tested your code locally and see the recursive calls to ```\nmergeSort```\n should be moved up to just below the line where you compute ```\nm```\n. The following lines where you copy to the temp arrays belong to the merge process and should be after the recursive calls.\n\nWorking example at ideone.com\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merged merge sort in Java\r\n                \r\nI had to write a merge sort function in Java. No problem. Well, a little, but I got through it. Then the follow up question I didn't get.\n\nQuestion: Given an array ```\nA[][]```\n such that ```\nA[i][0]```\n is a ```\nfloat```\n and ```\nA[i][1]```\n is a nonnegative ```\nint```\n giving the multiplicity of the value ```\nA[i][0]```\n (here think of a big vector that's been collapsed down by combining repeated entries and recording how many got combined), write a version of merge sort that returns ```\nB[][]```\n where ```\nB[i][0] < B[i+1][0]```\n for all ```\ni```\n.\n\nAny ideas? The best I could do was merge sort and then group the equal ones, but apparently you can do it all in one step.\n    ", "Answer": "\r\nStrage question... and using different types in these arrays is just ugly (personal point of view).\n\nHowever, the most useful thing to do, is to rewrite your merge function with a ```\nComparator```\n.\nThis way you can sort using whatever property you want.\nYou would end up with a signature like ```\nvoid merge(A[] arr, Comparator<? super A> comp)```\n.\nBy the way, the Java implementation of sort is a lot like this.\n\nTo solve your question you would call:\n\n```\nA[][] a = ...;\nmerge(a, new Comparator<A[]>() {\n  int compare(A[] a, A[] b) {\n    return ((Float)a[0]) - ((Float)b[0]);\n  }\n});\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort C++ not sorting\r\n                \r\nI am doing the Algorithm Part I course, and I implemented merge sort using C++. It was supposed to do the in-place sorting but It doesn't sort the array. I am not able to find the reason. Hoping to get a positive response. Thank you.\n```\nvoid merge(int *a, int *aux, int low, int mid, int high) {\n    for (int k = low; k <= high; ++k)\n        aux[k] = a[k]; // copy\n    int i = low, j = mid + 1;\n    for (int k = low; k <= high; ++k) { // merge\n        if (i > mid)\n            a[k] = aux[j++];\n        else if (j > mid)\n            a[k] = aux[i++];\n        else if (aux[i] > aux[j])\n            a[k] = aux[j++];\n        else\n            a[k] = aux[i++];\n    }\n}\n```\n\n```\nvoid sort(int *a, int *aux, int low, int high) {\n    if (high <= low)\n        return;\n    int mid = low + (high - low) / 2;\n    sort(a, aux, low, mid);\n    sort(a, aux, mid + 1, high);\n    merge(a, aux, low, mid, high);\n}\n```\n\n```\nvoid sort(int *a, int N) {\n    int *aux = new int[N];\n    sort(a, aux, 0, N - 1);\n}\n```\n\n    ", "Answer": "\r\nYour merge function is logically incorrect. For any iteration the last two conditions will never be executed. ```\nj```\n will be always greater than ```\nmid```\n, control will not reach beyond the second expression.\nModify your definition of merge function to something like this :\n```\nvoid merge(int *a, int *aux, int low, int mid, int high) {\n    for (int k = low; k <= high; ++k)\n        aux[k] = a[k]; // copy\n    int i = low, j = mid + 1;\n    for (int k = low; k <= high; ++k) { // merge\n\n// changes begin here\n\n        if (i <= mid and j <= high) {\n            if (aux[i] > aux[j])\n                a[k] = aux[j++];\n            else\n                a[k] = aux[i++];\n        }\n        else if (i > mid)\n            a[k] = aux[j++];\n        else // if (j > high)\n            a[k] = aux[i++];\n\n// changes end here\n\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort not sorting array\r\n                \r\nI have written the Java code below after reading up on merge sort. There are no errors when running the code but the merge sort does not sort the array. It just returns the original unsorted array. I can't for the life of me figure out where the problem might be. I appreciate any leads.\n\n```\npublic class mergeSort {\n\npublic void mergeSort(int array[], int n){\n\n    if(n<2) return; \n    int m=n/2;\n    int left[]=new int[m];\n    int right[]=new int[n-m];\n    int i;\n\n    for(i=0; i<m;i++){\n        left[i]=array[i];\n    }\n    for( i=m; i<n;i++){\n        right[i-m]=array[i];\n    }\n    printArray(left);\n    printArray(right);\n    mergeSort(left, m);\n    mergeSort(right, n-m);\n    merge(array, left, m, right, m-n);\n}\n\nprivate void merge(int[] array, int[] left, int leftCount, int[] right, int rightCount) {\n    int i=0,j=0,k=0;\n\n    while(i<leftCount && j< rightCount){\n        if(left[i]<=right[j]){\n            array[k]=left[i];\n            i++;\n            k++;\n        }else{\n            array[k]=right[j];\n            j++;\n            k++;\n        }\n    }\n\n    while(i<leftCount){\n        array[k]=left[i];\n        i++;\n        k++;\n    }\n    while(j<rightCount){\n        array[k]=right[j];\n        j++;\n        k++;\n    }\n\n}\n static void printArray(int arr[])\n    {\n        int n = arr.length;\n        for (int i=0; i<n; ++i)\n            System.out.print(arr[i] + \" \");\n        System.out.println();\n    }\n\npublic static void main(String[] args){\n    int a[]={3,2,1,7,9,8};\n    printArray(a);\n\n\n    mergeSort m=new mergeSort();\n    m.mergeSort(a, a.length);\n\n    printArray(a);\n}\n```\n\n\n}\n    ", "Answer": "\r\nThe leftCount and rightCount that you pass to the merge method is wrong.\n\nInstead don't pass that but calculate that in the merge method. I tried your code with the below change and it works perfectly fine.\n\n```\n merge(array, left, right);\n ...\nprivate void merge(int[] array, int[] left,  int[] right) {\n    int i=0,j=0,k=0;\n    int leftCount= left.length;\n    int rightCount = right.length;\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Javascript Shell Sort implementation is quicker then Merge Sort\r\n                \r\nI got two implementation of the algorithms: one is shell sort, the other is merge sort. \nShell sort complexity is something near n^1.5 and merge sort is n * logn, so basically merge sort should be quicker. However, on my test I see different results: shell sort much quicker then merge sort. I believe I am doing something wrong, however not seeing this.\n\nShell Sort implementaion:\n\n```\nvar shell_sort = function(array){\n    var length = array.length;\n    var h = 1;\n    while( h < length / 3){\n        h = 3 * h + 1;\n    }\n\n    while( h > 0 ){\n        for ( var i = h; i < length; i++){\n\n            for ( var j = i; j > 0 && array[j] < array[j-h]; j-=h){\n                array.swap(j, j-h);\n            }\n        }\n        //decreasing h\n        h = --h / 3\n\n    }\n    return array;\n};\n```\n\n\nAnd Merge Sort:\n\n```\nvar merge_sort = function(array){      \n    function merge(left, right){\n        var result = [];\n        var il = 0;\n        var ir = 0;\n\n        while (il < left.length && ir < right.length){\n          if (left[il] < right[ir]){\n            result.push(left[il++]);\n          } else {\n            result.push(right[ir++]);\n          }\n        }\n\n        if ( il < left.length){\n            result.push.apply(result,left.slice(il));\n        } \n\n        if (ir < right.length){\n            result.push.apply(result,right.slice(ir));\n        }\n\n        return result;\n    }\n\n    function merge_sort(items){\n        //well it is only 1 element\n        if (items.length < 2){\n            return items;\n        }\n\n        var middle = Math.floor(items.length / 2);\n\n        //create two arrays\n        var left = items.slice(0, middle);\n        var right = items.slice(middle);\n\n        return merge(merge_sort(left), merge_sort(right));\n    }\n\n    return merge_sort(array);\n\n};\n```\n\n\nBasically results on arrays of 10 million elements is next:\n\nShell sort : 12725ms \n\nMerge Sort: 34338ms\n\nTest is very simple:\n\n```\n//sorting 100000 elements\narray.generate_numbers(10000000);\nconsole.time('10000000elements');\nsort_algs(array);\nconsole.timeEnd('10000000elements');\n```\n\n\nWhere generate_numbers is simple helper function which generates array of numbers with configured size, as well as swap is a function which changes element positions.\n    ", "Answer": "\r\nAt a high level, your shell sort implementation relies primarily on the call to swap(), while the merge sort involves a number of array accesses and manipulations.  Quite simply, the ratio of logic handled by built in functions vs. your script is much higher in the shell sort, and in interpreted languages, that will generally result in faster execution.\n\nIn your particular case, the merge sort will be creating a new array on every call to merge(), calling .push() on that array a number of times, and eventually discarding the array when it is merged.  The shell sort does every thing in place, and never needs to create or destroy arrays.  Therefore, the performance of your merge sort relative to the shell sort is going to be heavily influenced by the characteristics of the garbage collection used by your browser.\n\nIf I remember correctly, a traditional analysis of merge sort assumes that creating, extending, and destroying arrays are are all roughly constant time operations.  This is probably not the case in Javascript.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Step by Step [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nHow would a merge sort step by step iteration look? I'm trying to grasp what happens in the merge sort. Ex. How would a list of values such as 25, 64, 22, 46, 20, 65, 90, 66, 48, 98 look step by step in a merge sort?\n    ", "Answer": "\r\nTake a look at this image found from wikipedia. Numbers are different but it's a good example of what the data would look like in each recursive call. http://en.wikipedia.org/wiki/File:Merge_sort_algorithm_diagram.svg\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Example for Pascal\r\n                \r\nMy teacher gave me a homework about how to Merge Sort two arrays in Pascal.\n\nOne of the arrays is named as N and sorted as ASCENDING..\nOther array named as M and sorted as DESCENDING.\n\nThey are pre-defined and he wants me to Merge Sort these two arrays.\n\nN [ 2, 4, 5, 8, 10 ]\nM [ 9, 7, 6, 3, 1 ]\nMerge Sort [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\n\nSo how can I do that?\nCan anyone explain me this Merge Sort algorithm by simple coding examples?\n    ", "Answer": "\r\nYour teacher is a clever guy, actually you need to understand what a mergesort does to merge two already sorted arrays. That's how mergesort works, it splits up the problem until there are two already sorted arrays, then it merges those arrays to one sorted array. This merging will be repeated until the whole array is sorted.\n\nThat's what you need to do (the code you should write on your own...)\n\n\nCreate an array that is big enough to hold the elements of N and M\nFor each position in the target array take the smallest remaining value of N and M. The smallest one you find like this:\n\na. If there are no elements of N left, take the smallest element of M\n\nb. If there are no elements of M left, take the smallest element of N\n\nc. Otherwise compare the smallest elements of N and M and take the smaller one.\n\n\nBecause the arrays are already sorted, you know exactly at which position the smallest element of N and of M can be found.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Algorithm Dilemma\r\n                \r\nConsider a recursive implementation of Merge Sort which is used to sort an array of size ```\nn```\n. The number of recursive calls made to Merge Sort is\n\neither ```\nO(n)```\n but not ```\nTheta(n)```\n\n\nor ```\nTheta(n)```\n\n\nor ```\nO(n log n)```\n but not ```\nTheta(n log n)```\n\n\nor ```\nTheta(n log n)```\n\n\nPS : I am preparing for an exam and found this question, What I am thinking is that merge sort has a time complexity of ```\nTheta(n log n)```\n but in that we have not considered the constants. So, it should be ```\nO(n log n)```\n but not ```\nTheta(n log n)```\n. But that is a wrong answer. What should be the correct answer and why?\n    ", "Answer": "\r\nAt each level of recursion, you call two instances of Mergesort. Also, the recursion depth is ```\nlog(n)```\n\n\n```\nHence the number of calls to MergeSort = 2 + 4 + 8 + ... + 2^(logn)\n                                       = 2 * ( 2^logn - 1 ) / (2 - 1)\n                                       = 2 * (n - 1 )\n                                       = Theta(N)\n```\n\n\nSo the number of calls is ```\nTheta(N)```\n. However, the overall time complexity of the algorithm is ```\nTheta(NlogN)```\n because at each depth in the recursion, you perform ```\nTheta(N)```\n steps for merging the sorted arrays and the total depth of the recursion tree is ```\nTheta(logN)```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Quick sort Vs. Merge sort Performance Analysis\r\n                \r\nMerge sort has worst case complexity of O(logN) vs Quick sort has O(N^2), so theoretically merge sort is supposed to perform better than quick sort. But I heard due to some copy overhead most of the cases quick sort outperforms merge sort. See the reference.\n\nThen I decided to implement and test, below is my full source code in C,\n\nSource\n\n```\n#include <stdio.h>\n#include <time.h>\n\n#define SZ 10000000\n#define MOD 10000007\n#define i64 long long int\n\ni64 nums[SZ];\n\ni64 L[SZ], R[SZ];\n\ni64 seed = 0xff;\ni64 srand(){\n    seed = (seed + 17 * seed) % MOD;\n    return seed;\n}\n\nvoid make(){\n    for (register int i = 0; i < SZ; i++)\n        nums[i] = srand() % MOD;\n}\n\nvoid swap(i64 *a, i64 *b){\n    i64 t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint pivote(int s, int e){\n\n    //int p = s + srand() % (e - s + 1);\n    int p = s + (e - s) / 2;\n    //int p = s;\n    //int p = e;\n\n    i64 v = nums[p];\n    int c = s;\n    swap(nums + p, nums + e);\n    for (register int i = s; i < e; i++){\n        if (nums[i] < v){\n            swap(nums + i, nums + c);\n            c++;\n        }\n    }\n    swap(nums + c, nums + e);\n    return c;\n}\n\nvoid qsort(int s, int e){\n\n    if (s < e){\n        int p = pivote(s, e);\n        qsort(s, p - 1);\n        qsort(p + 1, e);\n    }\n}\n\nvoid merge(i64 arr[], int l, int m, int r){\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2)\n    {\n        if (L[i] <= R[j])\n        {\n            arr[k] = L[i];\n            i++;\n        }\n        else\n        {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1)\n    {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2)\n    {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(i64 arr[], int l, int r){\n    if (l < r){\n        int m = l + (r - l) / 2;\n\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\n\nvoid testQsort(){\n    double s, e;\n\n    make();\n\n    s = clock();\n    qsort(0, SZ - 1);\n    e = clock();\n    printf(\"qsort random: %Lf ms\\n\", (e - s) / 1);\n\n    s = clock();\n    qsort(0, SZ - 1);\n    e = clock();\n    printf(\"qsort sorted: %Lf ms\\n\", (e - s) / 1);\n\n}\n\nvoid testMsort(){\n    double s, e;\n\n    make();\n\n    s = clock();\n    mergeSort(nums, 0, SZ - 1);\n    e = clock();\n    printf(\"msort random: %Lf ms\\n\", (e - s) / 1);\n\n    s = clock();\n    mergeSort(nums, 0, SZ - 1);\n    e = clock();\n    printf(\"msort sorted: %Lf ms\\n\", (e - s) / 1);\n}\n\nint main(){\n\n    testMsort();\n    testQsort();\n\n    return 0;\n}\n```\n\n\nResult for 10 million elements:\n\n```\nmsort random: 4596.000000 ms\nmsort sorted: 3354.000000 ms\nqsort random: 7637.000000 ms\nqsort sorted: 5074.000000 ms\n```\n\n\nI have used four versions of quick sort,\n\n\npivote at the first position\npivote at the last position \npivot at the middle position\npivote at the random position\n\n\nNone of the versions of quick sort seems to outperform merge sort.\nCould anyone tell why it was mentioned that quick sort outperforms merge sort?\n\nIs there any wrong with my quick sort implementation?\n\nUpdate 1\n\nFollowing the answer of @rcgldr mentioned below, I have tested the below version of the quick sort and it finally outperforms any version of the merge sort.\n\n```\nvoid qsort3(int s, int e){\n    if (s < e){\n        i64 p = nums[(s + e) / 2];\n        int i = s - 1;\n        int j = e + 1;\n        while (true){\n            while (nums[++i] < p);\n            while (nums[--j] > p);\n            if (i >= j) break;\n            swap(nums + i, nums + j);\n        }\n        qsort3(s, j);\n        qsort3(j + 1, e);\n    }\n}\n```\n\n    ", "Answer": "\r\nThe question's example for quick sort is based on Lomuto partition scheme, which is slower than Hoare partition scheme. Link to an example of Hoare partition scheme:\n\nQuickSort with middle elemenet as pivot\n\nThe merge sort example is constantly creating sub-arrays and copying data. A more efficient approach is to do a one time allocation of an array, then change the direction of merge based on the level of recursion for top down merge sort, or based on the pass count for bottom up merge sort. Link to a java source code showing both bottom up and top down merge sort. This can be easily converted to c:\n\n'MergeSort Algorithm' - What's the better implementation in JAVA?\n\nAs for the relative performance, a simple quick sort such as the one linked to in this answer is about 15% than a basic merge sort for sorting an array of simple elements like integers or floating point numbers. However, if the quick sort is enhanced to avoid worst case time complexity of O(n^2), the advantage is decreased, and the main advantage is that it doesn't require O(n) space that merge sort needs for it's merge operations. In general, merge sort does more moves but fewer compares than quicksort. If sorting an array of pointers to objects, the compare overhead becomes greater than the time it takes to move pointers, and merge sort ends up being faster. On the other hand, sorting an array of pointers to objects involves random accessing of those objects, which isn't cache friendly, and it's faster to sort the objects rather than the pointers unless the objects are fairly large (the trade off is typically around 128 to 256 bytes, depending on the system).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java - Merge sort array\r\n                \r\nI'm making an algorithm for a shop. I have made an array which contains customer information. Now I want to implement a merge-sort on this array and sort it on age. This is my code for the customer class:\n\n```\npublic class Customer{\n\nprivate int customerID;\nprivate String name;\nprivate int age;\nprivate char gender;\nprivate String email;\n\npublic List<Customer> customerList = new ArrayList<Customer>();\n\npublic Customer(String name, int age, char gender, String email) {\n    this.customerID = customerList.size();\n    this.name= name;\n    this.age= age;\n    this.gender= gender;\n    this.email = email;\n    customerList.add(this);\n}\npublic int getCustomerID() {\n    return customerID;\n}\n\npublic void setCustomerID(int customerID) {\n    this.customerID = customerID;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name= name;\n}\n\npublic int getAge() {\n    return age;\n}\n\npublic void setAge(int age) {\n    this.age = age;\n}\n\npublic char getGender() {\n    return gender;\n}\n\npublic void setGender(char gender) {\n    this.gender = gender;\n}\n\npublic String getEmail() {\n    return email;\n}\n\npublic void setEmail(String email) {\n    this.email = email;\n}\n```\n\n\n}\n\nThis is my merge-sort:\n\n```\n    private int[] helper;\nprivate int number;\n\npublic void sort(Klant[] values) {\n    this.customerList= values;                      <---Error\n    number = values.length;\n    this.helper = new int[number];\n    mergesort(0, number - 1);\n}\n\nprivate void mergesort(int low, int high) {\n    // check if low is smaller then high, if not then the array is sorted\n    if (low < high) {\n        // Get the index of the element which is in the middle\n        int middle = low + (high - low) / 2;\n        // Sort the left side of the array\n        mergesort(low, middle);\n        // Sort the right side of the array\n        mergesort(middle + 1, high);\n        // Combine them both\n        merge(low, middle, high);\n    }\n}\n\nprivate void merge(int low, int middle, int high) {\n\n    // Copy both parts into the helper array\n    for (int i = low; i <= high; i++) {\n        helper[i] = customerList[i];\n    }\n\n    int i = low;\n    int j = middle + 1;\n    int k = low;\n// Copy the smallest values from either the left or the right side back\n    // to the original array\n    while (i <= middle && j <= high) {\n        if (helper[i] <= helper[j]) {\n            customerList[k] = helper[i];\n            i++;\n        } else {\n            customerList[k] = helper[j];\n            j++;\n        }\n        k++;\n    }\n    // Copy the rest of the left side of the array into the target array\n    while (i <= middle) {\n        customerList[k] = helper[i];\n        k++;\n        i++;\n    }\n\n}\n```\n\n\nOn the line with:\nthis.customerList = values; I get an error: incompatible types Customer[] cannot be converted to List\n\nMy question is how can I fix this error and is my merge-sort correct this way?\n\nEdit 1:\n@Jens \nYour first option:\n    this.customerList= Arrays.asList(values);  \n\nfixed the error. But now I'm getting an error on this line:\n\n```\n            helper[i] = customerList[i];\n```\n\n\nIt says: array required, but List found\n\nDoes anybody know how to fix this?\n    ", "Answer": "\r\nYou can`t assign a Array to a list.\n\nTry \n\n```\n this.customerList= Arrays.asList(values);   \n```\n\n\nor Change the method parameetr to ```\nList<Customer>```\n\n\n```\npublic void sort(List<Customer> values) {\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Quicksort vs. In-place Merge Sort\r\n                \r\nI was researching whether or not Quicksort is better than Merge Sort, and most sources were in consensus that Quicksort is better, because it is in-place, while Merge Sort is not. However, there exist in-place Merge Sort algorithms, which invalidate the \"it needs extra space\" argument. So which is better, Quicksort or In-place Merge Sort?\n\nPS: When I say better, I mean faster, since space is not an issue for either of these sorts.\n\nEDIT: Is any speed lost when switching from out-of-place Merge Sort to in-place Merge Sort?\n    ", "Answer": "\r\nThe common implementation of in place merge sort is recursive, and quicksort is recursive, or both use some form of stack, so there is stack space used, O(log2(n)) for merge sort, and quicksort can also be restricted to O(log2(n)) by only using recursion on the smaller part after a partition step and looping for the large part, but time complexity can still be O(n^2) worst case.\n\nThe common in place merge sort is slower and also not stable. There are versions of merge sort that are in place and stable, but these are slow.\n\nThe algorithm for common in place merge sort is to sort the second half and the first quarter of an array, leaving the second quarter of the array unsorted. Then the first quarter and second half are merged into the array starting at the second quarter. Each time an element is merged, rather than moving it, that element is swapped, so what was the non-sorted data in the second quarter gets scattered about the sorted parts during a merge step (which is why this algorithm is not \"stable\"). When the merge step is completed, all of the unordered elements end up in the first quarter, with the rest of the array sorted. Next the first eighth of the array is sorted, and then the first eight and last 3 quarters are merged into the second eighth of the array, leaving the first eighth with unsorted data and the rest of the array sorted. This process is continued until there are only two unsorted elements on the left side of the array. These two elements are moved into place using insertion sort.\n\nNote that this is not a stable sort.\n\n\n\nUpdate - A block merge sort is stable and in place with time complexity O(n log(n)), but with lower order factors that make it slower than a normal merge sort that uses a second buffer. It works best if there are at least 2 · sqrt(n) unique values, which allows them to be re-ordered to provide working areas of an array and remain stable.\n\nhttps://en.wikipedia.org/wiki/Block_sort\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Visualize the merge sort\r\n                \r\nI have to create a code that let visualize how the merge sort works, using turtle module. Here is my code\n```\nimport turtle\nfrom random import randint\nimport time\n\ndef draw_bar(x,y,w,h):\n    turtle.up()\n    turtle.goto(x,y)\n    turtle.seth(0)\n    turtle.down()\n    turtle.begin_fill()\n    turtle.fd(w)\n    turtle.left(90)\n    turtle.fd(h)\n    turtle.left(90)\n    turtle.fd(w)\n    turtle.left(90)\n    turtle.fd(h)\n    turtle.left(90)\n    turtle.end_fill()\n\ndef draw_bars(v,currenti=-1,currentj=-1,M=500):\n    turtle.clear()\n    x = -250\n    n = len(v)\n    w = 500/n\n    r = 500/M\n\n    for  i in range(n):\n        if i == currenti: turtle.fillcolor('red')\n        elif i == currentj: turtle.fillcolor('blue')\n        else: turtle.fillcolor('gray')\n        draw_bar(x,-250,w,v[i]*r)\n        x += w\n     screen.update()\n\ndef mergeSort(arr, start, length):\n    if length > 1:\n        mergeSort(arr, start, int(length/2))\n        mergeSort(arr, start+int(length/2), int(length/2))\n\n        L = arr[start:start+int(length/2)]\n        R = arr[start+int(length/2):start+length]\n        i=0\n        j=0\n        k=0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[start+k] = L[i]\n                draw_bars(arr, j, j+1, max(arr))\n                turtle.update()\n                i += 1\n            else:\n                arr[start+k] = R[j]\n                draw_bars(arr, j, j+1, max(arr))\n                turtle.update()\n                j += 1\n            k += 1\n        while i < len(L):\n            arr[start+k] = L[i]\n            draw_bars(arr, j, j+1, max(arr))\n            turtle.update()\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[start+k] = R[j]\n            draw_bars(arr, j, j+1, max(arr))\n            turtle.update()\n            j += 1\n            k += 1\n    \n\nscreen = turtle.Screen()\nscreen.setup(600,600)\nscreen.tracer(0,0)\nscreen.title('Grafica')\nturtle.speed(0)\nturtle.hideturtle()\na = [randint(0,100) for i in range(90)]\nmergeSort(a,0,len(a))\n```\n\nWhen I run, it makes some problem, the list is disorder, but a bit better. I think there is a problem in the merge sort algorithm. Does someone know the error? Can someone help me, o try to explain another way to show how the algorithm works?\nTo arrive at this point i read the geeks for geeks page: https://www.geeksforgeeks.org/merge-sort/, and the following question: Visualize MergeSort in Python\n    ", "Answer": "\r\n\nI think there is a problem in the merge sort algorithm.\n\nThe problem seems to be your half array length calculation (substituting ```\nlength//2```\n for ```\nint(length/2)```\n:\n```\nmergeSort(array, start, length//2)\nmergeSort(array, start + length//2, length//2)\n```\n\nThe second one is incorrect, this should be:\n```\nmergeSort(array, start, length//2)\nmergeSort(array, start + length//2, length - length//2)\n```\n\nOtherwise you potentially lose one off the end.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Correct merge sort\r\n                \r\nSo... If I input:\n\n4 1 5 3\n\nINSTEAD OF 1,3,4,5\n\nI GET      [ 4, 1, 5, 3 ]\n\nFollowing is the code for merge sort but for the last comparison the program doesn't fetch updated (1,4) (3,5) value rather (4,1) (5,3) thus giving the wrong result.\n\n\r\n\r\n```\n var a = [4, 1, 5, 3];\r\n    q(a);\r\n    function q(a) {\r\n      var start = 0;\r\n      var n = a.length;\r\n      var length = parseInt(n / 2);\r\n      if (n < 2) {\r\n        return n;\r\n      }\r\n      var l = [], r = [];\r\n      for (i = 0; i < length; i++) {\r\n        l[i] = a[i];  //left array\r\n      }\r\n      for (i = 0, j = length; j < n; i++ , j++) {\r\n        r[i] = a[j];   //right array\r\n      }\r\n      q(l);           //merge sort left array\r\n      q(r);           //merge sort right array\r\n      comp(l, r);\r\n    }\r\n    \r\n    function comp(l, r) {\r\n      var k = [], m = 0, i = 0, j = 0;\r\n      while (i < ((l.length)) && j < ((r.length))) {\r\n        if (l[i] < r[j]) {\r\n          k[m] = l[i];\r\n          i++;\r\n          m++\r\n        }\r\n        else {\r\n          k[m] = r[j];\r\n          j++;\r\n          m++\r\n        }\r\n      }\r\n      while (i != (l.length)) {\r\n        k[m] = l[i];\r\n        m++;\r\n        i++;\r\n      }\r\n      while (j != (r.length)) {\r\n        k[m] = r[j];\r\n        m++;\r\n        j++;\r\n      }\r\n      console.log(k); //for final output it is [ 4, 1, 5, 3 ] instead of [1,3,4,5]\r\n\r\n    }```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nYou have a couple small problems. The main one is that you are returning the wrong thing from your edge condition:\n\n```\nif (n < 2) {\n    return n; // n is just a length; doesn't make sense to return it.\n}\n```\n\n\n```\nn```\n is the length, you really want to return the small array here:\n\n```\n  if (n < 2) {\n    return a;  // return the array instead\n  }\n```\n\n\nAlso, you need to pass the result of the recursive call to your comp function. Right now you're just returning the original lists with:\n\n```\n comp(l, r)\n```\n\n\nSomething like this would work better:\n\n```\n  let l_sort = q(l);           //merge sort left array\n  let r_sort = q(r);           //merge sort right array\n  return comp(l_sort, r_sort); // merge the arrays when recursion unwinds.\n```\n\n\nAnd you need to ```\nreturn```\n things for recursion to work.\n\nPut all together:\n\n\r\n\r\n```\nfunction q(a) {\r\n  var start = 0;\r\n  var n = a.length;\r\n  var length = parseInt(n / 2);\r\n  if (n < 2) {\r\n    return a;\r\n  }\r\n  var l = [],\r\n    r = [];\r\n  for (i = 0; i < length; i++) {\r\n    l[i] = a[i]; //left array\r\n  }\r\n  for (i = 0, j = length; j < n; i++, j++) {\r\n    r[i] = a[j]; //right array\r\n  }\r\n  let l_sort = q(l); //merge sort left array\r\n  let r_sort = q(r); //merge sort right array\r\n  return comp(l_sort, r_sort);\r\n}\r\n\r\nfunction comp(l, r) {\r\n  var k = [],\r\n    m = 0,\r\n    i = 0,\r\n    j = 0;\r\n  while (i < ((l.length)) && j < ((r.length))) {\r\n    if (l[i] < r[j]) {\r\n      k[m] = l[i];\r\n      i++;\r\n      m++\r\n    } else {\r\n      k[m] = r[j];\r\n      j++;\r\n      m++\r\n    }\r\n  }\r\n  while (i != (l.length)) {\r\n    k[m] = l[i];\r\n    m++;\r\n    i++;\r\n  }\r\n  while (j != (r.length)) {\r\n    k[m] = r[j];\r\n    m++;\r\n    j++;\r\n  }\r\n  return k\r\n}\r\n\r\nconsole.log(q([4, 1, 5, 3]).join(','));\r\nconsole.log(q([5, 4, 3, 2, 1]).join(','));\r\nconsole.log(q([2, 3]).join(','));\r\nconsole.log(q([3, 2]).join(','));\r\nconsole.log(q([1]).join(','));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Explanation of Merge Sort for Dummies\r\n                \r\nI found this code online:\n\n```\ndef merge(left, right):\n    result = []\n    i ,j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result += left[i:]\n    result += right[j:]\n    return result\n\ndef mergesort(list):\n    if len(list) < 2:\n        return list\n    middle = len(list) / 2\n    left = mergesort(list[:middle])\n    right = mergesort(list[middle:])\n    return merge(left, right)\n```\n\n\nIt works 100% when I run it. I just do not really get how the merge sort works or how the recursive function is able to properly order both a left and a right.\n    ", "Answer": "\r\nI believe that the key to understanding merge sort is understanding the following principle -- I'll call it the merge principle:\n\n\n  Given two separate lists A and B ordered from least to greatest, construct a list C by repeatedly comparing the least value of A to the least value of B, removing the lesser value, and appending it onto C. When one list is exhausted, append the remaining items in the other list onto C in order. The list C is then also a sorted list. \n\n\nIf you work this out by hand a few times, you'll see that it's correct. For example:\n\n```\nA = 1, 3\nB = 2, 4\nC = \nmin(min(A), min(B)) = 1\n\nA = 3\nB = 2, 4\nC = 1\nmin(min(A), min(B)) = 2\n\nA = 3\nB = 4\nC = 1, 2\nmin(min(A), min(B)) = 3\n\nA = \nB = 4\nC = 1, 2, 3\n```\n\n\nNow A is exhausted, so extend C with the remaining values from B:\n\n```\nC = 1, 2, 3, 4\n```\n\n\nThe merge principle is also easy to prove. The minimum value of A is less than all other values of A, and the minimum value of B is less than all other values of B. If the minimum value of A is less than the minimum value of B, then it must also be less than all values of B. Therefore it is less than all values of A and all values of B.\n\nSo as long as you keep appending the value that meets those criteria to C, you get a sorted list. This is what the ```\nmerge```\n function above does. \n\nNow, given this principle, it's very easy to understand a sorting technique that sorts a list by dividing it up into smaller lists, sorting those lists, and then merging those sorted lists together. The ```\nmerge_sort```\n function is simply a function that divides a list in half, sorts those two lists, and then merges those two lists together in the manner described above.  \n\nThe only catch is that because it is recursive, when it sorts the two sub-lists, it does so by passing them to itself! If you're having difficulty understanding the recursion here, I would suggest studying simpler problems first. But if you get the basics of recursion already, then all you have to realize is that a one-item list is already sorted. Merging two one-item lists generates a sorted two-item list; merging two two-item lists generates a sorted four-item list; and so on. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort in java\r\n                \r\nThis code is a simple merge sort by divide and conquer analogy. I'm getting an unsorted array as output which is the same as the input array. Please point out the bug in this code:\n\n```\nimport java.util.*;\nclass Merge {\n    public static void main(String[] args) {\n        int n,i;\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"enter size of array\");\n        n = sc.nextInt();\n        int b[] = new int[n];\n        System.out.println(\"enter  array\");\n        for (i=0;i<n;i++) {\n            b[i] = sc.nextInt();\n        }\n        System.out.println(\"sorted array\");\n        int c[] = sort(b);\n        for (i=0;i<n;i++) {\n            System.out.println(c[i]);\n        }  \n    }\n    static int[] sort(int[] a) {   \n        int i;\n        int l = a.length;\n        if (l<2) {\n            return a;\n        }\n        int mid = l/2;\n        int left[] = new int[mid];\n        int right[] = new int[l - mid];\n        for (i=0;i<mid;i++) {\n            left[i] = a[i];\n        }\n        for (i=mid;i<l;i++) {\n            right[i-mid] = a[i];\n        }\n        sort(left);\n        sort(right);\n        merge(left,right,a);\n        return a;\n    }\n    static void merge(int[] left , int[] right , int[] a) {\n        int p=0,q=0,r=0;\n        while (p<left.length && q<right.length) {\n            if (left[p]<=left[q]) {\n                a[r] = left[p];\n                p++;\n            } else {\n                a[r] = right[q];\n                q++;\n            }\n            r++;\n        }\n        while (p<left.length) {\n            a[r] = left[p];\n            p++;\n            r++;\n        }\n        while (q<right.length) {\n            a[r] = right[q];\n            q++;\n            r++;\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nin your merge method you have problem with your condition\n\n```\n         if (left[p]<=left[q]) {\n```\n\n\nit should be  \n\n```\n          if (left[p]<=right[q]) {\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort implementation\r\n                \r\nI am new to c++ and was trying develop a code for merge sort. I tested it with a sample array of size 5 but the answer put out by the code is not right. I can't figure what's going wrong. Here is my code:\n\n```\n#include <iostream>\n#include <cstring>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\nvoid merge(int, int, int, int*);\nvoid merge_sort(int low, int high, int* p){\n    int pivot;\n    static int i(1);\n    if (high>low)\n    {\n        cout << \"calling merge_sort: \"<<i<<endl; i++;\n        pivot = low + ((high - low)/2);\n        cout << pivot << endl;\n        merge_sort(low, pivot, p);\n        merge_sort(pivot+1, high, p);\n        merge(low, pivot, high, p);\n\n    }\n}\nvoid merge(int l, int pi, int h,int* arr)\n{\n            int start = l;\n        int mid = pi+1;\n        while((start<=pi)&&(mid <=h)){\n            if (arr[start] > arr[mid])\n            {\n                int temp = arr[mid];\n                arr[mid] = arr[start];\n                arr[start] = temp;\n                mid++;\n             }\n            else\n                start++;\n    }\n}\nint main() \n{\n    int a[] = {2, 42, 3, 7, 1};\n    merge_sort(0, 4, a);\n    for (int i = 0; i<=4 ; i++)\n        cout << a[i] << endl;\n    return (0);\n\n}\n```\n\n\nThe output is as follows:\n\n```\ncalling merge_sort: 1\n2\ncalling merge_sort: 2\n1\ncalling merge_sort: 3\n0\ncalling merge_sort: 4\n3\n1\n3\n7\n2\n42\n```\n\n\nI have seen some codes for merge sort implementation on stackoverflow but they use another temporary array, which I want to avoid.\n\nAny help is greatly appreciated in sorting this issue.\n    ", "Answer": "\r\nThe logic in your merge is wrong. During the merge phase you know that you have 2 sections of sorted numbers. When you compare and swap ```\narr[start]```\n and ```\narr[mid]```\n you will break the sorting of the top set of numbers if ```\narr[start] > arr[mid+1]```\n. The example shows a problem with your code as 2 will be left in the wrong place:\n\n```\n4 6 8 | 1 3 5  ->  1 6 8 | 4 3 5\n^       ^          ^         ^\n```\n\n\nIn order to keep the 2 sections sorted you would have to insert ```\narr[start]```\n in the correct place in the top set of numbers which would make the complexity worse than ```\nO(n lg n)```\n. This is the reason that a second array is used.\n\nThere are method which use smaller arrays than the original for merging, these have their overheads but don't compromise the complexity (or correctness). If you want an ```\nO(n lg n)```\n in place sort then quicksort or heapsort is the way to go.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge Sort with non-recursive merge\r\n                \r\nI am trying to code a recursive merge sort algorithm, however my merging algorithm is not recursive.\nI have been told to do it using the following arguments in the functions below.\n```\ndef merge(left_buffer, right_buffer, data):\n    \n    \"Merges two sets of data together by comparison\"\n    print(\"MERGING\",left_buffer,\"and\",right_buffer)\n    #Dual iteration\n    m = 1\n    n = 1\n    k = 0\n    j = 0\n    for i in range(len(data)):\n        if len(left_buffer) == 0:\n            data[i] = right_buffer[k]\n            k+=1\n        elif len(right_buffer) == 0:\n            data[i] = left_buffer[j]\n            j += 1\n        elif left_buffer[0] < right_buffer[0]:\n            data[i] = left_buffer[0]\n            left_buffer = left_buffer[1:]\n            \n        else:\n            data[i] = right_buffer[0]\n            right_buffer = right_buffer[1:]\n    print('Result of the merge:',data)\n```\n\nThis is my function to merge two data sets together into another data set.\nAnd then my recursive merge sort algorithm:\n```\ndef merge_sort(data):\n    \"Merge sort recursion\"\n    if len(data) == 1:\n        return [data[0]]\n    else:\n        half_length = len(data)//2\n        left_half = data[0:half_length]\n        right_half = data[half_length:]\n        \n        #Only sorting the left side\n        left = merge_sort(left_half)\n        right = merge_sort(right_half)\n        \n        return merge(left,right,data)\n\n\n```\n\nThe main problem I receive is that upon the final merge of the two lists I get that I am merging ```\nNone```\n types.\nI am not sure how to solve this.\nMaybe my merging algorithm is incorrect, however my tutor said it was fine.\n    ", "Answer": "\r\nYour ```\nmerge```\n method doesn't return anything, so when your ```\nmerge_sort```\n method returns, it also returns ```\nNone```\n.\nThese ```\nNone```\n values get passed into ```\nleft```\n and ```\nright```\n, which you then pass into your ```\nmerge```\n method.\nPerhaps you want your ```\nmerge_sort```\n method to do the merge and then return the merged data?  I.e.:\n```\n    merge(left,right,data)\n    return data\n```\n\nAlternatively, you could modify ```\nmerge```\n so that it returned the merged data, by adding the line ```\nreturn data```\n to the end of it.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Selection sort to merge sort\r\n                \r\nBelow I have provided my example of selection sort code, which if possible I want to convert to merge sort (I am using a linked-list as my data type):\n\n```\npublic void sortRawDataRepository() {\n    for (int i = 0; i < rawDataRepository.size(); i++) {\n        for (int j = i + 1; j < rawDataRepository.size(); j++) {\n            Date iDate = rawDataRepository.get(i).getProductionDate();\n            Date jDate = rawDataRepository.get(j).getProductionDate();\n            if (iDate.getTime() > jDate.getTime()) {\n                Item tmp = rawDataRepository.get(i);\n                rawDataRepository.set(i, rawDataRepository.get(j));\n                rawDataRepository.set(j, tmp);\n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Big o of merge sort\r\n                \r\n```\nvoid mergeSort(int arr[], int l, int r) \n{ \n   if (l < r) \n    { \n        // Same as (l+r)/2, but avoids overflow for \n        // large l and h \n        int m = l+(r-l)/2; \n\n        // Sort first and second halves \n        mergeSort(arr, l, m); \n        mergeSort(arr, m+1, r); \n\n        merge(arr, l, m, r); \n    } \n} \n```\n\n\nhere's the code of merge sort \n\ni can't understand how its big o is n log(n) while the the big o of merge function is n and the function merge called 7 times which is n - 1\n\nif we have the following array as input {8,7,6,5,4,3,2,1}\n\nthen the calls of merge would be\n\nmerge({8,7,6,5,4,3,2,1}, 0,0,1)\n\nmerge({7,8,6,5,4,3,2,1}, 2,2,3)\n\nmerge({7,8,5,6,4,3,2,1}, 0,1,3)\n\nmerge({5,6,7,8,4,3,2,1}, 4,4,5)\n\nmerge({5,6,7,8,3,4,2,1}, 6,6,7)\n\nmerge({5,6,7,8,3,4,1,2}, 4,5,7)\n\nmerge({5,6,7,8,1,2,3,4}, 0,3,7)\n\nthen the result will be {1,2,3,4,5,6,7,8}\n\nso how big get calculated, i saw master method and i know its formula and saw 3 levels of the merge sort algorithm \n\nbut i want to calculate step by step \n    ", "Answer": "\r\nThe time complexity for sorting an array of length n with Mergesort is ```\nT(n)=2 * T(n/2) + O(n)```\n where T is the time complexity function and ```\n2 * T(n/2)```\n are the recursive calls and ```\nO(n)```\n is merging these two recursions. You can now prove that ```\nT(n) ∈ O(n * log(n))```\n with a proof by induction over ```\nm = log2(n)```\nif you want to. One such proof is stated here: https://www.cs.auckland.ac.nz/compsci220s1c/lectures/2016S1C/CS220-Lecture09.pdf\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "time complexity of merge sort [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nwhy the time complexity of best case of top-down merge sort is in O(nlogn)?\ni think the best case of top-down merge sort is 1, only need to compare 1 time.\nhow about the time complexity of bottom-up merge sort in worst case, best case and average case.\n\nOne more question is  why each iteration takes exactly O(n)? could some one help with that?\n    ", "Answer": "\r\n\n  why the time complexity of best case of top-down merge sort is in\n  O(nlogn)?\n\n\nBecause at each iteration you split the array into two sublists, and recursively invoke the algorithm. At best case you split it exactly to half, and thus you reduce the problem (of each recursive call) to half of the original problem. You need log_2(n) iterations,  and each iteration takes exactly ```\nO(n)```\n (each iteration is on all sublists, total size is still ```\nn```\n), so at total ```\nO(nlogn)```\n.\n\nHowever, with a simple preprocessing to check if the list is already sorted - it can be reduced to ```\nO(n)```\n.\n\nSince checking if a list is sorted is itself ```\nO(n)```\n - it cannot be done in ```\nO(1)```\n. Note that the \"best case\" is the \"best case\" for general ```\nn```\n, and not a specific size.\n\n\n  how about the time complexity of bottom-up merge sort in worst case,\n  best case and average case.\n\n\nThe same approach can give you O(n) best case to bottom up (simple pre processing). The worst case and best case of bottom up merge sort is ```\nO(nlogn)```\n - since in this approach the list is always divided to 2 equally length (up to difference 1) lists.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort throwing error [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am writing a merge sort and I'm getting an ```\narrayIndexOutOfBounds```\n exception and I can't figure out why.\n\nHere is the code:\n\n```\npublic class MergeSort {\n\n    private int[] helper; \n    private int[] numbers; \n\n    private int number; \n\n    //sort method\n    public MergeSort(int[] values){\n        this.numbers = values; \n        this.number = values.length; \n        this.helper = new int[number]; \n        merge(0, number-1); \n    }\n\n    //mergeSort method\n    public void merge(int low, int high){\n        if(low<high){\n            int mid =(low+high)/2;  \n            merge(low, mid); \n            merge(mid+1, high); \n            combine(low, mid, high);  \n        }\n    }\n    //merge method\n    public void combine(int low, int mid, int high){\n        //copy numbers into helper array;\n        for(int ii=0;ii<high;ii++){\n            this.helper[ii]=this.numbers[ii]; \n        }\n        int ii = low;\n        int jj = mid+1;\n        int kk = high; \n        while((ii <= mid) && (jj<=high)){\n\n            if(helper[ii] <= helper[jj]){\n                    //error is thrown here\n                this.numbers[kk] = this.helper[ii];\n                ii++; \n            }else{\n                this.numbers[kk] = this.helper[jj]; \n                jj++; \n            }\n            kk++;\n        }\n        while(ii<=mid){\n            this.numbers[kk]=this.helper[ii]; \n            kk++;\n            ii++;\n        }\n\n    }\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        int[] values = new int[]{2,6,1,9,12,64,32,23,12,90,87}; \n        // TODO Auto-generated method stub\n        MergeSort ms = new MergeSort(values); \n        System.out.println(Arrays.toString(ms.numbers)); \n    }\n\n}\n```\n\n    ", "Answer": "\r\nSeveral issues, but try the following code:\n\n```\npublic class MergeSort {\n\n    private int[] helper;\n    private int[] numbers;\n\n    private int number;\n\n    //sort method\n    public MergeSort(int[] values){\n        this.numbers = values;\n        this.number = values.length;\n        this.helper = new int[number];\n        merge(0, number-1);\n    }\n\n    //mergeSort method\n    public void merge(int low, int high){\n        if(low<high){\n            int mid =(low+high)/2;\n            merge(low, mid);\n            merge(mid+1, high);\n            combine(low, mid, high);\n        }\n    }\n    //merge method\n    public void combine(int low, int mid, int high){\n        //copy numbers into helper array;\n        for(int ii=low;ii<=high;ii++){\n            this.helper[ii]=this.numbers[ii];\n        }\n        int ii = low;\n        int jj = mid+1;\n        int kk = low;\n        while((ii <= mid) && (jj<=high)){\n            if(helper[ii] <= helper[jj]){\n                this.numbers[kk] = this.helper[ii];\n                ii++;\n            }else{\n                this.numbers[kk] = this.helper[jj];\n                jj++;\n            }\n            kk++;\n        }\n        while(ii<=mid){\n            this.numbers[kk]=this.helper[ii];\n            kk++;\n            ii++;\n        }\n\n    }\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        int[] values = new int[]{2,6,1,9,12,64,32,23,12,90,87};\n        // TODO Auto-generated method stub\n        MergeSort ms = new MergeSort(values);\n        System.out.println(Arrays.toString(ms.numbers));\n    }\n\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort function in C\r\n                \r\nI have the following piece of code which represents a merge sort function\n\n```\n/* perform merge sort */\nvoid merge_sort(int arr[], int left, int right) {\n    if (left < right) {\n        int middle = left + (right - left) / 2;\n        merge_sort(arr, left, middle);\n        merge_sort(arr, middle + 1, right);\n        merge(arr, left, middle, right);\n    }\n}\n```\n\n\nWhat is the use of this ```\nmerge_sort(arr, middle + 1, right);```\n?\n    ", "Answer": "\r\nThe basic idea of the merge sort algorithm is to divide the sequence to be sorted in half, sort each half, and then merge them together. This is frequently done recursively, as in this case. As a result, there must be two recursive calls, one for each half of the sequence.\n\nIf the ```\nmerge_sort(arr, middle+1, right);```\n call were not present, the algorithm would not be complete and the sort would not work.\n\nAs an experiment, you could try writing an example program using the merge sort function you posted. Try it with and without the line in question and see what results you get.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort in python IndexError\r\n                \r\nIn my merge sort implementation using python, run time an error occurred as\n\n\n  ```\nIndexError: list assignment index out of range```\n\n\n\nHere is the code:\n\n```\n#merge\ndef merge(array, low, mid, high):\n   n1 = mid - low + 1\n   n2 = high - mid\n   ll = [] * n1\n   rr = [] * n2\n   for i in range(n1):\n      ll[i] = array[low + i]\n   for j in range(n2):\n      rr[j] = array[mid + 1 + j]\n\n   (i, j) = (0, 0)\n   k = low\n\n   while i < n1 and j < n2:\n      if ll[i] <= rr[j]:\n         array[k] = ll[i]\n         i = i + 1\n      else:\n         array[k] = rr[j]\n         j = j + 1\n   k = k + 1\n   #for remaining members of the lists\n   while i < n1:\n      array[k] = ll[i]\n      i = i + 1\n      k = k + 1                \n\n   while i < n2:\n      array[k] = rr[j]\n      j = j + 1\n      k = k + 1  \n```\n\n\nmethod for merge sort\n\n```\ndef mergesort(array, low, high):\n   if low < high:\n      mid = low + (high - low) // 2\n\n      #recurrence\n      mergesort(array, low, mid)\n      mergesort(array, mid + 1, high)\n      merge(array, low, mid, high)\n```\n\n\ndriver \n\n```\narray = [ 74, 32, 89, 55, 21, 64 ]\nmergesort(array, 0, len(array))    \n```\n\n\nwhile running the code am getting an error that says ```\nIndexError: list assignment index out of range```\n\n    ", "Answer": "\r\nYou pass the length of the array as the second argument to ```\nmerge```\n, but the ```\nmerge```\n function seems to expect the index of the last element in the range to be sorted.\n\nThis API is classic but poorly chosen as you cannot specify an empty range and it is less regular, requiring some extra adjustments (```\n+ 1```\n and ```\n- 1```\n on subarray sizes etc.). You should modify the code so ```\nhigh```\n is the index of the first element after the range to be sorted.\n\nThere are other problems in the ```\nmerge```\n function:\n\n\nthe computation for the subarray sizes is incorrect\nyou increment ```\nk```\n outside the ```\nwhile```\n loop: ```\nk = k + 1```\n should be incremented in level deeper.\nthe last loop should use ```\nj```\n instead of ```\ni```\n as the index.\nthis implementation uses recursion, not recurrence\n\n\nHere is a modified version:\n\n```\ndef merge(array, low, mid, high):\n   n1 = mid - low\n   n2 = high - mid\n   ll = [] * n1\n   rr = [] * n2\n   for i in range(n1):\n      ll[i] = array[low + i]\n   for j in range(n2):\n      rr[j] = array[mid + j]\n\n   i = 0\n   j = 0\n   k = low\n\n   while i < n1 and j < n2:\n      if ll[i] <= rr[j]:\n         array[k] = ll[i]\n         i = i + 1\n      else:\n         array[k] = rr[j]\n         j = j + 1\n      k = k + 1\n\n   #copy the remaining members of the lists\n   while i < n1:\n      array[k] = ll[i]\n      i = i + 1\n      k = k + 1                \n\n   while j < n2:\n      array[k] = rr[j]\n      j = j + 1\n      k = k + 1  \n\ndef mergesort(array, low, high):\n   if high - low > 1:\n      mid = low + (high - low) // 2\n\n      #recursion\n      mergesort(array, low, mid)\n      mergesort(array, mid, high)\n      merge(array, low, mid, high)\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort in Pharo\r\n                \r\nSorry for my poor english.\nSo, i have a problem with my merge sort.\nThis is the merge part :\n\n```\nfusion: nTableau debut: deb1 fin1: fin1 fin2: fin2\n\n| deb2 compt1 compt2 i t |\n\nt := #().\ndeb2 := fin1 + 1.\ncompt1 := deb1.\ncompt2 := deb2.\ni:= deb1.\n\n(i to: fin1) do: [ t at:(i-deb1) put: (nTableau at:i) ].\n\ni := deb1.\ni to: deb1 do: [\n    (compt1 = deb2) ifTrue: [  ]\n    ifFalse:  [ compt2 =(fin2 +1)ifTrue: [ nTableau at:i put: (t at: compt1-deb1). compt1 := compt1+1 ] ];\n    ifFalse: [ (t at: (compt1-deb1) < nTableau at: compt2) ifTrue: [ nTableau at:i put: (t at:(compt1 - deb1)). compt1 := compt1 +1 ]  ];\n    ifFalse: [ nTableau at:i put: (nTableau at:compt2) ]\n      ]\n```\n\n\nAnd this is my sort part that do recursivity :\n\ntri\n\n```\n| trier milieu |\ntrier := nil.\ntrier := [ :tab :deb :fin |\n                [ deb := (taille/taille). fin = taille. tab := tableau ].\n                [ milieu := ( deb + fin ) //                    \n                                    (deb ~= fin) ifTrue: [ \n                                        trier value: tab value: deb value: milieu.\n                                        trier value: tab value: milieu+1 value: fin. \n                                        fusion: tab deb: debut fin1: milieu fin2: fin.\n                               ]\n     ]\n```\n\n\nI have the problem on the sort part. Please help me.\n    ", "Answer": "\r\nIt seems you have misunderstood what #ifTrue:ifFalse: and that family of messages do.\n\nThey are not syntactic constructions, but messages sent to objects and affected by ; as a cascade.\n\nIn your example, you have \n\n```\ni to: deb1 do: [\n    condition \n     ifTrue: [  ]\n     ifFalse: [ condition2 ifTrue: [ actions ] ];\n     ifFalse: [ condition3 ifTrue: [ other actions ];\n     ifFalse: [ an action more ] \n```\n\n\nbut that sends to the same boolean condition the first ifTrue:ifFalse: (which, by the way, is the same that just putting ifFalse: because the empty block in the ifTrue: part). And after, ifFalse: again, two more times, to the same object (because that is what the ; means). The condition is not re-evaluated, so if the first time it was true, nothing is done and if it was false, the three bocks of action will be performed.\nIt is equivalent to have only one ifFalse, concatenating all the actions inside the blocks.\n...and I don´t think that is what you intended.\n\nAlso, you had before that\n\n```\ni := deb1.\ni to: deb1 do: [ ... ]\n```\n\n\nand there you use the same value, doing deb1 to: deb1.\n(Does that even run? I thought that the block requires an argument)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "random merge sort\r\n                \r\nI was given the following question in an algorithms book:\n\nSuppose a merge sort is implemented to split a file at a random position, rather then exactly in the middle. How many comparisons would be used by such method to sort n elements on average?\n\nThanks.\n    ", "Answer": "\r\nTo guide you to the answer, consider these more specific questions:\n\nAssume the split is always at 10%, or 25%, or 75%, or 90%. In each case: what's the impact on recursion depths? How many comparisons need to be  per recursion level?\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort for characters\r\n                \r\nI have a large array of pointers, say 15,000 of them.\n\nI have a small bit of code\n\n```\nfor (int x = 0; x < n;x++)\n{\n    mergeSort(array[x],0,strlen(array[x]-1);\n}\n```\n\n\nThe reason I put merge sort in loop like that is to sort the characters in each index in alphabetical order, not the strings in the array.\n\nIs this losing efficiency if I have merge sort in the for loop? Will it make me lose run time of n log n?\n    ", "Answer": "\r\nMerge sort is always ```\nO(n * log_2(n))```\n, where ```\nn```\n is the length of the array being sorted. In this case, that's the string length. Each sort will be ```\nO(n * log_2(n))```\n.\n\nHowever, you're repeating the sort once for each of the strings, thus the total time is the sum of the time for each string:\n\n```\nO(n1 * log_2(n1)) + O(n2 * log_2(n2)) + ... + O(nk * log_2(nk))\n```\n\n\nWhere n1, n2, ..., nk are the lengths of all of the ```\nk```\n strings being sorted.\n\nIf we assume that all ```\nk```\n strings have length ```\nn```\n, than this algorithm as a whole is ```\nk * O(n * log_2(n))```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Where is Bottom Up merge sort useful?\r\n                \r\nI've been reading \"Algorithms, 4th Ed\" by Sedgewick & Wayne. The book presents two ways of using merge sort. Using standard top down recursive merge sort OR a bottom up merge sort.\n\nIs there any situation in which the bottom up merge sort is preferred over the top-down version?\n    ", "Answer": "\r\nRecursive mergesort requires ```\nO(log n)```\n space for the recursion stack, but the bottom-up version lets you do better (no recursion stack, just a few integers keeping track of your position in the input).\n\nIf you come across some language that doesn't support recursion and provides you with only limited memory for a stack (perhaps an embedded system?), the bottom-up version will be your only choice.\n\nHere's a bottom-up version that shows what I mean.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C++ merge sort not working\r\n                \r\nI am trying to implement merge sort, but I cannot get it to work. I would be really grateful if anyone could find and point out the error in my thinking (and code).\nMain function without unnecessary code:\n\n```\nint main(int argc, char *argv[]) {\n    int n = 0;\n    std::cin >> n;\n    int num[n];\n\n    for(int i = 0; i < n; i++) {\n        std::cin >> num[i];\n    }\n\n    sort(num, &num[n - 1], n);\n\n    return(0);\n}\n```\n\n\nMerge sort function:\n\n```\nint *sort(int *s, int *e, int size) {\n    if(s == e) {\n        return(s);\n    }\n\n    int mid = (size + 1) / 2;\n\n    //split array recursively to 1-element arrays\n\n    int *left  = sort(s, (s + mid - 1), mid);\n    int *right = sort(s + mid, e, size - mid);\n\n    int *counter = s;\n\n    //merge arrays back together\n\n    while(left < (s + mid - 1) && right <= e) {\n        //std::cout << *left << \" \" << *right << std::endl;\n\n        for(; left < (s + mid - 1) && *left <= *right; left++, counter++) {\n            *counter = *left;\n        }\n\n        for(; right <= e && *right <= *left; right++, counter++) {\n            *counter = *right;\n        }\n    }\n\n    for(; left < (s + mid - 1); left++, counter++) {\n        *counter = *left;\n    }\n    for(; right <= e; right++, counter++) {\n        *counter = *right;\n    }\n\n    return(s);\n}\n```\n\n\n\n  input0:\n  5\n  4 3 2 1 0\n  output0:\n  0 0 0 0 0  \n  \n  input1:\n  5\n  0 1 2 3 4\n  output1:\n  1 2 4 4 4  \n  \n  input2:\n  2\n  0 1\n  output2:\n  1 1\n\n    ", "Answer": "\r\nYour problem seems to be at ```\n*counter = *left```\n and ```\n*counter = *right```\n.A usual implementation of the algorithm uses a separate array for creating the new merged array. But in this case , you are merging it ```\ninplace```\n. When you do ```\n*counter = *left```\n that value is lost and this probably leads to all the zeros you see in your sample run.\n\nWhen you are merging , you could do it in two ways. Either create a temporary array and keep on writing to it instead of the ```\n*counter```\n and refill the actual array with the temporary array after you exhaust all the elements of both arrays, or resort to an insertion sort, once the array size to be merged is less than a predefined value . \n\nBoth these methods are given in detail in \nhttp://en.literateprograms.org/Merge_sort_%28C%29\n\nPS:I also think you should change the condition ```\nleft < (s + mid - 1)```\n to ```\nleft <=(s + mid -1)```\n in all the places .\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort With Linked List\r\n                \r\nI am trying to create a program for my computer science class that takes a linked list and sorts it via the merge sort algorithm. I'm having difficulty with taking the linked list and recursively splitting the nodes by finding the middle node. I have three classes, one for my node, my list, and for the merge sort class.\n\n```\nstatic Mynode h;\nstatic Mylist list = new Mylist();\n\npublic static void Sort(String[] list){\n}\n\npublic static void main(String[] args){\n    /*\n    node sort(node h);\n    node l2 = split(h);\n    */\n    list.insert(\"cat\");\n    list.insert(\"ok\");\n            list.insert(\"ok\");\n\n    list.printdata();\n    split(list);\n}\n\npublic void sort(){\n    String head;\n}\npublic static void merge(Mylist list, int right, int left){\n\n}\npublic static void split(Mylist list){\n    Mynode tempFast = h;\n    Mynode tempslow = h;        \n    Iterator iterator = tempFast.iterator();\n    Iterator iterator = tempslow.iterator();\n\n        while(tempslow.getNext()!=null && tempslow.getNext()!=null){\n            tempFast.getNext();\n            tempFast.getNext();\n            tempslow.getNext();\n        }\n}\n\npublic Merge(String data){\n    /*\n    this.data = data; \n    */\n}\n\n/*\npublic Node msort(String r){\n\n}\n    /*\n    node l2 = split(h);\n    h = msort(h);\n    l2 = msort(l2);\n    return merge(h, l2);\n    */\n}\n\n// input: java myms < word3\n// output: Unsorted: cow, zebra, ant || Sorted: ant, cat, zebra\n\nstatic Mynode h;\npublic Mylist(){\n    this.h = null;\n}\n\npublic void insert(String s) {\n//method for node insertion\n   this.h = new Mynode(s, this.h);\n}\npublic boolean contains(String s){\n//method for identifying contains specific data\n    Mynode temp = this.h;\n    while(temp !=null){\n    //while the node contains a value\n        if(s.equals(temp.getData())){\n        //if the node contains the specified data, return true\n            return true;\n        }\n        temp = temp.getNext();\n        //set the node reference to the next value\n    }\n    return false;\n}\npublic void printdata(){\n    Mynode temp = this.h;\n    while(temp !=null){\n        System.out.println(temp.getData());\n        //print the current node, then increment the temp node one over\n        temp = temp.getNext();\n    }\n}\npublic void deletion (String s){\n//method for deletion\n    Mynode temp = this.h;\n    Mynode previous = null;\n    if (temp != null && temp.getData().equals(s)) {\n    //when node contains data and the specified data matched the node in the linked list \n        this.h = temp.getNext();\n        //node reference is set to the next value\n        return; \n    } \n    while (temp != null && !(temp.getData().equals(s))) { \n    //retrieve node reference for next value\n        previous = temp; \n        temp = temp.getNext(); \n        //set node to the next value\n    } \n    if(temp ==null) {\n        return;\n    }\n    previous.setNext((temp.getNext())); \n\n}\npublic Iterator iterator() {\n    return new Myiter(this.h);\n}\nprivate class Myiter implements Iterator {\n\n    private Mynode temp;\n\n    public Myiter(Mynode temp) {\n        this.temp = h;\n    }\n    public boolean hasNext() {\n    //checks if there is an element next in the list\n        return this.temp != null;\n    }\n    public Object next() {\n    //gets the next element in the list\n        Object returndata = this.temp.getData();\n        temp = temp.getNext();\n        return  returndata;\n    }\n    public void remove() {\n    //not implemented\n    }\n}\n}\n\npublic class Mynode {\nprivate String data;\nprivate Mynode next;\npublic Mynode (String d, Mynode n){\n    this.data = d;\n    this.next =n;\n}\npublic String getData(){\n    return this.data;\n}\npublic void setNext(Mynode n){\n    this.next = n;\n}\npublic Mynode getNext(){\n    return this.next;\n}\n```\n\n\n}\n    ", "Answer": "\r\nIt might be easier to debug if we are given the Mynode class as well.\n\nFrom the information that we are given right now, it seems like the split method will be an infinite look.\n\nThe getNext method in a LinkedList should not change anything in the current object, it should just be a getter for the next node in the list. Because you are calling getNext but not storing the Mynode that is returned in any way, the getNext method will return the same node because the \"tempFast\" and \"tempSlow\" are never referencing the next Mynode in the list.\n\nInstead of the code here:\n\n```\n    while(tempslow.getNext()!=null && tempslow.getNext()!=null){\n        tempFast.getNext();\n        tempFast.getNext();\n        tempslow.getNext();\n    }\n```\n\n\nI would recommend setting the tempFast and tempSlow variables to the next node in the list, like so:\n\n```\n    while(tempslow.getNext()!=null && tempslow.getNext()!=null){\n        tempFast = tempFast.getNext();\n        if(tempFast != null){\n            tempFast = tempFast.getNext();\n        }\n        tempSlow = tempslow.getNext();\n    }\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Bucket sort or merge sort?\r\n                \r\nI am doing an c++ assignment where I have to sort data (n=400) which is student scores from 0-100. I am confused on using bucket sort, which sorts algorithm into buckets or merge sort, which divides and conquers. Which one should I use and why?\n    ", "Answer": "\r\nThe answer depends on your data. However, merge sort will run in O(n log n) while bucket sort will run in O(n + b) where b is the number of buckets you have. If scores are from zero to (and including) 100, then b is 101. So the question is of O(n log n) runs faster than O(n + 101) which is an easy question to answer theoretically, since O(n + 101) = O(n) and clearly O(n) is faster than O(n log n). Even if we did the (admittedly silly) exercise of substituting n for 400 we would get 501 for bucket sort and with log2(400) = 9 (rounded up) 3600 for merge sort. But that is silly, because big-O notation doesn't work that way. Theoretically, we would just conclude that O(n) is better than O(n log n).\nBut that is the theoretical answer. In practise, the overhead hidden behind the big-O counts, and then it might not be as simple.\nThat being said, the overhead in bucket sort is usually smaller than for merge sort. You need to allocate an array for some counts and an array to put the output in, and after that you need to run through the input twice, first for counting and then for sorting. A simple bucket sort could look like this:\n```\n#include <iostream>\n#include <string>\n\n// Some fake data\nstruct student\n{\n    int score;\n    std::string name;\n};\nstruct student scores[] = {\n    {45, \"jack\"},\n    {12, \"jill\"},\n    {99, \"john\"},\n    {89, \"james\"}};\n\nvoid bucket_sort(int n, struct student in[n], struct student out[n])\n{\n    int buckets[101]; // range 0-100 with 100 included\n    for (int i = 0; i < 101; i++)\n    {\n        buckets[i] = 0;\n    }\n\n    // get offsets for each bucket\n    for (int i = 0; i < n; i++)\n    {\n        buckets[in[i].score]++;\n    }\n    int acc = 0;\n    for (int i = 0; i < 101; i++)\n    {\n        int b = buckets[i];\n        buckets[i] = acc;\n        acc += b;\n    }\n\n    // Bucket the scores\n    for (int i = 0; i < n; i++)\n    {\n        out[buckets[in[i].score]++] = in[i];\n    }\n}\n\nvoid print_students(int n, struct student students[n])\n{\n    for (int i = 0; i < n; i++)\n    {\n        std::cout << students[i].score << ' ' << students[i].name << std::endl;\n    }\n    std::cout << std::endl;\n}\n\nint main(void)\n{\n\n    int no_students = sizeof scores / sizeof scores[0];\n    print_students(no_students, scores);\n\n    struct student sorted[no_students];\n    bucket_sort(no_students, scores, sorted);\n    print_students(no_students, sorted);\n\n    return 0;\n}\n```\n\n(excuse my C++, it's been more than 10 years since I used the language, so the code might look a bit more C like than it should).\nThe best way to work out what is faster in practise is, of course, to measure it. Compare ```\nstd::sort```\n with something like the above, and you should get your answer.\nIf it wasn't for an assignment, though, I wouldn't recommend you to experiment. The built-in ```\nstd::sort```\n can easily handle 400 elements faster than you need, and there is no need to implement new sorting algorithms for something like that. For an exercise, though, it could be fun to do some measuring and experiments.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort with a pointer to an array\r\n                \r\nI am trying to make a merge sort algorithm with the stl library but am having some issues. Below is the code I am using\n\n```\ntemplate <typename Item, typename SizeType>\nvoid merge_sort(Item array[], SizeType size){\n    size_t n1; //Size of the first subarray\n    size_t n2; //Size of the second subarray\n\n    if(size > 1){\n        //Compute the size of the subarrays\n        n1 = size/2;\n        n2 = size - n1;\n\n        //create the temp array.\n        int* n1Temp = new int[n1];\n        int* n2Temp = new int[n2];\n        int i;\n        for(i = 0; i < n1; i++)\n            n1Temp[i] = array[i];\n        for(i = 0; i < n2; i++)\n            n2Temp[i] = array[i + n1];\n\n        //recursive calls\n        merge_sort(n1Temp, n1);//sort from array[0] through array[n1 - 1] \n        merge_sort(n2Temp, n2);//sort from array[n1] to the end\n\n        //Merge the two sorted halves.\n        vector<int> v(array, array + size);\n        merge(n1Temp, n1Temp + n1, n2Temp, n2Temp + n2, v.begin());     \n        copy(v.begin(), v.end(), array);//copy the vector back to the array\n\n        delete[] n1Temp;\n        delete[] n2Temp;\n    }\n}\n```\n\n\nThe code sorts fine but the problem is that it acts like a O(n^2) algorithm instead of O(n \\log n), which is due to the creation of the vector in each merge sort call (I think). I tried removing the vector and just using an array in the merge function which can be seen below \n\n```\n    //Merge the two sorted halves.\n    int* finalArray = new int[n1 + n2];\n    merge(n1Temp, n1Temp + n1, n2Temp, n2Temp + n2, begin(finalArray)); \n    array = finalArray;\n```\n\n\nBut this gets me nothing but errors. Is there any thing I can do to salvage my merge sort algorithm?\n    ", "Answer": "\r\nAs both Vaughn and user93353 pointed out, you should be able to merge directly into the target array at each merge-point. But you can still use std::vector<> to make this significantly easier on yourself.\n\nAlso, your temp arrays are of direct type 'int', and I'm fairly sure that was intended to be the type of the template parameter ```\nItem```\n. I'm not sure what the ```\nSizeType```\n parameter is for, but I left it in case you had special ideas for it. Whatever it is, it better be compatible with ```\nsize_t```\n :\n\n```\ntemplate <typename Item, typename SizeType>\nvoid merge_sort(Item array[], SizeType size)\n{\n    if(size > 1)\n    {\n        //Compute the size of the subarrays\n        size_t n1 = size/2;\n\n        //create the temp array\n        std::vector<Item> n1Temp(array, array+n1);\n        std::vector<Item> n2Temp(array+n1, array+size);\n\n        //recursive calls\n        merge_sort(&n1Temp[0], n1);       //sort array[0] through array[n1-1]\n        merge_sort(&n2Temp[0], size-n1);  //sort array[n1] through array[size-1]\n\n        // merge the sorted halves\n        std::merge(n1Temp.begin(), n1Temp.end(),\n                   n2Temp.begin(), n2Temp.end(), array);\n    }\n}\n```\n\n\nThe above technique splits the sub-sequences top-down via copy, then merges in-place the split-copies into the original array. You can reduce this algorithm by one sublist allocation time (but no less space) by doing the splits on the original array, then merging into temp-space and copying after, which i think you were trying to do in the first place:\n\n```\ntemplate <typename Item>\nvoid merge_sort(Item ar[], size_t n)\n{\n    if (n > 1)\n    {\n        // Compute the size of the subarrays\n        size_t n1 = n/2;\n\n        // invoke recursion on the submerges\n        merge_sort(ar, n1);      //sort array[0] through array[n1-1]\n        merge_sort(ar+n1, n-n1); //sort array[n1] through array[size-1]\n\n        // create merge-buffer\n        std::vector<Item> mrg;\n        std::merge(ar, ar+n1, ar+n1, ar+n, back_inserter(mrg));\n        std::copy(mrg.begin(), mrg.end(), ar);\n    }\n}\n```\n\n\n\n\nGeneral Iterator-Based Solution\n\nFor a general solution that allows even more flexibility you can define your merge-sort based on iterators rather than Item pointers. It gets a little more hairy, but the benefits are very std-lib-ish.\n\n```\ntemplate <typename Iterator>\nvoid merge_sort(Iterator first, Iterator last)\n{\n    typedef typename std::iterator_traits<Iterator>::value_type value_type;\n    typedef typename std::iterator_traits<Iterator>::difference_type difference_type;\n\n    difference_type n = std::distance(first, last)/2;\n    if (n == 0)\n        return;\n\n    // invoke recursion on the submerges\n    merge_sort(first, first + n);\n    merge_sort(first + n, last);\n\n    // create merge-buffer\n    std::vector<value_type> mrg(std::distance(first, last));\n    std::merge(first, first+n, first+n, last, mrg.begin());\n    std::copy(mrg.begin(), mrg.end(), first);\n}\n```\n\n\n\n\nFinally, if you find yourself sorting a ton of fixed-length C-arrays you may find the following helpful (it uses the general-iterator solution above):\n\n```\n// front-loader for C arrays\ntemplate<typename Item, size_t N>\nvoid merge_sort(Item (&ar)[N])\n{\n    merge_sort(std::begin(ar), std::end(ar));\n}\n```\n\n\nIt make the following code rather convenient:\n\n```\nint arr[1024];\n... fill arr ...\nmerge_sort(arr);\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Understanding merge sort code\r\n                \r\nI'm trying to implement a merge sort using the following websites as resources.\nhttp://interactivepython.org/courselib/static/pythonds/SortSearch/TheMergeSort.html\nhttps://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/p/challenge-implement-merge\nTo me, my code looks fine; however, given my incorrect output it is obviously wrong.  I'm not sure where or why it is wrong.  I think I understand merge sort when I look at the image explanations of it but trying to implement it has been very difficult.  I have tried to give all variables names some meaning to help reduce confusion (\"i\", \"j\", \"k\", \"m, and \"n\" are a little hard to keep track of what they represent).  I have also tried to use print statements to help debug my code but recursion has never been easy for me so I'm not sure exactly what my print statements are telling me other than the output is wrong.  I've also tried to use the debugger but for whatever reason the debugger doesn't list the values that are in any of my arrays so I can't really proceed via the debugger. Any help in clarifying the implementation of merge sort would be greatly appreciated.\n```\n#include <stdio.h>\n\nvoid merge_sort(int array[], int startIndex, int endIndex);\nvoid merge(int array[], int startIndex, int midIndex, int endIndex);\n\nint main(void)\n{\n    int size = 8;\n    int numbers[8] = {14, 7, 3, 12, 9, 11, 6, 2};\n    \n    printf(\"Unsorted Array!\\n\");\n    for(int i = 0; i < size; i++)\n    {\n        printf(\"%i \", numbers[i]);\n    }\n    printf(\"\\n\");\n    \n    merge_sort(numbers, 0, 7);\n    \n    printf(\"Sorted Array!\\n\");\n    for(int i = 0; i < size; i++)\n    {\n        printf(\"%i \", numbers[i]);\n    }\n    printf(\"\\n\");\n}\n\nvoid merge_sort(int array[], int startIndex, int endIndex)\n{\n    // determine size of the array\n    int size = (endIndex - startIndex) + 1; // updated\n    \n    // if the array has more than 1 element then it needs broken down into smaller arrays\n    if(size > 1)\n    {\n        int midIndex = (startIndex + endIndex) / 2;\n        \n        merge_sort(array, startIndex, midIndex); // Sort the LEFT side\n        merge_sort(array, midIndex + 1, endIndex); // Sort the RIGHT side\n        \n        merge(array, startIndex, midIndex, endIndex);\n    }\n}\n\nvoid merge(int array[], int startIndex, int midIndex, int endIndex)\n{\n   int leftSize = midIndex - startIndex + 1;\n   int rightSize = endIndex - midIndex;\n   int originalArrayIndex = 0;\n   int leftArray[leftSize];\n   int rightArray[rightSize];\n   int currentLeftIndex = 0;\n   int currentRightIndex = 0;\n   \n   // fill the leftArray\n   for(int i = 0; i < leftSize; i++)\n   {\n       leftArray[i] = array[i];\n       printf(\"%i \", leftArray[i]);\n   }\n   printf(\" === Left array\\n\");\n   \n   // fill the rightArray\n   for(int i = 0; i < rightSize; i++)\n   {\n       rightArray[i] = array[leftSize + i];\n       printf(\"%i \", rightArray[i]);\n   }\n   printf(\" === Right array\\n\");\n   \n   // do the actual merge\n   // leftStart < leftSize and rightStart < rightSize\n   while((currentLeftIndex < leftSize) && (currentRightIndex < rightSize))\n   {\n       // if the left array value is smaller than the right array value then that means the left array value goes into the original array[]\n       if(leftArray[currentLeftIndex] < rightArray[currentRightIndex])\n       {\n           array[originalArrayIndex] = leftArray[currentLeftIndex];\n           originalArrayIndex++;\n           currentLeftIndex++;\n       }\n       else\n       {\n           array[originalArrayIndex] = rightArray[currentRightIndex];\n           originalArrayIndex++;\n           currentRightIndex++;\n       }\n   }\n   \n   // no clue what this is\n   while(currentLeftIndex < leftSize)\n   {\n       array[originalArrayIndex] = leftArray[currentLeftIndex];\n       originalArrayIndex++;\n       currentLeftIndex++;\n   }\n   \n   // no clue what this is\n   while(currentRightIndex < rightSize)\n   {\n       array[originalArrayIndex] = rightArray[currentRightIndex];\n       originalArrayIndex++;\n       currentRightIndex++;\n   }\n   \n   for(int i = 0; i < leftSize; i++)\n   {\n       printf(\"%i \", leftArray[i]);\n   }\n   printf(\" ==== left array after sort\\n\");\n   \n   for(int i = 0; i < rightSize; i++)\n   {\n       printf(\"%i \", rightArray[i]);\n   }\n   printf(\" ==== right array after sort\\n\");\n   \n   for(int i = 0; i < endIndex + 1; i++)\n   {\n       printf(\"%i \", array[i]);\n   }\n   printf(\" ===== post merge =====\\n\");\n}\n```\n\nOutput is listed below:\n\nUnsorted Array!\n14 7 3 12 9 11 6 2\n14 7  === Left array\n3 12  === Right array\n14 7  ==== left array after sort\n3 12  ==== right array after sort\n3 12 14 7  ===== post merge =====\n3 12  === Left array\n14 7  === Right array\n3 12  ==== left array after sort\n14 7  ==== right array after sort\n3 12 14 7 9 11 6 2  ===== post merge =====\n3 12 14 7  === Left array\n9 11 6 2  === Right array\n3 12 14 7  ==== left array after sort\n9 11 6 2  ==== right array after sort\n3 9 11 6 2 12 14 7  ===== post merge =====\nSorted Array!\n3 9 11 6 2 12 14 7\n\nUpdated Output:\n\nUnsorted Array!\n14 7 3 12 9 11 6 2 \n14  === Left array\n7  === Right array\n7 14  ===== post merge =====\n7  === Left array\n14  === Right array\n7 14 3 12  ===== post merge =====\n7 14  === Left array\n3 12  === Right array\n3 7 12 14  ===== post merge =====\n3  === Left array\n7  === Right array\n3 7 12 14 9 11  ===== post merge =====\n3  === Left array\n7  === Right array\n3 7 12 14 9 11 6 2  ===== post merge =====\n3 7  === Left array\n12 14  === Right array\n3 7 12 14 9 11 6 2  ===== post merge =====\n3 7 12 14  === Left array\n9 11 6 2  === Right array\n3 7 9 11 6 2 12 14  ===== post merge =====\nSorted Array! \n3 7 9 11 6 2 12 14\n\n    ", "Answer": "\r\nYour error is here:\n\n```\n   // fill the rightArray\n   for(int i = 0; i < rightSize; i++)\n   {\n       rightArray[i] = array[rightSize + i];\n       printf(\"%i \", rightArray[i]);\n   }\n   printf(\" === Right array\\n\");\n```\n\n\nyou need to indent by left array size:\n\n```\n   rightArray[i] = array[leftSize + i];\n```\n\n\nBy the way, the parts you commented on with \n\n\n  // no clue what this is\n\n\nare there to keep inserting indices in the case where the program already finished inserting all of the indices of one of the two arrays.\n\nUpdate:\nThere is another (bigger) problem. You also need to keep track of your current position at the original array. If you look closely you'll see that you always copying values starting from ```\nnumbers[0]```\n even when working with its right half. \nBut keeping another counter is a messy approach so consider changing your function definitions to:\n\n```\nmerge_sort (int array[], int arraySize);\nmerge (int leftArray[], int leftSize, int rightArray[], int rightSize, int targetArray[]);\n```\n\n\nThis will help keep things clean and simple.\nThis is what it should look like:\n\n```\n#include <stdio.h>\n\nvoid merge_sort(int array[], int arraySize);\nvoid merge(int leftArray[], int leftSize, int rightArray[], int rightSize, int targetArray[]);\n\nint main(void)\n{\n    int numbers[8] = { 14, 7, 3, 12, 9, 11, 6, 2 };\n    int size = sizeof(numbers) / sizeof(int);\n\n    printf(\"Unsorted Array!\\n\");\n    for (int i = 0; i < size; i++)\n    {\n        printf(\"%i, \", numbers[i]);\n    }\n    printf(\"\\n\");\n\n    merge_sort(numbers, size);\n\n    printf(\"Sorted Array!\\n\");\n    for (int i = 0; i < size; i++)\n    {\n        printf(\"%i \", numbers[i]);\n    }\n    printf(\"\\n\");\n}\n\nvoid merge_sort(int array[], int arraySize)\n{\n    if (arraySize > 1)\n    {\n        int leftSize = arraySize / 2;\n        int rightSize = arraySize - leftSize;\n\n        merge_sort(array, leftSize); // Sort the LEFT side\n        merge_sort(array + leftSize, rightSize); // Sort the RIGHT side\n\n        int* targetArray = (int*)malloc(arraySize * sizeof(int));\n        merge(array, leftSize, array + leftSize, rightSize, targetArray);\n        memcpy(array, targetArray, arraySize * sizeof(int));\n\n        free(targetArray);\n    }\n}\n\nvoid merge(int leftArray[], int leftSize, int rightArray[], int rightSize, int targetArray[])\n{\n    int currentLeftIndex = 0;\n    int currentRightIndex = 0;\n    int targetIndex = 0;\n\n    while ((currentLeftIndex < leftSize) && (currentRightIndex < rightSize))\n    {\n        if (leftArray[currentLeftIndex] < rightArray[currentRightIndex])\n        {\n            targetArray[targetIndex] = leftArray[currentLeftIndex];\n            currentLeftIndex++;\n        }\n        else\n        {\n            targetArray[targetIndex] = rightArray[currentRightIndex];\n            currentRightIndex++;\n        }\n        targetIndex++;\n    }\n\n    while (currentLeftIndex < leftSize)\n    {\n        targetArray[targetIndex] = leftArray[currentLeftIndex];\n        targetIndex++;\n        currentLeftIndex++;\n    }\n\n    while (currentRightIndex < rightSize)\n    {\n        targetArray[targetIndex] = rightArray[currentRightIndex];\n        targetIndex++;\n        currentRightIndex++;\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Error with Merge Sort\r\n                \r\nI am trying to create a merge sort algorithm in C++ that takes a Vector of a generic type as its input and sorts the elements in the Vector.\nExcept i am getting a [run] Bus error (core dumped) error everytime i try to test the algorithm.\n\nMy Code for the Merge Sort is as Follows:\n\n```\ntemplate <typename T>\nvoid merge_sort(std::vector<T>& vector)\n{\ntypename std::vector<T>::iterator middle_value = vector.begin()+vector.size()/2;        std::vector<T> left_side(vector.begin(), middle_value);\n    std::vector<T> right_side(middle_value,vector.end());\n    merge_sort(left_side);\n    merge_sort(right_side);\n    std::vector<T> merged;\n    int i,j;\n    while(i<left_side.size() && j<right_side.size())\n    {\n    if(left_side.at(i)<right_side.at(j))\n    {\n        merged.push_back(left_side.at(i));\n        i++;\n    }\n    else\n    {\n        merged.push_back(right_side.at(j));\n        j++;\n    }\n    }\n    while(i<left_side.size())\n    {\n        merged.push_back(left_side.at(i));\n        i++;\n    }\n    while(j<right_side.size())\n    {\n        merged.push_back(right_side.at(j));\n        j++;\n    }\n    for(int x=0;x<merged.size();x++)\n    vector.at(x)=merged.at(x);\n\n\n}\n```\n\n\nAny Light on this issue would help very much.\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Efficiency of alternative merge sort?\r\n                \r\nI'm learning merge sort and many tutorials I've seen merge by replacing values of the original array, like the way here. I was wondering if my alternative implementation is correct. I have only seen 1 tutorial do the same. My implementation returns the sorted array which goes like this:\n\n```\ndef mergesort(arr):\n    if len(arr) == 1:\n        return arr\n    mid = len(arr) // 2\n    left_arr = arr[:mid]\n    right_arr = arr[mid:]\n\n    return merge(mergesort(left_arr), mergesort(right_arr))\n\ndef merge(left_arr, right_arr):\n    merged_arr = [] # put merge of left_arr & right_arr here\n    i,j = 0, 0 # indices for left_arr & right_arr\n\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] < right_arr[j]:\n            merged_arr.append(left_arr[i])\n            i += 1\n        else:\n            merged_arr.append(right_arr[j])\n            j += 1\n\n    # add remaining elements to resulting arrray\n    merged_arr.extend(left_arr[i:]) \n    merged_arr.extend(right_arr[j:])\n    return merged_arr\n\n\narr = [12, 11, 13, 5, 6, 7]\nsorted_arr = mergesort(arr)\nprint(sorted_arr)\n# Output: [5, 6, 7, 11, 12, 13]\n```\n\n\nTo me, this is a more intuitive way of doing merge sort. Did this implementation break what merge sort should be? Is it less efficient speed-wise or space-wise (Aside from creating the results array)?\n    ", "Answer": "\r\nIf we are considering a merge sort with ```\nO(n)```\n extra memory, then your implementation seems to be correct but inefficient. Let's take a look at these lines:\n\n```\ndef mergesort(arr):\n    ...\n    mid = len(arr) // 2\n    left_arr = arr[:mid]\n    right_arr = arr[mid:]\n```\n\n\nYou are actually creating two new arrays on each call to ```\nmergesort()```\n and then copy elements from the original ```\narr```\n. It's two extra memory allocations on the heap and ```\nO(n)```\n copies. Usually, heap memory allocations are quite slow due to complicated allocators algorithms.\n\nGoing father, let's consider this line:\n\n```\nmerged_arr.append(left_arr[i])  # or similar merged_arr.append(left_arr[j])\n```\n\n\nHere again a bunch of memory allocations happens because you use a dynamically allocated array (aka list).\n\nSo, the most efficient way to mergesort would be to allocate one extra array of size of the original array once at the very beginning and then use its parts for temporary results.\n\n```\ndef mergesort(arr):\n    mergesort_helper(arr[:], arr, 0, len(arr))\n\ndef mergesort_helper(arr, aux, l, r):\n    \"\"\" sorts from arr to aux \"\"\"\n    if l >= r - 1:\n        return\n\n    m = l + (r - l) // 2\n    mergesort_helper(aux, arr, l, m)\n    mergesort_helper(aux, arr, m, r)\n    merge(arr, aux, l, m, r)\n\ndef merge(arr, aux, l, m, r):\n    i = l\n    j = m\n    k = l\n    while i < m and j < r:\n        if arr[i] < arr[j]:\n            aux[k] = arr[i]\n            i += 1\n        else:\n            aux[k] = arr[j]\n            j += 1\n        k += 1\n\n    while i < m:\n        aux[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j < r:\n        aux[k] = arr[j]\n        j += 1\n        k += 1\n\nimport random\n\ndef testit():\n    for _ in range(1000):\n        n = random.randint(1, 1000)\n        arr = [0]*n\n        for i in range(n):\n            arr[i] = random.randint(0, 100)\n\n        sarr = sorted(arr)\n        mergesort(arr)\n        assert sarr == arr\n\ntestit()\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Error in Merge Sort\r\n                \r\nI made my own merge sort which has a method that allows only an ArrayList and a Comparator. My colleague requested that the tmp Array that I normally declared into the \"merge\" method must be declared into the first wrapper method (mergeSort). Now if I execute a test with 3 elements it doesn't work. Why?\n\n```\npublic static < T > void mergeSort(ArrayList < T > array, Comparator < T > c) {\n    int high = array.size()-1;\n    sort(array, c, 0, high, new ArrayList < T > (high + 1));\n  }  \n\n  protected static < T > void sort(ArrayList < T > array, Comparator < T > c, int low, int high, ArrayList < T > tmp) {\n    if (low < high) {\n      int mid = low + (high - low) / 2;\n      sort(array, c, low, mid, tmp);\n      sort(array, c, mid + 1, high, tmp);\n      merge(array, c, low, mid, high, tmp);\n    }\n  }\n\n  protected static < T > void merge(ArrayList < T > array, Comparator < T > c, int p, int mid, int q, ArrayList < T > tmp) {\n    int i = p;\n    int j = mid + 1;\n    int k = 0;\n    for (; i <= mid && j <= q; k++) {\n      if (c.compare(array.get(i), array.get(j)) < 0)\n        tmp.add(k, array.get(i++));\n      else\n        tmp.add(k, array.get(j++));\n    }\n    if (i <= mid && j > q) {\n      while (i <= mid)\n        tmp.add(k++, array.get(i++));\n    } else {\n      while (j <= q)\n        tmp.add(k++, array.get(j++));\n    }\n    for (k = 0; k < tmp.size(); k++)\n      array.set(k + p, tmp.get(k));\n  }\n```\n\n    ", "Answer": "\r\nSince your ```\ntmp```\n ```\nArrayList```\n was previously local to the ```\nmerge```\n method, this implies that after moving it to the ```\nmergeSort```\n call, it should be cleared before being used in each call to ```\nmerge```\n:\n\n```\nprotected static < T > void merge(ArrayList < T > array, Comparator < T > c, int p, int mid, int q, ArrayList < T > tmp) {\n    tmp.clear();\n    ...\n}\n```\n\n\nWithout clearing it, you'll keep adding elements to it in each call to ```\nmerge```\n. It will just keep growing, and you might re-use obsolete elements of it.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort algorithm\r\n                \r\nWhat could be the best algorithm for \"Merge Sort\" in C++ where the memory must be used \"most effectively\"? I just know the standard way to do this, but that's not the most effective way how to use the memory.\nThis is the only variant which I know:\n\n```\n#include <iostream>\nusing namespace std;\nint main() {\nint arr1[20]= {0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};\nint arr2[14]= {0,23,25,27,29,31,33,35,37,39,40,41,42,43};\nint arr3[34];\nint indexA=0, indexB=0, indexC=0;\n\nwhile((indexA<20) && (indexB<14)) {\n    if(arr1[indexA] < arr2[indexB]) {\n        arr3[indexC] = arr1[indexA];\n        indexA++;\n    }\n    else {\n        arr3[indexC] = arr2[indexB];\n        indexB++;\n    }\n    indexC++;\n}\n\nwhile(indexA<20) {\n    arr3[indexC] = arr1[indexA];\n    indexA++;\n    indexC++;\n}\n\nwhile(indexB<14) {\n    arr3[indexC] = arr2[indexB];\n    indexB++;\n    indexC++;\n}\n\nfor (int i=0; i<34; i++)\n    cout << arr3[i] << \" \";\nreturn 0;\n}\n```\n\n\nCan anyone please advise me a better algorithm for \"Merge Sort\" which uses the memory in \"more effective\" way? It can also not be with arrays.\n\nThank You very much!\n    ", "Answer": "\r\nThe usual problem with merge sort is that for every recursion, you end up using a whole new piece of memory.  This turns out to need O(N*log(n)) memory.  It turns out that if you're a bit more clever, you can do this with linear O(N) memory.  Just don't make new arrays, and swap the elements as needed around within the original one.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Second Part of Merge Sort\r\n                \r\nHi i´ve got a little problem, i wonder how would be implemented just second part of merge sort, i mean by it like input would be  array like this [[1,2],[4,5],[2,3],[5,8]] and it merge together arrays and sort them using base principe of merge sort.\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort - stack corruption error\r\n                \r\nI'm writing a basic merge sort code in C++.  I'm getting stack corruption exception for variable b, when I run the below code in function merge().  I just can't figure out what am I doing wrong.  Any help is highly appreciated !!\n\nHere's my code:\n\n```\ntemplate <class T>\nclass mSort \n{\n    void mergeSort(T *a, int low, int high);\n    void merge(T *a, int low, int mid, int high);\npublic:\n    mSort(T* a, int size);\n};\n\ntemplate<class T>\nmSort<T>::mSort(T *a, int size)\n{\n    mergeSort(a, 0, size);\n}\ntemplate<class T>\nvoid mSort<T>::mergeSort(T *a, int low, int high)\n{\n    int m;\n    if (low < high)\n    {\n        m = (low + high) / 2;\n        //printf(\"mergeSort:low[%d], mid [%d], high [%d]\\n\", low, m, high);\n        mergeSort(a, low, m);\n        mergeSort(a, m+1, high);\n        merge(a, low, m, high);\n    }\n}\n\ntemplate<class T>\nvoid mSort<T>::merge(T *a, int low, int mid, int high)\n{\n    int b[20];\n    int i = low, j = mid + 1, k = 0;\n\n    while (i <= mid && j <= high) {\n        if (a[i] <= a[j])\n            b[k++] = a[i++];\n        else\n            b[k++] = a[j++];\n    }\n    while (i <= mid)\n        b[k++] = a[i++];\n\n    while (j <= high)\n        b[k++] = a[j++];\n\n    k--;\n    while (k >= 0) {\n        a[low + k] = b[k];\n        k--;\n    }\n}\n```\n\n\nInput array :\nint a[20];\n\n```\n#define prep_intput_array(a,n)\\\nfor (int i = 0; i < n; i++)\\\n{\\\n    a[i] = rand() % 65535;\\\n}\\\n```\n\n\ncalling the merge sort routine like this : \n\n```\nmSort<int> m1(a, 20);\n```\n\n\nCode is based on the merge sort in this link\n    ", "Answer": "\r\nhigh is passed with highest index in the array which is size-1 but you have passed size which is more than highest index in the array hence you might be getting an error.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Base condition in merge sort\r\n                \r\nI am trying to implement merge sort and I'm having trouble implementing the base condition.\n\nI have a function ```\nmerge```\n which takes in two sorted arrays and returns a merged array.\n\n```\nint[] merge(int[] a , int[] b)\n```\n\n\nNow my merge sort routine is as below\n\n```\nprivate static int[] mergeSort(int[] a, int low , int high)\n{\n    int mid = (low + high)  /2;\n    if (low  < high)\n    {\n        return  merge( mergeSort(a,low, mid-1), mergeSort(a, mid , high));\n    }\n    return //return what ?\n}\n```\n\n\nWhat is the base condition here? What is the mistake I am making?     \n    ", "Answer": "\r\nBase condition is when you have single element list ```\na```\n, which by definition is already sorted. Just return it.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Multithreaded Merge Sort [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Multithreaded quicksort or mergesort\r\n                            \r\n                                (9 answers)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nCan someone please give me a link or provide me with java code of a multithreaded merge sort?\n\nPreferable one that uses an executor!\n\nThank you very much!\n    ", "Answer": "\r\nHere is my version of MergeSort using 2 threads, it can be extended to n threads easily (just split the original array into n sub-arrays). For 10 million numbers, it is faster than its single-thread counterpart by about 25%.\n\n```\nimport java.util.Random;\n\npublic class MergeSortThreaded {\n\n    public static void finalMerge(int[] a, int[] b) {\n        int[] result = new int[a.length + b.length];\n        int i=0; \n        int j=0; \n        int r=0;\n        while (i < a.length && j < b.length) {\n            if (a[i] <= b[j]) {\n                result[r]=a[i];\n                i++;\n                r++;\n            } else {\n                result[r]=b[j];\n                j++;\n                r++;\n            }\n            if (i==a.length) {\n                while (j<b.length) {\n                    result[r]=b[j];\n                    r++;\n                    j++;\n                }\n            }\n            if (j==b.length) {\n                while (i<a.length) {\n                    result[r]=a[i];\n                    r++;\n                    i++;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Random rand = new Random();\n        int[] original = new int[10000000];\n        for (int i=0; i<original.length; i++) {\n            original[i] = rand.nextInt(1000);\n        }\n\n        long startTime = System.currentTimeMillis();\n        int[] subArr1 = new int[original.length/2];\n        int[] subArr2 = new int[original.length - original.length/2];\n        System.arraycopy(original, 0, subArr1, 0, original.length/2);\n        System.arraycopy(original, original.length/2, subArr2, 0, original.length - original.length/2);\n\n        Worker runner1 = new Worker(subArr1);\n        Worker runner2 = new Worker(subArr2);\n        runner1.start();\n        runner2.start();\n        runner1.join();\n        runner2.join();\n        finalMerge (runner1.getInternal(), runner2.getInternal());\n        long stopTime = System.currentTimeMillis();\n        long elapsedTime = stopTime - startTime;\n        System.out.println(\"2-thread MergeSort takes: \" + (float)elapsedTime/1000 + \" seconds\");\n    }\n\n}\n\nclass Worker extends Thread {\n    private int[] internal;\n\n    public int[] getInternal() {\n        return internal;\n    }\n\n    public void mergeSort(int[] array) {\n        if (array.length > 1) {\n            int[] left = leftHalf(array);\n            int[] right = rightHalf(array);\n\n            mergeSort(left);\n            mergeSort(right);\n\n            merge(array, left, right);\n        }\n    }\n\n    public int[] leftHalf(int[] array) {\n        int size1 = array.length / 2;\n        int[] left = new int[size1];\n        for (int i = 0; i < size1; i++) {\n            left[i] = array[i];\n        }\n        return left;\n    }\n\n    public int[] rightHalf(int[] array) {\n        int size1 = array.length / 2;\n        int size2 = array.length - size1;\n        int[] right = new int[size2];\n        for (int i = 0; i < size2; i++) {\n            right[i] = array[i + size1];\n        }\n        return right;\n    }\n\n    public void merge(int[] result, int[] left, int[] right) {\n        int i1 = 0;   \n        int i2 = 0;   \n\n        for (int i = 0; i < result.length; i++) {\n            if (i2 >= right.length || (i1 < left.length && left[i1] <= right[i2])) {\n                result[i] = left[i1];   \n                i1++;\n            } else {\n                result[i] = right[i2];   \n                i2++;\n            }\n        }\n    }\n\n    Worker(int[] arr) {\n        internal = arr;\n    }\n\n    public void run() {\n        mergeSort(internal);\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge Sort\r\n                \r\nI'm attempting to write a recursive merge sort method for class. I keep getting stackoverflows when I attempt to ```\nmergeSort(leftArr)```\n and ```\nmergeSort(rightArr)```\n. Why doesn't the base case I have work?\n\n```\nimport java.util.Arrays;\n\npublic class SortingAlgorithms {\n    public static void mergeSort(int[] list){\n\n        int mid = list.length / 2;\n        int [] leftArr = new int [mid];\n        int [] rightArr;\n\n\n        if (mid % 2 == 0) {\n            rightArr = new int [mid];\n        }\n        else{\n            rightArr = new int [mid + 1];\n        }\n\n        if (leftArr.length < 2 && rightArr.length < 2){\n            list = mergeHelper(leftArr, rightArr);\n        }\n\n        // copying first half of array\n        for (int i = 0; i < mid; i++){\n            leftArr[i] = list[i];\n        }\n\n        // copying second half of array\n        int placeHolder = 0;\n        for (int i = mid; i < list.length; i++){\n            if (placeHolder < rightArr.length) {\n                rightArr[placeHolder] = list[i];\n                placeHolder++;\n            }\n        }\n\n        mergeSort(leftArr);\n        mergeSort(rightArr);\n    }\n\n    public static int[] mergeHelper(int[] leftArr, int[] rightArr){\n\n        int leftIndex = 0;\n        int rightIndex = 0;\n        int sortedArrayIndex = 0;\n        int[] newList = new int[leftArr.length + rightArr.length];\n\n        while (leftIndex < leftArr.length || rightIndex < rightArr.length){\n            if (leftIndex < leftArr.length && rightIndex < rightArr.length){\n                if(leftArr[leftIndex] > rightArr[rightIndex]){\n                    newList[sortedArrayIndex] = rightArr[rightIndex];\n                    rightIndex++;\n                    sortedArrayIndex++;\n                }\n                else {\n                    newList[sortedArrayIndex] = leftArr[leftIndex];\n                    leftIndex++;\n                    sortedArrayIndex++;\n                }\n            }\n\n            else if (leftIndex < leftArr.length && rightIndex == rightArr.length){\n                newList[sortedArrayIndex] = leftArr[leftIndex];\n                leftIndex++;\n                sortedArrayIndex++;\n            }\n\n            else if (rightIndex < rightArr.length && leftIndex == leftArr.length){\n                newList[sortedArrayIndex] = rightArr[rightIndex];\n                rightIndex++;\n                sortedArrayIndex++;\n            }\n        }\n        return newList;\n    }\n\n    public static void populateArray(int[] list){\n        for (int i = 0; i < list.length; i++){\n            list[i] = (int) ((Math.random() * 100));\n        }\n    }\n\n    public static void main(String[] args){\n\n        int [] list = new int [10];\n        populateArray(list);\n        System.out.println(Arrays.toString(list));\n        mergeSort(list);\n        System.out.println(Arrays.toString(list));\n\n\n        //proof that mergeHelper() works\n        //      int[] left =  {1,3,5,7,9};\n        //      System.out.println(Arrays.toString(left));\n        //      int[] right = {0,2,4,6,8};\n        //      System.out.println(Arrays.toString(right));\n        //      System.out.println(Arrays.toString(mergeHelper(left,right)));\n\n}\n}\n```\n\n    ", "Answer": "\r\nYour rightArr length determination is not good. Correction:\n\n```\nrightArr = new int [list.length - mid];```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort in k parts\r\n                \r\nI'd really appreciate some help on this assignment.\nThe task is develop a merge sort algorithm that \"splits\" the input array recursively into k arrays. I initially coded two methods to merge sort with two parts, namely merge sort and merge. I tried to generalize this algorithm\n\n```\npublic class MergeSort {\n\n    public static int[] mergeSort(int[] a, int p, int r) {\n        // p is left bound\n        // r is right bound\n        if (p < r) {\n            int q = (int)Math.floor((p + r) / 2);\n            mergeSort(a, p, q);\n            mergeSort(a, q + 1, r);\n            return merge(a, p, q, r);\n        } else\n            return a;\n    }\n\n    // p ist linke grenze\n    // r ist rechte grenze\n    public static int[] merge(int[] a, int p, int q, int r) {\n        int n1 = q - p + 1; //length of first array\n        int n2 = r - q;     //length of second array\n        int[] lt = new int[n1 + 1];\n        int[] rt = new int[n2 + 1];\n        for (int i = 0; i < n1; i++) {\n            lt[i] = a[p + i];\n        }\n        for (int j = 0; j < n2; j++) {\n            rt[j] = a[q + j + 1];\n        }\n        lt[n1] = 1000000000; //sentinels\n        rt[n2] = 1000000000;\n        int i = 0;\n        int j = 0;\n\n        for (int k = p; k <= r; k++) { //comparing the values of the arrays and merging\n            if (lt[i] <= rt[j]) {\n                a[k] = lt[i];\n                i++;\n            } else {\n                a[k] = rt[j];\n                j++;\n            }\n        }\n        return a;\n    }\n\n    public static int[] mergeSortK(int[] a, int k, int p, int r) {\n        // k number of steps; p is first index of array; r is last index of array;\n        if (p < r) {\n            int[] pos = new int[k + 1]; //array for saving the indices of the \"splits\"\n            for (int i = 0; i <= k; i++) {\n                pos[i] = (int) Math.floor(p + (r - p) / k * i); //saving the array indices\n            }\n            for (int i = 0; i < k; i++) {\n                mergeSortK(a, k, pos[i], pos[i + 1]); //sorting the arrays\n            }\n            for (int i = 0; i < k - 1; i++) {\n                merge(a, pos[i], pos[i + 1], pos[i + 2]); //merging the arrays pairwise\n            }\n        }\n        return a;\n    }\n\n\n    public static void main(String[] args) {\n        // task 2.1.a)\n        // Example Values:\n        int[] list = { 2, 1, 5, 6, 2, 12 };\n        int k = 4;\n\n        // use MergeSort\n        int[] newlist = mergeSortK(list, k, 0, list.length);\n        printList(newlist);\n    }\n\n    // Helper function to print the elements of a list\n    private static void printList(int[] list) {\n        for(int i = 0; i < list.length; i++) {\n            System.out.println(list[i]);\n        }\n    }\n}\n```\n\n\nThe input given in the main method results in ```\n{2, 1, 2, 5, 6, 12}```\n\n\nAny help is immensely appreciated! Sorry if I'm doing some mistakes, I'm here to learn and I really hope you guys can help me out!\n    ", "Answer": "\r\nThere are a few problems in your code:\n\n\nthere is no need for ```\nMath.floor()```\n to truncate the results of integer division, unlike Javascript, Java uses different semantics for ```\n/```\n for ```\nint```\n arguments and floating point arguments. ```\n(p + r) / 2```\n is the integral quotient, But you might want to write ```\np + (r - p) / 2```\n to avoid potential overflow on ```\np + r```\n.\nthe upper index is excluded as you pass ```\nlist.length```\n from ```\nmain()```\n. This is actually a very convenient convention to avoid the need for ```\n+1```\n adjustments when computing slice sizes. Remove those erroneous adjustments and rely on the included/excluded convention.\ndon't use sentinels: using sentinels prevents you from correctly sorting arrays containing values greater or equal to the sentinel value ```\n1000000000```\n. This approach is not necessary and should be banned. Just compare the index variables to the slice lengths and copy the remaining elements when one of the slices is exhausted.\nyour computation for the slice boundaries in ```\nmergeSortK```\n is incorrect: ```\np + (r - p) / k * i```\n is computed with integer arithmetics so ```\n(r - p) / k```\n is rounded before the multiplication. The last slice ending index will not equal ```\nr```\n if ```\nr - p```\n is not a multiple of ```\nk```\n. Multiplying before the division would solve this issue but might overflow the range of type ```\nint```\n.\n```\nmergeSortK```\n does not perform k-way merging, but a series of partial merges that are insufficient for ```\nk > 2```\n.\nyour test set is a bit small.\n\n\nHere is a corrected version:\n\n```\npublic class MergeSort {\n\n    public static int[] mergeSort(int[] a, int p, int r) {\n        // p is left bound (included)\n        // r is right bound (excluded)\n        if (r - p >= 2) {\n            int q = p - (r - p) / 2;\n            mergeSort(a, p, q);\n            mergeSort(a, q, r);\n            return merge(a, p, q, r);\n        } else {\n            return a;\n        }\n    }\n\n    // p is left bound (included)\n    // q is start of right slice\n    // r is end of right slice (excluded)\n    public static int[] merge(int[] a, int p, int q, int r) {\n        int n1 = q - p;  // length of first array\n        int n2 = r - q;  // length of second array\n        int[] lt = new int[n1];\n        for (int i = 0; i < n1; i++) {\n            lt[i] = a[p + i];\n        }\n        int i = 0;  // index into lt\n        int j = q;  // index into a for right slice\n        int k = p;  // index into a for merged list\n\n        while (i < n1 && j < r) { //comparing the values of the arrays and merging\n            if (lt[i] <= a[j]) {\n                a[k] = lt[i];\n                i++;\n                k++;\n            } else {\n                a[k] = a[j];\n                j++;\n                k++;\n            }\n        }\n        while (i < n1) { // copy remaining elements from right slice\n            a[k] = lt[i];\n            i++;\n            k++;\n        }\n        // remaining elements from right slice are already in place\n        return a;\n    }\n\n    public static int[] mergeSortK(int[] a, int k, int p, int r) {\n        // k amount of steps; p is first index of slice; r is last index of slice (excluded);\n        if (r - p >= 2) {\n            if (k > r - p)\n                k = r - p;\n            int[] pos = new int[k + 1]; //array for saving the indices of the \"splits\"\n            for (int i = 0; i <= k; i++) {\n                pos[i] = p + (r - p) * i / k; //saving the array indices\n            }\n            for (int i = 0; i < k; i++) {\n                mergeSortK(a, k, pos[i], pos[i + 1]); //sorting the arrays\n            }\n            while (k > 1) {\n                int i, n = 1;\n                for (i = 0; i < k - 1; i += 2) {\n                    // merge slices 2 at a time: this will produce the expected output\n                    //  but is not a direct k-way merge.\n                    merge(a, pos[i], pos[i + 1], pos[i + 2]);\n                    pos[n++] = pos[i + 2];\n                }\n                if (i < k)\n                    pos[n++] = pos[i + 1];\n                k = n - 1;\n            }\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        // task 2.1.a)\n        // Example Values:\n        int[] list = {\n            64, 36, 46, 31, 45, 52,  4, 48, 74, 59,\n            12, 16, 70, 67, 71, 26, 73, 34, 46, 84,\n            60, 16, 26, 68, 56, 57, 97,  6, 39, 74,\n            25, 69, 29, 69, 77, 26, 44, 53, 20,  6,\n            77, 31, 71, 91, 28,  6, 24, 75, 26, 33,\n             3, 20, 55, 94, 17, 81, 88, 32, 94, 32,\n             3, 90, 76, 69,  9, 96, 76, 53, 78, 14,\n            97, 32, 17, 15, 61, 63, 21,  0, 16, 14,\n            61,  4, 81, 86, 29, 29, 27, 57, 85,  5,\n            91, 54,  6, 68, 40, 88, 41,  9, 90, 51 };\n        int k = 4;  // must be at least 2\n\n        // use MergeSort\n        int[] newlist = mergeSortK(list, k, 0, list.length);\n        printList(newlist);\n    }\n\n    // Helper function to print the elements of a list\n    private static void printList(int[] list) {\n        for (int i = 0; i < list.length; i++) {\n            System.out.println(list[i]);\n        }\n    }\n}\n```\n\n\nI did not write a correct k-way merging phase at the end of ```\nmergeSortK```\n, the code above should work but will merge the k slices in ceil(log2(k)) passes. Direct one pass k-way merging is tricky and usually not worth it.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort code debugging\r\n                \r\nI am trying to write a code for merge sort. I am not getting the correct output. I am following this pseudocode link Following is my code. I pass my unsorted array into merge_sort function and call merge function recursively to sort and combine the sub arrays.I know there are more simpler and efficient ways to write code for merge sort but I want to try on my own otherwise I won't learn. Thanks in advance. \n\n```\nint* merge_sort(int* a,int size)\n{\n    //cout<<size;\n    //cout<<\"hi\";\n    if(size == 1)\n    {\n        //cout<<\"less\";\n        //cout<<a[0];\n\n        return a;\n\n    }\n    int* left;\n    int* right;\n\n        int middle = ceil(size/2);\n        left = new int(middle);\n        right = new int(middle);\n        for(int i=0;i<middle;i++)\n        {\n            left[i]=a[i];\n            //cout<<left[i];\n        }\n        cout<<\"\\t\";\n\n        for(int j=middle;j<size;j++)\n        {\n            right[j]=a[j];\n            //cout<<right[j];\n        }\n        cout<<\"\\t\";\n        left = merge_sort(left,middle);\n        //if(size==2)\n            //cout<<left[0];\n\n        right = merge_sort(right,middle);\n        //if(size==2)\n            //cout<<right[0];\n\n        return merge(left,right,middle);\n\n\n}\n\n\n\n\nint* merge(int* l,int* r,int m)\n    {\n        int* result;\n        result = new int(2*m); //to store the output\n        int lsize=m;  // to keep track of left sub list\n        int rsize=m;  // to keep track of right sub list\n        int counter = 0;  // will use to index result\n        //cout<<m;\n\n\n        while(lsize>0 || rsize>0)\n        {\n            if(lsize>0 && rsize>0)\n            {\n                if(l[0]<=r[0])\n                {\n                    result[counter]=l[0];\n                    counter++; //to store next value in result\n                    lsize--;  \n                    l=&l[1]; //decrementing the size of left array\n                }\n                else\n                {\n                    result[counter]=r[0];\n                    counter++;\n                    rsize--; \n                    r=&r[1]; //dec. size of right array\n                }\n\n            }\n            else if(lsize>0)\n            {\n                result[counter]=l[0];\n                counter++;\n                lsize--;\n                l=&l[1];\n            }\n            else if(rsize>0)\n            {\n                result[counter]=l[0];\n                counter++;\n                lsize--;\n                l=&l[1];\n            }\n\n        }\n            return result;\n    }\n```\n\n    ", "Answer": "\r\nYour code:\n\n```\nint *left = new int(middle);\n```\n\n\nallocates a single integer initialized to ```\nmiddle```\n.  You need:\n\n```\nint *left = new int [middle];\n```\n\n\nwhich allocates an array of ```\nmiddle```\n integers.  Rinse and repeat for ```\nint *right```\n.  Actually, you need to use:\n\n```\nint *right = new int [size - middle];\n```\n\n\nThis gets the correct size for the ```\nright```\n array.  You then have to modify the recursive call to ```\nmerge_sort()```\n for the ```\nright```\n sub-array:\n\n```\nmerge_sort(right, size - middle);\n```\n\n\nFinally, you have to rewrite ```\nmerge()```\n to take the size of the left array and the size of the right array independently, because they may be of different sizes.  For example, if you sort 10 elements,\nyou then end up with a call to merge two arrays of 5 (which is fine), but at the next level you need to merge an array of 2 and an array of 3 elements (and you're hosed).\n\nThe allocation of ```\nresult```\n also has the ```\n()```\n vs ```\n[]```\n allocation problem.  And there are some other as yet unresolved problems.  But these are important steps in the right direction.\n\nAs mentioned in a comment to the question, you have a monumental memory leakage problem, too.  What's more, it is not trivial to fix because ```\nmerge_sort()```\n does an early exit without allocating new memory, so it isn't as simple as 'delete the memory returned by ```\nmerge_sort()```\n'.\n\nCopy and paste is wonderful until you forget to edit the pasted copy correctly:\n\n```\n    else if (lsize > 0)\n    {   \n        result[counter] = l[0];\n        counter++;\n        lsize--;\n        l = &l[1];\n    }   \n    else if (rsize > 0)\n    {   \n        result[counter] = l[0];\n        counter++;\n        lsize--;\n        l = &l[1];\n    } \n```\n\n\nMethinks you should be using ```\nr```\n and ```\nrsize```\n in the second of these blocks.\n\nThis still isn't the whole story...\n\nAnd the residual problem (apart from memory management, which is still 100% leaky and problematic) is:\n\n```\n    for(int j=middle;j<size;j++)\n    {\n        right[j]=a[j];\n        //cout<<right[j];\n    }\n```\n\n\nYou're copying into parts of ```\nright```\n that you've not allocated.  You need something more like:\n\n```\n    for(int j = 0; j < size - middle; j++)\n    {\n        right[j] = a[j + middle];\n        //cout<<right[j];\n    }\n```\n\n\nThis code works as long as you always sort at least two items at the top level (you crash freeing unallocated space if you sort 1 item — that's part of the memory management problem).\n\n```\n#include <iostream>\nusing namespace std;\n\nnamespace {\n\nint *merge(int *l, int m, int *r, int n);\n\nvoid dump_array(int *a, int size)\n{\n    int i;\n    cout << size << \": \";\n    for (i = 0; i < size; i++)\n    {\n        cout << ' ' << a[i];\n        if (i % 10 == 9)\n            cout << '\\n';\n    }\n    if (i % 10 != 0)\n        cout << '\\n';\n}\n\n};\n\nint *merge_sort(int *a, int size)\n{\n    cout << \"-->> merge_sort:\\n\";\n    dump_array(a, size);\n    if (size <= 1)\n    {\n        cout << \"<<-- merge_sort: early return\\n\";\n        return a;\n    }\n\n    int middle = size/2;\n    int *left = new int[middle];\n    int *right = new int[size - middle];\n    cout << middle << \": \";\n    for (int i = 0; i < middle; i++)\n    {\n        left[i] = a[i];\n        cout << ' ' << left[i];\n    }\n    cout << \"\\n\";\n\n    cout << (size - middle) << \": \";\n    for (int j = 0; j < size - middle; j++)\n    {\n        right[j] = a[j + middle];\n        cout << ' ' << right[j];\n    }\n    cout << \"\\n\";\n    cout << \"MSL:\\n\";\n    int *nleft = merge_sort(left, middle);\n    cout << \"NL: \";\n    dump_array(nleft, middle);\n    cout << \"OL: \";\n    dump_array(left, middle);\n    cout << \"OR: \";\n    dump_array(right, size - middle);\n    cout << \"MSR:\\n\";\n    int *nright = merge_sort(right, size - middle);\n    cout << \"NR: \";\n    dump_array(nright, size - middle);\n    cout << \"NL: \";\n    dump_array(nleft, middle);\n    cout << \"OL: \";\n    dump_array(left, middle);\n    cout << \"OR: \";\n    dump_array(right, size - middle);\n    int *result =  merge(nleft, middle, nright, size - middle);\n    cout << \"<<-- merge_sort:\\n\";\n    dump_array(result, size);\n    return result;\n}\n\nnamespace {\n\nint *merge(int *l, int m, int *r, int n)\n{\n    int *result = new int[m + n];\n    int lsize = m;\n    int rsize = n;\n    int counter = 0;\n    cout << \"-->> merge: (\" << m << \",\" << n << \")\\n\";\n    dump_array(l, m);\n    dump_array(r, n);\n\n    while (lsize > 0 || rsize > 0)\n    {\n        if (lsize > 0 && rsize > 0)\n        {\n            if (l[0] <= r[0])\n            {\n                result[counter] = l[0];\n                cout << \"C: \" << counter << \"; L = \" << l[0] << \"; LS = \" << lsize << '\\n';\n                counter++;\n                lsize--;\n                l++;\n            }\n            else\n            {\n                result[counter] = r[0];\n                cout << \"C: \" << counter << \"; R = \" << r[0] << \"; RS = \" << rsize << '\\n';\n                counter++;\n                rsize--;\n                r++;\n            }\n        }\n        else if (lsize > 0)\n        {\n            result[counter] = l[0];\n            cout << \"C: \" << counter << \"; L = \" << l[0] << \"; LS = \" << lsize << '\\n';\n            counter++;\n            lsize--;\n            l++;\n        }\n        else if (rsize > 0)\n        {\n            result[counter] = r[0];\n            cout << \"C: \" << counter << \"; R = \" << r[0] << \"; RS = \" << rsize << '\\n';\n            counter++;\n            rsize--;\n            r++;\n        }\n    }\n    cout << \"<<-- merge:\\n\";\n    dump_array(result, m+n);\n    return result;\n}\n\n};\n\nint main()\n{\n    for (int i = 2; i <= 10; i++)\n    {\n        int array1[] = { 9, 3, 5, 7, 1, 8, 0, 6, 2, 4 };\n        cout << \"\\nMerge array of size \" << i << \"\\n\\n\";\n        int *result = merge_sort(array1, i);\n        delete[] result;\n    }\n    return 0;\n}\n```\n\n\nThis is the debug-laden code.  It's the level to which I went to get the result.  I could perhaps have used a debugger.  Were I on a machine where ```\nvalgrind```\n works, it might have helped too (but it does not work on Mac OS X 10.8.x, sadly).\n\nThere are still many, many ways to improve the code — including the memory management.  You'd probably find it easiest to pass the input array to ```\nmerge()```\n for use as the result array (avoiding the memory allocation in that code).  This would reduce the memory management burden.\n\nWhen you remove the debug code, you'll need to call the ```\ndump_array()```\n function in the ```\nmain()```\n program to get the before and after sorting array images.\n\n\n\nCode converted to template functions and leak-free\n\nI've simplified the code a fair bit, especially in the ```\nmerge()```\n function.  Also, more as a matter of curiosity than anything else, converted it to a set of template functions, and then used them with 4 different array types (```\nint```\n, ```\ndouble```\n, ```\nstd::string```\n, ```\nchar```\n). The amount of debugging has been dramatically reduced, and the main debugging is conditional on being compiled with ```\n-DTRACE_ENABLED```\n now.\n\nThe code is now leak-free; ```\nvalgrind```\n on a Linux box (virtual machine) gives it a clean bill of health when there are no exceptions. It is not guaranteed exception-safe, though. In fact, given the naked uses of ```\nnew```\n and ```\ndelete```\n, it is pretty much guaranteed not to be exception-safe.  I've left the ```\nnamespace```\n control in place, but I'm far from convinced it is really correct — indeed, I'd lay odds on it not being good.  (I'm also curious if anyone has any views on how to layout code within a ```\nnamespace {```\n … ```\n};```\n block; it seems odd not indenting everything inside a set of braces, but …)\n\n```\n#include <iostream>\nusing namespace std;\n\nnamespace {\n\n#if !defined(TRACE_ENABLED)\n#define TRACE_ENABLED 0\n#endif\n\nenum { ENABLE_TRACE = TRACE_ENABLED };\n\ntemplate <typename T>\nvoid merge(T *l, int m, T *r, int n, T *result);\n\ntemplate <typename T>\nvoid dump_array(const char *tag, T *a, int size)\n{\n    int i;\n    cout << tag << \": (\" << size << \") \";\n    for (i = 0; i < size; i++)\n    {\n        cout << \"  \" << a[i];\n        if (i % 10 == 9)\n            cout << '\\n';\n    }\n    if (i % 10 != 0)\n        cout << '\\n';\n}\n\n};\n\ntemplate <typename T>\nvoid merge_sort(T *a, int size)\n{\n    if (size <= 1)\n        return;\n\n    if (ENABLE_TRACE)\n        dump_array(\"-->> merge_sort\", a, size);\n    int middle = size/2;\n    T *left = new T[middle];\n    T *right = new T[size - middle];\n\n    for (int i = 0; i < middle; i++)\n        left[i] = a[i];\n\n    for (int j = 0; j < size - middle; j++)\n        right[j] = a[j + middle];\n\n    merge_sort(left, middle);\n    merge_sort(right, size - middle);\n    merge(left, middle, right, size - middle, a);\n    delete [] left;\n    delete [] right;\n    if (ENABLE_TRACE)\n        dump_array(\"<<-- merge_sort\", a, size);\n}\n\nnamespace {\n\ntemplate <typename T>\nvoid merge(T *l, int m, T *r, int n, T *result)\n{\n    T *l_end = l + m;\n    T *r_end = r + n;\n    T *out = result;\n    if (ENABLE_TRACE)\n    {\n        cout << \"-->> merge: (\" << m << \",\" << n << \")\\n\";\n        dump_array(\"L\", l, m);\n        dump_array(\"R\", r, n);\n    }\n\n    while (l < l_end && r < r_end)\n    {\n        if (*l <= *r)\n            *out++ = *l++;\n        else\n            *out++ = *r++;\n    }\n    while (l < l_end)\n        *out++ = *l++;\n    while (r < r_end)\n        *out++ = *r++;\n\n    if (ENABLE_TRACE)\n        dump_array(\"<<-- merge\", result, m+n);\n}\n\n};\n\n#include <string>\n\nint main()\n{\n\n    for (size_t i = 1; i <= 10; i++)\n    {\n        int array1[] = { 9, 3, 5, 7, 1, 8, 0, 6, 2, 4 };\n        if (i <= sizeof(array1)/sizeof(array1[0]))\n        {\n            cout << \"\\nMerge array of type int of size \" << i << \"\\n\\n\";\n            dump_array(\"Original\", array1, i);\n            merge_sort(array1, i);\n            dump_array(\"PostSort\", array1, i);\n        }\n    }\n\n    for (size_t i = 1; i <= 10; i++)\n    {\n        double array2[] = { 9.9, 3.1, 5.2, 7.3, 1.4, 8.5, 0.6, 6.7, 2.8, 4.9 };\n        if (i <= sizeof(array2)/sizeof(array2[0]))\n        {\n            cout << \"\\nMerge array of type double of size \" << i << \"\\n\\n\";\n            dump_array(\"Original\", array2, i);\n            merge_sort(array2, i);\n            dump_array(\"PostSort\", array2, i);\n        }\n    }\n\n    for (size_t i = 1; i <= 10; i++)\n    {\n        std::string array3[] = { \"nine\", \"three\", \"five\", \"seven\", \"one\", \"eight\", \"zero\", \"six\", \"two\", \"four\" };\n        if (i <= sizeof(array3)/sizeof(array3[0]))\n        {\n            cout << \"\\nMerge array type std::string of size \" << i << \"\\n\\n\";\n            dump_array(\"Original\", array3, i);\n            merge_sort(array3, i);\n            dump_array(\"PostSort\", array3, i);\n        }\n    }\n\n    for (size_t i = 1; i <= 10; i++)\n    {\n        char array4[] = \"jdfhbiagce\";\n        if (i <= sizeof(array4)/sizeof(array4[0]))\n        {\n            cout << \"\\nMerge array type char of size \" << i << \"\\n\\n\";\n            dump_array(\"Original\", array4, i);\n            merge_sort(array4, i);\n            dump_array(\"PostSort\", array4, i);\n        }\n    }\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "PRAM( parallel) algo for Merge sort\r\n                \r\nI was in the middle of reading Multithreaded merge sort in Introduction to algorithm 3rd edition. However I am confused with the number of processors required for the following Merge-Sort algo:\n\n```\nMERGE-SORT(A, p, r)\n1 if p < r\n2 q = (p+r)/2\n3 spawn MERGE-SORT(A, p, q)\n4 MERGE-SORT(A, q + 1, r)\n5 sync\n6 MERGE(A, p, q, r)\n```\n\n\nthe MERGE is the standard merge algorithm. Now what is the number of processor required for this algorithm ?? Though i am assuming it should be O(N) but the book is claiming it to be O(log n), why? Note i am not multithreading the MERGE procedure. an explaination with an example will be really helpful. Thanks in advance.\n    ", "Answer": "\r\nThe O(log n) value is not the number of CPUs \"required\" to run the algorithm, but the actual \"parallelism\" achieved by the algorithm. Because MERGE itself is not parallelized, you don't get the full benefit if O(n) processors even if you have them all available.\n\nThat is, the single-threaded, serial time complexity for merge sort is O(n log n). You can think of 'n' as the cost of merge and 'log n' as the factor that counts in the recursive invocations of merge sort to get the array to a stage where you can merge it. When you parallelize the recursion, but merge is still serial, you save the O(log n) factor but the O(n) factor stays there. Therefore the parallelism is of the order O(log n) when you have enough processors available, but you can't get to O(n).\n\nIn yet other words, even if you have O(n) CPUs available, most of them fall idle very soon and less and less CPUs work when the large MERGEs start to take place.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merging function for merge sort\r\n                \r\nI am having a difficult time with the merging portion for merge sort. Every time I merge the two halves of the vector, it ends up losing at least one of the values in the vector. \n\n```\nvoid merge(vector <double> &v, vector <double> &temp, int start, int size) {\nint i, j, k;\n\n\ni = start;\nj = start + size - size/2;\nk = start;\n\ntemp.resize(v.size());\nwhile(i < start+size/2 && j < start+size) {\n    if(v[i] <= v[j]) {\n        temp[k] = v[i];\n        i++;\n        k++;\n    //  cout << \"i <= j \" << temp[k] << endl;\n    } else {\n        temp[k] = v[j];\n        j++;\n        k++;\n    //  cout << \"i > j \"<< temp[k] << endl;\n    }\n}\n\nfor(i = start; i < start+size; i++) {\n    v[i] = temp[i];\n}\n```\n\n\n}\n    ", "Answer": "\r\nSince I don't know the caller implementation and I may be wrong, but I think there are two bugs.\n\n\nFirst, ```\ni```\n is terminated at ```\nstart+size/2```\n in the first while-loop.\nThis value must be equal to the first value of ```\nj```\n which is ```\nstart+size-size/2```\n.\nBut, for instance, if ```\nsize==5```\n, then ```\nstart+5/2=start+2```\n and ```\nstart+5-5/2=start+3```\n.\nIn this case ```\nv[start+2]```\n is never entered to the final result.\nSecondly, after breaking out of the first while-loop, remaining values of ```\nv```\n also must be assigned to ```\ntemp```\n.\n\n\nIn summary, my quick answer is as follows. Demo is here.\n\n```\nvoid merge(std::vector<double> &v, std::vector<double> &temp, int start, int size) \n{\n    int i = start;             // left  array begin\n    int j = i + size - size/2; // right array begin (which should be guaranteed by caller.)\n\n    int i_max = j;             // left  array end\n    int j_max = start+size;    // right array end\n\n    int k = i;\n    temp.resize(v.size());\n\n    while(i < i_max && j < j_max) \n    {\n        if(v[i] <= v[j]){\n            temp[k] = v[i];\n            i++;\n            k++;\n            //std::cout << \"i <= j: \" << temp[k-1] << std::endl;\n        } \n        else {\n            temp[k] = v[j];\n            j++;\n            k++;\n            //std::cout << \"i >  j: \"<< temp[k-1] << std::endl;\n        }\n    }\n\n    while (i < i_max) { \n        temp[k] = v[i]; \n        i++; \n        k++; \n    } \n\n    while (j < j_max) { \n        temp[k] = v[j]; \n        j++; \n        k++; \n    } \n\n    for(i = start; i < j_max; i++) {\n        v[i] = temp[i];\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Number of Comparisons in Merge-Sort\r\n                \r\nI was studying the merge-sort subject that I ran into this concept that the number of comparisons in merge-sort (in the worst-case, and according to Wikipedia) equals (n ⌈lg n⌉ - 2⌈lg n⌉ + 1); in fact it's between (n lg n - n + 1) and (n lg n + n + O(lg n)). The problem is that I cannot figure out what these complexities try to say. I know O(nlogn) is the complexity of merge-sort but the number of comparisons? \n    ", "Answer": "\r\nWhy to count comparisons\n\nThere are basically two operations to any sorting algorithm: comparing data and moving data. In many cases, comparing will be more expensive than moving. Think about long strings in a reference-based typing system: moving data will simply exchange pointers, but comparing might require iterating over a large common part of the strings before the first difference is found. So in this sense, comparison might well be the operation to focus on.\n\nWhy an exact count\n\nThe numbers appear to be more detailed: instead of simply giving some Landau symbol (big-Oh notation) for the complexity, you get an actual number. Once you have decided what a basic operation is, like a comparison in this case, this approach of actually counting operations becomes feasible. This is particularly important when comparing the constants hidden by the Landau symbol, or when examining the non-asymptotic case of small inputs.\n\nWhy this exact count formula\n\nNote that throughout this discussion, lg denotes the logarithm with base 2. When you merge-sort n elements, you have ⌈lg n⌉ levels of merges. Assume you place ⌈lg n⌉ coins on each element to be sorted, and a merge costs one coin. This will certainly be enough to pay for all the merges, as each element will be included in ⌈lg n⌉ merges, and each merge won't take more comparisons than the number of elements involved. So this is the n⌈lg n⌉ from your formula.\n\nAs a merge of two arrays of length m and n takes only m + n − 1 comparisons, you still have coins left at the end, one from each merge. Let us for the moment assume that all our array lengths are powers of two, i.e. that you always have m = n. Then the total number of merges is n − 1 (sum of powers of two). Using the fact that n is a power of two, this can also be written as 2⌈lg n⌉ − 1, and subtracting that number of returned coins from the number of all coins yields n⌈lg n⌉ − 2⌈lg n⌉ + 1 as required.\n\nIf n is 1 less than a power of two, then there are ⌈lg n⌉ merges where one element less is involved. This includes a merge of two one-element lists which used to take one coin and which now disappears altogether. So the total cost reduces by ⌈lg n⌉, which is exactly the number of coins you'd have placed on the last element if n were a power of two. So you have to place fewer coins up front, but you get back the same number of coins. This is the reason why the formula has 2⌈lg n⌉ instead of n: the value remains the same unless you drop to a smaller power of two. The same argument holds if the difference between n and the next power of two is greater than 1.\n\nOn the whole, this results in the formula given in Wikipedia:\n\n\n  n ⌈lg n⌉ − 2⌈lg n⌉ + 1\n\n\nNote: I'm pretty happy with the above proof. For those who like my formulation, feel free to distribute it, but don't forget to attribute it to me as the license requires.\n\nWhy this lower bound\n\nTo proove the lower bound formula, let's write ⌈lg n⌉ = lg n + d with 0 ≤ d < 1. Now the formula above can be written as\nn (lg n + d) − 2lg n + d + 1 =\nn lg n + nd − n2d + 1 =\nn lg n − n(2d − d) + 1 ≥\nn lg n − n + 1\nwhere the inequality holds because 2d − d ≤ 1 for 0 ≤ d < 1\n\nWhy this upper bound\n\nI must confess, I'm rather confused why anyone would name n lg n + n + O(lg n) as an upper bound. Even if you wanted to avoid the floor function, the computation above suggests something like n lg n − 0.9n + 1 as a much tighter upper bound for the exact formula. 2d − d has its minimum (ln(ln(2)) + 1)/ln(2) ≈ 0.914 for d = −ln(ln(2))/ln(2) ≈ 0.529.\n\nI can only guess that the quoted formula occurs in some publication, either as a rather loose bound for this algorithm, or as the exact number of comparisons for some other algorithm which is compared against this one.\n\n\n\n(Two different counts)\n\nThis issue has been resolved by the comment below; one formula was originally quoted incorrectly.\n\n\n  equals (n lg n - n + 1); in fact it's between (n lg n - n + 1) and (n lg n + n + O(lg n))\n\n\nIf the first part is true, the second is trivially true as well, but explicitely stating the upper bound seems kind of pointless. I haven't looked at the details myself, but these two statements appear strange when taken together like this. Either the first one really is true, in which case I'd omit the second one as it is only confusing, or the second one is true, in which case the first one is wrong and should be omitted.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sorting a struct\r\n                \r\n```\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct points{\n        float axis[2];\n        int id;\n}Points;\n\ntypedef enum{\n        SortById,\n        SortByXAxis\n}SortType;\n\nPoints* fill_Array(char* filename, int* length);\nvoid Print_set(Points* set, int number_of_points);\nvoid mergesort(Points* set, int low, int high, int number_of_points,SortType sort);\nvoid merge(Points* set, int low, int middle, int high, int number_of_points,SortType sort);\n\nint main(int argc, char* argv[])\n{\n    int length;\n    Points *array;\n    array=fill_Array(argv[1],&length);\n    Print_set(array,length);\n    printf(\"\\n\\n\");\n    mergesort(array,0,length,length,SortById);\n    Print_set(array,length);\n    return 0;\n}\nPoints* fill_Array(char* filename,int* length)\n{\n    int i;\n    Points* array;\n    FILE* file=fopen(filename,\"r\");\n\n    if(file == NULL)\n    {\n        return NULL;\n    }\n\n    fscanf(file,\"%d\",length);\n    array=malloc(sizeof(Points)* *length);\n\n    for(i = 0; i < *length; i++)\n    {\n        fscanf(file,\"%d %f %f\", &(array+i)->id,&(array+i)->axis[0],&(array+i)->axis[1]);\n    }\n    fclose(file);\n\n    return array;\n}\n\nvoid Print_set(Points *set, int number_of_points)\n{\n    int i;\n\n    for(i = 0; i < number_of_points; i++)\n    {\n        printf(\"%d %f %f\\n\",(set+i)->id,(set+i)->axis[0],(set+i)->axis[1]);\n    }\n}\n\nvoid mergesort(Points* set,int low,int high,int number_of_points, SortType sort)\n{\n    int mid1;\n\n    if((high-low)>=1)\n    {\n        mid1 = (low+high)/2;\n\n        mergesort(set, low, mid1, number_of_points, sort);\n        mergesort(set, mid1+1, high, number_of_points, sort);\n        merge(set, low, mid1, high, number_of_points, sort);\n\n    }\n\n}\nvoid merge(Points* set, int low, int middle, int high, int number_of_points, SortType sort)\n{\n        int leftIndex=low;\n        int rightIndex=middle;\n        int combinedIndex = low;\n        Points tempArray[number_of_points];\n        int i;\n\n        while(leftIndex <= middle && rightIndex<= high)\n        {\n            if(set[leftIndex].id <= set[rightIndex].id)\n            {\n                tempArray[combinedIndex++] = set[leftIndex++];\n            }\n            else\n                tempArray[combinedIndex++] = set[rightIndex++];\n        }\n\n        if(leftIndex == middle+1)\n        {\n            while(rightIndex <= high)\n            {\n                tempArray[combinedIndex++] = set[rightIndex++];\n            }\n        }\n        else\n        {\n            while(leftIndex <= middle)\n            {\n                tempArray[combinedIndex++] = set[leftIndex++];\n            }\n        }\n\n        for( i = low; i < high; i++)\n        {\n            set[i] = tempArray[i];\n        }\n}\n```\n\n\nI am trying to perform a merge sort on an input file using a custom merge sort function. The merge sort functions however are not working and print out down below, the first block being the actual input file printed out to make sure fscanf is reading in everything correctly and the second being the printing after the merge functions are run. The functions are duplicating some of the values and are not sorting them either and I cannot find the mistake in the code. Note that the enum will be used to sort either the ids or the first float values I am just trying to get the merge sort to work before I use it to sort either the ids or those values.\n\n```\n1 13.000000 7.000000\n13 14.000000 6.000000\n95 7.000000 13.000000\n39 0.000000 20.000000\n78 10.000000 10.000000\n68 3.000000 17.000000\n32 6.000000 14.000000\n10 19.000000 1.000000\n0 18.000000 2.000000\n45 17.000000 3.000000\n92 4.000000 16.000000\n29 5.000000 15.000000\n85 8.000000 12.000000\n79 15.000000 5.000000\n12 16.000000 4.000000\n32 1.000000 19.000000\n77 9.000000 11.000000\n52 12.000000 8.000000\n80 11.000000 9.000000\n31 2.000000 18.000000\n\n\n1 13.000000 7.000000\n13 14.000000 6.000000\n68 3.000000 17.000000\n0 18.000000 2.000000\n10 19.000000 1.000000\n0 18.000000 2.000000\n0 18.000000 2.000000\n92 4.000000 16.000000\n92 4.000000 16.000000\n29 5.000000 15.000000\n32 1.000000 19.000000\n52 12.000000 8.000000\n77 9.000000 11.000000\n79 15.000000 5.000000\n12 16.000000 4.000000\n32 1.000000 19.000000\n32 1.000000 19.000000\n80 11.000000 9.000000\n95 7.000000 13.000000\n95 7.000000 13.000000\n```\n\n    ", "Answer": "\r\nYou appear to have gotten confused about the meaning of your boundary indices.  Consider the initial call to function ```\nmergesort()```\n:\n\n```\n    mergesort(array,0,length,length,SortById);\n```\n\n\nYou pass the same value for arguments ```\nhigh```\n and ```\nnumber_of_points```\n, which is fine, but it implies that ```\nhigh```\n represents an exclusive upper bound on the indices of the sort range.  The ```\nmergesort()```\n implementation, however, seems geared for argument ```\nhigh```\n to represent an inclusive bound.\n\nThe confusion continues with your ```\nmerge()```\n function, which is probably the main culprit here.  By taking the passed midpoint value as the start index of the right sub-array, it seems to be expecting the midpoint as an exclusive upper bound of the left sub-array, but the current ```\nmergesort()```\n implementation passes an inclusive upper bound.  On the other hand, some of the index comparisons performed by ```\nmerge()```\n are appropriate only if ```\nmiddle```\n is an inclusive upper bound of the subarray.\n\nIn short, you have a muddle.  The basic outline of the algorithm looks fine, but you need to decide (and document for yourself) what your function parameters represent, and reconcile your implementation details with that.  Were I you, I would adopt half-open representation for all intervals, so that lower bounds are always inclusive, and upper bounds always exclusive.  Among other things, that has the advantage that each midpoint value can be interpreted equally correctly as the (exclusive) upper bound of the left half of its subarray or as the (inclusive) lower bound of the right half.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort implementation in c++ [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI was trying to implement the merge sort algorithm given in CLRS 3rd edition.\nInstead of using sentinel values, I have checked for the bounds in the merge operation.\n\nFollowing is my merge sort implementation\n\n```\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nvoid merge(int [],int p,int q ,int r);\nvoid mergeSort(int [],int p,int r);\nint main(int argc, char** argv)\n{\n    int input[10];\n\n    for(int i = 0 ; i < 10 ; i++){\n        input[i] = (rand()%100)+10;\n    }\n    mergeSort(input,0,9);\n    cout<<endl;\n    for(int i = 0 ;i <10; i++){\n        cout<<input[i]<<\"\\t\";\n\n    }\n    cout<<endl;\n\n    return 0;\n}\n\nvoid mergeSort(int  input[],int lower, int higher)\n{\n    if(lower<higher){\n        int mid = (lower + higher)/2;\n        mergeSort(input,lower,mid);\n        mergeSort(input,mid+1,higher);\n        merge(input,lower,mid,higher);\n    }\n}\nvoid merge(int input[], int lower, int mid , int higher)\n{\n    int sizeLeft = mid - lower +1;\n\n    int sizeRight = higher - mid;\n\n    int *leftArray = new int(sizeLeft);\n\n    int *rightArray  = new int(sizeRight);\n\n    for(int i = 0 ; i < sizeLeft ; i++){\n        leftArray[i] = input[i+lower];\n    }\n    for(int j = 0 ; j < sizeRight ; j++){\n        rightArray[j] = input[mid+j+1];\n    }\n\n    int i = 0 ;\n    int j =0;\n\n    for (int k  = lower ; k <= higher ; k++){\n\n        if(leftArray[i]<=rightArray[j] || j>higher){\n            input[k]= leftArray[i];\n            i =  i + 1;\n\n        }else if(rightArray[j]< leftArray[i] || i>mid){\n            input[k] = rightArray[j];\n            j = j+1;\n        }\n    }\n}\n```\n\n\nI get the following output for every run of the program\n\n```\n25      0       0       31      0       0       45      0       87      0```\n\n\nBasically I am randomly generating 10 numbers and copying them to an array and I sort the array using merge sort.\n\nPlease help me. Thanks in advance.\n\n```\n--EDIT--```\n\n\nI made the following changes after going through the debugger and I got the correct answer.\nIn the  merge operation, I changed it to this:\n\n```\nvoid merge(int input[], int lower, int mid , int higher)\n{\n    int sizeLeft = mid - lower +1;\n\n    int sizeRight = higher - mid;\n\n    int *leftArray = new int[sizeLeft];\n\n    int *rightArray  = new int[sizeRight];\n\n    for(int i = 0 ; i < sizeLeft ; i++){\n        leftArray[i] = input[i+lower];\n    }\n    for(int j = 0 ; j < sizeRight ; j++){\n        rightArray[j] = input[mid+j+1];\n    }\n\n    int i = 0 ;\n    int j =0;\n\n    for (int k  = lower ; k <= higher ; k++){\n\n        if((i+lower)>mid){\n            input[k]= rightArray[j++];\n        }else if((j+mid+1)>higher){\n            input[k] = leftArray[i++];\n        }else if(leftArray[i]<= rightArray[j]){\n            input[k] = leftArray[i++];\n        }else{\n            input[k] = rightArray[j++];\n        }\n    }\n\n    delete [] leftArray;\n    delete [] rightArray;\n}\n```\n\n    ", "Answer": "\r\nYou might have problems with your algorithm but what stands out is a very bad memory handling bug.\n\nWhen you say:\n\n```\nint *leftArray = new int(sizeLeft);\n```\n\n\nYou allocate memory for  single ```\nint```\n and initialize it with the value of ```\nsizeLeft```\n. That's clearly not what you want. If you want to allocate memory for an array of ```\nint```\n you should say:\n\n```\nint *leftArray = new int[sizeLeft];\n```\n\n\nNote the square brackets instead of parentheses.\n\nYou also don't release the memory before the function returns so you leak memory every time it's called. To free the memory you'll need to do:\n\n```\ndelete [] leftArray;\n```\n\n\nHaving said that, this is C++ and there are better ways to have a dynamic array such as ```\nstd::vector```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Counting Operations of Merge Sort and Selection Sort\r\n                \r\nI want to compare count of operations of the sorting algorithms Merge Sort and Selection Sort, but I have some problems figuring out which operations to count and which not..\n\nHere are my implementations. I think I'm counting the operations of Selection Sort in the right way, but I don't know about Merge Sort:\n\nSelection Sort:\n\n```\npublic class SelectionSort {\nprivate int exchanges, comparisons;\n\npublic void selectionSort(int[] x) {    \n    for (int i=0; i<x.length-1; i++) {\n        for (int j=i+1; j<x.length; j++) {\n            if (x[i] > x[j]) \n            {\n                //... Exchange elements\n                int temp = x[i];\n                x[i] = x[j];\n                x[j] = temp;\n                exchanges++;\n            }\n            comparisons++;\n        }\n    }\n    System.out.println(\"SelSort_Exchanges: \"+exchanges);\n    System.out.println(\"SelSort_Comparisons: \"+comparisons);\n    System.out.println(\"SelSort_Operations: \"+(exchanges+comparisons));\n}\n}\n```\n\n\nIf I put in an array of 10 int I get:\n\n```\nSelSort_Comparisons: 45\nSelSort_Exchanges: 27\nSelSort_Operations: 72\n```\n\n\nSeems right to me, but now for Merge Sort:\n\n```\npublic class Mergesort {\nprivate int[] numbers;\nprivate int[] helper;\n\nprivate int number;\nprivate int comparisons, exchanges;\n\npublic void sort(int[] values) {\n    this.numbers = values;\n    number = values.length;\n    this.helper = new int[number];\n    mergesort(0, number - 1);\n    System.out.println(\"MerSort_Comparisons \"+comparisons);\n    System.out.println(\"MerSort_Exchanges \"+exchanges);\n    System.out.println(\"MerSort_Operations \"+(comparisons+exchanges));\n    System.out.println();\n}\n\nprivate void mergesort(int low, int high) {\n    // Check if low is smaller then high, if not then the array is sorted\n    if (low < high) \n    {\n        // Get the index of the element which is in the middle\n        int middle = (low + high) / 2;\n        // Sort the left side of the array\n        mergesort(low, middle);\n        // Sort the right side of the array\n        mergesort(middle + 1, high);\n        // Combine them both\n        merge(low, middle, high);\n    }\n}\n\nprivate void merge(int low, int middle, int high) {\n\n    // Copy both parts into the helper array\n    for (int i = low; i <= high; i++) {\n        helper[i] = numbers[i];\n        exchanges++;\n    }\n    int i = low;\n    int j = middle + 1;\n    int k = low;\n    // Copy the smallest values from either the left or the right side back\n    // to the original array\n    while (i <= middle && j <= high) {\n        if (helper[i] <= helper[j]) {\n            numbers[k] = helper[i];\n            i++;\n            exchanges++;\n        } else {\n            numbers[k] = helper[j];\n            j++;\n            exchanges++;\n        }\n        k++;\n        comparisons++;\n\n    }\n    // Copy the rest of the left side of the array into the target array\n    while (i <= middle) {\n        numbers[k] = helper[i];\n        exchanges++;\n        k++;\n        i++;\n    }\n}   \n}\n```\n\n\nnow I get\n\n```\nMerSort_Comparisons 22\nMerSort_Exchanges 61\nMerSort_Operations 83\n```\n\n\nas a result but I don't know if its right. Result of Comparisons seems right to me, but if I take an array of 20 for example it doesnt seem right anymore. \n\nCould anyone help me with this and tell me where exactly I have to put my comparison and exchange increments? \n\nthanks in advance! :)\n    ", "Answer": "\r\nSimplest way would be to create two methods, ```\nCompare```\n and ```\nSwap```\n, and increase counter inside of them. Whatever sorting algorithm you implement, it should only interact with the array using these methods.\n\nAlso, this page can help you analyze different sorting algorithms visually.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Number of Comparisons in Merge-Sort\r\n                \r\nI was studying the merge-sort subject that I ran into this concept that the number of comparisons in merge-sort (in the worst-case, and according to Wikipedia) equals (n ⌈lg n⌉ - 2⌈lg n⌉ + 1); in fact it's between (n lg n - n + 1) and (n lg n + n + O(lg n)). The problem is that I cannot figure out what these complexities try to say. I know O(nlogn) is the complexity of merge-sort but the number of comparisons? \n    ", "Answer": "\r\nWhy to count comparisons\n\nThere are basically two operations to any sorting algorithm: comparing data and moving data. In many cases, comparing will be more expensive than moving. Think about long strings in a reference-based typing system: moving data will simply exchange pointers, but comparing might require iterating over a large common part of the strings before the first difference is found. So in this sense, comparison might well be the operation to focus on.\n\nWhy an exact count\n\nThe numbers appear to be more detailed: instead of simply giving some Landau symbol (big-Oh notation) for the complexity, you get an actual number. Once you have decided what a basic operation is, like a comparison in this case, this approach of actually counting operations becomes feasible. This is particularly important when comparing the constants hidden by the Landau symbol, or when examining the non-asymptotic case of small inputs.\n\nWhy this exact count formula\n\nNote that throughout this discussion, lg denotes the logarithm with base 2. When you merge-sort n elements, you have ⌈lg n⌉ levels of merges. Assume you place ⌈lg n⌉ coins on each element to be sorted, and a merge costs one coin. This will certainly be enough to pay for all the merges, as each element will be included in ⌈lg n⌉ merges, and each merge won't take more comparisons than the number of elements involved. So this is the n⌈lg n⌉ from your formula.\n\nAs a merge of two arrays of length m and n takes only m + n − 1 comparisons, you still have coins left at the end, one from each merge. Let us for the moment assume that all our array lengths are powers of two, i.e. that you always have m = n. Then the total number of merges is n − 1 (sum of powers of two). Using the fact that n is a power of two, this can also be written as 2⌈lg n⌉ − 1, and subtracting that number of returned coins from the number of all coins yields n⌈lg n⌉ − 2⌈lg n⌉ + 1 as required.\n\nIf n is 1 less than a power of two, then there are ⌈lg n⌉ merges where one element less is involved. This includes a merge of two one-element lists which used to take one coin and which now disappears altogether. So the total cost reduces by ⌈lg n⌉, which is exactly the number of coins you'd have placed on the last element if n were a power of two. So you have to place fewer coins up front, but you get back the same number of coins. This is the reason why the formula has 2⌈lg n⌉ instead of n: the value remains the same unless you drop to a smaller power of two. The same argument holds if the difference between n and the next power of two is greater than 1.\n\nOn the whole, this results in the formula given in Wikipedia:\n\n\n  n ⌈lg n⌉ − 2⌈lg n⌉ + 1\n\n\nNote: I'm pretty happy with the above proof. For those who like my formulation, feel free to distribute it, but don't forget to attribute it to me as the license requires.\n\nWhy this lower bound\n\nTo proove the lower bound formula, let's write ⌈lg n⌉ = lg n + d with 0 ≤ d < 1. Now the formula above can be written as\nn (lg n + d) − 2lg n + d + 1 =\nn lg n + nd − n2d + 1 =\nn lg n − n(2d − d) + 1 ≥\nn lg n − n + 1\nwhere the inequality holds because 2d − d ≤ 1 for 0 ≤ d < 1\n\nWhy this upper bound\n\nI must confess, I'm rather confused why anyone would name n lg n + n + O(lg n) as an upper bound. Even if you wanted to avoid the floor function, the computation above suggests something like n lg n − 0.9n + 1 as a much tighter upper bound for the exact formula. 2d − d has its minimum (ln(ln(2)) + 1)/ln(2) ≈ 0.914 for d = −ln(ln(2))/ln(2) ≈ 0.529.\n\nI can only guess that the quoted formula occurs in some publication, either as a rather loose bound for this algorithm, or as the exact number of comparisons for some other algorithm which is compared against this one.\n\n\n\n(Two different counts)\n\nThis issue has been resolved by the comment below; one formula was originally quoted incorrectly.\n\n\n  equals (n lg n - n + 1); in fact it's between (n lg n - n + 1) and (n lg n + n + O(lg n))\n\n\nIf the first part is true, the second is trivially true as well, but explicitely stating the upper bound seems kind of pointless. I haven't looked at the details myself, but these two statements appear strange when taken together like this. Either the first one really is true, in which case I'd omit the second one as it is only confusing, or the second one is true, in which case the first one is wrong and should be omitted.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Sorting a multidimensional array using merge sort?\r\n                \r\nI am trying to sort this multidimensional array after the number on the first index using the merge sort algorithm, but I am very unsure on how to do so.\nThis is the multidimensional array I am trying to sort:\n```\nOrders_db = [[1347517405, 54413, '78'], [1347517413, 54421, '86'], [1347517454, 54462, '127'], [1347517460, 54468, '133'], [1347517461, 54469, '134'], [1347517426, 54434, '99'], [1347517464, 54472, '137'], [1347517394, 54402, '67'], [1347517445, 54453, '118'], [1347517375, 54383, '48'], [1347517377, 54385, '50'], [1347517392, 54400, '65'], [1347517450, 54458, '123'], [1347517404, 54412, '77'], [1347517389, 54397, '62'], [1347517393, 54401, '66'], [1347517440, 54448, '113'], [1347517457, 54465, '130'], [1347517444, 54452, '117'], [1347517400, 54408, '73'], [1347517412, 54420, '85'], [1347517371, 54379, '44'], [1347517415, 54423, '88'], [1347517441, 54449, '114'], [1347517435, 54443, '108'], [1347517409, 54417, '82'], [1347517398, 54406, '71'], [1347517422, 54430, '95'], [1347517468, 54476, '141'], [1347517402, 54410, '75'], [1347517437, 54445, '110'], [1347517446, 54454, '119'], [1347517382, 54390, '55'], [1347517399, 54407, '72'], [1347517438, 54446, '111'], [1347517416, 54424, '89'], [1347517380, 54388, '53'], [1347517425, 54433, '98'], [1347517406, 54414, '79'], [1347517449, 54457, '122'], [1347517388, 54396, '61'], [1347517430, 54438, '103'], [1347517455, 54463, '128'], [1347517458, 54466, '131'], [1347517452, 54460, '125'], [1347517396, 54404, '69'], [1347517423, 54431, '96'], [1347517465, 54473, '138'], [1347517397, 54405, '70'], [1347517459, 54467, '132'], [1347517395, 54403, '68'], [1347517381, 54389, '54'], [1347517424, 54432, '97'], [1347517436, 54444, '109'], [1347517434, 54442, '107'], [1347517401, 54409, '74'], [1347517376, 54384, '49'], [1347517467, 54475, '140'], [1347517456, 54464, '129'], [1347517427, 54435, '100'], [1347517383, 54391, '56'], [1347517451, 54459, '124'], [1347517433, 54441, '106'], [1347517414, 54422, '87'], [1347517417, 54425, '90'], [1347517453, 54461, '126'], [1347517378, 54386, '51'], [1347517432, 54440, '105'], [1347517403, 54411, '76'], [1347517439, 54447, '112'], [1347517448, 54456, '121'], [1347517410, 54418, '83'], [1347517391, 54399, '64'], [1347517447, 54455, '120'], [1347517421, 54429, '94'], [1347517379, 54387, '52'], [1347517411, 54419, '84'], [1347517386, 54394, '59'], [1347517384, 54392, '57'], [1347517374, 54382, '47'], [1347517462, 54470, '135'], [1347517431, 54439, '104'], [1347517419, 54427, '92'], [1347517428, 54436, '101'], [1347517466, 54474, '139'], [1347517443, 54451, '116'], [1347517463, 54471, '136'], [1347517385, 54393, '58'], [1347517387, 54395, '60'], [1347517373, 54381, '46'], [1347517372, 54380, '45'], [1347517418, 54426, '91'], [1347517420, 54428, '93'], [1347517469, 54477, '142]'], [1347517442, 54450, '115'], [1347517408, 54416, '81'], [1347517390, 54398, '63'], [1347517407, 54415, '80'], [1347517429, 54437, '102']]\n```\n\nAnd I can implement a general merge sort algorithm, but i cannot do it in a way where I sort after the number in the array on the first index.\nMy implementation of merge sort is:\n```\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        merge_sort(left)\n        merge_sort(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return arr\n```\n\nHow can I fit the general merge sort algorithm to sort this array?\nThe preferred answer is that it returns the array with the highest number in the end.\n    ", "Answer": "\r\nTry below:\n```\ndef merge(left, right):\n    if not len(left) or not len(right):\n        return left or right\n\n    result = []\n    i, j = 0, 0\n    while (len(result) < len(left) + len(right)):\n        if left[i][0] < right[j][0]:\n            result.append(left[i])\n            i+= 1\n        else:\n            result.append(right[j])\n            j+= 1\n        if i == len(left) or j == len(right):\n            result.extend(left[i:] or right[j:])\n            break\n\n    return result\n\ndef mergesort(list):\n    if len(list) < 2:\n        return list\n\n    middle = len(list)/2\n    left = mergesort(list[:middle])\n    right = mergesort(list[middle:])\n\n    return merge(left, right)\n    \nseq = [[1347517405, 54413, '78'], [1347517413, 54421, '86'], [1347517454, 54462, '127'], [1347517460, 54468, '133'], [1347517461, 54469, '134'], [1347517426, 54434, '99'], [1347517464, 54472, '137'], [1347517394, 54402, '67'], [1347517445, 54453, '118'], [1347517375, 54383, '48'], [1347517377, 54385, '50'], [1347517392, 54400, '65'], [1347517450, 54458, '123'], [1347517404, 54412, '77'], [1347517389, 54397, '62'], [1347517393, 54401, '66'], [1347517440, 54448, '113'], [1347517457, 54465, '130'], [1347517444, 54452, '117'], [1347517400, 54408, '73'], [1347517412, 54420, '85'], [1347517371, 54379, '44'], [1347517415, 54423, '88'], [1347517441, 54449, '114'], [1347517435, 54443, '108'], [1347517409, 54417, '82'], [1347517398, 54406, '71'], [1347517422, 54430, '95'], [1347517468, 54476, '141'], [1347517402, 54410, '75'], [1347517437, 54445, '110'], [1347517446, 54454, '119'], [1347517382, 54390, '55'], [1347517399, 54407, '72'], [1347517438, 54446, '111'], [1347517416, 54424, '89'], [1347517380, 54388, '53'], [1347517425, 54433, '98'], [1347517406, 54414, '79'], [1347517449, 54457, '122'], [1347517388, 54396, '61'], [1347517430, 54438, '103'], [1347517455, 54463, '128'], [1347517458, 54466, '131'], [1347517452, 54460, '125'], [1347517396, 54404, '69'], [1347517423, 54431, '96'], [1347517465, 54473, '138'], [1347517397, 54405, '70'], [1347517459, 54467, '132'], [1347517395, 54403, '68'], [1347517381, 54389, '54'], [1347517424, 54432, '97'], [1347517436, 54444, '109'], [1347517434, 54442, '107'], [1347517401, 54409, '74'], [1347517376, 54384, '49'], [1347517467, 54475, '140'], [1347517456, 54464, '129'], [1347517427, 54435, '100'], [1347517383, 54391, '56'], [1347517451, 54459, '124'], [1347517433, 54441, '106'], [1347517414, 54422, '87'], [1347517417, 54425, '90'], [1347517453, 54461, '126'], [1347517378, 54386, '51'], [1347517432, 54440, '105'], [1347517403, 54411, '76'], [1347517439, 54447, '112'], [1347517448, 54456, '121'], [1347517410, 54418, '83'], [1347517391, 54399, '64'], [1347517447, 54455, '120'], [1347517421, 54429, '94'], [1347517379, 54387, '52'], [1347517411, 54419, '84'], [1347517386, 54394, '59'], [1347517384, 54392, '57'], [1347517374, 54382, '47'], [1347517462, 54470, '135'], [1347517431, 54439, '104'], [1347517419, 54427, '92'], [1347517428, 54436, '101'], [1347517466, 54474, '139'], [1347517443, 54451, '116'], [1347517463, 54471, '136'], [1347517385, 54393, '58'], [1347517387, 54395, '60'], [1347517373, 54381, '46'], [1347517372, 54380, '45'], [1347517418, 54426, '91'], [1347517420, 54428, '93'], [1347517469, 54477, '142]'], [1347517442, 54450, '115'], [1347517408, 54416, '81'], [1347517390, 54398, '63'], [1347517407, 54415, '80'], [1347517429, 54437, '102']]\nprint(\"Given array is\")\nprint(seq);\nprint(\"\\n\")\nprint(\"Sorted array is\")\nprint(mergesort(seq))\n\n```\n\nIf you chage ```\nleft[i][0] < right[j][0]```\n to ```\nleft[i][1] < right[j][1]```\n then it will sort accrding to the second element in the inner array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Iterative merge sort?\r\n                \r\nI am aware of classical recursive approach to sort something by merging.\nIt yields ```\nO(n * log(n))```\n complexity, which can be more or less easily shown via recurrence relation. \n\nI've tried to reimplement merge sort in iterative fashion:\n\n```\ndef atomize(l):\n    return list(\n        map(\n            lambda x: [x],\n            l if l is not None else []\n        )\n    )\n\ndef merge(l, r):\n    res = []\n    while (len(l) + len(r)) > 0:\n        if len(l) < 1:\n            res += r\n            r = []\n        elif len(r) < 1:\n            res += l\n            l = []\n        else:\n            if l[0] <= r[0]:\n                res.append(l.pop(0))\n            else:\n                res.append(r.pop(0))\n    return res\n\ndef iter_merge_sort(l):\n    atoms = atomize(l) # O(n)\n    while len(atoms) > 1: # O(n - 1)\n        atoms.append(merge(atoms.pop(0), atoms.pop(0)))\n    return atoms[0]\n```\n\n\n...and feels like I am mistaken somewhere, yet I fail to notice exact place. Recursive merge sort splits problem unless list of unsorted values reduces to a list of singletons - single elements that can be compared. That's what ```\natomize(...)```\n does: given a list, produces a list of lists-singletons (order ```\nO(n)```\n).\n\nObviously, ```\nmerge(...)```\n is ```\nO(n)```\n as well: ignore for moment that no linked lists are used for concatenation, that's not important here. \n\nFinally.. the ```\nwhile```\n block in the ```\niter_merge_sort(...)```\n itself takes exactly ```\nn - 1```\n repetitions, each of which costs at most ```\nO(n)```\n. Hence, I took ```\nO(n * log(n))```\n algorithm and \"improved\" it to be ```\n(n - 1) * n ~ O(n * n)```\n. Where is my mistake?\n    ", "Answer": "\r\nYour algorithm is entirely correct. The problem lies in that you're using ```\nlist.pop(0)```\n as a way to dequeue, which costs O(n) in Python since all items after a popped item of a list have to be copied to the preceding positions.\n\nYou can use ```\ncollections.deque```\n in place of list so that you can use the ```\ndeque.popleft```\n method, which costs O(1):\n\n```\nfrom collections import deque\n\ndef atomize(l):\n    return deque(\n        map(\n            lambda x: deque([x]),\n            l if l is not None else []\n        )\n    )\n\ndef merge(l, r):\n    res = deque()\n    while (len(l) + len(r)) > 0:\n        if len(l) < 1:\n            res += r\n            r = deque()\n        elif len(r) < 1:\n            res += l\n            l = deque()\n        else:\n            if l[0] <= r[0]:\n                res.append(l.popleft())\n            else:\n                res.append(r.popleft())\n    return res\n\ndef iter_merge_sort(l):\n    atoms = atomize(l) # O(n)\n    while len(atoms) > 1: # O(n - 1)\n        atoms.append(merge(atoms.popleft(), atoms.popleft()))\n    return list(atoms[0])\n```\n\n\nso that:\n\n```\niter_merge_sort([3,5,1,6,2,1])\n```\n\n\nreturns:\n\n```\n[1, 1, 2, 3, 5, 6]\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "coarsening of merge sort\r\n                \r\nI just started CLRS. The first problem of the 2nd chapter involves coarsening the merge sort algorithm by using insertion sort when the subarray reaches a specified minimum size. I have written the modified code and i think it is correct as I have checked it on some inputs and different values of coarseness. I am not so sure about some hidden corner cases.\nCan anybody tell me if it can be improvised further. \nHere is the modified merge sort procedure(its run time in theta notation is (nk + nlg(n/k)):\n\n```\nvoid mergesort(int arr[], int p, int r, int k) { // k is the coarseness\n    int q = (p + r) / 2;\n\n    if (r - p + 1 > k) { // when the size of the subarray is atmost k, sort using insertion sort\n    mergesort(arr, p, q, k);\n    mergesort(arr, q + 1, r, k);\n\n        merge(arr, p, q, r); // merge is the standard procedure\n\n    }\n    else {\n        insort(arr, p, r); // insort is the standard insertion sort procedure\n    }\n\n}\n```\n\n\nMoreover part 3 of the question asks the largest value of k at which the run time of this procedure is same as the standard mergesort algorithm. I tried equating the theta notations of both the procedures(nk + nlg(n/k) = nlgn) , but can that be done? is it valid to do that since i am not getting a sensible answer. Any sort of help will be appreciated. Thank you.\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort mergin\r\n                \r\nI am trying to implement merge sort.\n\nI have declared merge function \n\n```\nvoid mergeSort( vector<int> &a  , int low , int high){\n    if( low < high){\n        int mid = (low + high ) / 2;\n        mergeSort( a  , low , mid);\n        mergeSort( a , mid + 1 , high);\n        mergeArays( a , low , mid , high);\n    }\n}\n```\n\n\nhowever i have trouble with merge , i have declared\n\n```\nvoid mergeArays( vector<int> &a , int low , int mid , int high){\n    int i = 0;\n    int j = mid + 1;\n    vector<int> final;\n    while( i != mid && j!= high){\n        if( a[i] < a[j]){\n            final.push_back(a[i++]);\n            continue;\n        }\n        final.push_back(a[j++]);\n    }\n    for( int i = 0; i < final.size() ;i++){\n        a[i] = final[i];\n    }\n}\n```\n\n\nwith input ```\n9 8 7 6 5 4 3 2 1```\n , it throws competely wrong output. Where is a bug or mistake in my logic behind merge? I fail to find it , everytime i try to calcualte it it should be good. \n\nThanks\n    ", "Answer": "\r\nYou have a bug here in your ```\nmergeArrays```\n method. Consider the loop:\n\n```\nwhile( i != mid && j!= high){\n    if( a[i] < a[j]){\n        final.push_back(a[i++]);\n        continue;\n    }\n    final.push_back(a[j++]);\n}\n```\n\n\nNow, imagine that you're merging 2-element subarrays. Those are:\n\n```\n[3,9]    // a[i] = 3, a[i+1] = 9\n[10,12]  // j[i] = 10, j[i+1] = 12\n```\n\n\nSo according to your code, it's going to output 3 and 9, and then the loop will exit, because ```\ni == mid```\n.\n\nYou need to clean up after the loop to make sure everything gets copied. Correct code would be:\n\n```\nwhile( i != mid && j!= high){\n    if( a[i] < a[j]){\n        final.push_back(a[i++]);\n        continue;\n    }\n    final.push_back(a[j++]);\n}\nwhile (i != mid)\n{\n    final.push_back(a[i++]);\n}\nwhile (j != high)\n{\n    final.push_back(a[j++]);\n}\n```\n\n\nNote that only one of those two cleanup loops will be entered, because for the first loop to exit, either ```\ni == mid```\n or ```\nj == high```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Counting Operations of Merge Sort and Selection Sort\r\n                \r\nI want to compare count of operations of the sorting algorithms Merge Sort and Selection Sort, but I have some problems figuring out which operations to count and which not..\n\nHere are my implementations. I think I'm counting the operations of Selection Sort in the right way, but I don't know about Merge Sort:\n\nSelection Sort:\n\n```\npublic class SelectionSort {\nprivate int exchanges, comparisons;\n\npublic void selectionSort(int[] x) {    \n    for (int i=0; i<x.length-1; i++) {\n        for (int j=i+1; j<x.length; j++) {\n            if (x[i] > x[j]) \n            {\n                //... Exchange elements\n                int temp = x[i];\n                x[i] = x[j];\n                x[j] = temp;\n                exchanges++;\n            }\n            comparisons++;\n        }\n    }\n    System.out.println(\"SelSort_Exchanges: \"+exchanges);\n    System.out.println(\"SelSort_Comparisons: \"+comparisons);\n    System.out.println(\"SelSort_Operations: \"+(exchanges+comparisons));\n}\n}\n```\n\n\nIf I put in an array of 10 int I get:\n\n```\nSelSort_Comparisons: 45\nSelSort_Exchanges: 27\nSelSort_Operations: 72\n```\n\n\nSeems right to me, but now for Merge Sort:\n\n```\npublic class Mergesort {\nprivate int[] numbers;\nprivate int[] helper;\n\nprivate int number;\nprivate int comparisons, exchanges;\n\npublic void sort(int[] values) {\n    this.numbers = values;\n    number = values.length;\n    this.helper = new int[number];\n    mergesort(0, number - 1);\n    System.out.println(\"MerSort_Comparisons \"+comparisons);\n    System.out.println(\"MerSort_Exchanges \"+exchanges);\n    System.out.println(\"MerSort_Operations \"+(comparisons+exchanges));\n    System.out.println();\n}\n\nprivate void mergesort(int low, int high) {\n    // Check if low is smaller then high, if not then the array is sorted\n    if (low < high) \n    {\n        // Get the index of the element which is in the middle\n        int middle = (low + high) / 2;\n        // Sort the left side of the array\n        mergesort(low, middle);\n        // Sort the right side of the array\n        mergesort(middle + 1, high);\n        // Combine them both\n        merge(low, middle, high);\n    }\n}\n\nprivate void merge(int low, int middle, int high) {\n\n    // Copy both parts into the helper array\n    for (int i = low; i <= high; i++) {\n        helper[i] = numbers[i];\n        exchanges++;\n    }\n    int i = low;\n    int j = middle + 1;\n    int k = low;\n    // Copy the smallest values from either the left or the right side back\n    // to the original array\n    while (i <= middle && j <= high) {\n        if (helper[i] <= helper[j]) {\n            numbers[k] = helper[i];\n            i++;\n            exchanges++;\n        } else {\n            numbers[k] = helper[j];\n            j++;\n            exchanges++;\n        }\n        k++;\n        comparisons++;\n\n    }\n    // Copy the rest of the left side of the array into the target array\n    while (i <= middle) {\n        numbers[k] = helper[i];\n        exchanges++;\n        k++;\n        i++;\n    }\n}   \n}\n```\n\n\nnow I get\n\n```\nMerSort_Comparisons 22\nMerSort_Exchanges 61\nMerSort_Operations 83\n```\n\n\nas a result but I don't know if its right. Result of Comparisons seems right to me, but if I take an array of 20 for example it doesnt seem right anymore. \n\nCould anyone help me with this and tell me where exactly I have to put my comparison and exchange increments? \n\nthanks in advance! :)\n    ", "Answer": "\r\nSimplest way would be to create two methods, ```\nCompare```\n and ```\nSwap```\n, and increase counter inside of them. Whatever sorting algorithm you implement, it should only interact with the array using these methods.\n\nAlso, this page can help you analyze different sorting algorithms visually.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort incorrect output\r\n                \r\nI'm trying to use the following merge sort function to sort an array. However it is not giving me the expected output.\nIt will not print out correct/expected output i.e\n\nInput: 5,4,3,2,1\nOutput: 1,2,3,4,5\n\nInstead it gives: 2,3,4,5,1,9,8,7,8,4,1,8,8,2.\n\n```\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\nvoid mergeSort(int a[], int low , int high,int res[]);\nvoid merge(int a[], int low , int mid , int high,int res[]);\nvoid mergeSort(int numbers[], int temp[], int array_size);\n\nconst int SIZE=5;\n\nint main () {\n\n    int sorted[SIZE];\n    for (int i=0; i<SIZE; i++) {\n        cout << \"input numbers\" <<endl;\n        cin >>sorted[i];\n    }\n    int merge[SIZE];\n\n    mergeSort(sorted,merge,SIZE);\n\n    for (int i=0; i<SIZE; i++) {\n        cout << merge[i];\n    }\n\n    return 0;\n}\n\nvoid mergeSort(int numbers[], int temp[], int array_size)\n{\n    mergeSort(numbers, 0, array_size-1, temp);\n}\n\nvoid mergeSort(int a[], int low , int high,int res[])\n{\n    int mid = (low + high)  /2;\n    if (low + 1 < high)\n    {\n        //  Sort sub-parts\n        mergeSort(a,low,mid,res);\n        mergeSort(a,mid,high,res);\n\n        //  Merge back to \"res\"\n        merge(a,low,mid,high,res);\n    }else{\n        res[low] = a[low];\n    }\n}\n\nvoid merge(int a[], int low , int mid , int high,int res[])\n{\n    int i = low;\n    int j = mid;\n    int k = low;   //  Use \"low\" instead of 0.\n\n    while (i < mid && j < high)\n        if(a[i] < a[j])\n            res[k++] = a[i++];\n        else\n            res[k++] = a[j++];\n\n    while (i < mid)\n        res[k++] = a[i++];\n\n    while (j < high)\n        res[k++] =a[j++];\n\n    //  Copy back to \"a\"\n    for (int c = low; c < high; c++){\n        a[c] = res[c];\n    }\n}\n```\n\n    ", "Answer": "\r\nI think this is causing the problem --\n\n```\n    //  Sort sub-parts\n    mergeSort(a,low,mid,res);\n    mergeSort(a,mid,high,res);\n```\n\n\nIt should be \n\n```\n    //  Sort sub-parts\n    mergeSort(a,low,mid,res);\n    mergeSort(a,mid+1,high,res);\n```\n\n\nAlso ```\nif (low + 1 < high)```\n should be changed to ```\nif (low < high)```\n\n\nFurthermore ```\nwhile (i < mid && j < high)```\n should be ```\nwhile (i <= mid && j <= high)```\n and single while loops below it too need to be updated with <=\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort with PThreads in C\r\n                \r\nSide Note: I'm beginning to learn how to use pthreads and I'm starting to get the concept. I've been using this example script (written in C++) here to manage a Merge Sort with threads: https://www.geeksforgeeks.org/merge-sort-using-multi-threading/\n\nSince I'm writing my own merge sort in C rather than C++, I rewrote this example script to test and noticed an issue. Rather than ```\nMAX 20```\n for an array of 20 elements, I decided to go with 15. I noticed that the sorting/merging is invalid (yet somewhat close) and I cannot figure out why... In addition, I've altered the code to use a different amount of threads instead of ```\nTHREAD_MAX 4```\n so I may change it to 5 or 10 threads.\n\nCould it be the Merge that's yielding invalid results? I've commented it below within main().\n\nMy C++ to C convert below:\n\n```\n#include <pthread.h>\n#include <time.h>\n#include <stdlib.h>\n\n// number of elements in array\n#define MAX 15\n\n// number of threads\n#define THREAD_MAX 4\n\n//using namespace std;\n\n// array of size MAX\nint a[MAX];\nint part = 0;\n\n// merge function for merging two parts\nvoid merge(int low, int mid, int high)\n{   \n    int* left = (int*) malloc( (mid - low + 1) * sizeof(int));\n    int* right = (int*) malloc( (high - mid) * sizeof(int));\n\n\n    // n1 is size of left part and n2 is size\n    // of right part\n    int n1 = mid - low + 1,\n    n2 = high - mid,\n    i, j;\n\n    // storing values in left part\n    for (i = 0; i < n1; i++)\n        left[i] = a[i + low];\n\n    // storing values in right part\n    for (i = 0; i < n2; i++)\n        right[i] = a[i + mid + 1];\n\n    int k = low;\n    i = j = 0;\n\n    // merge left and right in ascending order\n    while (i < n1 && j < n2) {\n        if (left[i] <= right[j])\n            a[k++] = left[i++];\n        else\n            a[k++] = right[j++];\n    }\n\n    // insert remaining values from left\n    while (i < n1) {\n        a[k++] = left[i++];\n    }\n\n    // insert remaining values from right\n    while (j < n2) {\n        a[k++] = right[j++];\n    }\n\n    free(left);\n    free(right);\n}\n\n// merge sort function\nvoid merge_sort(int low, int high)\n{\n    // calculating mid point of array\n    int mid = low + (high - low) / 2;\n    if (low < high) {\n\n        // calling first half\n        merge_sort(low, mid);\n\n        // calling second half\n        merge_sort(mid + 1, high);\n\n        // merging the two halves\n        merge(low, mid, high);\n    }\n}\n\n// thread function for multi-threading\nvoid* merge_sort123(void* arg)\n{\n    // which part out of 4 parts\n    int thread_part = part++;\n\n    // calculating low and high\n    int low = thread_part * (MAX / THREAD_MAX);\n    int high = (thread_part + 1) * (MAX / THREAD_MAX) - 1;\n\n    // evaluating mid point\n    int mid = low + (high - low) / 2;\n    if (low < high) {\n        merge_sort(low, mid);\n        merge_sort(mid + 1, high);\n        merge(low, mid, high);\n    }\n    return 0;\n}\n\n\n\n// Driver Code\nint main()\n{\n    // generating random values in array\n    for (int i = 0; i < MAX; i++){\n        a[i] = rand() % 100;\n    //        printf(\"%d \", a[i]);\n    }\n\n\n    pthread_t threads[THREAD_MAX];\n\n    // creating 4 threads\n    for (int i = 0; i < THREAD_MAX; i++)\n        pthread_create(&threads[i], NULL, merge_sort123,\n                       (void*)NULL);\n\n    // joining all 4 threads\n    for (int i = 0; i < THREAD_MAX; i++)\n        pthread_join(threads[i], NULL);\n\n\n    ///////////////////////////////////////////////////////////////\n    // --- THIS MAY BE THE PART WHERE THE MERGING IS INVALID --- //\n    ///////////////////////////////////////////////////////////////\n    // merging the final 4 parts\n    merge(0, (MAX / 2 - 1) / 2, MAX / 2 - 1);\n    merge(MAX / 2, MAX/2 + (MAX-1-MAX/2)/2, MAX - 1);\n    merge(0, (MAX - 1)/2, MAX - 1);\n\n\n    // displaying sorted array\n    printf(\"\\n\\nSorted array: \");\n    for (int i = 0; i < MAX; i++)\n        printf (\"%d \", a[i]);\n\n\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nAs I mentioned in the top comments, there are a few issues with the original code.\n\nThe above race condition.\n\nThe [seemingly] missing ```\ndelete```\n at the bottom of ```\nmerge```\n\n\nThe fact that the number of array elements must be a multiple of the number of threads. If not, the range for the last thread will be calculated incorrectly.\n\nThe final merge in the main thread is fixed/hardwired for 4 threads.\n\n\n\nA general solution is possible. However, unless the array size is very large, it isn't as big a time saver, so it's mostly for practice with multithreading [which is what you wanted, I believe]. See: Multithreaded quicksort or mergesort\n\nIt is easier to pass several parameters to a thread using a control struct. This is good technique for multithreading in general.\n\nThe main thread can prepopulate this with the array ranges for each thread. It can later use these control structs to generalize the final merge.\n\nHere's a a cleaned up version that works for an arbitrary array size and arbitrary number of threads:\n\n```\n#include <stdio.h>\n#include <pthread.h>\n#include <time.h>\n#include <stdlib.h>\n\nint opt_a;\nint opt_t;\nint opt_r;\n\n// number of elements in array\n//#define MAX 15\n//#define MAX 16\nint MAX;\n\n// number of threads\n//#define THREAD_MAX 4\nint THREAD_MAX;\n\n//using namespace std;\n\n// array of size MAX\nint *a;\n\n// thread control parameters\nstruct tsk {\n    int tsk_no;\n    int tsk_low;\n    int tsk_high;\n};\n\n// merge function for merging two parts\nvoid\nmerge(int low, int mid, int high)\n{\n\n    // n1 is size of left part and n2 is size of right part\n    int n1 = mid - low + 1;\n    int n2 = high - mid;\n\n    int *left = malloc(n1 * sizeof(int));\n    int *right = malloc(n2 * sizeof(int));\n\n    int i;\n    int j;\n\n    // storing values in left part\n    for (i = 0; i < n1; i++)\n        left[i] = a[i + low];\n\n    // storing values in right part\n    for (i = 0; i < n2; i++)\n        right[i] = a[i + mid + 1];\n\n    int k = low;\n\n    i = j = 0;\n\n    // merge left and right in ascending order\n    while (i < n1 && j < n2) {\n        if (left[i] <= right[j])\n            a[k++] = left[i++];\n        else\n            a[k++] = right[j++];\n    }\n\n    // insert remaining values from left\n    while (i < n1)\n        a[k++] = left[i++];\n\n    // insert remaining values from right\n    while (j < n2)\n        a[k++] = right[j++];\n\n    free(left);\n    free(right);\n}\n\n// merge sort function\nvoid\nmerge_sort(int low, int high)\n{\n\n    // calculating mid point of array\n    int mid = low + (high - low) / 2;\n\n    if (low < high) {\n        // calling first half\n        merge_sort(low, mid);\n\n        // calling second half\n        merge_sort(mid + 1, high);\n\n        // merging the two halves\n        merge(low, mid, high);\n    }\n}\n\n// thread function for multi-threading\nvoid *\nmerge_sort123(void *arg)\n{\n    struct tsk *tsk = arg;\n    int low;\n    int high;\n\n    // calculating low and high\n    low = tsk->tsk_low;\n    high = tsk->tsk_high;\n\n    // evaluating mid point\n    int mid = low + (high - low) / 2;\n\n    if (low < high) {\n        merge_sort(low, mid);\n        merge_sort(mid + 1, high);\n        merge(low, mid, high);\n    }\n\n    return 0;\n}\n\n// Driver Code\nint\nmain(int argc, char **argv)\n{\n    char *cp;\n    struct tsk *tsk;\n\n    --argc;\n    ++argv;\n\n    MAX = 15;\n    THREAD_MAX = 4;\n\n    // use new/general algorithm by default\n    opt_a = 1;\n\n    for (; argc > 0; --argc, ++argv) {\n        cp = *argv;\n        if (*cp != '-')\n            break;\n\n        switch (cp[1]) {\n        case 'M':  // array count\n            MAX = atoi(cp + 2);\n            break;\n\n        case 'T':  // thread count\n            THREAD_MAX = atoi(cp + 2);\n            break;\n\n        case 'a':  // change algorithm\n            opt_a = !opt_a;\n            break;\n\n        case 'r':  // do _not_ use rand -- use linear increment\n            opt_r = !opt_r;\n            break;\n\n        case 't':  // tracing\n            opt_t = !opt_t;\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    // allocate the array\n    a = malloc(sizeof(int) * MAX);\n\n    // generating random values in array\n    if (opt_t)\n        printf(\"ORIG:\");\n    for (int i = 0; i < MAX; i++) {\n        if (opt_r)\n            a[i] = MAX - i;\n        else\n            a[i] = rand() % 100;\n        if (opt_t)\n            printf(\" %d\", a[i]);\n    }\n    if (opt_t)\n        printf(\"\\n\");\n\n    pthread_t threads[THREAD_MAX];\n    struct tsk tsklist[THREAD_MAX];\n\n    int len = MAX / THREAD_MAX;\n\n    if (opt_t)\n        printf(\"THREADS:%d MAX:%d LEN:%d\\n\", THREAD_MAX, MAX, len);\n\n    int low = 0;\n\n    for (int i = 0; i < THREAD_MAX; i++, low += len) {\n        tsk = &tsklist[i];\n        tsk->tsk_no = i;\n\n        if (opt_a) {\n            tsk->tsk_low = low;\n            tsk->tsk_high = low + len - 1;\n            if (i == (THREAD_MAX - 1))\n                tsk->tsk_high = MAX - 1;\n        }\n\n        else {\n            tsk->tsk_low = i * (MAX / THREAD_MAX);\n            tsk->tsk_high = (i + 1) * (MAX / THREAD_MAX) - 1;\n        }\n\n        if (opt_t)\n            printf(\"RANGE %d: %d %d\\n\", i, tsk->tsk_low, tsk->tsk_high);\n    }\n\n    // creating 4 threads\n    for (int i = 0; i < THREAD_MAX; i++) {\n        tsk = &tsklist[i];\n        pthread_create(&threads[i], NULL, merge_sort123, tsk);\n    }\n\n    // joining all 4 threads\n    for (int i = 0; i < THREAD_MAX; i++)\n        pthread_join(threads[i], NULL);\n\n    // show the array values for each thread\n    if (opt_t) {\n        for (int i = 0; i < THREAD_MAX; i++) {\n            tsk = &tsklist[i];\n            printf(\"SUB %d:\", tsk->tsk_no);\n            for (int j = tsk->tsk_low; j <= tsk->tsk_high; ++j)\n                printf(\" %d\", a[j]);\n            printf(\"\\n\");\n        }\n    }\n\n    // merging the final 4 parts\n    if (opt_a) {\n        struct tsk *tskm = &tsklist[0];\n        for (int i = 1; i < THREAD_MAX; i++) {\n            struct tsk *tsk = &tsklist[i];\n            merge(tskm->tsk_low, tsk->tsk_low - 1, tsk->tsk_high);\n        }\n    }\n    else {\n        merge(0, (MAX / 2 - 1) / 2, MAX / 2 - 1);\n        merge(MAX / 2, MAX / 2 + (MAX - 1 - MAX / 2) / 2, MAX - 1);\n        merge(0, (MAX - 1) / 2, MAX - 1);\n    }\n\n    // displaying sorted array\n    printf(\"\\n\\nSorted array:\");\n    for (int i = 0; i < MAX; i++)\n        printf(\" %d\", a[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort algorithm for stream data\r\n                \r\nI am reading about merge sort at below link \n\nhttp://www.eternallyconfuzzled.com/tuts/algorithms/jsw_tut_sorting.aspx\n\n\n  Merge sort's claim to fame is that it can easily be modified to handle\n  sequential data such as from a stream or a generator. Another huge\n  benefit is that when written carefully, merge sort does not require\n  that all items be present. It can sort an unknown number of items\n  coming in from a stream or generator, which is a very useful property.\n\n\nMy questions are\n\n1.My understanding is that merge sort requires complete array because we have to divide array in between and sort independently followed by merge.How merge sort algorithm works if not all items are present?\n\n\nGive a algorithm in simple terms how merge sort algorithm used for items coming in from a stream?\n\n    ", "Answer": "\r\nThe answers to 1 and 2 are somewhat related.\n\n\nYou can still perform a ```\nmergesort```\n with an incomplete array, which would leave you with a sorted, partially complete array.  The running time would still be ```\nO(n lg n)```\n.  As for inserting the remaining items, you could either merge the partial array with the new items, or insert the new items one at a time, q.v. part 2 below.  Inserting the remaining items one at a time would work best if the original array is nearly complete.\nAssuming you are starting with a sorted array of numbers, as new numbers came in from the stream one-by-one, you would not have to run another ```\nmergesort```\n.  Instead, you could simply walk through the sorted array in ```\nO(n)```\n time and insert each new item coming from the stream.\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Iterative Java merge sort\r\n                \r\nI am trying make an iterative version of Merge Sort for an Assignment. I got the Merge sort method from a website, and I worked on the method that is supposed to merge the arrays. However I keep getting an IndexOutOfBounds Exception.\n\nI have been working on this for multiple hours and I cannot find the error. Can someone help me find a way to solve this?\n\nSo far I have this:\n\n```\npublic static void MergeSort(int[] array) {\n    int current;\n    int leftStart;\n    int arraySize = array.length - 1;\n    for (current = 1; current <= arraySize; current = 2 * current) {\n        for (leftStart = 0; leftStart <= arraySize; leftStart += 2 * current) {\n\n            int mid = leftStart + current - 1;\n            int right = getMin(leftStart + 2 * current - 1, arraySize);\n\n            mergeArray(array, leftStart, mid, right);\n        }\n\n    }\n\n}\n\npublic static void mergeArray(int[] array, int left, int mid, int right) {\n\n    int leftArraySize = mid - left + 1;\n    int rightArraySize = right - mid;\n\n    int[] leftArray = new int[leftArraySize];\n    int[] rightArray = new int[rightArraySize];\n\n    for (int i = 0; i < leftArraySize; i++)\n        leftArray[i] = array[left + i];\n\n    for (int i = 0; i < rightArraySize; i++)\n        rightArray[i] = array[mid + 1 + i];\n\n    int leftPtr = 0;\n    int rightPtr = 0;\n    int tempPtr = leftPtr;\n\n    while (leftPtr < leftArraySize && rightPtr < rightArraySize) {\n\n        if (leftArray[leftPtr] <= rightArray[rightPtr])\n            array[tempPtr++] = leftArray[leftPtr++];\n\n        else\n            array[tempPtr++] = rightArray[rightPtr++];\n    }\n\n    while (leftPtr <= left)\n        array[tempPtr++] = leftArray[leftPtr++];\n\n    while (rightPtr < right)\n        array[tempPtr++] = rightArray[rightPtr++];\n\n}\n\npublic static int getMin(int left, int right) {\n    if (left <= right) {\n        return left;\n    } else {\n        return right;\n    }\n}\n```\n\n\nAny sort of help will be highly appreciated!\n\nThanks!\n    ", "Answer": "\r\nMerge sort algorithm is a classical  Divide and Conquer algorithm.\n\n\nDivide the problem  into smaller sub problems\nConquer via recursive calls.\nCombine solutions of sub problems into one for the original problem\n\n\nThe Pseudocode for Merge:\n\n```\nC = output[length = n]\nA = 1st sorted array[n/2]\nB = 2st sorted array[n/2]\ni = 1\nj = 1\nfor k = 1 to n\n    if A[i] < B[j]\n        C[k] = A[i]\n        i++\n    else B[j]<A[i]\n        C[k] = B[j] \n        j++\nend (ignores end cases)\n```\n\n\nSo your source code problem is this line:\n\n```\narray[tempPtr++] = leftArray[leftPtr++];\n```\n\n\nplease change to the logic of pseudocode:\n\n```\nif (leftArray [leftPtr ] <= rightArray[rightPtr ])\n{\n    array[tempPtr] = leftArray [leftPtr];\n    leftPtr++;\n}\nelse\n{\n    array[tempPtr] = rightArray[rightPtr];\n    rightPtr++;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Modified version of merge sort which uses insertion sort\r\n                \r\nAfter I have divided an array using merge sort,till the array has length k,I'm supposed to use insertion sort on the k length array and then continue with merging. What should be the optimal value of k?\n\nAlso, I found these questions similar to mine but didn't find a definite answer\nChoosing minimum length k of array for merge sort where use of insertion sort to sort the subarrays is more optimal than standard merge sort\nModification to merge sort to implement merge sort with insertion sort Java\n    ", "Answer": "\r\nJust measure. \n\nThe best threshold value depends on your programming language, data type, daata set value distribution, computer hardware, mergesort and insertion sort implementation details and so on. \n\nUsually this value is in range 10-200, and the gain for the best value is not very significant.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How external merge sort algorithm works?\r\n                \r\nI'm trying to understand how external merge sort algorithm works (I saw some answers for same question, but didn't find what I need). I'm reading the book \"Analysis Of Algorithms\" by Jeffrey McConnell and I'm trying to implement the algorithm described there.\n\nFor example, I have input data: ```\n3,5,1,2,4,6,9,8,7```\n, and I can load only 4 numbers into memory.\n\nMy first step is read the input file in 4-number chunks, sort them in memory and write one to file A and next to file B.\n\nI got:  \n\n```\nA:[1,2,3,5][7]  \nB:[4,6,8,9]\n```\n\n\nNow my question how can I merge chunks from these files to the bigger ones if they will not fit to the memory? Jeffrey McConnell wrote that I need to read half chunks and merge them to next files C and D.\n\nBut I got wrong sequence:\n\n```\nC:[1,2,4,6,3,8,5,9]\nD:[7]\n```\n\n\nCan anyone provide an example with step by step instruction, please?\n\nPS: I understand how to merge number by number by reading from file, but how do I do it with in-memory buffers to reduce I/O operations?\n    ", "Answer": "\r\nI guess after such a long time you must have got an answer. But I am still providing some example links to help someone else who hits this question.\n\nNOTE: Before looking into this link you should have an idea about Heap data structure\nTake a look at Example of Two-Way Sorting and Example of multiway external sorting and you will get a complete idea of the implementation of a external sorting algorithm\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort performance compared to insertion sort\r\n                \r\nFor any array of length greater than 10, is it safe to say that merge sort performs fewer comparisons among the array's elements than does insertion sort on the same array because the best case for the run time of merge sort is O(N log N) while for insertion sort, its O(N)?\n    ", "Answer": "\r\nMy take on this. First off, you are talking about comparisons, but there are swaps as well that matter.\n\nIn insertion sort in the worst case (an array sorted in opposite direction) you have to do ```\nn^2 - n```\n comparisons and swaps (11^2 - 11 = 121 - 11 = 110 for 11 elements, for example). But if the array is even partially sorted in needed order (I mean many elements already stay at correct positions or even not far from them), the number of swaps&comparisons may significantly drop. The right position for the element will be found pretty soon and there will be no need for performing as many actions as in case of an array sorted in opposite order. So, as you can see for ```\narr2```\n, which is almost sorted, the number of actions will become linear (in relation to the input size) - 6.\n\n\r\n\r\n```\nvar arr1 = [11,10,9,8,7,6,5,4,3,2,1];\r\nvar arr2 = [1,2,3,4,5,6,7,8,11,10,9];\r\n\r\nfunction InsertionSort(arr) {\r\n    var arr = arr, compNum = 0, swapNum = 0;\r\n    for(var i = 1; i < arr.length; i++) {\r\n        var temp = arr[i], j = i - 1;\r\n        while(j >= 0) {\r\n            if(temp < arr[j]) { arr[j + 1] = arr[j]; swapNum++; } else break;\r\n            j--;\r\n            compNum++;\r\n        }\r\n        arr[j + 1] = temp;\r\n    }\r\n    console.log(arr, \"Number of comparisons: \" + compNum, \"Number of swaps: \" + swapNum);\r\n}\r\nInsertionSort(arr1); // worst case, 11^2 - 11 = 110 actions\r\nInsertionSort(arr2); // almost sorted array, few actions```\n\r\n\r\n\r\n\n\nIn merge sort we always do aprox. ```\nn*log n```\n actions - the properties of the input array don't matter. So, as you can see in both cases we will get both of our arrays sorted in 39 actions:\n\n\r\n\r\n```\nvar arr1 = [11,10,9,8,7,6,5,4,3,2,1];\r\nvar arr2 = [1,2,3,4,5,6,7,8,11,10,9];\r\nvar actions = 0;\r\nfunction mergesort(arr, left, right) {\r\n  if(left >= right) return;\r\n  var middle = Math.floor((left + right)/2);\r\n  mergesort(arr, left, middle);\r\n  mergesort(arr, middle + 1, right);\r\n  merge(arr, left, middle, right);\r\n}\r\nfunction merge(arr, left, middle, right) {\r\n  var l = middle - left + 1, r = right - middle, temp_l = [], temp_r = [];\r\n  for(var i = 0; i < l; i++) temp_l[i] = arr[left + i];\r\n  for(var i = 0; i < r; i++) temp_r[i] = arr[middle + i + 1];\r\n  var i = 0, j = 0, k = left;\r\n  while(i < l && j < r) {\r\n    if(temp_l[i] <= temp_r[j]) {\r\n    arr[k] = temp_l[i]; i++;\r\n    } else {\r\n    arr[k] = temp_r[j]; j++;  \r\n    }\r\n  k++; actions++; \r\n  }\r\n  while(i < l) { arr[k] = temp_l[i]; i++; k++; actions++;}\r\n  while(j < r) { arr[k] = temp_r[j]; j++; k++; actions++;}\r\n}\r\nmergesort(arr1, 0, arr1.length - 1);\r\nconsole.log(arr1, \"Number of actions: \" + actions); // 11*log11 = 39 (aprox.)\r\nactions = 0;\r\nmergesort(arr2, 0, arr2.length - 1);\r\nconsole.log(arr2, \"Number of actions: \" + actions); // 11*log11 = 39 (aprox.)```\n\r\n\r\n\r\n\n\nSo, answering your question:\n\n\n  For any array of length greater than 10, is it safe to say that merge sort performs fewer comparisons among the array's elements than does insertion sort on the same array\n\n\nI would say that no, it isn't safe to say so. Merge sort can perform more actions compared to insertion sort in some cases. The size of an array isn't important here. What is important in this particular case of comparing insertion sort vs. merge sort is how far from the sorted state is your array. I hope it helps :)\n\nBTW,  merge sort and insertion sort have been united in a hybrid stable sorting algorithm called Timsort to get the best from both of them. Check it out if interested.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort using one array\r\n                \r\nMy merge sort algorithm is given below... \n\nAs we know this algorithm needs extra memory. Is there any way to do sorting with only one array? (Sorting in a single array.)\n\nMy merge sort algorithm is:\n\n```\n//LeftPos = start of left half;\n//RightPos = start of right half\nvoid  Merge(int A[ ], int LeftPos, int RightPos, int RightEnd) \n{\n    int LeftEnd = RightPos – 1;\n    int TmpPos = 1\n    int NumElements = RightEnd – LeftPos + 1;\n    int TempArray[NumElements];\n    while(leftPos <= LeftEnd && RightPos <= RightEnd)\n        if(A[LeftPos] <= A[RightPos])\n            TmpArray[TmpPos++] = A[LeftPos++];\n        else\n            TmpArray[TmpPos++] = A[RightPos++];\n    while(LeftPos <= LeftEnd)   //Copy rest of first half   \n        TmpArray[TmpPos++] = A[LeftPos++];\n    while(RightPos <= RightEnd) //Copy rest of second half      TmpArray[TmpPos++] = A[RightPos++];\n    for(int i = 1; i <= NumElements; i++) //Copy TmpArray back\n        A[LeftPos++] = TmpArray[i];\n}\n```\n\n    ", "Answer": "\r\nCheck these links:\n\nHow to sort in-place using the merge sort algorithm?\n\nJava code which will fit your question:\n\nhttps://github.com/bakeraj4/In-Place-Merge-Sort/blob/master/mergeMain.java\n\nThe technique you are looking for is \"in place\", for future searches you can use it to find better results in the internet.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Python Merge Sort Algorithm\r\n                \r\nHi I am attempting to make a Merge Sort algorithm for fun, and do not want to just copy code off the internet. Which is why I have not referred to another person's Stack Overflow thread. So unless the thread has the same issue, please do not direct me towards that. I am using 2 functions, merge and merge sort. Merge sort is recursive, I intend for it to split a list in half, and then sort each half. The merge algorithm should then take the two sorted lists and return a new list, which is just the two lists combined and sorted. Eventually the code should return a fully sorted list. Below is my code, and if you run it you will see that I am getting an empty list returned, which makes no sense to me. Any help would be greatly appreciated. Thanks :)\n```\ndef merge(left, right):\n    resultList = []\n    leastRight = 0\n    leastLeft = 0\n    if len(left) >= len(right):\n        for i in range(len(left)-1):\n            counter = 0\n            for j in range(len(right)-1):\n                counter += 1\n                if right[counter % (len(right)-1)] <= right[j]:\n                    leastRight = right[counter % (len(right)-1)]\n                    print(\"leastRight if\",leastRight)\n                else:\n                    leastRight = right[j]\n                    print(\"leastRight else\", leastRight)\n                right.remove(leastRight)\n            if left[i] <= leastRight:\n                resultList.append(left[i])\n            else:\n                resultList.append(leastRight)\n    else:\n        for i in range(len(right)-1):\n            counter = 0\n            for j in range(len(left)-1):\n                counter += 1\n                if left[counter % (len(left)-1)] <= left[j]:\n                    leastLeft = left[counter%(len(left)-1)]\n                    print(\"leastLeft if\", leastLeft)\n                else:\n                    leastLeft = left[j]\n                    print(\"leastLeft else\", leastLeft)\n                left.remove(leastLeft)\n            if right[i] <= leastLeft:\n                resultList.append(right[i])\n            else:\n                resultList.append(leastLeft)\nreturn (resultList)\n\ndef mergeSort(alist):\n\n    print(\"alist\", alist)\n    if len(alist) > 2:\n        middleIndex = len(alist) // 2\n        sortedLeft = mergeSort(alist[:middleIndex])\n        print(\"left\", sortedLeft)\n        sortedRight = mergeSort(alist[middleIndex:])\n        print(\"right\", sortedRight)\n        result = merge(sortedLeft, sortedRight)\n        print(\"result\", result)\n    else:\n        result = alist\n    return (result)\n\nprint(\"mergesort\", mergeSort([6, 0, 2, 8, 9, 1]))\n```\n\n    ", "Answer": "\r\nSorry, but approach of your merge function is not usable at all. Principle of choosing the smallest element is too tangled here and causes errors (I just saw it cannot merge [6] and [0,2]). Have you read classical description of merging?\nIn ```\nmergesort```\n (we cannot omit treatment of length 2 lists):\n```\nif len(alist)   >=    2:\n```\n\nQuick-made working implementation of merge routine.\n```\ndef merge(left, right):\n    resultlist = []\n    llen = len(left)\n    rlen = len(right)\n    il = 0\n    ir = 0\n    while il < llen and ir < rlen:  #while both list are not exhausted\n        if left[il] <= right[ir]:    #choose the smallest current item\n            resultlist.append(left[il])\n            il += 1\n        else:\n            resultlist.append(right[ir])\n            ir += 1\n       #now treat the rest tail\n    while il < llen:  \n        resultlist.append(left[il])\n        il += 1\n    while ir < rlen:\n        resultlist.append(right[ir])\n        ir += 1\n    return resultlist\n```\n\nresult\n```\n>>> mergesort [0, 1, 2, 6, 8, 9]\n```\n\nNote it would be wise to make ```\nresultlist```\n of known length for speed.\n```\ndef merge(left, right):\n    llen = len(left)\n    rlen = len(right)\n    resultlist = [0]*(llen+rlen) # we know data type and full length\n    il = 0\n    ir = 0\n    k = 0\n    while il < llen and ir < rlen:\n        if left[il] <= right[ir]:\n            resultlist[k] = left[il]\n            il += 1\n        else:\n            resultlist[k] = right[ir]\n            ir += 1\n        k += 1\n    while il < llen:\n        resultlist[k] = left[il]\n        il += 1\n        k += 1\n    while ir < rlen:\n        resultlist[k] = right[ir]\n        ir += 1\n        k += 1\n    return resultlist\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Combine merge sort and comb sort\r\n                \r\nI tried to combine comb sort and merge sort in C, so that merge sort wouldn't need to divide the sequence to the smallest unit (I mean when the length of the divisions in sequence less than a value called num, the program will immediately change to comb sort, and we can save time).\n\nHowever, the code didn't work as I expected. (It should sort the sequence I gave to 12345678). I really don't know what is wrong with it. Please help me.\n\nHere is my code\n\n```\n#include <stdio.h>\nvoid swap(int i, int j, int *data){\n     int attempt = data[i];\n     data[i] = data[j];\n     data[j] = attempt;\n}\n\nvoid comb(int n, int *data) {\n    int i, gap = n, flag = 1;\n    while (flag || gap > 1) {\n        if ((gap = gap / 1.3) < 1) {\n            gap = 1;\n        }\n        if (gap == 9 || gap == 10) {\n            gap = 11;\n        }\n        flag = 0;\n        for (i = 0; i < n - gap; i++) {\n            if (data[i] > data[i + gap]) {\n                swap(i, i + gap, data);\n                flag = 1;\n            }\n        }\n    }\n}\nvoid merge(int first, int last, int min,int *data, int *work){\n\n    int middle, mae, ato, i,j,k;\n\n    if (abs(last - first) <= min) {\n       int segment[last - first];\n    for(k = first; k <= last; k++) {segment[k-first] = data[k];}\n        comb(abs(last - first), segment);\n    for(k = first; k <= last; k++) {data[k] = segment[k - first];}\n    }\n    else{\n    middle = (first + last) / 2;\n    merge(first, middle,min, data, work);\n    merge(middle + 1, last,min, data, work);\n    i = first;\n    mae = first;\n    ato = middle + 1;\n    for(j = 0; j <= middle - first; j++) work[j] = data[j+first];\n    while (mae <= middle && ato <= last) {\n        if (work[mae-first] <= data[ato]) {\n            data[i] = work[mae-first];\n            i++;\n            mae++;\n        } else {\n            data[i] = data[ato];\n            i++;\n            ato++;\n        }\n    }\n    while (mae <= middle) {\n        data[i] = work[mae-first];\n        i++;\n        mae++;\n    }\n    while (ato <= last) {\n        data[i] = data[ato];\n        i++;\n        ato++;\n    }\n    }\n\n}\n\nint main(){\n    int arr[8] = {2,8,7,3,6,1,5,4};\n       int work[4] = {0,0,0,0};\n    int i;  \n    merge(0,7,2,arr,work);\n    for(i = 0; i < 8; i++) printf(\"%d\\n\",arr[i]);\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Implementation Check\r\n                \r\nI am doubtful of my implementation of the merge sort for two cases specifically:\n\n\n1. If the size of the list is 2, then I have swapped the values if they are not in the ascending order else I have returned them.\n\n\n2. In the merge function when the list tries to check outside the number of elements in it, I have assigned the greatest number (```\n9999```\n), so that in case of comparison with it always comes false.\n\nCan anyone tell me if the implementation of my merge sort is correct or not? As in sorting is complete, but is the implementation of merge sort exact or is it wrong because of the cases?\n\n\nHere is my code:\n\n\n```\n# unsorted LIST\nu_list = [3, 6, 8, 1, 4, 7, 2, 12, 45];\n\n# Size of the unsorted list\nglobal_size = len(u_list)\n\ndef foo(temp_list):\n    size_of_list = len(temp_list)\n    # If the size of the list is 1\n    if size_of_list == 1:\n        return temp_list\n\n    # If the size of the list is 2\n    if size_of_list == 2:\n        if temp_list[0] > temp_list[1]:\n            temp_list[0],temp_list[1] = temp_list[1],temp_list[0]\n            return temp_list\n        else: \n            return temp_list\n\n    # If the size of the list is greater than 2                \n    if size_of_list > 2:\n        count = 1\n        i = 0\n        if size_of_list % 2 == 0:\n            mid1 = size_of_list / 2\n        else:\n            mid1 = (size_of_list / 2) + 1\n\n        mid2 = size_of_list - mid1\n\n        newlist1 = list()\n        newlist2 = list()\n\n        for e in temp_list:\n            if count >= mid1 + 1:\n                newlist2.append(e)\n            else:\n                newlist1.append(e)\n            if count == size_of_list:\n                break\n            count = count + 1\n        sorted_list = list()\n        return merge(foo(newlist1), foo(newlist2))\n\n# Merging all the sorted components\ndef merge(list1, list2):\n    i = 0\n    j = 0\n    k = 0\n    size_of_list = len(list1) + len(list2)\n    sorted_list = list()\n    while k <= size_of_list - 1:\n        if i == len(list1):\n            list1.append(9999)\n        if j == len(list2):\n            list2.append(9999)\n\n        if list1[i] < list2[j]:\n            sorted_list.append(list1[i])\n            i = i + 1\n        elif list2[j] < list1[i]:\n            sorted_list.append(list2[j])\n            j = j + 1\n        k = k + 1\n    return sorted_list\n\nprint foo(u_list)\n```\n\n    ", "Answer": "\r\nTo be honest, I feel very uneasy if I see code like this ;). It may be correct, but my guts feeling sais it's not (what if there are numbers > 9999?). It is more complicated than necessary. The syntax is Python, but you are not using the power of Python.\n\nHere's how I would implement merge sort in Python:\n\n```\ndef merge_sort(sequence):\n    if len(sequence) < 2: \n        return sequence\n\n    mid = int(len(sequence) / 2)\n    left_sequence = merge_sort(sequence[:mid])\n    right_sequence = merge_sort(sequence[mid:])\n    return merge(left_sequence, right_sequence)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1 \n    result += left[i:]\n    result += right[j:]\n\n    return result\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort 3 way split C\r\n                \r\nSorry for annoying anyone here, but I'm having an issue with my merge sort code. Previously I could code the 2-way merge sort and when I tried to adapt my merge sort to be an 3-way merge sort my compiler gave me: ```\n9154 segmentation fault(core dumped)```\n. Could you help me to fix this? there is my code:             \n\n```\n#include <stdio.h>\n\nvoid merge(int v[], int p, int q, int r) {\n    int i, j, k, b[10];\n    for (i = p; i <= q; i++) {\n        b[i] = v[i];\n    }\n    for (j = q + 1; j <= r; j++) {\n        b[r + q + 1 - j] = v[j];\n    }\n    i = p;\n    j = r;\n    for (k = p; k <= r; k++) {\n        if (b[i] <= b[j]) {\n            v[k] = b[i];\n            i++;\n        } else {\n            v[k] = b[j];\n            j--;\n        }\n    }\n}\nvoid mersort(int v[], int p, int r) { //2-way mergesort that works\n    int q;\n    if (p < r) {\n        q = (p + r) / 2;\n        mersort(v, p, q);\n        mersort(v, q + 1, r);\n        merge(v, p, q, r);\n    }\n}\nvoid mersort3(int v[], int p, int r) {//not working\n    int q, s;\n    if (r > p) {\n        q = p + (p + r) / 3;\n        s = p + 2 * ((p + r) / 3) + 1;\n        mersort3(v, p, q);\n        mersort3(v, q, s);\n        mersort3(v, s, r);\n        merge(v, p, q, s);\n        merge(v, p, s, r);\n    }\n}\n```\n\n    ", "Answer": "\r\nYour main problems are due to out-of-range indexing due to improper index calculations, and potential infinite recursion for the same reason.\n\nYou're overcomplicating this tremendously. One of the beautiful advantages to C is pointer arithmetic, which makes things like sequence partitioning and traversals like this much, much simpler. As a bonus, you also get to remove one of your function arguments, as the only reason it is there is the base-adjustment, which is taken care of with the pointer arithmetic. \n\nFor example, a simple VLA-based merge algorithm (obviously, don't invoke this with a large sequence)\n\n```\n/* a simple little VLA-based merge. don't invoke with huge arrays */\nvoid merge(int v[], size_t mid, size_t len)\n{\n    if (len < 2)\n        return;\n\n    size_t i=0, j=mid, k=0;\n    int tmp[len];\n\n    while (i < mid && j < len)\n        tmp[k++] = (v[i] < v[j]) ? v[i++] : v[j++];\n\n    memcpy(tmp+k, v+i, (mid-i) * sizeof *v);\n    memcpy(v, tmp, (k + (mid-i)) * sizeof *v);\n}\n```\n\n\nWell, not a great showcase of pointer arithmetic, but there's some in there. The place where it really shines is the partitioning algorithms. For example, a simple merge sort:\n\n```\nvoid mersort(int v[], size_t len)\n{\n    if (len < 2)\n        return;\n\n    size_t mid = len/2;\n    mersort(v, mid);\n    mersort(v+mid, len-mid); // see here.\n    merge(v, mid, len);\n}\n```\n\n\nExtending this to a three-way partitioning scheme becomes:\n\n```\nvoid mersort3(int v[], size_t len)\n{\n    if (len < 3)\n    {\n        mersort(v, len);\n        return;\n    }\n\n    size_t m1 = len/3;\n    size_t m2 = (2 * len)/3;\n    mersort3(v, m1);\n    mersort3(v+m1, m2-m1);   // see here\n    mersort3(v+m2, len-m2);  // and here\n    merge(v, m1, m2);\n    merge(v, m2, len);\n}\n```\n\n\nAn example invoke that uses a guaranteed-unusual partition size is below (the sequence is 29 elements long)\n\n```\nint main()\n{\n    srand((unsigned)time(NULL));\n\n    const size_t N = 29;\n    size_t i,j;\n    int ar[N], n=0;\n\n    // build a sequence from 1..29\n    for (i=0; i<N; ++i)\n        ar[i] = ++n;\n\n    // shuffle the sequence\n    for (i=0; i<3; ++i)\n    {\n        for (j=0; j<N; ++j)\n        {\n            n = rand() % N;\n            int tmp = ar[n];\n            ar[n] = ar[j];\n            ar[j] = tmp;\n        }\n    }\n\n    // show the shuffled sequence\n    for (i=0; i<N; ++i)\n        printf(\"%d \", ar[i]);\n    fputc('\\n', stdout);\n\n    // sort it\n    mersort3(ar, N);\n\n    // show it again\n    for (i=0; i<N; ++i)\n        printf(\"%d \", ar[i]);\n    fputc('\\n', stdout);\n\n    return EXIT_SUCCESS;\n}\n```\n\n\nOutput (shuffled sequence varies)\n\n```\n21 8 11 27 18 9 17 28 20 14 15 1 29 6 19 22 7 2 16 23 5 12 4 3 10 26 13 25 24 \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merging in merge sort algorithm\r\n                \r\nI know the basic concept of the merge sort algorithm but when it comes to implementing it via recursion I am having trouble grasping how it works. From what I understand, the merge sort function splits our current array into two halves and using recursion we keep doing this until we are left with 1 element for each side.\n\nIf our array is {38, 27, 43, 3, 9, 82, 10} then our recursion will start by calling itself using the subarray (left side of the original array) and repeat the process each time, halving the array and storing the left most side until  we reach 1 element:\n\n```\n38 27 43 3 9 82 10\n38 27 43 3 <-split\n<---first subroutine/recursion\n38 27 <-split\n<---second subroutine/recursion\n38 <---only 1 element left so we return the value back to the first subroutine that called\n```\n\n\nThen in our second subroutine we move on to the next line: right = merge_sort(right) which again calls itself to split the subarray and storing the right most side:\n\n```\n38 27 <-split\n<---second subroutine/recursion\n   27\n<---only 1 element left so we return the value back to the first subroutine that called\n```\n\n\nThen in our second subroutine we move on to the next line: result = merge(left, right) which calls the merge function to sort our left and right arrays that are just 38 and 27. The merge function sorts our two values based on which is smaller and then it adds the first one to an array although I'm not sure which array. (I need specification on this; shouldn't we have a new array every time we merge two previous arrays?) Then the merge function returns the \"result\" to another result variable in our merge sort function from having called the merge function. I am assuming this result is the new array that has 38 and 27 sorted in order. Then it looks like we are returning that result again to whatever called the merge sort function but I am confused because wouldn't that end everything? What about the first subroutine that paused for the left side recursion? I'm not sure what happens to:\n\n```\n38 27 43 3\n      43 3\n      43\nand\n      43 3\n         3\n```\n\n\nPseudo-code:\n\n```\n function merge_sort(m)\n    if length(m) ≤ 1\n        return m\n    var list left, right, result\n\n\n    var integer middle = length(m) / 2\n    for each x in m up to middle\n         add x to left\n    for each x in m after middle\n         add x to right\n    left = merge_sort(left)\n    right = merge_sort(right)\n    result = merge(left, right)\n    return result\n```\n\n\nFollowing writing merge_sort function, then it is required to merge both the left and right lists created above. There are several variants for the merge() function; one possibility is this:\n\n```\nfunction merge(left,right)\n    var list result\n    while length(left) > 0 or length(right) > 0\n        if length(left) > 0 and length(right) > 0\n            if first(left) ≤ first(right)\n                append first(left) to result\n                left = rest(left)\n            else\n                append first(right) to result\n                right = rest(right)\n        else if length(left) > 0\n            append first(left) to result\n            left = rest(left)             \n        else if length(right) > 0\n            append first(right) to result\n            right = rest(right)\n    end while\n    return result\n```\n\n\nhttp://www.princeton.edu/~achaney/tmve/wiki100k/docs/Merge_sort.html\n    ", "Answer": "\r\nI'm not sure whether it is what you're looking for, but you can simplify your merge loop by replacing ```\nor```\n with ```\nand```\n in the main condition:\n\n```\nwhile length(left) > 0 and length(right) > 0\n    if first(left) ≤ first(right)\n        append first(left) to result\n        left = rest(left)\n    else\n        append first(right) to result\n        right = rest(right)\nend while\n\n# You know that one of left and right is empty\n# Copy the rest of the data from the other\nwhile length(left) > 0\n    append first(left) to result\n    left = rest(left)             \nend while\nwhile length(right) > 0\n    append first(right) to result\n    right = rest(right)\nend while\n```\n\n\nYes, there are three loops, but only one of the last two is ever executed.\n\n\n\nWorking C99 code based closely on pseudo-code\n\nThus code uses C99 variable-length arrays (an optional feature in C11).  If compiled with ```\n-DDEBUG```\n, you'll get extensive tracing while the program is running.  If compiled without, you only get the input (unsorted) and output (sorted) arrays printed.  I needed it to diagnose a stupid typo (an ```\nr_pos```\n where an ```\nl_pos```\n was clearly required).  Note the general techniques:\n\n\nDocument entry and exit from functions\nCreate a diagnostic print function (here ```\ndump_array()```\n with one argument a 'tag' (to identify which call is being used) and the other arguments the data structure to be printed.\nCall the diagnostic print function at suitable points.\nMake it easy to enable or disable diagnostics.\n\n\nFor production quality code, my diagnostic print functions also take a ```\nFILE *fp```\n argument and write to the given file; I cheated and used ```\nstdout```\n here.  The extra generality means the function can be used to write to ```\nstderr```\n or a log file as well as, or instead of, ```\nstdout```\n.\n\nSpace management\n\nThe ```\nmerge_sort()```\n code copies the complete input array into two smaller arrays (```\nleft```\n and ```\nright```\n) and then sorts the smaller arrays (recursion) and merges the sorted smaller arrays into the input array.  This happens at each of log N levels of recursion.  Some empirical testing shows that the space used is approximately 2N items — it is O(N) space usage.\n\n\n  Shouldn't we have a new array every time we merge two previous arrays?\n\n\nIn a functional programming language, you would have new arrays.  In C, you use the input array as the output array too.  The code copies the original input array into separate smaller arrays, sorts those smaller arrays, and merges the sorted smaller arrays into the original array.\n\n\n  My other question is what procedure in the code allows us to go back to before the recursion where we split the left side of our array so we can work on the right side to get 43 a 3 in order to merge them as well.\n\n\nThe splitting process creates a copy of the input array (so the information in the original data is temporarily superfluous).  The merging process copies the (now sorted) split arrays back into the original array. (Largely repeating myself.)\n\nSource\n\n```\n#include <stddef.h>\n\nextern void merge_sort(int *array, size_t arrlen);\n\n/* Debug */\n#ifdef DEBUG\nstatic void dump_array(const char *tag, int *array, size_t len);\nstatic void enter_func(const char *func);\nstatic void exit_func(const char *func);\n#else\n#define dump_array(t, a, l) ((void)0)\n#define enter_func(f)       ((void)0)\n#define exit_func(f)        ((void)0)\n#endif\n\n/*\nfunction merge(left, right)\n   var list result\n    while length(left) > 0 and length(right) > 0\n        if first(left) ≤ first(right)\n            append first(left) to result\n            left = rest(left)\n        else\n            append first(right) to result\n            right = rest(right)\n    end while\n\n    # You know that one of left and right is empty\n    # Copy the rest of the data from the other\n    while length(left) > 0\n        append first(left) to result\n        left = rest(left)             \n    end while\n    while length(right) > 0\n        append first(right) to result\n        right = rest(right)\n    end while\n    return result\nend function\n*/\n\nstatic void merge(int *left, size_t l_len, int *right, size_t r_len, int *output)\n{\n    size_t r_pos = 0;\n    size_t l_pos = 0;\n    size_t o_pos = 0;\n    enter_func(__func__);\n    dump_array(\"Left:\", left, l_len);\n    dump_array(\"Right:\", right, r_len);\n    while (r_pos < r_len && l_pos < l_len)\n    {\n        if (right[r_pos] < left[l_pos])\n            output[o_pos++] = right[r_pos++];\n        else\n            output[o_pos++] = left[l_pos++];\n    }\n    while (r_pos < r_len)\n        output[o_pos++] = right[r_pos++];\n    while (l_pos < l_len)\n        output[o_pos++] = left[l_pos++];\n    dump_array(\"Output:\", output, r_len + l_len);\n    exit_func(__func__);\n}\n\n/*\nfunction merge_sort(m)\n    if length(m) ≤ 1\n        return m\n    var list left, right, result\n\n    var integer middle = length(m) / 2\n    for each x in m up to middle\n        add x to left\n    for each x in m after middle\n        add x to right\n    left = merge_sort(left)\n    right = merge_sort(right)\n    result = merge(left, right)\n    return result\n*/\n\nvoid merge_sort(int *array, size_t len)\n{\n    if (len <= 1)\n        return;\n    int left[(len+1)/2];\n    int l_pos = 0;\n    int right[(len+1)/2];\n    int r_pos = 0;\n    size_t mid = len / 2;\n\n    enter_func(__func__);\n    dump_array(\"Input:\", array, len);\n    for (size_t i = 0; i < mid; i++)\n        left[l_pos++] = array[i];\n    for (size_t i = mid; i < len; i++)\n        right[r_pos++] = array[i];\n    dump_array(\"Left:\", left, l_pos);\n    dump_array(\"Right:\", right, r_pos);\n    merge_sort(left, l_pos);\n    merge_sort(right, r_pos);\n    merge(left, l_pos, right, r_pos, array);\n    dump_array(\"Result:\", array, len);\n    exit_func(__func__);\n}\n\n/* Test code */\n#include <stdio.h>\n\n#ifdef DEBUG\nstatic void enter_func(const char *func)\n{\n    printf(\"-->> %s\\n\", func);\n}\n\nstatic void exit_func(const char *func)\n{\n    printf(\"<<-- %s\\n\", func);\n}\n#endif\n\n/* dump_array is always used */\n#undef dump_array\n\nstatic void dump_array(const char *tag, int *array, size_t len)\n{\n    printf(\"%-8s\", tag);\n    for (size_t i = 0; i < len; i++)\n        printf(\" %2d\", array[i]);\n    putchar('\\n');\n}\n\nint main(void)\n{\n    int array[] = { 38, 27, 43, 3, 9, 82, 10 };\n    size_t arrlen = sizeof(array) / sizeof(array[0]);\n\n    dump_array(\"Before:\", array, arrlen);\n    merge_sort(array, arrlen);\n    dump_array(\"After:\", array, arrlen);\n    return 0;\n}\n```\n\n\nSample outputs\n\nNon-debugging\n\n```\nBefore:  38 27 43  3  9 82 10\nAfter:    3  9 10 27 38 43 82\n```\n\n\nDebugging\n\n```\nBefore:  38 27 43  3  9 82 10\n-->> merge_sort\nInput:   38 27 43  3  9 82 10\nLeft:    38 27 43\nRight:    3  9 82 10\n-->> merge_sort\nInput:   38 27 43\nLeft:    38\nRight:   27 43\n-->> merge_sort\nInput:   27 43\nLeft:    27\nRight:   43\n-->> merge\nLeft:    27\nRight:   43\nOutput:  27 43\n<<-- merge\nResult:  27 43\n<<-- merge_sort\n-->> merge\nLeft:    38\nRight:   27 43\nOutput:  27 38 43\n<<-- merge\nResult:  27 38 43\n<<-- merge_sort\n-->> merge_sort\nInput:    3  9 82 10\nLeft:     3  9\nRight:   82 10\n-->> merge_sort\nInput:    3  9\nLeft:     3\nRight:    9\n-->> merge\nLeft:     3\nRight:    9\nOutput:   3  9\n<<-- merge\nResult:   3  9\n<<-- merge_sort\n-->> merge_sort\nInput:   82 10\nLeft:    82\nRight:   10\n-->> merge\nLeft:    82\nRight:   10\nOutput:  10 82\n<<-- merge\nResult:  10 82\n<<-- merge_sort\n-->> merge\nLeft:     3  9\nRight:   10 82\nOutput:   3  9 10 82\n<<-- merge\nResult:   3  9 10 82\n<<-- merge_sort\n-->> merge\nLeft:    27 38 43\nRight:    3  9 10 82\nOutput:   3  9 10 27 38 43 82\n<<-- merge\nResult:   3  9 10 27 38 43 82\n<<-- merge_sort\nAfter:    3  9 10 27 38 43 82\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Logic errors in a merge sort [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Merge sorting a struct\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 8 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n```\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct points{\n        float axis[2];\n        int id;\n}Points;\n\ntypedef enum{\n        SortById,\n        SortByXAxis\n}SortType;\n\nPoints* fill_Array(char* filename, int* length);\nvoid Print_set(Points* set, int number_of_points);\nvoid mergesort(Points* set, int low, int high, int number_of_points,SortType sort);\nvoid merge(Points* set, int low, int middle, int high, int number_of_points,SortType sort);\n\nint main(int argc, char* argv[])\n{\n    int length;\n    Points *array;\n    array=fill_Array(argv[1],&length);\n    Print_set(array,length);\n    printf(\"\\n\\n\");\n    mergesort(array,0,length,length,SortById);\n    Print_set(array,length);\n    return 0;\n}\nPoints* fill_Array(char* filename,int* length)\n{\n    int i;\n    Points* array;\n    FILE* file=fopen(filename,\"r\");\n\n    if(file == NULL)\n    {\n        return NULL;\n    }\n\n    fscanf(file,\"%d\",length);\n    array=malloc(sizeof(Points)* *length);\n\n    for(i = 0; i < *length; i++)\n    {\n        fscanf(file,\"%d %f %f\", &(array+i)->id,&(array+i)->axis[0],&(array+i)->axis[1]);\n    }\n    fclose(file);\n\n    return array;\n}\n\nvoid Print_set(Points *set, int number_of_points)\n{\n    int i;\n\n    for(i = 0; i < number_of_points; i++)\n    {\n        printf(\"%d %f %f\\n\",(set+i)->id,(set+i)->axis[0],(set+i)->axis[1]);\n    }\n}\n\nvoid mergesort(Points* set,int low,int high,int number_of_points, SortType sort)\n{\n    int mid1;\n\n    if((high-low)>1)\n    {\n        mid1 = (low+high)/2;\n\n        mergesort(set, low, mid1, number_of_points, sort);\n        mergesort(set, mid1, high, number_of_points, sort);\n        merge(set, low, mid1, high, number_of_points, sort);\n\n    }\n\n}\nvoid merge(Points* set, int low, int middle, int high, int number_of_points, SortType sort)\n{\n        int leftIndex=low;\n        int rightIndex=middle;\n        int combinedIndex = low;\n        Points tempArray[number_of_points];\n        int i;\n\n        while(leftIndex <= middle && rightIndex < high)\n        {\n            if(set[leftIndex].id <= set[rightIndex].id)\n            {\n                tempArray[combinedIndex++] = set[leftIndex++];\n            }\n            else\n                tempArray[combinedIndex++] = set[rightIndex++];\n        }\n\n        if(leftIndex == middle+1)\n        {\n            while(rightIndex < high)\n            {\n                tempArray[combinedIndex++] = set[rightIndex++];\n            }\n        }\n        else\n        {\n            while(leftIndex < middle)\n            {\n                tempArray[combinedIndex++] = set[leftIndex++];\n            }\n        }\n\n        for( i = low; i < high; i++)\n        {\n            set[i] = tempArray[i];\n        }\n}\n```\n\n\nI am trying to do a merge sort however I am getting duplicates from my input file as well as it leaves out some of the values and I cannot figure out where my logic is wrong. Below is the input file that is printed out after the fill_Array function is called and then the bottom is the output after the merge sort is performed.\n\n```\n1 13.000000 7.000000\n13 14.000000 6.000000\n95 7.000000 13.000000\n39 0.000000 20.000000\n78 10.000000 10.000000\n68 3.000000 17.000000\n32 6.000000 14.000000\n10 19.000000 1.000000\n0 18.000000 2.000000\n45 17.000000 3.000000\n92 4.000000 16.000000\n29 5.000000 15.000000\n85 8.000000 12.000000\n79 15.000000 5.000000\n12 16.000000 4.000000\n32 1.000000 19.000000\n77 9.000000 11.000000\n52 12.000000 8.000000\n80 11.000000 9.000000\n31 2.000000 18.000000\n\n\n0 18.000000 2.000000\n1 13.000000 7.000000\n10 19.000000 1.000000\n0 18.000000 2.000000\n12 16.000000 4.000000\n13 14.000000 6.000000\n29 5.000000 15.000000\n31 2.000000 18.000000\n32 6.000000 14.000000\n32 1.000000 19.000000\n39 0.000000 20.000000\n39 0.000000 20.000000\n52 12.000000 8.000000\n31 2.000000 18.000000\n68 3.000000 17.000000\n77 9.000000 11.000000\n78 10.000000 10.000000\n12 16.000000 4.000000\n79 15.000000 5.000000\n85 8.000000 12.000000\n```\n\n    ", "Answer": "\r\n```\nleftIndex <= middle```\n change to ```\nleftIndex < middle```\n\nand\n```\nif(leftIndex == middle+1)```\n change to ```\nif(leftIndex == middle)```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort using one array\r\n                \r\nMy merge sort algorithm is given below... \n\nAs we know this algorithm needs extra memory. Is there any way to do sorting with only one array? (Sorting in a single array.)\n\nMy merge sort algorithm is:\n\n```\n//LeftPos = start of left half;\n//RightPos = start of right half\nvoid  Merge(int A[ ], int LeftPos, int RightPos, int RightEnd) \n{\n    int LeftEnd = RightPos – 1;\n    int TmpPos = 1\n    int NumElements = RightEnd – LeftPos + 1;\n    int TempArray[NumElements];\n    while(leftPos <= LeftEnd && RightPos <= RightEnd)\n        if(A[LeftPos] <= A[RightPos])\n            TmpArray[TmpPos++] = A[LeftPos++];\n        else\n            TmpArray[TmpPos++] = A[RightPos++];\n    while(LeftPos <= LeftEnd)   //Copy rest of first half   \n        TmpArray[TmpPos++] = A[LeftPos++];\n    while(RightPos <= RightEnd) //Copy rest of second half      TmpArray[TmpPos++] = A[RightPos++];\n    for(int i = 1; i <= NumElements; i++) //Copy TmpArray back\n        A[LeftPos++] = TmpArray[i];\n}\n```\n\n    ", "Answer": "\r\nCheck these links:\n\nHow to sort in-place using the merge sort algorithm?\n\nJava code which will fit your question:\n\nhttps://github.com/bakeraj4/In-Place-Merge-Sort/blob/master/mergeMain.java\n\nThe technique you are looking for is \"in place\", for future searches you can use it to find better results in the internet.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Heap Sort vs Merge Sort in Speed [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Quicksort superiority over Heap Sort\r\n                            \r\n                                (6 answers)\r\n                            \r\n                    \r\n                Closed 4 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nWhich algorithm is faster when iterating through a large array: heap sort or merge sort? Why is one of these algorithms faster than the other?\n    ", "Answer": "\r\nAlthough time complexity is the same, the constant factors are not. Generally merge sort will be significantly faster on a typical system with a 4 or greater way cache, since merge sort will perform sequential reads from two runs and sequential writes to a single merged run. I recall a merge sort written in C was faster than an optimized heap sort written in assembly.\n\nOne issue is that heap sort swaps data, that's two reads and two writes per swap, while merge sort moves data, one read and one write per move. \n\nThe main drawback for merge sort is a second array (or vector) of the same size as the original (or optionally 1/2 the size of the original) is needed for working storage, on a PC with 4 GB or more of RAM, this usually isn't an issue.\n\nOn my system, Intel 3770K 3.5 ghz, Windows 7 Pro 64 bit, Visual Studio 2015, to sort 2^24 = 16,777,216 64 bit unsigned integers, heap sort takes 7.98 seconds while bottom up merge sort takes 1.59 seconds and top down merge sort takes 1.65 seconds.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort using recursion\r\n                \r\nI tried to implement a recursive merge-sort, but I get a stack overflow error.\n\n```\npublic class MergeSort {\n    static int input[],mid;\n    public static void mergeSort(int input[],int start,int end ){\n        if(start>end){\n            return;\n        }\n// dividing input array into two equal parts\n        mid=(start+end)/2;\n        mergeSort(input,start,mid);\n        mergeSort(input,mid+1,end);\n        merge(input,start,mid,end);\n    }\n    public static void merge(int input[],int start,int mid,int end )\n    {\n        int l[]=new int[mid-start+1];\n        int r[]=new int[end-mid];\n        for(int i=1;i<end-start+1;i++){\n            l[i]=input[start+i-1];\n        }\n        for(int j=1;j<end-mid;j++){\n            r[j]=input[mid+j];\n        }\n\n    l[end-start+2]='\\u221e';// ASCII vlaue of infinity at the end of left array\n    r[end-mid+1]='\\u221e';//ASCII vlaue of infinity at the end of right array\n    int i=1,j=1;\n    for(int k=start;k<end;k++){\n        if(l[i]<=r[j]){\n            input[k]=l[i];\n            i=i+1;\n        }\n        else{\n            input[k]=r[j];\n            j=j+1;\n        }\n    }\n```\n\n    ", "Answer": "\r\nThe problem is your termination condition:\n\n```\n    if(start > end){\n        return;\n    }\n    // dividing input array into two equal parts\n    mid=(start+end)/2;\n    mergeSort(input,start,mid);   //  <= infinite recursion\n    mergeSort(input,mid+1,end);\n```\n\n\nIn the first recursion, there is no way to reduce ```\nmid```\n (the next ```\nend```\n value) to be less than ```\nstart```\n.  For instance, starting with the range [0, 6], here is the sequence of ```\nstart, end```\n values for the first recursive call:\n\n```\n0 6    mid = (0+6)/2 = 3\n0 3    mid = (0+3)/2 = 1\n0 1    mid = (0+1)/2 = 0\n0 0    mid = (0+0)/2 = 0\n0 0    mid = (0+0)/2 = 0\n...\n```\n\n\nYou never get to a point where ```\nstart > end```\n.  Infinite recursion.\n\nPerhaps ```\nstart >= end```\n would work for you?  That makes your base case a 1-item array, rather than an empty array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Program\r\n                \r\n```\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid merge(int a[],int l,int m,int r)\n{\n    int i,j,k;\n    int n1= m - l + 1;\n    int n2= r - m;\n    int L[n1],R[n2];\n    for(i=0;i<n1;i++)\n        L[i]=a[l+i];\n    for(j=0;j<n2;j++)\n        R[j]=a[m + 1+ j];\n    i=0;j=0;k=l;\n    while(i<n1 && j<n2)\n    {\n        if(L[i]<R[j])\n        {\n            a[k]=L[i];\n            i++;\n        }\n        else\n        {\n            a[k]=R[j];\n            j++;\n        }\n        k++;\n    }\n    while(i<n1)\n    {\n        a[k]=L[i];\n        i++;\n        k++;\n    }\n    while(j<n2)\n    {\n        a[k]=R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int a[],int l,int r)\n{\n    if(l<r)\n    {\n        int m = l+(r-1)/2;\n        mergeSort(a,l,m);\n        mergeSort(a,m+1,r);\n        merge(a,l,m,r);\n    }   \n}\n\nvoid printArray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d   \",a[i]);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int a[]= {\n                12,76,34,45,63,98\n             };\n    int n = sizeof(a)/sizeof(a[0]);\n    printf(\"The element entered in array   \");\n    printArray(a,n);\n    mergeSort(a,0,n-1);\n    printf(\"The element after sorting    \");\n    printArray(a,n);\n    return 0;\n}\n```\n\n\nThis is a merge sort program. Why it's giving runtime error if anyone can explain? There is no error in this program\n\nI have tried this 10 times. And unable to find the solution.\n    ", "Answer": "\r\nWhen you call ```\nmergesort(a, 3, 5)```\n the following happens:\n\n```\nint m = l+(r-1)/2;  // 3 + (5-1)/2 -> 3 + 4/2 -> 3 + 2 -> 5\nmergeSort(a,l,m);   // So this will call: mergesort(a, 3, 5) again\n```\n\n\nIn other words: An endless loop.\n\nMaybe you want this instead:\n\n```\nint m = (l+(r-1))/2;\n\n        ^       ^\n         notice\n```\n\n\n\n  So how did I find the bug?\n\n\nVery easy - just use some printf-debug.\n\nFirst I added a print in the start of ```\nmergesort```\n - like:\n\n```\nvoid mergeSort(int a[],int l,int r)\n{\n    printf(\"mergesort %d %d\\n\", l, r);  // Debug print\n    if(l<r)\n    {\n        int m = (l+(r-1))/2;\n        mergeSort(a,l,m);\n        mergeSort(a,m+1,r);\n        merge(a,l,m,r);\n    }   \n}\n```\n\n\nand got the output:\n\n```\nmergesort 3 5\nmergesort 3 5\nmergesort 3 5\n...\n...\n```\n\n\nwhich told me that there was an endless loop for input values 3 and 5.\n\nThen I added a print of ```\nm```\n\n\n```\nvoid mergeSort(int a[],int l,int r)\n{\n  printf(\"mergesort %d %d\\n\", l, r);\n    if(l<r)\n    {\n        int m = (l+(r-1))/2;\n        printf(\"m %d\\n\", m);\n        mergeSort(a,l,m);\n        mergeSort(a,m+1,r);\n        merge(a,l,m,r);\n    }   \n}\n```\n\n\nand got the output:\n\n```\nmergesort 3 5\nm 5\nmergesort 3 5\nm 5\nmergesort 3 5\nm 5\n```\n\n\nso obviously ```\nm```\n was calculated wrongly.\n\nLooking close at\n\n```\nint m = l+(r-1)/2;\n```\n\n\nis was clear that the addition should be before the division. A set of ```\n(....)```\n was missing.\n\nHope you can use this debug example for your own debug.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort complexity\r\n                \r\nWe know that merge sort has time complexity O(nlogn) for the below algorithm:\n\n```\nvoid mergesort(n elements) {\nmergesort(left half);  ------------ (1)\nmergesort(right half); ------------(2)\nmerge(left half, right half);\n```\n\n\nWhat will be the Time complexities for the following implementations?\n\n```\n(1)\nvoid mergesort(n elements) {\n    mergesort(first quarter);  ------------ (1)\n    mergesort(remaining three quarters); ------------(2)\n    merge(first quarter, remaining three quarters);\n\n(2)\nvoid mergesort(n elements) {\n    mergesort(first quarter);  ------------ (1)\n    mergesort(second quarter); ------------(2)\n    mergesort(third quarter);  ------------ (3)\n    mergesort(fourth quarter); ------------(4)\n    merge(first quarter, second quarter,third quarter, fourth quarter);\n```\n\n\nPlease elaborate how you find the complexities.\n    ", "Answer": "\r\nStill O (n log n) because log base 4 of n = log n / log 4, which ends up being a constant.\n\n[EDIT]\n\nThe recurence relation of the merge sort algorithm with k split is as follows. I assume that merging k sorted arrays with a total of n elements cost n log2(k), log2 representing log base 2.\n\n```\nT(1) = 0\nT(n) = n log2(k) + k T(n/k)\n```\n\n\nI could resolve the recurence relation to:\n\n```\nT(n) = n log2(n)\n```\n\n\nregardless of the value of k.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "what is threshold in merge sort?\r\n                \r\ni can not understand threshold in merge sort and how can I determine it.\ni google it but no result. can anyone explain it for me?\ni want to sort the array[50000] using merge sort, when threshold crossover using insertion sort. \n\n```\nprivate int[] MergeSort(int[] lst)\n    {\n        int hl = lst.Length - 0;\n\n        if (hl < 5 || hl < 10 || hl < 15 || hl < 20 || hl < 25 || hl < 30 || hl < 35 || hl < 40 || hl < 45 || hl < 50)\n        {\n            RunTime run = new RunTime();\n            run.X = hl;\n            InsertionSort(lst);\n            run.Ttime = Process.GetCurrentProcess().TotalProcessorTime.Milliseconds;\n\n                _listRunTime.Add(run);\n\n\n\n        }\n\n        if (lst.Length == 1)\n            return lst;\n        int middle = lst.Length / 2;\n        int[] left = new int[middle];\n        for (int i = 0; i < middle; i++)\n        {\n            left[i] = lst[i];\n        }\n        int[] right = new int[lst.Length - middle];\n        for (int i = 0; i < lst.Length - middle; i++)\n        {\n            right[i] = lst[i + middle];\n        }\n        left = MergeSort(left);\n        right = MergeSort(right);\n\n        int leftptr = 0;\n        int rightptr = 0;\n\n        int[] sorted = new int[lst.Length];\n        for (int k = 0; k < lst.Length; k++)\n        {\n            if (rightptr == right.Length || ((leftptr < left.Length) && (left[leftptr] <= right[rightptr])))\n            {\n                sorted[k] = left[leftptr];\n                leftptr++;\n            }\n            else if (leftptr == left.Length || ((rightptr < right.Length) && (right[rightptr] <= left[leftptr])))\n            {\n                sorted[k] = right[rightptr];\n                rightptr++;\n            }\n        }\n        return sorted;\n    }\n\n    private void InsertionSort(int[] arr)\n    {\n        int i, j, tmp;\n        for (i = 1; i < arr.Length; i++)\n        {\n            j = i;\n            while (j > 0 && arr[j - 1] > arr[j])\n            {\n                tmp = arr[j];\n                arr[j] = arr[j - 1];\n                arr[j - 1] = tmp;\n                j--;\n            }\n        }\n    }\n```\n\n\ni must use threshold instead of ```\nif (hl < 5 || hl < 10 || hl < 15 || hl < 20 || hl < 25 || hl < 30 || hl < 35 || hl < 40 || hl < 45 || hl < 50)```\n .\n    ", "Answer": "\r\nLook at this question that discusses this topic: Why should Insertion Sort be used after threshold crossover in Merge Sort\n\nbasically, a threshold is just a number n such that if there are n elements unsorted left after running merge sort, we switch to insertion sort.  n is pretty ambiguous I believe and you can test it out on your code to see which n optimizes performance.  So no, there is no way to determine the threshold number unless you try out a bunch of different values and test the performance.\n\nbtw isn't your huge if statement the exact same as \n\n```\nif(hl < 50) \n```\n\n\n?\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort with other data structures?\r\n                \r\nIt seems that in a lot of text books top down Merge Sort is done with arrays given its advantage of random access.\n\nI am wondering if there is a way of doing Merge Sort with other data structures? Say the data is stored in a queue or a stack, is it possible to do Merge Sort on the queue/stack with at most another auxiliary queue/stack?\n\nMy main concern is that since there is no random access, would merge sort in this case still be able to reach O(n logn) efficiency?\n    ", "Answer": "\r\nAn additional advantage of using an array with merge sort is that if you write clever (but incomprehensible) algorithm you can switch the \"scratch\" array and the \"real\" array between levels of recursive calls. In any implementation of merge sort worth its salt will allocate the \"scratch\" array only once, but with the switching technique, you only have to move your results at most once.\n\nWith stacks and queues you will likely use an array anyway as an underlying data structure. You can use linked lists, but then the constant factors in ```\npush()```\n and ```\npop()```\n or ```\nenqueue()```\n and ```\ndequeue()```\n grow larger, as you'll also have to allocate the memory for your items. Clearly, as @LearnedfromMistake shows, using stacks and queues is possible, but given that arrays are likely to be used as an underlying data structure anyway, it is not clear what the advantage of such an approach would be.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "K-way merge operation for merge sort\r\n                \r\nI have ```\nk```\n sorted arrays, each with ```\nn```\n elements, and need to combine them into a single sorted array of ```\nk*n```\n elements.\n\nHow do I implement the merging procedure for merge sort, starting with the first two and the next one and so on?\n\nThis is what I have so far.\n\n```\n// implementing function to merge arrays (merge procedure for merge sort)   \n    public  int[] merge(int[][] array){\n        int k = array.length;\n        int n = array[0].length;\n\n// final merged array\n         int[] mergedArray = new int[k*n];\n        return mergedArray;     \n    }\n\n    public static void main(String[]args){\n    Merge obj = new Merge();\nint[][] data= new int[][]{{2, 9, 15, 20},\n                              {6, 8, 9, 19},\n                              {5, 10, 18, 22},\n                              {8, 12, 15, 26}};\n    int[] mergedArrayTest = obj.merge(data);\n    //printArray(mergedArrayTest);\n  }\n```\n\n    ", "Answer": "\r\nInstead of merging the sub-arrays two at a time, you can merge all ```\nk```\n at once.\n\n\nMake an array of indices into each sub-array. Initially each index is zero.\nOn each one of ```\nk*n```\n iterations to fill the merged array, consider each sub-array's value at its respective index and remember the minimum value. (Skip an index if it has already reached the end of the sub-array.)\nIncrement the index that pointed to the minimum value.\n\n\nThis will do it:\n\n```\n// k-way merge operation\npublic int[] merge(int[][] array){\n  int k = array.length;\n  int n = array[0].length;\n\n  int[] mergedArray = new int[k*n];\n  int[] indices = new int[k];\n  for (int i = 0; i < mergedArray.length; ++i) { \n    int bestValue = -1, bestIndex = -1;\n    for (int j = 0; j < indices.length; ++j) { \n      int index = indices[j];\n      if (index < n && (bestValue == -1 || array[j][index] < bestValue)) { \n        bestValue = array[j][index];\n        bestIndex = j;\n      } \n    } \n    mergedArray[i] = bestValue;\n    indices[bestIndex] += 1;\n  }\n\n  return mergedArray;\n}\n```\n\n\nYou can make this approach somewhat more efficient by removing indices that have reached the end of their sub-array. However, that still leaves the running time in O(nk2) because O(k) indices are scanned nk times.\n\nWe can make an asymptotic improvement in running time by storing the indices in a min-heap that uses the value at each index as the key. With k indices, the size of the heap never exceeds k. In each of nk iterations, we pop the heap and push at most one element back on. These heap operations each cost O(log k), so the total running time is O(nk log k).\n\n```\nimport java.lang.*;\nimport java.util.*;\nimport java.io.*;\n\nclass Candidate {\n  int id, index, value;\n  Candidate(int id, int index, int value) {\n    this.id = id;\n    this.index = index;\n    this.value = value;\n  }\n}\n\nclass Heap {\n  ArrayList<Candidate> stack = new ArrayList<Candidate>();\n\n  void push(Candidate current) {\n    // Add to last position in heap.\n    stack.add(current);\n    // Bubble up.\n    int n = stack.size(),\n        pos = n - 1;\n    while (pos != 0) {\n      int parent = (pos - 1) / 2;\n      if (stack.get(parent).value <= current.value) {\n        return;\n      }\n      stack.set(pos, stack.get(parent));\n      stack.set(parent, current);\n    }\n  }\n\n  Candidate pop() {\n    // Get top of heap.\n    if (stack.size() == 0) {\n      return null;\n    }\n    Candidate result = stack.get(0);\n    int n = stack.size();\n    if (n == 1) {\n      stack.remove(0);\n      return result;\n    }\n    // Swap last element to top.\n    stack.set(0, stack.get(--n));\n    Candidate current = stack.get(0);\n    stack.remove(n);\n    // Bubble down.\n    int pos = 0;\n    while (true) {\n      int left = 2 * pos + 1;\n      if (left >= n) {\n        return result;\n      }\n      int right = left + 1,\n          swapTo = -1;\n      if (current.value <= stack.get(left).value) {\n        if (right == n || current.value <= stack.get(right).value) {\n          return result;\n        }\n        swapTo = right;\n      } else {\n        if (right != n && stack.get(left).value > stack.get(right).value) {\n          swapTo = right;\n        } else {\n          swapTo = left;\n        }\n      }\n      stack.set(pos, stack.get(swapTo));\n      stack.set(swapTo, current);\n      pos = swapTo;\n    }\n  }\n}\n\npublic class Merge {\n\n  // k-way merge\n  public  int[] merge(int[][] array){\n    int k = array.length;\n    int n = array[0].length;\n\n    int[] mergedArray = new int[k*n];\n\n    // Initialize heap with subarray number, index, and value.\n    Heap indexHeap = new Heap();\n    for (int i = 0; i < k; ++i) {\n      indexHeap.push(new Candidate(i, 0, array[i][0]));\n    }\n\n    for (int i = 0; i < mergedArray.length; ++i) {\n      // Get the minimum value from the heap and augment the merged array.\n      Candidate best = indexHeap.pop();\n      mergedArray[i] = best.value;\n      // Increment the index. If it's still valid, push it back onto the heap.\n      if (++best.index < array[best.id].length) {\n        best.value = array[best.id][best.index];\n        indexHeap.push(best);\n      }\n    }\n\n    // Print out the merged array for testing purposes.\n    for (int i = 0; i < mergedArray.length; ++i) {\n      System.out.print(mergedArray[i] + \" \");\n    }\n    System.out.println();\n    return mergedArray;\n  }\n\n  public static void main(String[]args){\n    Merge merge = new Merge();\n    int[][] data= new int[][]{{2, 9, 15, 20},\n                              {6, 8, 9, 19},\n                              {5, 10, 18, 22},\n                              {8, 12, 15, 26}};\n    int[] mergedArrayTest = merge.merge(data);\n  }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Application of merge sort [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nMerge sort application \n\nCan anyone tell me what does online sorting means?I could not find perfect answer.\nSource : http://en.wikipedia.org/wiki/Merge_sort\n\nThanks in advance!\n    ", "Answer": "\r\n\n  Quicksort gained widespread adoption, appearing, for example, in Unix as the default library sort function, whence it lent its name to the C standard library function qsort and in the reference implementation of Java.  \n  \n  Merge sort type algorithms allowed large data sets to be sorted on early computers that had small random access memories by modern standards. Records were stored on magnetic tape and processed on banks of magnetic tape drives . merge sort is implemented with disk drives.  \n\n\nFor more read : http://en.wikipedia.org/wiki/Merge_sort\nhttp://en.wikipedia.org/wiki/Quicksort#References\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge Sort Bug\r\n                \r\nI'm writing my own merge sort function for my own linked list class using C++. I have tested my Split_List and Merge functions and they work well. But I'm having trouble with the Merge_Sort recursive function: it can merge sort the left and right parts of the linked list but have error when finally merging the whole linked list.\n\noutput: \n\n1st list:\n[100]->[2]->[37]->[-10]->|||\n\nsorted 1st list:\n[37]->[100]->|||\n\nnode.h\n\n```\n#ifndef NODE_H\n#define NODE_H\n#include <iostream>\n\ntemplate <typename T>\nclass node{\npublic:\n    node(const T& data){item=data; link=NULL;}\n    int item;\n    node* link;\n};\n\n#endif // NODE_H\n```\n\n\nlinked_list.h\n\n```\n#ifndef Linked_List_H\n#define Linked_List_H\n#include \"node.h\"\n#include <iostream>\n\nusing namespace std;\n\ntemplate<typename T>\nclass Linked_List{\npublic:\n    Linked_List(){tail=head=NULL; count=0;}\n    void Insert_Head(const T& item);\n    void Append_Tail(const T& item);\n    void Insertion_Sort();\n    void Merge_Sort();\n    void Print();\n    int Size() {return count;}\nprivate:\n    node<T>* head;\n    node<T>* tail;\n    int count;\n    void InsertHead(node<T>* &list_head, const T& item);\n    void InsertBefore(node<T>* &list_head, node<T>* here, const T& item);\n    void Append_Tail(node<T>* &list_head, node<T>* end);\n    void Delete(node<T>* &list_head, node<T>* deleteHere);\n    node<T>* DeleteHead(node<T>* &list_head);\n    void Merge_Sort(node<T>* list_head, int size);\n    node<T>* Merge(node<T>* left, node<T>* right);\n    node<T>* Split_List(node<T>* list_head, int size);\n    void Print(node<T>* list_head);\n};\n\ntemplate<typename T>\nvoid Linked_List<T>::Merge_Sort(){\n    Merge_Sort(head, count);\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Merge_Sort(node<T>* list_head, int size){\n    int n1;\n    int n2;\n    node<T>* right_head;\n\n    if(size>1){\n        right_head=Split_List(list_head, size);\n        n1=size/2;\n        n2=size-n1;\n        Merge_Sort(list_head, n1);\n        Merge_Sort(right_head, n2);\n        head=Merge(list_head, right_head);\n    }\n}\n\ntemplate<typename T>\nnode<T>* Linked_List<T>::Split_List(node<T>* list_head, int size){\n    if (size==0){\n        return NULL;\n    }else if (size==1){\n        return list_head;\n    }else{\n        node<T>* iter=list_head;\n        node<T>* right_head=NULL;\n        int i=0;\n        while (i<size/2-1){\n            iter=iter->link;\n            i++;\n        }\n        right_head=iter->link;\n        iter->link=NULL;\n        return right_head;\n    }\n}\n\ntemplate<typename T>\nnode<T>* Linked_List<T>::Merge(node<T>* left, node<T>* right){\n    node<T>* newHead=NULL;\n    while (left!=NULL && right!=NULL){\n        if (left->item<=right->item){\n            Append_Tail(newHead, DeleteHead(left));\n        }else{\n            Append_Tail(newHead, DeleteHead(right));\n        }\n    }\n    if (left==NULL){\n        while (right!=NULL){\n            Append_Tail(newHead, DeleteHead(right));\n        }\n    }else{\n        while (left!=NULL){\n            Append_Tail(newHead, DeleteHead(left));\n        }\n    }\n    return newHead;\n}\n\n\ntemplate<typename T>\nvoid Linked_List<T>::Insertion_Sort(){\n    node<T>* end=head;\n    while (end!=NULL){\n        for (node<T>* iter=head; iter!=end; iter=iter->link){\n            if (iter->item>=end->item){\n                InsertBefore(head, iter, end->item);\n                Delete(head, end);\n                break;\n            }\n        }\n        end=end->link;\n    }\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Insert_Head(const T& item){\n    InsertHead(head, item);\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::InsertHead(node<T>* &list_head, const T& item){\n    node<T>* tempPtr=new node<T> (item);     //create new node\n    tempPtr->link=list_head;         //connect the new node to orignal 1st node\n    list_head=tempPtr;               //make the head point to the new node as the new 1st node\n    count++;\n}\n\ntemplate <typename T>\nvoid Linked_List<T>::InsertBefore(node<T>* &list_head, node<T>* here, const T& item){\n    if (list_head==NULL || list_head==here)\n    {\n        InsertHead(head, item);      //add \"head\" node\n        return;\n    }else{\n        node<T>* tempPtr=new node<T>(item);     //create new node\n\n        node<T>* previous=head;\n        while (previous->link!=here){\n            previous=previous->link;        //if the previous node cannot be found, go to the link node\n        }\n        tempPtr->link=here;                 //if the previous node is found, connect the new node to \"here\" node\n        previous->link=tempPtr;\n        count++;\n    }\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Append_Tail(const T& item){\n    if (head==NULL)\n    {\n        InsertHead(head, item);      //add \"head\" node\n        tail=head;\n    }else{\n        node<T>* tempPtr=new node<T>(item);     //create new node\n        tail->link=tempPtr;\n        tail=tail->link;\n        count++;\n    }\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Append_Tail(node<T>* &list_head, node<T>* end){\n    if (list_head==NULL)\n    {\n        end->link=list_head;         //connect the new node to orignal 1st node\n        list_head=end;               //make the head point to the new node as the new 1st node\n        count++;\n        tail=list_head;\n    }else{\n        tail->link=end;\n        tail=tail->link;\n        count++;\n    }\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Delete(node<T>* &list_head, node<T>* deleteHere){\n    node<T>* here=list_head;\n    if (here==NULL)\n    {\n        cout<<\"Empty linked list!\";             //empty linked list\n        return;\n    }\n    else{\n        node<T>* previous=list_head;\n        if (deleteHere==list_head){\n            list_head=deleteHere->link;              //if the deleted node is the 1st node, let the head point to the link node\n            count--;\n        }\n        else{\n            while (previous->link!=deleteHere){\n                previous=previous->link;        //if the previous node cannot be found, go to the link node\n            }\n            previous->link=deleteHere->link;\n            //if the previous node is found, connect the previous node to the node after the deleted node\n            count--;\n        }\n    }\n}\n\ntemplate<typename T>\nnode<T>* Linked_List<T>::DeleteHead(node<T>* &list_head){\n    node<T>* deleted=list_head;\n    list_head=list_head->link;              //if the deleted node is the 1st node, let the head point to the link node\n    count--;\n    deleted->link=NULL;\n    return deleted;\n}\n\n\ntemplate<typename T>\nvoid Linked_List<T>::Print(){\n    Print(head);\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Print(node<T>* list_head){\n    node<T>* iter;\n    for (iter=list_head; iter!=NULL; iter=iter->link){\n        cout<<\"[\"<<(iter->item)<<\"]->\";\n    }\n    cout<<\"|||\"<<endl<<endl;\n}\n\n#endif // Linked_List_H\n```\n\n\nmain.cpp\n\n```\n#include <iostream>\n#include \"linked_list.h\"\n\nusing namespace std;\n\nint main()\n{\n    Linked_List<int> list1;\n    list1.Insert_Head(-10);\n    list1.Insert_Head(37);\n    list1.Insert_Head(2);\n    list1.Insert_Head(100);\n    cout<<\"1st list: \"<<endl;\n    list1.Print();\n\n    cout<<\"sorted 1st list: \"<<endl;\n    list1.Merge_Sort();\n    list1.Print();\n}\n```\n\n    ", "Answer": "\r\nIf you add some excessive ```\nPrint```\n calls in your code, you'll see your problem. You sort the size-2 lists correctly, but in the top-level one, after:\n\n```\nMerge_Sort(list_head, n1);\nMerge_Sort(right_head, n2);\n```\n\n\n```\nlist_head```\n will be the list ```\n[100]->|||```\n and ```\nright_head```\n will be the list ```\n[37]->|||```\n. You're actually merging and sorting correctly, it's just that those pointers don't change, so you start with:\n\n```\n[100] -> [2] -> Nil\n  ^\n  list_head\n```\n\n\nAnd end up with:\n\n```\n[2] -> [100] -> Nil\n         ^\n         list_head\n```\n\n\nAnd similarly for the other list. So as far as you're concerned at that point, you're just merging two lists of size one, which you do correctly - that's how you end up with just ```\n37```\n and ```\n100```\n. \n\nThat should point you in the right direction.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge Sort Bug\r\n                \r\nI'm writing my own merge sort function for my own linked list class using C++. I have tested my Split_List and Merge functions and they work well. But I'm having trouble with the Merge_Sort recursive function: it can merge sort the left and right parts of the linked list but have error when finally merging the whole linked list.\n\noutput: \n\n1st list:\n[100]->[2]->[37]->[-10]->|||\n\nsorted 1st list:\n[37]->[100]->|||\n\nnode.h\n\n```\n#ifndef NODE_H\n#define NODE_H\n#include <iostream>\n\ntemplate <typename T>\nclass node{\npublic:\n    node(const T& data){item=data; link=NULL;}\n    int item;\n    node* link;\n};\n\n#endif // NODE_H\n```\n\n\nlinked_list.h\n\n```\n#ifndef Linked_List_H\n#define Linked_List_H\n#include \"node.h\"\n#include <iostream>\n\nusing namespace std;\n\ntemplate<typename T>\nclass Linked_List{\npublic:\n    Linked_List(){tail=head=NULL; count=0;}\n    void Insert_Head(const T& item);\n    void Append_Tail(const T& item);\n    void Insertion_Sort();\n    void Merge_Sort();\n    void Print();\n    int Size() {return count;}\nprivate:\n    node<T>* head;\n    node<T>* tail;\n    int count;\n    void InsertHead(node<T>* &list_head, const T& item);\n    void InsertBefore(node<T>* &list_head, node<T>* here, const T& item);\n    void Append_Tail(node<T>* &list_head, node<T>* end);\n    void Delete(node<T>* &list_head, node<T>* deleteHere);\n    node<T>* DeleteHead(node<T>* &list_head);\n    void Merge_Sort(node<T>* list_head, int size);\n    node<T>* Merge(node<T>* left, node<T>* right);\n    node<T>* Split_List(node<T>* list_head, int size);\n    void Print(node<T>* list_head);\n};\n\ntemplate<typename T>\nvoid Linked_List<T>::Merge_Sort(){\n    Merge_Sort(head, count);\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Merge_Sort(node<T>* list_head, int size){\n    int n1;\n    int n2;\n    node<T>* right_head;\n\n    if(size>1){\n        right_head=Split_List(list_head, size);\n        n1=size/2;\n        n2=size-n1;\n        Merge_Sort(list_head, n1);\n        Merge_Sort(right_head, n2);\n        head=Merge(list_head, right_head);\n    }\n}\n\ntemplate<typename T>\nnode<T>* Linked_List<T>::Split_List(node<T>* list_head, int size){\n    if (size==0){\n        return NULL;\n    }else if (size==1){\n        return list_head;\n    }else{\n        node<T>* iter=list_head;\n        node<T>* right_head=NULL;\n        int i=0;\n        while (i<size/2-1){\n            iter=iter->link;\n            i++;\n        }\n        right_head=iter->link;\n        iter->link=NULL;\n        return right_head;\n    }\n}\n\ntemplate<typename T>\nnode<T>* Linked_List<T>::Merge(node<T>* left, node<T>* right){\n    node<T>* newHead=NULL;\n    while (left!=NULL && right!=NULL){\n        if (left->item<=right->item){\n            Append_Tail(newHead, DeleteHead(left));\n        }else{\n            Append_Tail(newHead, DeleteHead(right));\n        }\n    }\n    if (left==NULL){\n        while (right!=NULL){\n            Append_Tail(newHead, DeleteHead(right));\n        }\n    }else{\n        while (left!=NULL){\n            Append_Tail(newHead, DeleteHead(left));\n        }\n    }\n    return newHead;\n}\n\n\ntemplate<typename T>\nvoid Linked_List<T>::Insertion_Sort(){\n    node<T>* end=head;\n    while (end!=NULL){\n        for (node<T>* iter=head; iter!=end; iter=iter->link){\n            if (iter->item>=end->item){\n                InsertBefore(head, iter, end->item);\n                Delete(head, end);\n                break;\n            }\n        }\n        end=end->link;\n    }\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Insert_Head(const T& item){\n    InsertHead(head, item);\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::InsertHead(node<T>* &list_head, const T& item){\n    node<T>* tempPtr=new node<T> (item);     //create new node\n    tempPtr->link=list_head;         //connect the new node to orignal 1st node\n    list_head=tempPtr;               //make the head point to the new node as the new 1st node\n    count++;\n}\n\ntemplate <typename T>\nvoid Linked_List<T>::InsertBefore(node<T>* &list_head, node<T>* here, const T& item){\n    if (list_head==NULL || list_head==here)\n    {\n        InsertHead(head, item);      //add \"head\" node\n        return;\n    }else{\n        node<T>* tempPtr=new node<T>(item);     //create new node\n\n        node<T>* previous=head;\n        while (previous->link!=here){\n            previous=previous->link;        //if the previous node cannot be found, go to the link node\n        }\n        tempPtr->link=here;                 //if the previous node is found, connect the new node to \"here\" node\n        previous->link=tempPtr;\n        count++;\n    }\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Append_Tail(const T& item){\n    if (head==NULL)\n    {\n        InsertHead(head, item);      //add \"head\" node\n        tail=head;\n    }else{\n        node<T>* tempPtr=new node<T>(item);     //create new node\n        tail->link=tempPtr;\n        tail=tail->link;\n        count++;\n    }\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Append_Tail(node<T>* &list_head, node<T>* end){\n    if (list_head==NULL)\n    {\n        end->link=list_head;         //connect the new node to orignal 1st node\n        list_head=end;               //make the head point to the new node as the new 1st node\n        count++;\n        tail=list_head;\n    }else{\n        tail->link=end;\n        tail=tail->link;\n        count++;\n    }\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Delete(node<T>* &list_head, node<T>* deleteHere){\n    node<T>* here=list_head;\n    if (here==NULL)\n    {\n        cout<<\"Empty linked list!\";             //empty linked list\n        return;\n    }\n    else{\n        node<T>* previous=list_head;\n        if (deleteHere==list_head){\n            list_head=deleteHere->link;              //if the deleted node is the 1st node, let the head point to the link node\n            count--;\n        }\n        else{\n            while (previous->link!=deleteHere){\n                previous=previous->link;        //if the previous node cannot be found, go to the link node\n            }\n            previous->link=deleteHere->link;\n            //if the previous node is found, connect the previous node to the node after the deleted node\n            count--;\n        }\n    }\n}\n\ntemplate<typename T>\nnode<T>* Linked_List<T>::DeleteHead(node<T>* &list_head){\n    node<T>* deleted=list_head;\n    list_head=list_head->link;              //if the deleted node is the 1st node, let the head point to the link node\n    count--;\n    deleted->link=NULL;\n    return deleted;\n}\n\n\ntemplate<typename T>\nvoid Linked_List<T>::Print(){\n    Print(head);\n}\n\ntemplate<typename T>\nvoid Linked_List<T>::Print(node<T>* list_head){\n    node<T>* iter;\n    for (iter=list_head; iter!=NULL; iter=iter->link){\n        cout<<\"[\"<<(iter->item)<<\"]->\";\n    }\n    cout<<\"|||\"<<endl<<endl;\n}\n\n#endif // Linked_List_H\n```\n\n\nmain.cpp\n\n```\n#include <iostream>\n#include \"linked_list.h\"\n\nusing namespace std;\n\nint main()\n{\n    Linked_List<int> list1;\n    list1.Insert_Head(-10);\n    list1.Insert_Head(37);\n    list1.Insert_Head(2);\n    list1.Insert_Head(100);\n    cout<<\"1st list: \"<<endl;\n    list1.Print();\n\n    cout<<\"sorted 1st list: \"<<endl;\n    list1.Merge_Sort();\n    list1.Print();\n}\n```\n\n    ", "Answer": "\r\nIf you add some excessive ```\nPrint```\n calls in your code, you'll see your problem. You sort the size-2 lists correctly, but in the top-level one, after:\n\n```\nMerge_Sort(list_head, n1);\nMerge_Sort(right_head, n2);\n```\n\n\n```\nlist_head```\n will be the list ```\n[100]->|||```\n and ```\nright_head```\n will be the list ```\n[37]->|||```\n. You're actually merging and sorting correctly, it's just that those pointers don't change, so you start with:\n\n```\n[100] -> [2] -> Nil\n  ^\n  list_head\n```\n\n\nAnd end up with:\n\n```\n[2] -> [100] -> Nil\n         ^\n         list_head\n```\n\n\nAnd similarly for the other list. So as far as you're concerned at that point, you're just merging two lists of size one, which you do correctly - that's how you end up with just ```\n37```\n and ```\n100```\n. \n\nThat should point you in the right direction.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "sorting via Merge Sort algorithm\r\n                \r\nThis is the merge sort program. I traced this program and found that after sorting the first four elements of array, the recursive call to sort function with left array with elements 4,6 again gets executed which increments 'k' to upper bound and throws ArrayIndexOutofBound index. I am not able to figure out the complete flow. please help.\n\n```\n    class MergeSort\n{\nstatic int k=0;\nstatic int a[]={2,1,4,6,8,5,3,9};\n\npublic static void main(String args[])\n{\n\nint i;\nSystem.out.println(\"Before\");\nfor(i=0;i<a.length;i++)\n{\nSystem.out.print(a[i]+\" \");\n}\nSystem.out.println(\"\\n\");\n\nsort(a);\n\nSystem.out.println(\"\\nAfter\");\nfor(i=0;i<a.length;i++)\n{\nSystem.out.print(a[i]+\" \");\n}\nSystem.out.println(\"\\n\");\n}\n\npublic static void sort(int b[])\n{\n\nint n=b.length;\n\nif(n<2)\nreturn;\n\nint mid=n/2;\nint left[]=new int[mid];\nint right[]=new int[n-mid];\nint i;\n\nSystem.out.print(\"left \");\nfor(i=0;i<mid;i++)\n{\nleft[i]=b[i];\nSystem.out.print(left[i]+\" \");\n}\nSystem.out.println();\nSystem.out.print(\"right \");\nfor(i=mid;i<n;i++)\n{\nright[i-mid]=b[i];\nSystem.out.print(right[i-mid]+\" \");\n}\nSystem.out.println(\"\\n\");\n\nsort(left);\nsort(right);\nmerge(left,right);\n}\n\npublic static void merge(int l[], int r[])\n{\n\nint i=0;\nint j=0;\n\nwhile(i<l.length && j<r.length)\n{\n\nif(l[i] < r[j]){\na[k]=l[i];\nSystem.out.println(\"a[\"+k+\"]=\"+a[k]);\ni++;\n}\nelse\n{\na[k]=r[j];\nSystem.out.println(\"a[\"+k+\"]=\"+a[k]);\nj++;\n}\nk++;\n}\nwhile(i<l.length)\n{\na[k]=l[i];\nSystem.out.println(\"a[\"+k+\"]=\"+a[k]);\ni++;\nk++;\n}\nwhile(j<r.length)\n{\na[k]=r[j];\nSystem.out.println(\"a[\"+k+\"]=\"+a[k]);\nj++;\nk++;\n\n}\n}\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort with help Iterators\r\n                \r\nI develop merge sort, which can use only iterator (it is a statement of the problem). Output of my function is generator.\n\nI write merge sort function:\n\n```\ndef merge_sort(data):\n    data1, data2 = itertools.tee(data)\n\n    counter = 0\n    for i in data1:\n        counter += 1\n\n    if counter < 2:\n        return data2\n\n    middle = int(counter / 2)\n\n    y = itertools.islice(data2, 0, middle)\n    z = itertools.islice(data2, middle, counter)\n\n    sorted_y = merge_sort(y)\n    sorted_z = merge_sort(z)\n\n    return heapq.merge(sorted_y, sorted_z)\n```\n\n\nI test my function:\n\n```\ndef main():\n    unsorted_list = [10, 3, 5, 0, 1, -5, 6, 2]\n\n    result = merge_sort(iter(unsorted_list))\n\n    for i in result:\n        print(i)\n```\n\n\nBut It does not work. I only get the number 10. Where I did the mistake?\n    ", "Answer": "\r\nThis is a right function:\n\n```\ndef merge_sort(data):\n    data1, data2, data3 = itertools.tee(data, 3)\n\n    counter = 0\n    for i in data1:\n        counter += 1\n\n    if counter < 2:\n        return data3\n\n    middle = int(counter / 2)\n\n    y = itertools.islice(data2, 0, middle)\n    z = itertools.islice(data3, middle, counter)\n\n    sorted_y = merge_sort(y)\n    sorted_z = merge_sort(z)\n\n    return merge(sorted_y, sorted_z)\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Understanding the sort part of Java Merge sort\r\n                \r\nI understand how the merge part of the merge sort works, however, for some reason I just cannot wrap my head around the recursive/divide part that occurs before the merge function is called. Using the sample code below, I tried tracing the value of different variables but could not fully understand what is happening.\n\n```\npublic void sort(int arr[], int l, int r) { \n    if (l < r) \n    { \n        // Find the middle point \n        int m = (l+r)/2; \n\n        // Sort first and second halves \n        sort(arr, l, m); \n        sort(arr , m+1, r); \n\n        // Merge the sorted halves \n        merge(arr, l, m, r); \n    } \n```\n\n\n} \n\nTo me it seems like m keeps getting passed into sort until it becomes 0, so it seems like the 2nd sort() call and the merge() call never execute. Can someone explain the steps that are taken?\n    ", "Answer": "\r\nTake the following array:\n\n```\n[4][2][5][1][3]\n```\n\n\nWe're going to split it in half:\n\n```\n[4][2][5]    [1][3]\n```\n\n\nAnd again:\n\n```\n[4][2]    [5]    [1]    [3]\n```\n\n\nAnd again:\n\n```\n[4]    [2]    [5]    [1]    [3]\n```\n\n\nNotice how we now have 5 sorted arrays (each of length 1). Now it's time to merge them together, sorting as we go. It's a very simple (read: low time-complexity) operation to merge two sorted arrays into a new sorted array:\n\n```\n[2][4]    [1][5]    [3]\n```\n\n\nNow we have 3 sorted arrays. Let's merge them again:\n\n```\n[1][2][4][5]    [3]\n```\n\n\nAnd one final time:\n\n```\n[1][2][3][4][5]\n```\n\n\nIt's now been sorted.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Stack based merge sort C [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm having trouble converting a recursive based merge sort to a stack based merge sort. Having double recursive calls in a function throws me off. I'm not sure how I'm supposed to approach this.\n    ", "Answer": "\r\nYou can implement ```\nmergesort```\n iteratively, merging adjacent slices of 2^k elements, from k=0 until 2^k >= n. It is quite straightforward, there is no need for a stack conversion of the recursive algorithm.\n\nYou will need extra space to perform this, typically the same size as the dataset.  You can allocate this space with ```\nmalloc```\n or use automatic storage if that's not too large (stack based allocation).  But this memory requirement is similar to that of the recursive implementation.\n\nMerging slices of 2^k elements is slightly less efficient if the total number of elements is not a power of 2, and it performs more comparisons and uses upto twice as much memory but the overall complexity is still O(n*log(n)) in the worst case, and a clever implementation can bring it down to O(n) for the sorted case.\n\nTry this approach, I will post some code after you show your own attempts.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort list java\r\n                \r\nThe output of this code is always the last digit of the input.\nCannot find the reason.I use merge sort recursively, and the result is wrong. I thought maybe the list being overlapped.\n\n```\npublic class MergeSort {\n    public static List<Integer> Sort(List<Integer> list) {\n        if (list.size() <= 1) {\n            return list;\n        }\n        List<Integer> aList = new ArrayList<Integer>();\n        aList = list.subList(0, list.size() / 2);\n\n        List<Integer> bList = new ArrayList<Integer>();\n        bList = list.subList(list.size() / 2, list.size());\n\n        Sort(aList);\n        Sort(bList);\n\n        merge(aList, bList, list);\n        return list;\n    }\n\n    private static List<Integer> merge(List<Integer> alist,\n        List<Integer> blist, List<Integer> list) {\n        int alistIndex = 0, blistIndex = 0, listIndex = 0;\n        while (alistIndex < alist.size() && blistIndex < blist.size()) {\n            if (alist.get(alistIndex) < blist.get(blistIndex)) {\n                list.set(listIndex, alist.get(alistIndex));\n                alistIndex++;\n            } else {\n                list.set(listIndex, blist.get(blistIndex));\n                blistIndex++;\n            }\n            listIndex++;\n        }\n        List<Integer> rest;\n        if (alistIndex == alist.size()) {\n            rest = blist.subList(blistIndex, blist.size());\n            for(int c = blistIndex; c < rest.size(); c++){\n                list.set(listIndex, blist.get(c));\n                listIndex++;\n            }\n        } else {\n            rest = alist.subList(alistIndex, alist.size());\n            for(int c = alistIndex; c < rest.size(); c++){\n                list.set(listIndex, alist.get(c));\n                listIndex++;\n            }\n        }\n        return list;\n    }\n}\n```\n\n\nThe test input is 5, 4, 3, 2, 1.\nBut the output is 1, 1, 1, 1, 1.\nSo, there must have some wrong with this merge method\n    ", "Answer": "\r\nThe quick fix to your problem is replacing:\n\n```\nList<Integer> aList = new ArrayList<Integer>();\naList = list.subList(0, list.size() / 2);\n\nList<Integer> bList = new ArrayList<Integer>();\nbList = list.subList(list.size() / 2, list.size());\n```\n\n\nwith:\n\n```\nList<Integer> aList = new ArrayList<Integer>(list.subList(0, list.size() / 2));\nList<Integer> bList = new ArrayList<Integer>(list.subList(list.size() / 2, list.size()));\n```\n\n\nYou create new ```\nArrayList```\ns for your partitions then immediately change the reference to a view of your original list.\n\n\n\nThe partitioning of the list is being done correctly, however, because you are using the view instead of the shallow copies, during the merge you are changing your partitions.\n\nUsually if you are doing a sort that mutates the original list, you don't return anything from that method, so something like:\n\n```\npublic class MergeSort {\n  public static void sort(List<Integer> list) {\n    if (list.size() < 2) {\n      return;\n    }\n    int mid = list.size()/2;\n    List<Integer> left = new ArrayList<Integer>(list.subList(0, mid));\n    List<Integer> right = new ArrayList<Integer>(mid, list.size()));\n\n    sort(left);\n    sort(right);\n    merge(left, right, list);\n  }\n\n  private static void merge(\n      List<Integer> left, List<Integer> right, List<Integer> list) {\n    int leftIndex = 0;\n    int rightIndex = 0;\n    int listIndex = 0;\n\n    while (leftIndex < left.size() && rightIndex < right.size()) {\n      if (left.get(leftIndex) < right.get(rightIndex)) {\n        list.set(listIndex++, left.get(leftIndex++));\n      } else {\n        list.set(listIndex++, right.get(rightIndex++));\n      }\n    }\n    while (leftIndex < left.size()) {\n      list.set(listIndex++, left.get(leftIndex++));\n    }\n    while (rightIndex < right.size()) {\n      list.set(listIndex++, right.get(rightIndex++));\n    }\n  }\n}\n```\n\n\n\n\nThe alternative where the original list isn't mutated could be:\n\n```\npublic class MergeSort {\n  public static List<Integer> sorted(List<Integer> list) {\n    if (list.size() < 2) {\n      return list;\n    }\n    int mid = list.size()/2;\n    return merged(\n        sorted(list.subList(0, mid)), \n        sorted(list.subList(mid, list.size())));\n  }\n\n  private static List<Integer> merged(List<Integer> left, List<Integer> right) {\n    int leftIndex = 0;\n    int rightIndex = 0;\n    List<Integer> merged = new ArrayList<Integer>();\n\n    while (leftIndex < left.size() && rightIndex < right.size()) {\n      if (left.get(leftIndex) < right.get(rightIndex)) {\n        merged.add(left.get(leftIndex++));\n      } else {\n        merged.add(right.get(rightIndex++));\n      }\n    }\n    merged.addAll(left.subList(leftIndex, left.size()));\n    merged.addAll(right.subList(rightIndex, right.size()));\n    return merged;\n  }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Multithreaded merge sort Stack Overflow error\r\n                \r\nI'm trying to make a multithreaded merge sort and I've encountered a stack overflow error and I'm not sure what is causing it. \n\n```\npublic static void concurrentMergeSort(int[] arr, int threadCount) {\n    if(threadCount <= 1){\n        regularMergeSort(arr);\n        return;\n    }\n    int middle = arr.length/2;\n    int[] left = Arrays.copyOfRange(arr, 0, middle); //Says error here\n    int[] right = Arrays.copyOfRange(arr, middle, arr.length);\n    concurrentMergeSort(left);//Says error here\n    concurrentMergeSort(right);\n    Thread leftSort = new Thread(new Sorting(left, threadCount));\n    Thread rightSort = new Thread(new Sorting(right, threadCount));\n\n    try{\n        leftSort.join();\n        rightSort.join();\n    }\n    catch (Exception ex){\n        ex.printStackTrace();\n    }\n    merge(arr, left, right);\n}\npublic static void regularMergeSort(int[] arr){\n    if(arr.length == 1){\n        return;\n    }\n    int middle = arr.length/2;\n    int[] left = Arrays.copyOfRange(arr, 0, middle);\n    int[] right = Arrays.copyOfRange(arr, middle, arr.length);\n    regularMergeSort(left);\n    regularMergeSort(right);\n    merge(arr, left, right);\n}\n```\n\n\n}\n\nI was thinking that maybe it was the thread count never decreasing, but when I modify the thread count I still get the same result. Also it was working until I added a regular merge sort and concurrent merge sort to separate it. I only added the regular merge sort as well because I was barely getting a speed increase from just having the concurrent merge sort method and the main purpose of this modification of merge sort is to increase the time it takes to sort with multithreading. \n    ", "Answer": "\r\nYour return condition from regularMergeSort is:\n\n```\nif(arr.length == 1)\n```\n\n\nWhen middle = 0, you will end up creating an empty array; and this terminating condition won't be hit, and there will be infinite loop. Change this condition to:\n\n```\nif(arr.length <= 1)\n```\n\n\nAnd assuming your merge function handles empty arrays, you should be good.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "In-place merge sort practical usage\r\n                \r\nI tried search here and there to find what exactly in-place merge sort and where I need to use it ? But not found a straight answer. Please help me by answering below.\n\n1) When and where in-place merge is required ? Practical usage of in-place merge.\n\n2) What happens if the input arrays to the in-place merge is not sorted ?\n\n3) Which eats more memory to sort among Merge sort, in-place merge sort and quick sort ?\n\nNote : I am asking regarding \"std::inplace_merge\" which is an stl algorithm. \n    ", "Answer": "\r\n1) In-place merge sort is used when you want to sort a list in O(nlogn) time while using less space than standard mergesort. \n\n2) The whole purpose of sorting is the make the input arrays sorted, so not sorted input arrays will be sorted by the in-place mergesort.\n\n3) Mergesort uses more memory because it creates two new arrays of half size for the two recursive calls. In-place merge sort and quick sort should take around the same space, because they are both in-place. For mergesort, in-place means O(log n) extra space from keeping the relevant indices of the array of length n, not the strictest O(1) meaning of in-place. Quicksort takes O(nlogn) extra space in the worst case because there can be O(n) recursive calls, each of which has pointers which take space O(logn).\n\nHope this helps.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "In-Place Merge Sort\r\n                \r\nI'm having a little bit of trouble coming up with a working in-place merge sort. Does anyone have any algorithms or tips that can help me get started?\n    ", "Answer": "\r\nmergesort.cpp\n\n```\n#include \"mergesort.h\"\n#include <limits>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nvoid merge_sort(int *data, int start, int end){\n    if (start < end){\n        int middle = int((end + start) / 2);\n        merge_sort(data, start, middle);\n        merge_sort(data, middle+1, end);\n        merge(data, start, middle+1, end);\n    }\n}\n\n\nvoid merge(int *data, int start, int middle, int end){\n    int left[middle-start+1];\n    for (int l_cnt=0; l_cnt<middle-start; l_cnt++){\n        left[l_cnt] = data[start+l_cnt];\n    }\n    left[middle-start] = numeric_limits<int>::max();\n    int right[end-middle+2];\n    for (int r_cnt=0; r_cnt<end-middle+1; r_cnt++){\n        right[r_cnt] = data[middle+r_cnt];\n    }\n    right[end-middle+1] = numeric_limits<int>::max();\n    int i = 0;\n    int j = 0;\n    for (int k=start; k<=end; k++){\n        if (left[i] < right[j]){\n            data[k] = left[i];\n            i++;\n        }\n        else{\n            data[k] = right[j];\n            j++;\n        }\n    }\n}\n```\n\n\nmergesort.h\n\n```\n#ifndef INSERTIONSORT_H_\n#define INSERTIONSORT_H_\nvoid merge_sort(int *data, int start, int end);\nvoid merge(int *data, int start, int middle, int end);\n#endif\n```\n\n\nAnd unittest file\n\n```\n#include \"mergesort.h\"\n#include \"gtest/gtest.h\"\n\ntemplate<typename T, size_t size>\n    ::testing::AssertionResult ArraysMatch(const T (&expected)[size],\n                                           const T (&actual)[size]){\n        for (size_t i(0); i < size; ++i){\n            if (expected[i] != actual[i]){\n                return ::testing::AssertionFailure() << \"array[\" << i\n                    << \"] (\" << actual[i] << \") != expected[\" << i\n                    << \"] (\" << expected[i] << \")\";\n            }\n        }\n        return ::testing::AssertionSuccess();\n}\n\nnamespace{\n    class MergeSortTest : public ::testing::Test{\n        protected:\n            MergeSortTest() {}\n            virtual ~MergeSortTest() {}\n            virtual void SetUp() {}\n            virtual void TearDown() {}\n    };\n\n    TEST(MergeSortTest, MergeTwo){\n        int raw_array[] = {6,0,5,2,4,1,9,7};\n        merge(raw_array, 2, 3, 3);\n        int sorted_array[] = {6,0,2,5,4,1,9,7};\n        EXPECT_TRUE(ArraysMatch(sorted_array, raw_array));\n    }\n\n    TEST(MergeSortTest, MergeFive){\n        int raw_array[] = {6,0,2,5,1,4,9,7};\n        merge(raw_array, 2, 4, 6);\n        int sorted_array[] = {6,0,1,2,4,5,9,7};\n        EXPECT_TRUE(ArraysMatch(sorted_array, raw_array));\n    }\n\n    TEST(MergeSortTest, SortTwo){\n        int raw_array[] = {5, 2};\n        int sorted_array[] = {2, 5};\n        merge_sort(raw_array, 0, 1);\n        EXPECT_TRUE(ArraysMatch(sorted_array, raw_array));\n    }\n\n    TEST(MergeSortTest, SortThree){\n        int raw_array[] = {5, 2, 4};\n        int sorted_array[] = {2, 4, 5};\n        merge_sort(raw_array, 0, 2);\n        EXPECT_TRUE(ArraysMatch(sorted_array, raw_array));\n    }\n\n    TEST(MergeSortTest, Five){\n        int raw_array[] = {5, 2, 4, 1, 9};\n        int sorted_array[] = {1, 2, 4, 5, 9};\n        merge_sort(raw_array, 0, 4);\n        EXPECT_TRUE(ArraysMatch(sorted_array, raw_array));\n    }\n}\n\nint main(int argc, char **argv){\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Stable Merge sort C\r\n                \r\nI am writing a simple merge sort function to sort based on a given compar function:\n\n```\nvoid merge(int left, int mid, int right, int(*compar)(const void *, const void *))\n{\n  // sublist sizes\n  int left_size = mid - left + 1;\n  int right_size = right - mid;\n\n  // counts\n  int i, j, k;\n\n  // create left and right arrays\n  B *left_list = (B*) malloc(left_size*sizeof(B));\n  B *right_list = (B*) malloc(right_size*sizeof(B));\n\n  // copy sublists, could be done with memcpy()?\n  for (i = 0; i < left_size; i++)\n    left_list[i] = list[left + i];\n\n  for (j = 0; j < right_size; j++)\n    right_list[j] = list[mid + j + 1];\n\n  // reset counts\n  i = 0; j = 0;\n\n  for (k = left; k <= right; k++)\n  {\n    if (j == right_size)\n      list[k] = left_list[i++];\n    else if (i == left_size)\n      list[k] = right_list[j++];\n    // here we call the given comparision function\n    else if (compar(&left_list[i], &right_list[j]) < 0)\n      list[k] = left_list[i++];\n    else\n      list[k] = right_list[j++];\n  }\n}\n\nvoid sort(int left, int right, int(*compar)(const void *, const void *))\n{\n  if (left < right)\n  {\n    // find the pivot point\n    int mid = (left + right) / 2;\n\n    // recursive step\n    sort(left, mid, compar);\n    sort(mid + 1, right, compar);\n\n    // merge resulting sublists\n    merge(left, mid, right, compar);\n  }\n}\n```\n\n\nI am then calling this several times on the same list array using different comparison functions. I am finding that the sort is stable for the first call, but then after that I see elements are swapped even though they are equal.\n\nCan anyone suggest the reason for this behaviour?\n    ", "Answer": "\r\nI'm not sure if this will do it but try changing this line:\n\n```\ncompar(&left_list[i], &right_list[j]) < 0\n```\n\n\nto this:\n\n```\ncompar(&left_list[i], &right_list[j]) <= 0\n```\n\n\nThis will make it so that if they are already equal it does the first action which will (hopefully) preserve the stability rather than moving things around.\n\nThis is just a guess though.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort algorithm: std::out_of_range\r\n                \r\nI am currently making a merge sort algorithm but when i run the code i get an error says \"terminate called after throwing an instance of 'std::out_of_range\". This is my code.\n```\ntemplate<typename T>\nvoid merge(std::vector<T> &vec, int l, int m, int r){\n    int i = l;\n    int j = m + 1;\n    int k = l;\n    \n    //CREATE TEMPORARY MEMORY\n    int temp[vec.size()];\n\n    while(vec.at(i) <= m && j <= r){\n        if(vec.at(i) <= vec.at(j)){\n            temp[k] = vec.at(i);\n            i++;\n            k++;\n        }else{\n            temp[k] = vec.at(j);\n            j++;\n            k++;\n        }\n    }\n    while (i <= m){ //first half: Copy the remaining elements of first half, if there are any\n        temp[k] = vec.at(i);\n        i++;\n        k++;\n    }\n    while (j <= r){ //second half: Copy the remaining elements of second half, if there are any \n        temp[k] = vec.at(j);\n        j++;\n        k++;\n    }\n    for(size_t p = 1; p <= r; p++){ //copy temp array to original array\n        vec.at(p) = temp[k];\n    }\n}\n```\n\nMerge Sort Function\n```\ntemplate<typename T>\nvoid mergeSort(std::vector<T> &vec, int l, int r){\n    if(l < r){ \n        int m = (l + r) / 2; //find midpoint\n        mergeSort(vec, l, m); //first half\n        mergeSort(vec, m + 1, r); //second half\n        merge(vec, l, m, r); // merge\n    }\n}\n```\n\n    ", "Answer": "\r\nA few issues in your ```\nmerge```\n function (which you can spot easily through debugging):\n\n```\nvec.at(i) <= m```\n compares a value with an index. These two are unrelated. So change:\n```\nwhile(vec.at(i) <= m && j <= r){ \n```\n\nwith:\n```\nwhile(i <= m && j <= r){ \n```\n\n\nThe final loop starts with ```\np = 1```\n which is an index that in many cases is out of the range that is being merged. So change:\n```\nfor(size_t p = 1; p <= r; p++){\n```\n\nwith:\n```\nfor(size_t p = l; p <= r; p++){\n```\n\n\nThe body of that same loop uses ```\nk```\n as index, but that variable is unrelated to the loop, and has a value that is out of the range that is under consideration. So change:\n```\nvec.at(p) = temp[k];\n```\n\nwith:\n```\nvec.at(p) = temp[p];\n```\n\n\n\nWith those changes your code will work.\nHowever, it is a pity that ```\ntemp```\n always has the size of the complete vector, while you only use a subsection of it. Consider reducing the memory usage.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why Parallel Merge sort runs faster with single thread?\r\n                \r\nI have the following Parallel Merge sort algorithm in openMP. OpenMP creates 8 threads by default, but it is way slower than sequential. But when I specify omp_set_num_threads(1), i.e. set number of threads to one, the time is faster than the sequential one. Any plausible explanation to this?\n\n```\nvoid para_merge_sort(int para_arr[], int low, int high)\n{\n    if (low < high)\n    {\n        int med = low + (high-low)/2;\n        #pragma omp task firstprivate(para_arr, low, med)\n        para_merge_sort (para_arr, low, med);\n        #pragma omp task firstprivate(para_arr, med, high)\n        para_merge_sort (para_arr, med+1, high);\n        #pragma omp taskwait\n        merge (para_arr, low, med, high);\n    }\n}\n\nvoid merge_sort()\n{\n    int seq_arr[MAX], para_arr[MAX];\n    omp_set_num_threads(1);\n\n    for (int i=0; i<MAX; ++i)\n        seq_arr[i] = para_arr[i] = rand()%100;\n\n    double start_time = omp_get_wtime();\n    seq_merge_sort(seq_arr, 0, MAX-1);\n    double comp_time = omp_get_wtime() - start_time;\n    printf (\"Sequential merge sort : %f\\n\", comp_time);\n\n    start_time = omp_get_wtime();\n    #pragma omp parallel\n    {\n        #pragma omp single\n        para_merge_sort(para_arr, 0, MAX-1);\n    }\n    comp_time = omp_get_wtime() - start_time;\n    printf (\"Parallel merge sort : %f\\n\", comp_time);\n\n    /*for (int i=0; i<MAX; ++i)\n        printf (\"%d\\n\", para_arr[i]);*/\n}\n```\n\n\nSequential merge sort : 0.004533\n\nParallel merge sort : 0.007102\n\nwhen omp_set_num_threads(1) :\n\nSequential merge sort : 0.005124\n\nParallel merge sort : 0.002424\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge-sort in a Linked List\r\n                \r\nI am currently practicing or my interview and was doing the merge-sort for the linked list problem.\n\nGiven a linked list (has ```\nnext```\n and ```\nval```\n attributes), ```\n4-2-1-3```\n, I am supposed to sort it to be ```\n1-2-3-4```\n in ```\nO(nlogn)```\n. So, I tried to use merge sort to a linked list. Below is my code.\n\n```\ndef sortList(self, head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n\n    if head.next:\n\n        # find mid point\n\n        mid = fast = head\n        while fast.next and fast.next.next:\n            mid = mid.next\n            fast = fast.next.next\n\n        # split linkedList into two\n\n        L = head\n        R = mid.next\n        mid.next = None\n\n        # recursively call mergeSort to Left and Right Lists\n\n        self.sortList(L)\n        self.sortList(R)\n\n        # pointers for merging\n\n        newPtr = newHead = ListNode(-1)\n        newHead.next = newPtr\n\n        # merge and sort\n\n        while L and R:\n            if L.val < R.val:\n                newPtr.next = L\n                L = L.next\n            else:\n                newPtr.next = R\n                R = R.next\n            newPtr = newPtr.next\n        # for remaining nodes\n        while L:\n            newPtr.next = L\n            newPtr = newPtr.next\n            L = L.next\n        while R:\n            newPtr.next = R\n            newPtr = newPtr.next\n            R = R.next\n\n        return newHead.next\n\n    else:\n        return head\n```\n\n\nI feel like my merge sort algorithm is correct, but my result for the input above gives me ```\n1-3-4```\n missing the ```\n2```\n.\n\nI think I am really close, but I am not sure which part I am messing up.\n\nPlease help.\n\nEDIT\n\nI solved the problem by changing ```\nL```\n and ```\nR```\n to ```\nl1```\n and ```\nl2```\n and changing\n\n```\n        self.sortList(L)\n        self.sortList(R)\n```\n\n\nThis to\n\n```\n        L = self.sortList(l1)\n        R = self.sortList(l2)\n```\n\n\nOther parts are identical and now I have the same answer. However, I am not sure how the change made the difference.\n    ", "Answer": "\r\nWhen calling sortList recursively, the local function variables R and L may no longer be the head of their respective list segments.  The subsequent merge operation would then \"skip\" the parts of the sorted lists that precede the original nodes resulting in an incomplete output.\n\nYour change ensured that R and L have the effective head of each sub list to merge by re-assigning them with the head of the sorted chains.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Haskell merge sort implementation\r\n                \r\nI am trying to solve this question:\nDefine a recursive function msort :: Ord a => [a] -> [a] that imple-\nments merge sort, which can be specified by the following two rules:\n Lists of length  1 are already sorted;\n Other lists can be sorted by sorting the two halves and merging the\nresulting lists.\n\nBut I am having a hard time understanding how exactly the code of merge sort work.\n\nhere is my code ::\n\n```\nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] [] = []\nmerge (x:xs) (y:ys) | y > x =  (x:xs) ++  (y:ys)\n                    |otherwise =  (y:ys) ++  (x:xs)\n\n\nmsort :: Ord a => [a] -> [a]\n--base case , if length less than or equal 1 , then list is already  sorted\nmsort [] = [] -- how to implement base case?\nmsort (x:xs)  = merge  (take (length(x:xs) `div` 2 ) (x:xs)) (drop (length(x:xs) `div` 2 ) (x:xs))\n```\n\n    ", "Answer": "\r\nYour ```\nmerge```\n function has two issues.\n\ni) Patterns are not exhaustive: If precisely one of the lists is empty, there's no match. You should have\n\n```\nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] ys = ys\nmerge xs [] = xs\nmerge (x:xs) (y:ys) = something\n```\n\n\nii) Your ```\nsomething```\n is not actually merge sorting, it is looking at the heads and concatenates the two lists based on the comparison of the heads. For instance, if given ```\n[1,4,5]```\n and ```\n[2,3,4]```\n, ```\n1```\n would be bound to ```\nx```\n, ```\n2```\n to ```\ny```\n, and then since ```\ny > x```\n holds, then it would return ```\n[1,4,5,2,3,4]```\n, clearly unsorted, though the two given lists were sorted.\n\nImagine the merging as follows. Given two lists, you see only the heads, and pick the smaller one. In place of the one you removed, the next element rolls in, and you keep doing the same thing. This is a recursive process; after each pick, you do the same thing. In code:\n\n```\nmerge (x:xs) (y:ys) | x < y     = x : merge xs (y:ys)\n                    | otherwise = y : merge (x:xs) ys\n```\n\n\nAs for the actual sorting ```\n:: Ord a => [a] -> [a]```\n, you must also work with halves that are already sorted, which also calls for recursion:\n\n```\nmsort :: Ord a => [a] -> [a]\nmsort []  = []\nmsort [x] = [x]\nmsort xs  = merge firstHalfSorted secondHalfSorted\n     where firstHalfSorted  = msort . fst $ halves\n           secondHalfSorted = msort . snd $ halves\n           halves           = splitAt halfPoint xs\n           halfPoint        = length xs `div` 2\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort and Selection Sort\r\n                \r\nI am having trouble developing the recurrence for an algorithm that uses recursive Merge Sort calls for list sizes greater than m. It uses Selection Sort for list sizes less or equal to m.\nHere is my pseudocode:\n```\nproc merge_and_selection (A, p, r, m) {\nif (p <= r) then\n   q = (p + r)/2\n   \n   if r - p > m then\n      merge_and_selection(A, p, q - 1, m)\n      merge_and_selection(A, q + 1, r, m)\n   else\n      selection_sort(A, p, q - 1)\n      selection_sort(A, q + 1, r)\n   end\n\n   merge(A, p, q, r)\nend if \n}\n```\n\nI think the recurrence is:\n\nwith T(2) = [m(m-1)]/2\n    ", "Answer": "\r\nI think more accurate formula is the following:\n\n\nT(n) = 2*T(n/2) + Theta(n) for n >= m/2\nT(n) = Theta(n^2) for n < m/2\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Stable Merge sort C\r\n                \r\nI am writing a simple merge sort function to sort based on a given compar function:\n\n```\nvoid merge(int left, int mid, int right, int(*compar)(const void *, const void *))\n{\n  // sublist sizes\n  int left_size = mid - left + 1;\n  int right_size = right - mid;\n\n  // counts\n  int i, j, k;\n\n  // create left and right arrays\n  B *left_list = (B*) malloc(left_size*sizeof(B));\n  B *right_list = (B*) malloc(right_size*sizeof(B));\n\n  // copy sublists, could be done with memcpy()?\n  for (i = 0; i < left_size; i++)\n    left_list[i] = list[left + i];\n\n  for (j = 0; j < right_size; j++)\n    right_list[j] = list[mid + j + 1];\n\n  // reset counts\n  i = 0; j = 0;\n\n  for (k = left; k <= right; k++)\n  {\n    if (j == right_size)\n      list[k] = left_list[i++];\n    else if (i == left_size)\n      list[k] = right_list[j++];\n    // here we call the given comparision function\n    else if (compar(&left_list[i], &right_list[j]) < 0)\n      list[k] = left_list[i++];\n    else\n      list[k] = right_list[j++];\n  }\n}\n\nvoid sort(int left, int right, int(*compar)(const void *, const void *))\n{\n  if (left < right)\n  {\n    // find the pivot point\n    int mid = (left + right) / 2;\n\n    // recursive step\n    sort(left, mid, compar);\n    sort(mid + 1, right, compar);\n\n    // merge resulting sublists\n    merge(left, mid, right, compar);\n  }\n}\n```\n\n\nI am then calling this several times on the same list array using different comparison functions. I am finding that the sort is stable for the first call, but then after that I see elements are swapped even though they are equal.\n\nCan anyone suggest the reason for this behaviour?\n    ", "Answer": "\r\nI'm not sure if this will do it but try changing this line:\n\n```\ncompar(&left_list[i], &right_list[j]) < 0\n```\n\n\nto this:\n\n```\ncompar(&left_list[i], &right_list[j]) <= 0\n```\n\n\nThis will make it so that if they are already equal it does the first action which will (hopefully) preserve the stability rather than moving things around.\n\nThis is just a guess though.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Visualizer\r\n                \r\nMy merge sort visualizer draws the array but does not show them being sorted and doesnt seem to be correctly merging them and displaying each step. instead of returning a sorted array, I see a quick flash of the array then a blank screen. \n\nvalues is the array and states is supposed to change in value from -1 to 1 based on whether an index is currently in progress, waiting, or completed but I'm trying to get the sort and merge working first.\n\n```\n//array of values to be sorted\nlet values = [];\n//width of values\nlet w = 2;\n//hold the state of the array\nlet states = [];\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight);\n    values = new Array(floor(random(250, width / w)));\n    for (i = 0; i < values.length; i++) {\n        values[i] = random(height);\n        states[i] = -1;\n    }\n\n}\n\nasync function mergeSort(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n\n    //get midpoint\n    let mid = Math.round(arr.length / 2);\n    states[mid] = -1;\n    //split the array\n    temp1 = arr.slice(0, mid);\n    temp2 = arr.slice(mid, arr.length);\n    //merge the array\n    await Promise.all([\n        merge(mergeSort(temp1), mergeSort(temp2))\n    ]);\n\n}\n\nasync function merge(arr1, arr2) {\n    await sleep(25);\n    let sorted = [];\n    while (arr1.length > 0 && arr2.length > 0) {\n        (arr1[0] < arr2[0]) ? sorted.push(arr1.shift()): \nsorted.push(arr2.shift());\n    }\n    while (arr1.length > 0) {\n        sorted.push(arr1.shift());\n    }\n    while (arr2.length > 0) {\n        sorted.push(arr2.shift());\n    }\n    values = sorted.slice();\n}\n\nfunction draw() {\n    background(0);\n    mergeSort(values);\n    for (let i = 0; i < values.length; i++) {\n        noStroke();\n        if (states[i] == 0) {\n            fill('#38e332');\n        } else if (states[i] == 1) {\n            fill('#c9c8c7');\n        } else {\n            fill(255);\n        }\n        //draw the array values at location x=i*w , y=height-array[i] with given width (w) and height(array[i])\n        rect(i * w, height - values[i], w, values[i]);\n    }\n\n}\n\n\nasync function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n'\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort - recursion tree\r\n                \r\nSo I've been studying sorting algorithms.\n\nI am stuck on finding the complexity of merge sort.  \n\nCan someone please explain to me how h=1+lg(n)\n\n\n    ", "Answer": "\r\nIf you keep dividing n by 2, you'll eventually get to 1.\nNamely, it takes log2(n) divisions by 2 to make this happen, by definition of the logarithm.\n\nEvery time we divide by 2, we add a new level to the recursion tree.\nAdd that to the root level (which didn't require any divisions), and we have log2(n) + 1 levels total.\n\n\n\nHere's a cooler proof. Notice that, rearranging, we have T(2n) - 2 T(n) = 2 c n.  \n\nIf n = 2k, then we have T(2k + 1) - 2 T(2k) = 2 c 2k.   \n\nLet's simplify the mess. Let's define U(k) = T(2k) / (2 c).  \n\nThen we have U(k + 1) - 2 U(k) = 2k, or, if we define U'(k) = U(k + 1) - U(k):\n\nU'(k) - U(k) = 2k\n\nk is discrete here, but we can let it be continuous, and if we do, then U' is the derivative of U.  \n\nAt that point the solution is obvious: if you've ever taken derivatives, then you know that if the difference of a function and its derivative is exponential, then the function itself has to be exponential (since only in that case will the derivative be some multiple of itself).  \n\nAt that point you know U(k) is exponential, so you can just plug in an exponential for the unknown coefficients in the exponential, and plug it back in to solve for T.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "When would you use Selection sort versus Merge sort?\r\n                \r\nEfficiency of Merge sort (nlogn) is always faster then Selection sort (n^2). When would you ever choose selection over merge sort?\n    ", "Answer": "\r\nBecause the runtime of selection sort is Θ(n2) and the runtime of mergesort is O(n log n), for sufficiently large inputs mergesort will outperform selection sort. However, there are two areas in which selection sort might be better:\n\n\nSelection sort on an array can be implemented with O(1) auxiliary storage space, whereas (most) implementations of mergesort on arrays use Θ(n) auxiliary storage space. As a result, if memory is extremely scarce, selection sort would be a better choice than mergesort. (However, it would be a worse choice than, say, heapsort or quicksort!)\nSelection sort may be faster than mergesort on small input arrays because it's a simpler algorithm with lower constant factors than the ones hidden by mergesort. If you're sorting, say, arrays of 16 or so elements, then selection sort might be faster than mergesort. (However, it would probably be a worse choice than, say, insertion sort).\n\n\nSo in other words, there are some cases where selection sort would be better than mergesort, but in those cases you're still probably better off using another sorting algorithm. :-)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge-Sort Issues\r\n                \r\nSo a little background:\n\nOur teacher basically sat down and made a basic implementation of SQL in Java, you could say. He told us to try and make an implementation of a Merge-Algorithm in this system that he made.\n\nI am trying to do a Merge-Sort (Top-Down Implementation) but I have a few issues.\n\nThe Merge-Sort is supposed to take two Tables (simulated from the Database implementation he made) and arrange them so that they show from lowest to highest in ascending order (1-8).\n\nThe code lets me use a DbIterator which our teacher wrote to iterate over a Table and its contents. So we have two tables which have the following data:\n\n```\n[hello1, 5]\n[hello2, 6]\n[hello3, 7]\n[hello4, 8]\n```\n\n\nAnd the other table:\n\n```\n[goodbye4, 4]\n[goodbye2, 2]\n[goodbye3, 3]\n[goodbye1, 1]\n```\n\n\nAfter a merge-sort it's supposed to print out this:\n\n```\n[goodbye1, 1]\n[goodbye2, 2]\n[goodbye3, 3]\n[goodbye4, 4]\n[hello1, 5]\n[hello2, 6]\n[hello3, 7]\n[hello4, 8]\n```\n\n\nBut this is what it prints out:\n\n```\nnull\n[hello1, 5]\n[hello2, 6]\n[hello3, 7]\n```\n\n\nI am sort of puzzled at this and have tried to debug to figure out what goes wrong, but I might have tried so much that I become blind to the actual issue. So here is the code (the sort happens on the last three methods):\n\n```\npublic String[] MergeSort(String table1, String table2) {\n    DbIterator scannerA = getTableScanner(table1);\n    DbIterator scannerB = getTableScanner(table2);\n    HashMap<Integer, String> records = new HashMap<>();\n    ArrayList<Integer> A = new ArrayList<>();\n    ArrayList<Integer> B = new ArrayList<>();\n    int n = 0;\n    scannerA.open();\n    while(scannerA.hasNext()) {\n        Record r = scannerA.next();\n        StringField sF = (StringField) r.getField(0);\n        IntegerField iF = (IntegerField) r.getField(1);\n        records.put(iF.hashCode(), sF.toString());\n        A.add(iF.hashCode());\n        n++;\n    }\n    scannerA.close();\n\n    scannerB.open();\n    while(scannerB.hasNext()) {\n        Record r = scannerB.next();\n        StringField sF = (StringField) r.getField(0);\n        IntegerField iF = (IntegerField) r.getField(1);\n        records.put(iF.hashCode(), sF.toString());\n        B.add(iF.hashCode());\n        n++;\n    }\n    scannerB.close();\n\n    int[] mergeResult;\n    int[] aA = convertIntegers(A);\n    int[] bB = convertIntegers(B);\n    mergeResult = TopDownSplitMerge(aA, 0, n, bB);\n    String[] results = new String[mergeResult.length];\n    for(int v = 0; v < mergeResult.length; v++) {\n        if(records.containsKey(v)) {\n            results[v] = \"[\" + records.get(v) + \", \" + v +\"]\";\n        }\n    }\n\n    return results;\n}\n\nprivate int[] CopyArray(int[] B, int iBegin, int iEnd, int[] A) {\n    for(int k = iBegin; k < iEnd; k++)\n        A[k] = B[k];\n    return A;\n}\n\nprivate int[] TopDownSplitMerge(int[]A,int iBegin, int iEnd, int[]B) {\n    if(iEnd - iBegin < 2) {\n        return null;\n    }\n    int iMiddle = (iEnd + iBegin) / 2;\n    TopDownSplitMerge(A, iBegin, iMiddle, B);\n    TopDownSplitMerge(A, iMiddle, iEnd, B);\n    TopDownMerge(A, iBegin, iMiddle, iEnd, B);\n    int[] tmp = CopyArray(B, iBegin, iEnd, A);\n    return tmp;\n}\n\npublic void TopDownMerge(int[] A, int iBegin, int iMiddle, int iEnd, int[] B) {\n    int i0 = iBegin;\n    int i1 = iMiddle;\n\n    for(int j = iBegin; j < iEnd; j++) {\n        if(i0 < iMiddle && (i1 >= iEnd || A[i0] <= A[i1])) {\n            B[j] = A[i0++];\n        } else {\n            B[j] = A[i1++];\n        }\n    }\n}\n```\n\n\nFirst of all, this is not my personal algorithm but rather me trying to implement it from a wiki. The only part I cannot figure out, which might solve the whole issue all together, is what they call \"iEnd\". The value ```\nn```\n. I can't figure out how to calculate that or what value to give. Might be the whole problem really.\n    ", "Answer": "\r\nRead ```\nTopDownMerge```\n – is merges items from two sorted parts of ```\nA```\n array into corresponding part of ```\nB```\n, then```\nCopyArray```\n copies merged data back to ```\nA```\n. So ```\nB```\n is just a temporary buffer for merging data, not the data source. You should not invoke ```\nTopDownSplitMerge```\n with two arrays of input ```\naA```\n and ```\nbB```\n but rather concatenate them into a single array and use that array as ```\nA```\n parameter (and another array as ```\nB```\n buffer).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Is this python code relevant for merge sort?\r\n                \r\nThe code below is what i think should be the implementation of merge sort in Python and works as expected. It sorts the given list. But after considering some online implementations I am doubtful about my implementation. So the base question is \"Is this even Merge sort?\". Thank you for your time and effort in critiquing this code:\n\n```\ndef merge(arr):\n    # base case\n    length = len(arr)\n    half = length//2\n    if length == 1 or length == 0:\n        return arr\n    # recursive case\n    firstHalf = merge(arr[:half])  # sort first half\n    secondHalf = merge(arr[half:])  # sort second half\n    length_firstHalf = len(firstHalf)\n    length_secondHalf = len(secondHalf)\n    sortedList = []\n\n    i, j = 0, 0  # variables for iteration\n    while i != length_firstHalf and j != length_secondHalf:  # add elements into the new array until either of then two sub arrays is completely traversed\n        if firstHalf[i] > secondHalf[j]:\n            sortedList.append(secondHalf[j])\n            j += 1\n            continue\n        if firstHalf[i] < secondHalf[j]:\n            sortedList.append(firstHalf[i])\n            i += 1\n    return(sortedList + firstHalf[i:] + secondHalf[j:])  # return the array after adding whats left of sub array which wasnt completely traversed \nprint(merge([20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]))\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "how to show time performance for merge sort? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nshow the time performance analysis for merge sort algorithm in c programming\nhow to print merge sort algorithm the time performance (in ms) in c programming. \nMerge sort time complexity is (n log n) whether the condition in the worst case or best case. Someone can help me solve the problem. thanks, someone for solving my problem. \n\n```\n#include<stdio.h>\n#define MAX 50\n\nvoid mergeSort(int arr[],int low,int mid,int high);\nvoid partition(int arr[],int low,int high);\n\nint main(){\n\n    int merge[MAX],i,n;\n\n    printf(\"Enter the total number of elements: \");\n    scanf(\"%d\",&n);\n\n    printf(\"Enter the elements which to be sort: \");\n    for(i=0;i<n;i++){\n         scanf(\"%d\",&merge[i]);\n    }\n\n    partition(merge,0,n-1);\n\n    printf(\"After merge sorting elements are: \");\n    for(i=0;i<n;i++){\n         printf(\"%d \",merge[i]);\n    }\n\n   return 0;\n}\n\nvoid partition(int arr[],int low,int high){\n\n    int mid;\n\n    if(low<high){\n         mid=(low+high)/2;\n         partition(arr,low,mid);\n         partition(arr,mid+1,high);\n         mergeSort(arr,low,mid,high);\n    }\n\n}\n\nvoid mergeSort(int arr[],int low,int mid,int high){\n\n    int i,m,k,l,temp[MAX];\n\n    l=low;\n    i=low;\n    m=mid+1;\n\n    while((l<=mid)&&(m<=high)){\n\n         if(arr[l]<=arr[m]){\n             temp[i]=arr[l];\n             l++;\n         }\n         else{\n             temp[i]=arr[m];\n             m++;\n         }\n         i++;\n    }\n\n    if(l>mid){\n         for(k=m;k<=high;k++){\n             temp[i]=arr[k];\n             i++;\n         }\n    }\n    else{\n         for(k=l;k<=mid;k++){\n             temp[i]=arr[k];\n             i++;\n         }\n    }\n\n    for(k=low;k<=high;k++){\n         arr[k]=temp[k];\n    }\n}\n```\n\n    ", "Answer": "\r\n```\ninclude <time.h> \ninclude <stdio.h>\nint main(){\n    clock_t start = clock(); // Execuatable code\n    clock_t stop = clock();\n    double elapsed = (double)(stop - start) * 1000.0 / CLOCKS_PER_SEC;\n    printf(\"Time elapsed in ms: %f\", elapsed);\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort single function\r\n                \r\nI'm trying to merge sort recursively, in a single function. \n\nHow can I fix this code to get the correct output?\n\n```\nvoid merge(int a[], int left, int right)\n{\n    if(left < right)\n    {\n        int mid = (left + right) / 2;\n        merge(a, left, mid);  \n        merge(a, mid + 1, right); \n\n        int b[mid - left + 1], c[right - mid]; \n        //two half arrays of the original array 'a'\n\n        int i, j, k;\n        for(i = left, j = 0; i <= mid; i++, j++) \n            b[j] = a[i];\n        for(j = mid + 1, i = 0; j <= right; j++, i++)  \n            c[i] = a[j];\n        i = 0;   \n        j = 0;   \n        k =- 1;  \n        while(k < (right - left + 1))   \n        {   \n            k++;\n            if(i == (mid - left + 1))    \n                a[k] = c[j++];\n            else if(j == (right - mid))   \n                a[k] = b[i++];\n            else if(b[i] < c[j]) \n                a[k] = b[i++];\n            else  \n                a[k] = c[j++];\n        }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort in Python Bug\r\n                \r\nI'm trying to implement a merge sort in Python. I completed a merge sort lesson on Khan Academy where they had me implement it in JavaScript, but I wanted to try and implement it in Python.\n\nLesson: https://www.khanacademy.org/computing/computer-science/algorithms#merge-sort\n\nHere is my code:\n\n```\nfrom math import floor\n\ndef merge(array, p, q, r):\n    left_array = []\n    right_array = []\n\n    k = p\n    while (k < q):\n        left_array.append(array[k])\n        k += 1\n    while (k < r):\n        right_array.append(array[k])\n        k += 1\n\n    k = p\n    i = 0\n    j = 0\n    while (i < len(left_array) and j < len(right_array)):\n        if (left_array[i] <= right_array[j]):\n            array[k] = left_array[i]\n            k += 1\n            i += 1\n        else:\n            array[k] = right_array[j]\n            k += 1\n            j += 1\n\n    while (i < len(left_array)):\n        array[k] = left_array[i]\n        k += 1\n        i += 1\n\n    while (j < len(right_array)):\n        array[k] = right_array[j]\n        k += 1\n        j += 1\n    print(\"Merging\", array)\n\ndef merge_sort(array, p, r):\n    print(\"Splitting\", array)\n    if p < r:\n        q = floor((p + r) / 2)\n        merge_sort(array, p, q)\n        merge_sort(array, q + 1, r)\n        merge(array, p, q, r)\n\ntest3 = [3, 2, 1]\nmerge_sort(test3, 0, len(test3))\n```\n\n\nThere's a bug somewhere in my code and I can't seem to get it. I think that it has to do with my splicing, but I haven't been able to confirm this. Here is my output for the test at the bottom:\n\n```\nSplitting [3, 2, 1]\nSplitting [3, 2, 1]\nSplitting [3, 2, 1]\nSplitting [3, 2, 1]\nMerging [3, 2, 1]\nSplitting [3, 2, 1]\nSplitting [3, 2, 1]\nSplitting [3, 2, 1]\nMerging [3, 2, 1]\nMerging [2, 1, 3]\n```\n\n\nI took the idea of adding print statements from here.\n\nAny help is appreciated. Thank you!\n    ", "Answer": "\r\nYour code is not following the conventions of the text you linked to on whether the bounds are exclusive or inclusive. In the text, they are inclusive, but in your code they are exclusive of the upper bound. As a result, when you have these two lines:\n\n```\nmerge_sort(array, p, q)\nmerge_sort(array, q + 1, r)\n```\n\n\nthe first sorts ```\narray[p]```\n through ```\narray[q-1]```\n, the second sorts ```\narray[q+1]```\n through ```\narray[r-1]```\n, and you end up completely skipping ```\narray[q]```\n.\n\nI think you will find it easier to follow the conventions of the text and make both bounds inclusive. So modify you code, start with \n\n```\ntest3 = [3, 2, 1]\nmerge_sort(test3, 0, len(test3) - 1)\n```\n\n\n, and go from there.\n\nYou can also clean up your code greatly by using python slice notation. For example:\n\n```\nleft_array = []\nright_array = []\n\nk = p\nwhile (k < q):\n    left_array.append(array[k])\n    k += 1\nwhile (k < r):\n    right_array.append(array[k])\n    k += 1\n```\n\n\ncan be simplified to\n\n```\nleft_array = array[p:q]\nright_array = array[q:r]\n```\n\n\nalthough, as I stated, you'll probably want to start using inclusive indices.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort not merging properly C++\r\n                \r\nI have written a program for merge sort and The program works fine until at a point of merging that it doesn't merge properly \n\nHere is the 3 functions that does the merge sort. I can't find the problem\n\n```\nvoid mergeSort(int A[], int tmp[], int n)\n{\nmergeSort(A, tmp, 0, n);\nmerge(A,tmp,0,n);}\n\nvoid mergeSort(int A[],int tmp[], int left, int right){\nif (right-left<2)\n    return;\n\n\nint mid;\n\nif (left < right)\n{\n    mid= ((left+right)/2);\n\n    mergeSort(A, tmp, mid+1, right);\n    merge (A, tmp, mid+1, right-1);\n\n    mergeSort(A, tmp, left ,mid);\n    merge (A, tmp, left, mid);\n}\n\nreturn;\n}\nvoid merge(int A[], int tmp[], int left, int right)\n{\nint k=left;\nint start=left;\nint mid= ((right+left)/2)+1;\nint leftEnd= mid-1;\nint numElemet= (right-left);\n\nwhile ((left<=leftEnd) &&(mid<=right))\n{\n    if (A[left]<= A[mid])\n    {\n        tmp[k] = A[left];\n        k++;\n        left++;\n    }\n    else\n    {\n        tmp[k] = A[mid];\n        k++;\n        mid++;\n    }\n}\nwhile (left<= leftEnd)\n{\n    tmp[k]= A[left];\n    left++;\n    k++;\n}\nwhile(mid<= right)\n{\n    tmp[k]= A[mid];\n    mid++;\n    k++;\n}\nfor (int i=start;i<k; i++)\n{\nA[i]= tmp[i];\n}\n}\n```\n\n\nSo the program gets in the array splits it fine but when it gets to going back recursion misses some of the merges and half of the array doesn't get merged on in the right place.\nHow can I fix it? \n    ", "Answer": "\r\nYou should be double-careful about the boundaries while manipulating arrays.\n\n1.\nYour code:\n\n```\nmergeSort(A, tmp, mid+1, right);\nmerge (A, tmp, mid+1, right-1);\n```\n\n\nMerge sort is a ```\nDivide and conquer```\n method. The range of numbers being divided and conquered should be the same. Which part of the above code do you think has a mistake?\n\n2.```\nint numElemet= (right-left);```\n is not used and should be deleted, further more, the # of elements should be ```\nright-left+1```\n.\n\n3.\n\n```\nfor (int i=start;i<k; i++)\n{\n    A[i]= tmp[i];\n}\n```\n\n\nThe k is not the desired value, try find where the error is before this piece of code.\n\n4.\nA piece of advice:\nUse tab to indent the code in order to improve readibility. It's good for both you and the people reading your code. And use ```\ncout```\n to check the values of variables in case the code doesn't perform as you desired.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "About bubble sort vs merge sort\r\n                \r\nThis is an interview question that I recently found on Internet:\n\nIf you are going to implement a function which takes an integer array as input and returns the maximum, would you use bubble sort or merge sort to implement this function? What if the array size is less than 1000? What if it is greater than 1000?\n\nThis is how I think about it:\n\nFirst, it is really weird to use sorting to implement the above function. You can just go through the array once and find the max one.\nSecond, if have to make a choice between the two, then bubble sort is better - you don't have to implement the whole bubble sort procedure but only need to do the first pass. It is better than merge sort both in time and space.\n\nAre there any mistakes in my answer? Did I miss anything?\n    ", "Answer": "\r\nIt's a trick question. If you just want the maximum, (or indeed, the kth value for any k, which includes finding the median), there's a perfectly good ```\nO(n)```\n algorithm. Sorting is a waste of time. That's what they want to hear.\n\nAs you say, the algorithm for maximum is really trivial. To ace a question like this, you should have the quick-select algorithm ready, and also be able to suggest a heap datastructure in case you need to be able to mutate the list of values and always be able to produce the maximum rapidly.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Sorting of an array using merge sort\r\n                \r\nI have implemented  for merge sort in c , although the code seems to be correct the code does not give me the sorted array rather returns the same array that is given to it, that means my merge function  in not working\n\n```\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid re_sort(int arr[],int size);\nvoid merge(int left[],int right[],int arr[],int rightlen,int leftlen);\n\nint main(void)\n{ \n  int a[10];\n  int n;\n\n  printf(\"enter the number\\n\");\n\n  scanf(\"%d\",&n);\n\n    printf(\"enter the elements\\n\");\n    for(int i=0;i<n;i++)\n\n      {  \n         scanf(\"%d\",&a[i]);\n      }\n\n    re_sort(a,n);          //merge sort using recursion  \n\n    printf(\"the sorted list is:\\n\");\n    for(int i=0;i<n;i++)\n\n      {  printf(\"%d\\t\",a[i]);\n\n      }\n\n\n    return 0;\n}\n\nvoid re_sort(int arr[],int size)\n\n{  int mid,*left,*right;\n   int k=0;\n  if(size<2)            \n    return; \n\n  else \n  mid=size/2;\n  left=(int*)(malloc(mid*(sizeof(int))));          // two sub arrays left and right \n  right=(int*)(malloc((size-mid)*(sizeof(int))));\n\n  for(int i=0;i<mid;i++)\n  { \n    left[i]=arr[k++];\n  }\n\n  for(int j=0;j<(size-mid);j++)\n  { \n    right[j]=arr[k++];\n  }\n\n  re_sort(left,mid);                 //recursion until size becomes less than 2\n  re_sort(right,size-mid);\n  merge(left,right,arr,size-mid,mid); //both the elements in left and right are merged\n\n\n\n}\nvoid merge(int left[],int right[],int arr1[],int rightlen,int leftlen)\n\n{   int arr[100];\n    int k=0,i=0,j=0;\n    while(i<leftlen && j<rightlen)\n    { \n      if(left[i]<= right[j])\n\n      arr[k++]=left[i++];\n\n      else \n\n      arr[k++]=right[j++];\n\n    }\n\n    while(i<leftlen)\n    {\n        arr[k++]=left[i++];\n    } \n    while(j<rightlen)\n\n    { \n       arr[k++]=right[j++];\n    }\n\n    for(int l=0;l<(rightlen+leftlen);l++)\n    { \n      arr1[l]=arr[l];\n    }\n    free(left);\n    free(right);\n}\n```\n\n    ", "Answer": "\r\nHere\n\n```\n  if(left[i]<= right[j])\n      arr[k++]=left[i++];\n  else \n      arr[k++]=left[j++];\n```\n\n\nlast ```\nleft```\n should be ```\nright```\n.\n\nAnyway, where do you ```\nfree```\n the memory you ```\nmalloc```\n-ed...?\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "in-place Merge Sort | C# [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to sort in-place using the merge sort algorithm?\r\n                            \r\n                                (10 answers)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have written a program for merge sort and The program works fine until at a point of merging that it doesn't merge properly \n\nsuch as Example: \n\nmergesort.in:\n    // all number is one array and  not use temp array for sorting\n\n\n2   //-->This is Array Number \n5   //-->This is Array(next line) Length\n4 6 98 8 24\n8   //-->This is Array(next line) Length\n12 14 89 21 4 7 9 41\n\n\nmergesort.Out: \n\n```\n  //Output in file mergesort.Out \n```\n\n\n\n4 6 8 24 98\n4 7 9 12 14 21 41 89\n\n\nI'm not understand how to work mergeArray function for in-place merge Sort\n\n```\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading.Tasks;\n\n    namespace ConsoleApplication1\n    {\n        class ReadFromFile\n        {\n            static void Main()\n            {\n                ArrayList lines = new ArrayList();\n\n            var input = System.IO.File.ReadAllLines(@\"C:\\mergesort.in\");\n\n            System.Console.WriteLine(\"Contents of mergesort.in = \");\n\n            foreach (string line in input)\n            {\n                Console.WriteLine(\"\\t\" + line);\n            }\n            foreach (var i in input)\n            {\n                if (Convert.ToInt32(i.Length) > 1)\n                {\n                    var counter = 0;\n                    foreach (var item in input)\n                    {\n                        if (input[counter].Length > 1)\n                        {\n                            string[] t = input[counter].Split(' ');\n                            foreach (string word in t)\n                            {\n                                lines.Add(word);\n                            }\n                            ReadFromFile.mergesort(t, 0, 5, lines);\n                        }\n                        counter++;\n                    }\n\n                    foreach (string line in lines)\n                    {\n                        Console.WriteLine(\"\\t\" + line);\n                    }\n                    break;\n                }\n            }\n\n            Console.WriteLine(\"Press any key to exit...\");\n            System.Console.ReadKey();\n        }\n\n        private static void mergesort(string[] t, int p1, int p2, ArrayList lines)\n        {\n            if (p1 < p2)\n            {\n                int mid = (p2 + p1) / 2;\n                ReadFromFile.mergesort(t, p1, mid, lines);\n                Console.WriteLine(p1);\n\n                ReadFromFile.mergesort(t, mid + 1, p2, lines);\n                Console.WriteLine(t);\n                foreach (var item in t)\n                {\n                    Console.WriteLine(item);\n                }\n                ReadFromFile.mergeArray(t, p1, mid, p2, lines);\n            }\n        }\n\n        private static void mergeArray(string[] arr, int start, int mid, int end, ArrayList lines)\n        {\n\n            //I'm not understand how to work this function for in-place merge Sort\n\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nIt would be much easier if you use Linq:\n\n```\nforeach (var line in input)\n{\n    var elements = line.Split(' ');\n\n    if (elements.Count > 1)\n    {\n        var t = elements\n            .Select(i => Convert.ToInt32(i))\n            .Distinct()\n            .OrderBy(i => i)\n            .Select(i => i.ToString())\n            .ToArray();\n\n        Console.WriteLine(\"\\t\" + string.Join(\" \", t));\n    }\n}\n```\n\n\nUse ```\n.Union```\n if you want to merge unique values from more than one array\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort java.lang.StackOverflowError\r\n                \r\nI am working on a project for school and things are going well until i tried to perform a merge sort on my ```\nArrayList```\n.\nIt will run but then it errors out. The first error of many is ```\nException in thread \"main\" java.lang.StackOverflowError```\n. \nI have looked over the code and cant find out why the error is occurring.\nIt does give me a location ( ```\nline 74:first_half = mergeSort(first_half);```\n ) but i don't see the issue.\n\n```\npublic static void main(String[] args) throws IOException {\n\n    // URL url = new\n    // URL(\"https://www.cs.uoregon.edu/Classes/15F/cis212/assignments/phonebook.txt\");\n    FileReader fileReader = new FileReader(\"TestSort.txt\");\n    BufferedReader bufferReader = new BufferedReader(fileReader);\n    String entry = bufferReader.readLine();\n\n    // Scanner s = new Scanner(url.openStream());\n\n//      int count = 0;\n\n    while (entry != null) {\n\n        // String person = s.nextLine();\n        String phoneNum = entry.substring(0, 7);\n        String name = entry.substring(9);\n        PhonebookEntry newentry = new PhonebookEntry(name, phoneNum);\n        phoneBook.add(newentry);\n        entry = bufferReader.readLine();\n    }\n    // ********************Selection\n    // Sort*************************************\n    ArrayList<PhonebookEntry> sortList = new ArrayList<PhonebookEntry>(phoneBook);\n\n    for (int min = 0; min < sortList.size(); min++) {\n\n        for (int i = min; i < sortList.size(); i++) {\n            int res = sortList.get(min).getName().compareTo(sortList.get(i).getName());\n\n            if (res > 0) {\n                PhonebookEntry temp = sortList.get(i);\n                sortList.set(i, sortList.get(min));\n                sortList.set(min, temp);\n\n            }\n\n        }\n\n    }\n    for (PhonebookEntry sortentry : sortList) {\n        System.out.println(sortentry);\n    }\n\n\n    System.out.println(mergeSort(mergeSortList));\n\n}\n\n\n// *****************************merge sort******************************************\nstatic int mergecounter = 0;\nstatic ArrayList<PhonebookEntry> mergeSortList = new ArrayList<PhonebookEntry>(appMain.phoneBook);\n\npublic static ArrayList<PhonebookEntry> mergeSort(ArrayList<PhonebookEntry> mergeSortLists) {\n    if (mergeSortLists.size() == 1) {\n        return mergeSortLists;\n    }\n    int firstHalf = mergeSortLists.size() % 2 == 0 ? mergeSortLists.size() / 2 : mergeSortLists.size() / 2 + 1;\n\n    ArrayList<PhonebookEntry> first_half = new ArrayList<PhonebookEntry>(mergeSortLists.subList(0, firstHalf));\n    ArrayList<PhonebookEntry> mergeSortHalf2 = new ArrayList<PhonebookEntry>(\n    mergeSortLists.subList(first_half.size(), mergeSortLists.size()));\n\n    System.out.println(++mergecounter);\n\n    first_half = mergeSort(first_half);\n    mergeSortHalf2 = mergeSort(mergeSortHalf2);\n    return merge(first_half, mergeSortHalf2);\n}\n\npublic static ArrayList<PhonebookEntry> merge(ArrayList<PhonebookEntry> first_half,\n        ArrayList<PhonebookEntry> mergeSortHalf2) {\n    ArrayList<PhonebookEntry> returnMerge = new ArrayList<PhonebookEntry>();\n\n    while (first_half.size() > 0 && mergeSortHalf2.size() > 0) {\n        if (first_half.get(0).getName().compareTo(mergeSortHalf2.get(0).getName()) > 0) {\n            returnMerge.add(mergeSortHalf2.get(0));\n            mergeSortHalf2.remove(0);\n        }\n\n        else {\n            returnMerge.add(first_half.get(0));\n            first_half.remove(first_half.get(0));\n        }\n    }\n\n    while (first_half.size() > 0) {\n        returnMerge.add(first_half.get(0));\n        first_half.remove(first_half.get(0));\n\n    }\n    while (mergeSortHalf2.size() > 0) {\n        returnMerge.add(mergeSortHalf2.get(0));\n        mergeSortHalf2.remove(mergeSortHalf2.get(0));\n    }\n    return returnMerge;\n}\n\n}\n```\n\n    ", "Answer": "\r\nMy opinion there is no error in code.\nHow so sure?\n\nI ran you code in my environment and its executed without any error.\n\nWith the text file i found at https://www.cs.uoregon.edu/Classes/15F/cis212/assignments/phonebook.txt As input\nand done a simple implementation for ```\nPhonebookEntry```\n\n\nThen why is this error?\n\nFirst off all try to understand the error, I mean why ```\nStackOverflowError```\n occur. As there are lots of I am not going to explain this\nBut please read the top answer of this two thread and i am sure you will know why this happen.\n\nThread 1: What is a StackOverflowError?\nThread 2: What actually causes a Stack Overflow error?\n\nIf you read those I hope you understand the summury is ```\nYou Ran Out Of Memory```\n.\n\nThen why I didnt got that error: Possible reason is\n\nIn my environment  I configured the jvm to run with a higher memory 1024m  to 1556m (as eclipse parameter)\n\nNow lets analyze your case with solution:\n\n\nInput: you have big input here ( 50,000 ) \n\nTo check you code try to shorten the input and test.\nYou have executed two algorithm in a sigle method over this big Input:\nWhen a method execute all its varibles stay in the memory untill it complete its execution.\nso when you are calling merge sort all previouly user vairables and others stay in the memory which can contribute to this situation\n\nNow if you use separated method and call them from the main method like write an method for selection sort, all its used varible will go out of scope\nand possibly be free (if GC collect them) after the selection sort is over.\n\nSo write two separated method for reading input file and selection sort.\nAnd Please Please ```\nclose()```\n those ```\nFileReader```\n and  ```\nBufferedReader```\n.\nGet out of those static mehtod . Make them non static create and object of the class and call them from main method \n\n\nSo its all about code optimization\n\nAnd also you can just increase the memory for jvm and test by doing like this ```\njava -Xmx1556m -Xms1024m```\n when ruining the app in command line\n\nBTW, Thanks for asking this this question its gives me something to think about\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementing merge sort in java\r\n                \r\nHere's my implementation of Merge Sort in java\n\n```\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class MergeSort\n{\n  private static int [] LeftSubArray(int [] Array)\n  {\n    int [] leftHalf = Arrays.copyOfRange(Array, 0, Array.length / 2);\n    return leftHalf;\n  }\n\n  private static int [] RightSubArray(int [] Array)\n  {\n    int [] rightHalf = Arrays.copyOfRange(Array, Array.length / 2 + 1, Array.length);\n    return rightHalf;\n  }\n\n  private static int [] Sort(int [] A)\n  {\n    if(A.length > 1)\n    {\n      return Merge( Sort( LeftSubArray(A) ) , Sort( RightSubArray(A) ) );\n    }\n    else\n    {\n      return A;\n    }\n  }\n\n  private static int [] Merge(int [] B, int [] C)\n  {\n    int [] D = new int[B.length + C.length];\n    int i,j,k;\n    i = j = k = 0;\n    while(k < D.length)\n    {\n      if(i == B.length)\n      {\n        //Copy the remainder of C into D\n        while(k < D.length){ D[k++] = C[j++]; }\n      }\n      if(j == C.length)\n      {\n        //Copy the remainder of B into D\n        while(k < D.length){ D[k++] = B[i++]; }\n      }\n      if(i<B.length && j<C.length)\n      {\n        if(B[i] > C[j]){ D[k++] = B[i++]; }\n        else { D[k++] = C[j++]; }\n      }\n    }\n    return D;\n  }\n\n  public static void main(String [] args)\n  {\n    int [] array = {1,3,5,2,4};\n    int [] sorted = MergeSort.Sort(array);\n    for(int i = 0;i < sorted.length; ++i)\n    {\n      System.out.print(sorted[i] + \" \");\n    }\n  }\n}\n```\n\n\nThe output I get is\n\n```\n2 1\n```\n\n\nFrom what I can tell there seems a problem with my division of the right sub array.\nWhat am I doing wrong?\n    ", "Answer": "\r\nHere is the javadoc of copyOfRange:\n\n```\nParameters:\noriginal - the array from which a range is to be copied\nfrom - the initial index of the range to be copied, **inclusive**\nto - the final index of the range to be copied, **exclusive**. (This index may lie outside the array.)\n```\n\n\nI highlighted two words you should pay special attention to ;-)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementing merge sort in java\r\n                \r\nHere's my implementation of Merge Sort in java\n\n```\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class MergeSort\n{\n  private static int [] LeftSubArray(int [] Array)\n  {\n    int [] leftHalf = Arrays.copyOfRange(Array, 0, Array.length / 2);\n    return leftHalf;\n  }\n\n  private static int [] RightSubArray(int [] Array)\n  {\n    int [] rightHalf = Arrays.copyOfRange(Array, Array.length / 2 + 1, Array.length);\n    return rightHalf;\n  }\n\n  private static int [] Sort(int [] A)\n  {\n    if(A.length > 1)\n    {\n      return Merge( Sort( LeftSubArray(A) ) , Sort( RightSubArray(A) ) );\n    }\n    else\n    {\n      return A;\n    }\n  }\n\n  private static int [] Merge(int [] B, int [] C)\n  {\n    int [] D = new int[B.length + C.length];\n    int i,j,k;\n    i = j = k = 0;\n    while(k < D.length)\n    {\n      if(i == B.length)\n      {\n        //Copy the remainder of C into D\n        while(k < D.length){ D[k++] = C[j++]; }\n      }\n      if(j == C.length)\n      {\n        //Copy the remainder of B into D\n        while(k < D.length){ D[k++] = B[i++]; }\n      }\n      if(i<B.length && j<C.length)\n      {\n        if(B[i] > C[j]){ D[k++] = B[i++]; }\n        else { D[k++] = C[j++]; }\n      }\n    }\n    return D;\n  }\n\n  public static void main(String [] args)\n  {\n    int [] array = {1,3,5,2,4};\n    int [] sorted = MergeSort.Sort(array);\n    for(int i = 0;i < sorted.length; ++i)\n    {\n      System.out.print(sorted[i] + \" \");\n    }\n  }\n}\n```\n\n\nThe output I get is\n\n```\n2 1\n```\n\n\nFrom what I can tell there seems a problem with my division of the right sub array.\nWhat am I doing wrong?\n    ", "Answer": "\r\nHere is the javadoc of copyOfRange:\n\n```\nParameters:\noriginal - the array from which a range is to be copied\nfrom - the initial index of the range to be copied, **inclusive**\nto - the final index of the range to be copied, **exclusive**. (This index may lie outside the array.)\n```\n\n\nI highlighted two words you should pay special attention to ;-)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "in-place Merge Sort | C# [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to sort in-place using the merge sort algorithm?\r\n                            \r\n                                (10 answers)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have written a program for merge sort and The program works fine until at a point of merging that it doesn't merge properly \n\nsuch as Example: \n\nmergesort.in:\n    // all number is one array and  not use temp array for sorting\n\n\n2   //-->This is Array Number \n5   //-->This is Array(next line) Length\n4 6 98 8 24\n8   //-->This is Array(next line) Length\n12 14 89 21 4 7 9 41\n\n\nmergesort.Out: \n\n```\n  //Output in file mergesort.Out \n```\n\n\n\n4 6 8 24 98\n4 7 9 12 14 21 41 89\n\n\nI'm not understand how to work mergeArray function for in-place merge Sort\n\n```\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading.Tasks;\n\n    namespace ConsoleApplication1\n    {\n        class ReadFromFile\n        {\n            static void Main()\n            {\n                ArrayList lines = new ArrayList();\n\n            var input = System.IO.File.ReadAllLines(@\"C:\\mergesort.in\");\n\n            System.Console.WriteLine(\"Contents of mergesort.in = \");\n\n            foreach (string line in input)\n            {\n                Console.WriteLine(\"\\t\" + line);\n            }\n            foreach (var i in input)\n            {\n                if (Convert.ToInt32(i.Length) > 1)\n                {\n                    var counter = 0;\n                    foreach (var item in input)\n                    {\n                        if (input[counter].Length > 1)\n                        {\n                            string[] t = input[counter].Split(' ');\n                            foreach (string word in t)\n                            {\n                                lines.Add(word);\n                            }\n                            ReadFromFile.mergesort(t, 0, 5, lines);\n                        }\n                        counter++;\n                    }\n\n                    foreach (string line in lines)\n                    {\n                        Console.WriteLine(\"\\t\" + line);\n                    }\n                    break;\n                }\n            }\n\n            Console.WriteLine(\"Press any key to exit...\");\n            System.Console.ReadKey();\n        }\n\n        private static void mergesort(string[] t, int p1, int p2, ArrayList lines)\n        {\n            if (p1 < p2)\n            {\n                int mid = (p2 + p1) / 2;\n                ReadFromFile.mergesort(t, p1, mid, lines);\n                Console.WriteLine(p1);\n\n                ReadFromFile.mergesort(t, mid + 1, p2, lines);\n                Console.WriteLine(t);\n                foreach (var item in t)\n                {\n                    Console.WriteLine(item);\n                }\n                ReadFromFile.mergeArray(t, p1, mid, p2, lines);\n            }\n        }\n\n        private static void mergeArray(string[] arr, int start, int mid, int end, ArrayList lines)\n        {\n\n            //I'm not understand how to work this function for in-place merge Sort\n\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nIt would be much easier if you use Linq:\n\n```\nforeach (var line in input)\n{\n    var elements = line.Split(' ');\n\n    if (elements.Count > 1)\n    {\n        var t = elements\n            .Select(i => Convert.ToInt32(i))\n            .Distinct()\n            .OrderBy(i => i)\n            .Select(i => i.ToString())\n            .ToArray();\n\n        Console.WriteLine(\"\\t\" + string.Join(\" \", t));\n    }\n}\n```\n\n\nUse ```\n.Union```\n if you want to merge unique values from more than one array\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Is merge sort an adaptive algorithm?\r\n                \r\nWe have 3 variants of Merge sort. \n\n\nTop down\nBottom up\nNatural\n\n\nAre any of these adaptive algorithms? For instance, if an array is sorted they will take advantage of the sorted order.\n\nAccording to me, no matter if an array is sorted or not, merge sort will still go in for comparisons and then merge. So, the answer is none of these are adaptive.\n\nIs my understanding is correct?\n    ", "Answer": "\r\nNatural merge sort is adaptive. For example, it executes only one run through sorted array and makes N comparisons.\n\nBoth top down and bottom up sorts are not adaptive, they always make O(NlogN) operations\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Purpose of sentinel values in merge sort\r\n                \r\nI am currently taking my first algorithms class and we have recently begun talking about merge sort. Our professor showed us the pseudocode for merge sort with sentinel values, but did not really explain their purpose. I am still fairly confused as to what purpose they serve, as one of our homework problems is to write a merge sort without sentinel values. Are there any advantages or disadvantages to including sentinel values? Any help would be greatly appreciated.\n\nEdit: Just as a note, I have programmed a merge sort previously and did so without sentinel values, which is part of what has led to my confusion.\n    ", "Answer": "\r\nThe use of sentinels in merge sort prevents us from needing to check to see if we have reached the end of either of the arrays being sorted. Merge sort can be performed without a sentinel, but an implementation of merge sort without a sentinel adds an additional check for every iteration of the comparison loop.\n\nFor example:\n\nI'll describe this as it's described in Introduction and Analysis of Algorithms by Cormen, Leiserson, Rivest, and Stein, using two stacks of  playing cards to represent two arrays to be sorted.\n\nWe'll assume that both piles of cards are face-up and sorted such that the smallest card in each pile is on the top, and the largest card in each pile is on the bottom.\n\nLet's call the left-hand pile of cards array 'L' and the right-hand pile of cards array 'R'.\n\nFor each iteration of the merge sort, we'll compare the top card on each pile and determine which is the smallest. We'll take the smallest card off of the pile, and place it face-down to create a new pile of sorted cards. This is the overarching principle of merge sort.\n\nBUT, before we can perform a comparison between the top card on each pile, we have to make sure that there IS a card on each pile. For example, IF the cards in the left pile were consistently smaller than the cards in the right pile, we could exhaust the cards in the left pile before touching any of the cards in the right pile. In our code, this would mean as we continued to try and look at the next item in our array, we would eventually try to access an index of the array that doesn't exist, because we've already looked at all of that array's values. To protect ourselves from this occurrence, we would need to precede each comparison in the merge sort with a check to ensure that there is still a value in each array to compare.\n\nUsing a sentinel prevents us from needing to perform this extra check before each comparison by ensuring that we will never be able to remove all of the cards from one or the other pile. If we were to use 'infinity' as a sentinel value, then the 'infinity' card will NEVER get removed from the pile because no value will ever be larger than 'infinity'. This ensures that there will ALWAYS be a value in the array to compare against.\n\nThink of the above example: where cards in the left pile are consistently smaller than cards in the right pile. Cards in the left pile will be removed one at a time UNTIL the 'infinity' (sentinel) card is reached. Then, the cards in the right pile will begin being exhausted.\n\nAt some point, BOTH piles will have their 'infinity' card on top. However, by this point, the loop counter will have reached it's maximum value, causing the loop to terminate BEFORE it can attempt to access an array index that doesn't exist.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Python-Merge sort difficulties\r\n                \r\nI attempted to implement a merge sort, here is my code: \n\n```\ndef mergeSort(array):\n    result=[]\n    n=len(array)\n    if n==1:\n        result=array\n    else:\n        a=round(n/2)\n        first=mergeSort(array[0:a])\n        second=mergeSort(array[a:n])\n\n        for i in range(len(first)):\n            for j in range(len(second)):\n                if first[i]<second[j]:\n                    result.append(first[i])\n                    i=i+1\n                else:\n                    result.append(second[j])\n                    j=j+1\n    return result\n\na=[5,4,1,8,7,6,2,3]\nb=mergeSort(a)\nprint(b)\n```\n\n\nUnfortunately, the result turns out to be ```\n[1]```\n. What is wrong with my function?\n    ", "Answer": "\r\nA number of things...\n\nFirstly, this is a recursive function, meaning you cannot create a list within the function, as you did here:\n\n```\nresult=[]\n```\n\n\nThis will simply reset your list after every recursive call, skewing your results. The easiest thing to do is to alter the list that is passed as a parameter to merge sort.\n\nYour next problem is that you have a for loop within a for loop. This will not work because while the first for loop iterates over ```\nfirst```\n, the second for loop will iterate over ```\nsecond```\n for every increment of ```\ni```\n, which is not what you want. What you need is to compare both ```\nfirst```\n and ```\nsecond```\n and extract the minimum value, and then the next minimum value, and so on until you get a sorted list.\nSo your for loops need to be changed to the following:\n\n```\nwhile i < len(first) and j < len(second):\n```\n\n\nWhich leads me to final problem in your code. The while loop will exit after one of the conditions are met, meaning either ```\ni```\n or ```\nj```\n (one or the other) will not have reached ```\nlen(first)```\n or ```\nlen(second)```\n. In other words, there will be one value in either ```\nfirst```\n or ```\nsecond```\n that is unaccounted for. You need to add this unaccounted value to your sorted list, meaning you must implement this final excerpt at the end of your function:\n\n```\nremaining = first if i < j else second\nr = i if remaining == first else j\n\nwhile r < len(remaining):\n    array[k] = remaining[r]\n    r = r + 1 \n    k = k + 1\n```\n\n\nHere ```\nr```\n represents the index value where the previous while loop broke off. The while loop will then iterate through the rest of the remaining values; adding them to the end of your sorted list.\n\nYou merge sort should now look as follows:\n\n```\ndef mergeSort(array):\n    if len(array)==1:\n        return array\n    else:\n        a=round(len(array)/2)\n        first=mergeSort(array[:a])\n        second=mergeSort(array[a:])\n        i = 0\n        j = 0\n        k = 0\n        while i < len(first) and j < len(second):\n            if first[i]<second[j]:\n                array[k] = first[i]\n                i=i+1\n                k=k+1\n            else:\n                array[k] = second[j]\n                j=j+1\n                k=k+1\n\n        remaining = first if i < j else second\n        r = i if remaining == first else j\n\n        while r < len(remaining):\n            array[k] = remaining[r]\n            r += 1; k += 1\n\n    return array\n```\n\n\nI tried to not alter your code as much as possible in order to make it easier for you to understand. However, if your difficulty in understanding what I did persists, try de-bugging your merge sort using multiple print statements so that you can follow the function's progress and see where it goes wrong.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "threaded merge sort giving invalid results\r\n                \r\nI created a merge sort that works fine for arrays of non repeating integers.\nI am attempting to make a multithreaded version of the same.\n\nI am getting back invalid results.\n\n```\nvoid mergesort(int data[ ], size_t n)\n{\n    size_t n1; // Size of the first subarray\n    size_t n2; // Size of the second subarray\n\n    if (n > 1)\n    {\n        // Compute sizes of the subarrays.\n        n1 = n / 2;\n        n2 = n - n1;\n\n        mergesort(data, n1);         // Sort from data[0] through data[n1-1]\n        mergesort((data + n1), n2);  // Sort from data[n1] to the end\n\n        // Merge the two sorted halves.\n        merge(data, n1, n2);\n    }\n}\n\nDWORD WINAPI threadedmergesort(LPVOID params)\n{\n    size_t n1; // Size of the first subarray\n    size_t n2; // Size of the second subarray\n    Params* parameters = (Params*) params;\n    if (parameters->size > 1)\n    {\n        // Compute sizes of the subarrays.\n        n1 = parameters->size / 2;\n        n2 = parameters->size - n1;\n\n        Params* p1 = new Params(parameters->dataArray, n1);\n        //mergesort(data, n1);         // Sort from data[0] through data[n1-1]\n        HANDLE h1 = CreateThread(NULL, 0, threadedmergesort, (LPVOID)p1, 0, NULL);\n        Params* p2 = new Params(parameters->dataArray, n2);\n        //mergesort((data + n1), n2);  // Sort from data[n1] to the end\n        HANDLE h2 = CreateThread(NULL, 0, threadedmergesort, (LPVOID)p1, 0, NULL);\n        WaitForSingleObject(h1, INFINITE);\n        WaitForSingleObject(h2, INFINITE);\n\n        // Merge the two sorted halves.\n        merge(parameters->dataArray, n1, n2);\n    }\n    return (DWORD)0x0; //null\n}\n\nstruct Params\n{\n    int* dataArray;\n    int size;\n    Params(int _dataArray[], int _size);\n};\nParams::Params(int _dataArray[], int _size)\n{\n    dataArray = _dataArray;\n    size = _size;\n}\n```\n\n\nCould someone comment on why I would get invalid results with the threaded version of the merge sort and what I could do to correct the problem?\n    ", "Answer": "\r\n```\nParams* p1 = new Params(parameters->dataArray, n1);\n//mergesort(data, n1);         // Sort from data[0] through data[n1-1]\nHANDLE h1 = CreateThread(NULL, 0, threadedmergesort, (LPVOID)p1, 0, NULL);\nParams* p2 = new Params(parameters->dataArray, n2);\n//mergesort((data + n1), n2);  // Sort from data[n1] to the end\nHANDLE h2 = CreateThread(NULL, 0, threadedmergesort, (LPVOID)p1, 0, NULL);\n```\n\n\nIt looks like you're sending p1 twice to the mergesorter. So you're just sorting the first halfs of your list. Change your second parameter and everything should be correct. \nMy Mergesort looks like this: \n\n```\nDWORD WINAPI Mergesorter::mergesort_MT(LPVOID param)\n{\n    Mergesort_Params* i_mergesortParams = (Mergesort_Params*)param;\n    unsigned int half = i_mergesortParams->numberOfValues / 2;\n    DWORD threadId[2] = {0,0};\n    HANDLE h[2];\n    Mergesort_Params* mergesortParams;\n\n    if(i_mergesortParams->numberOfValues > 1)\n    {\n        mergesortParams = new Mergesort_Params[2];\n        mergesortParams[0].l_list = i_mergesortParams->l_list;\n        mergesortParams[1].l_list = i_mergesortParams->l_list + half;\n        mergesortParams[0].numberOfValues = half;\n        mergesortParams[1].numberOfValues = i_mergesortParams->numberOfValues - half;\n\n        h[0] = CreateThread(0,0,mergesort_MT,(void*)&mergesortParams[0],0,&threadId[0]);\n        //WaitForSingleObject(h[0],INFINITE);\n        h[1] = CreateThread(0,0,mergesort_MT,(void*)&mergesortParams[1],0,&threadId[1]);        \n        //WaitForSingleObject(h[1],INFINITE);\n        WaitForMultipleObjects(2,h,TRUE,INFINITE);\n        merge_ST(i_mergesortParams->l_list,half,i_mergesortParams->numberOfValues - half);\n\n\n    }\n\n//delete threadId;\n//delete h;\n//delete mergesortParams;\n\nreturn 0;\n}\n```\n\n\nDid you fix your problem? Now my problem is, that I'm not able to sort enough values 100000 are too much (Single-Threaded no problem) and my CPU isn't used completely (25% on my A8-3500M so just one core)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort code throwing NullPointerException\r\n                \r\nI did a very simple merge sort implementation but I keep on getting java.lang.NullPointerException. Here's my code : \n\n```\npublic class MergeSort {\n\n    private int[] c;\n    private int i = 0, j = 0, k = 0;\n\n    public MergeSort(int[] a, int[] b){\n\n        while( i < a.length && j < b.length){\n\n            if(a[i] > b[j])\n                c[k++] = b[j++];\n            else\n                c[k++] = a[i++];\n        }\n\n        while(i < a.length){\n            c[k++] = a[i++];\n        }\n\n        while(j < b.length){\n            c[k++] = b[j++];\n        }\n\n        i = 0;\n        while(i < c.length){\n            System.out.print(c[i++] + \" \");\n        }\n    }\n\n}\n```\n\n\nAnd I am calling the constructor from the main class like this: \n\n```\npublic class MainRun {\n\n\n    public static void main(String[] args) {\n\n        System.out.println(\"Merge Sort Algorithm\");\n\n        int a[] = {1, 3, 5, 7, 9};\n        int b[] = {2, 6, 7, 9, 11};\n\n        new MergeSort(a, b);\n\n    }\n\n}\n```\n\n\nWhile I know I get the exception for using uninitialized objects, still I am unable to find the error in my code. Here's the exact error: \n\n\n  Merge Sort Algorithm Exception in thread \"main\"\n  java.lang.NullPointerException    at MergeSort.(MergeSort.java:14)\n    at MainRun.main(MainRun.java:11)\n\n\nWhat am I doing wrong? Thanks :)\n    ", "Answer": "\r\n```\nc```\n is not initialized\n\nyou do this by writing: \n\n```\nprivate int[] c = new int[x];\n```\n\n\nthis creates an array with the length ```\nx```\n filled with zeros\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Python merge sort + insertion sort hybrid Tim sort\r\n                \r\nI have already made code for insertion sort and merge sort. Now I want to implement my insertion sort and merge sort into a Tim sort.\nI can see that the example of Tim sort uses start, mid and end inputs but it should be possible to do this without no?\nI would like to keep my merge and insertion sorts as they are if possible because of input outputs fits well with the rest of my code.\n```\nfrom random import randint\nminrun = 32\n\ndef insertion_sort(in_data):\n    s_data = list(in_data)\n    for i in range(1, len(s_data)):\n        key = s_data[i]\n        j = i - 1\n        while j >= 0 and key < s_data[j]:\n            s_data[j + 1] = s_data[j]\n            j -= 1\n        s_data[j + 1] = key\n    return s_data\n\ndef merge(a, b):\n    c = []\n    a_idx, b_idx = 0, 0\n    while a_idx < len(a) and b_idx < len(b):\n        if a[a_idx] < b[b_idx]:\n            c.append(a[a_idx])\n            a_idx += 1\n        else:\n            c.append(b[b_idx])\n            b_idx += 1\n    if a_idx == len(a):\n        c.extend(b[b_idx:])\n    else:\n        c.extend(a[a_idx:])\n    return c\n\ndef merge_sort(a):\n    if len(a) <= 1:\n        return a\n    left, right = merge_sort(a[:len(a) // 2]), merge_sort(a[len(a) // 2:])\n    return merge(left, right)\n\ndef tim_sort(in_data):\n    n = len(in_data)\n\n    for start in range(0, n, minrun):\n        end = min(start + minrun - 1, n - 1)\n        in_data = insertion_sort(in_data, start, end)\n\n    curr_size = minrun\n    while curr_size < n:\n        for start in range(0, n, curr_size * 2):\n            mid = min(n - 1, start + curr_size - 1)\n            end = min(n - 1, mid + curr_size)\n            in_data = merge_sort(in_data, start, mid, end)\n        curr_size *= 2\n    return in_data\n\ndef create_array(size=10, max=50):\n    from random import randint\n    return [randint(0, max) for _ in range(size)]\n```\n\nI found this example of Tim sort but I struggle with how to make it work within my code.\n    ", "Answer": "\r\n27 November 2020\nIt is not clear where you obtained this example, but it certainly is not timsort.  If you want to implement timsort, the first thing to do is read and understand Tim Peters description of the algorithm:\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt\nThis is the definitive document regarding timsort.  You can find all kinds of rubbish with google.  The only reference I have ever found that might be worth reading to get your feet wet is:\nhttps://www.infopulse.com/blog/timsort-sorting-algorithm\nwhich is lightweight, but fairly complete and not seriously incorrect in any way.  It does, however, omit any consideration of galloping, which is the trickiest part of the algorithm.\nIt is important to realize ```\npython```\n is a dynamic language so dumbly implementing timsort will produce something that uses large excesses of memory due to internal object allocation.  Timsort requires:\n\nsorting in-place\nstability\nmaintaining an invariant\ngalloping\nthorough testing\n\nSorting in-place in ```\npython```\n implies indexing the data list manually.  If you use slices, you allocate and dispose of memory each time.\nThere are three ```\npython```\n implementations on the web that are worth looking at for guidance that I am aware of:\n1 https://github.com/reingart/pypy/blob/master/rpython/rlib/listsort.py\n2 https://gist.github.com/ruminations/89a045dc0ef7edfb92304a0de0752ee0\n3 https://github.com/hu-ng/timsort\nThe first is part of the ```\npypy```\n trunk and is implemented in ```\nrpython```\n.  It appears to be an adaptation of the ```\ncpython```\n implementation.  ```\nrpython```\n is a restricted subset of python intended for static compilation.\nThe second is a well tested implementation that is well documented and fairly readable.  The last is apparently a university exercise, and appears to be complete and correct, but not well tested.\nYou can find dozens of other attempts at python implementation of timsort but all I have seen either fail to fulfill basic requirements or are clearly incorrect.\nFinally, if you expect someone to help you adapt your code, you should at least link to it, but better to provide it directly, for neither mergesort nor insort are difficult to code.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Three way merge sort problem not sorting correctly\r\n                \r\nI've been working on this three way merge sort algorithm which I based off of my normal merge sort code; however, it isn't sorting correctly and so I believe there might be a minor mistake in my code. Any help please? I've been looking into the code for 3 hours trying to find the problem but it has proven difficult.\n```\npublic class TriMergeSort {\n\n    void merge(int arr[], int low, int mid1, int mid2, int high) { \n        int sizeA = mid1 - low + 1; \n        int sizeB =  mid2 - mid1;\n        int sizeC = high - mid2;\n\n        int A[] = new int[sizeA]; \n        int B[] = new int[sizeB]; \n        int C[] = new int[sizeC];\n\n        for (int i = 0; i < sizeA; i++) \n            A[i] = arr[low + i]; \n        for (int j = 0; j < sizeB; j++) \n            B[j] = arr[mid1 + j + 1]; \n        for (int x = 0; x < sizeC; x++) \n            C[x] = arr[mid2 + x + 1];\n\n        int i = 0, j = 0, x = 0; \n        int k = low; \n        \n        while (i < sizeA && j < sizeB && x < sizeC) {\n            \n            if (A[i] < B[j] && A[i] < C[x]) { \n                arr[k] = A[i]; \n                i++; \n            } else\n            if (A[i] >= B[j] && B[j] < C[x]) { \n                arr[k] = B[j]; \n                j++; \n            } else\n            if (A[i] > C[x] && B[j] >= C[x]) { \n                arr[k] = C[x]; \n                x++; \n            } \n            k++; \n        } \n\n        while (i < sizeA) { \n            arr[k] = A[i]; \n            i++; \n            k++; \n        } \n\n        while (j < sizeB) { \n            arr[k] = B[j]; \n            j++; \n            k++; \n        } \n        \n        while (x < sizeC) { \n            arr[k] = C[x]; \n            x++; \n            k++; \n        }\n    } \n\n    void sort(int arr[], int low, int high) { \n        \n        if (low < high) {  \n            int mid1 = low + ((high - low) / 3); \n            int mid2 = low + 2 * ((high - low) / 3) + 1;\n\n            sort(arr, low, mid1); \n            sort(arr, mid1 + 1, mid2); \n            sort(arr, mid2 + 1, high);\n\n            merge(arr, low, mid1, mid2, high); \n        } \n    } \n\n    static void print(int arr[]) { \n        int n = arr.length; \n        for (int i = 0; i < n; ++i) \n            System.out.print(arr[i] + \" \"); \n        System.out.println(); \n    } \n\n    public static void main(String args[]) { \n        int arr[] = { 15, 2, 6, 7, 55, 0, 28, 41, 12 }; \n\n        TriMergeSort test = new TriMergeSort(); \n        test.sort(arr, 0, arr.length - 1); \n\n        print(arr); \n    }\n} \n```\n\n    ", "Answer": "\r\nThe code posted in the question works fine. You did not post the 3-way merge code you have problems with.\nNote that instead of passing ```\nhigh```\n as the index to the last item in the slice to sort, you should pass the index of the first element beyond the slice. This allows for simpler code, without confusing and error prone ```\n+1```\n/```\n-1```\n adjustments.\nHere is a modified version:\n```\npublic class MergeSort { \n\n    void merge(int arr[], int low, int mid, int high) { \n        int sizeA = mid - low; \n        int sizeB = high - mid; \n\n        int A[] = new int[sizeA]; \n        int B[] = new int[sizeB]; \n\n        for (int i = 0; i < sizeA; i++) \n            A[i] = arr[low + i]; \n        for (int j = 0; j < sizeB; j++) \n            B[j] = arr[mid + j]; \n\n        int i = 0, j = 0; \n        int k = low; \n        \n        while (i < sizeA && j < sizeB) { \n            if (A[i] <= B[j]) { \n                arr[k++] = A[i++]; \n            } else { \n                arr[k++] = B[j++]; \n            } \n        } \n\n        while (i < sizeA) {\n            arr[k++] = A[i++];\n        } \n\n        while (j < sizeB) { \n            arr[k++] = B[j++];\n        } \n    } \n\n    void sort(int arr[], int low, int high) { \n        if (high - low >= 2) {  \n            int mid = low + (high - low) / 2; \n            sort(arr, low, mid); \n            sort(arr, mid, high); \n            merge(arr, low, mid, high); \n        } \n    } \n\n    static void print(int arr[]) { \n        int n = arr.length; \n        for (int i = 0; i < n; ++i) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println(); \n    } \n\n    public static void main(String args[]) { \n        int arr[] = { 15, 2, 6, 7, 55, 0, 28, 41, 12, 10, 59 }; \n        MergeSort test = new MergeSort(); \n        test.sort(arr, 0, arr.length); \n        print(arr); \n    } \n}\n```\n\nTo convert this into a 3-way merge version, ```\nsort3```\n must follow these steps:\n\nsplit the range into 3 slices instead of 2. The first slice runs from ```\nlow```\n to ```\nmid1 = low + (high - low)/3```\n excluded, the second from ```\nmid1```\n to ```\nmid2 = low + (high - low)*2/3```\n excluded and the third from ```\nmid2```\n to ```\nhigh```\n excluded.\nsort each of the 3 subslices recursively\ncall ```\nmerge3(arr, low, mid1, mid2, high)```\n\n\nmake copies of the 3 subslices\nwrite a loop for 3 index values running the 3 slices until one of them is exhausted\nwrite 3 loops for the 2 remaining slices (A and B) or (B and C) or (A and C),\nwrite 3 loops to copy the remaining elements from the remaining slice, A, B or C\n\n\n\nEDIT: the ```\nmerge```\n function in your ```\nTriMergeSort```\n class is missing the 3 loops that merge 2 slices once one of the 3 initial slices is exhausted. This explains why the array does not get properly sorted. After the 3-way merge loop, you should have:\n```\n    while (i < sizeA && j < sizeB) {\n        ...\n    }\n    while (i < sizeA && x < sizeC) {\n        ...\n    }\n    while (j < sizeB && x < sizeC) {\n        ...\n    }\n```\n\nTo avoid all these repeated loops, you could combine tests on the index values into a single loop body:\n```\npublic class TriMergeSort {\n\n    void merge(int arr[], int low, int mid1, int mid2, int high) { \n        int sizeA = mid1 - low; \n        int sizeB = mid2 - mid1;\n        int sizeC = high - mid2;\n\n        int A[] = new int[sizeA]; \n        int B[] = new int[sizeB]; \n        int C[] = new int[sizeC];\n\n        for (int i = 0; i < sizeA; i++) \n            A[i] = arr[low + i]; \n        for (int j = 0; j < sizeB; j++) \n            B[j] = arr[mid1 + j]; \n        for (int k = 0; k < sizeC; k++) \n            C[k] = arr[mid2 + k];\n\n        int i = 0, j = 0, k = 0;\n        \n        while (low < high) {\n            if (i < sizeA && (j >= sizeB || A[i] <= B[j])) {\n                if (k >= sizeC || A[i] <= C[k]) {\n                    arr[low++] = A[i++];\n                } else {\n                    arr[low++] = C[k++];\n                }\n            } else {\n                if (j < sizeB && (k >= sizeC || B[j] <= C[k])) {\n                    arr[low++] = B[j++];\n                } else {\n                    arr[low++] = C[k++];\n                }\n            }\n        } \n    } \n\n    void sort(int arr[], int low, int high) { \n        if (high - low >= 2) {  \n            int mid1 = low + (high - low) / 3; \n            int mid2 = low + (high - low) * 2 / 3;\n            sort(arr, low, mid1); \n            sort(arr, mid1, mid2); \n            sort(arr, mid2, high);\n            merge(arr, low, mid1, mid2, high); \n        } \n    } \n\n    static void print(int arr[]) { \n        int n = arr.length; \n        for (int i = 0; i < n; ++i) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println(); \n    } \n\n    public static void main(String args[]) { \n        int arr[] = { 15, 2, 6, 7, 55, 0, 28, 41, 12 }; \n        TriMergeSort test = new TriMergeSort(); \n        test.sort(arr, 0, arr.length); \n        print(arr); \n    }\n}\n```\n\nThe ```\nwhile```\n loop above can be further simplified but somewhat less readable as:\n```\n    while (low < high) {\n        if (i < sizeA && (j >= sizeB || A[i] <= B[j])) {\n            arr[low++] = (k >= sizeC || A[i] <= C[k]) ? A[i++] : C[k++];\n        } else {\n            arr[low++] = (j < sizeB && (k >= sizeC || B[j] <= C[k])) ? B[j++] : C[k++];\n        }\n    } \n```\n\nAnd even one step further:\n```\n    while (low < high) {\n        arr[low++] = (i < sizeA && (j >= sizeB || A[i] <= B[j])) ?\n            ((k >= sizeC || A[i] <= C[k]) ? A[i++] : C[k++]) :\n            (j < sizeB && (k >= sizeC || B[j] <= C[k])) ? B[j++] : C[k++];\n    } \n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "random_randint does not work with merge sort\r\n                \r\nMerge sort using some random numbers is not working. I get ```\nNone```\n as the output on the terminal when I call ```\nmerge_sort()```\n to sort the random numbers. Any ideas?\n\nOutput: \nRandom Numbers?:\n20\nMerge Sort: [7, 7, 10, 19, 10, 1, 3, 6, 15, 10, 15, 5, 0, 1, 6, 9, 15, 1, 5, 6]\nNone\n\n```\n\ndef merge_sort(sequence):\n    if len(sequence) > 1:\n        half_sequence = len(sequence) // 2\n        first_half = sequence[:half_sequence]\n        second_half = sequence[half_sequence:]\n\n        merge_sort(first_half)\n        merge_sort(second_half)\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(first_half) and j < len(second_half):\n            if first_half[i] < second_half[j]:\n                sequence[k] = first_half[i]\n                i += 1\n                #print (i)\n            else: \n                sequence[k] = second_half[j]\n                j += 1\n            k += 1\n            #print (i)\n\n        while i < len(first_half):\n\n            sequence[k] = first_half[i]\n            i += 1\n            k += 1\n\n        while j < len(second_half):\n            sequence[k] = second_half[j]\n            j += 1\n            k += 1\n\ndef random_list(n):\n    lista = [0] * n\n    for i in range(n):\n          lista[i] = random.randint(0,n)\n    return lista\n\nprint(\"Random Numbers?:\")\nn=int(input())\n\nrandom_num = random_list(n)\nprint (\"Merge Sort: {}\".format(random_num))\nprint(merge_sort(random_num))´´´\n```\n\n    ", "Answer": "\r\nYour ```\nmerge_sort```\n function does not have a ```\nreturn```\n statement\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "benchmarking bubble sort vs merge sort using JMH\r\n                \r\nI am benchmarking an implementation for merge sort and bubble sort for a school project using JMH.\nThe results aren't what I expected because it seems to me that bubble sort is performing better.\nso is there something wrong in my benchmarking or my implementation of the algorithms?\nbenchmarking code:\n```\n    @Benchmark\n    @BenchmarkMode(Mode.AverageTime)\n    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n    @Fork(value = 1)\n    @Warmup(iterations = 2)\n    @Measurement(iterations = 3)\n    public void init() {\n        int arr[]={3,2,2,2,1,3,2,3,2,3,0,1,22,9,12,44,55,1000,99,33,333,4,33339,32,3,444,332345,32939,39493,3,2,2,2,1,3,2,3,2,3,0,1,22,9,12,44,55,1000,99,33,333,4,33339,32,3,444,332345,32939,39493,3,2,2,2,1,3,2,3,2,3,0,1,22,9,12,44,55,1000,99,33,333,4,33339,32,3,444,332345,32939,39493};\n\n mergeSort(arr,0,arr.length-1);\n //bubbleSort(arr);\n\n     \n\n    }\n```\n\nThe results:\nmerge sort:\n```\n    \"\n# JMH version: 1.35\n# VM version: JDK 16.0.2, Java HotSpot(TM) 64-Bit Server VM, 16.0.2+7-67\n# VM invoker: C:\\Program Files\\Java\\jdk-16.0.2\\bin\\java.exe\n# VM options: -javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2021.2.2\\lib\\idea_rt.jar=8379:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2021.2.2\\bin -Dfile.encoding=UTF-8\n# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)\n# Warmup: 2 iterations, 10 s each\n# Measurement: 3 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Average time, time/op\n# Benchmark: benchmark.testBM.init\n\n# Run progress: 0.00% complete, ETA 00:00:50\n# Fork: 1 of 1\n# Warmup Iteration   1: 2411.561 ns/op\n# Warmup Iteration   2: 2403.000 ns/op\nIteration   1: 2434.613 ns/op\nIteration   2: 2505.492 ns/op\nIteration   3: 2578.021 ns/op\n\n\nResult \"benchmark.testBM.init\":\n  2506.042 ±(99.9%) 1308.179 ns/op [Average]\n  (min, avg, max) = (2434.613, 2506.042, 2578.021), stdev = 71.706\n  CI (99.9%): [1197.864, 3814.221] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:00:50\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark    Mode  Cnt     Score      Error  Units\ntestBM.init  avgt    3  2506.042 ± 1308.179  ns/op\n\nProcess finished with exit code 0\n```\n\nso its average is : 2506.042\nbubble sort:\n```\n    \"\n\n# Run progress: 0.00% complete, ETA 00:00:50\n# Fork: 1 of 1\n# Warmup Iteration   1: 1963.402 ns/op\n# Warmup Iteration   2: 1815.476 ns/op\nIteration   1: 1831.914 ns/op\nIteration   2: 1863.120 ns/op\nIteration   3: 1874.605 ns/op\n\n\nResult \"benchmark.testBM.init\":\n  1856.546 ±(99.9%) 403.037 ns/op [Average]\n  (min, avg, max) = (1831.914, 1856.546, 1874.605), stdev = 22.092\n  CI (99.9%): [1453.509, 2259.584] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:00:50\n\nBenchmark    Mode  Cnt     Score     Error  Units\ntestBM.init  avgt    3  1856.546 ± 403.037  ns/op\n\nProcess finished with exit code 0\n```\n\nthe average is : 1856.546\nso does anyone know what is the problem may be?\nimplementation of bubble sort:\n```\n   public int[] bubbleSort(int arr[])\n    {\n        for(int i = 0 ; i< arr.length;i++)\n        {\n            for(int j =arr.length-1 ; j>=i+1;j--)\n            {\n                if(arr[j]<arr[j-1])\n                {\n                    int temp = arr[j-1];\n                    arr[j-1]=arr[j];\n                    arr[j]=temp;\n\n                }\n            }\n        }\n        return arr;\n    }\n```\n\nimplementation of merge sort:\n```\n public void merge(int[] arr, int p, int q, int r) {\n\n    int left = q - p + 1;\n    int right = r - q;\n\n    int[] L = new int[left];\n    int[] R = new int[right];\n\n    for (int i = 0; i < left; ++i)\n        L[i] = arr[p + i];\n    for (int j = 0; j < right; ++j)\n        R[j] = arr[q + 1 + j];\n\n    int i = 0, j = 0;\n    int z = p;\n    while (i < left && j < right) {\n\n        if (L[i] <= R[j]) {\n            arr[z] = L[i];\n            i++;\n        } else {\n            arr[z] = R[j];\n            j++;\n        }\n        z++;\n    }\n\n\n    while (i < left) {\n        arr[z] = L[i];\n        i++;\n        z++;\n    }\n\n    while (j < right) {\n        arr[z] = R[j];\n        j++;\n        z++;\n\n    }\n\n\n}\n\npublic void mergeSort(int[] arr, int p, int r) {\n    if (p < r) {\n\n        int q = p + (r - p) / 2;\n        mergeSort(arr, p, q);\n        mergeSort(arr, q + 1, r);\n        merge(arr, p, q, r);\n\n\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "incorrect output of merge sort\r\n                \r\nI am trying to write a merge sort algorithm using template functions in c++. The output is close but not correct. When I give the function the array [7, 6, 4, 8, 1, 2, 3], it returns [1, 1, 2, 2, 3, 3, 8]. I specifically believe that the problem is in the merge function rather than the merge sort function. Any help would be much appreciated. Here is my code:\n\n```\ntemplate <class T1>\nvoid mergeSort(T1 array[], int lower, int upper)\n{\n    if (lower < upper)\n    {\n        int middle = (lower + upper) / 2;\n\n        mergeSort(array, lower, middle);\n        mergeSort(array, middle + 1, upper);\n        merge(array, lower, middle, upper);\n    }\n}\n\ntemplate <class T1>\nvoid merge(T1 array1[], int lower, int middle, int upper)\n{\n    int i = 0,\n        j = 0,\n        k = 0;\n    int size1 = middle - lower + 1;\n    int size2 = upper - middle;\n    T1* temp1 = new T1[size1];\n    T1* temp2 = new T1[size2];\n\n    for (int i = 0; i < size1; i++)\n    {\n        temp1[i] = array1[lower + i];\n    }\n    for (int j = 0; j < size2; j++)\n    {\n        temp2[j] = array1[middle + 1 + j];\n    }\n\n    while (i < size1 && j < size2)\n    {\n        if (temp1[i] < temp2[j])\n        {\n            array1[k] = temp1[i];\n            i++;\n        }\n        else\n        {\n            array1[k] = temp2[j];\n            j++;\n        }\n        k++;\n    }\n\n    if (i == size1)\n    {\n        while (j < size2)\n        {\n            array1[k] = temp2[j];\n            k++;\n            j++;\n        }\n    }\n    else\n    {\n        while (i < size1)\n        {\n            array1[k] = temp1[i];\n            k++;\n            i++;\n        }\n    }\n}\n\nint main(){\n     int a[] = { 7, 6, 4, 8, 1, 2, 3 };\n     mergeSort(a, 0, 6);\n}\n```\n\n\nOutput:\n\n```\n1 1 2 2 3 3 8\n```\n\n    ", "Answer": "\r\nIn your ```\nmerge```\n function you shouldn't initialize ```\nk```\n to 0 because it will write the result of merge in the wrong place. Instead you should initialize ```\nk```\n to ```\nlower```\n. Because that is the start index of the part you are actually sorting.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort code in F# not sorting\r\n                \r\nIm trying to write a merge sort code. its printing though not sorting. What could I be doing wrong? \n\n```\nlet rec mergePm xs ys =\n    match (xs, ys) with\n    | [], _ -> ys\n    | _,[] -> xs\n    | x::xs, y::ys ->\n        if x < y then x :: mergePm xs (y::ys)\n        else y :: mergePm (x::xs) ys\n\nlet rec msortPm xs =\n    let sz = List.length xs\n    if sz < 2 then xs\n    else\n        let n = sz / 2\n        let ys = xs. [0..n-1]\n        let zs = xs.[n..sz-1]\n            in mergePm (msortPm ys) (msortPm zs)\n\nprintfn \"%A\" (msortPm[1,2,6,5])\n```\n\n    ", "Answer": "\r\nYou're using the wrong list syntax. \n\nWhen you say ```\n[1,2,6,5]```\n, you're not making a list of four elements, but rather a list one one element, and that element is a tuple of four numbers.\n\nIn F# list elements are separated by either a new line or a semicolon.\n\nThis should work fine:\n\n```\nprintfn \"%A\" (msortPm[1;2;6;5])\n```\n\n\n\n\nAdditionally, I'd like to point out that ```\nList.length```\n does a full pass of the list (since F# lists are immutable singly linked lists), so that slows down your algorithm. It's better to pattern-match on empty list and list of one element:\n\n```\nlet rec msortPm xs = match xs with\n    | [] | [_] -> xs\n    | _ ->\n        let n = sz / 2\n        let ys = xs. [0..n-1]\n        let zs = xs.[n..sz-1]\n        mergePm (msortPm ys) (msortPm zs)\n```\n\n\n(also notice how ```\nin```\n after ```\nlet```\n is optional in F#)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "javascript merge sort and recursion\r\n                \r\nI am trying to understand how JavaScript merge sort function work. And I struggle understanding how the recursive function work. This is the code:\n```\nconst mergeSort = array => {\n  if (array.length < 2) {\n    //function stop here\n    return array\n  }\n\n  const middle = Math.floor(array.length / 2);\n  const leftSide = array.slice(0, middle);\n  const rightSide = array.slice(middle, array.length);\n  return merge(mergeSort(leftSide), mergeSort(rightSide))\n\n};\n\nconst merge = (left, right) => {\n  const result = [];\n\n  while (left.length && right.length) {\n    if (left[0] <= right[0]) {\n      result.push(left.shift());\n    } else {\n      result.push(right.shift);\n    }\n  }\n\n  while(left.length) result.push(left.shift());\n\n  while(right.length) result.push(right.shift());\n\n  return result;\n}\nmergeSort([5,3,8,10,4,1])\n```\n\n    ", "Answer": "\r\nTo understand recursion you can trace all recursion levels with indentation. For example:\n\n```\nconst mergeSort = (array, level) => {\n  logWithLevel(level, \"Start sort array \" + array);\n  if(array.length < 2) {\n    //function stop here\n    logWithLevel(level, \"Finish sort array \" + array);\n    return array;\n  }\n\n  const middle = Math.floor(array.length / 2);\n  logWithLevel(level, \"middle element is \" + array[middle])\n  const leftSide = array.slice(0, middle);\n  const rightSide = array.slice(middle, array.length);\n  var result = merge(mergeSort(leftSide, level + 1), mergeSort(rightSide, level + 1));\n  logWithLevel(level, \"Finish sort array \" + result);\n  return result;\n};\n\nconst merge = (left, right) => {\n  const result = [];\n\n  while(left.length && right.length){\n    if(left[0] <= right[0]){\n      result.push(left.shift());\n    }else{\n      result.push(right.shift());\n    }\n  }\n\n  while(left.length) result.push(left.shift());\n\n  while(right.length) result.push(right.shift());\n\n  return result;\n}\n\nconst logWithLevel = (level, data) => {\n    var s = \"\"\n    for (i = 0; i < level; i++) {\n        s += \"    \";\n    }\n    console.log(s + data);\n}\n```\n\n\nAnd result:\n\n```\n> mergeSort([5,3,8,10,4,1], 0)\n    Start sort array 5,3,8,10,4,1\n    middle element is 10\n        Start sort array 5,3,8\n        middle element is 3\n            Start sort array 5\n            Finish sort array 5\n            Start sort array 3,8\n            middle element is 8\n                Start sort array 3\n                Finish sort array 3\n                Start sort array 8\n                Finish sort array 8\n            Finish sort array 3,8\n        Finish sort array 3,5,8\n        Start sort array 10,4,1\n        middle element is 4\n            Start sort array 10\n            Finish sort array 10\n            Start sort array 4,1\n            middle element is 1\n                Start sort array 4\n                Finish sort array 4\n                Start sort array 1\n                Finish sort array 1\n            Finish sort array 1,4\n        Finish sort array 1,4,10\n    Finish sort array 1,3,4,5,8,10\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Understanding Recursion with Merge sort\r\n                \r\nI see some of the posts to understand merge sort. I know recursive methods maintains stack to hold values. (my understand was return statement result will be in stack )\n\n```\nprivate int recur(int count) {\n    if (count > 0) {\n        System.out.println(count);\n        return count + recur(--count); // this value will be in stack.\n    }\n    return count;\n}\n```\n\n\nI am confusing in merge sort how stack is maintaining here. \n\n```\nprivate void divide(int low, int high) { \n    System.out.println(\"Divide => Low: \"+ low +\" High: \"+ high);\n    if (low < high) {\n        int middle = (low + high) / 2; \n        divide(low, middle); // {0,7},{0,3}, {0,1} ;\n        divide(middle + 1, high); // {0,0};  high = 1; // 2nd divide\n        combine(low, middle, high);\n    }\n}\n```\n\n\n\nIs stack for all local variables?\nWhen 2nd recursive method calls, 1st recursive will also join? \nHow stack are maintained in such cases?\n\n    ", "Answer": "\r\nYou only have to know that a statement needs to finish and return and that you call ```\ndivide```\n or ```\ncombine```\n from ```\ndivide```\n works the same. Both need to finish before the next line of code can be executed or, if there are no more lines, the function returns. Yes, it's done with stack but it's really not important.\n\n\nThe state of the waiters variables ```\nlow```\n, ```\nhigh```\n and ```\nmiddle```\n is only the current invocations bindings so they don't get mixed with other invocations. \nEvery time you nest a new call it gets it's own variables and each need to finish. When the low-middle is finished it calls middle+1-high and when that finished combine. Those calls will do the same so you will have deeper nesting and how the call structure will be visited is like like a binary tree structure with the leafs being ```\nlow == high```\n (one element).\n\n\nA word of advice. When looking at recursive code try doing it from leaf to more complex tree. eg. try it out with base case first, then the simplest of default case. eg.\n\n\n1 element array: does nothing\n2 element array: -> 1 element array (see 1.), 1 element array, combine\n4 element array: -> 2 element array (see 2.), 2 element array, combine\n\n\nNotice that the 2. you know both recursive calls won't do anything and ```\ncombine```\n will do perhaps a swap. The 3. does 2. twice (including the swap) before ```\ncombine```\n that will merge 2 2 element arrays that are sorted. You are perhaps looking at it the other way, which requires you to halt 3. to do 2. that halts it and does 1., then the next 1, then back to 2. to do the text that has two 1s... It needs pen and paper. Looking at it from leaf to root using what you have learned of it so far lets you understand it much easier. I do think functional recursion is easier to grasp than mutating structures like your merge sort. eg. fibonacci sequence. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "ArrayOutOfBounds Exception Merge Sort\r\n                \r\nI'm working on Merge Sort, and an ```\nArrayIndexOutOfBoundsException```\n is being thrown. I've been combing the code looking for the error and cannot find it. The exception stack trace says it is coming from my merge function on line 77 which is ```\ntemp[current3++] = list2[current2++];```\n. Line 102 is ```\nmerge(firstHalf, secondHalf, list);```\n and line 93 is ```\nmergeSortRoutine(firstHalf);```\n. Any and all help is greatly appreciated. Thank you for your time. \n\nBelow are the two functions: \n\n```\n//this function will merge two arrays\nprivate static void merge(Integer[] list1, Integer[] list2, Integer[] temp){\n    int current1 = 0; //current index in list1\n    int current2 = 0; //current index in list2\n    int current3 = 0; //current index in temp\n\n    while((current1 < list1.length) && (current2 < list2.length)){\n\n        if(list1[current1].intValue() < list2[current2].intValue()){\n            temp[current3++] = list1[current1++];\n        }\n        else{\n            temp[current3++] = list2[current2++];\n        }\n    }\n\n    while(current1 < list1.length){\n        temp[current3++] = list2[current2++];\n    }\n\n    while(current2 < list2.length) {\n        temp[current3++] = list2[current2++];\n    }\n}\n\n//merge sort function\nprivate static void mergeSortRoutine(Integer[] list){\n\n    if(list.length > 1){\n\n        //merge sort the first half\n        Integer[] firstHalf = new Integer[(list.length)/2];\n        System.arraycopy(list, 0, firstHalf, 0, (list.length)/2);\n        mergeSortRoutine(firstHalf);\n\n        //merge sort the second half\n        int secondHalfLength = list.length - ((list.length)/2);\n        Integer[] secondHalf = new Integer[secondHalfLength];\n        System.arraycopy(list, (list.length)/2, secondHalf, 0, secondHalfLength);\n        mergeSortRoutine(secondHalf);\n\n        //merge firstHalf with secondHalf into list\n        merge(firstHalf, secondHalf, list);\n    }\n}\n```\n\n\nBelow is the stack trace:\n\n```\njava.lang.ArrayIndexOutOfBoundsException: 1\nat Merge.merge(Merge.java:77)\nat Merge.mergeSortRoutine(Merge.java:102)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.mergeSortRoutine(Merge.java:93)\nat Merge.main(Merge.java:27)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\n```\n\n    ", "Answer": "\r\nAs Scary Wombat says, in your final ```\nwhile```\n loop you're checking current2 and then incrementing it.\n\nIn addition to that, you're incrementing ```\ncurrent2```\n in your second-to-last ```\nwhile```\n loop, ```\nwhile(current1 < list1.length)```\n. I think you probably intended that statement to be ```\ntemp[current3++] = list1[current1++]```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Understanding Recursion with Merge sort\r\n                \r\nI see some of the posts to understand merge sort. I know recursive methods maintains stack to hold values. (my understand was return statement result will be in stack )\n\n```\nprivate int recur(int count) {\n    if (count > 0) {\n        System.out.println(count);\n        return count + recur(--count); // this value will be in stack.\n    }\n    return count;\n}\n```\n\n\nI am confusing in merge sort how stack is maintaining here. \n\n```\nprivate void divide(int low, int high) { \n    System.out.println(\"Divide => Low: \"+ low +\" High: \"+ high);\n    if (low < high) {\n        int middle = (low + high) / 2; \n        divide(low, middle); // {0,7},{0,3}, {0,1} ;\n        divide(middle + 1, high); // {0,0};  high = 1; // 2nd divide\n        combine(low, middle, high);\n    }\n}\n```\n\n\n\nIs stack for all local variables?\nWhen 2nd recursive method calls, 1st recursive will also join? \nHow stack are maintained in such cases?\n\n    ", "Answer": "\r\nYou only have to know that a statement needs to finish and return and that you call ```\ndivide```\n or ```\ncombine```\n from ```\ndivide```\n works the same. Both need to finish before the next line of code can be executed or, if there are no more lines, the function returns. Yes, it's done with stack but it's really not important.\n\n\nThe state of the waiters variables ```\nlow```\n, ```\nhigh```\n and ```\nmiddle```\n is only the current invocations bindings so they don't get mixed with other invocations. \nEvery time you nest a new call it gets it's own variables and each need to finish. When the low-middle is finished it calls middle+1-high and when that finished combine. Those calls will do the same so you will have deeper nesting and how the call structure will be visited is like like a binary tree structure with the leafs being ```\nlow == high```\n (one element).\n\n\nA word of advice. When looking at recursive code try doing it from leaf to more complex tree. eg. try it out with base case first, then the simplest of default case. eg.\n\n\n1 element array: does nothing\n2 element array: -> 1 element array (see 1.), 1 element array, combine\n4 element array: -> 2 element array (see 2.), 2 element array, combine\n\n\nNotice that the 2. you know both recursive calls won't do anything and ```\ncombine```\n will do perhaps a swap. The 3. does 2. twice (including the swap) before ```\ncombine```\n that will merge 2 2 element arrays that are sorted. You are perhaps looking at it the other way, which requires you to halt 3. to do 2. that halts it and does 1., then the next 1, then back to 2. to do the text that has two 1s... It needs pen and paper. Looking at it from leaf to root using what you have learned of it so far lets you understand it much easier. I do think functional recursion is easier to grasp than mutating structures like your merge sort. eg. fibonacci sequence. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Building quick sort and merge sort\r\n                \r\nI have built functions related to quick sort and merge sort. I am not getting any errors but still I am not getting the required output.\n```\n#include <iostream>\n\nusing namespace std;\n\nvoid swap(int *a, int *b);\n\nvoid printarray(int array[], int size);\n\nint partition(int array[], int low, int high, int select);\n\nvoid quicksort(int array[], int low, int high, int select);\n\nvoid merge(int arr[], int p, int q, int r);\n\nvoid mergesort(int arr[], int l, int r);\n\nint main() {\n    int n, arr[20], selection, num, select;\n    int divide = 0, merge_count = 0;\n    cout << \"Enter the total number of elements:\" << endl;\n    cin >> n;\n    cout << \"Enter the elements:\" << endl;\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    cout << \"Which method would you like to choose?\" << endl;\n    cout << \"1. Quick sort\" << endl << \"2. Merge Sort\" << endl;\n    cin >> num;\n    switch (num) {\n      case 1:\n        cout << \"Which element would you choose to be the pivot element?\" << endl;\n        cout << \"1. First element\" << endl << \"2. Middle element\" << endl << \"3. Last element\" << endl;\n        cin >> selection;\n        switch (selection) {\n          case 1:\n            select = 0;\n            cout << \"pivot element = \" << arr[select] << endl;\n            quicksort(arr, 0, n - 1, select);\n            printarray(arr, n);\n            break;\n          case 2:\n            select = n / 2;\n            cout << \"pivot element = \" << arr[select] << endl;\n            quicksort(arr, 0, n - 1, select);\n            printarray(arr, n);\n            break;\n          case 3:\n            select = n - 1;\n            cout << \"pivot element = \" << arr[select] << endl;\n            quicksort(arr, 0, n - 1, select);\n            printarray(arr, n);\n            break;\n          default:\n            cout << \"Invalid input\" << endl;\n            break;\n        }\n        break;\n      case 2:\n        mergesort(arr, 0, n - 1);\n        printarray(arr, n);\n        break;\n      default:\n        cout << \"invalid input\" << endl;\n        break;\n    }\n}\n\nvoid swap(int *a, int *b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid printarray(int array[], int size) {\n    int i;\n    for (i = 0; i < size; i++)\n        cout << array[i] << \" \";\n    cout << endl;\n}\n\nint partition(int array[], int low, int high, int select) {\n    \n    int pivot = array[select];\n    \n    int i = (low - 1);\n    \n    for (int j = low; j < high; j++) {\n        if (array[j] <= pivot) {\n            i++;\n            swap(&array[i], &array[j]);\n        }\n    }\n    \n    swap(&array[i + 1], &array[high]);\n    \n    return (i + 1);\n}\n\nvoid quicksort(int array[], int low, int high, int select) {\n    if (low < high) {\n        int pi = partition(array, low, high, select);\n        \n        quicksort(array, low, pi - 1, select);\n        \n        quicksort(array, pi + 1, high, select);\n    }\n}\n\nvoid merge(int arr[], int p, int q, int r) {\n    int n1 = q - p + 1;\n    int n2 = r - q;\n    \n    int L[n1], M[n2];\n    \n    for (int i = 0; i < n1; i++)\n        L[i] = arr[p + i];\n    for (int j = 0; j < n2; j++)\n        M[j] = arr[q + 1 + j];\n    \n    int i = 0, j = 0, k = p;\n    \n    while (i < n1 && j < n2) {\n        if (L[i] <= M[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = M[j];\n            j++;\n        }\n    }\n    \n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    \n    while (j < n2) {\n        arr[k] = M[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergesort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        \n        mergesort(arr, l, m);\n        mergesort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n```\n\nAt first my quicksort was working just fine, but then I added the code for mergesort(I did not edit the code for quicksort at all) and now none of them are working as expected.\nOUTPUT:\n```\nEnter the total number of elements:\n6\nEnter the elements:\n12\n14\n15\n13\n11\n10\nWhich method would you like to choose?\n1. Quick sort\n2. Merge Sort\n1\nWhich element would you choose to be the pivot element?\n1. First element\n2. Middle element\n3. Last element\n1\npivot element = 12\n12 11 10 15 13 14\n```\n\n    ", "Answer": "\r\nYour implementation of ```\nquicksort```\n is flawed: you select an element as the pivot from a fixed offset ```\nselect```\n from each slice of the array. When you recurse on the partitions, ```\nselect```\n should be recomputed from the slice length to refer to an element of the slice. As coded, your program has undefined behavior: the flaw in quicksort corrupts memory outside the array being sorted, potentially causing other functions to fail as well.\nFurthermore, your implementation of ```\nmergesort```\n is flawed as well: you do not increment ```\nk```\n in the main ```\nwhile```\n loop of the ```\nmerge```\n function, producing invalid output that might, by chance, go unnoticed in very specific cases. You should run a check before printing the sorted array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Sorting list of tuples using merge sort?\r\n                \r\nI am trying to sort this list of tuples after the number on the second index using the merge sort algorithm, but I am very unsure on how to do so.\n\nThis is the list of tuples I am trying to sort:\n\n```\nlist_of_tuples = [('Birds of Prey', 97.1),\n                  ('Dolittle', 175.0),\n                  ('The Gentlemen', 7.0),\n                  ('Falling', 22.0)]\n```\n\n\nAnd I can implement a general merge sort algorithm, but i cannot do it in a way where I sort after the number in the tuple on the second index.\n\nThis is my implementation of a general merge sort:\n\n```\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        merge_sort(left)\n        merge_sort(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return arr\n```\n\n\nHow would I make this fit the problem?\n\nThe prefered answer is that it returns the tuple with the highest number in the end, so the result would be ```\n('Dolittle', 175.0)```\n.\n    ", "Answer": "\r\nYou could follow Python's sort implementation and add a ```\nkey```\n argument:\n\n```\ndef merge_sort(arr, key=lambda x: x):\n    if len(arr) < 2:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    merge_sort(left)\n    merge_sort(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if key(left[i]) < key(right[j]):\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return arr\n```\n\n\nthen all you need to do is: ```\nres = merge_sort(list_of_tuples, key=lambda x: x[1])```\n\n\nOr with python's sort implementation: ```\nres = sorted(list_of_tuples, key=lambda x: x[1])```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort implementation JavaScript\r\n                \r\nI was trying to implement merge sort algorithm in JavaScript without built in methods like slice(), splice(), etc. It doesn’t work exactly I wish. Can you help me to figure out where is bug hidden? Getting output [3, 5, 5, 3, 7] instead of [3, 5, 5, 7, 8].\n\r\n\r\n```\n// Merge Sort implementation\n\n// sort implementation\nfunction sort(arr, start, mid, end) {\n\n  // Creation and filling the temp arrays\n  let lArray = [];\n  let rArray = [];\n\n  for (let i = 0; i <= mid - start; i++) {\n    lArray[i] = arr[start + i];\n  }\n\n  for (let j = 0; j <= end - mid - 1; j++) {\n    rArray[j] = arr[mid + 1 + j];\n  }\n\n\n  // Sorting and updating current array\n  let i = 0;\n  let j = 0;\n  let k = start;\n\n  while (i < lArray.length && j < rArray.length) {\n    if (lArray[i] < rArray[j]) {\n      arr[k] = lArray[i];\n      i++;\n      k++;\n    } else {\n      arr[k] = rArray[j];\n      j++;\n      k++;\n    }\n  }\n\n  // Handling last element in lArray or rArray\n\n  i < lArray.length ? arr[k] = lArray[i] : arr[k] = rArray[j];\n}\n\n// Recursive Merge Sort \nfunction recursiveMergeSort(arr, start, end) {\n  if (start < end) {\n    let mid = Math.floor(((end) + start) / 2);\n    //console.log(start, end, mid);\n    recursiveMergeSort(arr, start, mid);\n    recursiveMergeSort(arr, mid + 1, end);\n    sort(arr, start, mid, end);\n  }\n}\n\nfunction mergeSort(arr) {\n\n  let start = 0;\n  let end = arr.length - 1;\n\n  recursiveMergeSort(arr, start, end);\n  return (arr)\n}\n\nconsole.log(mergeSort([5, 8, 3, 7, 5]));```\n\r\n\r\n\r\n\n    ", "Answer": "\r\n```\n // Handling last element in lArray or rArray```\n is not correct.\nAfter merging arrays you have to check the rests and copy untreated tail if it does exist\n```\n while (i < lArray.length) {\n     arr[k] = lArray[i];\n     i++;\n     k++;\n }\n while (j < rArray.length) {\n     arr[k] = rArray[j];\n     j++;\n     k++;\n }\n```\n\nReplacing ternary operator by this code gives correct results for given data\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java, merge sort\r\n                \r\nI have been trying to code merge sort, without creating additional arrays for keeping sorted parts, after few hours I can't find the error, which causes last bit of the array to be sorted in a wrong order. Theres quite a few helper methods, I used for the debugging, I left them in. \n\n```\npublic class Sorter2\n{\n\n    public static void toString(int [] list)\n    {\n        for(int i = 0; i < list.length; i++)\n        {\n            System.out.print(list[i]);\n            if(!(i + 1 == list.length))\n            {\n                System.out.print(\",\");\n            }\n        }\n\n        System.out.println(\"\");\n    }\n\n    public static void toString(int list[], int from, int to)\n    {\n        for(int i = from; i <= to; i++)\n        {\n            System.out.print(list[i]);\n            if(i + 1 <= to)\n            {\n                System.out.print(\",\");\n            }\n        }\n\n        System.out.println(\"\");\n    }\n\n\n    public static void insertAt(int [] list, int insert_at, int taken_from)\n    {\n        int to_insert = list[taken_from];\n        for(int i = taken_from; i >= insert_at; i--)\n        {\n            if(i != insert_at)\n            {\n                list[i] = list[i - 1];\n            }\n            else\n            {\n                list[i] = to_insert;\n            }\n        }\n    }\n\n    public static void sortSegments(int [] list ,int segment_one_begin, int segment_one_end, int segment_two_begin, int segment_two_end)\n    {\n        toString(list, segment_one_begin, segment_two_end);\n        int sorted = 0;\n        for(int i = segment_two_begin; i <= segment_two_end; i++)\n        {\n            for(int l = segment_one_begin + sorted; l <= segment_one_end; l++)\n            {\n                if(list[i] <= list[l])\n                {\n                    insertAt(list, l, i);\n                    sorted++;\n                }\n            }\n        }\n        toString(list, segment_one_begin, segment_two_end);\n    }\n\n    public static void mergeSort(int [] list, int segment_begining, int segment_end)\n    {\n        if(segment_end - segment_begining < 1)\n        {\n            return;\n        }\n        else\n        {\n            int midpoint = (segment_end + segment_begining) / 2;\n\n            mergeSort(list, segment_begining, midpoint);\n            mergeSort(list, midpoint + 1, segment_end);\n            sortSegments(list, segment_begining, midpoint, midpoint + 1, segment_end);\n\n        }\n\n    }\n    public static void mergeSort(int [] list)\n    {\n        mergeSort(list, 0, list.length - 1);\n    }\n\n    public static boolean isInOrder(int [] toCheck)\n    {\n        for(int i = 1; i < toCheck.length; i++)\n        {\n            if(toCheck[i] < toCheck[i - 1])\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static int [] populate(int numOfItems)\n    {\n        int [] toReturn = new int[numOfItems];\n\n        for(int i = 0; i < toReturn.length; i++)\n        {\n            toReturn[i] = (int) (Math.random() * 100 + 1);\n        }\n\n        return toReturn;\n    }\n\n    public static void main(String [] args)\n    {\n        int [] nums = populate(20);\n        mergeSort(nums);\n        toString(nums);\n        System.out.println(isInOrder(nums));\n\n    }\n}\n```\n\n    ", "Answer": "\r\nLet's adjust your code a bit so that the tests would be reproducible, and we could see the whole process:\n\n```\nimport java.util.Random;\n\npublic class Sorter2 {\n    public static final Random RANDOM = new Random(55);\n\n    public static void toString(int[] list) {\n        System.out.println(Arrays.toString(list));\n    }\n\n    public static void toString(int list[], int from, int to) {\n        System.out.print(from + \"\\t\" + to + \"\\t\");\n        for (int i = from; i <= to; i++) {\n            System.out.print(list[i]);\n            if (i + 1 <= to) {\n                System.out.print(\",\");\n            }\n        }\n\n        System.out.println(\"\");\n    }\n\n\n    public static void insertAt(int[] list, int insert_at, int taken_from) {\n        int to_insert = list[taken_from];\n        for (int i = taken_from; i >= insert_at; i--) {\n            if (i != insert_at) {\n                list[i] = list[i - 1];\n            } else {\n                list[i] = to_insert;\n            }\n        }\n    }\n\n    public static void sortSegments(int[] list, int segment_one_begin, int segment_one_end, int segment_two_begin, int segment_two_end) {\n        System.out.println(\"Sorter2.sortSegments(\"+segment_one_begin + \",\" + segment_one_end + \",\" + segment_two_begin + \",\" + segment_two_end + \")\");\n        toString(list, segment_one_begin, segment_two_end);\n        int sorted = 0;\n        for (int i = segment_two_begin; i <= segment_two_end; i++) {\n            for (int l = segment_one_begin + sorted; l <= segment_one_end; l++) {\n                if (list[i] <= list[l]) {\n                    insertAt(list, l, i);\n                    sorted++;\n                }\n            }\n        }\n        toString(list, segment_one_begin, segment_two_end);\n    }\n\n    public static void mergeSort(int[] list, int segment_begining, int segment_end) {\n        if (segment_end - segment_begining < 1) {\n            return;\n        }\n\n        int midpoint = (segment_end + segment_begining) / 2;\n        mergeSort(list, segment_begining, midpoint);\n        mergeSort(list, midpoint + 1, segment_end);\n        sortSegments(list, segment_begining, midpoint, midpoint + 1, segment_end);\n    }\n\n    public static void mergeSort(int[] list) {\n        mergeSort(list, 0, list.length - 1);\n    }\n\n    public static boolean isInOrder(int[] toCheck) {\n        for (int i = 1; i < toCheck.length; i++) {\n            if (toCheck[i] < toCheck[i - 1]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static int[] populate(int numOfItems) {\n        int[] toReturn = new int[numOfItems];\n\n        for (int i = 0; i < toReturn.length; i++) {\n            toReturn[i] = (int) (nextRandom() * 100 + 1);\n        }\n\n        return toReturn;\n    }\n\n    private static double nextRandom() {\n        return RANDOM.nextDouble();\n    }\n\n    public static void main(String[] args) {\n        int[] nums = populate(20);\n        mergeSort(nums);\n        toString(nums);\n        System.out.println(isInOrder(nums));\n    }\n}\n```\n\n\nThe output is as follows:\n\n```\nSorter2.sortSegments(0,0,1,1)\n0   1   73,47\n0   1   47,73\nSorter2.sortSegments(0,1,2,2)\n0   2   47,73,48\n0   2   47,48,73\nSorter2.sortSegments(3,3,4,4)\n3   4   42,64\n3   4   42,64\nSorter2.sortSegments(0,2,3,4)\n0   4   47,48,73,42,64\n0   4   42,47,48,73,64\nSorter2.sortSegments(5,5,6,6)\n5   6   12,38\n5   6   12,38\nSorter2.sortSegments(5,6,7,7)\n5   7   12,38,14\n5   7   12,14,38\nSorter2.sortSegments(8,8,9,9)\n8   9   18,87\n8   9   18,87\nSorter2.sortSegments(5,7,8,9)\n5   9   12,14,38,18,87\n5   9   12,14,18,38,87\nSorter2.sortSegments(0,4,5,9)\n0   9   42,47,48,73,64,12,14,18,38,87\n0   9   12,42,14,18,38,47,48,64,73,87\nSorter2.sortSegments(10,10,11,11)\n10  11  60,29\n10  11  29,60\nSorter2.sortSegments(10,11,12,12)\n10  12  29,60,95\n10  12  29,60,95\nSorter2.sortSegments(13,13,14,14)\n13  14  21,37\n13  14  21,37\nSorter2.sortSegments(10,12,13,14)\n10  14  29,60,95,21,37\n10  14  21,29,37,60,95\nSorter2.sortSegments(15,15,16,16)\n15  16  28,66\n15  16  28,66\nSorter2.sortSegments(15,16,17,17)\n15  17  28,66,73\n15  17  28,66,73\nSorter2.sortSegments(18,18,19,19)\n18  19  80,69\n18  19  69,80\nSorter2.sortSegments(15,17,18,19)\n15  19  28,66,73,69,80\n15  19  28,66,69,73,80\nSorter2.sortSegments(10,14,15,19)\n10  19  21,29,37,60,95,28,66,69,73,80\n10  19  21,28,29,37,60,95,66,69,73,80\nSorter2.sortSegments(0,9,10,19)\n0   19  12,42,14,18,38,47,48,64,73,87,21,28,29,37,60,95,66,69,73,80\n0   19  12,21,28,29,37,42,14,18,38,47,48,64,73,87,60,95,66,69,73,80\n12,21,28,29,37,42,14,18,38,47,48,64,73,87,60,95,66,69,73,80\nfalse\n```\n\n\nAs you can see, the first problem manifests itself in the following lines:\n\n```\nSorter2.sortSegments(0,2,3,4)\n0   4   47,48,73,42,64\n0   4   42,47,48,73,64\n```\n\n\nWe take two ordered chunks and get an unordered chunk as a result. Put a breakpoint on line ```\nfor (int i = segment_two_begin; i <= segment_two_end; i++) {```\n and try to catch the case for ```\nSorter2.sortSegments(0,2,3,4)```\n:\n\n\n```\n42 <= 47```\n, so we call ```\ninsertAt```\n to move 42 before 47\nbut that means 73 is now in ```\nsegment_two```\n—and believed to be in place!\n\n\nHere's the error for you: your ```\nsortSegments```\n does not work as advertised.\n\nIf you think a minute about that method, you'll find that you do not actually need nested loops: all you need is to find the necessary elements, step by step. So you're better off with one cycle from ```\nsegment_one_begin```\n to ```\nsegment_two_end```\n, and a pointer to a current position in the second list: if an element from first list is lower than one from the second, you just skip to the new position. If it's not, you perform the shift you need—and move a pointer.\n\nI've made a fix and it works just fine for me—so it seems is was the only error in your implementation. If you're still stuck, please describe your problem, and I'll try to help.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Segfault in Merge - Sort in C\r\n                \r\nI am trying to sort an array of structures of size 5500 using merge sort.\nHowever, I am getting a segmentation fault pretty quickly because I am not allowed to use VLA. so I have to create 2 extra arrays of size 5500 each time I call merge-sort recursively.\n\nI would appreciate a fix for my problem. I will provide my code here:\n\n```\nvoid merge(Student rightArr[], Student leftArr[], Student mergedArr[], int sizeOfRight, int sizeOfLeft) {\n    int rightArrIndex = 0;\n    int leftArrIndex = 0;\n    int mergedArrIndex = 0;\n\n    while (leftArrIndex < sizeOfLeft && rightArrIndex < sizeOfRight) {\n        char *ptrLeft, *ptrRight;\n        long gradeLeft = strtol(leftArr[leftArrIndex].grade, &ptrLeft, BASE_COUNT);\n        long gradeRight = strtol(rightArr[rightArrIndex].grade, &ptrRight, BASE_COUNT);\n        if (gradeLeft > gradeRight) {\n            mergedArr[mergedArrIndex] = rightArr[rightArrIndex];\n            rightArrIndex++;\n        } else {\n            mergedArr[mergedArrIndex] = leftArr[leftArrIndex];\n            leftArrIndex++;\n        }\n        mergedArrIndex++;\n    }\n    if (leftArrIndex == sizeOfLeft) {\n        for (int i = mergedArrIndex; i < (sizeOfLeft + sizeOfRight); i++) {\n            mergedArr[i] = rightArr[rightArrIndex];\n            rightArr++;\n        }\n    } else {\n        for (int i = mergedArrIndex; i < (sizeOfLeft + sizeOfRight); i++) {\n            mergedArr[i] = leftArr[leftArrIndex];\n            leftArr++;\n        }\n    }\n}\n\nvoid mergeSort(Student studentsArray[], int amountOfStudents) {\n    if (amountOfStudents <= 1) {\n        return;\n    }\n    int leftSize = (amountOfStudents / 2);\n    int rightSize = (amountOfStudents - leftSize);\n    Student leftArr[5500], rightArr[5500];\n    for (int i = 0; i < leftSize; i++) {\n        leftArr[i] = studentsArray[i];\n    }\n    for (int i = 0; i < rightSize; i++) {\n        rightArr[i] = studentsArray[i + leftSize];\n    }\n    mergeSort(leftArr, leftSize);\n    mergeSort(rightArr, rightSize);\n    merge(rightArr, leftArr, studentsArray, rightSize, leftSize);\n}\n```\n\n    ", "Answer": "\r\nOk, I think this should do what you want.  It assumes that ```\nStudent```\n and ```\nBASE_COUNT```\n have been defined:\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid merge(Student studentsArr[],\n           int leftSize, int rightSize,\n           Student scratchArr[])\n{\n    Student *leftArr = studentsArr;\n    Student *rightArr = studentsArr + leftSize;\n    int leftIx = 0, rightIx = 0, mergeIx = 0, ix;\n\n    while (leftIx < leftSize && rightIx < rightSize) {\n        long gradeLeft = strtol(leftArr[leftIx].grade, NULL, BASE_COUNT);\n        long gradeRight = strtol(rightArr[rightIx].grade, NULL, BASE_COUNT);\n\n        if (gradeLeft <= gradeRight) {\n            scratchArr[mergeIx++] = leftArr[leftIx++];\n        }\n        else {\n            scratchArr[mergeIx++] = rightArr[rightIx++];\n        }\n    }\n\n    while (leftIx < leftSize) {\n        scratchArr[mergeIx++] = leftArr[leftIx++];\n    }\n\n    // Copy the merged values from scratchArr back to studentsArr.\n    // The remaining values from rightArr (if any) are already in\n    // their proper place at the end of studentsArr, so we stop\n    // copying when we reach that point.\n\n    for (ix = 0; ix < mergeIx; ix++) {\n        studentsArr[ix] = scratchArr[ix];\n    }\n\n}\n\nvoid mergeSortInternal(Student studentsArray[],\n                       int amountOfStudents,\n                       Student scratchArr[])\n{\n    if (amountOfStudents <= 1) {\n        return;\n    }\n\n    int leftSize = amountOfStudents / 2;\n    int rightSize = amountOfStudents - leftSize;\n\n    mergeSortInternal(studentsArray, leftSize, scratchArr);\n    mergeSortInternal(studentsArray + leftSize, rightSize, scratchArr);\n\n    merge(studentsArray, leftSize, rightSize, scratchArr);\n}\n\n#define MAX_ARR_SIZE    5500\n\nvoid mergeSort(Student studentsArray[], int amountOfStudents)\n{\n    if (amountOfStudents <= 1) {\n        return;\n    }\n\n    if (amountOfStudents > MAX_ARR_SIZE) {\n        fprintf(stderr, \"Array too large to sort.\\n\");\n        return;\n    }\n\n    Student scratchArr[MAX_ARR_SIZE];\n\n    mergeSortInternal(studentsArray, amountOfStudents, scratchArr);\n}\n```\n\n\nThe top-level sort function is ```\nmergeSort```\n, defined as in the original post.  It declares a single scratch array of size ```\nMAX_ARR_SIZE```\n, defined as ```\n5500```\n.  The top-level function is not itself recursive, so this scratch array is only allocated once.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Issue with merge sort\r\n                \r\nI'm trying to run merge sort using python and recursion it is working fine for some cases not not working fine for most of the cases please correct me I tried and unable to find error in code.\n```\ndef merge_sort(a, min, max):\n    if max - min < 2:\n        return a[min:max]\n\n    mid = (min + max) // 2\n    L = merge_sort(a, min, mid)\n    R = merge_sort(a, mid, max)\n    return (sort(L, R))\n\ndef sort(L, R):\n    (c, m, n) = ([], len(L), len(R))\n    (i, j) = (0, 0)\n    while (i + j < m + n):\n        if i == m:\n            c.append(R[j])\n            j += 1\n        elif j == m:\n            c.append(L[i])\n            i += 1\n        elif R[j] <= L[i]:\n            c.append(R[j])\n            j += 1\n        elif L[i] < R[j]:\n            c.append(L[i])\n            i += 1\n    return c\n```\n\n    ", "Answer": "\r\nYou have a typo there, it should be ```\nj==n```\n in the second case.\nNext one is not an error, but it is usual to prefer the equal element coming from the left argument over the one on the right, for the sort to be stable (not change the order of elements unnecessarily). So you also need to switch the ```\n<=```\n and the ```\n<```\n comparisons in the other two cases.\nNaming is also important. The ```\nsort```\n function is really ```\nsorted_merge```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java Natural Merge Sort implementation\r\n                \r\nI can be considered new in Java . I ' ve been struggling with one question which was given to us by our professor in our school. I am supposed to make a natural merge sort algorithm which has to find two sorted sub-arrays everytime and merge them.(which is a version of bottom up merge sort). But i am stuck here is my code \n\n```\npublic class NaturalMergeMine {\n  private static Comparable[] aux;\n\n  public static void sort(Comparable[] a) {\n    aux = new Comparable[a.length];\n    sort(a, 0, a.length - 1);\n  }\n\n  public static boolean isSorted(Comparable[] a) {\n    for (int i = 1; i < a.length; i += 1) {\n      if (a[i - 1].compareTo(a[i]) < 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static void sort(Comparable[] a, int lo, int hi) {\n    int i = lo;\n    int j = 0;\n    int mid = 0;\n    int az = 0;\n\n    while (true) {\n      i = 0;\n      System.out.println(\"outter\");\n      while (i < a.length) {\n        System.out.println(\"inner 1\");\n        if (i == a.length - 1) {\n          break;\n        } else if (a[i].compareTo(a[i + 1]) < 0) {\n          break;\n        }\n        i++;\n      }\n\n      j = i + 1;\n\n      while (j < a.length) {\n        System.out.println(\"inner 2\");\n        if (j == a.length - 1) {\n          break;\n        } else if (a[j].compareTo(a[j + 1]) < 0) {\n          break;\n        }\n        j++;\n      }\n      mid = lo + (j - lo) / 2;\n      Merge(a, lo, mid, j);\n      lo = 0;\n\n      if (isSorted(a)) {\n        break;\n      }\n    }\n  }\n\n  public static void Merge(Comparable[] a, int lo, int mid, int hi) {\n    int i = lo;\n    int j = mid + 1;\n\n    for (int k = lo; k <= hi; k++) {\n      aux[k] = a[k];\n    }\n\n    for (int k = lo; k <= hi; k++) {\n      if (i > mid) {\n        a[k] = aux[j++];\n      } else if (j > hi) {\n        a[k] = aux[i++];\n      } else if (aux[i].compareTo(aux[j]) < 0) {\n        a[k] = aux[j++];\n      } else {\n        a[k] = aux[i++];\n      }\n    }\n  }\n\n  public static void show(Comparable[] a) {\n    for (int i = 0; i < a.length; i++) {\n      System.out.print(a[i] + \" \");\n    }\n  }\n\n  public static void main(String[] args) {\n    Integer[] arr = {6, 4, 5, 7, 8, 3, 2, 1};\n    sort(arr);\n    show(arr);\n  }\n}\n```\n\n\nwhat happens is that it is not merging correctly and it goes in an infinite loop in the outter loop ,which is because it is not sorted properly. Is there anyone who can advice me a better way or can tell me the mistake i make here. Thanks in advance.\n    ", "Answer": "\r\nThe issue is in the mid calculation, im not quite sure why you do that,but if the mid is less than i in you merge method you wont reach the fault case so you will stuck in discovering it without solving, for each run you need to pick up two arrays to sort, so instead of mid you can insert i to the merge method so you start the merging  from the fault in.\n\n```\n public class NaturalMergeMine {\nprivate static Comparable[] aux;\n\n public static void sort(Comparable[] a) {\n  aux = new Comparable[a.length];\n  sort(a, 0, a.length - 1);\n}\n\n public static boolean isSorted(Comparable[] a) {\n   for (int i = 1; i < a.length; i += 1) {\n     if (a[i - 1].compareTo(a[i]) > 0) {//changed operator to greater than\n      return false;\n    }\n  }\n  return true;\n}\n\nprivate static void sort(Comparable[] a, int lo, int hi) {\n  int i = lo;\n  int j = 0;\n  int mid = 0;\n  int az = 0;\n\n  while (true) {\n   i = 0;\n    System.out.println(\"outter\");\n    while (i < a.length) {\n     System.out.println(\"inner 1\");\n     if (i == a.length - 1) {\n       break;\n      } else if (a[i].compareTo(a[i + 1]) > 0) {//changed operator to greater than\n       break;\n      }\n      i++;\n    }\n\n    j = i + 1;\n\n    while (j < a.length) {\n    System.out.println(\"inner 2\");\n    if (j == a.length - 1) {\n      break;\n    } else if (a[j].compareTo(a[j + 1]) > 0) {//changed operator to greater than\n      break;\n    }\n    j++;\n  }\n //      mid = lo + (j - lo) / 2;\n  Merge(a, lo, i, j);\n  lo = 0;\n\n  if (isSorted(a)) {\n    break;\n  }\n }\n}\n\npublic static void Merge(Comparable[] a, int lo, int mid, int hi) {\nint i = lo;\nint j = mid + 1;\n\nfor (int k = lo; k <= hi; k++) {\n  aux[k] = a[k];\n}\n\nfor (int k = lo; k <= hi; k++) {\n  if (i > mid) {\n    a[k] = aux[j++];\n  } else if (j > hi) {\n    a[k] = aux[i++];\n  } else if (aux[i].compareTo(aux[j]) > 0) {//changed the operator to greater than\n    a[k] = aux[j++];\n  } else {\n    a[k] = aux[i++];\n  }\n }\n }\n\n  public static void show(Comparable[] a) {\n   for (int i = 0; i < a.length; i++) {\n    System.out.print(a[i] + \" \");\n   }\n  }\n\n public static void main(String[] args) {\n  Integer[] arr = {6, 4, 5, 7, 8, 3, 2, 1};\n  sort(arr);\n  show(arr);\n  }\n }\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Scheme and Merge Sort?\r\n                \r\nI was assigned to write a merge sort in Scheme but I have some issues with it. I showed it my professor and he said there is one simple mistake. Can someone help me? \nPlzz!\n\n```\n(define msort\n     (lamdba(1st)\n          (cond\n               ((null?? 1st) 1st)\n               ((null? (cdr 1st)) 1st)\n               (#t ((letrec ((half (quotient (lenght 1st) 2))\n                    (merge (lamdba (a b result)\n                         (cond ((null? a) (apped (reserve a) result))\n                               ((null? b) (append (reserve a) result))\n                               ((> (car a) (car b) (merge a (cdr b) (cons (car b) result))\n                               (#t (merge (cdr a) b (cons (car a) result)))))))\n                   (merge (msort (take 1st half)) (msort (drop 1st half)) '()))))))  \n```\n\n    ", "Answer": "\r\nOne simple mistake? He probably referred to #1, but even after fixing that you have some identifiers and parenthesis to fix:\n\n\n```\nlambda```\n, ```\nnull?```\n, ```\nlength```\n, ```\nappend```\n, and ```\nreverse```\n  is spelled incorrectly. \n```\nletrec```\n result gets applied since you have excess parenthesis around it.\n```\ncond```\n in ```\nmerge```\n where you compare elements are missing parenthesis two places.\n\n\nIt's obvious you need help with parenthesis matching so you should download a decent IDE to write code in. I use DrRacket for Scheme development (#!R5RS, #!R6RS and #!racket) and it idents (just press CTRL+i to get it reidented after pasting in code) and indicate where function names are written wrong when you hit RUN.\n\nMaking merge a global function in the beginning and perhaps move it to a letrec later  (if you have to) might ease development. Eg. you could find errors by testing stuff like ```\n(merge '(3 2 1) '())```\n.\n\nThis is no guarantee the program will work since I only address syntax here. You need to debug it! DrRacket has a debugger too!\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Number of Comparisons using merge sort\r\n                \r\nIf you have 5 distinct numbers, how many comparisons at most do you need to sort this using merge sort?\n    ", "Answer": "\r\nWhat is stopping you from coding a merge sort, keeping a counter for the number of comparisons in it, and trying it out on all permutations of [0,1,2,3,4]? \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort without extra space or in-place [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  How to sort in-place using the merge sort algorithm?  \n\n\n\n\nUsually we take an extra array to sort it using merge sort , is it possible to do this without using extra space ?\n\nIf this is possible then merge sort would be better than quick sort right?\n    ", "Answer": "\r\nYes, it's possible to perform an in-place merge sort. That does not mean it doesn't require any extra memory, since the recursion still takes O(lg n) stack space (just like quicksort).\n\nEdit: it's been long since I read the Katajainen paper, and I never paid attention to the space complexity claim; apparently, merge sort can be done in O(1) extra space.\n\nBut no, all this does not mean one algorithm is better than another, unless you specify what you mean by that word. Randomized quicksort, while it can go quadratic, still performs a smaller expected number of operations, regardless of the input. Which one \"works better\" for your data depends on factors ranging from the statistics of the data to the hardware the program runs on.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "java - ArrayList - Merge Sort [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nWhen I run this the merge sort is not happening and I can't figure out where the problem is. int brelem and SortThread task arguments are there only because I need them to Override a method of the parent class properly so they do not play any role in this case.\n\n```\nclass MergeSort extends Sort {\n\n@Override\nArrayList sort(ArrayList<Integer> a, int brelem, SortThread task) {\n    if (a.size() > 1) {\n\n        ArrayList<Integer> firstHalf = new ArrayList<>(a.subList(0, a.size() / 2));\n\n        firstHalf.subList(0, a.size() / 2);\n        firstHalf=sort(firstHalf, a.size() / 2, task);\n\n        ArrayList<Integer> secondHalf = new ArrayList<>(a.subList(a.size()/2, a.size()));\n\n        secondHalf=sort(secondHalf, secondHalf.size(), task);\n\n        ArrayList<Integer> temp = merge(firstHalf, secondHalf);\n        a.subList(0, temp.size());\n    }\n    return a;\n}\n\nprivate static ArrayList merge(ArrayList<Integer> list1, ArrayList<Integer> list2) {\n    ArrayList<Integer> temp = new ArrayList<>();\n\n    int current1 = 0;\n    int current2 = 0;\n    int current3 = 0;\n\n    while (current1 < list1.size() && current2 < list2.size()) {\n        if (list1.get(current1) < list2.get(current2)) {\n            temp.set((current3++), list1.get(current1++));\n        } else {\n            temp.set((current3++), list2.get(current2++));\n        }\n    }\n\n    while (current1 < list1.size()) {\n        temp.set((current3++), list1.get(current1++));\n    }\n\n    while (current2 < list2.size()) {\n        temp.set((current3++), list2.get(current2++));\n    }\n\n    return temp;\n}\n```\n\n\n}\n    ", "Answer": "\r\nAmong other things, you are returning ```\na```\n, not ```\ntemp```\n.  As far as I can tell, you never modify ```\na```\n.\n\nPerhaps you are confused about what ```\nList.subList()```\n does.  It returns a view of the list, so whatever you're doing with it in ```\nsort```\n's penultimate statement will have no effect since you're disregarding the return value.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Bottom up merge sort on Linked List\r\n                \r\nBottom up merge sort treats a list each element of size 1, and iteratively merge the sub-lists back and forth until they are in sorted order. This makes it very attractive to use bottom up merge sort to sort linked list as they are already \"separated\".\n\nI'm trying to implement bottom up merge sort in C language, and realised that there are various approach to implement bottom up merge sort; in particular, I'm using this approach: \n\n\nInsert single lists into a queue\nDequeue first two lists and merge them\nEnqueue merged lists (merged items go to the end)\nRepeat step 1-3 until they are in sorted order\n\n\nHowever, I'm struggling to implement the following:\n\n\nMerge linked-lists without using extra O(n) space (if possible)\n\n\nHence, my questions are: \n\n\nHow would one implement this correctly in C language? (in particular: the handling of repeating the dequeue and enqueue process until it's fully sorted) How would one know if the entire queue is in sorted order? I'm thinking of keeping track of the *head pointer(s) in a list.\nIs merge sort stable in this case? Why? \nThe running time of bottom-up merge sort is still O(nlogn). However, does this bottom up merge sort use O(n) space? Suppose the linked-list we implement is already a queue. \nExtra question: is there a better alternative to implement bottom-up merge sort on linked list? \n\n\nI suppose this is one of the advantage of using bottom-up merge sort on linked list, as it is more space efficient than using bottom-up merge sort on arrays. Correct me if I'm wrong.\n    ", "Answer": "\r\n\nHow would one implement that? is a bit too broad question, I'm afraid.\nMergesort is stable provided that when you encounter equal items in two sublists, you take them from the 'left' (earlier) sublist first.\nWith a linked list you can use O(1) space; just unlink sublist sequentially, and append them to a new temporary list after merging, then use the new list in the next iteration with longer sublists. You will only need to keep additional 'head' and 'tail' pointers for a temporary list.\nYes, there is: unlink longest possible increasing runs instead of 1, 2, 4... items sublists. That is as good as the original algorithm in the worst case (input in reverse order makes one-item runs in the first iteration), but it makes a full use of an existing partial order if there is one (for a fully sorted input it just scans the list once).\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort analysis\r\n                \r\nI am testing Merge Sort for large Inputs following code is working fine for all input in the range of 4 byte int, but in my gcc compiler of linux mint it is giving segmentation fault for the input of above ~59000. Cant' understand the behaviour.\n\n```\n#include<stdio.h>\n#include<time.h>\nvoid Merge(int *c,int *a,int aSize,int *b,int bSize){\n    int i = 0,j = 0,k = 0;\n    while(i<aSize && j<bSize){\n        if(a[i]<=b[j])\n           c[k++] = a[i++];\n        else\n           c[k++] = b[j++];\n    }\n    while(j<bSize)\n        c[k++] = b[j++];\n    while(i<aSize)\n        c[k++] = a[i++];\n}\nclock_t start,end;\nvoid MergeSort(int *a,int size){\n    start = clock();\n    if(size == 1)\n        return;\n    int fh[100000],fhSize = 0, sh[100000],shSize = 0;\n    int mid = size/2,i,j;\n    for(i = 0;i<mid;i++)\n        fh[i] = a[i];\n    fhSize = i;\n    for(i = 0;i<size - mid;i++)\n        sh[i] = a[mid + i];\n    shSize = i;\n    MergeSort(fh,fhSize);\n    MergeSort(sh,shSize);\n    Merge(a,fh,fhSize,sh,shSize);\n\n}\nvoid display(int *a,int size){\n   int i;\n   for(i =0 ;i<size;i++)\n    printf(\"%d \",a[i]);\n   printf(\"\\n\");\n}\nint main(){\n    int a[100000];\n    int i,j;\n    for(i = 100000,j = 0;i>0 && j<100000;i--,j++)\n      a[j] = i;\n    MergeSort(a,100000);\n    end = clock();\n    double tTime = (double) (end-start)/CLOCKS_PER_SEC;\n    display(a,100000);\n    printf(\"%lf\\n\",tTime);\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Optimizing a merge sort\r\n                \r\nI need to optimize my sort (a merge sort), so that with a list of size 10^6 will be sorted in less than 100 seconds. My best time at the moment is 105 seconds and I can't think of a way to make this code more optimized.\n```\ndef my_sort(lst):\nif len(lst) > 1:\n    puolivali = len(lst) // 2\n    vas = lst[:puolivali]\n    oik = lst[puolivali:]\n    vas = my_sort(vas)\n    oik = my_sort(oik)\n    lst = []\n    while len(vas) > 0 and len(oik) > 0:\n        if vas[0] < oik[0]:\n            lst.append(vas[0])\n            vas.pop(0)\n        else:\n            lst.append(oik[0])\n            oik.pop(0)\n\n    for i in vas:\n        lst.append(i)\n    for i in oik:\n        lst.append(i)\n\nreturn lst\n```\n\n    ", "Answer": "\r\n```\n.pop(0)```\n is the main performance killer as it shifts all subsequent elements. Use a moving index instead:\n```\n    # ...\n    vas_i = oik_i = 0\n    lst = []\n    while vas_i < len(vas) and oik_i < len(oik):\n        if vas[vas_i] < oik[oik_i]:\n            lst.append(vas[vas_i])\n            vas_i += 1\n        else:\n            lst.append(oik[oik_i])\n            oik_i += 1\n\n    lst.extend(vas[vas_i:])\n    lst.extend(oik[oik_i:])\n```\n\nOr as a complete function:\n```\ndef my_sort(lst):\n    mid = len(lst) // 2\n    if mid:\n        lo, hi = my_sort(lst[:mid]), my_sort(lst[mid:])\n        lo_i = hi_i = 0\n        lst = []\n        while lo_i < len(lo) and hi_i < len(hi):\n            if lo[lo_i] > hi[hi_i]:\n                lo, lo_i, hi, hi_i = hi, hi_i, lo, lo_i\n            lst.append(lo[lo_i])\n            lo_i += 1\n        lst.extend(lo[lo_i:])\n        lst.extend(hi[hi_i:])\n    return lst\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "In merge sort why not merge each sorted sublist into a rolling list?\r\n                \r\nSo for merge sort when splitting I'd have \n\n```\nHGFEDCBA\nHG FE DC BA\nH G F E D C B A\n```\n\n\nFor merging instead of\n\n```\nGH EF DC AB\nEFGH  ABCD\nABCDEFGH\n```\n\n\nWhy Not \n\n```\nH G F E D C B A\nGH F E D C B A\nFGH E D C B A\nEFGH D C B A\nDEFGH C B A\nCDEFGH B A\nCBDEFGH A\nABCDEFGH \n```\n\n\nThe only thing I can think of is that merge sort is usually implemented recursively and that its easier to merge using the first way if using recursion to split. \n    ", "Answer": "\r\nAs some of the comments have mentioned, your second picture is actually depicting insertion sort instead of merge sort. I understand your confusion, as in your example insertion sort would run faster than merge sort. An insertion sort of a reversed list would be O(n), as every new element added to the output array would only need to compare one element before being inserted. Merge-sort, however, requires O(n logn) comparisons in all cases.\n\nBut you are correct in saying that merge-sort has less comparisons than insertion sort in general. If the list was already sorted (\"ABCDEFGH\"), for example, every new element added to the output would have to compare itself to the whole output before being added to the end, which would be O(n^2) time complexity.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Non Recursive Merge Sort Skipping\r\n                \r\nI am attempting to sort an array of numbers using natural merge sort. I have an array that these numbers in exact order(9,2,129,921,38,31,10,219,27,45) when I use my merge sort function I get(2,9,10,21,27,45,129,38,219,921), as you can see i am very close to getting it to sort but it seems as if it  is partly sorting it. I can't seem to find whats wrong with my code, any suggestions?\n\n```\nvoid merge(int *a, int size, int low, int high, int mid)\n{\n    int i, j, k;\n    int *c = new int[size];\n    i = low;\n    k = low;\n    j = mid + 1;\n    while (i <= mid && j <= high)\n    {\n        if (a[i] < a[j])\n        {\n           c[k] = a[i];\n           k++;\n           i++;\n         }\n       else\n       {\n           c[k] = a[j];\n           k++;\n           j++;\n       }\n}\nwhile (i <= mid)\n{\n    c[k] = a[i];\n    k++;\n    i++;\n}\nwhile (j <= high)\n{\n    c[k] = a[j];\n    k++;\n    j++;\n}\nfor (i = low; i < k; i++)\n {\n    a[i] = c[i];\n  }\n}\nvoid naturalMS(int * a, int s)\n{\n    for(int i = 1; i < s; i *= 2)\n    {\n       for(int low = 0; low < s- i; low += o)\n       {\n           merge(a,s,low,s-1,low+i-1);\n       }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort create memory heap\r\n                \r\nI wrote this Merge Sort which allow the user to call it by passing only two parameters (an ArrayList and a Comparator):\n\n```\npublic static < T > void mergeSort(ArrayList < T > array, Comparator < T > c) {\n    int high = array.size()-1;\n    sort(array, c, 0, high, new ArrayList < T > (high/2));\n  }  \n\n  protected static < T > void sort(ArrayList < T > array, Comparator < T > c, int low, int high, ArrayList < T > tmp) {\n    if (low < high) {\n      int mid = low + (high - low) / 2;\n      sort(array, c, low, mid, tmp);\n      sort(array, c, mid + 1, high, tmp);\n      merge(array, c, low, mid, high, tmp);\n    }\n  } \n\n  protected static < T > void merge(ArrayList < T > array, Comparator < T > c, int p, int mid, int q, ArrayList < T > tmp) {\n    tmp.clear();\n    int i = p;\n    int j = mid + 1;\n    int k = 0;\n    for (; i <= mid && j <= q; k++) {\n      if (c.compare(array.get(i), array.get(j)) < 0)\n        tmp.add(k, array.get(i++));\n      else\n        tmp.add(k, array.get(j++));\n    }\n    if (i <= mid && j > q) {\n      while (i <= mid)\n        tmp.add(k++, array.get(i++));\n    } else {\n      while (j <= q)\n        tmp.add(k++, array.get(j++));\n    }\n    for (k = 0; k < tmp.size()-p; k++)\n      array.set(k + p, tmp.get(k));\n\n  }\n}\n```\n\n\nAfter calling it I tried to print its content (which I supposed to be order):\n\n```\nSorting.mergeSort(arrayA, new LongComparator());\nSystem.out.println(Arrays.toString(arrayA.toArray()));\n```\n\n\nBut I got this error:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n    at java.util.Arrays.copyOf(Arrays.java:3332)\n    at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)\n    at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)\n    at java.lang.StringBuilder.append(StringBuilder.java:136)\n    at java.util.Arrays.toString(Arrays.java:4574)\n```\n\n\nHow can I improve my merge sort? Is the the temporary ArrayList the main cause of the error? Because this error happens when I try to order millions of data. With 2-3 elements it works.\nEDIT: This is my first version of the algorithm, which hasn't the support method with only two parameters that I need to do\n\n```\npublic static < T > void sort(ArrayList < T > array, Comparator < T > c, int low, int high) {\n    if (low < high) {\n      int mid = low + (high - low) / 2;\n      sort(array, c, low, mid);\n      sort(array, c, mid + 1, high);\n      merge(array, c, low, mid, high);\n    }\n  } \n\n@SuppressWarnings(\"unchecked\")\n  public static <T> void merge(ArrayList<T> array, Comparator<T> c, int p, int mid, int q) {\n    Object[] tmp = new Object[q-p+1]; \n    int i = p;\n    int j = mid+1;\n    int k = 0;\n    while (i <= mid && j <= q) {\n        if (c.compare(array.get(i), array.get(j))<0)\n          tmp[k] = array.get(i++);\n        else\n          tmp[k] = array.get(j++);\n        k++;\n    }\n    if (i <= mid && j > q) {\n        while (i <= mid) \n          tmp[k++] = array.get(i++);\n    } else {\n        while (j <= q)\n          tmp[k++] = array.get(j++);\n    }\n    for (k = 0; k < tmp.length; k++)\n      array.set(k+p, (T)tmp[k]);\n  }\n```\n\n    ", "Answer": "\r\nTwo ways to approach the problem:\n\nIncrease available memory: As was mentioned by Turing85, run java with more memory using VM option, -Xmx2048m to assign 2GB for example.\n\nDecrease the memory used: Using ArrayList of basic types like Long and Double uses 4 times (in my simple experiment) as much memory as using the equivalent array of the basic types long / double.\n\n```\nArrayList<Long> instead of long[]\n```\n\n\nwill also make the code run significantly slower for several reasons (if you are aiming to use the merge sort for non-basic types you may see performance increase but memory gain will not be as significant)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "4 threaded merge sort algorithm\r\n                \r\nI want to modify the 2 threaded merge sort to 4 threaded merge sort. First I want to divide the array into 4 equal subarrays(the last subarray might be larger) and assign them into separate threads to sort. Finally, merge 1 and 2 subarrays and 3 and 4 subarrays, then merge already sorted-merged 1 and 2 subarrays with sorted-merged 3 and 4 subarrays.\nhere is what i have as now:\nHow can I implement that? Thanks ver much!!!\n\n```\npackage four_threaded;\nimport java.util.Random;\n\npublic class four_threaded_merge_sort {\n\n    public static void finalMerge(int[] a, int[] b) {\n        int[] result = new int[a.length + b.length];\n        int i=0; \n        int j=0; \n        int r=0;\n        while (i < a.length && j < b.length) {\n            if (a[i] <= b[j]) {\n                result[r]=a[i];\n                i++;\n                r++;\n            }\n            else {\n                result[r]=b[j];\n                j++;\n                r++;\n            }\n            if (i==a.length) {\n                while (j<b.length) {\n                    result[r]=b[j];\n                    r++;\n                    j++;\n                }\n            }\n            if (j==b.length) {\n                while (i<a.length) {\n                    result[r]=a[i];\n                    r++;\n                    i++;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Random rand = new Random();\n        int[] original = new int[10];\n        for (int i=0; i<original.length; i++) {\n            original[i] = rand.nextInt(100);\n        }\n\n        long startTime = System.currentTimeMillis();\n\n        int s = original.length / 4 ;\n        int r = original.length % 4;\n\n        //first subarray\n        int[] subArr1 = new int[s];\n        System.arraycopy(original, 0, subArr1, 0, s);\n        //second subarray\n        int[] subArr2 = new int[s];\n        System.arraycopy(original, s, subArr2, 0, s);\n        //third subarray\n        int[] subArr3 = new int[s];\n        System.arraycopy(original, 2*s, subArr3, 0, s);\n        //fourth subarray\n        int[] subArr4 = new int[s+r];\n        System.arraycopy(original, 3*s, subArr4, 0, s+r);\n\n        Worker runner1 = new Worker(subArr1);\n        Worker runner2 = new Worker(subArr2);\n        Worker runner3 = new Worker(subArr3);\n        Worker runner4 = new Worker(subArr4);\n        runner1.start();\n        runner2.start();\n        runner3.start();\n        runner4.start();\n        runner1.join();\n        runner2.join();\n        runner3.join();\n        runner4.join();\n\n        finalMerge(runner1.getInternal(), runner2.getInternal());\n\n\n        long stopTime = System.currentTimeMillis();\n        long elapsedTime = stopTime - startTime;\n        System.out.println(\"4-thread MergeSort takes: \" + (float)elapsedTime/1000 + \" seconds\"); \n\n    }\n\n}\n\nclass Worker extends Thread {\n    private int[] internal;\n\n    public int[] getInternal() {\n        return internal;\n    }\n\n    public void mergeSort(int[] array) {\n        if (array.length > 1) {\n            int[] left = leftHalf(array);\n            int[] right = rightHalf(array);\n\n            mergeSort(left);\n            mergeSort(right);\n\n            merge(array, left, right);\n        }\n    }\n\n    public int[] leftHalf(int[] array) {\n        int size1 = array.length / 2;\n        int[] left = new int[size1];\n        for (int i = 0; i < size1; i++) {\n            left[i] = array[i];\n        }\n        return left;\n    }\n\n    public int[] rightHalf(int[] array) {\n        int size1 = array.length / 2;\n        int size2 = array.length - size1;\n        int[] right = new int[size2];\n        for (int i = 0; i < size2; i++) {\n            right[i] = array[i + size1];\n        }\n        return right;\n    }\n\n    public void merge(int[] result, int[] left, int[] right) {\n        int i1 = 0;   \n        int i2 = 0;   \n\n        for (int i = 0; i < result.length; i++) {\n            if (i2 >= right.length || (i1 < left.length && left[i1] <= right[i2])) {\n                result[i] = left[i1];   \n                i1++;\n            } else {\n                result[i] = right[i2];   \n                i2++;\n            }\n        }\n    }\n\n    Worker(int[] arr) {\n        internal = arr;\n    }\n\n    public void run() {\n        mergeSort(internal);\n    }\n}\n```\n\n    ", "Answer": "\r\nAfter the 4 threads complete, you could use 2 threads to merge the 4 sub-arrays into 2 sub-arrays, although that probably won't help much since the merging of large arrays will be memory bandwidth limited. You could also use the main thread to do a 4 way merge. On processor with 16 registers, like a PC in 64 bit mode, there are enough registers to deal with 4 sub-arrays via pointers or indices.\n\nIf speed is the goal here, allocating a working array one time and using a bottom up merge sort would be faster than top down. To avoid copying, each merge sort alternates merging data between the original and the working array. Each merge sort can determine the number of passes needed, and if it's an odd number, then swap in place for the first pass instead of merging to the other buffer.\n\nIf the final pass will be a 4 way merge, then each merge sort thread should end up with the sorted data in the working array. In this case, if it's an even number of passes, then swap in place for the first pass. You may want to do an in place swap for more than 2 elements at a time. Using something like a sorting network, 4 elements can be swapped with 6 if / swap statements. I'm not sure about using other in place sort methods for small sets of elements helps.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to sort in-place using the merge sort algorithm?\r\n                \r\nI know the question is not too specific. \n\nAll I want is someone to tell me how to convert a normal merge sort into an in-place merge sort (or a merge sort with constant extra space overhead). \n\nAll I can find (on the net) is pages saying \"it is too complex\" or \"out of scope of this text\". \n\n\n  The only known ways to merge in-place (without any extra space) are too complex to be reduced to practical program.  (taken from here)\n\n\nEven if it is too complex, what is the basic concept of how to make the merge sort in-place?\n    ", "Answer": "\r\nKnuth left this as an exercise (Vol 3, 5.2.5). There do exist in-place merge sorts. They must be implemented carefully.\nFirst, naive in-place merge such as described here isn't the right solution. It downgrades the performance to O(N2).\nThe idea is to sort part of the array while using the rest as working area for merging.\nFor example like the following merge function.\n\n```\nvoid wmerge(Key* xs, int i, int m, int j, int n, int w) {\n    while (i < m && j < n)\n        swap(xs, w++, xs[i] < xs[j] ? i++ : j++);\n    while (i < m)\n        swap(xs, w++, i++);\n    while (j < n)\n        swap(xs, w++, j++);\n}  \n```\n\nIt takes the array ```\nxs```\n, the two sorted sub-arrays are represented as ranges ```\n[i, m)```\n and ```\n[j, n)```\n respectively. The working area starts from ```\nw```\n. Compare with the standard merge algorithm given in most textbooks, this one exchanges the contents between the sorted sub-array and the working area. As the result, the previous working area contains the merged sorted elements, while the previous elements stored in the working area are moved to the two sub-arrays.\nHowever, there are two constraints that must be satisfied:\n\nThe work area should be within the bounds of the array. In other words, it should be big enough to hold elements exchanged in without causing any out-of-bound error.\nThe work area can be overlapped with either of the two sorted arrays; however, it must ensure that none of the unmerged elements are overwritten.\n\nWith this merging algorithm defined, it's easy to imagine a solution, which can sort half of the array; The next question is, how to deal with the rest of the unsorted part stored in work area as shown below:\n```\n... unsorted 1/2 array ... | ... sorted 1/2 array ...\n```\n\nOne intuitive idea is to recursive sort another half of the working area, thus there are only 1/4 elements haven't been sorted yet.\n```\n... unsorted 1/4 array ... | sorted 1/4 array B | sorted 1/2 array A ...\n```\n\nThe key point at this stage is that we must merge the sorted 1/4 elements B\nwith the sorted 1/2 elements A sooner or later.\nIs the working area left, which only holds 1/4 elements, big enough to merge\nA and B? Unfortunately, it isn't.\nHowever, the second constraint mentioned above gives us a hint, that we can exploit it by arranging the working area to overlap with either sub-array if we can ensure the merging sequence that the unmerged elements won't be overwritten.\nActually, instead of sorting the second half of the working area, we can sort the first half, and put the working area between the two sorted arrays like this:\n```\n... sorted 1/4 array B | unsorted work area | ... sorted 1/2 array A ...\n```\n\nThis setup effectively arranges the work area overlap with the sub-array A. This idea\nis proposed in [Jyrki Katajainen, Tomi Pasanen, Jukka Teuhola. ``Practical in-place mergesort''. Nordic Journal of Computing, 1996].\nSo the only thing left is to repeat the above step, which reduces the working area from 1/2, 1/4, 1/8, … When the working area becomes small enough (for example, only two elements left), we can switch to a trivial insertion sort to end this algorithm.\nHere is the implementation in ANSI C based on this paper.\n```\nvoid imsort(Key* xs, int l, int u);\n\nvoid swap(Key* xs, int i, int j) {\n    Key tmp = xs[i]; xs[i] = xs[j]; xs[j] = tmp;\n}\n\n/* \n * sort xs[l, u), and put result to working area w. \n * constraint, len(w) == u - l\n */\nvoid wsort(Key* xs, int l, int u, int w) {\n    int m;\n    if (u - l > 1) {\n        m = l + (u - l) / 2;\n        imsort(xs, l, m);\n        imsort(xs, m, u);\n        wmerge(xs, l, m, m, u, w);\n    }\n    else\n        while (l < u)\n            swap(xs, l++, w++);\n}\n\nvoid imsort(Key* xs, int l, int u) {\n    int m, n, w;\n    if (u - l > 1) {\n        m = l + (u - l) / 2;\n        w = l + u - m;\n        wsort(xs, l, m, w); /* the last half contains sorted elements */\n        while (w - l > 2) {\n            n = w;\n            w = l + (n - l + 1) / 2;\n            wsort(xs, w, n, l);  /* the first half of the previous working area contains sorted elements */\n            wmerge(xs, l, l + n - w, n, u, w);\n        }\n        for (n = w; n > l; --n) /*switch to insertion sort*/\n            for (m = n; m < u && xs[m] < xs[m-1]; ++m)\n                swap(xs, m, m - 1);\n    }\n}\n```\n\nWhere wmerge is defined previously.\nThe full source code can be found here and the detailed explanation can be found here\nBy the way, this version isn't the fastest merge sort because it needs more swap operations. According to my test, it's faster than the standard version, which allocates extra spaces in every recursion. But it's slower than the optimized version, which doubles the original array in advance and uses it for further merging.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort k lists c++\r\n                \r\nI have a randomly generated list of sorted lists and I have to merge sort the big list into one final list with the help of a heap.\n\n```\nstd::list<int> randomList(int size)\n{\n    std::list<int> list;\n    for (int i = 0; i < size; i++)\n        list.push_back(rand());\n    list.sort();\n    return list;\n}\n\nstd::list<list<int>> generateListOfLists(int size, int elements)\n{\n    std::list<list<int>> bigList;\n    std::list<int> aux;\n    for (int i = 0; i < size; i++)\n    {\n        aux = randomList(elements);\n        bigList.push_back(aux);\n    }\n    return bigList;\n}\n```\n\n\nThe reason I'm using lists is because I have to. Can anyone help me with an idea of how I can implement the merge sort here?\n\nThanks!\n    ", "Answer": "\r\nMake an array of iterators for all your lists. Make a heap of minimal elements from all the lists.\n\nWhile doing the merging, your heap should always contain exactly one element from each list. In your main loop, get the minimal element from the heap, determine from which list it came, increase the iterator for that list, and replace the element in the heap with the next element from the corresponding list.\n\nTo attach a list index to an element, store ```\nstruct```\ns in your heap:\n\n```\nstruct data\n{\n    int element;\n    int list;\n};\nstd::vector<data> heap;\n...\nstd::pop_heap(heap.begin(), heap.end());\n... // Your data is in the last position of the array: heap.back()\nstd::push_heap(heap.begin(), heap.end());\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort in C using Recursion\r\n                \r\nThis is my code for merge sort in C. I'm not able to understand what the issue is here. My knowledge of pointers is not that much. The merge function takes in 2 arrays and merges them. the sort function is a recursive function which is supposed to sort the array.\n```\n\nint * merge(int *fir, int n, int *sec, int m){\n    int res[m+n];\n    int x=0, y=0;\n    for(int i = 0; i < m+n; i++){\n        if(*(fir+x)<=*(sec+y)){\n            res[i] = *(fir+x);\n            x++;\n        }else{\n            res[i] = *(sec+y);\n            y++;\n        }\n\n    }\n    return res;\n}\n\nint * sort(int A[], int n){\n    if(n == 1){\n        return A;\n    }\n    int mid = n/2;\n    int AL[mid], AR[n-mid];\n    for(int i = 0; i < mid; i++){\n        AL[i] = A[i];\n    }\n    for(int i = 0; i < n-mid; i++){\n        AR[i] = A[i+mid];\n    }\n    int *BL, *BR;\n    BL = sort(AL, mid);\n    BR = sort(AR, n-mid);\n    return(merge(BL, mid, BR, n-mid));\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    int A[n];\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", &A[i]);\n    }\n    int *sortedArray;\n    sortedArray = sort(A, n);\n    for(int i = 0; i < n; i++){\n        printf(\"%d \", *(sortedArray+i));\n    }\n\n    return 0;\n}\n```\n\nAnd this is the output\n```\nq8.c:16:9: warning: address of stack memory associated with local variable 'res' returned [-Wreturn-stack-address]\n        return res;\n               ^~~\n1 warning generated.\n7\n23 12 56 67 11 99 97\n97 32766 539779418 32767 -2002825496 32767 6 %```\n```\n\n    ", "Answer": "\r\nThere are two issues here: First, you merge your partial arrays into a temporary local array, which yoes out of bounds after you return from ```\nmerge```\n. The pointer you return points to invlid memory. That's what the warning about.\nSecond, you don't check whether you are reading beyond the limits of the partial arrays when you merge: The condition ```\nx < n```\n must be true when you access ```\nfir```\n, likewise for ```\ny < m```\n and ```\nsec```\n.\nYou are also causing confusion by returning a pointer to the first element of the sorted or merged arrays. That suggests that you create new sorted and merged arrays (and that's what you try to do in ```\nmerge```\n). This is okay for garbage-collected morern languages, but C doesn't work that way.\nIn C, if you need new memory, you must allocate it and later free it explicitly. In a recursive function like yours, this is tedious, because you are interested only in the final sorted array, not in the intermediate results. Therefore, C sorting algorithms usually work \"in place\": The same memory is used thoughout the sorting and elements are swapped. The original order of the elements is lost unless you make a copy before sorting.\nFor merge sort, you need auxiliary memory. In your case, you use the temporary arrays ```\nAL```\n and ```\nAR```\n, which are copies of the contents of the original array, ```\nA```\n. Now when you merge, you can merge ```\nAL```\n and ```\nAR```\n back into ```\nA```\n.\nSo istead of creating a ephemeral local array, pass in ```\nA```\n so that it can be filled with the sorted elements:\n```\nvoid sort(int A[], int n)\n{\n    if (n > 1) {\n        int mid = n / 2;\n        int AL[mid], AR[n - mid];\n\n        for (int i = 0; i < mid; i++) AL[i] = A[i];\n        for (int i = 0; i < n - mid; i++) AR[i] = A[i + mid];\n        \n        sort(AL, mid);\n        sort(AR, n - mid);\n        \n        merge(A, AL, mid, AR, n - mid);\n    }\n}\n```\n\nYour ```\nmerge```\n function is now very similar to the one you has before, only that you have the result array as parameter and that you must catch the out-of-bound cases before accessing elements with ```\n[]```\n.\n```\nvoid merge(int *res, const int *fir, int n, const int *sec, int m)\n{\n    int x = 0, y = 0;\n\n    for(int i = 0; i < m + n; i++) {\n        if      (x == n)            res[i] = sec[y++];\n        else if (y == m)            res[i] = fir[x++];\n        else if (fir[x] <= sec[y])  res[i] = fir[x++];\n        else                        res[i] = sec[y++];\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to return my merged array from merge() to sort()? Java merge sort algorithm\r\n                \r\nI am creating a merge sort for an assignment based on an interface I was given. (merge, mergesort, and sort). I am right there, but my brain is fried and I can't find the final issue with my code. I successfully merge the two as seen in the final \"MERGE:\" print, but then the final line \"SORTEXAMPLE\" goes back to being unsorted. I think it's an issue with my returns, but I can't wrap my head around it. Here is the code (I'm sorry it's all of it, the issue could be in any of the methods to my knowledge).\n```\n@Override\npublic void sort(Comparable[] a) {\n    if(a == null || a.length <= 1){\n        return;\n    }\n    mergesort(a);\n}\n\n@Override\npublic Comparable[] mergesort(Comparable[] a) {\n    int length = a.length;\n\n    if(length <= 1){return a;} //base case\n\n    int middle = length / 2;\n    Comparable[] leftArray = new Comparable[middle];\n    Comparable[] rightArray = new Comparable[length - middle];\n    int l = 0, r = 0;\n\n    for(; l < length; l++){     //copy contents to either left or right side\n        if(l < middle){\n            leftArray[l] = a[l];\n        }\n        else{\n            rightArray[r] = a[l];\n            r++;\n        }\n    }\n\n    leftArray = mergesort(leftArray);       //sort left side\n    rightArray = mergesort(rightArray);      //sort right side\n    return merge(leftArray, rightArray);   //merge the two\n}\n\n@Override\npublic Comparable[] merge(Comparable[] a, Comparable[] b) {\n    Comparable[] array = new Comparable[a.length + b.length];\n    int arrayIndex = 0, aIndex = 0, bIndex = 0;\n\n    while(aIndex < a.length && bIndex < b.length){\n        if(less(a[aIndex], b[bIndex])){\n            array[arrayIndex] = a[aIndex];\n            aIndex++;\n        }\n        else{\n            array[arrayIndex] = b[bIndex];\n            bIndex++;\n        }\n        arrayIndex++;\n    }\n    while(aIndex < a.length){\n        array[arrayIndex] = a[aIndex];\n        arrayIndex++;\n        aIndex++;\n    }\n    while(bIndex < b.length){\n        array[arrayIndex] = b[bIndex];\n        arrayIndex++;\n        bIndex++;\n    }\n    System.out.print(\"MERGE: \");\n    show(array);\n    return array;\n}\n```\n\nI am expecting the output to be \"A E E L M O P R S T X\" from an input of \"SORTEXAMPLE\" string array. It should function as a basic top down merge sort.\n    ", "Answer": "\r\nI think the issue may be that your merge method is not updating the original array with the sorted result.\nInstead, it is returning a new array array that contains the sorted elements.\nTherefore, in your ```\nmergesort(...)```\n method, when you call ```\nmerge(leftArray, rightArray)```\n, you are not actually updating the leftArray and rightArray arrays with the sorted result.\nYou can just make merge return ```\nvoid```\n and update the original array a with the sorted result\n```\n    for (int i = 0; i < array.length; i++) {\n      a[i] = array[i];\n    }\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Templated Quick/Merge Sort\r\n                \r\nI've been trying to write a templated function in C++ that can accept an array of any type and sort it. The sort used has to be a quick sort or a merge sort, but I'm having a lot of trouble with implementing either of these, as a quick sort header usually comes with a top and bottom parameter, and a merge sort comes with a first and last parameter.  My function header looks like this: void mySort(T *array, int n)\n\nSo far I have this:\n\n```\ntemplate <typename T>\nvoid sort(T *a, int n)\n{\n  int i = 0;\n  int j = n-1;\n  int tmp;\n  int pivot = a[(n-1)/2];\n  while (i <= j){\n    while (a[i] < pivot)\n       i++;\n    while (a[j] > pivot)\n       j--;\n    if (i<=j){\n       tmp = a[i];\n       a[i] = a[j];\n       a[j] = a[i];\n       i++;\n       j--;\n    }\n  }\n\n  if(0<j)\n    sort(a, j);\n  /*\n  if(i<right)\n    sort(\n  */\n}\n```\n\n\nI was trying to use a recursive call to sort, but I couldn't figure out how to call recursive for the right partition created, without a different parameter list.\n    ", "Answer": "\r\nBefore answering the actual question: your code would benefit from factoring the partition code out of the body of the function! That way, you'd essentially call partition to determine the mid-point between the two arrays to be called, i.e., you'd have something like this:\n\n```\ntemplate <typename T>\nvoid sort(T* a, int n) {\n    T* mid = partition(a, n);\n    // ...\n}\n```\n\n\nThe idea is that ```\n[a, mid)```\n contains all elements sorting smaller than the pivot and ```\n[mid, a + n)```\n contains all elements sorting equal or greater than the pivot. All what remains is\n\n\nCall ```\nsort()```\n recursively with the two array, i.e.,\n\n```\nsort(a, mid - a);\nsort(mid, (a + n) - mid);\n```\n\nMake sure ```\nsort()```\n terminates if the array obtained is small than 2.\n\n\nOf course, if you want your Quick Sort to be quick you'll also need to pull half a dozen or so tricks. Like:\n\n\nUse Introsort to guarantee the complexity is ```\nO(n lg n)```\n (e.g. together with Merge Sort).\nUse Insertion Sort on small ranges.\nUse an implementation of partition and insertion sort taking advantage of suitable sentinels.\nSort really sort ranges directly.\n\n\nOne of the things which oddly is rather futile to play with is choice of a pivot. As far as I can tell, using the middle element works as well as any more advanced technique (assuming optimizations like those mentioned above are implemented).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Visualisation\r\n                \r\n\r\n\r\n```\n// variables\n// arr has elements to be sorted\nvar arr = []\n// temp is to store the intermediate results after merging\nvar temp = []\n// seen is for marking visited i.e. sorted half as green\nvar seen = []\n// length of array\nvar len = 100\n\n// canvas initialisations\nvar canvas = document.getElementById(\"myCanvas\")\ncanvas.width = canvas.height = 1000\nvar canvaswidth = canvas.width\nvar canvasheight = canvas.height\nvar ctx = canvas.getContext(\"2d\")\n\n// random array\nfor (let i = 0; i < len; i++) {\n    arr.push(parseInt(Math.random() * 500))\n    temp.push(parseInt(0))\n    seen.push(parseInt(0))\n}\n\n// initial contents of array to be sorted\n// console.log(arr)\n\n// draw the bars\ndraw = (s, e) => {\n    ctx.clearRect(0, 0, 1000, 1000)\n\n    // this loop will make unvisited bars in the upper half as black\n    // and visited bars in the upper half as green\n    for (let i = 0; i < len; i++) {\n        ctx.fillStyle = \"#000000\"\n        ctx.fillRect(15 * i, 500 - arr[i], 10, arr[i])\n        if (seen[i]) {\n            ctx.fillStyle = \"#00ff00\"\n            ctx.fillRect(15 * i, 500 - arr[i], 10, arr[i])\n        }\n    }\n\n    // the part that was merged is made blue in the lower half\n    // also its equivalent in the uper half is made white\n    for (let i = s; i <= e; i++) {\n        ctx.fillStyle = \"#ffffff\"\n        ctx.fillRect(15 * i, 500 - arr[i], 10, arr[i])\n        ctx.fillStyle = \"#0000ff\"\n        ctx.fillRect(15 * i, 500, 10, arr[i])\n        seen[i] = 1\n    }\n\n}\n\n// merge\nmerge = (s, e) => {\n\n    let m = parseInt((s + e) / 2)\n    let p1 = s\n    let p2 = m + 1\n    let n1 = m\n    let n2 = e\n    let idx = s\n\n    while (p1 <= n1 && p2 <= n2) {\n        if (arr[p1] <= arr[p2]) {\n            temp[idx++] = arr[p1++]\n        }\n        else {\n            temp[idx++] = arr[p2++]\n        }\n    }\n\n    while (p1 <= n1) {\n        temp[idx++] = arr[p1++]\n    }\n\n    while (p2 <= n2) {\n        temp[idx++] = arr[p2++]\n    }\n\n    idx = s\n    while (idx <= e) {\n        arr[idx] = temp[idx++]\n    }\n\n}\n\n// delay\nfunction mytimeout(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// mergesort\nconst mergesort = async (s, e) => {\n\n    if (s < e) {\n        let m = parseInt((s + e) / 2)\n        await mergesort(s, m)\n        await mergesort(m + 1, e)\n        await merge(s, e)\n        // await console.log(`merged ${s} to ${e} now draw...`)\n        await draw(s, e)\n        await mytimeout(500)\n    }\n\n}\n\n// calls merge sort and at last \n// makes all bars become green in upper half\nconst performer = async () => {\n    await mergesort(0, len - 1)\n    // await console.log(arr)\n    await draw()\n}\n\n\n\nperformer()```\n\r\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n\n<body>\n    <canvas id=\"myCanvas\">\n        Your browser does not support the canvas element.\n    </canvas>\n    <script src=\"testmerge.js\"></script>\n</body>\n\n</html>```\n\r\n\r\n\r\n\nI am trying to make a visualisation of merge sort using plain javascript with HTML canvas.\nIf i change the len variable to 50 or below my code works\ncurrently i have kept the len variable at 100\nthe entire array after getting sorted, in the final picture, the bars in the histogram decrease in height automatically\ni am not sure if there is a better/cleaner way to approach this\n    ", "Answer": "\r\nThere is a visual glitch because the width of your canvas element is fixed to 1000 pixels, and the bars always have a width of 10 pixels with 5 pixel gaps between them. This means that the bar chart gets clipped as soon as the number of bars gets too large to fit in those 1000 pixels.\nOne way to fix this is to make the width of the bars (and the inter-gap) dynamically smaller as the number of bars increases.\nHere is a fix, which introduces the variables ```\nbardistance```\n, ```\nbarwidth```\n and ```\nbargap```\n, although the latter is only there to pinpoint what the gap-value is: it is not used in the rest of the code.\n\r\n\r\n```\n// variables\n// arr has elements to be sorted\nvar arr = [];\n// temp is to store the intermediate results after merging\nvar temp = [];\n// seen is for marking visited i.e. sorted half as green\nvar seen = [];\n// length of array\nvar len = 100;\n\n// canvas initialisations\nvar canvas = document.getElementById(\"myCanvas\");\ncanvas.width = canvas.height = 1000;\nvar canvaswidth = canvas.width;\nvar canvasheight = canvas.height;\nvar ctx = canvas.getContext(\"2d\");\n\nvar bardistance = Math.floor(canvaswidth / len);\nif (!bardistance) bardistance = 1;\nvar barwidth = Math.floor(bardistance * 0.7);\nif (!barwidth) barwidth = 1;\nvar bargap = bardistance - barwidth;\n\n// random array\nfor (let i = 0; i < len; i++) {\n    arr.push(parseInt(Math.random() * 500));\n    temp.push(parseInt(0));\n    seen.push(parseInt(0));\n}\n\n// initial contents of array to be sorted\n// console.log(arr)\n\n// draw the bars\nvar draw = (s, e) => {\n    ctx.clearRect(0, 0, 1000, 1000);\n\n    // this loop will make unvisited bars in the upper half as black\n    // and visited bars in the upper half as green\n    for (let i = 0; i < len; i++) {\n        ctx.fillStyle = \"#000000\";\n        ctx.fillRect(bardistance * i, 500 - arr[i], barwidth, arr[i]);\n        if (seen[i]) {\n            ctx.fillStyle = \"#00ff00\";\n            ctx.fillRect(bardistance * i, 500 - arr[i], barwidth, arr[i]);\n        }\n    }\n\n    // the part that was merged is made blue in the lower half\n    // also its equivalent in the uper half is made white\n    for (let i = s; i <= e; i++) {\n        ctx.fillStyle = \"#ffffff\";\n        ctx.fillRect(bardistance * i, 500 - arr[i], barwidth, arr[i]);\n        ctx.fillStyle = \"#0000ff\";\n        ctx.fillRect(bardistance * i, 500, barwidth, arr[i]);\n        seen[i] = 1;\n    }\n\n}\n\n// merge\nmerge = (s, e) => {\n\n    let m = parseInt((s + e) / 2);\n    let p1 = s;\n    let p2 = m + 1;\n    let n1 = m;\n    let n2 = e;\n    let idx = s;\n\n    while (p1 <= n1 && p2 <= n2) {\n        if (arr[p1] <= arr[p2]) {\n            temp[idx++] = arr[p1++];\n        }\n        else {\n            temp[idx++] = arr[p2++];\n        }\n    }\n\n    while (p1 <= n1) {\n        temp[idx++] = arr[p1++];\n    }\n\n    while (p2 <= n2) {\n        temp[idx++] = arr[p2++];\n    }\n\n    idx = s;\n    while (idx <= e) {\n        arr[idx] = temp[idx++];\n    }\n\n}\n\n// delay\nfunction mytimeout(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// mergesort\nconst mergesort = async (s, e) => {\n\n    if (s < e) {\n        let m = parseInt((s + e) / 2);\n        await mergesort(s, m);\n        await mergesort(m + 1, e);\n        await merge(s, e);\n        // await console.log(`merged ${s} to ${e} now draw...`)\n        await draw(s, e);\n        await mytimeout(500);\n    }\n\n}\n\n// calls merge sort and at last \n// makes all bars become green in upper half\nconst performer = async () => {\n    await mergesort(0, len - 1);\n    // await console.log(arr)\n    await draw();\n}\n\nperformer();```\n\r\n```\n<canvas id=\"myCanvas\"></canvas>```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementation of merge sort\r\n                \r\nI need help with my implementation of merge sort in C.\n\nMy program generates a random array and display the execution time of sorts.\nMy other sort work well but starting from 2000 Elements sorted my program stops.\n\nI dont know why, please can you look at my implementation.\n\n```\nvoid Interclassement(TABLEAU t, int nbelts, int m, int n) {\n\n    TABLEAU S = recopie( t, nbelts);\n    int i, j, k;\n\n    i = m;\n    j = ((m+n)/2) +1;\n    k = m;\n\n    while (i <= (m+n)/2  && j <= n) {\n        if (t[i] <= t[j]) {\n            S[k] = t[i];\n            i++;\n        }\n        else {\n            S[k] = t[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i <= (m+n)/2 ) {\n        S[k]= t[i];\n        i++;\n        k++;\n    }\n\n    for (i=1; i < k-1 ; i++) {\n        t[i]=S[i];\n    }\n}\n\nvoid triParFusion(TABLEAU t, int nbelts, int m, int n){\n    if (m < n) {\n        triParFusion(t, nbelts, m, (m+n)/2 );\n        triParFusion(t, nbelts, ((m+n)/2) +1, n);\n        Interclassement(t, nbelts, m, n);\n    }\n} \n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Target specific attributes with merge sort\r\n                \r\nImplemented the merge sort algorithm in my javascript code. \n\nI'm wonder how I can target specific attributes like ```\ndate```\n, ```\ntitle```\n, ```\nname```\n etc for sorting in an array when calling merge sort like ```\nmergeSort(array);```\n.\n\n```\nfunction mergeSort(arr){\n    var len = arr.length;\n    if(len <2)\n        return arr;\n    var mid = Math.floor(len/2),\n        left = arr.slice(0,mid),\n        right =arr.slice(mid);\n\n    return merge(mergeSort(left),mergeSort(right));\n}\n\nfunction merge(left, right){\n    var result = [],\n        lLen = left.length,\n        rLen = right.length,\n        l = 0,\n        r = 0;\n    while(l < lLen && r < rLen){\n        if(left[l] < right[r]){\n            result.push(left[l++]);\n        }\n        else{\n            result.push(right[r++]);\n        }\n    }  \n\n    return result.concat(left.slice(l)).concat(right.slice(r));\n}\n```\n\n\nUsing it in a sort options method. What I want is to print a sorted list. The way the list is sorted will be defined by the users chosen sort option.\n\n```\nfunction sortConfig(array, sortOption){\n if(sortOption == 'title') mergeSort(array.Title);\n //..etc\n}\n```\n\n    ", "Answer": "\r\nTo implement the behavior with an optional argument, you could do it in the following way:\n\n```\nfunction mergeSort(arr, compare = (item => item))\n```\n\n\nThis would set compare function to be the item itself when running the merge\n\nand then we update the calling of the merge and mergeSort itself, where they now all get the compare argument\n\n```\nreturn merge(mergeSort(left, compare), mergeSort(right, compare), compare);\n```\n\n\nand ofcourse the declaration for your merge function itself\n\n```\nfunction merge(left, right, compare)\n```\n\n\nWhich then calls the compare function upon comparison, like here:\n\n```\nif (compare(left[l]) < compare(right[r]))\n```\n\n\nThis lets you choose wether you wish to give an argument or not wen you call your mergeSort function, like:\n\n```\nconsole.log(mergeSort(nrs).join(','));\nconsole.log(mergeSort(nrs, n => -n).join(','));\n\nconsole.log(mergeSort(arr, i => i.id));\nconsole.log(mergeSort(arr, i => i.title));\n```\n\n\n\r\n\r\n```\nfunction mergeSort(arr, compare = (item => item)) {\r\n  var len = arr.length;\r\n  if (len < 2)\r\n    return arr;\r\n  var mid = Math.floor(len / 2),\r\n    left = arr.slice(0, mid),\r\n    right = arr.slice(mid);\r\n\r\n  return merge(mergeSort(left, compare), mergeSort(right, compare), compare);\r\n}\r\n\r\nfunction merge(left, right, compare) {\r\n  var result = [],\r\n    lLen = left.length,\r\n    rLen = right.length,\r\n    l = 0,\r\n    r = 0;\r\n  while (l < lLen && r < rLen) {\r\n    if (compare(left[l]) < compare(right[r])) {\r\n      result.push(left[l++]);\r\n    } else {\r\n      result.push(right[r++]);\r\n    }\r\n  }\r\n\r\n  return result.concat(left.slice(l)).concat(right.slice(r));\r\n}\r\nvar arr = [{\r\n  title: 'test 5',\r\n  id: 4\r\n}, {\r\n  title: 'test',\r\n  id: 0\r\n}, {\r\n  title: 'test 3',\r\n  id: 2\r\n}, {\r\n  title: 'test 4',\r\n  id: 3\r\n}];\r\nvar nrs = [5, 3, 7, 156, 15, 6, 17, 9];\r\n\r\n// and call like\r\nconsole.log(mergeSort(nrs).join(','));\r\nconsole.log(mergeSort(nrs, n => -n).join(','));\r\n\r\n// or like\r\nconsole.log(mergeSort(arr, i => i.id));\r\nconsole.log(mergeSort(arr, i => i.title));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java Merge Sort not working\r\n                \r\nHi I have been working on getting the merge sort working, I have a complteted code but am not getting the right results... Here is my code and the results are \"876323149\" any help would be greatly appreciated. \n\n```\npublic class MergeSort\n{\n  private static int[] local;  // for use in copying\n  private static int[] a;\n  public static void main(String[] args)\n {\n  int[] test = {2,3,1,4,7,8,6,3,9};\n  sort(test);}\n\n  public static void sort(int[] orig)\n  {\n    int n = orig.length;\n    local = new int[n];\n    a = orig;\n    recursiveSort(0, n-1);\n    for(int i = 0; i < a.length; i ++){\n    System.out.print(a[i]);\n  }\n  }\n\n  private static void recursiveSort(int lo, int hi)\n  {\n    int mid =(hi + lo) / 2;\n    if(hi-lo > 2){\n      recursiveSort(lo, mid);\n      recursiveSort(mid + 1, hi);\n      merge(lo, mid + 1, hi);\n\n    }      \n  }\n\n  private static void merge(int lo, int mid, int hi)\n  {\n    int d = lo;\n    int b = mid + 1;\n    int c = lo;\n    for (int i = lo; i <= hi; i++) {\n      local[i] = a[i];\n    }\n    while(d <= mid && b <= hi){\n      if(local[d] > local[b]){\n        a[c] = local[d];\n        d++;}\n      else{\n        a[c] = local[b];\n        b++;}\n      c++;}\n   while (d <= mid) {\n      a[c] = local[d];\n      c++;\n      d++;\n    }\n  }\n} \n```\n\n    ", "Answer": "\r\nYou have to make sure that lo is less than hi so that recursiveSort keeps sorting the different array recursively and doesn't try to sort an array of length <= 1. And more importantly mid must be set inside of this if statement every time the if statement is called\n\nHere is the fix:\n\n```\nprivate static void recursiveSort(int lo, int hi)\n{\nif(lo < hi){\nint mid =(hi + lo) / 2;\n\nrecursiveSort(lo, mid);\nrecursiveSort(mid + 1, hi);\nmerge(lo, mid + 1, hi);\n\n}      \n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort and Quick Sort issues\r\n                \r\nI thought this would be nontrivial, but its been awhile since I've done any java. My merge sort and quick sort algorithms (assignment for class) don't work! The array remains in the same order as before I call the methods. Any help is appreciated!\n\n```\nimport java.io.IOException;\npublic class Main {\n/**\n * @param args\n * @throws IOException \n */\n\npublic static void main(String[] args) throws IOException {\n    // \n    Lab1Methods lab1 = new Lab1Methods();\n    lab1.fillArray();\n    lab1.testProblem1(lab1.integers);\n\n    lab1.auxMergeSort(lab1.integers, lab1.startIndex, lab1.endIndex);\n    lab1.testProblem1(lab1.integers);\n\n    lab1.auxQuickSort(lab1.integers, lab1.startIndex, lab1.endIndex);\n    lab1.testProblem1(lab1.integers);\n    }\n}\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Lab1Methods {\n//**************************************************fields\nint[] integers;\nint startIndex;\nint endIndex;\n\n//**************************************************methods\n\n//****************************************constructors\npublic Lab1Methods(){\n    integers = new int [10000000];\n    startIndex = integers[0];\n    endIndex = integers[9999999];\n}\n//****************************************1***********************\n    public void fillArray() throws IOException{\n        FileReader file = new FileReader(\"lab1_data.txt\");\n        int i = 0;\n        try {\n            Scanner input = new Scanner(file);\n            while(input.hasNext())\n            {\n                integers[i] = input.nextInt();\n                i++;\n            }\n            input.close();\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n\n    }\n    //**********test the first problem**********\n    public void testProblem1(int[] array){\n        int [] testIntegers = array;\n\n        System.out.println(\"The first ten integers: \");\n        for(int j = 0;j<10;j++)\n        {\n            System.out.println(testIntegers[j]);            \n        }\n        int sum = 0;\n        System.out.println(\"Sum of all 10,000,000 integers: \");\n        for(int k = 0;k <= testIntegers.length; k++)\n        {\n            sum += k;\n        }\n        System.out.println(sum);\n    }\n\n    //****************************************2****************************\n     public void DoMerge(int [] numbers, int left, int mid, int right)\n      {\n        int [] temp = new int[25];\n        int i, left_end, num_elements, tmp_pos;\n\n        left_end = (mid - 1);\n        tmp_pos = left;\n        num_elements = (right - left + 1);\n\n        while ((left <= left_end) && (mid <= right))\n        {\n            if (numbers[left] <= numbers[mid])\n                temp[tmp_pos++] = numbers[left++];\n            else\n                temp[tmp_pos++] = numbers[mid++];\n        }\n\n        while (left <= left_end)\n            temp[tmp_pos++] = numbers[left++];\n\n        while (mid <= right)\n            temp[tmp_pos++] = numbers[mid++];\n\n        for (i = 0; i < num_elements; i++)\n        {\n            numbers[right] = temp[right];\n            right--;\n        }\n    }\n    public void auxMergeSort(int[] array, int left, int right){\n\n        int mid;\n\n        if (right > left){\n            mid = (right + left) / 2;\n            auxMergeSort(array, left, mid);\n            auxMergeSort(array, (mid + 1), right);\n\n            DoMerge(array, left, (mid+1), right);\n          }\n        }\n\n              //**********************************3************************\n    public void auxQuickSort(int [] arr, int startIndex, int endIndex){\n              // For Recusrion\n              if(startIndex < endIndex)\n              {\n                  int pivot = Partition(arr, startIndex, endIndex);\n\n                  if(pivot > 1)\n                      auxQuickSort(arr, startIndex, pivot - 1);\n\n                  if(pivot + 1 < endIndex)\n                      auxQuickSort(arr, pivot + 1, endIndex);\n              }\n          }\n\n    public int Partition(int[] numbers, int startIndex, int endIndex){\n        int pivot = numbers[startIndex];\n        while (true){\n            while (numbers[startIndex] < pivot)\n                startIndex++;\n\n            while (numbers[endIndex] > pivot)\n                endIndex--;\n\n            if (startIndex < endIndex)\n                {\n                    int temp = numbers[endIndex];\n                    numbers[endIndex] = numbers[startIndex];\n                    numbers[startIndex] = temp;\n                }\n            else\n                {\n                    return endIndex;\n                }\n    }\n\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Realize worker-threads for merge sort algorithm\r\n                \r\nI have a single-thread version of the merge sort http://pastebin.com/2uMGjTxr\n\nIt creates an array, fills it with random numbers and calles the sort method on it that performs the merge sort:\n\n```\nprivate static int[] sort(int[] array) {\n    //TODO: use multiple threads to speed up the sorting\n\n    return mergeSort(array, 0, array.length);\n}\n```\n\n\nNow I want to increase performance using the multithreading technique in java. The code is from my tutor and he said I have to add something to the sort method but that actually confuses me. \n\nThe merge sort is a devide and conquer algorithm:\n\n\nIf the list is of length 0 or 1, then it is already sorted. Otherwise:\nDivide the unsorted list into two sublists of about half the size.\nSort each sublist recursively by re-applying the merge sort.\nMerge the two sublists back into one sorted list.\n\n\nSo I actually would start a thread for each sublist. What do you think? How can merge sort be parallelized according to the give implementation? Has anyone a clue why I should edit the sort method?\n    ", "Answer": "\r\nThis is a great exercise for the use of the ForkJoin Framework set to release in Java 7.0.  Its exactly what you are looking for.  You simply submit(fork) Recursive merging tasks to the pool and join the results when complete.\n\nYou can download the JSR 166 Binary.  For more information this is a nice article\n\nEdit to address your comment:\n\nIf you wanted to implement it yourself, you would not want a new Thread for each sublist.  You can imagine there will be many partitions of a given array to sort so a thread per partition would grow huge (assuming a big enough array).  Instead you would want a thread for each partitioned array you will actually being doing the merge work on.  The ForkJoin does this for you, one of the benefits of using an FJ pool is that it will reuse threads instead of creating a new thread for a subprocess merge.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort on Linked List\r\n                \r\nMerge Sort functions with only some inputs when run on a linked list. If I include 0 in the list of inputs, only 0 is returned from the final print() call. I don't know what I'm doing wrong\n\n```\nclass StackNode(object):\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n\nclass Stack(object):\n    def __init__(self):\n        self.head = None\n        self.count = 0\n\n    def push(self, data):\n        if (self.head == None):\n            self.head = StackNode(data)\n            self.count += 1\n            return\n        node = StackNode(data)\n        node.prev = self.head\n        self.head = node\n        self.count += 1\n        return\n\n    def pop(self):\n        node = self.head\n        self.head = self.head.prev\n        self.count -= 1\n        return node\n\n    def print(self):\n        node = self.head\n        if(node == None):\n            return\n        print(node.data)\n        while(node.prev):\n            node = node.prev\n            print(node.data)\n\n    def MergeSort(self, h):\n        if h == None or h.prev == None:\n            return h\n        middle = self.GetMiddle(h)\n        nextToMiddle = middle.prev\n        middle.prev = None\n        left = self.MergeSort(h)\n        right = self.MergeSort(nextToMiddle)\n        sortedList = self.SortedMerge(left, right)\n        return sortedList\n\n\n     def SortedMerge(self, a, b):\n        if a is None:\n            return b\n        if b is None:\n            return a\n        if(a.data > b.data):\n            result = a\n            a.prev = self.SortedMerge(a.prev, b)\n        else:\n            result = b\n            b.prev = self.SortedMerge(b.prev, a)\n        return result\n\n    def GetMiddle(self, head):\n        if head == None:\n            return head\n        slow = head\n        fast = head\n        while(fast.prev != None and fast.prev.prev != None):\n            slow = slow.prev\n            fast = fast.prev.prev\n        return slow\n\na = Stack()\na.push(2)\na.push(5)\na.push(1)\na.push(4)\na.push(3)\na.push(7)\na.print()\na.MergeSort(a.head)\nprint(\"after: \")\na.print()\n```\n\n\nI transcribed my code directly from the linked list merge sort example given on geeksforgeeks.com, with the only difference being that my code creates a stack instead of a queue\n    ", "Answer": "\r\nMergeSort returns the head of a sorted list, so the call in the main code should be:\n\n```\na.head = a.MergeSort(a.head)\n```\n\n\nFor a sorted stack, it would seem that the result of doing successive list.pop() should return the nodes in data order, but the code is using \">\" instead of \"<=\" in the compare, reversing the order.\n\n\n\nPython 2.7 complained about using the name print for the class print function, and also complained about the 5 (instead of 4) spaces before \"def SortedMerge(self, a, b):\"\n\n\n\nSortedMerge() does one level of recursion for every node merged. For a large list, the program will get stack overflow. Since the list class includes a count, the code could use list.count//2 to determine the number of nodes to advance to reach the midpoint, then use (count//2) for the size of the left half and (count-(count//2)) for the size of the right half. A bottom up merge sort is faster still. However, with python, the overhead of interpreting code is so large that I don't know if it will make a difference. Here is a link to both top down and bottom up merge sort for a linked list, in java, that use a common merge function:\n\nMerge Sort for Singly Linked List seems to remove any numbers larger than the final number I input into the list\n\n\n\nI converted the code to python. The merge function is the same for both examples. Note the sort logic is the same, only the push and pop functions result in the linked list acting as a stack. Merge function:\n\n```\n    def Merge(self, a, b):\n        if a is None:\n            return b\n        if b is None:\n            return a\n        r = StackNode(0)                    # dummy node\n        d = r\n        while(True):\n            if(a.data <= b.data):\n                d.prev = a\n                d = a\n                a = a.prev\n                if(a == None):\n                    d.prev = b\n                    break\n            else:\n                d.prev = b\n                d = b\n                b = b.prev\n                if(b == None):\n                    d.prev = a\n                    break\n        return r.prev\n```\n\n\nTop down example:\n\n```\n    def MergeSort(self):\n        if(self.count < 2):\n            return\n        self.head = self.MergeSortR(self.head, self.count)\n\n    def MergeSortR(self, h, n):\n        if(n < 2):\n            return h\n        n2 = n//2\n        t = self.Scan(h, n2-1)\n        m = t.prev\n        t.prev = None\n        h = self.MergeSortR(h, n2)\n        m = self.MergeSortR(m, n-n2)\n        h = self.Merge(h, m)\n        return h\n\n    def Scan(self, h, n):\n        while(n > 0):\n            h = h.prev\n            n = n-1\n        return h\n```\n\n\nBottom up example:\n\n```\n    def MergeSort(self):\n        if(self.count < 2):\n            return\n        an = [None] * 32\n        node = self.head\n        while(node != None):\n            prev = node.prev\n            node.prev = None\n            i = 0\n            while((i < 32) and (an[i] != None)):\n                node = self.Merge(an[i], node)\n                an[i] = None\n                i = i+1\n            if(i == 32):\n                i = i-1\n            an[i] = node\n            node = prev\n        for i in xrange (0, 32):\n            node = self.Merge(an[i], node)\n        self.head = node\n```\n\n\nTest code for 512K nodes. On my system, top down takes about 4.5 seconds, bottom up about 3.9 seconds. To get an idea of the overhead of Python, bottom up in C takes about 0.06 seconds. \n\n```\nimport random\nfrom time import time\np = [random.randint(0, 2147483647) for r in xrange(512*1024)]\na = Stack()\nfor i in xrange (0, len(p)):\n    a.push(p[i])\ns = time()\na.MergeSort()\ne = time()\nprint e - s\nfor i in xrange (0, len(p)):\n    p[i] = a.pop().data\nfor i in xrange (1, len(p)):\n    if(p[i-1] > p[i]):\n        print(\"error\")\n        break\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort remove duplicates\r\n                \r\nI am trying to sort an array via merge sort, and while sorting, remove elements that I have deemed equal.  I am recursively calling merge sort and then merging.  \n\nI get to this point and find that ```\na```\n and ```\nc```\n are duplicates.  \n\n```\na b | c d\n```\n\n\nI determine which one I want based on certain criteria and I pick c. I increment the right hand counter and and the left hand counter and compare b and d.  Say I pick d, then I pick b. I want my final list to only have the elements \n\n```\nc d b  \n```\n\n\nHowever, what is happening is on the next recursive call, ```\nstart```\n and ```\nend```\n are 0 and 3 so d is listed twice in the array on the next call.  The array that the merge procedure works with is:\n\n```\nc d b d\n```\n\n\nHere is the code.  Thanks in advance.\n\n```\nprivate static void merge(int[] data, int start, int mid, int end)\n{\n    int firstCopied=0;\n    int secondCopied=0;\n    int index=0;\n    int length=end-start+1;\n\n    int[] temp = new int[end-start+1];\n    int firstSize=mid-start+1;\n    int secondSize=end-mid;\n\n    while(firstCopied < firstSize && secondCopied < secondSize)\n    {\n        if(data[start+firstCopied] < data[mid+1+secondCopied])\n        {\n            temp[index++] = data[start+firstCopied];\n            firstCopied++;\n        }\n\n        else if(data[start+firstCopied] > data[mid+1+secondCopied])\n        {\n            temp[index++] = data[mid+1+secondCopied];\n            secondCopied++;\n        }\n\n        else if(data[start+firstCopied]==data[mid+1+secondCopied])\n        {\n            boolean result = PickOne();\n\n            if(result)\n            {\n                temp[index++] = data[start+firstCopied];\n            }\n            else\n            {\n                temp[index++] = data[mid+1+secondCopied];\n            }\n\n            firstCopied++;\n            secondCopied++;\n            length--;\n        }\n    }\n    while(firstCopied < firstSize)\n    {\n        temp[index++] = data[start+firstCopied];\n        firstCopied++;\n    }\n\n    while(secondCopied < secondSize)\n    {\n        temp[index++] = data[mid+1+secondCopied];\n        secondCopied++;\n    }\n\n    for(int i=0; i<length; i++)\n    {\n        data[start+i]=temp[i];\n    }\n\n}\n```\n\n    ", "Answer": "\r\nThe philosophy of the C++ Standard Library is to use algorithms that do one thing well. It's best to follow that approach since it will lead to more reusable code.\n\nE.g. here's a mergesort sketch followed by a call to ```\nstd::unique```\n\n\n```\ntemplate<typename BiDirIt>\nvoid merge_sort(BiDirIt first, BiDirIt last)\n{\n    auto const N = std::distance(first, last);\n    if (N < 2) return;\n\n    // sort each part individually, then merge back in-place\n    auto middle = first + N / 2;\n    merge_sort(first, middle);\n    merge_sort(middle, last);\n    std::inplace_merge(first, middle, last);\n}    \n\nint data[] = { /* your data */ };\nmerge_sort(std::begin(data), std::end(data));\n\nauto it = std::unique(std::begin(data), std::end(data));\nfor (auto ut = std::begin(data); ut != it; ++ut) {\n    // process unique data\n}\n```\n\n\nIf your data was in a ```\nstd::vector```\n instead of a C-array, you could call ```\nv.erase(v.begin(), it);```\n to actually erase the non-unique data as well.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort function C# not sorting\r\n                \r\nI've been trying to build a merge sort algorithm, that sorts a list of numbers but cannot seem to get it to work. The functions look like this at the moment:\n```\nprivate void Merge_sort(List<int> list, int left, int right)\n{\n    if (left < right)\n    {\n        int center = (left + right) / 2;\n        Merge_sort(list, left, center);\n        Merge_sort(list, center + 1, right);\n        Merge(list, left, center, right);\n    }\n}\n\nprivate void Merge(List<int> list, int left, int center, int right)\n{\n    int num1 = center - left + 1;\n    int num2 = right - center;\n\n    List<int> left_list = new List<int>();\n    List<int> right_list = new List<int>();\n\n    for (int ii = left; ii <= center; ii++)\n    {\n        left_list.Add(ii);\n    }\n    for (int jj = center + 1; jj < right; jj++)\n    {\n        right_list.Add(jj);\n    }\n    left_list[num1 + 1] = int.MaxValue;\n    right_list[num2 + 1] = int.MaxValue;\n    int i = 1;\n    int j = 1;\n\n    for (int k = left; k < right; k++)\n    {\n        if (left_list[i] <= right_list[j])\n        {\n            list[k] = left_list[i];\n            i= i+1;\n        }\n        else\n        {\n            list[k] = right_list[j];\n            j = j+1;\n        }\n    }\n}\n```\n\nthe function that calls these ones is:\n```\npublic override void Sort(List<int> list)\n{\n    //find the center\n    int center = list.Count / 2;\n    int right = center;\n    int left = center;\n    Merge_sort(list, left, right);\n}\n```\n\ncan anyone see what I am doing wrong? The program runs, it just doesn't sort the list.\n    ", "Answer": "\r\n```\nif(left < right)```\n you init both with ```\ncenter```\n, so this will always be ```\nfalse```\n and sorting never ever even starts.\nWhich you would have probably seen, had you stepped it through. Make yourself familiar with the debugging tools :)\nTo fix this, try ...\n```\npublic override void Sort(List<int> list)\n{\n    // TODO Check Count > 1 , maybe even > 2 for 2 elements you simply need an if/else\n    int right = list.Count-1;\n    int left = 0;\n    Merge_sort(list, left, right);\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in C\r\n                \r\nI am new in programming/C. \nI understand the algorithm of merge-sort as an algorithm but when it comes to programming, it appears that I am doing something wrong. \nCould anybody help?\n\nThanks.\n\nHere is my code:\n\n```\nmerge(int A[],int p,int q,int r);\npart(int A[],int p,int r);\n\nint main()\n{\nint A [6]={10,5,4,0,11,7}, n,y,z;\n\ny=1; z=sizeof(A)/sizeof(int);\n\npart(A,y,z);\nfor(n=0;n<z;n++)\nprintf(\"%d\\n\", A[n]);\n\n    return 0;\n}\n\npart(int A[],int p,int r)\n{\n    if (p<r)\n    {\n        int q=(p+r)/2;\n        part(A,p,q);\n        part(A,q+1,r);\n        merge(A,p,q,r);\n    }\n}\n\nmerge(int A[],int p,int q,int r)\n{\n    int n1=q-r+1,n2=r-q,L[n1+1],R[n2+1],i,j,k;\n    L[n1+1]=100000;\n    R[n2+1]=100000;\n    for (i=0;i<n1;i++)\n        L[i]=A[p-1+i];\n    for (j=0;j<n2;j++)\n        R[j]=A[q+j];\n    i=0;j=0;\n    for (k=0;k<r;k++)\n        if(L[i]<=R[j])\n    {\n        A[k]=L[i];\n        i++;\n    }\n    else\n    {\n        A[k]=R[j];\n        j++;\n    }\n}\n```\n\n    ", "Answer": "\r\nHere is your corrected code:\n\n```\n#include<stdio.h>\n#include<limits.h>\n\nvoid merge(int A[],int p,int q,int r);\nvoid part(int A[],int p,int r);\n\nint main()\n{\nint A [6]={10,5,4,0,11,7}, n,y,z;\n\ny=0; z=6;\n\npart(A,0,z-1); // Pass starting from 0 to Length - 1 of Array\nfor(n=0;n<z;n++)\nprintf(\"%d\\n\", A[n]);\n\n    return 0;\n}\n\nvoid part(int A[],int p,int r)\n{\n    if (p<r)\n    {\n        int q=(p+r)/2;\n        part(A,p,q);\n        part(A,q+1,r);\n        merge(A,p,q,r);\n    }\n}\n\nvoid merge(int A[],int p,int q,int r)\n{\n    int n1=q-p+1,n2=r-q;\n    int L[n1+1],R[n2+1],i,j,k;\n    L[n1]=INT_MAX;\n    R[n2]=INT_MAX;\n\n    for (i=0;i<n1;i++)\n        L[i]=A[p+i];\n\n    for (j=0;j<n2;j++)\n        R[j]=A[q+j+1];\n\n    i=0;j=0;\n\n    for (k=p;k<=r;k++)\n    {\n        if(L[i]<=R[j])\n        {\n            A[k]=L[i];\n            i++;\n        }\n        else\n        {\n            A[k]=R[j];\n            j++;\n        }\n    }\n}\n```\n\n\nThese are the parts which were wrong:\n\n```\nint n1=q-r+1,n2=r-q  // --> Your calculation of new indices was wrong\n```\n\n\nThese indices take you out of bounds of the array:\n\n```\nL[n1+1]=100000;\nR[n2+1]=100000;\n```\n\n\nAlso instead of using a random value like ```\n100000```\n use ```\nINT_MAX```\n in ```\nlimits.h```\n for the sentinel element.\n\n```\n for (k=0;k<r;k++) // ->wrong\n```\n\n\nYou should move from left index of array to right not from ```\n0```\nth index.\n\nOutput:\n\n```\n0\n4\n5\n7\n10\n11\n```\n\n\nRest you can check for yourself.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Understanding and solving K-Way merge sort\r\n                \r\nI want to:\n\ncount the number of comparisons needed by k-Way merge sort to sort random permutation of numbers from 0 to N-1.\n\nto count the number of data moves needed by K-Way merge sort to sort random permutation of numbers from 0 to N-1.\n\n\nI understand how 2-way merge sort works correctly, and understand the code very well. My problem now is I don't know how to start. How do I convert the 2-way merge sort into K-Way so that I can solve the above problems?\nI have searched the web but can't find any tutorial to explain \"k-Way merge sort\" very well.\nI need good explanation what to do so that I can take it from there and do it myself.\nLike I said I understand the 2-Way, so how do I move to the K-Way merge sort?  How do I implement the K-way?\nEdit\nI read some post http://bchalk.com/work/view/k_way_merge_sort\nthat BinaryHeap must be used to implement k-Way merge. Is that so or there are other ways?\nHow do I divide my list into K? Is there a special way of doing it?\n    ", "Answer": "\r\nWhen ```\nk > 2```\n, the leading elements from each of the input streams are typically kept in a minheap structure.  This makes it easy to find to the mininum of the the n-values, to pop that value off the heap, and insert a replacement value from the corresponding input stream.\n\nA heap does ```\nO(lg2 k)```\n comparisons for each insertion, so the total work for a k-way merge of n items is ```\nn * lg2(k)```\n.\n\nEventhough you asked about C# and Java, you can learn how to do it by looking at the Python standard library code for a k-way merge:  http://hg.python.org/cpython/file/2.7/Lib/heapq.py#l323\n\nTo answer your other question, there is no special way to divide your list into K groups.  Just take the first N/k elements in the first array, the next N/k elements into the next, etc.  Sort each array and then merge them using heaps as mentioned above.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "is this implementation of merge sort good?\r\n                \r\nI've just started to learn Haskell last night and I've never used a functional programming language before.\nI just want to know if my implemention of merge sort is good or bad and what exactly is good or bad.\nMaybe it's even wrong - Well it does sort but maybe the Algorithm is not what I think what merge sort is.\n\nJust tell me everything I could improve here. I by myself think its a pretty clear and simple implementation.\nThanks for your advice, here's the code :)\n\n```\nmerge [] ys = ys\nmerge xs [] = xs\nmerge xs ys =  sorted : merge left right\n                where \n                    sorted = if head(xs) < head(ys) then head(xs) else head(ys)\n                    left = if head(xs) <= head(ys) then tail(xs) else xs\n                    right = if head(xs) > head(ys) then tail(ys) else ys\n\nmsort [] = []\nmsort [x] = [x]\nmsort xs = merge (msort left) (msort right)\n            where \n                left = take (div (length xs) 2) xs\n                right = drop (div (length xs) 2) xs\n```\n\n    ", "Answer": "\r\nWell, first of all, we can rewrite merge to be a little more elegant using pattern matching\n\n```\nmerge [] ys = ys\nmerge xs [] = xs\nmerge xs@(x:xs1) ys@(y:ys1)\n    | x <= y = x : merge xs1 ys\n    | otherwise = y : merge xs ys1\n```\n\n\nIn general you should avoid using ```\nhead```\n and ```\ntail```\n since they are a bit unsafe (they raise an error for the empty list) and use pattern matching whenever possible.\n\nThe implementation of ```\nmsort```\n is pretty much spot on, except that we can split the list in a more efficient way. That's because ```\nlength xs```\n - takes O(N) to complete. The compiler might save you and cache the result of the ```\nlength```\n call so that the second call to ```\nlength```\n won't traverse the list again. But the ```\ntake```\n and ```\ndrop```\n will pretty much cause another two traversals thus splitting the list using 3 traversals which may prove to be expensive. We can do better by splitting the list in two lists - the first one containing the elements on the odd positions and the second list with the elements placed on the even positions, like so:\n\n```\nmsort [] = []\nmsort [x] = [x]\nmsort xs = merge (msort first) (msort second)\n    where\n        (first, second) = splitInHalves xs\n        splitInHalves [] = ([], [])\n        splitInHalves [x] = ([x], [])\n        splitInHalves (x:y:xs) =\n            let (xs1, ys1) = splitInHalves xs\n            in  (x:xs1, y:ys1)\n```\n\n\nThis gets you the same Merge Sort in O(NlogN) time. It feels different because you would probably implement it in place (by modifying the original list) in an imperative language such as C. This version is slightly more costly on the memory, but it does have it's advantages - it is more easy to reason about, so it is more maintainable, and also it is very easy to parallelize without being concerned of anything else except the algorithm itself - which is exactly what a good programming language should provide for the developers that use it.\n\nEDIT 1 :\n\nIf the syntax is a bit much, here are some resources:\n\n\nPattern Matching - the bit with the ```\n@```\n symbol is called an as-pattern. You'll find it in there\n```\nlet```\n is a keyword used to declare a variable to be used in the expression that follows it (whereas ```\nwhere```\n binds a variable in the expression that precedes it). More on Haskell syntax, including guards (the things with ```\n| condition = value```\n) can be found here, in this chapter of Learn You a Haskell\n\n\nEDIT 2 :\n\n@is7s proposed a far more concise version of ```\nsplitInHalves```\n using the ```\nfoldr```\n function:\n\n```\nsplitInHalves = foldr (\\x (l,r) -> (x:r,l)) ([],[])\n```\n\n\nEDIT 3 :\n\nHere is another answer which provides an alternative implementation of merge sort, which also has the property of being stable:\n\nLazy Evaluation and Time Complexity\n\nHope this helps and welcome to the wonderful world of Functional Programming !\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C++ Merge Sort using iterators\r\n                \r\nCurrently, I am trying to create a simple C++ Merge Sort Program.\n```\nusing namespace std;\n\nusing Iterator = std::vector<int>::iterator;\nusing CIterator = std::vector<int>::const_iterator;\nstd::vector<int> merge(CIterator left_begin, CIterator left_end, CIterator right_begin, CIterator right_end) {\n    std::vector<int> result;\n    \n    CIterator left = left_begin;\n    CIterator right = right_begin;\n    \n    while (left != left_end && right != right_end) {\n        if (*left <= *right) {\n            result.push_back(*left);\n            left++;\n        } else {\n            result.push_back(*right);\n            right++;\n        }\n    }\n    \n    while (left != left_end) {\n        result.push_back(*left);\n        left++;\n    }\n    \n    while (right != right_end) {\n        result.push_back(*right);\n        right++;\n    }\n    \n    return result;\n}\n```\n\nI created a merge function that basically connects two sorted vectors into one and returns it (I am bound to use the following return type of the function merge). Then Trying to write the driver function merge sort I have the following code, that I think works correctly\n```\nvoid merge_sort(Iterator begin, Iterator end) {\n    auto difference = distance(begin, end);\n    \n    if (difference <= 1) {\n        return;\n    }\n    \n    Iterator middle = begin;\n    advance(middle, difference / 2);\n    \n    merge_sort(begin, middle);\n    merge_sort(middle, end);\n    \n    vector<int> result = merge(begin, middle, middle, end);\n    // But what to put here?\n}\n```\n\nAt the place of the comment mark, I don't understand what to write in order to move the sorted array a step up in the recursion. I tried\n```\n    begin = result.begin();\n    end = result.end();\n```\n\nbut this obviously doesnt work\n    ", "Answer": "\r\nThe problem is that the type signature for ```\nmerge_sort```\n assumes an in-place algorithm:\n```\nvoid merge_sort(Iterator begin, Iterator end);\n```\n\nBut your ```\nmerge```\n procedure isn't in-place but returns a merged copy of the arrays. You either need to change ```\nmerge```\n to be in-place, or you need to change ```\nmerge_sort```\n to return the sorted array. The latter solution (easier but less efficient) would be like this:\n```\nstd::vector<int> merge_sort(Iterator begin, Iterator end) {\n    auto difference = distance(begin, end);\n    \n    if (difference <= 1) {\n        return;\n    }\n    \n    Iterator middle = begin;\n    advance(middle, difference / 2);\n    \n    std::vector<int> left = merge_sort(begin, middle);\n    std::vector<int> right = merge_sort(middle, end);\n    return merge(left.begin(), left.end(), right.begin(), right.end());\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort implementation questions in Java\r\n                \r\nI'm in an algorithms course and am learning about merge sort. Our professor recommended we try to implement the pseudo code provided in the book. \n\n\nAm I correct in using Integer.MAX_VALUE as a sentinel value when\nsorting an array of integers (used in lines 8 & 9 in the Merge\nmethod pseudo code below)?\nFor line 2 of the Merge-Sort pseudo code method, is it correct to code that in Java using Math.ceil() like I did? (Edit: It's actually floor and I updated my code to reflect this.)\n\n\nIf you see any other mistakes please let me know!\n\nHere is the pseudo code the book gives for merge sort.\n\n\n\n\nAnd, here is how I coded it in Java:\n\n```\npublic void mergeSort(int[] arrNums, int p, int r) {\n    if (p < r) {\n        int q = (p + r) / 2;\n        mergeSort(arrNums, p, q);\n        mergeSort(arrNums, q + 1, r);\n        merge(arrNums, p, q, r);\n    }\n}\n\npublic void merge(int[] arrNums, int p, int q, int r) {\n    int nOne = q - p + 1;\n    int nTwo = r - q;\n\n    int[] arrLeft = new int[nOne + 1];\n    int[] arrRight = new int[nTwo + 1];\n\n    for (int i = 0; i < nOne; i++) {\n        arrLeft[i] = arrNums[p + i - 1];\n    }\n\n    for (int j = 0; j < nTwo; j++) {\n        arrRight[j] = arrNums[q + j];\n    }\n\n    arrLeft[nOne] = Integer.MAX_VALUE;\n    arrRight[nTwo] = Integer.MAX_VALUE;\n\n    // Tracks arrLeft index\n    int i = 0;\n\n    // Tracks arrRight index\n    int j = 0;\n\n    for (int k = p; k < r; k++) {\n        if (arrLeft[i] <= arrRight[j]) {\n            arrNums[k] = arrLeft[i];\n            i++;\n        } else {\n            arrNums[k] = arrRight[j];\n            j++;\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nThe last ```\nfor```\n loop in your ```\nmerge```\n method, variable ```\nk```\n should start from ```\np - 1```\n:\n\n```\nfor (int k = p - 1; k < r; k++) {\n    if (arrLeft[i] <= arrRight[j]) {\n        arrNums[k] = arrLeft[i];\n        i++;\n    } else {\n        arrNums[k] = arrRight[j];\n        j++;\n    }\n}\n```\n\n\nPseudo code in many text books likes to start array index from ```\n1```\n, so here you need to subtract it by 1. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Pipeline merge sort in Java [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI google this topic so I found some stuff : \n\n```\nConsider a pipeline of sorters S0 to Sm.\n\nS0 has one input stream (the input sequence), and two output streams.\nSi (i = 1 to m-1) has two input streams and two output streams. The\noutput streams of Si are the input streams of Si+1, for i = 0 to m-1.\nSm has two input streams and one output stream.\n\nS0 reads the input stream, creates \"sorted\" sub-sequences of size one\nand sends these intermittently to one of its two output streams.\n\nSi repeatedly reads two sorted sub-sequences, one from each input\nstream, merges them, and writes the double sized sorted sub-sequences\nintermittently two one of its output streams.\n\nSm reads two sorted sub-sequences, one from each input stream, merges\nthese and produces the resulting output sequence.\n\nHere is an example for a sequence of 8 numbers, where a bar | delimits\nsorted sub sequences  \n\n                  2 | 1 | 6 | 8  3 1 | 8 4  8 6 5 4 \n7 2 3 1 5 6 4 8   ------------>  -------->  ------>   8 7 6 5 4 3 2 1\n--------------> S0             S1         S2       S3 -------------->\n                  ------------>  -------->  ------>\n                  7 | 3 | 5 | 4  7 2 | 6 5  7 3 2 1 \n```\n\n\nI need some pseudo code of merge sort in pipeline pattern. \n    ", "Answer": "\r\nThis looks to be a variantion of a Bottom-Up Mergesort (and here and lecture notes here) that uses \"streams\":\n\n\n  Bottom-up merge sort is a non-recursive variant of the merge sort, in which the array is sorted by a sequence of passes. During each pass, the array is divided into blocks of size m (Initially, m=1). Every two adjacent blocks are merged (as in normal merge sort), and the next pass is made with a twice larger value of m. \n\n\nIn the Pipeline Mergesort each sorter represents a pass as it combines adjacent blocks. However, unlike the more traditional Bottom-Up Mergesort, the adjacent blocks are the matched pairs read from both input streams (instead of being adjacent within the same stream/array).\n\nIn any case, try something first -- SO is a place to ask practical questions, not post tasks :)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort - Vector subscript out of range\r\n                \r\nI'm trying to get a merge sort program working, along with a radix sort which is already working, using vectors.\n\nHowever, the merge sort always gives me the \"Vector subscript out of range\" error. I know why this error appears, but I can't figure out what change I should make to stop it.\n\nCode:\n\n```\n#include \"Includes.h\"\n\nclass Mergesort\n{\npublic:\n\nstd::vector<int> mergeSort(std::vector<int> list, int low, int high, int max)\n{\n    int mid;\n\n    if (low < high) // Does not continue to merge sort when low is less than high.\n    { // This will be when the given set is a single number.\n        mid = low + (high - low) / 2;\n        list = mergeSort(list, low, mid, max); // Split the given set into two halves down the middle.\n        list = mergeSort(list, mid + 1, high, max);\n        list = merge(list, low, mid, high, max);\n    }\n\n    return list;\n}\n\nstd::vector<int> merge(std::vector<int> list, int low, int mid, int high, int max) // Call requires the bottom, middle and top numbers of the set.\n{\n    int h, i, j, k;\n    std::vector<int> listb(max); // Merged list.\n    h = low - 1;\n    i = low - 1;\n    j = mid;\n\n    while ((h <= mid) && (j <= high))\n    {\n        if (list[h] <= list[j]) // If the low part of the array is less than the upper middle of the array,\n        {\n            listb[i] = list[h]; // The next number in the merged array becomes h (initially low part).\n            h++; // Increment h to the next part of the array\n        }\n        else // Otherwise,\n        {\n            listb[i] = list[j]; // The next number in the merged array becomes j (initially upper middle).\n            j++; // Increment j to the next part of the array.\n        }\n        i++; // Always increment i, the position of the merged array. Starts at the bottom of the array.\n    } // End of while loop\n\n    if (h > mid) // If h - the progress from the bottom of the array - is beyond the middle.\n    {\n        for (k = j; k <= high; k++) // Loop until k is out of the array's range.\n        {\n            listb[i] = list[k]; // Set the next element in the merged array to the k element in the unmerged.\n            i++; // I.e. this starts from the middle, goes to the top of the array copying it into the merged one.\n        }\n    }\n    else // Otherwise, progress has not reached the the j value\n    {\n        for (k = h; k <= mid; k++) // K will start from h instead\n        {\n            listb[i] = list[k];\n            i++;\n        }\n    }\n    // Then,\n    for (k = low; k <= high; k++) // Loop through the entire original array, copying the merged array into it.\n    {\n        list[k] = listb[k];\n    }\n\n    return list;\n}\n};\n```\n\n\nAnd the main:\n\n```\n#include \"Mergesort.h\"\n#include \"Radixsort.h\"\n\n// Import things we need from the standard library\nusing std::chrono::duration_cast;\nusing std::chrono::milliseconds;\nusing std::cout;\nusing std::endl;\nusing std::this_thread::sleep_for;\n\n// Define the alias \"the_clock\" for the clock type we're going to use.\n// (You can change this to make the code below use a different clock.)\ntypedef std::chrono::steady_clock the_clock;\n\nusing namespace std;\n\nMergesort mergeSorter;\nRadixsort radixSorter;\n\nvoid main()\n{\nint num, i = 0, j = 0, k = 0;\nint inputNumber = 0;\n\ncout << \"Please input the size of the list to sort, then press enter:\" << endl;\ncin >> num;\n\nvector<int> intList(num);\n\ncout << endl << \"Please enter a 1 for manual input or 2 for random generation between 0 and 99, then press enter:\" << endl;\nwhile (j != 1 && j != 2)\n{\n    cin >> j;\n    if (j != 1 && j != 2)\n    {\n        cout << \"Please enter 1 or 2.\" << endl;\n    }\n    else\n    {\n        cout << endl;\n    }\n}\nif (j == 1)\n{\n    cout << \"Now, Please enter the \" << num << \" numbers, pressing enter between each:\" << endl;\n    for (i = 0; i < num; i++)\n    {\n        cin >> inputNumber;\n        intList[i] = (inputNumber);\n    }\n}\nelse if (j == 2)\n{\n    for (i = 0; i < num; i++)\n    {\n        inputNumber = rand() % 100;\n        intList[i] = (inputNumber);\n    }\n    cout << \"The list generated is: \";\n    for (std::vector<int>::iterator it = intList.begin(); it != intList.end(); it++) // Loops through the list, printing it out.\n    {\n        cout << *it << \" \";\n    }\n    cout << endl << endl;\n}\n\ncout << endl << \"Now, Please enter a 1 for merge sort or 2 for radix sort, then press enter:\" << endl;\nwhile (k != 1 && k != 2)\n    {\n        cin >> k;\n        if (k != 1 && k != 2)\n        {\n            cout << \"Please enter 1 or 2.\" << endl;\n        }\n    }\n\nif (k == 1)\n{\n    intList = mergeSorter.mergeSort(intList, 1, num, num);\n    cout << endl << \"So, the sorted list using merge sort will be:\";\n}\nelse if (k == 2)\n{\n    intList = radixSorter.radixSort(intList, num);\n    cout << endl << \"So, the sorted list using radix sort will be:\";\n}\ncout << endl << endl;\n\nfor (std::vector<int>::iterator it = intList.begin(); it != intList.end(); it++) // Loops through the list, printing it out.\n{\n    cout << *it << \" \";\n}\ncout << endl << endl;\n}\n```\n\n    ", "Answer": "\r\nThe parameter max is never used. Normally the right index for mergesort is the ending index (one more than the last index in the vector). In merge(), setting h and i to low-1 will cause the out of range problem, set them both to low, not low -1. Since the merge copies back to list, then mergesort and merge should be void functions using reference for parameters:\n\n```\nvoid mergeSort(std::vector<int> &list, int low, int high)\n\nvoid merge(std::vector<int> &list, int low, int mid, int high)\n```\n\n\nThe main code in mergesort should be:\n\n```\n    if ((high-low) > 1)   // nothing to do if 0 or 1 elements\n    { // This will be when the given set is a single number.\n        mid = low + (high - low) / 2;\n        mergeSort(list, low, mid);\n        mergeSort(list, mid, high);\n        merge(list, low, mid, high;\n```\n\n\nIn merge the early lines should be:\n\n```\n    h = low;\n    i = low;\n    j = mid;\n\n    while ((h < mid) && (j < high))    // change <= to <\n```\n\n\nThe other lines using <= should be changed to use <.\n\nThe initial call to merge sort should be:\n\n```\n    mergeSort(std::vector<int> list, 0, list.size());\n```\n\n\nYou may want to use size_t for indices instead of int.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "My merge sort is not ordering correctly\r\n                \r\nSo i've for a school project i've been assigned to implement a merge sort from a pseudo code given by the professor. This is what i came up with, in my use case, \ninstead of ordering:\n    0 1 4 5 9\nit orders it:\n    5 4 1 0 9\n\nMy use case: \n    5 9 1 0 5 4\n\nhere is the merge part of the merge sort and the global variables\n\n```\nlong long intercambio;\nint aux[5555], arr[555];\n\nvoid merge(int begin, int middle, int end) {\n    int i = begin, j = middle+1, k = begin, temp;\n    while (i <= middle && j <= end) {\n        if (arr[i] < arr[j]) {\n            aux[k] = arr[i];\n            i++;\n        }\n        else {\n            aux[k] = arr[j];\n            j++;\n        }\n        k++;\n        noSwaps++;\n    }\n    if (i > middle) {\n        while (j <= end) {\n            if (aux[k -1] > arr[j]) {\n                temp = aux[k - 1];\n                aux[k - 1] = arr[j];\n                aux[k] = temp;\n                noSwaps++;\n            }\n            else {\n                aux[k] = arr[j];\n            }\n            k++;\n            j++;\n        }\n    }\n    else {\n        while (i <= middle) {\n            if (aux[k -1] > arr[i]) {\n                temp = aux[k - 1];\n                aux[k - 1] = arr[i];\n                aux[k] = temp;\n                noSwaps++;\n            }\n            else {\n                aux[k] = arr[i];\n            }\n            k++;\n            i++;\n        }\n    }\n}\n```\n\n\nHere i call recursively the merge sort\n\n```\nvoid mergeSort(int begin, int end) {\n    if (begin < end) {\n        int middle = (begin + end) / 2;\n        mergeSort(begin, middle);\n        mergeSort(middle + 1, end);\n        merge(begin, middle, end);\n    }\n}\n```\n\n\nThis is the main class\n\n```\nint main(int argc, const char * argv[])\n    {\n        int len;\n\n        cin >> len;\n        while (len != 0) {\n\n            for (int x = 0; x < len; x++)\n                cin >> arr[x];\n\n            noSwaps = 0;\n\n            mergeSort(0, len - 1);\n            for (int x = 0; x < len; x++)\n                cout << aux[x] << \" \";\n            cout << endl;\n\n            cout << noSwaps << endl;\n\n            cin >> len;\n        }\n\n        return 0;\n    }\n```\n\n    ", "Answer": "\r\nI don't see why your code inside the ```\nif (i > middle)```\n block and its ```\nelse```\n block are so complicated. All you have to do is copy the remaining elements into ```\naux```\n, and then from ```\naux```\n back to ```\narr```\n:\n\n```\nvoid merge(int begin, int middle, int end) {\n    int i = begin, j = middle+1, k = begin, temp;\n    while (i <= middle && j <= end) {\n        // ... same as before ...\n    }\n    while (i <= middle)\n    {\n        aux[k++] = arr[i++];\n    }\n    while (j <= end)\n    {\n        aux[k++] = arr[j++];\n    }\n    for (i = begin; i <= end; ++i)\n    {\n        arr[i] = aux[i];\n    }\n}\n```\n\n\nThis may or may not be less (or more) efficient than your solution, but at least it works :)\n\nBy the way, there is a cute trick to implementing merge sort where you don't have to worry about exhausting one range before the other. You copy the left range to ```\naux```\n in ascending order, and the right range in descending order. Then you start merging from both ends, and when the indexes meet, both ranges are exhausted:\n\n```\nvoid merge(int begin, int middle, int end)\n{\n    int i, j, k;\n    for (i = begin; i <= middle; ++i)\n    {\n        aux[i] = arr[i];\n    }\n    for (j = end; j > middle; --j, ++i)\n    {\n        aux[i] = arr[j];\n    }\n    i = begin;\n    j = end;\n    k = begin;\n    while (i <= j)\n    {\n        arr[k++] = aux[(aux[i] < aux[j]) ? i++ : j--];\n    }\n}\n```\n\n\nThis solution appears to produce the wrong output, but only because there is a bug inside ```\nmain```\n:\n\n```\nfor (int x = 0; x < len; x++)\n    cout << aux[x] << \" \";\n```\n\n\nYou are printing ```\naux```\n, when in fact you should be printing ```\narr```\n:\n\n```\nfor (int x = 0; x < len; x++)\n    cout << arr[x] << \" \";\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Optimized merge sort faster than quicksort\r\n                \r\nhttp://jsperf.com/optimized-mergesort-versus-quicksort\nWhy does this half buffer merge sort work as fast as quicksort?\nQuickSort is:\n\nIn-Place although it takes up ```\nlog(n)```\n recursions (stack space)\nCache-Friendly\n\nThis half buffer merge sort:\n\nUses an ```\nn/2```\n Buffer to do merges.\nUses ```\nlog(n)```\n recursions.\nMakes fewer comparisons.\n\nMy question is, why is the half buffer merge sort matching the speed of QuickSort in this scenario?\nPlus, is there anything I'm doing wrong to the quickSort that makes it slower?\n```\nfunction partition(a, i, j) {\n    var p = i + Math.floor((j - i) / 2);\n    var left = i + 1;\n    var right = j;\n    swap(a, i, p);\n    var pivot = a[i];\n    while (left <= right) {\n        while (builtinLessThan(a[left], pivot)) {\n            ++left;\n        }\n        while (builtinLessThan(pivot, a[right])) {\n            --right;\n        }\n        if (left <= right) {\n            swap(a, left, right);\n            ++left;\n            --right;\n        }\n    }\n    swap(a, i, right);\n    return right;\n};\n\nfunction quickSort(a, i, j) {\n    var p = partition(a, i, j);\n    if ((p) - i > j - p) {\n        if (i < p - 1) {\n            quickSort(a, i, p - 1);\n        }\n        if (p + 1 < j) {\n            quickSort(a, p + 1, j);\n        }\n    } else {\n        if (p + 1 < j) {\n            quickSort(a, p + 1, j);\n        } if (i < p - 1) {\n            quickSort(a, i, p - 1);\n        }\n    }\n};\n```\n\n    ", "Answer": "\r\nMerge sort does fewer compares, but more moves than quick sort. Having to call a function to do the compares increases the overhead for compares, which  makes quick sort slower. All those if statements in the example quick sort is also slowing it down. If the compare and swap are done inline, then quick sort should be a bit faster if sorting an array of pseudo random integers. \n\nIf running on a processor with 16 registers, such a PC in 64 bit mode, then 4 way merge sort using a bunch of pointers that end up in registers is about as fast as quick sort. A 2 way merge sort averages 1 compare for each element moved, while a 4 way merge sort averages 3 compares for each element moved, but only takes 1/2 the number of passes, so the number of basic operations is the same, but the compares are a bit more cache friendly, making the 4 way merge sort about 15% faster, about the same as quick sort. \n\nI'm not familiar with java script, so I'm converting the examples to C++. \n\nUsing a converted version of the java script merge sort, it takes about 2.4 seconds to sort 16 million pseudo random 32 bit integers. The example quick sort shown below takes about 1.4 seconds, and the example bottom up merge shown below sort about 1.6 seconds. As mentioned, a 4 way merge using a bunch of pointers (or indices) on a processor with 16 registers would also take about 1.4 seconds.\n\nC++ quick sort example:\n\n```\nvoid QuickSort(int a[], int lo, int hi) {\n    int i = lo, j = hi;\n    int pivot = a[(lo + hi) / 2];\n    int t;\n    while (i <= j) {            // partition\n        while (a[i] < pivot)\n            i++;\n        while (a[j] > pivot)\n            j--;\n        if (i <= j) {\n            t = a[i]\n            a[i] = a[j];\n            a[j] = t;\n            i++;\n            j--;\n        }\n    }\n    if (lo < j)                 // recurse\n        QuickSort(a, lo, j);\n    if (i < hi)\n        QuickSort(a, i, hi);\n}\n```\n\n\nC++ bottom up merge sort example:\n\n```\nvoid BottomUpMergeSort(int a[], int b[], size_t n)\n{\nsize_t s = 1;                               // run size \n    if(GetPassCount(n) & 1){                // if odd number of passes\n        for(s = 1; s < n; s += 2)           // swap in place for 1st pass\n            if(a[s] < a[s-1])\n                std::swap(a[s], a[s-1]);\n        s = 2;\n    }\n    while(s < n){                           // while not done\n        size_t ee = 0;                      // reset end index\n        while(ee < n){                      // merge pairs of runs\n            size_t ll = ee;                 // ll = start of left  run\n            size_t rr = ll+s;               // rr = start of right run\n            if(rr >= n){                    // if only left run\n                rr = n;\n                BottomUpCopy(a, b, ll, rr); //   copy left run\n                break;                      //   end of pass\n            }\n            ee = rr+s;                      // ee = end of right run\n            if(ee > n)\n                ee = n;\n            BottomUpMerge(a, b, ll, rr, ee);\n        }\n        std::swap(a, b);                    // swap a and b\n        s <<= 1;                            // double the run size\n    }\n}\n\nvoid BottomUpMerge(int a[], int b[], size_t ll, size_t rr, size_t ee)\n{\n    size_t o = ll;                          // b[]       index\n    size_t l = ll;                          // a[] left  index\n    size_t r = rr;                          // a[] right index\n    while(1){                               // merge data\n        if(a[l] <= a[r]){                   // if a[l] <= a[r]\n            b[o++] = a[l++];                //   copy a[l]\n            if(l < rr)                      //   if not end of left run\n                continue;                   //     continue (back to while)\n            while(r < ee)                   //   else copy rest of right run\n                b[o++] = a[r++];\n            break;                          //     and return\n        } else {                            // else a[l] > a[r]\n            b[o++] = a[r++];                //   copy a[r]\n            if(r < ee)                      //   if not end of right run\n                continue;                   //     continue (back to while)\n            while(l < rr)                   //   else copy rest of left run\n                b[o++] = a[l++];\n            break;                          //     and return\n        }\n    }\n}\n\nvoid BottomUpCopy(int a[], int b[], size_t ll, size_t rr)\n{\n    while(ll < rr){                         // copy left run\n        b[ll] = a[ll];\n        ll++;\n    }\n}\n\nsize_t GetPassCount(size_t n)               // return # passes\n{\n    size_t i = 0;\n    for(size_t s = 1; s < n; s <<= 1)\n        i += 1;\n    return(i);\n}\n```\n\n\nC++ example of 4 way merge sort using pointers (goto's used to save code space, it's old code). It starts off doing 4 way merge, then when the end of a run is reached, it switches to 3 way merge, then 2 way merge, then a copy of what's left of the remaining run. This is similar to algorithms used for external sorts, but external sort logic is more generalized and often handles up to 16 way merges.\n\n```\nint * BottomUpMergeSort(int a[], int b[], size_t n)\n{\nint *p0r;       // ptr to      run 0\nint *p0e;       // ptr to end  run 0\nint *p1r;       // ptr to      run 1\nint *p1e;       // ptr to end  run 1\nint *p2r;       // ptr to      run 2\nint *p2e;       // ptr to end  run 2\nint *p3r;       // ptr to      run 3\nint *p3e;       // ptr to end  run 3\nint *pax;       // ptr to set of runs in a\nint *pbx;       // ptr for merged output to b\nsize_t rsz = 1; // run size\n    if(n < 2)\n        return a;\n    if(n == 2){\n        if(a[0] > a[1])std::swap(a[0],a[1]);\n        return a;\n    }\n    if(n == 3){\n        if(a[0] > a[2])std::swap(a[0],a[2]);\n        if(a[0] > a[1])std::swap(a[0],a[1]);\n        if(a[1] > a[2])std::swap(a[1],a[2]);\n        return a;\n    }\n    while(rsz < n){\n        pbx = &b[0];\n        pax = &a[0];\n        while(pax < &a[n]){\n            p0e = rsz + (p0r = pax);\n            if(p0e >= &a[n]){\n                p0e = &a[n];\n                goto cpy10;}\n            p1e = rsz + (p1r = p0e);\n            if(p1e >= &a[n]){\n                p1e = &a[n];\n                goto mrg201;}\n            p2e = rsz + (p2r = p1e);\n            if(p2e >= &a[n]){\n                p2e = &a[n];\n                goto mrg3012;}\n            p3e = rsz + (p3r = p2e);\n            if(p3e >= &a[n])\n                p3e = &a[n];\n            // 4 way merge\n            while(1){\n                if(*p0r <= *p1r){\n                    if(*p2r <= *p3r){\n                        if(*p0r <= *p2r){\nmrg40:                      *pbx++ = *p0r++;    // run 0 smallest\n                            if(p0r < p0e)       // if not end run continue\n                                continue;\n                            goto mrg3123;       // merge 1,2,3\n                        } else {\nmrg42:                      *pbx++ = *p2r++;    // run 2 smallest\n                            if(p2r < p2e)       // if not end run continue\n                                continue;\n                            goto mrg3013;       // merge 0,1,3\n                        }\n                    } else {\n                        if(*p0r <= *p3r){\n                            goto mrg40;         // run 0 smallext\n                        } else {\nmrg43:                      *pbx++ = *p3r++;    // run 3 smallest\n                            if(p3r < p3e)       // if not end run continue\n                                continue;\n                            goto mrg3012;       // merge 0,1,2\n                        }\n                    }\n                } else {\n                    if(*p2r <= *p3r){\n                        if(*p1r <= *p2r){\nmrg41:                      *pbx++ = *p1r++;    // run 1 smallest\n                            if(p1r < p1e)       // if not end run continue\n                                continue;\n                            goto mrg3023;       // merge 0,2,3\n                        } else {\n                            goto mrg42;         // run 2 smallest\n                        }\n                    } else {\n                        if(*p1r <= *p3r){\n                            goto mrg41;         // run 1 smallest\n                        } else {\n                            goto mrg43;         // run 3 smallest\n                        }\n                    }\n                }\n            }\n            // 3 way merge\nmrg3123:    p0r = p1r;\n            p0e = p1e;\nmrg3023:    p1r = p2r;\n            p1e = p2e;\nmrg3013:    p2r = p3r;\n            p2e = p3e;\nmrg3012:    while(1){\n                if(*p0r <= *p1r){\n                    if(*p0r <= *p2r){\n                        *pbx++ = *p0r++;        // run 0 smallest\n                        if(p0r < p0e)           // if not end run continue\n                            continue;\n                        goto mrg212;            // merge 1,2\n                    } else {\nmrg32:                  *pbx++ = *p2r++;        // run 2 smallest\n                        if(p2r < p2e)           // if not end run continue\n                            continue;\n                        goto mrg201;            // merge 0,1\n                    }\n                } else {\n                    if(*p1r <= *p2r){\n                        *pbx++ = *p1r++;        // run 1 smallest\n                        if(p1r < p1e)           // if not end run continue\n                            continue;\n                        goto mrg202;            // merge 0,2\n                    } else {\n                        goto mrg32;             // run 2 smallest\n                    }\n                }\n            }\n            // 2 way merge\nmrg212:     p0r = p1r;\n            p0e = p1e;\nmrg202:     p1r = p2r;\n            p1e = p2e;\nmrg201:     while(1){\n                if(*p0r <= *p1r){\n                    *pbx++ = *p0r++;            // run 0 smallest\n                    if(p0r < p0e)               // if not end run continue\n                        continue;\n                    goto cpy11;\n                } else {\n                    *pbx++ = *p1r++;            // run 1 smallest\n                    if(p1r < p1e)               // if not end run continue\n                        continue;\n                    goto cpy10;\n                }\n            }\n            // 1 way copy\ncpy11:      p0r = p1r;\n            p0e = p1e;\ncpy10:      while (1) {\n                *pbx++ = *p0r++;                // copy element\n                if (p0r < p0e)                  // if not end of run continue\n                    continue;\n                break;\n            }\n            pax += rsz << 2;            // setup for next set of runs\n        }\n        std::swap(a, b);                // swap ptrs\n        rsz <<= 2;                      // quadruple run size\n    }\n    return a;                           // return sorted array\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort: Segmentation error Core Dumped\r\n                \r\nI read the theory of merge sort algorithm and based on that i wrote an implementation of merge sort in C++ using the STL Vector class.\n\nI know that a copy paste from any one of the trillion articles on internet about merge sort can solve this, but I wanted to try this one on my own.\n\nWhen I run the code i get segmentation fault core dumped error, which is caused by the recursive functions not terminating.\nCan anybody help me find the error in the code.\n\n```\n#include<iostream>\n#include<vector>\nvoid merge(std::vector<int>& arr,int last,int begin,int mid);\nvoid mergeSort(std::vector<int>& arr,int begin, int last){ \n    std::cout<<\"In merge sort\";\n    int mid; \n    if(begin<last){\n      mid = (begin+last)/2;\n      mergeSort(arr,begin,mid);\n      mergeSort(arr,mid,last);\n      merge(arr,last,begin,mid);\n    } \n    return;\n}\nvoid merge(std::vector<int>& arr ,int last,int begin,int mid){\n    if(last==begin){\n        std::cout<<\"Returned form finger\";\n        return; \n    }\n    int b=begin,c=mid;\n    std::vector<int> temp;\n    while(b<mid&&c<last){\n        if(arr[b]<arr[c]){\n            temp.push_back(arr[b]);\n            b++;\n        }\n        else{\n            temp.push_back(arr[c]);\n            c++;\n        }\n    }\n    while(b<mid){temp.push_back(arr[b]);}\n    while(c<last){temp.push_back(arr[c]);}\n    arr.swap(temp);\n    return;\n}\n\n\nint main(){\n    std::vector<int> arr({2,4,1,5,3,6,2,4,3});   \n    for(auto it=arr.begin();it!=arr.end();++it){\n        std::cout<<*it<<' '; \n    }\n    std::cout<<'\\n';\n   mergeSort(arr,0,8);\n    for(auto it=arr.begin();it!=arr.end();++it){\n        std::cout<<*it<<' '; \n    }\n    return 0;\n    }\n```\n\n\nI use gcc version 9.3.0 to compile the code using the terminal command\n\n```\n$ gcc filename.cpp -lstdc++\n```\n\n\nAfter analyzing the code i think the problem is in the merge function but i cant point out where it is. It would be helpful if anybody could help me and if possible suggest a few ways to optimize my code.\n    ", "Answer": "\r\nSo your recursion is wrong. In ```\nmain```\n you have a vector of nine elements.\n\n```\nstd::vector<int> arr({2,4,1,5,3,6,2,4,3});\n```\n\n\nand you call ```\nmergeSort```\n like this\n\n```\nmergeSort(arr,0,8);\n```\n\n\nSo the third parameter to ```\nmergeSort```\n is the last valid index of the vector you are sorting (it would have been better to use ```\narr.size() - 1```\n). Put another way mergeSort is sorting the inclusive range (0, 8).\n\nNow in ```\nmerge_sort```\n you have this\n\n```\nvoid mergeSort(std::vector<int>& arr,int begin, int last) { \n    ...\n    mergeSort(arr,begin,mid);\n    mergeSort(arr,mid,last);\n    ...\n}\n```\n\n\nRecall merge sort is sorting the inclusive range (begin, last). So your recursion is going to sort the two inclusive ranges (begin,mid) and (mid,last). In other words ```\nmid```\n is being included twice.\n\nSince (very admirably) you want to program this for yourself, I'll leave you to figure out the fix.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementing External Merge Sort\r\n                \r\nI am aware of External merge sort and how it works.\nBut currently i'm stuck while implementing it. I've written code to sort and merge the arrays but I'm facing problem while reading and writing the data from/into the file, i want to implement the following methods in C++:\n\n```\n1. int * read(int s, int e) : This method should read from file all the number \nstarting from 's' till 'e' and return the array\n2. write(int a[], int s, int e) : This method should write to file the input \narray by replacing the numbers from s to e.\n```\n\n\nFor eg. \n\n```\nGiven file has the following numbers:\n\n1\n2\n3\n4\n5\n6\n\nread(0, 2) should return [1,2,3]\nwrite([4,5,6], 0, 2) should update the file to :\n4\n5\n6\n4\n5\n6\n```\n\n\nHow can I implement both these methods?\n    ", "Answer": "\r\nThe first thing you should do is stop working with raw pointers.\n\n```\nstd::vector<int>```\n will be just as efficient, and far less bug prone.\n\nSecond, the file format matters.  I will assume a binary file with packed 32 bit signed integers.\n\nThe signature for read and write is now:\n\n```\nstd::vector<int> read( std::ifstream const& f, int offset );\nvoid write( std::ofstream& f, int offset, std::vector<int> const& data );\n```\n\n\n```\nifstream```\n and ```\nofstream```\n have seek methods -- in particular, ```\nifstream```\n has ```\nseekg```\n and ```\nofstream```\n has ```\nseekp```\n.\n\n```\nifstream.read( char* , length )```\n reads ```\nlength```\n bytes from the file at the current get position (set by ```\nseekg```\n, and advanced by ```\nread```\n).  If you aren't concerned with memory layout of your file, you can get the ```\n.data()```\n from the ```\nstd::vector<int>```\n, reinterpret it to a ```\nchar*```\n, and proceed to ```\nread( reinterpret_cast<char*>(vec.data()), sizeof(int)*vec.size() )```\n to read in the buffer all at once.\n\n```\nofstream```\n has a similar ```\nwrite```\n method which works much the same way.\n\nWhile writing data rawly to disk and back is dangerous, in most (every?) implementation you'll be safe with data written and read in the same execution session (and probably even between sessions).  Take more care if the data is meant to persist between sessions, or if it is output/input from your code.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why is Merge Sort in Java getting faster on same Array\r\n                \r\nI have implemented merge sort in Java. Instance of the class is named ms. rArray is a random integer array. For testing i ran it with the following code:\n\n```\nfor (int i=0; i<10; i++) {\n        System.out.println(\"Starting Merge Sort\");\n        testArray = rArray; // Create duplicate for testing\n        long startM = System.currentTimeMillis();\n        ms.sort(testArray);\n        long stopM = System.currentTimeMillis();\n        long durationM = stopM-startM;\n        System.out.println(\"Size: \" + size + \"; Duration: \" + durationM + \"ms\");\n        System.out.println(\"++++++++++++++++++++++++++++++++++++++++++\");\n    }\n```\n\n\nOutput:\n\n```\nStarting Merge Sort\nSize: 1000000; Duration: 5853ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 4527ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 4082ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3000ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 2930ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 2904ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3403ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3570ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 2930ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3133ms\n```\n\n\nIt is the same pattern for every run. \nWhy is it always speeding up? I guess it has to do with the compiler, since ```\nArrays.sort```\n shows the same behaviour. What i don't understand is, if i first run ```\nArrays.sort```\n and then my implementation of merge sort, why is the latter still faster compared to if i run my implementation of merge sort on it's own?\n\nUpdate\n\nAfter using ```\nSystem.arraycopy(rArray, 0, testArray, 0, rArray.length);```\n as suggested by Makoto (Thanks!), the output is getting better. But as for Merge sort it remains the same. My implementation of merge sort is not saving the sorting result. So is the reason for this speedup the JIT Warmup?\n\nNew Output:\n\n```\nStarting Default Sort\nSize: 1000000; Duration: 1799ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Default Sort\nSize: 1000000; Duration: 1816ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Default Sort\nSize: 1000000; Duration: 945ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Default Sort\nSize: 1000000; Duration: 944ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Default Sort\nSize: 1000000; Duration: 944ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Default Sort\nSize: 1000000; Duration: 943ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Default Sort\nSize: 1000000; Duration: 957ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Default Sort\nSize: 1000000; Duration: 963ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Default Sort\nSize: 1000000; Duration: 964ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Default Sort\nSize: 1000000; Duration: 952ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 5913ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3171ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3093ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 4816ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3685ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3094ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3488ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3660ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3094ms\n++++++++++++++++++++++++++++++++++++++++++\nStarting Merge Sort\nSize: 1000000; Duration: 3604ms\n```\n\n    ", "Answer": "\r\ntestArray = rArray. This will not create a duplicate. It just creates a new reference to the rArray. So, you are sorting already sorted array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort in Ruby\r\n                \r\nCan anybody please tell what am I doing wrong in my Merge-Sort\n\n```\ndef print_array(a)\n  print a\n  print \"\\n\\n\"\nend\n\n#Merge-Sort code starts Here.\ndef merge_sort(a)\n  if a.size < 2\n    return a\n  end\n\n  middle = (a.length / 2).to_i\n  left = a.slice(0, middle)\n  right = a.slice(middle, a.size)\n\n  merge_sort(left)\n  merge_sort(right)\n\n  a = merge(left, right)\nend\n\ndef merge(left, right) \n  result = []\n\n  while left.length > 0 || right.length > 0\n    if left.length > 0 && right.length > 0\n      if left[0] <= right[0]\n        result << left.slice!(0)\n      else\n        result << right.slice!(0)\n      end\n    elsif left.length > 0\n      result.concat left.slice!(0..left.length-1)\n    elsif right.length > 0\n      result.concat right.slice!(0..right.length-1)\n    end\n  end\n\n  result  \nend\n\na = [ 3, 2, 1 ]\nprint_array(a)\n\na = merge_sort(a)\nprint_array(a)\n```\n\n\nBasically, What I know is that when it comes time to Merge [2] and [1], that happens correctly (ie. [1, 2] is returned) , but for the previous step of the Recursion as it unwinds, it comes back (or doesn't come back) as [1, 2] but as [2, 1], ie.\n\nPrevious step\n-> left = [3]\n-> right = [2, 1] #This is the value of right from recursion instead of [1, 2]\n\nI don't know how to fix this, and it's driving me crazy, Can you please help me?\n    ", "Answer": "\r\nThese two lines:\n\n```\nmerge_sort(left) \nmerge_sort(right)\n```\n\n\nshould be:\n\n```\nleft = merge_sort(left) \nright = merge_sort(right)\n```\n\n\nSince your merge sort is not sorting in place, you need to assign the result back to the variables.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java & Merge Sort\r\n                \r\nWhy Java impl choose merge sort over quick sort? and why do they copy the content to an array?\n\nAPI: \"The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n log(n) performance. This implementation dumps the specified list into an array, sorts the array, and iterates over the list resetting each element from the corresponding position in the array. This avoids the n2 log(n) performance that would result from attempting to sort a linked list in place.\"\n    ", "Answer": "\r\nJava guys traded the worst-case scenario with the avg case, as you probably know, quick sort might run in O(n^2) in the worst case..\n\nYou can read in the API, sorting a linked list in-place is more complex n^2log(n)\n\nMerge sort is stable which the isn't true for the efficient version of quicksort.\n(which can be highly important upon sorting objects + many programmers take that as granted when they use Collections.sort())\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "multithreading and merge sort, 3 threads for sort and merging\r\n                \r\nthis question been asked a few times but cannot find anything specific, the topic is I'm trying to perform a merge sort using 2 threads for sorting each sub list, each thread taking a half, and a third thread to merge the two lists afterwards,\nbut I'm having difficulty, understanding the merge sort, (first time trying to write a sort algorithm in\nc)\ni know i need to lets say take \"apart\" the merge sort and perform only each half in two separate functions, that I can pass into the thread, then perform the final merging process, but lets say I have lists\n```\nlist1 11 22 1 6 9\nlist2 99 33 4 5 7\n```\n\nI know I could write a simple sort algorithm to put each in order, but the merging process is throwing me for a loop soheres what im thinking or visualizing the error, and what i am lost on, say i sort the two lists with their different thread functions\n```\nlist1 1 6 9 11 22\nlist2 4 5 7 33 99\n```\n\nI keep thinking this will be the result if I go ahead and merge them at this stage\n```\n1 6 9 11 22 4 5 7 33 99\n```\n\nthat isn't exactly in order is it?\nand if I sort them in the final merger using a sort, I mean what was the point of sorting them initially? that kind of just makes the point of sorting them in the two subthreads pointess, when my goal is to use the 2 threads and 2 threads only,  then use the final thread to merge like a merge sort would sort each array\ncan anyone help me visualize this better, either with code, or pseudocode?, assume that in my code I already have the array split and ready to be passed into the functions in my main(void) function, with pointers named first_half, second_half, the starter array is constructed, by taking a user input and passing that into a malloc function, and filled using random limited to 0-99\n    ", "Answer": "\r\nThe way merge sort is working is by comparing the sorted element of each list together, it does not concatenate one array after another, see example code below (singlethreaded):\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define _DEBUG 1\n\nvoid insertion_sort(int n, int a[n])\n{\n    int i, tmp, j;\n    for (i = 1; i < n; i++) {\n        tmp = a[i];\n        j = i - 1;\n        while (j >= 0 && a[j] > tmp) {\n            a[j + 1] = a[j];\n            --j;\n        }\n        a[j + 1] = tmp;\n    }\n    #ifdef _DEBUG\n        for (int i = 0; i < n; i++)\n            printf(\"%d \", a[i]);\n        putchar('\\n');\n    #endif\n}\n\nvoid merge_sort(int n, int a[n], int x, int b[x], int y, int c[y])\n{\n    for (int i = 0; i < x; i++) // split values of a into two arrays\n        b[i] = a[i];\n    for (int i = 0; i < y; i++)\n        c[i] = a[i+x];\n    insertion_sort(x, b); // sort each of the sub arrays, you multithread this part.\n    insertion_sort(y, c);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < n) {\n        if (b[j] < c[k]) // you add to a the smallest between b and c.\n            a[i++] = b[j++];\n        else\n            a[i++] = c[k++];\n        if (x == j) { // if all the elements of b have filled a:\n            do {\n                a[i++] = c[k++]; // we proceed to fill a with c\n            } while (y != k);\n            break ; // the merge sorting is completed.\n        }\n        else if (y == k) {\n            do {\n                a[i++] = b[j++];\n            } while (x != j);\n            break ;\n        }\n    }\n    #ifdef _DEBUG\n        for (int i = 0; i < n; i++)\n            printf(\"%d \", a[i]);\n        putchar('\\n');\n    #endif\n}\n\n\n int main(void) {\n    srand ( time(NULL) );\n    const int n = 100;\n    int a[n];\n    int b[n/2];\n    int c[(n+1)/2];\n\n    for (int i = 0; i < n; i++) // initialize with random values\n        a[i] = rand() % 1000;\n\n    merge_sort(n, a, n/2, b, (n+1)/2, c);\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort with Java Futures\r\n                \r\nI am trying to write a merge sort algorithm that uses java futures. The current program I have using futures is slower then a standard merge sort algorithm. I would prefer to use java futures over fork join as I am currently learning about java futures. I am trying to work in parallel streams and was advice it was best to have half the work in the future and half the work in the main thread.\n```\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\npublic class MParallelSorter1 implements Sorter {\n    \n    private static final ExecutorService pool = Executors.newFixedThreadPool(10);\n    private MSequentialSorter s = new MSequentialSorter();\n\n  @Override\n  public <T extends Comparable<? super T>> List<T> sort(List<T> list) {\n      \n      if(list.size() < 2){\n          \n          return list;\n      }else {\n      int mid = list.size()/2;\n      Future<List<T>> left = pool.submit(()->sort(list.subList(0, mid)));\n      List<T> right = sort(list.subList(mid, list.size()));\n      \n      return mergeSort(get(left), right);\n          \n      }\n    }\n  \n\n  public <T extends Comparable<? super T>> List<T> mergeSort(List<T> left, List<T> right) {\n        int i = 0, j = 0, k = 0;\n        List<T> toReturn = new ArrayList<>();\n            \n  \n      while (i < left.size() && j < right.size()) {\n            if (left.get(i).compareTo(right.get(j)) < 0)  {\n                toReturn.add(k, left.get(i));\n                i++;\n            } else {\n                toReturn.add(k, right.get(j));\n                j++;\n            }\n            k++;\n        }\n\n        while (i < left.size()) {\n            toReturn.add(k, left.get(i));\n            i++;\n            k++;\n        }\n\n        while (j < right.size()) {\n            toReturn.add(k, right.get(j));\n            j++;\n            k++;\n        }\n  \n        \n    return toReturn;   \n}\n\n\n  public static <T> T get (Future<T> f) {\n      try {\n          return f.get();\n      }\n      catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new Error(e);\n    }\n    catch (ExecutionException e) {\n        Throwable t = e.getCause();\n        if(t instanceof RuntimeException rt) {\n            throw rt;\n        }\n        if(t instanceof Error et) {\n            throw et;\n        }\n        throw new Error(\"Unexpected Checked Exception\", t);\n    }\n    \n  }\n}```\n```\n\n    ", "Answer": "\r\nHave you tried changing Executors.newFixedThreadPool(10) to Executors.newWorkStealingPool()?\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort function (natural merge sort)\r\n                \r\nThere are a few ways to do a merge sort, but I specifically need it to work like a natural merge sort. What happens in this algorithm is that smaller lists of numbers are generated in the file like so:\n\nOriginal List: 35 27 24 28 31 37 1 4 7 6 8 9\n\nSmaller List sections: [35], [27], [24, 28], [31, 37], [1, 4, 7], [6, 8, 9]\n\nAs you notice, everytime the unsorted list comes across a number that's smaller than it's present value, a new unit is created. Once the list ends, this list breaks into two other lists like so in an alternative fashion:\n\nFirst list: [35], [24, 28], [1, 4, 7]\n\nSecond list: [27], [31, 37], [6, 8, 9]\n\nThe last step involves pulling the two lists together again, and the values are compared between the units in the first list item and the second list item as it traverses. For example, first unit in list one is compared with the first unit in list two and keeps the numbers in order. Any leftover units will be added on the end(Not shown).\n\nMerging two lists: [27, 35], [24, 28, 31, 37], [1, 4, 6, 7, 8, 9]\n\nThis process will repeat until the list is sorted in one unit.\n\nI have everything set up in this algorithm to work except for merging the two lists and it's extremely hard to debug or locate the problem. It gets about halfway through before it goes into a segmentation fault. Anyways, I can't use the mergesort STL on this program and it's all in a linked list.\n\nNote: The constructors and other necessary functions are already in place. I left out the other functions on purpose to empathize the specific function.\n\n```\nclass mergeList\n{\n   public:\n\n      //Setters\n      void setNumber(int item);\n      void setStart(bool newStatus);\n      void setEnd(bool newStatus);\n      void setPrev(mergeList* node);\n      void setNext(mergeList* node);\n\n      //Getters\n      int getNumber();\n      bool getStart();\n      bool getEnd();\n      mergeList* getPrev();\n      mergeList* getNext();\n\n   private:\n      int number;\n\n      bool startSection;\n      bool endSection;\n\n      mergeList* prev;\n      mergeList* next;\n};\n\nclass mergeListObject\n{\n   public:\n     mergeList* firstNode;\n     mergeList* lastNode;\n\n   void mergeLists(mergeListObject &firstList,\n                   mergeListObject &secondList);\n\n   //Other functions in program are in here.\n};\n\nvoid mergeListObject::mergeLists(mergeListObject &firstList,\n                                 mergeListObject &secondList)\n{\n   mergeList* combTraverse = firstNode;\n   mergeList* firstTraverse = firstList.firstNode;\n   mergeList* secondTraverse = secondList.firstNode;\n\n   bool listDone = false;\n\n   //This will clear the combination list for insertion\n   while (combTraverse != NULL)\n   {\n      combTraverse->setNumber(-1);\n      combTraverse->setStart(false);\n      combTraverse->setEnd(false);\n\n      combTraverse = combTraverse->getNext();\n   }\n\n   combTraverse = firstNode;\n\n   combTraverse->setStart(true);\n\n   while (listDone == false)\n   {\n      //This will go until the first list is traversed.\n      do\n      {\n         bool exception = false;\n\n         int j = firstTraverse->getNumber();\n         int k;\n\n         //If the second list is still active, this will\n         //grab its current value for comparison.\n         if (secondTraverse != NULL)\n            k = secondTraverse->getNumber();\n\n         //Second list is done, will automatically grab\n         //first list's value and traverse through to the end.\n         if (secondTraverse == NULL)\n            combTraverse->setNumber(firstTraverse->getNumber());\n\n         else\n         {\n            //Both values from both lists are compared.\n            if (j <= k)\n               combTraverse->setNumber(firstTraverse->getNumber());\n\n            else\n            {\n                exception = true;\n                combTraverse->setNumber(secondTraverse->getNumber());\n            }\n         }\n\n         //If the first value unit was used, move the first list iterator up.\n         //Otherwise, the second list's iterator moves up.\n         if (exception == false)\n            firstTraverse = firstTraverse->getNext();\n\n         else\n            secondTraverse = secondTraverse->getNext();\n\n         exception = false;\n      }\n      while (firstTraverse->getEnd() == false);\n\n      //If the second list isn't done, this will finish it.\n      do\n      {\n         combTraverse->setNumber(secondTraverse->getNumber());\n\n         secondTraverse = secondTraverse->getNext();\n         combTraverse = combTraverse->getNext();\n      }\n      while (secondTraverse->getEnd() == false);\n\n      combTraverse->setEnd(true);\n\n      //Marks the end of the section and sets the next one,\n      //considering it isn't the end of the list.\n      if (combTraverse->getNext() != NULL)\n         combTraverse->getNext()->setStart(true);\n\n      //Both of these should end up at the start of a unit in their own lists.\n      firstTraverse = firstTraverse->getNext();\n      secondTraverse = secondTraverse->getNext();\n\n      //Are both lists done?\n      if (firstTraverse == NULL &&\n          secondTraverse == NULL)\n         listDone = true;\n   }\n\n   return;\n}\n\nint main()\n{\n   mergeListObject one;\n   mergeListObject two;\n   mergeListObject combined;\n\n   //The two lists are already separated. All\n   //other functions have already been called.\n\n   combined.mergeLists(one, two);\n\n   return 0;\n} \n```\n\n    ", "Answer": "\r\nThe first bug I could spot was at the end of your merge function :\n\n```\nfirstTraverse = firstTraverse->getNext();\nsecondTraverse = secondTraverse->getNext();\n```\n\n\nmay generate runtime error (\"access violation\" or \"segmentation fault\" depending on compiler and OS) you have to change it to \n\n```\nif (firstTraverse)\n    firstTraverse = firstTraverse->getNext();\nif (secondTraverse)\n    secondTraverse = secondTraverse->getNext();\n```\n\n\nnote that those pointers can really be NULL.\n\nyou also have to change ```\nwhile (firstTraverse->getEnd() == false);```\n to ```\nwhile(firstTraverse & firstTraverse->getEnd() == false);```\n again ```\nfirstTravers```\n can be NULL as long as first list has lower number of partitions than second list. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort algorithm Infinite loop\r\n                \r\nI am trying to create a merge sort algorithm, but when I go to sort the broken down arrays, I enter an infinite loop, the main problem is happening in my merge method below. Thanks in advance for the help.\n\n```\npublic static void mergeSort(double[] arr)\n{\n    int count = n;\n    long startTime = System.currentTimeMillis();\n    int mid = arr.length;\n    if(arr.length > 1)\n    {\n        mid = arr.length/2;\n    }\n    else\n    {\n        return;\n    }\n\n    double[] a = new double[mid];\n    double[] b = new double[arr.length-mid];\n\n    for(int i = 0; i < a.length; i++)\n    {\n        a[i] = arr[i];\n        System.out.println(\"A = \" + a[i]);\n        count++;\n    }\n    for(int i = 0; i < b.length; i++)\n    {\n        b[i] = arr[i+mid];\n        System.out.println(\"B = \" + b[i]);\n        count++;\n    }\n\n    mergeSort(a);\n    mergeSort(b);\n    merge(arr, a, b);\n}\n\npublic static void merge(double[] arr, double[] a, double [] b)\n{\n    int elem = a.length + b.length;\n    int i,j,k;\n    i = j = k = 0;\n    while(i < elem )\n    {\n        if((j < a.length) && (k < b.length))\n        {\n            if(a[j] < b[k])\n            {\n                arr[i] = a[k];\n                i++;\n                j++;\n            }\n            else\n            {\n                arr[i] = b[k];\n                i++;\n                k++;\n            }\n        }\n        else\n        {\n            if(j >= a.length)\n            {\n                while(k < b.length)\n                {\n                    arr[i] = b[k];\n                    i++;\n                    k++;\n                }\n            }\n            if(k >= b.length)\n            {\n                while(j >= a.length)\n                {\n                    arr[i] = a[j];\n                    j++;\n                    i++;\n                }\n            }\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\n```\nwhile(j >= a.length)\n{\n    arr[i] = a[j];\n    j++;\n    i++;\n}\n```\n\n\nI wonder what happens here....\n\nwhile j>=a.length, do something, and make j bigger... when do you expect this to end?\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "StackOverFlowException on Merge Sort\r\n                \r\nSo, I am trying to do merge sorting, but I keep getting a ```\nStackOverFlowException```\n and I don't quite get what I'm doing wrong. Would this work code work well for merge sorting or would there be a better way to write the code?\n\n```\nstatic public List<string> MergeSort(List<string> list)\n        {\n            List<string> left = new List<string>();\n            List<string> right = new List<string>();\n\n            if (list.Count <= 1)\n            {\n                return list;\n            }\n\n            foreach (var item in list)\n            {\n                if (list.IndexOf(item) <= (list.Count / 2))\n                {\n                    left.Add(item);\n                }\n                else\n                    right.Add(item);\n            }\n            left = MergeSort(left);\n            right = MergeSort(right);\n            return Merge(left, right);\n        }\n        static public List<string> Merge(List<string> left, List<string> right)\n        {\n            List<string> merged = new List<string>();\n\n            while (left.Count != 0 && right.Count != 0)\n            {\n                if (left.First().Length <= right.First().Length)\n                {\n                    merged.Add(left.First());\n                    left.Remove(left.First());\n                }\n                else\n                {\n                    merged.Add(right.First());\n                    right.Remove(right.First());\n                }\n            }\n            while(left.Count != 0)\n            {\n                merged.Add(left.First());\n                left.Remove(left.First());\n            }\n            while (right.Count != 0)\n            {\n                merged.Add(right.First());\n                right.Remove(right.First());\n            }\n            return merged;\n        }\n```\n\n    ", "Answer": "\r\nYour issue is with the code that determines which list to put each item into \n\n```\n if (list.IndexOf(item) <= (list.Count / 2))\n```\n\n\nIf the list has 2 items then the indexes are 0 and 1 and this condition is true for both so they are both put in the left list and nothing in the right.  Then you call \n\n```\nleft = MergeSort(left);\n```\n\n\nWhich is taking a list with 2 items and again it's going to put both in the left and call this again and put them both in the left and .... forever.\n\nJust change the comparison to \n\n```\n if (list.IndexOf(item) < (list.Count / 2))\n```\n\n\nAdditionally you should not use ```\nIndexOf```\n as it will return the index of the first item instead of the current one if you have duplicates in the list.  So a list with \"abc\" in it twice will return 0 both times and you'll fall into the same infinite loop.  Instead you can just do a ```\nfor```\n loop like this\n\n```\nfor (int i = 0; i < list.Count; i++)\n{\n     if (i < (list.Count / 2))\n     { \n         left.Add(list[i]);\n     }\n     else \n     {\n         right.Add(list[i]);\n     }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Outputs Wrongly\r\n                \r\nMerge Sort.\n\n```\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\npackage algorithms;\n\nimport java.util.Arrays;\n\n/**\n*\n* @author Navin\n*/\npublic class MergeSort {\n\n    int [] left;\n    int [] right;\n\n    public void Merge_Sort(int [] array){\n        if(array.length<2){\n            return;\n        }       \n\n        int mid = array.length/2;\n        left = new int[mid];\n        right = new int[array.length-mid];\n\n        for(int i =0;i<mid;i++){\n            left[i] = array[i];\n        }\n\n        for(int j =mid;j<array.length;j++){\n            right[j-mid] = array[j];\n\n        }\n\n        System.out.println(Arrays.toString(left));\n        System.out.println(Arrays.toString(right));\n\n        Merge_Sort(left);\n        Merge_Sort(right);\n        Merge(left,right,array);\n    }    \n\n\n    public void Merge(int [] left, int [] right, int [] array){\n\n        int i=0;\n        int j=0;\n        int k=0;\n\n        while(i<left.length && j<right.length){\n\n            if(left[i] < right[j]){\n                array[k] = left[i];\n                i++;\n            }else{\n                array[k] = right[j];\n                j++;\n            }\n            k++;\n        }\n\n    }\n\n    public static void main(String[] args) {\n        int [] array  = {2,4,1,6,8,5,3,7};\n        MergeSort ms = new MergeSort();\n\n        ms.Merge_Sort(array);\n        System.out.println(Arrays.toString(array));\n    }\n}\n```\n\n\nI'm not sure what's wrong with the above, the logic and the implementation is correct, but the output is an unsorted array, which is the same as the input.\n\nOutput:\n    [2, 4, 1, 6, 8, 5, 3, 7]\n    ", "Answer": "\r\nI tested your code and your merging method is wrong.  Use this code and all should be fine:\n\n```\npublic void merge(int[] left, int[] right, int[] array) {\n    int i = 0, j = 0, k = 0;\n\n    while (i < left.length && j < right.length) {\n        if (left[i] < right[j])\n            array[k++] = left[i++];\n        else        \n            array[k++] = right[j++];               \n    }\n\n    while (i < left.length)\n        array[k++] = left[i++];\n\n    while (j < right.length)    \n        array[k++] = right[j++];\n\n    return;\n}\n```\n\n\nRead this great SO post for information on how to merge two sorted arrays in Java.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementation of Bottom Up Merge Sort\r\n                \r\nI've learned that Merge Sort is a sorting algorithm which follows the principle of Divide and Conquer and it have average time complexity as n(log n).\nHere I've divided the array of size n in sub array (initializing with length 2) and conquered it by sorting the sub arrays. Then we proceed the range with multiple of 2 until it's less than length of the array (i.e. 2,4,8,....i where i<length of array).\nWhen it exceeds length of array then function returns the sorted array.\nI have used two functions to implement Merge Sort:\n\nMerge Sort (To Produce Sub Array)\n\n\nIf length of array is less than range return array.\nRecursion and increasing the range exponentially.\n\n\nInsertion Sort (To Sort Sub Array)\n\n\nSort the element within the range using Insertion Sort. I've chosen insertion sort because it's more efficient than bubble sort and selection sort.\n\nThe program works fine and I would like to know whether I've understand the concept of merge sort and implemented it correctly?\n```\n//C++ Code\n#include<iostream>\n\n// Print\nvoid print(int *arr, int length);\n\n// To Sort the sub array\nvoid insertion_sort(int *arr, int low, int high)\n{\n    for(int i = high; (i-1)>=low; i--)\n    {\n        if (arr[i] < arr [i-1])\n        {\n            int temp = arr[i];\n            arr[i] = arr[i-1];\n            arr[i-1] = temp;\n        }\n    }\n}\n\nint *merge_sort(int* arr, int length, int index = 2)\n{\n    if (length <= index) // Terminating Condition\n    {\n        return arr;\n    }\n\n    // The range is defined by index.\n\n        /*\n            If array has 8 elements:  ********\n            It will sort array until it's range within the length of array.\n            1st call  2*1 elements max: ** ** ** ** // 2 set as default argument\n            2nd call  2*2 elements max: **** ****\n            3rd call  2*3 elements max: ********\n            Returns Array\n        */\n\n    // The range is defined by index.\n\n    for(int i=0; (i+index)<length; i+=index)\n    {\n        // Divide and Sort\n        insertion_sort(arr, i, i+index);\n    }\n\n    // The range will increase in multiple of 2 (i.e. 2,4,8,....i where i<length of array)\n    return merge_sort(arr, length, index*2);\n}\n\nint main()\n{\n    int length;    \n    std::cout<<\"Length of Array: \";\n    std::cin>>length;\n\n    int arr[length];\n\n    for(int i=0; i<length; i++)\n    {\n        std::cout<<\"Enter element \"<<i+1<<\" : \";\n        std::cin>>arr[i];\n    }\n\n    int *result = merge_sort(arr, length);\n    \n    print(result, length);\n    \n    return 0;\n}\n\nvoid print(int *arr, int length)\n{\n    std::cout<<\"Sorted Array: \";\n\n    for(int i=0; i<length; i++)\n    {\n        std::cout<<arr[i]<<\" \";\n    }\n\n    std::cout<<\"\\n\";\n}\n```\n\n    ", "Answer": "\r\nA pure bottom up merge sort divides an array of n elements into n runs of size 1, then each pass merges even and odd runs. Link to wiki example:\nhttps://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation\nAs suggested in the Wiki example comments, the direction of merge can be changed with each pass. To end up with sorted data in the original array, calculate the number of passes needed, and if the number of passes is odd, compare and swap (if needed) pairs of elements in place to create runs of size 2, then do the merge sort passes.\nFor a hybrid insertion + merge sort, do the same calculation for the number of passes, and if the number of passes is odd, set initial run size to 32 elements, otherwise, set initial run size to 64 elements. Do a single pass using insertion sort to sort the initial runs, then switch to merge sort.\nSimple example code to get pass count (for 32 bit build, assumes n <= 2^31):\n```\nsize_t GetPassCount(size_t n)               // return # passes\n{\n    size_t i = 0;\n    for(size_t s = 1; s < n; s <<= 1)\n        i += 1;\n    return(i);\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort - Vector not sorting\r\n                \r\nI'm trying to perform a merge sort on a ```\nstd::vector<int>```\n. Each int in the vector corresponds to an index in another vector ```\nstd::vector<Node>```\n. Each node has a depth. I am trying to sort based on depth.\n\nI am using some merge sort code that I found. It works fine using an array of integers, so I figured it would work fine in my code. Here is a shortened version of my code:\n\n.h file:\n\n```\nclass Log{\npublic:\n    static std::vector<int> a;\n};\n```\n\n\n.cpp file:\n\n```\nstd::vector<int> Log::a;\n\nint getNodeDepth (int index, std::vector<cv::ml::DTrees::Node::Node> nodeList, std::vector<int> treeList) {\n    //returns the node's depth\n}\n\nvoid exchange(int i, int j) {\n    int t = Log::a[i];\n    Log::a[i] = Log::a[j];\n    Log::a[j] = t;\n}\n\nvoid compare(int i, int j, std::vector<cv::ml::DTrees::Node::Node> nodeList) {\n    if (getNodeDepth(nodeList[Log::a[i]], nodeList) > (getNodeDepth(nodeList[Log::a[j]], nodeList)))\n    exchange(i, j);\n}\n\n/**\n * lo is the starting position and\n * n is the length of the piece to be merged,\n * r is the distance of the elements to be compared\n */\nvoid oddEvenMerge(int lo, int n, int r, std::vector<cv::ml::DTrees::Node::Node> nodeList) {\n    int m = r * 2;\n    if (m < n) {\n        oddEvenMerge(lo, n, m, nodeList); // even subsequence\n        oddEvenMerge(lo + r, n, m, nodeList); // odd subsequence\n        for (int i = lo + r; i + r < lo + n; i += m)\n            compare(i, i + r, nodeList);\n    } else\n        compare(lo, lo + r, nodeList);\n}\n\n/**\n * sorts a piece of length n of the array\n * starting at position lo\n */\nvoid oddEvenMergeSort(int lo, int n, std::vector<cv::ml::DTrees::Node::Node> nodeList) {\n    if (n > 1) {\n        int m = n / 2;\n        oddEvenMergeSort(lo, m, nodeList);\n        oddEvenMergeSort(lo + m, m, nodeList);\n        oddEvenMerge(lo, n, 1, nodeList);\n    }\n}\n\nint mergeSort(std::vector<int> treeList, std::vector<cv::ml::DTrees::Node::Node> nodeList) {\n    Log::a = treeList;\n    int i, n = sizeof(Log::a) / sizeof(Log::a[0]);\n    for (i = 0; i < n; i++)\n        std::cout << std::setw(3) << Log::a[i];\n    std::cout << std::endl;\n    oddEvenMergeSort(0, n, nodeList);\n    //print sorted list\n    for (i = 0; i < Log::a.size(); i++)\n        std::cout << Log::a[i] << \"  *   \";\n    std::cout << std::endl;\n\n    return(0);\n}\n```\n\n\nNote that the variable ```\nnodeList```\n is just there because the depth method needs it. \nThe output looks like only the first half of the vector is touched. No items on the second half of the vector ever get swapped. I double checked to make sure the depths are correct, and that the correct things are being swapped. It just doesn't finish the job. Any ideas why?\n    ", "Answer": "\r\n```\nsizeof(Log::a) / sizeof(Log::a[0]);```\n\n\nThis does not get the number of elements in ```\nLog::a```\n! It gets the size (in bytes) of the ```\nstd::vector```\n type, which has nothing to do with the number of contained elements, then divides by the size of an element. This gives you some garbage.\n\nThis idiom is for arrays, and ```\nstd::size```\n is better, but not standard yet - you can easily write it yourself like this:\n\n```\ntemplate <typename T, std::size_t N>\nstd::size_t arraySize(T (&)[N])\n{\n    return N;\n}\n```\n\n\n(There are more convoluted versions if you need it as a compile time constant.)\n\nUse ```\nLog::a.size();```\n to get the size of a ```\nstd::vector```\n.\n\n(I may be missing other problems, but this one stands out.)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Trouble with A Java Merge Sort Algorithm\r\n                \r\nI am having trouble with this merge sort algorithm. I have 3 total methods to do a merge sort, plus the main method calling it. It is not outputting a sorted array and I am not sure where I went wrong. It all looks right to me when I am looking at it, I am not sure if the error is within the recursive parts of the method, or if it's within just one of the classes. Any help would be appreciated, thanks!\nHere is my code: \n\n```\n/**\n * To do: Implement merge sort.\n * @param array the array to sort\n * @return the sorted array\n */\npublic static int[] mergeSort(int[] array) {\n    // call mergeSort(int [], int, int) to initiate sorting\n    //throw new UnsupportedOperationException()\n    return mergeSort(array, 0, array.length-1);\n}\n\n/**\n * To do: Implement overloaded merge sort method.\n * @param array the array to sort\n * @param begin the starting index of the array to be sorted\n * @param end the last index of the array to be sorted\n */\nprivate static int[] mergeSort(int[] array, int begin, int end) {\n    // you need to write the merge sort algorithm here\n    // use this method mergeSort(int [], int, int) and merge(int [], int[])\n    // to complete it\n    //throw new UnsupportedOperationException();\n\n\n    if(begin < end) {\n        int [] left = new int[array.length/2];\n        int [] right = new int[array.length - left.length];\n\n        //copies first half of array into left\n        for(int i = 0; i < left.length; i++) {\n            left[i] = array[i];\n        }\n        //copies second half into right array\n        for(int j = 0; j < right.length; j++) {\n            right[j] = array[left.length + j];\n        }\n\n        mergeSort(left);\n        mergeSort(right);\n        return merge(left, right);\n    }\n    return array;\n}\n\n\n/**\n * To do: Merge two sorted arrays into one and return it\n * @param left the first array\n * @param right the second array\n * @return the sorted merged array\n */\nprivate static int[] merge(int[] left, int[] right) {\n    // merge two sorted array such way that it remains sorted\n    //throw new UnsupportedOperationException();\n    int [] sorted = new int[left.length + right.length];\n\n    int leftIndex = 0;\n    int rightIndex = 0;\n\n    for(int j = 0; j < sorted.length; j++ ) {\n        if( leftIndex <= left.length-1 && rightIndex <= right.length-1) {\n\n            if(left[leftIndex] < right[rightIndex]) {\n                sorted[j] = left[leftIndex];\n                leftIndex++;\n            }\n            else {\n                sorted[j] = right[rightIndex];\n                rightIndex++;\n            }\n        }\n        else if( leftIndex < left.length) {\n            sorted[j] = left[leftIndex];\n            leftIndex++;\n        }\n        else if(rightIndex< right.length) {\n            sorted[j] = right[rightIndex];\n            rightIndex++;\n        }\n    }\n\n    return sorted;\n}\n```\n\n    ", "Answer": "\r\nYour ```\nmergeSort```\n function is not in-place, i.e. it returns a new array instead of changing the order of elements in the same array. Therefore, these 2 lines:\n\n```\n            mergeSort(left);\n            mergeSort(right);\n```\n\n\nwill have absolutely no effects.\n\nChange it to:\n\n```\n            left = mergeSort(left);\n            right = mergeSort(right);\n```\n\n\nAnother comment: Even though your merge sort is ```\nO(NlogN)```\n, you use a lot copying arrays around, which creates a lot of the overhead. Try to use in place operation as much as possible, avoid creating extra array. Most often, the merge sort uses no more than 2 arrays at any time. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort C++ Compile Error\r\n                \r\nI'm trying to implement a merge sort function and I'm getting a compiler error that says \"no match for 'operator=' \" It occurs on my recursive assignment of left_list = mergesort(left_list) and the same error in the following line using right_list.\n\nIt compiles correctly if I take out the assignment and just have mergesort(left_list) but then it doesn't sort correctly. I thought that the way I have it now should merge sort correctly, but given that it doesn't, either the error has something to do with those lines or it's elsewhere in the mergesort() or merge() function.\n\nAny help would be appreciated.\n\n```\nvoid mergesort(vector<int> &data) {\n\nvector<int> left_list;\nvector<int> right_list;\n\nif ( data.size() <= 1 ) {\n    return;\n}\n\n// creates a middle point to separate into 2 sub lists\nint middle =  ( data.size() / 2 );\n\n// create a list of elements to the left of middle\nfor ( int i = 0; i < middle; i++ ) {\n    left_list.push_back(data[i]);\n}\n\n// create a list of elements to the right of middle\nfor ( unsigned int i = middle; i < data.size(); i++ ) {\n    right_list.push_back(data[i]);\n}\n\n// break down the sub lists until they are of size 1\nleft_list = mergesort(left_list);\nright_list = mergesort(right_list);\n\n// merge the sublists in the correct order\nmerge(left_list, right_list);\n\n\n\n}\n\nvector<int> merge(vector<int> &left, vector<int> &right) {\n\nvector<int> result;\n\nunsigned left_it = 0;\nunsigned right_it = 0;\n\nwhile( left_it < left.size() && right_it < right.size() ) {\n\n\n    // the smaller value is put into the result vector\n    if( left[left_it] < right[right_it] ) {\n\n        result.push_back(left[left_it]);\n        left_it++;\n    }\n    else\n    {\n        result.push_back( right[right_it] );\n        right_it++;\n    }\n}\n\n// Put the rest of the data from both vectors onto result\nwhile( left_it < left.size() ) {\n\n    result.push_back( left[left_it] );\n    left_it++;\n}\n\nwhile( right_it < right.size() ) {\n\n    result.push_back( right[right_it] );\n    right_it++;\n}\n\nreturn result;\n\n}\n```\n\n    ", "Answer": "\r\nYou have code that is trying to accept a return value from the ```\nmergesort```\n function. If that is what you want, my original answer addresses that. However, if ```\nmergesort```\n is supposed to update the input parameter with the sorted result, then it need not return any value, and ```\nvoid```\n is fine. Then, the assignment statements getting its return result is in error and should be changed.\n\n```\nmergesort(left_list);\nmergesort(right_list);\n```\n\n\nHowever, the call to ```\nmerge```\n needs to assign the result to the input parameter.\n\n```\ndata = merge(left_list, right_list);\n```\n\n\nMy original answer follows:\n\nYou should change your ```\nmergesort```\n function to return the same type that ```\nmerge```\n returns.\n\n```\nvector<int> mergesort(vector<int> &data) {\n```\n\n\nYou then need to update the ```\nmergesort```\n implementation so that the first ```\nreturn```\n statement returns the input parameter:\n\n```\nreturn data;\n```\n\n\nThe last statement should be changed to return the result:\n\n```\nreturn merge(left_list, right_list);\n```\n\n\nI haven't looked at the implementation of the algorithm itself.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in LMC / Assembly\r\n                \r\nI want to implement a merge sort in LMC where I input a pre-sorted array of values and store them then input a second pre-sorted array of values and merge sort them with the first array but I'm having a lot of trouble with my sorting and array shift loops. I'm using label to know where to start shifting down the array to insert smaller values. Entering 1, 2, 0 and then 2, 3, 0 should output (003 002 002 001).\n\n```\narrayInput (IN) ;; Enter the first array of numbers.\n    (BRZ sortLoop)\nstoreArray (DAT 380) ;; Storing the array of numbers.\n    (LDA arrayInput)\n    (ADD increment)\n    (STO arrayInput)\n    (LDA counter)\n    (ADD increment)\n    (STO counter)\n    (BR arrayInput)\nsortLoop (IN) ;; Insert the second array of numbers and start sorting here.\n    (BRZ outputLoop)\n    (STO temp)\n    (LDA 80)\n    (SUB temp)\n    (BRP shiftDownArray)\n    (BR sortLoop)\nshiftDownArray (BR label) ;; Shifting down the array everytime we find a smaller value.\n    (LDA label)\n    (ADD increment)\noutputLoop (DAT 380) ;; Output the results.\n    (OUT)\n    (LDA outputLoop)\n    (ADD increment)\n    (STO outputLoop)\n    (LDA counter)\n    (SUB increment)\n    (STA counter)\n    (BRZ end)\n    (BR outputLoop)\nend (HLT)\nlabel (LDA arrayInput)\n    (ADD counter)\n    (STO label)\n    (BR shiftDownArray)\ncounter (DAT 000)\nincrement (DAT 001)\ntemp (DAT 000)\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort, sorting dates properly but not integer values\r\n                \r\nI am doing a coding challenge trying to learn merge sort and I have gotten my merge sort to handle dates properly but not an integer value. Currently it seems to outputting data at random.\nEDIT: There are over a dozen different posts like the sample data listed. I am unable to sort each of those objects based on their votes from high to low\nMy Merge Sort Function:\n```\nfunction sortBy(array, key, descending = false) {\n  const length = array.length;\n  if (length === 1) {\n    return array;\n  } else if (length === 2) {\n    const aValue = array[0][key];\n    const bValue = array[1][key];\n    if (bValue > aValue) {\n      return array;\n    }\n    return [\n      array[0],\n      array[1],\n    ];\n  }\n\n  const mid = Math.floor(length / 2);\n  const firstHalf = array.slice(0, mid);\n  const secondHalf = array.slice(mid, length);\n\n  const arrayOne = sortBy(firstHalf, key);\n  const arrayTwo = sortBy(secondHalf, key);\n\n  const merged = [];\n  while (arrayOne.length || arrayTwo.length) {\n    if (!arrayOne.length) {\n      merged.push(arrayTwo.shift());\n      continue;\n    }\n\n    if (!arrayTwo.length) {\n      merged.push(arrayOne.shift());\n      continue;\n    }\n\n    const valueOne = arrayOne[0][key];\n    const valueTwo = arrayTwo[0][key];\n    if (valueOne <= valueTwo) {\n      merged.push(arrayOne.shift());\n    } else if (valueTwo < valueOne) {\n      merged.push(arrayTwo.shift());\n    }\n  }\n\n  return descending ? merged.reverse() : merged;\n}\n```\n\nSample Data\n```\n    [{\n    created: '2016-03-07T05:24:40.340Z',\n    details: 'Right now we only support single backticks. Would be nice to do triple as well... Consider supporting more or all of markdown but I\\'m not sure that\\'s the right direction.',\n    title: 'Support triple backtick codeblocks',\n    votes: 17,\n  },]\n```\n\n    ", "Answer": "\r\n2 things I see just reading through the code:\n\nneed to access different elements of the array in the last return statement\n\n```\nconst length = array.length;\n  if (length === 1) {\n    return array;\n  } else if (length === 2) {\n    const aValue = array[0][key];\n    const bValue = array[1][key];\n    if (bValue > aValue) {\n      return array;\n    }\n    return [\n      array[0], // needs to be array[1]\n      array[1], // needs to be array[0]\n    ];\n  }\n```\n\n\nYou need to be passing the third argument down everytime you recurse the function\n```\nconst arrayOne = sortBy(firstHalf, key, descending);```\n\n```\nconst arrayTwo = sortBy(secondHalf, key, descending);```\n\n\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort, sorting dates properly but not integer values\r\n                \r\nI am doing a coding challenge trying to learn merge sort and I have gotten my merge sort to handle dates properly but not an integer value. Currently it seems to outputting data at random.\nEDIT: There are over a dozen different posts like the sample data listed. I am unable to sort each of those objects based on their votes from high to low\nMy Merge Sort Function:\n```\nfunction sortBy(array, key, descending = false) {\n  const length = array.length;\n  if (length === 1) {\n    return array;\n  } else if (length === 2) {\n    const aValue = array[0][key];\n    const bValue = array[1][key];\n    if (bValue > aValue) {\n      return array;\n    }\n    return [\n      array[0],\n      array[1],\n    ];\n  }\n\n  const mid = Math.floor(length / 2);\n  const firstHalf = array.slice(0, mid);\n  const secondHalf = array.slice(mid, length);\n\n  const arrayOne = sortBy(firstHalf, key);\n  const arrayTwo = sortBy(secondHalf, key);\n\n  const merged = [];\n  while (arrayOne.length || arrayTwo.length) {\n    if (!arrayOne.length) {\n      merged.push(arrayTwo.shift());\n      continue;\n    }\n\n    if (!arrayTwo.length) {\n      merged.push(arrayOne.shift());\n      continue;\n    }\n\n    const valueOne = arrayOne[0][key];\n    const valueTwo = arrayTwo[0][key];\n    if (valueOne <= valueTwo) {\n      merged.push(arrayOne.shift());\n    } else if (valueTwo < valueOne) {\n      merged.push(arrayTwo.shift());\n    }\n  }\n\n  return descending ? merged.reverse() : merged;\n}\n```\n\nSample Data\n```\n    [{\n    created: '2016-03-07T05:24:40.340Z',\n    details: 'Right now we only support single backticks. Would be nice to do triple as well... Consider supporting more or all of markdown but I\\'m not sure that\\'s the right direction.',\n    title: 'Support triple backtick codeblocks',\n    votes: 17,\n  },]\n```\n\n    ", "Answer": "\r\n2 things I see just reading through the code:\n\nneed to access different elements of the array in the last return statement\n\n```\nconst length = array.length;\n  if (length === 1) {\n    return array;\n  } else if (length === 2) {\n    const aValue = array[0][key];\n    const bValue = array[1][key];\n    if (bValue > aValue) {\n      return array;\n    }\n    return [\n      array[0], // needs to be array[1]\n      array[1], // needs to be array[0]\n    ];\n  }\n```\n\n\nYou need to be passing the third argument down everytime you recurse the function\n```\nconst arrayOne = sortBy(firstHalf, key, descending);```\n\n```\nconst arrayTwo = sortBy(secondHalf, key, descending);```\n\n\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merging in merge sort without using temporary arrays\r\n                \r\nI'm trying to implement merge sort but somehow have been stuck for a day.\n[Sorry for pasting a big amount of code but wouldn't be able to do without it]\nImplementation:\nMerge Sort - Function\n```\nint mergeSort(int arr[], int low, int high)\n{\n    int half = (low + high) / 2;    /* Find the middle element */ \n    if (low < high) {\n        if (high - low == 1)        /* If only one element, return */\n            return;\n        mergeSort(arr, low, half);  /* Sort First Half */\n        mergeSort(arr, half, high); /* Sort Second Half */\n        merge(arr, low, half, high); /* Merge */\n    }\n    return SUCCESS;\n}\n```\n\nMerging Step - Merge Function\n```\nint merge(int arr[], int low, int half, int high)\n{\n    int i = 0, j = 0, k = 0, l = 0, temp;    /* Initialize indices */\n\n    for (i = low, j = half; i < half && j < high; i++, j++) { \n        /* Swap in the array itself if the elements are out of order */\n        if (arr[i] > arr[j]) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n\n    i = 0, j = low;  /* Compare and copy the elements in a global arrray C */\n    for (k = 0; k < SIZE && i < low && j < high; k++) {\n        if (arr[i] < arr[j]) {\n            c[k] = arr[i];\n            i++;\n        } else {\n            c[k] = arr[j];\n            j++;\n        }\n    }\n    \n    if (i < j) { /* Copy remaining elements to the end of the array C */\n        for (l = i; l < low; l++) {\n            c[k++] = arr[l];\n        }\n    } else {\n        for (l = j; l < high; l++) {\n            c[k++] = arr[l];\n        }\n    }\n```\n\nOutput\n```\n8 --> 9 --> \n4 --> 5 --> 8 --> 9 --> \n4 --> 5 --> 8 --> 9 --> \n1 --> 2 --> 4 --> 5 --> 8 --> 9 --> /* Sorting when left is sorted but right is in the process ? */\n4 --> 5 --> 6 --> 7 --> 8 --> 9 --> 1 --> 2 --> \n1 --> 2 --> 4 --> 5 --> 6 --> 7 --> 8 --> 9 --> \n1 --> 2 --> 6 --> 7 --> 4 --> 5 --> 8 --> 9 --> \n\n     \n```\n\nProblem Description\nI'm not using any local array for storing the elements of the array. Instead the elements are swapped if they are out of order and then copied into a global array by comparison\nExample: If I have the array\n```\n{ 9, 8, 4, 5, 2, 1, 7, 6 }\n```\n\nThen, firstly ```\n{8,9}```\n would be sorted and then ```\n{4,5}```\n would be sorted and then when copying procedure i.e ```\n{8,4}```\n would be compared and so on.\nThe following recursive calls take place\n```\nmergeSort(0,8) -> mergeSort(0,4) , mergeSort(4,8), merge(0,4,8)\nmergeSort(0,4) -> mergeSort(0,2) , mergeSort(2,4), merge(0,2,4)\nmergeSort(0,2) -> 1 element calls\nand so on.\n```\n\nWhen merge is called when ```\n{4,5,8,9}```\n are sorted , and the right is called ```\nmerge(4,5,6)```\n I have the following array\n```\n{4,5,8,9,1,2,7,6}\n```\n\nSo, the algo tries to sort ```\n{4,5,8,9}```\n and ```\n{1,2}```\n when ```\n{1,2}```\n is not a part of this subproblem i.e I want ```\n{1,2}```\n and ```\n'{6,7}```\n to become ```\n{1,2,6,7}```\n and then combine both of these.\nHow do I overcome this? I have been stuck for so many hours.\nThanks a lot\n    ", "Answer": "\r\nIn-place MergeSort is rarely, if ever used, because an in-place Merge operation, though possible, is quite complicated compared to the obvious version using an extra buffer.\nThough rarely suggested, an efficient version can be obtained by alternating the merges between the original and extra buffers, to minimize the number of moves. Care must be taken that an even number of merges be made across the recursive calls. This can be handled by implementing true in-place merges for very small number of elements (or alternative sorts).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort with OpenMP\r\n                \r\nSo I am making a program that sorts an aryay with 100.000.000 intengers using the  merge sort algorithm. At the end ,the program prints how much time it took to sort the array and to find its greatest element with 1,2,3 and 4 threads. The \"merge time\" seems to be right ,with the one thread being the slowest and the four threads being the fastest as expected(t1>t2>t3>t4),but that relation doesn's apply for the \"find max\" time ... Any ideas why is this happening?\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <unistd.h>\n#define MAX 100000000\n#define MAX_THREAD 4\n\ntypedef struct thr {\n    int thr_low;\n    int thr_high;\n}thr_t;\n\nvoid merge(int low, int mid, int high);\nvoid merge_sort(int low, int high);\nvoid multi_merge_sort(int low,int high);\nvoid copyArray(int *A,int begin,int end,int *B);\n\nint *A,*B,found,greatest,num=1,dummy;\ndouble mergetime[4],findmax[4],start_time,maxtime;\n\n\nint main(int argc, char const *argv[]){\n\n  A= malloc(sizeof(int) * MAX);\n  B= malloc(sizeof(int) * MAX);\n\n\n  for (int i = 0; i < MAX; i++) {\n    B[i] = rand() ;\n    if(B[i]>greatest)\n    greatest=B[i];\n  }\n  do{\n    copyArray(A,0,MAX,B);\n\n    thr_t *thr;\n    thr_t thrlist[num];\n    int len = MAX / num;\n\n    int low = 0;\n    found = greatest = dummy = 0;\n\n    for (int i = 0; i < num; i++, low += len) {\n        thr = &thrlist[i];\n\n        thr->thr_low = low;\n        thr->thr_high = low + len - 1;\n        if (i == (num - 1))\n          thr->thr_high = MAX - 1;\n     }\n\n    start_time=omp_get_wtime();\n\n    #pragma omp parallel num_threads(num)\n    {\n      int ID = omp_get_thread_num();\n      thr_t *thr = &thrlist[ID];\n      int low = thr->thr_low ;\n      int high = thr->thr_high;\n      multi_merge_sort(low,high);\n    }\n\n    thr_t *thrm = &thrlist[0];\n    for (int i = 1; i < num; i++) {\n        thr_t *thr = &thrlist[i];\n        merge(thrm->thr_low, thr->thr_low - 1, thr->thr_high);\n    }\n\n    mergetime[(num-1)]=omp_get_wtime()-start_time;\n    num++;\n  }while(num<=MAX_THREAD);\n\n\n\n\n\nprintf(\"Merge time:\\n\");\n  for (int i = 0; i < 4; i++) {\n    printf(\"%d --> %lf sec\\n\",(i+1),mergetime[i]);\n  }\n  printf(\"\\n\");\n  printf(\"Found greatest num in:\\n\");\n  for (int i = 0; i < 4; i++)\n    printf(\"%d --> %lf sec\\n\",(i+1),findmax[i]);\n\n  free(A);\n  free(B);\n  return 0;\n}\n\n\n\nvoid merge(int low, int mid, int high){\n\n  int p1 = mid - low + 1;\n  int p2 = high - mid;\n\n  int *left = malloc(p1 * sizeof(int));\n  int *right = malloc(p2 * sizeof(int));\n\n  int i,j,k=low;\n\n  for (i = 0; i < p1; i++){\n    left[i] = A[i + low];\n\n    if(greatest==left[i] && found==0){\n      found =1;\n      findmax[(num-1)]=omp_get_wtime()-start_time;\n    }\n  }\n\n  for (i = 0; i < p2; i++){\n      right[i] = A[i + mid + 1];\n      if(greatest==right[i] && found==0){\n        found =1;\n        findmax[(num-1)]=omp_get_wtime()-start_time;\n      }\n    }\n\n  i = j = 0;\n\n  while (i < p1 && j < p2) {\n    if (left[i] <= right[j])\n      A[k++] = left[i++];\n    else\n      A[k++] = right[j++];\n  }\n\n  while (i < p1)\n    A[k++] = left[i++];\n\n  while (j < p2)\n    A[k++] = right[j++];\n\n  free(left);\n  free(right);\n}\n\nvoid merge_sort(int low, int high){\n\n  int mid = low + (high - low) / 2;\n\n  if (low < high) {\n    merge_sort(low, mid);\n\n    merge_sort(mid + 1, high);\n\n    merge(low, mid, high);\n  }\n}\n\nvoid multi_merge_sort(int low,int high){\n\n  int mid = low + (high - low) / 2;\n\n  if (low < high) {\n    merge_sort(low, mid);\n    merge_sort(mid + 1, high);\n    merge(low, mid, high);\n  }\n}\n\nvoid copyArray(int *A,int begin,int end,int *B){\n  int k=0;\n  for(int i = begin; i < end; i++){\n     A[i] = B[i];\n  } \n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort on simd register\r\n                \r\nCan anyone think of a way to perform merge sort on 8 elements of an simd register within 3 steps and 4 comparisons in each step?\n\nThank you in advance!\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "the way merge-sort faster than insertion-sort puzzles me\r\n                \r\nJust got my feet wet in sorting algorithm with Haskell. I've implemented insertion-sort and merge-sort \n\n```\ninsert_sort :: (Ord a, Show a) => [a] -> [a]\ninsert_sort keys = foldr f [] keys\n           where f key []        = [key]\n                 f key acc       = insert key acc\n                 insert y []     = [y]\n                 insert y (x:xs)\n                     | x < y     = x : insert y xs\n                     | otherwise = y : x : xs\n\nmerge_sort :: (Ord a, Show a) => [a] -> [a]\nmerge_sort (x:[]) = [x]\nmerge_sort keys   = merge  (merge_sort (take len keys)) (merge_sort (drop len keys))\n      where len         = length keys `div` 2\n            merge :: [a] -> [a] -> [a]\n            merge (x:xs) []     = (x:xs)\n            merge []     (y:ys) = (y:ys)\n            merge (x:xs) (y:ys) = if x <= y\n                                  then x : merge (xs) (y:ys)\n                                  else y : merge (x:xs) ys\n```\n\n\nHere's how I compared their efficiency:\n\n```\ninsert_sort $ take 100000 $ randomRs (1,100000) $ mkStdGen 1 ::[Int]\nmerge_sort $ take 100000 $ randomRs (1,100000) $ mkStdGen 1 ::[Int]\n```\n\n\nBoth of them starts to print out results after a short delay but merge-sort prints much faster. As we know, merge-sort is much faster than insertion-sort for large data sets. I thought that would be shown by how they give results (like a long delay versus a short one) not how they print results. Is it because I use ```\nfoldr```\n in insertion-sort? What's behind the scene?\n\nEDIT: Thx guys. I've heard about lazy evaluation since I started to learn Haskell but yet got the hang of it. Would anybody illustrate a bit more with a small data set, say [5,2,6,3,1,4]? How is it possible to output results before finish sorting with ```\nfoldr```\n since the first elements comes at last?\n    ", "Answer": "\r\nBehind the scene is lazy evaluation. The start of the sorted lists is determined before the sort is complete, so it can be output before the work is finished. Since a mergesort is faster, the merge-sorted list is printed out faster.\n\nAs requested: how sorting ```\n[5,2,6,3,1,4]```\n proceeds. I use ```\ninsert_sort = foldr ins []```\n for brevity.\n\n```\ninsert_sort [5,2,6,3,1,4]\n  = foldr ins [] [5,2,6,3,1,4]\n  = 5 `ins` foldr ins [] [2,6,3,1,4]\n  = 5 `ins` 2 `ins` [6,3,1,4] ...\n  = 5 `ins` 2 `ins` 6 `ins` 3 `ins` 1 `ins` 4 `ins` []\n  = 5 `ins` 2 `ins` 6 `ins` 3 `ins` 1 `ins` (4:[])\n  = 5 `ins` 2 `ins` 6 `ins` 3 `ins` (1:4:[])\n  = 5 `ins` 2 `ins` 6 `ins` (1 : (3 `ins` (4:[])))\n  = 5 `ins` 2 `ins` (1 : (6 `ins` (3 `ins` (4:[]))))\n  = 5 `ins` (1 : (2 `ins` (6 `ins` (3 `ins` (4:[])))))\n  = 1 : (5 `ins` (2 `ins` (6 `ins` (3 `ins` (4:[])))))  -- now 1 can be output\n  = 1 : (5 `ins` (2 `ins` (6 `ins` (3:4:[]))))\n  = 1 : (5 `ins` (2 `ins` (3 : (6 `ins` (4:[])))))\n  = 1 : (5 `ins` (2 : (3 : (6 `ins` (4:[])))))\n  = 1 : 2 : (5 `ins` (3 : (6 `ins` (4:[]))))            -- now 2 can be output\n  = 1 : 2 : 3 : (5 `ins` (6 `ins` (4:[])))              -- now 3\n  = 1 : 2 : 3 : (5 `ins` (4:6:[]))\n  = 1 : 2 : 3 : 4 : (5 `ins` (6:[]))                    -- now 4\n  = 1 : 2 : 3 : 4 : 5 : 6 : []                          -- done\n```\n\n\nAnd merge sort (abbreviations: ```\nmerge = mg```\n, ```\nmerge_sort = ms```\n):\n\n```\nmerge_sort [5,2,6,3,1,4]\n  = mg (ms [5,2,6]) (ms [3,1,4])\n  = mg (mg (ms [5]) (ms [2,6])) (mg (ms [3]) (ms [1,4]))\n  = mg (mg [5] (mg [2] [6])) (mg [3] (mg [1] [4]))\n  = mg (mg [5] [2,6]) (mg [3] [1,4])\n  = mg (2 : mg [5] [6]) (1 : mg [3] [4])\n  = 1 : mg (2 : mg [5] [6]) (mg [3] [4])                -- now 1 can be output\n  = 1 : mg (2 : mg [5] [6]) [3,4]\n  = 1 : 2 : mg (mg [5] [6]) [3,4]                       -- now 2 can be output\n  = 1 : 2 : mg [5,6] [3,4]\n  = 1 : 2 : 3 : mg [5,6] [4]                            -- now 3\n  = 1 : 2 : 3 : 4 : mg [5,6] []                         -- now 4\n  = 1 : 2 : 3 : 4 : 5 : 6 : []                          -- now 5 and 6\n```\n\n\nAdmittedly I've taken a few short cuts, but Haskell isn't the only lazy one.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Running time of a modified merge sort compared to merge sort?\r\n                \r\nFrom wikipedia, https://en.wikipedia.org/wiki/Merge_algorithm#Application\n\nIn the diagram, let's say we consider the middle row of numbers (would help if someone can post the picture here). What would the running time of the algorithm be if I modified it to:\n\n\nMerge 38 and 27, then sort the numbers in ascending order. (27, 38)\nMerge the result from above with 43, then sort the numbers in ascending order. (27, 38, 43)\nMerge the result from above with 3, then sort the numbers in ascending order. (3, 27, 38, 43).\n...And so on until I have a fully sorted list.\n\n\nThis is an EXTREMELY inefficient way to sort (I can tell intuitively - in the worst case the number being added would swap with every number in the list) though I'm not so sure how it compares (in terms of justifying my analysis) to Merge Sort's O(n log n) time.\n\nAny thoughts?\n    ", "Answer": "\r\nThe algorithm you’re describing is insertion sort - you’re building a growing list of values in sorted order by adding one element in at a time. That means the runtime matches insertion sort - linear if the array is sorted, quadratic on average, etc.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How is shell sort algorithm any better than of merge sort algorithm?\r\n                \r\nI have this small presentation about algorithms with a group of nerds and i was randomly tasked to convince them that shell sort is better than merge sort algorithm... I have been reading for almost a weak But No matter how much i read on merge sort and shell sort i find the merge sort better than shell sort.. \n\nAre their any advantages of shell sort on merge sort? I mean on what circumstances is shell sort better than merge sort. I might have missed something but i dont know what.\n\nAny tips would be fine or if possible can you link me to something helpful..\n    ", "Answer": "\r\nYou have to remember the context in which shellsort was proposed: shellsort was published in 1959; quicksort, in 1961; mergesort, in 1948 (OK, that was a bit surprising). The computers of the day were slow and had small memories. Thus the asymptotic advantage of mergesort was hardly relevant compared to the increased complexity of implemention and code. In fact, shellsort gets the quadratic fallback of modern practical mergesorts for free, since insertion sorting with a gap of 1 is insertion sort.\n\nIt was not known then how to do an efficient in-place merge (and even now, no one implements it, because it's wildly inefficient in practice).\n\nShellsort has an uncomplicated nonrecursive implementation. Recursion in higher-level languages was confined to LISP (impractical then, not to mention lacking an array type) and the as-yet unimplemented ALGOL 60 standard.\n\nShellsort's running time improves a lot on mostly sorted data. (It's no Timsort though.)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort generic method\r\n                \r\nMy merge sort doesn't seem to be working correctly. When I display the sorted list, it is not sorted and elements are added, where there is supposed to be 9 there is 49. \nAnyone see where Im going wrong? \n\n```\npublic static <E extends Comparable<E>> void mergeSort(List<E> A) {\n    int n = A.size();\n    if (n > 1) {\n        int half = n / 2;\n        List<E> B = copyPartialArray(A, 0, half);\n        List<E> C = copyPartialArray(A, half, n);\n        mergeSort(B);\n        mergeSort(C);\n        merge(B, C, A);\n    }\n}\n\npublic static <E extends Comparable<E>> void merge(List<E> B, List<E> C, List<E> A) {\n    int n1 = B.size();\n    int n2 = C.size();\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < n1 && j < n2) {\n        if (B.get(i).compareTo(C.get(j)) < 0) {\n            A.add(k, B.get(i));\n            i++;\n        }\n        else {\n            A.add(k, C.get(j));\n            j++;\n        }\n        k++;\n    }\n    if (i == n1)\n        for (int p = j; p < n2; p++) {\n            A.add(k, C.get(p)); k++;\n        }\n    else if (j == n2)\n        for (int p = i; p < n1; p++) {\n            A.add(k, B.get(p)); k++;\n        }\n}\n\nprivate static <E extends Comparable<E>> List<E> copyPartialArray(List<E> A, int first, int last) {\n    int n = last - first;\n    List<E> copy = new ArrayList<E>(n);\n    for (int i = 0; i < n; i++)\n    copy.add(i, A.get(first + i));\n    return copy;\n}\n```\n\n    ", "Answer": "\r\nThis answer will try to make you realise what's wrong.\n\nIt's clear that mergeSort won't do anything to a one element array, but what happens if there are two (for instance [2,1])? You mention there are more elements than before in the result list (list A). Why? What's merge doing to that list? Hint.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "What is a NullPointerException, and how do I fix it?\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question's answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n\r\n\r\n    \r\n\r\nWhat are Null Pointer Exceptions (```\njava.lang.NullPointerException```\n) and what causes them?\n\nWhat methods/tools can be used to determine the cause so that you stop the exception from causing the program to terminate prematurely?\n    ", "Answer": "\r\nThere are two overarching types of variables in Java:\n\nPrimitives: variables that contain data. If you want to manipulate the data in a primitive variable you can manipulate that variable directly. By convention primitive types start with a lowercase letter. For example variables of type ```\nint```\n or ```\nchar```\n are primitives.\n\nReferences: variables that contain the memory address of an ```\nObject```\n i.e. variables that refer to an ```\nObject```\n. If you want to manipulate the ```\nObject```\n that a reference variable refers to you must dereference it. Dereferencing usually entails using ```\n.```\n to access a method or field, or using ```\n[```\n to index an array. By convention reference types are usually denoted with a type that starts in uppercase. For example variables of type ```\nObject```\n are references.\n\n\nConsider the following code where you declare a variable of primitive type ```\nint```\n and don't initialize it:\n```\nint x;\nint y = x + x;\n```\n\nThese two lines will crash the program because no value is specified for ```\nx```\n and we are trying to use ```\nx```\n's value to specify ```\ny```\n. All primitives have to be initialized to a usable value before they are manipulated.\nNow here is where things get interesting. Reference variables can be set to ```\nnull```\n which means \"I am referencing nothing\". You can get a ```\nnull```\n value in a reference variable if you explicitly set it that way, or a reference variable is uninitialized and the compiler does not catch it (Java will automatically set the variable to ```\nnull```\n).\nIf a reference variable is set to null either explicitly by you or through Java automatically, and you attempt to dereference it you get a ```\nNullPointerException```\n.\nThe ```\nNullPointerException```\n (NPE) typically occurs when you declare a variable but did not create an object and assign it to the variable before trying to use the contents of the variable. So you have a reference to something that does not actually exist.\nTake the following code:\n```\nInteger num;\nnum = new Integer(10);\n```\n\nThe first line declares a variable named ```\nnum```\n, but it does not actually contain a reference value yet. Since you have not yet said what to point to, Java sets it to ```\nnull```\n.\nIn the second line, the ```\nnew```\n keyword is used to instantiate (or create) an object of type ```\nInteger```\n, and the reference variable ```\nnum```\n is assigned to that ```\nInteger```\n object.\nIf you attempt to dereference ```\nnum```\n before creating the object you get a ```\nNullPointerException```\n. In the most trivial cases, the compiler will catch the problem and let you know that \"```\nnum may not have been initialized```\n,\" but sometimes you may write code that does not directly create the object.\nFor instance, you may have a method as follows:\n```\npublic void doSomething(SomeObject obj) {\n   // Do something to obj, assumes obj is not null\n   obj.myMethod();\n}\n```\n\nIn which case, you are not creating the object ```\nobj```\n, but rather assuming that it was created before the ```\ndoSomething()```\n method was called. Note, it is possible to call the method like this:\n```\ndoSomething(null);\n```\n\nIn which case, ```\nobj```\n is ```\nnull```\n, and the statement ```\nobj.myMethod()```\n will throw a ```\nNullPointerException```\n.\nIf the method is intended to do something to the passed-in object as the above method does, it is appropriate to throw the ```\nNullPointerException```\n because it's a programmer error and the programmer will need that information for debugging purposes.\nIn addition to ```\nNullPointerException```\ns thrown as a result of the method's logic, you can also check the method arguments for ```\nnull```\n values and throw NPEs explicitly by adding something like the following near the beginning of a method:\n```\n// Throws an NPE with a custom error message if obj is null\nObjects.requireNonNull(obj, \"obj must not be null\");\n```\n\nNote that it's helpful to say in your error message clearly which object cannot be ```\nnull```\n. The advantage of validating this is that 1) you can return your own clearer error messages and 2) for the rest of the method you know that unless ```\nobj```\n is reassigned, it is not null and can be dereferenced safely.\nAlternatively, there may be cases where the purpose of the method is not solely to operate on the passed in object, and therefore a null parameter may be acceptable. In this case, you would need to check for a null parameter and behave differently. You should also explain this in the documentation. For example, ```\ndoSomething()```\n could be written as:\n```\n/**\n  * @param obj An optional foo for ____. May be null, in which case\n  *  the result will be ____.\n  */\npublic void doSomething(SomeObject obj) {\n    if(obj == null) {\n       // Do something\n    } else {\n       // Do something else\n    }\n}\n```\n\nFinally, How to pinpoint the exception & cause using Stack Trace\n\nWhat methods/tools can be used to determine the cause so that you stop\nthe exception from causing the program to terminate prematurely?\n\nSonar with find bugs can detect NPE.\nCan sonar catch null pointer exceptions caused by JVM Dynamically\nNow Java 14 has added a new language feature to show the root cause of NullPointerException. This language feature has been part of SAP commercial JVM since 2006.\nIn Java 14, the following is a sample NullPointerException Exception message:\n\nin thread \"main\" java.lang.NullPointerException: Cannot invoke \"java.util.List.size()\" because \"list\" is null\n\nList of situations that cause a ```\nNullPointerException```\n to occur\nHere are all the situations in which a ```\nNullPointerException```\n occurs, that are directly* mentioned by the Java Language Specification:\n\nAccessing (i.e. getting or setting) an instance field of a null reference. (static fields don't count!)\nCalling an instance method of a null reference. (static methods don't count!)\n```\nthrow null;```\n\nAccessing elements of a null array.\nSynchronising on null - ```\nsynchronized (someNullReference) { ... }```\n\nAny integer/floating point operator can throw a ```\nNullPointerException```\n if one of its operands is a boxed null reference\nAn unboxing conversion throws a ```\nNullPointerException```\n if the boxed value is null.\nCalling ```\nsuper```\n on a null reference throws a ```\nNullPointerException```\n. If you are confused, this is talking about qualified superclass constructor invocations:\n\n```\nclass Outer {\n    class Inner {}\n}\nclass ChildOfInner extends Outer.Inner {\n    ChildOfInner(Outer o) { \n        o.super(); // if o is null, NPE gets thrown\n    }\n}\n```\n\n\nUsing a ```\nfor (element : iterable)```\n loop to loop through a null collection/array.\n\n```\nswitch (foo) { ... }```\n (whether its an expression or statement) can throw a ```\nNullPointerException```\n when ```\nfoo```\n is null.\n\n```\nfoo.new SomeInnerClass()```\n throws a ```\nNullPointerException```\n when ```\nfoo```\n is null.\n\nMethod references of the form ```\nname1::name2```\n or ```\nprimaryExpression::name```\n throws a ```\nNullPointerException```\n when evaluated when ```\nname1```\n or ```\nprimaryExpression```\n evaluates to null.\na note from the JLS here says that, ```\nsomeInstance.someStaticMethod()```\n doesn't throw an NPE, because ```\nsomeStaticMethod```\n is static, but ```\nsomeInstance::someStaticMethod```\n still throw an NPE!\n\n\n* Note that the JLS probably also says a lot about NPEs indirectly.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "GPU-accelerated sort (~1GB) and merge sort (~100GB)\r\n                \r\nI'm asking for a c++ library to do GPU-accelerated sort (around 1GB of data) and merge sort (say, around 100GB of data — but the size do not matter, because merge is a stream algorithm). License have to be LGPL, BSD or like this. I greatly prefer OpenCL because of portability (but I also interested in links to CUDA libraries). I appreciate links to papers and blog posts on this subject.\n\n Some background (please correct me if I wrong): \n\n2-way merge sort of 1GB (that is, 128 000 000 of 8-bytes entities) will consume approximately log2(128 000 000)·1G = 27GB of memory bandwidth, that is around 1 second on modern CPU with sequential memory bandwidth of ~30GB/s. (Any non-merge sort seems to take much longer time, because non-sequential memory access is slower in 10-100 times).\n\nAlthough I am not familiar with modern GPU, I suspect that merge sort of 1GB will take 0.2 second or even less, because typical GPU memory bandwidth is around 150GB/s, like AMD/ATI 58xx (see, for example http://en.wikipedia.org/wiki/Comparison_of_AMD_graphics_processing_units#Evergreen_.28HD_5xxx.29_series) \n\nThat is at least 5x speedup. (The time to transfer 1GB over 16x PCI-E 2.0 is around 0.125s, but it seems possible to make PCI transfers in parallel with sorting; however, this may require 2GB or 3GB of video-card memory instead of 1GB).\n\nI suspect even more speed-up due to more-than-2-way merge sort or some sort, suitable for GPU.\n    ", "Answer": "\r\nHave you looked at Thrust ?\n\nFrom the project page:\n\n\n  Thrust is a parallel algorithms library which resembles the C++\n  Standard Template Library (STL). Thrust's high-level interface greatly\n  enhances developer productivity while enabling performance portability\n  between GPUs and multicore CPUs. Interoperability with established\n  technologies (such as CUDA, TBB and OpenMP) facilitates integration\n  with existing software. Develop high-performance applications rapidly\n  with Thrust!\n\n\nLicense is Apache so it should suit you.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort: Heap Corruption on delete[]\r\n                \r\nWorking on a class project in which i need to implement a Merge Sort to sort 500,000 items.\nAfter many attempts I tried looking for source code online and found some here: http://www.sanfoundry.com/cpp-program-implement-merge-sort/\n\nI had to alter the code to use a dynamic array (for size). When the program runs the merge function, I create a new, dynamic array using the number of elements (or high) that are being merged. Once the function is finished sorting them and merge them into the original array, i use delete[] on the new dynamic array. This is where I get my \"Heap Corruption Detected\" error.\n\nHere is the code (wall of text):\n\n```\n//Heap Sort\n\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <ctime>\n#include <stdlib.h>\n#include <stdio.h>\n\nusing namespace std;\n\n//Function Prototypes\nvoid mergesort(int *a, int low, int high);\nvoid merge(int *a, int low, int high, int mid);\n\n\nint main()\n{\n//Start with element 1 of the array\nint line_no = 0;\nint num;\nint array_size = 500000;\nint* num_array = new int[array_size];\n\n//Open file for input\nfstream in_file(\"CSCI3380_final_project_dataset.txt\", ios::in);\n\n//Test for file opening\nif (!in_file)\n{\n    cout << \"Cannot open words1.txt for reading\" << endl;\n    exit(-1);\n}\n\n//Read file\nwhile(true)\n{\n    //Read one line at a time\n    in_file >> num;\n\n    //Test for eof\n    if (in_file.eof())\n      break;\n\n    num_array[line_no] = num;\n\n    //Increment array position\n    line_no++;\n\n}\n\n//Close the file\nin_file.close();\n\n//Start Time\nclock_t time_a = clock();   \n\n//Run Sorting Algorithim\nmergesort(num_array, 0, array_size-1);  \n\n//End Time\nclock_t time_b = clock();\n\n\n\n//Elapsed Time\nif (time_a == ((clock_t)-1) || time_b == ((clock_t)-1))\n{\n    cout << \"Unable to calculate elapsed time\" << endl;\n}\nelse\n{\n    int total_time_ticks = time_b - time_a;\n    cout << \"Elapsed time: \" << total_time_ticks << endl;\n}\n\ndelete[] num_array; \n\nreturn 0;\n}\n\nvoid mergesort(int *a, int low, int high)\n\n{\n\nint mid;\n\nif (low < high)\n\n{\n\n    mid=(low+high)/2;\n\n    mergesort(a,low,mid);\n\n    mergesort(a,mid+1,high);\n\n    merge(a,low,high,mid);\n\n}\n\nreturn;\n\n}\n\nvoid merge(int *a, int low, int high, int mid)\n\n{\n\n\n//--------------------------Create new array-------------------------------\n\nint* sort_array = new int[high];\n\n//--------------------------New Array Created-----------------------------\n\nint i, j, k;\n\ni = low;\n\nk = low;\n\nj = mid + 1;\n\nwhile (i <= mid && j <= high)\n\n{\n\n    if (a[i] < a[j])\n\n    {\n\n        sort_array[k] = a[i];\n\n        k++;\n\n        i++;\n\n    }\n\n    else\n\n    {\n\n        sort_array[k] = a[j];\n\n        k++;\n\n        j++;\n\n    }\n\n}\n\nwhile (i <= mid)\n\n{\n\n    sort_array[k] = a[i];\n\n    k++;\n\n    i++;\n\n}\n\nwhile (j <= high)\n\n{\n\n    sort_array[k] = a[j];\n\n    k++;\n\n    j++;\n\n}\n\nfor (i = low; i < k; i++)\n\n{\n\n    a[i] = sort_array[i];\n\n}\n\n//---------------------------Delete the New Array--------------------\n\ndelete[] sort_array;\n\n//--------------------------Oh No! Heap Corruption!------------------\n\n}\n```\n\n    ", "Answer": "\r\nI'll spare you the \"you should be using vectors\", \"you should be using smart pointers\", etc. You should be, and I'll leave it at that. Regarding your actual problem....\n\nYou're writing one-past the allocated space of your array. The allocated size is ```\nhigh```\n:\n\n```\nint* sort_array = new int[high];\n```\n\n\nmeaning you can only dereference from ```\n0..(high-1)```\n. Yet this:\n\n```\nwhile (j <= high)\n{\n    sort_array[k] = a[j];\n    k++;\n    j++;\n}\n```\n\n\nis one location that is guaranteed to write to ```\nsort_array[high]```\n, and therefore invoke undefined behavior.\n\n\n\nA Different Approach\n\nMergesort is about div-2 partitioning. You know this. What you may not have considered is that C and C++ both perform pointer-arithmetic beautifully and as such you only need two parameters for ```\nmergesort()```\n: a base address and a length. the rest can be taken care of for you with pointer math:\n\nConsider this:\n\n```\nvoid mergesort(int *a, int len)\n{\n    if (len < 2)\n        return;\n\n    int mid = len/2;    \n    mergesort(a, mid);\n    mergesort(a + mid, len-mid);\n    merge(a, mid, len);\n}\n```\n\n\nAnd a ```\nmerge```\n implementation that looks like this:\n\n```\nvoid merge(int *a, int mid, int len)\n{\n    int *sort_array = new int[ len ];\n    int i=0, j=mid, k=0;\n\n    while (i < mid && j < len)\n    {\n        if (a[i] < a[j])\n            sort_array[k++] = a[i++];\n        else\n            sort_array[k++] = a[j++];\n    }\n\n    while (i < mid)\n        sort_array[k++] = a[i++];\n\n    while (j < len)\n        sort_array[k++] = a[j++];\n\n    for (i=0;i<len;++i)\n        a[i] = sort_array[i];\n\n    delete[] sort_array;\n}\n```\n\n\nInvoked from ```\nmain()```\n like the following. Note: I've removed the file i/o in place of a random generation just to make it easier to test:\n\n```\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n//Function Prototypes\nvoid mergesort(int *a, int len);\nvoid merge(int *a, int mid, int len);\n\nint main()\n{\n    std::srand((unsigned int)std::time(nullptr));\n\n    // Start with element 1 of the array\n    int array_size = 500000;\n    int* num_array = new int[array_size];\n    std::generate_n(num_array, array_size, std::rand);\n\n    // Start Time\n    clock_t time_a = clock();\n\n    // Run Sorting Algorithim\n    mergesort(num_array, array_size);\n\n    // End Time\n    clock_t time_b = clock();\n\n    //Elapsed Time\n    if (time_a == ((clock_t)-1) || time_b == ((clock_t)-1))\n    {\n        cout << \"Unable to calculate elapsed time\" << endl;\n    }\n    else\n    {\n        int total_time_ticks = time_b - time_a;\n        cout << \"Elapsed time: \" << total_time_ticks << endl;\n    }\n\n    delete[] num_array;\n\n    return 0;\n}\n```\n\n\nThis resulted is an elapsed time of:\n\n```\nElapsed time: 247287\n```\n\n\n\n\nMore Efficient\n\nBy now you've seen that you will need at most N-space in addition to you sequence. The top-most merge should e evidence enough of that. What you may not consider is that in-reality that is exactly the space you need, and you can allocate it up-front and use it throughout the algorithm if you desire. You can keep the current entrapping for ```\nmergesort()```\n, but we'll be wrapping it up with a front-loader that allocates all the space we'll ever need once:\n\n```\n// merges the two sequences  a[0...mid-1] and a[mid...len-1]\n//  using tmp[] as the temporary storage space\nstatic void merge_s(int *a, int *tmp, int mid, int len)\n{\n    int i=0, j=mid, k=0;\n\n    while (i < mid && j < len)\n    {\n        if (a[i] < a[j])\n            tmp[k++] = a[i++];\n        else\n            tmp[k++] = a[j++];\n    }\n\n    while (i < mid)\n        tmp[k++] = a[i++];\n\n    while (j < len)\n        tmp[k++] = a[j++];\n\n    for (i=0;i<len;++i)\n        a[i] = tmp[i];\n}\n\nstatic void mergesort_s(int *a, int *tmp, int len)\n{\n    if (len < 2)\n        return;\n\n    int mid = len/2;\n    mergesort_s(a, tmp, mid);\n    mergesort_s(a + mid, tmp+mid, len-mid);\n    merge_s(a, tmp, mid, len);\n}\n\nvoid mergesort(int *a, int len)\n{\n    if (len < 2)\n        return;\n\n    int *tmp = new int[len];\n    mergesort_s(a,tmp,len);\n    delete [] tmp;\n\n}\n```\n\n\nThis resulted in an elapsed time of:\n\n```\nElapsed time: 164704\n```\n\n\nConsiderably better than we had before. Best of luck.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort on Strings in Java - Linked List\r\n                \r\nI have an excercise in which I have to insert into a linked list a string. Suppose the String is the following:\n\n```\n\"Java Coding Is Great\"\n```\n\n\nAfter the Merge Sort, the linked list is supposed to look like that:\n\n```\ncoding >>> great >>> is >>> java.\n```\n\n\nThe problem is that in my Merge Sort code I recieve the following:\n\n```\n great >> is >> java >> coding \n```\n\n\nAll the words are sorted BUT THE FIRST WORD (Head of the original list) is not.\n\nI have two classes: TextList and WordNode.\n\nThe WordNode class has two attributes:\n\n```\nString _word; WordNode _next; //an address to the next link\n```\n\n\nThe TextList class has only one attribute: an address of the head of the linked list:\n\n```\nWordNode _head;\n```\n\n\nI have a constructor in which I insert the String randomly into a linked list. in the end it starts merge sotring the list. This algorithem is for this excercise.\n\n```\npublic TextList(String text){\n     String s=\"\"; int index=text.length();\n    //we will stop at the end of the String.\n    for (int i=text.length()-1; i>=0; i--){\n        //if we reached a space, insert each string in appropriate order, \n        //the first word is the head of the string and last word points to null.\n        if (!(text.charAt(i)>='a' && text.charAt(i)<='z')){ \n            s=text.substring(i,index);\n            _head=new WordNode(s,_head);\n            s=\"\";\n            index=i;\n        }\n        if (i==1){\n            s=text.substring(i-1,index);\n            _head=new WordNode(s,_head);\n        }\n    }\n\n//start merge sotring the list.\n    this._head=this._head.mergeSort();\n}\n```\n\n\nMerge Sort Methods: mergeSort, merge and split: (These are in the WordNode class):\n\nMerge Sort method    \n\n```\npublic WordNode mergeSort(){\n    return mergeSort(this);\n}\nprivate WordNode mergeSort(WordNode h){\n    // Sort h by recursively splitting and merging\n    if (h==null || h._next==null)\n        return h;\n    else{\n        WordNode evens=h.splitOdds();\n        WordNode odds=h.splitEvens();\n        return mergeSort(odds).merge(mergeSort(evens)); \n    }\n}\n```\n\n\nMerge Method\n\n```\nprivate WordNode merge(WordNode h){\n        //method merges this's list with h's list\n\n        //if h is null, just return this.\n        if (h==null){\n            return this;\n        }\n        if (this._word.compareTo(h._word)<0){\n            if (this._next==null)\n                return new WordNode(this._word,h);\n            else\n                return new WordNode(this._word,this._next.merge(h));\n        }\n        else\n            return new WordNode (h._word, merge(h._next));\n\n    }\n```\n\n\nSplit Methods: one for even positions, one for odd positions.    \n\n```\nprivate WordNode splitOdds(){\n    boolean flag=true;\n    WordNode odds=null;\n    WordNode ptr=this;\n    while (ptr!=null){  \n        if(flag)\n        odds=new WordNode(ptr._word,odds);\n        ptr=ptr.getNext();\n        flag=!flag;\n    }\n    return odds;\n}\n//MUST BE INITILIZED ON HEAD\n    private WordNode splitEvens(){\n        boolean flag=true;\n        WordNode evens=null;\n        WordNode ptr=this._next;\n        while (ptr!=null){\n            if (flag)\n                evens=new WordNode(ptr._word,evens);\n                ptr=ptr.getNext();\n                flag=!flag;\n            }\n\n\n\n        return evens;\n    }\n```\n\n\nPlease help me figure out what's wrong. Unfortently, I can not use a third class, and I can't use pointers to the start of the list or to the end of the list.\n    ", "Answer": "\r\nCan you use your debugger to single-step through your code?  That will help you pinpoint the problem.  Even a few judiciously placed breakpoints will help.\n\nStart with a list containing only a single entry: \"Java\".  See what happens.\n\nThen try a two-entry list: \"Java Coding\".  See what happens in that case.\n\nWork out what is happening in the simple cases and then work up to the more complex ones.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Relationship between number of comparisons between merge sort and merge-insertion hybrid sort\r\n                \r\nI was playing around with a merge-insertion sort hybrid, which looks roughly like this:\n```\ndef hybrid_sort_comparisons(arr, S):\n    \"\"\"\n    Performs hybrid sort on `arr` with threshold `S`\n    Returns (arr, number_of_comparisons)\n    \"\"\"\n    if (len(arr) <= S):\n        return insertion_sort_comparisons(arr, S)\n    \n    num = len(arr) // 2\n    left, left_comparisons = hybrid_sort_comparisons(arr[:num],S)\n    right, right_comparisons = hybrid_sort_comparisons(arr[num:],S)\n    result, number_of_merge_comparisons = merge_comparisons(left, right)\n    return result, left_comparisons + right_comparisons + number_of_merge_comparisons\n```\n\nIt was merge sort, but basically if the array size smaller than a threshold S (I used 7), we would use insertion sort since it has less overhead on smaller arrays.\nI ran some exploratory analysis of the hybrid sort function - varying the size of the array, and recording the average number of comparisons required for both the hybrid sort and the merge sort to completely sort the array.\nHere is the number of comparisons between merge sort and insertion sort\n\nThis made sense, because the number of comparisons should increase as the size of the array to sort increases.\nNow, the interesting thing was when I tried to count the difference in the number of comparisons between merge sort and the hybrid sort. Here was what I found:\n\nI knew that the hybrid sort usually takes more comparisons on average than merge sort (because the hybrid sort part takes roughly $O(nS + n \\log \\frac{n}{S})$ comparisons, while pure merge sort requires $O(n log n)$, so I was expecting to see an upward trending smooth curve.\nHowever, it seems that somewhere a little bit less straightforward. It seems that the curve bounces up and down, and each successive bounce looks like its twice the size of the previous bounce. My guess is that it has something to do with $n/S$, and the ability of evenly splitting $n$ elements into even lists of size $S$, however I am unable to rigorously prove that to myself.\nI would like to know why this pattern emerges.\ntl;dr: Used a hybrid merge-insertion sort where when the array is small enough, I would use insertion sort, else I would do normal merge sort.\nWhen I compared the ```\nnumberOfComparisonsForHybridSort - numberOfComparisonsForMergeSort```\n, it forms this nice pattern of dipping down in ~$2^n$ increments, however I want to know whats going on behind this.\n    ", "Answer": "\r\nConsider the number of merge \"steps\" it takes to start with a run size of 1 or 7, until it reaches the size of an array. For pure merge sort, it's 1->2->4->8-> ... -> >= n. For your hybrid sort, it's 7->14->28->56 ... -> => n, plus the overhead of sorting ceiling(n/7) runs via insertion sort. If array size is equal to or slightly less than a power of 2 times 7, the hybrid sort is probably taking fewer comparisons.\nMost libraries use a higher size for the insertion sort, usually 16 to 96. Visual Studio uses 32.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Algorithm fail\r\n                \r\nI wrote a merge-sort algorithm in python. It works perfectly until 10000 numbers but after 10000 it gives me segmentation fault 11. What might be the problem? Any idea about it\n\n```\ndef merge_count(arr):\n    if len(arr) < 2:\n        return (arr, 0)\n    m = int(len(arr) / 2)\n    left, l_counter = merge_count(arr[:m])\n    right, r_counter = merge_count(arr[m:])\n    return merge(left, right, l_counter + r_counter)\n\n\ndef merge(left, right, counter):\n    if len(left) * len(right) == 0:\n        return (left + right, counter)\n    if left[len(left) - 1] > right[len(right) - 1]:\n        val = left.pop(len(left) - 1)\n        counter += len(right)\n    else:\n        val = right.pop(len(right) - 1)\n    arr, counter = merge(left, right, counter)\n\n    return (arr + [val], counter)\n```\n\n    ", "Answer": "\r\nIt looks like you have a stack overflow. ```\nmerge```\n uses stack space on the order of the size of the lists to merge, which is way more than Python can handle. Ordinarily, Python would stop you with a ```\nRuntimeError```\n before you got to that point; you probably used ```\nsys.setrecursionlimit```\n to go past the safe limit. Stop using ```\nsetrecursionlimit```\n, and rewrite ```\nmerge```\n to not use recursion.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort problem\r\n                \r\nI'm making a menu of all kinds of sorting algorithm and now I'm stuck at merge sort.\nI encountered an error after clicking the execute button. I entered 5 numbers in TextBox1 and another set of 5 numbers in TextBox2. It says that index was outside the bounds of the array. I indicated on the codes where it appeared. Any ideas what is the problem?\n\n```\n    private void ExeButton_Click(object sender, EventArgs e)\n    {\n        string[] numsInString = EntNum.Text.Split(' ');   //split values in textbox\n        string[] numsInString1 = EntNum1.Text.Split(' ');\n        for (int j = 0; j < numsInString.Length; j++)\n        {\n            a[j] = int.Parse(numsInString[j]);\n        }\n        for (int j = 0; j < numsInString1.Length; j++)\n        {\n            b[j] = int.Parse(numsInString1[j]);\n        }\n        {\n            sortArray();\n            Display();\n        }\n\n    }\n\n    public void sortArray()\n    {\n        m_sort(0, 10 - 1);\n    }\n\n    public void m_sort(int left, int right)\n    {\n        int mid;\n\n        if (right > left)\n        {\n            mid = (right + left) / 2;\n            m_sort(left, mid);\n            m_sort(mid + 1, right);\n\n            merge(left, mid + 1, right);\n        }\n    }\n\n    public void merge(int left, int mid, int right)\n    {\n        int i, left_end, num_elements, tmp_pos;\n\n        left_end = mid - 1;\n        tmp_pos = left;\n        num_elements = right - left + 1;\n\n        while ((left <= left_end) && (mid <= right))\n        {\n            if (a[left] <= a[mid])  //index was outside the bounds of the the array\n            {\n                b[tmp_pos] = a[left];\n                tmp_pos = tmp_pos + 1;\n                left = left + 1;\n            }\n            else\n            {\n                b[tmp_pos] = a[mid];\n                tmp_pos = tmp_pos + 1;\n                mid = mid + 1;\n            }\n        }\n\n        while (left <= left_end)\n        {\n            b[tmp_pos] = a[left];\n            left = left + 1;\n            tmp_pos = tmp_pos + 1;\n        }\n\n        while (mid <= right)\n        {\n            b[tmp_pos] = a[mid];\n            mid = mid + 1;\n            tmp_pos = tmp_pos + 1;\n        }\n\n        for (i = 0; i < num_elements; i++)\n        {\n            a[right] = b[right];\n            right = right - 1;\n        }\n    }\n\n\n    private void ClearButton_Click(object sender, EventArgs e)\n    {\n        richTextBox1.Clear();\n    }\n\n    public void Display()\n    {\n        int i;\n        String numbers = \"\";\n        for (i = 0; i < 10; i++)\n        numbers += a[i].ToString() + \"       \";\n        numbers += b[i].ToString() + \"       \";\n        richTextBox1.AppendText(numbers + \"\\n\");\n    }\n```\n\n    ", "Answer": "\r\nRegarding your concrete question: ```\na```\n is an array of 5 elements with the indexes ```\n0, 1, 2, 3, 4```\n, so ```\na[4]```\n is the last element. You start with  ```\nm_sort(0, 10 - 1) =  m_sort(0, 9);```\n.  In ```\nm_sort()```\n you compute\n\n```\nmid = (right + left) / 2 = (9 + 0) / 2 = 4\n```\n\n\nand call \n\n```\nmerge(left, mid + 1, right) = merge(0, 4 + 1, 9) = merge(0, 5, 9).\n```\n\n\nIn ```\nmerge(int left, int mid, int right)```\n you evaluate:\n\n```\nif (a[left] <= a[mid])   i.e.     if (a[0] <= a[5]) \n```\n\n\nso you access ```\na[5]```\n which is out of bounds.\n\nI think your merge sort can be simplified considerably. You might look at the many resources on the Web or in a textbook on algorithms.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "comparisons using merge sort vs selection sort\r\n                \r\nI have an array of 10 int, and using selection sort I calculate it takes about 45 comparisons to sort the whole array, but I'm not sure how many it takes to sort using merge sort by my calculation it takes 12 comparisons.... am I right or wrong here?\n\nThanks in advance\n\nhere's the merge method\n\n```\nstatic void merge(int[] first, int[] second, int[] a)\n    {\n        int iFirst = 0;\n        int iSecond = 0;\n        int i = 0; \n        //moving the smaller element into a\n        while(iFirst < first.length && iSecond < second.length)\n        {\n            if(first[iFirst] < second[iSecond])\n            {\n                a[i] = first[iFirst];\n                iFirst++;\n            }\n            else\n            {\n                a[i] = second[iSecond];\n                iSecond++;\n            } \n            i++;             \n        }\n        counter += i;\n\n        //copying the remaning of the first array\n        while(iFirst < first.length)\n        {\n            a[i] = first[iFirst];\n            iFirst++; i++;\n        }\n        //copying the remaining of second array\n        while(iSecond < second.length)\n        {\n            a[i] = second[iSecond];\n            iSecond++; i++;\n        }        \n    }\n```\n\n    ", "Answer": "\r\nTo merge an ```\nn```\n-element array with an ```\nm```\n-element array, you need ```\nn+m-1```\n comparisons in the worst case (```\nmin{m,n}```\n in the best).\n\nSo when you split the 10-element array in half, the top-level merge needs up to 9 comparisons. The two 5-element halves need up to 4 comparisons each, makes ```\n9 + 2*4 = 17```\n. Splitting the 5-element halves in a 2-element and a 3-element part requires up to 1 + 3 comparisons, so the total worst case would be 25 comparisons (9 + 2*4 + 2*3 + 2*1).\n\n```\n                10(9)                             9\n               /     \\\n              /       \\\n             /         \\\n            /           \\\n           /             \\\n          /               \\\n         /                 \\\n        5(4)               5(4)                   8\n       /   \\              /   \\\n      /     \\            /     \\\n    3(2)     2(1)      3(2)     2(1)              6\n   /   \\    /   \\     /   \\    /   \\\n  2(1)  1  1     1   2(1)  1  1     1             2\n /   \\              /   \\\n1     1            1     1\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Relationship between number of comparisons between merge sort and merge-insertion hybrid sort\r\n                \r\nI was playing around with a merge-insertion sort hybrid, which looks roughly like this:\n```\ndef hybrid_sort_comparisons(arr, S):\n    \"\"\"\n    Performs hybrid sort on `arr` with threshold `S`\n    Returns (arr, number_of_comparisons)\n    \"\"\"\n    if (len(arr) <= S):\n        return insertion_sort_comparisons(arr, S)\n    \n    num = len(arr) // 2\n    left, left_comparisons = hybrid_sort_comparisons(arr[:num],S)\n    right, right_comparisons = hybrid_sort_comparisons(arr[num:],S)\n    result, number_of_merge_comparisons = merge_comparisons(left, right)\n    return result, left_comparisons + right_comparisons + number_of_merge_comparisons\n```\n\nIt was merge sort, but basically if the array size smaller than a threshold S (I used 7), we would use insertion sort since it has less overhead on smaller arrays.\nI ran some exploratory analysis of the hybrid sort function - varying the size of the array, and recording the average number of comparisons required for both the hybrid sort and the merge sort to completely sort the array.\nHere is the number of comparisons between merge sort and insertion sort\n\nThis made sense, because the number of comparisons should increase as the size of the array to sort increases.\nNow, the interesting thing was when I tried to count the difference in the number of comparisons between merge sort and the hybrid sort. Here was what I found:\n\nI knew that the hybrid sort usually takes more comparisons on average than merge sort (because the hybrid sort part takes roughly $O(nS + n \\log \\frac{n}{S})$ comparisons, while pure merge sort requires $O(n log n)$, so I was expecting to see an upward trending smooth curve.\nHowever, it seems that somewhere a little bit less straightforward. It seems that the curve bounces up and down, and each successive bounce looks like its twice the size of the previous bounce. My guess is that it has something to do with $n/S$, and the ability of evenly splitting $n$ elements into even lists of size $S$, however I am unable to rigorously prove that to myself.\nI would like to know why this pattern emerges.\ntl;dr: Used a hybrid merge-insertion sort where when the array is small enough, I would use insertion sort, else I would do normal merge sort.\nWhen I compared the ```\nnumberOfComparisonsForHybridSort - numberOfComparisonsForMergeSort```\n, it forms this nice pattern of dipping down in ~$2^n$ increments, however I want to know whats going on behind this.\n    ", "Answer": "\r\nConsider the number of merge \"steps\" it takes to start with a run size of 1 or 7, until it reaches the size of an array. For pure merge sort, it's 1->2->4->8-> ... -> >= n. For your hybrid sort, it's 7->14->28->56 ... -> => n, plus the overhead of sorting ceiling(n/7) runs via insertion sort. If array size is equal to or slightly less than a power of 2 times 7, the hybrid sort is probably taking fewer comparisons.\nMost libraries use a higher size for the insertion sort, usually 16 to 96. Visual Studio uses 32.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort - Segmentation Error\r\n                \r\nI've been programming in Python for more than a year now, and I just moved back to C++, to learn a few basic algorithms. I started with merge sort, but it gives me a segmentation errror. Help would be greatly appreciated. I think I debugged where it happens, but I'm unable to understand why.\n\n```\n#include <iostream>\nusing namespace std;\nvoid* merge(int array1[], int array2[], int low, int mid, int high){\n    int i, j, k;\n    for (i = low,j = mid, k = low; i < mid, j < high; k++){\n        if (array1[i] < array1[j]){\n            array2[k] = array1[i];\n            i++;\n            }\n        else{\n            array2[k] = array1[j];\n            j++;\n        }\n    }\n    if (i == mid){\n        for (; j < high; j++, k++){\n            array2[k] = array1[j];\n            }\n    }\nelse{\n    for (; i < mid; i++, k++){\n        array2[k] = array1[i];\n    }\n}\nvoid* merge_sort(int array1[], int copy[], int low, int high){\n    int mid;\n    int range = high - low;\n    if (range == 1)\n        copy[low] = array1[low];\n    else{\n        mid = low + range/2;\n        merge_sort(array1, copy, low, mid);\n        // Segmentation error seems to be here.\n        merge_sort(array1, copy, mid, high);\n     }\n     merge(array1, copy, low, mid, high);\n}\n\nint main()\n{\n    int n, temp;\n    cout << \"How many numbers do you want to enter?\" << endl;\n    cin >> n;\n    int numarray[n];\n    for (int i = 0; i < n; i++){\n        cin >> numarray[i];\n    }\n    int dumarray[n];  // Used for filling elements from merge sort\n    merge_sort(numarray, dumarray, 0, n);\n    cout << \"Merge Sort\" << endl;\n    for (int i = 0; i < n; i++){\n        cout << dumarray[i] << endl;\n    } \n    return 0;\n}\n```\n\n\nEDIT:\n\n```\n#include <iostream>\nusing namespace std;\n\nvoid merge_sort(int [], int [], int, int);\n\nvoid merge(int array1[], int array2[], int low, int mid, int high){\n    int i, j, k;\n    for (i = low,j = mid, k = low; i < mid, j < high; k++){\n        if (array1[i] < array1[j]){\n            array2[k] = array1[i];\n            i++;\n            }\n        else{\n            array2[k] = array1[j];\n            j++;\n        }\n    }\n    if (i == mid){\n        for (; j < high; j++, k++){\n            array2[k] = array1[j];\n            }\n    }\n    else{\n        for (; i < mid; i++, k++){\n            array2[k] = array1[i];\n            }\n    }\n}\n\nvoid merge_sort(int array1[], int copy[], int low, int high){\n    int mid;\n    int range = high - low;\n    mid = low + range/2;\n    if (range == 1)\n        copy[low] = array1[low];\n    else{\n        mid = low + range/2;\n        merge_sort(array1, copy, low, mid);\n        merge_sort(array1, copy, mid, high);\n    merge(array1, copy, low, mid, high);\n    }\n}\nint main(){\n    int n, temp;\ncout << \"How many numbers do you want to enter?\" << endl;\ncin >> n;\nint numarray[n];\nfor (int i = 0; i < n; i++){\n    cin >> numarray[i];\n}\n    int dumarray[n];\n    merge_sort(numarray, dumarray ,0, n);\n    for (int i = 0; i < n; i++){\n        cout << dumarray[i] << endl;\n    }\n\n}\n```\n\n    ", "Answer": "\r\nThe calculation for mid value seems to be wrong. Try calculating mid as\n\n```\nmid = low + (high-low)/2```\n\n\nEdit: Move ```\nmerge(array1, copy, low, mid, high);```\ninside the else bracket.\n\n```\nelse\n{\n    mid = low + range/2;\n    merge_sort(array1, copy, low, mid);\n    merge_sort(array1, copy, mid, high);\n    merge(array1, copy, low, mid, high);\n}\n```\n\n\nThe ```\nmerge```\n function also has a lot of bugs. The condition check in the initial for loop\n```\ni < mid, j < high```\n is separated by a comma which means it is only checking for ```\nj < high```\n and discarding condition check for i.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "when is insertion sort faster than merge sort?\r\n                \r\nFor a homework problem, I was told that insertion sort runs at 8n^2 and that merge sort runs at 64(n(lg n)). As part of the solution I was given, it said that insertion sort was faster than merge sort as long as n <= 43, but the teacher's answer doesn't really explain why or how he arrived at 43. Can anyone explain this? I'm not that great with figuring out run times so I'm trying to get a better understanding. And yes, I tried asking the teacher, but I was still confused. Any help would be great! thank you!\n    ", "Answer": "\r\nIt came from this (algebraic) line of reasoning\n\n```\nsteps_in_insertion_sort <= steps_in_merge_sort\n8n^2 <= 64n lg n\nn^2 <= 8n lg n\nn <= 8 lg n\n```\n\n\nThen 43 works by trial and error, or by solving for the zero of the equation n - 8 lg n = 0.\n\nFor hacking by trial and error, note:\n\n```\n$ python\n>>> 8 * log(43)/log(2)\n43.41011803761678\n```\n\n\nBecause \"lg\"  means log-base-two.\n\n(Aside: calculations like this do not really translate to any real-world indication that one algorithm will beat another.  Seriously, exactly 43?)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Addition of merge sort method for a random array\r\n                \r\nI made some code that generates a random array and puts it through a quick sort. However, I need to do the same with a merge sort algorithm, but I'm not sure how. I'm also making sure to have a menu so that the array can be isolated for one sort. Can any one post some ideas on how I can add a merge sort method?\n\n```\n  import java.util.Scanner;\n  import java.util.Random;\n  public class Algo {\n\n  public static void main(String[] args) {\n  Random gen = new Random();\n  Scanner scanner = new Scanner(System.in);\n  int[] a = new int[20];\n\n  for (int i = 0; i < a.length; i++)\n    a[i] = gen.nextInt(100);\n\n  System.out.println(\"1. Quick Sort\");\n  System.out.println(\"2. Merge Sort\");\n  System.out.println(\"what number do you want?\");\n  int choice = scanner.nextInt();\n  if (choice == 1) {\n  System.out.println(\"Quick sort:\");\n  printArray(a);\n  quickSort(a, 0, a.length - 1);\n  printArray(a);\n  }\n  else \n  {\n  System.out.println(\"Merge sort:\");\n  printArray(a);\n  //MERGE SORT NEEDED\n  printArray(a);\n  }\n\n\n}\n\n private static void printArray(int[] a){\n  for (int i : a)\n    System.out.print(i + \" \");\n  System.out.println(\"\");\n}\nprivate static void quickSort(int a[], int left, int right)\n{\n  int i = left, j = right;\n  int tmp;\n  int pivot = a[(left + right) / 2];\n  while (i <= j) {\n        while (a[i] < pivot)\n              i++;\n        while (a[j] > pivot)\n              j--;\n        if (i <= j) {\n              tmp = a[i];\n              a[i] = a[j];\n              a[j] = tmp;\n              i++;\n              j--;\n    }\n}\nif (left < j)\n    quickSort(a, left, j);\nif (i < right)\n        quickSort(a, i, right);\n}\nprivate static void printArrays(int[] a, int tmp){\nSystem.out.println();\nfor (int x = 0; x < a.length; x++){\nSystem.out.print(tmp);\n}\n}\n}\n```\n\n    ", "Answer": "\r\nHere is my java implementation for mergesort. You could modify it as required : \n\n```\npublic class MergeSort\n{\npublic int[] arr;\n\npublic MergeSort( int[] a )\n{\n    arr = a;\n}\n\nprivate void mergeSort( int a, int b )\n{\n    if( a==b )\n        return;\n\n    int mid = ( a+b )/2;\n    mergeSort( a, mid );\n    mergeSort( mid+1, b );\n    merge( a, mid, mid+1, b );\n}\n\npublic void sort()\n{\n    mergeSort( 0, arr.length-1 );\n}\n\nprivate void merge( int a, int m1, int m2, int b )\n{\n    int[] sorted = new int[ b-a+1 ];\n    int i=0, j=0;\n\n    while( ( i<(m1-a+1)) &&( j<( b-m2+1 )) )\n    {\n        if( arr[ a+i ] < arr[ a+j ])\n        {\n            sorted[ i+j ] = arr[ a+i ];\n            i++;\n        }\n\n        else\n        {\n            sorted[ i+j ] = arr[ a+j ];\n            j++;\n        }\n\n    }\n\n    // copy rest of the remaining array\n\n    while( i< (m1-a+1 ))\n    {\n        sorted[ i+j ] = arr[ a+i ];\n        i++;\n    }\n\n    while( j<( b-m2+1 ))\n    {\n        sorted[ i+j ] = arr[ a+j ];\n        j++;\n    }\n    System.arraycopy(sorted, 0, arr, a, b - a + 1);\n}\n\n\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merging both merge sort and heap sort together\r\n                \r\nSuppose you want to improve Merge Sort by first applying Heap Sort to a number of consecutive subarrays. Given an array A, your algorithm subdivides A into subarrays A1, A2 · · · Ak, where k is some power of 2, and applies Heap Sort on each subarray Ai alone. The algorithm proceeds into merging pairs of consecutive subarrays until the array is sorted. For example, if k = 4, you first apply Heap Sort to sort each Ai and then you merge A1 with A2 and A3 with A4, then you apply the merge function once to get the sorted array. (a) Does the proposed algorithm improve the asymptotic running time of Merge Sort when k = 2? How about the case k = log n (or a power of 2 that is closest to log n)? Justify. (b) Is the proposed algorithm stable? Is it in-place? Prove your answers.\nSo I have this problem to solve, I was thinking that for k=2, the threshold value is too low and inefficient, but I'm not sure when k is at logn or more. If 2 sorting algorithms have the same complexity, won’t merging them be pointless in terms of running time? For b), i think the merged algorithim would be stable and not in place.\nwhat do you think?\n    ", "Answer": "\r\n(a) No, for any k this algorithm would not improve the running time of merge sort as it is a comparison-based sorting algorithm and it can be proven that any such algorithm is Ω(n ln n), and merge sort already is O(n ln n).\n(b) This algorithm can be in-place because heap sort is an in-place algorithm (using standard binary max heap implementation with array) and there exists an in-place stable merging algorithm. This algorithm can also be made stable using any stable merging and stable heap sort (can be achieved by using pairs (value, initial position) in the heap and lexicographic comparison). Making this algorithm both stable and in-place requires a stable in-place heap and as far as I know, such heap has not yet been invented.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort problem\r\n                \r\nI'm making a menu of all kinds of sorting algorithm and now I'm stuck at merge sort.\nI encountered an error after clicking the execute button. I entered 5 numbers in TextBox1 and another set of 5 numbers in TextBox2. It says that index was outside the bounds of the array. I indicated on the codes where it appeared. Any ideas what is the problem?\n\n```\n    private void ExeButton_Click(object sender, EventArgs e)\n    {\n        string[] numsInString = EntNum.Text.Split(' ');   //split values in textbox\n        string[] numsInString1 = EntNum1.Text.Split(' ');\n        for (int j = 0; j < numsInString.Length; j++)\n        {\n            a[j] = int.Parse(numsInString[j]);\n        }\n        for (int j = 0; j < numsInString1.Length; j++)\n        {\n            b[j] = int.Parse(numsInString1[j]);\n        }\n        {\n            sortArray();\n            Display();\n        }\n\n    }\n\n    public void sortArray()\n    {\n        m_sort(0, 10 - 1);\n    }\n\n    public void m_sort(int left, int right)\n    {\n        int mid;\n\n        if (right > left)\n        {\n            mid = (right + left) / 2;\n            m_sort(left, mid);\n            m_sort(mid + 1, right);\n\n            merge(left, mid + 1, right);\n        }\n    }\n\n    public void merge(int left, int mid, int right)\n    {\n        int i, left_end, num_elements, tmp_pos;\n\n        left_end = mid - 1;\n        tmp_pos = left;\n        num_elements = right - left + 1;\n\n        while ((left <= left_end) && (mid <= right))\n        {\n            if (a[left] <= a[mid])  //index was outside the bounds of the the array\n            {\n                b[tmp_pos] = a[left];\n                tmp_pos = tmp_pos + 1;\n                left = left + 1;\n            }\n            else\n            {\n                b[tmp_pos] = a[mid];\n                tmp_pos = tmp_pos + 1;\n                mid = mid + 1;\n            }\n        }\n\n        while (left <= left_end)\n        {\n            b[tmp_pos] = a[left];\n            left = left + 1;\n            tmp_pos = tmp_pos + 1;\n        }\n\n        while (mid <= right)\n        {\n            b[tmp_pos] = a[mid];\n            mid = mid + 1;\n            tmp_pos = tmp_pos + 1;\n        }\n\n        for (i = 0; i < num_elements; i++)\n        {\n            a[right] = b[right];\n            right = right - 1;\n        }\n    }\n\n\n    private void ClearButton_Click(object sender, EventArgs e)\n    {\n        richTextBox1.Clear();\n    }\n\n    public void Display()\n    {\n        int i;\n        String numbers = \"\";\n        for (i = 0; i < 10; i++)\n        numbers += a[i].ToString() + \"       \";\n        numbers += b[i].ToString() + \"       \";\n        richTextBox1.AppendText(numbers + \"\\n\");\n    }\n```\n\n    ", "Answer": "\r\nRegarding your concrete question: ```\na```\n is an array of 5 elements with the indexes ```\n0, 1, 2, 3, 4```\n, so ```\na[4]```\n is the last element. You start with  ```\nm_sort(0, 10 - 1) =  m_sort(0, 9);```\n.  In ```\nm_sort()```\n you compute\n\n```\nmid = (right + left) / 2 = (9 + 0) / 2 = 4\n```\n\n\nand call \n\n```\nmerge(left, mid + 1, right) = merge(0, 4 + 1, 9) = merge(0, 5, 9).\n```\n\n\nIn ```\nmerge(int left, int mid, int right)```\n you evaluate:\n\n```\nif (a[left] <= a[mid])   i.e.     if (a[0] <= a[5]) \n```\n\n\nso you access ```\na[5]```\n which is out of bounds.\n\nI think your merge sort can be simplified considerably. You might look at the many resources on the Web or in a textbook on algorithms.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort implementation query\r\n                \r\nI found this example of a merge sort algorithm online on a tutorial webpage and I have been trying to understand ow the code implements the algorithm. The example i found uses recursion and a temporary array to sort the array of unsorted algorithms.\n  My query is in the final step of the process. When copying the elements of the temporary array into the original array to sort the array. why does the algorithm decrements the right attribute instead of incrementing the left attribute? when i incremented the left left value the algorithm does not work.\n\n```\nclass Assignment1\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"Size of array:\");\n        int n = Convert.ToInt16(Console.ReadLine());\n        int[] unsorted = new int[n];\n\n        for(int i = 0; i < n; i++)\n        {\n            Console.WriteLine(\"Enter a number:\");\n            unsorted[i] = Convert.ToInt16(Console.ReadLine());\n        }\n\n        Console.WriteLine(\"--------Sort---------\");\n\n        Recursion_Sort(unsorted, 0, n - 1);\n        for (int i = 0; i < n; i++)\n        {\n              Console.WriteLine(unsorted[i]);\n        }\n    }\n\n    static public void Merge(int[] numbers, int left, int mid, int right, int n)\n    {\n\n        int[] tempArray = new int[n];\n\n        int i, lEnd, size, pos;\n\n\n\n        lEnd = mid - 1;\n        pos = left;\n        size = (right - left + 1);\n\n\n        while ((left <= lEnd) && (mid <= right))\n        {\n\n            if (numbers[left] <= numbers[mid])\n            {\n\n                tempArray[pos] = numbers[left];\n                pos++;\n                left++;\n            }\n\n            else\n            {\n\n                tempArray[pos] = numbers[mid];\n                pos++;\n                mid++;\n            }\n        }\n\n\n\n        while (left <= lEnd)\n        {\n            tempArray[pos] = numbers[left];\n            pos++;\n            left++;\n        }\n\n\n        while (mid <= right)\n        {\n            tempArray[pos] = numbers[mid];\n            pos++;\n            mid++;\n        }\n        Console.WriteLine(tempArray.Length);\n\n\n        for (i = 0; i < size; i++)\n        {\n            numbers[right] = tempArray[right];\n            right--;\n        }\n    }\n\n    static public void Recursion_Sort(int[] numbers, int left, int right)\n    {\n\n        int mid;\n\n        if (right > left)\n        {\n            mid = (right + left) / 2;\n\n\n            Recursion_Sort(numbers, left, mid);\n            Recursion_Sort(numbers, (mid + 1), right);\n            // we then merge the sorted sub arrays using the merge method\n            Merge(numbers, left, (mid + 1), right, numbers.Length);\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\n```\nleft```\n value is changing during merge and as you have code block \n\n\n  while (left <= lEnd)\n  {\n  //...\n  left++;\n  }  \n\n\n```\nleft```\n will be finally assigned to ```\nlEnd + 1```\n(the condition for ending while loop).\nOtherwise ```\nright```\n is not changing and is the last index of currently manipulated sequence. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort: sorting a list with mixed elements\r\n                \r\nI'm writing a merge sort in Scheme. I have a merge sort definition, a splitter which splits the list, and a merge which merges the list.\n\n```\n(define mymergesort\n  (lambda (alist)\n    (if (null? (cdr alist)) alist\n        (let ((splits (splitter alist)))\n          (merge (mymergesort (car splits)) (mymergesort (cadr splits)))))))\n\n(define splitter\n  (λ (alist) (splitter-helper alist () ())))\n\n(define splitter-helper\n  (λ (alist list_a list_b)\n    (cond ((null? alist) (cons (reverse list_a) (cons list_b ())))\n          ((null? (cdr alist)) (cons (reverse (cons (car alist) list_a)) (cons list_b ())))\n           (else (splitter-helper (reverse (cdr (reverse (cdr alist)))) (cons (car alist) list_a) (cons (car (reverse (cdr alist))) list_b))))))\n\n(define merge\n  (λ (list_a list_b)\n    (cond ((null? list_a) list_b)\n          ((null? list_b) list_a)\n          ((<= (car list_a) (car list_b)) (cons (car list_a) (merge (cdr list_a) list_b)))\n          ((<= (car list_b) (car list_a)) (cons (car list_b) (merge list_a (cdr list_b)))))))\n```\n\n\nThis implementation seems to work just fine for sorting a list of numbers. But I want to be able to sort a list of mixed elements.\n\nFor example:\n'(I can \"go\" 4 \"about\" 123 sodas k?)\n\nAny suggestions/solutions? I'm also trying to avoid the use of most procedures like length that \"cheat\" around recursive solutions.\n    ", "Answer": "\r\nYou would need a 'heuristic' that ranks those items. For instance, does \"go\" come before \"about\"? What about 4? So you could write a function to determine if one element you want to sort is '<=' to another element. Also,\n\n```\n(<= (car list_a) (car list_b))```\n and then ```\n(<= (car list_b) (car list_a))```\n is kind of redundant. If a is not <= b, then we know a > b.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort not working [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have been working on merge sort and I have written some code for it but it is not working as per the given algorithm. I exactly did according to the algorithm but seems like something is wrong. Please anyone let me know whats wrong. \n\n```\n#include<stdio.h>\n\nint main(){\n    int a[] = {5, 3, 2, 4, 9, 1, 11, 6, 10};\n    mergeSort(a, 0, sizeof(a)/ sizeof(int));\n    printArray(a);\n}\n\nvoid mergeSort(int a[], int low, int high){\n    int med;\n    if(high - low > 1){\n        med = (high - low) / 2 + low;\n        mergeSort(a, low, med);\n        mergeSort(a, med+1, high);\n        merge(a, low, med, high);\n    }\n}\nvoid printArray(int a[]){\n    int i;\n    for(i = 0; i < 9; i++){\n        printf(\"%d \", a[i]);\n    }\n    printf(\"\\n\");\n}\nvoid merge(int a[], int low, int med, int high){\n    int i = 0, j = 0, k = low;\n    int a1[9];\n    int a2[9];\n    for(i = 0; i < med; i++){\n        a1[i] = a[i];\n    }\n\n    for(i = med; i < high; i++){\n        a2[i] = a[i];\n    }\n\n    while(i < high - med && j < med - low){\n        if(a1[i] <= a2[j]){\n            a[k] = a1[i];\n            i++;\n        }else{\n            a[k] = a2[j];\n            j++;\n        }\n    }\n\n    while(i < high - med){\n        a[k] = a1[i];\n        i++;\n    }\n\n    while(j < med - low){\n        a[k] = a2[j];\n        j++;\n    }\n\n}\n```\n\n\nAlgorithm : https://i.stack.imgur.com/f73Zi.jpg\n    ", "Answer": "\r\nI'm not sure where you got that algorithm from but the end of it (the 2 last while loops) is incorrect. You also copied parts of it down wrong. I'll leave out stuff that didn't change and is unnecessary.\n\nAll of my comments indicate where code changed.\n\n```\nvoid mergeSort(int a[], int low, int high){\n    int med;\n    if(high - low > 1){\n        med = (high - low) / 2 + low;\n        mergeSort(a, low, med);\n        mergeSort(a, med, high); //you copied this down wrong. med NOT med + 1\n        merge(a, low, med, high);\n    }\n}\nvoid merge(int a[], int low, int med, int high){\n    int i = 0;\n    int j = 0;\n    int k = low;\n    int a1[9];\n    int a2[9];\n    for(i = 0; i < med; i++){\n        //algorithm states to copy by doing: a1[0 -> med] = a[low -> med - 1]\n        //we're copying the subarray 'a' from 'low' to 'med - 1' into\n        //'a1' from 0 to 'med'\n        a1[i] = a[i + low];\n    }\n\n    for(i = med; i < high; i++){\n        //algorithm states to copy by doing: a2[0 -> med] = a[med -> high - 1]\n        a2[i - med] = a[i];\n    }\n\n    //don't forget to reset i to 0\n    i = 0;\n\n    while(i < med - low && j < high - med){\n        if(a1[i] <= a2[j]){\n            a[k] = a1[i];\n            i++;\n        }else{\n            a[k] = a2[j];\n            j++;\n        }\n        k++;\n    }\n\n    while(i < med - low){\n        a[k] = a1[i];\n        i++;\n        k++;\n        //algorithm didn't have k++ for some reason\n    }\n\n    while(j < high - med){\n        //note it's a2[j] not a2[i]\n        //algorithm was wrong here\n        a[k] = a2[j];\n        j++;\n        k++;\n        //didn't have k++ here either\n    }\n}\n```\n\n\nThe last 3 while loops can be made shorter with post-increment operators in the array index since we know our intent is to increment them after the statement has completed (hence post-increment).\n\n```\n    while(i < med - low && j < high - med){\n        if(a1[i] <= a2[j])\n            a[k++] = a1[i++];\n        else\n            a[k++] = a2[j++];\n    }\n\n    while(i < med - low)\n        a[k++] = a1[i++];\n\n    while(j < high - med)\n        a[k++] = a2[j++];\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort algorithm advice\r\n                \r\nI have made a program that sorts a list using a merge sort algorithm. \n\nThe problem is that I think it should work but it is not working, the merge function returns a array that was sent as parameter. Can you please see the code I wrote and tell me what is wrong, and how it can be improved.\n\nThanks\n\n```\nvoid merge_sort(int *niz, int low, int medium, int high) {\n\nint *niz2 = new int[high-low];\n\nint bottom = low;\nint top = medium + 1;\n\nfor (int f1=low; f1<high-low; f1++) {\n    if (low > medium) {\n        niz2[f1] = niz[top++];\n    }\n    else if (top > high) {\n        niz2[f1] = niz[bottom++];\n    }\n    else if (niz[bottom] < niz[top]) {\n        niz2[f1] = niz[bottom++];\n    }\n    else {\n        niz2[f1] = niz[top++];\n    }\n}\nniz = niz2;\n}\n\nvoid merge(int *niz, int low, int high) {\nif (low < high) {\n    int medium = (high+low)/2;\n    merge(niz, low, medium);\n    merge(niz, medium+1, high);\n    merge_sort(niz, low, medium, high);        \n}\n}\n```\n\n\nThe output of program:\n\n```\n3 5 2 3 4 9 5 2 7 10 \n3 5 2 3 4 9 5 2 7 10 \n```\n\n    ", "Answer": "\r\nYou are passing the pointer by value, so the value you assign to ```\nniz```\n inside function is not visible in caller function.\n\nYour signatures should be \n```\nvoid merge(int niz[], int low, int medium, int high)```\n and\n```\nvoid merge_sort(int niz[], int low, int high)```\n.\n\nIn ```\nmerge```\n which you have named ```\nmerge_sort```\n, at the bottom, then you should copy back the contents from ```\nniz2```\n to ```\nniz```\n, instead of ```\nniz = niz2```\n.\n\n*EDIT - *\nAlso you have got the ```\nmerge```\n function wrong (which you have named ```\nmerge_sort```\n). If say you call the function with ```\nlow = 100```\n, ```\nmedium = 120```\n, ```\nhigh = 140```\n.\n\nThen ```\nfor (int f1=low; f1<high-low; f1++)```\n would never loop.\n\nIt should be ```\nfor (int f1=0; f1<high-low; f1++)```\n. One another consequence of above mistake is ```\nSIGSGV```\n, because you would be accessing, ```\nniz2```\n out of bounds (for the given example).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort not working in all cases\r\n                \r\nI have written following code for merge sort:\n\n```\n#include <stdio.h>\n\nvoid mergeSort(int array[],int left, int right);\n\nvoid mergeArray(int array[],int left,int middle, int right);\n\nvoid mergeArray(int array[],int left,int middle, int right)\n{\n\n    int n1 = middle - left + 1;\n    int n2 = right - middle ;\n\n    int temp_a[n1];\n    int temp_b[n2];\n\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\n    for ( i = left ; i <= middle ; i++ )\n    {\n        temp_a[k++] = array[i];\n    }\n\n    for ( i = middle + 1 ; i < right + 1; i++ )\n    {\n        temp_b[j++] = array[i];\n    }\n\n    // now merge these two arrays\n\n\n     i = 0;\n     j = 0;\n     k = 0;\n\n\n    while ( i < n1 && j < n2 )\n    {\n        if ( temp_a[i] < temp_b[j])\n        {\n            array[k++] = temp_a[i++];\n\n        }\n        else\n        {\n            array[k++] = temp_b[j++];\n        }\n    }\n\n    while ( i < n1 )\n    {\n        array[k++] = temp_a[i++];       \n    }\n\n    while ( j < n2 )\n    {\n        array[k++] = temp_b[j++];\n    }\n\n\n\n}\n\n\nvoid mergeSort(int array[],int left, int right)\n{\n    // since there is only one element in the array.\n    printf(\"I am in merge sort. left : %d, right : %d\\n\",left,right);\n    if ( right - left < 1 )\n    {\n        return;\n    }\n    else\n    {\n        int middle = ( right - left ) / 2 ;\n        mergeSort( array,left, middle );    \n        mergeSort( array, middle +1 , right);\n\n        mergeArray(array,left,middle,right);\n    }\n\n\n}\n\nint main(int argc, char const *argv[])\n{\n    int n = 3;\n    int i;\n\n    int array[] = { 12,11,14,19};\n\n    mergeSort(array,0,n);\n    printf(\"\\nArray is: \\n\");\n\n    for (i = 0; i <= n; ++i)\n    {\n        printf(\"%d\\n\",array[i] );\n    }\n    return 0;\n}\n```\n\n\nThe above code is working for ```\nn = 1```\n and ```\nn = 2```\n but not for other values. \n    ", "Answer": "\r\nThree problems:  (1) in ```\nmergeArray```\n, you used ```\nn1```\n in place of ```\nn2```\n for ```\ntemp_b```\n.  Change it to:\n\n```\nint temp_b[n2];\n```\n\n\n(2) After creating ```\ntemp_a```\n and ```\ntemp_b```\n, after the comment \"now merge these two arrays\", you need to set ```\nk```\n to ```\nleft```\n rather than ```\n0```\n:\n\n```\nk = left;\n```\n\n\n(3) In mergeSort, your expression for ```\nmiddle```\n is incorrect, you need to add rather than subtract:\n\n```\nint middle = ( right + left ) / 2 ;\n```\n\n\nIt should work with these three changes.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Logical Error\r\n                \r\nI was actually working on assignment and found an online code on merge sort and edited it a bit, but It is giving logical error, the answer (sorted array) isn't showing up instead it shows only first 2 numbers correctly(sometimes) and I can't fix it, if you could check on my code and give me a few ideas.\n\n```\n#include<stdio.h>\n\nint arr[20];       // array to be sorted\n\nint main()\n{\n\n  int n,i;\n  clrscr();\n  printf(\"Enter the size of array\\n\");  // input the elements\n  scanf(\"%d\",&n);\n  printf(\"Enter the elements:\");\n  for(i=0; i<n; i++)\n    scanf(\"%d\",&arr[i]);\n\n  merge_sort(arr,0,n-1);  // sort the array\n\n  printf(\"Sorted array:\");  // print sorted array\n  for(i=0; i<n; i++)\n    printf(\"%d\",arr[i]);\n   getch();\n  return 0;\n}\n\nint merge_sort(int arr[],int low,int high)\n{\n  int mid; int i;\n  if(low<high) {\n\n    mid=(low+high)/2;\n    // Divide and Conquer\n    merge_sort(arr,low,mid);\n    merge_sort(arr,mid+1,high);\n    // Combine\n\n\n    merge(arr,low,mid,high);\n  }\n\n  return 0;\n}\n\nint merge(int arr[],int l,int m,int h)\n{\n  int arr1[10],arr2[10];  // Two temporary arrays to\n  //hold the two arrays to be merged\n  int n1,n2,i,j,k,z;\n\n    i=0,j=0;\n\n    for(z=l;z<=m;z++)\n    {\n        arr1[i]=arr[z];\n        i++;\n    }\n    for(z=m+1;z<=h;z++)\n    {\n        arr2[j]=arr[z];\n        j++;\n    }\n\n\n\n\n  n1=i;\n  n2=j;\n  i=0;\n  j=0;\n  for(k=l; k<=h; k++)\n  { //process of combining two sorted arrays\n\n    if(i<n1 && j<n2)\n    {\n     if(arr1[i]<=arr2[j])\n     {\n          arr[k]=arr1[i++];\n          }\n    else\n         arr[k]=arr2[j++];\n     }\n     else if(i>=n1)\n     {\n      arr[k]=arr[j++];\n     }\n     else\n     {\n     arr[k]=arr[i++];\n     }\n\n\n  }\n\n  return 0;\n}\n```\n\n    ", "Answer": "\r\nwrong part\n\n```\n     else if(i>=n1)\n     {\n      arr[k]=arr[j++];\n     }\n     else\n     {\n     arr[k]=arr[i++];\n     }\n```\n\n\ncorrected (use ```\narr1```\n and ```\narr2```\n instead of ```\narr```\n as the source of assignments)\n\n```\n     else if(i>=n1)\n     {\n      arr[k]=arr2[j++];\n     }\n     else\n     {\n     arr[k]=arr1[i++];\n     }\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge Sort Algorithm Implementation\r\n                \r\nI am a newbie to Algorithm. I try to implement recursive merge sorting using ```\nstd::vector```\n. But I am stuck. The code does not work. \n\nI have looked at the algorithm from Introduction To Algorithms, Cormen/Leiserson/Rivest/Stein 3rd edition. The pseudocode which is I try to implement.\n\nHere my merge function:\n\n```\nvoid merge(std::vector<int>& vec, size_t vec_init, size_t vec_mid, size_t vec_size) {\n  int leftLoop = 0;\n  int rightLoop = 0;\n  int vecLoop = 0;\n  size_t mid = vec_mid - vec_init + 1;\n\n  std::vector<int> Left_Vec(std::begin(vec), std::begin(vec) + mid);\n  std::vector<int> Right_Vec(std::begin(vec) + mid, std::end(vec));\n\n  for (size_t vecLoop = vec_init; vecLoop<vec_size; ++vecLoop) {\n      vec[vecLoop] = (Left_Vec[leftLoop] <= Right_Vec[rightLoop]) ? Left_Vec[leftLoop++] : Right_Vec[rightLoop++];\n  }\n}\n```\n\n\nAnd here my Merge-Sort function\n\n```\nvoid merge_sort(std::vector<int>& vec, size_t vec_init, size_t vec_size) {\n    if (vec_init < vec_size) {\n      size_t vec_mid = (vec_init + vec_size) / 2;\n      merge_sort(vec, vec_init, vec_mid);\n      merge_sort(vec, vec_mid + 1, vec_size);\n      merge(vec, vec_init, vec_mid, vec_size);\n   }\n} \n```\n\n\nWhen the input ```\nvec = {30,40,20,10}```\n, the output ```\nvec = {10, 10, 0, 20}```\n:\n\n```\nint main() {\n    auto data = std::vector{ 30, 40, 20, 10 };\n    merge_sort(data, 0, data.size());\n    for (auto e : data) std::cout << e << \", \";\n    std::cout << '\\n';\n    // outputs 10, 10, 0, 20, \n}\n```\n\n\nWhere is my mistake about the algorithm or code?\n    ", "Answer": "\r\nThere are a couple of problems. These changes will fix the code:\n\n```\nvoid merge(std::vector<int>& vec, size_t vec_start, size_t vec_mid, size_t vec_end) {\n  size_t leftLoop = 0;\n  size_t rightLoop = 0;\n  size_t vecLoop = 0;\n  // Not needed, much simpler if mid is relative to vec.begin()\n  //size_t mid = vec_mid - vec_init + 1;\n\n  // You didn't take vec_init and vec_size into account when calculating the ranges.\n  std::vector<int> Left_Vec(std::begin(vec) + vec_start, std::begin(vec) + vec_mid);\n  std::vector<int> Right_Vec(std::begin(vec) + vec_mid, std::begin(vec) + vec_end);\n\n  // Values are not uniformly distributed in the left and right vec. You have to check for\n  // running out of elements in any of them.\n  for (/*size_t*/ vecLoop = vec_start; leftLoop < Left_Vec.size() && rightLoop < Right_Vec.size(); ++vecLoop) {\n    //   ^~~~~ shadowed outer vecLoop  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    vec[vecLoop] = Left_Vec[leftLoop] <= Right_Vec[rightLoop] ? Left_Vec[leftLoop++] : Right_Vec[rightLoop++];\n  }\n\n  // Copy the rest of the values into vec.\n  if (leftLoop == Left_Vec.size())\n    std::copy(Right_Vec.begin() + rightLoop, Right_Vec.end(), vec.begin() + vecLoop);\n  else\n    std::copy(Left_Vec.begin() + leftLoop, Left_Vec.end(), vec.begin() + vecLoop);\n}\n\nvoid merge_sort(std::vector<int>& vec, size_t vec_start, size_t vec_end) {\n  // Should only run the function if there are at least 2 elements, otherwise vec_mid\n  // would be always at least vec_start + 1 and the recursion would never stop.\n  if (vec_end - vec_start >= 2) {\n    size_t vec_mid = (vec_start + vec_end) / 2;\n    merge_sort(vec, vec_start, vec_mid);\n    merge_sort(vec, vec_mid /* + 1 */, vec_end);\n    //                         ^~~ + 1 here would skip an element\n    merge(vec, vec_start, vec_mid, vec_end);\n  }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Go Golang : Merge Sort Stack Overflow\r\n                \r\nhttp://play.golang.org/p/rRccL6YHtQ\n\nI just implement the same code as in CLRS\n\n```\nPseudocode from CLRS\n\nMerge-Sort(A, p, r)\n    if p < r\n        q = [(q+r)/2]\n        Merge-Sort(A, p, q)\n        Merge-Sort(A, q+1, r)\n        Merge(A, p, q, r)\n\nMerge(A, p, q, r)\n    n_1 = q - p + 1\n    n_2 = r - q\n    let L[1 .. n_1 + 1]  and R[1 .. n_2 + 1] be new arrays\n\n    for i = 1 to n_1\n            L[i] = A[p+i-1]\n\n    for j = 1 to n_2\n            R[j] = A[q+j]\n\n    L[n_1 + 1] = INFINITE\n    R[n_2 + 1] = INFINITE\n    i = 1\n    j = 1\n\n    for k = p to r\n        if L[i] <= R[j]\n                A[k] = L[i]\n                i = i + 1\n        else A[k] = R[j]\n                j = j + 1\n```\n\n\nBut I am getting the stack overflow in the merge sort.\n\n```\n        [9 -13 4 -2 3 1 -10 21 12]\n        runtime: goroutine stack exceeds 250000000-byte limit\n        fatal error: stack overflow\n\n        runtime stack:\n        runtime.throw(0x1b4980, 0x20280)\n```\n\n\nHow do I make this work?\n\n```\n        func MergeSort(slice []int, first, last int) {\n\n            if len(slice) < 2 {\n                return\n            }\n\n            if first < last {\n                mid := len(slice) / 2\n                MergeSort(slice, first, mid)\n                MergeSort(slice, mid+1, last)\n                Merge(slice, first, mid, last)\n            }\n        }\n```\n\n\nthanks a lot!\n    ", "Answer": "\r\n```\nmid := len(slice) / 2\n```\n\n\nThat's not where the middle should go. The middle is  supposed to be halfway between ```\nfirst```\n and ```\nlast```\n, which define the region of the slice you're sorting, not halfway through the slice. Alternatively, you can slice the slice to make new slices and drop ```\nfirst```\n and ```\nlast```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort algorithm advice\r\n                \r\nI have made a program that sorts a list using a merge sort algorithm. \n\nThe problem is that I think it should work but it is not working, the merge function returns a array that was sent as parameter. Can you please see the code I wrote and tell me what is wrong, and how it can be improved.\n\nThanks\n\n```\nvoid merge_sort(int *niz, int low, int medium, int high) {\n\nint *niz2 = new int[high-low];\n\nint bottom = low;\nint top = medium + 1;\n\nfor (int f1=low; f1<high-low; f1++) {\n    if (low > medium) {\n        niz2[f1] = niz[top++];\n    }\n    else if (top > high) {\n        niz2[f1] = niz[bottom++];\n    }\n    else if (niz[bottom] < niz[top]) {\n        niz2[f1] = niz[bottom++];\n    }\n    else {\n        niz2[f1] = niz[top++];\n    }\n}\nniz = niz2;\n}\n\nvoid merge(int *niz, int low, int high) {\nif (low < high) {\n    int medium = (high+low)/2;\n    merge(niz, low, medium);\n    merge(niz, medium+1, high);\n    merge_sort(niz, low, medium, high);        \n}\n}\n```\n\n\nThe output of program:\n\n```\n3 5 2 3 4 9 5 2 7 10 \n3 5 2 3 4 9 5 2 7 10 \n```\n\n    ", "Answer": "\r\nYou are passing the pointer by value, so the value you assign to ```\nniz```\n inside function is not visible in caller function.\n\nYour signatures should be \n```\nvoid merge(int niz[], int low, int medium, int high)```\n and\n```\nvoid merge_sort(int niz[], int low, int high)```\n.\n\nIn ```\nmerge```\n which you have named ```\nmerge_sort```\n, at the bottom, then you should copy back the contents from ```\nniz2```\n to ```\nniz```\n, instead of ```\nniz = niz2```\n.\n\n*EDIT - *\nAlso you have got the ```\nmerge```\n function wrong (which you have named ```\nmerge_sort```\n). If say you call the function with ```\nlow = 100```\n, ```\nmedium = 120```\n, ```\nhigh = 140```\n.\n\nThen ```\nfor (int f1=low; f1<high-low; f1++)```\n would never loop.\n\nIt should be ```\nfor (int f1=0; f1<high-low; f1++)```\n. One another consequence of above mistake is ```\nSIGSGV```\n, because you would be accessing, ```\nniz2```\n out of bounds (for the given example).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge Sort Algorithm Implementation\r\n                \r\nI am a newbie to Algorithm. I try to implement recursive merge sorting using ```\nstd::vector```\n. But I am stuck. The code does not work. \n\nI have looked at the algorithm from Introduction To Algorithms, Cormen/Leiserson/Rivest/Stein 3rd edition. The pseudocode which is I try to implement.\n\nHere my merge function:\n\n```\nvoid merge(std::vector<int>& vec, size_t vec_init, size_t vec_mid, size_t vec_size) {\n  int leftLoop = 0;\n  int rightLoop = 0;\n  int vecLoop = 0;\n  size_t mid = vec_mid - vec_init + 1;\n\n  std::vector<int> Left_Vec(std::begin(vec), std::begin(vec) + mid);\n  std::vector<int> Right_Vec(std::begin(vec) + mid, std::end(vec));\n\n  for (size_t vecLoop = vec_init; vecLoop<vec_size; ++vecLoop) {\n      vec[vecLoop] = (Left_Vec[leftLoop] <= Right_Vec[rightLoop]) ? Left_Vec[leftLoop++] : Right_Vec[rightLoop++];\n  }\n}\n```\n\n\nAnd here my Merge-Sort function\n\n```\nvoid merge_sort(std::vector<int>& vec, size_t vec_init, size_t vec_size) {\n    if (vec_init < vec_size) {\n      size_t vec_mid = (vec_init + vec_size) / 2;\n      merge_sort(vec, vec_init, vec_mid);\n      merge_sort(vec, vec_mid + 1, vec_size);\n      merge(vec, vec_init, vec_mid, vec_size);\n   }\n} \n```\n\n\nWhen the input ```\nvec = {30,40,20,10}```\n, the output ```\nvec = {10, 10, 0, 20}```\n:\n\n```\nint main() {\n    auto data = std::vector{ 30, 40, 20, 10 };\n    merge_sort(data, 0, data.size());\n    for (auto e : data) std::cout << e << \", \";\n    std::cout << '\\n';\n    // outputs 10, 10, 0, 20, \n}\n```\n\n\nWhere is my mistake about the algorithm or code?\n    ", "Answer": "\r\nThere are a couple of problems. These changes will fix the code:\n\n```\nvoid merge(std::vector<int>& vec, size_t vec_start, size_t vec_mid, size_t vec_end) {\n  size_t leftLoop = 0;\n  size_t rightLoop = 0;\n  size_t vecLoop = 0;\n  // Not needed, much simpler if mid is relative to vec.begin()\n  //size_t mid = vec_mid - vec_init + 1;\n\n  // You didn't take vec_init and vec_size into account when calculating the ranges.\n  std::vector<int> Left_Vec(std::begin(vec) + vec_start, std::begin(vec) + vec_mid);\n  std::vector<int> Right_Vec(std::begin(vec) + vec_mid, std::begin(vec) + vec_end);\n\n  // Values are not uniformly distributed in the left and right vec. You have to check for\n  // running out of elements in any of them.\n  for (/*size_t*/ vecLoop = vec_start; leftLoop < Left_Vec.size() && rightLoop < Right_Vec.size(); ++vecLoop) {\n    //   ^~~~~ shadowed outer vecLoop  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    vec[vecLoop] = Left_Vec[leftLoop] <= Right_Vec[rightLoop] ? Left_Vec[leftLoop++] : Right_Vec[rightLoop++];\n  }\n\n  // Copy the rest of the values into vec.\n  if (leftLoop == Left_Vec.size())\n    std::copy(Right_Vec.begin() + rightLoop, Right_Vec.end(), vec.begin() + vecLoop);\n  else\n    std::copy(Left_Vec.begin() + leftLoop, Left_Vec.end(), vec.begin() + vecLoop);\n}\n\nvoid merge_sort(std::vector<int>& vec, size_t vec_start, size_t vec_end) {\n  // Should only run the function if there are at least 2 elements, otherwise vec_mid\n  // would be always at least vec_start + 1 and the recursion would never stop.\n  if (vec_end - vec_start >= 2) {\n    size_t vec_mid = (vec_start + vec_end) / 2;\n    merge_sort(vec, vec_start, vec_mid);\n    merge_sort(vec, vec_mid /* + 1 */, vec_end);\n    //                         ^~~ + 1 here would skip an element\n    merge(vec, vec_start, vec_mid, vec_end);\n  }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in scilab\r\n                \r\nI implemented merge sort in scilab with the following code:\n```\n   function x = mergesortre (x)\n    n = length (x);\n    if ( n > 1 ) then\n    m = floor (n/2);\n    p = n-m;\n    x1 = mergesortre ( x(1:m) );\n    x2 = mergesortre ( x(m+1:n)  );\n    x = merge ( x1 , x2  );\n    end\n    endfunction\n    function [x] = merge ( x1 , x2 )\n    n1 = length (x1);\n    n2 = length (x2);\n    n = n1 + n2;\n    x = [];\n    i = 1\n    j = 1\n    k = 1\n    while(j<=n1 && k<=n2)\n          if x1(j)>=x2(k) \n             x(i)=x2(k);\n              k=k+1;\n             i=i+1;\n    elseif x1(j)<x2(k) \n             x(i)=x1(j);\n             j=j+1;\n             i=i+1;\n    end\n    end            \n    if (j > n1) then\n    x(i+1:n) = x2(k:n2);\n    else\n    x(i+1:n) = x1(j:n1);\n    end\n    endfunction\n    a=[5,4,3,2,1];\n    x=mergesortre(a);\n    disp x;\n```\n\nHowever in when i try to see the sorted array using the terminal window its showing only the first element,for example if my array is [5,4,3,2,1] its only giving output as 1. I need help understanding what i did wrong.\n    ", "Answer": "\r\nYour error is in the ```\nmerge```\n function. As ```\ni```\n is already incremented at the end of the loop you have to concatenate starting at ```\ni```\n:\n```\nif (j > n1) then\n    x(i:n) = x2(k:n2);\nelse\n    x(i:n) = x1(j:n1);\nend\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Error in merge sort program\r\n                \r\nI am doing a merge sort program in C but I'm getting some unexpected output.\nCan anyone find out error in the program? \n\n```\n   #include<stdio.h>\n\n    int array[100],n;\n    void merge(int l,int m,int h);\n    void mergesort(int start,int end);\n    main(){\n    int i;\n    printf(\"Enter Size: \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&array[i]);      \n    }\n    mergesort(0, n-1);\n    for(i=0;i<n;i++){\n        printf(\"%d\\n\",array[i]);        \n        }\n    }\n\n    void mergesort(int start,int end){\n    int mid;\n    if(start<end){\n        mid=(start+end)/2;\n        mergesort(start,mid);\n        mergesort(mid+1,end);\n        merge(start,mid,end);\n        }\n     }\n\n    void merge(int start,int mid,int end){\n    int i,j,k;\n    int a1[100],a2[100];\n\n    for(k=0,i=start;i<=mid;i++,k++){\n        a1[k]=array[i];\n    }\n    for(k=0,j=i;j<=end;j++,k++){\n        a2[k]=array[j]; \n    }\n    a1[mid]=999;\n    a2[j]=999;\n    i=0;j=0;\n    for(k=start; k <=end; k++)\n    {\n        if(a1[i]<=a2[j])\n            array[k]=a1[i++];\n        else\n            array[k]=a2[j++];\n    }\n}\n```\n\n\nOutput:\n\n```\nEnter Size: 5\n1 2 3 2 3\n2\n2\n3\n3\n-1818025592\n```\n\n\nFor larger arrays, the output is more scrambled. I think there is an error in merge() function.\n    ", "Answer": "\r\nYou are terminating your a1 and a2 arrays at the wrong location.\n\nTry changing:\n\n```\nfor(k=0,i=start;i<=mid;i++,k++){\n    a1[k]=array[i];\n}\nfor(k=0,j=i;j<=end;j++,k++){\n    a2[k]=array[j]; \n}\na1[mid]=999;\na2[j]=999;\n```\n\n\nto\n\n```\nfor(k=0,i=start;i<=mid;i++,k++){\n    a1[k]=array[i];\n}\na1[k]=999;\nfor(k=0,j=i;j<=end;j++,k++){\n    a2[k]=array[j]; \n}\na2[k]=999;\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "calling merge sort c#\r\n                \r\nI wrote a merge sort program, but I have problems calling It from another class. I need help. For some reason after I enter the size and the max number a get a black screen in the output. I believe that the solution is pretty easy, but I can't find the solution by myself\nThis is the class where It sorts the numbers\n\n```\n class MergeSort\n        {\n            public int[] Sort(int[] unsortedSequence)\n            {\n                int[] left;\n                int[] right;\n                int[] result = new int[unsortedSequence.Length];\n            if (unsortedSequence.Length <= 1)\n                return unsortedSequence;\n\n            int midPoint = unsortedSequence.Length / 2;\n            left = new int[midPoint];\n            if (unsortedSequence.Length % 2 == 0)\n                right = new int[midPoint];\n            else\n                right = new int[midPoint + 1];\n            for (int i = 0; i < midPoint; i++)\n                left[i] = unsortedSequence[i];\n\n            int x = 0;\n\n            for (int i = midPoint; i < unsortedSequence.Length; i++)\n            {\n                right[x] = unsortedSequence[i];\n                x++;\n            }\n            left = Sort(left);\n            right = Sort(right);\n            result = merge(left, right);\n            return result;\n        }\n\n        public static int[] merge(int[] left, int[] right)\n        {\n            int resultLength = right.Length + left.Length;\n            int[] result = new int[resultLength];\n            int indexLeft = 0, indexRight = 0, indexResult = 0;\n            while (indexLeft < left.Length || indexRight < right.Length)\n            {\n                if (indexLeft < left.Length && indexRight < right.Length)\n                {\n                    if (left[indexLeft] <= right[indexRight])\n                    {\n                        result[indexResult] = left[indexLeft];\n                        indexLeft++;\n                        indexResult++;\n                    }\n                    else\n                    {\n                        result[indexResult] = right[indexRight];\n                        indexRight++;\n                        indexResult++;\n                    }\n                }\n                else if (indexLeft < left.Length)\n                {\n                    result[indexResult] = left[indexLeft];\n                    indexLeft++;\n                    indexResult++;\n                }\n                else if (indexRight < right.Length)\n                {\n                    result[indexResult] = right[indexRight];\n                    indexRight++;\n                    indexResult++;\n                }\n            }\n            return result;\n        }\n    }\n```\n\n\nAnd this is the class where I'm trying to call the mergesort\n\n```\nclass Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\"How Many Random Numbers Would you like to Generate : \");\n            int n = Convert.ToInt32(Console.ReadLine());\n            Console.Write(\"What is the Maximum Random Number Would you like to Generate : \");\n            int max = Convert.ToInt32(Console.ReadLine());\n            Console.Clear();\n            int[] unsortedSequence = generateRandomSequence(n, max);\n               MergeSort mergeSortEngine = new MergeSort();\n            int[] mergeSortedArray = mergeSortEngine.Sort(unsortedSequence);\n            Console.Write(\"Output for Merge Sort: \\n\\n\");\n            OutputSequence(mergeSortedArray);\n            Console.WriteLine(\"\\n\\nPress Any Key to Continue...\");\n            Console.ReadKey();\n            Console.Clear();\n```\n\n    ", "Answer": "\r\nBecause you didn't provide them, I wrote the missing ```\ngenerateRandomSequence()```\n and ```\nOutputSequence```\n methods in order to test your code and I can't reproduce your issue. Perhaps you should compare these to your own:\n\n```\nstatic int[] generateRandomSequence(int count, int max)\n{\n    Random rn = new Random();\n    int[] seq = new int[count];\n    for (int i = 0; i < count; ++i)\n    {\n        seq[i] = rn.Next(0, max + 1);\n    }\n    return seq;\n}\n\nstatic void OutputSequence(int[] array)\n{\n    for (int i = 0; i < array.Length; ++i)\n    {\n        if (i > 0)\n        {\n            Console.Write(\", \");\n        }\n        Console.Write(array[i]);\n    }\n    Console.WriteLine();\n}\n```\n\n\nOutput from your code using the above methods:\n\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort Java Algorithm\r\n                \r\nHey I have been having issues with my merge sort, I know there is alot of information online and this has come up multiple times, but i Have no clue what is going on , no matter what I do, this will not work, some help would be appreciated Thanks \n\nMy main method looks like this:\n\n```\nfor (int i = 0; i < trials; i++) {\n        data = generateRandomArray(arraySize);\n\n        // You can use following line to print out data for debugging\n        System.out.println(\"The array is: \" + getString(data));\n\n        // ADD YOUR CODE HERE TO SORT DATA AND CALCULATE EXECUTION TIME\n\n        // System.out.println(\"first index:\" + data[0]);\n        // System.out.println(\"first index:\" + data[arraySize-1]);\n\n        //System.out.println(\"hello  \" + SortArray.basicPartition(data,0,data.length-1));\n        SortArray.mergeSort(data, 0, data.length-1);\n\n        if (isSorted(data))\n            System.out.println(\"   passes -  array is sorted\");\n        else\n            System.out.println(\"   failed -  array is not sorted\");\n```\n\n\n\n\n```\npublic static <T extends Comparable<? super T>>\nvoid mergeSort(T[] a, T[] tempArray, int first, int last){\n    if(first < last)        // We have some work to do\n    {\n        int mid = first+(last-first)/2;\n        mergeSort(a, tempArray, first, mid);\n        mergeSort(a, tempArray, mid+1, last);\n        merge(a, tempArray, first, mid, last);\n    }\n} // end mergeSort\n\n/** Merge the entries in two contiguous sorted sublists \n * @param a An array of Comparable objects.\n * @param tempArray A temporary array used in the merge.\n * @param first An integer >= 0 and < mid.\n * @param mid An integer  <= last.\n * @param last An integer  < a.length.\n */\npublic static <T extends Comparable<? super T>>\nvoid merge(T[] a, T[] tempArray, int first, int mid, int last){\n\n    int firstIndex = first;\n    int FirstHalfEnd = mid -1;\n\n\n    while ((first <= FirstHalfEnd) && (mid <= last)) {\n\n        if (a[first].compareTo(a[mid]) <= 0) {\n\n            tempArray[firstIndex] = a[first]; // last to first\n            firstIndex++;\n            first++;\n        } \n        else {\n            tempArray[firstIndex] = a[mid];\n            FirstHalfEnd++;\n            mid++;\n            //System.out.println(\"out of bounds\");\n        }\n    }\n\n    while (first <= FirstHalfEnd) {\n        tempArray[firstIndex] = a[first];\n        firstIndex++;\n        first++;\n\n    }\n    while(mid <= last){\n        tempArray[firstIndex] = a[mid];\n        firstIndex++;\n        mid++;\n    }\n    for(int i=0;i<(last-first+1);i++){ \n        a[last] = tempArray[last];\n        last--;\n        //System.out.println(a[i]);\n    }\n\n} // end merge\n```\n\n\n\n\nOUTPUT \n\n```\nThe array is: [ 1 5 3 5 1 6 9 7 1 4 ]\n   failed -  array is not sorted\nThe array is: [ 1 8 3 4 3 1 6 8 0 9 ]\n   failed -  array is not sorted\nThe array is: [ 0 1 5 5 5 0 0 3 0 4 ]\n   failed -  array is not sorted\nThe array is: [ 0 0 6 2 7 4 6 2 2 2 ]\n   failed -  array is not sorted\nThe array is: [ 4 9 2 3 3 4 4 0 3 5 ]\n   failed -  array is not sorted\n```\n\n    ", "Answer": "\r\nI haven't run your code - there are missing pieces -, but I spotted 2 problems in the first ```\nwhile```\n loop in the ```\nmerge()```\n function - see added comments:\n\n```\nwhile ((first <= FirstHalfEnd) && (mid <= last)) {\n\n    // compareTo return a negative value if (a[first] < a[mid])\n    // Then I think your comment is wrong: the values are put in the \n    // temporary array in increasing order. It means you have to review\n    // the for loop that copies the values \n    // at the end.\n    if (a[first].compareTo(a[mid]) <= 0) {\n\n        tempArray[firstIndex] = a[first]; // last to first (No!)\n        firstIndex++;\n        first++;\n    } \n    else {\n        tempArray[firstIndex] = a[mid];\n        FirstHalfEnd++; // <= this a bug, should be firstIndex++\n        mid++;\n        //System.out.println(\"out of bounds\");\n    }\n}\n```\n\n\nEDIT\nSince values are in increasing order in ```\ntempArray```\n, the copy ```\nfor```\n loop should be something along:\n\n```\nfor(int i = first; i <= last; ++){ \n    a[i] = tempArray[i];\n}\n```\n\n\nWhich can be simplified(?) or optimised by\n\n```\nSystem.arraycopy(tempArray, first, a, first, (last-first+1));\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "What is wrong with my merge sort implementation?\r\n                \r\nThis is my implementation of a list with merge sort:\n\n```\npublic class List {\n\n        private final Object data;\n        private final List next;\n        public static final List NIL = new List(null, null);\n\n        private List(Object d, List n) {\n                data = d;\n                next = n;\n        }\n\n        public static List list(Object d) {\n                return new List(d, List.NIL);\n        }\n\n        public List append(List that) {\n                return this.isEmpty() ?\n                        that :\n                        this.tail().append(that).push(this.head());\n        }\n\n        public Object nth(int n) {\n                return this.isEmpty() || n < 0 ? null :\n                                n == 0 ? this.head() :\n                                this.tail().nth(n-1);\n        }\n\n        public List sort() {\n                return mergesort(0, this.length());\n        }\n\n        private List mergesort(int top, int out) {\n                List l = null;\n                if (top < out - 1) {\n                        int mid = (top + out) / 2;\n                        mergesort(top, mid);\n                        mergesort(mid, out);\n                        l = merge(top, mid, out);\n                }\n                return l;\n        }\n\n        private List merge(int top1, int top2, int out) {\n                List temp = List.NIL;\n                List toReturn = this;\n                int i = top1;\n                int j = top2;\n                int k = 0;\n\n                while (i < top2 && j < out) {\n                        Comparable one = (Comparable) this.nth(i);\n                        Comparable two = (Comparable) this.nth(j);\n                        if (one.compareTo(two) < 0) {\n                                temp = temp.append(List.list(this.nth(i++)));\n                        } else {\n                                temp = temp.append(List.list(this.nth(j++)));\n                        }\n                }\n\n                while (i < top2) temp = temp.append(List.list(this.nth(i++)));\n                while (j < out) temp = temp.append(List.list(this.nth(j++)));\n\n                for (k = 0; k < temp.length(); k++)\n                        toReturn = toReturn.append(List.list(temp.nth(k)));\n\n                return toReturn;\n\n        }\n\n}\n```\n\n\nThis code appears to implement merge sort properly,  but I am getting the wrong result when sorting ```\n6 5 4 3 2 1```\n: I get ```\n3 2 1 6 5 4```\n, and I can't figure out why. I'm not sure if it's just some small thing that I haven't seen yet or if it's some fundamental problem.\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Parallel multiway merge sort for Unix\r\n                \r\nI have searched to see if I could find a parallel multiway merge sort that would run on a Unix command line. I could find none.\nGNU Sort uses merge sort, but the final merge is single threaded. ```\nparsort```\n is also single threaded in the final merge step.\nhttps://en.wikipedia.org/wiki/Merge_sort#Parallel_multiway_merge_sort shows how it is possible to parallelize the final merge step.\nBefore I spend time on implementing the multithreaded algorithm from Wikipedia:\n\nIs this already done?\nIf there is not a command line tool for Unix: Is there at least a library that does the final merge step in parallel (in other words: can I simply make a command line wrapper for an existing library?)?\n\n    ", "Answer": "\r\n- Is this already done?\nAs of posting date - nope. So you'd be the 1st one\n- If there is not a command line tool for Unix: Is there at least a library that does the final merge step in parallel (in other words: can I simply make a command line wrapper for an existing library?)?\nA ```\nGNU parallel extension```\n to the ```\nStandard C++ Library```\n includes a file called multiway_mergesort.h  which implements a ```\nparallel multiway merge sort```\n\n```\nMPDMSort```\n uses the ```\nOpenMP```\n library to develop a parallel implementation of the algorithm which  could be used to create a command line wrapper for an existing implementation of ```\nparallel multiway merge sort```\n.\nJust some starter thoughts\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Real life example of multithreaded merge sort\r\n                \r\nI have been working for a project MULTI THREADED MERGE SORT.\nI have one real example of this project is sorted of our files in Desktop.\ni-e : sort by name,sort by size \nCan anyone tell me more real life examples of merge sort ? \n    ", "Answer": "\r\nIn reality, merge sort is very important in distributed file system and distributed computing (more than multi-thread).  Some sort of multi-way merge sort can effectively utilize the secondary storage to sort very large files which can not fit in memory. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Error C\r\n                \r\nI am trying to implement the Merge Sort algorithm. I am following the algorithm mentioned in the CLRS book.Here is my code\n\n```\n#include<stdio.h>\n#include<stdlib.h>\nvoid merge_sort(int *arr,int start_index,int end_index);\nvoid merge(int *arr,int start_index,int middle_index,int end_index);\n\nint main(){\n\nint arr[]={5,2,1,6,0,3,3,4}; //8 elements last index 7\nint i;\nprintf(\"Before sorting.\\n\");\nfor(i=0;i<8;i++)\nprintf(\"%d\",arr[i]);\nmerge_sort(arr,0,7);\nprintf(\"\\nAfter sorting.\\n\");\nfor(i=0;i<8;i++)\nprintf(\"%d\",arr[i]);\n\nreturn 0;}\n\nvoid merge_sort(int *arr,int start_index,int end_index){\n    int middle_index;\n    if(start_index<end_index)\n    {\n        middle_index=(start_index+end_index)/2;\n        merge_sort(arr,start_index,middle_index);\n        merge_sort(arr,(middle_index+1),end_index);\n        merge(arr,start_index,middle_index,end_index);\n    }\n\n}\n\nvoid merge(int *arr, int start_index,int middle_index, int end_index){\n\n    int n1,n2,i,l,m;\n    n1=middle_index-start_index+2;\n    n2=end_index-middle_index+1;\n    int sub_arr1[n1],sub_arr2[n2];\n    for(i=0;i<(n1-1);i++)\n        sub_arr1[i]=arr[i];\n     for(i=0;i<(n2-1);i++)\n        sub_arr2[i]=arr[middle_index+1+i];\n\n    sub_arr1[n1+1]=100;\n    sub_arr2[n2+1]=100;\n\n    for(i=0;i<=end_index;i++){\n\n        l=0,m=0;\n        if(sub_arr1[l]<sub_arr2[m])\n        {arr[i]=sub_arr1[l++];}\n        else\n         {arr[i]=sub_arr2[m++];}\n\n    }}\n```\n\n\nI am getting the following output\n\n```\nBefore sorting.\n52160334\nAfter sorting.\n22222222\nRUN FINISHED; exit value 0; real time: 10ms; user: 0ms; system: 0ms\n```\n\n\nSince I am taking small integers, I have taken 100 as the ```\nsentinel value```\n. I guess there is something wrong with the merge function. Any help appreciated.\n    ", "Answer": "\r\nThe problem is very simple: your last ```\nloop```\n in the ```\nmerge(...)```\n has a problem.\n\nMove the ```\nl = 0```\n and ```\nm = 0```\n before the loop starts, because you are using the values 0 and 1 for l and m always, in each loop iteration.\n\nChange it to:\n\n```\nint l=0, m=0;\nfor(i=0;i<=end_index;i++){   \n    if(sub_arr1[l]<sub_arr2[m])\n    {arr[i]=sub_arr1[l++];}\n    else\n     {arr[i]=sub_arr2[m++];}\n\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort logic mistake\r\n                \r\nEDIT:\nThe problem seems to be that merge returns the sorted list but mergeSort doesn't work with the sorted list.\n\nI tried to write a simple merge sort in java but I have an issue with it. It doesn't sort the array of integers correctly. I must have made an logic mistake but I can't find it out. I have written selection and bubble sort before and they work like they should. I would be thankful for any help :) Here is my code:\n\n```\npublic static int[] mergeSort(int[] array)\n{\n    if (array.length <= 1)\n    {\n        return array;\n    }\n    else\n    {\n        int[] linkeListe = Arrays.copyOfRange(array, 0, array.length/2);\n        int[] rechteListe = Arrays.copyOfRange(array, linkeListe.length, array.length);\n\n        mergeSort(linkeListe);\n        mergeSort(rechteListe);\n        return merge(linkeListe, rechteListe);\n    }\n}\n\npublic static int[] merge(int[] linkeListe, int[] rechteListe)\n{\n    int[] sortedArray = new int[linkeListe.length + rechteListe.length];\n    int addElementPosition = 0;\n\n    while (linkeListe.length > 0 && rechteListe.length > 0)\n    {\n        if (linkeListe[0] <= rechteListe[0])\n        {\n            sortedArray[addElementPosition] = linkeListe[0];\n            linkeListe = deleteFirstElement(linkeListe);\n        }\n        else\n        {\n            sortedArray[addElementPosition] = rechteListe[0];\n            rechteListe = deleteFirstElement(rechteListe);\n        }\n\n        addElementPosition++;\n    }\n\n    while (linkeListe.length > 0)\n    {\n        sortedArray[addElementPosition] = linkeListe[0];\n        addElementPosition++;\n        linkeListe = deleteFirstElement(linkeListe);\n    }\n\n    while (rechteListe.length > 0)\n    {\n        sortedArray[addElementPosition] = rechteListe[0];\n        addElementPosition++;\n        rechteListe = deleteFirstElement(rechteListe);\n    }\n\n    return sortedArray;\n}\n\npublic static int[] deleteFirstElement(int[] array)\n{\n    int[] newArray;\n\n    if (array.length > 1)\n    {\n        newArray = new int[array.length - 1]; \n        newArray = Arrays.copyOfRange(array, 1, array.length);\n    }\n    else\n    {\n        newArray = new int[0];\n    }\n\n    return newArray;\n}\n```\n\n    ", "Answer": "\r\nI believe you need to change this:\n\n```\nmergeSort(linkeListe);\nmergeSort(rechteListe);\n```\n\n\nto this:\n\n```\nlinkeListe = mergeSort(linkeListe);\nrechteListe = mergeSort(rechteListe);\n```\n\n\nOn a side note, deleting the first element of the array like you are doing with deleteFirstElement is a huge performance issue.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "extra storage merge sort\r\n                \r\nI need make a merge sort using an additional array. Here is my code:\n\n```\npublic class extra_storage{  \n    public static void main(String[]args) { \n\n        int x[]=new int[]{12,9,4,99,120,1,3,10};\n        int a[]=new int[x.length];\n\n        mergesort(x,0,x.length-1,a);\n        for (int i=0;i<x.length;i++){\n            System.out.println(x[i]);\n        }       \n    }\n\n    public static void mergesort(int x[],int low,int high, int a[]){      \n        if (low>=high) {\n            return;\n        }\n        int middle=(low+high)/2;\n        mergesort(x,low,middle,a);\n        mergesort(x,middle+1,high,a);\n        int k;\n        int lo=low;\n        int h=high;\n        for (k=low;k<high;k++)\n            if ((lo<=middle ) && ((h>high)||(x[lo]<x[h]))){\n                a[k]=x[lo++];\n            }\n            else {\n                a[k]=x[h++];\n            }\n        for (k=low;k<=high;k++){\n            x[k]=a[k];\n        }     \n    }\n}\n```\n\n\nBut something is wrong. When I run it the output is this:\n\n\n1\n0\n3\n0\n4\n0\n9\n0\n\n\nWhat is the problem?\n    ", "Answer": "\r\nHere's your original algorithm with some corrections and stylistic improvements:\n\n```\npublic class MergeSort {  \n    public static void main(String[]args) { \n        int[] nums = {12,9,4,99,120,1,3,10};\n        mergeSort(nums);\n        System.out.println(java.util.Arrays.toString(nums));\n        // \"[1, 3, 4, 9, 10, 12, 99, 120]\"\n    }\n    static void mergeSort(int[] arr) {\n        mergeSort(arr, 0, arr.length - 1, new int[arr.length]);\n    }\n    static void mergeSort(int[] arr, int low, int high, int[] buff){\n        if (low >= high) {\n            return;\n        }\n        int mid = (low + high) >>> 1;\n        mergeSort(arr, low, mid, buff);\n        mergeSort(arr, mid+1, high, buff);\n        for (int left = low, right = mid + 1, i = low; i <= high; i++) {\n            if (right > high || left <= mid && arr[left] <= arr[right]) {\n                buff[i] = arr[left++];\n            } else {\n                buff[i] = arr[right++];\n            }\n        }\n        for (int i = low; i <= high; i++) {\n            arr[i] = buff[i];\n        }\n    }\n}\n```\n\n\nUnlike Eyal's implementation, where the role of ```\nsrc```\n and ```\ndst```\n are swapped back and forth through the levels of recursion, here we always sort to the same array object ```\narr```\n, and the array object ```\nbuff```\n is always used only as a temporary buffer for merging (and consequently, there's a copy phase after the merge phase). This is still ```\nO(N log N)```\n, but Eyal's more advanced implementation will be a constant-factor improvement.\n\nOn the merge loop\n\nEssentially you have a ```\nleft```\n index for the left subarray, and ```\nright```\n index for the right subarray, and you pick the right element from either the ```\nleft```\n or ```\nright```\n to put into ```\nbuff```\n.\n\nThe valid range of elements are (inclusive bounds):\n\n\n```\nleft = low...mid```\n for left subarray\n```\nright = mid+1...high```\n for right subarray\n\n\nTo evaluate which element to pick, consider the condition under which the ```\nleft```\n element is picked. It happens when:\n\n\nThere are no more element to pick from the right subarray (i.e. ```\nright > high```\n)\nOR (conditionally) there's still an element to pick from the left subarray (i.e. ```\nleft <= mid```\n) and (conditionally) that element is less than or equal to the element from the right subarray (i.e. ```\narr[left] <= arr[right]```\n).\n\n\nIt's important to use short-circuiting conditional-and ```\n&&```\n (JLS 15.23) and conditional-or ```\n||```\n (JLS 15.24) operators here, and to order these conditions accordingly. Otherwise you'll get an ```\nArrayIndexOutOfBoundsException```\n.\n\nRelated questions\n\n\nWhat’s the difference between | and || in Java?\nShortcut “or-assignment” (|=) operator in Java\nJava\nWhy doesn’t Java have compound assignment versions of the conditional-and and conditional-or operators? (&&=, ||=)\n\n\n\n\nOn finding average between two numbers\n\nIt's common to see the following:\n\n```\nint mid = (low + high) / 2; // BROKEN! Can result in negative!\n```\n\n\nThe problem is that nowadays, arrays/lists etc can easily exceed 230 elements, and the above would cause an overflow and results in a negative number.\n\nThe new idiom, as advocated by Josh Bloch, is the following:\n\n```\nint mid = (low + high) >>> 1; // WORKS PERFECTLY!\n```\n\n\nThis uses the unsigned right shift operator (JLS 15.19); it handles any overflow on the addition correctly for our need.\n\nReferences\n\n\nOfficial Google Research Blog: Nearly All Binary Searches and Mergesorts are Broken\n\n\nRelated questions\n\n\nBitwise Operations — Arithmetic Operations\n\n\nExplains how bitwise shifting relates to power-of-two arithmetics\n\nJava’s >> versus >>> Operator?\nDifference between >>> and >> operators\nDifference between >>> and >>\n\n\n\n\nOn array declarations\n\nDo not make a habit of declaring arrays like this:\n\n```\nint x[];\n```\n\n\nYou should instead put the brackets with the type, rather than with the identifier:\n\n```\nint[] x;\n```\n\n\nRelated questions\n\n\nIs there any difference between ```\nObject[] x```\n and ```\nObject x[]```\n ?\nDifference between ```\nint[] myArray```\n and ```\nint myArray[]```\n in Java\nin array declaration ```\nint[] k,i```\n and ```\nint k[],i```\n\n\n\nThese declarations result in different types for ```\ni```\n!\n\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java merge sort\r\n                \r\nThis is the merge sort algorithm provided by the java book im using, but the code doesnt work. It returns an array with some numbers duplicated that werent in the original number list. Any ideas why this code isnt working, thanks? Edit: The output of running this is: \"\n7\n2\n12\n4\n2\n      So it duplicates the 2's\n2\n2\n2\n4\n12\n\n```\npublic class Nothing1{\n\n public static void main(String[] args)\n    {\n        comp<Integer> c = new comp<Integer>();\n\n        Integer[] values1 = new Integer[5];\n\n        values1[0] = 7;\n        values1[1] = 2;\n        values1[2] = 12;\n        values1[3] = 4;\n        values1[4] = 2;\n\n        for(int index= 0; index <= values1.length-1; ++index)\n            {\n                System.out.println(values1[index]);\n            }\n\n        c.mergeSort(values1);\n\n        for(int index= 0; index <= values1.length-1; ++index)\n            {\n                System.out.println(values1[index]);\n            }\n\n\n\n    }\n\n     public static <T extends Comparable<T>> void mergeSort(T[] data)\n        {\n            mergeSort(data, 0, data.length-1);\n        }\n\n        private static <T extends Comparable<T>> void mergeSort(T[] data, int min, int max)\n        {\n            if(min < max)\n            {\n                int mid = (min + max)/2;\n                mergeSort(data, min, mid);\n                mergeSort(data, mid+1, max);\n                merge(data, min, mid, max);\n            }\n        }\n\n        private static <T extends Comparable <T>> \n                void merge(T[] data, int first, int mid, int last)\n        {\n            T[] temp = (T[])(new Comparable[data.length]);\n\n            int first1 = first, last1=mid;\n            int first2 = mid+1, last2=last;\n            int index = first1;\n\n            while(first1 <= last1 && first2 <= last2)\n            {\n                if(data[first1].compareTo(data[first2]) < 0)\n                {\n                    temp[index] = data[first];\n                    first1++;\n                }\n                else\n                {\n                    temp[index] = data[first2];\n                    first2++;\n                }\n                index++;\n            }\n\n            while(first1 <= last1)\n            {\n                temp[index] = data[first1];\n                first1++;\n                index++;\n            }\n\n            while(first2 <= last2)\n            {\n                temp[index] = data[first2];\n                first2++;\n                index++;\n            }\n\n            for(index = first; index <=last; index++)\n                data[index] = temp[index];\n        }\n}\n```\n\n    ", "Answer": "\r\nAre you forgetting to change one of variables, arent you?\n\nImagine you have 4 and 3 in the current to merge array.\n\nYour first1 and last1 is 0\nYour first2 and last2 is 1\n\nWhen you compare it, you enter to the else and copy the 3 to the first position of index, that is right. And then you move first2 one above.\n\nBut what about the 4?? You should copy it after the 3, right? Just in the second position of the index.\n\nMaybe Im wrong.\n\nIm sorry, my english is bad.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Problems In Python\r\n                \r\nSo I'm trying to teach myself how to write a merge sort but for whatever reason I can't seem to make it work.\n\n```\n    def merge(left, right):\n        result = []\n        i ,j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result\n\n    def mergesort(numlist):\n        if len(numlist) < 2:\n            return numlist\n        middle = int(len(numlist)/2)\n        left = mergesort(numlist[:middle])\n        right = mergesort(numlist[middle:])\n        return merge(left, right)\n```\n\n\nEvery list I feed into the sort then attempt to print just comes up the exact same with no changes\n    ", "Answer": "\r\nAnswering so this can be closed though it was fixed in comments with the help of @Jean-François Fabre.\n\nYour current code works fine but it does not sort the list in-place. In the case of sorting a list called ```\nlist_of_numbers```\n, you need to assign the result back to ```\nlist_of_numbers```\n:\n\n```\nlist_of_numbers = mergesort(list_of_numbers)```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Optimizing merge sort for cache misses\r\n                \r\nConsider an unsorted array of N elements wherein each element is byte sized.   Let  the  size  of  the  cache  be  1  KB  with  a  cache  line  size  of  64.Further assume that the cache is organized in a fully associative manner.Compute  the  number  of  cache  misses  when  a  merge  sort  algorithm  is applied on the array.  While doing the analysis, you may want to consider different cases comparing the array size N with the cache size. Do you have any suggestions on modifying the merge sort algorithm so as to reduce the cache misses.\nAssume the merge sort algorithm uses 1 temporary array to store the elements of the 2 arrays being merged.\n    ", "Answer": "\r\nIt would seem that a standard bottom up merge sort could be used without modification.\n\nThere are (1024/64) = 16 cache lines. Assume the merge sort has reached a point where sorted runs are now larger than 64 bytes. During a merge operations, 2 cache lines will be used for the 2 sorted runs to be merged, and 1 cache line for the merged output. Cache misses will only occur once every 64 bytes read or written.\n\nA bottom up merge sort will generate sorted runs with sizes of powers of 2, which might be a bit more cache friendly.\n\nI'm not sure what is allowed in the modification to merge sort. Using a hybrid insertion sort + merge sort can reduce sort time. Let k = # elements to be sorted by insertion sort to create sorted runs of size k. A simple implementation is to determine the number of sort passes required by a basic bottom up merge sort: passcount = ceil(log2(N)). If passcount is odd, use k = 32, if passcount is even, use k = 64. This results in an even number of merge sort passes, which can alternate the direction of merge on each merge pass, to avoid having to copy data during a merge step.\n\n\n  Assume the merge sort algorithm uses 1 temporary array to store the elements of the 2 arrays being merged.\n\n\nThis part isn't quite clear. It's more efficient to do a one time allocation of the temporary array the same size as the array to be sorted, then use identical indexing for the merge operations. A less efficient method is for every merge operation to allocate a temporary array the same size as the sum of the sizes of the two sorted runs to be merged, which would need to copy to (if before merge) or from (if after merge) the temporary array. As already mentioned, the merge operation can change the direction of merge based on bottom up merge pass or top down level of recursion to avoid copying of data. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Optimizing merge sort for cache misses\r\n                \r\nConsider an unsorted array of N elements wherein each element is byte sized.   Let  the  size  of  the  cache  be  1  KB  with  a  cache  line  size  of  64.Further assume that the cache is organized in a fully associative manner.Compute  the  number  of  cache  misses  when  a  merge  sort  algorithm  is applied on the array.  While doing the analysis, you may want to consider different cases comparing the array size N with the cache size. Do you have any suggestions on modifying the merge sort algorithm so as to reduce the cache misses.\nAssume the merge sort algorithm uses 1 temporary array to store the elements of the 2 arrays being merged.\n    ", "Answer": "\r\nIt would seem that a standard bottom up merge sort could be used without modification.\n\nThere are (1024/64) = 16 cache lines. Assume the merge sort has reached a point where sorted runs are now larger than 64 bytes. During a merge operations, 2 cache lines will be used for the 2 sorted runs to be merged, and 1 cache line for the merged output. Cache misses will only occur once every 64 bytes read or written.\n\nA bottom up merge sort will generate sorted runs with sizes of powers of 2, which might be a bit more cache friendly.\n\nI'm not sure what is allowed in the modification to merge sort. Using a hybrid insertion sort + merge sort can reduce sort time. Let k = # elements to be sorted by insertion sort to create sorted runs of size k. A simple implementation is to determine the number of sort passes required by a basic bottom up merge sort: passcount = ceil(log2(N)). If passcount is odd, use k = 32, if passcount is even, use k = 64. This results in an even number of merge sort passes, which can alternate the direction of merge on each merge pass, to avoid having to copy data during a merge step.\n\n\n  Assume the merge sort algorithm uses 1 temporary array to store the elements of the 2 arrays being merged.\n\n\nThis part isn't quite clear. It's more efficient to do a one time allocation of the temporary array the same size as the array to be sorted, then use identical indexing for the merge operations. A less efficient method is for every merge operation to allocate a temporary array the same size as the sum of the sizes of the two sorted runs to be merged, which would need to copy to (if before merge) or from (if after merge) the temporary array. As already mentioned, the merge operation can change the direction of merge based on bottom up merge pass or top down level of recursion to avoid copying of data. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort by object attribute in vector\r\n                \r\nI make a c++ project to compare different algorithm complexity. I have a vector of Circle  ```\nvector<Disque>```\n and i would like to sort this vector by attribute x of circle (x-axis the most in left =>  x-axis-radius). I've implement merge-sort algorithm but doesn't work and dont know why.\n\nMerge sort implementation : \n\n```\n/**\n* Méthode qui permet de fusionner les tableaux qui ont été séparés afin de trier le tableau final\n* @param indice_bas\n* @param milieu\n* @param indice_haut\n* @param taille\n*/\nvoid fusion(int indice_bas, int milieu, int indice_haut, vector<Disque> tableau) {\n    // Déclaration de différents indices pour la fusion\n    int h,i,j,k;\n    // Déclaration du tableau intérmediaire qui permet de stocké les disques du tableau\n    vector<Disque> tab_tmp;\n    // Initialisation des indices\n    h = indice_bas;\n    i = indice_bas;\n    j = milieu+1;\n\n    // Tant que nous avons pas trié l'ensemble du tableau\n    while((h <= milieu) && (j <= indice_haut)) {\n        // Si la valeurs de gauche est plus petite que celle de droite\n        if((tableau[h].getPoint().getX() - tableau[h].getRayon()) <= (tableau[j].getPoint().getX() - tableau[j].getRayon())) {\n            // On insère la valeur de gauche et on incrémente l'indice h\n            tab_tmp.push_back(tableau[h]);\n            h++;\n        } else {\n            // Sinon on interverti les valeurs du tableau afin de les remettrent dans l'ordre et on incrémente l'indice j\n            tab_tmp.push_back(tableau[j]);\n            j++;\n        }\n        // Incrémentation de i car tab_tmp[i] possède désormais une valeur\n        i++;\n    }\n\n    // Si il reste des valeurs à insérer dans le tableau temporaire, on les insère suivant si elles sont dans le tableau de droite ou de gauche\n    if(h > milieu) {\n        // Boucle qui permet d'insérer les valeurs restantes\n        for(k = j; k <= indice_haut; k++)\n        {\n            tab_tmp.push_back(tableau[k]);\n            i++;\n        }\n    } else {\n        // Boucle qui permet d'insérer les valeurs restantes\n        for(k = h; k <= milieu; k++) {\n            tab_tmp.push_back(tableau[k]);\n            i++;\n        }\n    }\n\n    // On replace les valeurs une à une dans le tableau que nous avons trié\n    for(k = indice_bas; k <= indice_haut; k++){\n        tableau[k] = tab_tmp[k];\n    }\n}\n\n/**\n * Méthode tri fusion qui permet de trier les abscisse du point central d'un disque.\n * Choix de cet algorithme car la complexité est en n log n\n * @param indice_bas\n * @param indice_haut\n */\nvoid tri_fusion(int indice_bas, int indice_haut, vector<Disque> tableau, int taille){\n    // On déclare un indice qui correspond au milieu du tableau à trier pour effectuer un split\n    int milieu;\n    if(indice_bas < indice_haut) {\n        // Calcul du milieu du tableau\n        milieu = indice_bas + (indice_haut - indice_bas) / 2;\n        // On appel récursivement la méthode de tri fusion jusqu'à la division de tous les tableaux\n        tri_fusion(indice_bas, milieu, tableau, taille);\n        tri_fusion(milieu + 1, indice_haut, tableau, taille);\n        fusion(indice_bas, milieu, indice_haut, tableau);\n    }\n}\n```\n\n\nMain : \n\n```\n// Fonction main qui est le point d'entrée du programme\nint main(int argc, const char * argv[]) {\n    // Permet de générer plus d'aléa pour la création des disques\n    srand((unsigned)time(NULL));\n    // On crée quelques disques pour essayer les algos\n    vector<Disque> tabDisque;\n    for (int i=0; i < 10; ++i) {\n        tabDisque.push_back(Disque(rand() % 10 + 1, Point(rand() % 30 + 1, rand() % 30 + 1)));\n    }\n\n    // On récupère la taille du vector\n    int const taille = (const int)tabDisque.size();\n\n    tri_fusion(0, taille-1, tabDisque, taille);\n\n    for (int z = 0; z < taille ; z++) {\n        cout << tabDisque[z].getPoint().getX() - tabDisque[z].getRayon() << \" \";\n    }\n    return 0;\n}\n```\n\n\nThanks a lot and sorry for the french code :)\n    ", "Answer": "\r\nIf you are aware of the difference between passing things to a function \"by reference\" and \"by value\": You passed your vector by value, you should clearly pass it by reference so you can modify it.\n\nIf not: The way you pass you vector to your function right now is called passing \"by value\". The function will receive a copy of the vector. Now if you modify this copy, say by swapping two entries, the original vector will be unchanged. What you need to do is pass the function a reference to the vector so you can modify it. To do so, change ```\nvector<Disque> tableau```\n to ```\nvector<Disque> &tableau```\n both in ```\nfusion```\n and ```\ntri_fusion```\n. You should look up the difference between these two ways to pass values to functions, it's quite important.\n\nA second mistake is\n\n```\nfor(k = indice_bas; k <= indice_haut; k++){\n  tableau[k] = tab_tmp[k];\n}\n```\n\n\nThe indexing in ```\ntab_tmp```\n starts at ```\n0```\n, as opposed to ```\nindice_bas```\n for ```\ntableau```\n. You need to change this to something like\n\n```\nfor(k = 0; k <= indice_haut-indice_bas; k++){\n  tableau[k+indice_bas] = tab_tmp[k];\n}\n```\n\n\nThis are the only mistakes I can see right now, but I can't compile your code as I don't know what ```\nDisque```\n is, so there might be more I have missed.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Generic Merge Sort Algorithm in Java - Error\r\n                \r\nCan anyone see something wrong with this code? I really can't find the error. It looks alright to me. I'm creating a generic merge sort algorithm using ArrayList. There's no syntax error. \n\nThis is my merge sort code:\n\n```\npublic static <T extends Comparable<T>> void MergeSortArrayList(ArrayList<T> arr){\n    ArrayList<T> tmp = new ArrayList<T>();\n    int high = arr.size()-1;\n    int low = 0;\n    sort(arr, tmp, low, high);      \n}\n\nprivate static <T extends Comparable<T>> void sort(ArrayList <T> arr, ArrayList <T> tmp, int low, int high){\n    if(low>=high) return;\n    int mid = (low+high)/2;\n    sort(arr, tmp, low,mid);\n    sort(arr, tmp, mid+1,high);\n    merge(arr,tmp,low,mid,high);    \n}\n\nprivate static <T extends Comparable<T>> void merge(ArrayList <T> arr, ArrayList <T> tmp, int low, int mid, int high){\n    int ml = low;\n    int mr = mid+1;\n    int i = low;\n    int j = low;\n\n    while(ml <= mid && mr <= high){\n        if(arr.get(ml).compareTo(arr.get(mr)) < 0){\n            tmp.set(i+1, arr.get(ml+1));\n        }\n        else{\n            tmp.set(i+1, arr.get(mr + 1));\n        }\n    }\n\n    while(ml <= mid){\n        tmp.set(i+1, arr.get(ml+1));\n    }\n\n    while(mr <= high){\n        tmp.set(i+1, arr.get(mr + 1));\n    }\n\n    while(j <= high){\n        arr.set(j, tmp.get(j));\n        j++;\n    }\n}\n```\n\n\nI can see the lines where the errors are according to the output screen display, however, I'm just really exhausted after so many hours and still not getting anywhere. Any help would be greatly appreciated.\n\nThis is the output:\n\n```\nrun:\nBefore sorting: \n\nString: \n[C, D, A, R, S, O]\n\nIntegers: \n[500, 400, 100, 200, 700, 900]\n\nDouble: \nException in thread \"main\" java.lang.IndexOutOfBoundsException: Index: 1, Size: 0\n[500.45, 400.55, 400.54, 100.21, 700.0, 900.99]\n\nObject: \n[olly bula 123, tani lagi 456, adam mate 321, jojo blue 119, lulu hall 300, lola bays 241]\nat java.util.ArrayList.rangeCheck(ArrayList.java:657)\n\nat java.util.ArrayList.set(ArrayList.java:448)\n\nAfter sorting: \nat genericsort.MergeSortArrayList.merge(MergeSortArrayList.java:36)\nString: \nat genericsort.MergeSortArrayList.sort(MergeSortArrayList.java:25)\nat genericsort.MergeSortArrayList.sort(MergeSortArrayList.java:23)\nat genericsort.MergeSortArrayList.sort(MergeSortArrayList.java:23)\nat \ngenericsort.MergeSortArrayList.MergeSortArrayList(MergeSortArrayList.java:17)\nat genericsort.MergeSortArrayList.main(MergeSortArrayList.java:130)\nC:\\Users\\Fiji\\AppData\\Local\\NetBeans\\Cache\\8.2\\executor-snippets\\run.xml:53: Java returned: 1\nBUILD FAILED (total time: 0 seconds)\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "String Sort With Merge Sort\r\n                \r\nI am trying to do a string sort using merge sort algorithm. Here is my related code:\n\n```\nvoid sortCities(EXPEDITION *expedition, int expeditionNumber)\n{\n    int i;\n    int j;\n    char **tmp;\n    tmp = (char**)malloc((expeditionNumber) * sizeof(char*));\n    for (i = 0; i < expeditionNumber; i++) {\n        tmp[i] = (char*)malloc(15 * sizeof(char));\n    }\n    for (i = 0, j = 0; i < expeditionNumber; i++, j++) {\n        tmp[j] = expedition[i].city;\n    }\n    for (i = 0; i < expeditionNumber; i++) {\n        printf(\"%s\\n\", tmp[i]);\n    }\n    mergeSort(tmp, 0, expeditionNumber);\n    for (i = 0; i < expeditionNumber; i++) {\n        printf(\"%s\\n\", tmp[i]);\n    }\n}\n\nvoid mergeSort(char** array, int first, int last)\n{\n    int middle;\n    if (first < last) {\n        middle = (first + last) / 2;\n        mergeSort(array, first, middle);\n        mergeSort(array, middle + 1, last);\n        merge(array, first, middle + 1, middle, last);\n    }\n}\n\nvoid merge(char** array, int first1, int first2, int last1, int last2)\n{\n    int i;\n    int j;\n    int k;\n    char **newArray;\n    newArray = (char**)malloc((last2 - first1 + 1) * sizeof(char*));\n    for (i = 0; i < last2 - first1 + 1; i++) {\n        newArray[i] = (char*)malloc(15 * sizeof(char));\n    }\n    j = first2;\n    i = first1;\n    k = 0;\n    while (i < last1 && j < last2) {\n        if (strcmp(array[i], array[j]) > 0) {\n            strcpy(newArray[k++], array[j++]);\n        }\n        else {\n            strcpy(newArray[k++], array[i++]);\n        }\n    }\n    if (i < last1) {\n        while (i < last1) {\n            strcpy(newArray[k++], array[i++]);\n        }\n    }\n    if (j < last2) {\n        while (j < last2) {\n            strcpy(newArray[k++], array[j++]);\n        }\n    }\n    for (i = first1, j = 0; i < last2; i++, j++) {\n        strcpy(array[i], newArray[j]);\n    }\n}\n```\n\n\nThe problem is tmp is returning with null values to sortCities function. I checked the content of the tmp before I sent it to mergeSort and I saw that it copied right(from expedition.city). What can be the reason?\n\nEdit: I handled that by writing \"array[i] = newArray[j];\" insead \"strcpy(array[i], newArray[j])\". But now it does not sort correctly. I think I should use \"<=\" instead \"<\" but this time it stopped executing because of the limits of pointer arrays I guess.\n    ", "Answer": "\r\nI just used normal char matrix (char[][N]) instead pointer matrix and it worked. Here is my new code:\n\n```\nvoid merge(char array[100][15],int first1,int first2,int last1,int last2){\nint i;\nint j;\nint k;\nchar **newArray;\nnewArray=(char **)malloc((last2-first1+1)*sizeof(char *));\nfor(i=0;i<last2-first1+1;i++){\n    newArray[i]=(char *)malloc(15*sizeof(char));\n}\nj=first2; \ni=first1; \nk=0;\nwhile(i<=last1 && j<=last2){\n\n    if(strcmp(array[i],array[j])>0){ \n        strcpy(newArray[k++], array[j++]);\n    }\n    else{\n        strcpy(newArray[k++], array[i++]);\n    }\n}\n\nwhile(i<=last1){            \n    strcpy(newArray[k++], array[i++]);\n}\n\nwhile(j<=last2){\n    strcpy(newArray[k++], array[j++]);\n}\n\nfor(i=first1,j=0;j<k;i++,j++){\n    strcpy(array[i], newArray[j]);\n}\n```\n\n\n}\n\n```\nvoid mergeSort(char array[100][15],int first,int last){ \nint middle;\nif(first<last){\n    middle=(first+last)/2;\n    mergeSort(array,first,middle);\n    mergeSort(array,middle+1,last);\n    merge(array,first,middle+1,middle,last); \n}\n```\n\n\n}\n\n```\nvoid sortCities(EXPEDITION *expedition, int expeditionNumber){\nint i;\nint j;\nchar tmp[100][15];\n\nfor(i=0,j=0;i<expeditionNumber;i++,j++){\n    strcpy(tmp[j],expedition[i].city);\n}\n\nmergeSort(tmp,0,expeditionNumber);\nfor(i=0;i<expeditionNumber;i++){\n    printf(\"%s\\n\",tmp[i]);\n}   \n```\n\n\n}\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sorting in Objective C\r\n                \r\nI am trying to implement merge sort in objective -C.\n\nThis is a similar question asked in the following link , did not find it answered so creating a new question.\n\nMerge sort in Objective-C\n\nThis is what I have tried ,\n\n```\n-(NSArray *)mergeSort:(NSArray *)unsortedArray {\n\n    if ([unsortedArray count] < 2)\n        return unsortedArray;\n\n    long mid = [unsortedArray count] / 2;\n    NSRange left = NSMakeRange(0, mid);\n    NSRange right = NSMakeRange(mid, [unsortedArray count] - mid);\n\n    NSArray *rightArray = [unsortedArray subarrayWithRange:right];\n    NSArray *leftArray = [unsortedArray subarrayWithRange:left];\n\n    NSArray *resultArray = [self merge:leftArray andRight:rightArray];\n    return resultArray;\n}\n\n-(NSArray *)merge:(NSArray *)leftArray andRight:(NSArray *)rightArray {\n\n    NSMutableArray *result = [NSMutableArray array];\n    int right = 0;\n    int left = 0;\n\n    while (left < [leftArray count] && right < [rightArray count]) {\n\n        NSComparisonResult comparisonResult = [leftArray[left] compare:rightArray[right]];\n\n        if (comparisonResult != NSOrderedDescending) {\n            [result addObject:[leftArray objectAtIndex:left++]];\n        } else {\n            [result addObject:[rightArray objectAtIndex:right++]];\n        }\n\n        /*if ([[leftArray objectAtIndex:left] intValue] < [[rightArray objectAtIndex:right] intValue]) {\n            [result addObject:[leftArray objectAtIndex:left++]];\n            //left++;\n        } else {\n            [result addObject:[rightArray objectAtIndex:right++]];\n            //right++;\n        }*/\n    }\n\n    NSRange leftRange = NSMakeRange(left, [leftArray count] - left);\n    NSRange rightRange = NSMakeRange(right, [rightArray count] - right);\n    NSArray * newRight = [rightArray subarrayWithRange:rightRange];\n    NSArray * newLeft = [leftArray subarrayWithRange:leftRange];\n    newLeft = [result arrayByAddingObjectsFromArray:newLeft];\n\n    return [newLeft arrayByAddingObjectsFromArray:newRight];\n}\n```\n\n\nKindly let me know if anyone has any other approaches for merge sort.\n    ", "Answer": "\r\nI dont understand why do you people want the long way.. Even though there are already easy way of doing this...\n\nI made one myself hope this will help you..\n\n```\n- (NSArray *)arrayMergeSort:(NSArray *)targetArray\n{\n    if (targetArray.count < 2)\n        return targetArray;\n\n    long midIndex = targetArray.count/2;\n\n    NSArray *arrayLeft = [targetArray subarrayWithRange:NSMakeRange(0, midIndex)];\n\n    NSArray *arrayRight= [targetArray subarrayWithRange:NSMakeRange(midIndex, targetArray.count - midIndex)];\n\n    return [self arrayMerge: [self arrayMergeSort:arrayLeft] : [self arrayMergeSort:arrayRight]];\n}\n```\n\n\nFor arrange merge:\n\n```\n- (NSArray *)arrayMerge:(NSArray *)arrayLeft :(NSArray *)arrayRight \n{\n    NSMutableArray *resultArray = [[NSMutableArray alloc] init];\n\n    int i = 0, j = 0;\n\n    while (i < arrayLeft.count && j < arrayRight.count)\n        [resultArray addObject:([arrayLeft[i] intValue] < [arrayRight[j] intValue]) ? arrayLeft[i++] : arrayRight[j++]];\n\n    while (i < arrayLeft.count)\n        [resultArray addObject:arrayLeft[i++]];\n\n    while (j < arrayRight.count)\n        [resultArray addObject:arrayRight[j++]];\n\n    return resultArray;\n}\n```\n\n\nAnd using it like:\n\n```\n//Sample array\nNSArray *activeArray = @[@101,@201,@301,@121,@11,@123,@21,@14,@32,@76,@89,@987,@65];\n\nNSLog(@\"arrayMergeSort %@\",[self arrayMergeSort:activeArray]);\n```\n\n\nOutput would be:\n\n\n\nAnd also this bubble sort if you needed this:\n\n```\n- (NSArray *)arrayBubbleSort:(NSArray *)targetArray\n{\n    NSMutableArray *resultArray = [targetArray mutableCopy];\n\n    for (int k = 0; k < resultArray.count; k++)\n    {\n        for (int l = 0; l < resultArray.count; l++)\n        {\n            if ([resultArray[k] intValue] < [resultArray[l] intValue])\n            {\n                [resultArray exchangeObjectAtIndex:k withObjectAtIndex:l];\n            }\n        }\n    }\n\n    return resultArray;\n}\n```\n\n\nHope i've helped you.. Cheers..\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Problems In Python\r\n                \r\nSo I'm trying to teach myself how to write a merge sort but for whatever reason I can't seem to make it work.\n\n```\n    def merge(left, right):\n        result = []\n        i ,j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result\n\n    def mergesort(numlist):\n        if len(numlist) < 2:\n            return numlist\n        middle = int(len(numlist)/2)\n        left = mergesort(numlist[:middle])\n        right = mergesort(numlist[middle:])\n        return merge(left, right)\n```\n\n\nEvery list I feed into the sort then attempt to print just comes up the exact same with no changes\n    ", "Answer": "\r\nAnswering so this can be closed though it was fixed in comments with the help of @Jean-François Fabre.\n\nYour current code works fine but it does not sort the list in-place. In the case of sorting a list called ```\nlist_of_numbers```\n, you need to assign the result back to ```\nlist_of_numbers```\n:\n\n```\nlist_of_numbers = mergesort(list_of_numbers)```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort String Java\r\n                \r\nI am writing a program to merge sort words in a string.\nBut when I run my cod it seems to be loosing some data in some places.\nI tested it with the string: \"hello world the cat sat on the bloody mat\"\nbut all i get back is [bloody, cat, hello, mat]\n\nHere is my code:\n\n```\npackage mergeSort;\n\nimport java.util.LinkedList;\n\npublic class mergeSort\n{\n    public static String sort(String userInput)\n    {\n        if (userInput == null)\n        {\n            return \"\";\n        }\n        LinkedList<String> input = toList(userInput);\n\n        String output = MergeSort(input).toString();\n\n        return output;\n    }\n\n    private static LinkedList<String> toList(String input)\n    {\n        LinkedList<String> output = new LinkedList<String>();\n        String[] array = input.split(\"\\\\s\");\n\n        for (String element : array)\n        {\n            output.addFirst(element);\n        }\n        return (output);\n    }\n\n    private static LinkedList<String> MergeSort(LinkedList<String> inputstring)\n    {\n        LinkedList<String> sequence1 = new LinkedList<String>();\n        LinkedList<String> sequence2 = new LinkedList<String>();\n\n        if (inputstring.size() <= 1)\n        {\n            return inputstring;\n        }\n\n        for (int index = 0; index <= (inputstring.size() / 2); index++)\n        {\n            sequence1.addLast(inputstring.removeFirst());\n        }\n        while (!(inputstring.isEmpty()))\n        {\n            sequence2.addLast(inputstring.removeFirst());\n        }\n\n        sequence1 = MergeSort(sequence1);\n        sequence2 = MergeSort(sequence2);\n\n        return merge(sequence1, sequence2);\n    }\n\n    private static LinkedList<String> merge(LinkedList<String> sequence1,\n            LinkedList<String> sequence2)\n    {\n        LinkedList<String> merged = new LinkedList<String>();\n\n        while (!(sequence1.isEmpty()) && !(sequence2.isEmpty()))\n        {\n            if (sequence1.peekFirst().compareTo(sequence2.peekFirst()) < 0)\n            {\n                merged.addLast(sequence1.removeFirst());\n            }\n            else\n            {\n                merged.addLast(sequence2.removeFirst());\n            }\n        }\n\n        while (!(sequence1.isEmpty()))\n        {\n            merged.addLast(sequence1.removeFirst());\n        }\n        while (!(sequence1.isEmpty()))\n        {\n            merged.addLast(sequence2.removeFirst());\n        }\n\n        return (merged);\n    }\n}\n```\n\n\nThe testerclass:\n\n```\npackage mergeSort;\n\npublic class mainTester\n{\n\n    public static void main(String[] args)\n    {\n        String test = \"hello world the cat sat on the bloody mat\";\n\n        System.out.println(mergeSort.sort(test));\n\n        System.exit(0);\n\n    }\n\n}\n```\n\n    ", "Answer": "\r\nThe problem is here:\n\n```\n    while (!(sequence1.isEmpty()))\n    {\n        merged.addLast(sequence1.removeFirst());\n    }\n    while (!(sequence1.isEmpty()))\n    {\n        merged.addLast(sequence2.removeFirst());\n    }\n```\n\n\nIn your merge function. Both loops check ```\nsequence1```\n for emptiness. Replace the second ```\nsequence1```\n with ```\nsequence2```\n in the loop condition and all will be well.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "implementing/running merge sort in Python\r\n                \r\nI am writing a program in python and I am trying to implement the merge sort algorithm (and using a function called merge to handle the merge step) and I get an error below. I passed L = [2, 6, 4, 8, 1] to the parameter for merge sort:\n\n```\n>>> L = [2, 6, 4, 8, 1]\n>>> mergeSort(L)\nTraceback (most recent call last):\n  File \"<pyshell#1>\", line 1, in <module>\n    mergeSort(L)\n  File \"H:\\CSIS 4014\\WinPython-64bit-3.5.3.1Qt5\\notebooks\\sorts.py\", line 19, in mergeSort\n    mergeSort(left)\n  File \"H:\\CSIS 4014\\WinPython-64bit-3.5.3.1Qt5\\notebooks\\sorts.py\", line 21, in mergeSort\n    merge(L, left, right, p, q, r)\n  File \"H:\\CSIS 4014\\WinPython-64bit-3.5.3.1Qt5\\notebooks\\sorts.py\", line 24, in merge\n    left[len(left)+1] = 999999\nIndexError: list assignment index out of range\n```\n\n\nBelow is my source code:\n\n```\ndef mergeSort(L) :\n    p = 0\n    r = len(L) - 1\n    if p < r :\n        q = math.floor((p + r) / 2)\n        left = L[:q]\n        right = L[q+1:]\n        mergeSort(left)\n        mergeSort(right)\n        merge(L, left, right, p, q, r)\n\ndef merge(L, left, right, p, q, r) :\n        left[len(left)+1] = 999999\n        right[len(right)+1] = 999999\n        i = 1\n        j = 1\n        k = p \n        for k in range(r) :\n                if left[i] <= right[j] :\n                        L[k] = left[i]\n                        i = i + 1\n                elif L[k] == right[j] :\n                        j = j + 1\n```\n\n\nI am trying to use slices for the variables left and right of the subarrays as well as following pseudocode from my textbook. I would appreciate any help!\n    ", "Answer": "\r\n```\nleft[len(left)+1] = 999999\n```\n\n\nThis is always going to be an error... you're specifically trying to write to an element that doesn't exist. The last element of the list is at ```\nleft[len(left) - 1]```\n. Writing to any index beyond that is an error.\n\nPerhaps you meant to append instead?\n\n```\nleft.append(999999)\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Modified merge Sort Algorithm\r\n                \r\nDescribe a modified merge sort algorithm, in which a given sequence is split into split into three sub-sequences of equal size approximately one-third. Analyze asymptotically the time complexity of your algorithm. How to solve this?\n    ", "Answer": "\r\nThis is probably your homework but i would recommend that you do read chapter 2 from Cormen , Lierson and Rivest .\n\nsolve this recurrence relation -\nT(n) = 3T(n/3) + O(n) \n\nEvery problem is subdivided into 3 sub-problems and contain n/3 part of the original data. \nApply masters theorem to it and you will find that the answer is 0( n*log(n) ).\n\n```\nNote - here logarithm is of base 3 .\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Segmentation Fault Linked List Merge Sort\r\n                \r\nI am trying to sort linked list using merge sort but every time i get a segmentation fault i have been trying very hard from 2 days and ran debugger many times  please some one help . I followed approach of dividing the linked list into 2 parts and recursively calling merge sort .\n```\nvoid merge_sort(Node**head){\n    if((*head)->next == NULL){\n        return ;\n    }\n    Node *a , *b ;\n    FrontBackSplit( *head, &a, &b);\n    merge_sort(&a);\n    merge_sort(&b);\n    *head = merge(a,b);\n}\nNode *merge(Node *a , Node*b){\n    Node *result = NULL ;\n    if(a == NULL){\n        return b;\n    }\n    else if(b == NULL){\n        return a;\n    }\n        if(a->data <= b->data){\n            result = a;\n            result->next = merge(a ->next,b) ;\n        }\n        else {\n            result = b; \n            result->next = merge(a , b->next) ;\n        }\n    \n    return result ;\n}\n\nvoid FrontBackSplit(Node* source,\n                    Node** frontRef, Node** backRef)\n{\n    Node* fast;\n    Node* slow;\n    slow = source;\n    fast = source->next;\n \n    /* Advance 'fast' two nodes, and advance 'slow' one node */\n    while (fast != NULL) {\n        fast = fast->next;\n        if (fast != NULL) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n    }\n \n    /* 'slow' is before the midpoint in the list, so split it in two\n    at that point. */\n    *frontRef = source;\n    *backRef = slow->next;\n    slow->next = NULL;\n}\n```\n\n    ", "Answer": "\r\nYou should also consider the condition in which your head pointer itself is pointing to the null(In case the length is 0)(not just \"head -> next \" pointer).\nAnd then your first if would be like this:\n```\nvoid merge_sort(Node**head){\nif((*head)->next == NULL || (*head) == NULL ){\n    return ;\n}\nNode *a , *b ;\nFrontBackSplit( *head, &a, &b);\nmerge_sort(&a);\nmerge_sort(&b);\n*head = merge(a,b);\n```\n\n}\n`\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why is my merge sort slower than this merge sort?\r\n                \r\nI've implemented merge sort in C/C++. But my code takes longer time than the code I pulled from a website.\nThe recursive code seems to be exactly same for both cases:\n```\nvoid mergeSort(int* arr, int l, int h) {\n    if (l < h) {\n        int mid = (l + h) / 2;\n        mergeSort(arr,l,mid);\n        mergeSort(arr, mid + 1, h);\n        merge(arr, l, mid, h);\n    }\n}\n```\n\nHowever the merge algorithm is a bit different, but I don't see any significant difference here.\nMy merge algorithm :\n```\nvoid merge(int *arr, int l, int mid, int h) {\n    int i = l, j = mid+1, k = l;\n    int* newSorted = new int[h+1]();\n    while (i <= mid && j <= h) {\n        if (arr[i] < arr[j])\n            newSorted[k++] = arr[i++];\n        else\n            newSorted[k++] = arr[j++];\n    }\n    for (; i <= mid; i++)\n        newSorted[k++] = arr[i];\n    for (; j <= h; j++)\n        newSorted[k++] = arr[j];\n    k = 0;\n    for (int x = l; x <= h; x++)\n        arr[x] = newSorted[x];\n    delete[] newSorted;\n}\n```\n\nTime taken for 200000 (two hundred thousand inputs) :\n17 Seconds\nMerge Algorithm from a website :\n```\nvoid merge(int arr[], int p, int q, int r) {\n\n    int n1 = q - p + 1;\n    int n2 = r - q;\n\n    int* L = new int[n1];\n    int *M = new int[n2];\n    \n\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[p + i];\n    for (int j = 0; j < n2; j++)\n        M[j] = arr[q + 1 + j];\n\n\n    int i, j, k;\n    i = 0;\n    j = 0;\n    k = p;\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= M[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = M[j];\n            j++;\n        }\n        k++;\n    }\n\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = M[j];\n        j++;\n        k++;\n    }\n    delete[] L;\n    delete[] M;\n}\n```\n\nTime taken for 200000 (two hundred thousand inputs) :\n0 Seconds\nThere is a massive difference in time. I don't understand the problem in my code. I would really appreciate if someone can help me figure this out. Thank you.\n    ", "Answer": "\r\nYour algorithm need to allocate [h+1] for each step.\nThe algorithm from a website only need to allocate [r-p+1]\n(your h = its r, your l = its p)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort and Arrays\r\n                \r\nHi so im implementing a merge sort on an array with Objects of type person. Now im thinking theoretical here and i want advice on a non tedious approach as i realised my approach seems impractical. \n\nSo i have an array and i want to first merge sort the Surname in alphabetical order\nwhich i have done but then i want to split the array again and merge for each letter (e.g. A) the first name. So for example my array would look like: \n\n```\nBRUCE WAYNE\nJIM MORRIS\nALBERT EINSTEIN \nADAM BILL \n```\n\n\nSo the first merge is easy it would use the surname and merge:\n\n```\nADAM BILL\nALBERT EINSTEIN\nJIM MORRIS\nBRUCE WAYNE\n```\n\n\nThen what i want to do is for every letter say for instance all the surnames with A i want to group into an array and do another merge with the first name\nso like adam bill would go to an array with all the surnames that start with b and then would be merged in alphabetical order according to his first name. \nNow i cant figure out how im going to do this if there are 26 letters in the alphabet it seems pretty tedious to do 26 arrays. Can anyone help me figure out how i could do this with a modular design ? \n\nI have a file with hundreds of names\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort on Array of Int C++\r\n                \r\nI'm trying to create a program merge-sort on an array of int butI keep having troubles running this merge sort, it gives me a segment fault but I couldn't find anything wrong with it. In void mergesort when I put first <= last then the segment fault appears if not, then 5 5 5 5 is being print.\n\n```\n#include <iostream>\n\n using namespace std;\n\n\nvoid merge(int *arr, int size, int first, int middle, int last)\n{\n    int temp[size];\n    for(int i = first; i<=last; i++)\n    {\n       temp[i] = arr[i];\n    }\n    int i=first, j=middle+1, k=0;\n    while(i<=middle && j<=last)\n    {\n       if(temp[i] <= temp[j])\n       {\n          arr[k] = temp[i];\n          i++;\n       }\n       else\n       {\n          arr[k]=temp[i];\n          j++;\n       }\n       k++;\n    }\n    while(i<=middle)\n    {\n       arr[k]=temp[i];\n       k++;\n       i++;\n    }\n}\n\nvoid mergesort(int *arr, int size, int first, int last)\n{\n    if(first<last)\n    {\n       int middle = ( first + last )/2;\n       mergesort(arr,size,first,middle);\n       mergesort(arr,size,middle+1,last);\n       merge(arr,size,first,middle,last);\n    }\n}\nint main()\n{\n    cout <<\"Him\";\n    const int size = 10;\n    int numbers [] = {5,10,1,6,2,9,3,8,7,4};\n    mergesort(numbers,size,0,9);\n    for( int i= 0; i<size; ++i)\n    {\n        cout << numbers[i] << \" \";\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThere are (at least) two bugs. This:\n\n```\nelse\n{\n   arr[k]=temp[i];                                          \n   j++;\n}\n```\n\n\nshould be this:\n\n```\nelse\n{\n   arr[k]=temp[j];                                          \n   j++;\n}\n```\n\n\nand this:\n\n```\nint i=first, j=middle+1, k=0;\n```\n\n\nshould be this:\n\n```\nint i=first, j=middle+1, k=first;\n```\n\n\nIn general, you ought to learn to step through the code, at least by putting diagnostic output statements here and there. Once you have the hang of that you can move up to a good debugger.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C++ Merge Sort Visualizer\r\n                \r\nI am trying to make a c++ console application that tries to show you how merge sort looks like. I understand merge sort, and I created a program that organizes a vector of strings called sort_visualize, and each string in it is filled with many #. This is completely randomized for every string. The merge sort will organize them depending on length, instead of the traditional number organizing people do with it. Every time I make a change to the vector, I also clear the screen and print out the entire vector through a draw function, to give the effect of it actively visualizing the sort every frame. The problem is that when I use the draw function to print out the entire sort_visualize string, it does not print out any changes that I have made to it, and prints out the same thing over and over again until the end, when it finally prints the sorted order. What is going on? I Don't understand. I even tried changing the draw(sort_visualize) to draw(sort_visualize_), and that shows small areas of the vector it is working on. Makes no sense. Please try this code and tell me any solutions. Thank you.\n Here's the code:\n\n```\n#include <vector>\n#include <iostream>\n#include <ctime>\n#include \"stdlib.h\"\n#include \"windows.h\"\nusing namespace std;\n\n\nvoid merge_sort(vector<string> &sort_visual_);\nvoid merge_halves(vector<string>&left, vector<string>& right, vector<string>& sort_visual_);\nvoid draw(vector <string> &sort_visual_);\n\nvector <string> sort_visual;\n\nint main()\n{\n    srand(time(NULL));\n    //vector\n\n    vector<int> num_list;\n\n    //fill vector with random integers\n    for (int i = 0; i < 40; i++)\n        num_list.push_back(rand() % 40);\n\n    //Fill the visualizer strings which will be bars with #'s\n    for (int i = 0; i < num_list.size(); i++)\n    {\n        sort_visual.push_back(\"\");\n        string temp;\n        for (int j = 0; j < num_list.at(i); j++)\n        {\n\n            temp.push_back('#');\n        }\n        sort_visual.at(i) = temp;\n    }\n\n    draw(sort_visual);\n    system(\"pause\");\n\n    //sort function\n    merge_sort(sort_visual);\n\n}\n\n\n\nvoid merge_sort(vector<string> &sort_visual_)\n{\n\n    //dont do anything if the size of vector is 0 or 1.\n    if (sort_visual_.size() <= 1) return;\n\n    //middle of vector is size/2\n    int mid = sort_visual_.size() / 2;\n\n    //2 vectors created for left half and right half\n    vector<string> left;\n    vector<string> right;\n\n    //divided vectors\n    for (int j = 0; j < mid; j++)\n    {\n        left.push_back(sort_visual_[j]); //add all the elements from left side of original vector into the left vector\n\n    }\n    for (int j = 0; j < (sort_visual_.size()) - mid; j++)\n    {\n        right.push_back(sort_visual_[mid + j]);//add all the elements from right side of original vector into the right vector\n    }\n\n\n    //recursive function for dividing the left and right vectors until they are length of 1\n    merge_sort(left);\n    merge_sort(right);\n    //do the actual merging function\n    merge_halves(left, right, sort_visual_);\n}\n\n\nvoid merge_halves(vector<string>&left, vector<string>&right, vector<string>& sort_visual_) //pass in 3 vectors\n{\n\n    // sizes of each vector (left and right)\n    int nL = left.size();\n    int nR = right.size();\n\n    //declaring variables pointint to elements for each vector. i will represent finished produce vector\n    int i = 0, j = 0, k = 0;\n\n    //as long as j and k are less than the left and right sizes\n    while (j < nL && k < nR)\n    {\n\n        if (left[j].length() < right[k].length()) //if the string in the left vector is smaller than string in right vector\n        {\n            sort_visual_[i] = left[j];//ad the string from left vector in the sort_visuals vector(which is the final product)\n            j++;//increment j to move on\n\n\n        }\n        else\n        {\n            sort_visual_[i] = right[k];//otherwise add the string from right vector in the sort_visual vector\n\n            k++; //increment k to move on\n\n        }\n        i++; //i is the final vector, and we have to increment it to set it up to take in the next number\n\n\n        system(\"CLS\");\n        draw(sort_visual);\n        Sleep(15);\n\n    }\n\n    while (j < nL)\n    {\n        sort_visual_[i] = left[j];\n        j++; i++;\n\n\n        system(\"CLS\");\n        draw(sort_visual);\n        Sleep(15);\n    }\n\n    while (k < nR)\n    {\n        sort_visual_[i] = right[k];\n        k++; i++;\n\n        system(\"CLS\");\n        draw(sort_visual);\n        Sleep(15);\n    }\n\n\n\n}\n\nvoid draw(vector <string> &sort_visual)\n{\n    for (int i = 0; i < sort_visual.size(); i++)\n    {\n        cout << sort_visual.at(i) << endl;\n    }\n}\n```\n\n    ", "Answer": "\r\nIn merge_halves you work on sort_visual_ but draw sort_visual which is a global that does not seem to be changed. Make sure there are no globals and it will be harder to make mistakes.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java recursion and Merge Sort\r\n                \r\nI'm trying to write a simple merge sort program in Java, I'm seeing a lot of red in Eclipse. I'm still a beginner, and don't quite see whats wrong. thanks.\n\n-Kyle\n\n```\npublic class merge{ \npublic static int[] mergeSub(int[] array, int left, int right){\n        if(left<right)\n        {\n        int mid = (left+right)/2;\n        int[] a = mergeSub(array, left, mid);\n        int [] b = mergeSub(array, mid+1, right);\n        return merge(a, b);\n\n}\n        int[] arr=new int[1];\n        arr[0]=arr[left];\n        return arr;\n}\n\nstatic int[] merge(int[] left, int[] right){\n        int index =0; int indexLeft =0; int indexRight=0;\n        int[] result = new int[left.length+right.length];\n\n        while(indexLeft<left.length && indexRight<right.length){\n                if(left[indexLeft] <= right[indexRight])\n                {\n                        result[index]=left[indexLeft];\n                        index++;\n                        indexLeft++;\n\n                }\n                else{\n                        result[index]=right[indexRight];\n                        index++;\n                        indexRight++;\n                }\n        }\n\n        if (indexLeft<left.length){\n                while(indexLeft<left.length){\n                        result[index]=left[indexLeft];\n                        indexLeft++; index++;\n                }\n        }\n        if (indexRight<right.length){\n                while(indexRight<left[indexRight]){\n                        result[index]=right[indexRight];\n                        indexRight++; right[indexRight]++;\n                }\n        }\n        return result;\n}\n\n\n\npublic static void main(String args[]){\n\n        int[] array = {2, 4, 5, 7, 5, 6, 3, 5, 7, 8};\n        System.out.println(mergeSub(array, 0, 9));\n}}\n```\n\n    ", "Answer": "\r\nYou should start by making it less red in Eclipse :-)\n\nWhen you mouse over the error, it tells you what the error is. For example, in your ```\nmergeSub```\n code you're declaring ```\nleft```\n and ```\nright```\n as local arrays even though ```\nleft```\n and ```\nright```\n are already declared as ```\nint```\n parameters. Name your local variables differently.\n\nRinse and repeat.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Embed Intel Assembly Merge Sort Code in C++ (Inline assembly)\r\n                \r\nI want to embed this merge sort code (please see below) into my C++ Program (please see below as well) so that I can have a merge sort in my program that uses assembly. Yes, I am aware that I can write merge sort in C++, but it is very important that I embed this assembly instead. \n\nMerge Sort Code:\n\n```\n%include \"io.mac\"\n\n.DATA\nMAX_SIZE EQU 25\n%define ARR_LEN dword [n]\n\nPROMPT_ENTER_ARR_LEN db \"Enter size of your Array : \", 0\nPROMPT_ENTER_ELEMENTS db    \"Please enter elements of your array : \", 0\nprint_orig_array db \"Original Array \", 0\nprint_final_array   db  \"Sorted Array \", 0\nprint_space db \" \",0\nmerge_sort_debug_str db \"Merge Sort Params: EAX, ECX: \", 0\nmerge_sort_end_debug_str db \"End Merge Sort\", 0\nmerge_debug_str db \"Merge Params: EAX, EBX, ECX, EDX, EDI: \", 0\ncopy_debug_str db \"Copy Params: EAX, EBX, ECX: \", 0\ntemp_array_debug_str db \"Temp array: \", 0\nmerge_copy_back_temp_debug_str db \"Merge Copy back temp array: \", 0\n.UDATA\n;; Length of the array\nn       resd 1\n;; Array to be sorted\narr   resd MAX_SIZE\n;; Temporary storage array\ntemp_arr resd MAX_SIZE\n.CODE\n.STARTUP\n\nREAD_ARR_LEN:\n;; Read the length of the array\nPutStr PROMPT_ENTER_ARR_LEN\nnwln\nGetLInt [n]     ; Size of input array\nPutLInt [n]\nnwln\n\nGET_ARRAY:\n;; Get values in arr from the user\nmov   EAX, arr\nmov   ECX, ARR_LEN\ncall  Read_Arr\n\n;; Print the original array\nmov   ECX, ARR_LEN\nPutStr print_orig_array\ncall  Print_Arr\n\n;; Run Merge Sort on the array\nmov   EAX, arr\nmov   EBX, temp_arr\nmov   ECX, ARR_LEN\ncall  Merge_Sort\n\n;; Print the final array\nPutStr print_final_array\ncall  Print_Orig_Arr\n.EXIT\n\nMerge_Sort:\n;; EAX - Array start\n;; ECX - array length\n\n;; Arrays of size 0 or 1 are already sorted\ncmp   ECX, 2\njl    Trivial_Merge_Sort\n\n;; Merge_Sort (first half)\n;; Length of the first half\n;; ECX /= 2\npush  ECX\nshr   ECX, 1\ncall  Merge_Sort\npop   ECX\n\n;; Merge_Sort (second half)\npush  EAX\npush  EBX\npush  ECX\n\n;; Length of the second half\n;; ECX = ECX - ECX/2\nmov   EDX, ECX\nshr   EDX, 1\nsub   ECX, EDX\nimul  EDX, 4\n;; Start index of the second half\n;; EAX = EAX + (ECX/2) * 4\nadd   EAX, EDX\npush  EDX\ncall  Merge_Sort\npop   EDX\n\npop   ECX\npop   EBX\npop   EAX\n\npushad\n;; Merge (first half, second half)\n;; Length of first half = ECX/2\n;; Length of second half = ECX - ECX/2\nmov   EDX, ECX\nshr   ECX, 1\nsub   EDX, ECX\n\n;; Start of second half = EAX + (ECX/2) * 4\nmov   EBX, EAX\nmov   EDI, ECX\nimul  EDI, 4\nadd   EBX, EDI\n;; Index of temp array = 0\nsub   EDI, EDI\ncall  Merge\npopad\n\n;; Copy back the merged array from temp_arr to arr\ncall  Merge_Copy_Back_Temp\n\nret\n\nTrivial_Merge_Sort:\n;; In case of arrays of length 0 or 1\nret\n\nMerge:\n;; Merge two arrays contents.\n;; The final merged array will be in temp_arr\n;; Merging is done recursively.\n\n;; Arguments:\n;; EAX - First array's start\n;; EBX - Second array's start\n;; ECX - Length of first array\n;; EDX - Length of second array\n;; EDI - Index in temp array\npushad\n\n;; Handle the cases where one array is empty\ncmp   ECX, 0\njz    First_Array_Over\ncmp   EDX, 0\njz    Second_Array_Over\n\n;; Compare first elements of both the arrays\npush  EDX\npush  EDI\nmov   EDX, [EAX]\nmov   EDI, [EBX]\ncmp   EDX, EDI\npop   EDI\npop   EDX\n\n;; Pick which ever is the least and update that array\njl    Update_First_Array\njmp   Update_Second_Array\n\nUpdate_First_Array:\n;; min_elem = min (first elements of first array and second array)\n;; Put min_elem into the temp array\npush  dword [EAX]\npop   dword [temp_arr + EDI * 4]\nadd   EAX, 4\ndec   ECX\ninc   EDI\n\n;; Recursively call Merge on the updated array and the\n;; other array\ncall  Merge\npopad\nret\n\nUpdate_Second_Array:\n;; min_elem = min (first elements of first array and second array)\n;; Put min_elem into the temp array\npush  dword [EBX]\npop   dword [temp_arr + EDI * 4]\nadd   EBX, 4\ndec   EDX\ninc   EDI\n\n;; Recursively call Merge on the updated array and the\n;; other array\ncall  Merge\npopad\nret\n\nMerge_Copy_Back_Temp:\n;; Copy back the temp array into original array\n;; Arguments:\n;; EAX - original array address\n;; ECX - original array length\npushad\n\n;; For copying back, the destination array is EAX\nmov   EBX, EAX\n;; Now, the source array is temp_arr\nmov   EAX, temp_arr\ncall  Copy_Array\npopad\nret\n\nTrivial_Merge:\n;; Note: One array is empty means no need to merge.\npopad\nret\n\nFirst_Array_Over:\n;; Copy the rest of the second array to the temp arr\n;; because the first array is empty\npushad\nmov   EAX, EBX\nmov   ECX, EDX\nmov   EBX, temp_arr\nimul  EDI, 4\nadd   EBX, EDI\ncall  Copy_Array\npopad\npopad\nret\n\nSecond_Array_Over:\n;; Copy the rest of the first array to the temp arr\n;; because the second array is empty\npushad\nmov   EBX, temp_arr\nimul  EDI, 4\nadd   EBX, EDI\ncall  Copy_Array\npopad\npopad\nret\n\nCopy_Array:\n;; Copy array to destination array\n;; EAX - Array start\n;; EBX - Destination array\n;; ECX - Array length\n\n;; Trivial case\ncmp   ECX, 0\njz    Copy_Empty_Array\n\npush  ECX\nsub   EDI, EDI\ncopy_loop:\n;; Copy each element\npush  dword [EAX + EDI * 4]\npop   dword [EBX + EDI * 4]\ninc   EDI\nloop  copy_loop\n\npop   ECX\nret\n\nCopy_Empty_Array:\nret\n\nRead_Arr:\n;; EAX - array start\n;; ECX - array length\nPutStr PROMPT_ENTER_ELEMENTS\nnwln\nmov   ESI, EAX\nsub   EDI, EDI\nloop1:\n;; Read each element\nGetLInt [ESI + EDI * 4]\ninc   EDI\nloop  loop1\nret\n\nPrint_Temp_Arr:\n;; Print contents of temp_arr (for debugging)\npushad\nmov EAX, temp_arr\nmov ECX, ARR_LEN\ncall Print_Arr\npopad\nret\n\nPrint_Orig_Arr:\n;; Print contents of arr (for debugging)\npushad\nmov EAX, arr\nmov ECX, ARR_LEN\ncall Print_Arr\npopad\nret\n\nPrint_Arr:\n;; Print contents of an array\n;; EAX - Array start\n;; ECX - array length\nnwln\nmov   ESI, EAX\nsub   EDI, EDI\nnew_loop1:\nPutLInt [ESI + EDI * 4]\nPutStr print_space\ninc   EDI\nloop  new_loop1\nnwln\nret\n```\n\n\nC++ Code:\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n\nusing namespace std;\n\nint main()\n{\n   //insert assembly code here\n   return 0;\n}\n```\n\n    ", "Answer": "\r\nAT&T syntax - http://www.codeproject.com/Articles/15971/Using-Inline-Assembly-in-C-C \n\nINTEL Syntax - http://www.rohitab.com/discuss/topic/28661-inline-assembly-on-gcc-using-intel-syntax/\nand\nHow to set a variable in GCC with Intel syntax inline assembly?\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in parallel\r\n                \r\nI have using pascal for my parallel language .(I don't like it , but force.) So the \n\nMerge sort in parallel with fork & join not working, can some one tell me why?\n\nhere is my code :\n\n```\nprogram parrallelmergesort;\narchitecture shared(100);\nconst \n    n=100;(*big array*)\n    size=10;\nvar \n    t,globalCounter:integer;\n    unsorted:array[1..n] of integer;\n\nprocedure CallMerge(var lower,mid,high:integer);\n    var \n        i,j,k,count:integer;\n        S:array[1..n] of integer;\nBEGIN\n    i:=lower;\n    j:=mid+1;\n    k:=lower;\n    count:=high-lower+1;\n    while (i<=mid) and (j<=high) do\n        begin\n            if unsorted[i]<unsorted[j] then\n                begin\n                    S[k] :=unsorted[i];\n                    i :=i+1;\n                end\n            else\n                begin\n                    S[k] :=unsorted[j];\n                    j :=j+1;\n                end;\n            k:=k+1;\n        end;\n    if i>mid then\n        begin\n            while j<=high do\n                begin\n                    S[k] :=unsorted[j];\n                    j :=j+1;\n                    k :=k+1;\n                end;\n        end\n    else if j>high then\n        begin\n                while i<=mid do\n                begin\n                    S[k] :=unsorted[i];\n                    i :=i+1;\n                    k :=k+1;\n                end;\n        end;\n    for t:=lower  to high do\n            unsorted[t] :=S[t];\nend;\n\nprocedure CallMergeSort(bottom,up:integer);\n    var middle,nextOfMiddle:integer;\nbegin\n    if up>bottom then\n    begin\n        middle := (up+bottom) div 2;\n        nextofMiddle :=middle+1;\n        fork CallMergeSort(bottom,middle);\n        fork CallMergeSort(nextOfMiddle,up);\n        join;join;\n        CallMerge(bottom,middle,up);\n    end;\n\nend;\n\n\nbegin\n    unsorted[1] :=4; unsorted[2] :=3; unsorted[3] :=10; unsorted[4] :=5;   unsorted[5] :=0;\n    unsorted[6] :=1; unsorted[7] :=8; unsorted[8] :=6;  unsorted[9] :=11;  unsorted[10] :=12;\n    CallMergeSort(1,size);\n    for globalCounter:=1 to size do\n     writeln(unsorted[globalCounter]);\n    readln;\nend.\n```\n\n\nWhen should I use fork ? before CallMergeSort (Recursive) ?\n\nLast lines is main function in pascal.\n    ", "Answer": "\r\ndon't call fork and join inside the rec function.\nJust call them twice from the main.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "why is the standard merge sort not in place?\r\n                \r\nIn the merge algorithm of merge sort, I don't understand we have to use auxiliary arrays L, R? Why can't we just keep 2 pointers corresponding which element we're comparing in the 2 subarrays L and R so that the merge-sort algorithm remains inplace?\n\nThanks.\n    ", "Answer": "\r\nsay you split your array s.th. L uses the first half of the original array, and R uses the second half.\n\nthen say that durign merge the first few elements from R are smaller than the smallest in L. If you want to put them in the correct place for the merge result, you will have to overwrite elements from L that have not been processed during the merge step yet.\n\nof course you can make a diferent split. But you can always construct such an (then slightly different) example.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort is not working [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\ni'm working on merge sort, i know i got problem when one of the list goes \nempty while comparing..then it will print null values after that..\nhelp me out to handle the conditions..i couldn't use to conditional statements properly.\nThanks in advance..:)\n\n```\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid merge(int *a, int n, int *b, int m)\n{\n    int i=0, j=0, c[100], k=0;\n\n    //make traitment :\n    //================\n    while(i!=n && j!=m) {\n      if(i!=n)\n         c[k++] = a[i]>b[j] ? b[j++] : a[i++];\n      else\n        c[k++] = a[j];\n\n      if(j!=m)\n        c[k++] = a[i]>b[j] ? b[j++] : a[i++];\n      else \n        c[k++] = a[i];\n    }\n\n    //view the result :\n    //================\n        for(i = 0;i < (n+m);i++) { \n          printf(\"%d\\n\", c[i]); \n        }\n   }\nvoid main() {\n    int size,size2;\n    scanf(\"%d\", &size);\n    scanf(\"%d\", &size2);\n    int ar[size], br[size2],i;\n    for(i = 0; i < size; i++)\n      { \n        scanf(\"%d\", &ar[i]); \n      }\n    for(i = 0; i < size2; i++)\n      { \n        scanf(\"%d\", &br[i]); \n      }\n    merge(ar, size, br, size2);\n\n  }\n```\n\n    ", "Answer": "\r\nk should not be bigger than (m+n) - 1, so change the while condition as follow :\n\n```\n  while(k <= (m+n-1))\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort Recursion Error\r\n                \r\n```\n   Mergesort(a,p,r){\n     if(p<r){\n       int q=[p+r]/2;\n       Mergesort(a,p,q);\n       Mergesort(a,q+1,r);\n       Merge(a,p,q,r);\n```\n\n\nIt's from the book Introduction to ALgorithms:Cormen\nin this i can't understand the recursive call of the merge sort algorithm\n\n```\n                   2 4 1 6 8 5 3 7 \n               2 4 1 6         \n              2 4 \n             2\n```\n\n\nin the first recursive call i got upto three then where does the control goes from here i m struck at 2 will it call the next function mergesort(a,q+1,r) and merge(a,p,q,r) ?  \n    ", "Answer": "\r\nSuppose your array is ```\na = { 2, 4, 6, 1, 8, 5, 3, 7 }```\n. I swapped two elements of the array proposed by you. Now, what follows is exactly what your program does, call after call.\n\n\n\nAt the first call ```\np=0, q=7```\n: your while array is the input.\nAt the second call ```\np=0, q=3```\n, at the third ```\np=0, q=1```\n.\n\nAt the fourth call ```\np=0, q=0```\n: the input is the subarray ```\n{ 2 }```\n. This array has just one element, thus is sorted: the line ```\nif(p<r)```\n makes sure the fourth call ends here and control returns to the third call.\n\nThe third call has the input ```\n{ 2, 4 }```\n. We have just ended the line ```\nMergesort(a,p,q);```\n, thus we know the first half of the input is sorted. The fifth call (line ```\nMergesort(a,q+1,r);```\n) will now sort the second half.\n\nAt the  fifth call ```\np=1, q=1```\n. The input is once again an array of length 1, thus sorted by default. Control returns to the third call.\n\nThe third call is now evaluating the line ```\nMerge(a,p,q,r);```\n. The first half is sorted, the second half is sorted: ```\nMerge(a,p,q,r);```\n takes those two halves and shifts the element making sure the whole subarray from index ```\np```\n to index ```\nr```\n is sorted. The third call ends.\n\nThe second call had ```\n{ 2, 4, 6, 1 }```\n has input. The first half is sorted, now remains the second half: after that call the input become ```\n{ 2, 4, 1, 6 }```\n. After ```\nMerge```\n is called the input become ```\n{ 1, 2, 4, 6 }```\n and the second call ends, returning control to the first call.\n\nThe first call now needs to sort the second half of its input, that incidentally is the whole array. That is done as before.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort throws StackOverflowError\r\n                \r\nI have a simple merge sort function in Java that for list with larger than 3 length throw StackOverFlow exception ,\nI pass the array object each time with it's offset's to produce the stack storage but it throw stackOverFlow exception !!\n where is the problem ??\n\n```\npublic class DiviedAndConquer {\n\n/**\n * @param args\n */\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    DiviedAndConquer app=new DiviedAndConquer();\n    Integer[] arr={3,5,1,8};\n    app.mergSort(arr,0,arr.length-1);\n    for(int i = 0;i<=arr.length-1;i++)\n        System.out.print(arr[i]+\" \");\n\n\n}\npublic  void mergSort(Integer[] arr,int l,int h){\n    if(h-l>0){\n        int m=(h-l+1)/2;\n        //int l=arr.length-h;\n        mergSort(arr,l,m);\n        mergSort(arr,m+1,h);\n        merg(arr,l,h);\n    }\n\n}\npublic   void merg(Integer[] arr,int l,int h){\n    Integer[] tarr=new Integer[h-l+1];\n    for(int p=0;p<=h;p++)\n        tarr[p]=0;\n    int m=(h-l)/2;\n    int j=m+1;\n    int k=0;\n    int i=l;\n    while(i<=m && j<=h){\n        if(arr[j]<arr[i]){\n            tarr[k]=arr[j];\n            j++;\n        }\n        else{\n            tarr[k]=arr[i];\n            i++;\n        }\n        k++;\n    }\n\n    if(i<=m){\n        for(;i<=m;i++){\n            tarr[k]=arr[i];\n            k++;\n        }\n        k--;\n    }\n    else if(j<=h){\n        for(;j<=m;j++){\n            tarr[k]=arr[j];\n            k++;\n        }\n        k--;\n    }\n    for(int z=0;z<=k;z++){\n        arr[l+z]=tarr[z];\n    }\n\n}}\n```\n\n    ", "Answer": "\r\nYou are computing an incorrect middle index.\n\n```\nint m=(h-l+1)/2;\n```\n\n\nshould be\n\n```\nint m=(h+l)/2;\n```\n\n\nThat's probably the reason your recursion never ends.\n\nYou also have some errors in your ```\nmerg```\n method :\n\nChange \n\n```\npublic void merg(Integer[] arr,int l,int h) {\n    Integer[] tarr = new Integer[h-l+1];\n    for(int p=0;p<=h;p++)\n        tarr[p]=0;\n    int m=(h-l)/2;\n    ...\n```\n\n\nto\n\n```\npublic void merg(Integer[] arr,int l,int h){\n    Integer[] tarr = new Integer[h-l+1];\n    for(int p=0;p<tarr.length;p++) // corrected the range of the loop\n        tarr[p]=0;\n    int m=(h+l)/2; // the same fix of m calculation as before\n    ...\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge Sort Java\r\n                \r\nI'm trying to create a recursive merge sort and I'm not sure why its not working. I have read other threads and tried debugging, but the end result is not sorted and one element would change into something else. Here's the code:\n\n```\npublic static <E extends Comparable<E>> void mergeSort(E[] array){\n    mergeSortRec(array, 0, array.length-1);\n}\n\nprivate static <E extends Comparable<E>> void mergeSortRec(E[] array, int firstIndex, int lastIndex){\n    //base case: if length of array is 1\n    if (firstIndex == lastIndex)\n        //return on void method: terminates method\n        return;\n\n    //split the array\n    int mid = (firstIndex + lastIndex)/2;\n    //recursive case\n    mergeSortRec(array, firstIndex, mid);\n    mergeSortRec(array, mid+1, lastIndex);\n    merge(array, firstIndex, mid, mid+1, lastIndex );\n}\n\nprivate static <E extends Comparable<E>> E[] merge(E[] array, int leftFirst, int leftLast, int rightFirst, int rightLast){\n    //create temporary array whose size equals (rightLast - leftFirst + 1)\n    E tmp[] = (E[]) Array.newInstance(array.getClass().getComponentType(), rightLast - leftFirst + 1);\n    int indexLeft = leftFirst;\n    int indexRight = rightFirst;\n    int index = 0;\n\n    while(indexLeft < leftLast && indexRight < rightLast){\n        //left half element is smaller\n        if (array[indexLeft].compareTo(array[indexRight]) < 0){\n            tmp[index] = array[indexLeft];\n            indexLeft++;\n        }\n        //right half element is smaller\n        else{\n            tmp[index] = array[indexRight];\n            indexRight++;\n        }\n        index++;\n    }\n    //add remaining elements to list\n    while(indexLeft < leftLast){\n        tmp[index] = array[indexLeft];\n        indexLeft++;\n        index++;\n    }\n    while(indexRight < rightLast){\n        tmp[index] = array[indexRight];\n        indexRight++;\n        index++;\n    }\n    //copy tmp to list\n    System.arraycopy(tmp, 0, array, 0, tmp.length);\n    return array;\n}\n```\n\n    ", "Answer": "\r\nSince your starting and ending indexes are inclusive, this means the while conditionals in the merge function should use <=.  Also, when you do the arraycopy at the end, make sure the starting index of array is leftFirst, not 0.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort not working completely\r\n                \r\nThe code that I have made for merge sort is given below. The thing is that on giving the input the output is 3 2 1 5 0. What is going wrong?\n\n```\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint d[100];\n\nvoid merge(int a[], int b[], int c[], int n)\n{\nint n2=floor(n/2);\nint i=0, j=0, k=0;\nwhile(i<n2 && j<(n-n2))\n{\n    if(b[i]<c[j])\n    {\n        d[k++]=b[i++];\n    }\n    else if(b[i]>c[j])\n    {\n        d[k++]=c[j++];\n    }\n}\n    if(i==n2)\n    {\n        if(j<(n-n2))\n        {\n            d[k++]=c[j++];\n        }\n    }\n    if(i<n2)\n    {\n        d[k++]=b[i++];\n    }\n}\n\n\nvoid mergesort(int a[], int n)\n{\nint n2=floor(n/2);\nint b[50],c[50];\nint i,j=0,k=0;\nfor(i=0;i<n2;i++)\n{\n    b[i]=a[k++];\n}\nwhile(k<n)\n{\n    c[j++]=a[k++];\n}\nmerge(a,b,c,n);\n}\n\nint main()\n{\nint a[]={5,4,3,2,1};\nint n=5;\nmergesort(a,n);\nfor(int i=0;i<n;i++)\n{\n    cout<<d[i]<<endl;\n}\n}\n```\n\n    ", "Answer": "\r\nThe main problem is that the arrays (b and c) passed to merge are not sorted.\nOther problems are that the algorithm is not recursive and that merge\ndoes not always put all numbers from b and c into a.\n\nA version that seems to work with minimal changes to your code would be\n\n```\nvoid merge(int a[], int b[], int c[], int n)\n{\n  int n2=floor(n/2);\n  int i=0, j=0, k=0;\n  while(k<n)\n  {\n    if((j == (n-n2) || b[i]<c[j]) && i < n2)\n    {\n      a[k++]=b[i++];\n    }\n    else\n    {\n      a[k++]=c[j++];\n    }\n  }\n}\n\n\nvoid mergesort(int a[], int n)\n{\n  int n2=floor(n/2);\n  int b[50],c[50];\n  int i,j=0,k=0;\n  for(i=0;i<n2;i++)\n  {\n    b[i]=a[k++];\n  }\n  while(k<n)\n  {\n    c[j++]=a[k++];\n  }\n  if(n2 > 1) {\n    mergesort(b, n2);\n  }\n  if(n - n2 > 1) {\n    mergesort(c, n - n2);\n  }\n  merge(a,b,c,n);\n}\n\nint main()\n{\n  int a[]={5,4,3,2,1};\n  int n=5;\n  mergesort(a,n);\n  for(int i=0;i<n;i++)\n  {\n    cout<<a[i]<<endl;\n  }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Issues\r\n                \r\nHello everyone I am currently working on implementing a merge sort algorithim and I have gotten my code to work, but there is still something wrong with my work. For example when I enter \"1 3 5 2\" , I receive back \"1 3 5 5\". I would like some help locating my error as I am unable to do so even with cerr statements. Thank You\n\n```\nvector<int> VectorOps::mergeSort(vector<int> toSort)\n{\nif (toSort.size() <= 1)\n{\nreturn toSort;\n\n}\n\nstd::vector<int>::iterator middle = toSort.begin() + (toSort.size() / 2);\n\nvector<int> left(toSort.begin(), middle);\nvector<int> right(middle, toSort.end());\nleft = mergeSort(left);\nright = mergeSort(right);\ncerr << \"The numbers are \"<< endl;\nreturn merge(left, right);\n\n}\n\n\nvector<int> merge(const vector<int>& left, const vector<int>& right)\n{\n\n    vector<int> toReturn;\n    unsigned left_it = 0, right_it = 0;\n\n    while(left_it < left.size() && right_it < right.size())\n     {\n\n\n\n    if(left[left_it] < right[right_it])\n     {  \n    toReturn.push_back(left[left_it]);\n    left_it++;\n\n\n     }\n    else\n     {\n\n      toReturn.push_back(left[left_it]);\n      right_it++;\n     }\n   } \n    while(left_it < left.size())\n    {\n        toReturn.push_back(left[left_it]);\n        left_it++;\n    }\n\n    while(right_it < right.size())\n    {\n      toReturn.push_back(right[right_it]);\n      right_it++;\n\n    }\n\n\n\n\nreturn toReturn;\n\n}\n```\n\n    ", "Answer": "\r\nIn the first conditional of ```\nmerge```\n, both branches have\n\n```\ntoReturn.push_back(left[left_it]);\n```\n\n\nOne of them should be \n\n```\ntoReturn.push_back(right[right_it]);\n```\n\n\nAnd that is why copy and paste is considered harmful.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C#: Merge sort with Vectors [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm writing a program that needs to sort a list of houses based on their coordinates with the Euclidean Distance. To sort the list I use the merge sort algorithm. \n\nVector2 coordinates: are the coordinates of the buildings.\nVector2 house: is the coordinates of the main building.\n\nBelow is the class that does the merge sort:\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.Xna.Framework;\n\nnamespace EntryPoint\n{\npublic static class MergeSorter\n{\n    public static void DoMergeSort(this Vector2[] numbers)\n    {\n        var sortedNumbers = MergeSort(numbers);\n\n        for (int i = 0; i < sortedNumbers.Length; i++)\n        {\n            numbers[i] = sortedNumbers[i];\n        }\n    }\n\n    private static Vector2[] MergeSort(Vector2[] numbers)\n    {\n        if (numbers.Length <= 1)\n        {\n            return numbers;\n        }\n\n        var left = new List<Vector2>();\n        var right = new List<Vector2>();\n\n        for (int i = 0; i < numbers.Length; i++)\n        {\n            if (i % 2 > 0)\n            {\n                left.Add(numbers[i]);\n            }\n            else\n            {\n                right.Add(numbers[i]);\n            }\n        }\n\n        left = MergeSort(left.ToArray()).ToList();\n        right = MergeSort(right.ToArray()).ToList();\n\n        return Merge(left, right);\n    }\n\n    private static Vector2[] Merge(List<Vector2> left, List<Vector2> right)\n    {\n        var result = new List<Vector2>();\n\n        while (left.Count > 0 && right.Count > 0)\n        {\n            if (**left.First() <= right.First()**)\n            {\n                MoveValueToResult(left, result);\n            }\n            else\n            {\n                MoveValueToResult(right, result);\n            }\n        }\n        while (left.Count > 0)\n        {\n            MoveValueToResult(left, result);\n        }\n        while (right.Count > 0)\n        {\n            MoveValueToResult(right, result);\n        }\n        return result.ToArray();\n    }\n\n    private static void MoveValueToResult(List<Vector2> list, List<Vector2> result)\n    {\n        result.Add(list.First());\n        list.RemoveAt(0);\n    }\n\n    private static double GetEuclideanDistance(Vector2 coordinates, Vector2 house)\n    {\n        double distance = Math.Sqrt(Math.Pow((house.X - coordinates.X), 2) + Math.Pow((house.Y - coordinates.Y), 2));\n        return distance;\n    }\n}\n```\n\n\n}\n\nOn the line with the double asterisks: left.First() <= right.First(). There needs to come the GetEuclideanDistance() method, I think, but I don't get how?\n\nI tried something like the following: GetEuclideanDistance( of the first item in left list) <= GetEuclideanDistance(of the first item in right list). But then I dont know what kind of parameters I need to give then.\n    ", "Answer": "\r\nIf I understood you correctly, what you want to achieve is ```\nCollection```\n of ```\nVector2```\n coordinates sorted by their Euclidean Distance in relation to ```\nhouse```\n coordinates.\nIf so, that should be sufficient:\n\n```\n//Coordinates - coordinates list to sort\n//housePosition - position to which Euclidean distance should be calculated for every coordinate\nprivate static List<Vector2> SortByDistance(IEnumerable<Vector2> coordinates, Vector2 housePosition)\n{\n    return coordinates.OrderBy(coordinate => GetEuclideanDistance(coordinate, housePosition)).ToList();\n}\n\n\nprivate static double GetEuclideanDistance(Vector2 coordinates, Vector2 house)\n{\n    double distance = Math.Sqrt(Math.Pow((house.X - coordinates.X), 2) + Math.Pow((house.Y - coordinates.Y), 2));\n    return distance;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementing merge sort in python3\r\n                \r\nI don't know what's wrong here. can anyone help me do merge sort in python3.Please ,where did i go wrong....?\n\n```\ndef merge_help(a,b):\n    c=[]\n    j=0\n    i=0\n    while(i<len(a) and j<len(b)):\n        if(a[i]>=b[j]):\n            c.append(b[j])\n            j+=1\n        elif(a[i]<=b[j]):\n            c.append(a[i])\n            i+=1\n    while(j<len(b)):\n        c.append(b[j])\n        j+=1\n    while(i<len(a)):\n        c.append(a[i])\n        i+=1\n    return c\n    def merge(a):\n    if(len(a)>1):\n        mid =len(a)//2\n        l=a[:mid]\n        r=a[mid:]\n        merge(l)\n        merge(r)\n        merge_help(l,r)\n    print(a)\n```\n\n\n```\nmerge([12,11,13,5,6,7])```\n doesn't work.... no errors but same list is returned back every recursive step\n    ", "Answer": "\r\nYou are not capturing the output of merge_help, so you are not actually changing the values in the 'a' list.\n\nYou are also attempting to do this in-place, which is not possible with merge sort.\n\nIn your merge function, do this:\n\n```\ndef merge(a):\n    if(len(a) > 1):\n        # Divide the list in two\n        mid = len(a)//2\n        left_unsorted = a[:mid]\n        right_unsorted = a[mid:]\n\n        # Sort both halves\n        left_sorted = merge(left_unsorted)\n        right_sorted = merge(right_unsorted)\n\n        # Merge the two sorted lists\n        a_sorted = merge_help(left_sorted, right_sorted)\n    else:\n        a_sorted = a.copy()\n    return a_sorted\n```\n\n\nNote: this does not sort the passed list; it only returns a sorted version. So if you call it with orig_list, orig_list will be unchanged at the end.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in c++ with divide 3\r\n                \r\nHow can I write a merge sort but divide to 3?\n\n```\nint merge_sort(int input[], int p, int r)\n{\n    if ( p >= r )\n        return 0; \n\n    int mid = floor((p + r) / 2);\n    merge_sort(input, p, mid);\n    **merge_sort(input, mid + 1, r);** \n    merge(input, p, r);\n}\n```\n\n    ", "Answer": "\r\nThis is probably supposed to be a 3 way merge. You may want to consider using a bottom up merge sort. For either top down or bottom up merge, most of the complexity is going to be in the merge function. As mentioned in the answer linked to by zwergmaster, it's a 3 way merge of runs. Each run needs a current and ending index or pointer. A sequence of if / else statements end up doing two compares to determine which of 3 runs has the smallest element, and then that smallest element is moved to the destination array (or vector or ...) and the next element from that run is retrieved. When the end of one of the 3 runs is reached, the code switches into a 2 way merge. When the end of the next run is reached, the code copies the rest of the remaining run. Then the next set of 3 runs are merged, repeating the process until the end of the array is reached, which could happen within any of the 3 runs, so the last merge near the end of the array may be a merge of 3 or 2 runs, or just a copy of 1 run.\n\nIt would be more efficient to have an initial function that allocates a temp array the same size as the array to be sorted, then have it call the merge sort function passing the temp array as a parameter, rather than constantly allocating and freeing small temp arrays during the merge sort process.\n\nSo using top down merge sort partial code to help explain this:\n\n```\nmerge_sort(int *a, int n)\n{\n    int *b = new int[n];\n    top_down_merge_sort(a, b, 0, n);\n    /* ... */\n    delete[] b;\n}\n\ntop_down_merge_sort(int *a, int *b, int beg, int end)\n{\n    if(end - beg < 3){\n        /* sort in place */\n        return;\n    }\n    int run0 = beg;\n    int run1 = beg +   (end-beg)/3;\n    int run2 = beg + 2*(end-beg)/3;\n    top_down_merge_sort(a, b, run0, run1);\n    top_down_merge_sort(a, b, run1, run2);\n    top_down_merge_sort(a, b, run2, end);\n    merge_runs(a, b, run0, run1, run2, end);\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in Haskell\r\n                \r\nI am new to Haskell and I am trying to implement a few known algorithms in it.\n\nI have implemented merge sort on strings. I am a bit disappointed with the\nperformance of my Haskell implementation compared to C and Java implementations.\nOn my machine (Ubuntu Linux, 1.8 GHz), C (gcc 4.3.3) sorts 1 000 000 strings in 1.85 s,\nJava (Java SE 1.6.0_14) in 3.68 s, Haskell (GHC 6.8.2) in 25.89 s.\nWith larger input (10 000 000 strings), C takes 21.81 s, Java takes 59.68 s, Haskell\nstarts swapping and I preferred to stop the program after several minutes.\n\nSince I am new to Haskell, I would be interested to know if my implementation can\nbe made more time / space efficient.\n\nThank you in advance for any hint\nGiorgio\n\nMy implementation:\n\n```\nmerge :: [String] -> [String] -> [String]\nmerge [] ys = ys\nmerge xs [] = xs\nmerge (x:xs) (y:ys) = if x < y\n                        then x : (merge xs (y:ys))\n                        else y : (merge (x:xs) ys)\n\nmergeSort :: [String] -> [String]\nmergeSort xs = if (l < 2)\n                 then xs\n                 else merge h t\n               where l = length xs\n                     n = l `div` 2\n                     s = splitAt n xs\n                     h = mergeSort (fst s)\n                     t = mergeSort (snd s)\n```\n\n    ", "Answer": "\r\nTry this version:\n```\nmergesort :: [String] -> [String]\nmergesort = mergesort' . map wrap\n\nmergesort' :: [[String]] -> [String]\nmergesort' [] = []\nmergesort' [xs] = xs\nmergesort' xss = mergesort' (merge_pairs xss)\n\nmerge_pairs :: [[String]] -> [[String]]\nmerge_pairs [] = []\nmerge_pairs [xs] = [xs]\nmerge_pairs (xs:ys:xss) = merge xs ys : merge_pairs xss\n\nmerge :: [String] -> [String] -> [String]\nmerge [] ys = ys\nmerge xs [] = xs\nmerge (x:xs) (y:ys)\n = if x > y\n        then y : merge (x:xs)  ys\n        else x : merge  xs    (y:ys)\n\nwrap :: String -> [String]\nwrap x = [x]\n```\n\n\nBad idea is splitting list first. Instead of it just make list of one member lists. Haskell is lazy, it will be done in right time.\nThen merge pairs of lists until you have only one list.\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge Sort In C++\r\n                \r\nI'm trying to code a merge sort in c++, but building it gives me a warning that it's recursive, and running it gives a stack overflow. I don't understand where I'm doing wrong.\n\n```\nvoid mergesort(int thelist[]) {\n  if (sizeof(thelist) <= 1)\n    return;\n\n  int middle = (sizeof(thelist) / 2);\n  for (i = 0; i <= sizeof(thelist); i++){\n    if (i < middle)\n      lft[i] = thelist[i];\n    else if (i >= middle)\n      rght[i-middle] = thelist[i];\n  }\n  mergesort(lft);\n  mergesort(rght);\n  merge(lft, lft + 10, rght, rght + 10, sortedlist);\n}\n```\n\n    ", "Answer": "\r\n\nIf you want to handle different parts of ```\nint []```\n by calling the same function, try to define your function as\n\n```\nvoid mergesort(int thelist[], int start, int end)\n```\n\nRegarding the ```\nsizeof(thelist)```\n part, if you want to get the size of a ```\nint []```\n. You need to use\n\n```\nsizeof(thelist)\n```\n\n\ninstead of\n\n```\nsizeof(thelist)/sizeof(int)\n```\n\n\nExample:\n\n```\nint a[] = {1, 2, 3, 4, 5};\nint n = sizeof(a)/sizeof(int); // n=5 now\n```\n\n\n\nPS: You also need to think twice on your code logic and rewrite it. You main function should looks like the following:\n\n```\nvoid MergeSort(int data[], int start, int end)\n{\n    if (start < end)\n    {\n        int middle = (start+end)/2;\n\n        // sort for first part\n        MergeSort(data, start, middle);\n\n        // sort for second part\n        MergeSort(data, middle+1, end);\n\n        // merge both parts together\n        Merge(data, start, middle, end);\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why Insertion sort faster than Merge sort?\r\n                \r\nI created on jsperf.com test for 3 sorting methods: Bubble, Insertion and Merge. Link\n\nBefore test I create unsorted array with random number from 0 to 1Mln.\nEach time test shows that Insertion sort faster than Merge one.\nWhat's reason for such result, if Merge sort time O(n log(n)) while Insertion and Bubble sorts have O(n^2) \ntest result here \n    ", "Answer": "\r\nWithout more testing, a tentative answer:\n\nYour insertion sort is fairly optimised - you are only switching elements. Your merge sort instantiates new arrays using ```\n[]```\n, and creates new arrays using ```\nslice```\n and ```\nconcat```\n, which is a large memory-management overhead, not to mention that ```\nconcat```\n and ```\nslice```\n have implicit loops inside them (although in native code). Merge sort is efficient when it is done in-place; with all the copying going on, that should slow you down a lot.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Sort an Arraylist of objects using merge sort\r\n                \r\nI have an ArrayList of Item objects consisting of OrderNo and CustomerID. I want to order the list using merge sort according to OrderNo with their corresponding CustomerID intact.\n\nI understand the merge sort part of the problem as I've done it on normal arrays and even ArrayLists. But the problem in this scenario comes when I have to match the sorted OrderNo with its corresponding CustomerID.\n\n```\npublic class Items {\n    private int orderNo;\n    private int customerID;\n\n    public Items(int r, int c, String p) {\n        this.orderNo = r;\n        this.customerID = c;\n    }\n   //getters and setters\n}\n```\n\n\nThen I create an array list of Items and feed them values for orderNo and customerID.\n\n```\nArrayList<Items> i = new ArrayList<Items>();\ni.add(new Items(orderNo, customerID);\n```\n\n\nI need to sort them according to orderNo but also make sure the customerID matches with their corresponding orderNo.\n\nHere's the merge sort implementation:\n\n```\n private static ArrayList mergeSort(ArrayList<Integer> left, ArrayList<Integer> right, ArrayList<Integer> whole) {\n        int leftIndex = 0;\n        int rightIndex = 0;\n        int wholeIndex = 0;\n\n        while (leftIndex < left.size() && rightIndex < right.size()) {\n            if ( (left.get(leftIndex) < right.get(rightIndex))) {\n                whole.set(wholeIndex, left.get(leftIndex));\n                leftIndex++;\n            } else {\n                whole.set(wholeIndex, right.get(rightIndex));\n                rightIndex++;\n            }\n            wholeIndex++;\n        }\n\n        ArrayList<Integer> rest;\n        int restIndex;\n        if (leftIndex >= left.size()) {\n            // The left ArrayList has been use up...\n            rest = right;\n            restIndex = rightIndex;\n        } else {\n            // The right ArrayList has been used up...\n            rest = left;\n            restIndex = leftIndex;\n        }\n\n        for (int i=restIndex; i<rest.size(); i++) {\n            whole.set(wholeIndex, rest.get(i));\n            wholeIndex++;\n        }\n\n        return whole;\n    }\n\npublic static ArrayList<Integer> merge(ArrayList<Integer> a)\n    {\n        int total = a.size();\n        if(total < 2)\n        {\n            return a;\n        }\n        else\n        {\n            int mid = a.size() / 2;\n            ArrayList<Integer> left = new ArrayList<>();\n            ArrayList<Integer> right = new ArrayList<>();\n\n            for(int i = 0; i < mid; i++)\n            {\n                left.add(a.get(i));\n            }\n            for(int i = mid; i < total; i ++)\n            {\n                right.add(a.get(i));\n            }\n\n            left = merge(left);\n            right = merge(right);\n\n            return mergeSort(left, right, a);\n        }\n    }\n```\n\n\nThe above implementation works with a simple arraylist of values. I tried changing it to work with Items object by filtering out the orderNo's from Items and feeding it to the method... but I'm sure that's not the way to go about it since that messes up the relationship each orderNo has with each of its corresponding customerId.\n    ", "Answer": "\r\n\n  I need to sort them according to orderNo but also make sure the customerID matches with their corresponding orderNo.\n\n\nIf you implement sort correctly, it is not going to mess up the relationship between customerID and orderNo.  (The sort algorithm should not be calling the setter methods on the ```\nItems```\n objects.  You should be moving the items in the array / array list.)\n\nSo this question really boils down to implementing merge sort.  Since this is (apparently) a homework assignment, giving you source code defeats the purpose.  You would be advised to just knuckle down and write it yourself.\n\n\n\nOne hint though:  It will be simpler if you copy the ```\nArrayList```\n elements to an ```\nItems[]```\n array, sort the array, then copy them back.  Something like this:\n\n```\nItems[] array = new Items[list.size()];\nlist.toArray(array);\n\n// Sort the array here\n\nlist.clear();\nlist.addAll(Arrays.asList(array));\n```\n\n\n\n\nLooking at your code:\n\nYour big mistake (IMO) is that you are trying to sorting ```\nArrayList<Integer>```\n objects.  You should be sorting an ```\nArrayList<Items>```\n.  (I haven't looked at the method implementation ...)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Example\r\n                \r\nI am new to Java and I have tried writing a Merge Sort Program .\nMergeSort.java program is below :-\n\n```\npublic class MergeSort {\n\n    public static int b[] = {6,2,3,1,9};\n\n    public void MergeSort(int a[],int left[], int right[]) {\n\n        int i = 0,j = 0,k = 0;\n\n        int l = left.length;\n\n        int r = right.length;\n        int v = a.length;\n\n        while ( i < l && j < r) {\n            if( left[i] < right[j]) {\n                a[k] = left[i] ;\n                i++;\n            } else {\n                a[k] = right [j];\n                j++;\n            }\n            k++;\n        }\n        while ( i < l ) {\n            a[k] = left[i];\n            k++;\n            i++;\n\n        }\n        while ( j < r ) {\n            a[k] = right[j];\n            k++;\n            j++;\n\n        }\n\n    }\n\n    public void Merge(int a[], int length) {\n\n\n        int n = length;\n        if(n < 2) return;\n        int mid = n/2;\n\n        int left[] = new int[mid];\n        int right[] = new int[n-mid];\n        for (int i = 0 ; i <mid ; i++) {\n            left[i] = a[i];\n        }\n        for (int i = mid ; i <n ; i++) {\n            right[i-mid] = a[i];\n        }\n\n        Merge(right,n-mid);\n        Merge(left,mid);\n        MergeSort(b, left, right);\n\n    }\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n\n        MergeSort ms = new MergeSort();\n        ms.Merge(b,b.length);\n        for(int i=0 ; i < b.length ; i++)\n        System.out.println(b[i]);\n\n    }\n\n}\n```\n\n\nWhen I run this program , the output I get is \n\n```\n3\n1\n6\n2\n9\n```\n\n\nBut , the expected output is ```\n1 2 3 6 9```\n\n\nCan anyone please help me point out the mistake I am doing and try to help me fix it please .I have tried debugging it on Eclipse but could not spot the bug .\nThanks \n    ", "Answer": "\r\nAre you sure you meant this in function ```\nMerge```\n:\n\n```\nMergeSort(b, left, right);\n```\n\n\nIt seems it should be:\n\n```\nMergeSort(a, left, right);\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Problem with parallel iterative merge sort using OpenMP\r\n                \r\nI need to parallelize iterative merge sort (not using recursion) using OpenMP.\n\nThe excellent code for it is here:\n\nhttps://www.techiedelight.com/iterative-merge-sort-algorithm-bottom-up\n\nBut the resulting array is no longer sorted after using pragma parallel for.\n\n```\n// Iteratively sort array A[low..high] using temporary array\nvoid mergesort(int A[], int temp[], int low, int high)\n{\n    int m, i;\n    // divide the array into blocks of size m\n    // m = [1, 2, 4, 8, 16...]\n    for (m = 1; m <= high - low; m = 2*m)\n    {\n        // for m = 1, i = 0, 2, 4, 6, 8\n        // for m = 2, i = 0, 4, 8\n        // for m = 4, i = 0, 8\n        // ...\n        #pragma omp parallel for private (i)\n        for (i = low; i < high; i += 2*m)\n        {\n            int from = i;\n            int mid = i + m - 1;\n            int to = min(i + 2*m - 1, high);\n\n            merge(A, temp, from, mid, to);\n        }\n    }\n}\n```\n\n\nI have written such a code to check if the array is sorted, but it has shown that the resulting array is not sorted.\n\n```\nvoid check(int A[])\n{\n    int i;\n    for (i = 0; i < N - 1; i++)\n    {\n        if (A[i] > A[i + 1])\n        {\n            cout << \"Array is not sorted\" << endl;\n            return;\n        }\n    }\n    cout << \"Array is sorted\" << endl;\n}\n```\n\n\nSo, my code using pragma is wrong. Could you help me please to parallelize correctly iterative merge sort with OpenMP? I have to use pragma (\"parallel\", \"for\"). Is it possible?\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Writing merge sort in PHP\r\n                \r\nI have tried to write a basic merge sort in PHP involving a small array, yet the problem is it takes about a minute or so to execute, and returns:\n\n\n  Fatal error: Allowed memory size of 536870912 bytes exhausted (tried\n  to allocate 35 bytes) in /Users/web/www/merge.php on line 39\n\n\nDoes anyone have an idea where the code might be going wrong (if at all)? I've been staring at this for a good hour now.\n\n```\n<?php\n\n$array = array(8,1,2,5,6,7);\nprint_array($array);\nmerge_sort($array);\nprint_array($array);\n\nfunction merge_sort(&$list){\n    if( count($list) <= 1 ){\n        return $list;\n    }\n\n    $left =  array();\n    $right = array();\n\n    $middle = (int) ( count($list)/2 );\n\n    // Make left\n    for( $i=0; $i < $middle; $i++ ){\n        $left[] = $list[$i];\n    }\n\n    // Make right\n    for( $i = $middle; $i < count($list); $i++ ){\n        $right[] = $list[$i];\n    }\n\n    // Merge sort left & right\n    merge_sort($left);\n    merge_sort($right);\n\n    // Merge left & right\n    return merge($left, $right);\n}\n\nfunction merge(&$left, &$right){\n    $result = array();\n\n    while(count($left) > 0 || count(right) > 0){\n        if(count($left) > 0 && count(right) > 0){\n            if($left[0] <= $right[0]){\n                $result[] = array_shift($left);\n            } else {\n                $result[] = array_shift($right);\n            }\n        } elseif (count($left) > 0){\n            $result[] = array_shift($left);\n        } elseif (count($right) > 0){\n            $result[] = array_shift($right);\n        }\n    }\n\n    print_array($result);exit;\n\n    return $result;\n}\n\nfunction print_array($array){\n    echo \"<pre>\";\n    print_r($array);\n    echo \"<br/>\";\n    echo \"</pre>\";\n}\n\n?>\n```\n\n    ", "Answer": "\r\nIn your ```\nmerge```\n function, you call count on ```\nright```\n instead of ```\n$right```\n. PHP assumes this is a string constant (at least in 5.3.9) and when casted into an array that always has one element. So ```\ncount(right)```\n is always one, and you never exit the first merge.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Stack Overflow vb.net\r\n                \r\nIn my project, I want to make a merge sort on a list of one of my project's class :  \n\nFirstly, I made the comparison's operators for this class\n\n\n\n```\nPublic Class Programme\n\n    Private DateLimite As Date\n\n\n    Public Shared Operator >(ByVal p1 As Programme, ByVal p2 As Programme) As Boolean\n         Return p1.acces_DateLimite > p2.acces_DateLimite\n    End Operator\n\n    Public Shared Operator <(ByVal p1 As Programme, ByVal p2 As Programme) As Boolean\n         Return p1.acces_DateLimite < p2.acces_DateLimite\n    End Operator\n\n    Public Shared Operator >=(ByVal p1 As Programme, ByVal p2 As Programme) As Boolean\n         Return p1.acces_DateLimite >= p2.acces_DateLimite\n    End Operator\n\n    Public Shared Operator <=(ByVal p1 As Programme, ByVal p2 As Programme) As Boolean\n         Return p1.acces_DateLimite <= p2.acces_DateLimite\n    End Operator\n\nEnd Class \n```\n\n\n\nAfter that, I made the merge sort algorithm\n\n\n\n```\nPublic Function InsertListe(element As Programme, sequence As List(Of Programme)) As List(Of Programme)\n    Dim list = New List(Of Programme)\n    If sequence.Count = 0 Then\n        list.Add(element)\n        Return list\n    ElseIf element <= sequence.First Then\n        sequence.Insert(0, element)\n        Return sequence\n    Else\n        list.Add(sequence(0))\n        list.AddRange(InsertListe(element, sequence.GetRange(1, sequence.Count - 1)))\n        Return list\n    End If\nEnd Function\n\n\nPublic Function Merge(subSeq1 As List(Of Programme), subSeq2 As List(Of Programme)) As List(Of Programme)\n    If subSeq1.Count = 0 Then\n        Return subSeq2\n    ElseIf subSeq2.Count = 0 Then\n        Return subSeq1\n    Else\n        Return Merge(subSeq1.GetRange(1, subSeq1.Count - 1), InsertListe(subSeq1(0), subSeq2))\n    End If\nEnd Function\n\n\nPublic Function MergeSort(sequence As List(Of Programme)) As List(Of Programme)\n    Dim n = sequence.Count\n    If n = 0 Or n = 1 Then\n        Return sequence\n    Else\n        Return Merge(MergeSort(sequence.GetRange(0, (n + 1) / 2)), _\n                     MergeSort(sequence.GetRange((n + 1) / 2, n - ((n + 1) / 2))))\n    End If\nEnd Function\n```\n\n\n\n\nBut when I call it on a 'List(Of Programme)', a StackOverFlowException is thrown \nand I can't find why. I was looking at the call stack, and only the ''MergeSort'' function is called even if n is greater than 1.\n\nThanks in advance.\n    ", "Answer": "\r\nAfter replacing your ```\nProgramme```\n class with a ```\nUInteger```\n (just an example of plain datatype) and minor style tweaks, everything works for me:\n\n```\nPublic Shared Sub Test()\n    Dim oPRNG As New Random\n    For ndxTrial As Integer = 1 To 10\n        Console.Out.WriteLine(\"Trial # {0}\", ndxTrial)\n        Dim nItems As Integer = oPRNG.Next(5, 25)\n        Dim auValues As New List(Of UInteger)(nItems)\n        For ndxItem As Integer = 0 To nItems - 1\n            auValues.Add(CUInt(oPRNG.Next(0, 100)))\n        Next\n        Console.Out.WriteLine(\"Random: {0}\", FormatList(auValues))\n        Console.Out.WriteLine(\"Sorted: {0}\", FormatList(MergeSort(auValues)))\n        Console.Out.WriteLine()\n    Next\nEnd Sub\n\nPublic Shared Function FormatList(ByVal auValues As List(Of UInteger)) As String\n    Return String.Format(\"{{ {0} }}\", String.Join(\", \", auValues))\nEnd Function\n\nPublic Shared Function InsertListe(element As UInteger, sequence As List(Of UInteger)) As List(Of UInteger)\n    Dim list As New List(Of UInteger)\n    If sequence.Count = 0 Then\n        list.Add(element)\n        Return list\n    ElseIf element <= sequence.First Then\n        sequence.Insert(0, element)\n        Return sequence\n    Else\n        list.Add(sequence(0))\n        list.AddRange(InsertListe(element, sequence.GetRange(1, sequence.Count - 1)))\n        Return list\n    End If\nEnd Function\n\n\nPublic Shared Function Merge(subSeq1 As List(Of UInteger), subSeq2 As List(Of UInteger)) As List(Of UInteger)\n    If subSeq1.Count = 0 Then\n        Return subSeq2\n    ElseIf subSeq2.Count = 0 Then\n        Return subSeq1\n    Else\n        Return Merge(subSeq1.GetRange(1, subSeq1.Count - 1), InsertListe(subSeq1(0), subSeq2))\n    End If\nEnd Function\n\n\nPublic Shared Function MergeSort(sequence As List(Of UInteger)) As List(Of UInteger)\n    Dim n As Integer = sequence.Count\n    If n = 0 Or n = 1 Then\n        Return sequence\n    Else\n        Return Merge(MergeSort(sequence.GetRange(0, (n + 1) \\ 2)), _\n                     MergeSort(sequence.GetRange((n + 1) \\ 2, n - ((n + 1) \\ 2))))\n    End If\nEnd Function\n```\n\n\nThus the first thing to get rid in your code are those floating-point division operations ­— use back slash (integer division) instead of forward: that way you will guarantee proper rounding.\n\nRelated to this, it is also worth noting the importance of being explicit about your intentions and never rely on automatic type deduction. Instead of\n\n```\n    Dim n = sequence.Count\n```\n\n\nwrite\n\n```\n    Dim n As Integer = sequence.Count\n```\n\n\nand instead of\n\n```\n    Dim list = New List(Of Programme)\n```\n\n\nwrite\n\n```\n    Dim list As New List(Of Programme)\n```\n\n\nMoreover, always enable ```\nOption Strict```\n and ```\nOption Explicit```\n, as well as disable ```\nOption Infer```\n in project properties. That will save you much time from debugging mysterious errors.\n\nOverall, I hope this “project” is just your home assignment for language learning rather than a real application, because the selected algorithm together with selected container (a List in .Net is simply a dynamically reallocated array) is suboptimal beyond imagination.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort With Specific Arguments\r\n                \r\nI am supposed to write the merge sort function and merge function with the given arguments. However, my code does not print anything. I believe it goes into an endless recursive loop. I believe my logic is right. Any advice on where I went wrong would be appreciated.\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid merge(int* A, int n, int mid){\n  int *temp = (int*)malloc(sizeof(int)*n);\n  //set indexes for left and right side of array and \n  //the beginning of the temporary array\n  int array_index = 0; //temporary array\n  int left = 0; //left side\n  int right = mid;\n\n  while(left < mid && right < n){\n    if(A[left] < A[right]){\n      temp[array_index] = A[left];\n      left++;\n      array_index++;\n    }else if(A[right] < A[left]){\n      temp[array_index] = A[right];\n      right++;\n      array_index++;\n    }\n  }\n   while(left < mid){\n    temp[array_index] = A[left];\n    left++;\n    array_index++;\n  }\n  while(right< mid){\n    temp[array_index] = A[right];\n    right++;\n    array_index++;\n  }\n for(int i = 0; i<n; i++){\n    A[i] = temp[i];\n  }\n  free(temp);\n}\n\nvoid merge_sort(int *A, int n){\n    if(n>=2){\n    int mid = n/2;\n    merge_sort(A,mid);\n    merge_sort(A+mid,n-mid);\n    merge(A, n, mid);\n  }\n}\n\nint main(void) {\n  int arr[10] = {1,5,3,13,88,21,55,23,99,1};\n  merge_sort(arr, 10);\n  for(int i = 0; i<10; i++){\n    printf(\"%d \",arr[i]);\n  }\n  return 0;\n}\n```\n\n    ", "Answer": "\r\n```\nif(A[left] < A[right]){```\n should be ```\nif(A[left] <= A[right]){```\n\nand remove  ```\nif(A[right] < A[left])```\n from corresponding ```\nelse```\n clause\nalso\n```\nwhile(right< mid){```\n should be ```\nwhile(right< n){```\n\nCorrected code at Ideone gives ```\n1 1 3 5 13 21 23 55 88 99 ```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "how many variations of merge sort there are?\r\n                \r\ni'm looking to find how many different implementation of merge sort in .net there are because i was checking this post Sorting Algorithms in VB.Net: How To Implement Merge Sort and the article mentions that there are several other versions such as in-place and dunno what else...\n    ", "Answer": "\r\nToo many to count. As you can see here: http://en.wikipedia.org/wiki/Merge_sort, there are optimizations depending on the CPU for example. You can also always choose a different .NET language (a functional language like F# might be interesting) and you can also create a multi-threaded version.\nFor in-place sorting: If you can create a sorting algorithm that works in-place, it only needs O(n) space and not (for example) O(n log n). This might be important for large datasets.\n\nI guess there's been a lot of research on Merge Sort, so just check the papers on that topic if you need more implementations/variations.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Error Does not contain definition and no extension method\r\n                \r\nI am trying to call the class Merge Sort from the program.cs but an error keeps showing up that the project does not contain a definnition for 'Merge Sort' and no extension method 'Merge Sort' accepting a first argument of type 'projectname.MergeSort' could be found. Below is the code that I have of the 2 classes. Can anyone help pls? Thanks\n\nClass Merge Sort code:\n\n```\nclass MergeSort\n{\n    static public void MergeSorting(int[] array, int left, int mid, int right)\n    {\n        int[] temp = new int[25];\n        int i, left_end, num_elements, tmp_pos;\n\n        left_end = (mid - 1);\n        tmp_pos = left;\n        num_elements = (right - left + 1);\n\n        while ((left <= left_end) && (mid <= right))\n        {\n            if (array[left] <= array[mid])\n                temp[tmp_pos++] = array[left++];\n            else\n                temp[tmp_pos++] = array[mid++];\n        }\n\n        while (left <= left_end)\n            temp[tmp_pos++] = array[left++];\n\n        while (mid <= right)\n            temp[tmp_pos++] = array[mid++];\n\n        for (i = 0; i < num_elements; i++)\n        {\n            array[right] = temp[right];\n            right--;\n        }\n    }\n\n    static public void MergeSort_Recursive(int[] array, int left, int right)\n    {\n        int mid;\n\n        if (right > left)\n        {\n            //splitting array into 2\n            mid = (right + left) / 2;\n            MergeSort_Recursive(array, left, mid);\n            MergeSort_Recursive(array, (mid + 1), right);\n\n            MergeSorting(array, left, (mid + 1), right);\n        }\n    }\n}\n```\n\n\nClass program.cs code:\n\n```\n//array to be sorted\n        int[] array = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };\n\n        //sort the array using merge sort\n        MergeSort mSort = new MergeSort();\n        int[] mergeSortedArray = mSort.MergeSort(array);\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementing merge sort algorithm issue\r\n                \r\nI am implementing a merge sort algorithm and I am receiving an std::bad_alloc in the merge algorithm  and using the cerr statement I have found that my error is in first loop of the merge algorithm. However I am unable to figure out what is wrong.\n\n```\nvector<int> VectorOps::mergeSort(vector<int> toSort)\n{\n    if(toSort.size() <= 1)\n    {\n        return toSort;\n\n    }\n    vector<int> left;\n    vector<int> right;\n\n    int half = toSort.size()/2;\n    for(int i = 0; i < half; ++i)\n    {\n        left.push_back(toSort.at(i));\n    }\n\n    for(int i = half; i < toSort.size(); ++i)\n    {\n        right.push_back(toSort.at(i));\n    }\n\n    //merge algorithim\n\n    vector<int> toReturn;\n    while(left.size() > 0 || right.size() > 0)\n    {\n        cerr << \"The numbers are \"<< endl;\n        if(left.size() > 0 && right.size() > 0)\n        {\n            if(left.at(0) <= right.at(0))\n            {\n                toReturn.push_back(left.at(0));\n            }\n            else\n            {\n                toReturn.push_back(right.at(0));\n            }\n        }\n        else if(left.size() > 0)\n        {\n            toReturn.push_back(left.at(0));\n        }\n        else if(right.size() > 0)\n        {\n            toReturn.push_back(right.at(0));\n        }\n    }\n\n    return toReturn;\n}\n```\n\n    ", "Answer": "\r\nIn:\n\n```\nwhile(left.size() > 0 || right.size() > 0)\n```\n\n\nThe size of ```\nleft```\n and ```\nright```\n never change (you don't remove the head element) so ```\ntoReturn```\n grows without bound and you run out of memory.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort for 2D Char Array C++\r\n                \r\nI have 2D char array and I can't think of a way to merge sort. I have tested my merge sort algorithm for 1D int array but can't figure out how to do for 2D char array.\nI have used std::string class to sort and made my lives easier but I just want to try out with 2D char array without using any STL and string class.\nI saw a similar post but that was used for c#.\n```\nmy_2D_array[5][20] = {\n       {'a', 'p', 'p', 'l', 'e'}, \n       {'a', 'i', 'r'}, \n       {'a', 'n', 'c', 'h', 'o', 'r'}, \n       {'c', 'a', 't'}, \n       {'c', 'o', 'u', 'g', 'h'}                      \n}\n```\n\nMerge sort algorithm for sorting int 1D array\n```\nvoid merge(int array[], int left, int center, int right){\n\n    auto sub_arr_one_size = center - left + 1;\n    auto sub_arr_two_size = right - center;\n\n\n    // 1st temp arrays\n    auto *sub_arr_one = new int(sub_arr_one_size);\n    for (auto i  = 0; i < sub_arr_one_size; i++){\n        sub_arr_one[i] = array[left + i];\n    }\n\n    // 2nd temp arrays\n    auto *sub_arr_two = new int(sub_arr_two_size);\n    for (auto i = 0; i < sub_arr_two_size; i ++){\n        sub_arr_two[i] = array[center + i + 1];\n    }\n\n    auto sub_arr_one_idx = 0, sub_arr_two_idx = 0; \n    int merge_arr_idx = left; // Initial index of merged array\n    \n    while (sub_arr_one_idx < sub_arr_one_size && \n          sub_arr_two_idx < sub_arr_two_size){\n            \n            if (sub_arr_one[sub_arr_one_idx] <= sub_arr_two[sub_arr_two_idx]){\n                array[merge_arr_idx] = sub_arr_one[sub_arr_one_idx];\n                sub_arr_one_idx++;\n            }\n\n            else{\n                array[merge_arr_idx] = sub_arr_two[sub_arr_two_idx];\n                sub_arr_two_idx++;\n            }\n            merge_arr_idx ++;\n    \n    }\n\n    while (sub_arr_one_idx < sub_arr_one_size){\n        array[merge_arr_idx] = sub_arr_one[sub_arr_one_idx];\n        sub_arr_one_idx++;\n        merge_arr_idx++;\n    }\n\n    while (sub_arr_two_idx < sub_arr_two_size){\n         array[merge_arr_idx] = sub_arr_two[sub_arr_two_idx];\n         sub_arr_two_idx++;\n         merge_arr_idx++;\n    }\n    \n    delete sub_arr_one;\n    delete sub_arr_two;\n}\n\nvoid mergeSort(int array[], int left, int right){\n    if (left < right){\n        auto center = (left + right) / 2;\n        mergeSort(array, left, center);\n        mergeSort(array, center + 1, right);\n        merge(array, left, center, right);\n    }\n}\n \n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort vs Radix Sort : Merge sort taking O(n (log n)^2) time in special cases?\r\n                \r\nI was reading about efficiency of Radix sort compared to comparison based sorting algorithms, where i found this piece :\n\n\n  For example, consider a bottom-up merge sort. The first pass will compare pairs of random keys, but the last pass will compare keys that are very close in the sorting order. This makes merge sort, on this class of inputs, take O(n (log n)2) time.\n\n\nCan someone help me understand the ```\nO(n (log n)2)```\n part ?\n    ", "Answer": "\r\nAssuming constant compare time == O(1), then merge sort is O (n log(n)). Assuming compare time is O(log(n)), then merge sort is O(N (log(n))^2). The assumption here is based on minimum key size for n distinct keys, which is log2(n) bits. However, key size is usually independent of n, and is either constant, or the average size of all keys in a set of n elements would be constant, in which case the time complexity is O(n log(n)).\n\nThe point being made is more about radix sort, where the number of passes is based on how many parts the key is separated into. For example, if the key is 64 bits, and radix sort is done 4 bits at a time, it takes 16 passes. If the key size is 28 characters, and radix sort is done 1 character at a time, then it takes 28 passes. If considering the minimum key size for n distinct keys, which is log2(n) bits, and if sorting by 8 bits at a time, then it takes log256(n) passes. For example sorting 2^32 keys, means the keys are 32 bits in size, and sorting by 8 bits at a time will take 4 passes. For 2^64 keys, it's 64 bits per key and 8 passes.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to combine insertion sort and merge sort to make it more efficient in c++ [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\n```\n#include<iostream>\n#include<stdio.h>\n#include<time.h>\nusing namespace std;\n#define ARRAYLENGTH 40\nvoid InsertionSort(int * nums, int arrayLength);\nvoid MergeSort(int * numlist1, int p, int r);\nvoid Merge(int * numsl, int p, int q,int r);\n\nvoid main(int argc, char* argv[])\n{\n    int nums1[ARRAYLENGTH],numsl[ARRAYLENGTH];\n    for (int i = 0; i < ARRAYLENGTH; i++)\n    {\n        nums1[i] = rand() % 10000;\n    }\n    cout << \"arraylength = \" << ARRAYLENGTH << endl;\n    cout << \"Before Sorting\" << endl;\n    for (int i = 0; i < ARRAYLENGTH; i++)\n    {\n        cout << nums1[i] << \"\\t\";\n    }\n    cout << endl;\n\n    clock_t startTime1 = clock();\n    InsertionSort(nums1, ARRAYLENGTH);\n    clock_t endTime1 = clock();\n\n    cout << \"Running Time for Insertion Sort is \" << (endTime1 - startTime1) / 1000 << endl;\n    for (int i = 0; i < ARRAYLENGTH; i++)\n    {\n        cout << nums1[i] << \"\\t\";\n    }\n    cout << endl;\n    cout << \"After Insertion Sorting\" << endl;\n\n    for (int i = 0; i < ARRAYLENGTH; i++)\n    {\n        numsl[i] = rand() % 10000;\n    }\n\n    clock_t startTime2 = clock();\n    MergeSort(numsl, 0, ARRAYLENGTH-1);\n\n    clock_t endTime2 = clock();\n    cout << \"Running Time for Merge Sort is \" << (endTime2 - startTime2) / 1000 << endl;\n\n    for (int i = 0; i < ARRAYLENGTH; i++)\n    {\n        cout << numsl[i] << \"\\t\";\n    }\n    cout << endl;\n    cout << \"After Merge Sorting\" << endl;\n    getchar();\n}\n```\n\n\nthis's the code for main function\n\n```\n void InsertionSort(int * numList, int arrayLength)\n    {\n        // your code here\n        int i,j,key;\n        for (j=1;j<arrayLength;j++)\n        {\n            key=numList[j];\n            i=j-1;\n            while(i>=0 && numList[i]>key)\n            {numList[i+1]=numList[i];\n            i=i-1;\n            }\n            numList[i+1]=key;\n        }\n    }\n\n\n //this is the code of insertion sort\n\n\n\n\nvoid MergeSort(int * numList, int p, int r)\n    {\n\n         if(p<r)\n        {  \n            int q=(p+r)/2;  \n            MergeSort(numList,p,q);  \n            MergeSort(numList,q+1,r);  \n            Merge(numList,p,q,r);  \n        }  \n\n    }\n\n    void Merge(int * numsl, int p, int q,int r)\n    {\n        int n1 = q - p + 1;\n        int n2 = r - q;\n        int * nums1 = (int *)malloc(sizeof(int) * (n1+1));\n        int * nums2 = (int *)malloc(sizeof(int) * (n2+1));\n        // your code here\n        int i,j,k;\n        for(i=0;i<n1;i++)\n            nums1[i]=numsl[p+i];\n        for(j=0;j<n2;j++)\n            nums2[j]=numsl[q+j+1];\n        nums1[n1]=10000;\n        nums2[n2]=10000;\n        i=0;\n        j=0;\n        for(k=p;k<=r;k++)\n        {\n            if (nums1[i]<=nums2[j])\n                {numsl[k]=nums1[i];\n                    i=i+1;}\n            else\n                {numsl[k] = nums2[j];\n            j=j+1;}\n    }\n```\n\n\nHow to make the new combined algorithm using merge sort firstly then when have been divided in some degree  using insertion sort, and how to find the array length N?as is known to all, in small numbers, insertion sort is faster than merge sort, when it comes to large numbers, merge sort is much faster, I am thinking to make a combination of those two to make it more efficient? Specifically, to merge sort can be break down into divide and merge, I am considering when dividing in some level, using insertion sort , but I have trouble to how to find the level in which switch to insertion sort and how to implement it.\n    ", "Answer": "\r\nExample code. I changed r to be the ending index (last + 1).\n\n```\nvoid MergeSort(int * numList, int p, int r)\n{\n    int n = r-p;\n    if(n < 2)\n        return;\n    if(n <= 32){                  // 16 to 128 are reasonable values\n        InsertionSort(numList, n)\n        return;\n    }\n    int q=(p+r)/2;  \n    MergeSort(numList,p,q);  \n    MergeSort(numList,q,r);  \n    Merge(numList,p,q,r);  \n}\n```\n\n\nWith the change to r, the calling code would be:\n\n```\n    MergeSort(array, 0, sizeof(array)/sizeof(array[0]));\n```\n\n\nIf performance is the goal, a bottom up merge sort is slightly faster. Most libraries use some variation of a hybrid insertion + bottom up merge sort. Top down merge sort is mostly used for educational purposes.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Javascript - Merge Sort Visualizer using CSS Style to Sort, having issues\r\n                \r\nI am having an issue with my merge sort visualizer.\nMy program has no issues visualizing bubble sort or quick sort, as I can do the swapping operation of css property values in-place, but I am having major issues trying to get merge sort to work properly. The issue arises when I try to update a css property on the dom, it causes the sort to not function.\nI have tried passing in copies of the data I wish to sort, and all sorts of weird things I could think of to make it work. I am currently trying to sort by the css property 'maxWidth'. I use that to display how large a div element is in the html file and then visualize the sort from there.\nMy latest thought has been to set all the div elements to have another css property equal to the maxWidth (I am using fontSize as it does not affect my program) and then sorting based on fontSize, allowing me in theory to change the maxWidth properties of the divs without affecting merge sorts algorithm.\nI am including my entire js file as I hope reading my correctly working bubble sort or quick sort functions can help you see what I am trying to achieve. Thank you so much for taking the time to read this and offer any help!\nImportant Note: I am not trying to visualize the individual steps of merge sort yet because I am unable to update the final result to the html page without affecting the merge sort algorithm. According to console logs, my merge sort algorithm does indeed work, I just can't update the DOM without messing it up. Once I can do that, I will turn it into an asynchronous function using async and await like I previously did with bubble and quick sort.\n```\n/********* Generate and Store Divs to be Sorted *************/\nconst generateSortingDivs = (numOfDivs) => {\n    const divContainer = document.querySelector('.div-container');\n    let html = '';\n    for (let i = 0; i < numOfDivs; i++) {\n        let r = Math.floor(Math.random() * 100);\n        html += `<div class='sorting-div' id='id-${i}' style='max-width: ${r}%'>&nbsp</div>`;\n    }\n    divContainer.innerHTML = html;\n    for(let i = 0; i < numOfDivs; i++) {\n        let x = document.getElementById('id-' + i);\n        x.style.fontSize = x.style.maxWidth;\n    }\n}\n\nconst storeSortingDivs = () => {\n    const divContainer = document.querySelector('.div-container');\n    let divCollection = [];\n    const numOfDivs = divContainer.childElementCount;\n\n    for(let i=0; i<numOfDivs; i++) {\n        let div = document.getElementById('id-' + i);\n        divCollection.push(div);\n    }\n\n    return divCollection;\n}\n\n/********** SLEEP FUNCTION ************/\n//Used to allow asynchronous visualizations of synchronous tasks\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/******* SWAP FUNCTIONS *********/\n//Used for Testing Algorithm before Animating Visualization\nconst syncSwap = (div1, div2) => {\n    let tmp = div1.style.maxWidth;\n    div1.style.maxWidth = div2.style.maxWidth;\n    div2.style.maxWidth = tmp;\n}\n\nasync function asyncSwap(div1, div2) {\n    await sleep(50);\n    let tmp = div1.style.maxWidth;\n    div1.style.maxWidth = div2.style.maxWidth;\n    div2.style.maxWidth = tmp;\n}\n\nconst swapDivs = (smallerDiv, biggerDiv) => {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            let tmp = smallerDiv.style.maxWidth;\n            smallerDiv.style.maxWidth = biggerDiv.style.maxWidth;\n            biggerDiv.style.maxWidth = tmp;\n            resolve();\n        }, 50);\n    });\n}\n\n/****************************************/\n/*********** SORTING ALGO'S *************/\n/****************************************/\n\n/******* BUBBLE SORT ***********/\nasync function bubbleSort(divCollection) {\n    displayBubbleSortInfo();\n    const len = divCollection.length;\n    for(let i=0; i<len; i++) {\n        for(let j=0; j<len-i-1; j++) {\n            divCollection[j].style.backgroundColor = \"#FF4949\";\n            divCollection[j+1].style.backgroundColor = \"#FF4949\";\n\n            let numDiv1 = parseInt(divCollection[j].style.maxWidth);\n            let numDiv2 = parseInt(divCollection[j+1].style.maxWidth);\n            let div1 = divCollection[j];\n            let div2 = divCollection[j+1];\n            if(numDiv1 > numDiv2) {\n                await swapDivs(div2, div1);\n            }\n            divCollection[j].style.backgroundColor = \"darkcyan\";\n            divCollection[j+1].style.backgroundColor = \"darkcyan\";\n        }\n        divCollection[len - i - 1].style.backgroundColor = 'black';\n    }\n}\n\nfunction displayBubbleSortInfo(){\n    const infoDiv = document.querySelector('.algo-info');\n    let html = `<h1>Bubble Sort Visualizer</h1>`;\n    html += `<h2>Time Complexity: O(n^2)</h2>`;\n    html += `<h3>Space Complexity: O(1)</h3>`;\n    html += `<p>This sorting algorithm loops through the array and continues to push the \n               largest found element into the last position, also pushing the last available\n               position down by one on each iteration. It is guaranteed to run in exactly \n               O(n^2) time because it is a nested loop that runs completely through.</p>`;\n    infoDiv.innerHTML = html;\n}\n\n/****** QUICK SORT ********/\nasync function quickSort(divCollection, start, end) {\n    if(start >= end) return;\n\n    let partitionIndex = await partition(divCollection, start, end);\n\n    await Promise.all([quickSort(divCollection, start, partitionIndex - 1), quickSort(divCollection, partitionIndex + 1, end)]);\n}\n\n/* This function takes last element as pivot, places\n   the pivot element at its correct position in sorted\n    array, and places all smaller (smaller than pivot)\n   to left of pivot and all greater elements to right\n   of pivot */\nasync function partition(divCollection, start, end) {\n    let pivotIndex = start;\n    let pivotValue = parseInt(divCollection[end].style.maxWidth);\n    for(let i = start; i < end; i++) {\n        if(parseInt(divCollection[i].style.maxWidth) < pivotValue) {\n            await asyncSwap(divCollection[i], divCollection[pivotIndex]);\n            pivotIndex++;\n        }\n    }\n    await asyncSwap(divCollection[pivotIndex], divCollection[end]);\n    return pivotIndex;\n}\n\nfunction displayQuickSortInfo(){\n    const infoDiv = document.querySelector('.algo-info');\n    let html = `<h1>Quick Sort Visualizer</h1>`;\n    html += `<h2>Time Complexity: O(n log n)</h2>`;\n    html += `<h3>Space Complexity: O(log n)</h3>`;\n    html += `<p>This sorting algorithm uses the idea of a partition to sort\n                each iteration recursively. You can implement quick sort\n                in a variety of manners based on the method in which you\n                pick your \"pivot\" value to partition the array. In this\n                visualization, I implemented the method that chooses the \n                last element of the array as the pivot value. You could\n                also choose the first value, the middle value, or the median\n                value based on the first, middle, and last values.</p>`;\n    infoDiv.innerHTML = html;\n}\n\n/* Merge Sort does not sort in place, and thus we have to be\n*  clever when implementing it and also editing the css style\n*  of our divs to show the visualization of how the algorithm\n*  works. My method is to store a copy of the divs, that way\n*  I can use one to be sorted by merge sort, and the other to\n*  change the css style property to show the visualization.\n*  Unlike Quick Sort and Bubble Sort, we are not swapping\n*  elements when sorting, instead we are merging entire\n*  arrays together as the name implies.                     */\nfunction mergeSort(divCollection) {\n    if(divCollection.length < 2) return divCollection;\n    let middleIndex = Math.floor(divCollection.length / 2);\n    let left = divCollection.slice(0, middleIndex);\n    let right = divCollection.slice(middleIndex);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n    let mergedCollection = [];\n    while(left.length && right.length) {\n        if(parseInt(left[0].style.fontSize) < parseInt(right[0].style.fontSize || right.length === 0)) {\n            let el = left.shift();\n            mergedCollection.push(el);\n        } else {\n            let el = right.shift();\n            mergedCollection.push(el);\n        }\n    }\n\n    let res = mergedCollection.concat(left.slice().concat(right.slice()));\n\n    return res;\n}\n\n\n/***** INITIALIZATION FUNCTION *******/\ngenerateSortingDivs(10);\nlet divs = storeSortingDivs();\nlet copyDivs = [...divs];\nconsole.log('Original State: ')\nconsole.log(divs);\n//bubbleSort(divs);\n//displayQuickSortInfo();\n//quickSort(divs, 0, divs.length-1);\nlet x = mergeSort(copyDivs);\nconsole.log('Sorted: ');\nconsole.log(x);\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java Merge Sort Implementation\r\n                \r\nI am trying to implement Merge Sort in Java. The code looks fine to me but it returning the initial unsorted array as the output. I am learning all the basics just now so it is difficult for me to find the error.  \n\n```\nimport java.util.Scanner;\nclass Hacker{\n    int[] input=new int[]{2,4,1,6,8,5,3,7};\n    int[] left;\n    int[] right;\n    //int size;\n    Scanner scan=new Scanner(System.in);\n\n    public void mergeSort(int[] input){\n        if(input.length<2){\n            return;\n        }\n        int mid=input.length/2;\n        left=new int[mid];\n        right=new int[input.length-mid];\n        System.arraycopy(input, 0, left, 0, left.length);\n        System.arraycopy(input, mid, right, 0, right.length);\n        mergeSort(left);\n        mergeSort(right);\n        merge(input,left,right);\n    }\n\n    public void merge(int[]input,int[]left,int[]right){\n        int i=0,j=0,k=0;\n        while(i<left.length&&j<right.length){\n            if(left[i]<right[j]){\n                input[k++]=left[i++];\n            }\n            else{\n                input[k++]=right[j++];\n            }\n        }\n        while(i<left.length){\n            input[k++]=left[i++];\n        }\n        while(j<right.length){\n            input[k++]=right[j++];\n        }\n    }\n\n\n    public static void main(String args[]){\n        Hacker h=new Hacker();\n\n        h.mergeSort(h.input);        \n        for(int i=0;i<h.input.length;i++){\n            System.out.print(h.input[i]);\n        }\n    }\n}\n```\n\n\nOutput:\n\n```\n24168537\n```\n\n    ", "Answer": "\r\nYour problem is that you are using instance variables ```\nleft```\n, ```\nright```\n and ```\ninput```\n in recursive methods. This means all the recursive calls are overwriting the values. Recursion need local variables which means returning the result from the methods. This will also mean the methods can be static and will make your code a lot cleaner. \n\nHere's your code converted to use local variables and return calculated results. I've also simplified a few things.\n\n```\npublic class Sorter {\n    public static int[] mergeSort(int[] input) {\n        if (input.length < 2) {\n            return input;\n        }\n        int mid = input.length / 2;\n        int[] left = Arrays.copyOfRange(input, 0, mid);\n        int[] right = Arrays.copyOfRange(input, mid, input.length);\n        return merge(mergeSort(left), mergeSort(right));\n    }\n\n    public static int[] merge(int[] left, int[] right) {\n        int i = 0, j = 0, k = 0;\n        int[] output = new int[left.length + right.length];\n        while (i < left.length && j < right.length) {\n            if (left[i] < right[j]) {\n                output[k++] = left[i++];\n            } else {\n                output[k++] = right[j++];\n            }\n        }\n        while (i < left.length) {\n            output[k++] = left[i++];\n        }\n        while (j < right.length) {\n            output[k++] = right[j++];\n        }\n        return output;\n    }\n\n    public static void main(String args[]) {\n        int[] input = new int[]{2, 4, 1, 6, 8, 5, 3, 7};\n        System.out.println(Arrays.toString(Sorter.mergeSort(input)));\n    }\n}\n```\n\n\nFor your reference, here's a simplified version with the two methods combined and sorting in-place rather than creating a new array.\n\n```\npublic void mergeSort(int[] input) {\n    if (input.length >= 2) {\n        int[] left = copyOfRange(input, 0, input.length / 2);\n        int[] right = copyOfRange(input, input.length / 2, input.length);\n        mergeSort(left);\n        mergeSort(right);\n        for (int i = 0, j = 0, k = 0; i < left.length || j < right.length; k++) {\n            if (i >= left.length || (j < right.length && left[i] > right[j]))\n                input[k] = right[j++];\n            else\n                input[k] = left[i++];\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort: time limit exceed\r\n                \r\nWhy I am getting ```\ntime limit exceeded```\n error in sorting array using merge sort algorithm? What is wrong with my code? I have taken an input of 9 elements.\n\nInput: ```\n4 2 1 8 5 9 6 7 0```\n\n\nOutput: ```\nTime limit exceeded```\n\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\nint a[100];\n\nvoid merge(int a[], int l, int r, int m) {\n    int t[r - l + 1];\n    int i = l, j = m + 1, k = 0;\n    while (i <= m && j <= r) {\n        if (a[i] < a[j])\n            t[k++] = a[i++];\n        else\n            t[k++] = a[j++];\n    }\n    while (i <= m)\n        t[k++] = a[i++];\n    while (j <= r)\n        t[k++] = a[j++];\n    for (int i = l; i <= r; i++)\n        a[i] = t[i - l];\n}\n\nvoid msort(int a[], int l, int r) {\n    if (l > r)\n        return;\n\n    int m = (r + l) / 2;\n    msort(a, l, m);\n    msort(a, m + 1, r);\n    merge(a, l, r, m);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    msort(a, 0, n - 1);\n    for (int i = 0; i < n; i++)\n        cout << a[i] << \" \";\n    cout << endl;\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThere are some problems in your code:\n\n\nThe test for termination in ```\nmsort()```\n is incorrect: you should stop when the slice has a single element or less. You currently loop forever on slices of 1 element.\n\n```\nif (l >= r) return;\n```\n\nYou should test in ```\nmain()```\n if the number ```\nn```\n of elements read from the user is no greater than ```\n100```\n, the size of the global array ```\na```\n into which you read the elements to be sorted. You should instead use a local array with the proper size or allocate the array from the heap. The temporary array ```\nt```\n in ```\nmerge()```\n might also be too large for automatic allocation. It is more efficient to allocate temporary space once and pass it recursively.\n\n\nNote also that it is idiomatic in C and C++ to specify array slices with the index of the first element and the index of the element after the last one. This simplifies the code and allows for empty arrays and avoid special cases for unsigned index types.\n\nHere is a modified version with this approach:\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid merge(int a[], int l, int r, int m, int t[]) {\n    int i = l, j = m, k = 0;\n    while (i < m && j < r) {\n        if (a[i] < a[j])\n            t[k++] = a[i++];\n        else\n            t[k++] = a[j++];\n    }\n    while (i < m)\n        t[k++] = a[i++];\n    while (j < r)\n        t[k++] = a[j++];\n    for (int i = l; i < r; i++)\n        a[i] = t[i - l];\n}\n\nvoid msort(int a[], int l, int r, int t[]) {\n    if (r - l > 1) {\n        int m = l + (r - l) / 2;\n        msort(a, l, m, t);\n        msort(a, m, r, t);\n        merge(a, l, r, m, t);\n    }\n}\n\nvoid msort(int a[], int n) {\n    if (n > 1) {\n        int *t = new int[n];\n        msort(a, 0, n, t);\n        delete[] t;\n    }\n}\n\nint main() {\n    int n;\n\n    cin >> n;\n    if (n <= 0)\n        return 1;\n    int *a = new int[n];\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    msort(a, n);\n    for (int i = 0; i < n; i++)\n        cout << a[i] << \" \";\n    cout << endl;\n    delete[] a;\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort vs Radix Sort : Merge sort taking O(n (log n)^2) time in special cases?\r\n                \r\nI was reading about efficiency of Radix sort compared to comparison based sorting algorithms, where i found this piece :\n\n\n  For example, consider a bottom-up merge sort. The first pass will compare pairs of random keys, but the last pass will compare keys that are very close in the sorting order. This makes merge sort, on this class of inputs, take O(n (log n)2) time.\n\n\nCan someone help me understand the ```\nO(n (log n)2)```\n part ?\n    ", "Answer": "\r\nAssuming constant compare time == O(1), then merge sort is O (n log(n)). Assuming compare time is O(log(n)), then merge sort is O(N (log(n))^2). The assumption here is based on minimum key size for n distinct keys, which is log2(n) bits. However, key size is usually independent of n, and is either constant, or the average size of all keys in a set of n elements would be constant, in which case the time complexity is O(n log(n)).\n\nThe point being made is more about radix sort, where the number of passes is based on how many parts the key is separated into. For example, if the key is 64 bits, and radix sort is done 4 bits at a time, it takes 16 passes. If the key size is 28 characters, and radix sort is done 1 character at a time, then it takes 28 passes. If considering the minimum key size for n distinct keys, which is log2(n) bits, and if sorting by 8 bits at a time, then it takes log256(n) passes. For example sorting 2^32 keys, means the keys are 32 bits in size, and sorting by 8 bits at a time will take 4 passes. For 2^64 keys, it's 64 bits per key and 8 passes.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementing Merge Sort with Java\r\n                \r\nI was trying to implement merge sort using java, but it's saying:\n\n```\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 3\n    at HelloWorld.merge(HelloWorld.java:42)\n    at HelloWorld.sort(HelloWorld.java:30)\n    at HelloWorld.sort(HelloWorld.java:28)\n    at HelloWorld.sort(HelloWorld.java:29)\n    at HelloWorld.sort(HelloWorld.java:28)\n    at HelloWorld.main(HelloWorld.java:10)\n```\n\n\nSo I tried to copy the original array into a helper array in the merge subroutine, I think it's the length I use for helper array messed everything up, isn't \"r-l+1\" the length of the helper array? \n\nIf I put 100 as the length of the helper array, the code would work, but obviously it's not going to work when the size of the original array gets larger. \n\nPlease help and thanks in advance.\n\n```\npublic class HelloWorld{\n\n     public static void main(String []args){\n\n         HelloWorld ms = new HelloWorld();\n         int arr[] = new int[]{4,3,0,1,3,2,4,20,13,22,10};\n\n         ms.sort(arr, 0, arr.length - 1);\n\n         ms.printArr(arr);\n\n     }\n\n     void printArr(int arr[])\n     {\n         int n = arr.length;\n         for(int i = 0; i<n; i++){\n             System.out.print(\" \"+arr[i]);\n         }\n     }\n\n     void sort(int arr[], int l, int r)\n     {\n         if(l<r){\n             int m = (l+r)/2;\n             sort(arr, l, m);\n             sort(arr, m+1, r);\n             merge(arr, l, m, r);\n\n         }\n\n     }\n\n     void merge(int arr[], int l, int m, int r)\n     {\n        //find out helper array length\n        int helper[] = new int[r-l+1];\n         // Your code here\n         for(int i=l; i<=r; i++){\n             helper[i] = arr[i];\n         }\n         int i = l;\n         int k = l;\n         int j = m+1;\n         while(i<=m && j<=r){\n             if(helper[i]<=helper[j]){\n                 arr[k]=helper[i];\n                 i++;\n             }else{\n                 arr[k]=helper[j];\n                 j++;\n             }\n             k++;\n         }\n\n         while(i<=m){\n             arr[k]=helper[i];\n             i++;\n             k++;\n         }\n     }\n\n\n}\n```\n\n    ", "Answer": "\r\nIf I understand the way you're attempting to implement the MERGE subroutine for your merge sort algorithm correctly, you're copying the relevant portion of the array (from index ```\nl```\n, inclusive, to index ```\nl```\n, inclusive) into the helper array, then modifying the original array using the data copied into the helper array.\n\nIn this case, the helper array should indeed have length ```\nr-l+1```\n. However, taking a look at your code for copying the original array portion into the helper array, you're not offsetting your indexes in the ```\nfor```\n loop. The correct way to do it would be:\n\n```\nint helper[] = new int[r-l+1];\n\nfor (int i = l; i <= r; i++){\n    helper[i-l] = arr[i];\n}\n```\n\n\nDon't forget arrays are zero indexed!\n\nI do however recommend moving on to more modern ways of copying arrays if you absolutely have to copy them. In this case, the most adapted in my opinion would be the system call ```\nSystem.arraycopy(arr, l, helper, 0, r-l+1)```\n. If you would like to read more about the different methods of copying an array (completely or partially) in Java, check this answer out.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Print each pass of Merge Sort and Quick Sort algorithms\r\n                \r\nI'm trying to output each pass of a Merge Sort and Quick Sort algorithm I wrote for a homework assignment, but I'm having a little difficulty figuring out what exactly to print, when to print it, and where to place the print statement. In addition to printing the values, I'm also required to surround the arrays created by the algorithm in brackets with each pass, like the following:\n\n\nMerge Sort Sample Desired Output:\n\n```\n[ 4     85     94     68     76     75     40     66     18 ]\n[ 4     85     94     68     76 ] [ 75     40     66     18 ]\n[ 4     85     94 ] [ 68     76 ] [ 75     40 ] [ 66     18 ]\n[ 4     85 ] [ 94 ] [ 68 ] [ 76 ] [ 75 ] [ 40 ] [ 66 ] [ 18 ]\n[ 4     85 ] [ 94 ]    \n[ 4 ] [ 85 ]  \n[ 4     85 ]    \n[ 4     85     94 ] [ 68     76 ] [ 40     75 ] [ 18     66 ] \n[ 4     68     76     85     94 ] [ 18     40     66     75 ]\n[ 4     18     40     66     68     75     76     85     94 ]\n```\n\n\nQuick Sort Sample Desired Output:\n\n```\n[ 47     44     39     77     80     19     49     45     65 ]\n[ 44     39     19     45 ] [ 47 ] [ 77     80     49     65 ]\n[ 39     19 ] [ 44 ] [ 45 ] [ 47 ] [ 49     65 ] [ 77 ] [ 80 ]\n[ 19 ] [ 39 ] [ 44 ] [ 45 ] [ 47 ] [ 49 ] [ 65 ] [ 77 ] [ 80 ]\n```\n\n\n\n\nMy class is just barely getting into stacks and recursive functions, so I'm currently just a little stuck. Here are my two functions for each sorting algorithm:\n\n\nMerge Sort Algorithm:\n\n```\npublic static void MergeSort(int[] array) {\n    int size = array.length;\n    if (size < 2)\n        return;\n    int mid = size / 2;\n    int leftSize = mid;\n    int rightSize = size - mid;\n    int[] left = new int[leftSize];\n    int[] right = new int[rightSize];\n\n    for (int i = 0; i < mid; i++) {\n        left[i] = array[i];\n\n    }\n\n    for (int i = mid; i < size; i++) {\n        right[i - mid] = array[i];\n    }\n\n    MergeSort(left);\n    MergeSort(right);\n    Merge(array, left, right);\n}\n\npublic static void Merge(int[] array, int[] left, int[] right) {\n    int leftSize = left.length;\n    int rightSize = right.length;\n    int i = 0, j = 0, k = 0;\n\n    while (i < leftSize && j < rightSize) {\n        if (left[i] <= right[j]) {\n            array[k] = left[i];\n            i++;\n            k++;\n        } else {\n            array[k] = right[j];\n            k++;\n            j++;\n        }\n    }\n\n    while (i < leftSize) {\n        array[k] = left[i];\n        k++;\n        i++;\n    }\n\n    while (j < rightSize) {\n        array[k] = right[j];\n        k++;\n        j++;\n    }\n}\n```\n\n\n\nQuick Sort:\n\n```\npublic static void QuickSort(int[] array, int left, int right) {\n    int pivotIndex = left + (right - left) / 2;\n    int pivotValue = array[pivotIndex];\n\n    int i = left;\n    int j = right;\n\n    while(i <= j) {\n        while(array[i] < pivotValue) {\n            i++;\n        }\n\n        while(array[j] > pivotValue) {\n            j--;\n        }\n\n        if(i <= j) {\n            int tmp = array[i];\n            array[i] = array[j];\n            array[j] = tmp;\n            i++;\n            j--;\n        }\n\n        if(left < i) {\n            QuickSort(array, left, j);\n        }\n\n        if(right > i) {\n            QuickSort(array, i, right);\n        }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementing merge sort iteratively\r\n                \r\nI'm trying to implement merge sort in order to get a better understanding of how it works.  In the following code I am attempting to sort an array of numbers.  The code I currently have is buggy and runs in an infinite loop.  I'm trying to solve this non-recursively for now:\n\n```\nfunction mergeSort(arr) {\n\n  var mid = Math.floor(arr.length/2);\n  var left = arr.slice(0, mid);\n  var right = arr.slice(mid, arr.length);\n\n  if (arr.length === 1) {return arr};\n\n  var sorted = [];\n\n  var i = 0;\n\n  while (left.length || right.length) {\n   if (left.length && right.length) {\n     if (left[0] < right[0]) {\n       sorted.push(left.shift())\n     } else {\n       sorted.push(right.shift())\n     }\n   } else if (left) {\n     sorted.push(left.shift())\n   } else {\n     sorted.push(right.shift())\n   }\n   i++;\n  }\n\n  return sorted;\n}\n```\n\n\nSo if I have an array ```\nvar nums = [1, 4, 10, 2, 9, 3];```\n calling ```\nmergeSort(nums)```\n should return ```\n[1, 2, 3, 4, 9, 10]```\n.\n    ", "Answer": "\r\nYou've written code that splits an array in two and merges the halves. This doesn't result in a sorted array because the two halves are not sorted. Mergesort works by sorting the two halves, then merging them.\n\nThere are many ways to implement mergesort iteratively. Let me offer one. Start by merging subarrays of size 1. You know that an array of size 1 is already sorted, so it's safe to merge two consecutive subarrays of size 1. If you do this to all consecutive pairs of subarrays of size 1 in the original array, you end up with an array consisting of consecutive sorted subarrays of size 2.\n\nDo you see where this is going? Now you can merge every two consecutive subarrays of size 2. You end up with an array of consecutive sorted subarrays of size 4. Keep on repeating this procedure until the whole array is sorted.\n\nThe following snippet implements this approach.\n\n\r\n\r\n```\nfunction mergeSort(arr) {\r\n  var sorted = arr.slice(),\r\n      n = sorted.length,\r\n      buffer = new Array(n);\r\n\r\n  for (var size = 1; size < n; size *= 2) {\r\n    for (var leftStart = 0; leftStart < n; leftStart += 2*size) {\r\n      var left = leftStart,\r\n          right = Math.min(left + size, n),\r\n          leftLimit = right,\r\n          rightLimit = Math.min(right + size, n),\r\n          i = left;\r\n      while (left < leftLimit && right < rightLimit) {\r\n        if (sorted[left] <= sorted[right]) {\r\n          buffer[i++] = sorted[left++];\r\n        } else {\r\n          buffer[i++] = sorted[right++];\r\n        }\r\n      }\r\n      while (left < leftLimit) {\r\n        buffer[i++] = sorted[left++];\r\n      }\r\n      while (right < rightLimit) {\r\n        buffer[i++] = sorted[right++];\r\n      }\r\n    }\r\n    var temp = sorted,\r\n        sorted = buffer,\r\n        buffer = temp;\r\n  }\r\n\r\n  return sorted;\r\n}\r\n\r\nfunction print(s) {\r\n  document.write(s + '<br />');\r\n}\r\n\r\nvar data = [1, 4, 10, 2, 9, 3];\r\nprint('input: ' + data.join(', '));\r\nprint('output: ' + mergeSort(data).join(', '));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort: time limit exceed\r\n                \r\nWhy I am getting ```\ntime limit exceeded```\n error in sorting array using merge sort algorithm? What is wrong with my code? I have taken an input of 9 elements.\n\nInput: ```\n4 2 1 8 5 9 6 7 0```\n\n\nOutput: ```\nTime limit exceeded```\n\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\nint a[100];\n\nvoid merge(int a[], int l, int r, int m) {\n    int t[r - l + 1];\n    int i = l, j = m + 1, k = 0;\n    while (i <= m && j <= r) {\n        if (a[i] < a[j])\n            t[k++] = a[i++];\n        else\n            t[k++] = a[j++];\n    }\n    while (i <= m)\n        t[k++] = a[i++];\n    while (j <= r)\n        t[k++] = a[j++];\n    for (int i = l; i <= r; i++)\n        a[i] = t[i - l];\n}\n\nvoid msort(int a[], int l, int r) {\n    if (l > r)\n        return;\n\n    int m = (r + l) / 2;\n    msort(a, l, m);\n    msort(a, m + 1, r);\n    merge(a, l, r, m);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    msort(a, 0, n - 1);\n    for (int i = 0; i < n; i++)\n        cout << a[i] << \" \";\n    cout << endl;\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThere are some problems in your code:\n\n\nThe test for termination in ```\nmsort()```\n is incorrect: you should stop when the slice has a single element or less. You currently loop forever on slices of 1 element.\n\n```\nif (l >= r) return;\n```\n\nYou should test in ```\nmain()```\n if the number ```\nn```\n of elements read from the user is no greater than ```\n100```\n, the size of the global array ```\na```\n into which you read the elements to be sorted. You should instead use a local array with the proper size or allocate the array from the heap. The temporary array ```\nt```\n in ```\nmerge()```\n might also be too large for automatic allocation. It is more efficient to allocate temporary space once and pass it recursively.\n\n\nNote also that it is idiomatic in C and C++ to specify array slices with the index of the first element and the index of the element after the last one. This simplifies the code and allows for empty arrays and avoid special cases for unsigned index types.\n\nHere is a modified version with this approach:\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid merge(int a[], int l, int r, int m, int t[]) {\n    int i = l, j = m, k = 0;\n    while (i < m && j < r) {\n        if (a[i] < a[j])\n            t[k++] = a[i++];\n        else\n            t[k++] = a[j++];\n    }\n    while (i < m)\n        t[k++] = a[i++];\n    while (j < r)\n        t[k++] = a[j++];\n    for (int i = l; i < r; i++)\n        a[i] = t[i - l];\n}\n\nvoid msort(int a[], int l, int r, int t[]) {\n    if (r - l > 1) {\n        int m = l + (r - l) / 2;\n        msort(a, l, m, t);\n        msort(a, m, r, t);\n        merge(a, l, r, m, t);\n    }\n}\n\nvoid msort(int a[], int n) {\n    if (n > 1) {\n        int *t = new int[n];\n        msort(a, 0, n, t);\n        delete[] t;\n    }\n}\n\nint main() {\n    int n;\n\n    cin >> n;\n    if (n <= 0)\n        return 1;\n    int *a = new int[n];\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    msort(a, n);\n    for (int i = 0; i < n; i++)\n        cout << a[i] << \" \";\n    cout << endl;\n    delete[] a;\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort with a comparator and a vector as arguments\r\n                \r\nThe issue I'm having involves writing a function to use merge sort to sort a vector, and I need to use a functor as well. How can a comparator/functor be used as an argument to the merge sort function to sort a vector?\n    ", "Answer": "\r\nYou could define a comparisor operator like this\n\n```\nstruct MyLessThanFunctor\n{\n    bool operator() (int i,int j)\n    {\n    return (i<j);\n    }\n};\n```\n\n\nAnd after that, instancing it and using it\n\n```\nMyLessThanFunctor comparator;\nsort(elements, comparator);\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "OCaml merge sort function\r\n                \r\nSo this is a merge sort function I'm playing with in OCaml. The funny thing is the code delivers what I expect, which means, it sorts the list. But then raises some errors. So can someone please check my code and tell me what's going on and why these errors? And how do I eliminate them? I'm a OCaml newbie but I really want to get what's going on: \n\n```\n(* Merge Sort *)\n(* This works but produces some extra error. Consult someone!! *)\nlet rec length_inner l n =\n    match l with\n    [] -> n\n    | h::t -> length_inner t (n + 1)\n;;\n\nlet length l = length_inner l 0;;\n\nlet rec take n l =\n    if n = 0 then [] else\n        match l with\n        h::t -> h :: take (n - 1) t\n;;\n\nlet rec drop n l =\n    if n = 0 then l else\n        match l with\n        h::t -> drop (n - 1) t\n;;\n\nlet rec merge x y =\n    match x, y with \n    [], l -> l\n    | l, [] -> l\n    | hx::tx, hy::ty -> \n        if hx < hy\n            then hx  :: merge tx (hy :: ty)\n    else hy :: merge (hx :: tx) ty\n;;\n\nlet rec msort l =\n    match l with\n    [] -> []\n    | [x] -> [x]\n    | _ ->\n        let left = take (length l/2) l in \n        let right = drop (length l/2) l in\n        merge (msort left) (msort right)\n;;\n\nmsort [53; 9; 2; 6; 19];; \n```\n\n\nIn the terminal, I get: \n\n```\n        OCaml version 4.00.1\n\n# #use \"prac.ml\";;\nval length_inner : 'a list -> int -> int = <fun>\nval length : 'a list -> int = <fun>\nFile \"prac.ml\", line 13, characters 2-44:\nWarning 8: this pattern-matching is not exhaustive.\nHere is an example of a value that is not matched:\n[]\nval take : int -> 'a list -> 'a list = <fun>\nFile \"prac.ml\", line 19, characters 2-39:\nWarning 8: this pattern-matching is not exhaustive.\nHere is an example of a value that is not matched:\n[]\nval drop : int -> 'a list -> 'a list = <fun>\nval merge : 'a list -> 'a list -> 'a list = <fun>\nval msort : 'a list -> 'a list = <fun>\n- : int list = [2; 6; 9; 19; 53]\n# \n```\n\n    ", "Answer": "\r\nThe compiler is telling you that your pattern matches aren't exhaustive. In fact it's telling exactly what to try to see the problem. For example, you might try:\n\n```\ndrop 2 []\n```\n\n\nTo fix the problem you need to decide what to do with empty lists in your functions. Here's a definition of drop with exhaustive matches:\n\n```\nlet rec drop n l =\n    if n = 0 then l\n    else\n        match l with\n        | [] -> []\n        | h::t -> drop (n - 1) t\n```\n\n\nIf this isn't clear: your code doesn't say what to do with an empty list. Your matches only say what to do if the list has the form ```\nh :: t```\n. But an empty list doesn't have this form. You need to add a case for ```\n[]```\n to your matches.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Segmentation Fault with Merge Sort\r\n                \r\nI've recently begun brushing up on my C again after having not touched it for some time. So, I started by trying to implement merge sort but after looking at these lines for about an hour, I've failed to determine what is wrong.\n\n```\nint main(int argc,char** argv){\n    printf(\"test\\n\");\n    int x;\n    int input[] = {1,2,3};\n        int start=0;\n        int end=2;\n    for (x=0;x<5;x++){\n        //printf(\"%i\\n\",x);\n    }\n    printf(\"Run mergeSort in main \\n\");\n    mergeSort(input,start,end);\n\n}\n\nvoid mergeSort(int input[], int start, int end){\n    printf(\"Running merge %i %i\",start,end);\n    int middle = (start + end)/2;\n    if (start < end){\n        mergeSort(input,start,middle);\n        mergeSort(input,middle+1,end);\n        merge(input,start,middle,end);\n    }\n}\n```\n\n\nWhen I run this program, the first line \"test\" will print then \"Run merge sort in main\" but\n\n```\nprintf(\"Running merge %i %i\",start,end); \n```\n\n\ndoes not get executed which leaves me confused. I can't find any memory allocation issues or maybe I'm missing something very obvious.\n\nNote that the merge function has been implemented on the side, but that portion of the code was not relevant to this problem directly so I did not include it.\n\nEDIT Remaining Code:\n\n```\nvoid merge(int input[],int start, int middle, int end){\n    int save_start = start;\n    int temp[end-start+1];\n    int index = 0;\n    printf(\"Start merge\");\n    while (start<=middle || middle+1<=end){\n        if (input[start]<input[middle]){\n            temp[index] = input[start];\n            start++;\n        } else {\n            temp[index] = input[middle];\n            middle++;\n        } \n        index++;\n    }\n    while  (start<=middle){\n        temp[index] = input[start];\n        start++;\n    }\n\n    while (middle+1<=end){\n        temp[index] = input[middle];\n        middle++;\n    }\n\n    int i=0;\n    int a;\n    for (a=save_start;i<index;a++,i++){\n        input[a]=temp[i];\n    }\n\n}\n```\n\n    ", "Answer": "\r\nMost likely your output is buffered and is just waiting around to get printed.  Add a ```\n\\n```\n to that string or call ```\nfflush(stdout)```\n.\n\nAs far as your segmentation fault is concerned, you haven't shown us enough code.  Use a debugger to get a backtrace and you may find out some more information.\n\nEdit:  You have some array index bugs in your ```\nmerge```\n function.  Notice that you're moving middle during the first loop there - what does that do to the loop condition?  Hint: you need to stop at the actual middle position, not keep going once ```\nstart```\n gets past that point.\n\nEdit 2:  You have some off-by-one errors in there too.\n\nEdit 3: Your ```\n||```\n should be ```\n&&```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Quick Sort vs Merge Sort for nearly sorted arrays\r\n                \r\nWhen dealing with an array that is nearly sorted which algorithm performs better quick sort or merge sort and why? I realize other algorithms might perform better than these given the situation.  \n    ", "Answer": "\r\nBoth Quick Sort and Merge Sort are great for sorted arrays because for both algorithms the sorted array is kind of a good-case which lets them run in O(n).\n\nHowever, Quick Sort has less bureaucratic overhead because it does everything in-place.  (On modern architectures it might even benefit from multiple processor cores, depending on the implementation.)\n\nMerge Sort, on the other hand, builds new data structures (lists) in every recursion step, handing them back up to the caller who then merges these lists to become its result.  So even if this is also running in O(n), this will be slower (unless something weird is going on).  It will also need more memory than Quick Sort.\n\nBut keep in mind that Quick Sort in the worst case will still need O(n²) (while Merge Sort will not raise above O(n log n)), so if you only hope to have nearly sorted arrays, this should be considered.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort segmentation fault c++\r\n                \r\nI am trying to implement merge sort for my algorithm analysis class and every time I run it there is a segmentation fault. I think the problem is when i split the vector in the merge_sort function but I cannot find the problem. Help would be really appreciated guys.\n\n```\ntemplate <typename T>\nstd::vector<int> merge(std::vector<T>& A,std::vector<T>& B)\n{\n   int a_size = A.size();\n   int b_size = B.size();\n   std::vector<int> C(a_size+b_size,0);\n   //int *c = new int[b_size+a_size];\n   int i =0,j =0,k=0;\n   while(i < a_size && j < b_size)\n   {\n        if(A[i]<B[j])\n        {\n            C[k] = A[i];\n            k++;\n            i++;\n        }   \n        else\n        {\n            C[k] = B[j];\n            k++;\n            j++;\n            if(i!=a_size)\n            {\n                for(;i<a_size;i++,k++)\n                {\n                    //copy rest of a to c\n                    C[k] = A[i];\n                }\n            }\n            if(j != b_size)\n            {\n                for(;j<b_size;k++,j++)\n                {\n                    //copy the rest of b to c\n                    C[k] = B[j];\n                }\n            }   \n        }\n    }\n    return C;\n}\n// Merge sort implementation\ntemplate <typename T>\nvoid merge_sort(std::vector<T>& vector)\n{\n    // TODO implement merge sort\n    int vector_size = vector.size();\n    int big_vector_index = 0;\n    int half_size = (int)vector_size/2;\n    int remainder = vector_size%2;\n    std::vector<int> left(half_size,0);\n    std::vector<int> right(half_size+remainder,0);\n    for(int l = 0;big_vector_index<half_size;l++,big_vector_index++)\n    {\n        left[l] = vector[big_vector_index];\n    }\n\n    for(int m = 0;big_vector_index<vector_size;m++,big_vector_index++)\n    {\n        right[m] = vector[big_vector_index];\n    }\n    big_vector_index = 0;\n    merge_sort(left);\n    merge_sort(right);\n    vector = merge(left,right);\n\n}\n```\n\n    ", "Answer": "\r\nI took a look at your code, and the majority of it is correct from my testing. I don't want to do your coursework for you but maybe a couple of hints in the right direction will help.\n\nFor your original question about the segfault that you got, PaulMcKenzie, Jim Lewis, and Tahlil are right, ```\nmerge_sort()```\n needs a base condition (base case) to check whether or not the recursion should continue, so it doesn't run forever and/or until your computer runs out of memory (which is what is happening in your case). In general, any recursive function should have a base case.\n\nAlso, you should take a look at your merge function as well. It has all the parts of a correct merge function, but some parts of it run a bit earlier/more often than you want them too. I don't want to give too much away since it's for class, but if you fix the segfault problem and are still getting strange answers, take a look at it.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Sorting an array of structures using merge sort\r\n                \r\nSo I have a structure called ```\nproduct```\n and I have an array of products. \n\nI am trying to sort the array by product price using merge sort, the problem is that my code is not swapping anything and I don't understand why. If someone could help me I would appreciate it a lot.\n\nStructure:\n\n```\ntypedef struct product {\n    int ident;      /* idp of a product */\n    char desc[64];  /* string that describes a product eg. \"bread\" */\n    int price;      /* price of the product */\n    int weight;     /* weight of the product eg. 2kg */\n    int quant;      /* quantity of the product in stock */\n    int state_prod; /* state of a product, if 1 it is in the system else is 0 and is not in the sistem */\n} product;\n```\n\n\nMerge sort algorithm\n\n```\nvoid mergesort_price(product a[], int left, int right) {\n    int m = (right + left) / 2;\n    if (right <= left)\n      return;\n    mergesort_price(a, left, m);\n    mergesort_price(a, m + 1, right);\n    merge_price(a, left, m, right);\n}\n\nvoid merge_price(product a[], int left, int m, int right) { \n    int i, j, k;\n    for (i = m + 1; i > left; i--) \n        aux[i - 1] = a[i - 1];\n    for (j = m; j < right; j++)\n        aux[right + m - j] = a[j + 1];\n    for (k = left; k <= right; k++)\n        if (aux[j].price < aux[i].price || i > m)\n            a[k] = aux[j--];\n        else\n        if ((aux[j].price == aux[i].price) || i > m) {\n            if ((aux[j].ident < aux[i].ident) || i > m) {\n                a[k] = aux[j--];\n            }\n        } else\n            a[k] = aux[i++];\n}\n```\n\n\nExample:\n\nMy input:\n\n```\ndesc: pao, price:2, weight: 2, quant:200\ndesc: ovos, price:1, weight: 1, quant:100\ndesc: iscas, price:3, weight: 3, quant:300\ndesc: fiambre, price:2, weight: 2, quant:200\ndesc: queijo, price:2, weight: 2, quant:200\n```\n\n\nCorrect output:\n\n```\ndesc: ovos, price:1, weight: 1, quant:100\ndesc: pao, price:2, weight: 2, quant:200\ndesc: fiambre, price:2, weight: 2, quant:200\ndesc: queijo, price:2, weight: 2, quant:200\ndesc: iscas, price:3, weight: 3, quant:300\n```\n\n\nProgram:\n\n```\n#include <stdlib.h> \n#include <stdio.h>\n#include <string.h>\n\n#define MAX_PROD 10000 /* max products in the system */\n\ntypedef struct product {\n   int ident;      /* idp of a product */\n   char desc[64];  /* string that describes a product eg. \"bread\" */\n   int price;      /* price of the product */\n   int weight;     /* weight of the product eg. 2kg */\n   int quant;      /* quantity of the product in stock */\n   int state_prod; /* state of a product, if 1 it is in the system else is 0 and is not in the system */\n} product;\n\nproduct p1 = { 0, \"pao\", 2, 2, 200, 1 };\nproduct p2 = { 1, \"ovos\", 1, 1, 100, 1 };\nproduct p3 = { 2, \"iscas\", 3, 3, 300, 1 };\nproduct p4 = { 3, \"bacon\", 2, 5, 400, 1 };\nproduct p5 = { 4, \"abacate\", 2, 6, 500, 1 };\n\nproduct sistem[5] = {};  /* array that contains the products */\nproduct sistem2[5] = {}; /* Will be used has a copy of sistem */\n\nsistem[5] = { p1, p2, p3, p4, p5}\nproduct aux[5]; /* Auxliar array used in mergesort */\n\nvoid mergesort_price(product a[], int left, int right) {\n    int m = (right + left) / 2;\n    if (right <= left)\n        return;\n    mergesort_price(a, left, m);\n    mergesort_price(a, m + 1, right);\n    merge_price(a, left, m, right);\n}\n\nvoid merge_price(product a[], int left, int m, int right) { \n    int i, j, k;\n    for (i = m + 1; i > left; i--) \n        aux[i - 1] = a[i - 1];\n    for (j = m; j < right; j++)\n        aux[right + m - j] = a[j + 1];\n    for (k = left; k <= right; k++)\n        if (aux[j].price < aux[i].price || i > m)\n            a[k] = aux[j--];\n        else if ((aux[j].price == aux[i].price) || i > m) {\n            if ((aux[j].ident < aux[i].ident) || i > m) {\n                a[k] = aux[j--];\n            }\n        } else\n            a[k] = aux[i++];\n}\n\nvoid print_array(product arr[]) {\n    int i;\n    for (i = 0; i < 5; i++) {\n         printf(\"* %s %d %d %d\\n\", arr[i].desc, arr[i].price, arr[i].quant, arr[i].ident);\n    }\n}\n\nvoid copy_el(product source[], product dest[], int size) {\n    int i;\n    for (i = 0; i < size; i++) {\n        dest[i] = source[i];\n    }\n}\n\nint main() {   \n    copy_el(sistem, sistem2, 5);\n    printf(\"The products in the system are:\\n\");\n    print_array(sistem);\n\n    printf(\"\\nSorted products by price in the system:\\n\");\n    mergesort_price(sistem2, 5, 0);\n    print_array(sistem2);\n\n    return 0;\n}\n```\n\n\nI know the input that I typed is not coded in the program I just gave the input in that way as an example to make it more comprehensible.\n    ", "Answer": "\r\nRemember as I mentioned in the top comments, your ```\nfor```\n loops are not initializing ```\ni```\n, ```\nj```\n, or ```\nk```\n\n\nYour sort looks a bit complicated.\n\nThere are two ways to do the merge:\n\n(1) copy to temp array and merge back to original (this is what you're doing)\n\n(2) merge from original left/right arrays to temp array and the copy the result back to the original (seems simpler to me)\n\nAnyway, here's a refactored version:\n\n```\n#include <stdio.h>\n\ntypedef struct product {\n    int ident;                          /* idp of a product */\n    char desc[64];                      /* string that describes a product eg.\n                                            \"bread\" */\n    int price;                          /* price of the product */\n    int weight;                         /* weight of the product eg. 2kg */\n    int quant;                          /* quantity of the product in stock */\n    int state_prod;                     /* state of a product, if its 1 its in\n                                            the system else is 0 and is not in\n                                            the system */\n} product;\n\n#define AMAX    28\nproduct a[AMAX];\nproduct aux[AMAX];\n\nvoid merge_price(product a[], int low, int mid, int high);\n\nvoid\nmergesort_price(product a[], int low, int high)\n{\n    int mid = (high + low) / 2;\n\n    if (high <= low)\n        return;\n    mergesort_price(a, low, mid);\n    mergesort_price(a, mid + 1, high);\n    merge_price(a, low, mid, high);\n}\n\nvoid\nmerge_price(product a[], int low, int mid, int high)\n{\n    int right;\n    int left;\n    int k;\n    int i;\n\n    k = 0;\n    left = low;\n    right = mid + 1;\n\n    for (;  (left <= mid) && (right <= high);  ++k) {\n        if (a[left].price <= a[right].price)\n            aux[k] = a[left++];\n        else\n            aux[k] = a[right++];\n    }\n\n    for (;  left <= mid;  ++left, ++k)\n        aux[k] = a[left];\n\n    for (;  right <= high;  ++right, ++k)\n        aux[k] = a[right];\n\n    k = low;\n    i = 0;\n    for (;  k <= high;  ++k, ++i)\n        a[k] = aux[i];\n}\n\nvoid\nshow(void)\n{\n    for (int idx = 0;  idx < AMAX;  ++idx)\n        printf(\" %d\",a[idx].price);\n    printf(\"\\n\");\n}\n\nint\nmain(void)\n{\n\n    for (int idx = 0;  idx < AMAX;  ++idx)\n        a[idx].price = AMAX - idx;\n    show();\n\n    mergesort_price(a,0,AMAX - 1);\n    show();\n}\n```\n\n\n\n\nUPDATE:\n\n\n  ok it worked thanks but when i tried to do it but for strings it didnt work. I only changed the if statement really, like can u explain me why it didnt pls.\n\n\nOkay, I've created a version that generates random product descriptions and sorts by ```\nprice```\n. It then resorts based on ```\ndesc```\n [a string sort].\n\nI did this with a pointer to a comparison function that is passed as an extra argument to the existing functions. This is similar to the last argument of libc's ```\nqsort```\n function.\n\nThis could be extended to a \"multikey\" sort (e.g. sort by ```\nprice```\n and then by ```\ndesc```\n [or whatever ```\nstruct```\n members you wish]). See: ```\ncmpbyboth```\n and ```\ncmpbyall```\n.\n\nNote that, at first glance, ```\ncmpbyall```\n should be faster than ```\ncmpbyboth```\n but with (e.g.) ```\n-O2```\n the compiler may choose to inline the [simple] functions so that both functions may generate exactly the same executable code.\n\nAnyway, here's the code:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#define STRMAX      64\n#define GENSTR      7\n\ntypedef struct product {\n    int ident;                          /* idp of a product */\n    char desc[STRMAX];                  /* string that describes a product eg.\n                                            \"bread\" */\n    int price;                          /* price of the product */\n    int weight;                         /* weight of the product eg. 2kg */\n    int quant;                          /* quantity of the product in stock */\n    int state_prod;                     /* state of a product, if its 1 its in\n                                            the system else is 0 and is not in\n                                            the system */\n} product;\n\ntypedef int (*cmpfnc_p)(const product *,const product *);\n\n#define AMAX    28\nproduct a[AMAX];\nproduct aux[AMAX];\n\nvoid merge_price(product a[], int low, int mid, int high,cmpfnc_p cmpfnc);\n\nvoid\nmergesort_price(product a[], int low, int high, cmpfnc_p cmpfnc)\n{\n    int mid = (high + low) / 2;\n\n    if (high <= low)\n        return;\n    mergesort_price(a, low, mid, cmpfnc);\n    mergesort_price(a, mid + 1, high, cmpfnc);\n    merge_price(a, low, mid, high, cmpfnc);\n}\n\nvoid\nmerge_price(product a[], int low, int mid, int high,cmpfnc_p cmpfnc)\n{\n    int cmpflg;\n    int right;\n    int left;\n    int k;\n    int i;\n\n    k = 0;\n    left = low;\n    right = mid + 1;\n\n    for (;  (left <= mid) && (right <= high);  ++k) {\n        cmpflg = cmpfnc(&a[left],&a[right]);\n        if (cmpflg <= 0)\n            aux[k] = a[left++];\n        else\n            aux[k] = a[right++];\n    }\n\n    for (;  left <= mid;  ++left, ++k)\n        aux[k] = a[left];\n\n    for (;  right <= high;  ++right, ++k)\n        aux[k] = a[right];\n\n    k = low;\n    i = 0;\n    for (;  k <= high;  ++k, ++i)\n        a[k] = aux[i];\n}\n\nvoid\nshow(const char *tag)\n{\n\n    printf(\"\\n\");\n    printf(\"%s\",tag);\n\n    for (int idx = 0;  idx < AMAX;  ++idx)\n        printf(\" %s=%d\",a[idx].desc,a[idx].price);\n\n    printf(\"\\n\");\n}\n\n// genstr -- get random string\nvoid\ngenstr(char *desc)\n{\n    int len;\n    int idx;\n    int chr;\n    int carry;\n\n    // get random string length\n    len = (rand() % GENSTR) + 1;\n\n    // fill in random string\n    for (idx = 0;  idx < len;  ++idx) {\n        chr = rand() % 26;\n        chr += 'a';\n        *desc++ = chr;\n    }\n\n    *desc = 0;\n}\n\n// cmpbyprice -- compare by price\nint\ncmpbyprice(const product *left,const product *right)\n{\n    int cmpflg;\n\n    cmpflg = left->price - right->price;\n\n    return cmpflg;\n}\n\n// cmpbydesc -- compare by description\nint\ncmpbydesc(const product *left,const product *right)\n{\n    int cmpflg;\n\n    cmpflg = strcmp(left->desc,right->desc);\n\n    return cmpflg;\n}\n\n// cmpbyboth -- compare by price description\nint\ncmpbyboth(const product *left,const product *right)\n{\n    int cmpflg;\n\n    do {\n        cmpflg = cmpbyprice(left,right);\n        if (cmpflg)\n            break;\n\n        cmpflg = cmpbydesc(left,right);\n        if (cmpflg)\n            break;\n\n        // add more if you like ...\n    } while (0);\n\n    return cmpflg;\n}\n\n// cmpbyall -- compare by price description [faster version]\nint\ncmpbyall(const product *left,const product *right)\n{\n    int cmpflg;\n\n    do {\n        cmpflg = left->price - right->price;\n        if (cmpflg)\n            break;\n\n        cmpflg = strcmp(left->desc,right->desc);\n        if (cmpflg)\n            break;\n\n        // add more if you like ...\n    } while (0);\n\n    return cmpflg;\n}\n\nint\nmain(int argc,char **argv)\n{\n    unsigned int seed;\n    product *ptr;\n\n    --argc;\n    ++argv;\n\n    if (argc > 0)\n        seed = atoi(*argv);\n    else\n        seed = time(NULL);\n    printf(\"SEED: %u\\n\",seed);\n    srand(seed);\n\n    for (int idx = 0;  idx < AMAX;  ++idx) {\n        ptr = &a[idx];\n        ptr->price = AMAX - idx;\n        genstr(ptr->desc);\n    }\n    show(\"INITED\");\n\n    mergesort_price(a,0,AMAX - 1,cmpbyprice);\n    show(\"BYPRICE\");\n\n    mergesort_price(a,0,AMAX - 1,cmpbydesc);\n    show(\"BYDESC\");\n\n    mergesort_price(a,0,AMAX - 1,cmpbyboth);\n    show(\"BYBOTH\");\n\n    mergesort_price(a,0,AMAX - 1,cmpbyall);\n    show(\"BYALL\");\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Invalid pointer operation; Recursive Merge Sort\r\n                \r\nI've attempted to implement a merge sort for strings however I cannot perform the recursive part and I get the error \"Invalid Pointer Operation\"\n\n```\nprogram Project1;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nvar i : Integer;\nconst MyArray : array[1..5]of string = ('hi', 'zebra', 'apple', 'Xylophone', 'dog');\n\nProcedure merge(result, left, right : array of string);\nvar i, i1, i2 : Integer;\nbegin\n  i1 := 0;\n  i2 := 0;\n  for i := 0 to Length(result) do\n  begin\n    if (i2 >= Length(right)) or (i1 < Length(left)) and (StrComp(PChar(left[i]), PChar(right[i2])) < 0) then\n    begin\n      result[i] := left[i1];\n      inc(i1);\n    end\n    else\n    begin\n      result[i] := right[i2];\n      inc(i2);\n    end;\n  end;\nend;\n\n\nProcedure mergeSort(OriginalList : array of string);\nvar left, right : array of string;\n    i : Integer;\nbegin\n  if (Length(OriginalList) >= 2) then\n  begin\n    setlength(left, length(OriginalList) div 2);\n    setlength(right, length(OriginalList) - (length(OriginalList) div 2));\n    for i := 0 to Length(left) do\n    begin\n      left[i] := OriginalList[i];\n    end;\n    for i := 0 to Length(right) do\n    begin\n      right[i] := OriginalList[i + Length(OriginalList) div 2];\n    end;\n    mergeSort(left);\n    mergeSort(right);\n    merge(OriginalList, left, right);\n  end;\nend;\n\nbegin\n  writeln('The data before sorting: ');\n  for i := low(MyArray) to High(MyArray) do\n  begin\n    write(MyArray[i]+' ');\n  end;\n  writeln;\n  mergeSort(MyArray);\n  writeln('The data before sorting: ');\n  for i := low(MyArray) to High(MyArray) do\n  begin\n    write(MyArray[i]+' ');\n  end;\n  readln;\nend.\n```\n\n\nOn the line in the mereSort function where I recall the merge sort function on the arrays \"left\" and \"right\", I get the error message but I don't quite understand why?\n    ", "Answer": "\r\nThere are many different things wrong with this, hopefully these points will help you in the right direction.\n\nProblems with Array Indexes\n\nYou are indexing beyond the end of your arrays:\nDynamic arrays are indexed starting from zero so the line\n\n```\n    for i := 0 to Length(left) do\n```\n\n\nshould be \n\n```\n    for i := 0 to Length(left) - 1 do\n```\n\n\nor you can use \n\n```\n   for i := Low(left) to High(left) do\n```\n\n\nAs you did later. \n\nI would recommend you choose a standard form and use it consistently, and also that you avoid declaring constant arrays with non-zero based indexing unless you have good reason, this way you can use the same forms consistently or change the type of array later without running into trouble\n\nThis first fix will stop your program crashing, but you'll notice your sort code isn't changing anything...\n\nProblems with parameter passing\n\nDelphi has several different ways to pass parameters into procedures:\n\n```\nprocedure doSomething(a : array of string);\nprocedure doSomething(var a : array of string);\nprocedure doSomething(out a : array of string);\nprocedure doSomething(const a : array of string);\n```\n\n\nThese determine how what happens inside the procedure can affect the original variable passed\n\nThis is something you will need to understand, read up in the documentation:\nhttp://docwiki.embarcadero.com/RADStudio/Tokyo/en/Parameters_(Delphi)\n\nThere is IMO some very confusing behaviour and syntax relating to array parameters and a lot of stuff that seems intuitive is not allowed especially with XE/older version, its worth reading the documentation about the standard data types\n\nIn the current state, your merge procedure will have no effect because it only operates on a new copy of the array you pass in, which you have also declared as constant\n\nOther\n\nI would avoid the use of ```\nresult```\n as a procedure parameter since this is the name used for function return values, it seems like asking for trouble to use it like that.\n\nPS: I haven't looked at the logic of the merging, just the basic language mistakes\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to implement a k-way merge sort?\r\n                \r\nI need to implement a function which does a k-way merge sort on an unsorted array or integers. \n\nThe function takes in two parameters, an integer K, which is the \"way\" of the sort and always a power of 2. The second parameter is the array of integers to be sorted, whose length is also a power of 2. \n\nThe function is to return an array containing the sorted elements. So far, I know how to implement a regular merge sort. How would I modify this code so that it implements a K-way merge sort? (Note: this function doesn't return the sorted array, I need help with that as well. It also doesn't take in K, since its a regular merge sort)\n\nBelow code:\n\n```\npublic class MergeSort {\n\n  public static void main(String[] args) {\n\n  }\n\n  public static void mergeSort(int[] inputArray) {\n    int size = inputArray.length;\n    if (size < 2)\n        return;\n    int mid = size / 2;\n    int leftSize = mid;\n    int rightSize = size - mid;\n    int[] left = new int[leftSize];\n    int[] right = new int[rightSize];\n    for (int i = 0; i < mid; i++) {\n        left[i] = inputArray[i];\n\n    }\n    for (int i = mid; i < size; i++) {\n        right[i - mid] = inputArray[i];\n    }\n    mergeSort(left);\n    mergeSort(right);\n    merge(left, right, inputArray);\n  }\n\n  public static void merge(int[] left, int[] right, int[] arr) {\n    int leftSize = left.length;\n    int rightSize = right.length;\n    int i = 0, j = 0, k = 0;\n    while (i < leftSize && j < rightSize) {\n      if (left[i] <= right[j]) {\n        arr[k] = left[i];\n        i++;\n        k++;\n      } else {\n        arr[k] = right[j];\n        k++;\n        j++;\n      }\n    }\n    while (i < leftSize) {\n      arr[k] = left[i];\n      k++;\n      i++;\n    }\n    while (j < leftSize) {\n      arr[k] = right[j];\n      k++;\n      j++;\n    }\n  }\n}\n```\n\n    ", "Answer": "\r\nRegular merge sort is two-way sorting. You compare elements from the first and the second halves of array and copy smallest to output array. \n\nFor k-way sorting you divide input array into K parts. K indexes point to the first elements of every part. To effectively choose the smallest of them, use priority queue (based on binary heap) and pop the smallest element from the heap top at every step. When you pop element belonging to the m-th part, push the next element from the same part (if it still exists)\n\nLet you have array length 16 and k = 4.\nThe first recursion level calls  4 mergesorts for arrays copied from indexes 0..3, 4..7, 8..11, 12..15.\nThe second recursion level gets length 4 array and calls 4 mergesorts for 1-element arrays.\nThe third recursion level gets length 1 array and immediately returns (such array is sorted).\nNow at the second recursion level you merge 4 one-element arrays into one sorted array.\nNow at the first recursion level you merge 4 four-element arrays into one sorted array length 16\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Aux complexity on merge sort modification\r\n                \r\nAccording to geekforgeeks:\n\n```\nAuxiliary Space is the extra space or temporary space used by an algorithm.\nSpace Complexity of an algorithm is total space taken by the algorithm with respect to the input size. Space complexity includes both Auxiliary space and space used by input.For example, if we want to compare standard sorting algorithms on the basis of space, then Auxiliary Space would be a better criteria than Space Complexity. Merge Sort uses O(n) auxiliary space, Insertion sort and Heap Sort use O(1) auxiliary space. Space complexity of all these sorting algorithms is O(n) though.```\n\n\nBut, assume a scenario, a modification to merge sort, where was to ```\nreturn```\n a brand new sorted array keeping the input array unchanged.\n\nWould the ```\nnew sorted array which is returned```\n be treated as ```\ntemporary space```\n ?\nIn other words, would the aux complexity ```\nstill```\n be O(n) and space be O(n) ?\n    ", "Answer": "\r\nI've never heard the term auxiliary space complexity. But the regular notion of space complexity separates the input and output space, and the space complexity of your algorithm is any extra space, and for some other more restrictive models to measure space complexity where you can't even write in the input space, it is read only and the output could be written only once, but those are only interesting from a theoretical point of view.\n\nSo I guess the output space should not be considered as part of the aux space, I mean you NEED that space, there is no way you may avoid it, that's why in some analysis the running time also uses the output size as parameter.\n\nSo yes, the space that you use for the output might not be counted as extra space, nevertheless, in the case of mergesort you can't avoid this O(n) extra space, since you are not touching the input, so you will need another auxiliary array to do the merge step.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementation of merge sort with linked lists\r\n                \r\nI am trying out a question found online, which is to implement merge sort with linked list, but using the strange list interface implementation taught by my school instead of using just the nodes, so plain copying from other solutions does not work here. I was usually just expanding on ```\nBasicLinkedList```\n and didn't really bother with the interface. This is my driver code and classes, and the merge sort does not run the way I want it to run and I can't seem to figure out why after debugging for a long time. Can anyone help me out here?\n\nDo inform me if you need more information.\n\n```\nimport java.util.*;\n\nclass Main {\n    public static void main(String [] args) {\n        BasicLinkedList<Integer> lst = BasicLinkedList.of(4,2,1,3);\n        BasicLinkedList<Integer> sortedList = BasicLinkedList.mergeSort(lst);\n        sortedList.print();\n\n    }\n}\n\n\nclass ListNode <E> {\n    protected E element;\n    protected ListNode <E> next;\n\n    /* constructors */\n    public ListNode (E item) { \n        element = item; \n        next = null; \n    }\n\n    public ListNode (E item, ListNode <E> n) { \n        element = item; \n        next=n;\n    }\n\n    /* get the next ListNode */\n    public ListNode <E> getNext ( ) {\n        return this.next;\n    }\n\n    /* get the element of the ListNode */\n    public E getElement ( ) {\n        return this.element;\n    }\n\n    public void setNext(ListNode<E> item) {\n        this.next = item;\n    }\n\n\n}\n\n\n\n\nclass BasicLinkedList <E> implements LinkedListInterface <E> {\n    protected ListNode <E> head = null;\n    protected int num_nodes = 0;\n\n\n    public boolean isEmpty() \n        { return (num_nodes == 0); }\n\n    public int size( ) \n        { return num_nodes; }\n\n    public E getFirst ( ) throws NoSuchElementException {\n        if (head == null) \n            throw new NoSuchElementException(\"can't get from an empty list\");\n        else return head.element;\n    }\n\n    public boolean contains (E item) {\n        for (ListNode <E> n = head; n!= null; n=n.next)\n            if (n.getElement().equals(item)) return true;\n\n        return false;\n    }\n\n    public void addFirst (E item) {\n        head = new ListNode <E> (item, head);\n        num_nodes ++;\n    }\n\n    public E removeFirst ( ) throws NoSuchElementException {\n        ListNode <E> ln;\n        if (head == null) \n            throw new NoSuchElementException (\"can't remove from an empty list\");\n        else { \n            ln = head;\n            head = head.next;\n            num_nodes --;\n            return ln.element;\n        }\n    }\n\n    public void print2 ( ) throws NoSuchElementException {\n        if (head == null)\n            throw new NoSuchElementException (\"Nothing to print...\");\n\n        ListNode <E> ln = head;\n        System.out.print (\"List is: \" + ln.element);\n        for (int i=1; i < num_nodes; i++) {\n            ln = ln.next;\n            System.out.print (\", \" + ln.element );\n        }\n        System.out.println(\".\");\n    }\n\n    public void print () throws NoSuchElementException {\n        if (head == null)\n            throw new NoSuchElementException (\"Nothing to print...\");\n\n        Iterator <E> itr = iterator();\n        System.out.print (\"List is: \" + itr.next() );\n        while (itr.hasNext()) \n            System.out.print ( \", \" + itr.next() );\n        System.out.println(\".\");\n    }\n\n    public Iterator<E> iterator() { \n        return new LinkedListIterator(); \n    }\n\n    private class LinkedListIterator implements Iterator<E> {\n        private ListNode<E> current = head;\n\n        public boolean hasNext(){ return current != null;}\n        public void remove()    { throw new UnsupportedOperationException(); }\n        public E next() {\n            if ( !hasNext()) {\n                throw new NoSuchElementException();\n            }\n            E element = current.element;\n            current = current.next;\n            return element;\n        }\n    }\n\n\n    public static <E> BasicLinkedList<E> of(E ... values) {\n        BasicLinkedList<E> lst = new BasicLinkedList<>();\n        for (int i=values.length-1;i> -1; i--) {\n            lst.addFirst(values[i]);\n        }\n        return lst;\n    }\n\n    public static BasicLinkedList<Integer> mergeSort(BasicLinkedList<Integer> original) {\n        if (original.size() < 2) {\n            return original;\n        } else {\n            int totalSize = original.size();\n            int newSize = totalSize/2;\n\n            ListNode<Integer> middle = getMiddle(original);\n            ListNode<Integer> nextOfMiddle = middle.next; \n            BasicLinkedList<Integer> right = new BasicLinkedList<>();\n            right.head = nextOfMiddle;\n            right.num_nodes = totalSize- newSize;\n            //Create the left list, firstly by creating an empty shell and replace the head node\n            BasicLinkedList<Integer> left = new BasicLinkedList();\n            left.head = original.head;\n            right.num_nodes = newSize;\n\n\n\n\n            // set the next of middle node to null \n            middle.setNext(null);\n            // System.out.println(\"Before MS\");\n            // debug(left,right);\n\n\n            BasicLinkedList<Integer> newLeft = mergeSort(left);\n            BasicLinkedList<Integer> newRight = mergeSort(right);\n\n            // System.out.println(\"After MS\");\n\n            BasicLinkedList<Integer> lst = merge(newLeft,newRight);\n            //lst.print();\n            return lst;\n        }\n    }\n\n    public static ListNode<Integer> getMiddle(BasicLinkedList<Integer> original) {\n        if (original.head == null) \n            return null;\n        ListNode<Integer> slowPtr = original.head;\n        ListNode<Integer> fastPtr = slowPtr.next;\n        while (fastPtr != null) {\n            fastPtr = fastPtr.next; \n            if(fastPtr!=null) {\n                slowPtr = slowPtr.next; \n                fastPtr=fastPtr.next; \n            } \n        } \n        return slowPtr; \n    } \n\n    //Merges 2 non-empty lists together\n    public static BasicLinkedList<Integer> merge(\n        BasicLinkedList<Integer> firstList,\n        BasicLinkedList<Integer> secondList) {\n        ListNode<Integer> firstHead = firstList.head;\n        ListNode<Integer> secondHead = secondList.head;\n\n        BasicLinkedList<Integer> newList = new BasicLinkedList<Integer>();\n        // move smaller node into newList, and maintain its tail\n\n        //debugNode(firstHead,secondHead);\n        if (firstHead.getElement() <= secondHead.getElement()) {\n            newList.head = firstHead;\n            firstHead = firstHead.getNext();\n        } else {\n            newList.head = secondHead;\n            secondHead = secondHead.getNext();\n        }\n        ListNode<Integer> newTail = newList.head;\n\n\n        while (firstHead != null && secondHead != null) {\n            // System.out.println(\"Before loop \");\n            // debugNode(firstHead,secondHead);\n            if (firstHead.getElement() < secondHead.getElement()) {\n                newTail.setNext(firstHead);\n                firstHead = firstHead.getNext();\n            } else {\n                newTail.setNext(secondHead);\n                secondHead = secondHead.getNext();\n            }\n            newTail = newTail.getNext();\n            // System.out.println(\"After loop \");\n            // debugNode(firstHead,secondHead);\n        }\n\n        if (firstHead != null)\n            newTail.setNext(firstHead);\n        if (secondHead != null)\n            newTail.setNext(secondHead);\n        // perform cleanup\n        firstList.head = null;\n        secondList.head = null;\n        return newList;\n    }\n\n    public static void debug(BasicLinkedList<Integer> left, BasicLinkedList<Integer> right) {\n        System.out.print(\"Left\");\n        left.print();\n        System.out.print(\"Right\");\n        right.print();\n    }\n\n    public static void debugNode(ListNode<Integer> first, ListNode<Integer> second) {\n        System.out.print(\"Left\");\n        System.out.println(first.getElement());\n        System.out.print(\"Right\");\n        System.out.println(first.getElement());\n    }\n\n\n\n}\n\nimport java.util.*;\n\npublic interface LinkedListInterface <E> {\n\n    public boolean  isEmpty( );\n    public int      size ( );\n    public E        getFirst  () throws NoSuchElementException; \n    public boolean  contains (E item);\n    public void     addFirst (E item);\n    public E        removeFirst ( ) throws NoSuchElementException;  \n\n    public void     print ();\n\n    // ....etc....\n    // ....etc....\n}\n```\n\n\nAccording to my main driver code as shown, with the right merge sort function, ```\nList is: 1, 2 ,3, 4.```\n should be printed out when starting with a list of ```\n[4,2,1,3]```\n. My current merge sort prints out [1,3,2,4] and my debugging attempts are shown in the commented lines of code. \n    ", "Answer": "\r\nIn method ```\nBasicLinkedList<Integer> mergeSort```\n, you are not setting the size of the ```\nleft```\n linked list, rather you are setting the size of the ```\nright```\n linked list twice.\n\nHere is your code:\n\n```\n            right.head = nextOfMiddle;\n            right.num_nodes = totalSize - newSize;\n            //Create the left list, firstly by creating an empty shell and replace the head node\n            BasicLinkedList<Integer> left = new BasicLinkedList();\n            left.head = original.head;\n\n            //here is the mistake\n            //change it to  - left.num_nodes = newSize;\n            right.num_nodes = newSize;\n```\n\n\nPS: I don't know which IDE you are using, but I would suggest you to download IntelliJ Idea and use its debugging features. Also, you might have other corner cases to test for.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Iterative/ Non-Recursive Merge Sort\r\n                \r\nI was trying iterative merge sort , but am stuck at at conditions when input length is not 2^x.\n\nlike int[] A ={4,5,1,254,66,75,12,8,65,4,87,63,53,8,99,54,12,34};\n\n```\npublic class MergeSort {\n    public static void sort(int[] A) {\n        System.out.println(\"Log(A.len):\"+log(A.length, 2));\n\n        for (int i = 0; i < log(A.length, 2); i++) { //log A.len\n            int r = 2 << i; //2^i\n            int mid = r >>> 1;\n            for (int j = 0; j+r < A.length; j = j + r) {\n                System.out.print(\"offset:\" + j + \" mid:\" + (j + mid) + \" r:\" + (j + r));\n                merge(A, j, (j + mid), (j + r));\n            }\n        }\n    }\n\n    public static void merge(int[] A, int offset, int mid, int n) {\n        mid = mid - offset;\n        n = n - offset;\n        int[] L = new int[mid];\n        int[] R = new int[n - mid];\n        for (int i = 0; i < mid; i++) {\n            L[i] = A[i + offset];\n            R[i] = A[mid + i + offset];\n        }\n        System.out.print(\"\\nL:\");\n        print_array(L);\n        System.out.print(\"\\nR:\");\n        print_array(R);\n\n        int l = 0;\n        int r = 0; //left right pointer\n        int k = offset;\n        while (l < mid && r < mid) {\n            if (L[l] < R[r]) {\n//                System.out.println(\"in left\");\n                A[k] = L[l];\n                l++;\n            } else {\n//                System.out.println(\"in right\");\n                A[k] = R[r];\n                r++;\n            }\n            k++;\n        }\n        while (l < mid) {\n            A[k] = L[l];\n            l++;\n            k++;\n        }\n        while (r < mid) {\n            A[k] = R[r];\n            r++;\n            k++;\n        }\n\n        System.out.print(\"\\nA:\");\n        print_array(A);\n        System.out.print(\"\\n\\n\");\n\n    }\n\n\n    public static void main(String[] args) {\n        int[] A ={4,5,1,254,66,75,12,8,65,4,87,63,53,8,99,54,12,34};\n        sort(A);\n\n    }\n\n    public static void print_array(int[] A) {\n        for (int i = 0; i < A.length; i++) {\n            System.out.print(A[i] + \" \");\n        }\n    }\n\n    static int log(int x, int base) {\n        return (int) (Math.log(x) / Math.log(base));\n    }\n}\n```\n\n\nIt works fine when input length is 2^x.\n\nAlso is there any better way to implement iterative version , this looks a lot messy.\n    ", "Answer": "\r\nC++ example of bottom up merge sort. a[] is array to sort, b[] is temp array. It includes a check for number of merge passes and swaps in place if the number of passes would be odd, in order to end up with the sorted data in a[].\n\n```\nvoid BottomUpMerge(int a[], int b[], size_t ll, size_t rr, size_t ee);\nvoid BottomUpCopy(int a[], int b[], size_t ll, size_t rr);\nsize_t GetPassCount(size_t n);\n\nvoid BottomUpMergeSort(int a[], int b[], size_t n)\n{\nsize_t s = 1;                               // run size \n    if(GetPassCount(n) & 1){                // if odd number of passes\n        for(s = 1; s < n; s += 2)           // swap in place for 1st pass\n            if(a[s] < a[s-1])\n                std::swap(a[s], a[s-1]);\n        s = 2;\n    }\n    while(s < n){                           // while not done\n        size_t ee = 0;                      // reset end index\n        while(ee < n){                      // merge pairs of runs\n            size_t ll = ee;                 // ll = start of left  run\n            size_t rr = ll+s;               // rr = start of right run\n            if(rr >= n){                    // if only left run\n                rr = n;\n                BottomUpCopy(a, b, ll, rr); //   copy left run\n                break;                      //   end of pass\n            }\n            ee = rr+s;                      // ee = end of right run\n            if(ee > n)\n                ee = n;\n            BottomUpMerge(a, b, ll, rr, ee);\n        }\n        std::swap(a, b);                    // swap a and b\n        s <<= 1;                            // double the run size\n    }\n}\n\nvoid BottomUpMerge(int a[], int b[], size_t ll, size_t rr, size_t ee)\n{\n    size_t o = ll;                          // b[]       index\n    size_t l = ll;                          // a[] left  index\n    size_t r = rr;                          // a[] right index\n    while(1){                               // merge data\n        if(a[l] <= a[r]){                   // if a[l] <= a[r]\n            b[o++] = a[l++];                //   copy a[l]\n            if(l < rr)                      //   if not end of left run\n                continue;                   //     continue (back to while)\n            do                              //   else copy rest of right run\n                b[o++] = a[r++];\n            while(r < ee);\n            break;                          //     and return\n        } else {                            // else a[l] > a[r]\n            b[o++] = a[r++];                //   copy a[r]\n            if(r < ee)                      //   if not end of right run\n                continue;                   //     continue (back to while)\n            do                              //   else copy rest of left run\n                b[o++] = a[l++];\n            while(l < rr);\n            break;                          //     and return\n        }\n    }\n}\n\nvoid BottomUpCopy(int a[], int b[], size_t ll, size_t rr)\n{\n    do                                      // copy left run\n        b[ll] = a[ll];\n    while(++ll < rr);\n}\n\nsize_t GetPassCount(size_t n)               // return # passes\n{\n    size_t i = 0;\n    for(size_t s = 1; s < n; s <<= 1)\n        i += 1;\n    return(i);\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort and Queue\r\n                \r\nIm working on a review sheet pretty much got everything except not sure about these two. any help please?\n\nQ what is the benefit of using a queue to do merge sort?\nQ suppose in mergesort we replace the queue with a stack\n(i.e. push instead of enqueue, pop in place of dequeue).\nexplain what effect this replacement will have.\n    ", "Answer": "\r\nWith ```\nqueues```\n things automatically are added to the end of the list; thus, when you get to the lowest level of ```\nmergesort```\n's recursion (individual elements), your sorted array can just ```\nenqueue```\n the largest of these elements into a new list. Using a ```\nstack```\n should reverse your list since all elements added will be put at the front, so you'd have to essentially search for the smallest element instead of the largest.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementation of merge sort with linked lists\r\n                \r\nI am trying out a question found online, which is to implement merge sort with linked list, but using the strange list interface implementation taught by my school instead of using just the nodes, so plain copying from other solutions does not work here. I was usually just expanding on ```\nBasicLinkedList```\n and didn't really bother with the interface. This is my driver code and classes, and the merge sort does not run the way I want it to run and I can't seem to figure out why after debugging for a long time. Can anyone help me out here?\n\nDo inform me if you need more information.\n\n```\nimport java.util.*;\n\nclass Main {\n    public static void main(String [] args) {\n        BasicLinkedList<Integer> lst = BasicLinkedList.of(4,2,1,3);\n        BasicLinkedList<Integer> sortedList = BasicLinkedList.mergeSort(lst);\n        sortedList.print();\n\n    }\n}\n\n\nclass ListNode <E> {\n    protected E element;\n    protected ListNode <E> next;\n\n    /* constructors */\n    public ListNode (E item) { \n        element = item; \n        next = null; \n    }\n\n    public ListNode (E item, ListNode <E> n) { \n        element = item; \n        next=n;\n    }\n\n    /* get the next ListNode */\n    public ListNode <E> getNext ( ) {\n        return this.next;\n    }\n\n    /* get the element of the ListNode */\n    public E getElement ( ) {\n        return this.element;\n    }\n\n    public void setNext(ListNode<E> item) {\n        this.next = item;\n    }\n\n\n}\n\n\n\n\nclass BasicLinkedList <E> implements LinkedListInterface <E> {\n    protected ListNode <E> head = null;\n    protected int num_nodes = 0;\n\n\n    public boolean isEmpty() \n        { return (num_nodes == 0); }\n\n    public int size( ) \n        { return num_nodes; }\n\n    public E getFirst ( ) throws NoSuchElementException {\n        if (head == null) \n            throw new NoSuchElementException(\"can't get from an empty list\");\n        else return head.element;\n    }\n\n    public boolean contains (E item) {\n        for (ListNode <E> n = head; n!= null; n=n.next)\n            if (n.getElement().equals(item)) return true;\n\n        return false;\n    }\n\n    public void addFirst (E item) {\n        head = new ListNode <E> (item, head);\n        num_nodes ++;\n    }\n\n    public E removeFirst ( ) throws NoSuchElementException {\n        ListNode <E> ln;\n        if (head == null) \n            throw new NoSuchElementException (\"can't remove from an empty list\");\n        else { \n            ln = head;\n            head = head.next;\n            num_nodes --;\n            return ln.element;\n        }\n    }\n\n    public void print2 ( ) throws NoSuchElementException {\n        if (head == null)\n            throw new NoSuchElementException (\"Nothing to print...\");\n\n        ListNode <E> ln = head;\n        System.out.print (\"List is: \" + ln.element);\n        for (int i=1; i < num_nodes; i++) {\n            ln = ln.next;\n            System.out.print (\", \" + ln.element );\n        }\n        System.out.println(\".\");\n    }\n\n    public void print () throws NoSuchElementException {\n        if (head == null)\n            throw new NoSuchElementException (\"Nothing to print...\");\n\n        Iterator <E> itr = iterator();\n        System.out.print (\"List is: \" + itr.next() );\n        while (itr.hasNext()) \n            System.out.print ( \", \" + itr.next() );\n        System.out.println(\".\");\n    }\n\n    public Iterator<E> iterator() { \n        return new LinkedListIterator(); \n    }\n\n    private class LinkedListIterator implements Iterator<E> {\n        private ListNode<E> current = head;\n\n        public boolean hasNext(){ return current != null;}\n        public void remove()    { throw new UnsupportedOperationException(); }\n        public E next() {\n            if ( !hasNext()) {\n                throw new NoSuchElementException();\n            }\n            E element = current.element;\n            current = current.next;\n            return element;\n        }\n    }\n\n\n    public static <E> BasicLinkedList<E> of(E ... values) {\n        BasicLinkedList<E> lst = new BasicLinkedList<>();\n        for (int i=values.length-1;i> -1; i--) {\n            lst.addFirst(values[i]);\n        }\n        return lst;\n    }\n\n    public static BasicLinkedList<Integer> mergeSort(BasicLinkedList<Integer> original) {\n        if (original.size() < 2) {\n            return original;\n        } else {\n            int totalSize = original.size();\n            int newSize = totalSize/2;\n\n            ListNode<Integer> middle = getMiddle(original);\n            ListNode<Integer> nextOfMiddle = middle.next; \n            BasicLinkedList<Integer> right = new BasicLinkedList<>();\n            right.head = nextOfMiddle;\n            right.num_nodes = totalSize- newSize;\n            //Create the left list, firstly by creating an empty shell and replace the head node\n            BasicLinkedList<Integer> left = new BasicLinkedList();\n            left.head = original.head;\n            right.num_nodes = newSize;\n\n\n\n\n            // set the next of middle node to null \n            middle.setNext(null);\n            // System.out.println(\"Before MS\");\n            // debug(left,right);\n\n\n            BasicLinkedList<Integer> newLeft = mergeSort(left);\n            BasicLinkedList<Integer> newRight = mergeSort(right);\n\n            // System.out.println(\"After MS\");\n\n            BasicLinkedList<Integer> lst = merge(newLeft,newRight);\n            //lst.print();\n            return lst;\n        }\n    }\n\n    public static ListNode<Integer> getMiddle(BasicLinkedList<Integer> original) {\n        if (original.head == null) \n            return null;\n        ListNode<Integer> slowPtr = original.head;\n        ListNode<Integer> fastPtr = slowPtr.next;\n        while (fastPtr != null) {\n            fastPtr = fastPtr.next; \n            if(fastPtr!=null) {\n                slowPtr = slowPtr.next; \n                fastPtr=fastPtr.next; \n            } \n        } \n        return slowPtr; \n    } \n\n    //Merges 2 non-empty lists together\n    public static BasicLinkedList<Integer> merge(\n        BasicLinkedList<Integer> firstList,\n        BasicLinkedList<Integer> secondList) {\n        ListNode<Integer> firstHead = firstList.head;\n        ListNode<Integer> secondHead = secondList.head;\n\n        BasicLinkedList<Integer> newList = new BasicLinkedList<Integer>();\n        // move smaller node into newList, and maintain its tail\n\n        //debugNode(firstHead,secondHead);\n        if (firstHead.getElement() <= secondHead.getElement()) {\n            newList.head = firstHead;\n            firstHead = firstHead.getNext();\n        } else {\n            newList.head = secondHead;\n            secondHead = secondHead.getNext();\n        }\n        ListNode<Integer> newTail = newList.head;\n\n\n        while (firstHead != null && secondHead != null) {\n            // System.out.println(\"Before loop \");\n            // debugNode(firstHead,secondHead);\n            if (firstHead.getElement() < secondHead.getElement()) {\n                newTail.setNext(firstHead);\n                firstHead = firstHead.getNext();\n            } else {\n                newTail.setNext(secondHead);\n                secondHead = secondHead.getNext();\n            }\n            newTail = newTail.getNext();\n            // System.out.println(\"After loop \");\n            // debugNode(firstHead,secondHead);\n        }\n\n        if (firstHead != null)\n            newTail.setNext(firstHead);\n        if (secondHead != null)\n            newTail.setNext(secondHead);\n        // perform cleanup\n        firstList.head = null;\n        secondList.head = null;\n        return newList;\n    }\n\n    public static void debug(BasicLinkedList<Integer> left, BasicLinkedList<Integer> right) {\n        System.out.print(\"Left\");\n        left.print();\n        System.out.print(\"Right\");\n        right.print();\n    }\n\n    public static void debugNode(ListNode<Integer> first, ListNode<Integer> second) {\n        System.out.print(\"Left\");\n        System.out.println(first.getElement());\n        System.out.print(\"Right\");\n        System.out.println(first.getElement());\n    }\n\n\n\n}\n\nimport java.util.*;\n\npublic interface LinkedListInterface <E> {\n\n    public boolean  isEmpty( );\n    public int      size ( );\n    public E        getFirst  () throws NoSuchElementException; \n    public boolean  contains (E item);\n    public void     addFirst (E item);\n    public E        removeFirst ( ) throws NoSuchElementException;  \n\n    public void     print ();\n\n    // ....etc....\n    // ....etc....\n}\n```\n\n\nAccording to my main driver code as shown, with the right merge sort function, ```\nList is: 1, 2 ,3, 4.```\n should be printed out when starting with a list of ```\n[4,2,1,3]```\n. My current merge sort prints out [1,3,2,4] and my debugging attempts are shown in the commented lines of code. \n    ", "Answer": "\r\nIn method ```\nBasicLinkedList<Integer> mergeSort```\n, you are not setting the size of the ```\nleft```\n linked list, rather you are setting the size of the ```\nright```\n linked list twice.\n\nHere is your code:\n\n```\n            right.head = nextOfMiddle;\n            right.num_nodes = totalSize - newSize;\n            //Create the left list, firstly by creating an empty shell and replace the head node\n            BasicLinkedList<Integer> left = new BasicLinkedList();\n            left.head = original.head;\n\n            //here is the mistake\n            //change it to  - left.num_nodes = newSize;\n            right.num_nodes = newSize;\n```\n\n\nPS: I don't know which IDE you are using, but I would suggest you to download IntelliJ Idea and use its debugging features. Also, you might have other corner cases to test for.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Out of memory error when parallelizing merge sort\r\n                \r\nI try to ```\nparallelize```\n my merge sort implementation: http://pastebin.com/2uMGjTxr. \nI want to create as many threads as Java-VM can provide. I want to determine the maximum number of possible threads using java.lang.Runtime.\n\nSo I came up with a class called MergeThread:\n\n```\npublic class MergeThread implements Runnable{\n\n    public int[] list;\n    int sIndex, eIndex;\n\n    public MergeThread(int[] pArray, int pStartIndex, int pEndIndex){\n        list = pArray;\n        sIndex = pStartIndex;\n        eIndex = pEndIndex;\n    }\n\n    public void run(){\n        list = mergeSort(list, sIndex, eIndex);\n    }\n\n    /**\n     * Merges two sorted int array into one new sorted array.\n     * @param lhs\n     * @param rhs\n     * @return\n     */\n    private static int[] merge(int[] lhs, int[] rhs) {\n        int[] result = new int[lhs.length + rhs.length];\n\n        int leftIndex = 0;\n        int rightIndex = 0;\n        while(leftIndex < lhs.length && rightIndex < rhs.length) {\n            if(lhs[leftIndex] <= rhs[rightIndex]) {\n                result[leftIndex + rightIndex] = lhs[leftIndex];\n                leftIndex++;\n            } else {\n                result[leftIndex + rightIndex] = rhs[rightIndex];\n                rightIndex++;\n            }\n        }\n\n        while(leftIndex < lhs.length) {\n            result[leftIndex + rightIndex] = lhs[leftIndex];\n            leftIndex++;\n        }\n\n        while(rightIndex < rhs.length) {\n            result[leftIndex + rightIndex] = rhs[rightIndex];\n            rightIndex++;\n        }\n\n        return result;\n    }\n\n    /**\n     * Sorts an array from index <code>startIndex</code> (inclusive) to <code>endIndex</code> (exclusive).\n     * @param array\n     * @param startIndex\n     * @param endIndex\n     * @return new array that is sorted\n     */\n    private static int[] mergeSort(int[] array, int startIndex, int endIndex) {\n        int length = endIndex - startIndex;\n        if(length == 0) {\n            return new int[]{};\n        }\n        if(length == 1) {\n            return new int[]{array[startIndex]};\n        }\n\n        int halfLength = length / 2;\n        //int[] sortedLeftPart = mergeSort(array, startIndex, startIndex + halfLength);\n        MergeThread m1 = new MergeThread(array, startIndex, startIndex + halfLength);\n        Thread t1 = new Thread(m1);\n        t1.start();\n        //int[] sortedRightPart = mergeSort(array, startIndex + halfLength, endIndex);\n        MergeThread m2 = new MergeThread(array, startIndex + halfLength, endIndex);\n        Thread t2 = new Thread(m2);\n        t2.start();\n        try{\n        t1.join();\n        t2.join();\n        }catch(InterruptedException e){}\n        return merge(m1.list, m2.list);     \n    }\n}\n```\n\n\nAnd a class that actually starts the process\n\n```\nimport java.util.Random;\n\npublic class Aufg2 {\n    public static Random random = new Random(100);\n\n    public static void main(String[] args) {\n        int[] array = createRandomArray(10000000);\n\n        long time = System.currentTimeMillis();\n\n        int[] sortedArray = sort(array);\n\n        if(sortedArray.length != array.length || !isSorted(sortedArray)) {\n            System.err.println(\"Failed to sort given array! :-(\");\n            return;\n        }       \n        System.out.println(\"Success! Sorting took \" + (System.currentTimeMillis() - time) + \"ms.\");     \n    }\n\n    /**\n     * Creates a randomly filled array of given length\n     * @param length\n     * @return\n     */\n    private static int[] createRandomArray(int length) {\n        int[] result = new int[length];\n        for(int i = 0; i < length; i++) {\n            result[i] = random.nextInt();\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether a given int array is sorted in ascending order  \n     * @param array\n     * @return <code>true</code> if the given int array is sorted; <code>false</code> otherwise.\n     */\n    private static boolean isSorted(int[] array) {\n        for(int i = 1; i < array.length; i++) {\n            if(array[i] < array[i-1]) {\n                return false;\n            }\n        }\n        return true;\n    }   \n\n    /**\n     * Sorts a given array (ascending order)\n     * @param array\n     * @return\n     */\n    private static int[] sort(int[] array){\n        //TODO: use multiple threads to speed up the sorting\n        MergeThread m = new MergeThread(array, 0, array.length);\n\n        try{\n\n        Thread t1 = new Thread(m);\n        t1.start();\n        t1.join();\n        }catch(InterruptedException e){\n\n        }\n        return m.list;\n    }\n}\n```\n\n\nHowever this merge sort does not work. The console prints a lot of ```\njava.lang.OutOfMemmoryError's unable to create new native thread```\n.\n\nLater the message changes to something like ```\njava heap```\n.\n\nWhat do I have to change to get the merge sort working and how do I use java.lang.Runtime for that?\n    ", "Answer": "\r\nThe divide and conquer mechanism has you trying to create something like 5000000 threads - and each of those wants as default 256KB (IIRC) of stack memory. Still surprised why you get an ```\nOutOfMemmoryError```\n?\n\nLimit the number of threads by using a fixed size thread pool - experiment a bit with the number of threads in the pool, but anything much more than the number of cores in your system is very unlikely to improve performance (and may indeed reduce it).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "What is wrong with my Merge Sort code?\r\n                \r\nI'm having trouble with Merge Sort in my computers class. I keep getting either errors or the original ArrayList returned.\n\nI believe that Merge Sort involves splitting an array(list) in half recursively until there is only one element left, then, working from those individual elements, merging them in sorted order. This continues until the array(list) has been sorted. As for the actual sorting part, I am trying to insert into a new ArrayList the higher value between the two halves until they are both empty, in which case the filled ArrayList is now sorted.\n\nHere's my current code:\n\n```\npublic static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n\n    // Base case: if size of ArrayList is 1, return it.\n    if (arr.size() < 2) {\n        return arr;\n    }\n\n    // Else: Find the middle index.\n    int middle = (arr.size() - 1) / 2;\n\n    // Split into left and right halves.\n    ArrayList<Integer> leftHalf = new ArrayList<Integer>();\n    for (int i = 0; i < middle; i++)\n        leftHalf.add(arr.get(i));\n\n    ArrayList<Integer> rightHalf = new ArrayList<Integer>();\n    for (int j = middle; j < arr.size(); j++)\n        rightHalf.add(arr.get(j));\n\n    // Recurse using the halves.\n    mergesort(leftHalf);\n    mergesort(rightHalf);\n\n    // Sort and merge the two halves.\n    return merge(leftHalf, rightHalf, arr);\n}\n\n// Merge two halves and sort them, and put the sorted values into the ArrayList sorted.\npublic static ArrayList<Integer> merge(ArrayList<Integer> arr1, ArrayList<Integer> arr2, ArrayList<Integer> sorted) {\n\n    // While the ArrayLists are not empty, add sorted elements to ArrayList sorted.\n    while (arr1.size() > 0 && arr2.size() > 0) {\n\n        // If the first element in A is greater than the first in B, remove A and add to ArrayList sorted.\n        if (arr1.get(0) >= arr2.get(0)) {\n            sorted.add(arr1.get(0));\n            arr1.remove(0);\n        }\n        // Else, remove from B and add to ArrayList sorted.\n        else {\n            sorted.add(arr2.get(0));\n            arr2.remove(0);\n        }\n    }\n\n    // If there're still elements in A due to arr being odd\n    // add them to C since they will be the largest.\n    if (arr1.size() > 0)\n        sorted.add(arr1.get(0));\n\n    return sorted;\n}\n```\n\n\nI would appreciate any help, but please don't give me a full implementation of the Merge Sort, since I want to actually learn how to do this for the future.\n    ", "Answer": "\r\nTwo immediate problems I see.\n\nFirst, you have infinite recursion.  Say you pass in a 4-value list and print your list size and middle values, you'll get:\n\n```\nsize 4, middle 1\n size 3, middle 1\n size 2, middle 0\n size 2, middle 0\n size 2, middle 0\n ... to infinity\n```\n\n\nRemember that Java is aleardy doing integer division in your code.\n\nSecond, you're passing the ```\narr```\n parameter from ```\nmergesort```\n to ```\nmerge```\n, nothing is ever getting removed from it.  So even if you made it past the infinite recursion you'd still end up with a larger list in the end, your original list plus anything you've ```\n.add()```\ned to it\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort algorithm not working correctly\r\n                \r\nAs part of a homework assignment, I need to be able to implement a merge sort using a structure as the main argument. Having not been familiar with the merge sort until today, i have attempted to write my own implementation of it. For some reason I cannot get it to work.\n\nHere is my code:\n\n```\n#include<iostream>\n#include<stdlib.h>\n\nusing namespace std;\n\nstruct MergeArgument\n{\n    int *numArray;\n    int *tempArray;\n    int lowIndex, highIndex;\n};\n\nvoid merge(MergeArgument*);\nvoid merge_sort(MergeArgument*);\n\nint main(int argc, char** argv)\n{   int SIZE = 25;\n    MergeArgument arg;\n    int arr[SIZE];\n    int temp[SIZE];\n\n    for(int k = 0; k < SIZE; k++)\n    {\n        arr[k] = rand() % 100;\n        cout << arr[k] << \" \";\n    }\n\n    arg.numArray = arr;\n    arg.tempArray = temp;\n    arg.lowIndex = 0;\n    arg.highIndex = SIZE - 1;\n\n    cout << endl;\n\n    merge_sort(&arg);\n\n    cout << \"Sorted array: \\n\";\n\n    for (int i = 0; i < SIZE; i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n\n    return 0;\n}\n\nvoid merge_sort(MergeArgument *arg)\n{   int tempHigh, tempLow;\n    if(arg->lowIndex < arg->highIndex)\n    {\n        tempHigh = arg->highIndex;\n        tempLow = arg->lowIndex;\n        arg->highIndex = (tempHigh + tempLow) / 2;\n        merge_sort(arg);\n        arg->highIndex = tempHigh;\n        arg->lowIndex = ((tempHigh + tempLow) / 2) + 1;\n        merge_sort(arg);\n        arg->lowIndex = tempLow;\n        merge(arg);\n    }\n\n}\n\nvoid merge(MergeArgument *arg)\n{   int low = arg->lowIndex, mid = ((arg->lowIndex + arg->highIndex) / 2), high = arg->highIndex;\n    int i = low, lowCounter = low, highCounter = mid + 1;\n\n    while((lowCounter <= mid) && (highCounter <= high))\n    {\n        if(arg->numArray[lowCounter] < arg->numArray[highCounter])\n        {\n            arg->tempArray[i] = arg->numArray[lowCounter];\n            lowCounter++;\n        }\n        else\n        {\n            arg->tempArray[i] = arg->numArray[highCounter];\n            highCounter++;\n        }\n        i++;\n    }\n\n    if (lowCounter < mid)\n    {\n        for (int k = lowCounter; k < mid; k++)\n        {\n            arg->tempArray[i] = arg->numArray[k];\n            i++;\n        }\n    }\n    else\n    {\n        for (int k = highCounter; k <= arg->highIndex; k++)\n        {\n            arg->tempArray[i] = arg->numArray[k];\n            i++;\n        }\n\n    }\n\n    for(int k = arg->lowIndex; k <= arg->highIndex; k++)\n    {\n        arg->numArray[k] = arg->tempArray[k];\n    }\n}\n```\n\n\nHere is the output I am getting:\n\n```\n83 86 77 15 93 35 86 92 49 21 62 27 90 59 63 26 40 26 72 36 11 68 67 29 82    \nSorted array:  \n11 -1216235240 15 0 21 26 -1079135248 26 27 -1079135396 29 -1216770650 35 -1216235240 49 -1216492084 59 0 68 72 82 83 0 86 82\n```\n\n\nCan anyone point out what exactly I am doing wrong?\n    ", "Answer": "\r\nThis is pretty close to working, although you might want to consider some of the comments folks have made on making this more C++ like.  No doubt this is from hard-won experience that there is never enough time to go back and do what you really should do.\n\nThe problem I see is here, in ```\nmerge```\n:\n\n```\nif (lowCounter < mid)\n{\n    for (int k = lowCounter; k < mid; k++)\n    {\n        arg->tempArray[i] = arg->numArray[k];\n        i++;\n    }\n}\n```\n\n\nYou might want to compare and contrast the bounds here to the initial loop.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Stack Overflow while sorting (merge sort and quick sort)\r\n                \r\nWe are supposed to compare the speeds of each sort with 10000 inputs. They all work by themselves but when I add them together in the program I think perhaps merge sort takes a lot of space so I always get an ```\nunhandled exception: StackOverflow```\n once I reach ```\nquicksort```\n. Does anyone know a solution to this problem to perhaps make it so merge sort doesn't take a lot of space (if that is the problem)? Specifically, the exception is thrown at the partition function for ```\nquicksort```\n.\n```\n#include <iostream>\n#include <fstream>\n#include <ctime>\nusing namespace std;\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int *L = new int[n1];\n    int *R = new int[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0; \n    j = 0; \n    k = l; \n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint partition(int arr[], int start, int end) { //start is 0 and end is counter-1\n    int pivot = start; //remember start here\n    int imp = arr[end];\n    for (int i = start; i < end; i++) { //remember this is start and end;\n        if (arr[i] <= imp) {\n            int temp = arr[i];\n            arr[i] = arr[pivot];\n            arr[pivot] = temp;\n            pivot++;\n        }\n    }\n    int p = arr[pivot];\n    arr[pivot] = arr[end];\n    arr[end] = p;\n    return pivot;\n}\n\nvoid quicksort(int arr[], int start, int end) {\n    if (start < end) {\n        int index = partition(arr, start, end);\n        quicksort(arr, start, index - 1);\n        quicksort(arr, index + 1, end);\n    }\n}\n\nint main() {\n    clock_t timereq;\n    double time_taken;\n    ifstream in(\"input3.txt\");\n    int size;\n    in >> size;\n    int num;\n    int *arrq = new int[size];\n    int i = 0;\n    while (!in.eof()) {\n        in >> num;\n        arrq[i] = num;\n        i++;\n    }\n    timereq = clock();\n    mergeSort(arrq, 0,size-1);\n    timereq = clock() - timereq;\n    time_taken = double(timereq) / CLOCKS_PER_SEC; /// double(CLOCKS_PER_SEC);\n    cout << time_taken << endl;\n    \n    timereq = clock();\n    quicksort(arrq, 0,size-1);\n    timereq = clock() - timereq;\n    time_taken = double(timereq) / CLOCKS_PER_SEC; /// double(CLOCKS_PER_SEC);\n    cout << time_taken << endl;\n\n    for (i = 0; i < size; i++) {\n        cout << arrq[i] << endl;\n    }\n}\n```\n\nThe input looks for example like this, the number of values and then the values:\n```\n8\n3 1 4 1 5 9 2 6\n```\n\n    ", "Answer": "\r\nYou should really follow the suggestions given in the comments above, and directly tackle the root of the problem (limited stack size) by redesigning your code with ```\nstack```\n data structures in place, so to specifically avoid memory-draining recursions.\nHowever, you could also in principle cut corners, and adopt a dirtier and quicker solution: just add flags to your compiler to let it increase the size of the stack.\nIf you use gcc, you can do this by inserting the ```\n-Wl, --stack,<size>```\n keys if compiling from the prompt.\nThe ```\n<size>```\n key above could be any size bigger than your current stack size, ```\n-Wl, --stack,1000000000```\n (9 zeros) for instance.\nIf you instead are using an IDE, I happen to know how to do this on Codeblocks: go to Settings->Compiler->Global Compiler Settings->Linker Settings-> add the line above under the Other Linker Options field.\nSee also stackoverflow: How to increase stack size when compiling a C++ program using MinGW compiler\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementation of merge sort using threads and fork\r\n                \r\nProblem: I'm trying to implement Merge Sort in the following way, I have a Parent and two children. the first child will use the merge sort on his own, the second child will implement this the following way: create 2 threads, first one will sort the first half of the array, the second one will sort the rest. Then, after calling the merge sort, he will create again 2 threads for the first half, and 2 threads for the rest, and so on, until we end up in the base case and we finish. In the end, I want to check how much faster the second child implemented the merge sort than the first child.\n\nMy question: I've created 2 childs, the first child is implementing the sort merge and everything is fine. the second child - I was able to create only 2 threads, instead of much more (then 2 for each half, and so on), and in the end it neither prints the array nor the date of its finish.\n\nThis is the code for the second child:\n\n```\nif((id2 = fork()) == 0 && id1 != 0)\n    {\n        printf(\"Child2: \\n\");\n        ans1 = pthread_create ( &thread1 , NULL , mergeSort ,(arr3, (arr_size / 2) - 1 ,arr_size - 1 )) ;\n        ans2 = pthread_create ( &thread2 , NULL , mergeSort ,(arr3, 0, (arr_size / 2)-  1 )) ;\n        ans3 = pthread_create ( &thread3 , NULL , printArray ,(arr3, arr_size) ) ;\n        execl(\"/bin/date\", \"date\",0);\n        if ( ans1 != 0 || ans2 != 0 || ans3 != 0) {\n            printf ( \" \\n can't create threads \" ) ;\n            exit(0) ;\n        }\n            pthread_join ( thread1 , NULL ) ;\n            pthread_join ( thread2 , NULL ) ;\n            pthread_join ( thread3 , NULL ) ;\n\n    }\n```\n\n\nI'm using UNIX, and for compiling:\n\n```\ngcc -lpthread prog.c\n```\n\n\nfor executing:\n\n```\n./a.out\n```\n\n\nThis is the whole code:\n\n```\n/* C program for Merge Sort */\n#include<stdlib.h>\n#include<stdio.h>\n#include <pthread.h>\n\n#define N 100\n\n// Merges two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nvoid merge(int arr[], int l, int m, int r)\n{\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 =  r - m;\n\n    /* create temp arrays */\n    int L[n1], R[n2];\n\n    /* Copy data to temp arrays L[] and R[] */\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1+ j];\n\n    /* Merge the temp arrays back into arr[l..r]*/\n    i = 0; // Initial index of first subarray\n    j = 0; // Initial index of second subarray\n    k = l; // Initial index of merged subarray\n    while (i < n1 && j < n2)\n    {\n        if (L[i] <= R[j])\n        {\n            arr[k] = L[i];\n            i++;\n        }\n        else\n        {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    /* Copy the remaining elements of L[], if there\n       are any */\n    while (i < n1)\n    {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    /* Copy the remaining elements of R[], if there\n       are any */\n    while (j < n2)\n    {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n/* l is for left index and r is right index of the\n   sub-array of arr to be sorted */\nvoid mergeSort(int arr[], int l, int r)\n{\n    if (l < r)\n    {\n        // Same as (l+r)/2, but avoids overflow for\n        // large l and h\n        int m = l+(r-l)/2;\n\n        // Sort first and second halves\n        mergeSort(arr, l, m);\n        mergeSort(arr, m+1, r);\n\n        merge(arr, l, m, r);\n    }\n}\n\n/* UTILITY FUNCTIONS */\n/* Function to print an array */\nvoid printArray(int A[], int size)\n{\n    int i;\n    for (i=0; i < size; i++)\n        printf(\"%d \", A[i]);\n    printf(\"\\n\");\n}\n\n/* Driver program to test above functions */\nint main()\n{\n    int min = -1000, max = 1000;\n    int arr[10], arr2[10], arr3[10];\n    int i,r;\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\n    int id1,id2;\n    //Threads init\n    pthread_t thread1 , thread2, thread3;\n    int ans1, ans2, ans3;\n\n\n    for( i = 0; i < arr_size; i++){\n        r = rand() % (max - min + 1);\n        arr[i] = r;\n        arr2[i] = r;\n        arr3[i] = r;\n    }\n    //printf(\"Before: \\n\");\n\n    if((id1 = fork()) == 0)\n    {\n        printf(\"Child1: \\n\");\n        mergeSort(arr2, 0, arr_size - 1);\n        printArray(arr2, arr_size);\n        execl(\"/bin/date\", \"date\",0);\n    }\n\n    if((id2 = fork()) == 0 && id1 != 0)\n    {\n        printf(\"Child2: \\n\");\n        ans1 = pthread_create ( &thread1 , NULL , mergeSort ,(arr3, (arr_size / 2) - 1 ,arr_size - 1 )) ;\n        ans2 = pthread_create ( &thread2 , NULL , mergeSort ,(arr3, 0, (arr_size / 2)-  1 )) ;\n        ans3 = pthread_create ( &thread3 , NULL , printArray ,(arr3, arr_size) ) ;\n        execl(\"/bin/date\", \"date\",0);\n        if ( ans1 != 0 || ans2 != 0 || ans3 != 0) {\n            printf ( \" \\n can't create threads \" ) ;\n            exit(0) ;\n        }\n            pthread_join ( thread1 , NULL ) ;\n            pthread_join ( thread2 , NULL ) ;\n            pthread_join ( thread3 , NULL ) ;\n\n    }\n    wait();\n    if(id1 != 0 && id2 != 0){\n\n        printf(\"Given array is \\n\");\n        printArray(arr, arr_size);\n        printf(\"Father:\\n\");\n        mergeSort(arr, 0, arr_size - 1);\n        printArray(arr, arr_size);\n        execl(\"/bin/date\", \"date\",0);\n        printf(\"\\nSorted array is \\n\");\n        //printf(\"After: \\n\");\n    }\n    return 0;\n}\n```\n\n\nEDITED CODE:\n\n```\n   /* C program for Merge Sort */\n#include<stdlib.h>\n#include<stdio.h>\n#include <pthread.h>\n#include <time.h>\n\n#define N 100\n\n// Merges two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nvoid merge(int arr[], int l, int m, int r)\n{\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 =  r - m;\n\n    /* create temp arrays */\n    int L[n1], R[n2];\n\n    /* Copy data to temp arrays L[] and R[] */\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1+ j];\n\n    /* Merge the temp arrays back into arr[l..r]*/\n    i = 0; // Initial index of first subarray\n    j = 0; // Initial index of second subarray\n    k = l; // Initial index of merged subarray\n    while (i < n1 && j < n2)\n    {\n        if (L[i] <= R[j])\n        {\n            arr[k] = L[i];\n            i++;\n        }\n        else\n        {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    /* Copy the remaining elements of L[], if there\n       are any */\n    while (i < n1)\n    {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    /* Copy the remaining elements of R[], if there\n       are any */\n    while (j < n2)\n    {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n/* l is for left index and r is right index of the\n   sub-array of arr to be sorted */\nvoid mergeSort(int arr[], int l, int r)\n{\n    if (l < r)\n    {\n        // Same as (l+r)/2, but avoids overflow for\n        // large l and h\n        int m = l+(r-l)/2;\n\n        // Sort first and second halves\n        mergeSort(arr, l, m);\n        mergeSort(arr, m+1, r);\n\n        merge(arr, l, m, r);\n    }\n}\n\nvoid* mergeSort2(void* args)\n{\n\n    int* newArgs = (int*)args;\n    int l = newArgs[1];\n    int r = newArgs[2];\n\n    pthread_t thread1 , thread2;\n    int ans1, ans2;\n\n    if (l < r)\n    {\n        // Same as (l+r)/2, but avoids overflow for\n        // large l and h\n        int m = (r+l)/2;\n        int newArgs1[3] = {newArgs[0], l, m};\n        int newArgs2[3] = {newArgs[0], m+1, r};\n        ans1 = pthread_create ( &thread1 , NULL , mergeSort2 ,(void*)newArgs1);\n        ans1 = pthread_create ( &thread2 , NULL , mergeSort2 ,(void*)newArgs2);\n        pthread_join(thread1,NULL);     \n        pthread_join(thread2,NULL);\n\n        merge(newArgs[0], l, m, r);\n\n    }\n\n}\n\n/* UTILITY FUNCTIONS */\n/* Function to print an array */\nvoid printArray(int A[], int size)\n{\n    int i;\n    for (i=0; i < size; i++)\n        printf(\"%d \", A[i]);\n    printf(\"\\n\");\n}\n\nstatic void print_timestamp(void)\n{\n    time_t now = time(0);\n    struct tm *utc = gmtime(&now);\n    char iso8601[32];\n    strftime(iso8601, sizeof(iso8601), \"%Y-%m-%d  %H:%M:%S\", utc);\n    printf(\"%s\\n\", iso8601);\n}\n\n/* Driver program to test above functions */\nint main()\n{\n    int min = -1000, max = 1000;\n    int arr[10], arr2[10], arr3[10];\n    int i,r;\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\n    int id1,id2;\n    int args[3] ={arr3, 0, arr_size - 1};\n     struct timeval tvalBefore, tvalAfter;\n     struct timeval tvalBefore1, tvalAfter1;\n    //Threads init\n    pthread_t thread1;\n    int ans1;\n\n    srand(time(NULL));\n\n    for( i = 0; i < arr_size; i++){\n        r = rand() % (max - min + 1);\n        arr[i] = r;\n        arr2[i] = r;\n        arr3[i] = r;\n    }\n    //printf(\"Before: \\n\");\n\n    if((id1 = fork()) == 0)\n    {\n     gettimeofday (&tvalBefore, NULL);\n    //Operation to do\n        printf(\"Child1: \\n\");\n        mergeSort(arr2, 0, arr_size - 1);\n        printArray(arr2, arr_size);\n        print_timestamp();\n    gettimeofday (&tvalAfter, NULL);\n\n    // Changed format to long int (%ld), changed time calculation\n\n    printf(\"Time in microseconds for sorting CHILD 1: %ld microseconds\\n\",\n            ((tvalAfter.tv_sec - tvalBefore.tv_sec)*1000000L\n           +tvalAfter.tv_usec) - tvalBefore.tv_usec\n          ); // Added semicolon\n    }\n\n    else if((id2 = fork()) == 0)\n    {\n\n        printf(\"Child2: \\n\");\n        //Start Timer\n        gettimeofday (&tvalBefore1, NULL);\n        //Operation to do\n        ans1 = pthread_create ( &thread1 , NULL , mergeSort2 ,(void*)args);\n        pthread_join ( thread1 , NULL ) ;\n\n        print_timestamp();\n        gettimeofday (&tvalAfter1, NULL);\n        // Changed format to long int (%ld), changed time calculation\n\n         printf(\"Time in microseconds for sorting CHILD 2: %ld microseconds\\n\",\n            ((tvalAfter1.tv_sec - tvalBefore1.tv_sec)*1000000L\n           +tvalAfter1.tv_usec) - tvalBefore1.tv_usec\n          ); // Added semicolon\n    }\n\n    else{\n        wait();\n        wait();\n         gettimeofday (&tvalBefore, NULL);\n        //Operation to do\n        printf(\"Given array is \\n\");\n        printArray(arr, arr_size);\n        printf(\"Father:\\n\");\n        mergeSort(arr, 0, arr_size - 1);\n        printArray(arr, arr_size);\n        print_timestamp();\n\n        gettimeofday (&tvalAfter, NULL);\n\n    // Changed format to long int (%ld), changed time calculation\n\n    printf(\"Time in microseconds for sorting Father: %ld microseconds\\n\",\n            ((tvalAfter.tv_sec - tvalBefore.tv_sec)*1000000L\n           +tvalAfter.tv_usec) - tvalBefore.tv_usec\n          ); // Added semicolon\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nYou have several problems:\n\n\nas noted in comments and Jonathan's answer, you call ```\nexec```\n and replace your whole process image before your threads complete (and possibly before they actually start, since they may not have been given their first timeslice yet)\nif you move that, you still have the problem that your ```\nprintArray```\n function was run in parallel to your sort threads, instead of afterwards\nif you fix that, you still have the problem that your ```\nprintArray```\n thread was started improperly (with a likely invalid input pointer), for the same reason as for the sorting threads, described in more detail below\nif you fix the printing, your sorting thread invocation is completely wrong (much detail follows below)\nif you fix the thread invocation, your code still doesn't do what you claim you wanted: to keep starting new child threads for smaller and smaller sub-ranges of your input array\n\n\nLet's start with the prototype of ```\npthread_create```\n, the declaration of your thread function, and the thread creation call:\n\n```\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                   void *(*start_routine) (void *), void *arg);\n```\n\n\nthis requires a function of shape ```\nvoid* start_routine(void *)```\n as its third argument. However, you have\n\n```\nvoid mergeSort(int arr[], int l, int r) { ... }\n```\n\n\nwhich will nevertheless be called with only the first argument having a defined value. I'm amazed your compiler didn't warn about this.\n\nNow, consider your the fourth argument to ```\npthread_create```\n in the following call:\n\n```\n    ans1 = pthread_create(&thread1, NULL,\n                          mergeSort,\n                          (arr3, (arr_size / 2) - 1 ,arr_size - 1 )) ;\n```\n\n\nit takes the expression ```\n(arr3, (arr_size / 2) - 1 ,arr_size - 1 )```\n. However, C doesn't have tuple types, and even if it did they wouldn't be convertible to ```\nvoid*```\n. Instead this uses the comma operator ```\n,```\n to discard the results of the first two expressions, and so you're actually using the integer value of ```\narr_size - 1```\n as a pointer argument.\n\nI'd expect it to crash when it tries to start the child thread - you didn't say how your program failed, but a SEGV would be common. You can catch these in a debugger, but it'll be somewhere inside the pthread library code, so it might not help much.\n\nA sane solution for your problem would look something like this un-tested and never-compiled sample code:\n\n```\n/* use this for the fourth argument to pthread_create */\nstruct Range {\n  int *array;\n  int left;\n  int right;\n  pthread_t thread;\n};\n\nvoid mergeSortRange(Range *r) {\n  const int width = (right - left);\n  const int mid = left + (width/2);\n  if (width > THRESHOLD) {\n    /* wide enough to be worth a child thread */\n    Range left = { r->array, r->left, mid };\n    Range right = { r->array, mid+1, r->right };\n    pthread_create(&left.thread, NULL,\n                   mergeSortRangeThreadFunction,\n                   &left);\n    mergeSortRange(&right);\n    pthread_join(left.thread);\n    mergeSortedHalved(r->array, r->left, mid, r->right);\n  } else {\n    regularSingleThreadedMergeSort(r->array, r->left, r->right);\n  }\n}\n\n/* this is what you pass to pthread_create */\nvoid* mergeSortRangeThreadFunction(void *data) {\n  Range *r = (Range *)data;\n  mergeSortRange(r);\n  return data;\n}\n```\n\n\nalthough, even with ```\nTHRESHOLD```\n set to something good, it's better to use a thread pool than to start & stop threads repeatedly.\n\nFinally, of course, you don't need to use recursion to start these threads and populate these ```\nRange```\n structures - you could just create an array of ```\nsize/THRESHOLD + 1```\n range descriptors, create one thread per core, and then figure out some logic for deciding when you're allowed to merge two consecutive ranges.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Multiple execution times in python Merge Sort Function\r\n                \r\nI wrote an algorithm for Merge Sort that sorts correctly but I'm sure how to get a single execution time using ```\ntime.time()```\n - Any advice would be very helpful!\n```\ndef merge_sort(data):\n\n    start_time = time.time()\n    \n    if len(data) <= 1:\n        return\n    \n    mid = len(data) // 2\n    left_data = data[:mid]\n    right_data = data[mid:]\n    \n    merge_sort(left_data)\n    merge_sort(right_data)\n    \n    left_index = 0\n    right_index = 0\n    data_index = 0\n    \n    while left_index < len(left_data) and right_index < len(right_data):\n        if left_data[left_index] < right_data[right_index]:\n            data[data_index] = left_data[left_index]\n            left_index += 1\n        else:\n            data[data_index] = right_data[right_index]\n            right_index += 1\n        data_index += 1\n    \n    if left_index < len(left_data):\n        del data[data_index:]\n        data += left_data[left_index:]\n        \n    elif right_index < len(right_data):\n        del data[data_index:]\n        data += right_data[right_index:]\n\n    \n    print('Merge Sort execution time: {}'.format(start_time - time.time()))\n    return data \n```\n\nOUTPUT:\n```\nMerge Sort execution time: 0.0\nMerge Sort execution time: 0.0\nMerge Sort execution time: -0.015623092651367188\nMerge Sort execution time: 0.0\nMerge Sort execution time: 0.0\nMerge Sort execution time: 0.0\nMerge Sort execution time: 0.0\nMerge Sort execution time: -0.046871185302734375\nMerge Sort execution time: 0.0\nMerge Sort execution time: 0.0\nMerge Sort execution time: 0.0\nMerge Sort execution time: -0.015625476837158203\nMerge Sort execution time: 0.0\nMerge Sort execution time: 0.0\nMerge Sort execution time: 0.0\nMerge Sort execution time: -0.015624284744262695\nMerge Sort execution time: -0.0312497615814209\nMerge Sort execution time: -0.07812094688415527\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Visualisation of merge sort java?\r\n                \r\nHello folks I would like to do the visualisation of merge sort algorithm in java. I've already written the program in java. Where should I exactly begin for the visualisation? Are there any predefined libraries for visualisation in java?\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort creates stack overflow\r\n                \r\nI cant understand why this merge sort is causing a stack overflow. Is it because I have no base case and if so, how would I go about adding it? The merge sort is pretty advance for a beginner like me :( so I would appreciate any help or advice.\nAdditionally, I am having trouble understanding where data is stored once you split the array recursively. I understand that splitting the original array breaks it down into individual elements, but where are these individual elements stored??\n\n```\nSub Main()\n    Dim Array() As Integer = {5, 4, 3, 1, 2, 6}\n    Dim right As Integer = Array.Length - 1 'find right index\n    Dim left As Integer = 0 'set left index\n    mergeSort(Array, left, right)\nEnd Sub\n\nSub mergeSort(Array, left, right)\n    Dim middle As Integer\n    If left < right Then\n        middle = (left + right) / 2\n\n        'recursively split both halves of the array\n        mergeSort(Array, left, middle)\n        mergeSort(Array, middle + 1, right)\n\n        'sort individual elements\n        mergeSortedArray(Array, left, middle, middle + 1, right)\n    End If\nEnd Sub\n\nSub mergeSortedArray(ByRef Array, left, middle, rbeg, right)\n    Dim pt As Integer = 0\n    Dim TempArray(6)\n\n    While (left <= middle) And (rbeg <= right) 'sort every element\n        If Array(left) < Array(rbeg) Then\n            TempArray(pt) = Array(left)\n            left += 1\n        Else\n            TempArray(pt) = Array(rbeg)\n            rbeg += 1\n        End If\n        pt += 1\n    End While\n\n    If left > middle Then\n        While rbeg <= right   'left sub array exhausted \n            TempArray(pt) = Array(rbeg)\n            rbeg += 1\n            pt += 1\n        End While\n    Else\n        While left <= middle   'right sub array exhausted \n            TempArray(pt) = Array(left)\n            left += 1\n            pt += 1\n        End While\n    End If\n\n    For Each element In TempArray\n        Console.WriteLine(element & \" \")\n    Next\nEnd Sub\n```\n\n    ", "Answer": "\r\nLots of problems with this code. A merge sort in VB would look more like this:\n\n```\nSub Main()\n    Dim Array() As Integer = {5, 33, 3, 10, 2} 'make the array\n\n    'Split Array: you need the leftmost index & rightmost index\n    Split(Array, 0, 4)\n    Console.ReadKey()\n\nEnd Sub\n\nSub Split(Array, left, right)\n    If left < right Then 'if the array has elements..\n        Dim middle As Integer = (left + right) \\ 2 'find halfway point \n\n        Split(Array, left, middle) 'split left array \n\n        Split(Array, middle + 1, right) 'split right array \n        'recursion keeps on splitting the two arrays until we have a bunch of single elements\n\n        'now sort and merge\n        Merge(Array, left, middle, right)\n    End If\nEnd Sub\nSub Merge(ByRef Array, left, middle, right)\n\n    Dim SizeA As Integer = middle - left + 1\n    Dim SizeB As Integer = right - middle\n    Dim LeftArray(SizeA) As Integer 'set size of left array.\n    Dim RightArray(SizeB) As Integer 'set size of right array\n\n    'Left & Right pointers to keep track of what elements in the array we are referring to\n    Dim LP As Integer\n    Dim RP As Integer\n\n    For LP = 0 To SizeA - 1\n        LeftArray(LP) = Array(left + LP) 'assign 0 index of original array to left hand array (5)\n    Next\n\n    For RP = 0 To SizeB - 1\n        RightArray(RP) = Array(middle + 1 + RP) 'assign 1 index of original array to right hand array (33)\n    Next\n\n    'reset pointers\n    LP = 0\n    RP = 0\n    Dim i = left 'set a pointer for the original array\n\n    'swap elements if need be:\n    While LP < SizeA And RP < SizeB\n        If LeftArray(LP) <= RightArray(RP) Then 'if element in left array is smaller that the one in the right\n            Array(i) = LeftArray(LP) 'assign the left value to the original array\n            LP += 1 ' increment the left array's pointer\n        Else\n            Array(i) = RightArray(RP) 'otherwise the original array gets the right element\n            RP += 1 'increment the right array's pointer\n        End If\n        i += 1 'now increment the counter for our new array\n    End While\n\n    'Hang on...what if there are still elements in the left array\n    While LP < SizeA\n        Array(i) = LeftArray(LP) 'assign these elements to the new array\n        LP += 1 'increment the left pointer\n        i += 1 'increment the new array's pointer\n    End While\n\n    'Hang on...what if there are still elements in the right array\n    While RP < SizeB\n        Array(i) = RightArray(RP) 'assign these elements to the new array\n        RP += 1 'increment the right pointer\n        i += 1 'increment the new array's pointer\n    End While\n\n    'write out the new array\n    For Each element In Array\n        Console.Write(element & \" \")\n    Next\n    Console.WriteLine(\"\")\n    'start the second pass\nEnd Sub\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in ArrayList in Java\r\n                \r\nI am learning how to implement basic algorithms in Java, so i am a newbie in this environment. I am trying to implement Merge Sort algorithm using ArrayList where program will read data (Integer in each line) from file and produce sorting result using Merge Sort. However, my code is showing same result as it has not sorted anything out! I would be very glad if someone can identify where did I do my mistake. As i am a beginner, the code is very simple, not optimized and not very fast in performance probably.\n\nHere is my code:\n\n```\npublic class MergeSortExp1 {\n\n    public static void main(String[] args) {\n\n        ArrayList<Integer>number = new ArrayList<Integer>();\n\n        Scanner myScanner = null;\n        try {\n        myScanner = new Scanner(new File(\"/Users/Sabbir/Desktop/workload.txt\"));\n        } catch (FileNotFoundException e) {\n\n        e.printStackTrace();\n        }\n\n        while(myScanner.hasNextInt()){\n            number.add(myScanner.nextInt());\n        }\n\n        System.out.println(\"Before sorting\" +number);\n        number=mergeSort(number);\n        System.out.println(\"Sorted Array =\" +number);\n    }\n\n        public static ArrayList<Integer> mergeSort( ArrayList<Integer> Input)\n        {\n            if (Input.size() ==1){\n                return Input;\n            }\n            else {\n                int mid= Input.size()/2;\n                ArrayList<Integer> left= new ArrayList<Integer>(mid);\n                ArrayList<Integer> right=new ArrayList<Integer>(Input.size()-mid);\n\n               for (int i = 0; i < mid; i++) {\n                   left.add(Input.get(i));\n                   } \n\n               for (int i = 0; i < Input.size()-mid; i++) {\n                   right.add(Input.get(i));\n               } \n\n               left=mergeSort(left); \n               right=mergeSort(right);\n               merge(left,right,Input);\n            }\n               return Input;\n        }\n\n\n        public static void merge (ArrayList<Integer>left,ArrayList<Integer>right,ArrayList<Integer>Input)\n        {\n            int i1=0;// left Index\n            int i2=0;// right Index\n            int InputIndex=0;\n\n            for (int i = 0; i < Input.size(); i++) {\n                if (i2>=right.size() || (i1<left.size() && left.get(i)<=right.get(i))) \n                {\n                    Input.set(InputIndex,left.get(i1));\n                    InputIndex++;\n                }\n                else {\n                    Input.set(InputIndex, right.get(i2));\n                    InputIndex++;\n                }\n            }\n\n        }\n}\n```\n\n    ", "Answer": "\r\nIf your merge method is Ok (I don't test it), you forget to merge left and right to input, edit your code as shown below and re-try:\n\n```\n // This is called recursion. Calling a method again within the  \n //method until the value of left and right becomes 1.\n left=mergeSort(left); \n right=mergeSort(right);\n\n merge(left,right,Input);\n```\n\n\nhope helped you!\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Debugging a merge sort implementation in c\r\n                \r\nI am debugging a c implementation of merge sort. For some reason, the value of ```\nr```\n (in merge) is ```\nnan```\n. Yet, ```\nn2```\n (defined as ```\n(int) (r - q)```\n) is well defined. Why is ```\nr == nan```\n ?\n\n```\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\nvoid merge(int *A,float p,float q,float r)\n{\n    float n = r - p + 1; /* number of elements in array A */\n    int n1 = (int) (q - p + 1);\n    int n2 = (int) (r - q);\n    printf(\"n2 = %d\\n\",n2);\n    int  i, j;\n    float k;\n\n    int *L, *R;\n    for (i = 1; i <= n1; i++){\n        L[i] = A[(int) (p + i - 1)];\n    }\n\n    for (j = 1; j < n2; j++){\n        R[j] = A[(int) (q + j)];\n    }\n\n    L[n1+1] = INT_MAX;\n    R[n2+1] = INT_MAX;\n\n    i = 1;\n    j = 1;\n\n    printf(\"p = %f\\n\",p);\n    printf(\"r = %f\\n\",r);\n\n    for (k = p; k <= r; k++){\n        printf(\"k=%f\\n\",k);\n        if (L[i] <= R[j]){\n            A[(int) k] = L[i];\n            i += 1;\n        }\n\n        else{\n            A[(int) k] = R[j];\n            j += 1;\n        }\n    }\n}\n\nvoid merge_sort(int *A, float p, float r)\n{\n    int i;\n/*  for (i=0; i<=r-p;i++){\n        printf(\"%d\\n\",A[i]);\n    }*/\n    float q;\n    if (p < r){\n    /*  printf(\"merge_sort p = %d\\n\",p);\n        printf(\"merge_sort r = %d\\n\",r);*/\n        q = floor((p + r)/2);\n/*      printf(\"q = %f\\n\",q);*/\n        merge_sort(A, p, q);\n        merge_sort(A, q+1, r);\n/*      printf(\"done\\n\");*/\n        merge(A, p, q, r);\n    }\n}\n\n\nint main()\n{\n    int x, c, *array;\n    int n;\n\n    printf(\"Enter number of elements\\n\");\n    scanf(\"%d\",&n);\n\n    printf(\"Enter %d elements\\n\",n);\n\n    for (c = 0; c < n; c++){\n        scanf(\"%d\", &array[c]);\n    }\n\n    merge_sort(array, 0, n-1);\n\n    for (c = 0; c < n; c++){\n        printf(\"%d\\n\", array[c]);\n    }\n}\n```\n\n    ", "Answer": "\r\n```\nint *L, *R;\nfor (i = 1; i <= n1; i++){\n    L[i] = A[(int) (p + i - 1)];\n}\n```\n\n\n```\nL```\n and ```\nR```\n are used uninitialized\n\nSame for ```\narray```\n:\n\n```\n   int x, c, *array;\n\n   ...\n\n   for (c = 0; c < n; c++){\n       scanf(\"%d\", &array[c]);\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge Sort C++\r\n                \r\nI want to write a recursive merge sort program in C++. The problem is, I don't know how to get the base case idea working recursively. Can anybody please tell me what would be the base case for ```\nMerg Function()```\n, ```\nSplit Function()```\n and ```\nMergSort()```\n function. I would be thankful to you.  \n\n```\nvoid Merg(int A[], int s1, int e1, int s2, int e2)\n{\n   int B[8];\n   int i=0;\n\n   while (A[s1] < A[s2])\n      B[i] = B[s1];\n      i++;\n      s1++;\n\n      if (s1 == e1)\n      {\n         B[i] = A[s2];\n         i++;\n         s2++;\n      }\n\n   while (A[s2] < A[s1])\n      B[i] = B[s2];\n      i++;\n      s2++;\n\n      if (s2 == e2)\n      {\n         B[i] = A[s1];\n         i++;\n         s1++;\n      }\n}\n\nvoid Split(int A[], int s, int e)\n{\n   int mid = (s+e)/2;\n\n   if (s < e && mid != 0)\n   {   \n      Split(A, s, mid);\n      Split(A, mid+1, e);   \n   }\n   Merg(A, s, mid, mid+1, e);\n}\n\nint main()\n{\n   int A[8] = {10,4,8,12,11,2,7,5};\n\n   Split(A, 0, 7);\n\n   return 0;\n}\n```\n\n    ", "Answer": "\r\nThe base case is an array that is guaranteed to be sorted, so either an empty array or an array of length 1.\n\nYour merge function is not correct, but at least contains most of the right ideas. All you need there is a further wrapping loop and a few conditions to prevent your merge running past the end of the arrays. The split function is totally off, splitting is not recursive, further splits happen inside the recursive ```\nmergeSort```\n calls.\n\n\nif length(A) < 2 return // already sorted\nsplit A in lower half L and upper half H\nmerge-sort L\nmerge-sort H\nmerge the sorted L and H\ndone\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Complexity Confusion\r\n                \r\nCan someone explain to me in plain english how Merge Sort is O(n*logn). I know that the 'n' comes from the fact that it takes n appends to merge two sorted lists of size n/2. What confuses me is the log. If we were to draw a tree of the function calls of running Merge Sort on a 32 element list, then it would have 5 levels. Log2(32)= 5. That makes sense, however, why do we use the levels of the tree, rather than the actual function calls and merges in the Big O definition ?\nIn this diagram we can see that for an 8 element list, there are 3 levels. In this context, Big O is trying to find how the number of operations behaves as the input increases, my question is how are the levels (of function calls) considered operations? \n    ", "Answer": "\r\nThe levels of function calls are considered like this(in the book [introduction to algorithms](https://mitpress.mit.edu/books/introduction-algorithms Chapter 2.3.2):\n\nWe reason as follows to set up the recurrence for T(n), the worst-case running time of merge sort on n numbers. Merge sort on just one element takes constant time. When we have n > 1 elements, we break down the running time as follows.\nDivide: The divide step just computes the middle of the subarray, which takes constant time. Thus, D(n) =  Θ(1).\nConquer: We recursively solve two subproblems, each of size n/2, which contributes 2T(n/2) to the running time.\nCombine: We have already noted that the MERGE procedure on an n-element subarray takes time  Θ(n), and so C(n) = Θ(n).\nWhen we add the functions D(n) and C(n) for the merge sort analysis, we are adding a function that is Θ(n) and a function that is Θ(1). This sum is a linear function of n, that is, Θ(n). Adding it to the 2T(n/2) term from the “conquer” step gives the recurrence for the worst-case running time T(n) of merge sort:\nT(n) = Θ(1), if n = 1; T(n) = 2T(n/2) + Θ(n), if n > 1.\n\nThen using the recursion tree or the master theorem, we can calculate:\nT(n) = Θ(nlgn).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort recursions\r\n                \r\nI have a problem. I started to learn how merge sort works, and now I'm stuck.\nI don't understand second recursion in merge function. \n\n```\nint merge_sort(int input[], int p, int r)\n{\n      if ( p >= r ) return 0; \n\n        int mid = floor((p + r) / 2);\n        merge_sort(input, p, mid);\n        **merge_sort(input, mid + 1, r);** \n        merge(input, p, r);\n}\n```\n\n\nWhen first recursion is finished, I end up with something like this:\nOriginal array: 3 4 5 6 7 8\n\n3 4 5 | 6 7 8 \n\n3 4 | 5\n\n3 | 4\n\n3\n\nAnd then second recursion starts.\nSo, my question is: does second recursion starts from array with only one element ( array with only one number, 3 in this case) or from original array ( 6 element array from beginning)?\nI hope you will understand what I mean. Thanks.\n    ", "Answer": "\r\ni can't tell from your code because you are always passing the input array. But yes the idea is to divide and conquer so the first call should be with\n\nmerge_sort: 3 4 5 6 7 8 \n\nfirst recursion: 3 4 5\n\nsecond recursion: 6 7 8\n\nTake a look at this wikipedia picture: http://en.wikipedia.org/wiki/File:Merge_sort_algorithm_diagram.svg\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Runtime comparison between merge sort, insertion sort and recursive insertion sort in python\r\n                \r\n```\ndef merge_sort(unorderedList):\n    if len(unorderedList) > 1:\n        mid = len(unorderedList) // 2 \n        left = unorderedList[:mid]\n        right = unorderedList[mid:]\n        merge_sort(left)\n        merge_sort(right)\n        i = 0\n        j = 0\n        k = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                unorderedList[k] = left[i]\n                i += 1\n            else:\n                unorderedList[k] = right[j]\n                j += 1\n            k += 1\n        while i < len(left):\n            unorderedList[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            unorderedList[k] = right[j]\n            j += 1\n            k += 1\n```\n\n```\ndef insertion_sort(list1):\n    for i in range(1, len(list1)):\n        key = list1[i]\n        j = i - 1 \n        while j >= 0 and list1[j] > key:\n            list1[j + 1] = list1[j]\n            j -= 1\n        list1[j + 1] = key\n```\n\n```\ndef recursive_insertion_sort(arr, n):\n    if n <= 1:\n        return\n\n    recursive_insertion_sort(arr, n-1)\n    last = arr[n-1]\n    j = n-2\n     \n    while j >= 0 and arr[j] > last:\n        arr[j + 1] = arr[j]\n        j -= 1\n \n    arr[j + 1] = last\n```\n\n```\nimport time\nimport random\nt0 = time.time()\ninsertion_sort([random.randint(-10000, 10000) for i in range(50000)])\nt1 = time.time()\nrecursive_insertion_sort([random.randint(-10000, 10000) for i in range(50000)])\nt2 = time.time()\nmerge_sort([random.randint(-10000, 10000) for i in range(50000)])\nt3 = time.time()\n\nprint(\"insertion sort timer : \", t1 - t0)\nprint(\"recursive insertion sort timer : \", t2 - t1)\nprint(\"merge sort timer : \", t3 - t2)\n\n```\n\nI used these three functions to compare their runtimes on a 50 thousand membered random list\nAnd i got these times with python 3.10 in vscode\ninsertion sort timer : 78.13s\nrecursive insertion sort timer : 0.068s\nmerge sort timer : 0.209s\nIs this correct? And if so, can you explain it please?\nConsidering merge sort has an order of O(nlogn) and insertion sorts order is O(n^2), how is this happening?\nEDIT: added the code and method used for time testing.\n    ", "Answer": "\r\nSince these functions are performing an \"inplace\" sort, I suspect that your metrics were not starting from the same original list.\nFor example, if you test merge_sort first on list ```\nA```\n and then test insertion_sort on ```\nA```\n, that second sort gets an already sorted list which that algorithm should benefit from.  This is likely what happened between the \"insertion sort\" measurement and the \"recursive insertion sort\" measurement.\nTheoretically, recursive_insertion_sort function shouldn't be able to sort any list with more than 990 items. So, I'm guessing you changed the maximum recursion depth limit (if you didn't then something else is wrong in the experiment)\nIf you test each sort independently (or on copies of the original list), you should get very different results.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort algorithm not working correctly\r\n                \r\nAs part of a homework assignment, I need to be able to implement a merge sort using a structure as the main argument. Having not been familiar with the merge sort until today, i have attempted to write my own implementation of it. For some reason I cannot get it to work.\n\nHere is my code:\n\n```\n#include<iostream>\n#include<stdlib.h>\n\nusing namespace std;\n\nstruct MergeArgument\n{\n    int *numArray;\n    int *tempArray;\n    int lowIndex, highIndex;\n};\n\nvoid merge(MergeArgument*);\nvoid merge_sort(MergeArgument*);\n\nint main(int argc, char** argv)\n{   int SIZE = 25;\n    MergeArgument arg;\n    int arr[SIZE];\n    int temp[SIZE];\n\n    for(int k = 0; k < SIZE; k++)\n    {\n        arr[k] = rand() % 100;\n        cout << arr[k] << \" \";\n    }\n\n    arg.numArray = arr;\n    arg.tempArray = temp;\n    arg.lowIndex = 0;\n    arg.highIndex = SIZE - 1;\n\n    cout << endl;\n\n    merge_sort(&arg);\n\n    cout << \"Sorted array: \\n\";\n\n    for (int i = 0; i < SIZE; i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n\n    return 0;\n}\n\nvoid merge_sort(MergeArgument *arg)\n{   int tempHigh, tempLow;\n    if(arg->lowIndex < arg->highIndex)\n    {\n        tempHigh = arg->highIndex;\n        tempLow = arg->lowIndex;\n        arg->highIndex = (tempHigh + tempLow) / 2;\n        merge_sort(arg);\n        arg->highIndex = tempHigh;\n        arg->lowIndex = ((tempHigh + tempLow) / 2) + 1;\n        merge_sort(arg);\n        arg->lowIndex = tempLow;\n        merge(arg);\n    }\n\n}\n\nvoid merge(MergeArgument *arg)\n{   int low = arg->lowIndex, mid = ((arg->lowIndex + arg->highIndex) / 2), high = arg->highIndex;\n    int i = low, lowCounter = low, highCounter = mid + 1;\n\n    while((lowCounter <= mid) && (highCounter <= high))\n    {\n        if(arg->numArray[lowCounter] < arg->numArray[highCounter])\n        {\n            arg->tempArray[i] = arg->numArray[lowCounter];\n            lowCounter++;\n        }\n        else\n        {\n            arg->tempArray[i] = arg->numArray[highCounter];\n            highCounter++;\n        }\n        i++;\n    }\n\n    if (lowCounter < mid)\n    {\n        for (int k = lowCounter; k < mid; k++)\n        {\n            arg->tempArray[i] = arg->numArray[k];\n            i++;\n        }\n    }\n    else\n    {\n        for (int k = highCounter; k <= arg->highIndex; k++)\n        {\n            arg->tempArray[i] = arg->numArray[k];\n            i++;\n        }\n\n    }\n\n    for(int k = arg->lowIndex; k <= arg->highIndex; k++)\n    {\n        arg->numArray[k] = arg->tempArray[k];\n    }\n}\n```\n\n\nHere is the output I am getting:\n\n```\n83 86 77 15 93 35 86 92 49 21 62 27 90 59 63 26 40 26 72 36 11 68 67 29 82    \nSorted array:  \n11 -1216235240 15 0 21 26 -1079135248 26 27 -1079135396 29 -1216770650 35 -1216235240 49 -1216492084 59 0 68 72 82 83 0 86 82\n```\n\n\nCan anyone point out what exactly I am doing wrong?\n    ", "Answer": "\r\nThis is pretty close to working, although you might want to consider some of the comments folks have made on making this more C++ like.  No doubt this is from hard-won experience that there is never enough time to go back and do what you really should do.\n\nThe problem I see is here, in ```\nmerge```\n:\n\n```\nif (lowCounter < mid)\n{\n    for (int k = lowCounter; k < mid; k++)\n    {\n        arg->tempArray[i] = arg->numArray[k];\n        i++;\n    }\n}\n```\n\n\nYou might want to compare and contrast the bounds here to the initial loop.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementing Merge Sort in Python\r\n                \r\nI'm trying to implement simple merge sort algorithm in Python.\n\n```\narr=[1,3,5,2,4,6]\nn=6\nl=0\nh=n-1\n\ndef merge_Sort(l,h):\n    if(l==h):\n        return arr[l]\n\n    m=(h+l)//2\n    arr1=merge_Sort(l,m)\n    arr2=merge_Sort(m+1,h)\n\n    s1=m-l\n    s2=h-(m+1)\n    mer=[]\n    k1=k2=0\n\n    while(k1<=s1 or k2<=s2):\n        if(arr1[k1] < arr2[k2]):\n            mer.append(arr1[k1])\n            k1+=1\n        else:\n            mer.append(arr2[k2])\n            k2+=1\n\n    if(k1>s1):\n        while(k2<=s2):\n            mer.append(arr2[k2])\n            k2+=1\n\n    if(k2>s2):\n        while(k1<=s1):\n            mer.append(arr1[k1])\n            k1+=1    \n\n    return mer\n\nres=merge_Sort(l,h)\n\nprint(res)\n```\n\n\nBut I'm getting this error message when running the above code:\n\n\n  TypeError: 'int' object is not subscriptable\n\n\nCan anybody explain to me why I'm geting this error?\n    ", "Answer": "\r\nThe problems are here:\n\n```\n    if(l==h):\n        return arr[l]\n    ...\n    while(k1<=s1 or k2<=s2):\n```\n\n\nUse this code instead:\n\n```\n    if(l==h):\n        return arr[l:l+1]\n    ...\n    while(k1<=s1 and k2<=s2):\n```\n\n\n\n\nSide note, this piece of code:\n\n```\n    if(k1>s1):\n        while(k2<=s2):\n            mer.append(arr2[k2])\n            k2+=1\n\n    if(k2>s2):\n        while(k1<=s1):\n            mer.append(arr1[k1])\n            k1+=1\n```\n\n\ncan be simplified to this:\n\n```\n    mer.extend(arr1[k1:s1+1])\n    mer.extend(arr2[k2:s2+1])\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "whats wrong with my below merge sort code in python?\r\n                \r\nmerge sort\nit is showing error i cant able to figure out please help in merge sort,, It is showing out of index but i cant figure it out how please could anyone update and please help me?\n```\ndef mergesort(a,low,high):\n    if(low<high):\n        mid=(high+low)//2\n        mergesort(a,low,mid)\n        mergesort(a,mid+1,high)\n        merge(a,low,mid,high)\ndef merge(a,low,mid,high):\n    i=low\n    j=mid+1\n    while(i<=mid and j<=high):\n        if(a[i]<=a[j]):\n            print(a[i])\n            c.append(a[i])\n            i+=1\n        else:\n            c.append(a[j])\n            j+=1\na=[4,2,7,0,9,6,5]\nc=[]\nmergesort(a,0,len(a))\nprint(c)\n    \n```\n\n```\nmy merge sort algo not working ```\n\n    ", "Answer": "\r\nAfter you fix the indexing, there are other problems.  \"Mergesort\" is supposed to do a sort in place, modifying the original list.  You're not doing that; you're trying to build up a new list.  That means you need to RETURN the list you've created, and use that in the next pass.\nThen, ```\nc```\n cannot be a global.  It's local to the \"merge\" function, so each call has it's own copy.  Finally, each merge step only processed part of the list.  You have to copy over the parts you aren't changing.  This seems to work:\n```\ndef mergesort(a,low,high):\n    if low<high:\n        mid=(high+low)//2\n        a = mergesort(a,low,mid)\n        a = mergesort(a,mid+1,high)\n        a = merge(a,low,mid,high)\n    return a\ndef merge(a,low,mid,high):\n    c = a[:low]\n    i=low\n    j=mid+1\n    while i<=mid and j<=high:\n        if a[i]<=a[j]:\n            print(a[i])\n            c.append(a[i])\n            i+=1\n        else:\n            print(a[i])\n            c.append(a[j])\n            j+=1\n    c.extend( a[i:mid+1] )\n    c.extend( a[j:] )\n    return c\n\na=[4,2,7,0,9,6,5]\nc = mergesort(a,0,len(a)-1)\nprint(c)\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sorting a 2d array\r\n                \r\nI'm stuck again on trying to make this merge sort work. \nCurrently, I have a 2d array with a Unix timecode(fig 1) and merge sorting using (fig 2) I am trying to check the first value in each array i.e array[x][0] and then move the whole array depending on array[x][0] value, however, the merge sort creates duplicates of data and deletes other data  (fig 3) my question is what am I doing wrong? I know it's the merge sort but cant see the fix. \n\nfig 1\n\n```\n[[1422403200        100]\n [1462834800        150]\n [1458000000         25]\n [1540681200        150]\n [1498863600        300]\n [1540771200        100]\n [1540771200        100]\n [1540771200        100]\n [1540771200        100]\n [1540771200        100]]\n```\n\n\nfig 2\n\n```\nimport numpy as np\n\n\ndef sort(data):\n    if len(data) > 1:\n        Mid = len(data) // 2\n        l = data[:Mid]\n        r = data[Mid:]\n        sort(l)\n        sort(r)\n\n        z = 0\n        x = 0\n        c = 0\n\n        while z < len(l) and x < len(r):\n            if l[z][0] < r[x][0]:\n                data[c] = l[z]\n                z += 1\n            else:\n                data[c] = r[x]\n                x += 1\n            c += 1\n\n        while z < len(l):\n            data[c] = l[z]\n            z += 1\n            c += 1\n\n        while x < len(r):\n            data[c] = r[x]\n            x += 1\n            c += 1\n        print(data, 'done')\nunixdate = [1422403200, 1462834800, 1458000000, 1540681200, 1498863600, 1540771200, 1540771200,1540771200, 1540771200, 1540771200]\nprice=[100, 150, 25, 150, 300, 100, 100, 100, 100, 100]\narray = np.column_stack((unixdate, price))\nsort(array)\nprint(array, 'sorted')\n```\n\n\nfig 3 \n\n```\n[[1422403200        100]\n [1458000000         25]\n [1458000000         25]\n [1498863600        300]\n [1498863600        300]\n [1540771200        100]\n [1540771200        100]\n [1540771200        100]\n [1540771200        100]\n [1540771200        100]] \n```\n\n    ", "Answer": "\r\nI couldn't spot any mistake in your code.\n\nI have tried your code and I can tell that the problem does not happen, at least with regular Python lists: The function doesn't change the number of occurrence of any element in the list.\n\n```\ndata = [\n [1422403200, 100],\n [1462834800, 150],\n [1458000000,  25],\n [1540681200, 150],\n [1498863600, 300],\n [1540771200, 100],\n [1540771200, 100],\n [1540771200, 100],\n [1540771200, 100],\n [1540771200, 100],\n]\n\nsort(data)\n\nfrom pprint import pprint\npprint(data)\n```\n\n\nOutput:\n\n```\n[[1422403200, 100],\n [1458000000, 25],\n [1462834800, 150],\n [1498863600, 300],\n [1540681200, 150],\n [1540771200, 100],\n [1540771200, 100],\n [1540771200, 100],\n [1540771200, 100],\n [1540771200, 100]]\n```\n\n\n\n\nEdit, taking into account the numpy context and the use of ```\nnp.column_stack```\n.\n\n-I expect what happens there is that ```\nnp.column_stack```\n actually creates a view mapping over the two arrays. To get a real array rather than a link to your existing arrays, you should copy that array:-\n\n```\narray = np.column_stack((unixdate, price)).copy()\n```\n\n\n\n\n\n\nEdit 2, taking into account the numpy context\n\nThis behavior has actually nothing to do with ```\nnp.column_stack```\n; ```\nnp.column_stack```\n already performs a copy.\n\nThe reason your code doesn't work is because slicing behaves differently with numpy than with python. Slicing create a view of the array which maps indexes.\n\nThe erroneous lines are:\n\n```\nl = data[:Mid]\nr = data[Mid:]\n```\n\n\nSince ```\nl```\n and ```\nr```\n just map to two pieces of the memory held by ```\ndata```\n, they are modified when ```\ndata```\n is. This is why the lines ```\ndata[c] = l[z]```\n and ```\ndata[c] = r[x]```\n overwrite values and create copies when moving values.\n\nIf ```\ndata```\n is a numpy array, we want ```\nl```\n and ```\nr```\n to be copies of data, not just views. This can be achieved using the ```\ncopy```\n method.\n\n```\nl = data[:Mid]\nr = data[Mid:]\nif isinstance(data, np.ndarray):\n    l = l.copy()\n    r = r.copy()\n```\n\n\nThis way, I tested, the copy works.\n\n\n\nNote\n\nIf you wanted to sort the data using python lists rather than numpy arrays, the equivalent of np.column_stack in vanilla python is ```\nzip```\n:\n\n```\nz = zip([10, 20, 30, 40], [100, 200, 300, 400], [1000, 2000, 3000, 4000])\nz\n# <zip at 0x7f6ef80ce8c8>\n# `zip` creates an iterator, which is ready to give us our entries.\n# Iterators can only be walked once, which is not the case of lists.\n\nlist(z)\n# [(10, 100, 1000), (20, 200, 2000), (30, 300, 3000), (40, 400, 4000)]\n```\n\n\nThe entries are (non-mutable) tuples. If you need the entries to be editable, map list on them:\n\n```\nz = zip([10, 20, 30, 40], [100, 200, 300, 400], [1000, 2000, 3000, 4000])\nli = list(map(list, z))\n# [[10, 100, 1000], [20, 200, 2000], [30, 300, 3000], [40, 400, 4000]]\n```\n\n\nTo transpose a matrix, use ```\nzip(*matrix)```\n:\n\n```\ndef transpose(matrix):\n    return list(map(list, zip(*matrix)))\n\ntranspose(l)\n# [[10, 20, 30, 40], [100, 200, 300, 400], [1000, 2000, 3000, 4000]]\n```\n\n\nYou can also sort a python list ```\nli```\n using ```\nli.sort()```\n, or sort any iterator (lists are iterators), using ```\nsorted(li)```\n.\n\nHere, I would use (tested):\n\n```\nsorted(zip(unixdate, price))\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "printing time taken for merge sort\r\n                \r\ni'm tryin' to print the time taken for a merge sort on an array of random numbers generated by the computer, whose size should be taken from the user during runtime, but it's givin' a segmentation fault. can anyone help correct my mistake?\n\n```\npart(int arr[],int min,int max)\n{\n int mid;\n if(min<max)\n {\n   mid=(min+max)/2;\n   part(arr,min,mid);\n   part(arr,mid+1,max);\n   merge(arr,min,mid,max);\n }\n}\n\n\nmerge(int arr[],int min,int mid,int max)\n{\n  int tmp[30];\n  int i,j,k,m; \n  j=min;\n  m=mid+1;\n  for(i=min; j<=mid && m<=max ; i++)\n  {\n     if(arr[j]<=arr[m])\n     {\n         tmp[i]=arr[j];\n         j++;\n     }\n     else\n     {\n         tmp[i]=arr[m];\n         m++;\n     }\n  }\n  if(j>mid)\n  {\n     for(k=m; k<=max; k++)\n     {\n         tmp[i]=arr[k];\n         i++;\n     }\n  }\n  else\n  {\n     for(k=j; k<=mid; k++)\n     {\n        tmp[i]=arr[k];\n        i++;\n     }\n  }\n  for(k=min; k<=max; k++)\n     arr[k]=tmp[k];\n}\n\nmain(){\nint x, *b, i;\ndouble t5;\nprintf(\"array size = \\t\");\nscanf(\"%d\", &x);\nb = (int)malloc(x*sizeof(int));\nsrand(time(NULL));\nfor(i = 0; i<x; i++)    b[i] = rand();\ntime_t t1 = 0;\ntime_t t2 = 0;\nt1 = time(NULL);\npart(b, 0, (x-1));\nt2 = time(NULL);\nprintf(\"time taken for merge sort = %f sec\\n\", (t1 - t2));\n}\n```\n\n    ", "Answer": "\r\nThere are several issues with the code here:\n\n\nAll relevant prototypes to system functions are missing, Fix this by including the necessary headers.\nThe prototype for ```\nmerge()```\n is missing, as needed by ```\npart()```\n. Add it.\nFunctions not returning anything shall be typed as ```\nvoid```\n. Declare them alike.\nThere is no need to cast the result of ```\nmalloc()```\n. And if it is done it should be done to the correct type: ```\nint *```\n here not ```\nint```\n!\n```\ntime_t```\n is an integer in most of the cases, so if it is don't use the conversion specifier for ```\ndouble```\n when trying to print ```\ntime_t```\n, but the correct integer conversion specifier that is ```\nd```\n for 32bit wide time_t or ```\nld```\n for 64bit wide  ```\ntime_t```\n. However to print difference of ```\ntime_t```\ns use ```\ndifftime()```\n, which actually results in a ```\ndouble```\n. \nLast not least the temporary buffer in ```\nmerge()```\n doesn't scale. Make it ```\nmax+1```\n elements wide.\n\n\n\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid merge(int arr[], int min, int mid, int max);\nvoid part(int arr[], int min, int max);\n\nvoid part(int arr[], int min, int max)\n{\n  int mid;\n  if (min < max)\n  {\n    mid = (min + max) / 2;\n    part(arr, min, mid);\n    part(arr, mid + 1, max);\n    merge(arr, min, mid, max);\n  }\n}\n\nvoid merge(int arr[], int min, int mid, int max)\n{\n  int tmp[max + 1];\n  int i, j, k, m;\n  j = min;\n  m = mid + 1;\n  for (i = min; j <= mid && m <= max; i++)\n  {\n    if (arr[j] <= arr[m])\n    {\n      tmp[i] = arr[j];\n      j++;\n    }\n    else\n    {\n      tmp[i] = arr[m];\n      m++;\n    }\n  }\n  if (j > mid)\n  {\n    for (k = m; k <= max; k++)\n    {\n      tmp[i] = arr[k];\n      i++;\n    }\n  }\n  else\n  {\n    for (k = j; k <= mid; k++)\n    {\n      tmp[i] = arr[k];\n      i++;\n    }\n  }\n  for (k = min; k <= max; k++)\n    arr[k] = tmp[k];\n}\n\nint main(void)\n{\n  int x, *b, i;\n\n  printf(\"array size = \\t\");\n  scanf(\"%d\", &x);\n\n  b = malloc(x * sizeof(int));\n\n  srand(time(NULL ));\n  for (i = 0; i < x; i++)\n    b[i] = rand();\n\n  time_t t1 = 0;\n  time_t t2 = 0;\n\n  t1 = time(NULL);\n  part(b, 0, x - 1);\n  t2 = time(NULL);\n\n  printf(\"time taken for merge sort = %f sec\\n\", difftime(t2, t1));\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Improving merge sort\r\n                \r\nI am practicing merge sort and am curious if my second version is better than the first -- it seems to be in terms of memory requirement since I am popping from a list instead of just moving indices\n\nVersion 1:\n\n```\ndef mergesort(L):\n    if len(L)<=1: return L\n    pivot=len(L)/2\n    left=mergesort(L[:pivot])\n    right=mergesort(L[pivot:])\n    i=j=0\n    sortedArr=[]\n    while i<len(left) and j<len(right):\n        if left[i]<right[j]:\n            sortedArr.append(left[i])\n            i+=1\n        else:\n            sortedArr.append(right[j])\n            j+=1\n    return sortedArr + left[i:] + right[j:]\n```\n\n\nVersion 2\n\n```\ndef mergesort(L):\n    if len(L)<=1: return L\n    pivot=len(L)/2\n    left=mergesort(L[:pivot])\n    right=mergesort(L[pivot:])\n    sortedArr=[]\n    while left!=[] and right!=[]:\n        if left[0]<right[0]:\n            sortedArr.append(left.pop(0))\n        else:\n            sortedArr.append(right.pop(0))\n    return sortedArr + left + right\n```\n\n\nWithout getting into parallelizing, is there any way to further improve upon Version 2, assuming it is superior to Version 1? How would I describe the memory requirements of these two versions so far?\n    ", "Answer": "\r\nwhy not using a deque from collections ? It would lower the cost of the popleft() operation ?\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Record execution of a merge sort\r\n                \r\nI have a merge sort implemented in Python ...\n\n```\ndef mergesort(z):\n    if len(z) > 1:\n        mid = len(z)//2\n        leftPortion = z[:mid]\n        rightPortion = z[mid:]\n        mergesort(leftPortion)\n        mergesort(rightPortion)\n        l = 0 # Next position in rightPortion\n        r = 0 # Next position in leftPortion\n        i = 0 # Next position in z\n        while l < len(leftPortion) and r < len(rightPortion):\n            if leftPortion[l] <= rightPortion[r]:\n                z[i] = leftPortion[l]\n                l = l + 1 \n            else:\n                z[i] = rightPortion[r]\n                r = r + 1\n            i = i + 1 \n        while l < len(leftPortion):\n            z[i] = leftPortion[l]\n            l = l + 1\n            i = i + 1\n        while r < len(rightPortion):\n            z[i] = rightPortion[r]\n            r = r + 1\n            i = i + 1\n```\n\n\n... and I want to 'record' the state of the original list, z, as the sort executes so I can use Matplotlib to graph an animation of the sort. I have implemented this method for a Bubble sort and for an Insertion sort but can't figure out how to do it because of the recursion in the merge. Can anyone help please?\n\nThis is the way I did it with Bubble Sort ...\n\n```\nimport matplotlib.pyplot as plot\nfrom time import sleep\nfrom random import shuffle\nfrom copy import copy\nfrom time import time\n\nplot.ion()\n\ndef generatecolours(w):\n    max = 16581375 # 255**3\n    interval = int(max/len(w))\n    r = range(0,max,interval)\n    return ['#{0}'.format(hex(r[i])[2:].zfill(6)) for i in w]\n\ndef plotchart(x,y,title):\n    plot.clf()\n    plot.title(title)\n    plot.axis('off')\n    plot.bar(x,y,color=generatecolours(y))\n    plot.pause(0.0001)\n    sleep(pause)\n\ndef bubblesort():\n    n = len(z)\n    trace = [copy(z)]\n    while True:\n        swap = False\n        for i in range(n-1):\n            if z[i] > z[i+1]:\n                z[i],z[i+1] = z[i+1],z[i]\n                swap = True\n            trace.append(copy(z))\n        n = n - 1\n        if not swap or n == 1:\n            break\n    return trace\n\n# Define number of items in the list\nitems = 16\n\n# Pause between iterations (s)\npause = 0.2\n\n# Define coordinates and shuffle y\nx = [i for i in range(1,items+1)]\ny = [i for i in range(1,items+1)]\nshuffle(y)\n\n# Time sort operation for copies of y\nprint('Bubble sort')\nprint('-----------')\nz = copy(y)\nprint('Unsorted list : {0}'.format(','.join(map(str,z))))\nplotchart(x,z,'Bubble Sort')\ninput('Press enter to start ...')\nstart = time()\ntrace = bubblesort()\nfor line in trace:\n    plotchart(x,line,'Bubble Sort')\nprint('Time elapsed : {:.3f}s'.format(time()-start))\nprint('Sorted list   : {0}\\n'.format(','.join(map(str,z))))\ninput('Press enter when ready ...')\n```\n\n\nThanks for your help.\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Compilation error in Merge Sort in Haskell\r\n                \r\nI was writing Merge Sort in Haskell and it is giving a strange error:\n\n```\nCouldn't match expected type '[a0] -> Int' with actual type '[Int]'\n```\n\n\nCode is:\n\n```\nf :: [Int] -> [Int] \nf l \n  |length l == 1 = l    \n  |length l == 2 = if head l > last l then reverse l else l\n  |otherwise = myappend ( take ( div length l 2 )  l )  ( drop ( div length l 2 ) l )\n\nmyappend  :: [Int] -> [Int] -> [Int]\nmyappend l [] = l\nmyappend [] l = l\nmyappend ( x : xs ) (y : ys) = if x > y then y : x : myappend xs ys else x : y : myappend ys xs \n```\n\n    ", "Answer": "\r\nYour problem lies in the ```\ndiv length l 2```\n part. Here you're giving ```\ndiv```\n 3 arguments: ```\nlength```\n, ```\nl```\n and 2. Instead, you should have written ```\ndiv (length l) 2```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort with large number of integers\r\n                \r\nNeed to sort a large number of integers which cannot hold into memory. Wondering if Merge sort is the right way? My solution like this,\n\n\nUsing memory based sorting for each 5% of integers, which could hold into memory, using quick sort which performs efficiently in memory;\nAfter each 20 chunks are sorted, using merge sort to sort the 20 lists, for merge sort, I just need to load part of each file into memory, and load next part of the same list if current part of the same list is fully sorted into final results. Since each of the 20 lists are sorted, and I just need to load part of the chunks from head to tail sequentially, so memory is affordable.\n\n\nI am not sure if it is the right way for large number of integer sorting?\n    ", "Answer": "\r\nSince,\n\n\n  they are integers, and most of them are 1-100\n\n\nall you need is Counting Sort.\n\n\n\nIt is very simple in implementation.\n\n\nCreate an array of 100 ints (or ```\nHashMap<int, int>```\n) called ```\nintCounts```\n (take 64-bit ints if you think 32-bit can overflow)\nOne by one read the integers that you have to sort\nFor every ```\ninputInteger```\n to be sorted, just do ```\nintCounts[inputInteger]++```\n\nAfter you have read all integers, ```\nintCounts[i]```\n tells how many times you saw integer ```\ni```\n in your large set of integers\nJust iterate over your ```\nintCounts```\n from least index to highest index\nWrite back ```\ni```\n a total of ```\nintCounts[i]```\n times\nYou have written back a sorted list of all your input integers now.\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "MIPS merge sort recursion\r\n                \r\nI need to write  a MIPS assembly language code for merge sort. I have already created the merge function but the merge_sort function that uses recursion extensively confuses me. I have posted the reference C code for the same. I understand that stacks will have to be used, however, unable to do it myself being a beginner, I would appreciate any kind of help. \n\n```\nint merge_sort(int arr[],int low,int high)\n{\n  int mid;\n  if(low<high) {\nmid=(low+high)/2;\n// Divide and Conquer\nmerge_sort(arr,low,mid);\nmerge_sort(arr,mid+1,high);\n// Combine\nmerge(arr,low,mid,high);\n }\n\n return 0;\n}\n```\n\n    ", "Answer": "\r\nWhy not go from the bottom up and first ```\nmerge```\n pairs of singletons, then pairs of already sorted 2-length sub-arrays, then pairs of 4-length sub-arrays, etc., ```\nlog n```\n passes over same array, in a loop? \n\nThe problem remaining is to implement ```\nmerge```\n. It will be called repeatedly, but not recursively. This ```\nmerge```\n will of course have to write its output back into the array over the input area, perhaps making a temporary copy of its input to work over. \n\n```\nvoid mrgsort( int a[], int n) // pseudo-code\n{\n    if( n < 1 ) return;\n    int s1 = 1, s2 = 2;\n    do\n    {\n        int i, k = n/s2, p1=0, p2=s1;\n        for( i=0; i<k; ++i, p1+=s2, p2+=s2 )\n        {\n            merge(p1, p2); // merge chunks of size s1\n        }\n        //  deal with the edge ...\n        if( i > 0 )\n        {\n            if( p2 < n ) merge_edge(p1,p2,n); // 2nd chunk shorter\n        }\n        s1 = s2;\n        s2 = s2*2;\n    } while( s2 <= n )\n    if( s1 < n )\n        merge_edge(0,s1,n);                   // 2nd chunk shorter\n}\n```\n\n\nNo recursion, just one loop.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort is in infinite loop\r\n                \r\nI am trying to code a recursive merge sort. \nHowever, as I run the code I found out that the code does not go through the right array.\nPlease help me solve the problem. \n\n```\nvoid merge_sort_recursive(int *arr, int left, int right) {\n    int mid;\n    while (left < right) { \n        mid = (left + right) / 2;\n        merge_sort_recursive(arr, left, mid);\n        merge_sort_recursive(arr, mid + 1, right);\n        merge_recursive(arr, left, mid, right);\n    }\n    for (int i = 0; i < 4; i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\n\nvoid merge_recursive(int *arr, int left, int mid, int right) {\n    int *buffer = new int[right + 1]; \n    int lPtr = left; \n    int rPtr = mid + 1;\n    int bPtr = left; \n\n    while (lPtr <= mid && rPtr <= right) {\n        if (arr[lPtr] < arr[rPtr]) \n            buffer[bPtr++] = arr[lPtr++];\n        else\n            buffer[bPtr++] = arr[rPtr++];\n    }\n\n    if (lPtr > mid) \n        for (int i = rPtr; i <= right; i++)\n            buffer[bPtr++] = arr[i];\n    else \n        for (int i = lPtr; i <= mid; i++)\n            buffer[bPtr++] = arr[i];\n\n    for (int i = left; i <= right; i++) \n        arr[i] = buffer[i]; \n}\n```\n\n    ", "Answer": "\r\nThere are multiple problems in your code:\n\n\nin function ```\nmerge_sort_recursive```\n, you should not loop ```\nwhile (left < right)```\n but just proceed recursively ```\nif (left < right)```\n.\nyou should remove the output in ```\nmerge_sort_recursive```\n. I suppose you only have it there for debugging purposes.\nin function ```\nmerge_recursive```\n you allocate a temporary array of size ```\nright + 1```\n. This is much too large, ```\nright - left + 1```\n is sufficient (with adjustments on the index values).\nyou do not ```\ndelete```\n the temporary array, causing substantial memory leaks,\nthe test in the first merge loop should use ```\n<=```\n instead of ```\n<```\n,\n\n\nThe main problem is the ```\nwhile```\n loop that prevents returning from the recursive calls.\n\nHere is a modified version:\n\n```\nvoid merge_sort_recursive(int *arr, int left, int right) {\n    if (left < right) { \n        int mid = (left + right) / 2;\n        merge_sort_recursive(arr, left, mid);\n        merge_sort_recursive(arr, mid + 1, right);\n        merge_recursive(arr, left, mid, right);\n    }\n}\n\nvoid merge_recursive(int *arr, int left, int mid, int right) {\n    int *buffer = new int[right - left + 1];\n    int lPtr = left;\n    int rPtr = mid + 1;\n    int bPtr = 0;\n\n    while (lPtr <= mid && rPtr <= right) {\n        if (arr[lPtr] <= arr[rPtr]) \n            buffer[bPtr++] = arr[lPtr++];\n        else\n            buffer[bPtr++] = arr[rPtr++];\n    }\n    /* copy the remaining elements from the left part */\n    while (lPtr <= mid) {\n        buffer[bPtr++] = arr[lPtr++];\n    }\n    /* no need to copy the remaining elements from the right part \n       because they already are at the final position */\n    for (int i = 0; i < bPtr; i++) {\n        arr[left + i] = buffer[i];\n    }\n    delete[] buffer;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why is recursive Merge Sort preferred over iterative Merge Sort even though the latter has auxillary space complexity?\r\n                \r\nWhile studying about Merge Sort algorithm, I was curious to know if this sorting algorithm can be further optimised. Found out that there exists Iterative version of Merge Sort algorithm with same time complexity but even better ```\nO(1)```\n space complexity. And Iterative approach is always better than recursive approch in terms of performance. Then why is it less common and rarely talked about in any regular Algorithm course?\nHere's the link to Iterative Merge Sort algorithm\n    ", "Answer": "\r\nIf you think that it has ```\nO(1)```\n space complexity, look again.  They have the original array ```\nA```\n of size ```\nn```\n, and an auxiliary ```\ntemp```\n also of size ```\nn```\n.  (It actually only needs to be ```\nn/2```\n but they kept it simple.)\nAnd the reason why they need that second array is that when you merge, you copy the bottom region out to temp, then merge back starting with where it was.\nSo the tradeoff is this.  A recursive solution involves a lot less fiddly bits and makes the concepts clearer, but adds a ```\nO(log(n))```\n memory overhead on top of the ```\nO(n)```\n memory overhead that both solutions share.  When you're trying to communicate concepts, that's a straight win.\nFurthermore in practice I believe that recursive is also a win.\nIn the iterative approach you keep making full passes through your entire array.  Which, in the case of a large array, means that data comes into the cache for a pass, gets manipulated, and then falls out as you load the rest of the array.  Only to have to be loaded again for the next pass.\nIn the recursive approach, by contrast, for the operations that are the equivalent of the first few passes you load them into cache, completely sort them, then move on.  (How many passes you get this win for depends heavily on data type, memory layout, and the size of your CPU cache.)  You are only loading/unloading from cache when you're merging too much data to fit into cache.  Algorithms courses generally omit such low-level details, but they matter a lot to real-world performance.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort recursion call stack\r\n                \r\nI am trying to understand how merge sort recursion stack actually manages to merge two arrays into a sorted array. \n\nThe code and the output are at - https://gist.github.com/antani/144a2dfc85d89ae86297 (to prevent clutter in the question)\n\nI am not able to visualize the stack trace of this algorithm\n    ", "Answer": "\r\nWell, both arrays ```\nleft```\n and ```\nright```\n are sorted if they will be merged. Then the algorithm compares the first and therefore the smallest ```\nleft```\n-value with the smallest ```\nright```\n-value. The smaller value of both is the next value for the resulting array.\n\nAfter this part the resulting array is also sorted and will be returned back to the recursion depth/step/iteration ```\nn -1```\n...\n\nMaybe this animated working sort algorithms will hell you to understand: http://www.sorting-algorithms.com\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "MIPS merge sort recursion\r\n                \r\nI need to write  a MIPS assembly language code for merge sort. I have already created the merge function but the merge_sort function that uses recursion extensively confuses me. I have posted the reference C code for the same. I understand that stacks will have to be used, however, unable to do it myself being a beginner, I would appreciate any kind of help. \n\n```\nint merge_sort(int arr[],int low,int high)\n{\n  int mid;\n  if(low<high) {\nmid=(low+high)/2;\n// Divide and Conquer\nmerge_sort(arr,low,mid);\nmerge_sort(arr,mid+1,high);\n// Combine\nmerge(arr,low,mid,high);\n }\n\n return 0;\n}\n```\n\n    ", "Answer": "\r\nWhy not go from the bottom up and first ```\nmerge```\n pairs of singletons, then pairs of already sorted 2-length sub-arrays, then pairs of 4-length sub-arrays, etc., ```\nlog n```\n passes over same array, in a loop? \n\nThe problem remaining is to implement ```\nmerge```\n. It will be called repeatedly, but not recursively. This ```\nmerge```\n will of course have to write its output back into the array over the input area, perhaps making a temporary copy of its input to work over. \n\n```\nvoid mrgsort( int a[], int n) // pseudo-code\n{\n    if( n < 1 ) return;\n    int s1 = 1, s2 = 2;\n    do\n    {\n        int i, k = n/s2, p1=0, p2=s1;\n        for( i=0; i<k; ++i, p1+=s2, p2+=s2 )\n        {\n            merge(p1, p2); // merge chunks of size s1\n        }\n        //  deal with the edge ...\n        if( i > 0 )\n        {\n            if( p2 < n ) merge_edge(p1,p2,n); // 2nd chunk shorter\n        }\n        s1 = s2;\n        s2 = s2*2;\n    } while( s2 <= n )\n    if( s1 < n )\n        merge_edge(0,s1,n);                   // 2nd chunk shorter\n}\n```\n\n\nNo recursion, just one loop.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Difficulty with merge sort algorithm\r\n                \r\nI'm working on understanding and implementing a merge sort.  I'm running into a brick wall on this one, and can't seem to get an implementation that works.  My current implementation hits a \"list index out of range\" error.  Here is my code:\n\n```\ndef merge_sort(list_a):\n    mid = len(list_a) // 2\n    print('Mid is ', mid)\n    while len(list_a) > 1:\n        left = list_a[:mid]\n        print('Left is now ', left)\n        right = list_a[mid:]\n        print('Right is now ', right)\n        merge_sort(left)\n        merge_sort(right)\n        merge(list_a, left, right)\n\n\ndef merge(comb_list, list_a, list_b):\n    print('Starting the merge.')\n    a1, b1, c1 = 0, 0, 0\n    na, nb, nc = len(list_a), len(list_b), len(comb_list)\n    while a1 < na and b1 < nb:\n        if list_a[a1] < list_b[b1]:\n            print('Adding from A')\n            comb_list[c1] = list_a[a1]\n            a1 += 1\n        else:\n            print('Adding from B')\n            comb_list[c1] = list_b[b1] \n            b1 += 1\n\n        c1 += 1\n\n    while list_a:\n        comb_list[c1] = list_a[a1]\n        c1 += 1\n        a1 += 1\n\n    while list_b:\n        comb_list[c1] = list_b[b1]\n        c1 += 1\n        b1 += 1\n\nif __name__ == '__main__':\n    list_a = [54,26,93,17,77,31,44,55,20]\n    merge_sort(list_a)\n```\n\n    ", "Answer": "\r\nI have made three changes to your script to get it to work. As pointed by sshdup ```\nwhile list_a```\n will always evaluate to true as you don't remove any elements inside the loop. Therefore I have changed ```\nwhile list_a:```\n to ```\nlen(list_a)>a1```\n, ```\nwhile list_b:```\n to ```\nlen(list_b)>b1```\n. I also added ```\nreturn merge(list_a, left, right)```\n to your ```\nmerge_sort```\n method in line with the pseudo code. After adding the ```\nreturn```\n statement the ```\nwhile```\n in ```\nmerge_sort```\n can also be replaced with an ```\nif```\n statement. I have tested this on a random array of integers and it seems to work, however, as usual you should test your edge cases to make sure it works as expected.\n\n```\ndef merge_sort(list_a):\n    mid = len(list_a) // 2\n    print('Mid is ', mid)\n    if len(list_a) > 1:\n        left = list_a[:mid]\n        print('Left is now ', left)\n        right = list_a[mid:]\n        print('Right is now ', right)\n        merge_sort(left)\n        merge_sort(right)\n        return merge(list_a, left, right)\n\n\ndef merge(comb_list, list_a, list_b):\n    print('Starting the merge.')\n    a1, b1, c1 = 0, 0, 0\n    na, nb, nc = len(list_a), len(list_b), len(comb_list)\n    while a1 < na and b1 < nb:\n        if list_a[a1] < list_b[b1]:\n            print('Adding from A')\n            comb_list[c1] = list_a[a1]\n            a1 += 1\n        else:\n            print('Adding from B')\n            comb_list[c1] = list_b[b1] \n            b1 += 1\n\n        c1 += 1\n\n    while len(list_a)>a1:\n        comb_list[c1] = list_a[a1]\n        del list_a[a1]\n        c1 += 1\n        a1 += 1\n\n    while len(list_b)>b1:\n        comb_list[c1] = list_b[b1]        \n        c1 += 1\n        b1 += 1\n\nif __name__ == '__main__':\n    list_a = [54,26,93,17,77,31,44,55,20]\n    merge_sort(list_a)\n    print list_a\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort is in infinite loop\r\n                \r\nI am trying to code a recursive merge sort. \nHowever, as I run the code I found out that the code does not go through the right array.\nPlease help me solve the problem. \n\n```\nvoid merge_sort_recursive(int *arr, int left, int right) {\n    int mid;\n    while (left < right) { \n        mid = (left + right) / 2;\n        merge_sort_recursive(arr, left, mid);\n        merge_sort_recursive(arr, mid + 1, right);\n        merge_recursive(arr, left, mid, right);\n    }\n    for (int i = 0; i < 4; i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\n\nvoid merge_recursive(int *arr, int left, int mid, int right) {\n    int *buffer = new int[right + 1]; \n    int lPtr = left; \n    int rPtr = mid + 1;\n    int bPtr = left; \n\n    while (lPtr <= mid && rPtr <= right) {\n        if (arr[lPtr] < arr[rPtr]) \n            buffer[bPtr++] = arr[lPtr++];\n        else\n            buffer[bPtr++] = arr[rPtr++];\n    }\n\n    if (lPtr > mid) \n        for (int i = rPtr; i <= right; i++)\n            buffer[bPtr++] = arr[i];\n    else \n        for (int i = lPtr; i <= mid; i++)\n            buffer[bPtr++] = arr[i];\n\n    for (int i = left; i <= right; i++) \n        arr[i] = buffer[i]; \n}\n```\n\n    ", "Answer": "\r\nThere are multiple problems in your code:\n\n\nin function ```\nmerge_sort_recursive```\n, you should not loop ```\nwhile (left < right)```\n but just proceed recursively ```\nif (left < right)```\n.\nyou should remove the output in ```\nmerge_sort_recursive```\n. I suppose you only have it there for debugging purposes.\nin function ```\nmerge_recursive```\n you allocate a temporary array of size ```\nright + 1```\n. This is much too large, ```\nright - left + 1```\n is sufficient (with adjustments on the index values).\nyou do not ```\ndelete```\n the temporary array, causing substantial memory leaks,\nthe test in the first merge loop should use ```\n<=```\n instead of ```\n<```\n,\n\n\nThe main problem is the ```\nwhile```\n loop that prevents returning from the recursive calls.\n\nHere is a modified version:\n\n```\nvoid merge_sort_recursive(int *arr, int left, int right) {\n    if (left < right) { \n        int mid = (left + right) / 2;\n        merge_sort_recursive(arr, left, mid);\n        merge_sort_recursive(arr, mid + 1, right);\n        merge_recursive(arr, left, mid, right);\n    }\n}\n\nvoid merge_recursive(int *arr, int left, int mid, int right) {\n    int *buffer = new int[right - left + 1];\n    int lPtr = left;\n    int rPtr = mid + 1;\n    int bPtr = 0;\n\n    while (lPtr <= mid && rPtr <= right) {\n        if (arr[lPtr] <= arr[rPtr]) \n            buffer[bPtr++] = arr[lPtr++];\n        else\n            buffer[bPtr++] = arr[rPtr++];\n    }\n    /* copy the remaining elements from the left part */\n    while (lPtr <= mid) {\n        buffer[bPtr++] = arr[lPtr++];\n    }\n    /* no need to copy the remaining elements from the right part \n       because they already are at the final position */\n    for (int i = 0; i < bPtr; i++) {\n        arr[left + i] = buffer[i];\n    }\n    delete[] buffer;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort recursion call stack\r\n                \r\nI am trying to understand how merge sort recursion stack actually manages to merge two arrays into a sorted array. \n\nThe code and the output are at - https://gist.github.com/antani/144a2dfc85d89ae86297 (to prevent clutter in the question)\n\nI am not able to visualize the stack trace of this algorithm\n    ", "Answer": "\r\nWell, both arrays ```\nleft```\n and ```\nright```\n are sorted if they will be merged. Then the algorithm compares the first and therefore the smallest ```\nleft```\n-value with the smallest ```\nright```\n-value. The smaller value of both is the next value for the resulting array.\n\nAfter this part the resulting array is also sorted and will be returned back to the recursion depth/step/iteration ```\nn -1```\n...\n\nMaybe this animated working sort algorithms will hell you to understand: http://www.sorting-algorithms.com\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementing merge-sort in python\r\n                \r\nI am trying to implement the merge-sort algorithm in Python 3. Here's the function that implements the merge part of the algorithm:\n\n```\ndef Merge(A,p,q,r):\nn1 = q - p + 1\nn2 = r - q\n\n#We first populate two lists that contain the sorted subsequences A[p,...,q] and A[q+1,...,r]\nL = []\nR = []\n\nfor index in range(n1):\n    L.append(A[index + p])\n\nfor index in range(n2):\n    R.append(A[index + q + 1])\n\n#We now overwrite the A[p,..,q,...r] section of the list by comparing the 'top-most'\n#elements in the lists l and R and putting the smaller element in the corresponding\n#entry in A. If one of the list is fully exposed/no longer available, we simply put the \n#remaining list's elements in the corresponding positions in A.\n\ni = 0\nj = 0\n\nfor k in range(r - p + 1 ):\n\n    if i > n1-1:\n        A[k] = R[j]\n        j = j + 1\n\n    elif j > n2-1:\n        A[k] = L[i]\n        i = i + 1\n\n    elif L[i] < R[j]:\n        A[k] = L[i]\n        i = i + 1\n\n    else:\n        A[k] = R[j]\n        j = j + 1 \n\nreturn A   \n```\n\n\nI have tested this function and it runs fine: as long as the subarrays A[p,q] and A[q+1,r] are sorted, the whole array A[p,r] will be sorted correctly. I now try and implement a divide and conquer approach to merge a large enough list.\n\n```\nimport math\n\ndef Merge_Sort(A,p,r):\n\nif p == r:\n\n    return A\n\nif p < r:\n\n    q = math.floor((p+r)/2)\n    Merge_Sort(A,p,q)\n    Merge_Sort(A,q+1,r)\n    Merged_List = Merge(A,p,q,r)\n\nreturn Merged_List\n```\n\n\nBut I get erroneous answers when I run it. Here's an example:\n\n```\n#We now analyze the merge sort algorithm.\nA = [1,7,9,3]\nB = Merge_Sort(A,0,3)\nprint(B)\n```\n\n\nThe output is\n\n```\n[3, 9, 3, 9]\n```\n\n\nI am probably making some obvious/stupid mistake in the implementation of the divide and conquer bit. Suggestions?\n    ", "Answer": "\r\nThe error is in the assignments to ```\nA[k]```\n. They should be changed to assignments to ```\nA[p+k]```\n.\n\nNote that ```\nL```\n and ```\nR```\n can be defined using the following syntax (no explicit loop):\n\n```\nL = A[p:q+1]\nR = A[q+1:r+1]\n```\n\n\nTo be consistent with how native functions work in Python (e.g. ```\nlist.extend```\n), your two functions should not return the list. They mutate the list that you pass as argument, and so to avoid confusion, it is better not to return it: it could make users of your code think that the function has no side effects.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "The difference between \"3 way Merge Sort\" and \"3 way Natural Merge Sort\"\r\n                \r\nI am trying to learn all the merge sort algorithms. I tried to search the web for them but each page says something different and I want closure regarding those algorithms. \n\nCan anybody help?\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Segmentation faut when implementing merge sort\r\n                \r\nI'm trying to implement the merge sort in c, but I have a segmentation fault 11, and I don't get why.\n```\nvoid trieFusion(int *t, int d, int f){\n    if (f==d)\n        return;\n    \n    int m=(f-d)/2+d;\n    trieFusion(t, d, m);\n    trieFusion(t, m+1, f);\n    \n    int tmp[(f-d+1)];\n    int pg = d;    \n    int pd = m + 1; \n\n    for(int i = d; i <= f; i++) {\n        if(pg == m + 1) { \n            tmp[i] = t[pd];\n            pd++;\n        }\n        else if (pd == f + 1) { \n            tmp[i] = t[pg];\n            pg++;\n        }\n        else if (t[pg] < t[pd]) { \n            tmp[i] = t[pg];\n            pg++;\n        }\n        else{  \n            tmp[i] = t[pd];\n            pd++;\n        }\n    }\n    for(int i = d; i <= f; i++) { \n        t[i] = tmp[i];\n    }\n}\n```\n\nThe main\n```\nint main(){\n    int t[] = {2,4,2,4,6,7,2,3,5,4};\n    int n=10;\n    afficheTableau(t, n);\n\n    majoritaireNLogN(t, n);\n\n    afficheTableau(t,n);\n    return EXIT_SUCCESS;\n}\n```\n\nThe function that calls my merge sort\n```\nint majoritaireNLogN(int* t, int n){\n        n--;\n        trieFusion(t, 0, n);\n        return t[0];\n}\n```\n\nIf I run my code, I can sort the first half of a table without a problem, but the segmentation fault is coming from the second half of a table.\nI don't find where this problem is coming from.\n    ", "Answer": "\r\nProblem most likely lies in this loop (and the same loop below).\n\n```\nfor(int i = d; i <= f; i++)```\n\n\nto fix it, replace all instances of that with this:\n\n```\nfor(int i = d; i < f; i++)```\n\n\nIn C and most languages, arrays are 0 indexed, meaning the first element is in the ```\narray[0]```\n index and the last element, let's say our array has 10 elements, is on the ```\narray[9]```\n index. So, in your case, you pass in an array with 10 elements, and probably try to index a value in the array that isn't defined; i.e. look for an 11th element, which is not allocated in memory.\nWhen you say ```\n<=```\n it means that the loop will stop only when ```\nd```\n is greater than ```\nf```\n, and if ```\nf```\n is greater than 9 (which it is since it'll be 10), the index of the last element, your code will try to access areas in memory that are not allocated, so your code doesn't have access to it. This will cause a segmentation fault. Here is a quick guide to iterating through loops.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort code in Python using recursion\r\n                \r\nBelow is intended for a merge sort written in Python. It is throwing an error \"RuntimeError: maximum recursion depth exceeded\". Please let me know if I am missing the logic to end the recursion.\n\n```\n  list=[]\n  list1=[]\n  list2=[]\n  def merge(list,list1,list2):\n\n  for k in range(1,len(list1)+len(list2)):\n    i=1\n    j=1\n    if list1[i]>list2[j]:\n        list[k]=list2[j]\n        j=+1\n        k=+1\n    else:\n        list[k]=list2[i]\n        i=+1\n        k=+1\n\n\n    def split(list,list1,list2):\nif len(list)<>1:\n    list1=list[:len(list)/2]\n    list2=list[len(list)/2:]\nreturn  \n\n\n   def sort(list):\n      split(list,list1,list2)\n      sort(list1)\n      sort(list2)\n      merge(list,list1,list2)\n\n\n      list = [15,8,59,69,45,23]\n      sort(list)\n```\n\n    ", "Answer": "\r\nTry this program:\n\n```\n def sort( aList ):\n      aList = _mergesort( aList, 0, len( aList ) - 1 )\n      return aList\n\ndef _mergesort( aList, first, last ):\n  mid = ( first + last ) / 2\n  if first < last:\n    _mergesort( aList, first, mid )\n    _mergesort( aList, mid + 1, last )\n\n  a, f, l = 0, first, mid + 1\n  tmp = [None] * ( last - first + 1 )\n\n  while f <= mid and l <= last:\n    if aList[f] < aList[l] :\n      tmp[a] = aList[f]\n      f += 1\n    else:\n      tmp[a] = aList[l]\n      l += 1\n    a += 1\n\n  if f <= mid :\n    tmp[a:] = aList[f:mid + 1]\n\n  if l <= last:\n    tmp[a:] = aList[l:last + 1]\n\n  a = 0\n  while first <= last:\n    aList[first] = tmp[a]\n    first += 1\n    a += 1\n  return aList\n\naList = [15,8,59,69,45,23]\nprint sort(aList)\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Trouble with Merge Sort\r\n                \r\nFor my java homework I am struggling to write a recursive merge sort class.  As of right now I have 3 method a \"driver\" method to start the recursion, the recursive ```\nmergeSort```\n method and a ```\nmerge```\n method.  Depending on what variables I change my output is either an array of all zeros or my original array in the same order.  The only thing is the original ```\nmergeSort```\n method must take in one array and the ```\nmerge```\n method cannot return anything. Any help with be much appreciated \n\n```\nimport java.util.Arrays;\npublic class merge2 {\n    public static void main(String[] args){\n        int []a={22,45,1,4,89,7,0};\n        mergeSort(a);\n        System.out.println(Arrays.toString(a));                 \n    }\n\n    public static void mergeSort(int [] a){\n        mergeSort(a,0,a.length-1);\n    }\n\n    public static void mergeSort(int []a, int beg,int end){\n        if(beg<end){\n            int mid=(beg+end)/2;\n            mergeSort(a,beg,mid);\n            mergeSort(a,mid+1,end);\n            merge(a,beg,mid,end);\n        }\n    }\n\n    private static void merge(int []a, int beg, int middle, int end){\n        int [] d=new int[a.length];\n        int mid=middle+1; //start of second half of array\n        for(int i=0;i<d.length;i++){\n            if(beg<=middle && mid<=end){  \n                if(a[beg]<=a[mid]) {\n                d[i]=a[beg];\n                beg++;\n                } else if(a[mid]<=a[beg]){\n                        d[i]=a[mid];\n                        mid++;\n                }\n            }else if(beg>middle){ \n                d[i]=a[mid];\n                mid++;\n            }else if(mid==a.length){\n                d[i]=a[beg];\n                beg++;\n            }\n        }\n        for(int w=0;w<d.length;w++){\n            a[w]=d[w];\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nHere is pseudocode for the mergeSort method. I see that you have disregarded the base cases for one or two elements:\n\n```\nif (sublist has only one value)\n   do nothing\nelse if (sublist has two values)\n   switch if necessary\nelse    // recursion, divide list into two halves\n   Find midpoint of current sublist\n   Call mergeSort and process left sublist\n   Call mergeSort and process right sublist\n   merge left and right sublists\n```\n\n\nAs for your merge method, it is creating a new array instead of modifying the existing array. I suggest using ArrayLists to implement it:\n\n```\nprivate void merge(int[] a, int first, int mid, int last)\n  {\n    ArrayList<Integer> left = new ArrayList<Integer>(mid - first + 1), right = new ArrayList<Integer>(last - mid);\n    for(int m = first; m <= mid; ++m)   //initialize left sublist\n    {\n      left.add(a[m]);\n    }\n    for(int m = mid + 1; m <= last; ++m)    //initialize right sublist\n    {\n      right.add(a[m]);\n    }\n    int i = first;\n    while(!left.isEmpty() || !right.isEmpty())  //while either list has an element\n    {\n      if(left.isEmpty())\n      {\n        a[i++] = right.remove(0);\n      }\n      else if(right.isEmpty())\n      {\n        a[i++] = left.remove(0);\n      }\n      else if (left.get(0) < right.get(0))\n      {\n        a[i++] = left.remove(0);\n      }\n      else\n      {\n        a[i++] = right.remove(0);\n      }\n    }\n  }\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Debugging a merge sort\r\n                \r\n```\nvoid CensusData::mergeSort(int type) {\n    if(type == 0)\n        MERGE_SORT(type, 0, data.size());\n}\n\nvoid CensusData::MERGE_SORT(int type, int p, int r){\n    //int q;\n    //cout << \"data size \" << data.size() << endl;\n    std::cout << \"MERGE_SORT START ///(\"<< p << \", \" << r << \")\" <<std::endl;\n    if(p < r)\n    {\n        int q = (p + r)/2;\n        MERGE_SORT(type, p, q);\n        MERGE_SORT(type, q + 1, r);\n        MERGE(type, p, q ,r);\n    }\n}\n\nvoid CensusData::MERGE(int type, int p, int q, int r){\n    if(type == 0)\n    {\n        std::cout << \"MERGING\" << std::endl;\n        //int n1;\n        //int n2;\n        int n1 = q - p + 1;\n        int n2 = r - q;\n        int L[n1 + 1];\n        int R[n2 + 1];\n        for(int i = 1; i < n1; i++)\n        {\n            cout << \"filling Left Array\" << endl;\n            L[i] = data[p + i - 1]->population;\n        }\n        for(int j = 1; j < n2; j++)\n        {\n            cout << \"filling Right Array\" << endl;\n            R[j] = data[q + j]->population;\n        }\n        int i = 1;\n        int j = 1;\n        for(int k = p; p < r; p++)\n        {\n            cout << \"for loop: \" << endl;\n            if(L[i] <= R[j])\n            {\n                cout << \"TRUE\" << endl;\n                data[k]->population = L[j];\n                i = i + 1;\n            }\n            /*else if(data[k]->population == R[j])\n            {\n                cout << \"FALSE\" << endl;\n                j = j + 1;\n            }*/\n            else\n            {\n                data[k]->population = R[j];\n                j = j + 1;\n            }\n        }\n\n    }\n}\n```\n\n\ndo not worry about type, it wont effect this program at all.  basically i am trying to make a merge sort that will take a vector containing an integer, the vector looks like this:\n\n```\n   class Record {                         // declaration of a Record\n   public:\n      std::string* city;\n      std::string* state;\n      int population;\n      Record(std::string&, std::string&, int);\n      ~Record();\n   };\n   std::vector<Record*> data;   \n```\n\n\nbasically i have been trying to get it to actually sort, but it doesn't seem to work at all, i have even seen garbage in the program.\n\nexample input:\n237 812826 68642\noutput:\n4484540 812826 68642\n\nNote: all of the rest of the program works fine (tested it with an insertion sort) only this part is not working.\n    ", "Answer": "\r\nTake a look at lecture 15 of the excellent Stanford Universities course Programming Abstractions. It covers all kinds of sorts including merge:\n\nhttp://see.stanford.edu/see/lecturelist.aspx?coll=11f4f422-5670-4b4c-889c-008262e09e4e\n\nYou can even get the source code from SourceForge:\n\nhttp://sourceforge.net/projects/progabstrlib/files/\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort (Sort words based on frequency)\r\n                \r\nI'm writing a merge sort method that is suppose to sort words basded on frequency or on how many times they have appeared ex. Highest to lowest. For some reason my words are not sorting in the correct order, and eveything i have done seems to be logically correct and works on paper.\n\nmethod:\n\n```\npublic void mergeSortFreq(ArrayList<Term> toDo, int first, int mid, int last){\n    int first1 = first;\n    int last1 = mid;\n    int first2 = mid+1;\n    int last2 = last;\n    int index = 0;\n    ArrayList<Term> temp = new ArrayList<Term>();\n    int counter = 0;\n\n    while((first1 <= last1) && (first2 <= last2)){\n        if(toDo.get(first1).getTotalFrequency() >= (toDo.get(first2).getTotalFrequency())){\n            temp.add(index, toDo.get(first1));\n            first1++;\n            counter++;\n        }\n        else{\n            temp.add(index, toDo.get(first2));\n            first2++;\n        }\n        index++;\n    }\n\n    while(first1<=last1){\n        temp.add(index, toDo.get(first1));\n        first1++;\n        index++;\n    }\n\n    while(first2<=last2){\n        temp.add(index, toDo.get(first2-1));\n        first2++;\n        index++;\n    }\n\n    terms.clear();\n    for(int i=0; i<temp.size(); i++){\n        terms.add(temp.get(i));\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Count Inversion using merge sort\r\n                \r\ni wrote the code of count inversion using merge sort in C++ but i am getting wrong answer\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long merge(long long *arr,long long s, long long mid,long long e){\n    long long count =0;\n    long long temp[e-s+1];\n    long long i = s;\n    long long j = mid+1;\n    long long k =0;\n    while(i<=mid && j<=e){\n        if(arr[i]<arr[j]){\n            temp[k++] = arr[i++];\n        }else{\n            temp[k++] = arr[j++];\n\n            count = count + (mid+1)-i;\n        }\n    }\n    while(i<=mid){\n        temp[k++] = arr[i++];\n    }\n    while(j<=e){\n        temp[k++] = arr[j++];\n    }\n    k=0;\n    for(i=s;i<=e;i++){\n        arr[i] = temp[k++];\n    }\n    return count;\n}\n\nlong long mergeSort(long long *arr,long long s,long long e){\n    long long count =0;\n    if(s<e){\n        long long mid = (s+e)/2;\n        count += mergeSort(arr,s,mid);\n        count += mergeSort(arr,mid+1,e);\n        count += merge(arr,s,mid,e);\n    }\n    return count;\n}\n\nint main(){\n    long long x;\n    cin >> x;\n    long long arr[x];\n    for(long long i=0;i<x;i++){\n        cin >> arr[i];\n    }\n    long long N =x;\n    cout << mergeSort(arr,0,N-1);\n}\n```\n\nit fails this test case\n```\nArray size : 42\nelements : 468 335 1 170 225 479 359 463 465 206 146 282 328 462 492 496 443 328 437 392 105 403 154 293 383 422 217 219 396 448 227 272 39 370 413 168 300 36 395 204 312 323\n```\n\nCorrect Output\n```\n494\n```\n\noutput of my code\n```\n495\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort with Random Split\r\n                \r\nIn Mergesort Algorithm, instead of splitting array into the equal half, try to split array from random point in each call, I want to calculate the average time of this algorithm?\n\nOur notes calculate it as normal merge sort.  any formal idea? \n    ", "Answer": "\r\nHere is a proof that its time complexity is ```\nO(n log n)```\n(it's not very formal).\n\n\nLet's call a split \"good\" if the size of the largest part is at most 3/4 of the initial subarray(it looks this way: ```\nbad bad good good good good bad bad```\n for an array with 8 elements). The probability of split to be good is ```\n1/2```\n. It means that among two splits we expect one two be \"good\". \nLet's draw a tree of recursive merge sort calls:\n\n```\n    [a_1, a_2, a_3, ..., a_n]    --- level 1\n         /             \\\n[a_1, ..., a_k]   [a_k + 1, a_n] --- level 2\n    /    \\            /  \\\n...                              --- level 3\n\n                                 ...\n\n                                 --- level m   \n```\n\n\nIt is clear that there are at most ```\nn```\n elements at each level, so the time complexity is ```\nO(n * m)```\n.\nBut 1). implies that the number of levels is ```\n2 * log(n, 4 / 3)```\n, where  ```\nlog(a, b)```\n is a logarithm of ```\na```\n base ```\nb```\n, which is ```\nO(log n)```\n.\nThus, the time complexity is ```\nO(n * log n)```\n.\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C++ Merge-Sort Algorithm with Subsequence Sorting\r\n                \r\nThe idea is the following: \n\nwe want to create a merge-sort algorithm that takes a sequence length 'n' and divides this n-length into subsequences such that you have n subsequences that are then sorted. \n\nExample:\n\n```\n    n = length 4 \n    Array = {2, 9, 4, 1}\n```\n\n\nthen you get something like:\n\n```\n    Sub1 = {2} Sub2 = {9} Sub3 = {4} Sub4 = {1} \n```\n\n\nThis will sort the subsequences by comparing them and then merge them together to form one sequence again. (Illustrated below)\n\n\n  Sequence -> split into Subsequences -> Subsequences compared -> Merged\n  into sorted sequence.\n\n\nThe basics behind it is a recursive merge-sort, but instead of dividing the sequence by 2, we want to divide by the length of the array. \n\nI created a working merge-sort that takes a user-inputed length of the list (however generates random values of the list) and sorts. However I get stuck when it comes down to sorting by the length. In my code I have 3 functions and the user-input is given in the main (the length). How do I change this such that I can use the user-input as my division factor for my sort? \n\nNote: I don't want a code, but more of an explanation on how to approach this. I tried a couple times with moving and merging my functions, but I haven't gotten anywhere. \n\nThanks in advance! :) \n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge-sort implementation doesn't work\r\n                \r\nI'm trying to implement merge sort in C using arrays, here's my code:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid merge(int s[], int low, int middle, int high)\n{\n    int i,l=0,r=0;\n    int left[high/2], right[high/2];\n\n    for(i = low; i<=middle; i++) left[i-low] = s[i];\n    for(i = middle+1; i<=high; i++) right[i-middle-1] = s[i];\n\n    i = low;\n    while(l <= middle-low || r <= high - middle - 1)\n    {\n        if(left[l] <= right[r])\n        {\n            s[i++] = left[l];\n            l++;\n        }\n        else\n        {\n            s[i++] = right[r];\n            r++;\n        }\n    }\n    while(l <= middle-low)\n    {\n        s[i++] = left[l];\n        l++;\n    }\n    while(r <= high - middle - 1)\n    {\n        s[i++] = left[r];\n        r++;\n    }\n}\n\nvoid mergesort(int s[], int low, int high)\n{\n    int i;\n    int middle;\n    if(low < high){\n        middle = (low + high)/2;\n        mergesort(s, low, middle);\n        mergesort(s, middle+1, high);\n        merge(s, low, middle, high);\n    }\n}\n\nint main()\n{\n    int nums[] = {5, 345, 1, 120, 40, 3450};\n    int size = (sizeof(nums))/(sizeof(int));\n    int i;\n    for(i = 0; i < size; i++)\n        printf(\"%d \", nums[i]);\n    printf(\"\\n\");\n    mergesort(nums, 0, size);\n    for(i = 0; i < size; i++)\n        printf(\"%d \", nums[i]);\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n\nThat outputs:\n\n```\n5 345 1 120 40 3450 \n0 1 4 5 40 120 \n```\n\n\nWhich is kind of close. Could someone point out my mistakes? Thank you.\n    ", "Answer": "\r\nYou access the array out of bounds at several places. Your code uses C-style ranges, which have an inclusive lower bound ```\nL```\n and an exclusive upper bound ```\nH```\n. Exclusive means that the upper bound ```\nH```\n is not a valid index in the (sub-)array. A typical loop over the range look like this:\n\n```\nfor (i = L; i < U; i++) ...\n```\n\n\nor\n\n```\ni = L;\nwhile (i < U) ...\n```\n\n\nA greater-than-or-equal operator ```\n<=```\n in such loops should make you wary, as should suprious additions or subtraction of 1. They might be correct in some cases, but they are usually consequences of inconsitent array indexing.\n\nLet's revise your code with the C-style ranges in mind:\n\n```\nint left[high/2], right[high/2];\n```\n\n\nThe array sizes are wrong. The left array has ```\nmiddle - low```\n elements and the right array has ```\nhigh - middle```\n elements. If the array size ```\nhigh - low```\n is odd, you have one more element in right than in left.\n\n```\nfor(i = low; i<=middle; i++) left[i-low] = s[i];\n```\n\n\nYou mistakenly put the middle element in the left array. It is the first element of the right array.\n\n```\nfor(i = middle+1; i<=high; i++) right[i-middle-1] = s[i];\n```\n\n\nSame here, plus you access ```\ns[high]```\n which is one beyond the array.\n\n```\ni = low;\nwhile(l <= middle-low || r <= high - middle - 1)\n```\n\n\nThe conditions should have ```\n<```\n and no ```\n-1```\n. More importantly, the conditions should both be true, otherwise you access the subarrays out of bounds; hence the operator should be ´&&`.\n\n```\n    if(left[l] <= right[r])\n```\n\n\nThe ```\n<=```\n is okay, though, for once.\n\n```\nwhile(l <= middle-low)\n{\n    s[i++] = left[l];\n    l++;\n}\nwhile(r <= high - middle - 1)\n{\n    s[i++] = left[r];\n    r++;\n}\n```\n\n\nHere, it should be ```\n<```\n again. Also note that you access ```\nleft```\n with the index ```\nr```\n, which is probably just a typo owed to copy and paste.\n\n```\nif(low < high){\n    middle = (low + high)/2;\n    mergesort(s, low, middle);\n    mergesort(s, middle+1, high);\n    merge(s, low, middle, high);\n}\n```\n\n\nHere, the second call to megesort should be to ```\nmiddle```\n, not to ```\nmiddle + 1```\n. Because the upper bound is exclusive and the lower is not, adjacent arrays share the same bounds.\n\nHere's a sort that works:\n\n```\nvoid merge(int s[], int low, int middle, int high)\n{\n    int i, l = 0, r = 0;\n    int left[middle - low];\n    int right[high - middle];\n\n    for (i = low; i < middle; i++) left[i - low] = s[i];\n    for (i = middle; i < high; i++) right[i - middle] = s[i];\n\n    i = low;\n    while (low + l < middle && middle + r < high) {\n        if (left[l] < right[r]) {\n            s[i++] = left[l];\n            l++;\n        } else {\n            s[i++] = right[r];\n            r++;\n        }\n    }\n\n    while (low + l < middle) {\n        s[i++] = left[l];\n        l++;\n    }\n\n    while (middle + r < high) {\n        s[i++] = right[r];\n        r++;\n    }\n}\n\nvoid mergesort(int s[], int low, int high)\n{\n    int middle;\n\n    if (low + 1 < high) {\n        middle = (low + high) / 2;\n        mergesort(s, low, middle);\n        mergesort(s, middle, high);\n        merge(s, low, middle, high);\n    }\n}\n```\n\n\nThe code can still be improved. The different indices for the left and right subarrays make it difficult to maintain and test the code. If you have already learned about pointer arithmetic, you can do without the ```\nlow```\n bound entirely by passing ```\narray + low```\n and the size as new array base, as EOF has suggested in a comment.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort space\r\n                \r\nIn a top-down merge sort  the recursive functions are called in this fashion:\n\n```\nvoid mergesort(Item a[], int l, int r) {\n    if (r <= l) return;\n    int m = (r+l)/2;\n    mergesort(a, l, m);\n    mergesort(a, m+1, r);\n    merge(a, l, m, r);\n}\n```\n\n\nIt is given in text book that space complexity of this strategy is O(n). whereas if we look at the recursion closely : we are passing pointer to array in recursive calls. Second the recursion is resolved in preorder order of traversal by merging bottom nodes to parent nodes. so at each time there are O(logn) variables on stack (or O(log n) frames on stack). So how is it that space complexity is O(n) inspite of having in-place merging techniques?\n    ", "Answer": "\r\n\n  So how is it that space complexity is O(n) inspite of having in-place merging techniques?\n\n\nBecause the implementation given in your book probably doesn't use an in-place merging technique. If an O(1) space and O(n log n) time sort is required, heapsort is usually preferred to merge sort since it is much easier. Only when you're talking about sorting lists does doing an O(1) merge sort make sense... and then, it is easy to do. Merge sort specified for e.g. a linked list would be O(1) space and O(n log n) time.\n\nThe fundamental misunderstanding here seems to be this: time complexities apply to algorithms, not the problems they solve. I can write an O(n^3) merge sort if I want... doesn't mean my algorithm isn't O(n^3), and it doesn't say anything about your O(n log n) merge sort. This is a little different from computational complexity, where we talk about e.g. problems being in P... a problem is in P if there's a polynomial time algorithm for it. However, problems in P can also be solved by non-polynomial time algorithms, and if you think about it, it's trivial to construct such an algorithm. Same goes for space complexities.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort on an ArrayList\r\n                \r\nI'm working on a method that sorts my array list using merge sort. My problem is that it will not sort the array list the way i want it t(By total number of times the word appears). It seems as if it is sorting it but when i debug it reverts back to alphabetical order at the end. \n\nEdit: To clarify: the variable \"temp\" is an instance variable. This is the ArrayList that we are trying to sort.\n\ncode:\n\n```\npublic void mergeSortFreq(ArrayList<Term> toDo, int first, int mid, int last) {\n    int first1 = first;\n    int last1 = mid;\n    int first2 = mid + 1;\n    int last2 = last;\n    int index = first1;\n    ArrayList<Term> temp = new ArrayList<Term>();\n    int counter = 0;\n    while ((first1 <= last1) && (first2 < last2)) {\n        if (toDo.get(first1).compareTo(toDo.get(first2).getTotalFrequency()) <= 0) {\n            temp.add(toDo.get(first1));\n            first1++;\n            counter++;\n        } else {\n            temp.add(toDo.get(first2));\n            first2++;\n        }\n        index++;\n    }\n\n    while (first1 < last1) {\n        temp.add(toDo.get(first1));\n        first1++;\n        index++;\n    }\n\n    while (first2 < last2) {\n        temp.add(toDo.get(first2));\n        first2++;\n        index++;\n    }\n\n    for(index = first; index < temp.size(); ++index){\n            terms.set(index, temp.get(index));\n    }\n}\n\npublic void mergeFreqhelp(ArrayList<Term> toDo, int first, int last) {\n    int mid = (first + last) / 2;\n    if (first < last) {\n        mergeFreqhelp(toDo, first, mid);\n        mergeFreqhelp(toDo, mid + 1, last);\n        mergeSortFreq(toDo, first, mid, last);\n    }\n    else{\n        System.out.println(\"Working???\");\n    }\n}\n```\n\n    ", "Answer": "\r\nThis is a scope problem. You are not returning and assigning the result of sorting from ```\nmergeSortFreq```\n. Change that method so that it returns an ArrayList. Otherwise the sorting will take place within the method, but will never be returned back.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why Merge sort is used for objects in Android/Java API?\r\n                \r\nIn Java Arrays.sort() for primitive type uses quick sort. On the other hand Arrays.sort() for objects uses Merge sort. And, same goes for Collection.sort() which also uses Merge sort. Collections sort uses Arrays sort implementation underneath. So, in simple sense i can say that primitives are sorted using quick sort but objects are sorted using Merge sort. \n\nMy guess is it has something to do with sorting algorithm it self. There are so many discussion on SO on Quick sort vs Merge sort, like this and this. Seems to be there are conflicting claims on which one is better, which is understandable as this depend on data sets.  \n\nMy understanding is \n\n\nIn place: Quick sort wins. Merge sort can be implemented in in-place for Linked list\nExternal Storage Data: Merge sort wins.\nSorting List (backed by any form of linked list): Merge sort wins. Link\n\n\nAndroid API seems to follow the same pattern as Java. This is what i found in Arrays.java\n\n```\n    public static void sort(long[] array) {\n    DualPivotQuicksort.sort(array);\n}\n```\n\n\nAnd this,\n\n```\npublic static void sort(Object[] array) {\n    ComparableTimSort.sort(array);\n}\n```\n\n\nWhat i do not understand is, what makes Merge sort a good candidate for sorting objects in Java or in Android? Why not leaving this decision upto developers? \n    ", "Answer": "\r\nThe key issue is sort stability - if two elements are equal from the point of view of the sort order, do they appear in the result in the same order as in the input.\n\nIt does not matter for e.g. ```\nlong```\n. All instances of ```\n3```\n in the input will be grouped together, and nobody cares which was which.\n\nOn the other hand, objects may differ in ways that do not affect the sort order. If you are sorting animals by number of legs, you may care whether \"cat\" and \"dog\" stay in the original order or not.\n\nThe Arrays.sort mergesort is stable. The quicksort used for the primitives does not need to be stable.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Count Inversion using merge sort\r\n                \r\ni wrote the code of count inversion using merge sort in C++ but i am getting wrong answer\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long merge(long long *arr,long long s, long long mid,long long e){\n    long long count =0;\n    long long temp[e-s+1];\n    long long i = s;\n    long long j = mid+1;\n    long long k =0;\n    while(i<=mid && j<=e){\n        if(arr[i]<arr[j]){\n            temp[k++] = arr[i++];\n        }else{\n            temp[k++] = arr[j++];\n\n            count = count + (mid+1)-i;\n        }\n    }\n    while(i<=mid){\n        temp[k++] = arr[i++];\n    }\n    while(j<=e){\n        temp[k++] = arr[j++];\n    }\n    k=0;\n    for(i=s;i<=e;i++){\n        arr[i] = temp[k++];\n    }\n    return count;\n}\n\nlong long mergeSort(long long *arr,long long s,long long e){\n    long long count =0;\n    if(s<e){\n        long long mid = (s+e)/2;\n        count += mergeSort(arr,s,mid);\n        count += mergeSort(arr,mid+1,e);\n        count += merge(arr,s,mid,e);\n    }\n    return count;\n}\n\nint main(){\n    long long x;\n    cin >> x;\n    long long arr[x];\n    for(long long i=0;i<x;i++){\n        cin >> arr[i];\n    }\n    long long N =x;\n    cout << mergeSort(arr,0,N-1);\n}\n```\n\nit fails this test case\n```\nArray size : 42\nelements : 468 335 1 170 225 479 359 463 465 206 146 282 328 462 492 496 443 328 437 392 105 403 154 293 383 422 217 219 396 448 227 272 39 370 413 168 300 36 395 204 312 323\n```\n\nCorrect Output\n```\n494\n```\n\noutput of my code\n```\n495\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Passing a Tuple in merge sort\r\n                \r\nHere is merge sort : \n\n```\ndef msort[T](less: (T, T) => Boolean)\n            (xs: List[T]): List[T] = {\n  def merge(xs: List[T], ys: List[T], acc: List[T]): List[T] =\n    (xs, ys) match {\n      case (Nil, _) => ys.reverse ::: acc\n      case (_, Nil) => xs.reverse ::: acc\n      case (x :: xs1, y :: ys1) =>\n        if (less(x, y)) merge(xs1, ys, x :: acc)\n        else merge(xs, ys1, y :: acc)\n    }\n  val n = xs.length / 2\n  if (n == 0) xs\n  else {\n    val (ys, zs) = xs splitAt n\n    merge(msort(less)(ys), msort(less)(zs), Nil).reverse\n  }\n}                                                 //> msort: [T](less: (T, T) => Boolean)(xs: List[T])List[T]\n```\n\n\nI'm trying to define the comparison type of Tuple using : \n\n```\nval integerSorter = msort[((String, String), Double)]((a._2, b._2) => a._2 < b._2) _\n```\n\n\nBut I receive error : \n\n```\n<console>:1: error: not a legal formal parameter\n       val integerSorter = msort[((String, String), Double)]((a._2, b._2) => a._2 < b._2) _\n```\n\n\nHow can I define integerSorter so that it accepts a Tuple of type ```\n((String, String), Double)```\n ?\n    ", "Answer": "\r\nYou need to change your definition to:\n\n```\nval integerSorter = msort[((String, String), Double)]((a, b) => a._2 < b._2) _\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Need Advice on Multithreaded Merge Sort\r\n                \r\nBasically, if the number of lists in a merge sort is equal to the number of cores in the computer it will spawn a thread to sort each of the lists. It works currently but the problem that I'm facing is that it's actually taking longer to sort than the normal merge sort. It takes longer because instead of spawning lets say 4 threads at the same time, it's spawning a thread and it goes through its whole process before moving on to calling the next thread. Below is the code that I wrote, it works but again it goes slower because of the problem I stated above. If anyone has any familiarity with using threads in sorting algorithms any feedback would be greatly appreciated. FURTHERMORE, this is not homework, my project for class was to design a normal merge sort, I'm just trying to experiment around with the language and try different things. \n\n```\nvoid MergeSortThreading(int low, int high, int* source, int* destination, int count)\n{\nif (low == high)\n    return;\nint mid = (low + high) / 2;\nint start_1 = low, end_1 = mid, start_2 = (mid + 1), end_2 = high, dest = start_1;\n\nif (pow(2, count) == cores())\n{\n    thread* processes = new thread[cores()];\n    int j = 1;\n    for (int i = 0; i < cores(); i++)\n    {\n        processes[i] = thread(MergeSortThreading, j, (j + (high)), destination, source, 1000);\n        j += (high - 1);\n    }\n\n    for (int i = 0; i < cores(); i++)\n        processes[i].join();\n}\n\nMergeSortThreading(low, mid, destination, source, ++count);\nMergeSortThreading((mid + 1), high, destination, source, 150);\n\nwhile (start_1 <= end_1 && start_2 <= end_2)\n{\n    if (source[start_1] > source[start_2])\n        destination[dest++] = source[start_2++];\n    else\n        destination[dest++] = source[start_1++];\n}\n\nif (start_1 > end_1)\n{\n    for (; start_2 <= end_2; start_2++)\n    {\n        destination[dest] = source[start_2];\n        dest++;\n    }\n}\nelse\n{\n    for (; start_1 <= end_1; start_1++)\n    {\n        destination[dest] = source[start_1];\n        dest++;\n    }\n}\n```\n\n\n}\n    ", "Answer": "\r\nA very simple method to parallelize a recursion that splits into two at each step is with the following structure:\n\n```\nvoid recursive_function(int threads_to_use)\n{\n    if(threads_to_use == 1) {\n        recursive_function(1);\n        recursive_function(1);\n    } else {\n        int half = threads_to_use / 2;\n        thread th(recursive_function, half);\n        recursive_function(threads_to_use - half);\n        th.join();\n    }\n}\n```\n\n\nIt's not the ideal solution, but it is a decent one and relatively easy to tack onto an existing single-threaded design if the two calls can be done concurrently.\n\nIt might be better to use ```\nstd::async```\n to do asynchronous function calls rather than doing low-level thread creation if your C++ library provided a good implementation of it... but the ones I've used haven't really been all that useful (either creating too many threads or not doing multi-threading at all), so I can't really advise trying to learn to use it.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Sort array using merge sort\r\n                \r\nI am using merge sort for descending my array. What is the reason that my first element changed his value?\nMy half code works. But with my first and last elements something went wrong.\n```\n#include <iostream>\n\nvoid Merge(int a[], int low, int high, int mid)\n{\n    int i = low, j = mid + 1, k = 0;\n    int temp[high - low + 1];\n\n    while (i <= mid && j <= high) {\n        if (a[i] > a[j])\n            temp[k++] = a[i++];\n\n        else\n            temp[k++] = a[j++];\n    }\n\n    while (i <= mid) {\n        temp[k++] = a[i++];\n    }\n\n    while (j <= high) {\n        temp[k++] = a[j++];\n    }\n    for (i = low; i <= high; i++) {\n        a[i] = temp[i - low];\n    }\n    return;\n}\n\nvoid MergeSort(int a[], int low, int high)\n{\n    int mid;\n    if (low < high) {\n        mid = (low + high) / 2;\n        MergeSort(a, low, mid);\n        MergeSort(a, mid + 1, high);\n\n        Merge(a, low, high, mid);\n    }\n\n    return;\n}\n\nvoid output(int* a, int n)\n{\n    for (int i = 0; i < n; i++) {\n        std::cout << a[i] << \"\\t\";\n    }\n}\n\nint main()\n{\n    int n;\n    std::cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    MergeSort(a, 0, n);\n    output(a, n);\n}\n```\n\nThe output must be this.\ninput 10\n```\n1 2 3 4 5 6 7 8 9 10\n```\n\noutput\n```\n10 9 8 7 6 5 4 3 2 1\n```\n\nBut I'm getting this\noutput\n```\n4197055 10  9   8   7   6   5   4   3   2 \n```\n\nI'm a beginner in a c++. So I will be happy if you can help me to do my first steps here.\n    ", "Answer": "\r\nYou have mixed up how ranges of indexes are described. In same cases you have made those ranges closed at the end and in other opened at the end. Result is undefined behavior buffer overrun.\nHere is fixed version where ```\nlow```\n points to first element and ```\nhigh```\n point one step beyond last element.\nRemember that in C++ indexes of array ```\narr[n]```\n should be from ```\n0```\n to ```\nn - 1```\n inclusive.\n```\nvoid Merge(int a[], int low, int high, int mid)\n{\n    int i = low, j = mid, k = 0;\n    int temp[high - low];\n\n    while (i < mid && j < high) {\n        temp[k++] = a[i] < a[j] ? a[i++] : a[j++];\n    }\n\n    while (i < mid) {\n        temp[k++] = a[i++];\n    }\n\n    while (j < high) {\n        temp[k++] = a[j++];\n    }\n\n    for (i = low; i < high; i++) {\n        a[i] = temp[i - low];\n    }\n    return;\n}\n\nvoid MergeSort(int a[], int low, int high)\n{\n    int mid;\n    if (low + 1 < high) {\n        mid = (low + high) / 2;\n        MergeSort(a, low, mid);\n        MergeSort(a, mid, high);\n\n        Merge(a, low, high, mid);\n    }\n\n    return;\n}\n```\n\nhttps://godbolt.org/z/nET5YT\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Repeating the Same Numbers\r\n                \r\nI'm trying to rebrush up on my basic CS skills and trying to implement a simple merge sort algorithm. I can't figure out what I did wrong but the code is just saving the same numbers repeatedly. This is the output I get:\n\n\n\nI was using this site as a guide: http://geeksquiz.com/merge-sort/ which I confirmed does actually work properly (with a slight modification.) Anyone mind sharing any obvious bugs in my code that I couldn't catch?\n\n```\nvoid Merge(int arr[], int left, int right, int pivot)\n{\n\n    int leftCount = pivot - left + 1;\n    int rightCount = right - pivot;\n\n    int *leftSec = new int[leftCount];\n    int *rightSec = new int[rightCount];\n\n    for (int i = 0; i < leftCount; i++)\n    {\n        leftSec[i] = arr[left + i];\n    }\n    for (int j = 0; j < rightCount; j++)\n    {\n        rightSec[j] = arr[pivot + 1 + j];\n    }\n\n    int i = 0;\n    int j = 0;\n    int k = leftCount;\n    while(i < leftCount && j < rightCount)\n    {\n        if (leftSec[i] <= leftSec[j])\n        {\n            arr[k] = leftSec[i];\n            i++;\n        }\n        else\n        {\n            arr[k] = rightSec[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < leftCount)\n    {\n        arr[k] = leftSec[i];\n        i++;\n        k++;\n    }\n    while (j < rightCount)\n    {\n        arr[k] = rightSec[j];\n        j++;\n        k++;\n    }\n    delete[] leftSec;\n    delete[] rightSec;\n}\n\nvoid MergeSort(int arr[], int left, int right)\n{\n    if (left < right)\n    {\n        int pivot = (left + right) / 2;\n        MergeSort(arr, left, pivot);\n        MergeSort(arr, pivot + 1, right);\n        Merge(arr, left, right, pivot);\n    }\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int t;\n    int unsortedArray[] = { 94, 384, 934, 3, 56, 57, 94, 60, 90 };\n    int arrayLength = sizeof(unsortedArray) / sizeof(int);\n    printArray(unsortedArray, arrayLength);\n    MergeSort(unsortedArray, 0, arrayLength);\n    printArray(unsortedArray, arrayLength);\n    cin >> t;\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nYour code has many issues. It has a memory leak in function merge(): you use new, where is your delete ? Secondly the\n\n```\nwhile(j < rightCount) //this is never executed, you can double check this by drawing the mergesort tree and a perform the steps.\n```\n\n\nSorry for taking so long. Anyway here is your algorithm :) \n\n```\nvoid mergeTree(int* arr, int left, int mid, int right) {\n    //new arrays left and right\n\n\n\n    int* leftArr = new int[mid - left + 1];\n    int* rightArr = new int[right - mid];\n\n    //create a map between the new arrays 0...n where n = left counter/right counter and left...right\n    int leftCounter = mid - left + 1;\n    int rightCounter = right - mid;\n\n    int i = 0;\n    int j = left;\n    //copy the arrays\n    for(i = 0; i < leftCounter; i++) {\n        leftArr[i] = arr[j];\n        j++;\n    }\n    j = mid + 1;\n    for(i = 0; i < rightCounter; i++) {\n        rightArr[i] = arr[j];\n        j++;\n    }\n\n    i = 0;\n    j = 0;\n    int k = left;\n\n    while(i < leftCounter && j < rightCounter) {\n        if(leftArr[i] <= rightArr[j]) {\n            arr[k] = leftArr[i];\n            i++;\n        }\n        else {\n            arr[k] = rightArr[j];\n            j++;\n        }\n        k++;\n    }\n\n    while(i < leftCounter) {\n        arr[k] = leftArr[i];\n        i++;\n        k++;\n    }\n\n    delete[] leftArr;\n    delete[] rightArr;\n\n}\n\n void mergeSort(int* arr, int left, int right) {\n    if(left < right) {\n        int mid = (left + right) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        mergeTree(arr, left, mid, right);\n    }\n}\n\nmergesort(arr, 0, n-1)...\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort On Linked List in C\r\n                \r\nMerge sort is often preferred for sorting a linked list. The slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.\nI have been struggling to do Merge Sort on a linked list. It keeps throwing back an error. I'm providing the code I've tried to execute. Please do help me out.\nIt keeps giving runtime error.\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node {\n    int data;\n    struct node *next;\n};\n\nstruct node *SortedMerge(struct node *a, struct node *b); \nvoid FrontBackSplit(struct node *source, struct node *frontref, struct node *backref); \n\nstruct node *Create(struct node *head, int num) {\n    struct node *newnode, *temp;\n    newnode = (struct node *)malloc(sizeof(struct node));\n    newnode->data = num;\n    newnode->next = NULL;\n    if (head == NULL) {\n        head = newnode;\n        temp = newnode;\n    } else {\n        temp->next = newnode;\n        temp = temp->next;\n    }\n    temp->next = NULL; \n    return head;\n}\n\nstruct node *display(struct node *head) {\n    struct node *temp;\n    temp = head;\n    while (temp != NULL) {\n        printf(\"%d->\", temp->data);\n        temp = temp->next;\n    }\n    printf(\"NULL\");\n    return head;\n}\n\nstruct node *MergeSort(struct node *head) {\n    struct node *headref, *a, *b;\n    headref = head;\n    if ((head == NULL) || (head->next) == NULL) {\n        return;\n    }\n\n    FrontBackSplit(headref, a, b);\n\n    MergeSort(a);\n    MergeSort(b);\n\n    head = SortedMerge(a, b);\n    return head;\n}\n\nvoid FrontBackSplit(struct node *source, struct node *frontref, struct node *backref) {\n    struct node *fast, *slow;\n    slow = source;\n    fast = source->next;\n    while (fast != NULL) {\n        fast = fast->next;\n        if (fast != NULL) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n    }\n    frontref = source;\n    backref = slow->next;\n    slow->next = NULL;\n}\n\nstruct node *SortedMerge(struct node *a, struct node *b) {\n    struct node *result;\n    result = NULL;\n    if (a == NULL) {\n        return (b);\n    }\n    else if (b == NULL) {\n        return (a);\n    }\n\n    if (a->data <= b->data) {\n        result = a;\n        result->next = SortedMerge(a->next, b);\n    } else {\n        result = b;\n        result->next = SortedMerge(a, b->next);\n    }\n    return result;\n}\n\nint main() {\n    struct node *head = NULL;\n    int i, n, num;\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &num);\n        head = Create(head, num);\n    }\n    head = MergeSort(head);\n    display(head);\n}\n```\n\n    ", "Answer": "\r\nThere are a couple of problems with the code, and which one triggers the error you are seeing I cannot say, but I will point out a few of them below. Take ```\nCreate()```\n:\n```\nstruct node *Create(struct node *head, int num)\n{\n    struct node *newnode, *temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    newnode->data=num;\n    newnode->next=NULL;\n    if(head==NULL) {\n      head=newnode;\n      temp=newnode;\n    } else {\n      temp->next=newnode;\n      temp=temp->next;\n    }\n    temp->next=NULL; \n    return head;\n}\n```\n\nI cannot work out exactly what it is supposed to do, to be honest. Maybe add a new node to a list, represented by a head link? It doesn't do that. You create a new node\n```\n   newnode=(struct node *)malloc(sizeof(struct node));\n```\n\nwhich I would suggest you write as\n```\n   newnode = malloc(sizeof *newnode);\n```\n\nYou don't need to cast ```\nvoid *```\n, so you don't need to cast the result of ```\nmalloc()```\n, and using ```\nsizeof *newnode```\n rather than ```\nsizeof(struct node)```\n is safer. But the code works correctly in the form you have, so there is not a problem there. However, what happens with that node depends on ```\nhead```\n. If ```\nhead```\n is NULL, you point it at the new node, and through ```\ntemp```\n you (re)assign the new node's ```\nnext```\n to ```\nNULL```\n. So now you will return an updated ```\nhead```\n that consists of the new node as a single element list. That matches my guess at what the function should do.\nHowever, if ```\nhead```\n is not ```\nNULL```\n, you put the new node in ```\ntemp->next```\n, which is a problem, since ```\ntemp```\n isn't initialised. You write to ```\ntemp```\n in the ```\nif(head==NULL)```\n branch, but you dereference it in the ```\nelse```\n branch, where it can point anywhere. I am surprised if you don't get a segmentation fault from time to time here. It isn't necessary to assign the new node to ```\ntemp->next```\n, though, because immediately afterwards you change ```\ntemp```\n to point to ```\ntemp->next```\n, which is where you just put ```\nnewnode```\n, so ```\ntemp = newnode```\n would do the trick, without the segfault. But not all is well if we do that. We now would have the new node in ```\ntemp```\n (with the ```\nnext```\n pointer, again, reassigned to ```\nNULL```\n) and then we return ```\nhead```\n. We didn't connect ```\nhead```\n with ```\nnewnode```\n anywhere, if we took the ```\nelse```\n branch. So calling ```\nCreate()```\n with a non-```\nNULL```\n head creates a new node, throws it away (and leaking memory), and that is all that does.\nSo while my guess is that ```\nCreate()```\n should add a new to a list, represented by ```\nhead```\n, or something to that effect, what it actually does is create a single-element list if the first argument is ```\nNULL```\n, and leak ```\nsizeof(struct node)```\n memory while doing nothing if ```\nhead != NULL```\n.\nThat being said, the code might work by pure luck of course. When I tried it with ```\nclang```\n with zero optimisation, I somehow managed to build a list correctly. This is luck, though. It won't work in general. I suspect that what happens is that the repeated calls to ```\nCreate()```\n in the loop in ```\nmain()```\n happens to leave the last node you created (and wrote to ```\ntemp```\n) at the same stack location as the uninitialised ```\ntemp```\n in the next call. So by pure luck, putting the new node in ```\ntemp```\n's ```\nnext```\n appends the new node to the last node you created. It was really interesting working that one out :) But don't rely on this, of course. It is a combination of several lucky circumstances. Add optimisation flags, and the compiler will change the stack layout, and the code will break. Call other functions between successive calls to ```\nCreate()```\n and the stack will change, and then you don't have the last link on the stack any longer. And the code will break. It is a very unstable situation if this works at all.\nIf you just want to add a new node to a list, make a prepend function. Something like\n```\nstruct node *prepend(int val, struct node *list)\n{\n  struct node *n = malloc(sizeof *n);\n  if (n) {\n    n->data = val;\n    n->next = list;\n  }\n  return n;\n}\n```\n\n(I haven't tested it, so there might by syntax errors, but it will be something like that...you need to figure out what to do if ```\nmalloc()```\n fails, but you could just ```\nabort()```\n if you don't want to deal with it).\nThere is nothing wrong with ```\ndisplay()```\n, except that I don't understand why it is in lower-case when the other functions are in camel-case. You don't need ```\ntemp```\n, you can use ```\nhead```\n in the ```\nwhile```\n-loop, but that is a style choice. The function works as intended.\nWith ```\nMergeSort()```\n, however, we have another problem. I am surprised that your compiler didn't scream warnings at you here. It should really give you an error, with the right flags, but at the very least an error. When you test if the list is empty or a singleton, you ```\nreturn```\n, but not with a node. The function should return a ```\nstruct node *```\n, so just using ```\nreturn```\n will not give you anything useful.\n```\n  if((head==NULL) || (head->next)==NULL){\n    return;\n  }\n```\n\nIf the base case of the recursion returns garbage, obviously the whole recursion tumbles. Otherwise, assuming that the ```\nFrontBackSplit()```\n and ```\nSortedMerge()```\n work, the function looks okay. You don't need the extra ```\nheadref```\n variable, it is just a synonym for ```\nhead```\n, but there is nothing wrong with having it. The compiler will get rid of it for you. There isn't any need to assign the merged lists to ```\nhead```\n and then return ```\nhead```\n either. You can just return ```\nSortedMerge(a,b)```\n. But again, your compiler will handle that for you, once you turn on optimisation. Except for the base case, I believe the function should work.\nIn ```\nFrontBackSplit()```\n, I get the impression that you want to get the ```\nfrontref```\n and ```\n backref```\n values back to the caller. Otherwise, the function doesn't do anything. But when you are modifying the function parameters, you are not changing the variables in the caller's scope. You need to pass the two pointers by reference, which means that you need to use pointers to pointers. Change it to something like this:\n```\nvoid FrontBackSplit(struct node *source,\n                    struct node **frontref,\n                    struct node **backref)\n{\n  struct node *fast, *slow;\n  slow=source;\n  fast=source->next;\n  while(fast!=NULL) {\n    fast=fast->next;\n    if(fast!=NULL) {\n        slow=slow->next;\n        fast=fast->next;\n    }\n  }\n  *frontref=source;\n  *backref=slow->next;\n  slow->next=NULL;\n}\n```\n\nWhen you call the function, use the addresses of the parameters for the second and third argument, so use ```\nFrontBackSplit(headref,&a,&b);```\n instead of ```\nFrontBackSplit(headref,a,b);```\n.\nAs far as I can see, ```\nSortedMerge()```\n should work (with a modified ```\nFrontBackSplit()```\n). It is recursive, but not tail-recursive, so you might have problems with overflowing the stack for long lists. It isn't hard to make iterative, though.\nYou should make ```\nmain()```\n either ```\nint main(void)```\n or ```\nint main(int, char**)```\n. You should return 0 for success.\nMy guess is that one of three things are breaking your code. When you ```\nCreate()```\n your lists, you do not get the lists you want. In just the right circumstances, with just the right compiler and function call configurations, however, you might get lucky (and maybe that is what you have seen). In that case, it might be the ```\nreturn```\n in ```\nMergeSort()```\n. Return ```\nhead```\n instead, there, that is probably what you want. If you have an empty list or a list of length one, you should return that list. So change ```\nreturn;```\n to ```\nreturn head;```\n. And if it isn't that either, it is probably because you recurse on random data in ```\nMergeSort()```\n, because ```\na```\n and ```\nb```\n aren't initialised in the recursion. They are uninitialised when you call ```\nFrontBackSplit()```\n and the call doesn't change them, because they are passed by value and not reference. The change I listed above will fix that.\nThere might be more that I have overlooked, but at least those three issues are enough to break the code, each of them on their own, so it is a good place to start with debugging.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort on array of strings\r\n                \r\nI am trying to sort an array of strings using merge sort algorithm.I wrote this code and it works for arrays of integers but surprisingly for array of strings does not!It seems that it just sorts second part of array.I have no idea what piece is wrong in this code! I will be appreciated for your help.\n\n\n```\n\n\n#include <iostream>\n#include <list>\n#include <string>\nusing namespace std;\n\nvoid MergeSortA(int low , int high);\nvoid MergeA(int low ,int mid ,int high);\n\nstring currentArray[5];\nint main()\n{\n    for(int i = 0; i < 5; i++)\n        cin >> currentArray[i];\n\n    MergeSortA(0,4);\n\n    for(int i = 0; i < 5; i++)\n        cout << currentArray[i] <<endl;\n\n    return 0;\n}\n\nvoid MergeSortA(int low , int high)\n{\n    int mid = 0;\n    if(low < high)\n    {\n        mid = ((low+high)/2);\n        MergeSortA(low , mid);\n        MergeSortA(mid+1,high);\n        MergeA(low,mid,high);\n    }\n}\nvoid MergeA(int low ,int mid , int high)\n{\n    int i = low, j = mid+1 , k = low;\n    string Temp[5];\n\n    while(i <= mid && j <= high)\n    {\n        if( currentArray[i] < currentArray[j] )\n        {\n            Temp[k].assign(currentArray[i]);\n            i++;\n        }\n        else\n        {\n            Temp[k].assign(currentArray[j]);\n            j++;\n        }\n        k++;\n    }\n    if(i > mid )\n    {\n        for(int h = j ;h <= high ; h++ )\n        {\n            Temp[k].assign(currentArray[h]);\n            k++;\n        }\n    }\n    else\n        for(int h = i; h<= mid ; h++ )\n        {\n            Temp[k].assign(currentArray[h]);\n            k++;\n        }\n   for(int i = 0; i <= high ; i++)\n   {\n       currentArray[i].assign(Temp[i]);\n   }\n}\n```\n\n    ", "Answer": "\r\nYou need a correction while copying values back into currentArray from the Temp array:\n\n```\nfor(int i = low; i <= high ; i++) //copy from low to high\n   {\n       currentArray[i].assign(Temp[i]);\n   }\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort with four threads in C#?\r\n                \r\nI want to write a merge sort program in C# with four threads. In this program each thread has some numbers which are sorted in their threads. I will explain them with an example: first thread has 100 numbers. This thread sort those numbers with merge sort and then, pass them to second thread. Second thread, itself has 100 numbers and sort its numbers with the numbers that have been passed from the first thread. Again after sorting data in second thread all 200 numbers pass to third thread to sort this numbers with third thread's numbers and finally all numbers in fourth thread, are sorted with the fourth thread's numbers and the result is shown. I know in this scenario simple sequential sort method is probably faster than merge sort but I must do the sorting in this way for my school project and also this 100 numbers for each thread was only an example and in my project each thread has more than 100 numbers. I want to sort numbers with merge sort with four threads. I specially have problem in passing the numbers between threads. I'm a beginner in C# and if it's possible please help me with a code. Thanks.\n    ", "Answer": "\r\nFrom the scenario you explained, it seems like a sequential process. One thread waits for the outcome of other thread.\n\nBut what I guess that if you really want to sort suppose 100 numbers using 4 threads, then pass 25 numbers to each thread and call merge sort on each thread.\nWhen each thread is done sorting, at the end of 1st iteration you have 4 sorted array. Now pass 2 sorted arrays to each thread and call MERGE of merge sort on each thread. (AT this stage you are only using 2 threads only).\nOnce this merge is done, you are left with 2 sorted arrays.\nYou just can pass 2 sorted array to any thread and call MERGE (Not merge sort).\n\nI think if you google hard, you will get the solution online. \nhttp://penguin.ewu.edu/~trolfe/ParallelMerge/ParallelMerge.html\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java ArrayList merge sort algorithm\r\n                \r\nI'm having some issues with my merge sort algorithm in Java. It seems to be doing a lot of weird things now and I'm having trouble getting it to work. I believe the issue might lie somewhere in the ```\nmergeArrayLists```\n function, but I'm not sure. Any help would be appreciated!\n\n```\npublic class MergeSort extends Sort {\n\n   public MergeSort() {\n   }\n\n   // Inherited from Sort\n   public <T extends Comparable<T>> void sortArrayList(ArrayList<T> arrayList) {\n      arrayList = mergeSort(arrayList);\n   }\n\n   // Returns the sorted form of the given array list (sorted via the merge sort algorithm)\n   public <T extends Comparable<T>> ArrayList<T> mergeSort(\n         ArrayList<T> arrayList) {\n      if (arrayList.size() <= 1) {\n         return arrayList;\n      } else {\n         ArrayList<T> firstList = new ArrayList<T>();\n         ArrayList<T> secondList = new ArrayList<T>();\n\n         for (int i = 0; i < arrayList.size(); i++) {\n            T thisValue = arrayList.get(i);\n            if (i < arrayList.size() / 2) {\n               firstList.add(thisValue);\n            } else {\n               secondList.add(thisValue);\n            }\n         }\n         //System.out.println(firstList+\" \"+mergeSort(firstList));\n         ArrayList<T> firstSort = mergeSort(firstList);\n         ArrayList<T> secondSort = mergeSort(secondList);\n         return mergeArrayLists(firstSort, secondSort);\n      }\n   }\n\n   // Merges two array lists together, in order\n   public <T extends Comparable<T>> ArrayList<T> mergeArrayLists(\n         ArrayList<T> firstList, ArrayList<T> secondList) {\n      ArrayList<T> resultList = new ArrayList<T>();\n\n      int firstIndex, secondIndex = 0;\n      for (firstIndex = 0; firstIndex < firstList.size() - 1; firstIndex++) {\n         while (secondIndex < secondList.size() - 1) {\n            if (firstList.get(firstIndex)\n                  .compareTo(secondList.get(secondIndex)) < 0) {\n               break;\n            } else {\n               resultList.set(firstIndex + secondIndex,\n                     secondList.get(secondIndex));\n               secondIndex++;\n            }\n         }\n         resultList.set(firstIndex + secondIndex, firstList.get(firstIndex));\n      }\n      System.out.println(firstList + \" + \" + secondList + \" = \" + resultList);\n\n      return resultList;\n   }\n}\n```\n\n    ", "Answer": "\r\nYou have an off by one error. \n\n```\nfor(firstIndex=0; firstIndex<firstList.size(); firstIndex++) {\n    while(secondIndex < secondList.size()) {\n        if(firstList.get(firstIndex).compareTo( secondList.get(secondIndex) ) < 0) {\n            break;\n        }\n        else {\n            resultList.set(firstIndex + secondIndex, secondList.get(secondIndex));\n            secondIndex++;\n        }\n    }\n    resultList.set(firstIndex + secondIndex, firstList.get(firstIndex));\n}\n```\n\n\nYour lists should be index < size not size -1\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why Merge Sort time complexity is not O(N)?\r\n                \r\nMerge Sort time complexity is  O(n log n) so here n is dominate on logn , so  Is Merge-Sort is O(N) \n\nThanks\n    ", "Answer": "\r\n```\nO(n log n)```\n  is the best that you can get using tradional sort algorithms.  \n\nYou can't say that  ```\nO(n log n) == O(n)```\n even if  ```\nn```\n dominates ```\nlogn```\n because they are multiplying not adding. \n\nIf you got ```\nn + logn```\n and  ```\nn```\n dominates ```\nlogn```\n then you can say that ```\nO```\n is ```\nO(n)```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Multithreading the Merge Sort\r\n                \r\nI am trying to create a multithreaded version of the Merge Sort and I am using executors for that (pls let me know if there is any other better way). I want the two threads to run simultaneously. I am new to Executors and finding it difficult to code even after seeing some tutorials. Any method of parallelizing other than executors is of course most welcomed.\n\n```\npublic static void ASC(int[] input_array, int left, int right, int[] temp_array) // Sorts in ascending order\n{\n    if(left < right)\n    {\n        int middle = ( left + right )>>>1 ; // Same as (left + right)/2, but avoids overflow for large left and right and is probably faster\n\n    // I want to run these 2 codes in 2 threads simultaneously\n        ASC(input_array, left, middle, temp_array);\n        ASC(input_array, middle+1, right, temp_array);\n\n    // And I want the execution to stop here until the threads are finished\n    // I know invokeAll() will do the job but I cant seem to code it properly\n    // Pls tell me how to do it properly along with what classes to import as Im new to Executors.\n    // Any other method of parallelizing is most welcomed\n\n    // The part below is the Merge Procedure\n        int j = middle + 1;\n        int temp_indx = left;\n        int left2 = left;\n        while((left <= middle) && (j <= right))\n        {\n            if (input_array[left] < input_array[j])\n            {\n                temp_array[temp_indx] = input_array[left];\n                left = left + 1;\n            }\n            else\n            {\n                temp_array[temp_indx] = input_array[j];\n                j = j + 1;\n            }\n            temp_indx = temp_indx + 1;\n        }\n        while(left <= middle)\n        {\n            temp_array[temp_indx] = input_array[left];\n            left = left + 1;\n            temp_indx = temp_indx + 1;\n        }\n        while(j <= right)\n        {\n            temp_array[temp_indx] = input_array[j];\n            j = j + 1;\n            temp_indx = temp_indx + 1;\n        }\n        while(right >= left2)\n        {\n            input_array[right] = temp_array[right];\n            right = right - 1;\n        }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort recursion trouble\r\n                \r\nI've been trying to make a merge sort and I got the merging part down, it's just the recursive splitting that I'm having a little trouble with. The left and right lists are getting merged and sorted individually and not carrying over between each recursive pass. I'm not sure what I'm doing wrong with the recursion or how to fix it without scrapping the entire division method.\n```\npublic static int[] mergeSort(int[] x)\n{\n    divide(x);\n    return sorted;\n}\n\npublic static void divide(int[] x)\n{\n    int midP;\n    if((x.length/2f) == 1.5f) //the left side of the list will always be larger\n        midP = 2;\n    else \n        midP = x.length/2;\n\n    if(midP == 0) //if the list contains one number end\n        return;\n\n    System.out.println(\"mid: \" + midP);\n\n    int[] left = new int[midP];\n    int[] right = new int[x.length - midP];\n\n    for(int i = 0; i < midP; i++) //fills the left list\n        left[i] = x[i];\n\n    for(int i = midP; i < x.length; i++) //fills the right list\n        right[i-midP] = x[i];\n\n    divide(left);\n    divide(right);\n\n    sorted = merge(left, right);\n}\n\npublic static int[] merge(int[] x, int[] y)\n{\n    int[] mergedList = new int[x.length + y.length];\n\n    int counter = 0, xCounter = 0, yCounter = 0, high = 0;\n\n    while(xCounter < x.length && yCounter < y.length)\n    {\n        printArray(x);\n        printArray(y);\n        System.out.println(\"checking: \" + x[xCounter] + \" \" + y[yCounter]);\n        \n        if(x[xCounter] < y[yCounter])\n        {\n            mergedList[counter] = x[xCounter];\n            high = y[yCounter];\n            if(xCounter != x.length)\n                xCounter++;\n        }\n        else\n        {\n            mergedList[counter] = y[yCounter];\n            \n            high = x[xCounter];\n            \n            if(yCounter != y.length)\n                yCounter++;\n        }\n        counter++;\n    }\n    mergedList[counter] = high;\n    return mergedList;\n}\n\npublic static void printArray(int[] x)\n{\n    System.out.print(\"list: \");\n    for(int i = 0; i < x.length; i++)\n        System.out.print(x[i] + \" \");\n    System.out.println();\n}\n```\n\n    ", "Answer": "\r\nWhen using recursive methods, it's tricky to use static or instance variables like ```\nsorted```\n  in this case. What's happening is that ```\nsorted```\n gets set and reset over the recursive calls, and it can be difficult to predict what its value will be at any given time. Recursive functions are easier to understand if you only use local variables. So change your ```\ndivide```\n function so that it returns the sorted array, and use the return value from the recursive calls:\n```\npublic static int[] divide(int[] x) {\n    ... your existing divide logic ...\n\n    int[] leftSorted = divide(left);\n    int[] rightSorted = divide(right);\n\n    return merge(leftSorted, rightSorted);\n}\n```\n\nDon't forget to also change the main entry point:\n```\npublic static int[] mergeSort(int[] x) {\n    return divide(x);\n}\n```\n\nYou seem to still have a bug in the ```\nmerge```\n method:\n```\n    int[] x = {5, 4, 1, 2, 3};\n    int[] sorted = mergeSort(x);\n```\n\nresults in ```\n1 2 3 4 0```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Multithreading the Merge Sort\r\n                \r\nI am trying to create a multithreaded version of the Merge Sort and I am using executors for that (pls let me know if there is any other better way). I want the two threads to run simultaneously. I am new to Executors and finding it difficult to code even after seeing some tutorials. Any method of parallelizing other than executors is of course most welcomed.\n\n```\npublic static void ASC(int[] input_array, int left, int right, int[] temp_array) // Sorts in ascending order\n{\n    if(left < right)\n    {\n        int middle = ( left + right )>>>1 ; // Same as (left + right)/2, but avoids overflow for large left and right and is probably faster\n\n    // I want to run these 2 codes in 2 threads simultaneously\n        ASC(input_array, left, middle, temp_array);\n        ASC(input_array, middle+1, right, temp_array);\n\n    // And I want the execution to stop here until the threads are finished\n    // I know invokeAll() will do the job but I cant seem to code it properly\n    // Pls tell me how to do it properly along with what classes to import as Im new to Executors.\n    // Any other method of parallelizing is most welcomed\n\n    // The part below is the Merge Procedure\n        int j = middle + 1;\n        int temp_indx = left;\n        int left2 = left;\n        while((left <= middle) && (j <= right))\n        {\n            if (input_array[left] < input_array[j])\n            {\n                temp_array[temp_indx] = input_array[left];\n                left = left + 1;\n            }\n            else\n            {\n                temp_array[temp_indx] = input_array[j];\n                j = j + 1;\n            }\n            temp_indx = temp_indx + 1;\n        }\n        while(left <= middle)\n        {\n            temp_array[temp_indx] = input_array[left];\n            left = left + 1;\n            temp_indx = temp_indx + 1;\n        }\n        while(j <= right)\n        {\n            temp_array[temp_indx] = input_array[j];\n            j = j + 1;\n            temp_indx = temp_indx + 1;\n        }\n        while(right >= left2)\n        {\n            input_array[right] = temp_array[right];\n            right = right - 1;\n        }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort: Incorrect answer\r\n                \r\nI am trying to implement the Merge Sort algorithm as stated in the book \"Introduction To Algorithms\".\nThe output is incorrect although the implementation is as specified in the book.\nThere's a strong possibility of a off-by-one error, but I can't put my finger to it.\nAny pointers? \n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#define SENTINEL 32767\n\nint* getArray(int size) {\n    int* arr;\n    int i;\n\n    arr = (int*) malloc(sizeof(int) * size);\n\n    printf(\"\\nEnter %d elements:\\n\\n\", size);\n\n    for (i = 0; i < size; ++i) {\n        scanf(\"%d\", (arr + i));\n    }\n\n    printf(\"\\n\");\n\n    return arr;\n}\n\nvoid printArray(int* arr, int size) {\n    int i;\n    printf(\"Array[%d]: \", size);\n    for (i = 0; i < size; ++i) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nvoid merge(int* arr, int p, int q, int r) {\n    int i, j, k, n1, n2;\n    int* left;\n    int* right;\n\n    n1 = q - p;\n    n2 = r - q;\n\n    left  = (int*) malloc(sizeof(int) * (n1 + 1));\n    right = (int*) malloc(sizeof(int) * (n2 + 1));\n\n    left[n1] = right[n2] = SENTINEL;\n\n    for (i = 0; i < n1; ++i) {\n        left[i] = arr[p + i];\n    }\n\n    for (j = 0; j < n2; ++j) {\n        right[j] = arr[q + j];\n    }\n\n    i = j = 0;\n\n    for (k = p; k < r; ++k) {\n        if (left[i] <= right[j]) {\n            arr[k] = left[i++];\n        } else {\n            arr[k] = right[j++];\n        }\n    }\n\n}\n\nvoid mergeSort(int* arr, int p, int r) {\n    if (p < r) {\n        int q = (p + r) / 2;\n        mergeSort(arr, p, q);\n        mergeSort(arr, q + 1, r);\n        merge(arr, p, q, r);\n    }\n}\n\nint main() {\n    int* arr;\n    int size;\n\n    printf(\"Enter array size: \");\n    scanf(\"%d\", &size);\n\n    arr = getArray(size);\n    printArray(arr, size);\n\n    mergeSort(arr, 0, size);\n    printArray(arr, size);\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\n```\nmergeSort```\n must be in the following manner for the reasons already stated in the comments.\n\n```\nvoid mergeSort(int* arr, int p, int r) {\n    if (r - p > 1) {//for call(a, 0, 1) -> call(a, 0, 1)\n        int q = (p + r) / 2;\n        mergeSort(arr, p, q);\n        mergeSort(arr, q, r);\n        merge(arr, p, q, r);\n    }\n}\n```\n\n\nalso need ```\nfree(left);free(right);```\n and ```\nfree(arr);```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Stack overflow in merge sort\r\n                \r\nI have homework assignment to implement merge sort in C++ via recursion. I'm not really good at recursion and what follows is the code I implemented, but it gives a stackoverflow error.\nKindly tell me what I am doing wrong. EDITED VERSION\n\n```\n    #include<iostream>\nusing namespace std;\nvoid divide(int A[], int n);\nvoid sort();\nint main(){\n    int A[4]={2,3,0,5};\n    divide(A, 4);\n    for(int i =0 ;i<4;i++)\n        cout<<A[i]<<endl;\n    getchar();\n}\nvoid divide(int A[], int n){\n    if(n<=2 && n>=1){\n        for(int i=0; i<n; i++)\n                if(A[i]>A[i+1]){\n\n                int temp=A[i];\n                A[i]= A[i+1];\n                A[i+1]=temp;\n\n                }\n    }\n    else{\n    divide(A, n/2);\n    divide(A,(n/2)+1 );\n    }\n\n}\n```\n\n\nIn the code above, ```\nn```\n is the number of elements to sort and ```\nA```\n is the array I'm sorting.\n    ", "Answer": "\r\nCalling the below code with \n\n```\ndivide(A, 1);\n```\n\n\nShould illustrate the problem \n\n```\nvoid divide(int A[], int n){\n    if(n==2){ // first time n==1 so no, further calls are n==0 so also no.\n        for(int i=0; i<2; i++)\n            if(A[i]>A[i+1]){\n                int temp=A[i];\n                A[i]= A[i+1];\n            }\n    } else{\n        divide(A, n/2); // for both n==1 and n== 0 => n==0, calls divide(A, 0)\n        divide(A,(n/2)+1 ); // calls divide(A, 1) always \n    }\n}\n```\n\n\nSo the program will forever call divide(A, 0) until you run out of memory.\n\nTo stop this eternal recursion you need a correct stop condition\n\n```\nif (n<=2) {\n    // correct code for swapping 1 or 2 elements\n}  else\n```\n\n\nYou could also check for incorrect values of n, which is 0, negative and larger than length of A.\n\n\n\nLets say you have A[]= {1,2,3} so you call \n\n```\ndivide(A, 3);\n```\n\n\nNow in the else part of the program you need to split up A in to parts, N/2 elements and the rest.\n\n```\ndivide(A, n/2);\n```\n\n\nin our example this gives n/2 = 3/2 = 1 so\n\ndivide(A, 1);\n\nand starting in the element just after the n/2'th element\n\n```\ndivide(A+(n/2), n-(n/2));\n```\n\n\nthe first element is at A[0], so the remaining start at A[1] and contains n-(n/2)=3-(3/2)=3-1=2 elements.\n\nAnd now the first ```\nif```\n, it looks like a bubble-sort, but fails as it address an element beyond the end of the array.\n\n```\nif(n<=2 && n>=1){\n    for(int i=0; i<n; i++)\n        if(A[i]>A[i+1]) { \n```\n\n\nA[i+1] is beyond the end of the array for i=1 and n=2, n=2 => 2 elements at address A[0] and A[1] so A[i+1]=A[2] which is not part of the array A with length 2.\n\n```\n    for(int i=0; i<n-1; i++)\n```\n\n\nsolves that and also takes care of the case with n=1, which means the array contains only one element, which by definition is already sorted.\n\nNow if the algorithm was called divide-sort you would be finished, but you still are missing the merge part.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort recursion trouble\r\n                \r\nI've been trying to make a merge sort and I got the merging part down, it's just the recursive splitting that I'm having a little trouble with. The left and right lists are getting merged and sorted individually and not carrying over between each recursive pass. I'm not sure what I'm doing wrong with the recursion or how to fix it without scrapping the entire division method.\n```\npublic static int[] mergeSort(int[] x)\n{\n    divide(x);\n    return sorted;\n}\n\npublic static void divide(int[] x)\n{\n    int midP;\n    if((x.length/2f) == 1.5f) //the left side of the list will always be larger\n        midP = 2;\n    else \n        midP = x.length/2;\n\n    if(midP == 0) //if the list contains one number end\n        return;\n\n    System.out.println(\"mid: \" + midP);\n\n    int[] left = new int[midP];\n    int[] right = new int[x.length - midP];\n\n    for(int i = 0; i < midP; i++) //fills the left list\n        left[i] = x[i];\n\n    for(int i = midP; i < x.length; i++) //fills the right list\n        right[i-midP] = x[i];\n\n    divide(left);\n    divide(right);\n\n    sorted = merge(left, right);\n}\n\npublic static int[] merge(int[] x, int[] y)\n{\n    int[] mergedList = new int[x.length + y.length];\n\n    int counter = 0, xCounter = 0, yCounter = 0, high = 0;\n\n    while(xCounter < x.length && yCounter < y.length)\n    {\n        printArray(x);\n        printArray(y);\n        System.out.println(\"checking: \" + x[xCounter] + \" \" + y[yCounter]);\n        \n        if(x[xCounter] < y[yCounter])\n        {\n            mergedList[counter] = x[xCounter];\n            high = y[yCounter];\n            if(xCounter != x.length)\n                xCounter++;\n        }\n        else\n        {\n            mergedList[counter] = y[yCounter];\n            \n            high = x[xCounter];\n            \n            if(yCounter != y.length)\n                yCounter++;\n        }\n        counter++;\n    }\n    mergedList[counter] = high;\n    return mergedList;\n}\n\npublic static void printArray(int[] x)\n{\n    System.out.print(\"list: \");\n    for(int i = 0; i < x.length; i++)\n        System.out.print(x[i] + \" \");\n    System.out.println();\n}\n```\n\n    ", "Answer": "\r\nWhen using recursive methods, it's tricky to use static or instance variables like ```\nsorted```\n  in this case. What's happening is that ```\nsorted```\n gets set and reset over the recursive calls, and it can be difficult to predict what its value will be at any given time. Recursive functions are easier to understand if you only use local variables. So change your ```\ndivide```\n function so that it returns the sorted array, and use the return value from the recursive calls:\n```\npublic static int[] divide(int[] x) {\n    ... your existing divide logic ...\n\n    int[] leftSorted = divide(left);\n    int[] rightSorted = divide(right);\n\n    return merge(leftSorted, rightSorted);\n}\n```\n\nDon't forget to also change the main entry point:\n```\npublic static int[] mergeSort(int[] x) {\n    return divide(x);\n}\n```\n\nYou seem to still have a bug in the ```\nmerge```\n method:\n```\n    int[] x = {5, 4, 1, 2, 3};\n    int[] sorted = mergeSort(x);\n```\n\nresults in ```\n1 2 3 4 0```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort with ArrayList\r\n                \r\nI'm trying to implement a merge sort algorithm for an ArrayList as a parameter. As far as I can tell the code is working fine except for my if statement in the merge method. I'm receiving the error bad operand types for binary operator '<='. I'm sure it is because I have a two incompatible types being compared, but I have seemed to hit a wall figuring that out. Still, a learning student so any guidance or steering in the right direction would be extremely helpful.\n\nI got it to sort now correctly by the last name. Now I'm wondering what I would need to change to sort by first name or even the ID number. If I could get some guidance on how to tackle this I would appreciate it.\n\n```\nprivate static void sortListByID (List<Person> theList) {\n   if (theList.size() >= 2) {\n      List<Person> left  = new ArrayList<>();\n      left.addAll(theList.subList(0, theList.size()/2));\n      List<Person> right = new ArrayList<>();\n      right.addAll(theList.subList(theList.size()/2, theList.size()));\n\n      sortListByID(left);\n      sortListByID(right);\n      merge(theList, left, right);\n   }\n}\nprivate static void merge(List<Person> result, List<Person> left, \n      List<Person> right) {\n   int i1 = 0;\n   int i2 = 0;\n\n   for (int i = 0; i < result.size(); i++) {\n      if (i2 >= right.size() || (i1 < left.size() && \n            left.get(i1).compareTo(right.get(i2)) < 0)) {\n         result.set(i, left.get(i1));\n         i1++;\n      } else {\n        result.set(i, right.get(i2));\n        i2++;\n      }\n   }\n}\n```\n\n    ", "Answer": "\r\nYou probably should use ```\ncompareTo```\n instead of ```\n<=```\n which cannot be used with ```\nPerson```\n objects\n\n```\nleft.get(i1) <= right.get(i2)\n```\n\n\nbecomes\n\n```\nleft.get(i1).compareTo(right.get(i2)) < 0\n```\n\n\nMake sure the ```\nPerson```\n implements the ```\nComparable```\n interface for this method to work\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Sorting with Insertion Sort, Selection Sort, and Merge Sort\r\n                \r\nNow I am in grade 12 at high school taking a programming course in Java.  Now I have a test tomorrow, and I am trying to study.  The test is a practical test, and I have to take either primitive data or an object and sort them using Insertion Sort, Selection Sort, and Merge sort into either primitive data, an array, or an array list.  Now I have it bang down on primitive data.  It's just that I am having a really hard time on sorting objects into arrays and array lists.  I have selection sort down for arrays and array list, so it is just Merge sort and Insertions sort I am having dear trouble with.  I just don't get how to do it.\n\nThank you for your help in advance.\n\nTo simplify the question, I would like to know how to convert these two classes to sort objects named Circle\n\nMy first chunk of code here gets random circles and then feeds it into my other class to sort.  My last code block sorts it.\n\n```\npackage Merge_Sort_Objects_Array;\nimport java.util.Scanner;\nimport java.lang.Math;\n\npublic class TestSorts {\n    public static void displayArray(int[] array){\n        for (int i = 0; i < array.length; i++){\n            System.out.print(array[i] + \" \");\n        }\n            System.out.println(\"\\n\");\n        }\n\n        public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int numItems;\n        int[] test;\n\n        System.out.print(\"Enter number of elements: \");\n        numItems = input.nextInt();\n\n        /* populate array with random integers */\n        test = new int[numItems];\n        for (int i=0; i < test.length; i++){\n            test[i] = (int)(100 * Math.random());\n        }\n        System.out.println(\"Unsorted:\");\n        displayArray(test);\n\n        mergesort.mergesort(test, 0, test.length - 1);\n\n        System.out.println(\"Sorted: \");\n        displayArray(test);\n    }\n\n}\n\n\n\n\n\n  package Merge_Sort_Objects_Array;\n\n    public class mergesort {\n\n    /**\n     * Merges two sorted portion of items array\n     * pre: items[start.mid] is sorted.  items[mid+1.end] sorted.  start <= mid <= end\n     * post: items[start.end] is sorted\n     */\n\n    private static void merge(int[] items, int start, int mid, int end){\n            int[] temp = new int[items.length];\n            int pos1 = start;\n            int pos2 = mid + 1;\n            int spot = start;\n\n            while (!(pos1 > mid && pos2 > end)){\n                if ((pos1 > mid) || ((pos2 <= end) &&(items[pos2] < items[pos1]))){\n                    temp[spot] = items[pos2];\n                    pos2 +=1;\n                }else{\n                    temp[spot] = items[pos1];\n                    pos1 += 1;\n                }\n                spot += 1;\n            }\n            /* copy values from temp back to items */\n\n            for (int i = start;  i <= end; i++){\n                items[i] = temp[i];\n            }\n    }\n\n    /**\n     * mergesort items[start..end]\n     * pre: start > 0, end > 0\n     * post: items[start..end] is sorted low to high\n     */\n    public static void mergesort(int[] items, int start, int end){\n        if (start < end){\n            int mid = (start + end) / 2;\n            mergesort(items, start, mid);\n            mergesort(items, mid + 1, end);\n            merge(items, start, mid, end);\n        }\n    }\n}\n```\n\n\nIs that better?\n\nOkay Greg, here is the updated testSorts class.  Now I changed them all to Circle instead of int, however I still get that error where I identified earlier.  \n\n```\npublic class TestSorts {\n    public static void displayArray(Circle[] array){\n        for (int i = 0; i < array.length; i++){\n            System.out.print(array[i] + \" \");\n        }\n            System.out.println(\"\\n\");\n        }\n\n        public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int numItems;\n        Circle[] test;\n\n        System.out.print(\"Enter number of objects: \");\n        numItems = input.nextInt();\n\n        /* populate array with random integers */\n        test = new Circle[numItems];\n        for (int i=0; i < test.length; i++){\n            test[i] = new Circle((int)(10 * Math.random() + 1));\n        }\n        System.out.println(\"Unsorted:\");\n        displayArray(test);\n\n        mergesort.mergesort(test, 0, test.length - 1);\n\n        System.out.println(\"Sorted: \");\n        displayArray(test);\n    }\n\n}\n```\n\n\nDoes that help?\n    ", "Answer": "\r\nIt looks like there are two basic things you need to do to modify your existing sorting code to handle ```\nCircle```\n objects.\n\n\nChange the type ```\nint```\n to type ```\nCircle```\n in the array type of your sort methods (just the array type, not the indexes).\nDo something meaningful in place of ```\nitems[pos2] < items[pos1]```\n (since you can't compare objects with just ```\n<```\n). Perhaps for circles you want to sort by radius, so you could do ```\nitems[pos2].getRadius() < items[pos1].getRadius()```\n. But that's up to you.\n\n\nAs you learn more about generic programming, you will discover better ways to do this so that your existing code can apply to any suitable type of object without having to modify it each time you need to use it with a new type.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort worst case running time for lexicographic sorting?\r\n                \r\nA list of n strings each of length n is sorted into lexicographic order using the merge sort algorithm. The worst case running time of this computation is?\n\nI got this question as a homework. I know merge sort sorts in O(nlogn) time. For lexicographic order for length in is it n times nlogn ? or n^2 ?\n    ", "Answer": "\r\nEach comparison of the algorithm is ```\nO(n)```\n [comparing two strings is ```\nO(n)```\n worst case - you might detect which is \"bigger\" only on the last character], You have ```\nO(nlogn)```\n comparisons in mergesort. \n\nThus you get ```\nO(nlogn * n)  = O(n^2 * logn)```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why is my merge sort implementation in Java erring?\r\n                \r\nI am learning Java and algorithms at the same time. I implemented merge sort in this class.\n\n```\npublic class Sorter {\n    private void merge(int [] numbers, int low, int mid, int high) {\n            // create a new array that will contain the merged integers\n            int[] arrIntMerged = new int[high - low + 1];\n\n            // set indices\n            int i = low, j = mid + 1, k = 0;\n\n            // add the lesser integer into merged array\n            while (i <= mid && j <= high) {\n                if (numbers[i] < numbers[j]) {\n                    arrIntMerged[k] = numbers[i];\n                    i++;\n                } else {\n                    arrIntMerged[k] = numbers[j];\n                    j++;\n                }\n                k++;\n            }\n\n            // add anything left in the left side of the array\n            while (i <= mid) {\n                arrIntMerged[k] = numbers[i];\n                i++;\n                k++;\n            }\n\n            // add anything left in the right side of the array\n            while (j <= high) {\n                arrIntMerged[k] = numbers[j];\n                j++;\n                k++;\n            }\n\n            // write this newly created array into the positions in the original array\n            for (int l = 0; l < arrIntMerged.length; l++) {\n                numbers[l + low] = arrIntMerged[l];\n            }\n        }\n\n        // recursive implementation\n        private void _mergeSort(int[] numbers, int low, int high) {\n            if (low == high)\n                return;\n            else {\n                // find midpoint while preventing overflow\n                int mid = low + (high - low) / 2;\n                // sort left and right side\n                _mergeSort(numbers, low, mid);\n                _mergeSort(numbers, mid + 1, high);\n                // merge both sides\n                merge(numbers, low, mid + 1, high);\n            }\n        }\n\n        // friendly interface to begin merge sort\n        public void mergeSort(int[] numbers) {\n            _mergeSort(numbers, 0, numbers.length - 1);\n        }\n}\n```\n\n\nI then inspected this code in a scrapbook in Eclipse.\n\n```\nSorter sorter = new Sorter();\nint[] nums = {5, 6, 7, 8, 1, 2, 3, 4};\nsorter.mergeSort(nums);\nSystem.out.println(Arrays.toString(nums));\n```\n\n\nUnfortunately, standard output reads ```\n[2, 3, 4, 5, 6, 7, 8, 1]```\n, which is out of order. Why is my merge sort erring? I am pretty sure of my boundary conditions in ```\n_mergeSort```\n, so I suspect my ```\nmerge```\n function is awry.\n    ", "Answer": "\r\nYour problem comes from the following assignment in ```\nmerge```\n: \n\n```\nj = mid + 1\n```\n\n\n```\nmid```\n is already the index to the first number on the right side of the merge, this increment is making the rest of your merge logic start at the wrong array position. \n\nBecause it looks like you are learning, I won't spoil your experience by posting the actual code changes needed, but here a hint: check all the places where you compare things against the ```\nmid```\n value.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Incorrect output in a basic merge sort [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nTried to implement a merge sort, but getting the sort output incorrect...\n\nFor the input: 2 8 6 1 10 15 3 12 11\nGetting the output as: 12 11 15 3 12 11 15 3 8\n\nNot sure where the bug is... \n\nWould appreciate any help. Thanks\n\n```\ntemplate<class T>\nvoid merge(T data[], int left, int right, T temp[])\n{\n    int mid = (left+right)/2;\n    int l = left, r= mid+1, t=0;\n\n    while(l <= mid && r <= right)\n    {\n        if(data[l] < data[r])\n            temp[t++] = data[l++];\n        else\n            temp[t++] = data[r++];\n\n    }\n\n    while(l <= mid)\n        temp[t++] = data[l++];\n\n    while(r <= right)\n        temp[t++] = data[r++];\n\n    //copy it back\n    for(int i=0; i<(right-left+1); i++)\n        data[i] = temp[i];\n\n}\n\ntemplate<class T>\nvoid merge_helper(T data[], int first, int last, T temp[])\n{\n    if(first < last)\n    {\n        int mid = (first+last)/2;\n        merge_helper(data, first, mid, temp);\n        merge_helper(data, mid+1, last, temp);\n        merge(data, first, last, temp);\n\n    }\n\n}\n\n\n// merge sort\n\ntemplate<class T>\nvoid mergesort(T data[], int size)\n{\n    T *temp = (T*)malloc(sizeof(T)*size);\n    merge_helper(data, 0, size-1, temp);\n}\n```\n\n    ", "Answer": "\r\n```\n//copy it back\nfor(int i=0; i<(right-left+1); i++)\n data[i] = temp[i];\n```\n\n\npossible problem here when you are copying it back into the original array, you always start from zero, you must copy it back from the left element to the right element.\n\ntry this \n\n```\nfor(int i = left,k=0; i<=right;i++,k++)\ndata[i] = temp[k];\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Unusual Merge Sort Failure\r\n                \r\nI have an unusual problem. I've been implementing Merge Sort and have encountered the following: The method works correctly except on the last pass. Given a random ```\nInteger```\n array as input returns an ```\nInteger```\n array where the first half and the second half are sorted separately. The merge works correctly except on the last pass. After fiddling with the debugger for a few hours I figured out that \"mention point\" is always evaluating to ```\nfalse```\n on the last pass, even though it shouldn't based on the values.\n\nAll help is appreciated.\n\n```\npublic static Integer[] mergeSort(Integer[] input)\n{\n    if (input.length == 1) return input;\n\n    int splittle = input.length / 2;\n\n    Integer[] first = new Integer[splittle];\n    Integer[] second = new Integer[input.length - splittle];\n\n    for (int i = 0; i < splittle; i++)\n        first[i] = input[i];\n    for (int i = splittle; i < input.length; i++)\n        second[i - splittle] = input[i];\n\n    mergeSort(first);\n    mergeSort(second);\n\n    LinkedList<Integer> returner = new LinkedList<Integer>();\n\n    PriorityQueue<Integer> sFirst = new PriorityQueue<Integer>();\n    PriorityQueue<Integer> sSecond = new PriorityQueue<Integer>();\n\n    for (int i = 0; i < first.length; i++)\n        sFirst.offer(first[i]);\n    for (int i = 0; i < second.length; i++)\n        sSecond.offer(second[i]);\n\n    // while (!sFirst.isEmpty()&&!sSecond.isEmpty())\n    // returner.add((sFirst.peek()>=sSecond.peek() ?\n    // sFirst.poll():sSecond.poll()));\n\n    // expansion of line above for debugging purposes\n\n    while (!sFirst.isEmpty() && !sSecond.isEmpty())\n    {\n        int temp = 0;\n\n        if (sFirst.peek() >= sSecond.peek())\n            temp = sFirst.poll(); // Mention point\n        else\n            temp = sSecond.poll();\n        returner.add(temp);\n\n    }\n\n    while (!sFirst.isEmpty())\n        returner.add(sFirst.poll());\n    while (!sSecond.isEmpty())\n        returner.add(sSecond.poll());\n\n    return returner.toArray(new Integer[0]);\n}\n```\n\n    ", "Answer": "\r\nThe problem is inside your ```\nwhile```\n code, and more specific when you use the ```\npoll()```\n method.\n\nYou had:\n\n```\nif (sFirst.peek() >= sSecond.peek())\n    temp = sFirst.poll(); // Mention point\nelse\n    temp = sSecond.poll();\n```\n\n\nwhen you should had:\n\n```\nif (sFirst.peek() >= sSecond.peek())\n    temp = sSecond.poll(); // Mention point\nelse\n    temp = sFirst.poll();\n```\n\n\nBefore, in an input like this:\n\n```\nsFirst = [-9, 1, 2, 9, 89] and  sSecond =  [4, 15, 18, 23, 31, 123]\n```\n\n\nyou would have ```\nif (-9 >= 4)```\n which would be false, so you would do the ```\nelse```\n part, which would ```\npoll()```\n from ```\nsSecond```\n although you should ```\npoll()```\n from ```\nsFirst```\n. ```\n-9```\n should be the first element to be added in the ```\nreturner```\n list, not ```\n4```\n.\n\nAlso (based on ccoakley answer) change, you should use the returned array from ```\nmergeSort()```\n, which can be done easily by:\n\n```\nfirst = mergeSort(first);\nsecond = mergeSort(second);\n```\n\n\nYou can have a look of the working code (after the changes) here.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Python - Merge Sort Recursive Algorithm\r\n                \r\nI was trying to implement this pseudocode for the recursive merge sort algorithm:\n\n```\n**procedure**  *mergesort*(L = a1, a2,…,an )\n**if**  n  > 1 **then** \n     m := ⌊n/2⌋\n     L1 := a1, a2,…,am \n     L2 := am+1, am+2,…,an\n     L   := merge(mergesort(L1), mergesort(L2 ))\n{L is now sorted into elements in increasing order}\n\n**procedure**  *merge*(L1, L2 :sorted lists)\nL := empty list\n**while** L1  and L2  are both nonempty\n remove smaller of first elements of L1 and L2 from its list; \n         put at the right end of L\n **if** this removal makes one list empty \n     **then** remove all elements from the other list and append them to L\nreturn L {L is the merged list with the elements in increasing order}\n```\n\n\nThe purpose its to write it on python, so far I have coded all of it but it does not run properly, everytime I run it prints: function merge at 0x0000000002024730. Here is the python code:\n\n```\n#Recursive Merge Sort\nimport math\nent = [10000, 967, 87, 91, 117, 819, 403, 597, 1201, 12090]\ndef merge(L1, L2):\n\n        while len(L1) and len(L2) != 0:\n            L.append(L1[0])\n            L1.remove(L1[0])\n            L.append(L2[0])\n            L2.remove(L2[0])\n            if len(L1) == 0:\n                L.append(L2)\n            elif len(L2) == 0:\n                L.append(L1)\n        return L\n\n\ndef mergesort(ent):\n\nif len(ent)>1:\n    m=math.floor(len(ent)/2)\n    L1 = []\n    L2 = []\n    L1=L1+ent[:m]\n    L2=L2+ent[m+1:len(ent)]\n    L=merge(mergesort(L1),mergesort(L2))\n\n\n\n\nprint(merge)\n```\n\n\nI have some doubts about how the functions are supossed to work recursively together, which is why I think I cant solve and code it right. Any help or suggestions?\n    ", "Answer": "\r\nYou're not executing ```\nmerge```\n, but printing the function itself. Do this:\n\n```\nprint(merge())\n```\n\n\nHowever, your logic is a bit messed up, you don't even have a recursive function there.\n\nTake a look at this question\n\nAlso, i think what you need is to call mergesort:\n\n```\ndef mergesort(ent):\n    if len(ent)>1:\n        m=math.floor(len(ent)/2)\n        L1 = ent[:m]\n        L2 = ent[m+1:len(ent)]\n        L=merge(mergesort(L1),mergesort(L2))\nreturn L\n```\n\n\nAnd execute it:\n\n```\nprint(mergesort(ent))\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Wrong output when i run with this Merge sort code\r\n                \r\nI have implemented merge sort algorithm. I debugged the code properly.\n but not able to identify what is the problem with my code.\nHere is my code :\n\n```\n#include<iostream>\nusing namespace std;\nvoid merge(int* l,int nL,int* r,int nR,int * a){\n    //merging the arrays\n    int i=0,j=0,k=0;\n    while(i<nL && j<nR){\n        if(l[i]<=r[j]){\n            i++;\n            a[k]=l[i];\n        }\n\n        else{\n            j++;\n            a[k]=r[j];\n        }\n        k++;\n    }\n    //now elements that are left out\n    while(i<nL){\n        a[k]=l[i];\n        k++;\n        i++;\n    }\n    while(j<nR){\n        a[k]=r[j];\n        j++;\n        k++;\n    }\n}\n```\n\n\nThis is my mergeSort function to implement the merge sort algorithm.\n\n```\nvoid mergeSort(int* a,int n){\n    //base case\n    if(n<2)\n        return;\n    //rec case\n    int mid=n/2;\n    //take 2 arrays of size mid & (n-mid)\n    int nL=mid;\n    int nR=n-mid;\n    int l[nL];\n    int r[nR];\n    //fill the arrays\n    for(int i=0;i<mid;i++){\n        l[i]=a[i];\n    }\n    for(int i=mid;i<n;i++){\n        r[i-mid]=a[i];\n    }\n    //call merge sort recursively\n    mergeSort(l,nL);\n    mergeSort(r,nR);\n    merge(l,nL,r,nR,a);\n}\n```\n\n\nHere is the main function where I am taking an array as input and passing to the function mergeSort\n\n```\nint main(){\n    int a[100];\n    cout<<\"Enter no of elements\"<<endl;\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    mergeSort(a,n);\n    cout<<\"After sorting with merge sort\"<<endl;\n    for(int i=0;i<n;i++){\n        cout<<a[i]<<\" \";\n    }\n\n    return 0;\n}\n```\n\n\nFunction merge() is merging two arrays and mergeSort is the function to divide the array and implement the merge sort.\n\nI am giving this as input :\n\n```\n8\n2 4 1 6 8 5 3 7\n```\n\n\nOutput : \n\n```\n6 1006565088 2096014825 6 2098806136 2096014825 93 8 \n```\n\n    ", "Answer": "\r\nIssue is because Value of ```\ni```\n and ```\nj```\n is incrementing before the value is assigned to left and right arrays, in function merge.\nThe while loop should be:\n\n```\nwhile(i<nL && j<nR){\n        if(l[i]<=r[j]){\n\n            a[k]=l[i];\n            i++;  //here was the mistake.\n        }\n\n        else{\n\n            a[k]=r[j];\n            j++;  // here was the mistake\n        }\n        k++;\n    }\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to call merge sort\r\n                \r\nThe code below is based on Merge sort from \"Programming Scala\" causes stack overflow\n\n```\n  def msort[T](less: (T, T) => Boolean)(xs: List[T]): List[T] = {\n\n    def merge(xs: List[T], ys: List[T], acc: List[T]): List[T] =\n      (xs, ys) match {\n        case (Nil, _) => ys.reverse ::: acc\n        case (_, Nil) => xs.reverse ::: acc\n        case (x :: xs1, y :: ys1) =>\n          if (less(x, y)) merge(xs1, ys, x :: acc)\n          else merge(xs, ys1, y :: acc)\n      }\n    val n = xs.length / 2\n    if (n == 0) xs\n    else {\n      val (ys, zs) = xs splitAt n\n      merge(msort(less)(ys), msort(less)(zs), Nil).reverse\n    }\n\n  }\n```\n\n\nWhen I try to invoke msort using : \n\n```\n  val l = List(5, 2, 4, 6, 1, 3)\n  msort[Int](l)\n```\n\n\nI receive error : \n\n```\nMultiple markers at this line - type mismatch; found : List[Int] required: (Int, Int) => Boolean - type mismatch; \n found : List[Int] required: (Int, Int) => Boolean - missing arguments for method msort in object mergesort; follow \n this method with `_' if you want to treat it as a partially applied function\n```\n\n\nHow do I invoke msort & why is a function required as part of the invocation ?\n    ", "Answer": "\r\nIn Scala it is possible to have Multiple Parameters Lists. Your invocation only passes one argument.\n\nThe method is declared as ```\ndef msort[T](less: (T, T) => Boolean)(xs: List[T]): List[T]```\n, so the first argument is of type ```\n(T, T) => Boolean```\n, which is a function taking two parameters of type ```\nT```\n and returning a ```\nBoolean```\n value. You pass there a ```\nList[Int]```\n, which makes Scala complain.\n\nWhy would you like to have such a thing you may ask. Well, consider following example.\n\n```\nval stringSorter = msort[String]((a, b) => a.compareTo(b) < 0) _\n// stringSorter: List[String] => List[String] = <function1>\n\nval integerSorter = msort[Int]((a, b) => a < b) _\n// integerSorter: List[Int] => List[Int] = <function1>\n```\n\n\nThose two invocation create two new functions taking only a single parameter - the list you want to sort. You don't have to tell it how to compare the elements, because you already did. Note you can invoke the same function with different lists as an argument.\n\n```\nintegerSorter(List(2, 3, 1))\n// res0: List[Int] = List(1, 2, 3)\n\nintegerSorter(List(2, 4, 1))\n// res1: List[Int] = List(1, 2, 4)\n\nstringSorter(List(\"b\", \"a\", \"c\"))\nres3: List[String] = List(a, b, c)\n```\n\n\nNote also that the newly created functions are type safe and following code will fail:\n\n```\nintegerSorter(List(\"b\", \"a\", \"c\"))\n<console>:10: error: type mismatch;\n found   : String(\"b\")\n required: Int\n              integerSorter(List(\"b\", \"a\", \"c\"))\n```\n\n\nImplicit Parameters\n\nAs the article in the link mentioned one of the reasons you may want to use Multiple Parameter Lists are implicit parameters.\n\n\n  When using implicit parameters, and you use the implicit keyword, it\n  applies to the entire parameter list. Thus, if you want only some\n  parameters to be implicit, you must use multiple parameter lists.\n\n\nLet's modify the example code you gave us a bit to introduce a new type:\n\n```\ntrait Comparator[T] {\n  def less(a: T, b: T): Boolean\n}\n```\n\n\nand let's swap the parameter lists, and add ```\nimplicit```\n keyword to the second one, so now it becomes:\n\n```\ndef msort[T](xs: List[T])(implicit c: Comparator[T]): List[T] = {\n\n    def merge(xs: List[T], ys: List[T], acc: List[T]): List[T] =\n      (xs, ys) match {\n        case (Nil, _) => ys.reverse ::: acc\n        case (_, Nil) => xs.reverse ::: acc\n        case (x :: xs1, y :: ys1) =>\n          if (c.less(x, y)) merge(xs1, ys, x :: acc)\n          else merge(xs, ys1, y :: acc)\n      }\n    val n = xs.length / 2\n    if (n == 0) xs\n    else {\n      val (ys, zs) = xs splitAt n\n      merge(msort(ys)(c), msort(zs)(c), Nil).reverse\n    }\n\n}\n```\n\n\nNow you can declare implicit object which will be used in case you don't supply one, e.g.\n\n```\nimplicit val intComparator = new Comparator[Int] { def less(a: Int, b: Int) = a < b }\n\nmsort(List(5, 3, 1, 3))\n// res8: List[Int] = List(1, 3, 3, 5)\n```\n\n\nWhile this may not seem to be very appealing it gives you extra flexibility when designing your API. Let's assume that we have a type called ```\nCustomType```\n. It can declare an implicit in the companion object and it will be resolved \"automatically\" by the compiler.\n\n```\ncase class CustomType(ordinal: Int, name: String)\n\nobject CustomType {\n  implicit val customTypeComparator = new Comparator[CustomType] { \n    def less(a: CustomType, b: CustomType) = a.ordinal < b.ordinal \n  }\n}\n\n\nmsort(List(CustomType(2, \"Second\"), CustomType(1, \"First\")))\n// res11: List[CustomType] = List(CustomType(1,First), CustomType(2,Second))\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort function [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI'm trying to come up with an algorithm that recursively calls the merge sort function using the same parameters as the qsort function that is defined in the C library. However, although my values print out, they are not in order. Can somebody take a look at my function and tell me how to correct this? I'm also including the compare function that i used. thanks in advance\n\n```\n  int cmp (const void *first, const void *second)\n    {  \n        if (first < second)\n            return -1;\n        else if (first > second)\n            return 1;\n        else\n            return 0;\n    }\n\n\n\n    static void msort (void *b,size_t n,size_t s, int(*cmp)(const void*,const void*) )\n\n    {\n        char *tmp;\n\n        void *t;\n        if ((t = malloc(s*n)) == NULL)\n        {\n            printf(\"\\nError: No Memory.\");\n            return;\n        }   \n        char *b1, *b2;\n        size_t n1, n2;\n\n\n\n        n1 = n / 2;\n        n2 = n - n1;\n        b1 = b;\n        b2 = (char *) b + (n1 * s);\n\n        if (n2 <= n1)\n            return;\n\n        msort (b1, n2, s, cmp);\n        msort (b2, n1+1, s, cmp);\n\n        tmp = t;\n\n        while (n1 > 0 && n2 > 0)\n        {\n            if ((*cmp) (b1, b2) <= 0)\n            {\n                memcpy (tmp, b1, s);\n                tmp += s;\n                b1 += s;\n                --n1;\n            }\n            else\n            {\n                memcpy (tmp, b2, s);\n                tmp += s;\n                b2 += s;\n                --n2;\n            }\n        }\n        if (n1 > 0)\n            memcpy (tmp, b1, n1 * s);\n        memcpy (b, t, (n - n2) * s);\n    } \n```\n\n\nhere's my main. i left out some functions that you see here.\n\n```\nint main()\n{\n    int n;\n    int *a, *b, *c;\n\nprintf(\"enter n: \");\nif(scanf(\"%d\", &n) != 1 || n < 10)\n{\n    fprintf(stderr, \"bad input.  goodbye\\n\");\n    abort();\n}\n\nprintf(\"sizeof(double) %d\\n\", sizeof(double) );\n\nprintf(\"running experiments with n=%d\\n\", n);\n\na = gen_int_array(n, 5000);\n//b = clone_int_array(a, n);\nc = clone_int_array(a, n);\n\n\n//ssort(a, n);\n//isort(b, n);\n//msort_int(c, n);\n\n//msort_int(d, n);\nmsort (c, n, sizeof(int), cmp );\n\n\n\nif(n<50)\ndump_int_array(c, n);\n\nfree(a);\nfree(b );\nfree(c);\n```\n\n\n}\n    ", "Answer": "\r\nOne problem is your compare function; it is comparing the two pointers, that's all — not the values that are pointed at.  Since you don't show us the definition of the array that you're merge sorting, we can't easily help much more.  However, supposing that you're sorting an array of ```\nint```\n, then the comparator might be:\n\n```\nint comparator(void const *v1, void const *v2)\n{\n    int i1 = *(int *)v1;\n    int i2 = *(int *)v2;\n    if (i1 < i2)\n        return -1;\n    else if (i1 > i2)\n        return +1;\n    else\n        return 0;\n}\n```\n\n\nNote that this formulation avoids arithmetic overflow and other such undefined behaviour.  It is also a decent template for comparing structures and other more complex values; you can add more of the pairs of ```\n<```\n and ```\n>```\n tests until you've no more criteria for separating two values.\n\nWe can also observe that there's definitively a memory leak in your code.  You allocate an array inside the function, but you do not release it or return a pointer to it.\n\n\n\nSSCCE with original ```\nmsort()```\n and ```\ncomparator()```\n\n\nAn SSCCE is a Short, Self-Contained, Correct Example.\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic int comparator(void const *v1, void const *v2)\n{\n    int i1 = *(int *)v1;\n    int i2 = *(int *)v2;\n    if (i1 < i2)\n        return -1;\n    else if (i1 > i2)\n        return +1;\n    else\n        return 0;\n}\n\nstatic void sort_check(int *array, size_t n)\n{\n    size_t fail = 0;\n\n    for (size_t i = 1; i < n; i++)\n    {\n        if (array[i-1] > array[i])\n        {\n            fprintf(stderr, \"Elements %zu (value %d) and %zu (value %d) are out of order\\n\",\n                    i-1, array[i-1], i, array[i]);\n            fail++;\n        }\n    }\n    if (fail != 0)\n        exit(1);\n}\n\nstatic void msort(void *b, size_t n, size_t s, int(*cmp)(const void*, const void*) )\n{\n    char *tmp;\n    void *t;\n\n    if ((t = malloc(s*n)) == NULL)\n    {\n        fprintf(stderr, \"Error: No Memory.\\n\");\n        return;\n    }\n\n    char *b1, *b2;\n    size_t n1, n2;\n\n    n1 = n / 2;\n    n2 = n - n1;\n    b1 = b;\n    b2 = (char *) b + (n1 * s);\n\n    if (n2 <= n1)\n        return;\n\n    msort (b1, n2, s, cmp);\n    msort (b2, n1+1, s, cmp);\n\n    tmp = t;\n\n    while (n1 > 0 && n2 > 0)\n    {\n        if ((*cmp) (b1, b2) <= 0)\n        {\n            memcpy (tmp, b1, s);\n            tmp += s;\n            b1 += s;\n            --n1;\n        }\n        else\n        {\n            memcpy (tmp, b2, s);\n            tmp += s;\n            b2 += s;\n            --n2;\n        }\n    }\n    if (n1 > 0)\n        memcpy (tmp, b1, n1 * s);\n    memcpy (b, t, (n - n2) * s);\n}\n\nstatic int *gen_int_array(size_t n, int max_val)\n{\n    int *a = malloc(n * sizeof(*a));\n    if (a == 0)\n    {\n        fprintf(stderr, \"Out of memory.\\n\");\n        exit(1);\n    }\n    for (size_t i = 0; i < n; i++)\n        a[i] = rand() % max_val;\n    return(a);\n}\n\nstatic int *clone_int_array(int *master, size_t n)\n{\n    int *a = malloc(n * sizeof(*a));\n    if (a == 0)\n    {\n        fprintf(stderr, \"Out of memory.\\n\");\n        exit(1);\n    }\n    for (size_t i = 0; i < n; i++)\n        a[i] = master[i];\n    return(a);\n}\n\nstatic void dump_array(FILE *fp, char const *tag, int *a, size_t n)\n{\n    char const *pad = \"\";\n    fprintf(fp, \"Array: %s (size %zu)\\n\", tag, n);\n    for (size_t i = 0; i < n; i++)\n    {\n        fprintf(fp, \"%s%d\", pad, a[i]);\n        pad = \",\";\n    }\n    putc('\\n', fp);\n}\n\nint main(int argc, char **argv)\n{\n    int n;\n    int *a, *b;\n\n    if (argc == 1)\n        n = 10;\n    else\n        n = atoi(argv[1]);\n    if (n <= 0)\n        n = 10;\n\n    printf(\"running experiments with n = %d\\n\", n);\n\n    a = gen_int_array(n, 5000);\n    b = clone_int_array(a, n);\n\n    dump_array(stdout, \"Unsorted\", a, n);\n\n    printf(\"Q-Sort\\n\");\n    qsort(a, n, sizeof(int), comparator);\n    dump_array(stdout, \"Q-sorted\", a, n);\n    sort_check(a, n);\n\n    printf(\"M-Sort\\n\");\n    msort(b, n, sizeof(int), comparator);\n    dump_array(stdout, \"M-sorted\", b, n);\n    sort_check(b, n);\n\n    free(a);\n    free(b);\n\n    return(0);\n}\n```\n\n\nThe output for this (with no arguments, on Mac OS X 10.7.5) is:\n\n```\nrunning experiments with n = 10\nArray: Unsorted (size 10)\n1807,249,73,3658,3930,1272,2544,878,2923,2709\nQ-Sort\nArray: Q-sorted (size 10)\n73,249,878,1272,1807,2544,2709,2923,3658,3930\nM-Sort\nArray: M-sorted (size 10)\n1807,249,73,3658,3930,1272,2544,878,2923,2709\nElements 0 (value 1807) and 1 (value 249) are out of order\nElements 1 (value 249) and 2 (value 73) are out of order\nElements 4 (value 3930) and 5 (value 1272) are out of order\nElements 6 (value 2544) and 7 (value 878) are out of order\nElements 8 (value 2923) and 9 (value 2709) are out of order\n```\n\n\nAs you can see, the ```\nqsort()```\n gets the data in the correct order.  The ```\nmsort()```\n does not change the order of anything.  The test harness isn't set up to manage 0 rows of data, but running ```\nmsort 1```\n gets a core dump from the ```\nmsort()```\n function.  It's always a bad sign when a degenerate case fails with a segmentation fault.  \n\nThe size 1 problem (and size 0) is fixed by checking ```\nn```\n on entry to ```\nmsort()```\n and returning if ```\nn <= 1```\n.\n\nThe next problem is the condition where ```\nif (n2 <= n1)```\n; it returns early.  Indeed, that condition always fires for an even value of ```\nn```\n; when you start with an odd value of ```\nn```\n, the recursion generates an even value, and the early return kicks in.  Thus, the sorting never happens.  This is the (partially) instrumented version of the function that demonstrates this behaviour:\n\n```\nstatic void msort(void *b, size_t n, size_t s, int (*cmp)(const void *v1, const void *v2) )\n{\n    if (n <= 1)\n        return;     /* Already sorted */\n\n    printf(\"-->> msort(%zu)\\n\", n);\n    void *t = malloc(s*n);\n\n    if (t == NULL)\n    {\n        fprintf(stderr, \"Error: No Memory.\\n\");\n        printf(\"<<-- msort(%zu)\\n\", n);\n        return;\n    }\n\n    size_t n1 = n / 2;\n    size_t n2 = n - n1;\n\n    if (n2 <= n1)\n    {\n        fprintf(stderr, \"Oops: %zu <= %zu\\n\", n2, n1);\n        free(t);\n        printf(\"<<-- msort(%zu)\\n\", n);\n        return;\n    }\n\n    char *b1 = b;\n    char *b2 = (char *) b + (n1 * s);\n\n    msort(b1, n2, s, cmp);\n    msort(b2, n1+1, s, cmp);\n\n    char *tmp = t;\n\n    while (n1 > 0 && n2 > 0)\n    {\n        if ((*cmp)(b1, b2) <= 0)\n        {\n            memcpy(tmp, b1, s);\n            tmp += s;\n            b1 += s;\n            --n1;\n        }\n        else\n        {\n            memcpy(tmp, b2, s);\n            tmp += s;\n            b2 += s;\n            --n2;\n        }\n    }\n    if (n1 > 0)\n        memcpy(tmp, b1, n1 * s);\n    memcpy(b, t, (n - n2) * s);\n    free(t);\n    printf(\"<<-- msort(%zu)\\n\", n);\n}\n```\n\n\nAnd sample runs:\n\n```\nrunning experiments with n = 1\nArray: Unsorted (size 1)\n1807\nQ-Sort\nArray: Q-sorted (size 1)\n1807\nM-Sort\nArray: M-sorted (size 1)\n1807\n\nrunning experiments with n = 2\nArray: Unsorted (size 2)\n1807,249\nQ-Sort\nArray: Q-sorted (size 2)\n249,1807\nM-Sort\n-->> msort(2)\nOops: 1 <= 1\n<<-- msort(2)\nArray: M-sorted (size 2)\n1807,249\nElements 0 (value 1807) and 1 (value 249) are out of order\n\nrunning experiments with n = 3\nArray: Unsorted (size 3)\n1807,249,73\nQ-Sort\nArray: Q-sorted (size 3)\n73,249,1807\nM-Sort\n-->> msort(3)\n-->> msort(2)\nOops: 1 <= 1\n<<-- msort(2)\n-->> msort(2)\nOops: 1 <= 1\n<<-- msort(2)\n<<-- msort(3)\nArray: M-sorted (size 3)\n249,73,1807\nElements 0 (value 249) and 1 (value 73) are out of order\n\nrunning experiments with n = 4\nArray: Unsorted (size 4)\n1807,249,73,3658\nQ-Sort\nArray: Q-sorted (size 4)\n73,249,1807,3658\nM-Sort\n-->> msort(4)\nOops: 2 <= 2\n<<-- msort(4)\nArray: M-sorted (size 4)\n1807,249,73,3658\nElements 0 (value 1807) and 1 (value 249) are out of order\nElements 1 (value 249) and 2 (value 73) are out of order\n\nrunning experiments with n = 5\nArray: Unsorted (size 5)\n1807,249,73,3658,3930\nQ-Sort\nArray: Q-sorted (size 5)\n73,249,1807,3658,3930\nM-Sort\n-->> msort(5)\n-->> msort(3)\n-->> msort(2)\nOops: 1 <= 1\n<<-- msort(2)\n-->> msort(2)\nOops: 1 <= 1\n<<-- msort(2)\n<<-- msort(3)\n-->> msort(3)\n-->> msort(2)\nOops: 1 <= 1\n<<-- msort(2)\n-->> msort(2)\nOops: 1 <= 1\n<<-- msort(2)\n<<-- msort(3)\n<<-- msort(5)\nArray: M-sorted (size 5)\n249,73,1807,3658,3930\nElements 0 (value 249) and 1 (value 73) are out of order\n\nrunning experiments with n = 6\nArray: Unsorted (size 6)\n1807,249,73,3658,3930,1272\nQ-Sort\nArray: Q-sorted (size 6)\n73,249,1272,1807,3658,3930\nM-Sort\n-->> msort(6)\nOops: 3 <= 3\n<<-- msort(6)\nArray: M-sorted (size 6)\n1807,249,73,3658,3930,1272\nElements 0 (value 1807) and 1 (value 249) are out of order\nElements 1 (value 249) and 2 (value 73) are out of order\nElements 4 (value 3930) and 5 (value 1272) are out of order\n```\n\n\nIt's your problem from here...I've shown some debug techniques, and diagnosed some of the problems.  Note that tracking function entry and exit can be helpful (though I cheated and didn't diagnose size 0 or 1 entry/exit).  Especially in recursive code, it helps a lot to identify the key parameter to the function (here, ```\nn```\n, though the address of the start of the array might also be relevant) so that separate calls can be detected.\n\n\n\nI got bored, or careless, or something...this code works.  Changes in the recursive calls, and the cleanup at the end of the merge loop, and the copy back to the original array.  And removed the dubious ```\nif (n2 <= n1)```\n block altogether; I couldn't work out a purpose for it.  Oh, and more diagnostics, print array on entry and exit.\n\n```\nstatic void msort(void *b, size_t n, size_t s, int (*cmp)(const void *v1, const void *v2) )\n{\n    if (n <= 1)\n        return;     /* Already sorted */\n\n    printf(\"-->> msort(%zu)\\n\", n);\n    dump_array(stdout, \"Entry to msort()\", (int *)b, n);\n    void *t = malloc(s*n);\n\n    if (t == NULL)\n    {\n        fprintf(stderr, \"Error: No Memory.\\n\");\n        printf(\"<<-- msort(%zu)\\n\", n);\n        return;\n    }\n\n    size_t n1 = n / 2;\n    size_t n2 = n - n1;\n\n    char *b1 = b;\n    char *b2 = (char *) b + (n1 * s);\n\n    msort(b1, n1, s, cmp);\n    msort(b2, n2, s, cmp);\n\n    char *tmp = t;\n\n    while (n1 > 0 && n2 > 0)\n    {\n        if ((*cmp)(b1, b2) <= 0)\n        {\n            memcpy(tmp, b1, s);\n            tmp += s;\n            b1 += s;\n            --n1;\n        }\n        else\n        {\n            memcpy(tmp, b2, s);\n            tmp += s;\n            b2 += s;\n            --n2;\n        }\n    }\n    if (n1 > 0)\n        memcpy(tmp, b1, n1 * s);\n    else if (n2 > 0)\n        memcpy(tmp, b2, n2 * s);\n    memcpy(b, t, n * s);\n    free(t);\n\n    dump_array(stdout, \"Exit from msort()\", (int *)b, n);\n    printf(\"<<-- msort(%zu)\\n\", n);\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Error in the Merge Function(Merge Sort) [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Merge Sort Error C\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am trying to implement the merge sort algorithm as mentioned in the algorithms book by CLRS. I have come up with the following code.\n\n```\n#include<stdio.h>\n#include<stdlib.h>\nvoid merge_sort(int *arr,int start_index,int end_index);\nvoid merge(int *arr,int start_index,int middle_index,int end_index);\n\nint main(){\n\nint arr[]={5,2,1,6,0,3,3,4}; //8 elements last index 7\nint i;\nprintf(\"Before sorting.\\n\");\nfor(i=0;i<8;i++)\nprintf(\"%d,\",arr[i]);\nmerge_sort(arr,0,7);\nprintf(\"\\nAfter sorting.\\n\");\nfor(i=0;i<8;i++)\nprintf(\"%d,\",arr[i]);\n\nreturn 0;}\n\nvoid merge_sort(int *arr,int start_index,int end_index){\n    int middle_index;\n    if(start_index<end_index)\n    {\n        middle_index=(start_index+end_index)/2;\n        merge_sort(arr,start_index,middle_index);\n        merge_sort(arr,(middle_index+1),end_index);\n        merge(arr,start_index,middle_index,end_index);\n    }\n\n}\n\nvoid merge(int *arr, int start_index,int middle_index, int end_index){\n\n    int n1,n2,i,l,m;\n    n1=middle_index-start_index+1;\n    n2=end_index-middle_index;\n    int sub_arr1[n1+1],sub_arr2[n2+1];\n    for(i=0;i<=(n1-1);i++)\n        sub_arr1[i]=arr[i];\n     for(i=0;i<=(n2-1);i++)\n        sub_arr2[i]=arr[middle_index+1+i];\n\n    sub_arr1[n1]=100;\n    sub_arr2[n2]=100;\n        l=0,m=0;\n    for(i=0;i<=end_index;i++){\n\n\n        if(sub_arr1[l]<sub_arr2[m])\n        {arr[i]=sub_arr1[l];\n        l=l+1;}\n        else\n         {arr[i]=sub_arr2[m];\n        m=m+1;}\n\n    }}\nThere seems to be some error in the merge function due to which I am getting an erroneous output which is as follows.\n\nBefore sorting.\n5,2,1,6,0,3,3,4,\nAfter sorting.\n2,4,100,-1076668400,2,4,100,7,\nRUN FINISHED; exit value 0; real time: 0ms; user: 0ms; system: 0ms\n```\n\n\nSince the numbers that I am sorting with this method are small, I have used 100 as a sentinel value. Can that be a possible source of error? Any help appreciated.\n    ", "Answer": "\r\nYou have an error in your merge function: you are ignoring start_index. These lines:\n\n```\nfor(i=0;i<=(n1-1);i++)\n    sub_arr1[i]=arr[i];\n```\n\n\nShould be replaced by:\n\n```\nfor(i=0;i<=(n1-1);i++)\n    sub_arr1[i]=arr[start_index+i];\n```\n\n\nAnd the last for loop, should, instead, start with i = start_index:\n\n```\nfor (i=start_index;i<=end_index;i++) { /* ... */ }\n```\n\n\nI improved indentation a little bit. Here's the final working version of merge():\n\n```\nvoid merge(int *arr, int start_index,int middle_index, int end_index) {\n    int n1,n2,i,l,m;\n    n1=middle_index-start_index+1;\n    n2=end_index-middle_index;\n    int sub_arr1[n1+1],sub_arr2[n2+1];\n    for (i=0;i<=(n1-1);i++)\n        sub_arr1[i]=arr[start_index+i];\n     for (i=0;i<=(n2-1);i++)\n        sub_arr2[i]=arr[middle_index+1+i];\n    sub_arr1[n1]=100;\n    sub_arr2[n2]=100;\n    l=0,m=0;\n    for (i=start_index;i<=end_index;i++) {\n        if(sub_arr1[l]<sub_arr2[m]) {\n            arr[i]=sub_arr1[l];\n            l=l+1;\n        }\n        else {\n            arr[i]=sub_arr2[m];\n            m=m+1;\n        }\n    }\n}\n```\n\n\nTested and working.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Error in the Merge Function(Merge Sort) [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Merge Sort Error C\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am trying to implement the merge sort algorithm as mentioned in the algorithms book by CLRS. I have come up with the following code.\n\n```\n#include<stdio.h>\n#include<stdlib.h>\nvoid merge_sort(int *arr,int start_index,int end_index);\nvoid merge(int *arr,int start_index,int middle_index,int end_index);\n\nint main(){\n\nint arr[]={5,2,1,6,0,3,3,4}; //8 elements last index 7\nint i;\nprintf(\"Before sorting.\\n\");\nfor(i=0;i<8;i++)\nprintf(\"%d,\",arr[i]);\nmerge_sort(arr,0,7);\nprintf(\"\\nAfter sorting.\\n\");\nfor(i=0;i<8;i++)\nprintf(\"%d,\",arr[i]);\n\nreturn 0;}\n\nvoid merge_sort(int *arr,int start_index,int end_index){\n    int middle_index;\n    if(start_index<end_index)\n    {\n        middle_index=(start_index+end_index)/2;\n        merge_sort(arr,start_index,middle_index);\n        merge_sort(arr,(middle_index+1),end_index);\n        merge(arr,start_index,middle_index,end_index);\n    }\n\n}\n\nvoid merge(int *arr, int start_index,int middle_index, int end_index){\n\n    int n1,n2,i,l,m;\n    n1=middle_index-start_index+1;\n    n2=end_index-middle_index;\n    int sub_arr1[n1+1],sub_arr2[n2+1];\n    for(i=0;i<=(n1-1);i++)\n        sub_arr1[i]=arr[i];\n     for(i=0;i<=(n2-1);i++)\n        sub_arr2[i]=arr[middle_index+1+i];\n\n    sub_arr1[n1]=100;\n    sub_arr2[n2]=100;\n        l=0,m=0;\n    for(i=0;i<=end_index;i++){\n\n\n        if(sub_arr1[l]<sub_arr2[m])\n        {arr[i]=sub_arr1[l];\n        l=l+1;}\n        else\n         {arr[i]=sub_arr2[m];\n        m=m+1;}\n\n    }}\nThere seems to be some error in the merge function due to which I am getting an erroneous output which is as follows.\n\nBefore sorting.\n5,2,1,6,0,3,3,4,\nAfter sorting.\n2,4,100,-1076668400,2,4,100,7,\nRUN FINISHED; exit value 0; real time: 0ms; user: 0ms; system: 0ms\n```\n\n\nSince the numbers that I am sorting with this method are small, I have used 100 as a sentinel value. Can that be a possible source of error? Any help appreciated.\n    ", "Answer": "\r\nYou have an error in your merge function: you are ignoring start_index. These lines:\n\n```\nfor(i=0;i<=(n1-1);i++)\n    sub_arr1[i]=arr[i];\n```\n\n\nShould be replaced by:\n\n```\nfor(i=0;i<=(n1-1);i++)\n    sub_arr1[i]=arr[start_index+i];\n```\n\n\nAnd the last for loop, should, instead, start with i = start_index:\n\n```\nfor (i=start_index;i<=end_index;i++) { /* ... */ }\n```\n\n\nI improved indentation a little bit. Here's the final working version of merge():\n\n```\nvoid merge(int *arr, int start_index,int middle_index, int end_index) {\n    int n1,n2,i,l,m;\n    n1=middle_index-start_index+1;\n    n2=end_index-middle_index;\n    int sub_arr1[n1+1],sub_arr2[n2+1];\n    for (i=0;i<=(n1-1);i++)\n        sub_arr1[i]=arr[start_index+i];\n     for (i=0;i<=(n2-1);i++)\n        sub_arr2[i]=arr[middle_index+1+i];\n    sub_arr1[n1]=100;\n    sub_arr2[n2]=100;\n    l=0,m=0;\n    for (i=start_index;i<=end_index;i++) {\n        if(sub_arr1[l]<sub_arr2[m]) {\n            arr[i]=sub_arr1[l];\n            l=l+1;\n        }\n        else {\n            arr[i]=sub_arr2[m];\n            m=m+1;\n        }\n    }\n}\n```\n\n\nTested and working.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Simple implementation of merge sort in javascript\r\n                \r\nWhat's wrong with following implementation of merge sort algorithm. it just returns undefined. \n\nI suspect the error is somewhere in merge function. \n\ncan someone help me point out the error. \n\n```\n    function mergeSort(arr1, lower, higher) {\n\n    if (lower < higher) {\n        var mid = Math.floor((lower + higher) / 2);\n        mergeSort(arr1, lower, mid);\n        mergeSort(arr1, mid + 1, higher);\n        merge(arr1, lower, mid, higher);\n    }\n}\n```\n\n\nAnd merge function\n\n```\nfunction merge(arr1, lower, mid, higher) {\n\n    var i = lower;\n    var j = mid + 1;\n    var k = 0;\n    var mergearr = [];\n\n    while (i < j && j <= higher) {\n\n        if (arr1[i] <= arr1[j]) {\n            mergearr[k] = arr1[i];\n            k++;\n            i++;\n        } else {\n            mergearr[k] = arr1[j];\n            k++;\n            j++;\n        }\n\n    }\n\n    if (i === j) {\n        while (j < higher) {\n            mergearr[k] = arr1[j];\n            k++;\n            j++;\n        }\n    } else if (j > higher) {\n        while (i < j) {\n            mergearr[k] = arr1[i];\n            k++;\n            i++;\n        }\n    }\n\n\n    for (var a = 0; a <= k; a++) {\n        console.log(a);\n        arr1[a] = mergearr[a];\n        console.log(arr1[a]);\n    }\n\n    return arr1;\n}\n```\n\n\nHere is output on the console\n\n```\nindex: 0\n value: 4\nindex: 1\n value: 5\nindex: 2\n value: 4\nindex: 3\n value: undefined\nindex: 0\n value: 4\nindex: 1\n value: 4\nindex: 2\n value: 5\nindex: 3\n value: 4\nindex: 4\n value: undefined\nindex: 0\n value: undefined\nindex: 1\n value: 4\nindex: 2\n value: undefined\nindex: 3\n value: undefined\nindex: 0\n```\n\n    ", "Answer": "\r\nSetting aside possible \"off-by-1\" errors in the sort, the ```\nmerge()```\n function has a problem in the way that it copies the merged list back to the source array. The function is told to merge from ```\nlower```\n to ```\nhigher```\n, which it does. But then, the merged array is copied back to the original array starting at index 0. Instead, you need to make sure that the original array is only modified between ```\nlower```\n and ```\nhigher```\n:\n\n```\nfor (var a = 0; a <= k; a++) {\n    console.log(a);\n    arr1[a + lower] = mergearr[a]; // <--- here\n    console.log(arr1[a + lower]);\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Visual C++ Merge Sort\r\n                \r\nI'm trying to figure out why the following code does not do a merge sort.  The code compiles fine and there are no runtime errors.  SortCollection method just returns an unsorted array.   No compile errors and no run time errors, just returns an unsorted array.  Any pointers would be greatly appreaciated.\n\n```\n#include \"stdafx.h\"\n#include <deque>\n#include <climits>\n#include <stdio.h>\n\nusing namespace System;\nusing namespace System::Collections;\nusing namespace System::Collections::Generic;\n\ngeneric <typename T> where T: IComparable<T>\nref class MergeSort\n{\npublic:\n// constructor\nMergeSort(){}\n\n// SortCollection() method\narray<T>^ SortCollection(array<T>^ inputArray)\n{\n    int n = inputArray->Length;\n    if (n <= 1)\n    {\n        return inputArray;\n    }\n    array<T>^ array1 = gcnew array<T>(inputArray->Length / 2);\n    array<T>^ array2 = gcnew array<T>(inputArray->Length - array1->Length);\n    int array1Count = 0;\n    int array2Count = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (i < n / 2)\n        {\n            array1[array1Count] = inputArray[i];\n            array1Count++;\n        }\n        else\n        {\n            array2[array2Count] = inputArray[i];\n            array2Count++;\n        }\n    }\n    SortCollection(array1);\n    SortCollection(array2);\n    array<T>^ newArray = gcnew array<T>(inputArray->Length);\n    delete inputArray;\n    return Merge(newArray, array1, array2);\n}\n\narray<T>^ Merge(array<T>^ targetArray, array<T>^ array1, array<T>^ array2)\n{\n    int n1 = array1->Length;\n    int n2 = array2->Length;\n    int x1 = 0;\n    int x2 = 0;\n    int counter = 0;\n    while (x1 < n1 && x2 < n2)\n    {\n        if (array1[x1]->CompareTo(array2[x2]) < 0)\n        {\n            targetArray[counter] = array1[x1];\n            x1 ++;\n            counter++;\n        }\n        else\n        {\n            targetArray[counter] = array2[x2];\n            x2 ++;\n            counter++;\n        }\n    }\n    while (x1 < n1) \n    {\n        targetArray[counter] = array1[x1];\n        counter ++;\n        x1 ++;\n    }\n    while (x2 < n2) \n    {\n        targetArray[counter] = array2[x2];\n        counter ++;\n        x2 ++;\n    }\n    return targetArray;\n}\n};\n```\n\n    ", "Answer": "\r\nHmm... but what are you printing/testing? The original array or what Sort return?\nAnyway, try this:\n\n```\nSortCollection(array1);                \nSortCollection(array2);          \n// array<T>^ newArray = gcnew array<T>(inputArray->Length);\n// delete inputArray;                 ---> \"reuse\" the input array        \nreturn Merge(inputArray, array1, array2);\n```\n\n\nEDIT:\nI’m sure you know this, but you just need to paid more attention to it.\n\nA „Normal“ function take arguments and return a result, without changing the arguments:\n\n```\nY=f(x);\n```\n\n\nYou expect ```\nx```\n to be as previous, and the result in ```\ny```\n. These are the good function. But some function will change the argument. Sometime it is evident, like in \n\n```\nDestroy(x); \n```\n\n\nbut  oft is not very evident, like in \n\n```\ny=sort(x);\n```\n\n\nPassing ```\nx```\n “by value” is a guaranty not to be change, but if the function take a kind of reference (like ```\ntype^ x```\n) it have direct access to the original variable and can change its contents. This duality is what you have (in ```\nSortCollection```\n and in ```\nMerge```\n). You need to decide, and “document” what your function return and how modify the arguments it take. \n\nIn one version (with ```\ndelete```\n) you modify the argument deleting it!!! This is normally not a good idea and has to be very good documented. And the sorted array is passed as a “return value” (a sort of reference too, really). This version modifies the argument but the result is in the return (and that is what you need to use/test/print). \n\nThe version without the delete modifies the argument, by putting the sorted array in it. In this case it could be perfectly what you want. Anyway – document it! It returns a reference to the sorted array too, -to the argument. It is done for convenience, but can be exclude for better readability, and “return” just void. \n\nA third variant could be, not modify the argument, and return the sorted array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "why my merge sort program is not working?\r\n                \r\nWhy is my merge sort program not working?\n```\ndef merge(a, p, q, r):\n    n1 = (q - p) + 1\n    n2 = r - q\n    L = [0] * n1\n    M = [0] * n2\n\n    for i in range(n1):\n        L[i] = a[i]\n\n    for j in range(n2):\n        M[j] = a[j]\n\n    i = 0\n    j = 0\n\n    for k in range(p, r):\n        if L[i] <= M[j]:\n            a[k] = L[i]\n            i += 1\n        else:\n            a[k] = M[j]\n            j += 1\n\ndef merge_sort(a, p, r):\n    if len(a) <= 1:\n        print('list has only one element')\n    else:\n        q = len(a) // 2\n        merge_sort(a, p, q)\n        merge_sort(a, q + 1, r)\n        merge(a, p, q, r)\n\n        \na = [3,41,52,26,38,57,9,49]\nmerge_sort(a, 0, len(a) - 1)\nfor _ in range(len(a)):\n    print('%d', a[_])\n```\n\n    ", "Answer": "\r\nThere are multiple problems in your code:\n\nThe initialization loops for the slices are incorrect. The index into ```\na```\n should start at ```\np```\n and ```\nq+1```\n respectively. Change them to:\n```\n  for i in range(n1):\n      L[i] = a[p+i]\n\n  for j in range(n2):\n      M[j] = a[q+1+j]\n```\n\nOr simply write:\n```\n  L = a[p..q+1]\n  M = b[q+1..r+1]\n```\n\nWhich make it obvious that ```\nq```\n and ```\nr```\n should be excluded bounds rather than included.\n\nThe merging loop is incorrect: the range should be ```\nrange(p, r+1)```\n and once one of the temporary arrays is exhausted, comparing ```\nL[i] <= M[j]```\n refers to an element beyond the boundary of either ```\nL```\n or ```\nM```\n.\n\n```\nq```\n is not computed correctly in ```\nmerge_sort```\n: it should be ```\nq = (p + r) // 2```\n\n\nthe test ```\nif len(a) <= 1:```\n is incorrect, you should instead test if the slice has at least 2 elements and do nothing if it does not:\n```\n  if p < r:\n      q = (p + r) // 2\n      merge_sort(a, p, q)\n      merge_sort(a, q + 1, r)\n      merge(a, p, q, r)\n```\n\n\n\nHere is a modified version with excluded upper bounds:\n```\ndef merge(a, p, q, r):\n    L = a[p..q]\n    M = a[q..r]\n\n    i = 0\n    j = 0\n\n    for k in range(p, r):\n        if j >= len(M) or (i < len(L) and L[i] <= M[j]):\n            a[k] = L[i]\n            i += 1\n        else:\n            a[k] = M[j]\n            j += 1\n\ndef merge_sort(a, p, r):\n    if r - p > 1:\n        q = p + (r - p) // 2\n        merge_sort(a, p, q)\n        merge_sort(a, q, r)\n        merge(a, p, q, r)\n\n        \na = [3,41,52,26,38,57,9,49]\nmerge_sort(a, 0, len(a))\nfor _ in range(len(a)):\n    print('%d', a[_])\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "recursive Merge Sort is not working [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI programmed a recursive merge sort algorithm in C. But it is not working.\n\n```\n#include <stdio.h>\n```\n\n\nThis is my Algorithm:\n\n```\nvoid mearge( int a[],int elementsOfA,int b[],int elementsOfB,int c[]){\n\n    int elementsOfC = elementsOfB + elementsOfA;\n    int i=0,j=0,k=0;\n\n    while(k<elementsOfC){\n        if(a[i]<=b[j] || j==elementsOfB) {\n            c[k]=a[i];\n            i++;\n            k++;\n        }\n\n        if(b[j]<a[i] || i==elementsOfA) {\n            c[k]=b[j];\n            j++;\n            k++;\n        }\n    }\n}\n\nvoid meargeSort(int a[], int indexOfLeft, int positionOfRight, int b[]){\n\n    if(positionOfRight-indexOfLeft==1){\n        b[0]=a[indexOfLeft];\n    }\n\n    if(positionOfRight-indexOfLeft>1){\n       int mid = (positionOfRight+indexOfLeft)/2;\n       //int left[mid-1],right[positionOfRight-mid];\n       int left[mid],right[positionOfRight-mid];\n\n       meargeSort(a,indexOfLeft,mid,left);\n       meargeSort(a,mid,positionOfRight,right);\n       mearge(left,mid-indexOfLeft,right,positionOfRight-mid,b);\n    }\n}\n```\n\n\nHere is my main function. I am giving two different inputs to the algotithm:\n\n\nFirst is array arr\nSecond is array brr.\n\n\nIn both cases, output is improper sort\n\n```\nint main(int argc, char **argv)\n{\n    int i, arr[]={5,42,31,1,-1,23,0}, brr[7];\n\n    meargeSort(arr,0,7,brr);\n\n    //int i, brr[]={-1,23,0},brr[3];\n    //meargeSort(arr,0,3,brr);\n\n    for(i=0;i<7;i++)\n        printf(\"%d \",brr[i]);\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nfix like as\n\n```\nwhile(k<elementsOfC){\n    if(j == elementsOfB || i != elementsOfA &&  a[i] <= b[j]){//need check `i`\n        c[k++]=a[i++];\n    } else if(i == elementsOfA || b[j] < a[i]){\n        c[k++] = b[j++];\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to prove the time complexity of Merge Sort and Insertion Sort?\r\n                \r\nSorting Algorithms have different time complexities e.g. Merge sort has O(nlogn), insertion and selection have O(n^2). How to prove that Merge Sort has the Time Complexity of O(nlogn), Insertion and Selection sorts have O(n^2) time complexity in the average case.\n    ", "Answer": "\r\nThe Time complexity of the merge sort for the arrays is O(n(log(n)).\nPsuedoCode: The arrays divides always into two equal halves if keep on dividing until the one element remains to be a divide. For every call of the division of the array, the factor depends upon the (previouslengtharray)/2. While merging the two halve the worst case found in the first case call of merging and the time complexity for merging equal to the length of the array i.e n and the division of the list takes place unit log(n). Hence the time complexity is O(n(log(n)).\n```\n MergeSort(arr[], left,  right)\nIf rigth > left\n     1. Find the middle point to divide the array into two halves:  \n            middle = left+ (right-left)/2\n     2. Call mergeSort for first half:   \n             Call mergeSort(arr, left, middle)\n     3. Call mergeSort for the second half:\n             Call mergeSort(arr, middle+1, right)\n     4. Merge the two halves sorted in step 2 and 3:\n             Call merge(arr, left, middle, right)\n\n\nProof:\n\n    |         n\n    |       /   \\\n    |      /     \\\n    |    n/2  +   n/2 =n\n    |    / \\     /  \\\n    |   /   \\   /    \\\n logn  (n/4+n/4  n/4+n/4) =n Timecomplexity (n(logn))\n```\n\nFor Selection sort and insertion sort the average time-complexity will be O(n^2). When the maximum element found in the nearly last position of the array. We can modify the selection similar to the bubble sort algorithm if the smaller element not found on the current index we simply break the outer loop. This somewhat decreases the average time complexity of the selection sort.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort on structs not working\r\n                \r\nI am performing a merge sort on a struct.\nThe sort is performed on the destination cities which is an array\nWhen I tried it with plain arrays it worked.It doesnt work for structures though :(\n\n```\n#include <fstream>   // for std::ifstream\n#include <sstream>   // for std::istringstream\n#include <cstring>    // for std::string and std::getline\n#include <iostream>\n#include <ctype.h>\n#include <stdio.h>\n#include<algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define MAX 30\n#define WORD 3\n\n\ntypedef struct node{\nint nodeId;\nchar destCity[MAX];\nchar arrCity[MAX];\nint time;\n}NODE;\n\ntypedef struct edge{\n int adjoin;\nint distance;\n}EDGE;\n\ntypedef struct graph{\nNODE cityNode[MAX];\nEDGE e[MAX][MAX];\n}GRAPH;\n\nGRAPH graph,graphCpy,Temp;\nGRAPH currentArray;\n\n\nvoid MergeA(int low ,int mid , int high)\n{\nint i = low, j = mid+1 , k = low;\n\nwhile(i <= mid && j <= high)\n{\n    if(currentArray.cityNode[i].destCity <= currentArray.cityNode[j].destCity)\n    {\n    strcpy(Temp.cityNode[k].destCity,currentArray.cityNode[i].destCity);\n            i++;\n    }\n    else\n    {\n            strcpy(Temp.cityNode[k].destCity,currentArray.cityNode[j].destCity);\n        Temp[k].assign(currentArray[j]);\n            j++;\n    }\n    k++;\n}\nif(i > mid )\n{\n    for(int h = j ;h <= high ; h++ )\n    {\n\n    strcpy(Temp.cityNode[k].destCity,currentArray.cityNode[h].destCity);\n        k++;\n\n    }\n}\nelse\n    for(int h = i; h<= mid ; h++ )\n    {\n\nstrcpy(Temp.cityNode[k].destCity,currentArray.cityNode[h].destCity);\n\n    k++;\n\n    }\n for(int i = low; i <= high ; i++){\n\n    strcpy(currentArray.cityNode[i].destCity,Temp.cityNode[i].destCity);\n}\n\n\n}\nvoid MergeSortA(int low , int high)\n{\n\nint mid = 0;\nif(low < high)\n{\n    mid = low + (high-low)/2;\ncout<<\"beforemerge\"<<endl;\n    MergeSortA(low , mid);\n    MergeSortA(mid+1,high);\n    MergeA(low,mid,high);\n\n}\n}\nint main(){\nstd::ifstream infile(\"theWords.txt\");\n    std::string line;\nwhile (std::getline(infile,(line)) && count<30){\n    std::istringstream iss(line);\n            if ((iss) >>graph.cityNode[count].destCity >> graph.cityNode[count].arrCity  >> graph.cityNode[count].time){\ngraph.cityNode[count].nodeId = count ;\ncount++;\n}\ngraphCpy= graph;\ncurrentArray= graphCpy;\nMergeSortA(0,count);\nfor(int i = 0; i <= count ; i++){\n    cout << currentArray.cityNode[i].destCity <<endl;\n\n    }\n}\n```\n\n\nI input values into graph copy which is then given to currentArray!!\n    ", "Answer": "\r\nYou seem to be under the impression that you can reasonably compare arrays of characters using ```\na < b```\n. That is not the case. You'll need to have a look at ```\nstrcmp()```\n or, preferable, use ```\nstd::string```\n instead in the first place. Personally, I would also strong recommend to make the merge sort algorithms entirely independent on any particular structure and make sure that I can reasonably swap my nodes around.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "LINQ merge sort for multiple sources\r\n                \r\nI have several \"data sources\", each of which provides ordered timestamped data. I'd like to flatten it into a single ordered stream (like merge sort). This answer describes how to do it for two enumerables, but I am not sure how to generalize it.\n\nData sources are huge, so I cannot do it in memory, it has to be streamed.\n\nTo explain it with an example, I have something like this:\n\n```\ninterface IDataSource\n{\n    IEnumerable<DateTime> GetOrderedRecords();\n}\n```\n\n\nI would like to be able to have an extension method like this:\n\n```\n// get all sources\nIEnumerable<IDataSource> dataSources = GetAllSources();\n\n// merge sort\nIEnumerable<DateTime> flattened = dataSources\n    .MergeSort(s => s.GetOrderedRecords());\n```\n\n\n[Edit]\n\nThe reason I can't load everything eagerly and then sort it is because I am loading data from multiple databases and exporting it into a different one. Each ```\nIDataSource```\n is basically Linq-to-NHibernate under the hood, and I have millions of data rows to return.\n\nSo what I need is something like:\n\n\nFrom all available sources, load the next timestamp.\nStore it to disk and \"forget it\".\n\n\nData sources are already sorted, which makes the \"merge sort\" approach feasible.\n    ", "Answer": "\r\nOne simple thing you could do is to concat the calls to the ```\nMerge```\n implementation from the question you linked:\n\n```\npublic static IEnumerable<DateTime> Merge(this IEnumerable<IDataSource> dataSources)\n{\n    var result = Enumerable.Empty<DateTime>();\n\n    foreach(var dataSource in dataSources)\n    {\n        result = result.Merge(dataSource.GetOrderedRecords(), (x, y) => x < y);\n    }\n\n    return result;\n}\n```\n\n\nYou would call it like this:\n\n```\nvar result = dataSources.Merge();\n```\n\n\nThis has the drawback that each call to ```\nMoveNext```\n on the enumerator of the returned enumerable yields quite a lot of MoveNext calls on the nested enumerables.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why does memoization not improve the runtime of Merge Sort?\r\n                \r\nWhy does memoization not improve the runtime of Merge Sort?\n\nI have this question from Assignment task. But as far as I know, Merge Sort uses divide and conquer approach (no overlapping subproblems) but Memoization is based on dynamic programing (with overlapping subproblem). I know the runtime of Merge Sort is O(nlogn) .\n\nI even searched on web search engines and there is no result for this question. Is this question wrong? If it sounds wrong but why would a professor give a wrong question in assignment? \nIf the question is not wrong or my understanding about the question, Merge Sort and Memoization is wrong, How should I answer this question?\n    ", "Answer": "\r\nYou have already given the answer in the question. Memoization implies writing a memo after solving a problem, so that when we encounter the problem again, we use the memo instead of solving the same problem again.\n\nSince in mergesort, the problems don't overlap, writing a memo is of no use.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C Merge sort stuck in an infinite loop\r\n                \r\nMy programme uses recursion for divide and conquer but i am getting an infinite loop due to reasons unknown. and i am still getting the unsorted array as an answer\n\n```\n/**\n * MergeSort.c\n *\n * Uses recursion for divide and conquer\n * \n *\n * Implements merge sort for an array\n */\n```\n\n\nInitialize the method calls for merge and merge sort\n\n```\n#include<stdio.h>\n#include<conio.h>\nvoid merge(int array[6],int beg,int mid,int end);\nvoid mergesort(int array[6],int beg,int end);\n```\n\n\nInitialize the display functions\n\n```\nvoid display(int array[6]);\n\nint main(void)\n{\n     // Initializes the array\n     int array[6]={3,1,2,9,5,4};\n     // Initialize the beginning and the end \n     int beg=0, end=5;\n     // Implement the Merge Sort \n     mergesort(array,beg,end);\n     getch();\n}\n\nvoid mergesort(int array[6],int beg,int end) //Calls Initial merge sort\n{\n      int mid;\n      mid=(beg+end)/2;\n      while (beg<end)\n      {\n            mergesort(array,beg,mid);        //Left part of the array\n            mergesort(array,mid+1,end);      //Right part of the array\n            merge(array,beg,mid,end);        //merge two sorted arrays\n      }\n }\n\n //merges two subarrays\nvoid merge(int array[6],int beg,int mid,int end)\n{\n     int temp[6]; //Declare a temp array for storing the sorted elements\n     int k=beg;     \n     int i=beg;   //initialize the pointers for two sub arrays\n     int j=mid;\n\n     while (i<mid && j<end)\n       {\n            if(array[i]<array[j])\n              {\n                 temp[k]=array[i];\n                 i++;\n                 k++;\n              }\n            else\n              {\n                 temp[k]=array[j];\n                 j++;\n                 k++;\n              }              \n        }\n\n    //Clearing any remaining elements in the sub array\n     while (i<mid) \n      {\n           temp[k]=array[i];\n           i++;\n           k++; \n      }\n\n    //Clearing any remaining elements in the sub array\n    while (j<end) \n      {\n          temp[k]=array[j];\n          j++;\n          k++; \n      }\n\n    //Reassign the sorted elements to the original array\n    for(i=0,k=0;i<end,k<end;i++,k++)     \n      {\n          array[i]=temp[k];                                      \n      }\n    //prints the individual array elements  \n    display(array);           //display array\n}\n\n//Displays the entire array\n\nvoid display(int array[6])\n{\n     //prints the individual array elements\n    for (int i=0;i<6;i++)\n      {\n             printf(\"%d \",array[i]); //prints the individual array elements\n      }\n     printf(\"\\n\"); //Enter a new line after every iteration\n}\n```\n\n    ", "Answer": "\r\nWell, from mergesort function,\n\n```\nwhile (beg<end)\n  {\n        mergesort(array,beg,mid);        //Left part of the array\n        mergesort(array,mid+1,end);      //Right part of the array\n        merge(array,beg,mid,end);        //merge two sorted arrays\n  }\n```\n\n\nbeg and end won't be editted. So it will do somethingin this loop forever.\nI think you should change from while into if.\n\nAnd moreover, if your end is 5 (last index in that array/segment) the last element in the segment won't be sorted. That's mean this array won't be sorted. You have to change to...\n\n```\n while (i<mid && j<=end) //from j<end to j<=end and for another loop\n   {\n        if(array[i]<array[j])\n          {\n             temp[k]=array[i];\n             i++;\n             k++;\n          }\n        else\n          {\n             temp[k]=array[j];\n             j++;\n             k++;\n          }              \n    }\n```\n\n\nGood luck on DQ<3\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Google Go parallel Merge Sort\r\n                \r\nI successfully implemented Merge Sort Parallely on Google Go, but the problem is that sometimes parallel solution takes more time to sort than normal.\nHere is my code:\n    package main\n\n```\nimport \"fmt\"\nimport \"math/rand\"\nimport \"time\"\nimport \"sync\"\n\nconst (\n    n = 1000000;\n)\n\nvar nProcess = 1;\n\nfunc generateData() [n]int {\n    var data [n]int;\n    rand.Seed(time.Now().UnixNano());\n    for i := 0; i < n; i++ {\n        data[i] = rand.Intn(100);\n    }\n    return data;\n}\n\nfunc merge(a []int, b []int) []int {\n    i, j, k := 0, 0, 0\n    var out = make([]int, len(a)+len(b));\n    for ; i < len(a) && j < len(b); k++ {\n        if a[i] < b[j] {\n            out[k] = a[i]\n            i++\n        } else {\n            out[k] = b[j]\n            j++\n        }\n    }\n    if i < len(a) {\n        copy(out[k:], a[i:])\n    } else {\n        copy(out[k:], b[j:])\n    }\n    return out;\n}\n\n\nfunc mergeSort(data []int, level int) []int {\n    var halfSize = len(data)/2;\n    var a = make([]int, halfSize);\n    var b = make([]int, halfSize);\n    var low = 0;\n    var mid = (0 + len(data)-1) / 2;\n    var high = len(data)-1;\n    a = data[low:mid+1];\n    b = data[mid+1:high+1];\n    level = level + 1;\n    var wg sync.WaitGroup\n    if(len(data) > 1) {\n        if( level < nProcess ) {\n            wg.Add(2);\n            go func() { go func() { b = mergeSort(b[:], level); wg.Done(); }(); a = mergeSort(a[:], level); wg.Done(); }()\n            wg.Wait();\n        }else {\n            a = mergeSort(a[:], level);\n            b = mergeSort(b[:], level);\n        }\n    }\n    var out = merge(a[:], b[:]);\n    return out;\n}\n\nfunc main() {\n    var data = generateData();\n    nProcess = 1;\n    start := time.Now();\n    var data2 = mergeSort(data[:], 1);\n    duration := time.Since(start);\n    fmt.Println(\"Processes: \", nProcess);\n    fmt.Println(\"Data: \", len(data2));\n    fmt.Println(\"Duration: \", duration);\n    nProcess = 4;\n    start = time.Now();\n    data2 = mergeSort(data[:], 1);\n    duration = time.Since(start);\n    fmt.Println(\"Processes: \", nProcess);\n    fmt.Println(\"Data: \", len(data2));\n    fmt.Println(\"Duration: \", duration);\n\n}\n```\n\n\nI need to compare results with how many processes do the job. I decided to declare a nProcess. For example if it is = 1 then no parallel code will be executed as you can see from if statement. Everything will be calculated in normal flow. The bigger number is, the deeper in merge sort portions will be executed parallely. The problem is that results are not that impressively different as I think it should be. Maybe you can spot where I did a mistake? Is merging is really executed parallely?\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "MIT Scheme - Merge Sort + Timing Execution\r\n                \r\nI've implemented my own merge sort in MIT Scheme. I want to test it against the builtin ```\nmerge-sort```\n and compare times; however, I don't know how to get the run time of both. Also how do you increase the stack size/recursion depth as i'm testing up to 1 million elements.\n    ", "Answer": "\r\nThere's a bunch of timing procedures in MIT Scheme, check the documentation. In particular, try this one:\n\n```\n(with-timings\n (lambda ()\n   (merge-sort '(1 2 3 4 5) >))\n (lambda (run-time gc-time real-time)\n   (write (internal-time/ticks->seconds run-time))\n   (write-char #\\space)\n   (write (internal-time/ticks->seconds gc-time))\n   (write-char #\\space)\n   (write (internal-time/ticks->seconds real-time))\n   (newline)))\n```\n\n\nThe built-in ```\nsort```\n shouldn't have a problem with one million elements, if your own implementation is a good one, it shouldn't have problems producing a result with that data size.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "What sorting technique does merge sort use while merging\r\n                \r\nAt the last but one step of the merge sort where we have two sorted lists and we are trying to combine them into one sorted list, how would the logic go?\n\nThis is what my naive mind came up with:\nTake each element of list #1 and compare it with each element of list#2 and find its place in list #2. BAsically like an insertion sort.\n\nBut obviously this is not how it happens because this gives me a complexity of O(n^2). \nBut merge sort is O(nlogn). So how does the final step happens?\n    ", "Answer": "\r\nIt uses merge sort. Merge sort doesn't have a separate sorting algorithm, it IS a sorting algorithm.\n\nSo your original lists are already sorted, so the smallest element is always at the beginning. Compare A and B. Take the lesser of the two and add it to the end of the result list. Repeat until both source lists are empty.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "merge sort with recurrsion\r\n                \r\n```\n    /*\nThis code is Written by Shankhadeep Dey\n(15th Aug 2018)\n*/\n#include<iostream>\nusing namespace std;\nvoid merge(int a[],int p,int q,int r)\n{\n    int n1,n2,j,i,k;\n    n1= q-p+1;\n    n2= r-q;\n    int L[n1],R[n2];\n    for (i = 0; i < n1-1; ++i)\n        L[i]=a[p+i-1];\n    for (j = 0; j < n2-1; ++j)\n        R[j]=a[q+j];\n    L[n1]=1e9;\n    R[n2]=1e9;\n    i=0;\n    j=0;\n    for (k = p; k < r; ++k)\n    {\n        if (L[i]<=R[j])\n        {\n            a[k]=L[i];\n            i++;\n        }\n        else\n        {\n            a[k]=R[j];\n            j++;\n        }\n    }\n    while (i < n1)\n    {\n        a[k] = L[i];\n        i++;\n        k++;\n    }\n\n    /* Copy the remaining elements of R[], if there\n       are any */\n    while (j < n2)\n    {\n        a[k] = R[j];\n        j++;\n        k++;\n    }\n}\nvoid mergeSort(int a[],int p,int r)\n{\n    int q;\n    if (p<r)\n    {\n        q= (p+r)/2;\n        mergeSort(a,p,q);\n        mergeSort(a,q+1,r);\n        merge(a,p,q,r);\n    }\n}\nint main()\n{   int w[4]={4,3,21,5};\n    mergeSort(w,0,3);\n    for (int i = 0; i < 4; ++i)\n    {\n        cout<<w[i]<<\" \";\n    }\n    cout<<endl;\n}\n```\n\n\nCan anyone tell me why this sorting is not working?\nI tried this algorithm from the book \"Introduction to Algorithm\" but I am not so sure why this code is not running. I tried searching online for merge sort and find so much things but I exactly want to know what is wrong with my code.\nOutput is:-0 1000000000 1 1000000000 (which is not the correct ans).\nThis is the warning I'm getting\n\n```\nmergeSort.cpp: In function ‘void merge(int*, int, int, int)’:\nmergeSort.cpp:12:10: warning: ISO C++ forbids variable length array ‘L’ [-Wvla]\n  int L[n1],R[n2];\n          ^\nmergeSort.cpp:12:16: warning: ISO C++ forbids variable length array ‘R’ [-Wvla]\n  int L[n1],R[n2];\n```\n\n    ", "Answer": "\r\nThere are issues in your merge logic. Think about what happens when you want to merge the first two elements in the array. In this case, ```\np```\n=0, ```\nq```\n=0 and ```\nr```\n=1. In this case ```\nn1```\n=0, and the following loop never executes:\n\n```\nfor (i = 0; i < n1-1; ++i)\n    L[i]=a[p+i-1];\n```\n\n\nSame with the next loop. Even worse, if you were to fix it by changing ```\nn1-1```\n to ```\nn1```\n, then in the first iteration, ```\np+i-1```\n would be -1, which would cause more problems. \n\nIf you want to cheat by comparing to a working solution, I believe that there is one at How to implement merge sort from \"The Introduction to Algorithms\" by Cormen and Co\n\nMore generally, I would suggest working with a line by line debugger (either gdb or by using an IDE like Eclipse) will allow you to step line by line through the code, checking what executes when and what variable values are at each step. This makes diagnosing errors like this much easier. \n\n\n\n(Note: This problem was fixed in question edit).\n\nThere is a problem is in these lines:\n\n```\nfor (int i = 0; i < n2-1; ++i)\n    R[j]=a[q+j];\n```\n\n\nEither use ```\nj```\n or ```\ni```\n, but not both. At the moment you are using an uninitialised value of ```\nj```\n. \n\n\n\nOn a side note, you declare the variables ```\ni```\n and ```\nj```\n twice (once near the top of the function, and again in the ```\nfor```\n loop). This doesn't stop the program from working, but having two variables with the same name at different scopes isn't great practice, as it could cause confusion.\n\nAlso, in this line:\n\n```\nq= (int)(p+r)/2;\n```\n\n\nthe ```\n(int)```\n part does nothing, and could mislead the reader. ```\np```\n and ```\nr```\n are already integers, so the compiler uses integer division yielding an integer result.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort output issue\r\n                \r\nI'm trying to code merge sort through recursion. However I'm not getting the output in proper sorted order. Please correct my code and tell me the detail about my error.\nThe program takes the number of elements and elements from the user. Based on the data, the program shoud give the elements in sorted order.\nThe code is as follow.\n\n```\n#include <iostream>\n#include <cstdio>\n#define max 20\n\nusing namespace std;\n\nint data[max];\nint nw[max];\nvoid mergeparts(int, int, int);\n\n\nvoid merge_sort(int low, int high){\n    int mid;\n\n    if(low<high){\n        mid=(low+high)/2;\n        merge_sort(low, mid);\n        merge_sort(mid+1, high);\n        mergeparts(low, mid, high);\n    }\n}\n\nvoid mergeparts(int low, int mid, int high){\n\n    for(int i=low; i<high; i++){\n        nw[i] = data[i];\n    }\n    int i = low;\n    int j = mid+1;\n    int k = low;\n\n\n    while((i <= mid)&&(j <= high)){\n        if(nw[i]<=nw[j]){\n            data[k]=nw[i];\n            i++;\n        }\n        else{\n            data[k]=nw[j];\n            j++;\n        }\n        k++;\n    }\n\n    while(i <= mid){\n        data[k] = nw[i];\n        k++;\n        i++;\n    }\n\n    while(j <= high){\n        data[k] = nw[j];\n        k++;\n        j++;\n    }\n    for(int i=low; i<high; i++){\n        data[i] = nw[i];\n    }\n\n}\n\nint main(){\n    int n;\n\n    cout<<\"Enter the number of elements\"<<endl;\n    cin>>n;\n\n\n\n    cout<<\"Enter the \"<<n<<\" numbers.\"<<endl;\n    for(int i=0; i<n; i++){\n        cin>>data[i];\n    }\n\n    cout<<\"The unsorted list is: \"<<endl;\n    for(int i=0; i<n; i++){\n        printf(\"%d\\t\",data[i]);\n    }\n    cout<<endl;\n\n    merge_sort(0,n+1);\n\n    cout<<\"The sorted list is: \"<<endl;\n        for(int i=0; i<n; i++){\n            printf(\"%d\\t\",data[i]);\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nYour code is not the same as the one from this article, as you wrote in your comment. The key difference is in the merging function.\nIf you carefully examine your code, you will notice that  there are parts of your code that might alter the data array, without saving it's current state; for example:\n```\n while(i <= mid){\n        data[k] = nw[i];\n        k++;\n        i++;\n    }\n```\n\nTry it out on an array with some 4 elements, e.g. 5,6,4,2 and you will notice some of the original array members will not appear in the output array.\nYou didn't provide the information about your developing environment, but most of them have debuggers built in. Play around with debugger and you will eventually solve your problem. Or re-read the article and code the algorithm again.\nBest of luck.\n(Also, in the future, try to be a bit more specific with question title and try to provide some additional information about the problem, like some examples. People here want to help, but not everyone has enough time to read the question, compile, or debug your code. If you're more specific, someone might know the answer just by reading your question, and with no further investigation )\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How do I use merge sort to delete duplicates?\r\n                \r\nI use recursive merge sort for sorting a link list, but during the merge sort I would like to delete duplicates. Anyone has insight in how to accomplish this? \n\nI am using C code.\n    ", "Answer": "\r\nIn merge sort you take two (or more) already-sorted lists repeatedly apply the following rules:\n\n\nfind the lesser/least of the items of the top of each of the input lists, choosing any of the lowest items if there is a tie\nremove that item from its list\nadd it to your output list\n\n\nTo remove duplicates, you simply modify the rules very slightly:\n\n\nfind the lesser/least of the items of the top of each of the input lists, choosing any of the lowest items if there is a tie\nremove that item from its list\nif it is the same as the last item you added to your output list, throw it away\notherwise, add it to your output list\n\n\nThis will ensure that no two consecutive items on your output list are the same, and that the items in it are in order, which is what you were after.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Java Iterative Merge Sort Runtime\r\n                \r\nI'm currently working on a project for school that asked me to write code for different sorting algorithms.  The most difficult part was writing an iterative version of merge sort given an input array of length 2^N.  I used a required helper method called merge to assist in iteratively merging.  \n\nMy structure was as follows.  Given an array of 2^N (let us use an array size of 16 to explain my method), I iterated through the array looking at each 2 integers, and swapping if one was greater than the other using merge().  This process would occur 8 times in a length 16 array.  I would then iterate through the array looking at each 4 integers, 4 times.  I would use my merge method to merge the two ordered pairs in every set of 4.  Then, I would look at a block of 8 integers...so on and so forth.  My code is posted here:\n\n```\npublic static void MergeSortNonRec(long[] a) {\n    //======================\n    //FILL IN YOUR CODE HERE\n    //======================    \n    /*\n    System.out.print(\"Our array is: \");\n    printArray(a);\n    System.out.println('\\n');\n    */\n    int alength = a.length;\n    int counter = 2;\n    //the counter will iterate through levels 2n - 2 4 8 16 32 etc.\n    int pointtracker = 0;\n    //the point tracker will keep track of the position in the array\n    while (counter <= alength) {\n        long [] aux = new long [alength];\n        int low = pointtracker;\n        int high = pointtracker + counter - 1;\n        int mid = (low + high)/2;\n\n        merge(a, aux, low, mid, high);\n\n        if (high < alength - 1) {\n            pointtracker += counter; \n            //move to the next block\n        }\n        else {\n            //if our high point is at the end of the array\n            counter *= 2;\n            pointtracker = 0;\n            //start over at a[0], with a doubled counter\n        }\n    }\n    /*\n    System.out.print(\"Final array is: \");\n    printArray(a);\n    System.out.println('\\n');\n    */\n}//MergeSortNonRec()\n```\n\n\nMy merge method is as follows:\n\n```\n    private static void merge(long[] a, long[] aux, int lo, int mid, int hi) {\n\n    // copy to aux[]\n    for (int k = lo; k <= hi; k++) {\n        aux[k] = a[k]; \n    }\n\n    // merge back to a[]\n    int i = lo, j = mid+1;\n    for (int k = lo; k <= hi; k++) {\n        if      (i > mid)           a[k] = aux[j++];\n        else if (j > hi)            a[k] = aux[i++];\n        else if (aux[j] < aux[i])   a[k] = aux[j++];\n        else                        a[k] = aux[i++];\n    }\n}\n```\n\n\nThe recursive solution is much more elegant:\n\n```\n    private static void sort(long[] a, long[] aux, int lo, int hi) {\n    if (hi <= lo) return;\n    int mid = lo + (hi - lo) / 2;\n    sort(a, aux, lo, mid);\n    sort(a, aux, mid + 1, hi);\n    merge(a, aux, lo, mid, hi);\n}\n\npublic static void MergeSort(long[] a) {\n    long[] aux = new long[a.length];\n    sort(a, aux, 0, a.length-1);\n}\n```\n\n\nMy issue is with runtime.  My professor has said that the iterative version of merge sort, because we are only inputting arrays at length 2^N, should run faster than the non-iterative version.  However, my iterative version is running slower than the recursive version at large sets.  Here is an example of my time output:\n\n![runtime]: https://i.stack.imgur.com/J8Auh.jpg \"sorting algorithms\"\n\nWhat can I do to reduce the time of my iterative mergesort?\n\nEDIT:  I've figured it out.  I moved my instantiation of aux outside of the while loop and this decreased time exponentially.  Thanks all!\n    ", "Answer": "\r\n\n  What can I do to reduce the time of my iterative mergesort?\n\n\nWiki has a simplified example of iterative (bottom up) merge sort:\n\nhttps://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation\n\nTo reduce the time, only do a one time allocation of the aux[] array, and don't copy data on each merge pass, but instead swap the references to the arrays on each pass.\n\n```\n        long [] t = a;      // swap references\n        a = aux;\n        aux = t;\n```\n\n\nIf the size of the array is an odd power of 2, you'll need to copy the array one time or swap in place instead of doing the first merge pass.\n\n\n  iterative merge sort should run faster than recursive merge sort\n\n\nAssuming reasonably optimized versions of both, iterative merge sort will usually be faster, but the relative difference decreases as the size of the array increases, because most of the time will be spent in the merge() function which can be identical for both iterative and recursive merge sort.\n\nThere are trade offs. Recursive version will push and pop length - 2 or 2*length - 2 pairs of indices to / from the stack, while iterative generates indices on the fly (which could be kept in registers). It could seem that during the deeper levels of recursion, the recursive version is more cache friendly because it is operating on a portion of the array, while iterative version is always operating across the entire array on each pass, but I've never seen a situation where this resulted in better overall performance with recursive merge sort. Most caches on a PC are 4 or more way set associative, so two lines used for input, one line used for output during a merge process. In my testing, a multi-threaded iterative merge sort is much faster than a single-threaded iterative merge sort, so a merge sort on the systems I've tested with is not memory bandwidth limited.\n\nHere is a somewhat optimized example of iterative (bottom up) merge sort along with a test program:\n\n```\npackage jsortbu;\nimport java.util.Random;\n\npublic class jsortbu {\n    static void MergeSort(int[] a)          // entry function\n    {\n        if(a.length < 2)                    // if size < 2 return\n            return;\n        int[] b = new int[a.length];\n        BottomUpMergeSort(a, b);\n    }\n\n    static void BottomUpMergeSort(int[] a, int[] b)\n    {\n    int n = a.length;\n    int s = 1;                              // run size \n        if(1 == (GetPassCount(n)&1)){       // if odd number of passes\n            for(s = 1; s < n; s += 2)       // swap in place for 1st pass\n                if(a[s] < a[s-1]){\n                    int t = a[s];\n                    a[s] = a[s-1];\n                    a[s-1] = t;\n                }\n            s = 2;\n        }\n        while(s < n){                       // while not done\n            int ee = 0;                     // reset end index\n            while(ee < n){                  // merge pairs of runs\n                int ll = ee;                // ll = start of left  run\n                int rr = ll+s;              // rr = start of right run\n                if(rr >= n){                // if only left run\n                    do                      //   copy it\n                        b[ll] = a[ll];\n                    while(++ll < n);\n                    break;                  //   end of pass\n                }\n                ee = rr+s;                  // ee = end of right run\n                if(ee > n)\n                    ee = n;\n                Merge(a, b, ll, rr, ee);\n            }\n            {                               // swap references\n                int[] t = a;\n                a = b;\n                b = t;\n            }\n            s <<= 1;                        // double the run size\n        }\n    }\n\n    static void Merge(int[] a, int[] b, int ll, int rr, int ee) {\n        int o = ll;                         // b[]       index\n        int l = ll;                         // a[] left  index\n        int r = rr;                         // a[] right index\n        while(true){                        // merge data\n            if(a[l] <= a[r]){               // if a[l] <= a[r]\n                b[o++] = a[l++];            //   copy a[l]\n                if(l < rr)                  //   if not end of left run\n                    continue;               //     continue (back to while)\n                do                          //   else copy rest of right run\n                    b[o++] = a[r++];\n                while(r < ee);\n                break;                      //     and return\n            } else {                        // else a[l] > a[r]\n                b[o++] = a[r++];            //   copy a[r]\n                if(r < ee)                  //   if not end of right run\n                    continue;               //     continue (back to while)\n                do                          //   else copy rest of left run\n                    b[o++] = a[l++];\n                while(l < rr);\n                break;                      //     and return\n            }\n        }\n    }\n\n    static int GetPassCount(int n)          // return # passes\n    {\n        int i = 0;\n        for(int s = 1; s < n; s <<= 1)\n            i += 1;\n        return(i);\n    }\n\n    public static void main(String[] args) {\n        int[] a = new int[10000000];\n        Random r = new Random();\n        for(int i = 0; i < a.length; i++)\n            a[i] = r.nextInt();\n        long bgn, end;\n        bgn = System.currentTimeMillis();\n        MergeSort(a);\n        end = System.currentTimeMillis();\n        for(int i = 1; i < a.length; i++){\n            if(a[i-1] > a[i]){\n                System.out.println(\"failed\");\n                break;\n            }\n        }\n        System.out.println(\"milliseconds \" + (end-bgn));\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why is merge sort used by java to sort an array greater than elements 7\r\n                \r\nAccording to Wikipedia: \n\n\n  \"In Java, the Arrays.sort() methods use merge sort or a tuned\n  quicksort depending on the datatypes and for implementation efficiency\n  switch to insertion sort when fewer than seven array elements are\n  being sorted\"\n\n\nBut why? Both merge sort and quick sort are O(n log n).\n    ", "Answer": "\r\nWhere the algorithms differ is their typical case behavior and this is where insertion sort is one of the worst. On the other hand, for very small collections (n ≈ n2) insertion sort's simplicity wins.\n\nJava's algorithm selection rules prefer QuickSort first, and only fall back to something else due to specific restrictions. QuickSort, namely, is an unstable sort and thus is only acceptable for the sorting of primitives. For reference types, TimSort is used as of OpenJDK 7 (previously MergeSort).\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "LINQ merge sort for multiple sources\r\n                \r\nI have several \"data sources\", each of which provides ordered timestamped data. I'd like to flatten it into a single ordered stream (like merge sort). This answer describes how to do it for two enumerables, but I am not sure how to generalize it.\n\nData sources are huge, so I cannot do it in memory, it has to be streamed.\n\nTo explain it with an example, I have something like this:\n\n```\ninterface IDataSource\n{\n    IEnumerable<DateTime> GetOrderedRecords();\n}\n```\n\n\nI would like to be able to have an extension method like this:\n\n```\n// get all sources\nIEnumerable<IDataSource> dataSources = GetAllSources();\n\n// merge sort\nIEnumerable<DateTime> flattened = dataSources\n    .MergeSort(s => s.GetOrderedRecords());\n```\n\n\n[Edit]\n\nThe reason I can't load everything eagerly and then sort it is because I am loading data from multiple databases and exporting it into a different one. Each ```\nIDataSource```\n is basically Linq-to-NHibernate under the hood, and I have millions of data rows to return.\n\nSo what I need is something like:\n\n\nFrom all available sources, load the next timestamp.\nStore it to disk and \"forget it\".\n\n\nData sources are already sorted, which makes the \"merge sort\" approach feasible.\n    ", "Answer": "\r\nOne simple thing you could do is to concat the calls to the ```\nMerge```\n implementation from the question you linked:\n\n```\npublic static IEnumerable<DateTime> Merge(this IEnumerable<IDataSource> dataSources)\n{\n    var result = Enumerable.Empty<DateTime>();\n\n    foreach(var dataSource in dataSources)\n    {\n        result = result.Merge(dataSource.GetOrderedRecords(), (x, y) => x < y);\n    }\n\n    return result;\n}\n```\n\n\nYou would call it like this:\n\n```\nvar result = dataSources.Merge();\n```\n\n\nThis has the drawback that each call to ```\nMoveNext```\n on the enumerator of the returned enumerable yields quite a lot of MoveNext calls on the nested enumerables.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "What is wrong in this implementation of merge sort?\r\n                \r\nI know that there are many implementations of merge sort but this is one which I have read in the book \"Introduction to algorithms\". The following code is an implementation of merge sort which  is not working correctly:\n\n```\n#include <iostream>\n\nusing namespace std;\nvoid merge(int*a, int p, int q, int r) {  //function to merge two arrays\n\n  int n1 = (q - p);  // size of first sub array\n\n  int n2 = (r - q);  // size of second subarray\n\n  int c[n1], d[n2];\n\n  for (int i = 0; i <= n1; i++) {\n    c[i] = a[p + i];\n  }\n\n  for (int j = 0; j <= n2; j++) {\n    d[j] = a[q + j];\n  }\n\n  int i = 0, j = 0;\n\n  for (int k = p; k < r; k++) {  // merging two arrays in ascending order\n\n    if (c[i] <= d[j]) {\n      a[k++] = c[i++];\n\n    } else {\n      a[k++] = d[j++];\n\n    }\n  }\n}\n\nvoid merge_sort(int*a, int s, int e) {\n  if (s < e) {\n    int mid = (s + e) / 2;\n    merge_sort(a, s, mid);\n    merge_sort(a, mid + 1, e);\n    merge(a, s, mid, e);\n  }\n}\n\nint main() {\n  int a[7] { 10, 2, 6, 8, 9, 10, 15 };\n  merge_sort(a, 0, 6);\n  for (auto i : a)\n    cout << i << endl;\n}\n```\n\n\nThis code is not working correctly. What's wrong in this code? How can it be fixed?\n    ", "Answer": "\r\nFirst of all you should be correctly set for the size of the array.\n\n```\nvoid merge(int*a, int p, int q, int r) {  //function to merge two arrays\n/* If i am not wrong , p is the starting index of the first sub array\n   q is the ending index of it also q+1 is the starting index of second  \n   sub array and r is the end of it */\n\n/* size of the sub array would be (q-p+1) think about it*/\nint n1 = (q - p);  // size of first sub array\n/* This is right n2 = (r-(q+1)+1)*/\nint n2 = (r - q);  // size of second subarray\n\nint c[n1], d[n2];\n\nfor (int i = 0; i < n1; i++) {\nc[i] = a[p + i];\n}\n\nfor (int j = 0; j < n2; j++) {\nd[j] = a[q + 1 + j];\n}\n.\n.\n.\n}\n```\n\n\nNow , after this you have copies the both arrays in locally defined arrays. Until this, it is correct .\n\nNow the main part is merging of the two arrays which you are doing in the for loop. You are just comparing the ith element of first sub array with jth element of the second, but what you are missing here is that there may be a time when you have updated all  the values of the first( or second) sub array in the main array but still some elements are remaining int the second ( first) one.\n\nFor example, take these two subarrays\n\n```\nsub1={2,3,4,5};\nsub2={7,8,9,10};\n```\n\n\nin this case you should break from the loop as soon as you have traversed either of the array completely and copy the rest of the elements of the other array in the same order.\n       Also in the for loop you increasing k two times in a loop , one in the for statement and another while updating a value, Check that too.\nHope this may solve the problem.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How does quick sort differ from merge sort?\r\n                \r\nI was trying to understand quicksort and mergesort.\n\nSteps of quick sort as written on Wikipedia are:\n\n```\nQuicksort is a divide and conquer algorithm. Quicksort first divides a large list into two smaller sub-lists: the low elements and the high elements. Quicksort can then recursively sort the sub-lists.\nThe steps are:\nPick an element, called a pivot, from the list.\nReorder the list so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.\nRecursively apply the above steps to the sub-list of elements with smaller values and separately the sub-list of elements with greater values.\n```\n\n\nHere quick sort use an pivot element and while merge sort use a middle element.\n\nOther than this how they differ?\nThanks.\n    ", "Answer": "\r\nSeems relevant Ironically, discovered by googling, how do quicksort and merge sort differ?\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How return value this merge sort\r\n                \r\nMerge sort algorithm reduce the original array in a collection of 2 numbers, and put the lower before, and after sort 2 collections (1collection x 1collection), after 2x2, 3x3, etc. Finally array is sorted.\nThe question is: How this algorithm (the implementation in Java) sort the array if the second mergeSort(), when call mergeSort(), and merge, doesn't assign the output to an array?\n\nI call the algorithm with:\n\n```\nint[] a = {4 , 8, 19, 7};\nint[] sorted_array = mergeSort(a, 0, a.length-1);\n```\n\n\n\n\n```\nstatic void mergeSort(int[] a)\n{\n    return mergeSort(a, 0, a.length - 1);\n}\n\nstatic int[] mergeSort(int[] a, int i, int f)\n{\n    if(i < f)\n    {\n        int h = (f + i) / 2;\n        mergeSort(a, i, h);\n        mergeSort(a, h + 1, f);\n        merge(a, i, h, f);\n    }\nreturn a;\n}\n\nstatic void merge(int[] a, int i, int h, int f)\n{\n    int[] aux = new int[f - i + 1];\n    int k = 0, iaux = i, jaux = h + 1, kaux;\n\nwhile(iaux <= h && jaux <= f)\n{\n    if(a[iaux] < a[jaux])\n    {\n        aux[k] = a[iaux];\n        iaux++;\n    }\n    else\n    {\n        aux[k] = a[jaux];\n        jaux++;\n    }\n\n    k++;\n}\n\nwhile(iaux <= h)\n{\n    aux[k] = a[iaux];\n    iaux++;\n    k++;\n}\n\nwhile(jaux <= f)\n{\n    aux[k] = a[jaux];\n    jaux++;\n    k++;\n}\n\nkaux = 0;\n\nfor(iaux = i; iaux <= f; iaux++)\n{\n    a[iaux] = aux[kaux];\n    kaux++;\n}\n```\n\n\n}\n\nThank you.\n    ", "Answer": "\r\nIn Java, everything is passed-by-value. But it is important to know, what that value is! \n\nEvery variable, that is not primitive data type (int, boolean etc.) contains reference to object.\n\nIn this line ```\nint[] a = {4 , 8, 19, 7};```\n you create new array and you store reference to this object in variable ```\na```\n.\n\nIf you call this method ```\nmergeSort(a, 0, a.length-1);```\n, the value of variable ```\na```\n which is reference to the array is copied to the method (the second and third parameters are primitive data types, its value is copied, not reference). Therefore inside mergeSort method, it accessing directly the same array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "c++ merge sort trouble [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am new to c++ and was trying develop a code for merge sort. I tested it with a sample array of size 15 but the answer put out by the code is not right. I can't figure what's going wrong. Here is my code:\n\n```\n#include <stdlib.h>\n#include <stdio.h> \n#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <unistd.h>\n#include <cstdlib>\n\nusing namespace std;\n\n//two arrays, input\nint initial[15] = {200,1,2,9,8,98,6,44,5,4,67,15,3,2,0};\n//for output\nint fin[15];\n\nvoid sort(int* ini, int left, int right, int m);\n\n//saperate the input in a recursion\nvoid devide(int* ini, int left, int right){\n     int m;\n\n     if(left < right){\n          m = (left + right) / 2;\n          devide(ini, left, m);\n          devide(ini, m+1, right);\n\n          sort(ini, left, right, m);\n     }\n}\n\n\n//sorting\nvoid sort(int* ini, int left, int right, int m){\n\n     //first half, start at the first element in the input array\n     int first_h = left;\n\n     //second half, start at the first element after the \n     // middle element in the input array\n     int second_h = m+1;\n\n     //index for output array\n     int out = left;\n\n     //comparing, if both half of array have element\n     while(first_h <= m && second_h <= right){\n\n          //put the smaller in the the output array\n          if(initial[first_h] < initial[second_h]){\n               fin[out] = initial[first_h];\n              first_h++;\n          }\n          else{\n               fin[out] = initial[second_h];\n               second_h++;\n\n          }  \n          out++;   \n     }\n\n     //if one of half of input is empty, put the rest element into the \n     // output array\n     while(first_h <= m){\n          fin[out] = initial[first_h];\n          out++;\n      first_h++;\n     }\n     while(second_h <= right){\n          fin[out] = initial[second_h];\n          out++;\n          second_h++;\n     }\n}\n\nint main(){\n     devide(initial, 0, 14);\n\n     for(int i =0; i<15; i++){\n          cout<<fin[i];\n          cout<<\",\";\n     }\n     return 0;\n}\n```\n\n\nThe output of initiation[], which is fin[] is:\n\n```\n5,4,67,15,3,2,0,200,1,2,9,8,98,6,44,\n```\n\n    ", "Answer": "\r\nSo one small mistake that you don't take into account is that, you are passing pointer array ini but inside the method you still use the method initial and one more thing is, you should take in a temp array that would assign the sorted values to your ini array.\n\nSo your code should look something like this\n\n```\n  void sort(int* ini, int left, int right, int m){\n     int first_h = left;\n     int second_h = m+1;\n     int out = left;\n     while(first_h <= m && second_h <= right){\n          if(ini[first_h] < ini[second_h]){\n               fin[out] = ini[first_h];\n              first_h++;\n          }\n          else{\n               fin[out] = ini[second_h];\n               second_h++;\n\n          }  \n          out++;   \n     }\n\n     while(first_h <= m){\n          fin[out] = ini[first_h];\n          out++;\n      first_h++;\n     }\n     while(second_h <= right){\n          fin[out] = ini[second_h];\n          out++;\n          second_h++;\n     }\n     for(int i=left; i<out; i++)\n     {\n       ini[i] = fin[i];\n     }\n}\n```\n\n\nHope this helps in understanding the algorithm better!\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to efficiently merge sort with vectors using C++\r\n                \r\nI have implemented a merge sort in c++ by using vectors as function\narguments instead of indices (start, end). However, I would love to \nknow if there is any trade off by doing this, in terms of speed \nand space complexity\n\nThe code:\n\n```\nvoid mergeSort(std::vector<int> &array) {\n    if(array.size() == 1) return;\n    else {\n      const unsigned int len = array.size();\n      const int lo = floor((double)len/2);\n      const int hi = ceil((double)len/2);\n\n      std::vector<int> L(&array[0], &array[lo]);\n      std::vector<int> R(&array[lo], &array[len]);\n\n      mergeSort(L);\n      mergeSort(R);\n      merge(array, L, R);\n    }\n    return;\n}\n```\n\n\nCreating new lists every call to merge sort might not be the way to go,\nbut this is how the merge sort function works. Also, how fast/slow is the:\n\n```\nstd::vector<int> L(&array[0], &array[lo]);\n```\n\n\nThe merge function then looks like:\n\n```\nvoid merge(\n           std::vector<int> &array, \n           std::vector<int> &L, \n           std::vector<int> &R\n          ) {\n    std::vector<int>::iterator a = array.begin();\n    std::vector<int>::iterator l = L.begin();\n    std::vector<int>::iterator r = R.begin();\n\n    while(l != L.end() && r != R.end()) {\n      if (*l <= *r) {\n      *a = *l;\n      l++;\n      }\n      else {\n        *a = *r;\n        r++;\n      }\n      a++;\n   }\n   while (l != L.end()) {\n     *a = *l;\n     a++;\n     l++;\n   }\n   while (r != R.end()) {\n     *a = *r;\n     a++;\n     r++;\n   }\n   return;\n```\n\n\n}\n    ", "Answer": "\r\nWell, there is not need to create new space at each call of merge.\n```\nstd::vector<int> L(&array[0], &array[lo]);```\n will actually create space to accomodate ```\nlo```\n elements and will perform ```\nlo```\n copies as well.\n\nYou are never gonna use more then ```\nO(n)```\n additional space for storing values. So, why don't you allocate a buffer large enough accommodate the \na copy of the whole vector upfront and make each recursive call operate on a specific portion of the data? this way you don't have to create new vectors at each call.\n\nPlus, I will also encourage you to make the ```\nmergesort```\n works on iterators instead on ```\nvector<int>```\n only. An interface like the following should be enough. \n\n```\ntemplate < typename Iterator, typename Compare>\nvoid mergesort(Iterator s, Iterator e, Compare cmp);\n```\n\n\nOn Github you can find a version of mergesort I have implemented a while ago. It should be enough I guess.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursion in Merge Sort, Quick Sort and traversal of trees\r\n                \r\nWhile learning different algorithms (like merge sort, quick sort or Tree traversals) I have observed that there are two recursive calls immediately followed by each other.\nI am unable to understand completely. Please explain in simple terms why do we use two recursive calls? Is this any kind of pattern?\nAlso are there any algorithms where more than two immediate recursive calls are made?\nMerge Sort\nm_sort(numbers, temp, left, mid);\nm_sort(numbers, temp, mid+1, right);\nTree Traversals\npreorder(node.left)\npreorder(node.right)\n    ", "Answer": "\r\nThere are two recursive calls because the same function needs to be performed in two different places. In the case of tree traversals starting from the root you want to recursively go down the left and then down the right. The way that function calls work, ```\nF```\n calls ```\npreorder(node.left)```\n and knows nothing about ```\npreorder(node.right)```\n. When it goes into the ```\nnode.left```\n it is now at ```\nB```\n. The same recursive call will be made there all the way until the bottom, at ```\nA```\n. When preorder(node.left) returns from ```\nA```\n then the code in ```\nB```\n calls ```\npreorder(node.right)```\n and the recursion will continue. \n\nThis isn't so much a pattern as the nature of doing recursive work on many binary structures, where a divide-and-conquer strategy is adapted to split the work into smaller parts, and then recursion is performed on each part seperately until the trivial case is met (such as a node without children as in ```\nA```\n, when it returns) \n\n\n\nSource: \"Sorted binary tree preorder\" by Sorted_binary_tree.svg: Milesderivative work: Pluke (talk) - Sorted_binary_tree.svg. Licensed under Public Domain via Wikimedia Commons.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Parallel Merge Sort in Scala\r\n                \r\nI have been trying to implement parallel merge sort in Scala. But with 8 cores, using ```\n.sorted```\n is still about twice as fast.\n\nedit:\n\nI rewrote most of the code to minimize object creation. Now it runs about as fast as the ```\n.sorted```\n\n\nInput file with 1.2M integers:\n\n\n1.333580 seconds (my implementation)\n1.439293 seconds (```\n.sorted```\n)\n\n\nHow should I parallelize this?\n\nNew implementation\n\n```\nobject Mergesort extends App\n{\n\n//=====================================================================================================================\n// UTILITY\n  implicit object comp extends Ordering[Any] {\n    def compare(a: Any, b: Any) = {\n      (a, b) match {\n        case (a: Int, b: Int)       => a compare b\n        case (a: String, b: String) => a compare b\n        case _                      => 0\n      }\n    }\n  }\n\n//=====================================================================================================================\n// MERGESORT\n\n  val THRESHOLD = 30\n\n  def inssort[A](a: Array[A], left: Int, right: Int): Array[A] = {\n    for (i <- (left+1) until right) {\n      var j = i\n      val item = a(j)\n      while (j > left && comp.lt(item,a(j-1))) {\n        a(j) = a(j-1)\n        j -= 1\n      }\n      a(j) = item\n    }\n    a\n  }\n\n  def mergesort_merge[A](a: Array[A], temp: Array[A], left: Int, right: Int, mid: Int) : Array[A] = {\n    var i = left\n    var j = right\n    while (i < mid) { temp(i) = a(i);   i+=1;       }\n    while (j > mid) { temp(i) = a(j-1); i+=1; j-=1; }\n\n    i = left\n    j = right-1\n    var k = left\n    while (k < right) {\n      if (comp.lt(temp(i), temp(j))) { a(k) = temp(i); i+=1; k+=1; }\n      else                           { a(k) = temp(j); j-=1; k+=1; }\n    }\n    a\n  }\n\n  def mergesort_split[A](a: Array[A], temp: Array[A], left: Int, right: Int): Array[A] = {\n    if (right-left == 1) a\n\n    if ((right-left) > THRESHOLD) {\n      val mid = (left+right)/2\n      mergesort_split(a, temp, left, mid)\n      mergesort_split(a, temp, mid, right)\n      mergesort_merge(a, temp, left, right, mid)\n    }\n    else\n      inssort(a, left, right)\n  }\n\n  def mergesort[A: ClassTag](a: Array[A]): Array[A] = {\n    val temp = new Array[A](a.size)\n    mergesort_split(a, temp, 0, a.size)\n  }\n```\n\n\nPrevious implementation\n\nInput file with 1.2M integers:\n\n\n4.269937 seconds (my implementation)\n1.831767 seconds (```\n.sorted```\n)\n\n\nWhat sort of tricks there are to make it faster and cleaner?\n\n```\nobject Mergesort extends App\n{\n\n//=====================================================================================================================\n// UTILITY\n\n  val StartNano = System.nanoTime\n  def dbg(msg: String) = println(\"%05d DBG \".format(((System.nanoTime - StartNano)/1e6).toInt) + msg)\n  def time[T](work: =>T) = {\n    val start = System.nanoTime\n    val res = work\n    println(\"%f seconds\".format((System.nanoTime - start)/1e9))\n    res\n  }\n\n  implicit object comp extends Ordering[Any] {\n    def compare(a: Any, b: Any) = {\n      (a, b) match {\n        case (a: Int, b: Int)       => a compare b\n        case (a: String, b: String) => a compare b\n        case _                      => 0\n      }\n    }\n  }\n\n//=====================================================================================================================\n// MERGESORT\n\n  def merge[A](left: List[A], right: List[A]): Stream[A] = (left, right) match {\n    case (x :: xs, y :: ys) if comp.lteq(x, y) => x #:: merge(xs, right)\n    case (x :: xs, y :: ys) => y #:: merge(left, ys)\n    case _ => if (left.isEmpty) right.toStream else left.toStream\n  }\n\n  def sort[A](input: List[A], length: Int): List[A] = {\n    if (length < 100) return input.sortWith(comp.lt)\n    input match {\n      case Nil | List(_) => input\n      case _ =>\n        val middle = length / 2\n        val (left, right) = input splitAt middle\n        merge(sort(left, middle), sort(right, middle + length%2)).toList\n    }\n  }\n\n  def msort[A](input: List[A]): List[A] = sort(input, input.length)\n\n//=====================================================================================================================\n// PARALLELIZATION\n\n  //val cores = Runtime.getRuntime.availableProcessors\n  //dbg(\"Detected %d cores.\".format(cores))\n  //lazy implicit val ec = ExecutionContext.fromExecutorService(Executors.newFixedThreadPool(cores))\n\n  def futuremerge[A](fa: Future[List[A]], fb: Future[List[A]])(implicit order: Ordering[A], ec: ExecutionContext) =\n  {\n    for {\n      a <- fa\n      b <- fb\n    } yield merge(a, b).toList\n  }\n\n  def parallel_msort[A](input: List[A], length: Int)(implicit order: Ordering[A]): Future[List[A]] = {\n    val middle = length / 2\n    val (left, right) = input splitAt middle\n\n    if(length > 500) {\n      val fl = parallel_msort(left, middle)\n      val fr = parallel_msort(right, middle + length%2)\n      futuremerge(fl, fr)\n    }\n    else {\n      Future(msort(input))\n    }\n  }\n\n//=====================================================================================================================\n// MAIN\n\n  val results = time({\n    val src = Source.fromFile(\"in.txt\").getLines\n    val header = src.next.split(\" \").toVector\n    val lines = if (header(0) == \"i\") src.map(_.toInt).toList else src.toList\n    val f = parallel_msort(lines, lines.length)\n    Await.result(f, concurrent.duration.Duration.Inf)\n  })\n\n  println(\"Sorted as comparison...\")\n  val sorted_src = Source.fromFile(input_folder+\"in.txt\").getLines\n  sorted_src.next\n  time(sorted_src.toList.sorted)\n\n  val writer = new PrintWriter(\"out.txt\", \"UTF-8\")\n  try writer.print(results.mkString(\"\\n\"))\n  finally writer.close\n}\n```\n\n    ", "Answer": "\r\nMy answer is probably going to be a bit long, but i hope that it will be useful for both you and me.\n\nSo, first question is: \"how scala is doing sorting for a List?\" Let's have a look at the code from scala repo!\n\n```\n  def sorted[B >: A](implicit ord: Ordering[B]): Repr = {\n    val len = this.length\n    val b = newBuilder\n    if (len == 1) b ++= this\n    else if (len > 1) {\n      b.sizeHint(len)\n      val arr = new Array[AnyRef](len)  // Previously used ArraySeq for more compact but slower code\n      var i = 0\n      for (x <- this) {\n        arr(i) = x.asInstanceOf[AnyRef]\n        i += 1\n      }\n      java.util.Arrays.sort(arr, ord.asInstanceOf[Ordering[Object]])\n      i = 0\n      while (i < arr.length) {\n        b += arr(i).asInstanceOf[A]\n        i += 1\n      }\n    }\n    b.result()\n  }\n```\n\n\nSo what the hell is going on here? Long story short: with java. Everything else is just size justification and casting. Basically this is the line which defines it:\n\n```\njava.util.Arrays.sort(arr, ord.asInstanceOf[Ordering[Object]])\n```\n\n\nLet's go one level deeper into JDK sources:\n\n```\npublic static <T> void sort(T[] a, Comparator<? super T> c) {\n    if (c == null) {\n        sort(a);\n    } else {\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a, c);\n        else\n            TimSort.sort(a, 0, a.length, c, null, 0, 0);\n    }\n}\n```\n\n\nlegacyMergeSort is nothing but single threaded implementation of merge sort algorithm.\n\nThe next question is: \"what is TimSort.sort and when do we use it?\"\n\nTo my best knowledge default value for this property is false, which leads us to TimSort.sort algorithm. Description can be found here. Why is it better? Less comparisons that in merge sort according to comments in JDK sources.\n\nMoreover you should be aware that it is all single threaded, so no parallelization here.\n\nThird question, \"your code\":\n\n\nYou create too many objects. When it comes to performance, mutation (sadly) is your friend.\nPremature optimization is the root of all evil -- Donald Knuth. Before making any optimizations (like parallelism), try to implement single threaded version and compare the results.\nUse something like JMH to test performance of your code.\nYou should not probably use Stream class if you want to have the best performance as it does additional caching.\n\n\nI intentionally did not give you answer like \"super-fast merge sort in scala can be found here\", but just some tips for you to apply to your code and coding practices.\n\nHope it will help you.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "External Merge Sort\r\n                \r\nI am trying to implement External merge sort for my DBMS project. I have a 3 file each with 20 pages and my buffer size is 20 pages . \nEach of these i have sorted now . So all three files of 20 pages are sorted. Now  while merging i need to bring 6 pages  of each files (6x3=18 pages ) and 1 page to write the sorted output . And this has to be done 4 times to get whole file complete sorted .\nBut i am finding difficult to merge all these files ? any steps how to perform merge of 3 files making sure that every pages is brought in buffer size .Any recursive function ?\nAll the files content are stored in array a[fileno][pageno] format \neg a[1][20] =5 mean i have a data of 5 in the page no 20 of File 1 .\nAssuming the page of a file hold an integer .\n    ", "Answer": "\r\nAssuming you do a 3 way merge, that's 3 inputs and 1 output, and it only has to be done once. Divide buffer into 4 parts, 5 pages each. Start by reading the first 5 pages of the 3 files, each into it's on 5 page buffer. Start a 3 way merge by comparing the first records in each of the 3 buffers and move the smallest to the output buffer. When the output buffer is filled (5 pages), write it out and continue. When an input buffer is emptied, read in the next 5 pages for that file.\n\nWhen the end of one of the three input files is reached, the code switches to a 2 way merge. To simplify the code, copy the file related parameters into the parameters for file 0 and file 1. If file 2 goes empty first, nothing needs to be done. If file 1 goes empty first, copy file 2 parameters to file 1. If file 0 goes empty first, copy file 1 parameters to file 0, then file 2 parameters to file1. Then do the 2 way merge using file 0 and file 1.\n\nWhen the end of of the two input files is reaches, the code switches to just copy the remaining file. Again, if file 0 goes empty first, then copy file 1 parameters to file 0, so that the copy code always works with file 0.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Understanding running time for merge sort and quick sort\r\n                \r\nFor both merge sort and quick sort, I'm trying to come up with scenarios where they become worst case. If I'm correct, merge sort's worst case O(nlogn) when everything is sorted. Quick sort's worst case is when the pivot is in the least optimal place, and the array is sorted, so it becomes O(n^2). I was wondering if this was correct first off, so please correct me if not. \nMy real question is if the pivot for quick sort is in the middle of an array, what would the array have to look like in order for it to be O(n^2)?\n    ", "Answer": "\r\nWorst case for quick sort is when the pivot is less than or greater than all of the other values left to be sorted. In this case only 1 item is removed from the remaining values at each level of recursion, and the time complexity ends up O(n^2).\n\nFor a basic merge sort, top down or bottom up, the number of moves is always the same. The number of compares depends on the data pattern. When merging two runs of size n each, the worst case number of compares is 2n-1 (when every element but 1 from the two runs is compared, when there's just 1 element remaining, there's nothing to compare to, so it's just copied), the best case is when all of the elements of one run are less than the first element of the other run, in which case the number of compares is n, such as when the data is already sorted or reverse sorted.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursion not exiting on the base case in merge sort\r\n                \r\nI am learning python and was implementing 2D matrix merge sort and my code goes to infinite loop while calling merge sort and i am unable to find the reason for the same.\n```\ndef mergesort(arr,l,r,u,d):\n    if(l>=r or u>=d):\n        return\n\n    else :\n        mid_h = l + int((r-1)/2)\n        mid_v = u + int((d-1)/2)\n\n        print( l,mid_h)\n        print(u,mid_v)\n\n        mergesort(arr,l,mid_h,u,mid_v)\n        mergesort(arr,mid_h+1,r,u,mid_v)\n        mergesort(arr,l,mid_h,mid_v+1,d)\n        mergesort(arr,mid_h+1,r,mid_v+1,d)\n\n        merge_row(arr,l,mid_h,r,u,mid_v,d)\n        merge_col(arr,l,mid_h,r,u,mid_v,d)\n```\n\n    ", "Answer": "\r\nYour midpoints aren't actually midpoints. Consider ```\nl == 5```\n and ```\nr == 8```\n. Then ```\nl + r//2 == 5 + 4 == 9```\n.\nInstead, you want\n```\n# Add half the distance between the endpoints, not half the far endpoint.\nmid_h = l + (r - l) // 2\nmid_v = u + (d - u) // 2\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C++ Merge Sort Count Comparison\r\n                \r\nI am working on a project that asks us to implement different sorts and add counter variables to measure the runtime with different array sizes. My problem is that my current output is not matching the expected output for my Merge Sort. Its only off by a bit.\nAny suggestions on what is wrong?\nOutput:\n```\nArray Size:          10         100         1000         10000\n--------------------------------------------------------------------\nMerge sort           19          569         9275       129630\n```\n\nExpected Output:\n```\nArray Size:          10         100         1000         10000\n--------------------------------------------------------------------\nMerge Sort           19         550         8706         120355 \n\n```\n\nWhats inside the contents of the array for array size 10\n```\nMerge sort\n\n[ 935, 942, 697, 299, 382, 579, 408, 181, 366, 505 ] //unsorted\n[ 181, 299, 366, 382, 408, 505, 579, 697, 935, 942 ] //sorted\n```\n\nProgram:\n```\n#include <iostream>\n#include <stdlib.h>\n#include <iomanip>\n#include <cmath>\n      /******************************/\n      /* Start of Merge Algorithm   */\n      /******************************/\n\n /**\n  * The maximum size of the temporary array\n  */\nconst int MAX_SIZE = 10000;\n\nint count = 0; //I added this global variable but It seems Incorrect\n\n/**\n * Merges two sorted array segments theArray[first..mid] and\n *    theArray[mid+1..last] into one sorted array.\n */\ntemplate<class ItemType>\nvoid merge(ItemType theArray[], int first, int mid, int last) {\n    ItemType tempArray[MAX_SIZE];  // Temporary array\n    // Initialize the local indices to indicate the subarrays\n    int first1 = first;            // Beginning of first subarray\n    int last1 = mid;               // End of first subarray\n    int first2 = mid + 1;          // Beginning of second subarray\n    int last2 = last;              // End of second subarray\n    // While both subarrays are not empty, copy the\n    // smaller item into the temporary array\n    int index = first1;            // Next available location in tempArray\n    while ((first1 <= last1) && (first2 <= last2)) {\n        // At this point, tempArray[first..index-1] is in order\n        if (theArray[first1] <= theArray[first2]) {\n            tempArray[index] = theArray[first1];\n            first1++;\n            count++; //I incremented count here\n        }\n        else {\n            tempArray[index] = theArray[first2];\n            first2++;\n            count++; //I incremented count here\n        }  // end if\n        index++;\n\n    }  // end while\n\n    // Finish off the first subarray, if necessary\n    while (first1 <= last1) {\n        // At this point, tempArray[first..index-1] is in order\n        tempArray[index] = theArray[first1];\n        first1++;\n        index++;\n    }  // end while\n\n    // Finish off the second subarray, if necessary\n    while (first2 <= last2) {\n        // At this point, tempArray[first..index-1] is in order\n        tempArray[index] = theArray[first2];\n        first2++;\n        index++;\n    }  // end for\n\n    // Copy the result back into the original array\n    for (index = first; index <= last; index++) {\n        theArray[index] = tempArray[index];\n    }\n}\n\n/**\n * Sorts the items in an array into ascending order.\n */\ntemplate<class ItemType>\nint mergesort(ItemType theArray[], int first, int last) {\n    if (first < last) {\n        // Sort each half\n        int mid = first + (last - first) / 2;\n\n        // Sort left half theArray[first..mid]\n         mergesort(theArray, first, mid);\n\n        // Sort right half theArray[mid+1..last]\n         mergesort(theArray, mid + 1, last);\n        // Merge the two halves\n        merge(theArray, first, mid, last);\n    }\n    return count; //return count here\n}\n\n\n      /******************************/\n      /* Start of Sorting Benchmark  */\n      /******************************/\n/**\n * Generate an array of random integers\n */\nint* makeRandomArray(int n, int seed) {\n    srand(seed);\n    int * a = new int[n];\n    for (int i = 0; i < n; i++) {\n        a[i] = rand() % 1000;\n    }\n    return a;\n}\n\nint main(){\n    const int seed = 9000;\n    int *a;\n    /******************************/\n    /* Start of Merge Sort    */\n    /******************************/\n    std::cout << \"Merge sort\";\n\n    int n = 10;\n    a = makeRandomArray(10, seed);\n    std::cout <<std::setw(13)<< mergesort(a, 0, n-1);\n    delete[] a;\n\n    n = 100;\n    a = makeRandomArray(100, seed);\n    std::cout <<std::setw(13)<< mergesort(a, 0, n-1);\n    delete[] a;\n\n    n = 1000;\n    a = makeRandomArray(1000, seed);\n    std::cout <<std::setw(13)<< mergesort(a, 0, n-1);\n    delete[] a;\n\n    n = 10000;\n    a = makeRandomArray(10000, seed);\n    std::cout <<std::setw(13)<< mergesort(a, 0, n-1)<<std::endl;\n    delete[] a;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "External Merge Sort\r\n                \r\nI am trying to implement External merge sort for my DBMS project. I have a 3 file each with 20 pages and my buffer size is 20 pages . \nEach of these i have sorted now . So all three files of 20 pages are sorted. Now  while merging i need to bring 6 pages  of each files (6x3=18 pages ) and 1 page to write the sorted output . And this has to be done 4 times to get whole file complete sorted .\nBut i am finding difficult to merge all these files ? any steps how to perform merge of 3 files making sure that every pages is brought in buffer size .Any recursive function ?\nAll the files content are stored in array a[fileno][pageno] format \neg a[1][20] =5 mean i have a data of 5 in the page no 20 of File 1 .\nAssuming the page of a file hold an integer .\n    ", "Answer": "\r\nAssuming you do a 3 way merge, that's 3 inputs and 1 output, and it only has to be done once. Divide buffer into 4 parts, 5 pages each. Start by reading the first 5 pages of the 3 files, each into it's on 5 page buffer. Start a 3 way merge by comparing the first records in each of the 3 buffers and move the smallest to the output buffer. When the output buffer is filled (5 pages), write it out and continue. When an input buffer is emptied, read in the next 5 pages for that file.\n\nWhen the end of one of the three input files is reached, the code switches to a 2 way merge. To simplify the code, copy the file related parameters into the parameters for file 0 and file 1. If file 2 goes empty first, nothing needs to be done. If file 1 goes empty first, copy file 2 parameters to file 1. If file 0 goes empty first, copy file 1 parameters to file 0, then file 2 parameters to file1. Then do the 2 way merge using file 0 and file 1.\n\nWhen the end of of the two input files is reaches, the code switches to just copy the remaining file. Again, if file 0 goes empty first, then copy file 1 parameters to file 0, so that the copy code always works with file 0.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Does merge sort essentially trade space for time when compared to insertion sort\r\n                \r\nI am trying to understand, kinda intuitively, how the runtime for merge sort is so much better than insertion sort.\n\nEven though we divide and conquer with merge sort, on a single CPU, each of the nodes of the merge sort execution tree will be executed serially. Is the smaller input size on every recursive call (iteration) somehow the key thing for merge sort?\n\nOr is it the fact that since merge sort is not in-place and uses O(n) space this saves on the number of shifts we have to do in insertion sort to make space for the insertion of the smaller number.\nBut what about the penalty of copying the elements in left and right temporary arrays in every merge step?\n    ", "Answer": "\r\nYes, that smaller input size is in large part where the speed up of mergesort comes from compared with insertion sort. The fact that mergesort uses more space is more an artifact of how it works than an inherent reason for the speedup.\n\nHere’s one way to see this. We know that insertion sort, on average, takes time Θ(n2). Now, suppose you want to insertion sort an array of n elements. Instead, you cut the array apart into two smaller arrays of size roughly n/2 and insertion sort each of those. How long will this take? Since insertion sort has quadratic runtime, the cost of insertion sorting each half will be roughly one quarter the cost of insertion sorting the whole array ((n/2)2 = n2 / 4). Since there are two of those arrays, the total cost of sorting things this way will be roughly \n\n\n  2(n2 / 4) = n2 / 2,\n\n\nwhich is half the time required to sort the original array. This gives rise to a simple sorting algorithm that’s an improvement over insertion sort:\n\n\nSplit the array in half.\nInsertion sort each half.\nMerge the two halves together.\n\n\nThat last step introduces linear space overhead for the merge, though you could do it with an in-place merge at a higher cost.\n\nThis algorithm, “split sort,” is about twice as a fast as insertion sort. So then you might ask - why split in halves? Why not quarters? After all, the cost of sorting one quarter of the array is about\n\n\n  (n/4)2 = n2 / 16,\n\n\nwhich is sixteen times faster than sorting the original array! We could turn that into a sorting algorithm like this:\n\n\nSplit the array into quarters.\nInsertion sort each quarter.\nMerge the quarters into halves.\nMerge the halves into the full array.\n\n\nThis will be about four times faster than insertion sort (each sort takes one sixteenth the time of the original sort, and we do four of them).\n\nYou can think of mergesort as the “limit” of this process where we never stop splitting and divide the array into the smallest units possible and then merge them all back together at the end. The speedup is based on the fact that sorting smaller arrays is inherently faster than sorting larger arrays, with the memory overhead for the merge being more of an implementation detail than an intrinsic reason for the speedup.\n\nAnother way to see that the space usage isn’t necessary for the speedup is to compare insertion sort to heapsort. Heapsort also runs in time O(n log n) but uses only O(1) auxiliary space.\n\nHope this helps!\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "recursive merge sort in python\r\n                \r\nI am trying to make merge sort using two functions in python. But I got an error like\nIndexError: list assignment index out of range whenever run my code. I don't know which part is wrong.\nThis is my code below. \nAny help will appreciate!!\n\n```\ndef merge(A):\n\n    def merge_sort(A,first,last):\n        if first<last:\n            mid=(first+last)//2\n            merge_sort(A,first, mid)\n            merge_sort(A,mid+1,last)\n\n            temp=[]\n            temp.append(99999)\n            i=first\n            j=mid+1\n            k=0\n            while i<=mid and j<=last:\n                if A[i]<=A[j]:\n                    temp[k]=A[i]\n                    k=k+1\n                    i=i+1\n                else:\n                    temp[k]=A[j]\n                    k=k+1\n                    j=j+1\n            while i<=mid:\n                temp[k]=A[i]\n                k=k+1\n                i=i+1\n            while j<=last:\n                temp[k]=A[j]\n                k=k+1\n                j=j+1\n            a=0\n            b=first\n            while a<k:\n                A[b]=temp[a]\n                b=b+1\n                a=a+1\n\n    merge_sort(A,0,len(A)-1)\n\n    return A\n```\n\n    ", "Answer": "\r\nYou can not assign a value to ```\ntemp[k]```\n as long as this element does not exist.\n\nDelete the row ```\ntemp.append(99999)```\n, replace every ```\ntemp[k]=A[i]```\n by ```\ntemp.append(A[i])```\n and every ```\ntemp[k]=A[j]```\n by ```\ntemp.append(A[j])```\n.\n\nYou will end up with: \n\n```\ndef merge(A):\n\n    def merge_sort(A,first,last):\n        if first<last:\n            mid=(first+last)//2\n            merge_sort(A,first, mid)\n            merge_sort(A,mid+1,last)\n\n            temp=[]\n            i=first\n            j=mid+1\n            k=0\n            while i<=mid and j<=last:\n                if A[i]<=A[j]:\n                    temp.append(A[i])\n                    k=k+1\n                    i=i+1\n                else:\n                    temp.append(A[j])\n                    k=k+1\n                    j=j+1\n            while i<=mid:\n                temp.append(A[i])\n                k=k+1\n                i=i+1\n            while j<=last:\n                temp.append(A[j])\n                k=k+1\n                j=j+1\n            a=0\n            b=first\n            while a<k:\n                A[b]=temp[a]\n                b=b+1\n                a=a+1\n\n    merge_sort(A,0,len(A)-1)\n\n    return A\n\n\nA = [1,9,4,5]\nprint(A)\nprint(merge(A))\n```\n\n\nOutput: \n\n```\n[1, 9, 4, 5]\n[1, 4, 5, 9]\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Recursive Merge sort in java\r\n                \r\nI have been studying on merge sort as algorithm and visualization. When I went through the coding part, it was kinda challenging for me. But, I still did the coding with a runtime error. The error is NullPointerException. Please help me. It's a school project.\n\n```\npublic class test\n{       \n    public static void main (String[]args)\n    {               \n        int arr[]={11,34,65,89,1,456,90,85,12,70};\n        mergesort(arr,0,9);\n        for(int a=0;a<arr.length;a++)\n            System.out.println(arr[a]);\n    }\n\n    public static void mergesort (int arr[], int low, int high)\n    {           \n        int middle;\n        if(low<high)\n        {\n        middle = (low+high)/2;\n        mergesort(arr,low,middle);\n        mergesort(arr,middle+1,high);\n        merge(arr,low,middle,high);\n        }           \n    }\n\n    public static void merge(int arr[], int low, int middle, int high)\n    {\n        Queue<Integer> buffer1 = new LinkedList<Integer>();     \n        Queue<Integer> buffer2 = new LinkedList<Integer>(); \n        int i;\n\n        for(int a=low;a<middle;a++) buffer1.add(arr[a]);\n        for(int a=middle+1;a<high;a++) buffer2.add(arr[a]);\n        i=low;\n        while(!(buffer1.isEmpty()) && !(buffer2.isEmpty()))\n        {\n            if(buffer1.peek() <= buffer2.peek())\n            {\n                arr[i] = buffer1.poll();\n\n            } else\n            {\n                arr[i] = buffer2.poll();                    \n            }               \n        }\n        while(!(buffer1.isEmpty()))\n        {\n            arr[i] = buffer1.poll();\n        }\n        while(!(buffer2.isEmpty()))\n        {\n            arr[i] = buffer2.poll();\n        }\n    }\n\n}\n```\n\n    ", "Answer": "\r\nChange your for loops like this\n\n```\nfor(i=low;i<=middle;i++)\n{\n    buffer1.add(arr[i]);                \n}\nfor(i=middle+1;i<=high;i++)\n{\n    buffer2.add(arr[i]);\n}\n```\n\n\nHere low and high denote the index of first and last elements of array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Segfault in C++ merge sort code\r\n                \r\nTrying to get this to work.. GDB seems to indicate that the indexes might be off for some reason. I'm using a vector of a subclass called Record containing mainly population (int) and name (string) that needs to be sorted both ways. bt indicates null pointer at line 27 which is the 'if' statement in the isSmaller() function. This function works perfectly well with an insertion sort code in the same program, but not the merge sort, so I'm wondering what's wrong with the merge sort code. Please advise. Is something wrong with the algorithm?\n\nbt returns the following:\n\n```\n#0  0x0000000000403160 in CensusData::isSmaller (this=0x7fffffffdd10, type=0,     r1=0x609590, r2=0x0) at CensusDataSorts.cpp:27\n#1  0x0000000000403510 in CensusData::mergeIt (this=0x7fffffffdd10, type=0,     list=..., p=0, q=1, r=2) at CensusDataSorts.cpp:96\n#2  0x0000000000403347 in CensusData::mergeSortIt (this=0x7fffffffdd10,     type=0, list=..., p=0, r=2) at CensusDataSorts.cpp:70\n#3  0x0000000000403645 in CensusData::mergeSort (this=0x7fffffffdd10, type=0)    at CensusDataSorts.cpp:113\n#4  0x0000000000401a50 in runMergeSorts (fp=...) at CensusSort.cpp:106\n#5  0x0000000000401e6f in main (argc=2, argv=0x7fffffffe068)    at CensusSort.cpp:174\n```\n\n\nCode appears below\n\n```\nbool CensusData::isSmaller(int type, Record* r1, Record* r2)\n{\n    if(type==POPULATION)\n    {\n        if(r1->population <= r2->population)\n            return true;\n    }\n\n    else if(type==NAME)\n    {\n        if(*(r1->city) <= *(r2->city))\n            return true;\n    }\n\n    return false;        \n}\n\nvoid CensusData::mergeSortIt(int type, vector<Record*>& list, int p, int r)\n{\n    if(p < r)\n    {\n        int q = floor((p+r)/2);\n        mergeSortIt(type,list,p,q);\n        mergeSortIt(type,list,q+1,r);\n        mergeIt(type,list,p,q,r);\n    }        \n}    \n\nvoid CensusData::mergeIt(int type, vector<Record*>& list, int p, int q, int r)\n{\n    int n1=q-p+1;\n    int n2=r-q;\n    int i,j;\n\n    vector<Record*> L(n1,0);\n    vector<Record*> R(n2,0);\n\n    for(i=0; i<n1; i++)\n        L[i]=list[p+i];\n\n    for(j=0; j<n2; j++)\n        R[j]=list[q+j+1];\n\n    i=0;\n    j=0;\n\n    for(int k=p; k<=r; k++)\n    {\n        if(isSmaller(type,L[i],R[j]))\n        {\n            list[k]=L[i];\n            i++;\n        }\n        else\n        {\n            list[k]=R[j];\n            j++;\n        }\n    }\n}\n\nvoid CensusData::mergeSort(int type)\n{\n    mergeSortIt(type, data, 0, data.size()-1);\n}\n```\n\n    ", "Answer": "\r\nthe problem is the way you rewrite merged records:\n\n```\nfor(int k=p; k<=r; k++)\n{\n    // Here i or j can be outside L/R bounds\n    if(isSmaller(type,L[i],R[j]))\n    {\n        list[k]=L[i];\n        i++;\n    }\n    else\n    {\n        list[k]=R[j];\n        j++;\n    }\n}\n```\n\n\nhere is rewritten version:\n\n```\nint k=p;\nfor(; k<=r; k++)\n{\n    if(isSmaller(type,L[i],R[j]))\n    {\n        list[k]=L[i];\n        i++;\n        if ( i == L.size() )\n          break;\n    }\n    else\n    {\n        list[k]=R[j];\n        j++;\n        if ( j == R.size() )\n          break;\n    }\n}\nfor ( ; i < L.size(); ++i )\n  list[k++]=L[i];\nfor ( ; j < R.size(); ++j )\n  list[k++]=R[j];\n```\n\n\nI am not sure if this makes your program work as intended, but it should fix your segfault.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort with TypeScript\r\n                \r\nI have tried to implement a simple merge sort in TypeScript. Unfortunately half of my array is missing from the result. Could someone more experienced explain to me please why it is missing?\nSource:\n```\nfunction mergeSort(arr:number[]):number[]{\n    if(arr.length <= 1){\n        return arr;\n    }\n\n    const half:number = Math.floor(arr.length/2);\n    const first:number[] = mergeSort(arr.slice(0,half));\n    const second:number[] = mergeSort(arr.slice(half + 1));\n\n    return merge(first, second);\n}\n\nfunction merge(a:number[], b:number[]):number[]{\n    const c:number[] = [];\n    while(a.length && b.length){\n        if(a[0]<b[0]){\n            c.push(a.shift()!);\n        }else{\n            c.push(b.shift()!);\n        }\n    }\n\n    while(a.length){\n        c.push(a.shift()!);\n    }\n\n    while(b.length){\n        c.push(b.shift()!);\n    }\n\n    return c;\n}\n\nconsole.log(mergeSort([4, 53, 22, 10, 2, 74, 91, 33, 25, 14, 19, 100, 256, 81, 7, 300]));\n```\n\nCurrent output: [4, 10, 14, 33, 74, 81, 100, 300]\nExpected output: [2, 4, 7, 10, 14, 19, 22, 25, 33, 53, 74, 81, 91, 100, 256, 300]\nThank you for your time and answer!\n    ", "Answer": "\r\nI think you are loosing a number at ```\nhalf```\n index each time you split your array.\nBecause neither of these two slices include item at ```\nhalf```\n index.\n```\nconst first:number[] = mergeSort(arr.slice(0,half));\nconst second:number[] = mergeSort(arr.slice(half + 1));\n```\n\nTo fix that you need to include that item either in the first half:\n```\nconst first:number[] = mergeSort(arr.slice(0,half + 1));\n```\n\nOr include it in to the second half:\n```\nconst second:number[] = mergeSort(arr.slice(half));\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Implementation using C++\r\n                \r\nI am having trouble with trying to implement the merge sort algorithm. I would appreciate it if someone can help me out. Here is what I have.\n\n```\n#include <iostream>\n#include <deque>\nusing size_type = std::deque<int>::size_type;\nvoid print(std::deque<int> &v)\n{\n    for(const auto &ref:v)\n        std::cout << ref << \" \";\n    std::cout << std::endl;\n}\nvoid merge(std::deque<int> &vec, size_type p, size_type q, size_type r)\n{\n    int n_1 = q - p;\n    int n_2 = r - q;\n    std::deque<int> left, right;\n    for(auto i = 0; i != n_1; i++)\n        left.push_back(vec[p + i]);\n    for(auto j = 0; j != n_2; j++)\n        right.push_back(vec[q + j]);\n    int i = 0, j = 0;\n    std::cout << \"left = \";\n    print(left);\n    std::cout << \"right = \";\n    print(right);\n    for(auto k = p; k != r; k++) {\n        if(i < n_1 && left[i] <= right[j]) {\n            vec[k] = left[i];\n            i++;\n        }\n        else if(j < n_2){\n            vec[k] = right[j];\n            j++;\n        }\n    }\n}\nvoid merge_sort(std::deque<int> &A, size_type p, size_type r)\n{\n    int q;\n    if(p < r) {\n        q = (p + r)/2;\n        merge_sort(A, p, q);\n        merge_sort(A, q + 1, r);\n        merge(A, p, q, r);\n    }\n}\nint main()\n{\n    std::deque<int> small_vec = {1, 6, 2, 10, 5, 2, 12, 6};\n    std::deque<int> samp_vec = {2, 9, 482, 72, 42, 3, 4, 9, 8, 73, 8, 0, 98, 72, 473, 72, 3, 4, 9, 7, 6, 5, 6953, 583};\n    print(small_vec);\n    merge_sort(small_vec, 0, small_vec.size());\n    print(small_vec);\n    return 0;\n}\n```\n\n\nThe output from the program is:\n\n```\nleft = \nright = 1 \nleft = 1 \nright = 6 \nleft = \nright = 10 \nleft = 1 6 \nright = 2 10 \nleft = \nright = 2 \nleft = \nright = 6 \nleft = 2 \nright = 12 6 \nleft = 1 2 6 10 \nright = 5 2 12 6 \n1 2 5 2 6 10 12 6 \n```\n\n    ", "Answer": "\r\nThere are a few issues with your sort. Firstly the merge step is wrong. Second how you call merge is wrong. Ill suggest a few steps to improve the implementation to a correct solution, and maybe itll help you.\n\nFirst my code for merge:\n\n```\nvoid merge(std::deque<int> &vec, size_type p, size_type q, size_type r)\n{\n  std::deque<int> left, right;\n  int i = p, j = q+1;\n  while(i <= q) //change 1: to a while loop. expresses it a little simpler but \n                //you weren't inserting the correct left elements here\n    left.push_back(vec[i++]);\n  while(j <= r) //change 2: same thing, lets get the correct right values\n    right.push_back(vec[j++]);\n  i = 0; j = 0;\n  for(auto k = p; k <= r; k++) {\n    //change 3: alter this case to include the left over left elements! this is the main error\n    if(i < left.size() && left[i] <= right[j] || j >= right.size())\n        vec[k] = left[i++];\n    else if(j < right.size())\n        vec[k] = right[j++];\n  }\n}\n```\n\n\nThen to change how you call merge_sort to:\n\n```\nmerge_sort(small_vec, 0, small_vec.size()-1); //change 4: initialized r wrong\n```\n\n\nThis made the sort work for me. As a review of the problems I found: 1) not grabbing the correct subarrays of left and right. 2) didn't handle merge correctly - forgot to grab all the left elements after right is gone. 3) didn't call merg_sort correctly, initializing the r parameter incorrectly.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Parallel merge sort using OPENMP\r\n                \r\nI have a written a sequential merge sort program as below:\n\n```\n#include \"stdafx.h\"\n#include \"iostream\"\n#include \"omp.h\"\n#include \"fstream\"\nusing namespace std;\n\nint a[50];\nvoid merge(int,int,int); \nvoid merge_sort(int low,int high)\n{\nint mid,newval;\ndouble clock, clock1,clock2;\nif(low<high)\n {\n    mid=(low+high)/2;\n    #pragma omp parallel shared(low,mid,high) num_threads(2)\n    {\n        //newval=omp_get_thread_num();\n        //cout<<\"thread: \"<<newval<<endl;\n        merge_sort(low,mid);\n        clock=omp_get_wtime();\n        //cout<<\"Clock: \"<<clock<<endl;\n        merge_sort(mid+1,high);\n        merge(low,mid,high);\n        clock1=omp_get_wtime();\n        //cout<<\"Clock1: \"<<clock<<endl;\n        clock2=clock1-clock;\n        cout<<\"Clock2: \"<<clock2<<endl;\n    }       \n    //cout<<\"valud=%d\"<<low<<endl; \n }\n }\n void merge(int low,int mid,int high)\n {\n int h,i,j,b[50],k;\n h=low;\n i=low;\n j=mid+1;\n\n while((h<=mid)&&(j<=high))\n {\n    if(a[h]<=a[j])\n    {\n        b[i]=a[h];\n        h++;\n    }\n    else\n    {\n        b[i]=a[j];\n        j++;\n    }\n    i++;\n }\n if(h>mid)\n {\n    for(k=j;k<=high;k++)\n    {\n        b[i]=a[k];\n        i++;\n    }\n }\n else\n {\n    for(k=h;k<=mid;k++)\n    {\n        b[i]=a[k];\n        i++;\n    }\n }\n for(k=low;k<=high;k++) a[k]=b[k];\n    }\n\n    void main()\n    {\nint num,i;\nint clock_n,len;\nFILE *fp;\nchar *buf;\nchar *newchat;//ifstream properfile;\n\n\ncout<<\"********************************************************************************\"<<endl;\ncout<<\"                             MERGE SORT PROGRAM\"<<endl;\n\ncout<<\"********************************************************************************\"<<endl;\ncout<<endl<<endl;\ncout<<\"Please Enter THE NUMBER OF ELEMENTS you want to sort [THEN PRESS ENTER]:\"<<endl;\ncout<<endl;\n//cout<<\"Now, Please Enter the ( \"<< num <<\" ) numbers (ELEMENTS) [THEN PRESS ENTER]:\"<<endl;\n//for(i=1;i<=num;i++)\n//{\n        fp=fopen(\"E:\\\\Study\\\\Semester 2\\\\Compsci 711- Parallel and distributed computing\\\\Assignment\\\\sample_10.txt\",\"rb\");\nfseek(fp,0,SEEK_END); //go to end\nlen=ftell(fp); //get position at end (length)\ncout<<\"Length is %d\"<<len<<endl;\n//fseek(fp,0,SEEK_SET); //go to beg.\nbuf=(char *)malloc(len); //malloc buffer\nnewchat=buf;\nfread(newchat,len,1,fp); //read into buffer\nfclose(fp);\n//cout<<\"Read %c\"<<newchat<<endl;\n\n////cin>>num;\n\n\n//}\n\n    merge_sort(1,len);\n\ncout<<endl;\ncout<<\"So, the sorted list (using MERGE SORT) will be :\"<<endl;\ncout<<endl<<endl;\n\nfor(i=1;i<=num;i++)\ncout<<a[i]<<\"   \";\ncout<<endl<<endl<<endl<<endl;\n\n  }\n```\n\n\nNow I want to parallelize this code(API used for parallelization in C is OPENMP). Can you help people me out? Basically I use #pragma parallel num_thread(4) but I dont know whether I should include anything else in order for parallelization to take place.\n    ", "Answer": "\r\nThe main bottleneck of a merge-sort algorithm is the merge function. Its complexity is O(n). \nThe cost of first few merge operations is going to dominate the cost of your complete application. Use an optimized parallel algorithm for larger arrays. \n\nFor smaller arrays (<20 elements), avoid the barriers. Actually I would prefer a sequential O(n^2) algorithm.\n\nShouldn't you use sections instead of  ```\n#pragma omp parallel shared(low,mid,high) num_threads(2)```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Implementation of merge sort in python3\r\n                \r\nI'm taking an Algorithms course online, and the first sorting algorithm they've analysed and asked us to implement in any language of choice is merge sort.\nI implemented it in python: \n\n```\ndef mergeSort(arr):\n\n    while len(arr) > 1:\n        mid = len(arr) // 2\n        l = arr[:mid]\n        r = arr[mid:]\n\n        mergeSort(l)\n        mergeSort(r)\n\n        i = j = k = 0\n\n        while i < len(l) and j < len(r):\n            if l[i] < r[j]:\n                arr[k] = l[i]\n                i+=1\n            else:\n                arr[k] = r[j]\n                j+=1\n            k+=1\n\n        while i < len(l):\n            arr[k] = l[i]\n            i+=1\n            k+=1\n\n        while j < len(r):\n            arr[k] = r[j]\n            j+=1\n            k+=1\n\nif __name__ == '__main__':\n\n    arr = [1,6,2,5,3,4]\n    mergeSort(arr)\n    print(arr)\n```\n\n\nWhen I execute this program, absolutely nothing is printed out. Why?\n    ", "Answer": "\r\n```\nmergesort```\n has an infinite loop for non trivial arrays.\n\nYou must change the ```\nwhile len(arr) > 1:```\n to ```\nif len(arr) > 1:```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in agda\r\n                \r\nI want to implement merge sort in agda. If I do this in a naive way, the termination checker fails to pass the program because after we split input list into two parts, and then call ourselves recursively, agda doesn't know that size of each of the lists is smaller than the size of the original list.\n\nI've seen several solutions, for example this one: https://gist.github.com/twanvl/5635740 but the code seems too complicated to me, and the worst thing is that we intermix the program and the proof.\n    ", "Answer": "\r\nThere are at least three ways in which you can write merge sort so that it passes the termination checker.\n\nFirst of all, here's what we need to make our merge sort generic:\n\n```\nopen import Relation.Binary\nopen import Relation.Binary.PropositionalEquality\n\nmodule MergeSort\n  {ℓ a} {A : Set a}\n  {_<_ : Rel A ℓ}\n  (strictTotalOrder : IsStrictTotalOrder _≡_ _<_) where\n\nopen IsStrictTotalOrder strictTotalOrder\n```\n\n\nOnce we prove that some relation is a strict total order, we can use that proof as a parameter to this module and get corresponding merge sort.\n\n\n\nThe first way is to use well-founded recursion, which is more or less what the linked code in your question uses. However, we do not need to prove that merge sort returns a sorted permutation of its input list in a bounded number of comparisions, so we can cut most of the code.\n\nI wrote something about well-founded recursion in this answer, you might want to check it out.\n\nOther imports first:\n\n```\nopen import Data.List\nopen import Data.Nat\n  hiding (compare)\nopen import Data.Product\nopen import Function\nopen import Induction.Nat\nopen import Induction.WellFounded\n```\n\n\nHere's the implementation of ```\nmerge```\n:\n\n```\nmerge : (xs ys : List A) → List A\nmerge [] ys = ys\nmerge xs [] = xs\nmerge (x ∷ xs) (y ∷ ys) with compare x y\n... | tri< _ _ _ = x ∷ merge xs (y ∷ ys)\n... | tri≈ _ _ _ = x ∷ merge xs (y ∷ ys)\n... | tri> _ _ _ = y ∷ merge (x ∷ xs) ys\n```\n\n\nIf you are having problems getting this past termination checker, check out my answer on this. It should work as is with the development version of Agda.\n\n```\nsplit```\n is easy as well:\n\n```\nsplit : List A → List A × List A\nsplit [] = [] , []\nsplit (x ∷ xs) with split xs\n... | l , r = x ∷ r , l\n```\n\n\nBut now we get to the complicated part. We need to show that ```\nsplit```\n returns two lists that are both smaller than the original (which of course holds only if the original list had at least two elements). For this purpose, we define a new relation on lists: ```\nxs <ₗ ys```\n holds iff ```\nlength x < length y```\n:\n\n```\n_<ₗ_ : Rel (List A) _\n_<ₗ_ = _<′_ on length\n```\n\n\nThe proof is then fairly straightforward, it's just an induction on the list:\n\n```\n-- Lemma.\ns≤′s : ∀ {m n} → m ≤′ n → suc m ≤′ suc n\ns≤′s ≤′-refl     = ≤′-refl\ns≤′s (≤′-step p) = ≤′-step (s≤′s p)\n\nsplit-less : ∀ (x : A) y ys →\n  let xs    = x ∷ y ∷ ys\n      l , r = split (x ∷ y ∷ ys)\n  in l <ₗ xs × r <ₗ xs\nsplit-less _ _ [] = ≤′-refl , ≤′-refl\nsplit-less _ _ (_ ∷ []) = ≤′-refl , ≤′-step ≤′-refl\nsplit-less _ _ (x ∷ y ∷ ys) with split-less x y ys\n... | p₁ , p₂ = ≤′-step (s≤′s p₁) , ≤′-step (s≤′s p₂)\n```\n\n\nNow we have everything we need in order to bring the well-founded recursion machinery. Standard library gives us proof that ```\n_<′_```\n is well-founded relation, we can use this to construct a proof that our freshly defined ```\n_<ₗ_```\n is also well-founded:\n\n```\nopen Inverse-image {A = List A} {_<_ = _<′_} length\n  renaming (well-founded to <ₗ-well-founded)\n\nopen All (<ₗ-well-founded <-well-founded)\n  renaming (wfRec to <ₗ-rec)\n```\n\n\nAnd finally, we use ```\n<ₗ-rec```\n to write ```\nmerge-sort```\n.\n\n```\nmerge-sort : List A → List A\nmerge-sort = <ₗ-rec _ _ go\n  where\n  go : (xs : List A) → (∀ ys → ys <ₗ xs → List A) → List A\n  go [] rec = []\n  go (x ∷ []) rec = x ∷ []\n  go (x ∷ y ∷ ys) rec =\n    let (l , r)   = split (x ∷ y ∷ ys)\n        (p₁ , p₂) = split-less x y ys\n    in merge (rec l p₁) (rec r p₂)\n```\n\n\nNotice that in the recursive call (```\nrec```\n), we not only specify what to recurse on, but also a proof that the argument is smaller than the original one.\n\n\n\nThe second way is to use sized types. I also wrote an overview in this answer, so you might want to check it out.\n\nWe need this pragma at the top of the file:\n\n```\n{-# OPTIONS --sized-types #-}\n```\n\n\nAnd a different set of imports:\n\n```\nopen import Data.Product\nopen import Function\nopen import Size\n```\n\n\nHowever, we cannot reuse lists from standard library since they do not use sized types. Let's define our own version:\n\n```\ninfixr 5 _∷_\n\ndata List {a} (A : Set a) : {ι : Size} → Set a where\n  []  : ∀ {ι} →                  List A {↑ ι}\n  _∷_ : ∀ {ι} → A → List A {ι} → List A {↑ ι}\n```\n\n\n```\nmerge```\n stay more or less the same, we only need to change the type a bit to convince the termination checker:\n\n```\nmerge : ∀ {ι} → List A {ι} → List A → List A\n```\n\n\nHowever, ```\nsplit```\n has a slight but very important change:\n\n```\nsplit : ∀ {ι} → List A {ι} → List A {ι} × List A {ι}\nsplit [] = [] , []\nsplit (x ∷ xs) with split xs\n... | l , r = x ∷ r , l\n```\n\n\nThe implementation stays the same, but the type changed. What this change does is that it tells Agda that ```\nsplit```\n is size-preserving. This means that the two resulting lists cannot be larger than the input one. ```\nmerge-sort```\n then looks very natural:\n\n```\nmerge-sort : ∀ {ι} → List A {ι} → List A\nmerge-sort [] = []\nmerge-sort (x ∷ []) = x ∷ []\nmerge-sort (x ∷ y ∷ ys) =\n  let l , r = split ys\n  in  merge (merge-sort (x ∷ l)) (merge-sort (y ∷ r))\n```\n\n\nAnd indeed, this gets past the termination checker. The trick is the above mentioned size-preserving property: Agda can see that ```\nsplit ys```\n does not produce lists larger than ```\nys```\n and thus ```\nx ∷ l```\n and ```\ny ∷ r```\n are both smaller than ```\nx ∷ y ∷ ys```\n. This is enough to convince the termination checker.\n\n\n\nThe last one is not really a merge sort in the usual sense. It uses the same idea but instead of repeatedly splitting the lists, recursively sorting them and then merging them together, it does all the splitting upfront, stores the results in a tree and then folds the tree using ```\nmerge```\n.\n\nHowever, since this answer is already fairly long, I'll just give you a link.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort List Implementation TopDown + BottomUp + Abstract MergeSort\r\n                \r\nI am trying to implement a Merge Sort for static lists (ArrayLists). I have both the TopDown and the BottomUp implementation. However, I believe that the Abstract Merge Sort is not working. I say this because I have tested both implementations having the same unordered list, which lead me to believe that the merge method is the one that's not working. I can't find the mistake. The private methods are in different classes. I put them here together for easier reading. Here is the code. Thank you in advance.\n\n```\n    public <T> void merge(@NotNull Comparator<T> comparator, @NotNull List<T> list, int lo, int mid, int hi) {\n//        // Merge a[lo..mid] with a[mid+1..hi].\n        List<T> aux = new ArrayList<>(list);// Copy a[lo..hi] to aux[lo..hi].\n        int i = lo, j = mid + 1;\n        for (int k = lo; k <= hi; k++) // Merge back to a[lo..hi].\n            if (i > mid)\n                list.set(k, aux.get(j++));\n            else if (j > hi)\n                list.set(k, aux.get(i++));\n            else if (comparator.compare(list.get(i), list.get(j)) > 0)\n                list.set(k, aux.get(j++));\n            else\n                list.set(k, aux.get(i++));\n    }\n\n\n    public <T> void sort(@NotNull Comparator<T> comparator, @NotNull List<T> list) {\n        sort(comparator, list, 0, list.size() - 1);\n    }\n\n\n\n    //TopDown\n    private <T> void sort(@NotNull Comparator<T> comparator, @NotNull List<T> list, int lo, int hi) {  // Sort a[lo..hi].\n         if (hi <= lo) return;\n         int mid = lo + (hi - lo)/2;\n         sort(comparator, list, lo, mid);       // Sort left half.\n         sort(comparator, list, mid+1, hi);     // Sort right half.\n         merge(comparator, list, lo, mid, hi);  // Merge results\n    }\n\n    //BottomUp\n    private <T> void sort(@NotNull Comparator<T> comparator, @NotNull List<T> list) {\n        for (int mid = 1; mid < list.size(); mid = mid + mid)\n            // mid: subarray size\n            for (int lo = 0; lo < list.size() - mid; lo += mid + mid) { // lo: subarray index\n                merge(comparator, list, lo, lo + mid - 1, Math.min(lo + mid + mid - 1, list.size() - 1));\n            }\n    }\n```\n\n    ", "Answer": "\r\nThe code in merge() is comparing the output list elements (list) instead of the input list element (aux).\n\nchange\n\n```\n        else if (comparator.compare(list.get(i), list.get(j)) > 0)\n```\n\n\nto\n\n```\n        else if (comparator.compare(aux.get(i), aux.get(j)) > 0)\n```\n\n\nIs there a reason that merge() is not private, and that merge() and sort() are not static?\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Need help implementing a visualizer for merge sort with pygame\r\n                \r\nI am currently building a sorting visualizer using pygame, and I have been able to do bubble and selection sorts so far. What I am currently doing is drawing a frame of the array each time a change is made, which works for the bubble and selection sorts. But for merge sort, there are arrays always being split up and merged back, so I can't draw the array every frame because only a part of the array will show up each frame. I am currently stuck on how to implement the visualizer on merge sort, down bellow i will put an example of what works for the bubble sort, and what i currently have for merge sort.\n```\n# Bubble sort\ndef bubble_sort_visual(array, window, delay):\nfor i in range(len(array)):\n    for j in range(0, len(array)-i-1):\n        if array[j] > array[j + 1]:\n            temp = array[j]\n            array[j] = array[j + 1]\n            array[j + 1] = temp\n            pygame.draw.rect(screen, RED, (15 + 15*j, 0, 10, temp))\n            pygame.display.update()\n\n        # This block of code is what I use to show the array on screen each frame\n        window.fill(GREEN)\n        array_bars(heights, screen, WHITE) # drawing the array each frame\n        pygame.time.delay(delay)\n        pygame.display.update()\n\n\n # Merge sort\n def merge_sort_visual(array, window, delay):\n if len(array) > 1:\n    mid = len(array) // 2\n    left_array = array[:mid]\n    right_array = array[mid:]\n\n    merge_sort_visual(left_array, screen, 8)\n    merge_sort_visual(right_array, screen, 8)\n\n    left_index = 0\n    right_index = 0\n    sort_index = 0\n\n    while left_index < len(left_array) and right_index < len(right_array):\n        if left_array[left_index] <= right_array[right_index]:\n            array[sort_index] = left_array[left_index]\n            left_index += 1\n\n        else:\n            array[sort_index] = right_array[right_index]\n            right_index += 1\n\n        sort_index += 1\n\n    while left_index < len(left_array):\n        array[sort_index] = left_array[left_index]\n        left_index += 1\n        sort_index += 1\n\n    while right_index < len(right_array):\n        array[sort_index] = right_array[right_index]\n        right_index += 1\n        sort_index += 1\n```\n\nAs seen above, I am not sure where to put the block of code that i put in the bubble sort in the merge sort, i tried for a bit but each time i get the wrong result. Any help would be appreciated, thank you.\n    ", "Answer": "\r\nWith the bubble, you're only dealing with a single array. With the merge sort, you're dealing with recursion and several layers of arrays. Updating the main array is a challenge since each layer of recursion only sees part of the full array.\nThe solution is to pass the partial array location to the child process so the child knows which part of the full array to update.\nHere's the updated code to illustrate the idea:\n```\n # Merge sort\n def merge_sort_visual(start, array, window, delay):  # pass the starting postion of this array within the full array (first call is 0)\n if len(array) > 1:\n        mid = len(array) // 2\n        left_array = array[:mid]\n        right_array = array[mid:]\n\n        # This block of code is what I use to show the array on screen each frame\n        window.fill(GREEN) \n        # for this method, you will need to create a temporary copy of the full array to display on the screen \n        array_bars(start, array, heights, screen, WHITE) # update part of the full array on screen (start location and array length)\n        pygame.time.delay(delay)\n        pygame.display.update()\n\n        merge_sort_visual(start, left_array, screen, 8)  # pass location within full array\n        merge_sort_visual(start+mid, right_array, screen, 8)  # pass location within full array\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "sorting object property by merge sort\r\n                \r\nI want to sort students by their roll numbers. I know how to sort an arraylist of integers using merge sort, but sorting an ArrayList of type Student is different.\n\nmy Student class contains the following properties:\n\n```\npublic static class Student\n    {\n        String name;\n        int rollNum, WebMark, dsMark, dmMark;\n\n        public Student(String name, int rollNum, int WebMark, int dsMark, int dmMark)\n        {\n            this.name = name;\n            this.rollNum = rollNum;\n            this.WebMark = WebMark;\n            this.dsMark = dsMark;\n            this.dmMark = dmMark;\n        }\n}\n```\n\n\nI've seen people use Comparators  to sort ArrayLists of object's properties. However, they use it for built-in sorting like the following line (which is straightforward):\n\n```\nCollections.sort(Database.arrayList, new CustomComparator());\n```\n\n\nHowever, I want to use my mergesort functions that I wrote in my Student class.  But I still don't understand how am I going to pass the property 'rollNum' into the mergesort function and how are other properties in the ArrayList are going to be moved accordingly? I've never seen this anywhere in Google.\n\nHere is my full code:\n\n```\npackage student;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.Comparator;\n\npublic class Main \n{\n    public static class Student\n    {\n        String name;\n        int rollNum, WebMark, dsMark, dmMark;\n\n        public Student(String name, int rollNum, int WebMark, int dsMark, int dmMark)\n        {\n            this.name = name;\n            this.rollNum = rollNum;\n            this.WebMark = WebMark;\n            this.dsMark = dsMark;\n            this.dmMark = dmMark;\n        }\n        public String getName()\n        {\n            return name;\n        }\n        public int getRollNum()\n        {\n            return rollNum;\n        }\n        public int getWebMark()\n        {\n            return WebMark;\n        }\n        public int getDSMark()\n        {\n            return dsMark;\n        }\n        public int getDMMark()\n        {\n            return dmMark;\n        }\n        public static void addStudent(ArrayList<Student> studentArray)\n        {\n            Scanner input = new Scanner(System.in);\n            System.out.println(\"Enter Name: \");\n            String name = input.next();\n            System.out.println(\"Enter Roll Number\");\n            int rollNum = input.nextInt();\n            System.out.println(\"Enter Web Mark:\");\n            int webMark = input.nextInt();\n            System.out.println(\"Enter Data Structure Mark:\");\n            int DSMark = input.nextInt();\n            System.out.println(\"Enter Discrete Math Mark:\");\n            int DMMark = input.nextInt();\n            //create this student profile in array \n            Student newStudent = new Student(name,rollNum,webMark,DSMark,DMMark);\n            studentArray.add(newStudent);\n        }\n        public static void findStudent(int rollNum, ArrayList<Student> studentArr)\n        {\n            for(int i = 0; i < studentArr.size(); i++)\n            {\n                if(studentArr.get(i).getRollNum()==rollNum)\n                {\n                    System.out.println(\"Roll Number: \" + studentArr.get(i).getRollNum() +\n                                        \", Name: \" + studentArr.get(i).getName() +\n                                        \", Web Grade: \" + studentArr.get(i).getWebMark() +\n                                        \", Data Structure Grade: \" + studentArr.get(i).getDSMark() +\n                                        \", Discrete Math Grade: \" + studentArr.get(i).getDMMark());\n                }\n                else\n                {\n                    System.out.println(\"Couldn't find student.\");\n                }\n            }\n        }\n        public static void deleteStudent(ArrayList<Student> studentArr)\n        {\n            System.out.println(\"Enter Student Roll Number: \");\n            Scanner input = new Scanner(System.in);\n            int rollNum = input.nextInt();\n            for(int counter = 0; counter < studentArr.size(); counter++)\n            {\n                if(studentArr.get(counter).getRollNum() == rollNum)\n                {\n                    studentArr.remove(counter);\n                }\n            }\n        }\n\n        public String toString()\n        {\n            return name + \" \" + rollNum + \" \" + WebMark + \" \" + dsMark + \" \" + dmMark;\n        }\n\n        public static double avg(ArrayList<Student> studentArr)\n        {\n            double[] avgArr = new double[studentArr.size()];\n            double max = 0.0;\n            for(int counter = 0; counter < studentArr.size(); counter++)\n            {\n                avgArr[counter] = (studentArr.get(counter).getWebMark() + \n                        studentArr.get(counter).getDSMark() + studentArr.get(counter).getDMMark())/(3);\n\n                if(avgArr[counter] > max)\n                {\n                    max = avgArr[counter];\n                }\n            }\n            return max;\n        }\n\n        public int compareTo(Student studCompare)\n        {\n            int compareRollNum = ((Student) studCompare).getRollNum();\n\n            //ascending order\n            return this.rollNum - compareRollNum;\n        }\n\n        /*Comparator for sorting the array by student name*/\n        public static Comparator<Student> StuNameComparator = new Comparator<Student>() \n        {\n            public int compare(Student s1, Student s2) \n            {\n               String StudentName1 = s1.getName().toUpperCase();\n               String StudentName2 = s2.getName().toUpperCase();\n\n               //ascending order\n               return StudentName1.compareTo(StudentName2);\n\n               //descending order\n               //return StudentName2.compareTo(StudentName1);\n            }\n        };\n\n        /*Comparator for sorting the array by student name*/\n        public static Comparator<Student> StuRollno = new Comparator<Student>() \n        {\n            public int compare(Student s1, Student s2) \n            {\n                int rollno1 = s1.getRollNum();\n                int rollno2 = s2.getRollNum();\n\n               //ascending order\n                return rollno1-rollno2;\n\n               //descending order\n               //return StudentName2.compareTo(StudentName1);\n            }\n        };\n\n        public static <T extends Comparable<T>> List<T> mergeSort(List<T> m)\n        {\n            // exception\n            if (m==null) throw new NoSuchElementException(\"List is null\");\n            // base case\n            if (m.size() <= 1) return m;\n\n            // make lists\n            List<T> left = new ArrayList<>();\n            List<T> right = new ArrayList<>();\n\n            // get middle\n            int middle = m.size()/2;\n\n            // fill left list\n            for (int i = 0; i < middle; i++)\n            {\n                if (m.get(i)!=null) left.add(m.get(i));\n            }\n\n            // fill right list\n            for (int i = middle; i < m.size(); i++)\n            {\n                if (m.get(i)!=null) right.add(m.get(i));\n            }\n\n            // recurse\n            left = mergeSort(left);\n            right = mergeSort(right);\n\n            // merge\n            return merge(left,right);\n        }\n\n        private static <T extends Comparable<T>> List<T> merge(List<T> left, List<T> right)\n        {\n            List<T> result = new ArrayList<>();\n\n            // merge\n            while (!left.isEmpty() && !right.isEmpty())\n            {\n                if (left.get(0).compareTo(right.get(0)) <= 0)\n                {\n                    result.add(left.remove(0));\n                }\n                else\n                {\n                    result.add(right.remove(0));\n                }\n            }\n\n            // cleanup leftovers\n            while (!left.isEmpty())\n            {\n                result.add(left.remove(0));\n            }\n            while (!right.isEmpty())\n            {\n                result.add(right.remove(0));\n            }\n            return result;\n        }\n\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner input = new Scanner(System.in);\n        int userChoice = 0;\n        int userChoice2 = 0;\n        ArrayList<Student> studentArr = new ArrayList<Student>(); //array size is 6\n\n        System.out.println(\"1- Merge Sort\");\n        System.out.println(\"2- Shell Sort\");\n        System.out.println(\"3- Quit\");\n        userChoice2 = input.nextInt();\n\n        if (userChoice2 == 1 || userChoice2 == 2) \n        {\n            do {\n                System.out.println(\"1- Add a New Record\");\n                System.out.println(\"2- Sort by Student Name\");\n                System.out.println(\"3- Sort by Roll Number\");\n                System.out.println(\"4- Delete a Student Specific Record\");\n                System.out.println(\"5- Display a Student Specific Record\");\n                System.out.println(\"6- Search\");\n                System.out.println(\"7- Display the Highest Average\");\n                System.out.println(\"8- Print\"); //print the array size, sort time, and number of comparisons to the screen.\n                System.out.println(\"9- Quit\");\n                System.out.println(\"Select your Option: \\n\");\n\n                userChoice = input.nextInt();\n\n                switch (userChoice) {\n                case 1:\n                    Student.addStudent(studentArr);\n                    break;\n                case 2:\n                    if (userChoice2 == 1) {\n                        //call mergesort function\n                    } else if (userChoice2 == 2) {\n                        //call shell sort function\n                    }\n                case 3:\n                    if (userChoice2 == 1) {\n                        //call mergesort function\n                    } else if (userChoice2 == 2) {\n                        //call shell sort function\n                    }\n                case 4:\n                    Student.deleteStudent(studentArr);\n                    break;\n                case 5:\n                    System.out.println(\"Enter Student Roll Number: \");\n                    int rollNum_ = input.nextInt();\n                    Student.findStudent(rollNum_, studentArr);\n                    break;\n                case 6:\n                case 7:\n                    double highestAvg = Student.avg(studentArr);\n                    System.out.println(\"Highest Average is: \" + highestAvg);\n                    break;\n                case 8:\n                    System.out.println(\"Printing students...\");\n                    System.out.print(studentArr);\n                    System.out.println(\"\\n\");\n                    break;\n                case 9:\n                }\n            } while (userChoice != 9);\n        }\n        else\n        {\n            return;\n        }\n        input.close();\n    }\n}\n```\n\n    ", "Answer": "\r\nYour ```\nStudent```\n is already ```\nComparable```\n and it already compares to other ```\nStudent```\n instances using ```\nrollNum```\n field, so the current implementation using ```\ncompareTo()```\n should already sort on that field.\n\nBut if you want to sort using a different ordering, you could write a ```\nComparator```\n and change your sorting method like so:\n\n```\nprivate static <T> List<T> merge(List<T> left, List<T> right, Comparator<? super T> comparator) {\n    .. use comparator.compare(a, b) instead of a.compareTo(b)\n}\n```\n\n\nHere, you don't need to restrict ```\nT```\n with ```\nComparable```\n.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Is it the best practice to use built in sort()function rather than merge sort whose complexity is always nlogn\r\n                \r\nworst case complexity of quick sort is n^2 and best n logn and heap sort and merge sort complexity is n logn both worst,best and average case.But heap sort is not stable in everywhere.Instead merge is stable.So merge is best.But built in sort() function is n logn and implementing  this, is more easier than merge sort while save time and energy.Is there any case where merge sort is apllied rather than this.\n\n```\n#include<stdio.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    int a[2000];\n    int n=2000;\n    for(int i=0;i<2000;i++)\n    {\n        a[i]=rand()%3000;//taking elements randomly less than 3000\n    }\n    sort(a,a+n);//sort elements .is it best practice instead use of merge sort always\n\n}\n```\n\n    ", "Answer": "\r\nIn C++ 11, std::stable_sort is guaranteed to be stable, and if sufficient memory is available then it's O(n log n). If it needs additional memory then it's O(n log2 n).\n\nIf you don't need a stable sort, then call std::sort, which is documented to be O(n log n).\n\nAs I understand it, ```\nstd::sort```\n and ```\nstd::stable_sort```\n often use something like Introsort, which uses Quicksort if possible, but falls back to something else if the Quicksort recursion depth becomes too deep.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Javascript merge sort visualisation\r\n                \r\nI have managed to get a merge sort working in p5.js to sort different length lines but can not figure out how to actually show them being sorted. I.e show them unsorted and then update their position as they are being sorted. I'm not sure if there is an easy way to do this with the way my code is currently written or if I need to break the sorting function up and re draw it after each stage?\n\n\r\n\r\n```\nvar values = [];\r\nvar numLines = 500;\r\n\r\nfunction setup() {\r\n  createCanvas(900, 600);\r\n  colorMode(HSB, height);\r\n  for (i = 0; i < numLines; i++) {\r\n    values[i] = (round(random(height)));\r\n  }\r\n  \r\n\tvalues = mergeSort(values);\r\n\t\r\n  noLoop();\r\n }\r\n\r\n\r\nfunction draw() {\r\n  background(51);\r\n\r\n  for (let i = 0; i < values.length; i++) {\r\n    let col = color(values[i], height, height);\r\n    stroke(col);\r\n    fill(col);\r\n    var location = map(i, 0, values.length, 0, width);\r\n    rect(location, height - values[i], width/numLines, height);\r\n  } \r\n}\r\n\r\nfunction mergeSort(a) {\r\n  if (a.length <= 1) {\r\n    return a;\r\n  }\r\n  var mid = Math.round((a.length / 2));\r\n  var left = a.slice(0, mid);\r\n  var right = a.slice(mid);\r\n  return merge(mergeSort(left), mergeSort(right));\r\n}\r\n\r\nfunction merge(left, right) {\r\n  sorted = [];\r\n  \r\n  while (left && left.length > 0 && right && right.length > 0) {\r\n    if (left[0] <= right[0]) {\r\n      sorted.push(left.shift());\r\n    }\r\n    else {\r\n      sorted.push(right.shift());\r\n    }\r\n  }\r\n  return sorted.concat(left, right);\r\n}```\n\r\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.2/p5.min.js\"></script>```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nThis answer uses a non-recursive merge sort that keeps a history of the stages of the sort. The entire sort is performed before draw and then draw steps through all the stages so that we can see how the algorithm moves the lines to achieve the sort. The code is adapted from Mike Bostock's Visualizing Algorithms. \n\nhttps://bost.ocks.org/mike/algorithms/\nhttps://bl.ocks.org/mbostock/1b5450d525babd28425f \n\n\r\n\r\n```\nvar values = [];\r\nvar numLines = 500;\r\nvar sortHist = [];\r\nfunction setup() {\r\n  createCanvas(900, 600);\r\n  colorMode(HSB, height);\r\n  for (i = 0; i < numLines; i++) {\r\n    values[i] =random(height);\r\n  }\r\n  sortHist = mergeSort(values);\r\n  frameRate(1);\r\n}\r\n  \r\nvar historyIndex = 0;\r\nfunction draw() {\r\n  background(51);\r\n  for (i = 0; i < sortHist[historyIndex].length; i++) {\r\n    let col = color(sortHist[historyIndex][i], height, height);\r\n    stroke(col);\r\n    fill(col);\r\n    var location = map(i, 0, sortHist[historyIndex].length, 0, width);\r\n    rect(location, height - sortHist[historyIndex][i], width/numLines, height);\r\n  } \r\n  historyIndex++;\r\n  if (historyIndex > sortHist.length -1){\r\n    noLoop();\r\n  }\r\n}\r\n\r\nfunction mergeSort(array) {\r\n  var arrays = [array.slice()],\r\n  n = array.length,\r\n  array0 = array,\r\n  array1 = new Array(n);\r\n\r\n  for (var m = 1; m < n; m <<= 1) {\r\n    for (var i = 0; i < n; i += (m << 1)) {\r\n      merge(i, Math.min(i + m, n), Math.min(i + (m << 1), n));\r\n    }\r\n    arrays.push(array1.slice());\r\n    array = array0, array0 = array1, array1 = array;\r\n  }\r\n\r\nfunction merge(left, right, end) {\r\n  for (var i0 = left, i1 = right, j = left; j < end; ++j) {\r\n    array1[j] = array0[i0 < right && (i1 >= end || array0[i0] <=    array0[i1]) ? i0++ : i1++];\r\n   }\r\n }\r\n return arrays;\r\n}  ```\n\r\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.2/p5.min.js\"></script>```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Is it the best practice to use built in sort()function rather than merge sort whose complexity is always nlogn\r\n                \r\nworst case complexity of quick sort is n^2 and best n logn and heap sort and merge sort complexity is n logn both worst,best and average case.But heap sort is not stable in everywhere.Instead merge is stable.So merge is best.But built in sort() function is n logn and implementing  this, is more easier than merge sort while save time and energy.Is there any case where merge sort is apllied rather than this.\n\n```\n#include<stdio.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    int a[2000];\n    int n=2000;\n    for(int i=0;i<2000;i++)\n    {\n        a[i]=rand()%3000;//taking elements randomly less than 3000\n    }\n    sort(a,a+n);//sort elements .is it best practice instead use of merge sort always\n\n}\n```\n\n    ", "Answer": "\r\nIn C++ 11, std::stable_sort is guaranteed to be stable, and if sufficient memory is available then it's O(n log n). If it needs additional memory then it's O(n log2 n).\n\nIf you don't need a stable sort, then call std::sort, which is documented to be O(n log n).\n\nAs I understand it, ```\nstd::sort```\n and ```\nstd::stable_sort```\n often use something like Introsort, which uses Quicksort if possible, but falls back to something else if the Quicksort recursion depth becomes too deep.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Sort Link List using Merge Sort in Java\r\n                \r\nI am trying to implement a merge sort on Linkedin List . Its resulting into a StackOverflowError error . Following is the implementation done by me . Kindly tell me the alterations to be done. \n\n```\npublic class Solution {\n    public ListNode sortList(ListNode A) {\n        if (A == null || A.next == null)\n        {\n            return A;\n        }\n        ListNode middle = getMiddle(A);\n        ListNode middleNext = middle.next;\n        middle.next = null;\n        ListNode left = sortList(A);\n        ListNode right = sortList(middleNext);\n        ListNode head = combine(left,right);\n        return head;\n    }\n\n    public ListNode combine(ListNode head,ListNode otherHead){\n        ListNode combineResult = null;\n        if(head==null)\n            return otherHead;\n        if(otherHead == null)\n            return head;\n        if(head.val<=otherHead.val){\n            combineResult = head;\n            combineResult.next = combine(head.next,otherHead);\n        } else {\n            combineResult = otherHead;\n            combineResult.next = combine(head,otherHead.next);\n        }\n        return combineResult;\n    }\n\n    public ListNode getMiddle(ListNode A){\n        ListNode fastPtr = A;\n        ListNode slowPtr = A;\n        while(fastPtr!=null && fastPtr.next!=null){\n            fastPtr = fastPtr.next.next;\n            slowPtr = slowPtr.next;\n        }\n        return slowPtr;\n    }\n}\n```\n\n    ", "Answer": "\r\nYou have this method declaration\n\n```\npublic ListNode sortList(ListNode A) {\n```\n\n\nand without any change to ```\nA```\n, you call the method like this:\n\n```\nListNode left = sortList(A);\n```\n\n\nSince you have no end sign, you have infinite recursivity. The input of ```\nsortList```\n should be the leftmost and the rightmost node of your current interval, and, since you have a linked list, the number of items in the interval would not hurt either as a parameter, to avoid having to calculate it repeatedly. Now, instead of this, you have a single parameter, a ```\nListNode```\n called ```\nA```\n. That's not enough to define an interval.\n\nThe idea of merge sort is to repeatedly dividing an ordered set into halves, partitioning it, posing similar, but easier subproblems until we reach triviality and solve the trivial tasks, then the combination of such trivial tasks becomes easier.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort in agda\r\n                \r\nI want to implement merge sort in agda. If I do this in a naive way, the termination checker fails to pass the program because after we split input list into two parts, and then call ourselves recursively, agda doesn't know that size of each of the lists is smaller than the size of the original list.\n\nI've seen several solutions, for example this one: https://gist.github.com/twanvl/5635740 but the code seems too complicated to me, and the worst thing is that we intermix the program and the proof.\n    ", "Answer": "\r\nThere are at least three ways in which you can write merge sort so that it passes the termination checker.\n\nFirst of all, here's what we need to make our merge sort generic:\n\n```\nopen import Relation.Binary\nopen import Relation.Binary.PropositionalEquality\n\nmodule MergeSort\n  {ℓ a} {A : Set a}\n  {_<_ : Rel A ℓ}\n  (strictTotalOrder : IsStrictTotalOrder _≡_ _<_) where\n\nopen IsStrictTotalOrder strictTotalOrder\n```\n\n\nOnce we prove that some relation is a strict total order, we can use that proof as a parameter to this module and get corresponding merge sort.\n\n\n\nThe first way is to use well-founded recursion, which is more or less what the linked code in your question uses. However, we do not need to prove that merge sort returns a sorted permutation of its input list in a bounded number of comparisions, so we can cut most of the code.\n\nI wrote something about well-founded recursion in this answer, you might want to check it out.\n\nOther imports first:\n\n```\nopen import Data.List\nopen import Data.Nat\n  hiding (compare)\nopen import Data.Product\nopen import Function\nopen import Induction.Nat\nopen import Induction.WellFounded\n```\n\n\nHere's the implementation of ```\nmerge```\n:\n\n```\nmerge : (xs ys : List A) → List A\nmerge [] ys = ys\nmerge xs [] = xs\nmerge (x ∷ xs) (y ∷ ys) with compare x y\n... | tri< _ _ _ = x ∷ merge xs (y ∷ ys)\n... | tri≈ _ _ _ = x ∷ merge xs (y ∷ ys)\n... | tri> _ _ _ = y ∷ merge (x ∷ xs) ys\n```\n\n\nIf you are having problems getting this past termination checker, check out my answer on this. It should work as is with the development version of Agda.\n\n```\nsplit```\n is easy as well:\n\n```\nsplit : List A → List A × List A\nsplit [] = [] , []\nsplit (x ∷ xs) with split xs\n... | l , r = x ∷ r , l\n```\n\n\nBut now we get to the complicated part. We need to show that ```\nsplit```\n returns two lists that are both smaller than the original (which of course holds only if the original list had at least two elements). For this purpose, we define a new relation on lists: ```\nxs <ₗ ys```\n holds iff ```\nlength x < length y```\n:\n\n```\n_<ₗ_ : Rel (List A) _\n_<ₗ_ = _<′_ on length\n```\n\n\nThe proof is then fairly straightforward, it's just an induction on the list:\n\n```\n-- Lemma.\ns≤′s : ∀ {m n} → m ≤′ n → suc m ≤′ suc n\ns≤′s ≤′-refl     = ≤′-refl\ns≤′s (≤′-step p) = ≤′-step (s≤′s p)\n\nsplit-less : ∀ (x : A) y ys →\n  let xs    = x ∷ y ∷ ys\n      l , r = split (x ∷ y ∷ ys)\n  in l <ₗ xs × r <ₗ xs\nsplit-less _ _ [] = ≤′-refl , ≤′-refl\nsplit-less _ _ (_ ∷ []) = ≤′-refl , ≤′-step ≤′-refl\nsplit-less _ _ (x ∷ y ∷ ys) with split-less x y ys\n... | p₁ , p₂ = ≤′-step (s≤′s p₁) , ≤′-step (s≤′s p₂)\n```\n\n\nNow we have everything we need in order to bring the well-founded recursion machinery. Standard library gives us proof that ```\n_<′_```\n is well-founded relation, we can use this to construct a proof that our freshly defined ```\n_<ₗ_```\n is also well-founded:\n\n```\nopen Inverse-image {A = List A} {_<_ = _<′_} length\n  renaming (well-founded to <ₗ-well-founded)\n\nopen All (<ₗ-well-founded <-well-founded)\n  renaming (wfRec to <ₗ-rec)\n```\n\n\nAnd finally, we use ```\n<ₗ-rec```\n to write ```\nmerge-sort```\n.\n\n```\nmerge-sort : List A → List A\nmerge-sort = <ₗ-rec _ _ go\n  where\n  go : (xs : List A) → (∀ ys → ys <ₗ xs → List A) → List A\n  go [] rec = []\n  go (x ∷ []) rec = x ∷ []\n  go (x ∷ y ∷ ys) rec =\n    let (l , r)   = split (x ∷ y ∷ ys)\n        (p₁ , p₂) = split-less x y ys\n    in merge (rec l p₁) (rec r p₂)\n```\n\n\nNotice that in the recursive call (```\nrec```\n), we not only specify what to recurse on, but also a proof that the argument is smaller than the original one.\n\n\n\nThe second way is to use sized types. I also wrote an overview in this answer, so you might want to check it out.\n\nWe need this pragma at the top of the file:\n\n```\n{-# OPTIONS --sized-types #-}\n```\n\n\nAnd a different set of imports:\n\n```\nopen import Data.Product\nopen import Function\nopen import Size\n```\n\n\nHowever, we cannot reuse lists from standard library since they do not use sized types. Let's define our own version:\n\n```\ninfixr 5 _∷_\n\ndata List {a} (A : Set a) : {ι : Size} → Set a where\n  []  : ∀ {ι} →                  List A {↑ ι}\n  _∷_ : ∀ {ι} → A → List A {ι} → List A {↑ ι}\n```\n\n\n```\nmerge```\n stay more or less the same, we only need to change the type a bit to convince the termination checker:\n\n```\nmerge : ∀ {ι} → List A {ι} → List A → List A\n```\n\n\nHowever, ```\nsplit```\n has a slight but very important change:\n\n```\nsplit : ∀ {ι} → List A {ι} → List A {ι} × List A {ι}\nsplit [] = [] , []\nsplit (x ∷ xs) with split xs\n... | l , r = x ∷ r , l\n```\n\n\nThe implementation stays the same, but the type changed. What this change does is that it tells Agda that ```\nsplit```\n is size-preserving. This means that the two resulting lists cannot be larger than the input one. ```\nmerge-sort```\n then looks very natural:\n\n```\nmerge-sort : ∀ {ι} → List A {ι} → List A\nmerge-sort [] = []\nmerge-sort (x ∷ []) = x ∷ []\nmerge-sort (x ∷ y ∷ ys) =\n  let l , r = split ys\n  in  merge (merge-sort (x ∷ l)) (merge-sort (y ∷ r))\n```\n\n\nAnd indeed, this gets past the termination checker. The trick is the above mentioned size-preserving property: Agda can see that ```\nsplit ys```\n does not produce lists larger than ```\nys```\n and thus ```\nx ∷ l```\n and ```\ny ∷ r```\n are both smaller than ```\nx ∷ y ∷ ys```\n. This is enough to convince the termination checker.\n\n\n\nThe last one is not really a merge sort in the usual sense. It uses the same idea but instead of repeatedly splitting the lists, recursively sorting them and then merging them together, it does all the splitting upfront, stores the results in a tree and then folds the tree using ```\nmerge```\n.\n\nHowever, since this answer is already fairly long, I'll just give you a link.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort C implementation with linked lists\r\n                \r\nI'm having a segmentation fault core dumped when trying to merge sort with linked lists in C. Can't seem to track the root cause of the issue:\nthis is my node structure:\n```\ntypedef struct node0* node;\nstruct node0{\n    int val;\n    node next;\n}node0;\n```\n\nthis is my splitting function:\n```\nnode* divide(node head){\n    float mid = ceilf((float)length(head)/2);\n    node* ret = malloc(sizeof(node)*2);\n    node tmp1 = head;\n    while (mid>1){\n        tmp1 = tmp1->next;\n        mid--;\n    }\n    node tmp2 = tmp1->next;\n    tmp1->next = NULL;\n    ret[0] = head;\n    ret[1]=tmp2;\n    return ret;\n}\n```\n\nthis is my merging function:\n```\nnode mergesorted(node head1, node head2){\n    node ret = NULL;\n    if(head1 == NULL) return head2;\n    else if(head2 == NULL) return head1;\n    if(head1->val <= head2->val){\n        ret = head1;\n        ret->next = mergesorted(head1->next, head2);\n    } else {\n        ret = head2;\n        ret->next = mergesorted(head1, head2->next);\n    }\n    return ret;\n}\n```\n\nand this is the regular merge sort algorithm:\n```\nnode merged(node head){\n    if(length(head)>1){\n        node *lists = divide(head);\n        merged(lists[0]);\n        merged(lists[1]);\n        return mergesorted(lists[0], lists[1]);\n\n    }\n}\n```\n\nmain:\n```\nint main() {\n    node l1 = create_node(1);\n    l1->next = create_node(3);\n    l1->next->next = create_node(4);\n    l1->next->next->next= create_node(2);\n    l1 = merged(l1);\n    print_list(l1);\n}\n```\n\nafter adding some prints I get the following log:\n```\ndeviding: 1-->3-->4-->2-->\ndevided into:\nl1: 1-->3-->\nl2: 4-->2-->\n\ndeviding: 1-->3-->\ndevided into:\nl1: 1-->\nl2: 3-->\n\nmerging: 1-->\nwith: 3-->\nmerged:1-->3-->\n\ndeviding: 4-->2-->\ndevided into:\nl1: 4-->\nl2: 2-->\n\nmerging: 4-->\nwith: 2-->\nmerged:2-->4-->\n\nmerging: 1-->3-->\nwith: 4-->\nmerged:1-->3-->4-->\n\nProcess finished with exit code 139 (interrupted by signal 11: SIGSEGV)\n```\n\nAs it appears at the final merge the right hand list pointer seems to be null!\n    ", "Answer": "\r\nThe problem arises because of following fragments:\n```\n    if(head1->val <= head2->val){\n        ret = head1;\n        ret->next = mergesorted(head1->next, head2);\n    } else {\n        ret = head2;\n        ret->next = mergesorted(head1, head2->next);\n    }\n```\n\nIf you see, you are assigning a new \"head\" every time the value is lesser or greater! That shouldn't be clearly the intension.\nRather you need to create / appened a new head only when the resultant node is ```\nempty```\n or ```\nNULL```\n.\n```\n    if(head1->val <= head2->val){\n        if(ret == NULL){\n          ret = head1;\n        }\n        ret->next = mergesorted(head1->next, head2);\n    } else {\n        if(ret == NULL){\n          ret = head2;\n        }\n        ret->next = mergesorted(head1, head2->next);\n    }\n```\n\nI didn't see any other problem in your code.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Linked List Merge Sort\r\n                \r\nI'm trying to implement a merge sort for a liked list, but when I test it, it returns a list of just the smallest item and then it seems to cut out the rest of the numbers in the list. Here is some of my code: Can any one point me in the right direction of my error?\n\n```\n    ListNode* ListP::merge(ListNode* head1, ListNode* head2)\n    {\n        if (head1 == NULL)\n            return head1;\n        else if (head2 == NULL)\n            return head2;\n        else if (head1->getItem() < head2->getItem())\n        {\n            head1->next = (merge(head1->next, head2));\n            return head1;\n        }\n        else\n        {\n            head2->next = (merge(head2->next, head1));\n            return head2;\n        }\n\n    }\n\n    ListNode* ListP::mergesort(ListNode * theHead, int size)\n    {\n        int leftSize = size / 2;\n\n        int rightSize = size - leftSize;\n        int i = 0;\n        if (theHead == NULL)\n            return NULL ;\n        else if (theHead->next == NULL)\n            return theHead;\n\n        ListNode* slow = theHead;\n        ListNode* fast = theHead->next;\n        while (fast != NULL)\n        {\n            fast = fast->next;\n            if (fast != NULL)\n            {\n                slow = slow->next;\n                fast = fast->next;\n            }\n        }\n        ListNode* ptr2 = slow->next;\n        slow->next = NULL;\n        slow = NULL;\n        return merge(mergesort(theHead, leftSize), mergesort(ptr2, rightSize));\n    }\n\n    void ListP::sort_mergesort()\n    {\n        ListNode* ptr = head;\n        head = mergesort(head, size);\n\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "javascript merge/sort fatal error\r\n                \r\nI was writing the merge sort algorithm, and in the merge helper function, I had the following comparison statement:\n\n```\n    function merge(a,b){\n        var result = [];\n            while(a.length && b.length){\n                    result.push(a[0] < b[0] ? a.shift() : b.shift()); // you can't just grab a[0] or b[0] \n        //as it results in a fatal error.\n                }\nreturn, etc.\n}\n```\n\n\nWhy is it that when instead of 'a.shift()', I typed a[0], it resulted in a fatal error? Is it because you are doing something with something that's also in a conditional clause?\n    ", "Answer": "\r\nCheckout the documentation for shift. It removes the first element. So if you only access a[0] and don't remove it then the while loop never exits.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Calculate efficiency for insertion sort and merge sort(daa)\r\n                \r\nAssume that a CPU can process 10^8 operations per second. Suppose you have to sort an array with 10^6 elements?\n\nWhat is the time taken by insertion sort n merge sort in hr?\n\nWant to know how to calculate the time.\n    ", "Answer": "\r\nThe information given is insufficient to give an exact answer to the question.\n\nThe time taken will depend on data itself and the implementation of the algorithm.\n\nIt is, of course, possible to make an estimate based on reasonable assumptions.\n\nInsertion sort is ```\nO(n^2)```\n, so it will take in the order of ```\nK1 * 10^12```\n operations to sort the array, or ```\nK1 * 10^4```\n seconds. Insertion sort would probably take several hours, even with an optimized implementation.\n\nMerge sort is ```\nO(n * log n)```\n, so it will take in the order of ```\nK2 * 10^6 * 6```\n operations to sort the array, or ```\nK2 * 6 * 10^(-2)```\n seconds. Merge sort would probably take less than a second.\n\nThis example is a good illustrator on why it is important to choose the right algorithm for the job. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Stack Overflow error in Merge Sort algorithm?\r\n                \r\nI'm writing a merge sort class in java and i get a stack overflow error when I get to the ```\nsort(left)```\n line. Any thoughts? I don't understand why this would be a problem.\n\npackage ds;\n\n```\nimport java.util.Comparator;\n\npublic class MergeSorter<T> extends Sorter<T> {\n\npublic MergeSorter(Comparator<T> comparator){\n    super(comparator);\n}\n\n@SuppressWarnings(\"unchecked\")\n@Override\npublic void sort(T[] array){\n    if (array.length <= 1);\n    else {\n        T[] left = (T[]) new Object[array.length/2 + 1];\n        T[] right = (T[]) new Object[array.length/2 + 1];\n        int middleIndex = array.length / 2;\n        for (int i = 0; i < middleIndex; i++) {\n            left[i] = array[i];\n        }\n        for (int i = middleIndex; i < array.length; i++) {\n            right[i - middleIndex] = array[i];\n        }\n        sort(left);\n        sort (right);\n        merge(left, right, array);\n    }\n}\n\npublic final void merge(T[] left, T[] right, T[] array){\n    Array<T> sortedArray = new Array<T>(array.length);\n    while (left.length > 0 || right.length > 0) {\n        if (left.length > 0 && right.length > 0) {\n            if (comparator.compare(left[0], right[0]) < 0) {\n                sortedArray.add(left[0]);\n                for (int i = 1; i < left.length; i++) {\n                    left[i - 1] = left[i];\n                    left[left.length - 1] = null;\n                }\n            }\n            else {\n                sortedArray.add(right[0]);\n                for (int i = 1; i < right.length; i++) {\n                    right[i - 1] = right[i];\n                    right[right.length - 1] = null;\n                }\n            }\n        }\n        else if (left.length > 0) {\n            sortedArray.add(left[0]);\n            for (int i = 1; i < left.length; i++) {\n                left[i - 1] = left[i];\n                left[left.length - 1] = null;\n            }\n        }\n        else if (right.length > 0) {\n            sortedArray.add(right[0]);\n            for (int i = 1; i < right.length; i++) {\n                right[i - 1] = right[i];\n                right[right.length - 1] = null;\n            }\n        }\n    }\n    for (int i = 0; i < array.length; i++) {\n        array[i] = sortedArray.get(i);\n    }\n}\n\n}\n```\n\n    ", "Answer": "\r\nSuppose the array has length ```\n2```\n. Then left is:\n\n```\nT[] left = (T[]) new Object[array.length/2 + 1];\n```\n\n\nwhich is\n\n```\nT[] left = (T[]) new Object[2/2 + 1];\n```\n\n\nand this equals to\n\n```\nT[] left = (T[]) new Object[2];\n```\n\n\nAnd when you sort on ```\nleft```\n, this continues, and leads to an infinite recursion which might have caused the stack overflow error you posted.\n\nSince you are copying the first ```\nmiddleIndex```\n elements into ```\nleft```\n, ```\nmiddleIndex```\n length should right fit the array ```\nleft```\n. So ```\nleft```\n should be a length ```\narray.length/2```\n array.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "concurrent Threads Merge Sort\r\n                \r\nI have to code a concurrent Merge Sort Aplication. Every time the array gets split up, I have to create a new thread for the right half (max. Number of Threads is 5 -> so 5 Times) which continues the Mergesort algorithm. \n\n\n\nThat's my program:\n\n```\nclass Mergesorts implements Runnable{\n\n    private int[] internal;\n\n    Mergesorts(int[] arr) {\n        internal = arr;\n    }\n\n    private void processCommand(int [] array) {\n        if (array.length > 1) { \n            int[] left = leftHalf(array);\n            int[] right = rightHalf(array);\n            processCommand(left);\n            processCommand(right);\n            merge(array, left, right);\n        }\n    }\n\n    public int[] rightHalf(int[] array) {\n        int size1 = array.length / 2;\n        int size2 = array.length - size1;\n        int[] right = new int[size2];\n        for (int i = 0; i < size2; i++) {\n            right[i] = array[i + size1];\n        }\n        return right;\n    }\n\n    public void run() {\n        processCommand(internal);\n    }\n}\n```\n\n\nHow can I rewrite my code to sort concurrently as described above?\n\nHow can i edit my code so it only creates up to 5 Threads and not more? \n\n```\nprivate void processCommand(int [] array) {\n    if (array.length > 1) {\n\n\n        int[] right = rightHalf(array);\n        int[] left = leftHalf(array);\n\n\n        Mergesorts worker2 = new Mergesorts(right);\n        Thread s = new Thread(worker2);\n        s.start();\n\n        processCommand(left);\n\n        try {\n            s.join();\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        merge(array, left, right);}\n\n}\n```\n\n    ", "Answer": "\r\nStart the new thread in the processCommand() method, not in the rightHalf() method.  If you have threads available, then instead of the line calling processCommand(right), construct a new Mergesorts object on ```\nright```\n and start a thread with it.  Don't forget to call join() on the thread to ensure it completes before doing the merge.\n\nTo improve parallelism, you can start the new thread on the right half of the array before processing the left half of the array, so both are done at the same time - that is, move processCommand(left) to after the block that either does processCommand(right) or starts a new thread.  The join() call should be after both halves are done, but before the merge.\n\nEdit:  you are getting closer; to address your comment, you need something like this:\n\n```\nprivate void processCommand(int [] array) {\n    if (array.length <= 1)\n        {return;}\n\n    int[] left = leftHalf(array);\n    int[] right = rightHalf(array);\n    Thread rightThread = null;\n\n    if (b <= 5) {\n        ++b;\n        Mergesorts worker = new Mergesorts(right);\n        rightThread = new Thread(worker);\n        rightThread.start();\n    } else {\n        processCommand(right);\n    }\n\n    processCommand(left);\n\n    if (null != rightThread) {\n        try {\n            rightThread.join();\n            b--\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n            // better error handling would be good\n        }\n    }\n\n    merge(array, left, right);\n}\n```\n\n\n```\nb```\n also needs to be volatile to ensure the different threads can see how many threads are currently executing.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "implementing a merge sort in java\r\n                \r\nI'm trying to code a quick merge sort in java. I've essentially copied the code from the Wikipedia page, but for some reason I can't seem to make it work. I'm sure there is some small error I'm over looking, but I can't seem to find it.    \n\n```\npublic static void mergeSort(double[] array, double[] temp, int first, int last)\n{         \n    if( last - first < 2)\n    {// if the length of subarray is 1 return the array.\n        return;\n    }// else you recurse.\n\n    int mid = (first + last)/2;\n\n    mergeSort(array, temp,first, mid);// recursively split the array\n    mergeSort(array, temp, mid , last);\n    merge(array,temp,first,mid,last);// merge the sorted halves\n    copyArray(array, temp, first, last);\n}// end of method merge sort\n\nprivate static void merge(double[] array, double[] temp, int first, int mid ,int last)\n{\n    //  left half is A[first...mid-1]\n    // right half is A[mid...last -1]\n    int index0 = first, index1 = mid;\n\n    for(int i = first; i < last;i++)\n    {\n        if(index0 <= mid && (index1 <= last || array[index0] <= array[index1]))\n        {\n            temp[i]= array[index0];\n            index0+=1;\n        }\n        else\n        {\n            temp[i] = array[index1];\n            index1+=1;\n        }// end else\n    }// end for       \n}// end of method merge\n\npublic static void copyArray(double[] array, double[]temp, int first, int last)\n{\n    for(int i = first;i< last;i++)\n    {\n        array[i] = temp[i];\n    }// end for        \n}// end of method copyArray\n```\n\n\nHere's my input\n\n```\ndouble [] array = {7,4,9,3,4,1,6,8,2,5};\ndouble [] temp = new double[10];\n\nmergeSort(array, temp, 0, 10);\nSystem.out.println(Arrays.toString(array));\n```\n\n\nHere's my output. \n\n```\n[7.0, 4.0, 9.0, 9.0, 3.0, 1.0, 1.0, 6.0, 8.0, 8.0]\n```\n\n\nAny idea on what would make it double certain numbers like this?\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "RxSwift - Arrays merge, sort, remove duplicates\r\n                \r\nConsider the following arrays\n\n\n```\n\n\nlet a = [1,2,3,4,5,6]\nlet b = [5,6,7,8,9]\n\n```\n\n\n\nHow to get c, where ```\nc = [1,2,3,4,5,6,7,8,9]```\n? \nIn RxSwift, how to do merge, sort, and removing duplicate for the input arrays?\n    ", "Answer": "\r\nEverything you need is provided by the Core Library:\n\n```\nlet c = Set(a + b).sorted()\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "choose the middle in merge sort\r\n                \r\nI was trying to complete a merge sort in Python. I found when I use ```\nmiddle = (len(x)-1)//2```\n, the right part was in infinity loop and never reached the base case, but if I changed m```\niddle = len(x)//2```\n, it worked normally. So why?\n\n    ", "Answer": "\r\nThe solution does lie in the ```\nmiddle```\n variable. After abit of experimenting I found that using ```\nmiddle = len(alist)//2```\n fixes the whole program. Despite this not being technically mathematical, it does seem to work.\nYou could also increase efficiency by replacing the if and else at the start of the ```\nmergesort()```\n function with a simple ```\nif len(alist) > 1:```\n and then return ```\nalist```\n at the end of the function, rather than at the end of each if and else, if that makes sense. (This would also mean you can just replace the ```\ncom```\n variable with ```\nalist```\n).\nFor reference, heres my code (some variables are renamed):\n```\nfrom random import shuffle\n\n###  INIT  ###\narr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\nshuffle(arr)\nprint(\"Starting List:  \" + str(arr))\n\n###  SORT   ###\n# Merge\ndef merge(left,right):\n    sorted = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            sorted.append(left[i])\n            i += 1\n        else:\n            sorted.append(right[j])\n            j += 1\n    \n    sorted += right[j:]\n    sorted += left[i:]\n    return sorted\n\n\n# Decomposition\ndef sort(arr):\n    #print(arr)\n    if len(arr) > 1:\n        middle = len(arr)//2\n        left = sort(arr[:middle])\n        right = sort(arr[middle:])\n        arr = merge(left, right)\n    return arr\n\narr = sort(arr)\nprint(\"Ending List:    \" + str(arr))\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "count swap/comparisons numbers of merge sort algorithm\r\n                \r\nI need to count how many swaps and comparisons happened during merge sorting, I think my comparison number counting is fine, just due recursion I get as much numbers as my array length, somehow i need to store those numbers to variable in merge sort function?Also would love to know ideas on how to count total swaps\n\n```\n    void merge(double arr[], int l, int m, int r)\n    {\n        int counter = 0;//number of comparisons\n        int i, j, k;\n        int n1 = m - l + 1;\n        int n2 =  r - m;\n        int cc;\n        /* create temp arrays */\n        double L[n1], R[n2];\n        /* Copy data to temp arrays L[] and R[] */\n        for (i = 0; i < n1; i++)\n            L[i] = arr[l + i];\n        for (j = 0; j < n2; j++)\n            R[j] = arr[m + 1+ j];\n        /* Merge the temp arrays back into arr[l..r]*/\n        i = 0; // Initial index of first subarray\n        j = 0; // Initial index of second subarray\n        k = l; // Initial index of merged subarray\n        while (i < n1 && j < n2)\n            {\n\n                if (L[i] <= R[j])\n                {\n                    arr[k] = L[i];\n                    i++;\n                }\n                else\n                {\n                    arr[k] = R[j];\n                    j++;\n                }\n                k++;\n                counter++;\n        }\n        cout << counter << endl;\n    /* Copy the remaining elements of L[], if there\n       are any */\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n    /* Copy the remaining elements of R[], if there\n       are any */\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            j++;\n            k++;\n              }\n    }\n    void mergeSort(double arr[], int l, int r)\n         {\n          if (l < r)\n         {\n            // Same as (l+r)/2, but avoids overflow for\n        // large l and h\n        int m = l+(r-l)/2;\n        // Sort first and second halves\n        mergeSort(arr, l, m);\n        mergeSort(arr, m+1, r);\n        merge(arr, l, m, r);\n        }\n    }\n```\n\n    ", "Answer": "\r\nI would do the job rather differently.\n\nInstead of trying to instrument the sort itself to track the number or comparisons and swaps, I'd create a type that keeps track of the number of times it's compared and/or swapped. I was too lazy to write a whole merge sort to demonstrate it, but here's one doing a bubble sort:\n\n```\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nnamespace instrumented {\n\n    template <class T>\n    class wrapper {\n        T value;\n    public:\n        static std::size_t comparisons;\n        static std::size_t swaps;\n        wrapper(T val) : value(val) {}\n        bool operator<(wrapper const &other) { ++comparisons; return value < other.value; }\n        operator T() const { return value; }\n\n        static void reset() { comparisons = swaps = 0; }\n\n        static std::ostream &report(std::ostream &os) {\n            os << \"comparisons: \" << comparisons << \"\\n\";\n            os << \"swaps: \" << swaps << \"\\n\";\n            comparisons = 0;\n            swaps = 0;\n            return os;\n        }\n    };\n\n    template <class T>\n    std::size_t wrapper<T>::comparisons;\n\n    template <class T>\n    std::size_t wrapper<T>::swaps;\n\n    template <class T>\n    void swap(wrapper<T> &a, wrapper<T> &b) {\n        ++wrapper<T>::swaps;\n        auto temp{ a };\n        a = b;\n        b = temp;\n    }\n}\n\ntemplate <class T>\nvoid sort(std::vector<T> &input) {\n    std::vector<instrumented::wrapper<T>> values;\n\n    for (auto const & i : input)\n        values.push_back(i);\n\n    for (auto i = 0; i < values.size() - 1; i++)\n        for (auto j = i + 1; j < values.size(); j++)\n            if (values[j] < values[i])\n                swap(values[i], values[j]);\n\n    values[0].report(std::cout);\n}\n\nint main() {\n    std::vector<int> inputs1{ 5, 4, 3, 2, 1 };\n    sort(inputs1);\n    std::cout << \"\\n\";\n\n    std::vector<int> inputs2{ 10, 9, 7, 8, 5, 100, 2, 3, 1, 17, 6 };\n    sort(inputs2);\n}\n```\n\n\nNote that with this, you should be able to (for example) get results for ```\nstd::sort```\n, ```\nstd::partial_sort```\n, and so on, not just your own sort functions.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C++ merge sort implement\r\n                \r\nI want to implement merge sort with C++ and vector(considering input number of integers is unknown). I tried to implement based on the Bottom-up implementation thought through wikipedia: http://en.wikipedia.org/wiki/Merge_sort. I came out with the following code. It can pass compile but dies when entered numbers. I do not know what's going wrong here.\n\n```\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nvoid BottomUpMerge(vector<int>, vector<int>::iterator, vector<int>::iterator, vector<int>::iterator, vector<int>);\n\nvoid BottomUpSort(int n, vector<int> A, vector<int> B)\n{\n  int width;\n\n  /* Each 1-element run in A is already \"sorted\". */\n\n  /* Make successively longer sorted runs of length 2, 4, 8, 16... until whole array is sorted. */\n  for (width = 1; width < n; width = 2 * width){\n    vector<int>::iterator leftstart;\n\n    /* Array A is full of runs of length width. */\n    for (leftstart = A.begin(); leftstart <= A.end(); leftstart = leftstart + 2 * width){\n        /* Merge two runs: A[i:i+width-1] and A[i+width:i+2*width-1] to B[] */\n        /* or copy A[i:n-1] to B[] ( if(i+width >= n) ) */\n        vector<int>::iterator rightstart;\n        vector<int>::iterator rightend;\n        if(leftstart+width >= A.end()){\n            rightstart = A.end();\n        }\n        else{\n            rightstart = leftstart+width;\n        }\n        if(leftstart+2*width >= A.end()){\n            rightend = A.end();\n        }\n        else{\n            rightend = leftstart+2*width;\n        }\n\n        BottomUpMerge(A, leftstart, rightstart, rightend, B);\n    }\n\n    /* Now work array B is full of runs of length 2*width. */\n    /* Copy array B to array A for next iteration. */\n    /* A more efficient implementation would swap the roles of A and B */\n    A = B;\n    /* Now array A is full of runs of length 2*width. */\n    }\n}\n\nvoid BottomUpMerge(vector<int> A, vector<int>::iterator iLeft, vector<int>::iterator iRight, vector<int>::iterator iEnd, vector<int> B)\n{\n  vector<int>::iterator i0 = iLeft;\n  vector<int>::iterator i1 = iRight;\n  vector<int>::iterator j = B.begin() + distance(iLeft, A.begin()); //iterator for vector B\n\n  /* While there are elements in the left or right lists */\n  for (; j != B.end(); j++){\n    /* If left list head exists and is <= existing right list head */\n    if (i0 < iRight && (i1 >= iEnd || *i0 <= *i1)){\n        *j = *i0;\n        i0 = i0 + 1;\n    }\n    else{\n        *j = *i1;\n        i1 = i1 + 1;\n    }\n  }\n}\n\n\nint main(){\n    int input;\n    vector<int> numbers;    //input vector of numbers\n\n    cout << \"Please input the numbers to be sorted:\" << endl;\n    while(cin>>input){\n        numbers.push_back(input);\n    }\n\n    int length = numbers.size();\n    vector<int> sorted = numbers;   //work vector ensure has the same size of the original vector\n\n    BottomUpSort(length, numbers, sorted);\n\n    vector<int>::iterator it;\n    for(it = numbers.begin(); it != numbers.end(); ++it) {\n        std::cout << (*it) << '\\n';\n    }\n\n    system(\"pause\");\n    return 1;\n}\n```\n\n    ", "Answer": "\r\nLook here:\n\n```\nBottomUpMerge(A, leftstart, rightstart, rightend, B);\n...\n\nvoid BottomUpMerge(vector<int> A, vector<int>::iterator iLeft, ...)\n{\n  ...\n```\n\n\nYou are passing the vectors by value, which means that ```\nBottomUpMerge```\n is handling copies of them. But the iterators still point back into the originals, and hilarity ensues. Pass the vectors by reference, and at least some of these problems should disappear.\n\n(You should have discovered this when you were testing this function, before you wrote all of the surrounding code. Never add to code that doesn't work.)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C++ Merge Sort returning original vector\r\n                \r\nI have been attempting to make a merge sort using vectors in C++ and am running into an issue where any vector input is sorted into its original order. I have based the algorithm off the geeks4geeks site here: https://www.geeksforgeeks.org/merge-sort/\n\nSo far I have spent about five hours attempting to find the source of the error and it seems that upon ending the merge function the vector somehow goes back to its original format, but I am unsure why. Any suggestions would be much appreciated.\n\n```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\nvoid merge(vector<int> vect, int p, int q, int r) {\n\n    int i, j, k, n1, n2;\n\n    n1 = q - p + 1;\n    n2 = r - q;\n\n    vector<int> L, R;\n\n    L.resize(n1);\n    R.resize(n2);\n\n    for (i = 0; i < n1; i++) {\n        L[i] = vect[p + i];\n    }\n\n    for (j = 0; j < n2; j++) {\n        R[j] = vect[q + 1 + j];\n    }\n\n    i = 0;\n    j = 0;\n    k = p;\n\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            vect[k] = L[i];\n            i++;\n\n        }\n        else {\n            vect[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n\n    while (i < n1) {\n        vect[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        vect[k] = R[j];\n        j++;\n        k++;\n    }\n\n}\n\n\n\nvoid mergeSort(vector<int> vect, int p, int r) {\n    if (p < r) {\n        int q = (p + r) / 2;\n\n        mergeSort(vect, p, q);\n        mergeSort(vect, q + 1, r);\n\n        merge(vect, p, q, r);\n\n\n    }\n}\n\nint main() {\n\n    vector<int> vect{4,3,5,6,7,8};\n    mergeSort(vect, 0, vect.size() - 1);\n\n\n    for (int i = 0; i < vect.size(); i++) { \n        cout << vect[i] << endl;\n    }\n}\n```\n\n    ", "Answer": "\r\nFirst of all you should know the difference between:\n\npass by value\n\npass by reference\nGo and check it here.\n\n\n\nSecondly, you should change your code as it is shown:\n```\n#include <iostream>\n#include <vector>\n\n//using namespace std; forget about it, start using std::whatever_it_is_in_here\n\n\nvoid merge(std::vector<int> &vect, int p, int q, int r) // note the & near vect\n{\n    int i, j, k, n1, n2;\n\n    n1 = q - p + 1;\n    n2 = r - q;\n\n    std::vector<int> L, R;\n\n    L.resize(n1);\n    R.resize(n2);\n\n    for (i = 0; i < n1; i++) {\n        L[i] = vect[p + i];\n    }\n\n    for (j = 0; j < n2; j++) {\n        R[j] = vect[q + 1 + j];\n    }\n\n    i = 0;\n    j = 0;\n    k = p;\n\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            vect[k] = L[i];\n            i++;\n\n        }\n        else {\n            vect[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n\n    while (i < n1) {\n        vect[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        vect[k] = R[j];\n        j++;\n        k++;\n    }\n\n}\n\n\n\nvoid mergeSort(std::vector<int> &vect, int p, int r) // note the & near vect\n{\n    if (p < r) {\n        int q = (p + r) / 2;\n\n        mergeSort(vect, p, q);\n        mergeSort(vect, q + 1, r);\n\n        merge(vect, p, q, r);\n\n\n    }\n}\n\nint main()\n{\n    std::vector<int> vect{4,3,5,6,7,8};\n    mergeSort(vect, 0, vect.size() - 1);\n\n\n    for (int i = 0; i < vect.size(); i++)\n        std::cout << vect[i] << \"\\n\"; // note \\n instead of std::endl\n\n    return 0; // you forgot the return statement \n}\n```\n\n\n\nYou forgot the return statement in the main function.\nStop using using namespace std. Check why here\nNote the ```\n\"\\n\"```\n instead of ```\nstd::endl```\n. You can understand more of it here\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Threads in a Multi-threaded Merge Sort (c)\r\n                \r\nSo I am currently working on a threaded merge sort program. I know my algorithm is correct since it works for a single thread. It is designed such that I have a MergeSort() function which recursively halves an array on both the left and right sides and then I call a Merge() function which does the actual sorting and merging. So for my multi-threaded merge-sort, I am partitioning my array in main according to the number of threads passed in (on the command line) and then sending each thread to my MergeSort() function. So far, my program is able to send each sub-array to MergeSort and sort the individual chunks within each thread. My problem now is calling a final merge on all threads. Am I supposed to thread the master merge at the end? Or can I just call Merge on whole array at once (from 0 to N-1)? How should I think about approaching this problem? Any guidance will be appreciated.\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How do I write a merge sort?\r\n                \r\nI am trying to implement a merge sort and am getting ```\nstack level too deep (SystemStackError)```\n error when I run my code.  I am not sure what the issue may be.\n\n```\ndef merge_sort(lists)\n  lists if lists.count == 1\n\n  middle  = lists[0..(lists.count / 2) - 1 ]\n  left = lists[0..middle.count - 1]\n  right = lists[middle.count..lists.count]\n\n  x = merge_sort(left)\n  y = merge_sort(right)\nend\n\nmerge_sort [1,2,3,4,5,6,7,8]\n```\n\n\nAny help would be great!\n    ", "Answer": "\r\nFrom wikipedia:\n\n```\ndef mergesort(list)\n  return list if list.size <= 1\n  mid   = list.size / 2\n  left  = list[0...mid]\n  right = list[mid...list.size]\n  merge(mergesort(left), mergesort(right))\nend\n\ndef merge(left, right)\n  sorted = []\n  until left.empty? || right.empty?\n    if left.first <= right.first\n      sorted << left.shift\n    else\n      sorted << right.shift\n    end\n  end\n  sorted.concat(left).concat(right)\nend\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sorting 3 Sorted Arrays\r\n                \r\nSay I have 3 sorted arrays A1, A2, A3. I want to merge them using merge aspect in merge sort. How would I find that runtime?\nI can't even suggest a solution, I'm completely stuck...\nThanks!\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Cannot reason with Cormen (4th ed) problem on Merge-Sort\r\n                \r\nConfused with Cormen's (4th ed.) 2.3-2 problem. It states the following:\n\nThe test in line 1 of the Merge-Sort procedure reads \"if p >= r\" rather than \"if p != r\". If Merge-Sort is called with p > r, then the subarray A[p : r] is empty. Argue that as long as the initial call of Merge-Sort(A, 1, n) has n >= 1, the test \"if p != r\" suffices to ensure that no recursive call has p > r.\n\nMerge-Sort pseudo code:\n```\nMerge-Sort(A, p, r)\n1    if p >= r\n2        return\n3    q = math.floor((p + r) / 2)\n4    Merge-Sort(A, p, q)\n5    Merge-Sort(A, q + 1, r)\n6    // Merge A[p : q] and A[q + 1 : r] into A[p : r]\n7    Merge(A, p, q, r)\n```\n\nBut if we change first line condition to ```\nif p != r```\n we'll get the following.\nIn case ```\nn = 1```\n, we call ```\nMerge-Sort(A, 1, 1)```\n. Line 1 — ```\np != r```\n — evaluates to false. We skip line 2, ```\nq = math.floor((1 + 1) / 2) = 1 ---> q = 1```\n. On line 4 we call ```\nMerge-Sort(A, 1, 1)```\n and after this call returns we go to line 5 and call ```\nMerge-Sort(A, 2, 1)```\n which is clearly a recursive call that has ```\np > r```\n.\nWhat is wrong with my reasoning and how can I solve the problem?\nUPD 1: @500 - Internal Server Error, thanks for replying. I should have stated that earlier — the convention of the pseudo code is that first index is 1 and last equals to array length. So in case of array of length 1 I should call ```\nMerge-Sort(A, 1, 1)```\n\n    ", "Answer": "\r\nClearly, you cannot just replace ```\nif p >= r```\n with ```\nif p != r```\n. ```\np != r```\n is the condition which should lead you to executing lines 3 through 7, so if you want to keep the same program structure, you'd need ```\nif p == r / return```\n.\nThis problem with the book has already been reported and the publishers say it will be corrected in the next printing. See the official errata for the 4th edition.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Haskell - Merge Sort, sorting words and numbers\r\n                \r\nI've written a merge sort in Haskell, it works when using numbers but not with words, and I thought it would. I just get \"Not in scope\" when using words and letters. What am I doing wrong?\n\nHere's my code:\n\n```\nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] ys = ys\nmerge xs [] = xs\nmerge (x:xs) (y:ys)\n    | x <= y = x : merge xs (y:ys)\n    | otherwise = y : merge (x:xs) ys\n\nmergeSort :: Ord a => [a] -> [a]\nmergeSort [] = []\nmergeSort [x] = [x]\nmergeSort xs\n    = merge (mergeSort top) (mergeSort bottom)\n    where\n    (top, bottom) = splitAt (length xs `div` 2) xs\n```\n\n    ", "Answer": "\r\nAre you entering your words like this?\n\n```\n[this,is,an,example,sentence]\n```\n\n\nThe syntax is not correct. If you want to input a literal string, you have to encapsulte it in double quotes (```\n\"```\n):\n\n```\n[\"this\",\"is\",\"an\",\"example\",\"sentence\"]\n```\n\n\nIf that is not your error, feel free to ignore this answer.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Guidance on Merge Sort Algorithm\r\n                \r\nCurrently working on a class assignment to create a merge sort algorithm using MIPS assembly language. Ill paste the instructions to said assignment to make sure my interpretation of what I'm supposed to do is correct. \n\nThe Instructions: \n\nConvert \"merge\" in Assignment 3 (Assignment 3 is a merge algorithm that takes two ordered lists merges all elements of that list into one long ordered list, I've already completed this) into a subroutine. Write a \"main\" program to perform merge-sorting of a list of integers by calling \"merge\" repeatedly ( ** Im assuming this means calling my previous Assignment 3**). For example, if the sorting program takes (6,5,9,1,7,0,-3,2) as input, it will produce a sorted list (-3,0,1,2,4,6,7,9). \nThe original unsorted list of integers should be received from the keyboard input. Your program should first ask for the user to input the number of integers in the original list, and then ask for inputting all the integers. The total number of integers to be sorted by this program should be a power of 2. This means, the program should work with a list of 2, 4, 8, 16, or 32 (...) integers (but your program needs only to handle up to 32 integers).\n\nNow, my merge algorithm takes two ordered lists but this assignment takes only 1 list. However, the link bellow explains merge sort in a way where the original unsorted list is progressively divided up into individual elements and then it works backwards and puts the elements in order. (Since my assignment 3 (the merge algorithm that i already have) takes two ordered lists would it be possible for me to simply do one iteration of my merge algorithm right after dividing the unsorted list into two unsorted lists??)\n\nBasically, calling my merge algorithm at the second step in the bellow link.\n\nhttps://www.tutorialspoint.com/data_structures_algorithms/merge_sort_algorithm.htm\n\nThank you so much! \n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort flowchart and guidance\r\n                \r\nIm currently working with merge sort. I am trying to write a program that reads a file full of numbers, asks the user if they want it sorted in ascending, descending, or both. and then write another file. I have gotten to the point where I am able to read the file, and sort it in ascending order, but hit a wall and don't know what to do next.\n\n```\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class mergesortapp{\n\n    public void mergeSort(Integer[] array, int lo, int n) {\n        int low = lo;\n        int high = n;\n        if (low >= high) {\n            return;\n        }\n\n        int middle = (low + high) / 2;\n        mergeSort(array, low, middle);\n        mergeSort(array, middle + 1, high);\n        int end_low = middle;\n        int start_high = middle + 1;\n        while ((lo <= end_low) && (start_high <= high)) {\n            if (array[low] < array[start_high]) {\n                low++;\n            } else {\n                int Temp = array[start_high];\n                for (int k = start_high - 1; k >= low; k--) {\n                    array[k + 1] = array[k];\n                }\n                array[low] = Temp;\n                low++;\n                end_low++;\n                start_high++;\n            }\n        }\n    }\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n    Final pb = new Final();\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"/TextFile\"));\n            List<Integer> lines = new ArrayList<Integer>();\n            String line;\n            while ((line = br.readLine()) != null) {\n                lines.add(Integer.parseInt(line));\n            }\n            br.close();\n            Integer[] inputArray = lines.toArray(new Integer[lines.size()]);\n            pb.mergeSort(inputArray, 0, inputArray.length - 1);\n            System.out.println(\"Here is your list of numbers that you requested: \");\n            for (Integer i : inputArray) {\n                System.out.println(i);\n            }\n        } catch (IOException ie) {\n            System.out.print(ie.getMessage());\n        }\n\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Is this the correct implementation of merge sort?\r\n                \r\n```\ndef merge(arr1, arr2):\n    returned = []\n    while len(arr1) > 0 and len(arr2) > 0:\n        if arr1[0] >= arr2[0]:\n            returned.append(arr2[0])\n            arr2.pop(0)\n        else:\n            returned.append(arr1[0])\n            arr1.pop(0)\n    if len(arr1) > 0:\n        returned = returned + arr1\n    if len(arr2) > 0:\n        returned = returned + arr2\n    return returned\n```\n\nAbove is the merge function. Below is the merge sort function.\n```\ndef merge_sort(nums):\n    #print(\"Merge sorting following array:\")\n    #print(nums)\n    if len(nums) == 1:\n        return nums\n    else:\n        middle = int(len(nums)/2)\n        first_half = nums[:middle]\n        #print(\"First half is:\")\n        #print(first_half)\n        second_half = nums[middle:]\n        #print(\"Second half is:\")\n        #print(second_half)\n        return merge(merge_sort(first_half), merge_sort(second_half))\n```\n\nIt feels like something is off because I timed it using the time module, and it was about 4 times as fast as a bubble sort algorithm, on a list 10 numbers long. I think I may be overthinking the merge function, but cannot put my finger on what I am doing wrong.\n    ", "Answer": "\r\nYour implementation is mostly functional, but it has some shortcomings:\n\nit cannot handle an empty list: such an argument will cause an infinite recursion resulting in a stack overflow. You should test if the length is <= 1.\nthe merge function modifies its arguments by popping the first element repeatedly. This is likely a very costly approach. It would be more efficient to use index variables to iterate in ```\narr1```\n and ```\narr2```\n.\nit does not implement a stable sort as equal elements are taken first from ```\narr2```\n then from ```\narr1```\n.\n\nHere is an alternative you can time and compare:\n```\ndef merge(arr1, arr2):\n    result = []\n    i = 0\n    j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            result.append(arr1[i])\n            i = i + 1\n        else:\n            result.append(arr2[j])\n            j = j + 1\n    return result + arr1[i:] + arr2[j:]\n\ndef merge_sort(nums):\n    if len(nums) <= 1:\n        return nums\n    else:\n        middle = len(nums) >> 1\n        first_half = nums[:middle]\n        second_half = nums[middle:]\n        return merge(merge_sort(first_half), merge_sort(second_half))\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to fix my merge sort?\r\n                \r\nWhen I compile my merge sort, it compiles fines but there is no output.\n\nThis needs to be done recursively.  Also, I do run my printList() function in my main, so it isn't that I am forgetting to print the list.  I've been staring at this for the past 30 minutes.\n\n```\npublic void printList(){\n    for(int i = 0; i <  fullNames.size(); i++){\n        System.out.println(fullNames.get(i));\n    }\n}\n\npublic void sort(){\n    fullNames = mergeSort(fullNames);\n}\n\npublic ArrayList<String> extract(ArrayList<String> ex, int low, int high){\n    ArrayList<String> answer = new ArrayList<String>();\n    for(int i = low; i <= high; i++){\n        answer.add(ex.get(i));\n    }\n\n    return answer;\n}\n\npublic ArrayList<String> merge(ArrayList<String> first, ArrayList<String> second){\n    int f = 0; \n    int s = 0;\n    ArrayList<String> answer = new ArrayList<String>();\n    while(first.size() > 0 || second.size() > 0){\n        if(s != second.size() && f != first.size()){\n            if(first.get(f).compareTo(second.get(s)) > 0){\n                answer.add(second.get(s));\n                s++;\n            }\n\n            else if(first.get(f).compareTo(second.get(s)) < 0){\n                answer.add(first.get(f));\n                f++;\n            }\n        }\n\n        else if(f == first.size()){\n            while(s != second.size()){\n                answer.add(second.get(s));\n                s++;\n            }\n        }\n\n        else{\n            while(f != first.size()){\n                answer.add(first.get(f));\n                f++;\n            }\n        }\n    }\n\n    return answer;\n}\npublic ArrayList<String> mergeSort(ArrayList<String> names){\n    int k = names.size()-1;\n\n    if(k > 1){\n        ArrayList<String> first = extract(names, 0, k / 2);\n        ArrayList<String> second = extract(names, (k / 2) + 1, k);\n\n        mergeSort(first);\n        mergeSort(second);\n\n        return merge(first, second);\n    }\n\n    else{\n        return names;\n    }\n}\n```\n\n    ", "Answer": "\r\nThe while condition in your merge will never be false because the size of first and second is never adjusted within the loop:\n\n```\nwhile(first.size() > 0 || second.size() > 0){\n        if(s != second.size() && f != first.size()){\n            if(first.get(f).compareTo(second.get(s)) > 0){\n                answer.add(second.get(s));\n                s++;\n            }\n\n            else if(first.get(f).compareTo(second.get(s)) < 0){\n                answer.add(first.get(f));\n                f++;\n            }\n        }\n\n        else if(f == first.size()){\n            while(s != second.size()){\n                answer.add(second.get(s));\n                s++;\n            }\n        }\n\n        else{\n            while(f != first.size()){\n                answer.add(first.get(f));\n                f++;\n            }\n        }\n    }\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "actual time complexity of merge sort\r\n                \r\nI believe I have understood merge-sort to some extent and I was trying to understand the time complexity of merge-sort but find it hard to totally understand it. so we will recursively call mergesort to each(i.e. left and right sub-arrays), which will be log(n) and I understand that. but the merging part of the merge-sort says its complexity is o(n) making the whole time complexity, O(nlog(n)). but i don't quite understand how the merging part is linear becasue for every subarray call, there will be len(sub_array) * some constant operations. so if the length of the array to be sorted is n, then the merging part will be as ff according to my understanding:\nlet k = number of primitive operations, n = length of sub-array, then total time complexity will be, here 2 is as there are two parts(left sub-array and right sub-array).\n2(k)*2 + 2(k)*4+2(k)*8 + ......+2(k)n.(number of sums is logn times) but i don't know how is this generalized to nlogn?(like had it been k + k + k + k +.....+k n times, then it makes sense to say O(nk) and discard the constant k, however, in merge sort, it's not constant? so how is the time complexity really computed??\n    ", "Answer": "\r\nLet array length is n=2^k for simplicity. I'll show scheme for length 8 array.\nAt first we recursively divide array to 2^(k-1) chunks, then 2^(k-2) chunks and so on until length becomes 1\n```\n a   b   c   d   e   f   g   h\n```\n\nNow we perform merging to size 2 chunks  (ab denotes sorted array with a and b elements)\n```\n a   b   c   d   e   f   g   h\n  \\ /     \\ /     \\ /     \\ /\n   ab     cd       ef      gh\n```\n\nWe make 4*2 operations (not elementary operations, but every is O(1))\n```\n   ab     cd       ef      gh\n     \\   /           \\    /\n     abcd             efgh  \n```\n\nWe make 2*4 operations\n```\n     abcd           efgh\n          \\        /  \n           abcdefgh\n```\n\nAnd here we make  1*8 operations\nWe can see that we make ```\nlog(n)```\n steps, every steps takes the same number: ```\nn```\n operations, so overall complexity is ```\nO(nlogn)```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "want to implement merge sort algorithm in different way\r\n                \r\nMerge Sort divide the list into the smallest unit (1 element), then compare each element with the adjacent list to sort and merge the two adjacent list. Finally all the elements are sorted and merged.\nI want to implement the merge sort algorithm in such a way that it divides the list into a smallest unit of two elements and then sort and merge them. ? \nHow i can implement that???\n\nMERGE-SORT (A, p, r)\n\n\nIF p < r                                                    // Check for base case\nTHEN q = FLOOR[(p + r)/2]                 // Divide step\nMERGE (A, p, q)                          // Conquer step.\nMERGE (A, q + 1, r)                     // Conquer step.\nMERGE (A, p, q, r)                       // Conquer step.\n\n\nsomething like p < r+1 .\n    ", "Answer": "\r\nI've done something that sounds this before.  Here are 2 variations.\n\nVariation 1: Go through the list, sorting each pair.  Then go through the list, merging each pair of pairs.  Then each pair of 4s, and so on.  When you've merged the whole list, you're done.\n\nVariation 2: Have a stack of sorted arrays.  Each element merges into the bottom array, and then cascade, but merging down until there is only one, or the second from the top is larger than the top.  After your last element has been added, collapse the array by merging it.\n\nThe case where I've used variation 2 was one where I had a very large amount of data streaming in.  I kept the first few stacks of sorted arrays in memory, and then later ones stored on disk.  This lead to good locality of reference, and efficient use of disk.  (You ask why I didn't use an off the shelf solution?  Well the dataset I had coming in was bigger than the disk I had to handle it on, there was custom merging logic in there, and the sort really wasn't that hard to write.)\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "C++ OpenMP merge sort\r\n                \r\nI have written parallel implementation of merge sort but for some reasons that I cannot understand sometimes it finishes properly, and sometimes it crashes. Whats more interesting following code sometimes seems to crash AFTER it has sorted the array (the array gets printed and then code stops working).\n\nCould anyone help me diagnose a problem? I guess I messed something with threads and they are not ending properly?\n\n```\nvoid printArray (int* a, int elements) {\n    for(int i = 0; i < elements; i++) {\n        printf(\"%d\\t\", a[i]);\n    }\n}\n\nvoid merge2(int a[], int l, int middle, int r) {\n    int leftIterator = l;\n    int rightIterator = middle+1;\n    int k = 0;\n\n    int* tmp = new int[(r - l)]; \n    while (leftIterator <= middle &&  rightIterator <= r) { \n        if (a[leftIterator] < a[rightIterator]) {\n            tmp[k] = a[leftIterator];\n            leftIterator++;\n        }\n        else {\n            tmp[k] = a[rightIterator];\n            rightIterator++;\n        }\n        k++;\n    }\n\n    if (leftIterator <= middle) { \n        while (leftIterator <= middle) {\n            tmp[k] = a[leftIterator];\n            leftIterator++;\n            k++;\n        }\n    }\n    else {\n            while (rightIterator <= r) {\n                tmp[k] = a[rightIterator];\n                rightIterator++;\n                k++;\n            }\n    }\n\n    for (int i = 0; i <= (r - l); i++)\n        a[l + i] = tmp[i];\n}\n\nvoid merge_sort(int a[], int l, int r) {\n    if (l != r) {\n    int middle= (l + r) / 2; //find middle element\n    #pragma omp parallel sections\n    { \n       #pragma omp section\n       merge_sort(a, l, middle);\n       #pragma omp section\n        merge_sort(a, middle + 1, r);\n    }\n    merge2(a, l, middle, r);\n    }\n}\n\nint main(void) {\n    int elements = 10;\n    int a[10] = { 10,2,1,5,6,3,4,9,8,7 };\n    merge_sort(a, 0, elements-1);\n    printArray(a, elements); // print sorted array\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort - Wrong Output\r\n                \r\nI have just implemented Merge Sort in C. In terms of logic I think my code is right. Although, the output is wrong. And the output is not the number I have in the original array. That is what I find odd. Please help me. The output I receive is: -1 0 0 -1 0 4.\n\nHere is the code:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid merge (int right[], int left[], int elements[], int midValue) {\n\n    int lengthL = midValue; /*tamanho do array da esquerda*/\n    int lengthR = midValue - 1; /*tamanho do array da direita*/\n\n    int i = 0; /*index do numero mais pequeno no array da esquerda*/\n    int j = 0; /*index do numero mais pequeno no array da direita*/\n    int k = 0; /*representa o index da posicao que precisa de ser preenchida no array original\n               que neste caso é \"elementos\"*/\n\n    while (i < lengthL && j < lengthR) {\n        if (left[i] <= right[j]) {\n            elements[k] = left[i];\n            i = i + 1;\n        }\n        else {\n            elements[k] = right[j];\n            j = j + 1;\n        }\n        k = k + 1;\n    }\n\n\n    /*estes dois while loops seguintes sao para as sobras em ambos\n    os arrays. depois de sair do primeiro while loop que esta acima apenas um\n    dos while loops a seguir serao executados pois apenas irá haver sobras em apenas um deles*/\n\n    while (i < lengthL) {\n        elements[k] = elements[i];\n        i = i + 1;\n        k = k + 1;\n    }\n\n    while (j < lengthR) {\n        elements[k] = elements[j];\n        j = j + 1;\n        k = k + 1;\n    }\n\n}\n\nvoid MergeSort (int elements[], int numberOfElements) {\n\n    if (numberOfElements < 2) {\n        return;\n    }\n\n    int midValue = numberOfElements / 2;\n\n    int left[midValue];\n    int right[midValue - 1];\n\n    for (int i = 0; i < midValue - 1; i = i + 1) {\n        left[i] = elements[i];\n    }\n\n    for (int i = midValue; i < numberOfElements - 1; i = i + 1) {\n        right[i] = elements[i];\n    }\n\n    MergeSort(left, midValue);\n    MergeSort(right, midValue - 1);\n    merge(left, right, elements, midValue);\n}\n\n\n\nint main() {\n\n    int elements[6] = {2, 1, 5, 3, 7, 4};\n\n    int numberOfElements = 6; /*número de elementos do array*/\n\n    MergeSort(elements, numberOfElements);\n\n    for(int i = 0; i < numberOfElements; i = i + 1) {\n        printf(\"%d \",elements[i]);\n    }\n\n}\n```\n\n    ", "Answer": "\r\nThere appear to be multiple errors in your code.\nFor example, the input to ```\nMergeSort```\n includes an array ```\nelements```\n with\nelements numbered 0, 1, ..., (numberOfElements - 1).  The loops that copy these elements from ```\nelements```\n to the ```\nleft```\n and ```\nright```\n arrays do not copy element number (midValue - 1) (too large to be copied by the ```\nleft```\n loop, too small to be copied by the ```\nright```\n loop) nor do they copy element number (numberOfElements - 1).\n\nMoreover, the second loop within ```\nMergeSort```\n writes data to memory locations somewhere past the end of the space allocated for the ```\nright```\n array, not in the correct places in the ```\nright```\n array.\nTo correctly copy the second half of ```\nelements```\n, element number midValue of ```\nelements```\n should be copied to element number 0 of ```\nright```\n.\nYour code clearly does not do that.\n\nWhen you pass the ```\nleft```\n and ```\nright```\n arrays to ```\nmerge```\n near the end of ```\nMergeSort```\n, however, ```\nmerge```\n treats the ```\nleft```\n array as if it contained midValue elements even though it contains only (midValue - 1) elements.\n\nI think there's more but you have plenty of debugging to do already. Try printing out the input and output of each function to see if the functions are doing what you expect, or try smaller test cases (such as an array of length 2) and follow the logic of your program while you step through it in a debugger.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort for multiple types\r\n                \r\nI'm trying to implement a Merge Sort algorithm that can work with integers, strings and char. Unfortunately, I found that it doesn't work properly with integers when the array length is odd. \n\nFor example: Input: ```\n2 2 3 7 1 2 1```\n. Output: ```\n2 2 3 7 0 1 1```\n.\n\nNow I'm trying to find the mistake in my code. Here it is:\n\n```\n#include <stddef.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"MergeSort.h\"\n\nint StrCmp(char *st1, char *st2) {\n    char *str1 = st1, *str2 = st2;\n    while (*str1 == *str2 && *str1 != 0)\n        str1++, str2++;\n    return *str1 - *str2;\n}\n\nint CompareInt(void *a, void *b) {\n    return *(int *)a - *(int *)b;\n}\n\nint CompareChar(void *a, void *b) {\n    return *(char *)a - *(char *)b;\n}\n\nint CompareStr(const void *a, const void *b) {\n    return strcmp(*(char **)a, *(char **)b);\n}\n\nint merge(void *base, size_t num, size_t el_size, int (*compar)(const void*, const void*)) {\n    size_t size = (size_t)num / 2;\n    char *char_base = (char *)base;\n    char *first = malloc(size * el_size);\n    char *second = malloc((num - size) * el_size);\n\n    for (int i = 0; i < size; i++)\n        for (int j = 0; j < el_size; j++)\n            first[i * el_size + j] = char_base[i * el_size + j];\n\n    for (int i = 0; i < num - size; i++)\n        for (int j = 0; j < el_size; j++)\n            second[i * el_size + j] = char_base[size * el_size + i * el_size + j];\n\n    size_t i = 0, j = 0, c = 0;\n    while (i < size && j < num - size) {\n        if (compar(&first[i * el_size], &second[j * el_size]) <= 0) {\n            for (int k = 0; k < el_size; k++) \n                char_base[el_size * c + k] = first[i * el_size + k];\n            i++;\n        } else { \n            for (int k = 0; k < el_size; k++) \n                char_base[el_size * c + k] = second[j * el_size + k];\n            j++;\n        }\n        c++;\n    }\n\n    if (i == size) { \n        while (j < num - size) {\n            for (int k = 0; k < el_size; k++) \n                char_base[el_size * c + k] = second[j * el_size + k];\n            j++;\n            c++;\n        }\n    } else { \n        while (i < size) {\n            for (int k = 0; k < el_size; k++) \n                char_base[el_size * c + k] = first[i * el_size + k];\n            i++;\n            c++;\n        }\n    }\n    free(first);\n    free(second);\n}\n\nint merge_sort(void *base, size_t num, size_t el_size, int (*compar)(const void*, const void*)) {\n    if (num > 1) {\n        size_t s = num / 2;\n        char *char_base = base;\n        merge_sort(char_base, s, el_size, compar);\n        merge_sort(char_base + (num - s) * el_size, num - s, el_size, compar);\n        merge(char_base, num, el_size, compar);\n    }\n}\n\nint main() {\n    int nums[] = { 2, 2, 3, 7, 1, 2, 1 };\n    cmp_t cmp = CompareInt;\n    merge_sort(nums, 7, sizeof(int), cmp);\n    for (int i = 0; i < 7; i++)\n        printf(\"%i \", nums[i]);\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThe bug is in function ```\nmerge_sort()```\n: the second recursive call is done on the wrong base address:\n\n```\nmerge_sort(char_base + (num - s) * el_size, num - s, el_size, compar);\n```\n\n\nfix is with \n\n```\nmerge_sort(char_base + s * el_size, num - s, el_size, compar);\n```\n\n\nNote that there are other issues in your code:\n\n\nthe comparison functions have incorrect signatures, they should take ```\nconst void *```\n arguments.\nboth ```\nmerge()```\n and ```\nmerge_sort()```\n should be defined as ```\nvoid```\n since they return no value.\n```\nCompareInt```\n cannot handle large integer values whose difference exceeds ```\nINT_MAX```\n, such as ```\nINT_MAX```\n and ```\nINT_MIN```\n.  It should be written:\n\n```\nint CompareInt(const void *a, const void *b) {\n    int na = *(const int *)a;\n    int nb = *(const int *)b;\n    return (nb < na) - (na < nb);\n}\n```\n\nyou should print a ```\n'\\n'```\n after the numbers.\n\n\nYou could also improve the implementation in various ways:\n\n\nif you computed ```\ns```\n as ```\n(n + 1) / 2```\n, you could use less memory and have a simpler and faster implementation as you would not need the ```\nsecond```\n array in the ```\nmerge```\n function.\nusing pointers, you would drastically reduce the number of multiplications.\n\n\nHere is a simpler implementation with the same semantics:\n\n```\nvoid merge(void *base, size_t num, size_t el_size, size_t size,\n           int (*compar)(const void*, const void*)) {\n    size_t split = size * el_size;\n    char *first = malloc(split);\n    char *p1 = memcpy(first, base, split);\n    char *dest = base, *p2 = dest + split;\n    size_t i = 0, j = size;\n    while (i < size) {\n        if (j == num || compar(p1, p2) <= 0) {\n            for (size_t k = 0; k < el_size; k++)\n                *dest++ = *p1++;\n            i++;\n        } else {\n            for (size_t k = 0; k < el_size; k++)\n                *dest++ = *p2++;\n            j++;\n        }\n    }\n    free(first);\n}\n\nvoid merge_sort(void *base, size_t num, size_t el_size,\n                int (*compar)(const void*, const void*)) {\n    if (num > 1) {\n        size_t s = (num + 1) / 2;\n        char *char_base = base;\n        merge_sort(char_base, s, el_size, compar);\n        merge_sort(char_base + s * el_size, num - s, el_size, compar);\n        merge(char_base, num, el_size, s, compar);\n    }\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort most efficient implementation\r\n                \r\nSo I wonder what is the most efficient implementation of a merge sort in Java (In case its efficiency in terms of time can change depending on the language). This question may be trivial but my ultimate goal is to learn from more experienced programmers. Here are 2 examples I made:\n\n```\n//version I made.\npublic static double[] mergeSort(double[] arreglo) {\n    if (arreglo.length > 1) {\n        int d = (arreglo.length / 2);\n        double[] arreglo1 = Arrays.copyOfRange(arreglo, 0, d),\n                arreglo2 = Arrays.copyOfRange(arreglo, d, arreglo.length);\n        arreglo1 = mergeSort(arreglo1);\n        arreglo2 = mergeSort(arreglo2);\n        return merge(arreglo1, arreglo2);\n    } else {\n        return arreglo;\n    }\n}\n\npublic static double[] merge(double[] arreglo1, double[] arreglo2) {\n    double[] convi = new double[arreglo1.length + arreglo2.length];\n    for (int i = 0, m1 = 0, m2 = 0; i < convi.length; i++) {\n        if (arreglo1.length > m1 && arreglo2.length > m2) {\n            if (arreglo1[m1] <= arreglo2[m2])\n                convi[i] = arreglo1[m1++];\n            else {\n                convi[i] = arreglo2[m2++];\n            }\n        } else {\n            convi[i] = (arreglo1.length == m1) ? arreglo2[m2++] : arreglo1[m1++];\n        }\n    }\n    return convi;\n}\n\n//Taken out of Cormens book.\npublic static void mergeSort(int[] arreglo, int i, int f) {\n    if (f > i) {\n        int d = ((i + f) / 2);\n        mergeSort(arreglo, i, d);\n        mergeSort(arreglo, d + 1, f);\n        merge(arreglo, i, d, f);\n    }\n}\n\n\npublic static void merge(int[] arreglo, int i, int m, int f) {\n    int n1 = (m - i) + 1;\n    int n2 = (f - m);\n    int[] mitad1 = new int[n1 + 1];\n    int[] mitad2 = new int[n2 + 1];\n    for (int v = 0; v < n1; v++) {\n        mitad1[v] = arreglo[i + v];\n    }\n    for (int p = 0; p < n2; p++) {\n        mitad2[p] = arreglo[p + m + 1];\n    }\n    mitad1[n1] = Integer.MAX_VALUE;\n    mitad2[n2] = Integer.MAX_VALUE;\n    for (int r = i, m1 = 0, m2 = 0; r <= f; r++) {\n        if (mitad1[m1] <= mitad2[m2]) {\n            arreglo[r] = mitad1[m1];\n            m1++;\n        } else {\n            arreglo[r] = mitad2[m2];\n            m2++;\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nThe following program is translated from C++ example given in Robert Sedgewick's Algorithms in C++, Parts 1-4 \n\nIt introduces one type of improvement. It does a single copy of the whole sorting array into a an auxiliary array that is further dealt with. Next, the recursion splitting is done on the auxiliary array by alternating between the auxiliary array and original array so that the extra copying operation of the merged arrays doesn’t happen. Basically, the algorithm switches the role of the input and auxiliary array in each recursive call. For example, conceptually:\n\nRegular Mergesort:\n\n--merge\n\n```\n(((8) (5))((2) (3)))(((1) (7))((4) (6)))\n\n(( 5 8 )( 2 3 ))(( 1 7 )( 4 6 ))\n\n-- copy back and ignore previous (UNNECESSARY)\n\n(( 5 8 )( 2 3 ))(( 1 7 )( 4 6 ))\n```\n\n\n– – – – – – – –\n\nThis program:\n\n--merge\n\n```\n(((8) (5))((2) (3)))(((1) (7))((4) (6)))\n\n(( 5 8 )( 2 3 ))(( 1 7 )( 4 6 ))\n```\n\n\n--merge backwards\n\n```\n( 2 3 5 8 )( 1 4 6 7 )\n\n(( 5 8 )( 2 3 ))(( 1 7 )( 4 6 ))    \n```\n\n\nAlso, after splitting the array into halves gives small enough arrays, the algorithm uses ```\ninsertion sort```\n since it performs better on small data sets than ```\nmerge sort```\n. The threshold for when exactly to use ```\ninsertion sort```\n can be determined with trial-and-error.\n\nThe code:\n\n```\nstatic int M = 10;\n\n//insertion sort to be used once the mergesort partitions become small enough\nstatic void insertionsort(int[] a, int l, int r) {\n    int i, j, temp;\n    for (i = 1; i < r + 1; i++) {\n        temp = a[i];\n        j = i;\n        while ((j > 0) && a[j - 1] > temp) \n        {\n            a[j] = a[j - 1];\n            j = j - 1;\n        }\n        a[j] = temp;\n    }\n}\n\n//standard merging two sorted half arrays into single sorted array\nstatic void merge(int[] merged_a, int start_a, int[] half_a1, int start_a1, int size_a1, \n                         int[] half_a2, int start_a2, int size_a2) {\n    int i, j, k;\n    int total_s = size_a1 + size_a2;\n    for (i = start_a1, j = start_a2, k = start_a; k < (total_s); k++) {\n        // if reached end of first half array, run through the loop \n        // filling in only from the second half array\n        if (i == size_a1) {\n            merged_a[k] = half_a2[j++];\n            continue;\n        }\n        // if reached end of second half array, run through the loop \n        // filling in only from the first half array\n        if (j == size_a2) {\n            merged_a[k] = half_a1[i++];\n            continue;\n        }\n        // merged array is filled with the smaller element of the two \n        // arrays, in order\n        merged_a[k] = half_a1[i] < half_a2[j] ?\n                      half_a1[i++] : half_a2[j++];\n    }\n}\n\n//merge sort data during merging without the additional copying back to array\n//all data movement is done during the course of the merges\nstatic void mergesortNoCopy(int[] a, int[] b, int l, int r) {\n    if (r - l <= M) {\n        insertionsort(a + l, l, r - l);\n        return;\n    }\n    int m = (l + r) / 2;\n    //switch arrays to msort b thus recursively writing results to b\n    mergesortNoCopy(b, a, l, m); //merge sort left\n    mergesortNoCopy(b, a, m + 1, r); //merge sort right\n    //merge partitions of b into a\n    merge(a, l, b, l, m - l + 1, b, m + 1, r - m); //merge\n}\n\nstatic void mergesort(int[] a) {\n    int[] aux = Arrays.copyOf(a, a.length);\n    mergesortNoCopy(a, aux, 0, a.length - 1);\n}\n```\n\n\nSome other possible improvements:\n\nStop if already sorted.\n\nCheck if the largest item in first half ≤ smallest item in second half.\nHelps for partially-ordered arrays.\n\n```\n// after split, before merge\nif (a[mid] <= a[mid + 1]) return;\n```\n\n\nEDIT: here is a good document I found on different versions of Mergesort and improvements thereof. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort of a linked list java: Stack overflow\r\n                \r\nI'm trying to implement a linked list merge sort. \n\nHere's the class I'm trying to do the merge sort in. \n\n```\n/**\n * CS 200 Colorado State University, Fall 2011\n */\n\npublic class Member {\n\nprivate String userID;\nprivate String first;\nprivate String last;\nprivate EdgeStack edgeStack;\n\npublic void sortScore(Member member){\n    // calling a helper method\n    // this greedy method takes all the creds \n    edgeStack = sortEdgeStack(member); \n}\n\nprivate EdgeStack sortEdgeStack(Member member)\n{\n    // our temp stacks\n    EdgeStack tempEdgeStack_A = new EdgeStack();\n    EdgeStack tempEdgeStack_B = new EdgeStack();\n\n    // our return value \n    EdgeStack result = null; \n    // storing the size of the stack \n    int sizeOfStack = member.getEdgeStack().getSize();\n    // base case \n    if(sizeOfStack<0){\n        return null; \n    }\n    // our true base case\n    else if(sizeOfStack==1) \n    { \n        // init stack\n        EdgeStack base = new EdgeStack(); \n\n        base.push(member.getEdgeStack().pop());\n        return base; \n    }\n    else\n    {\n\n        // pop and store \n        for(int i = 0; i < (sizeOfStack / 2); i++)\n        {\n            tempEdgeStack_A.push(member.getEdgeStack().pop()); \n        }\n        // pop and store into b\n        for(int j = (sizeOfStack/2)+1; j < sizeOfStack; j++)\n        {\n            tempEdgeStack_B.push(member.getEdgeStack().pop());\n        }\n\n        tempEdgeStack_A = sortEdgeStack(member);\n        tempEdgeStack_B = sortEdgeStack(member);\n        result = merge(tempEdgeStack_A,tempEdgeStack_B); \n        return result;\n    }\n}\n\n\nprivate EdgeStack merge(EdgeStack tempEdgeStack_A, EdgeStack tempEdgeStack_B) {\n\n    EdgeStack result = new EdgeStack(); \n\n    // while either or\n    while(tempEdgeStack_A.getSize()> 0 || tempEdgeStack_B.getSize() > 0)\n    {\n        // if both are bigger then 0 \n        if(tempEdgeStack_A.getSize()> 0 && tempEdgeStack_B.getSize() > 0)\n        {\n            if(tempEdgeStack_A.peek().getEdgeRank()<=tempEdgeStack_B.peek().getEdgeRank())\n            {\n                // adds b to result\n                result.push(tempEdgeStack_A.pop()); \n            }\n            else \n            {\n                result.push(tempEdgeStack_B.pop());\n            }\n        }\n        // these elses cover if A or B are > 0 but A or B is also less then or equal too 0; \n        else if(tempEdgeStack_A.getSize()> 0)\n        {\n            while(tempEdgeStack_A.iterator().hasNext())\n            {\n                result.push(tempEdgeStack_A.iterator().next()); \n            }\n        }\n        else if(tempEdgeStack_B.getSize()> 0)\n        {\n            while(tempEdgeStack_B.iterator().hasNext())\n            {\n                result.push(tempEdgeStack_B.iterator().next()); \n            }\n        }\n    }\n\n    return result; \n}\n }\n```\n\n\nHere's the stack class (that implements a linked list). Why am I getting a stack overflow error? \n\n```\nimport java.util.LinkedList;\nimport java.util.ListIterator;\n\n/**\n * CS 200 Colorado State University, Fall 2011\n */\n\npublic class EdgeStack {\n\n\nprivate LinkedList<Edge> llist=new LinkedList<Edge>();\n\npublic EdgeStack(){\n    //add your code\n}\n\npublic boolean isEmpty(){\n    return llist.isEmpty();\n}\n\npublic void push(Edge e){\n    llist.add(e);\n}\n\npublic Edge getIndexAt(int n){\n    return llist.get(n);\n}\n\npublic Edge pop(){\n    return llist.remove();\n}\n\npublic Edge peek(){\n\n    return llist.getLast();\n}\n\npublic int getSize(){\n    return llist.size();\n}\n\n//  public Edge peek(int n){\n//      LinkedList<Edge> temp=llist;\n//      return temp.peek();\n//  }\n\n\npublic LinkedList<Edge> popAll(){\n    LinkedList<Edge> temp=llist;\n    llist=null;\n    return temp;    }\n\npublic ListIterator<Edge> iterator()\n{\n    return llist.listIterator();\n}\n\n}\n```\n\n    ", "Answer": "\r\nCheck this:\n\n```\n    else if(tempEdgeStack_A.getSize()> 0)\n    {\n        while(tempEdgeStack_A.iterator().hasNext())\n        {\n            result.push(tempEdgeStack_A.iterator().next()); \n        }\n    }\n    else if(tempEdgeStack_B.getSize()> 0)\n    {\n        while(tempEdgeStack_B.iterator().hasNext())\n        {\n            result.push(tempEdgeStack_B.iterator().next()); \n        }\n    }\n```\n\n\nYou don't remove entries from the stacks, so the loop doesn't stop.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Parallel Merge-Sort in OpenMP\r\n                \r\nI have seen an algorithm for parallel merge-sort in a this paper. This is the code:\n```\nvoid mergesort_parallel_omp (int a[], int size, int temp[], int threads) \n{  \n    if ( threads == 1)       { mergesort_serial(a, size, temp); }\n    else if (threads > 1) \n    {\n         #pragma omp parallel sections\n         {\n             #pragma omp section\n             mergesort_parallel_omp(a, size/2, temp, threads/2);\n             #pragma omp section\n             mergesort_parallel_omp(a + size/2, size - size/2, temp + size/2, threads - threads/2);\n         }\n         merge(a, size, temp); \n    } // threads > 1\n}\n```\n\nI run it on a multicore. What happens is that at the leafs of the tree, 2 threads run in parallel. After they finished their work 2 other threads start and so on. Even if we have free cores for all the leaf nodes.\nI think the reason is this OpenMP code does not create parallel regions inside parallel regions. Am I correct?\n    ", "Answer": "\r\n\nI think the reason is that OpenMP cannot create parallel regions\ninside parallel regions\n\nYou can have a parallel region of parallel region.\n\nOpenMP parallel regions can be nested inside each other. If nested\nparallelism is disabled, then the new team created by a thread\nencountering a parallel construct inside a parallel region consists\nonly of the encountering thread. If nested parallelism is enabled,\nthen the new team may consist of more than one thread (source).\n\nIn order to run your code correctly, you need to call ```\nomp_set_nested(1)```\n and ```\nomp_set_num_threads(2)```\n.\n\nNested parallelism can be enabled or disabled by setting the\nOMP_NESTED environment variable or calling omp_set_nested() function\n\n\nFor a better performance instead of sections you can use OpenMP tasks (detailed information and examples about can be found here) as follows:\n```\nvoid merge(int * X, int n, int * tmp) {\n   ...\n} \n\nvoid mergeSort(int *X, int n, int *tmp)\n{  \n   if (n < 2) return;\n   \n   #pragma omp task shared(X) if (n > TASK_SIZE)\n   mergeSort(X, n/2, tmp);\n   \n   #pragma omp task shared(X) if (n > TASK_SIZE)\n   mergeSort(X+(n/2), n-(n/2), tmp + n/2);\n   \n   #pragma omp taskwait\n   mergeSortAux(X, n, tmp);\n}\n\n\n\nint main()\n{\n   ...\n   #pragma omp parallel\n   {\n      #pragma omp single\n      mergesort(data, n, tmp);\n   }\n} \n```\n\nThe sequential code of the merge algorithm comes from Dr. Johnnie W. Baker webpage.. However, the code that I am providing in this answer has some corrections and performance improvements.\nA full running example:\n```\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h>\n\n#define TASK_SIZE 100\n\nunsigned int rand_interval(unsigned int min, unsigned int max)\n{\n    // https://stackoverflow.com/questions/2509679/\n    int r;\n    const unsigned int range = 1 + max - min;\n    const unsigned int buckets = RAND_MAX / range;\n    const unsigned int limit = buckets * range;\n\n    do\n    {\n        r = rand();\n    } \n    while (r >= limit);\n\n    return min + (r / buckets);\n}\n\nvoid fillupRandomly (int *m, int size, unsigned int min, unsigned int max){\n    for (int i = 0; i < size; i++)\n    m[i] = rand_interval(min, max);\n} \n\nvoid mergeSortAux(int *X, int n, int *tmp) {\n   int i = 0;\n   int j = n/2;\n   int ti = 0;\n\n   while (i<n/2 && j<n) {\n      if (X[i] < X[j]) {\n         tmp[ti] = X[i];\n         ti++; i++;\n      } else {\n         tmp[ti] = X[j];\n         ti++; j++;\n      }\n   }\n   while (i<n/2) { /* finish up lower half */\n      tmp[ti] = X[i];\n      ti++; i++;\n   }\n   while (j<n) { /* finish up upper half */\n      tmp[ti] = X[j];\n      ti++; j++;\n   }\n   memcpy(X, tmp, n*sizeof(int));\n} \n\nvoid mergeSort(int *X, int n, int *tmp)\n{\n   if (n < 2) return;\n\n   #pragma omp task shared(X) if (n > TASK_SIZE)\n   mergeSort(X, n/2, tmp);\n\n   #pragma omp task shared(X) if (n > TASK_SIZE)\n   mergeSort(X+(n/2), n-(n/2), tmp + n/2);\n\n   #pragma omp taskwait\n   mergeSortAux(X, n, tmp);\n}\n\nvoid init(int *a, int size){\n   for(int i = 0; i < size; i++)\n       a[i] = 0;\n}\n\nvoid printArray(int *a, int size){\n   for(int i = 0; i < size; i++)\n       printf(\"%d \", a[i]);\n   printf(\"\\n\");\n}\n\nint isSorted(int *a, int size){\n   for(int i = 0; i < size - 1; i++)\n      if(a[i] > a[i + 1])\n        return 0;\n   return 1;\n}\n\nint main(int argc, char *argv[]) {\n        srand(123456);\n        int N  = (argc > 1) ? atoi(argv[1]) : 10;\n        int print = (argc > 2) ? atoi(argv[2]) : 0;\n        int numThreads = (argc > 3) ? atoi(argv[3]) : 2;\n        int *X = malloc(N * sizeof(int));\n        int *tmp = malloc(N * sizeof(int));\n\n        omp_set_dynamic(0);              /** Explicitly disable dynamic teams **/\n        omp_set_num_threads(numThreads); /** Use N threads for all parallel regions **/\n\n         // Dealing with fail memory allocation\n        if(!X || !tmp)\n        { \n           if(X) free(X);\n           if(tmp) free(tmp);\n           return (EXIT_FAILURE);\n        }\n\n        fillupRandomly (X, N, 0, 5);\n\n        double begin = omp_get_wtime();\n        #pragma omp parallel\n        {\n            #pragma omp single\n            mergeSort(X, N, tmp);\n        }   \n        double end = omp_get_wtime();\n        printf(\"Time: %f (s) \\n\",end-begin);\n    \n        assert(1 == isSorted(X, N));\n\n        if(print){\n           printArray(X, N);\n        }\n\n        free(X);\n        free(tmp);\n        return (EXIT_SUCCESS);\n}\n```\n\nAn had-doc benchmark in a 4 core machine yield the following results:\n```\n100000000 elements \n1 thread : Time: 11.052081 (s)\n2 threads: Time: 5.907508  (s)\n4 threads: Time: 4.984839  (s)\n\nA overall Speed up of 2.21x\n```\n\nFuture improvements will be available on GitHub.\n\nAn advance C++ version of parallel version can be found here. The final algorithm looks like the following:\n```\nvoid mergeSortRecursive(vector<double>& v, unsigned long left, unsigned long right) {\n   if (left < right) {\n      if (right-left >= 32) {\n         unsigned long mid = (left+right)/2; \n         #pragma omp taskgroup\n         {\n            #pragma omp task shared(v) untied if(right-left >= (1<<14))\n            mergeSortRecursive(v, left, mid);\n            #pragma omp task shared(v) untied if(right-left >= (1<<14))\n            mergeSortRecursive(v, mid+1, right);\n            #pragma omp taskyield\n         }\n         inplace_merge(v.begin()+left, v.begin()+mid+1, v.begin()+right+1);\n      }else{\n         sort(v.begin()+left, v.begin()+right+1);\n     }\n    }\n  }\n}\n\n\nvoid mergeSort(vector<double>& v) { \n     #pragma omp parallel\n     #pragma omp single\n     mergeSortRecursive(v, 0, v.size()-1); \n}\n```\n\nA reported speedup of ```\n6.61x```\n for 48 threads.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Count Comparisons for Merge Sort\r\n                \r\n I'm trying to count the number of comparisons a merge sort algorithm makes when sorting a list. I've tried multiple ways, but due to the recursion, I am always returned with an answer that is essentially the size of the list. Any suggestion on how to count the number of comparisons this makes? \n    ", "Answer": "\r\nI can think of two solutions:\n\n\nless beautiful, but easier to implement.\n\n\nDeclare counter as global variable. You can refer to it in your function by using ```\nglobal counter```\n.\n\n\nAvoiding global variables\n\n\nHere:\n\n```\nmergesort(lefthalf)\nmergesort(righthalf)\n```\n\n\nYou do not make use of the returned comparison counter. if you make something like:\n\n```\ncount += mergesort(lefthalf)\ncount += mergesort(righthalf)\n```\n\n\nYou will get your comparison count. Remember to initialize your counter with 0 each time you call ```\nmergesort()```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Together Two Arrays in Php?\r\n                \r\nI'm new to ```\nPHP```\n, so maybe I'm missing something simple. I have two multidimensional hashes of the form:\n\n```\nArray1:\n'x' => Array ( 'a' => num1, 'b' => '1' ), \n'y' => Array ( 'a' => num3, 'b' => '3' ), \n'z' => Array ( 'a' => num5, 'b' => '5' ) \n\nArray2:\n'w' => Array ( 'a' => num1, 'b' => '2' ), \n'q' => Array ( 'a' => num3, 'b' => '4' ), \n'r' => Array ( 'a' => num5, 'b' => '6' ) \n```\n\n\nBoth arrays are sorted by b. All I want to do is merge them together to get a list of the keys sorted by b. This should be a trivial O(n) operation a la merge sort, but I can't find any elegant way of doing this in php with its 50 different sort functions. The result should be:\n\n```\narray('x','w','y','q','z','r')\n```\n\n\nI'm fine with using a typical sort at O(nlogn) for this if it's a much shorter solution. I really want to avoid a ton of messy code for the merge/sort function.\n    ", "Answer": "\r\nYou can just union the arrays and then sort the result by ```\nb```\n:\n\n```\n$union = $arr1 + $arr2;\nuasort($union, function($a, $b){\n    return $a['b'] - $b['b'];\n});\n$result = array_keys($union);\n```\n\n\nLive Demo\n\nIf you still want a ```\nO(n)```\n solution this should do it and it's not overly complex, however note that it may be slower unless you are dealing with very large arrays:\n\n```\n$result = array(); \n$keys = array_keys($arr2);\n$i = 0;\nforeach($arr1 as $key => $value){\n    while($arr2[$keys[$i]]['b'] < $value['b'])\n        $result[] = $keys[$i++];\n    $result[] = $key;\n}\n$result = array_merge($result, array_slice($keys, $i));\n```\n\n\nLive Demo\n\nI have no idea which one of these solutions will achieve the desired result faster in your case. The first one seems more readable though.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort most efficient implementation\r\n                \r\nSo I wonder what is the most efficient implementation of a merge sort in Java (In case its efficiency in terms of time can change depending on the language). This question may be trivial but my ultimate goal is to learn from more experienced programmers. Here are 2 examples I made:\n\n```\n//version I made.\npublic static double[] mergeSort(double[] arreglo) {\n    if (arreglo.length > 1) {\n        int d = (arreglo.length / 2);\n        double[] arreglo1 = Arrays.copyOfRange(arreglo, 0, d),\n                arreglo2 = Arrays.copyOfRange(arreglo, d, arreglo.length);\n        arreglo1 = mergeSort(arreglo1);\n        arreglo2 = mergeSort(arreglo2);\n        return merge(arreglo1, arreglo2);\n    } else {\n        return arreglo;\n    }\n}\n\npublic static double[] merge(double[] arreglo1, double[] arreglo2) {\n    double[] convi = new double[arreglo1.length + arreglo2.length];\n    for (int i = 0, m1 = 0, m2 = 0; i < convi.length; i++) {\n        if (arreglo1.length > m1 && arreglo2.length > m2) {\n            if (arreglo1[m1] <= arreglo2[m2])\n                convi[i] = arreglo1[m1++];\n            else {\n                convi[i] = arreglo2[m2++];\n            }\n        } else {\n            convi[i] = (arreglo1.length == m1) ? arreglo2[m2++] : arreglo1[m1++];\n        }\n    }\n    return convi;\n}\n\n//Taken out of Cormens book.\npublic static void mergeSort(int[] arreglo, int i, int f) {\n    if (f > i) {\n        int d = ((i + f) / 2);\n        mergeSort(arreglo, i, d);\n        mergeSort(arreglo, d + 1, f);\n        merge(arreglo, i, d, f);\n    }\n}\n\n\npublic static void merge(int[] arreglo, int i, int m, int f) {\n    int n1 = (m - i) + 1;\n    int n2 = (f - m);\n    int[] mitad1 = new int[n1 + 1];\n    int[] mitad2 = new int[n2 + 1];\n    for (int v = 0; v < n1; v++) {\n        mitad1[v] = arreglo[i + v];\n    }\n    for (int p = 0; p < n2; p++) {\n        mitad2[p] = arreglo[p + m + 1];\n    }\n    mitad1[n1] = Integer.MAX_VALUE;\n    mitad2[n2] = Integer.MAX_VALUE;\n    for (int r = i, m1 = 0, m2 = 0; r <= f; r++) {\n        if (mitad1[m1] <= mitad2[m2]) {\n            arreglo[r] = mitad1[m1];\n            m1++;\n        } else {\n            arreglo[r] = mitad2[m2];\n            m2++;\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nThe following program is translated from C++ example given in Robert Sedgewick's Algorithms in C++, Parts 1-4 \n\nIt introduces one type of improvement. It does a single copy of the whole sorting array into a an auxiliary array that is further dealt with. Next, the recursion splitting is done on the auxiliary array by alternating between the auxiliary array and original array so that the extra copying operation of the merged arrays doesn’t happen. Basically, the algorithm switches the role of the input and auxiliary array in each recursive call. For example, conceptually:\n\nRegular Mergesort:\n\n--merge\n\n```\n(((8) (5))((2) (3)))(((1) (7))((4) (6)))\n\n(( 5 8 )( 2 3 ))(( 1 7 )( 4 6 ))\n\n-- copy back and ignore previous (UNNECESSARY)\n\n(( 5 8 )( 2 3 ))(( 1 7 )( 4 6 ))\n```\n\n\n– – – – – – – –\n\nThis program:\n\n--merge\n\n```\n(((8) (5))((2) (3)))(((1) (7))((4) (6)))\n\n(( 5 8 )( 2 3 ))(( 1 7 )( 4 6 ))\n```\n\n\n--merge backwards\n\n```\n( 2 3 5 8 )( 1 4 6 7 )\n\n(( 5 8 )( 2 3 ))(( 1 7 )( 4 6 ))    \n```\n\n\nAlso, after splitting the array into halves gives small enough arrays, the algorithm uses ```\ninsertion sort```\n since it performs better on small data sets than ```\nmerge sort```\n. The threshold for when exactly to use ```\ninsertion sort```\n can be determined with trial-and-error.\n\nThe code:\n\n```\nstatic int M = 10;\n\n//insertion sort to be used once the mergesort partitions become small enough\nstatic void insertionsort(int[] a, int l, int r) {\n    int i, j, temp;\n    for (i = 1; i < r + 1; i++) {\n        temp = a[i];\n        j = i;\n        while ((j > 0) && a[j - 1] > temp) \n        {\n            a[j] = a[j - 1];\n            j = j - 1;\n        }\n        a[j] = temp;\n    }\n}\n\n//standard merging two sorted half arrays into single sorted array\nstatic void merge(int[] merged_a, int start_a, int[] half_a1, int start_a1, int size_a1, \n                         int[] half_a2, int start_a2, int size_a2) {\n    int i, j, k;\n    int total_s = size_a1 + size_a2;\n    for (i = start_a1, j = start_a2, k = start_a; k < (total_s); k++) {\n        // if reached end of first half array, run through the loop \n        // filling in only from the second half array\n        if (i == size_a1) {\n            merged_a[k] = half_a2[j++];\n            continue;\n        }\n        // if reached end of second half array, run through the loop \n        // filling in only from the first half array\n        if (j == size_a2) {\n            merged_a[k] = half_a1[i++];\n            continue;\n        }\n        // merged array is filled with the smaller element of the two \n        // arrays, in order\n        merged_a[k] = half_a1[i] < half_a2[j] ?\n                      half_a1[i++] : half_a2[j++];\n    }\n}\n\n//merge sort data during merging without the additional copying back to array\n//all data movement is done during the course of the merges\nstatic void mergesortNoCopy(int[] a, int[] b, int l, int r) {\n    if (r - l <= M) {\n        insertionsort(a + l, l, r - l);\n        return;\n    }\n    int m = (l + r) / 2;\n    //switch arrays to msort b thus recursively writing results to b\n    mergesortNoCopy(b, a, l, m); //merge sort left\n    mergesortNoCopy(b, a, m + 1, r); //merge sort right\n    //merge partitions of b into a\n    merge(a, l, b, l, m - l + 1, b, m + 1, r - m); //merge\n}\n\nstatic void mergesort(int[] a) {\n    int[] aux = Arrays.copyOf(a, a.length);\n    mergesortNoCopy(a, aux, 0, a.length - 1);\n}\n```\n\n\nSome other possible improvements:\n\nStop if already sorted.\n\nCheck if the largest item in first half ≤ smallest item in second half.\nHelps for partially-ordered arrays.\n\n```\n// after split, before merge\nif (a[mid] <= a[mid + 1]) return;\n```\n\n\nEDIT: here is a good document I found on different versions of Mergesort and improvements thereof. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort using inplace merging\r\n                \r\nA[]  ->  1 3 5 7 2 4 6 8      // \n\nlb=0,mid-1=3,mid+1=4,ub=7; \n\na=3,b=7,ab=7;\n\n1st iteration\n\na=3,b=6,ab=6;\n\n\n\n2nd iteration\n\nswap(A[ab],A[a])  // int t; t i'll using for temporary storage\n\n1 3 5 6 2 4 7 8 \n\nb=5,ab=5;\n sort(A,lb,mid-1);  // using bubble sort\n\n\n\n3rd iteration\n\nswap(A[ab],A[a])\n\n1 3 5 4  2 6 7 8  \n\nb=5,ab=4\n\nsort(A,lb,mid-1) // using bubble sort \n\n\n\nIs this correct approach for Merge sort using inplace merging. This is my first attempt about inplace merging.If it is not correct approach  someone can suggest me.\n    ", "Answer": "\r\nNot sure that you have Mergesort algorithm.\n\nUsing Mergesort at first phase you need to split you array into subarrays.\n\n```\nA = [1, 3, 5, 7, 2, 4, 6, 8]\n\nA1 = [1, 3, 5, 7], A2 = [2, 4, 6, 8]\n\nA11 = [1,3], A12 = [5,7], A21 = [2,4], A22 = [6,8]\n... // till you have an arrays looks like this:\nA1 = [1], A2 = [3], A3 = [5], A4 = [7], A5 = [2], A6 = [4], A7 = [6], A8 = [8]\n```\n\n\nThen you merging in reverse order, and compare only first elements in both arrays (put lowest element in new array).\n\n```\n[1,3], [5,7], [2,4], [6,8]\n  [1,3,5,7],   [2,4,6,8]\n     [1,2,3,4,5,6,7,8]\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "simple merge sort in python\r\n                \r\niam learning python so sorry for not coding the pythonic way\niam trying to make a merge sort but its not working\ni looked at the debugger it seems the problem it doesnt do line ```\n arr1[i] = arr[s+i]```\n and jumb back to the mergeSort function idont know why\n```\ndef mergeSort(arr,s,e):\n    if s >= e: return\n    mid = s + (e-s)//2; \n    mergeSort(arr,s,mid)\n    mergeSort(arr,mid+1,e)\n    merge(arr,s,mid,e)\n\n\ndef merge(arr,s,mid,e):\n        arr1 = []\n        arr2 = [] \n        n = mid -s + 1\n        m = e - mid\n        for i in range (0,n):\n            arr1[i] = arr[s+i]\n        for i in range (0,m):\n            arr2[i] = arr[mid + i + 1]\n                \n        i = 0\n        j = 0\n        k = s\n        while i <  len(arr1) and  j < len(arr2):\n            if(arr1[i] < arr2[j]):\n                arr[k] = arr1[i]\n                i+=1\n            else:\n                arr[k] = arr2[j]\n                j+=1 \n            k+=1\n        while(i < len(arr1)):\n            arr[k] = arr1[i]\n            i+=1\n            k+=1\n        while(j < len(arr2)):\n            arr[k] = arr2[j]\n            j+=1\n            k+=1\n\narr = [1,5,0,3,-15,99,1500,-1500,66,120]\nmergeSort(arr,0,len(arr))\nprint(arr)\n```\n\nThe error I get is:\n```\nline 41, in merge arr1[i] = arr[s+i]\nIndexError: list assignment index out of range\n```\n\n    ", "Answer": "\r\nwith ```\narr1[i] = arr[s+i]```\n you're trying to update the value on index i, but that value may or may not exist. If you try to update that doesn't exist, you get ```\nIndexError: list assignment index out of range```\n\nYou can work around it by wrapping it in a try-catch block:\n```\n            try:\n              arr1[i] = arr[s+i]\n            except:\n              arr1.append(arr[s+i])\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge Sort Using Vectors c++\r\n                \r\nI'm trying to sort a text file using the merge sort method using vectors instead of arrays. The code builds but when I run it I get a an out bounds error on one of my vectors.\n\nSpecifically : \n\n```\nfor (int k = start; k < end; k++)\n{\n    if (L.at(x) <= R.at(y))\n    {\n        v.at(k) = L.at(x);          // out of bounds\n        x++;\n    }\n    else\n    {\n        v.at(k) = R.at(y);          // out of bounds\n        y++;\n    }\n\n} \n```\n\n\nI resize vector 'v' yet int K still increments to high. i.e. the size of v will be 10, yet k will also equal 10. I've tried changing some values, but every time it compiles the function ends up not sorting. I've looked up various methods of merge sort and each time I keep getting the same out of bounds error.\n\nEDIT: I made a change to my loops, now it goes through my functions. But they return a blank vector. The entire 'v' vector is whitespace when I print it.\n\nFull Code:\n\n```\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std\n\nvector<string> readFile(string fileName) {\n    /* reads a textfile into vector. Works dandy. */ \n}\n\nvector<string> merge(vector<string>& v, int start, int mid, int end) {\n    int n1 = mid - start + 1;\n    int n2 = end - mid;\n\n    vector<string> L;\n    vector<string> R;\n\n    L.resize(n1 + 1); // size left vector\n    R.resize(n2 + 1); // size right vector\n\n    for (int i = 1; i < n1; i++) {\n        L.at(i) = v.at(start + i - 1); // populate left vector\n    }\n    for (int j = 1; j < n2; j++) {\n        R.at(j) = v.at(mid + j);       // populate right vector\n    }\n\n    int x = 1;\n    int y = 1;\n\nfor (int k = start; k < end; k++)\n{\n    if (L.at(x) <= R.at(y))\n    {\n        v.at(k) = L.at(x);          // merge left vector into v\n            if (x < L.size() - 1)   // prevents x from increasing past bounds of L vector\n            x++;\n    }\n    else\n    {\n        v.at(k) = R.at(y);          // merge right vector into v\n        y++;\n    }\n    return v;\n}\n\nvector<string> mergeSort(vector<string>& v, int start, int end) {\n    int middle;\n    if (start < end)                    // base case\n    {\n        middle = (start + end) / 2;     // find middle\n        mergeSort(v, start, middle);    // divide vectors\n        mergeSort(v, middle + 1, end);\n        merge(v, start, middle, end);   // merge sorted vectors\n    }\n    return v;\n}\n\nint main() {\n    vector<string> vectorReadIn;\n    vector<string> sortedVector;\n    int x = 0;\n\n    string fileName = \"C:/Users/User/Downloads/Algorithims/Perm Words/perm15k.txt\";\n\n    vectorReadIn = readFile(fileName);    // reads file into vector\n\n    sortedVector = mergeSort(vectorReadIn, 1, vectorReadIn.size());  // calls mergesort\n    cout << \"Sorted file:\" << endl;\n    while (x < 8) {\n        cout << sortedVector.at(x);\n        x++; \n    }\n}\n```\n\n    ", "Answer": "\r\nAll the indexing that you're doing on your ```\nvectors```\n is 1-based.  C++ vectors (and arrays) use 0-based indexing.  At the very least, ```\nx```\n and ```\ny```\n should be initialized to 0, the indexing in the ```\ni```\n and ```\nj```\n population loops should start at 0 (with appropriate changes to the end condition and usage within the loop), and the second parameter in the call to ```\nmergeSort```\n in ```\nmain```\n should be 0, not 1.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "various errors in c++ linked list merge sort\r\n                \r\nHi I have an error in my linked list program and it is suppose to do merge sort on linked list.\n\nI did declared it but it still giving me the error.\n\np.s. i didn't finish the merge sort function, but merge is suppose to compile already.\n\nplease help!!\n\nCode: \n\n```\n#ifndef _NODE\n#define _NODE \n\ntemplate<typename ItemType>\n\nclass Node {\n    private:\n        ItemType item; // A data item\n        Node<ItemType>* next; // Pointer to next node\n    public:\n        Node();\n        Node(const ItemType& anItem);\n        Node(const ItemType& anItem, Node<ItemType>* nextNodePtr);\n        void setItem(const ItemType& anItem);\n        void setNext(Node<ItemType>* nextNodePtr);\n        void mergeSort(Node<ItemType>*& head);\n        Node<ItemType>* merge(Node<ItemType>*& head1, Node<ItemType>*& head2);\n        ItemType getItem() const;\n        Node<ItemType>* getNext() const;\n}; // end Node \n\n#endif\n\ntemplate<typename ItemType>\nNode<ItemType>::Node() {\n\n    next(nullptr)\n\n} // end default constructor \n\ntemplate<typename ItemType>\nNode<ItemType>::Node(const ItemType& anItem) {\n\n    item(anItem);\n    next(nullptr);\n\n} // end constructor \n\ntemplate<typename ItemType>\nNode<ItemType>::Node(const ItemType& anItem, Node<ItemType>* nextNodePtr) {\n\n    item(anItem);\n    next(nextNodePtr);\n\n} // end constructor \n\ntemplate<typename ItemType>\nvoid Node<ItemType>::setItem(const ItemType& anItem) {\n\n    item = anItem;\n\n} // end setItem \n\ntemplate<typename ItemType>\nvoid Node<ItemType>::setNext(Node<ItemType>* nextNodePtr) {\n\n    next = nextNodePtr;\n\n} // end setNext \n\ntemplate<typename ItemType>\nItemType Node<ItemType>::getItem() const {\n\n    return item;\n\n} // end getItem \n\ntemplate<typename ItemType>\n\nNode<ItemType>* Node<ItemType>::getNext() const {\n\n    return next;\n\n} // end getNext\n\ntemplate<typename ItemType>\nvoid Node<ItemType>::mergeSort(Node<ItemType>*& head) {\n\n    Node<ItemType>*countptr = head;\n    int length = 0;\n\n    while (countptr->getNext() != nullptr) {\n        length++;\n        countptr = countptr->getNext();\n    }\n\n    //if only one or non in list then return list\n    if (length <= 1)\n        return head;\n\n    //int half = length / 2;\n\n\n\n\n\n}\n\ntemplate<typename ItemType>\nItemType Node<ItemType>::merge(Node<ItemType>*& head1, Node<ItemType>*& head2) {\n\n    Node<ItemType>*head = nullptr;\n    Node<ItemType>*cur = nullptr;\n\n    //set the first element\n    if (head1->getItem() >= head2->getItem()) {\n        head = head2;\n        head2 = head2->getNext();\n    }\n    else {\n        head = head1;\n        head1 = head1->getNext();\n    }\n\n    cur = head;\n\n    while (true) {\n        if (head1->getItem() == NULL && head2->getItem() != NULL) {\n            cur->setNext(head2);\n            cur = cur->getNext();\n            head2 = head2->getNext();\n        }\n        else if (head2->getItem() == NULL && head1->getItem() != NULL) {\n            cur->setNext(head1);\n            cur = cur->getNext();\n            head1 = head1->getNext();\n        }\n        else if (head1->getItem() >= head2->getItem()) {\n            cur->setNext(head2);\n            cur = cur->getNext();\n            head2 = head2->getNext();\n        }\n        else if (head1->getItem() <= head2->getItem()) {\n            cur->setNext(head1);\n            cur = cur->getNext();\n            head1 = head1->getNext();\n        }\n        else {\n            break;\n        }\n    }\n\n\n    return head;\n}\n```\n\n\nand here is my error:\n\n```\nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\n\n\\xlocale(341): war\nning C4530: C++ exception handler used, but unwind semantics are not enabled. Sp\necify /EHsc\nc:\\users\\mykev\\desktop\\Node.h(145): error C2244: 'Node<ItemType>::merge': unable\n to match function definition to an existing declaration\nc:\\users\\mykev\\desktop\\Node.h(100): note: see declaration of 'Node<ItemType>::me\nrge'\nc:\\users\\mykev\\desktop\\Node.h(145): note: definition\nc:\\users\\mykev\\desktop\\Node.h(145): note: 'ItemType Node<ItemType>::merge(Node<I\ntemType> *&,Node<ItemType> *&)'\nc:\\users\\mykev\\desktop\\Node.h(145): note: existing declarations\nc:\\users\\mykev\\desktop\\Node.h(145): note: 'Node<ItemType> *Node<ItemType>::merge\n(Node<ItemType> *&,Node<ItemType> *&)'\n```\n\n    ", "Answer": "\r\nYou've (at least) two issues in your code\n\n1) your default constructor is missing a semi-colon around line 29\n\n2) your prototype for merge (around line 17) doesn't look like your implementation (around line 100). You could change the line 100 to look more like:\n\n```\ntemplate<typename ItemType>\nNode<ItemType>* Node<ItemType>::merge(Node<ItemType>*& head1, Node<ItemType>*& head2) {\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Why my merge sort is not working?\r\n                \r\nI tried to use merge sort. however, it keeps popping me ArrayIndexOutOfBoundsException. Can anyone let me know why?\n\nI totally confused. Did i miss something?\n\n```\npublic class InversionSearch {\n    public int[] mergeSort(int[] array){\n        if (array.length == 1) {\n            return array;\n        }\n        int[] first = new int[array.length/2];\n        int[] second = new int[array.length - first.length];\n\n        System.arraycopy(array, 0, first, 0, first.length);\n        System.arraycopy(array, first.length, second, 0, second.length);\n\n        int[] result = merge(mergeSort(first), mergeSort(second));\n        return result;\n    }\n\n    public int[] merge(int[] first, int[] second) {\n        int i = 0;\n        int j = 0;\n        int[] temp = new int[first.length + second.length];\n        for (int k = 0; k < temp.length; k++) {\n            if (first[i] < second[j]) {\n                temp[k] = first[i];\n                i++;\n            }else {\n                temp[k] = second[j];\n                j++;\n            }\n        }\n        return temp;\n    }\n\n    public static void main(String[] args) {\n        int[] input = {1, 3, 2, 4, 5, 6};\n        InversionSearch iSearch = new InversionSearch();\n        iSearch.mergeSort(input);\n    }\n\n}\n```\n\n    ", "Answer": "\r\nyour ```\nfor```\n loop is wrong\n\n```\nfor (int k = 0; k < temp.length; k++) {\n    if (first[i] < second[j]) {\n        temp[k] = first[i];\n        i++;\n    }else {\n        temp[k] = second[j];\n        j++;\n    }\n }\n```\n\n\nYou are not checking whether ```\ni```\n and ```\nj```\n are the correct index or not.\n\nFor something like \n\n```\nfirst = { 1, 2, 3, 4 } second = { 5, 6, 7 }\n```\n\n\nyour for loop will go for k times and k is 7, after 5 iterations ```\ni```\n  value will be 5 and you will get ```\nArrayIndexOutofBoundException```\n.\n\nproper way to write this is :\n\n```\nint k=0;\nwhile(i < first.length && j< second.length){\n    if (first[i] < second[j]) {\n        temp[k] = first[i];\n        i++;\n    }else {\n        temp[k] = second[j];\n        j++;\n    }\n    k++;\n}\n\n//for corner cases where some elements are left out\nwhile(i < first.length) {\n    temp[k] = first[i];\n    k++;\n    i++;\n}\nwhile(j < second.length) {\n    temp[k] = second[j];\n    k++;\n    j++;\n}\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "How to sort K sorted arrays, with MERGE SORT\r\n                \r\nI know that this question has been asked, and there is a very nice elegant solution using a min heap.\n\nMY question is how would one do this using the merge function of merge sort.\n\nYou already have an array of sorted arrays.  So you should be able to merge all of them into one array in O(nlog K) time, correct?\n\nI just can't figure out how to do this!  \n\nSay I have\n\n[ [5,6], [3,4], [1,2], [0] ]\n\nStep 1: [ [3,4,5,6], [0,1,2] ]\n\nStep2:  [ [0,1,2,3,4,5,6] ]\n\nIs there a simple way to do this?  Is O(nlog K) theoretically achievable with mergesort?\n    ", "Answer": "\r\nAs others have said, using the min heap to hold the next items is the optimal way. It's called an N-way merge. Its complexity is O(n log k).\n\nYou can use a 2-way merge algorithm to sort k arrays. Perhaps the easiest way is to modify the standard merge sort so that it uses non-constant partition sizes. For example, imagine that you have 4 arrays with lengths 10, 8, 12, and 33. Each array is sorted. If you concatenated the arrays into one, you would have these partitions (the numbers are indexes into the array, not values):\n\n```\n[0-9][10-17][18-29][30-62]\n```\n\n\nThe first pass of your merge sort would have starting indexes of 0 and 10. You would merge that into a new array, just as you would with the standard merge sort. The next pass would start at positions 18 and 30 in the second array. When you're done with the second pass, your output array contains:\n\n```\n[0-17][18-62]\n```\n\n\nNow your partitions start at 0 and 18. You merge those two into a single array and you're done.\n\nThe only real difference is that rather than starting with a partition size of 2 and doubling, you have non-constant partition sizes. As you make each pass, the new partition size is the sum of the sizes of the two partitions you used in the previous pass. This really is just a slight modification of the standard merge sort.\n\nIt will take log(k) passes to do the sort, and at each pass you look at all n items. The algorithm is O(n log k), but with a much higher constant than the N-way merge.\n\nFor implementation, build an array of integers that contains the starting indexes of each of your sub arrays. So in the example above you would have:\n\n```\nint[] partitions = [0, 10, 18, 30];\nint numPartitions = 4;\n```\n\n\nNow you do your standard merge sort. But you select your partitions from the ```\npartitions```\n array. So your merge would start with:\n\n```\nmerge (inputArray, outputArray, part1Index, part2Index, outputStart)\n{\n    part1Start = partitions[part1Index];\n    part2Start = partitions[part2Index];\n\n    part1Length = part2Start - part1Start;\n    part2Length = partitions[part2Index-1] - part2Start;\n\n    // now merge part1 and part2 into the output array,\n    // starting at outputStart\n}\n```\n\n\nAnd your main loop would look something like:\n\n```\nwhile (numPartitions > 1)\n{\n    for (int p = 0; p < numPartitions; p += 2)\n    {\n        outputStart = partitions[p];\n        merge(inputArray, outputArray, p, p+1, outputStart);\n        // update partitions table\n        partitions[p/2] = partitions[p] + partitions[p+1];\n    }\n    numPartitions /= 2;\n}\n```\n\n\nThat's the basic idea. You'll have to do some work to handle the dangling partition when the number is odd, but in general that's how it's done.\n\nYou can also do it by maintaining an array of arrays, and merging each two arrays into a new array, adding that to an output array of arrays. Lather, rinse, repeat. \n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Using ExecutorService with a multithreaded version of Merge Sort\r\n                \r\nI am working on a homework problem where I have to create a Multithreaded version of Merge Sort.   I was able to implement it, but I am not able to stop the creation of threads.   I looked into using an ExecutorService to limit the creation of threads but I cannot figure out how to implement it within my current code.\n\nHere is my current Multithreaded Merge Sort.  We are required to implement a specific strategy pattern so that is where my ```\nsort()```\n method comes from.\n\n```\n@Override\npublic int[] sort(int[] list) {\n    int array_size = list.length;\n    list = msort(list, 0, array_size-1);\n    return list;\n}\n\nint[] msort(int numbers[], int left, int right) {\n    final int mid;\n    final int leftRef = left;\n    final int rightRef = right;\n    final int array[] = numbers;\n    if (left<right) {\n        mid = (right + left) / 2;\n        //new thread\n        Runnable r1 = new Runnable(){\n            public void run(){\n                msort(array, leftRef, mid);     \n            }\n        };\n        Thread t1 = new Thread(r1);\n        t1.start();\n\n        //new thread\n        Runnable r2 = new Runnable(){\n            public void run(){\n                msort(array, mid+1, rightRef);\n            }\n        };\n        Thread t2 = new Thread(r2);\n        t2.start();\n        //join threads back together\n        try {\n            t1.join();\n            t2.join();\n\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        merge(numbers, leftRef, mid, mid+1, rightRef);\n    }\n    return numbers;\n}\n\nvoid merge(int numbers[], int startA, int endA, int startB, int endB) {\n    int finalStart = startA;\n    int finalEnd = endB;\n    int indexC = 0;\n    int[] listC = new int[numbers.length];\n\n    while(startA <= endA && startB <= endB){\n        if(numbers[startA] < numbers[startB]){\n            listC[indexC] = numbers[startA];\n            startA = startA+1;\n        }\n        else{\n            listC[indexC] = numbers[startB];\n            startB = startB +1;\n        }\n        indexC++;\n    }\n\n    if(startA <= endA){\n        for(int i = startA; i < endA; i++){\n            listC[indexC]= numbers[i];\n            indexC++;\n        }\n    }\n\n    indexC = 0;\n    for(int i = finalStart; i <= finalEnd; i++){\n        numbers[i]=listC[indexC];\n        indexC++;\n    }\n}\n```\n\n\nAny pointers would be gratefully received.  \n    ", "Answer": "\r\nFollowing @mcdowella's comment, I also think that the fork/join framework is your best bet if you want to limit the number of threads that run in parallel.\n\nI know that this won't give you any help on your homework, because you are probably not allowed to use the fork/join framework in Java7. However it is about to learn something, isn't it?;)\n\nAs I commented, I think your merge method is wrong. I can't pinpoint the failure, but I have rewritten it. I strongly suggest you to write a testcase with all the edge cases that can happen during that merge method and if you verified it works, plant it back to your multithreaded code.\n\n@lbalazscs also gave you the hint that the fork/join sort is mentioned in the javadocs, however I had nothing else to do- so I will show you the solution if you'd implemented it with Java7.\n\n```\npublic class MultithreadedMergeSort extends RecursiveAction {\n\n  private final int[] array;\n  private final int begin;\n  private final int end;\n\n  public MultithreadedMergeSort(int[] array, int begin, int end) {\n    this.array = array;\n    this.begin = begin;\n    this.end = end;\n  }\n\n  @Override\n  protected void compute() {\n    if (end - begin < 2) {\n      // swap if we only have two elements\n      if (array[begin] > array[end]) {\n        int tmp = array[end];\n        array[end] = array[begin];\n        array[begin] = tmp;\n      }\n    } else {\n      // overflow safe method to calculate the mid\n      int mid = (begin + end) >>> 1;\n      // invoke recursive sorting action\n      invokeAll(new MultithreadedMergeSort(array, begin, mid),\n          new MultithreadedMergeSort(array, mid + 1, end));\n      // merge both sides\n      merge(array, begin, mid, end);\n    }\n  }\n\n  void merge(int[] numbers, int startA, int startB, int endB) {\n    int[] toReturn = new int[endB - startA + 1];\n    int i = 0, k = startA, j = startB + 1;\n    while (i < toReturn.length) {\n      if (numbers[k] < numbers[j]) {\n        toReturn[i] = numbers[k];\n        k++;\n      } else {\n        toReturn[i] = numbers[j];\n        j++;\n      }\n      i++;\n      // if we hit the limit of an array, copy the rest\n      if (j > endB) {\n        System.arraycopy(numbers, k, toReturn, i, startB - k + 1);\n        break;\n      }\n      if (k > startB) {\n        System.arraycopy(numbers, j, toReturn, i, endB - j + 1);\n        break;\n      }\n    }\n    System.arraycopy(toReturn, 0, numbers, startA, toReturn.length);\n  }\n\n  public static void main(String[] args) {\n    int[] toSort = { 55, 1, 12, 2, 25, 55, 56, 77 };\n    ForkJoinPool pool = new ForkJoinPool();\n    pool.invoke(new MultithreadedMergeSort(toSort, 0, toSort.length - 1));\n    System.out.println(Arrays.toString(toSort));\n\n  }\n```\n\n\nNote that the construction of your threadpool limits the number of active parallel threads to the number of cores of your processor.\n\n```\nForkJoinPool pool = new ForkJoinPool();\n```\n\n\nAccording to it's javadoc:\n\n\n  Creates a ForkJoinPool with parallelism equal to\n  java.lang.Runtime.availableProcessors, using the default thread\n  factory, no UncaughtExceptionHandler, and non-async LIFO processing\n  mode.\n\n\nAlso notice how my merge method differs from yours, because I think that is your main problem. At least your sorting works if I replace your merge method with mine.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Time Complexity Of Merge Sort In Special Condition\r\n                \r\nWhat would be the time complexity If I will apply merge sort on an already sorted array?\n    ", "Answer": "\r\nUsual merge sort still uses ```\nO(nlogn)```\n for sorted data.\n\nBut there is natural merge sort variant that provides linear complexity for sorted arrays.  \n\nNote that natural merge sort also gives ```\nO(nlogn)```\n for arbitrary data, compared with isertion sort, that behaves well for sorted data but becomes quadratic in the worst case\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "Merge sort not showing correct output\r\n                \r\nI have implemented each line of merge sort algorithm-wise and can't find error.\nal and ar are left and right sub arrays. Arrays are passed along with size.\n\n```\n#include<stdio.h>\n#include<conio.h>\nvoid mergesort(int a[] ,int);\nvoid merge(int al[],int,int ar[],int,int a[]);\nint main()\n{\n    int i,n;\n    printf(\"Enter the no of elements to be sorted\\n\");\n    scanf(\"%d\",&n);\n    int a[n];\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }   \n    mergesort(a,n);\n    printf(\"\\nThe elements after sorting are:\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d \",a[i]);\n    }\n    getch();\n    return 0;\n}\nvoid mergesort(int a[],int size)\n{\n    int i,n=size,mid;\n    if(n<2)\n    return;\n    mid=n/2;\n    int left[mid],right[n-mid];\n    for(i=0;i<mid;i++)\n    left[i]=a[i];\n    for(i=mid;i<n;i++)\n    right[i]=a[i];\n    mergesort(left,mid);\n    mergesort(right,n-mid);\n    merge(left,mid,right,n-mid,a);\n}\nvoid merge(int al[],int sl,int ar[],int sr,int a[])\n{\n    int i=0,j=0,k=0;\n    while(i<sl && j<sr)\n    {\n        if(al[i]<=ar[j])\n        {\n            a[k]=al[i];\n            i++;\n        }\n        else\n        {\n        a[k]=ar[j];\n        j++;\n        }\n        k++;\n    }\n    while(i<sl)\n    {\n            a[k]=al[i];\n            i++;\n            k++;\n    }\n    while(j<sr)\n    {\n            a[k]=ar[j];\n            j++;\n            k++;\n    }\n}\n```\n\n\ninput: \n\n```\nno of elements:4\n5 6 3 1 \n```\n\n\noutput: \n\n```\n5 16 16 16\n```\n\n    ", "Answer": "\r\nLook at this part of your code:\n\n```\nint left[mid],right[n-mid];\nfor(i=0;i<mid;i++)\nleft[i]=a[i];\nfor(i=mid;i<n;i++)\nright[i]=a[i];\n```\n\n\nYou are accessing the ```\nright```\n array with indexes beyond the array bounds. That should be something like this instead:\n\n```\nright[i - mid]=a[i];\n```\n\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
{"Question": "ConcurrentModificationException in merge sort code\r\n                \r\nI'm a beginner to Java and coding in general. I'm trying to write a merge sort code for an ArrayList of a class I made called Member, but the code runs into a ConcurrentModificationException. isLargerThan is a custom method that I made to compare Members. What am I doing wrong?\n\n```\n  public static void mergeSort(List<Member> list) {\n    List<Member> another1 = new ArrayList<Member>();\n    another1 = list.subList(0, list.size() / 2);\n    List<Member> another2 = new ArrayList<Member>();\n    another2 = list.subList(list.size() / 2, list.size());\n    if (another1.size() > 1) {\n      mergeSort(another1);\n    } if (another2.size() > 1) {\n      mergeSort(another2);\n    }\n    merge(list, another1, another2);\n  }\n\n  public static void merge(List<Member> goal, List<Member> list1, List<Member> list2) {\n    if (isLargerThan(list2.get(0), list1.get(0))) {\n      goal = list1;\n      goal.addAll(list2);\n    } else {\n      goal = list2;\n      goal.addAll(list1);\n    }\n  }\n```\n\n\nEDIT:\n\nI have since changed the merge method to this:\n\n```\n  public static void merge(List<Member> goal, List<Member> list1, List<Member> list2) {\n    if (isLargerThan(list2.get(0), list1.get(0))) {\n      goal.clear();\n      goal.addAll(list1);\n      goal.addAll(list2);\n    } else {\n      goal.clear();\n      goal.addAll(list2);\n      goal.addAll(list1);\n    }\n  }\n```\n\n\nThe error now appears on the first ```\ngoal.addAll(list1);```\n line, where before it appeared on the line ```\n} if (another2.size() > 1) {```\n.\n    ", "Answer": "\r\nThe sublist is not an actual list, instead, it just store the reference of current list into it with start and end value.\n\nDue to this, the ```\ngoal```\n, ```\nlist1```\n, ```\nlist2```\n of ```\nmerge```\n functional internally refers to same list.\n\nAs you are performing ```\ngoal.addAll(list2);```\n and ```\ngoal.addAll(list1);```\n, you are trying to perform read and write operation on same list causing ```\nConcurrentModificationException```\n.\n\nTo fix this issue, you can copy one list into another manually instead of using sublist.\nOr create a separate list to merge the result.\n    ", "Knowledge_point": "Merge Sort", "Tag": "算法分析"}
