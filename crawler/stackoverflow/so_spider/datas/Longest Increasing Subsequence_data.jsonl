{"Question": "Longest increasing subsequence\r\n                \r\nGiven an input sequence, what is the best way to find the longest (not necessarily continuous) increasing subsequence\n```\n[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]  # input\n\n[1, 9, 13, 15]  # an example of an increasing subsequence (not the longest)\n\n[0, 2, 6, 9, 13, 15]  # longest increasing subsequence (not a unique answer)\n[0, 2, 6, 9, 11, 15]  # another possible solution\n```\n\nI'm looking for the best algorithm. If there is code, Python would be nice, but anything is alright.\n    ", "Answer": "\r\nI just stumbled in this problem, and came up with this Python 3 implementation:\n\n\n\n```\ndef subsequence(seq):\n    if not seq:\n        return seq\n\n    M = [None] * len(seq)    # offset by 1 (j -> j-1)\n    P = [None] * len(seq)\n\n    # Since we have at least one element in our list, we can start by \n    # knowing that the there's at least an increasing subsequence of length one:\n    # the first element.\n    L = 1\n    M[0] = 0\n\n    # Looping over the sequence starting from the second element\n    for i in range(1, len(seq)):\n        # Binary search: we want the largest j <= L\n        #  such that seq[M[j]] < seq[i] (default j = 0),\n        #  hence we want the lower bound at the end of the search process.\n        lower = 0\n        upper = L\n\n        # Since the binary search will not look at the upper bound value,\n        # we'll have to check that manually\n        if seq[M[upper-1]] < seq[i]:\n            j = upper\n\n        else:\n            # actual binary search loop\n            while upper - lower > 1:\n                mid = (upper + lower) // 2\n                if seq[M[mid-1]] < seq[i]:\n                    lower = mid\n                else:\n                    upper = mid\n\n            j = lower    # this will also set the default value to 0\n\n        P[i] = M[j-1]\n\n        if j == L or seq[i] < seq[M[j]]:\n            M[j] = i\n            L = max(L, j+1)\n\n    # Building the result: [seq[M[L-1]], seq[P[M[L-1]]], seq[P[P[M[L-1]]]], ...]\n    result = []\n    pos = M[L-1]\n    for _ in range(L):\n        result.append(seq[pos])\n        pos = P[pos]\n\n    return result[::-1]    # reversing\n```\n\n\nSince it took me some time to understand how the algorithm works I was a little verbose with comments, and I'll also add a quick explanation:\n\n\n```\nseq```\n is the input sequence.\n```\nL```\n is a number: it gets updated while looping over the sequence and it marks the length of longest incresing subsequence found up to that moment.\n```\nM```\n is a list. ```\nM[j-1]```\n will point to an index of ```\nseq```\n that holds the smallest value that could be used (at the end) to build an increasing subsequence of length ```\nj```\n.\n```\nP```\n is a list. ```\nP[i]```\n will point to ```\nM[j]```\n, where ```\ni```\n is the index of ```\nseq```\n. In a few words, it tells which is the previous element of the subsequence. ```\nP```\n is used to build the result at the end.\n\n\nHow the algorithm works:\n\n\nHandle the special case of an empty sequence.\nStart with a subsequence of 1 element.\nLoop over the input sequence with index ```\ni```\n.\nWith a binary search find the ```\nj```\n that let ```\nseq[M[j]```\n be ```\n<```\n than ```\nseq[i]```\n.\nUpdate ```\nP```\n, ```\nM```\n and ```\nL```\n.\nTraceback the result and return it reversed.\n\n\nNote: The only differences with the wikipedia algorithm are the offset of 1 in the ```\nM```\n list, and that ```\nX```\n is here called ```\nseq```\n. I also test it with a slightly improved unit test version of the one showed in Eric Gustavson answer and it passed all tests.\n\n\n\nExample:\n\n```\nseq = [30, 10, 20, 50, 40, 80, 60]\n\n       0    1   2   3   4   5   6   <-- indexes\n```\n\n\nAt the end we'll have:\n\n```\nM = [1, 2, 4, 6, None, None, None]\nP = [None, None, 1, 2, 2, 4, 4]\nresult = [10, 20, 40, 60]\n```\n\n\nAs you'll see ```\nP```\n is pretty straightforward. We have to look at it from the end, so it tells that before ```\n60```\n there's ```\n40,```\nbefore ```\n80```\n there's ```\n40```\n, before ```\n40```\n there's ```\n20```\n, before ```\n50```\n there's ```\n20```\n and before ```\n20```\n there's ```\n10```\n, stop.\n\nThe complicated part is on ```\nM```\n. At the beginning ```\nM```\n was ```\n[0, None, None, ...]```\n since the last element of the subsequence of length 1 (hence position 0 in ```\nM```\n) was at the index 0: ```\n30```\n. \n\nAt this point we'll start looping on ```\nseq```\n and look at ```\n10```\n, since ```\n10```\n is ```\n<```\n than ```\n30```\n, ```\nM```\n will be updated:\n\n```\nif j == L or seq[i] < seq[M[j]]:\n    M[j] = i\n```\n\n\nSo now ```\nM```\n looks like: ```\n[1, None, None, ...]```\n. This is a good thing, because ```\n10```\n have more chanches to create a longer increasing subsequence. (The new 1 is the index of 10)\n\nNow it's the turn of ```\n20```\n. With ```\n10```\n and ```\n20```\n we have subsequence of length 2 (index 1 in ```\nM```\n), so ```\nM```\n will be: ```\n[1, 2, None, ...]```\n. (The new 2 is the index of 20)\n\nNow it's the turn of ```\n50```\n. ```\n50```\n will not be part of any subsequence so nothing changes.\n\nNow it's the turn of ```\n40```\n. With ```\n10```\n, ```\n20```\n and ```\n40```\n we have a sub of length 3 (index 2 in ```\nM```\n, so ```\nM```\n will be: ```\n[1, 2, 4, None, ...]```\n . (The new 4 is the index of 40)\n\nAnd so on...\n\nFor a complete walk through the code you can copy and paste it here :)\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence 2d\r\n                \r\nI have n sorted arrays of m integers in fixed order. I need to find a longest increasing subsequence such  that every element in the subsequence belongs into exactly one of the arrays. Can I do better than O(n2)? \n    ", "Answer": "\r\nIn line with @svs, this isn't possible to achieve in less than O(m * n). However, in practice, you can reduce the average worst time by terminating iteration through an array once you know you can't possibly find a longer subsequence within it.\n\nTrivial loop:\n\n```\nmaxList = []\nfor arr in arrays:\n    last = arr[0] - 1\n    tempList = []\n    for element in arr:\n        if element > last:\n            tempList.append(element)\n            if len(tempList) > len(maxList):\n                    maxList = tempList\n\n        else:\n            tempList = [element]\n        last = element\n\nreturn (maxList, iters)\n```\n\n\nWith redundant loop iterations ignored:\n\n```\nmaxList = []\nfor arr in arrays:\n    if len(maxList) == len(arr):\n        break\n\n    last = arr[0] - 1\n    tempList = []\n    for (index, element) in enumerate(arr):\n        if element > last:\n            tempList.append(element)\n            if len(tempList) > len(maxList):\n                    maxList = tempList[:]\n        else:\n            tempList = [element]\n\n        # if continuing looking down the array could not result in a longer\n        # increasing sequence\n        if (len(tempList) + (len(arr) - (index + 1)) <= len(maxList)):\n            break\n\n        last = element\n\nreturn (maxList, iters)\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence with minimum sum\r\n                \r\nI know there is a longest increasing subsequence algorithm that runs in O(nlogn) (https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/), but what if there are multiple increasing subsequences of the same length and I want to take the one with the minimum sum? Is there a way to calculate this, in O(nlogn) as well? I have found one that does it, but in (n^2) (https://www.geeksforgeeks.org/maximize-sum-of-all-elements-which-are-not-a-part-of-the-longest-increasing-subsequence/).\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "*First* Longest Increasing Subsequence\r\n                \r\nThe longest increasing subsequence is the well known problem and I have a solution with the patience algorithm.\n\nProblem is, my solution gives me the \"Best longest increasing sequence\" instead of the First longest increasing sequence that appears.\n\nThe difference is that some of the members of the sequence are larger numbers in the first(but the sequence length is exactly the same).\n\nGetting the first sequence is turning out to be quite harder than expected, because having the best sequence doesn't easily translate into having the first sequence.\n\nI've thought of doing my algorithm then finding the first sequence of length N, but not sure how to.\n\nSo, how would you find the First longest increasing subsequence from a sequence of random integers?\n\nMy code snippet:\n\n```\n  public static void main (String[] args) throws java.lang.Exception {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int inputInt;\n        int[] intArr;\n\n        try {\n            String input = br.readLine().trim();\n            inputInt = Integer.parseInt(input);\n            String inputArr = br.readLine().trim();\n            intArr = Arrays.stream(inputArr.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        } catch (NumberFormatException e) {\n            System.out.println(\"Could not parse integers.\");\n            return;\n        }\n        if(inputInt != intArr.length) {\n            System.out.println(\"Invalid number of arguments.\");\n            return;\n        }\n\n        ArrayList<ArrayList<Integer>> sequences = new ArrayList<ArrayList<Integer>>();\n\n        int sequenceCount = 1;\n        sequences.add(new ArrayList<Integer>());\n        sequences.get(0).add(0);\n\n        for(int i = 1; i < intArr.length; i++) {\n            for(int j = 0; j < sequenceCount; j++) {\n\n                if(intArr[i] <= intArr[sequences.get(j).get(sequences.get(j).size() - 1)]) {\n                    sequences.get(j).remove(sequences.get(j).size() - 1);\n                    sequences.get(j).add(i);\n                    break;\n                } else if (j + 1 == sequenceCount) {\n                    sequences.add(new ArrayList<Integer>(sequences.get(j)));\n                    sequences.get(j + 1).add(i);\n                    sequenceCount++;\n                    break; //increasing sequenceCount causes infinite loop\n                } else if(intArr[i] < intArr[sequences.get(j + 1).get(sequences.get(j + 1).size() - 1)]) {\n                    sequences.set(j+ 1, new ArrayList<Integer>(sequences.get(j)));\n                    sequences.get(j+ 1).add(i);\n                    break;\n                }\n            }           \n        }\n        int bestSequenceLength = sequenceCount;\n        ArrayList<Integer> bestIndexes = new ArrayList<Integer>(sequences.get(bestSequenceLength - 1));\n\n        //build bestSequence, then after it I'm supposed to find the first one instead\n        int[] bestSequence = Arrays.stream(bestIndexes.toArray()).mapToInt(x -> intArr[(int) x]).toArray();\n\n       StringBuilder output = new StringBuilder(\"\");\n       for(Integer x : bestSequence) {\n        output.append(x + \" \");\n       }\n        System.out.println(output.toString().trim());\n      }\n```\n\n\nI'm storing indexes instead in preparation for having to access the original array again. Since it's easier to go from indexes to values than vice versa.\n\nExample:\n\n3 6 1 2 8\n\nMy code returns: 1 2 8\n\nFirst sequence is: 3 6 8\n\nAnother Example:\n\n1 5 2 3 \n\nMy code correctly returns: 1 2 3\n\nBasically, my code works as long as the first longest sequence is the same as the best longest sequence. But when you have a bunch of longest sequences of the same length, it grabs the best one not the first one.\n    ", "Answer": "\r\nCode is self-explanatory. (Have added comments, let me know if you need something extra).\n\n```\npublic class Solution {\n    public static void main(String[] args) {\n        int[] arr = {3,6,1,2,8};\n        System.out.println(solve(arr).toString());\n    }\n\n    private static List<Integer> solve(int[] arr){\n        int[][] data = new int[arr.length][2];\n        int max_length = 0;\n        // first location for previous element index (for backtracing to print list) and second for longest series length for the element\n        for(int i=0;i<arr.length;++i){\n            data[i][0] = -1; //none should point to anything at first\n            data[i][1] = 1;\n            for(int j=i-1;j>=0;--j){\n                if(arr[i] > arr[j]){\n                    if(data[i][1] <= data[j][1] + 1){ // <= instead of < because we are aiming for the first longest sequence\n                        data[i][1] = data[j][1] + 1;\n                        data[i][0] = j;\n                    }\n                }\n            }\n\n            max_length = Math.max(max_length,data[i][1]);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n\n        for(int i=0;i<arr.length;++i){\n            if(data[i][1] == max_length){\n                int curr = i;\n                while(curr != -1){\n                    ans.add(arr[curr]);               \n                    curr = data[curr][0];\n                }                \n                break;\n            }\n        }\n\n        Collections.reverse(ans);// since there were added in reverse order in the above while loop\n        return ans;\n    }    \n}\n```\n\n\nOutput:\n\n```\n[3, 6, 8]\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence Problem with Javascript\r\n                \r\nI generated this code for Longest Increasing Subsequence:\n\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\n\r\n\r\n```\nvar lengthOfLIS = function(nums) {\n  if (nums.length === 0) return 0;\n  let result = 1;\n  const LISEndAt = new Array(nums.length).fill(1);\n\n  for (let i = 1; i < nums.length; i++) {\n    LISEndAt[i] = Math.max(1,\n      ...LISEndAt.slice(0, i).map((item, j) => {\n        return nums[i] > nums[j] ? item + 1 : 0\n      }));\n\n    result = Math.max(LISEndAt[i], result);\n  }\n  \n  return result;\n}\n\nlet nums = [7,7,7,7,7,7,7];\n\nconsole.log(lengthOfLIS(nums));```\n\r\n\r\n\r\n\nCan some one help me to understand this line:\n```\nLISEndAt[i] = Math.max(1,...LISEndAt.slice(0, i).map((item, j)\n```\n\nWhat is significance of ```\nthree dots```\n and as we know map generates key value pairs, what is ```\nmap```\n doing along with ```\nslice```\n?\n    ", "Answer": "\r\nClarification\nBefore I can explain what the line you're asking about does, there are a few things to clear up.\n```\n...```\n\n```\n...```\n is the spread syntax which expands the given iterable (array indices, object key-value pairs, etc). Here's an example where an existing array is used to create a new array with more elements:\n\r\n\r\n```\nconst first = [1, 2, 3];\nconst second = [...first, 4, 5, 6];\nconsole.log(second);\n/* returns [1, 2, 3, 4, 5, 6] */```\n\r\n\r\n\r\n\nIn your example, it is being used to provide multiple parameters to the ```\nMath.max()```\n function. Here's an example of that:\n\r\n\r\n```\nconst candidates = [1, 5, 6, 2, 4];\nconst largest = Math.max(...candidates);\nconsole.log(largest);\n/* returns 6 */```\n\r\n\r\n\r\n\nArray#map\n```\nArray#map```\n doesn't create key/value pairs. Instead, it creates a new array by performing an action on each element in the original array. Here's an example where a new array is created by doubling each item in the original array:\n\r\n\r\n```\nconst original = [1, 2, 3];\nconst doubled = original.map(i => i * 2);\nconsole.log(doubled);\n/* returns [2, 4, 6] */```\n\r\n\r\n\r\n\nYou can also access the index of each item in the original array:\n\r\n\r\n```\nconst alphabet = ['A', 'B', 'C'];\nconst positions = alphabet.map((letter, index) => index);\nconsole.log(positions);\n/* returns [0, 1, 2] */```\n\r\n\r\n\r\n\nArray#slice\n```\nArray#slice```\n creates a new array that is a subset of the original array from the provided starting index until (but not including) the provided end index. Here's an example where a new array is created from the first three items of an existing array:\n\r\n\r\n```\nconst superset = [1, 2, 3, 4, 5, 6];\nconst subset = superset.slice(0, 3);\nconsole.log(subset);\n/* returns [1, 2, 3] */```\n\r\n\r\n\r\n\nYour question\nWith all that in mind, let's take a look at the loop containing your line:\n```\nconst nums = [10, 9, 2, 5, 3, 7, 101, 18];\nconst LISEndAt = new Array(nums.length).fill(1);\n/* [1, 1, 1, 1, 1, 1, 1, 1] */\n\nfor (let i = 1; i < nums.length; i++) {\n    LISEndAt[i] = Math.max(1,\n        ...LISEndAt.slice(0, i).map((item, j) => {\n            return nums[i] > nums[j] ? item + 1 : 0;\n        }));\n}\n```\n\n```\nLISEndAt```\n is being updated with each iteration of your for-loop. Each time, the next index is calculated as:\n\nThe max of ```\n1```\n and any element in:\nThe subset of ```\nLISEndAt```\n from 0 to the current iteration of the for-loop as modified by:\nSome comparison in ```\nmap```\n which returns either:\nThe item at the current index being modified plus one or:\nZero.\n\nIf we add some logging to your loop, you can see this happen in sequence:\n\r\n\r\n```\nconst nums = [10, 9, 2, 5, 3, 7, 101, 18];\nconst LISEndAt = new Array(nums.length).fill(1);\nconsole.log(`original: ${JSON.stringify(LISEndAt)}`);\n\nfor (let i = 1; i < nums.length; i++) {\n  const subset = LISEndAt.slice(0, i);\n  console.log(`sliced: [${subset.join(', ')}]`);\n  const someArray = subset.map((item, j) => {\n    console.log(`comparing ${nums[i]} > ${nums[j]} ? ${item + 1} : 0`);\n    return nums[i] > nums[j] ? item + 1 : 0;\n  });\n  console.log(`taking max of 1, ${JSON.stringify(...someArray)}`);\n  LISEndAt[i] = Math.max(1, ...someArray);\n  console.log(`iteration ${i}: ${JSON.stringify(LISEndAt)}`);\n}```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence from each element\r\n                \r\nGiven a list {x_i}, I want to find the longest increasing subsequence starting from each element such that the starting element is included in the subsequence.\n\nThe obvious way would to do this would be to perform the usual longest increasing subsequence algorithm on each element, giving O(n^2 logn). Can this be beaten?\n    ", "Answer": "\r\nYou can use DP and bring it down to O(n^2).\n\nLet the input be x1, x2, ..., xn\n\nLet f1, f2, ..., fn be the length of longest increasing sequence starting from ith element. Initialize all of them to 1.\n\nNow, \n\n```\nfor i = n-1, n-2, .... , 1:\n    for j = i,i+1,...,n:\n        if x[i]<x[j]:\n            fi=max(fi, fj+1)\n```\n\n\nIf you want actual sequence in addition to the length, keep track of another variable g1,g2, ..., gn  where gi is the next element to follow. Initialize gis to NULL.\n\n```\nfor i = n-1, n-2, .... , 1:\n    for j = i,i+1,...,n:\n        if x[i]<x[j]:\n            if fi<fj+1:\n                fi=fj+1\n                gi=j\n```\n\n\nOnce you have gs, I will leave you to figure out how to enumerate the sequence starting from a particular location.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Finding All possible Longest Increasing subsequence\r\n                \r\nI want to find all possible Longest Increasing Subsequences in a given string.\n\nFor eg: Given string is ```\nqapbso```\n\n\nHere the length of longest increasing subsequence is 3.\nI want to find all possible longest subsequence of length 3. i.e \"abs\", \"aps\", \"abo\".\n\nI am using Dynamic Programming but I am only getting one LIS. I want to list down all of them.\n    ", "Answer": "\r\nSo the typical DP solution to this will produce an array in which you know what is the longest possible subsequence starting at a given position i let's say that you have and array with length n in which dp[i] stores the length of the longest non-decreasing subseq that starts with the element with index i.\n\nNow printing all the LNDSS(longest non-decreasing subsequences) is easiest to be done using a recursion. First find the actual length of the LNDSS by seleting the greast value in dp. Next start the recursion from each element in dp that has the maximum value in dp(these may be more then one). The recursion from a given index should print all the sequences starting from the current index that have length equal to the value dp[i]:\n\n```\nint st[1000];\nint st_index\nvoid rec(int index) {\n  if (dp[index] == 1) {\n    cout << \"Another sequence:\\n\";\n    for (int i = 0; i < st_index; ++i) {\n      cout << st[i] << endl;\n    }\n  }\n  for (int j = index + 1; j < n; ++j) {\n    if (dp[j] == dp[index] - 1 && a[j] >= a[index]) {\n      st[st_index++] = a[j];\n      rec(j);\n      st_index--;\n    }\n  }\n}\n```\n\n\nThis is example code in c++(hope it is understandable in other languages as well). I have a global stack called stack that keeps the elements we have already added. It has size 1000 assuming you will never have more then 1000 elements in the LNDSS but this can be increased. The solution does not have the best possible design, but I have focused on making it simple rather then well designed.\n\nHope this helps.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "OCaml searchin longest increasing subsequence [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking for code must demonstrate a minimal understanding of the problem being solved. Include attempted solutions, why they didn't work, and the expected results. See also: Stack Overflow question checklist\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI try to find longest increasing subsequence in list.\nAnd I have a problems with it ?\nAny suggestions ?\nFor example\n\n```\n[-5;6;7;8;-1;6;7;8;9;10;11;12]\nThe answer should be [-1;6;7;8;9;10;11;12]\n```\n\n    ", "Answer": "\r\nThe following snippet of code answers your question, IMHO.\n\n```\nlet longest l =\n  let rec aux nbest best ncurr curr = function\n    | [] -> List.rev best\n    | hd :: tl when hd <= List.hd curr -> (* new sequence *)\n        aux nbest best 1 [hd] tl\n    | hd :: tl when nbest > ncurr ->\n        aux nbest best (ncurr + 1) (hd :: curr) tl\n    | hd :: tl ->\n        aux (ncurr + 1) (hd :: curr) (ncurr + 1) (hd :: curr) tl\n  in\n  if l = [] then [] else aux 1 [List.hd l] 1 [List.hd l] (List.tl l)\n\nlet test = [-5; 6; 7; 8; -1; 6; 7; 8; 9; 10; 11; 12]\n\nlet () =\n  List.iter (Printf.printf \"%i \") (longest test)\n```\n\n\nNotice that it will return the first strictly increasing sequence, and that the nbest and ncurr are there only for performance reasons. I don't see any way of avoiding the List.rev operation. The function is tail-recursive.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence Length and Value\r\n                \r\nBelow code gives the length of longest increasing subsequence. Code works fine.\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\nWith the help of below code I want to print which array elements are part of the subsequence i.e [2,3,7,101],\nHow can I do it? Or do I need to write completely different code?\nIs there any generic way to do for other problems to do like longest palindromic subsequence?\n```\npublic int lengthOfLIS(int[] nums) {\n  return helper(nums, 0, Integer.MIN_VALUE);\n}\n\npublic int helper(int[] arr, int i, int prev) {\n  if (i == arr.length)\n    return 0;\n  int include = 0;\n  if (arr[i] > prev) {\n    include = 1 + helper(arr, i + 1, arr[i]);\n  }\n  int exclude = helper(arr, i + 1, prev);\n  return Math.max(include, exclude);\n}\n```\n\n    ", "Answer": "\r\n```\npublic void longestIncreasingSubsequence(int[] numbers)\n   {\n       List<Integer> result = new ArrayList<>();\n       List<Integer> temp = new ArrayList<>();\n       for (int i = 0; i < numbers.length; i++) {\n           temp.add(numbers[i]);\n           if ( i + 1 == numbers.length || numbers[i] > numbers[i + 1])\n           {\n               if(temp.size() >= result.size())\n               {\n                   result.clear();\n                   result.addAll(temp);\n               }\n               temp.clear();\n           }\n       }\n       System.out.println(result);\n   }\n```\n\nTry this\nI got your point. Plz Check my new code\n```\n  public void longestSubSequence(int[] nums)\n    {\n        int index=0;\n        List<Integer> result = new ArrayList<>();\n         while (index<nums.length)\n        {\n            int val=nums[index];\n            List<Integer> temp = new ArrayList<>();\n            temp.add(val);\n            for (int i = index+1; i < nums.length; i++) {\n                int currentVal = nums[i];\n                if (val < currentVal)\n                {\n                    val= currentVal;\n                    temp.add(currentVal);\n                }\n\n            }\n            if(temp.size()>= result.size())\n            {\n                result.clear();\n                result.addAll(temp);\n                temp.clear();\n            }\n            index++;\n        }\n        System.out.println(result);\n    }\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "longest increasing subsequence wrong answer\r\n                \r\nI wrote a recursive solution for the longest increasing subsequence and it worked perfectly fine. But when I applied dp on the same code it gives different answers.\nProblem Link: https://practice.geeksforgeeks.org/problems/longest-increasing-subsequence-1587115620/1\nRecursive code:\n```\nint LISrecursive(int arr[], int n, int currIndex, int maxVal) {\n    if (currIndex == n) {\n        return 0;\n    }\n    int included = 0, notIncluded = 0;\n    if (arr[currIndex] > maxVal) {\n        included = 1 + LISrecursive(arr, n, currIndex + 1, arr[currIndex]);\n    }\n    notIncluded = LISrecursive(arr, n, currIndex + 1, maxVal);\n\n    return max(notIncluded, included);\n\n}\n```\n\nDP Code:\n```\nint LISdp(int arr[], int n, int currIndex, int maxVal, vector<int> &dp) {\n    if (currIndex == n) {\n        return 0;\n    }\n    if (dp[currIndex] != -1) return dp[currIndex];\n    int included = 0, notIncluded = 0;\n    if (arr[currIndex] > maxVal) {\n        included = 1 + LISdp(arr, n, currIndex + 1, arr[currIndex], dp);\n    }\n    notIncluded = LISdp(arr, n, currIndex + 1, maxVal, dp);\n\n    return dp[currIndex] = max(notIncluded, included);\n\n}\n```\n\n```\nint32_t main() {\n    int n;\n    cin >> n;\n    int arr[n];\n    vector<int> dp(n, -1);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    cout << LISrecursive(arr,n,0,-1); \n    cout << LISdp(arr, n, 0 , -1, dp);\n    return 0;\n}\n```\n\nI cannot figure out what I did wrong?\nFor this test case\n6 (n)\n6 3 7 4 6 9 (arr[])\nRecursive code gives 4 answer(correct)\nBut DP code gives 3 answer(incorrect)\n    ", "Answer": "\r\nWhen I think of dynamic programming, I usually break it down into two steps:\n\nSolve the recursion with \"including the current element before recursing\nagain\" compared to \"not including the current element before recursing again\".   This is exactly what you did with your recursive solution.\n\nTake the recursive solution from step 1 and add a cache of previous computed results to avoid repetitive recursion.  The cache, can be conceptualized as a multidimension matrix that maps all the non-const variable parameters passed to the recursive function to the final result.\n\n\nIn your case, each recursive step has two variables, ```\ncurrIndex```\n, and ```\nmaxVal```\n.  ```\na```\n and ```\nn```\n are actually constants throughout the entire recursion. The number of non-const parameters of the recursive step is the number of dimensions in your cache.  So you need a two dimensional table.  We could use a big 2-d int array, but that would take a lot of memory.  We can achieve the same efficiency with a nested pair of hash tables.\nYour primary mistake is that your cache is only 1 dimension - caching the result compared to ```\ncurrIndex```\n irrespective of the value of ```\nmaxVal```\n.  The other mistake is using a vector instead of a hash table. The vector technique you have works, but doesn't scale. And when we add a second dimension, the scale in terms of memory use are even worse.\nSo let's defined a cache type as an unordered_map (hash table) that maps ```\ncurrIndex```\n to another hash table that maps ```\nmaxVal```\n to the result of the recursion.  You could also use tuples, but the geeksforgeeks coding site doesn't seem to like that.  No bother, we can just define this:\n```\ntypedef std::unordered_map<int, std::unordered_map<int, int>> CACHE;\n```\n\nThen your DP solution is effectively just inserting a lookup into the CACHE at the top of the recursive function and an insertion into the CACHE at the bottom of the function.\n```\nint LISdp(int arr[], int n, int currIndex, int maxVal, CACHE& cache) {\n    if (currIndex == n) {\n        return 0;\n    }\n\n    // check our cache if we've already solved for currIndex and maxVal together\n    auto itor1 = cache.find(currIndex);\n    if (itor1 != cache.end())\n    {\n        // itor1->second is a reference to cache[currIndex]\n        auto itor2 = itor1->second.find(maxVal);\n        if (itor2 != itor1->second.end())\n        {\n            // itor2->second is a reference to cache[n][maxVal];\n            return itor2->second;\n        }\n    }\n\n    int included = 0, notIncluded = 0;\n    if (arr[currIndex] > maxVal) {\n        included = 1 + LISdp(arr, n, currIndex + 1, arr[currIndex], cache);\n    }\n    notIncluded = LISdp(arr, n, currIndex + 1, maxVal, cache);\n\n    // cache the final result into the 2-d map before returning\n    int finalresult = std::max(notIncluded, included);\n    cache[currIndex][maxVal] = finalresult; // cache the result\n    return finalresult;\n\n}\n```\n\nThen the initial invocation with the input set to solve for is effectively passing INT_MIN as the intial ```\nmaxVal```\n and an empty cache:\n```\nint N = 16\nint A[N]={0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};\n\nCACHE cache;\nint result = LISdp(A, N, 0, INT_MIN, cache);\n```\n\nA minor optimization is to make ```\na```\n, ```\nn```\n, and ```\ncache```\n a member variable of the C++ class encapsulating your solution so that they don't have to be pushed onto the stack for each step of the recursion. The cache is getting passed by reference, so it's not that big of a deal.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find the Longest Increasing Subsequence with the Maximum Sum\r\n                \r\nGiven a sequence of number which can be positive and negative, there are several algorithms to find the longest increasing subsequence. But can someone give me an algorithm to find the longest increasing subsequence with the maximum sum if there are multiple longest increasing subsequences? \n\nExample: For 20, 1, 4, 3, 10, the answer is 1, 4, 10, not 1, 3, 10\n    ", "Answer": "\r\n```\ndpLen[i] = maximum length of a LIS with maximum sum ending at i\ndpSum[i] = maximum sum of a LIS with maximum sum ending at i\n\nfor i = 0 to n do\n  dpLen[i] = 1\n  dpSum[i] = input[i]\n\n  maxLen = 0\n  for j = 0 to i do\n    if dpLen[j] > maxLen and input[j] < input[i]\n      maxLen = dpLen[j]\n\n  for j = 0 to i do\n    if dpLen[j] == maxLen and input[j] < input[i] and dpSum[j] + input[i] > dpSum[i]\n      dpSum[i] = dpSum[j] + input[i]\n\n  dpLen[i] = maxLen + 1\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence problem (leetcode)\r\n                \r\nlink of the problem:\n[link]https://leetcode.com/problems/longest-increasing-subsequence/\n```\nclass Solution {\npublic:\nint lengthOfLIS(vector& nums)\n{\nint n=nums.size();\nif (n==0)\nreturn 0;\n\n    int list[n];\n    for(int i=0;i<n;i++)\n        list[i]=0;\n    \n    list[0]=1;\n    for(int i=1;i<n;i++)\n    {\n        for(int j=i-1;j>=0;j--)\n        {\n            if(nums[j]<nums[i])\n                list[i]=max(list[i],1+list[j]);\n        }\n    }\n    int ans=1;\n    for(int i=0;i<n;i++)\n        ans=max(ans,list[i]);\n    return ans;\n}\n};\n```\n\nInput: ```\n[10,9,2,5,3,7,101,18]```\n\noutput is coming:```\n3```\n\nexpected output:```\n4```\n\nnot getting it where its wrong.\n    ", "Answer": "\r\n```\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n\nclass Solution\n{\npublic:\n  int lengthOfLIS(std::vector<int> &);\n  int max(int, int);\n  std::string print(std::vector<int> const &);\n};\n\nint Solution::max(int a, int b)\n{\n  return a < b ? b : a;\n}\n\nstd::string Solution::print(std::vector<int> const &input)\n{\n  std::stringstream ss;\n    for (int i = 0; i < input.size(); i++)\n        ss << input.at(i) << ' ';\n\n  return ss.str();\n}\n\nint Solution::lengthOfLIS(std::vector<int> &nums)\n{\n  int n = nums.size();\n  \n  if (n == 0)\n    return 0;\n\n  int list[n];\n  std::fill_n(list, n, 1);\n  //list[0] = 1;\n\n  for (int i = 1; i < n; i++)\n  {\n    int min_val = nums[i];\n\n    for (int j = i - 1; j > -1; j--)\n    {\n      if (nums[j] < nums[i] && nums[j] < min_val)\n      {\n        list[i]++;\n        min_val = nums[j];\n      }\n    }\n  }\n\n  int ans = 1;\n\n  for(int i = 0; i < n; i++)\n    ans = max(ans, list[i]);\n\n  return ans;\n}\n\nint main()\n{\n  std::vector<int> Input0 { 10, 9, 2, 5, 3, 7, 101, 18 },\n    Input1 { 10, 19, 2, 5, 3, 7, 101, 18 },\n    Input2 { 10, 9, 12, 5, 3, 7, 101, 18 },\n    Input3 { 10, 9, 2, 15, 3, 7, 101, 18 },\n    Input4 { 10, 9, 2, 5, 13, 7, 101, 18 },\n    Input5 { 10, 9, 2, 5, 3, 17, 101, 18 },\n    Input6 { 10, 9, 2, 5, 13, 7, 10, 18 },\n    Input7 { 10, 9, 2, 5, 13, 7, 101, 180 };\n  Solution solution;\n  std::cout << solution.print(Input0) << \"\\t|\\t\" << solution.lengthOfLIS(Input0) << std::endl;\n  std::cout << solution.print(Input1) << \"\\t|\\t\" << solution.lengthOfLIS(Input1) << std::endl;\n  std::cout << solution.print(Input2) << \"\\t|\\t\" << solution.lengthOfLIS(Input2) << std::endl;\n  std::cout << solution.print(Input3) << \"\\t|\\t\" << solution.lengthOfLIS(Input3) << std::endl;\n  std::cout << solution.print(Input4) << \"\\t|\\t\" << solution.lengthOfLIS(Input4) << std::endl;\n  std::cout << solution.print(Input5) << \"\\t|\\t\" << solution.lengthOfLIS(Input5) << std::endl;\n  std::cout << solution.print(Input6) << \"\\t|\\t\" << solution.lengthOfLIS(Input6) << std::endl;\n  std::cout << solution.print(Input7) << \"\\t|\\t\" << solution.lengthOfLIS(Input7) << std::endl;\n  return 0;\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence linear time\r\n                \r\nI was reading the longest increasing subsequence problem:\nGiven array A={a_1,a_2,...,a_n}, find the length of the longest increasing subsequence (not necessarily contiguous)\nI thought of a recursive solution, which with memoization (or DP) has complexity = O( n * max(a_i) ).\nso basically n * range of a_i's.\nAll the solutions I found are O(n^2) or O(nlogn), is there something wrong logically with this solution?\n\nHere is the code:\nWithout loss of generality , assume all a_i's > 0.\n\n```\n#include <iostream>\nusing namespace std;\nint count = 0;\nint lis(int A[], int loc, int length, int ** table, int max_so_far=0){\ncount++;\n    if (loc == length)\n  return 0;\n\n    if (table[loc][max_so_far] != -1)\n      return table[loc][max_so_far];\n\nint val1 = 0, val2 = 0;\nval1 = lis(A, loc+1, length, table, max_so_far);\nif (max_so_far < A[loc])\n    val2 = 1 + lis(A, loc+1, length, table, A[loc]);\n    table[loc][max_so_far] = max(val1,val2);\nreturn max(val1,val2); \n}\n\nint main(){\nint A[]={10, 11, 12, 9, 8, 7, 5, 6};\n     int A[]={1,3,2,5,1,3,2,5,1,3,2,5,1,3,2,5,1,3,2,5,1,3,2,5,1,3,2,5, 1,3,2,5, 1,3,2,5, 1,3,2,5, 1,3,2,5, 1,3,2,5};\n    int ** table;\nint n = 49;\n    int range = 6;\ntable = new int*[n];\n    for (int i =0;i<n;i++){\n      table[i] = new int[range];\n      for(int j=0;j<range;j++)\n       table[i][j] = -1;\n}\n    count = 0;\n    cout<<lis(A, 0, n, table, 0)<<endl;\ncout<<\"Number of calls made: \"<<count<<endl;\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThis is just a convoluted and space inefficient way to write the standard O(n^2) algorithm.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence optimization\r\n                \r\nThe Longest Increasing Subsequence problem is to find a subsequence of a given sequence in which the subsequence's elements are in sorted order and in which the subsequence is as long as possible.\n\nHere is my O(n^2) approach which is running very slow for long input:\n\n```\nN = int(input())\n\nlst = []\nfor i in range(N):\n    lst.append(input())\n\ncount = [1] * N\n\nfor i in range(1, len(lst)):\n    for j in range(i):\n        if(int(lst[j]) < int(lst[i])):\n            k = int(count[j]) + 1\n            if (k > int(count[i])):\n                count[i] = k\ncount.sort()\nprint(count[-1])\n```\n\n\nCan anybody tell me how can it be done in O(n*log n) time?\n    ", "Answer": "\r\nGreat resources have been mentioned in the comments; if you still want a piece of python code, I've written and explained it here.\n\nIn this algorithm, for all ```\nL < N```\n, we keep a track of the values in the input which represent the endpoint of the current longest increasing subsequence of length ```\nL```\n.\n\n```\nlongest_sequence_values```\n stores these values. For example, ```\nlongest_sequence_values[3]```\n is a value in the input at which the longest increasing subsequence of length 3 ends.\n\nNote here that ```\nlongest_sequence_values```\n will always be non-decreasing, which allows us to perform a binary search when we're trying to build a new longest increasing subsequence. This happens because if ```\ni < j```\n, then the endpoint of a subsequence of length ```\ni```\n cannot be larger than the endpoint of a subsequence of length ```\nj```\n.\n\n```\nlongest_current_sequence```\n is the length of of the longest subsequence found thus far. We need this value to specify the range of the binary search. It also represents the answer at the end.\n\n```\nfrom math import ceil\nN = int(input())\n\ninput_vals = []\nfor i in range(N):\n    input_vals.append(input())\n\nlongest_sequence_values = [None] * (N+1)\nlongest_current_sequence = 0\n\nfor i in range(N):\n    # binary search starts here\n    # this gives us the log(N) factor\n    lo = 1\n    hi = longest_current_sequence\n    while lo <= hi:\n        mid = int(ceil((lo+hi)/2))\n        if longest_sequence_values[mid] <= input_vals[i]:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n\n    # lo will be length of the longest sequence ending at input_vals[i]\n    longest_len_here = lo\n    # We have a new lis of length longest_len_here ending at index i\n    # Note that before we perform the following substitutions,\n    # longest_sequence_values[longest_len_here] >= input_vals[i]\n    # This means that the new endpoint of the lis of length longest_len_here\n    # is <= to the old endpoint.\n    # This point is essential in keeping the result optimal\n    longest_sequence_values[longest_len_here] = input_vals[i]\n\n    if longest_len_here > longest_current_sequence:\n        longest_current_sequence = longest_len_here\n\nprint longest_current_sequence\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Patience sort and finding the longest increasing subsequence\r\n                \r\nI am able to understand the algorithm to find the longest increasing subsequence described HERE. But it is also related to patience sort.As author says\n\n\n  Bonus: You have learnt Patience Sorting technique partially :).\n\n\nI have tried reading patience sort from other places but could not see how it is related to longest increasing subsequence solution. \nI am trying to reverse engineer and see how to sort from the point longest increasing subsequence leaves us. \nCan someone please suggest any pointers on this? Moreover what really is the purpose and advantage of patience sorting ?\n\nHere is the stack overflow related question which shares information but other way round that is - how to get longest increasing subsequence using patience sort.\n    ", "Answer": "\r\nPatience sort is just another O(n lg n) sorting algorithm (it actually depends on implementation). If you have played solitaire before, it's kind of similar. The algorithm maintains a list of stacks each of which is sorted in decreasing order (tail to head). The numbers are inserted incrementally. \n\nTo insert a number x, find the leftmost stack whose top element is larger than x and push x onto it. If no such stack exists create a new one at the end and push x onto it. Notice that the way we insert numbers implies that top elements of the stacks are sorted in increasing order so the length of the longest increasing subsequence is just the number of piles at the end.\n\nOnce all numbers are inserted and the piles are ready, we'll repeatedly find the minimum number and write it to output. The stack from which we took the number must be inserted in a new position now so that the top elements of the stacks are sorted again. This can be done by using a heap to store the stacks.\n\nIf you simply scan the top elements to find the minimum and use no fancy data structures, the algorithm take O(n sqrt(n)) which is not bad for small n.\n\nSo this sorts the list of numbers and gives you the length of the LIS (and with some augmentation gives you a LIS).\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "display the longest increasing subsequence\r\n                \r\n```\n#include<iostream>\nusing namespace std;\nint main()\n{\n    int a[]={0,8,4,12,2,10,6,1,9,5,13,3,11,7};\n    int b[50],i,j,n,ls[50];\n    n=sizeof(a)/sizeof(a[0]);\n    int maxlen=0,end=-1;\n    b[0]=-1;\n    for(i=0;i<n;i++)\n    {\n        ls[i]=1;\n        for(j=0;j<i;j++)\n        {\n            if(a[i]>a[j] && ls[i]<ls[j]+1)\n            {\n                ls[i]=ls[j]+1;\n                b[i]=j;\n            }\n        }\n        if(ls[i]>maxlen)\n        {\n            end=i;\n            maxlen=ls[i];\n        }\n    }\n\n    cout<<maxlen<<endl;\n    for(int k=end;b[k]!=-1;k=b[k])\n    {\n        cout<<a[k];\n    }\n            return 0;\n}\n```\n\n\nThis was the program I done for finding the longest increasing subsequence. I am getting the length of the subsequence correctly but i am not getting the sequence correctly. I think there may be a problem with the the last for loop which contains the variable ```\nk```\n, but I cant figure it out. please help me.\n    ", "Answer": "\r\nActually you wrote correct sequence but in reverse order and skipping the first(last) element\n\nYou may change the last for to include the first element\n\n```\nvector<int> v;\nfor(int k=end;k!=-1;k=b[k])\n{\n    cout << a[k] << ' ';\n}\n```\n\n\nYou may need to store element in something like ```\nstd::vector```\n to reverse it to get correct order\n\n```\nvector<int> v;\nfor(int k=end;k!=-1;k=b[k])\n{\n    v.push_back(a[k]);\n}\nreverse(v.begin(), v.end());\nfor(int x: v) {\n    cout << x << ' ';\n}\n```\n\n\nhttp://ideone.com/URPACA\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence\r\n                \r\nThe task is to find the length of the longest subsequence in a given array of integers such that all elements of the subsequence are sorted in ascending order. For example, the length of the LIS for { 15, 27, 14, 38, 26, 55, 46, 65, 85 } is 6 and the longest increasing subsequence is {15, 27, 38, 55, 65, 85}. \n\nFollowing is the code I wrote. I am not sure if my logic is fine but the code fails to run properly. If I try to input the following test case\n\n9\n15\n27\n14\n\nThe program stops reading the values after 14 and gives me the output 2. It should read 9 values but the code is reading only 3 values. I have checked my code several times but unfortunately, I am unable to spot the error. \n\n```\n#include<stdio.h>\nint main()\n{\n    int N,max_val,i,j,k,l=1;\n    int a[100000], track[100000];\n    track[0]=0;\n    max_val=1;\n    scanf(\"%d\",&N);\n    for(i=0;i<N;++i)\n    {\n        printf(\"x\");\n        scanf(\" %d\",&a[i]);\n        if(i!=0)\n        {\n            for(j=0;j<l;++j)\n            {\n                if(a[i]>a[track[j]])\n                {\n                    max_val++;\n                    track[0]=i;\n                    l=1;\n                    break;\n                }\n                else\n                {\n                    track[l]=i;\n                    l++;\n                }\n            }\n        }\n    }\n    printf(\"%d\",max_val);\n    return 0;\n}\n```\n\n\nHelp is appreciated. Thanks!\n    ", "Answer": "\r\nOh, nicely convoluted. You have undefined behavior here, and the way it expresses itself is instructive. The general problem is that\n\n```\n            if(a[i]>a[track[j]])  // <-- when i == 2, this first is false with\n            {                     //     your input\n                max_val++;\n                track[0]=i;\n                l=1;\n                break;\n            }\n            else\n            {\n                track[l]=i;       // <-- and you end up here, where you write \n                l++;              //     into track[l] and increase l.\n            }\n```\n\n\nAfter ```\nl```\n is increased, you go back to the loop\n\n```\nfor(j=0;j<l;++j)\n```\n\n\nHere ```\nj```\n is increased, but since ```\nl```\n has also increased, the condition is never (except not really, see below) false, and the loop continues. From this point on, the condition\n\n```\na[i]>a[track[j]]\n```\n\n\nis always false, because you keep comparing the same two numbers, so ```\nl```\n is incremented every turn, and this just keeps happening.\n\nThis goes on until ```\ntrack```\n is full with twos (because ```\ni```\n remains ```\n2```\n). In fact, it goes on after ```\ntrack```\n is full, writing into whatever happens to lie behind ```\ntrack```\n in memory. What this is is not defined in the C language standard; for me this happens to be first ```\na```\n, then ```\nN```\n, ```\nmax_val```\n and so forth in order of declaration (found that out with a debugger, a tool I encourage you to look into). YMMV. So, for me, ```\na```\n is also filled, and then ```\nN```\n is overwritten with ```\n2```\n, ```\nmax_val```\n etc. are also overwritten with ```\n2```\n, then ```\nl```\n is overwritten with ```\n2```\n, and only then does the loop end. And then you go back to\n\n```\nfor(i=0;i<N;++i)\n```\n\n\n...where now ```\nN```\n is ```\n2```\n and ```\ni```\n is just being incremented to ```\n3```\n. Then the loop ends, and then the program ends.\n\nPerhaps needless to say, this is not behavior you can depend upon. The compiler doesn't have to arrange the stack variables in this order, and an optimising compiler can even generate code that doesn't hold certain variables in memory (or at all). But that is what happens.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Trouble understanding Longest Increasing Subsequence\r\n                \r\nI have been trying understand the concept of LIS and have found the following example on Wikipedia as a reference for my question.\n\n```\nIn the first 16 terms of the binary:\n0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15\na longest increasing subsequence is:\n0, 2, 6, 9, 11, 15.\n```\n\n\nMy question really is, why those numbers. Wouldn't the LIS be all of the numbers sorted from lowest to highest, and the length of the LIS would be the same length as the original sequence assuming there are no duplicate integers? For example:\n\n```\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n```\n\n\nHere we have a sequence of increasing numbers. Isn't that the longest increasing subsequence? What am I not understanding?\n    ", "Answer": "\r\nOrder matters in a sequence. By sorting it, you're changing it to a different sequence.\n\nFrom Wikipedia:\n\n\n  In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n\n\nSo, the goal in finding the longest increasing subsequence is to find the longest list of elements in the sequence that are in sorted order, but without changing the order of the original sequence.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence, Dynamic Programing\r\n                \r\nI have the following problem:\n\n\n  Find the longest increasing subsequence of a given sequence / array.\n  \n  In other words, find a subsequence of array in which the subsequence’s\n  elements are in strictly increasing order, and in which the\n  subsequence is as long as possible.  This subsequence is not\n  necessarily contiguous, or unique. In this case, we only care about\n  the length of the longest increasing subsequence.\n  \n  Example :\n  \n  Input : [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] Output\n  : 6 The sequence : [0, 2, 6, 9, 13, 15] or [0, 4, 6, 9, 11, 15] or [0,\n  4, 6, 9, 13, 15]\n\n\nThis is a DP problem and I do have some issue at the memorization step.\nHere is my code:\n\n```\npublic int lis(final List<Integer> a) {\n    return maxIncreasing(0, Integer.MIN_VALUE, a);\n}\nHashMap<Integer, Integer> memo = new HashMap<>();\nprivate int maxIncreasing(int index, int lastElt, final List<Integer> a) {\n    if(memo.containsKey(index)) return memo.get(index);\n    // end?\n    if(index >= a.size()) return 0;\n    int weTake = Integer.MIN_VALUE;\n    // can we take it?\n    if(a.get(index) > lastElt) {\n        // take it or don't\n        weTake = maxIncreasing(index + 1, a.get(index), a) + 1;\n    }\n    int weDoNot = maxIncreasing(index + 1, lastElt, a);\n    int max = Math.max(weTake, weDoNot);\n    memo.put(index, max);\n    return max;\n}\n```\n\n\nWithout the memo HashMap in place I have the correct result, I am not sure why this is giving me the wrong result once in place.\n\nThanks.\n    ", "Answer": "\r\nThat is because you are not taking care of the ```\nlastElt```\n. Basically, you can have more than one solution for a given ```\nindex```\n depending on what was the ```\nlastElt```\n value. Therefore, you would have to have a ```\nKey```\n for your ```\nmemo```\n that contains both ```\nindex```\n and ```\nlastElt```\n.\n\nYou could do something like this:\n\n```\n    class Key {\n        final int index;\n        final int lastEl;\n\n        Key(int index, int lastEl) {\n            this.index = index;\n            this.lastEl = lastEl;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Key key = (Key) o;\n\n            if (index != key.index) return false;\n            return lastEl == key.lastEl;\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result = index;\n            result = 31 * result + lastEl;\n            return result;\n        }\n    }\n\n    public int lis(final List<Integer> a) {\n        return maxIncreasing(0, Integer.MIN_VALUE, a);\n    }\n    HashMap<Key, Integer> memo = new HashMap<>();\n    private int maxIncreasing(int index, int lastElt, final List<Integer> a) {\n        Key key = new Key(index ,lastElt);\n        if(memo.containsKey(key)) return memo.get(key);\n        // end?\n        if(index >= a.size()) return 0;\n        int weTake = Integer.MIN_VALUE;\n        // can we take it?\n        if(a.get(index) > lastElt) {\n            // take it or don't\n            weTake = maxIncreasing(index + 1, a.get(index), a) + 1;\n        }\n        int weDoNot = maxIncreasing(index + 1, lastElt, a);\n        int max = Math.max(weTake, weDoNot);\n        memo.put(key, max);\n        return max;\n    }\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence Recursive version\r\n                \r\nTraditional Longest Increasing Subsequence problem.\nThis is recursion version ( not DP version )\nI realized that version1 code had a bug, so I changed it to version2.\n\nI don't clearly understand why version2 works and version1 has a bug for input A0\n\nPlease see version 1 and version2 below:\n\n```\nstatic int lis1(int[] v) {\n    int maxLen = 1;\n\n    for(int i = 1; i < v.length; i++) {\n        List<Integer> w = new ArrayList<Integer>();     \n\n        for( int j = 0; j < i; j++) {\n            if( v[j] < v[i] ) {\n                w.add(v[j]);                \n            }\n        }\n\n        // it used to be the following one line which has bug for input A0\n        //cand =  lis1(l2a(w)) + 1;           // version1\n\n        // so I changed it to the following, but can't clearly understand why it works.\n        // without this part, it has but for input A0\n        int cand = 1;                         // version2\n        if(v[i-1] < v[i])\n            cand =  lis1(l2a(w)) + 1;\n        else \n            cand =  lis1(l2a(w));\n\n        maxLen = Math.max(maxLen, cand);        \n    }\n\n    return maxLen;      \n}\n\npublic static void main(String[] args) {\n    int[] A0 = {3, 2, 5, 6};    // for this input version1 had a bug which printed out 4 ( instead of 3 )\n    int[] A1 = {1, 2, 3, 3, 2, 4, 6, 7};                            // 6\n    int[] A2 = { 10, 22, 9, 33, 21, 50, 41, 60, 80 };               // 6\n    int[] A3 = { 5, 0, 4, 2, 3, 7, 1 };                             // 4\n    int[] A4 = { 2, 7, 3, 4, 9, 8, 12 };                            // 5\n    int[] A5 = {3, 4, 2, 5 };                                       // 3\n```\n\n    ", "Answer": "\r\nActually... neither of your version works. Try putting ```\nA0={3,2,7,6}```\n, your v2 returns 2, obviously wrong.\n\nAs for v1, for ```\nv={3,2}```\n the answer should be 1, right? Let's see what your code does. When index ```\ni=1```\n, your ```\nw```\n after inner ```\nfor```\n loop equals ```\n{}```\n. Then you made a recursive call to ```\nw={}```\n, which should've returned 0, but it returns 1. Why, because of your ```\nmaxlen```\n variable, which is wrongly initialized with ```\n1```\n. This error propagates to entire ```\n{3,2,5,6}```\n and gives wrong answer.\n\nv2 accidentally solves this problem because your ```\nif```\n condition then fails ```\n(3<2)```\n, and it returns the previously returned 1.\n\nJust delete entire version 2, correct ```\nmaxlen```\n initialization. And start outer loop ```\nfor(int i = 1; i < v.length; i++)```\n with ```\ni=0```\n, else you will get 0 for single-element array. \n\n```\nstatic int lis1(int[] v) {\nint maxLen = 0;\n\nfor(int i = 0; i < v.length; i++) {\n    List<Integer> w = new ArrayList<Integer>();     \n\n    for( int j = 0; j < i; j++) {\n        if( v[j] < v[i] ) {\n            w.add(v[j]);                \n        }\n    }     \n    cand =  lis1(l2a(w)) + 1;           // version1\n\n    maxLen = Math.max(maxLen, cand);        \n}\n\nreturn maxLen;      \n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequences\r\n                \r\nFor a digit N we define LIS Array as \n\nLongest strictly increasing subsequence of digits ending with that digit.\n\nFor example, let us say 4-digit number is 1531, then the LIS array would be [1, 2, 2, 1]. The length of longest increasing subsequence ending at first digit is 1 (the digit 1 itself) and at the second digit is 2 ([1, 5]), at third digit is also 2 ([1, 3]), and at the 4th digit is 1 (the digit 1 itself).\n\nProblem Statement\n\nHere i am using bitmasking algorithm \n\n```\nfor(int i=2;i<=n;i++){\n    int x = Lis[i];\n\n    if(x==1){\n        for(int j=1;j<(1<<10);j++){\n            int last=-1;\n            int len=0;\n            for(int k=9;k>=0;k--)\n                if((j&(1<<k))!=0){ \n                    len++;\n                    if(len==1)\n                        last=k;\n                }\n\n            for(int k=0;k<=last;k++){\n                dp[1<<k][i] = (dp[1<<k][i]+ dp[j][i-1])%mod;\n            }\n        }\n\n        continue;\n    }\n\n    for(int j=1;j<(1<<10);j++){\n        int last=-1;\n        int len=0;\n        for(int k=9;k>=0;k--)\n            if((j&(1<<k))!=0){ \n                len++;\n                if(len==1)\n                    last=k;\n            }\n        if(len+1!=x) continue;\n\n        for(int k=last+1;k<10;k++)\n            dp[j|(1<<k)][i] = (dp[j|(1<<k)][i]+ dp[j][i-1])%mod; \n    }\n}\n```\n\n\nBut it's not working correctly ? Can anyone explain me correct approach to deal with this ?\n    ", "Answer": "\r\nFor each digit store the length of the longest associated sequence and go through the sequence:\n\n```\nmax_len[]\nresult\n\nfor digit in sequence\n    max_len[digit] = max(sub_array(max_len, 1, digit - 1)) + 1\n    result.append(max_len[digit])\n```\n\n\nsince ```\nmax_len```\n has length 9 or 10, depending upon whether 0 is allowed in the input-sequence, this solution runs in ```\nO(n)```\n. ```\nresult```\n contains the LIS-array.\n\nThe basic idea is to define the LIS of an element ```\ne```\n in the input-sequence recursively as the LIS of any element that precedes ```\ne```\n and is smaller than ```\ne```\n. Since we want the longest sequence we obviously choose the predecessor with the longest sequence. We can memorize this value as the longest sequence that ends with element ```\ne```\n for later use and add the length of the LIS of ```\ne```\n to the output sequence.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Cyclic Subsequence\r\n                \r\nI have a code for finding the longest increasing subsequence, but I'd like to extend this to allow wrap arounds. For example for the sequence (4,5,6,1,2,3) the longest increasing cyclic subsequence is (1,2,3,4,5,6) since once we reach 3, we can go back to the beginning of the sequence (we can only do this once.) Is anyone able to help me? \n\nHere is the code:\n\n```\ndef longest_increasing_subsequence(X):\n\nN = len(X)\nP = [0] * N\nM = [0] * (N+1)\nL = 0\nfor i in range(N):\n   lo = 1\n   hi = L\n   while lo <= hi:\n       mid = (lo+hi)//2\n       if (X[M[mid]] < X[i]):\n           lo = mid+1\n       else:\n           hi = mid-1\n\n   newL = lo\n   P[i] = M[newL-1]\n   M[newL] = i\n\n   if (newL > L):\n       L = newL\n\nS = []\nk = M[L]\nfor i in range(L-1, -1, -1):\n    S.append(X[k])\n    k = P[k]\nreturn len(S[::-1])\n```\n\n    ", "Answer": "\r\nConcatenate the sequence to the end of itself, then run your algorithm on it. \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to find the longest increasing subsequence?\r\n                \r\nI'm trying to use a code to print the  longest increasing subsequence,the code works but it doesn't print the right longest increasing subseqquence .\n\n\n\nfor example if the input was :3,5,11,8,4,7,1,2,10,12,9,6\n\nThe output is : [1, 2, 6, 9, 12]\n\nmy desired output is : 3,4,7,10,12\n\nI've debugging the way of inserting and printing the arraylist and its correct , I believe that there is something wrond here,why was is wrong?why it changes the order of numbers!?\n\n```\npublic static ArrayList<Integer> lengthOfsequance(ArrayList<Integer> nums) {\n\n    if (nums == null || nums.size() == 0)\n        return null;\n    ArrayList<Integer> list = new ArrayList<Integer>();\n    for (int num : nums) \n    {\n        if (list.size() == 0 || num > list.get(list.size() - 1)) \n            list.add(num);\n        else\n        {\n            int i = 0;\n            int j = list.size() - 1;\n            while (i < j) \n            {\n                int mid = (i + j) / 2;\n                if (list.get(mid) < num) \n                    i = mid + 1;\n                else\n                    j = mid;\n            }\n           list.set(j, num);\n        }\n    }\n    return list;\n}\n```\n\n    ", "Answer": "\r\nYour approach can't work. You are using one list to collect the longest sequence. But your input sequence can have multiple increasing sequences. Maybe one that goes from index 0 to 5; and another one that goes from index 10 to 20. \n\nIn other words; you need a different strategy; and the \"straight forward\" approach is something like:\n\n\niterate the input list, to \"collect\" all increasing sequences (in other words: that would be a List of Lists).\nAfterwards, you look into that List of Lists to find the max-length one\n\n\nOf course, this can then be further optimized - you don't need to remember all increasing sequences, you just have to remember about the \"longest completed\" sequence that you saw before. \n\nBut as said: the first, naive implementation would be to simply identify all \"increasing + complete\" sequences in the input list. And then you work  your way from there.\n\n( as I assume this is some kind of homework project I am only giving guiding ideas, not source code. Implementation is left as exercise to the reader )\n\nEdit: to address the comment \"how to avoid remembering 'equal' sequences\".\n\nAssume your input is this sequence: 1,2,3,0,1,2,3,4,1,2,3\nWhen you look for increasing sequences in there, you should find:\n\n(1, 2, 3) and (0, 1, 2, 3, 4), and (1, 2, 3)\n\nYou are correct: if you represent the above tuples as ```\nList<Integer>```\n; then \"correct\" code would collect three lists; where the first and third would be equal (because they contain the very same numbers).\n\nAnd when you store those lists within a ```\nList<List<Integer>>```\n then, yes, your code would have to account for duplicates. One way of avoiding that could be to use a ```\nSet<List<Integer>>```\n instead - because the Set makes sure by nature that all entries stored within that collection are not equal. In other words: when you add two lists with the same content to a Set object, then, in the end, the Set will only contain one of those two lists. (one thing to be aware of - when you use a HashSet here, then the order of add operations is lost ).\n\nFinally: instead of using ```\nSet<List<Integer>>```\n you could also you use a ```\nMap<Integer, Integer>```\n with \"key\" being the length of a sequence; and  \"value\" being the first index within the input list.\n\nIn other words: instead of remembering the whole sequence, you can as well just remember at which position a sequence starts, and how many elements that sequence has. \n\nLong story short: there are many many different ways to solve this puzzle, using all kinds of data structures and looping/counting mechanisms. So, don't stop with the first working version, but keep playing.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence Efficient Algorithm Implementation in Python\r\n                \r\nI am trying to write an efficient 0(nlogn) algorithm for longest increasing subseuqnce:\n\n```\ndef whereToInsert(a, k):\n    l, r = 0, len(a)-1\n    while l<=r:\n        m = l + (r-l)//2\n        if a[m]==k:\n            return m\n        elif a[m]>k:\n            r = m - 1\n        else:\n            l = m + 1\n\n    if l==len(a)-1:\n        return l+1\n    else:\n        return l\n\n#print(whereToInsert([1,2,3,4,5,6,7,8,9], 0.5)) #This works fine\n\ndef lengthOfLISEfficient(nums):\n    lis = [nums[0]]\n    for x in nums[1:]:\n        t = whereToInsert(lis,x)\n        if t>=len(lis):\n            lis.append(0)\n        lis.insert(t, x)\n\n    return len(lis)\n\nprint(lengthOfLISEfficient([10,9,2,5,3,4]))\n```\n\n\nBut the answer returned is 7 whereas the logest increasing subsequence 2 3 4 is of length 3.\n\nThe algorithm is described at the end in https://leetcode.com/problems/longest-increasing-subsequence/.\n\nI am not getting why the answer is coming 7, my algorithm is following the correct logic.\n\nThanks for your help.\n    ", "Answer": "\r\nThere are a number of issues with your code. Firstly, in the method,\n\n```\ndef lengthOfLISEfficient(nums):\n```\n\n\nwhen you state:\n\n```\nlis = [nums[0]]\n```\n\n\nyou send only the first item of the list [10,9,2,5,3,4] to the method:\n\n```\ndef whereToInsert(a, k):\n```\n\n\nwhereas the latter method is meant to position a number within a list.\n\nHere is a different approach, which involves matching each sublist of the main list with a sorted version of that sublist:\n\n```\ndef lengthOfLISEfficient(nums):\n    #lis = [nums[0]]\n    lisList = []\n    for h in range(len(nums)-1):\n        lis = []\n        #numberNow = nums[h]\n        addableLength = len(nums) - h\n        #lis.append(numberNow)\n        for f in range(addableLength):\n            additem = nums[h+f]\n            lis.append(additem)\n        lisList.append(lis)\n    print(lisList)  #just for check, feel free to delete this line\n    subsequenceList = []\n    for list in lisList:\n        sortedList = list.copy()\n        sortedList.sort()\n        subsequence = []\n        for e in range(len(list)):\n            if len(subsequence) > 0:\n                if prev <= list[e] and sortedList.index(list[e]) == index+1:\n                    subsequence.append(list[e])\n                else:\n                    continue\n            else:\n                subsequence.append(list[0])\n            prev = list[e]\n            index = sortedList.index(prev)\n        subsequenceList.append(subsequence)\n    print(subsequenceList)  #just for check, feel free to delete this line\n    lengths = []\n    for l in range(len(subsequenceList)):\n        lengths.append(len(subsequenceList[l]))\n        if len(lengths) == len(subsequenceList):\n            longest = max(lengths)\n            longestSublist = subsequenceList[lengths.index(longest)]\n    return longest, longestSublist  # Don't return longestSublist if you do not want it\n\nprint(lengthOfLISEfficient([10,9,2,5,3,4]))\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Reducing Longest common subsequence to Longest increasing Subsequence\r\n                \r\nWe can reduce the Longest Common Subsequence problem to Longest Increasing Subsequence problem if at most one sequence has repetitions. The process of reducing the problem is explained here:\n\n\n  Suppose you have the sequences:\n\n```\nS1 = {D, B, A, C, E}\nS2 = {E, Z, X, D, A, Y, C}\n```\n\n  \n  Then, create a sequence of integers S3, where you have to put the position of each element of S2 in S1 (if the element doesn't exists in S1, then ignore that element). In the example:\n\n```\nS3 = {4, 0, 2, 3}\n// Z, X and Y in S2 where ignored\n```\n\n  \n  Then, just find the LIS in S3. To find the original elements, just use the integers in the LIS as indices of S1. For example, in this case the LIS of S3 is ```\n{0, 2, 3}```\n, where that represents the sequence ```\n{D, A, C}```\n.\n\n\nHow does this approach work? Why does this reduction solve the problem of finding the longest common subsequence?\n    ", "Answer": "\r\nGiven how you build S3, you are guaranteed that the elements of S3 point to \"only and all\" the common elements of S1 and S2.\n\nBy using the positions and finding the longest increasing subsequence you make sure that what you find will be a subsequence of the original S1 and S2 and not just the number of elements they have in common:\n\n\nIt will be a subsequence of S1 because the numerical value of the elements in S3 encode the positions in S1, so increasing subsequence of S3 = subsequence of S1\nIt will be a subsequence of S2 because the elements encoded in the elements of S3 are in the same order as the elements of S2, so subsequence of S3 = subsequence of S2\n\n\nTherefore, the longest increasing subsequence of S3 will \"encode\":\n\n\na subsequence of S1\na subsequence of S2\na sequence that contains only elements present in both S1 and S2\nthe longest of such subsequences\n\n\ni.e. the longest common subsequence between S1 and S2\n\nWhich you can \"decode\" by using the process described, i.e. take the elements of S1 with index = element of S3.\n\nNOTE: as pointed out in the link, this only works when at most one of the sequences has repetitions, and when building S3 you should take the sequence without repetitions as S1.\n\nThis seems like the inverse of the more common reduction of LIS to LCS.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "PHP longest increasing subsequence\r\n                \r\nSo there are answers on here that apply to C but I am trying to do this in PHP, AND in a particular way.\n\nI have an array of numbers like this : \n\n\n  7, 2, 6, 3, 10\n\n\nI want to find the longest increasing subsequence that happens FIRST in the order given.  So for example in this case I want the result to be:\n\n\n  2, 6, 10\n  \n  And NOT 2, 3, 10.\n\n\nWhat would be the best way to accomplish this ?\n    ", "Answer": "\r\nHere is my own solution to the longest increasing subsequence coding challenge, it passed all 10 test cases.\n```\n<?php \n\nfunction ArrayChallenge($arr) {\n\n  $newArr = [];\n  foreach ($arr as $key => $value) {\n    $temp = array_slice($arr, $key, count($arr)-$key);\n    //print_r($temp);\n    $newArr[$key][] = \"\";\n    for($i=0; $i<count($temp); $i++) {\n      if ($temp[$i] > $value && max($newArr[$key]) < $temp[$i]){\n        $newArr[$key][] = $temp[$i];\n      }\n    }\n  }\n  //print_r($newArr);\n  $result = 0;\n  foreach ($newArr as $item) {\n    if (count($item) > $result) $result = count($item);\n  }\n  return $result;\n\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to make this Longest Increasing Subsequence program return this subsequence\r\n                \r\nI have this code for Longest Increasing Subsequence. Right now it returns length of the longest increasing subsequence, but I don't know how to make it return this exact subsequence. For ex. in this case it should return [3,6,7,8,9]. Any ideas? I would appreciate not using very complicated syntax :D\n\n```\na = [3, 6, 7, 2, 1, 8, 9, 5]\nn = len(a)\nq = [0] * n\nfor k in range(n):\n    max = 0\n    for j in range(k):\n        if a[k] > a[j]:\n            if q[j] > max:\n                max = q[j]\n    q[k] = max + 1\nreturn(max(q))\n```\n\n\nouter loop iterates after all elements from a and inner loop checks if element k from table is greater than item from index 0 to k-1\nThanks to that q table for this example looks like this ```\n[1,2,3,1,1,4,5,2]```\n We can see that ```\nfirst element```\n makes ```\nsubsequence of length 1```\n, ```\nsecond```\n one makes ```\nsubsequence of length 2```\n (with first element), ```\nthird element```\n makes ```\nsubsequence of length 3```\n (with first and second elements), ```\nfourth element```\n makes ```\nsubsequence of length 1```\n because non of previous elements is smaller than it, and so on. So basically at each iteration it gets the length of the longest increasing subsequence ending at index k\n\nShorter version of the same program:\n\n```\nfor i in range(n):\n        for j in range(i):\n            if a[i] > a[j]:\n                q[i] = max(q[i], 1 + q[j])\n```\n\n    ", "Answer": "\r\nIt would have been great if you had described what your code was doing but as I understand at each iteration it gets the length of the longest increasing subsequence ending at index ```\nk```\n.\n\nTo trace back the actual indices in the array, just add another array ```\nprevious[]```\n.\n\nInitialize ```\nprevious = [-1] * n```\n.\n\nAnd then \n\n```\nif q[j] > max: \n   max = q[j]\n   previous[k] = j\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Why am I finding the longest increasing subsequence instead of the longest decreasing subsequence?\r\n                \r\nI'm trying to look for the longest decreasing subsequence in an array in O(nlogn). Not sure whether this really takes O(nlogn), but anyways this returns the length of the longest increasing subsequence instead of the longest decreasing subsequence. Can anyone help?!?\n\n```\ndef binary_search(L, l, r, key): \n    while (r - l > 1): \n        m = l + (r - l)//2\n        if (L[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n\ndef LongestDecreasingSubsequenceLength(L, size): \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 \n    tailTable[0] = L[0] \n    len = 1\n    for i in range(1, size): \n        if (L[i] < tailTable[0]): \n            # new smallest value \n            tailTable[0] = L[i] \n        elif (L[i] > tailTable[len-1]): \n            tailTable[len] = L[i] \n            len+= 1\n        else: \n            tailTable[binary_search(tailTable, -1, len-1, L[i])] = L[i]\n    return len\n\nL = [ 38, 20, 15, 30, 90, 14, 6, 7] \nn = len(L) \n\n\nprint(\"Length of Longest Decreasing Subsequence is \", \n   LongestDecreasingSubsequenceLength(L, n))\n```\n\n    ", "Answer": "\r\nIf you are open to any way of looking at it, Wikipedia has some pseudocode which transferred easily into Python and flipped for decreasing subsequence.\n\n```\nN = len(X)\nP = np.zeros(N, dtype=np.int)\nM =  np.zeros(N+1, dtype=np.int)\n\nL = 0\nfor i in range(0, N-1):\n    # Binary search for the largest positive j ≤ L\n    # such that X[M[j]] <= X[i]\n    lo = 1\n    hi = L\n    while lo <= hi:\n        mid = (lo+hi)//2\n\n        if X[M[mid]] >= X[i]:\n            lo = mid+1\n        else:\n            hi = mid-1\n    # After searching, lo is 1 greater than the\n    # length of the longest prefix of X[i]\n    newL = lo\n\n    # The predecessor of X[i] is the last index of \n    # the subsequence of length newL-1\n    P[i] = M[newL-1]\n    M[newL] = i\n    #print(i)\n    if newL > L:\n        # If we found a subsequence longer than any we've\n        # found yet, update L\n        L = newL\n\n# Reconstruct the longest increasing subsequence\nS = np.zeros(L, dtype=np.int)\nk = M[L]\nfor i in range(L-1, -1, -1):\n    S[i] = X[k]\n    k = P[k]\n\nS\n```\n\n\nWhich gives the sequence you are after\n\n```\narray([38, 20, 15, 14,  6])\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Error in Longest Increasing Subsequence in Python\r\n                \r\nI am trying to implement the Longest Increasing Subsequence in Python by refering the video here.\n\nI think I have done it correct. A Dry Run of the code also looks fine to me. But the output is incorrect.\n\n```\nd = [3, 2, 6, 4, 5, 1]\nl = []\nl.append([d[0]])\n\nfor i in range(1, len(d)):\n    l.append([])\n    for j in range(0, i):\n        if d[j] < d[i] and len(l[i]) < len(l[j]) + 1:\n            l[i] = l[j]\n    l[i].append(d[i])\n\nprint(l)\n```\n\n\nExpected Output: ```\n[[3], [2], [2, 6], [2, 4], [2, 4, 5], [1]]```\n\n\nActual Output: ```\n[[3], [2, 6, 4, 5], [2, 6, 4, 5], [2, 6, 4, 5], [2, 6, 4, 5], [1]]```\n\n\nAny Help Would Be Appreciated!\n    ", "Answer": "\r\nThis is just another referencing problem.\n\n```\nfor i in range(1, len(d)):\n    l.append([])\n    for j in range(0, i):\n        if d[j] < d[i] and len(l[i]) < len(l[j]) + 1:\n            l[i] = l[j]\n    l[i].append(d[i])\n```\n\n\nNote the line ```\nl[i] = l[j]```\n, that makes ```\nl[i]```\n the same list as ```\nl[j]```\n, so when you modify ```\nl[i]```\n later, ```\nl[j]```\n gets modified too. You probably want a copy here:\n\n```\nl[i] = l[j][:]\nl[i] = list(l[j])\nl[i] = l[j].copy()  # Python 3.3 or up\n```\n\n\nThese 3 lines are equivalent so pick one you like.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to print the actual Longest Increasing Subsequence, not just length\r\n                \r\nI am reviewing the GeeksforGeeks code for the Longest Increasing Subsequence and I am trying to figure out how to print the actual longest increasing subsequence, and not just the length.\n\nI know that I somehow need to store the indices of the maximum, and then print out the actual numbers from that array... I'm just having trouble implementing it.  \n\nThe code from the G4G website is as follows:\n\n```\n# Dynamic programming Python implementation of LIS problem\n\n# lis returns length of the longest increasing subsequence\n# in arr of size n\ndef lis(arr):\n    n = len(arr)\n\n    # Declare the list (array) for LIS and initialize LIS\n    # values for all indexes\n    lis = [1]*n\n\n    # Compute optimized LIS values in bottom up manner\n    for i in range (1 , n):\n        for j in range(0 , i):\n            if arr[i] > arr[j] and lis[i]< lis[j] + 1 :\n                lis[i] = lis[j]+1\n\n    # Initialize maximum to 0 to get the maximum of all\n    # LIS\n    maximum = 0\n\n    # Pick maximum of all LIS values\n    for i in range(n):\n        maximum = max(maximum , lis[i])\n\n    return maximum\n# end of lis function\n\n# Driver program to test above function\narr = [10, 22, 9, 33, 21, 50, 41, 60]\nprint \"Length of lis is\", lis(arr)\n# This code is contributed by Nikhil Kumar Singh\n```\n\n    ", "Answer": "\r\nAs you have pointed out, the indices of the LIS need to be stored as well.\n\nThis can be done by introducing an additional array ```\nprev```\n. In the original code, ```\nlis(n)```\n represents the length of the LIS ending at ```\nn```\n, and we have ```\nprev(n)```\n representing the index number immediately before ```\nn```\n in the LIS ending at ```\nn```\n (i.e. the second last index number of the LIS), if the LIS ending at ```\nn```\n is of length ```\n1```\n, we simply define ```\nprev(n) = n```\n.\n\nWhenever you update the value of ```\nlis(n)```\n, ```\nprev(n)```\n also needs to be updated accordingly. Please find the enhanced code below for your reference:\n\n```\n# Dynamic programming Python implementation of LIS problem\n\n# lis returns length of the longest increasing subsequence\n# in arr of size n\ndef lis(arr):\n    n = len(arr)\n\n    # Declare the list (array) for LIS and initialize LIS\n    # values for all indexes\n    lis = [1]*n\n\n    prev = [0]*n\n    for i in range(0, n):\n        prev[i] = i\n\n    # Compute optimized LIS values in bottom up manner\n    for i in range (1 , n):\n        for j in range(0 , i):\n            if arr[i] > arr[j] and lis[i]< lis[j] + 1:\n                lis[i] = lis[j]+1\n                prev[i] = j\n\n    # Initialize maximum to 0 to get the maximum of all\n    # LIS\n    maximum = 0\n    idx = 0\n\n    # Pick maximum of all LIS values\n    for i in range(n):\n        if maximum < lis[i]:\n            maximum = lis[i]\n            idx = i\n\n    seq = [arr[idx]]\n    while idx != prev[idx]:\n        idx = prev[idx]\n        seq.append(arr[idx])\n\n    return (maximum, reversed(seq))\n# end of lis function\n\n# Driver program to test above function\narr = [10, 22, 9, 33, 21, 50, 41, 60]\nans = lis(arr)\nprint \"Length of lis is\", ans[0]\nprint \"The longest sequence is\", \", \".join(str(x) for x in ans[1])\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to read this longest increasing subsequence recurrence relation\r\n                \r\ni'm practicing my recurrence relations. As a example problem, I am looking at the longest increasing subsequence (LIS) problem.\nGiven a list [3,1,4,1,5,9,2,6,5,3] find a longest increasing subsequence (could be [3,4,5,9] or [1,4,5,6])\nIn this problem, I am only concerned with finding the length of such a subsequence, not the actual sequence.\nThe algorithm I can roughly describe as follows:\n```\n 1: start at first element i, check if it contains a longest increasing subsequence.\n If it does, store a number corresponding to the length of that subsequence at that element in the sequence\n 2. Move one item ahead to item i, check if we can \"extend\" any of the already defined subsequences with element i (is element i larger than preceeding elements) by this item i. element i will extend the largest subsequence that it is able to.\n 3. keep moving i along until the end of the list.\n```\n\nFor further clarification on the algorithms one can follow these sources:\n```\n -https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/handouts/140%20Guide%20to%20Dynamic%20Programming.pdf\n - https://www.youtube.com/watch?v=fV-TF4OvZpk\n```\n\nHowever, what I am struggling with is the recurrence relation for this problem, which I have found in this form:\n\nThe base case makes perfect sense, if i is 0, then there can be no increasing subsequence.\nAlso the first argument \"1\" to the max() function makes perfect sense, if there is no preceeding item that is smaller than item i.\nWhat confuses me is the second argument to max(), which itself is a max() function, but only with one argument? I thought max() was a function that had to take multiplie parameters?\nI have tried rewriting this with a bit of prose, would this amount to the same thing?:\n\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Algorithm behind longest increasing subsequence\r\n                \r\nI need a walkthrough example to understand following algorithm. It is taken from Algorithms by Dasgupta. Here is the algorithm they give to find the longest increasing subsequence.\n\n```\n for j = 1, 2, . . . , n:\n     L(j) = 1 + max{L(i) : (i, j) ∈ E}\n return maxj L(j)\n```\n\n\nand here is the graph:\n\n\n\nI understand that L(j) represents the LIS ending at j; however, I don't understand the following: max{L(i) : (i, j) ∈ E}\n\nA walkthrough example is highly appreciated to understand how this loop will work. Thank you!\n    ", "Answer": "\r\nE is most likely defined before this pseudocode, it is a set of pairs ```\ni, j```\n such that ```\ni < j```\n and ```\nX_i < X_j```\n\n\nIt simply means length of LIS for all numbers left and smaller than the current one. Python code: \n\n```\nX = [5, 2, 8, 6, 3, 6, 9, 7]\nL = []\nfor current_value in X:\n    # the whole algorithm is in this line:\n    # take the LIS of a smaller preceding number and increase by one\n    L.append(1 + max((l for l, x in zip(L, X) if x<current_value), default=0))\nresult = L[-1]\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Debug Longest Increasing Subsequence- Ruby\r\n                \r\nI'm working on the following problem via Leetcode:\n\nGiven an unsorted array of integers, find the length of longest increasing subsequence.\n\n\n  For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest\n  increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n  Note that there may be more than one LIS combination, it is only\n  necessary for you to return the length.\n  \n  Your algorithm should run in O(n2) complexity.\n  \n  Follow up: Could you improve it to O(n log n) time complexity?\n\n\nTrying to implement the first, brute force solution, which essentially is a recursive way to generate every single increasing subsequence then grab the one with the biggest length. After I implement this, I'll use dynamic programming to optimize. I find myself getting confused a bit on the implementation of the brute force-- here's my code:\n\n```\ndef length_of_lis(nums)\n    1 + max_len(nums, 1, nums.first)\nend\n\ndef max_len(nums, index, prev_number)\n    current_num = nums[index]\n    max = 0 \n    return 0 if index >= nums.length     \n    if current_num > prev_number\n        max = [1 + max_len(nums, index + 1, current_num), max].max\n    else\n        max = [max_len(nums, index + 1, prev_number), max].max\n    end \n    max = [1 + max_len(nums, index + 1, current_num), max].max\n\n    max\nend\n```\n\n\nNow I know this is obviously incorrect, but what I was going for was that at each number, a couple things happen. Either 1) it's being passed a function from a previous number, and if this current number is greater than the previous number then continue that function for LIS. 2) Create a new LIS subsequence at the current number.\n\nAs you can tell, this creates two identical lines, and I'm not sure how to structure the code such that two separate things happen and the max variable contains the final value. Any ideas of how to adjust this code accordingly? \n    ", "Answer": "\r\nI've used dynamic programming to obtain an optimal solution. \n\nCode\n\n```\ndef construct_sequence(longest, max_i)\n  a = []\n  loop do\n    a << max_i\n    max_i = longest[max_i][:next]\n    return a if max_i.nil?\n  end\nend      \n\ndef longest_increasing_sequence(arr)\n  longest = Array.new(arr.size)\n  longest[arr.size-1] = { length: 1, next: nil }\n  (arr.size-2).downto(0) do |i|\n    best_seq = { length: 1, next: nil }\n    (i+1).upto(arr.size-1) do |j| \n      next if arr[j] <= arr[i]\n      h = longest[j]      \n      best_seq = { length: 1 + h[:length], next: j } if h[:length] >= best_seq[:length]\n    end\n    longest[i] = best_seq\n  end\n  max_i = (0..arr.size-1).max_by { |i| longest[i][:length] }\n  construct_sequence(longest, max_i)\nend\n```\n\n\nExample\n\n```\narr = [10, 9, 2, 5, 3, 7, 101, 18]\na = longest_increasing_sequence(arr)\n  #=> [2, 3, 5, 6] \na.each_with_object({}) { |n,h| h[n] = arr[n] }\n  #=> {2=>2, 3=>5, 5=>7, 6=>101}\n```\n\n\nFor a second example, I constructed the following 20-element pseudo-random array.\n\n```\narr = (1..99).to_a.sample(20)\n  #=> [80, 75, 13, 12, 85, 16, 41, 89, 93, 56, 74, 18, 37, 24, 27, 63, 47, 83, 25, 44]\n```\n\n\n```\nlongest_increasing_sequence```\n returns an array of indices of ```\narr```\n that constitute a longest increasing sequence.\n\n```\na = longest_increasing_sequence(arr)\n  #=> [2, 5, 11, 13, 14, 15, 17]\na.each_with_object({}) { |n,h| h[n] = arr[n] }\n  #=> {2=>13, 5=>16, 11=>18, 13=>24, 14=>27, 15=>63, 17=>83}\n```\n\n\nExplanation\n\nThere is one stage for each element of the array. The state variable is the index of the array where the longest increasing sequence (\"LIS\") begins. We begin with the last element of the array, which is ```\narr[19]```\n in the example above. If the increasing sequence (\"IS\") begins there it also ends there. The length of that sequence is ```\n1```\n.\n\nWe then move back to stage 18. There are two possibilities: the LS starting at that stage is of length ```\n1```\n, or continues at stage 19 (if the sequence is increasing), in which case it is of length ```\n2```\n.\n\nMore generally, if the LIS begins at index ```\ni```\n, it may end there or continue, with ```\nj```\n being the next index in the LIS, where ```\ni+1 <= j <= arr.size-1```\n and ```\narr[i] < arr[j]```\n. For any such ```\nj```\n we have already computed the LIS if the sequence begins at index ```\nj```\n, so we know that, from index ```\nj```\n, ```\ni```\n and ```\nj```\n share the same LIS if the next element of the LIS starting at ```\ni```\n is ```\nj```\n. Therefore, to obtain the LIS starting at ```\ni```\n we take the size of the largest LIS for ```\nj```\n between ```\ni+1```\n and ```\narr.size-1```\n for which ```\narr[i] < arr[j]```\n and add ```\n1```\n, unless there are no indices ```\nj```\n for which ```\narr[i] < arr[j]```\n, in which case the LIS for ```\ni```\n ends at ```\ni```\n.   \n\nThe dynamic programming solution rests on the Principle of Optimality, which here is the observation that if index ```\ni```\n is a member of an LIS, the collection of indices ```\nj, j > i```\n that are also members of that LIS does not depend on the indices ```\nj, j < i```\n that are members of that LIS. In other words, the optimal way forward from index ```\ni```\n does not depend on how we got there.\n\nTo show the details of the calculations I've added some puts statements to ```\nlongest_increasing_sequence```\n:\n\n```\ndef longest_increasing_sequence(arr)\n  longest = Array.new(arr.size)\n  longest[arr.size-1] = { length: 1, next: nil }\n  puts \"longest[#{arr.size-1}]=#{longest[arr.size-1]}\"\n  (arr.size-2).downto(0) do |i|\n    best_seq = { length: 1, next: nil }\n    puts \"i=#{i}\"\n    puts \"  initial best_seq=#{best_seq}\"\n    (i+1).upto(arr.size-1) do |j| \n      puts \"    j=#{j}, arr[#{i}]=#{arr[i]}, arr[#{j}]=#{arr[j]}\"   \n      next if arr[j] <= arr[i]\n      h = longest[j]      \n      puts \"    h=#{h}\"\n      puts \"    j=#{j} provides new best_seq=#{{length: 1 + h[:length], next: j }}\" if\n        h[:length] >= best_seq[:length]\n      best_seq = { length: 1 + h[:length], next: j } if h[:length] >= best_seq[:length]\n    end\n    longest[i] = best_seq\n  end\n  longest.each_index { |i| puts \"i=#{i}: #{longest[i]}\" }\n  max_i = (0..arr.size-1).max_by { |i| longest[i][:length] }\n  construct_sequence(longest, max_i)\nend\n```\n\n\n\n\n```\narr = [60, 29, 56, 46, 37, 57, 28, 44]\nlongest_increasing_sequence(arr)\n\nlongest[7]={:length=>1, :next=>nil}\ni=6\n  initial best_seq={:length=>1, :next=>nil}\n    j=7, arr[6]=28, arr[7]=44\n    h={:length=>1, :next=>nil}\n    j=7 provides new best_seq={:length=>2, :next=>7}\ni=5\n  initial best_seq={:length=>1, :next=>nil}\n    j=6, arr[5]=57, arr[6]=28\n    j=7, arr[5]=57, arr[7]=44\n```\n\n\n\n\n```\ni=4\n  initial best_seq={:length=>1, :next=>nil}\n    j=5, arr[4]=37, arr[5]=57\n    h={:length=>1, :next=>nil}\n    j=5 provides new best_seq={:length=>2, :next=>5}\n    j=6, arr[4]=37, arr[6]=28\n    j=7, arr[4]=37, arr[7]=44\n    h={:length=>1, :next=>nil}\ni=3\n  initial best_seq={:length=>1, :next=>nil}\n    j=4, arr[3]=46, arr[4]=37\n    j=5, arr[3]=46, arr[5]=57\n    h={:length=>1, :next=>nil}\n    j=5 provides new best_seq={:length=>2, :next=>5}\n    j=6, arr[3]=46, arr[6]=28\n    j=7, arr[3]=46, arr[7]=44\ni=2\n  initial best_seq={:length=>1, :next=>nil}\n    j=3, arr[2]=56, arr[3]=46\n    j=4, arr[2]=56, arr[4]=37\n    j=5, arr[2]=56, arr[5]=57\n    h={:length=>1, :next=>nil}\n    j=5 provides new best_seq={:length=>2, :next=>5}\n    j=6, arr[2]=56, arr[6]=28\n    j=7, arr[2]=56, arr[7]=44\n```\n\n\n\n\n```\ni=1\n  initial best_seq={:length=>1, :next=>nil}\n    j=2, arr[1]=29, arr[2]=56\n    h={:length=>2, :next=>5}\n    j=2 provides new best_seq={:length=>3, :next=>2}\n    j=3, arr[1]=29, arr[3]=46\n    h={:length=>2, :next=>5}\n    j=4, arr[1]=29, arr[4]=37\n    h={:length=>2, :next=>5}\n    j=5, arr[1]=29, arr[5]=57\n    h={:length=>1, :next=>nil}\n    j=6, arr[1]=29, arr[6]=28\n    j=7, arr[1]=29, arr[7]=44\n    h={:length=>1, :next=>nil}\ni=0\n  initial best_seq={:length=>1, :next=>nil}\n    j=1, arr[0]=60, arr[1]=29\n    j=2, arr[0]=60, arr[2]=56\n    j=3, arr[0]=60, arr[3]=46\n    j=4, arr[0]=60, arr[4]=37\n    j=5, arr[0]=60, arr[5]=57\n    j=6, arr[0]=60, arr[6]=28\n    j=7, arr[0]=60, arr[7]=44\ni=0: {:length=>1, :next=>nil}\ni=1: {:length=>3, :next=>2}\ni=2: {:length=>2, :next=>5}\ni=3: {:length=>2, :next=>5}\ni=4: {:length=>2, :next=>5}\ni=5: {:length=>1, :next=>nil}\ni=6: {:length=>2, :next=>7}\ni=7: {:length=>1, :next=>nil}\n  #=> [1, 2, 5] \n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Competitive Programmer’s Handbook, Longest increasing subsequence - explanation needed\r\n                \r\nI'm having hard time understanding a part of above mentioned topic.\n\nOur ﬁrst problem is to ﬁnd the longest increasing subsequence in an array of n elements. This is a maximum-length sequence of array elements that goes from left to right, and each element in the sequence is larger than the previous element. For example, in the array\n```\n{6,2,5,1,7,4,8,3} ```\n\nthe longest increasing subsequence contains 4 elements:\n2,5,7,8\n\n\nLet length(k) denote the length of the longest increasing subsequence that endsatposition k. Thus,if we calculate all values of length(k) where 0≤k≤n−1, we will ﬁnd out the length of the longest increasing subsequence. For example, the values of the function for the above array are as follows:\n```\nlength(0) = 1```\n\n```\nlength(1) = 1```\n\n```\nlength(2) = 2```\n\n```\nlength(3) = 1```\n\n```\nength(4) = 3```\n\n```\nlength(5) = 2```\n\n```\nlength(6) = 4```\n\n```\nlength(7) = 2```\n\n\nThe part that i don't understand is why if for some k, length(k) = c then why is it possible for some n>k to have\nlength(n)<length(k), the array that we choose does only extend in right direction, so I think the length(k) as k increases can't decrease because we are only getting new values\nWhat am I missing? Please help.\n    ", "Answer": "\r\n\nLet length(k) denote the length of the longest increasing subsequence\nthat ends at position k.\n\nSo, for example, length(3) = 1, because the value at that position is ```\n1```\n, so there are no any smaller numbers in the array to the left of it.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Prolog - Finding the longest increasing subsequence\r\n                \r\nI want to solve the following exercise in Prolog: \n\n\n  For a list of integers ```\nZs```\n, ```\nmax_sequence(Zs,Xs)```\n finds a longest increasing subsequence ```\nXs```\n.\n\n\nSample queries:\n\n\n?- max_sequence([1,2,1,2,3,4,2,1,2,1],Xs).\nXs = [1,2,3,4].                                     % expected result\n\n?- max_sequence([1,2,1,2,3,4,2,1,6,7,7,2,1,8],Xs).\nXs = [1,2,3,4,6,7,8].                               % expected result\n\n\nI can't understand why... but my code is wrong, the result is always ```\nfalse```\n.\n\n```\nmax_sequence(L,R) :-\n    cresc(L,[],R).\n\ncresc([],[],[]).\ncresc([H|T],C,[H|C]) :-\n    maxList(H,C),\n    \\+ member(H,C),\n    cresc(T,C,C).\ncresc([H|T],C,C) :-\n    member(H,C),\n    cresc(T,C,C).       \ncresc([H|T],C,C) :-\n    \\+ maxList(H,C),\n    cresc(T,C,C).   \n\nmaxList(_,[]).\nmaxList(N, [H|T]) :-\n    N>H,\n    maxList(N,T).\n```\n\n\nI would like to know if my approach to the problem is correct.\nThanks for any help!\n    ", "Answer": "\r\nTL;DR: Solve problems on a high-level: Think idiomatically; and don't reinvent the wheel :)\n\n\n\nUse clpfd!\n\n```\n:- use_module(library(clpfd)).\n```\n\n\nWe proceed by taking the following two steps:\n\n\nWe start by using the meta-predicate  ```\nsplitlistIfAdj/3```\n together with ```\n(#>=)/3```\n:\n\n```\n?- splitlistIfAdj(#>=,[1,2,2,2,1,2,3,4,2,1,3,5,7,1],Zss).\nZss = [[1,2],[2],[2],[1,2,3,4],[2],[1,3,5,7],[1]].\n```\n\nWe are only interested in sublists of maximum size. ```\nmax_of_by/3```\n can exclude all other ones:\n\n```\n?- max_of_by(Xs,[[1,2],[2],[2],[1,2,3,4],[2],[1,3,5,7],[1]],length).\n  Xs = [1,2,3,4]\n; Xs = [1,3,5,7].\n```\n\n\n\nThat's it! Let's put it together and define ```\nlist_longest_ascending_sublist/2```\n:\n\n```\nlist_longest_ascending_sublist(Xs,Zs) :-\n   splitlistAdjIf(#>=,Xs,Yss),\n   max_of_by(Zs,Yss,length).\n```\n\n\nSample queries:\n\n\n?- list_longest_ascending_sublist([1,2,2,2,1,2,3,4,2,1,3,5,7,1],Zs).\n  Zs = [1,2,3,4]\n; Zs = [1,3,5,7].\n\n?- list_longest_ascending_sublist([1,2,2,3,4,5,6,2,1,2,3,4,2,1,3,5,7,1],Zs).\nZs = [2,3,4,5,6].\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find the longest increasing subsequence of a list in C\r\n                \r\nI'm having problems trying to find the elements that form the Longest Increasing Subsequence of a given list.\n\nI have the algorithm to find the value of a given item of the list, and I understand the method it uses, I just don't know what to add and where to add it so that I have the numbers that compose the L.I.S.\n\nHere is what I'm doing now: \n\n```\nfor (A[0] = N[0], i=lis=1; i<n; i++) {\n    int *l = lower_bound(A, A+lis, N[i]);\n    lis = max(lis, (l-A)+1);\n    *l = N[i];\n}\n```\n\n\n```\nA```\n is an array that stores the partial L.I.S., but at some point it changes because there may be a different solution. ```\nN```\n is the array of elements.\n\nHow can I get from here to finding the longest increasing subsequence of ```\nN```\n?\n    ", "Answer": "\r\nYou can use two additional array to find the LIS. For example, if your source is put in an array A\n\n```\n1  8  4  12  6  6  1\n```\n\n\nand we have an array B to store the elements of A which are more likely to be elements of LIS. More precisely, B will be maintained as an LIS at position i.\nPlus an array idx to record the positions.\n\nWe begin from A[0], place A[0] at B[0]. Since A[0] is appended at position 0 in B, idx[0] = 0.\n\n```\n      [0]  1   2   3   4   5   6\n\n A  |  1   8   4  12   6   6   1\n B  | (1)\nidx |  0\n```\n\n\nThen for position 1, since element in B is smaller than A[1], A[1] is appended to B. idx[1] records the position in B which is 1.\n\n```\n       0  [1]  2   3   4   5   6\n\n A  |  1   8   4  12   6   6   1\n B  |  1  (8)\nidx |  0   1\n```\n\n\nFor position 2, A[2], or 4, is more likely to be an element of LIS compared to elements in B in order to maintain B as an LIS. So find the element in B which is the smallest one no less than 4 and replace, which is 8. idx[2] is set to the position where 8 is replaced in B. I think you can use your searching algorithm to find such an element.\n\n```\n       0   1  [2]  3   4   5   6\n\n A  |  1   8   4  12   6   6   1\n B  |  1  (4)\nidx |  0   1   1\n```\n\n\nSo continue this manner, we gradually set up idx.\n\n```\nposition 3\n       0   1   2  [3]  4   5   6\n\n A  |  1   8   4  12   6   6   1\n B  |  1   4 (12)\nidx |  0   1   1   2\n\nposition 4\n       0   1   2   3  [4]  5   6\n\n A  |  1   8   4  12   6   6   1\n B  |  1   4  (6)\nidx |  0   1   1   2   2\n\nposition 5\n       0   1   2   3   4  [5]  6\n\n A  |  1   8   4  12   6   6   1\n B  |  1   4  (6)\nidx |  0   1   1   2   2   2\n\nposition 6\n       0   1   2   3   4   5  [6]\n\n A  |  1   8   4  12   6   6   1\n B  | (1)  4   6\nidx |  0   1   1   2   2   2   0\n```\n\n\nWe have idx recorded positions, now we scan idx backwards and will find out the LIS.\n\n```\n       0   1   2   3   4   5   6\n\n A  |  1   8   4  12   6   6   1\nidx |  0   1   1   2   2  (2)  0    | 6\n\n       0   1   2   3   4   5   6\n\n A  |  1   8   4  12   6   6   1\nidx |  0   1  (1)  2   2   2   0    | 4  6\n\n       0   1   2   3   4   5   6\n\n A  |  1   8   4  12   6   6   1\nidx | (0)  1   1   2   2   2   0    | 1  4  6\n```\n\n\nHence, the output LIS is {1, 4, 6}\n\nThe code and A = {1, 8, 4, 12, 6, 6, 1} as source\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\n#define INT_INF 10000\n\nint search_replace(int *lis, int left, int right, int key) {\n        int mid;\n\n        for (mid = (left+right)/2; left <= right; mid = (left+right)/2) {\n                if (lis[mid] > key) {\n                        right = mid - 1;\n                } else if (lis[mid] == key) {\n                        return mid;\n                } else if (mid+1 <= right && lis[mid+1] >= key) {\n                        lis[mid+1] = key;\n                        return mid+1;\n                } else {\n                        left = mid + 1;\n                }\n        }\n        if (mid == left) {\n                lis[mid] = key;\n                return mid;\n        }\n        lis[mid+1] = key;\n        return mid+1;\n}\n\nint main(void) {\n        int i, tmp, size = 7, lis_length = -1; \n        int *answer;\n        int A[7] = {1,8,4,12,6,6,1},\n            LIS[7],\n            index[7] = {0};\n\n        LIS[0] = A[0];\n        for (i = 1; i < size; ++i) {\n                LIS[i] = INT_INF;\n        }\n\n        for (i = 1; i < size; ++i) {\n                index[i] = search_replace(LIS, 0, i, A[i]);\n                if (lis_length < index[i]) {\n                        lis_length = index[i];\n                }\n        }\n\n        answer = (int*) malloc((lis_length+1) * sizeof(int));\n        for (i = size-1, tmp = lis_length; i >= 0; --i) {\n                if (index[i] == tmp) {\n                        answer[tmp] = A[i];\n                        --tmp;\n                }\n        }\n\n        printf(\"LIS: \");\n        for (i = 0; i < lis_length+1; ++i) {\n                printf(\"%d \", answer[i]);\n        }\n        printf(\"\\n\");\n\n        return 0;\n}\n```\n\n\nAnd the output of the code\n\n```\nLIS: 1 4 6\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to find the longest increasing subsequence without sorting?\r\n                \r\nI want to find the longest increasing subsequence without sorting it, and to then sum the numbers of the period, for example like :\n```\n12, 15, 16, 4, 7, 10, 20,25\n```\n\n\n```\n12,15,16```\n is an increasing subsequence.\n```\n4,7,10,20```\n is another increasing subsequence.\n\nbut since ```\n4,7,10,20,25```\n are ```\n5```\n elements and ```\n12,15,16```\n are ```\n3```\n which is less than the ```\n4```\n, the output should be the sum of the longer period which is the sum of the ```\n5```\n elements, ```\n66```\n.\nHow could such a thing be done using c?\nI am new to C so this is all what I could think of.\n```\n#include<stdio.h>\n int main() {\n int count = 0;\n int n;\n int max = 0;\n scanf(\"%d\", &n);\n int arr[1000];\n for(int i = 0;i<n;i++){\n  if(arr[i+1>arr[i])\n   count++;\n   if(count>max)\n    max = count;\n}\n```\n\n    ", "Answer": "\r\nYou really need two loops.\nOne that iterates through all elements. This is the \"starting\" index of a sequence.\nThen, an inner loop that starts at one element to the right of the start. It loops to the end of the array but stops if it sees the current element is out of sequence.\nAfter the second loop ends, the difference of these two indexes is the sequence length.\n\nHere is some refactored code. It is annotated:\n```\n#include <stdio.h>\n\nint arr[] = { 17, 18, 19, 5, 6, 23, 24, 25, 24, 25, 17, 18, 19 };\n\n// show -- print a sequence\nvoid\nshow(int begidx,int count,const char *tag)\n{\n\n    printf(\"%s: %d %d --\",tag,begidx,count);\n\n    for (;  count > 0;  --count, ++begidx)\n        printf(\" %d\",arr[begidx]);\n\n    printf(\"\\n\");\n}\n\n// sum -- get sum of the sequence\nint\nsum(int begidx,int count)\n{\n    int sum = 0;\n\n    for (;  count > 0;  --count, ++begidx)\n        sum += arr[begidx];\n\n    return sum;\n}\n\nint\nmain(void)\n{\n\n    int count = sizeof(arr) / sizeof(arr[0]);\n    int maxlen = 0;\n    int maxidx = -1;\n\n    show(0,count,\"ORIG\");\n\n    // loop through all possible starting points for sequence\n    for (int ilhs = 0;  ilhs < count;  ++ilhs) {\n        int lval = arr[ilhs];\n\n        // loop through all numbers to the right of the starter\n        // stop at the array end or when we get a number that is out of sequence\n        int irhs;\n        for (irhs = ilhs + 1;  irhs < count;  ++irhs) {\n            int rval = arr[irhs];\n\n            // out of sequence -- we've hit the end\n            if (rval < lval)\n                break;\n\n            lval = rval;\n        }\n\n        // get length of the sequence we just saw\n        int curlen = irhs - ilhs;\n\n        // remember a larger sequence\n        if (curlen > maxlen) {\n            maxlen = curlen;\n            maxidx = ilhs;\n            show(maxidx,maxlen,\"NEW\");\n        }\n    }\n\n    // show the maximum sequence\n    show(maxidx,maxlen,\"FINAL\");\n\n    // sum the sequence\n    printf(\"SUM: %d\\n\",sum(maxidx,maxlen));\n\n    return 0;\n}\n```\n\n\nHere is the program output:\n```\nORIG: 0 13 -- 17 18 19 5 6 23 24 25 24 25 17 18 19\nNEW: 0 3 -- 17 18 19\nNEW: 3 5 -- 5 6 23 24 25\nFINAL: 3 5 -- 5 6 23 24 25\nSUM: 83\n```\n\n\nUPDATE:\nA [considerable] speedup for the above is to change:\n```\nfor (int ilhs = 0;  ilhs < count;  ++ilhs) {\n```\n\nInto:\n```\nfor (int ilhs = 0;  ilhs < count;  ilhs = irhs) {\n```\n\nAnd, move the ```\nint irhs;```\n above the outer loop.\nThis reduces the time from O(n^2) to O(n)\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to make a call of this recursive Longest Increasing Subsequence function\r\n                \r\nI'm learning about recursion. I have taken as an example the algorithm LIS (Longest increasing subsequence) which given an array:\n\n```\n1,2,8,3,6,4,9,5,7,10\n```\n\n\nFind the longest increasing subsequence that would be:\n\n```\n1,2,3,4,5,7,10\n```\n\n\nTo start with an idea of the operation I was searching on google and I found that function:\n\n```\npublic static void printLis (int [] lis, int lisIndex, int [] arr, int max) {\n    if (max == 0) {\n        return;\n    }\n    if (lis [lisIndex] == max) {\n        printLis (lis, lisIndex-1, arr, max-1);\n        System.out.print (arr [lisIndex] + \"\");\n    } else {\n        printLis (lis, lisIndex-1, arr, max);\n    }\n}\n```\n\n\nHow do I call that function in my example, so that I get the indicated results?\n    ", "Answer": "\r\nAbove code is not for calculating LIS. Its for printing the LIS elements. Also the snippet contains syntax error.\n\nHere is a better recursive solution in Java with explanation.\n\n```\nclass LIS {\n\n    static int max_lis_length = 0; // stores the final LIS\n    static List<Integer> maxArray = new ArrayList<>();\n\n    // Recursive implementation for calculating the LIS\n    static List<Integer> _lis(int arr[], int indx)\n    {\n        // base case\n        if (indx == 0) {\n            max_lis_length = 1;\n            return new ArrayList<>(Arrays.asList(arr[indx]));\n        }\n\n        int current_lis_length = 1;\n        List<Integer> currList = new ArrayList<>();\n        for (int i=0; i< indx; i++)\n        {\n            // Recursively calculate the length of the LIS ending at arr[i]\n            List<Integer> subproblemList = _lis(arr, i);\n            int subproblem_lis_length = subproblemList.size();\n\n            // Check if appending arr[indx] to the LIS ending at arr[i] gives us an LIS ending at \n            // arr[indx] which is longer than the previously\n            // calculated LIS ending at arr[indx]\n            if (arr[i] < arr[indx] && current_lis_length < (1 + subproblem_lis_length)) {\n                current_lis_length = 1 + subproblem_lis_length;\n                currList = subproblemList;\n            }\n        }\n        currList.add(arr[indx]);\n\n        // Check if currently calculated LIS ending at\n        // arr[n-1] is longer than the previously calculated\n        // LIS and update max_lis_length accordingly\n        if (max_lis_length < current_lis_length) {\n            max_lis_length = current_lis_length;\n            maxArray = currList;\n        }\n\n        return currList;\n    }\n\n    // The wrapper function for _lis()\n    static int lis(int arr[], int n)\n    {    \n        // max_lis_length is declared static above \n        // so that it can maintain its value\n        // between the recursive calls of _lis()\n        List<Integer> r = _lis( arr, n );\n        System.out.println(r);\n\n        return max_lis_length;\n    }\n\n    // Driver program to test the functions above\n    public static void main(String args[]) {        \n        int arr[] = {10, 22, 9, 33, 21, 50, 41, 60};\n        int n = arr.length;\n        System.out.println(lis( arr, n - 1));\n\n\n    }\n};\n```\n\n\nOutput\n\n```\n[10, 22, 33, 50, 60]\n5\n```\n\n\nComplexity\n\nThe corresponding tree due to this recursion is like this - \n\n```\n              lis(4)\n        /        |     \\\n      lis(3)    lis(2)   lis(1)\n     /   \\        /\n   lis(2) lis(1) lis(1)\n   /\nlis(1)\n```\n\n\nThe time complexity is exponential. There will be ```\n2^n - 1```\n nodes will be generated for a ```\nn```\n sized array. Plus the space complexity is significant too as we are copying sub-problem's list in function argument. TO overcome this, dynamic programming is used.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "(LIS) Longest Increasing Subsequence Algorithm\r\n                \r\nEDIT\n\nFinally, I found this \"Brute force\" method is not right.\nSo I write another two methods to solve the LIS problem.\n\n\nUsing LCS on the original array and the sorted array. Time complexity = (n^2).\nUsing DP + Binary search. Time complexity = O(nlgn).\n\n\n[The code is at the end.]\n\n\nI try to use brute force to find Longest Increasing Subsequence (LIS).\nBut personally I think the time complexity of this algorithm is O(n2), which is equal to the DP approach, is it correct?\n\n```\n// Find LIS Brute force.\npublic static int[] findLIS_BF (int[] givenArray) {\n    int size = givenArray.length;\n    int maxLen = Integer.MIN_VALUE;\n    int prevIndex = 0;\n    int tempLen = 1;\n    int head = 0;\n    for (int tempHead = 0; tempHead < size; tempHead ++) {\n        prevIndex = tempHead;\n        tempLen = 1;\n        for (int subPointer = tempHead + 1; subPointer < size; subPointer ++) {\n            if (givenArray[prevIndex] <= givenArray[subPointer]) {\n                prevIndex = subPointer;\n                tempLen ++;\n            }\n        }\n        if (tempLen > maxLen) {\n            maxLen = tempLen;\n            head = tempHead;\n        }\n    }\n\n    System.out.println(\"LIS by BF, max len = \" + maxLen);\n    int[] rest = new int[maxLen];\n    int restIndex = 0;\n    rest[restIndex] = givenArray[head];\n    restIndex ++;\n    prevIndex = head;\n    for (int i = head + 1; i < size; i ++) {\n        if (givenArray[prevIndex] <= givenArray[i]) {\n            rest[restIndex] = givenArray[i];\n            restIndex ++;\n            prevIndex = i;\n        }\n    }\n    return rest;\n}\n```\n\n\n\n[EDIT]\n[LCS Method]\n\n```\npublic class FindLIS_LCS {\n\n// Find LIS by LCS.\n// Time complexity = O(n^2).\n// LCS.\n// Time complexity = O(n^2).\n// Note:\n// UP LEFT MARK = -1.\n// UP MARK = -2.\n// LEFT MARK = -3.\nprivate static int LCS (int[] firstA, int[] secondA, int[][]c, int[][]b) {\n    int lenFA = firstA.length;\n    int lenSA = secondA.length;\n\n    // Init c matrix.\n    for (int i = 0; i < lenFA; i ++) c[i][0] = 0;\n    for (int i = 0; i < lenSA; i ++) c[0][i] = 0;\n\n    for (int i = 1; i < lenFA+1; i ++) {\n        for (int j = 1; j < lenSA+1; j ++) {\n            if (firstA[i - 1] == secondA[j - 1]) {\n                c[i][j] = c[i - 1][j - 1] + 1;\n                b[i - 1][j - 1] = -1;\n            } else if (c[i - 1][j] >= c[i][j - 1]) {\n                c[i][j] = c[i - 1][j];\n                b[i - 1][j - 1] = -2;\n            } else {\n                c[i][j] = c[i][j - 1];\n                b[i - 1][j - 1] = -3;\n            }\n        }\n    }\n    return c[lenFA][lenSA];\n}\n\n// Print out the LCS.\n// Time complexity = O(m + n).\nprivate static void printLCS_Helper (int[] firstA, int[][]b, int i, int j) {\n    if (i < 0 || j < 0) return; // Base case.\n    if (b[i][j] == -1) {\n        printLCS_Helper(firstA, b, i - 1, j - 1);\n        System.out.print(String.format(\"%-6d\", firstA[i]));\n    } else if (b[i][j] == -2) printLCS_Helper(firstA, b, i - 1, j);\n    else printLCS_Helper(firstA, b, i, j - 1);\n}\npublic static void printLCS (int[] firstA, int[][]b) {\n    int size = firstA.length;\n    printLCS_Helper(firstA, b, size - 1, size - 1);\n}\n\n// Quick sort for array.\n// Time complexity = O(nlgn).\nprivate static void exchange (int[] givenArray, int firstIndex, int secondIndex) {\n    int temp = givenArray[firstIndex];\n    givenArray[firstIndex] = givenArray[secondIndex];\n    givenArray[secondIndex] = temp;\n}\nprivate static int partition (int[] givenArray, int start, int end, int pivotIndex) {\n    int pivot = givenArray[pivotIndex];\n    int left = start;\n    int right = end;\n    while (left <= right) {\n        while (givenArray[left] < pivot) left ++;\n        while (givenArray[right] > pivot) right --;\n        if (left <= right) {\n            exchange(givenArray, left, right);\n            left ++;\n            right --;\n        }\n    }\n    return left;\n}\nprivate static void quickSortFromMinToMax_Helper (int[] givenArray, int start, int end) {\n    if (start >= end) return; // Base case.\n    // Generate a random num in the range[start, end] as the pivot index to partition the array.\n    int rand = start + (int) (Math.random() * ((end - start) + 1));\n    int split = partition (givenArray, start, end, rand);\n    // Do recursion.\n    quickSortFromMinToMax_Helper(givenArray, start, split - 1);\n    quickSortFromMinToMax_Helper(givenArray, split, end);\n}\npublic static void quickSortFromMinToMax (int[] givenArray) {\n    int size = givenArray.length;\n    quickSortFromMinToMax_Helper(givenArray, 0, size - 1);\n}\n\n// Copy array.\npublic static int[] copyArray (int [] givenArray) {\n    int size = givenArray.length;\n    int[] newArr = new int[size];\n    for (int i = 0; i < size; i ++) \n        newArr[i] = givenArray[i];\n    return newArr;\n}\n\n// Main method to test.\npublic static void main (String[] args) {\n    // Test data: {1, 2, 1, 4, 5, 3, 10}.\n    //int[] givenArray = {1, 2, 1, 4, 5, 3, 10};\n    int[] givenArray = {2, 1, 6, 3, 5, 4, 8, 7, 9};\n    int size = givenArray.length;\n    // Test finding LIS by LCS approach.\n    int[] sortedArr = copyArray(givenArray);\n    quickSortFromMinToMax (sortedArr);\n    int[][]c = new int[size + 1][size + 1];\n    int[][]b = new int[size][size];\n    System.out.println(\"Test max len = \" + LCS(givenArray, sortedArr, c, b));\n    printLCS(givenArray, b);\n}\n}\n```\n\n\n[DP + Binary Search Method]\n\n```\npublic class FindLIS {\n\n// Linear search.\npublic static int linearSearch (int[] givenArray, int key) {\n    int size = givenArray.length;\n    for (int i = size - 1; i >= 0; i --) {\n        if (givenArray[i] >= 0) \n            if (givenArray[i] < key) return i;\n    }\n    return -1;\n}\n\n// Find the len of the LIS.(Longest increasing (non-necessarily-adjacent) subsequence).\n// DP + Binary search.\n// Time complexity = O(nlgn).\n// Note:\n// This binary search to find the elem's index of the given array, which is less than the elem's value = key.\nprivate static int biSearch (int[] givenArray, int start, int end, int key) {\n    if (start > end) return -1;\n    int mid = (start + end) / 2;\n    if (givenArray[mid] <= key) return mid;\n    else return biSearch(givenArray, start, mid - 1, key);\n}\n\npublic static int findLISLen (int[] givenArray) {\n    int size = givenArray.length;\n    int maxLen = 1;\n    int[] memo = new int[size];\n    for (int i = 0; i < size; i ++) memo[i] = -10;\n    memo[0] = givenArray[0];\n\n    for (int i = 1; i < size; i ++) {\n        if (givenArray[i] > memo[maxLen - 1]) {\n            memo[maxLen] = givenArray[i];\n            maxLen ++;\n        } else {\n            // int pos = linearSearch(memo, givenArray[i]); // Using linear search, the time complexity = O(n^2).\n            int pos = biSearch(memo, 0, maxLen - 1, givenArray[i]); // Using Binary search, the time complexity = O(nlgn).\n            memo[pos + 1] = givenArray[i];\n        }\n    }\n    // Show memo.\n    showArray(memo);\n    return maxLen;\n}\n\n\n// Show array.\npublic static void showArray (int[] givenArray) {\n    int size = givenArray.length;\n    for (int i = 0; i < size; i ++) \n        System.out.print(String.format(\"%-6d\", givenArray[i]));\n    System.out.println();\n}\n\n// Main method to test.\npublic static void main (String[] args) {\n    // Test data: {2, 1, 6, 3, 5, 4, 8, 7, 9}.\n    //int[] givenArray = {2, 1, 6, 3, 5, 4, 8, 7, 9};\n    //int[] givenArray = {1, 2, 1, 4, 5, 3, 10};\n    int[] givenArray = {2, 1, 6, 3, 5, 4, 8, 7, 9};\n\n    // Test finding the LIS by DP + Binary search.\n    System.out.println(\"Test finding the LIS by DP + Binary search, max len = \" + findLISLen(givenArray));\n\n}\n}\n```\n\n    ", "Answer": "\r\nYes your approach and both DP approach are of complexity O(n^2). For O(nlogn) algorithm refer here It also gives implementation.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Another approach for finding longest increasing subsequence\r\n                \r\nI am aware that there are many algorithms for finding longest increasing subsequence, but the algorithms using DP all have this is common - they recurse/ dynimacally calculate longest subsequence \"ENDING\" at a particular element of the array. \n\nI wrote a solution which resurses taking longest subsequence \"starting\" at a particular array, which seems to work fine too.\n\n```\n#include<iostream>\nusing namespace std;\n#define boostio ios_base::sync_with_stdio(0);\n\nint n;\nint a[100000];\nint t[100000] = {-1};\n\nint lis(int i){\n\n    if(t[i]!= -1){\n        return t[i];\n    }   \n\n    if(i == n){t[i] = 1; return 1;\n    }\n\n    for (int x = i+1; x <= n ; ++x)\n    {\n        if(a[x] > a[i] and 1 + lis(x) > t[i]){\n            t[i] = 1 + lis(x);\n            //return t[i];\n        }\n\n\n    }\n\n    if(t[i] != -1){\n            return t[i];\n        }\n\n    t[i] = 1; return 1;\n\n\n\n}\nint main(){\n    boostio;\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> a[i];\n    }\n\n    fill(t, t + n+2 ,-1);\n\n    Int m = 0;\n\n    for (int i = 1; i <= n; ++i)\n    {\n        //cout << i << \" \" << lis(i) << endl;\n        if(lis(i) >m) m= lis(i);\n    }\n\n    cout << m;\n\n    return 0;\n}\n```\n\n\nI am wondering, is this in any way worse than if we recurse on \"last element\" of subsequence instead of the first. They both appear to be order n square algorithms to me, so why isnt this algorithm more circulated. To me it seems more intuitive. Am I missing something?\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Determine which items in an array are part of longest increasing subsequence(s)\r\n                \r\nThis is a variant of the longest increasing subsequence problem. Suppose that, instead of wanting to find a sequence or counting how many sequences there are, you wanted to identify items that can be part of some longest increasing sequence.\n\nFor example, in the list ```\n1,2,4,3,0,5```\n all items except the zero can be part of a longest increasing subsequence.\n\nWhat is a strategy to find these items? How efficiently can it be done?\n    ", "Answer": "\r\nOne method is to use the same dynamic algorithm as in the longest increasing subsequence problem, keeping track of the best item to precede the ```\ni```\n'th item assuming it was the last item, but tweak it to keep track of ties. Then, after the best preceding items are known for every item, determine which items are reachable via that graph when starting from the top scoring items.\n\nIn the case of the example, ```\n1,2,4,3,0,5```\n, it would work like this:\n\n\n```\n1```\n is at index 0, so give it a lis score of 1 with no previous index\n```\n2```\n can be preceded by ```\n1```\n, so ```\n2```\n gets a lis score of 1+1=2 and a previous index of 0\n```\n4```\n can be preceded by ```\n2```\n and ```\n1```\n, but ```\n2```\n has a better lis score so ```\n4```\n gets a lis score of 2+1=3 and a previous index of 1\n```\n3```\n can be also preceded by ```\n2```\n and ```\n1```\n, and again ```\n2```\n has a better lis score so ```\n3```\n gets a lis score of 2+1=3 and a previous index of 1\n```\n0```\n can't be preceded by anything, so it gets a lis score of 1 with no previous index    \n```\n5```\n can be preceded by any of the other items, but ```\n3```\n and ```\n4```\n have the best lis scores (=3) so ```\n5```\n gets a lis score of 3+1=4 with previous indexes of 2 or 3.\n\n\nNow we take the top scoring items, just ```\n5```\n in this case, and iteratively search backwards for items that can precede it. This will mark ```\n5```\n, ```\n3```\n, ```\n4```\n, ```\n2```\n and ```\n1```\n (but not ```\n0```\n) as can-be-in-longest-sequence.\n\nThis definitely runs in ```\nO(n^2)```\n time, and I think by being clever it can be made to work in ```\nO(n lg n)```\n time.\n\nThe main challenge for going from quadratic time is not making an explicit graph with 'can optimally precede' edges. A list like ```\n1,1,1,1,1,1,...,2,2,2,2,2,2,...```\n has a quadratic number of edges, so you need to avoid storing them all or exploring them all.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find the length of the longest increasing subsequence\r\n                \r\nI've written some code in C that, given a sequence, should find the length of the longest increasing subsequence. However it always returns the length 4 when this is incorrect.\n\nHere is my code so far:\n\n```\nint LIS(int* seq, int* temp_seq, int seq_size)  \n{int i, j;\n\nfor(i=0; i<seq_size; i++);\n{ \n  temp_seq[i]=0; \n}\n  for(i=1; i<seq_size; i++);\n  { \n     for(j=1; j<seq_size; j++)\n     { \n       if (seq[i]<temp_seq[j])\n       seq[i]=temp_seq[j];\n\n       else if (seq[i]>temp_seq[j]) \n       seq[i]=temp_seq[j+1];\n     } \n  }\n return(sizeof temp_seq);\n}\n```\n\n\nWhat am I doing wrong?\n\nAlso I should note that the sequence lists all integers from 1 to n with no repeated numbers. \n    ", "Answer": "\r\n\nReturning wrong value. ```\nreturn(sizeof temp_seq);```\n is a constant, the size of the pointer  ```\ntemp_seq```\n.  @eurythmia\nThe ```\n;```\n after ```\nfor(i=0; i<seq_size; i++);```\n is certainly not needed as that completes the loop.  Same for ```\nfor(i=1; i<seq_size; i++);```\n.\nThe value of ```\nseq[0]```\n is never tested nor saved in ```\ntemp_seq```\n.\nPossible access passed end of array with ```\nseq[i]=temp_seq[j+1];```\n\nCode appears  to want to clear ```\ntemp_seq[]```\n and then set all ```\nseq[]```\n with ```\ntemp_seq[]```\n.\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing subsequence length in NlogN.[Understanding the Algo]\r\n                \r\nProblem Statement: Aim is to find the longest increasing subsequence(not contiguous) in nlogn time.\n\nAlgorithm: I understood the algorithm as explained here :\nhttp://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/.\n\nWhat i did not understand is what is getting stored in tail in the following code.\n\n```\nint LongestIncreasingSubsequenceLength(std::vector<int> &v) {\nif (v.size() == 0)\n    return 0;\n\nstd::vector<int> tail(v.size(), 0);\nint length = 1; // always points empty slot in tail\n\ntail[0] = v[0];\nfor (size_t i = 1; i < v.size(); i++) {\n    if (v[i] < tail[0])\n        // new smallest value\n        tail[0] = v[i];\n    else if (v[i] > tail[length-1])\n        // v[i] extends largest subsequence\n        tail[length++] = v[i];\n    else\n        // v[i] will become end candidate of an existing subsequence or\n        // Throw away larger elements in all LIS, to make room for upcoming grater elements than v[i]\n        // (and also, v[i] would have already appeared in one of LIS, identify the location and replace it)\n        tail[CeilIndex(tail, -1, length-1, v[i])] = v[i];\n}\n\nreturn length;\n}\n```\n\n\nFor example ,if input is {2,5,3,,11,8,10,13,6},\nthe code gives correct length as 6.\nBut tail will be storing 2,3,6,8,10,13.\n\nSo I want to understand what is stored in tail?.This will help me in understanding correctness of this algo.\n    ", "Answer": "\r\n```\ntail[i]```\n is the minimal end value of the increasing subsequence (IS) of length ```\ni+1```\n. \n\nThat's why ```\ntail[0]```\n is the 'smallest value' and why we can increase the value of LIS (```\nlength++```\n) when the current value is bigger than end value of the current longest sequence.\n\nLet's assume that your example is the starting values of the input:  \n\ninput = 2, 5, 3, 7, 11, 8, 10, 13, 6, ...  \n\nAfter ```\n9```\n steps of our algorithm ```\ntail```\n looks like this:\ntail = 2, 3, 6, 8, 10, 13, ...\n\nWhat does ```\ntail[2]```\n means? It means that the best IS of length ```\n3```\n ends with ```\ntail[2]```\n. And we could build an IS of length ```\n4```\n expanding it with the number that is bigger than ```\ntail[2]```\n. \n\n```\ntail[0] = 2```\n, ```\nIS length = 1```\n:  2, 5, 3, 7, 11, 8, 10, 13, 6\n```\ntail[1] = 3```\n, ```\nIS length = 2```\n:  2, 5, 3, 7, 11, 8, 10, 13, 6\n```\ntail[2] = 6```\n, ```\nIS length = 3```\n:  2, 5, 3, 7, 11, 8, 10, 13, 6\n```\ntail[3] = 8```\n, ```\nIS length = 4```\n:  2, 5, 3, 7, 11, 8, 10, 13, 6\n```\ntail[4] = 10```\n,```\nIS length = 5```\n:  2, 5, 3, 7, 11, 8, 10, 13, 6\n```\ntail[5] = 13```\n,```\nIS length = 6```\n:  2, 5, 3, 7, 11, 8, 10, 13, 6  \n\nThis presentation allows you to use binary search (note that defined part of ```\ntail```\n is always sorted) to update ```\ntail```\n and to find the result at the end of the algorithm.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Iterative solution to finding Longest Increasing Subsequence using Python\r\n                \r\nI am trying to implement an iterative solution for Longest Increasing Subsequence using bisect. My implementation is failing at some point. Help me fix it.\n\nImplementation:\n\n```\nfrom bisect import bisect\n\ndef lis_iterative(seq):\n    buff = []\n    for n in seq:\n        i = bisect(buff, n)\n        if i == len(buff):\n            buff.append(n)\n        else:\n            buff[i] = n\n    return buff\n\ndef main():\n    seq = [43, 25, 6, 37, 27, 26, 7, 24, 457, 5, 22, 72]\n    print lis_iterative(seq)\n\nmain()\n```\n\n\nExpected Output:\n\n```\n[6, 7, 24, 457]\n```\n\n\nGenerated Output:\n\n```\n[5, 7, 22, 72]\n```\n\n    ", "Answer": "\r\nYour current algorithm doesn't seem to make much sense, as noted in BrenBarn's comment.  Here is what I came up with:\n\n```\ndef lis_iterative(seq):\n    n = len(seq)\n    dp = [(0, -1)]*n\n    # dp contains (best, idx) tuples, where best is the length of the longest\n    # increasing sequence starting from that element, and idx is the index of the\n    # next element in that sequence\n    for i in range(n-1, -1, -1):\n        best = 0\n        idx = -1\n        for j in range(i+1, n):\n            if seq[i] < seq[j] and dp[j][0] + 1 > best:\n                best = dp[j][0] + 1\n                idx = j\n        dp[i] = (best, idx)\n\n    # find longest increasing sequence from dp, then follow idx chain for result\n    result = []\n    idx = max(range(n), key=lambda i: dp[i][0])\n    while idx != -1:\n        result.append(seq[idx])\n        _, idx = dp[idx]\n    return result\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence - LeetCode 300\r\n                \r\nReferring to the question: Longest Increasing Subsequence\nHere is my code with recursion that works but is too slow as it is not doing memoization:\n```\nclass Solution {\npublic static int recurse(int prev, int curr, int[]nums) {\n    if(curr == nums.length) return 0;\n\n    int elect=0;\n    int ignore=0;\n    if(prev==-1 || nums[prev]<nums[curr]) {\n        elect = 1 + recurse(curr,curr+1,nums);\n    }\n    ignore = recurse(prev,curr+1,nums);\n    return Math.max(elect,ignore);\n}\npublic int lengthOfLIS(int[] nums) {\n    return recurse(-1,0,nums);\n}\n```\n\nThe function ```\nlengthOfLIS```\n invokes my recursion as ```\nrecurse(-1,0,nums)```\n\nThe thing I am struggling for hours is that I want to use a 1 dimensional array that stores cached result for the sub-array for memoization. For example my ```\ndp```\n array if I were to create one of size ```\nnums.length```\n should be 1d. Is that possible? My attempts have failed and I get incorrect results. Here is the incorrect code\n(Note that this snippet does not show the init code for dp array)\n```\n    public static int recurse3(int prev, int curr, int nums[]) {\n    if(curr == nums.length) return 0;\n    if(dp2[curr]!=-1) return dp2[curr];\n    int op1 = 0;\n    if(prev==-1 || nums[curr]>nums[prev]) {\n        op1 = 1+recurse3(curr, curr+1, nums);\n    }\n    int op2=recurse3(prev,curr+1,nums);\n    dp2[curr] = Math.max(op1,op2);\n    return Math.max(op1,op2);\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing SubSequence using Binary Search\r\n                \r\nI am trying to implement The Longest Increasing SubSequence using Binary Search. Well I have coded the algorithm and my test cases are getting satisfied but when I submit the code,it is failing for some test cases like for example for the following list,\n\n29471 5242 21175 28931 2889 7275 19159 21773 1325 6901, the answer should be 4 but I am getting 5.Below is my code,\n\n```\nimport java.util.Scanner;\n\npublic class LongestIncreasingSubSequence {\n\n    public static int BS(int[] arr,int low,int high,int key){\n\n        int mid;\n\n        while ((high - low) > 1) {\n\n            mid = (int) Math.ceil((low + high) / 2);\n\n            if (arr[mid] >= key) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        return high;\n    }\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n;\n        n = sc.nextInt();\n        int arr[] = new int[n];\n        int LS[] = new int[arr.length];\n        int count = 1;\n\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n        LS[0] = arr[0];\n\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] < LS[0]) {\n                LS[0] = arr[i];\n            } else if (arr[i] > LS[count-1]) {\n                LS[count++] = arr[i];\n            } else {\n                LS[BS(arr,0,count-1,arr[i])] = arr[i];\n            }\n        }\n        System.out.println(count);\n    }\n}\n```\n\n\nSo can anyone please tell me where I am going wrong.Thanks in advance.\n    ", "Answer": "\r\nThere is a bug here:\n```\nLS[BS(arr,0,count-1,arr[i])] = arr[i];```\nshould be\n```\nLS[BS(LS,0,count-1,arr[i])] = arr[i];```\n instead, because we need to update the array with the smallest value for each length of an increasing sub sequence (that is, ```\nLS```\n), not the original one. \nWith this change, it works properly on your test case (I haven't tested it on anything else, but the algorithm looks correct to me now). \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "The number of increasing subsequences using \"The longest increasing subsequence algorithm (nlgn)\"\r\n                \r\nFor reference: I'm solving the nested dolls problem: http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2353\n\nI have written the portion to find the longest increasing subsequence (the nlgn version). For example if the sequence is the following: 1 2 3 1 2 1\n\n\nI find the largest subsequence: \"1 2 3\" and I remove it from the\noriginal sequence. The sequence becomes 1 2 1.\nI find the largest subsequence: \"1 2\" and I remove it again. The sequence becomes 1.\nI find the largest subsequence: \"1\" and I remove it. The sequence becomes empty.\n\n\nSo the answer is 3, 3 total increasing subsequences\n\nMy problem is that I'm getting TLE (time limit) and I need a better way of counting the subsequences. There is a hint about using \"Dilworth's theorem\" but I'm not sure how to apply it. \n    ", "Answer": "\r\nAlgorithm\n\nIf I understand the question correctly, you are trying to find the minimum number of nested dolls that can pack every doll, and your algorithm is to greedily make the biggest doll at each stage (biggest in the sense that it contains the most pieces) and repeat until all dolls are packed.\n\nIn other words, you are constructing chains from your partially ordered set.\n\nDilworth's theorem says:\n\n\n  the maximum number of elements in any antichain equals the minimum\n  number of chains in any partition of the set into chains\n\n\nand so you can compute the number of chains by counting the elements inside a single antichain.\n\nYou can construct the antichain in a very similar way to you are doing at the moment, by ordering the dolls by width in decreasing order and then finding the longest increasing subsequence within the heights.\n\nNote, that with this method you get the answer by measuring the length of the anti-chain and you only need to run the longest increasing subsequence algorithm once so it should be a lot faster.\n\nExample\n\nIn your example of  (1, 1), (1, 1), (2, 2), (3, 3), (1, 1), (2, 2), (1, 1) we first sort by width in decreasing order:\n\n```\n(3, 3), \n(2, 2), \n(2, 2), \n(1, 1), \n(1, 1), \n(1, 1), \n(1, 1)\n```\n\n\nand then extract the heights:\n\n```\n3,2,2,1,1,1,1\n```\n\n\nthen find the longest increasing subsequence (note that each element must be the same or higher than the previous so strictly speaking you find the longest non-decreasing subsequence):\n\n```\n1,1,1,1\n```\n\n\nthis is of length 4, so the answer is 4.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "LeetCode longest Increasing Subsequence\r\n                \r\nI am working on the following leetcode problem:\n\nGiven an integer array nums, return the length of the longest strictly increasing subsequence.\n\nThe solution given is O(N^2) time but I have the following solution that does not work in it's current state:\n\r\n\r\n```\n   def lengthOfLIS(self, nums: List[int]) -> int:\n        dp = [-1 for i in range(len(nums))]\n        dp[0] = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                if i >= 2:\n                    if dp[i] > dp[i-2]:\n                        dp[i] = max(dp[i-1], dp[i-2], 0) + 1\n                    else:\n                        dp[i] = dp[i-1] + 1\n                else:\n                    dp[i] = dp[i-1] + 1\n            else:\n                dp[i] = 1\n        return max(dp)```\n\r\n\r\n\r\n\nI am trying to get a  O(N) solution (if it is possible but I am not sure!). My logic is as follows to choose dp[i] by either deleting an element if needed or picking it otherwise. Is it possible to fix my approach or should I bin it altoghether?\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence in a 2D matrix.\r\n                \r\nI am solving a programming challenge to find the length of longest increasing subsequence in a 2D NxN matrix. Both row and columns must increase in each element of a sequence (no need to be consecutive) . I solved it with Dynamic programming approach but it is O(N^4) and inefficient. However, there are many solutions in O(N^3). One such solution is:\n\n```\n   scanf(\"%d\", &N);\n    for(i = 1; i <= N; i++) {\n        for(j = 1; j <= N; j++) {\n            scanf(\"%d\", &L[i][j]);\n        }\n    }\n    Answer = 0; \n\n    memset(maxLength,0,sizeof(maxLength));\n    for (i=1;i<=N;i++) \n    {\n        maxLength[1][i] = 1;\n        maxLength[i][1] = 1;\n    }\n\n    //\n    for (i=2;i<=N;i++)\n    {\n\n        memset(minValue,0,sizeof(minValue));\n        curLen = 1;\n        minValue[1] = L[i-1][1]; \n\n        for (j=2;j<=N;j++)  \n        {\n            for (p=1;p<i;p++)\n            {\n                tmpLen = maxLength[p][j-1];\n                if (minValue[tmpLen] == 0)\n                {\n                    minValue[tmpLen] = L[p][j-1]; \n                    curLen = tmpLen;\n                }\n                else if (minValue[tmpLen]>L[p][j-1])\n                {\n                    minValue[tmpLen] = L[p][j-1];\n                }\n            }\n\n\n            max = 1;\n            for (p=curLen;p>0;p--)\n            {\n                if (L[i][j]>=minValue[p])\n                {\n                    max = p+1;\n                    break;\n                }\n            }\n\n            maxLength[i][j] = max;\n            Answer = Answer>max?Answer:max;\n        }\n    }\n\n    // Print the answer to standard output(screen).\n    printf(\"%d\\n\", Answer);\n```\n\n\nCan someone explain how it works or any other O(N^3) approach ? i can't follow it at all :(.\n    ", "Answer": "\r\nIt's not that difficult to solve this in O(n3) time. I didn't read the source code, however, so I don't know if the following is what it did, but here is an idea of how it could be done.\n\nThe trick is in the update procedure. I guess what you originally did is the following. \n\n\n\nSay you are considering an element in the orange rectangle. The previous step has to originate from the blue rectangle (which you already solved). This yields a correct answer, but it's easy to see that it will yield a Θ(n4) result, as you can make both the orange and blue rectangles Θ(n2), and you need to consider all pairs between them. (It's easy to formalize this.)\n\nInstead, start by solving only the first row and the first column. In fact, in each iteration, take the next unsolved row and column, and solve them from the previously solved parts. \n\n\n\nHere's the trick (which I'll leave to you). If you store enough information in the cells (or in auxiliary data structures, it doesn't matter), then for each element in the orange column you're considering, you only need to look at the column to the left of it (ditto for the orange row - you only need to look at elements in the row above it).\n\nSo there are O(n) outer iterations (in each one you consider a row and a column). Each such row/column has O(n) elements, and each left/up row/column has O(n) elements two. The multiplication gives your target complexity.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Building bridges problem - how to apply longest increasing subsequence?\r\n                \r\nThe building bridges problem is stated as follows:\n\nThere is a river that runs horizontally through an area.  There are a set of cities above and below the river.  Each city above the river is matched with a city below the river, and you are given this matching as a set of pairs.\nYou are interested in building a set of bridges across the river to connect the largest number of the matching pairs of cities, but you must do so in a way that no two bridges intersect one another.\nDevise an algorithm to solve this problem as efficiently as possible.\n\nI have heard that this problem is related to the longest increasing subsequence problem, but I don't see how to use it here.  For example, if we're given the pairs\n```\n2  5  8  10\n6  4  1  2\n```\n\nThen which sequence do we consider for LIS?\nThanks!\n    ", "Answer": "\r\nTo build up to how you'd use the longest increasing subsequence algorithm to solve this problem, let's start off with some intuition and then build up to a solution.  Since you can only build bridges between cities at matching indices, you can think of the set of bridges that you end up building as the largest set of pairs you can find that don't contain any crossing.  So under what circumstance would you have a crossing?\n\nLet's see when this can happen.  Suppose that we sort all of the bridges built by their first city.  If two bridges cross, then we must have that there is some bridge (ai, bi) such that for some other bridge (aj, bj) one of the following holds:\n\n\nai < aj and bi > bj\nai > aj and bi < bj\n\n\nThis first case says that there is a bridge whose top city is further to the right than the start of our bridge and whose bottom city is further to the left than the end of our bridge, and the second case handles the opposite case.\n\nGiven that this property needs to hold, we need to ensure that for every set of bridges, we have that exactly one of the two following properties holds for any pair of bridges (ai, bi), (aj, bj): either\n\n\nai ≤ aj and bi ≤ bj\n\n\nor\n\n\nai ≥ aj and bi ≥ bj\n\n\nIn other words, if we were to sort the bridges by their first coordinate, the set of second coordinates would always be increasing.  Similarly, if we were to sort the bridges by their second coordiante, the first coordinate would always be increasing.\n\nThe property that we've just defined defines a partial ordering ≤both on the set of bridges, where we say that (ai, bi) ≤both (aj, bj) if ai ≤ aj and bi ≤ bj.  Notice that this is not a total ordering - for example, (1, 2) is incomparable with (2, 1) - but it is a partial ordering because it is reflexive, antisymmetric, and transitive.\n\nGiven this, the goal of the problem is to find the largest set of elements that we can that can be totally ordered by this relationship, since if we have a set containing two incomparable elements those elements must necessarily represent crossing bridges.  In other words, we want to find the longest chain in the partial order.  One way to do this is to, in O(n2) time, compare each element to each other element and see which elements can be ordered by ≤both.  This produces a directed acyclic graph, where the pair (ai, bi) has an edge to (aj, bj) iff (ai, bi) ≤both (aj, bj).  Once we have this directed acyclic graph, we can then find the longest path in the graph to find the largest set of elements that are call comparable by ≤both, which then gives the solution to the problem.  The overall runtime is thus O(n2).\n\nHowever, we can do substantially better than this.  The problem with the above algorithm is that we can't easily tell how the elements compare against one another, so we have to explicitly compare each city against each other city.\n\n```\n2  5  8 10\n6  4  1  2 \n```\n\n\nLet's sort the cities by the bottom row:\n\n```\n8 10  5  2\n1  2  4  6\n```\n\n\nNow, here's the really cool observation.  If we have the elements sorted by their bottom row, then we can tell if two pairs are orderable by ≤both by looking at their positions in the top row.  If the first pair is to the left of the second pair, we immediately know that the second elements of the first pair is less than the second element of the second pair, since we've sorted them by the second coordinate.  We then have that the pair of elements can be built together iff the first element of the first pair is less than the first element of the second pair.  Consequently, if we want to find a set of bridges that can be built together, we're looking for an increasing subsequence of the top row, since in that case both the first and second elements of the pairs are increasing as we move from the left to the right.  Finding the longest increasing subsequence then solves this problem.  Since we can sort the pairs by their second field in O(n log n) and find the longest increasing subsequence in O(n log n), this is an O(n log n) solution to the problem!\n\nWhew!  Hope that this answer explains things in detail!\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Constrained Longest Increasing Subsequence\r\n                \r\nConsider an array, which has ```\nN```\n integers. Now we are given with an index ```\ni```\n, which can take up values from ```\n1```\n through ```\nN```\n. This particular index should always be present in the LIS that we generate. Calculate the LIS for each value at ```\ni```\n. \n\nHow can we solve the above problem efficiently? My straightforward solution is to vary the index ```\ni```\n for all of its values and calculate LIS. The time complexity goes up to O(N2log(N)). Can it be beaten? \n\nExample:\n\nN = 2. i = 1\n\nSay the given array is [1,2]. \n\n```\n[1,2]```\n or ```\n[2, 2]```\n \n\nThe longest (strictly) increasing subsequence in each case is ```\n2```\n and ```\n1```\n. \n    ", "Answer": "\r\nThe canonical dynamic program for LIS computes, for each ```\nk```\n, the longest increasing subsequence of the elements at index ```\n1..k```\n that includes the element at index ```\nk```\n. Using this data and the mirror image data for longest increasing subsequences of ```\nk..n```\n, we find the LIS that includes index ```\nk```\n as the union of the longest before ```\nk```\n and the longest after ```\nk```\n.\n\nO(n log n)\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence after rearranging k subarrays\r\n                \r\nI require a way to find an increasing subsequence of a given array which consists of distinct natural numbers from 1 to n in some random manner, after rearranging exactly k subarrays(continuous elements). But elements within the subarray cannot be arranged. In a special case, if the array is sorted, you could leave it as it is.\n\nI'm thinking of applying Longest Increasing Subsequence algo on (n-k+1) elements and arrange the remaining accordingly but it would be very far from being close to correct answer.\n\nI'm not asking you to code but any reasonable explanation would be helpful to begin with.\n\nThanks in advance!\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "finding all possible longest increasing subsequence using recursion\r\n                \r\nI tried to find all possible longest increasing subsequence using recursion. When I tried an input array ```\n{10,22,9,33,21,50,41,40,60,55}```\n, it worked and the output was:\n\n```\n10 22 33 40 55 /\n10 22 33 41 55 /\n10 22 33 50 55 /\n10 22 33 40 60 /\n10 22 33 41 60 /\n10 22 33 50 60 /\n```\n\n\nBut when I tried an input array ```\n{2,-3,4,90,-2,-1,-10,-9,-8}```\n, I got an output:\n\n```\n-3 4 90 /\n-3 -2 -1 /\n-10 -9 -8 /\n```\n\n\nIn this case I didn't get ```\n2 4 90```\n. What should I change in my code to make it word for this case?\n\n```\npublic class Main {\n    public static void main(String[] args) {\n        int arr[]={10,22,9,33,21,50,41,40,60,55};\n        int lis[]=new int[arr.length];\n        for(int i=0;i<arr.length;i++){\n            lis[i]=1;\n        }\n        for(int i=1;i<arr.length;i++){\n            for(int j=0;j<i;j++){\n                if(arr[i]>arr[j]&&lis[i]<lis[j]+1){\n                    lis[i]=lis[j]+1;\n                }\n            }\n        }\n        int max=0;\n        for(int i=0;i<arr.length;i++){\n            if(max<lis[i])\n                max=lis[i];\n        }\n        //**************Recursive Print LIS****************\n        int rIndex=-1;\n        for(int i=arr.length-1;i>=0;i--){\n            if(lis[i]==max){\n                 rIndex=i;\n                 break;\n            }\n        }\n        int res[]=new int[max];\n        printLISRecursive(arr,rIndex,lis,res,max,max);\n    }\n\n    private static void printLISRecursive(int[] arr, int maxIndex, int[] lis, int[] res, int i, int max) {\n        if(maxIndex<0)return;\n        if(max==1&&lis[maxIndex]==1&&i==1){\n            res[i-1]=arr[maxIndex];\n//            System.out.println(\"Using Print Recursion:\");\n            for(int j=0;j<res.length;j++){\n                System.out.print(res[j]+\" \");\n            }\n            System.out.println();\n            return;\n        }\n        if(lis[maxIndex]==max){\n            res[i-1]=arr[maxIndex];\n            printLISRecursive(arr, maxIndex-1, lis, res, i-1, max-1);\n        }\n        printLISRecursive(arr, maxIndex-1, lis, res, i, max);\n    }\n\n}\n```\n\n    ", "Answer": "\r\n```\npublic static String  lcs(String  a, String  b){\n    int aLen = a.length();\n    int bLen = b.length();\n    if(aLen == 0 || bLen == 0){\n        return \"\";\n    }else if(a.charAt(aLen-1) == b.charAt(bLen-1)){\n        return lcs(a.substring(0,aLen-1),b.substring(0,bLen-1))\n            + a.charAt(aLen-1);\n    }else{\n        String  x = lcs(a, b.substring(0,bLen-1));\n        String  y = lcs(a.substring(0,aLen-1), b);\n        return (x.length() > y.length()) ? x : y;\n    }\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Issues with Longest Increasing Subsequence - Naive Approach\r\n                \r\nI was learning the fundamentals of dynamic programming and came over to the question of finding the Longest Increasing Subsequence in an array. Before looking up the DP solution, I decided to code it myself and came up with the following algorithm, the complete code to which can be found here.\n\nThe idea is to create a List Array to store all the increasing subsequences, and store the corresponding max value of each subsequence for faster comparisons.\n\n```\nprivate void findLIS(int[] inputArr) {\n    List[] listOfSubs = new ArrayList[inputArr.length];    //Max different subsequences in an array would be N\n    //To store the max value of each of the subsequences found yet\n    List<Integer> maxValList = new ArrayList<Integer>();\n    listOfSubs[0] = new ArrayList<Integer>();\n    listOfSubs[0].add(inputArr[0]);    //Add the first element of the array to the list\n    maxValList.add(inputArr[0]);\n\n    for (int i=1;i<inputArr.length;i++) {\n        boolean flag = false;\n        int iter=0;\n\n        //Compare inputArr[i] with the maxVal of each subsequence\n        for (int j=0; j<maxValList.size(); j++) {\n            if (inputArr[i]>maxValList.get(j)) {\n                maxValList.set(j, inputArr[i]); //Update the maxVal in the corresponding position in the list\n                listOfSubs[j].add(inputArr[i]);\n                flag = true;\n            }\n            iter = j;\n        }\n        //If inputArr[i] is not greater than any previous values add it to a new list\n        if (!flag) {\n            maxValList.add(inputArr[i]);\n            listOfSubs[iter+1] = new ArrayList<Integer>();\n            listOfSubs[iter+1].add(inputArr[i]);\n        }\n    }\n\n    //Finding the maximum length subsequence among all the subsequences\n    int max=0, iter=0, index=0;\n    for (List<Integer> lst : listOfSubs) {\n        if (lst!=null && lst.size() > max) {\n            max = lst.size();\n            index=iter;\n        }\n        iter++;\n    }\n\n    //Print the longest increasing subsequence found\n    System.out.println(\"The Longest Increasing Subsequence is of length \" + listOfSubs[index].size() +\n            \" and is as follows:\");\n    for (int i=0;i<listOfSubs[index].size();i++) {\n        System.out.print(listOfSubs[index].get(i) + \" \");\n    }\n}\n```\n\n\nThe code runs in O(n^2) time and works perfectly for small/medium sized inputs. However, when I try running the code against some of the online practice portals (like HackerRank), I get both TLE (Time Limit Exceeded Errors) and Wrong Answer. I understand the TLE errors, as the efficient solution is a DP O(nlogn) solution, but I'm confused about the wrong answers generated by this algorithm. Since, the inputs for such cases are too big (~10000), I'm unable to manually verify the where the solution goes wrong.\n\nThe complete code plus the output to one of the data sets can be found here. The correct answer should be 195 as reported by HackerRank.\n    ", "Answer": "\r\nI found the problem with my solution. The problem is because of not reading the problem statement carefully. \n\nSay we consider the input as {3, 2, 6, 4, 5, 1}. I only consider the sequences {3,6} and {2,6} in my code, but not sequences {2,4,5} or {3,4,5}. Thus, at every iteration if I find a number greater than the max of the previous subsequences, I add it to all such subsequences thereby diminishing the possibility of reaching the latter subsequences.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence. Where is the error?\r\n                \r\nI have been studying up of a tehnical interview and was doing DP problems. I came across the Longest Increasing Subsequence problem and i went straight into doing some recursion. I came up with this solution which I thought to be pretty straight forward, but it is showing some errors. However i cant understand where they might be. I read some of the discussed solutions and I understand how they work, but i cant understand where the mistake is on my part. Any help could be great!\n\nHere's my solution.\n\n```\n\n    public static int lengthOfLIS(int[] nums) {\n    return lengthOfLIS(nums, 0, 0, 0);\n  }\n\n  public static int lengthOfLIS(int[] nums, int carry, int index, int max){\n    if(nums.length == 0){\n      return 0;\n    }\n    if(index == nums.length - 1){\n      return carry;\n    }\n//Checks if nums[index] is bigger than the max which is the last item to be checked.\n    int temp_carry = carry;\n    if(nums[index] > max){\n      temp_carry++;\n      max = nums[index];\n    }\n\n//Here i iterate through all the values starting from index and at the same time, \n//start a recursive call from zeroes to the next digit, and ask them to return the max between both calls.\n    for(int i = index; i<nums.length; i++){\n      max = Math.max(lengthOfLIS(nums, temp_carry, index+1, max), lengthOfLIS(nums, 0, index+1, nums[index+1]));\n    }\n    return max;\n  }```\n\n\n```\n\n    ", "Answer": "\r\nSo you have a couple of problems. \n\nFirstly ... \n\n\n  ```\nif(index == nums.length - 1) { return carry; }```\n\n\n\nThis is going to effectively ignore your last value in the array. If your last value is greater that ```\nmax```\n then your are not going to be increment ```\ncarry```\n, so you will always potentially short your length count by 1.\n\nThe next problem is your ```\nfor```\n loop... \n\n\n```\nfor(int i = index; i<nums.length; i++){\n  max = Math.max(lengthOfLIS(nums, temp_carry, index+1, max), lengthOfLIS(nums, 0, index+1, nums[index+1]));\n}\n```\n\n\n\nHonestly not really sure what you are trying to achieve here as it's actually quite confusing. The bigger issue is that you are completely ignoring ```\ni```\n, which means that regardless of the number of runs of your loop, the values being passed to ```\nlengthOfLIS```\n are going to be exactly the same for each loop iteration. Also, if you ever managed to hit the condition ```\nif(index == nums.length - 1)```\n then you ```\nreturn carry```\n, which means you are going to perform the you ```\nMath.max```\n function on the returned ```\ncarry```\n value, but this is quite different from what you are using ```\nmax```\n for, as you are using ```\nmax```\n to denote the current maximum number at the end of your LIS. So all of a sudden your ```\nmax```\n becomes your ```\ncarry```\n, which just causes some mental back-flips. \n\nThe point of the Longest Increasing Subsequence (LIS) problem is to find the length of the longest sub-sequence of a given sequence such that all elements of the sub-sequence are sorted in increasing order, meaning that the LIS of { 10, 22, 9, 33, 21, 50, 41, 60 } is { 10, 22, 33, 50, 60 } (length = 5)\n\nTry this...\n\n```\npublic int lengthOfLIS(int[] nums) {\n    return lengthOfLIS(nums, 0, 0, -1);\n}\n\npublic int lengthOfLIS(int[] nums, int carry, int index, int max){\n    if(nums.length == 0){\n        return 0;\n    }\n\n    if(nums[index] > max) {\n        carry++;\n        max = nums[index];\n    }\n\n    int max_carry = carry;\n    for (int i = index; i < (nums.length - 1); i++) {\n        int temp_carry = lengthOfLIS(nums, carry, i + 1, max);\n        if (temp_carry > max_carry) {\n          max_carry = temp_carry;\n        }\n    }\n    return max_carry;\n}\n```\n\n\nAlso just notice that the initial call ```\nlengthOfLIS(nums, 0, 0, -1)```\n has a ```\n-1```\n this is because your sequence could start with a zero ... { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}, of which the LIS is { 0, 2, 6, 9, 11, 15 } (length = 6).\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "C# Collections vs Arrays: Longest Increasing Subsequence Benefits\r\n                \r\nWhat's the performance penalty that I can expect if I'm using Lists over Arrays to solve the Longest Increasing Subsequence? \n\nWill the dynamic nature of Lists improve average performance because we're not dealing with sizes we won't actually use?\n\nPS: Any tips on improving performance while still maintaining some readability?\n\n```\n   public static int Run(int[] nums)\n    {\n        var length = nums.Length;\n\n        List<List<int>> candidates = new List<List<int>>();\n\n        candidates.Add(new List<int> { nums[0] });\n\n        for (int i = 1; i < length; i++)\n        {\n            var valueFromArray = nums[i];\n\n            var potentialReplacements = candidates.Where(t => t[t.Count-1] > valueFromArray);\n\n            foreach (var collection in potentialReplacements)\n            {\n                var collectionCount = collection.Count;\n\n                if ((collection.Count > 1 && collection[collectionCount - 2] < valueFromArray) || (collectionCount == 1))\n                {\n                    collection.RemoveAt(collectionCount - 1);\n                    collection.Add(valueFromArray);\n                }\n            }\n\n            if (!candidates.Any(t => t[t.Count - 1] >= valueFromArray))\n            {\n                var newList = new List<int>();\n\n                foreach(var value in candidates[candidates.Count - 1])\n                {\n                    newList.Add(value);\n                }\n\n                newList.Add(nums[i]);\n                candidates.Add(newList);\n            }\n        }\n\n        return candidates[candidates.Count - 1].Count;\n    }\n```\n\n    ", "Answer": "\r\nDepending on the solution the results may vary. Arrays are faster when compared with lists of the same size. How more fast? Lets take a look at the c# solution below. This is a simple O(n^2) solution. I coded a version with arrays only and another one with lists only. I'm running it 1000 times and recording the values for both. Then I just print the average improvement of the array version over the list version. I'm getting over 50% improvement on my computer.\nNotice that this solution uses arrays and lists with the same sizes always. Than means I never created an array bigger than the size the lists are gonna grow to in the lists version. Once you start creating arrays with a Max size that may not be filled the comparison stops to be fair.\nC# code below:\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace hashExample\n{\n    class Program\n    {\n        static int RunArray(int[] array)\n        {\n            int[] dp = new int[array.Length];\n            dp[0] = 1;\n            for (int i = 1; i < array.Length; i++)\n            {\n                dp[i] = 1;\n                for (int j = 0; j < i; j++)\n                    if (array[i] > array[j] && dp[i] < dp[j] + 1)\n                            dp[i] = dp[j] + 1;\n            }\n            return dp.Max();\n        }\n\n        static int RunList(List<int> array)\n        {\n            List<int> dp = new List<int>(array.Count);\n            dp.Add(1);\n            for (int i = 1; i < array.Count; i++)\n            {\n                dp.Add(1);\n                for (int j = 0; j < i; j++)\n                    if (array[i] > array[j] && dp[i] < dp[j] + 1)\n                        dp[i] = dp[j] + 1;\n            }\n            return dp.Max();\n        }\n\n        static void Main(string[] args)\n        {\n            int arrayLen = 1000;\n            Random r = new Random();\n            List<double> values = new List<double>();\n            Stopwatch clock = new Stopwatch();\n            Console.WriteLine(\"Running...\");\n            for (int i = 0; i < 100; i++)\n            {\n                List<int> list = new List<int>();\n                int[] array = new int[arrayLen];\n                for (int j = 0; j < arrayLen;j++)\n                {\n                    int e = r.Next();\n                    array[j] = e;\n                    list.Add(e);\n                }\n\n                clock.Restart();\n                RunArray(array);\n                clock.Stop();\n                double timeArray = clock.ElapsedMilliseconds;\n                clock.Restart();\n                RunList(list);\n                clock.Stop();\n                double timeList = clock.ElapsedMilliseconds;\n                //Console.WriteLine(Math.Round(timeArray/timeList*100,2) + \"%\");\n                values.Add(timeArray / timeList);\n            }\n            Console.WriteLine(\"Arrays are \" + Math.Round(values.Average()*100,1) + \"% faster\");\n            Console.WriteLine(\"Done\");\n        }\n\n\n\n    }\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence. Why topDown code is not working working?\r\n                \r\n\nQ. Given an integer array nums, return the length of the longest strictly increasing subsequence.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\nAnswer:\nMy recursion code is working correct but TopDown DP code is not working. Even I am just storing the correct answers in dp vector and use them again.\nRecursion code:\n```\nint lengthOfLIS(vector<int>& arr, int i=0, int prev= INT_MIN){\n        //........... base case............\n        if(i==arr.size()) return 0;\n        //........... recursive case...........\n        // take if it is grater than prev\n        int X = INT_MIN;\n        if(arr[i] > prev)\n            X = 1 + lengthOfLIS(arr, i+1, arr[i]);\n        // ignore\n        int Y = lengthOfLIS(arr, i+1, prev);\n    \n        return max(X, Y);\n    }\n\n\nTopDown DP code:- \n\nint sol(vector<int> arr, vector<int>& dp, int i=0, int prev= INT_MIN){\n        //........... base case............\n        if(i==arr.size()) return dp[i]=0;\n        if(dp[i]!=-1) return dp[i];\n        //........... recursive case...........\n        // take if it is grater than prev\n        int X = INT_MIN;\n        if(arr[i] > prev)\n            X = 1 + sol(arr, dp, i+1, arr[i]);\n        // ignore\n        int Y = sol(arr, dp, i+1, prev);\n    \n        return dp[i] = max(X, Y);\n    }\n\n```\n\n    ", "Answer": "\r\nBasically you want to memoize using dp. I would suggest taking a 2d vector for memoization in this case.\nSo the final solution will be :\n```\nint lengthOfLIS(vector& nums){\n\nint n=nums.size();\n\nvector<vector<int>> dp(n,vector<int>(n+1,-1));\n \nreturn sol(nums,0,n,-1,dp);\n\n}\n\nint sol(vector<int>& nums,int i,int n,int prev,vector<vector<int>>& dp){\n\nif(i==n){\n    return 0;\n} \n\nif(dp[i][prev+1]!=-1){\n    \n    return dp[i][prev+1];\n    \n}\n\nint X=0;int Y=0;\n      \nif(prev==-1 or nums[i]>nums[prev]){\n    \n    X=1+sol(nums,i+1,n,i,dp);\n    \n}\n\nY=sol(nums,i+1,n,prev,dp);\n   \ndp[i][prev+1]=max(X,Y);\n\nreturn dp[i][prev+1];\n\n}   \n};\n```\n\nThe concept is the same as yours, I have just used a 2d vector dp.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest monotonic subsequence algorithm NOT longest increasing algorithm\r\n                \r\nI have some numbers at the input:\n```\n1 1 7 3 2 0 0 4 5 5 6 2 1\n```\n\nAnd I look for a longest monotonic subsequence and what is the sum of this subsequence. The result is:\n```\n6 20\n```\n\nI cannot find the algorithm at the internet. Do you own/found one? This is about longest monotonic not longest increasing subsequence.\nDefinition of monotonic: http://en.wikipedia.org/wiki/Monotonic_function\nI know that someone will ask: What have you tried? So i tried writing it(please don't check it I only post it so no one asks that question above I look for different algorithm->optimal one)\n```\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Rozwiazanie {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n            //2^63 > 10^16 = 10^7 * 10^9 longi starcza\n            //10^9 inty starcza\n            //int 32 bity, long 64 bity\n            long podsuma = 0;\n            int dlugosc = 0;\n            int maxDlugosc = 0;\n            long maxPodsuma = 0;\n            int poczatekRownych = 0;\n            int poprzedniWyraz = 0, aktualnyWyraz;//uwaga jakby cos nie gralo w sprawdzarce zmien typ na long\n            boolean czyRosnacy = false, rowny = false;\n            String[] splittedLinia = br.readLine().split((char) 32 + \"\");//moglaby byc \" \" ale tak na wszelki wypadek nie ma chuja zeby sie popierdolilo teraz nawet na linuxie\n            for (int i = 0; i < splittedLinia.length; i++) {\n                if (i == 0) {\n                    aktualnyWyraz = Integer.parseInt(splittedLinia[0]);\n                    maxDlugosc = dlugosc = 1;\n                    maxPodsuma = podsuma = aktualnyWyraz;\n                    if (splittedLinia.length > 1) {\n                        int nastepnyWyraz = Integer.parseInt(splittedLinia[1]);\n                        czyRosnacy = nastepnyWyraz > aktualnyWyraz;\n                        rowny = nastepnyWyraz == aktualnyWyraz;\n                    }\n                    System.out.println(\"akt: \" + aktualnyWyraz + \" pop: \" + poprzedniWyraz + \" dlugosc: \" + dlugosc + \" \" + 1);\n                } else {\n                    aktualnyWyraz = Integer.parseInt(splittedLinia[i]);\n                    System.out.println(rowny);\n                    if (aktualnyWyraz == poprzedniWyraz && rowny) {\n                        podsuma += aktualnyWyraz;\n                        dlugosc++;\n                        System.out.println(\"akt: \" + aktualnyWyraz + \" pop: \" + poprzedniWyraz + \" dlugosc: \" + dlugosc + \" \" + 2);\n                    } else if (rowny) {\n                        rowny = false;\n                        czyRosnacy = aktualnyWyraz > poprzedniWyraz;\n                        System.out.println(\"akt: \" + aktualnyWyraz + \" pop: \" + poprzedniWyraz + \" dlugosc: \" + dlugosc + \" \" + 3);\n                    }\n\n                    if (!rowny) {\n\n                        if (aktualnyWyraz >= poprzedniWyraz && czyRosnacy) {\n                            podsuma += aktualnyWyraz;\n                            dlugosc++;\n                            System.out.println(\"akt:\" + aktualnyWyraz + \" pop: \" + poprzedniWyraz + \" dlugosc: \" + dlugosc + \" \" + 4);\n                        } else if (aktualnyWyraz <= poprzedniWyraz && !czyRosnacy) {\n                            podsuma += aktualnyWyraz;\n                            dlugosc++;\n                            System.out.println(\"akt: \" + aktualnyWyraz + \" pop: \" + poprzedniWyraz + \" dlugosc: \" + dlugosc + \" \" + 5);\n                        } else {\n                            //  if (aktualnyWyraz == poprzedniWyraz) {\n                            rowny = true;\n                            //  } else {\n                            if (maxDlugosc < dlugosc) {\n                                maxDlugosc = dlugosc;\n                                maxPodsuma = podsuma;\n\n                            }\n                            podsuma = poprzedniWyraz + aktualnyWyraz;\n                            dlugosc = 2;\n                            czyRosnacy = aktualnyWyraz > poprzedniWyraz;\n                            rowny = aktualnyWyraz == poprzedniWyraz;\n                            System.out.println(\"akt: \" + aktualnyWyraz + \" pop: \" + poprzedniWyraz + \" dlugosc: \" + dlugosc + \" \" + 6);\n                            //}\n                        }\n                    }\n                }\n                poprzedniWyraz = aktualnyWyraz;\n            }\n            System.out.println(maxDlugosc + \" \" + maxPodsuma);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n//65 87 47 5 12 74 25 32 78 44 40 77 85 4 29 57:\n```\n\n    ", "Answer": "\r\ntry this one:\n\n```\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Rozwiazanie {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] splittedLinia = br.readLine().split((char) 32 + \"\");//moglaby byc \" \" ale tak na wszelki wypadek nie ma chuja zeby sie popierdolilo teraz nawet na linuxie\n            int aktualnyWyraz = Integer.parseInt(splittedLinia[0]);//uwaga jakby cos nie gralo w sprawdzarce zmien typ na long\n            int poprzedniWyraz = 0; \n\n            long podsumaRosnaca = aktualnyWyraz;\n            long podsumaSpadajaca = aktualnyWyraz;\n\n            int dlugoscRosnaca = 1;\n            int dlugoscSpadajaca = 1;\n\n            int maxDlugosc = 1;\n            long maxPodsuma = aktualnyWyraz;\n\n            int czyRosnacy = 0; // 0 -- nie znane (jezeli w poczatku wszystkie liczby sa rowne), 1 -- rosnacy, -1 -- spadajacy\n            boolean rowny = false;\n            System.out.println(\"akt: \" + aktualnyWyraz + \" dlR: \" + dlugoscRosnaca + \" podsumaR: \" + podsumaRosnaca + \" dlP: \" + dlugoscSpadajaca + \" podsumaP: \" + podsumaSpadajaca);\n\n            for (int i = 1; i < splittedLinia.length; i++) {\n                poprzedniWyraz = aktualnyWyraz;\n                aktualnyWyraz = Integer.parseInt(splittedLinia[i]);\n                if (aktualnyWyraz == poprzedniWyraz) {\n                    podsumaRosnaca += aktualnyWyraz;\n                    podsumaSpadajaca += aktualnyWyraz;\n                    dlugoscRosnaca++;\n                    dlugoscSpadajaca++;\n                    rowny = true;\n                } else { // rozne liczby\n                    if (aktualnyWyraz > poprzedniWyraz) { // rosnie\n                        podsumaRosnaca += aktualnyWyraz;\n                        dlugoscRosnaca++;      \n\n                        if (rowny) {\n                            dlugoscSpadajaca = 1;\n                            podsumaSpadajaca = 0;\n                            rowny = false;\n                        }       \n                        if (czyRosnacy < 0) {\n                            if (dlugoscSpadajaca > maxDlugosc) {\n                                maxDlugosc = dlugoscSpadajaca;\n                                maxPodsuma = podsumaSpadajaca;\n                            }\n                            podsumaSpadajaca = 0;\n                            dlugoscSpadajaca = 1;\n                        }\n                        czyRosnacy = 1;   \n                    } else { // spada\n                        podsumaSpadajaca += aktualnyWyraz;\n                        dlugoscSpadajaca++; \n\n                        if (rowny) {\n                            dlugoscRosnaca = 1;\n                            podsumaRosnaca = 0;\n                            rowny = false;\n                        }\n                        if (czyRosnacy == 1) {\n                            if (dlugoscRosnaca > maxDlugosc) {\n                                maxDlugosc = dlugoscRosnaca;\n                                maxPodsuma = podsumaRosnaca;\n                            }\n                            podsumaRosnaca = 0;\n                            dlugoscRosnaca = 1;\n                        }  \n                        czyRosnacy = -1;\n                    }\n\n                }\n                System.out.println(\"akt: \" + aktualnyWyraz + \" dlR: \" + dlugoscRosnaca + \" podsumaR: \" + podsumaRosnaca + \" dlP: \" + dlugoscSpadajaca + \" podsumaP: \" + podsumaSpadajaca);\n            }\n\n\n            System.out.println(\"maxDlugosc \" + maxDlugosc + \" maxPodsuma \" + maxPodsuma);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\nwhat I had to change:\n\n\nyou need a counter [dlugosc] (+ sum [podsuma]) for ascending \n[rosnacy] and descending [spadajacy] values, as you need to count \nboth when the values are the same [rowny]. \nI changed boolean \"rowny\"\n[equal] to int, as I thought that there are 3 values possible:\nascending, descending or unknown. If there are several equal values\nat the beginning, there's all the time \"unknown\". \nthis program needs at least one number, but therefore you don't need to check in every\niteration of the loop whether i == 0 or not. \nGoing through the\nnumbers, I have to check several things, most important is, whether\nthe actual value [aktualnyWyraz] and the last used value\n[poprzedniWyraz] are the same (then all counters and sums have to be\nchanged) or different. Different can mean ascending or descending, so\nwe have to increment the related counters and sum up the related sum.\nWhat happens the \"opposite\" variables? Well, we need to check whether\nthe counter is bigger then the maximum one (so maybe these values are\nuseful for the result) and then set them back to their start.\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence with K exceptions allowed\r\n                \r\nHello I am stuck with my homework which is:  given sequence of integers, find the longest subsequence whose elements are ordered in an increasing order.  Up to k exceptions that means at most k times, the next number in the sequence is smaller than previous one. Output should be the length of the longest such subsequence.\n\nI found many examples of finding LIS, even one with one change allowed, but I don't know how to check with k changes.  Here is the link to post with one change:  https://www.geeksforgeeks.org/longest-increasing-subarray-with-one-change-allowed/amp/\n    ", "Answer": "\r\nYou can set up k counters and traverse the sequence. Once you reach an exception you go to the next counter. If you reached the k+1-th counter you drop the first one and shift all your counters by one so that the n+1th counter becomes the nth. With each step you store the current index together with the sum of your k counters as the total sequence length. Take the maximum of that in the end\n\nExplanation:\nThe question is only where the longest subsequence begins. If you know that you know how long it is (until the k+1) exception or the end of the sequence). Let this point be s.\nThe longest subsequence can only begin at an exception or at the start of the sequence. If not you could add the s-1 item to the sequence without adding an exception and form a longer subsequence. \nThe method above computes all possible longest subsequences and chooses the longest candidate in the end.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence with K exceptions allowed\r\n                \r\nHello I am stuck with my homework which is:  given sequence of integers, find the longest subsequence whose elements are ordered in an increasing order.  Up to k exceptions that means at most k times, the next number in the sequence is smaller than previous one. Output should be the length of the longest such subsequence.\n\nI found many examples of finding LIS, even one with one change allowed, but I don't know how to check with k changes.  Here is the link to post with one change:  https://www.geeksforgeeks.org/longest-increasing-subarray-with-one-change-allowed/amp/\n    ", "Answer": "\r\nYou can set up k counters and traverse the sequence. Once you reach an exception you go to the next counter. If you reached the k+1-th counter you drop the first one and shift all your counters by one so that the n+1th counter becomes the nth. With each step you store the current index together with the sum of your k counters as the total sequence length. Take the maximum of that in the end\n\nExplanation:\nThe question is only where the longest subsequence begins. If you know that you know how long it is (until the k+1) exception or the end of the sequence). Let this point be s.\nThe longest subsequence can only begin at an exception or at the start of the sequence. If not you could add the s-1 item to the sequence without adding an exception and form a longer subsequence. \nThe method above computes all possible longest subsequences and chooses the longest candidate in the end.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "longest increasing subsequence of a [1 2 .. N] permutation\r\n                \r\nHere is the problem:\n\nGiven an array of N elements (1 to N), sort the array with one constraint: you can only move an element to begin of the array or end of the array. How many moves do you at least need to sort the array?\n\nFor example: ```\n2 5 3 4 1```\n => ```\n1 2 5 3 4```\n => ```\n1 2 3 4 5```\n, so I need at least 2 moves.\n\nI figure out one solution: ```\nN - length of longest increasing subsequence```\n, in above example the answer if ```\n5 - 3 = 2```\n.\n\nI know a ```\nO(NlogN)```\n algorithm to find longest increasing subsequence (LIS). But with elements in the array being in ```\n[1, N]```\n, I wonder is there a ```\nO(N)```\n solution to find LIS of the array?\n\nOr is there a ```\nO(N)```\n solution to solve the initial problem given that we know elements are from 1 to N?\n    ", "Answer": "\r\nWhat you are looking for is the longest increasing sequence where the difference between any two consecutive elements is ```\n1```\n.\n\nJust finding the longest increasing sequence is not enough, for example with ```\n1 5 3 4 2```\n the longest inc seq has length ```\n3```\n but the problem can only be solved in ```\n3```\n steps not ```\n2```\n as far as I can tell.\n\nTo find the longest inc seq where the difference is ```\n1```\n in ```\nO(N)```\n time and ```\nO(N)```\n space can be done by allocating a ```\nhelper```\n array of size ```\nN```\n initialized to all ```\n0```\n for example. This array will store at position ```\ni```\n the length of the longest subsequence up ```\ni```\n and if ```\ni```\n hasn't been seen yet it will be ```\n0```\n. \n\nThen you go through the unsorted array and when you find an element ```\nx```\n you set ```\nhelper[x] = helper[x-1] + 1```\n and you update a ```\nmax```\n variable.\n\nFinally, the cost to sort is ```\ninput_array.length - max```\n\n\nExample:\n\n```\narray:   3 1 2\n         0 1 2 3\nhelper:  0 0 0 0\nmax = 0\n\nstep 1:\ncheck element at position 1 which is 3. helper[3] = helper[3 - 1] + 1 == 1:\n          0 1 2 3\nhelper:   0 0 0 1\nmax = 1\n\nstep 2:\ncheck element at position 2 which is 1. helper[1] = helper[1 - 1] + 1 == 1:\n          0 1 2 3\nhelper:   0 1 0 1\nmax = 1\n\nstep 3:\ncheck element at position 3 which is 2. helper[2] = helper[2 - 1] + 1 == 2:\n          0 1 2 3\nhelper:   0 1 2 1\nmax = 2\n\ncost = 3 - 2 = 1\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "longest increasing subsequence of a set of disjoint decreasing sequences\r\n                \r\nLets say we have some disjoint decreasing sequences:\n\n```\ns1={10,8,2}\ns2={9,5,4,1}\ns3={7,6,3}\n```\n\n\nI select some decreasing sequences (say 5 decreasing sequences in the order ```\ns2```\n,```\ns1```\n,```\ns2```\n,```\ns3```\n,```\ns2```\n) and concatenate them (resulting sequence ```\nS = {9,5,4,1,10,8,2,9,5,4,1,7,6,3,9,5,4,1}```\n.\n\nNow I want to find the length of the longest increasing subsequence in S. In the above example: ```\n5```\n -> ```\n{1,2,4,7,9}```\n\n\nExpected Time Complexity is less than O(|S|).\n    ", "Answer": "\r\nThe length of the longest increasing subsequence can't be more than two. Because the sequences you concatenate are decreasing, it can only be an increasing sequence if you go from the last number of one sequence to the first number of the other sequence. To find out if there is an increasing subsequence with length 2 in your sequence S, you only have to focus on the end and the beginning of the sequences you want to concatenate.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to find longest increasing subsequence among all simple paths of an unweighted general graph?\r\n                \r\nLet G = (V, E) be an unweighted general graph in which every vertex v has a weight w(v).\n\nAn increasing subsequence of a simple path p in G is a sequence of vertices of p in which the weights of all vertices along this sequence increase. The simple paths can be closed paths.\n\nA longest increasing subsequence (LIS) of a simple path p is an increasing subsequence of p such that has maximum number of vertices.\n\nThe question is that, how to find a longest increasing subsequence among all simple paths of G?\n\nNote that the graph is undirected, therefore it is not a directed acyclic graph (DAG).\n    ", "Answer": "\r\nHere's a very fast algorithm for solving this problem. The longest increasing subsequence in the graph is a subsequence of a path in the graph, and each path must belong purely to a single connected component. So if we can solve this problem on connected components, we can solve it for the overall graph by finding the best solution across all connected components.\n\nNext, think about the case where you're solving this problem for a connected graph G. In that case, the longest increasing subsequence you could find would be formed by sorting the nodes by their weight, then traversing from the lowest-weight node to the second, then to the third, then to the fourth, etc. If there are any ties or duplicates, you can just skip them. In other words, you can solve this problem by\n\n\nSorting all the nodes by weight,\nDiscarding all but one node of each weight, and\nForming an LIS by visiting each node in sequence.\n\n\nThis leads to a very fast algorithm for the overall problem. In time O(m + n), find all connected components. For each connected component, use the preceding algorithm in time O(Sort(n)), where Sort(n) is the time required to sort n elements (which could be Θ(n log n) if you use heapsort, Θ(n + U) for bucket sort, Θ(n lg U) for radix sort, etc.). Then, return the longest sequence you find.\n\nOverall, the runtime is O(m + n + &Sort(n)), which beats my previous approach and should be a lot easier to code up.\n\n\n\nI had originally posted this answer, which I'll leave up because I think it's interesting:\n\nImagine that you pick a simple path out of the graph G and look at the longest increasing subsequence of that path. Although the path walks all over the graph and might have lots of intermediary nodes, the longest increasing subsequence of that path really only cares about\n\n\nthe first node on the path that's also a part of the LIS, and\nfrom that point, the next-largest value in the path.\n\n\nAs a result, we can think about forming an LIS like this. Start at any node in the graph. Now, travel to any node in the graph that (1) has a higher value than the current node and (2) is reachable from the current node, then repeat this process as many times as desired. The goal is to do so in a way that gives the longest possible sequence of increasing values.\n\nWe can model this process as finding a longest path in a DAG. Each node in the DAG represents a node in the original graph G, and there's an edge from a node u to a node v if\n\n\nthere's a path from u to v in G, and\nw(u) < w(v).\n\n\nThis is a DAG because of that second condition, even though the original graph isn't a DAG.\n\nSo we can solve this overall problem in a two-step process. First, build the DAG described above. To do so:\n\n\nFind the connected components of the original graph G and label each node with its connected component number. Time: O(m + n).\nFor each node u in G, construct a corresponding node u' in a new DAG D. Time: O(n).\nFor each node u in G, and for each node v in G that's in the same SCC as u, if w(u) < w(v), add an edge from u' to v'. Time: Θ(n2) in the worst-case, Θ(n) in the best case.\nFind the longest path in D. This path corresponds to the longest increasing subsequence of any simple path in G. Time: O(m + n).\n\n\nOverall runtime: Θ(n2) in the worst-case, Θ(m + n) in the best-case.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Number of longest increasing subsequences\r\n                \r\nI'm trying for a while now to come with an idea to calculate how many longest increasing subsequences there are in a given integer array in the most efficent way.\nI don't need to find all the subsequences, only how many are they...\nI'm working with Java. \nany ideas?\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Top down approach of longest increasing subsequence?\r\n                \r\n\nhttps://leetcode.com/problems/longest-increasing-subsequence/\n\nThis the link of the question which I tried to solve using recursion + memorization technique but not able to solve my testcases only pass only up to 4 is also I don't know that whether my approach is correct or not.\nBelow this line is the code I tried:\n```\nint lis( vector<int>& nums, int i, int n, int prev, vector<int>& ls){\n    if(i==n||n==0){\n        return 0;\n    }\n    if(ls[i]!=-1){\n        return 1 ;\n    }\n\n    lis(nums,i+1,n,prev,ls);\n\n    if(nums[i]>prev){\n        int  num=1+lis(nums,i+1,n,nums[i],ls);\n        ls[num]=1;\n        return num;\n    }\n\n    return 0;\n}\n```\n\n\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int  n=nums.size();\n        int c;\n        vector<int> ls(n+1,-1);\n\n        lis(nums,0,n,INT_MIN,ls);\n        for(int i=n;i>=0;i--) {\n            if(ls[i]!=-1) {\n                c=i;\n                break;\n            }\n            else {\n                c=0;\n            }\n        }\n        if(nums.size()==0) {\n            return 0;\n        }\n        else    {\n            if(c==0) {\n                return 0;\n            }\n            else {\n                return c;\n            }\n        }\n    }\n};\n\n```\n\nI want to know how to apply  recursion + memorization technique in this type of question. Everyone is teaching bottom up approach, not top down approach so it is hard to understand top down. So explain me how to solve this question?\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence in a linked list of integers\r\n                \r\nGiven a one-way linked list of integers, I need to return the longest increasing subsequence as a new linked list.\nFor example, the given list is: 1->5->4->3->6->8->12->10\nThe new one should be: 3->6->8->12.\nI've tried to traverse through the list and compare each node by\n```\nif (n.data < n.next.data)\n  newList.add(n);\n```\n\nHow can I store the node's and count when the list is in maximum length and then return it?\nThanks ahead :)\n    ", "Answer": "\r\nYou should try more, to get an idea of how to approach problems.\nWhich can be done by on paper / in thought designing how you would have solved the problem.\n\nYou need to maintain a maximum sublist ```\nmaxSublist```\n, and\na current sublist ```\ncurrentSublist```\n.\n\nAs you possibly add the current node, you should compare it with the prior node, the last element of the currentSubList. As taking the last element of a single linked list is expensive, I remember the node as ```\npriorNode```\n after handling it.\nIn pseudo-code:\n```\nList<Integer> maxSublist = new SingleLinkedList<>(); // Empty list.\n\nList<Integer> currentSublist = new SingleLinkedList<>();\nNode priorNode = null;\nfor (Node node = list.head(); node != null; node = node.next) {\n     if (priorNode == null || node.data > priorNode.data) {\n         currentSublist.add(node);\n     } else {\n         ...\n     }\n     if (currentSublist.size() > maxSublist.size()) {\n         maxSublist = currentSublist;\n     }\n     priorNode = node;\n}\nreturn maxSublist;\n```\n\nThe above is not the only solution by the way. And you might need to alter the code after filling in ```\n...```\n.\nFor the next task try to find a solution this way on your own. Realize what you need: the current sublist and separately the maximum sublist till then.\nIt is a kind of hard puzzling which brings more pleasure when totaLLy solving it oneself.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence with binary search\r\n                \r\nI'm trying to implement some algorithm in python and I need help.\nGiven some array of integers,\nI want to build BTS and find the Longest increasing subsequence.\nThe idea is to give index to each node(by order of inserting)\nNext we want to take all the indices from the left tree and put them in stack\nNext we want to check for each index in the above stack if we have in the tree index that is bigger than the current node, if yes we insert it to stack and update the value max which is the number of elements in our stack.\nI need help at the point of scanning the tree and insert the elements into a stack.\nhere is my code so far:\n```\nclass Node:\n    def __init__(self, key, index = -1):\n        self.right = None\n        self.left = None\n        self.key = key\n        self.index = index\n\n    def __str__(self):\n        return \"key: %s, index: %s\" % (str(self.key), str(self.index))  \n\ndef insert(root, key, value=-1):\n    if root is None:\n        root = Node(key, value)\n    else:\n        if key < root.key:\n            root.left = insert(root.left, key, value)\n        elif key > root.key:\n            root.right = insert(root.right, key, value)\n        else:\n            pass\n    return root\n\ndef LeftSideIndices(root):\n    res = []\n    if root:\n        res = LeftSideIndices(root.left)\n        res.append(root.index)\n    return res\n\ndef InOrderWithInsert(root,A):\n    newStack = []\n\n    if root:\n        for i in range(0, len(A)):\n            newStack = upInOrder(root.left,A)\n            if root.index > A[i]:\n                newStack.append(root.key)\n            newStack = newStack + upInOrder(root.right, A)\n    return newStack\n```\n\nExample:\n\nThe right stack should be: s=[0,2,8,11]\n    ", "Answer": "\r\nSome general remarks :\n\nproviding a MWE is appreciated.\nyour code does not define ```\nupInOrder```\n so we can't run part of it\nnitpick: in the ```\ninsert```\n function your ```\nvalue```\n parameter is passed to the ```\nindex```\n parameter of your ```\nNode```\n constructor, the naming is confusing.\nreformulating your question to make it explicit : \"given a Binary Search Tree, find the Longest Increasing Subsequence\"\nthere is a bug in your ```\nLeftSideIndices```\n : it returns only indices of left (grand)children instead of the indices of the whole left-half of the tree, example :\n```\nbst = insert(insert(insert(None, 2, 0), 0, 1), 1, 2)\n#            val=2,idx=0\n#            /\n#  val=0,idx=1\n#            \\\n#         val=1,idx=2\nprint(LeftSideIndices(bst))  # [1, 0]\n```\n\n\nfor reference :\n```\nprint(\"value | \" + \" | \".join(str(value).ljust(2) for value in A) + \" |\")\nprint(\"index | \" + \" | \".join(str(index).ljust(2) for index in range(len(A))) + \" |\")\n# | value | 4  | 1  | 13 | 7  | 0  | 2  | 8  | 11 | 3  |\n# | index | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |\n```\n\n\nas said in the comments, another solution would be to not use a BST at all, and just search the LIS in ```\nA```\n (which uses a much more common algorithm). I would even say that using a BST makes it pointlessly hard because the result has nothing to do with the BST structure, it is strictly defined by the insertion order, irregarding the datastructure considered.\nThere may be multiple different subsequences having the same length (being the longest possible), example :\n```\nbst = insert(insert(insert(insert(None, 1, 0), 22, 1), 14, 2), 15, 3)\n#     val=1,idx=0\n#               \\\n#               val=22,idx=1\n#               /\n#       val=14,idx=2\n#               \\\n#            val=15,idx=3\n\n# Expected LIS = { (1, 22),   (14, 15) }\n```\n\n\n\nI read several times your algorithm explanation (slightly reformatted) :\n\n\ntake all the indices from the left tree and put them in stack\ncheck for each index in the stack if we have in the tree index that is bigger than the current node\n\nif yes, insert it to stack and update the value max which is the number of elements in the stack.\n\n\n\n\nI am not sure to understand your algorithm, and I don't think it works.\nI am even not sure there is a simple solution to this problem.\nThe way your indices are scattered accross your tree prevent a node to know which solution(s) from its left and/or right sub-trees are interesting because there is too much holes in the index sequence in a sub-tree, the information at the node level is too much gappy.\nUsually for trees algorithms, it is simple to apply some divide and conquer algorithm, but in this case I can't even tell how recursively the root node could tell which is the longest subsequence, given the results of its left and righ subtrees.\nBut in your case it looks to me extra hard to find how to implement what you want. And I can't convince myself there is actually an algorithm. So I hope you will be able to prove me wrong.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find the longest increasing subsequence of a given array of integers, A\r\n                \r\nPlease dont post code\nfind a subsequence of array in which the subsequence’s elements are in strictly increasing order, and in which the subsequence is as long as possible.\nThis subsequence is not necessarily contiguous, or unique.\nIn this case, we only care about the length of the longest increasing subsequence.\n```\nInput 1:\n    A = [1, 2, 1, 5]\n\nOutput 1:\n    3\n    \nExplanation 1:\n    The sequence : [1, 2, 5]\n\nInput 2:\n    A = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n    \nOutput 2:\n    6\n\nExplanation 2:\n    The sequence : [0, 2, 6, 9, 13, 15] or [0, 4, 6, 9, 11, 15] or [0, 4, 6, 9, 13, 15]\n```\n\nMy doubt how is this sequence formed [0, 2, 6, 9, 13, 15] what will be the next number .Is this sequence[0, 2, 6, 9, 13, 15] resembles anything common with this sequence [0, 4, 6, 9, 11, 15]\n    ", "Answer": "\r\nYou can't select any correct sequence for further.\nBut we have some comparison.\nLet's assume that there are 2 lists, A and B:\nif len(A) >= len(B) and A[-1] <= B[-1]:\nIt's better to select A than B.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest K Sequential Increasing Subsequences\r\n                \r\nWhy I created a duplicate thread\nI created this thread after reading Longest increasing subsequence with K exceptions allowed. I realised that the person who was asking the question hadn't really understood the problem, because he was referring to a link which solves the \"Longest Increasing sub-array with one change allowed\" problem. So the answers he got were actually irrelevant to LIS problem.\nDescription of the problem\nSuppose that an array A is given with length N.\nFind the longest increasing sub-sequence with K exceptions allowed.\nExample\n1)\nN=9 , K=1\nA=[3,9,4,5,8,6,1,3,7]\nAnswer: 7\nExplanation:\nLongest increasing subsequence is : 3,4,5,8(or 6),1(exception),3,7 -> total=7\n\nN=11 , K=2\n\nA=[5,6,4,7,3,9,2,5,1,8,7]\nanswer: 8\nWhat I have done so far...\nIf K=1 then only one exception is allowed. If the known algorithm for computing the Longest Increasing Subsequence in O(NlogN) is used (click here to see this algorithm), then we can compute the LIS starting from A[0] to A[N-1] for each element of array A. We save the results in a new array L with size N. Looking into example n.1 the L array would be:\nL=[1,2,2,3,4,4,4,4,5].\nUsing the reverse logic, we compute array R, each element of which contains the current Longest Decreasing Sequence from N-1 to 0.\nThe LIS with one exception is just sol=max(sol,L[i]+R[i+1]),\nwhere sol is initialized as sol=L[N-1].\nSo we compute LIS from 0 until an index i (exception), then stop and start a new LIS until N-1.\n```\nA=[3,9,4,5,8,6,1,3,7]\n\nL=[1,2,2,3,4,4,4,4,5]\n\nR=[5,4,4,3,3,3,3,2,1]\n\nSol = 7\n```\n\n-> step by step explanation:\n```\ninit: sol = L[N]= 5\n\ni=0 : sol = max(sol,1+4) = 5 \ni=1 : sol = max(sol,2+4) = 6\ni=2 : sol = max(sol,2+3) = 6\ni=3 : sol = max(sol,3+3) = 6\ni=4 : sol = max(sol,4+3) = 7\ni=4 : sol = max(sol,4+3) = 7\ni=4 : sol = max(sol,4+2) = 7\ni=5 : sol = max(sol,4+1) = 7\n\n```\n\nComplexity :\nO( NlogN + NlogN + N ) = O(NlogN)\nbecause arrays R, L need NlogN time to compute and we also need Θ(N) in order to find sol.\nCode for k=1 problem\n```\n#include <stdio.h>\n#include <vector>\n\nstd::vector<int> ends;\n\nint index_search(int value, int asc) {\n    int l = -1;\n    int r = ends.size() - 1;\n    while (r - l > 1) { \n        int m = (r + l) / 2; \n        if (asc && ends[m] >= value) \n            r = m; \n        else if (asc && ends[m] < value)\n            l = m;\n        else if (!asc && ends[m] <= value)\n            r = m;\n        else\n            l = m;\n    } \n    return r;\n}\n\nint main(void) {\n    int n, *S, *A, *B, i, length, idx, max;\n\n    scanf(\"%d\",&n);\n    S = new int[n];\n    L = new int[n];\n    R = new int[n];\n    for (i=0; i<n; i++) {\n        scanf(\"%d\",&S[i]);\n    }\n\n    ends.push_back(S[0]);\n    length = 1;\n    L[0] = length;\n    for (i=1; i<n; i++) {\n        if (S[i] < ends[0]) {\n            ends[0] = S[i];\n        }\n        else if (S[i] > ends[length-1]) {\n            length++;\n            ends.push_back(S[i]);\n        }\n        else {\n            idx = index_search(S[i],1);\n            ends[idx] = S[i];\n        }\n        L[i] = length;\n    }\n\n    ends.clear();\n    ends.push_back(S[n-1]);\n    length = 1;\n    R[n-1] = length;\n    for (i=n-2; i>=0; i--) {\n        if (S[i] > ends[0]) {\n            ends[0] = S[i];\n        }\n        else if (S[i] < ends[length-1]) {\n            length++;\n            ends.push_back(S[i]);\n        }\n        else {\n            idx = index_search(S[i],0);\n            ends[idx] = S[i];\n        }\n        R[i] = length;\n    }\n\n    max = A[n-1];\n    for (i=0; i<n-1; i++) {\n        max = std::max(max,(L[i]+R[i+1]));\n    }\n\n    printf(\"%d\\n\",max);\n    return 0;\n}\n```\n\nGeneralization to K exceptions\nI have provided an algorithm for K=1. I have no clue how to change the above algorithm to work for K exceptions. I would be glad if someone could help me.\n    ", "Answer": "\r\nThis answer is modified from my answer to a similar question at Computer Science Stackexchange.\n\nThe LIS problem with at most k exceptions admits a O(n log² n) algorithm using Lagrangian relaxation. When k is larger than log n this improves asymptotically on the O(nk log n) DP, which we will also briefly explain.\n\nLet DP[a][b] denote the length of the longest increasing subsequence with at most b exceptions (positions where the previous integer is larger than the next one) ending at element  b  a. This DP is not involved in the algorithm, but defining it makes proving the algorithm easier.\n\nFor convenience we will assume that all elements are distinct and that the last element in the array is its maximum. Note that this does not limit us, as we can just add m / 2n to the mth appearance of every number, and append infinity to the array and subtract one from the answer. Let V be the permutation for which 1 <= V[i] <= n is the value of the ith element.\n\nTo solve the problem in O(nk log n), we maintain the invariant that DP[a][b] has been calculated for b < j. Loop j from 0 to k, at the jth iteration calculating DP[a][j] for all a. To do this, loop i from 1 to n. We maintain the maximum of DP[x][j-1] over x < i and a prefix maximum data structure that at index i will have DP[x][j] at position V[x] for x < i, and 0 at every other position.\n\nWe have DP[i][j] = 1 + max(DP[i'][j], DP[x][j-1]) where we go over i', x < i, V[i'] < V[i]. The prefix maximum of DP[x][j-1] gives us the maximum of terms of the second type, and querying the prefix maximum data structure for prefix [0, V[i]] gives us the maximum of terms of the first type. Then update the prefix maximum and prefix maximum data structure.\n\nHere is a C++ implementation of the algorithm. Note that this implementation does not assume that the last element of the array is its maximum, or that the array contains no duplicates.\n\n```\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Fenwick tree for prefix maximum queries\nclass Fenwick {\n    private:\n        vector<int> val;\n    public:\n        Fenwick(int n) : val(n+1, 0) {}\n\n        // Sets value at position i to maximum of its current value and \n        void inc(int i, int v) {\n            for (++i; i < val.size(); i += i & -i) val[i] = max(val[i], v);\n        }\n\n        // Calculates prefix maximum up to index i\n        int get(int i) {\n            int res = 0;\n            for (++i; i > 0; i -= i & -i) res = max(res, val[i]);\n            return res;\n        }\n};\n\n// Binary searches index of v from sorted vector\nint bins(const vector<int>& vec, int v) {\n    int low = 0;\n    int high = (int)vec.size() - 1;\n    while(low != high) {\n        int mid = (low + high) / 2;\n        if (vec[mid] < v) low = mid + 1;\n        else high = mid;\n    }\n    return low;\n}\n\n// Compresses the range of values to [0, m), and returns m\nint compress(vector<int>& vec) {\n    vector<int> ord = vec;\n    sort(ord.begin(), ord.end());\n    ord.erase(unique(ord.begin(), ord.end()), ord.end());\n    for (int& v : vec) v = bins(ord, v);\n    return ord.size();\n}\n\n// Returns length of longest strictly increasing subsequence with at most k exceptions\nint lisExc(int k, vector<int> vec) {\n    int n = vec.size();\n    int m = compress(vec);\n    vector<int> dp(n, 0);\n    for (int j = 0;; ++j) {\n        Fenwick fenw(m+1); // longest subsequence with at most j exceptions ending at this value\n        int max_exc = 0; // longest subsequence with at most j-1 exceptions ending before this\n        for (int i = 0; i < n; ++i) {\n            int off = 1 + max(max_exc, fenw.get(vec[i]));\n            max_exc = max(max_exc, dp[i]);\n\n            dp[i] = off;\n            fenw.inc(vec[i]+1, off);\n        }\n        if (j == k) return fenw.get(m);\n    }\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> vec(n);\n    for (int i = 0; i < n; ++i) cin >> vec[i];\n\n    int res = lisExc(k, vec);\n    cout << res << '\\n';\n}\n\n```\n\n\nNow we will return to the O(n log² n) algorithm. Select some integer 0 <= r <= n. Define DP'[a][r] = max(DP[a][b] - rb), where the maximum is taken over b, MAXB[a][r] as the maximum b such that DP'[a][r] = DP[a][b] - rb, and MINB[a][r] similarly as the minimum such b. We will show that DP[a][k] = DP'[a][r] + rk if and only if MINB[a][r] <= k <= MAXB[a][r]. Further, we will show that for any k exists an r for which this inequality holds.\n\nNote that MINB[a][r] >= MINB[a][r'] and MAXB[a][r] >= MAXB[a][r'] if r < r', hence if we assume the two claimed results, we can do binary search for the r, trying O(log n) values. Hence we achieve complexity O(n log² n) if we can calculate DP', MINB and MAXB in O(n log n) time.\n\nTo do this, we will need a segment tree that stores tuples P[i] = (v_i, low_i, high_i), and supports the following operations:\n\n\nGiven a range [a, b], find the maximum value in that range (maximum v_i, a <= i <= b), and the minimum low and maximum high paired with that value in the range.\nSet the value of the tuple P[i]\n\n\nThis is easy to implement with complexity O(log n) time per operation assuming some familiarity with segment trees. You can refer to the implementation of the algorithm below for details.\n\nWe will now show how to compute DP', MINB and MAXB in O(n log n). Fix r. Build the segment tree initially containing n+1 null values (-INF, INF, -INF). We maintain that P[V[j]] = (DP'[j], MINB[j], MAXB[j]) for j less than the current position i. Set DP'[0] = 0, MINB[0] = 0 and MAXB[0] to 0 if r > 0, otherwise to INF and P[0] = (DP'[0], MINB[0], MAXB[0]).\n\nLoop i from 1 to n. There are two types of subsequences ending at i: those where the previous element is greater than V[i], and those where it is less than V[i]. To account for the second kind, query the segment tree in the range [0, V[i]]. Let the result be (v_1, low_1, high_1). Set off1 = (v_1 + 1, low_1, high_1). For the first kind, query the segment tree in the range [V[i], n]. Let the result be (v_2, low_2, high_2). Set off2 = (v_2 + 1 - r, low_2 + 1, high_2 + 1), where we incur the penalty of r for creating an exception.\n\nThen we combine off1 and off2 into off. If off1.v > off2.v set off = off1, and if off2.v > off1.v set off = off2. Otherwise, set off = (off1.v, min(off1.low, off2.low), max(off1.high, off2.high)). Then set DP'[i] = off.v, MINB[i] = off.low, MAXB[i] = off.high and P[i] = off.\n\nSince we make two segment tree queries at every i, this takes O(n log n) time in total. It is easy to prove by induction that we compute the correct values DP', MINB and MAXB.\n\nSo in short, the algorithm is:\n\n\nPreprocess, modifying values so that they form a permutation, and the last value is the largest value.\nBinary search for the correct r, with initial bounds 0 <= r <= n\nInitialise the segment tree with null values, set DP'[0], MINB[0] and MAXB[0].\nLoop from i = 1 to n, at step i\n\n\nQuerying ranges [0, V[i]] and [V[i], n] of the segment tree,\ncalculating DP'[i], MINB[i] and MAXB[i] based on those queries, and\nsetting the value at position V[i] in the segment tree to the tuple (DP'[i], MINB[i], MAXB[i]).\n\nIf MINB[n][r] <= k <= MAXB[n][r], return DP'[n][r] + kr - 1.\nOtherwise, if MAXB[n][r] < k, the correct r is less than the current r. If MINB[n][r] > k, the correct r is greater than the current r. Update the bounds on r and return to step 1.\n\n\nHere is a C++ implementation for this algorithm. It also finds the optimal subsequence.\n\n```\n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n    using namespace std;\n    using ll = long long;\n    const int INF = 2 * (int)1e9;\n\n    pair<ll, pair<int, int>> combine(pair<ll, pair<int, int>> le, pair<ll, pair<int, int>> ri) {\n        if (le.first < ri.first) swap(le, ri);\n        if (ri.first == le.first) {\n            le.second.first = min(le.second.first, ri.second.first);\n            le.second.second = max(le.second.second, ri.second.second);\n        }\n        return le;\n    }\n\n    // Specialised range maximum segment tree\n    class SegTree {\n        private:\n            vector<pair<ll, pair<int, int>>> seg;\n            int h = 1;\n\n            pair<ll, pair<int, int>> recGet(int a, int b, int i, int le, int ri) const {\n                if (ri <= a || b <= le) return {-INF, {INF, -INF}};\n                else if (a <= le && ri <= b) return seg[i];\n                else return combine(recGet(a, b, 2*i, le, (le+ri)/2), recGet(a, b, 2*i+1, (le+ri)/2, ri));\n            }\n        public:\n            SegTree(int n) {\n                while(h < n) h *= 2;\n                seg.resize(2*h, {-INF, {INF, -INF}});\n            }\n            void set(int i, pair<ll, pair<int, int>> off) {\n                seg[i+h] = combine(seg[i+h], off);\n                for (i += h; i > 1; i /= 2) seg[i/2] = combine(seg[i], seg[i^1]);\n            }\n            pair<ll, pair<int, int>> get(int a, int b) const {\n                return recGet(a, b+1, 1, 0, h);\n            }\n    };\n\n    // Binary searches index of v from sorted vector\n    int bins(const vector<int>& vec, int v) {\n        int low = 0;\n        int high = (int)vec.size() - 1;\n        while(low != high) {\n            int mid = (low + high) / 2;\n            if (vec[mid] < v) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n\n    // Finds longest strictly increasing subsequence with at most k exceptions in O(n log^2 n)\n    vector<int> lisExc(int k, vector<int> vec) {\n        // Compress values\n        vector<int> ord = vec;\n        sort(ord.begin(), ord.end());\n        ord.erase(unique(ord.begin(), ord.end()), ord.end());\n        for (auto& v : vec) v = bins(ord, v) + 1;\n\n        // Binary search lambda\n        int n = vec.size();\n        int m = ord.size() + 1;\n        int lambda_0 = 0;\n        int lambda_1 = n;\n        while(true) {\n            int lambda = (lambda_0 + lambda_1) / 2;\n            SegTree seg(m);\n            if (lambda > 0) seg.set(0, {0, {0, 0}});\n            else seg.set(0, {0, {0, INF}});\n\n            // Calculate DP\n            vector<pair<ll, pair<int, int>>> dp(n);\n            for (int i = 0; i < n; ++i) {\n                auto off0 = seg.get(0, vec[i]-1); // previous < this\n                off0.first += 1;\n\n                auto off1 = seg.get(vec[i], m-1); // previous >= this\n                off1.first += 1 - lambda;\n                off1.second.first += 1;\n                off1.second.second += 1;\n\n                dp[i] = combine(off0, off1);\n                seg.set(vec[i], dp[i]);\n            }\n\n            // Is min_b <= k <= max_b?\n            auto off = seg.get(0, m-1);\n            if (off.second.second < k) {\n                lambda_1 = lambda - 1;\n            } else if (off.second.first > k) {\n                lambda_0 = lambda + 1;\n            } else {\n                // Construct solution\n                ll r = off.first + 1;\n                int v = m;\n                int b = k;\n                vector<int> res;\n                for (int i = n-1; i >= 0; --i) {\n                    if (vec[i] < v) {\n                        if (r == dp[i].first + 1 && dp[i].second.first <= b && b <= dp[i].second.second) {\n                            res.push_back(i);\n                            r -= 1;\n                            v = vec[i];\n                        }\n                    } else {\n                        if (r == dp[i].first + 1 - lambda && dp[i].second.first <= b-1 && b-1 <= dp[i].second.second) {\n                            res.push_back(i);\n                            r -= 1 - lambda;\n                            v = vec[i];\n                            --b;\n                        }\n                    }\n                }\n                reverse(res.begin(), res.end());\n                return res;\n            }\n        }\n    }\n\n    int main() {\n        int n, k;\n        cin >> n >> k;\n\n        vector<int> vec(n);\n        for (int i = 0; i < n; ++i) cin >> vec[i];\n\n        vector<int> ans = lisExc(k, vec);\n        for (auto i : ans) cout << i+1 << ' ';\n        cout << '\\n';\n    }\n```\n\n\nWe will now prove the two claims. We wish to prove that\n\n\nDP'[a][r] = DP[a][b] - rb if and only if MINB[a][r] <= b <= MAXB[a][r]\nFor all a, k there exists an integer r, 0 <= r <= n, such that MINB[a][r] <= k <= MAXB[a][r]\n\n\nBoth of these follow from the concavity of the problem. Concavity means that DP[a][k+2] - DP[a][k+1] <= DP[a][k+1] - DP[a][k] for all a, k. This is intuitive: the more exceptions we are allowed to make, the less allowing one more helps us.\n\nFix a and r. Set f(b) = DP[a][b] - rb, and d(b) = f(b+1) - f(b). We have d(k+1) <= d(k) from the concavity of the problem. Assume x < y and f(x) = f(y) >= f(i) for all i. Hence d(x) <= 0, thus d(i) <= 0 for i in [x, y). But f(y) = f(x) + d(x) + d(x + 1) + ... + d(y - 1), hence d(i) = 0 for i in [x, y). Hence f(y) = f(x) = f(i) for i in [x, y]. This proves the first claim.\n\nTo prove the second, set r = DP[a][k+1] - DP[a][k] and define f, d as previously. Then d(k) = 0, hence d(i) >= 0 for i < k and d(i) <= 0 for i > k, hence f(k) is maximal as desired.\n\nProving concavity is more difficult. For a proof, see my answer at cs.stackexchange.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence - Not able to understand the actual LIS creation\r\n                \r\nCan someone please explain the last of the algo given by Peter in the article \nHow to determine the longest increasing subsequence using dynamic programming?\nI am not able to get the construction of actual LIS, how the parent array will be constructed.\nPlease explain with the same example which Peter has taken.\nThanks in advance.\n    ", "Answer": "\r\nThe longest increasing subsequence in Peter's example is actually \"2 3 4 5 8\", resulting in length 5.\n\nIt is not possible to obtain the LIS by looking at the array ```\nS```\n at the end of the algorithm and ```\nS```\n is not the longest increasing subsequence.\n\nIf we need to construct the LIS, we will need to store more information and modify the algorithm that is presented. Peter has mentioned storing ```\nparent[i]```\n and changing ```\nS[i]```\n to store indexes instead of values in the later part of this article.\n\nLet me modify his proposed algorithm and define ```\nSi```\n to store the index of the numbers in the array ```\nS```\n and ```\nparent[i]```\n to store the index of the previous number in the LIS that ends at ```\narray[i]```\n.\nUsing his example: ```\narray[] = {2, 6, 3, 4, 1, 2, 9, 5, 8}```\n. Do note that ```\n-1```\n is used in the parent array when they form LIS of maximum length 1.\n\n```\n0. S = {} - Initialize S to the empty set\n   Si = {}\n   parent = {}\n1. S = {2} - New largest LIS\n   Si = {0}\n   parent = {-1}\n2. S = {2, 6} - New largest LIS\n   Si = {**0**, 1}\n   parent = {-1, **0**}\n3. S = {2, 3} - Changed 6 to 3\n   Si = {**0**, 2}\n   parent = {-1, 0, **0**}\n4. S = {2, 3, 4} - New largest LIS\n   Si = {0, **2**, 3}\n   parent = {-1, 0, 0, **2**}\n5. S = {1, 3, 4} - Changed 2 to 1\n   Si = {4, 2, 3}\n   parent = {-1, 0, 0, 2, -1}\n6. S = {1, 2, 4} - Changed 3 to 2\n   Si = {**4**, 5, 3}\n   parent = {-1, 0, 0, 2, -1, **4**}\n7. S = {1, 2, 4, 9} - New largest LIS\n   Si = {4, 5, **3**, 6}\n   parent = {-1, 0, 0, 2, -1, 4, **3**}\n8. S = {1, 2, 4, 5} - Changed 9 to 5\n   Si = {4, 5, **3**, 7}\n   parent = {-1, 0, 0, 2, -1, 4, 3, **3**}\n9. S = {1, 2, 4, 5, 8} - New largest LIS\n   Si = {4, 5, 3, **7**, 8}\n   parent = {-1, 0, 0, 2, -1, 4, 3, 3, 7}\n```\n\n\nAt the end, we get the parent array ```\n{-1, 0, 0, 2, -1, 4, 3, 3, 7}```\n\n\n1) by looking at ```\nS```\n, we know there is an LIS of length 5 ending at index 8 with value 8. \n```\nLIS = { ?, ?, ?, ?, 8 }```\n\n\n2) we now look at the parent of index 8, ```\nparent[8]```\n is 7 and the preceding member of the LIS will be in index 7. This is the number 5.\n```\nLIS = { ?, ?, ?, 5, 8 }```\n\n\n3) we now look at the parent of index 7 (value 5), ```\nparent[7]```\n is 3 and the previous member of the LIS will be in index 3. This is the number 4.\n```\nLIS = { ?, ?, 4, 5, 8 }```\n\n\n4) we now look at the parent of index 3 (value 4), ```\nparent[3]```\n is 2 and the previous member of the LIS will be in index 2. This is the number 3.\n```\nLIS = { ?, 3, 4, 5, 8 }```\n\n\n5) we now look at the parent of index 2 (value 3), ```\nparent[2]```\n is 0 and the previous member of the LIS will be in index 0. This is the number 2.\n```\nLIS = { 2, 3, 4, 5, 8 }```\n\n\n6) The actual LIS would be ```\n2 3 4 5 8```\n.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Cost function of a dynamic solution to the \"longest increasing subsequence\" problem\r\n                \r\nSo I have a pretty simple dynamic programming solution to the \"longest increasing subsequence\" problem (find the longest subsequence of increasing elements in a given sequence, for instance for [1, 7, 2, 6, 4] it would be [1, 2, 4]), which can also find the actual subsequence (as opposed to just lenght):\n```\nsequence = [1, 8, 6, 4, 9, 8, 3, 5, 2, 7, 1, 9, 5, 7]\nlistofincreasing = [[] for _ in range(len(sequence))]\nlistofincreasing[0].append(sequence[0])\n\nfor right in range(1, len(sequence)):\n    for left in range(right):\n        if (sequence[left] < sequence[right]) and (len(listofincreasing[right]) < len(listofincreasing[left])):\n            listofincreasing[right] = [] + listofincreasing[left]\n    listofincreasing[right].append(sequence[right])\n\nprint(max(listofincreasing, key=len))\n```\n\nThese sort of brainteasers are pretty manageable for me, but I don't really know the hard theory behind this. My question is this: How would I go about creating a cost function that would formally describe \"how I am filling the list', so to speak? Could someone show me how to approach these problems on this example? Thanks in advance.\nEdit - some people asked for a clarification. In the most succint way possible, I would need to create a mathematic function in the the exact same way as it is created here: https://medium.com/@pp7954296/change-making-problem-dynamic-method-4954a446a511 in the \"formula to solve coin change using dynamic method:\" section, but not for the change making problem but for my solution of the longest increasing subsequence problem\n    ", "Answer": "\r\nYou are looking for a recursive formulation of the overlapping subproblems in your dynamic programming solution.\nLet ```\nLONGEST(S,x)```\n be the longest increasing subsequence of the first x characters of the sequence S.  The solution to the problem is then ```\nLONGEST(S,|S|)```\n.\nRecursively (using 1-based indexing):\n```\nLONGEST(S,x) = S[1] if x = 1. Otherwise,\nLONGEST(S,x) = the longest of:\n    S[x],\n    LONGEST(S,y), where 1 <= y < x, or\n    LONGEST(S,y) + S[x], where 1 <= y < x and LAST_ELMENT(LONGEST(S,y)) < S[x]\n```\n\nSince ```\nLONGEST(S,x)```\n depends only on the values for smaller prefixes, we can produce the values iteratively in order of increasing x, and that is what your program does.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "potential O(n) solution to Longest Increasing Subsequence\r\n                \r\nI was trying to answer this problem, using just recursion (Dynamic programming)\nhttp://en.wikipedia.org/wiki/Longest_increasing_subsequence\n\nFrom the article, and around SO, I realise the most efficient existing solution is O(nlgn). My solution is O(N), and I cannot find a case that it fails. I include unit test cases that I used.\n\n```\nimport static org.junit.Assert.assertEquals;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.Test;\n\npublic class LongestIncreasingSubseq {\n\n    public static void main(String[] args) {\n        int[] arr = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15, 1};\n        getLongestSubSeq(arr);\n    }\n\n    public static List<Integer> getLongestSubSeq(int[] arr) {\n        List<Integer> indices = longestRecursive(arr, 0, arr.length-1);\n        List<Integer> result = new ArrayList<>();\n        for (Integer i : indices) {\n            result.add(arr[i]);\n        }\n\n        System.out.println(result.toString());\n        return result;\n    }\n\n    private static List<Integer> longestRecursive(int[] arr, int start, int end) {\n        if (start == end) {\n            List<Integer> singleton = new ArrayList<>();\n            singleton.add(start);\n            return singleton;\n        }\n\n        List<Integer> bestRightSubsequence = longestRecursive(arr, start+1, end); //recursive call down the array to the next start index\n        if (bestRightSubsequence.size() == 1 && arr[start] > arr[bestRightSubsequence.get(0)]) {\n            bestRightSubsequence.set(0, start); //larger end allows more possibilities ahead\n        } else if (arr[start] < arr[bestRightSubsequence.get(0)]) {\n            bestRightSubsequence.add(0, start); //add to head\n        } else if (bestRightSubsequence.size() > 1 && arr[start] < arr[bestRightSubsequence.get(1)]) {\n            //larger than head, but still smaller than 2nd, so replace to allow more possibilities ahead\n            bestRightSubsequence.set(0, start); \n        }\n\n        return bestRightSubsequence;\n    }\n\n    @Test\n    public void test() {\n        int[] arr1 = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15, 1};\n        int[] arr2 = {7, 0, 9, 2, 8, 4, 1};\n        int[] arr3 = {9, 11, 2, 13, 7, 15};\n        int[] arr4 = {10, 22, 9, 33, 21, 50, 41, 60, 80};\n        int[] arr5 = {1, 2, 9, 4, 7, 3, 11, 8, 14, 6};\n        assertEquals(getLongestSubSeq(arr1), Arrays.asList(0, 4, 6, 9, 11, 15));\n        assertEquals(getLongestSubSeq(arr2), Arrays.asList(0, 2, 8));\n        assertEquals(getLongestSubSeq(arr3), Arrays.asList(9, 11, 13, 15));\n        assertEquals(getLongestSubSeq(arr4), Arrays.asList(10, 22, 33, 50, 60, 80));\n        assertEquals(getLongestSubSeq(arr5), Arrays.asList(1, 2, 4, 7, 11, 14));\n    }\n\n}\n```\n\n\nThe cost is strictly O(n) because of the relation T(n) = T(n-1) + O(1) => T(n) = O(n)\n\nCan anyone find a case where this fails, or any bugs there are? Many thanks.\n\nUPDATE:\nThanks everyone for pointing out my mistake in previous implementation. Final code below passes all test cases that it used to fail. \n\nThe idea is to list (compute) all possible increasing subsequences (each starts from index i from 0 to N.length-1) and pick the longest subsequence. I use memoization (using a hash table) to avoid recomputation of already computed subsequences - so for each starting index we only compute all increasing subsequences once.\n\nHowever, I am not certain of how to formally derive time complexity in this case - I would be grateful if anyone can shed light on this. Many thanks.\n\n```\nimport static org.junit.Assert.assertEquals;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.Test;\n\npublic class LongestIncreasingSubsequence {\n\n    public static List<Integer> getLongestSubSeq(int[] arr) {\n        List<Integer> longest = new ArrayList<>();\n        for (int i = 0; i < arr.length; i++) {\n            List<Integer> candidate = longestSubseqStartsWith(arr, i);\n            if (longest.size() < candidate.size()) {\n                longest = candidate;\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (Integer i : longest) {\n            result.add(arr[i]);\n        }\n\n        System.out.println(result.toString());\n        cache = new HashMap<>(); //new cache otherwise collision in next use - because object is static\n        return result;\n    }\n\n    private static Map<Integer, List<Integer>> cache = new HashMap<>();\n    private static List<Integer> longestSubseqStartsWith(int[] arr, int startIndex) {\n        if (cache.containsKey(startIndex)) { //check if already computed\n            //must always return a clone otherwise object sharing messes things up\n            return new ArrayList<>(cache.get(startIndex)); \n        }\n\n        if (startIndex == arr.length-1) {\n            List<Integer> singleton = new ArrayList<>();\n            singleton.add(startIndex);\n            return singleton;\n        }\n\n        List<Integer> longest = new ArrayList<>();\n        for (int i = startIndex + 1; i < arr.length; i++) {\n            if (arr[startIndex] < arr[i]) {\n                List<Integer> longestOnRight = longestSubseqStartsWith(arr, i);\n                if (longestOnRight.size() > longest.size()) {\n                    longest = longestOnRight;\n                }\n            }\n        }\n\n        longest.add(0, startIndex);\n        List<Integer> cloneOfLongest = new ArrayList<>(longest);\n        //must always cache a clone otherwise object sharing messes things up\n        cache.put(startIndex, cloneOfLongest); //remember this subsequence\n        return longest;\n    }\n\n    @Test\n    public void test() {\n        int[] arr1 = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15, 1};\n        int[] arr2 = {7, 0, 9, 2, 8, 4, 1};\n        int[] arr3 = {9, 11, 2, 13, 7, 15};\n        int[] arr4 = {10, 22, 9, 33, 21, 50, 41, 60, 80};\n        int[] arr5 = {1, 2, 9, 4, 7, 3, 11, 8, 14, 6};\n        int[] arr6 = {0,0,0,0,0,0,1,1,1,1,2,3,0,0,0,1,1,0,1,1,0,1,0,3};\n        int[] arr7 = {0,1,2,0,1,3};\n        int[] arr8 = {0,1,2,3,4,5,1,3,8};\n        assertEquals(getLongestSubSeq(arr1), Arrays.asList(0, 4, 6, 9, 13, 15));\n        assertEquals(getLongestSubSeq(arr2), Arrays.asList(0, 2, 8));\n        assertEquals(getLongestSubSeq(arr3), Arrays.asList(9, 11, 13, 15));\n        assertEquals(getLongestSubSeq(arr4), Arrays.asList(10, 22, 33, 50, 60, 80));\n        assertEquals(getLongestSubSeq(arr5), Arrays.asList(1, 2, 4, 7, 11, 14));\n        assertEquals(getLongestSubSeq(arr6), Arrays.asList(0,1,2,3));\n        assertEquals(getLongestSubSeq(arr7), Arrays.asList(0,1,2,3));\n        assertEquals(getLongestSubSeq(arr8), Arrays.asList(0, 1, 2, 3, 4, 5, 8));\n    }\n\n    public static void main(String[] args) {\n        int[] arr1 = {7, 0, 9, 2, 8, 4, 1};\n        System.out.println(getLongestSubSeq(arr1));\n    }\n\n}\n```\n\n    ", "Answer": "\r\nYour program fails in this test case\n\n```\nint[] arr5 = {0,0,0,0,0,0,1,1,1,1,2,3,0,0,0,1,1,0,1,1,0,1,0,3};\n```\n\n\nYour result ```\n[0, 1, 3]```\n\nShouldn't it be ```\n[0,1,2,3]```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Common Increasing Subsequence Dynamic Programming\r\n                \r\nI'm working on finding a solution to the longest common increasing sub sequence problem. Here's a link if you're not familiar with it. LCIS\n\nThe problem can basically be reduced to two different problems. 'Longest common subsequence' and 'Longest increasing subsequence'. Here's the recursive solution to Longest common subsequence: \n\n```\nLCS(S,n,T,m)\n{\nif (n==0 || m==0) return 0;\nif (S[n] == T[m]) result = 1 + LCS(S,n-1,T,m-1); // no harm in matching up\nelse result = max( LCS(S,n-1,T,m), LCS(S,n,T,m-1) );\nreturn result;\n}\n```\n\n\nBased on that and the general recursive formula found here I've been trying to implement the algorithm so I can use dynamic programming. \n\n```\nint lcis(int S[4], int n, int T[4], int m, int prev)\n{\n  int result;\n\n  if (n == 0 || m  == 0)\n    return 1;\n  if (S[n] == T[m] && S[n] > S[prev]){\n    result = myMax(1 + lcis(S, n-1, T, m-1, n), lcis(S, n-1, T, m, prev),\n                    lcis(S, n, T, m-1, prev)) ;\n  }\n  else\n    result = max(lcis(S,n-1,T,m, prev), lcis(S,n,T,m-1, prev));\n\n  return result;\n}\n```\n\n\nObviously this does not give the correct solution. Any help would be appreciated. \n\nFor example, if I give it the two sequences {1, 2, 4, 5} and {12, 1, 2, 4} I get an output of 2. The correct output here would be 3, for the sub sequence {1,2,4}\n\nEDIT: \n\nHere is some revised code, after suggestions from below. Still not 100% correct. But closer. Note I am now using vectors, but this shouldn't change anything. \n\n```\nint lcis(vector<int> S, int n, vector<int> T, int m, int size)\n{\n  int result;\n\n  if (n < 0 || m < 0)\n    return 0;\n  if (S[n] == T[m] && (n == size - 1 || S[n] < S[n + 1] )){\n    result = myMax(1 + lcis(S, n - 1, T, m - 1, size), lcis(S, n - 1, T, m, size),\n                    lcis(S, n, T, m - 1, size));\n  }\n  else\n    result = max(lcis(S, n-1, T, m, size), lcis(S, n, T, m-1, size));\n\n  return result;\n}\n```\n\n    ", "Answer": "\r\nRemember that you are going backward through the array. So this test\n\n```\n S[n] > S[prev]\n```\n\n\nShould be the other way around:\n\n```\n S[n] < S[prev]\n```\n\n\nI am not sure why you need prev at all, as it should always be n+1, so maybe use\n\n```\nif (S[n] == T[m] && n < 3 && S[n] < S[n+1])\n```\n\n\nIf you need to make it work for any size, then either pass the size in, or just a flag to say don't check n+1\n\nEdit:\n\nMy mistake - you want to be going through the first if case when ```\nn == 3```\n (or size), as you are at the start of a (potentially) increasing subsequence.\n\nThe if test should be \n\n```\nif (S[n] == T[m] && (n == 3 || S[n] < S[n+1]))\n```\n\n\nNote that this if test:\n\n```\nif (n == 0 || m  == 0)\n    return 1;\n```\n\n\nis ignoring the first element of either sequence (and assuming it is at the end of an increasing subsequence). What is needed is to stop the recursion when you have gone before the start of either sequence. You also know that when you have gone before the start of the sequence, you can't possibly be in a subsequence, so you can return 0 for the length of the subsequence. So the test should be\n\n```\nif (n < 0 || m < 0)\n    return 0;\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Circular Longest Increasing Subsequence\r\n                \r\nHow can I find the length of Longest Increasing Sub-sequence if the numbers are arranged in circular fashion. For example:\n\n```\nLIS of 3, 2, 1 is 3 [1, 2, 3].```\n\n\nP.S I know how to solve Linear LIS in O(nlogn).\n\nProblem Source: https://www.codechef.com/problems/D2/\n\nUpdate: The LIS has to be calculated by going through the circle only once. \nExample 2: ```\nLIS of 1, 4, 3```\n is 2 and that could be either of ```\n1, 3```\n  or ```\n1, 4```\n or ```\n3, 4```\n.\nThanks\n    ", "Answer": "\r\nThe example in question is wrong. circular rotation of [1,2,3] would be [2,3,1] or [3,1,2]. \n\nIn which case, we can solve it similar way as longest increasing subsequence. As:\n\n\nSort the list in ascending order.\nFind min element in the original list. \nStart iteration from min_index in original list and compare it with sorted list, and create intermediate array L[i][j] with same logic as longest common subsequence. i will vary from min_index to (i+n-1)%n\nFinally return L[max_index][n]\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Node structure in longest increasing subsequence algorithm (Jacobson & Vo)\r\n                \r\nI have a problem in understanding the node structure for the calculation of the complete longest increasing subsequence (lis) in the paper \"Heaviest Increasing/Common Subsequence Problems\" by Jacobson and Vo.\n\nHere is the pseudo code from the paper:\n\n\n\nWhat is meant with\n\n\n  node is an auxiliary array that, for each element in L, contains a record of an element that precedes this element in an increasing subsequence. The function newnode() constructs such records and links them into a directed graph. At the end of the algorithm, we can search from the maximal element of L to recover an LIS of sigma.\n\n\n? How would you implement this structure?\n\nDo I have to construct a directed graph with all the elements of the sequence as vertices (plus a nil-vertex) and edges \"\\sigma_i -> s\" and then search for the longest path starting at the maximal element of L (and ending at nil)? Isn't there a more effective way to get the complete lis?\n\n\n\nMy second question: Is this algorithm as fast as the algorithm described in wikipedia? If not: Can I modify the algorithm from wikipedia as well to calculate heaviest common subsequences as described in the paper?\n    ", "Answer": "\r\nI'd implement the array with an array and the graph as a singly-linked list with structure sharing. To wit, in generic C++,\n\n```\n#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <utility>\n#include <vector>\n\ntemplate <typename T>\nstruct Node {\n  explicit Node(const T& e) : element(e) {}\n\n  T element;\n  std::size_t index = 0;\n  Node* previous = nullptr;\n};\n\ntemplate <typename T, typename Compare>\nstd::vector<T> LongestIncreasingSubsequence(const std::vector<T>& elements,\n                                            Compare compare) {\n  if (elements.empty()) {\n    return {};\n  }\n  std::vector<std::unique_ptr<Node<T>>> node_ownership;\n  node_ownership.reserve(elements.size());\n  std::vector<Node<T>*> tableau;\n  for (const T& element : elements) {\n    auto node = std::make_unique<Node<T>>(element);\n    auto it = std::lower_bound(tableau.begin(), tableau.end(), node.get(),\n                               [&](const Node<T>* a, const Node<T>* b) {\n                                 return compare(a->element, b->element);\n                               });\n    if (it != tableau.begin()) {\n      auto previous = it[-1];\n      node->index = previous->index + 1;\n      node->previous = previous;\n    }\n    if (it != tableau.end()) {\n      *it = node.get();\n    } else {\n      tableau.push_back(node.get());\n    }\n    node_ownership.push_back(std::move(node));\n  }\n  Node<T>* longest = *std::max_element(\n      tableau.begin(), tableau.end(),\n      [](Node<T>* a, Node<T>* b) { return a->index < b->index; });\n  std::vector<T> result(longest->index + 1);\n  for (; longest != nullptr; longest = longest->previous) {\n    result.at(longest->index) = longest->element;\n  }\n  return result;\n}\n\nint main() {\n  for (int x : LongestIncreasingSubsequence(\n           std::vector<int>{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3},\n           std::less<int>())) {\n    std::cout << x << '\\n';\n  }\n}\n```\n\n\nIf you're fortunate enough to be working in a language with garbage collection, you can ignore the business with ```\nnode_ownership```\n and ```\nstd::move```\n.\n\nHere's a Python version.\n\n```\nimport bisect\n\n\ndef longest_increasing_subsequence(elements):\n    elements = list(elements)\n    if not elements:\n        return []\n    # Build the tableau\n    tableau_elements = []\n    tableau_indexes = []\n    predecessors = []\n    for i, element in enumerate(elements):\n        j = bisect.bisect_left(tableau_elements, element)\n        predecessors.append(tableau_indexes[j - 1] if j > 0 else None)\n        if j < len(tableau_elements):\n            tableau_elements[j] = element\n            tableau_indexes[j] = i\n        else:\n            tableau_elements.append(element)\n            tableau_indexes.append(i)\n    # Find the subsequence lengths\n    lengths = []\n    for i, predecessor in enumerate(predecessors):\n        lengths.append(1 if predecessor is None else lengths[predecessor] + 1)\n    # Extract the best subsequence\n    best = max(range(len(lengths)), key=lambda i: lengths[i])\n    subsequence = []\n    while best is not None:\n        subsequence.append(elements[best])\n        best = predecessors[best]\n    subsequence.reverse()\n    return subsequence\n\n\nprint(longest_increasing_subsequence([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3]))\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence, algorithm works wrong, no idea why\r\n                \r\nI made an implementation of Longest Increasing Subsequence (LIS) algorithm, as I see it would work, but results are totally mess.\n\n```\ndef lis():\n    #D = map(int, raw_input().split())\n    D = [3, 2, 6, 4, 5, 1]\n    L = [[] for i in range(len(D))]\n    L[0].append(D[0])\n    for i in range(len(D)):\n        for j in range(0,i):\n            if D[i] > D[j]:\n                L[i] = L[j]\n        L[i].append(D[i])\n    print L\n```\n\n\nReturned result:\n\n```\n[[3], [2, 6, 4, 5], [2, 6, 4, 5], [2, 6, 4, 5], [2, 6, 4, 5], [1]]\n```\n\n\nWhat it should be:\n\n```\n[[3], [2], [2, 6], [2, 4], [2, 4, 5], [1]]\n```\n\n\nAs I saw in debugger when we have:\n\n```\nL[i] = L[j]\n```\n\n\nNot only ```\nL[i]```\n gets new values, but other lists on the ```\nmain (L)```\n list too...\n\nI don't know how to avoid it. It looks that lists in Python are totally different than vectors languages from C family...\n\nI'm fighting with this for a long time. Huge beer to someone who gonna find what is wrong :(\n    ", "Answer": "\r\nWhen you state ```\nL[i] = L[j]```\n you do not copy the content of the list, you simply copy a reference: from now on ```\nL[i]```\n and ```\nL[j]```\n point to the same list and changes made through ```\nL[i]```\n will reflect when you obtain ```\nL[j]```\n.\n\nA simply fix is simply to copy the list:\n\n\ndef lis():\n    #D = map(int, raw_input().split())\n    D = [3, 2, 6, 4, 5, 1]\n    L = [[] for i in range(len(D))]\n    L[0].append(D[0])\n    for i in range(len(D)):\n        for j in range(0,i):\n            if D[i] > D[j]:\n                L[i] = list(L[j])\n        L[i].append(D[i])\n    print(L)\n\n\nNow hoever your algorithm does not work anymore (it was not working in the first place nevertheless). When running your (fixed) code, you get:\n\n```\n>>> lis()\n[[3, 3], [2], [2, 6], [2, 4], [2, 4, 5], [1]]\n```\n\n\nThe ```\n3```\n occurs twice in the first list, you can solve this by removing the ```\n.append```\n before the ```\nfor```\n loop. So the final version is:\n\n```\ndef lis():\n    #D = map(int, raw_input().split())\n    D = [3, 2, 6, 4, 5, 1]\n    L = [[] for i in range(len(D))] #removed the next line\n    for i in range(len(D)):\n        for j in range(0,i):\n            if D[i] > D[j]:\n                L[i] = list(L[j])\n        L[i].append(D[i])\n    print(L)\n```\n\n\nWhich produces:\n\n```\n>>> lis()\n[[3], [2], [2, 6], [2, 4], [2, 4, 5], [1]]\n```\n\n\n\n  Note: based on your comment you use python-2.7, from python-3.x there is a method called ```\n.copy()```\n on lists that you can call.\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to find the actual sequence of a Longest Increasing Subsequence?\r\n                \r\nThis is not a homework problem. I am reviewing myself of the Longest Increasing Subsequence problem. I read every where online. I understand how to find the \"length\", but I don't understand how to back-trace the actual sequence. I am using the patience sorting algorithm to find the length. Can anyone explain how to find the actual sequence? I do not really understand the version in Wikipedia. Can someone explain in a different method or different way?\n\nThanks.\n    ", "Answer": "\r\nLets define as max(j) as the longest increasing subsequence up to A[j]. There are two options: or we use A[j] in this subsequence, or we don't.\n\nIf we dont use it, then the value will be max(j-1). If we do use it, then the value will be \nmax(i)+1, when i is the biggest index such that i < j and A[i] < A[j]. (Here we assume that the max(i) sequence uses i- not neccessary true, but we can solve this issue by saving for each cell 2 values- the max(j) value, and max*(j), when max*(j) is the longest increasing subsequence up to A[j] that uses A[j]. max*(j) will be calculated each time as max*(i)+1). \n\nTo sum up, the recursive formula for calculating max(j) will be:\nmax{max(j-1),max*(i)+1},and max*(j)= max*(i)+1.\nIn each array cell you can save a pointer, that tells you if you chose to use the A[j] cell or not. In this way you can find all the sequence while moving backwards on the array.\n\nTime Complexity: The complexity of the recursive formula and finding the sequence at the end is O(n). The problem here is finding for each A[j] the corresponding A[i] such that i is the biggest index such that i < j, A[i] < A[j].\nOf course you can do it naivly in O(n^2) (from each cell go backwards until you find this i). If you want to do better then I'm pretty sure that you can do it in O(nlogn) in the following way:\n\n*Sort your Array.\n1) go for the smallest integer in the array, and notate is position in the array as k.\n\n2)For A[k+1], we have of course A[k] < A[k+1]. If A[k+1]>A[k+2] then k will feet to the k+2 cell as well, and so on until we have A[k+m] < A[k+m+1], and then k+m is feet to k+m+1,\n\n3)delete all the cells that you found thier corresponding cell in the previous stage\n\n4) return to 1.\n\nHoped that it help. Please notice that I thought about it all alone, therefore there is a very small chance that there is some mistake here- please be convinced that I'm right and ask for more clarifications, if you need. \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How does algorithm for Longest increasing subsequence [O(nlogn)] work?\r\n                \r\nI found algorithm mentioned in The Hitchhiker’s Guide to the Programming Contests (note: this implementation assumes there are no duplicates in the list):\n\n```\nset<int> st;\nset<int>::iterator it;\nst.clear();\n\nfor(i=0; i<n; i++) {\n\n  st.insert(array[i]); it=st.find(array[i]);\n\n  it++; if(it!=st.end()) st.erase(it);\n}\n\ncout<<st.size()<<endl;\n```\n\n\nIt's an algorithm to find longest increasing subsequence in O(NlogN). If I try to work it with few test cases, it seems to work. But I still couldn't figure out its correctness logic. Also, it doesn't look so intuitive to me. \n\nCan anyone help me gain insight as to why this algorithm works correctly?\n    ", "Answer": "\r\nStatement: For each i, length of current set is equal to the length of the largest increasing subsequence.\n\nProof: Lets use the method of induction:\n\nBase case : Trivially true.\n\nInduction hypothesis: Suppose we have processed i-1 elements and the length of the set is LIS[i-1], i.e the length of the LIS possible with first i-1 elements.\n\nInduction step: Inserting an element array[i] in the set will result in two cases.\n\n\nA[i] >= set.last() : In this case A[i] will be the last element in the set and hence the LIS[i] = LIS[i-1]+1.\nA[i] < set.last() : In this case we insert A[i] into the set and knock off element just greater than A[i] in the sorted order. LIS[i] = LIS[i-1] + 1(adding A[i]) - 1 (removing one elem > A[i]). Which is true. Hence proved.\n\n\nTo explain the big picture. Inserting A[i] into the set will either add to the LIS[i-1] or will create a LIS of its own, which will be the elements from 0th position to the position of the ith element. \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How can we assure that a Bitonic sequence will be formed from one longest increasing subsequence and one longest decreasing subsequence?\r\n                \r\nFor example we have an ```\narray[]={1,3,2,7,4,6,8,9}```\n.\n\nlongest increasing subsequence of this ```\narray[]={1,3,4,6,8,9}```\n and its length=6.\n\nlongest decreasing subsequence of this ```\narray[]={3,2}```\n and its length=2.\n\nThen is Bitonic subsequence of this ```\narray[]={1,3,4,6,8,9}```\n? if Yes then its length=6.But length of Bitonic subsequence =length of lis + length of lds -1,\nhere they are not equal.\n\nif no how can you prove that length of bitonic subsequence=length of lis+length of lds-1\n\nCorrect me if I am wrong.\nThank you.\n    ", "Answer": "\r\nThe formula is correct and gives out 6 only... Consider the LIS[](as the LIS array) and LDS[] (as LDS array).. Now when  you iterate from left to right you reach the position where LIS[index]=6 i.e. LIS till array[7] is 6.. Now LDS[index=7] is 1 (Trivially one element is the maximum length of series)... NOW LIS[7]+LDS[7]-1=(6+1-1)\n\nNow the Proof you wanted for Bitonic sequence... \nLIS[i],LDS[i] represents the Longest Increasing / Decreasing sequence till i!\nNow, eventually you want to maximise it that's why you search over the sample space! So the answer will be maximum of (LIS[i]+LDS[i]-1) 0<=i<=n-1 ...\nThat -1 is due to repeated inclusion of the element at i th position!\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find Longest Increasing Subsequence with adjacent elements having a difference of at least k\r\n                \r\nGiven an array ```\nA```\n of size ```\nn```\n and a number ```\nk```\n, find the size of the Longest Increasing Subsequence (say, ```\nB[]```\n) where ```\nB[i+1] >= B[i] + k```\n. \n\n```\n2 <= n <= 10^6\nA[i] <= 10^5\nk <= 10^5\n```\n\n\nSample Input:\n\n```\nA = [1, 3, 1, 4, 5, 9, 12]\nk = 2\nThe LIS in this case will be: [1, 3, 5, 9, 12]\nAnswer = 5\n```\n\n\nHow to solve in complexity ```\nO(N * log(N))```\n (or better)? I have described my ```\nO(N^2 * log(N))```\n approach below:\n\nI'll use a Data Structure similar to ```\nstd::multiset```\n (in C++). ```\nstd::multiset```\n will ensure that all the elements in the multiset will be sorted at any point of time.\n\nI'll make a multiset of pairs ```\nstd::multiset <pair <int, int> > V```\n where the first element in the pair will be the element from array ```\nA```\n and the second element will be the size of the Longest Increasing Subsequence such that the LIS ends at the first element of the pair. Also, in each case, the first pair in the multiset will be ```\n<-∞, 0>```\n.\n\n```\nint answer() {\n\n    multiset < pair < int, int> > V;\n    V.insert(<-∞, 0>);\n    final_answer = 1\n\n    for (element e) in A {\n        maximum_possible = 1\n\n        for (pair p) in V {\n            if (p.first > e - k)\n                break;\n            maximum_possible = max(p.second + 1, maximum_possible)\n        }\n        V.insert(<A[i], maximum_possible>)\n        final_answer = max(final_answer, maximum_possible)\n    }\n\n    return final_answer;\n}\n```\n\n    ", "Answer": "\r\nYou could do this in ```\nO(N^2)```\n by using standard dynamic programming for LIS:\nOnly change is instead of ```\nnums[i] > nums[j]```\n in the if condition just change it to ```\nnums[i] - nums[j] >= K```\n\n\n```\n    public int lengthOfLISAtLeastKUsingDP(int[] nums, int K) {\n        int[] dp = new int[nums.length+1];\n        Arrays.fill(dp, 1);\n        int ans = 0;\n        for ( int i = 0; i < nums.length; i++ ) {\n            for ( int j = 0; j < i; j++ ) {\n                if ( nums[i] - nums[j] >= K ) {\n                    dp[i] = Math.max( dp[i], 1 + dp[j] );\n                }\n            }\n            ans = Math.max( ans, dp[i] ); \n        }\n        return ans;\n    }\n```\n\n\nHaving said that, I believe you could do it in ```\nO(N*log(N))```\n like this:\n\n\nCreate an empty list.\nAdd first element to list.\nTraverse the list, if you encounter an element which is bigger than the last element of the list by more than or equal to K, add it to the list.\nIf it is not, then do a binary search in the list for that element, if it is found there is nothing to do.\nOtherwise look at the insertion point. The insertion point is either greater than size of list or lesser than it.\nIf it is greater than size AND if the difference between that element and last element in the list is greater than K, add it to list.\nIf the insertion point is zero, just replace the 0th element.\nBut if the insertion point is not zero, look at its left element. If their difference is greater than or equal to K, insert the element there.\nThe size of resulting list is the answer.\n\n\n```\npublic int lengthOfLISAtLeastK(int[] nums, int K) {\n    if ( nums == null ) return 0;\n    if ( nums.length <= 1 ) return nums.length;\n    List<Integer> list = new ArrayList<Integer>(nums.length);\n    list.add( 0, nums[0] );\n    for ( int i = 1; i < nums.length; i++ ) {\n        if ( nums[i] - list.get( list.size() - 1 ) >= K ) {\n            list.add( nums[i] );\n        } else  {\n            int index = Collections.binarySearch( list, nums[i] );\n            if ( index >= 0 && index < nums.length ) {\n                list.set( index, nums[i] );\n            } else {\n                if ( -index - 1 > list.size() - 1 ) {\n                    if ( nums[i] - list.get(list.size()-1) >= K ) {\n                        list.add(nums[i]);\n                    }\n                } else {\n                     if ( -index - 1 == 0 ) {\n                        list.set(-index-1, nums[i]);\n                    } else if ( nums[i] - list.get(-index-2) >= K ) {\n                        list.set(-index-1, nums[i]);\n                    }\n                }\n            }\n        }\n    }\n    return list.size();\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Vectorization or efficient way to calculate Longest Increasing subsequence of tuples with Pandas\r\n                \r\nUsing pandas/python, I want to calculate the longest increasing subsequence of tuples for each ```\nDTE```\n group, but efficiently with 13M rows. Right now, using apply/iteration, takes about 10 hours.\nHere's roughly my problem:\n\n\n\n\nDTE\nStrike\nBid\nAsk\n\n\n\n\n1\n100\n10\n11\n\n\n1\n200\n16\n17\n\n\n1\n300\n17\n18\n\n\n1\n400\n11\n12\n\n\n1\n500\n12\n13\n\n\n1\n600\n13\n14\n\n\n2\n100\n10\n30\n\n\n2\n200\n15\n20\n\n\n2\n300\n16\n21\n\n\n\n\n```\nimport pandas as pd\npd.DataFrame({\n    'DTE': [1,1,1,1,1,1,2,2,2],\n    'Strike': [100,200,300,400,500,600,100,200,300],\n    'Bid': [10,16,17,11,12,13,10,15,16],\n    'Ask': [11,17,18,12,13,14,30,20,21],\n})\n```\n\nI would like to:\n\ngroup these by ```\nDTE```\n. Here we have two groups (DTE 1 and DTE 2). Then within each group...\nfind the longest paired increasing subsequence. Sort-ordering is determined by ```\nStrike```\n, which is unique for each DTE group. So 200 Strike comes after 100 Strike.\n\nthus, the Bid and the Ask of 200 Strike must be greater than or equal to (not strict) the 100 Strike bid and ask.\nany strikes in between that does NOT have bids and asks both increasing in value are deleted.\n\n\n\nIn this case, the answer would be:\n\n\n\n\nDTE\nStrike\nBid\nAsk\n\n\n\n\n1\n100\n10\n11\n\n\n1\n400\n11\n12\n\n\n1\n500\n12\n13\n\n\n1\n600\n13\n14\n\n\n2\n200\n15\n20\n\n\n2\n300\n16\n21\n\n\n\n\nOnly the LONGEST increasing subsequence is kept for EACH GROUP, not just any increasing subsequence. All other rows are dropped.\nNote that standard Longest increasing subsequence algorithm of ```\nO(nlogn)```\n does not work. See https://www.quora.com/How-can-the-SPOJ-problem-LIS2-be-solved for why. The example group DTE 2 values will fail for standard O(nlogn) LIS solution. I am currently using the standard LIS solution for O(n^2). There is a more complicated O(nlog^2n), but I do not think that is my bottleneck.\nSince each row must refer to the previous rows to have already computed the longest increasing subsequence at that point, it seems you cannot do this in parallel? which means you can't vectorize? Would that mean that the only way to speed this up would be to use cython? Or are there other concurrent solutions?\nMy current solution looks like this:\n```\ndef modify_lsc_row(row, df, longest_lsc):\n    lsc_predecessor_count = 0\n    lsc_predecessor_index = -1\n    df_predecessors = df[(df['Bid'] <= row.Bid) &\n                         (df['Ask'] <= row.Ask) &\n                         (df['lsc_count'] != -1)]\n    if len(df_predecessors) > 0:\n        df_predecessors = df_predecessors[(df_predecessors['lsc_count'] == df_predecessors['lsc_count'].max())]\n        lsc_predecessor_index = df_predecessors.index.max()\n        lsc_predecessor_count = df_predecessors.at[lsc_predecessor_index, 'lsc_count']\n\n    new_predecessor_count = lsc_predecessor_count + 1\n    df.at[row.name, 'lsc_count'] = new_predecessor_count\n    df.at[row.name, 'prev_index'] = lsc_predecessor_index\n\n    if new_predecessor_count >= longest_lsc.lsc_count:\n        longest_lsc.lsc_count = new_predecessor_count\n        longest_lsc.lsc_index = row.name\n\ndef longest_increasing_bid_ask_subsequence(df):\n    original_columns = df.columns\n    df.sort_values(['Strike'], ascending=True, inplace=True)\n\n    df.set_index(['Strike'], inplace=True)\n    assert df.index.is_unique\n\n    longest_lsc = LongestLsc()\n    longest_lsc.lsc_index = df.index.max()\n    longest_lsc.lsc_count = 1\n\n    df['lsc_count'] = -1\n\n    df.apply(lambda row: modify_lsc_row(row, df, longest_lsc),\n                              axis=1)\n\n    while longest_lsc.lsc_index != -1:\n        df.at[longest_lsc.lsc_index, 'keep'] = True\n        longest_lsc.lsc_index = df.at[longest_lsc.lsc_index, 'prev_index']\n\n    df.dropna(inplace=True)\n\n\n    return df.reset_index()[original_columns]\n\n\ndf_groups = df.groupby(['DTE'], group_keys=False, as_index=False)\ndf_groups.apply(longest_increasing_bid_ask_subsequence)\n```\n\nUpdate: https://stackoverflow.com/users/15862569/alexander-volkovsky has mentioned I can use pandarallel to parallelize each DTE since those are each independent. That does speed it up by 5x or so. However, I would like to speed it up much more (particularly the actual optimization of the longest increasing subsequence). Separately, pandarallel doesn't seem to work using pycharm (seems to be a known issue https://github.com/nalepae/pandarallel/issues/76 )\nUpdate: Used https://stackoverflow.com/users/15862569/alexander-volkovsky suggestions: namely numba, numpy. Pandarallel actually slowed things down as my thing got faster and faster (probably due to overhead). So removed that. 10 hours -> 2.8 minutes. Quite the success. Some of the biggest slowdowns was changing the n^2 to use numba. Also not using pandas groupby apply even if just for the numba function. I found out that the time for groupby+apply == groupby + pd.concat. and you can remove the pd.concat by using what Alexander said where you just select the rows you want to keep in the end (instead of concating all the different df groups together). Tons of other small optimizations mostly discovered by using the line profiler.\nUpdated code as follows:\n```\n@njit\ndef set_list_indices(bids, asks, indices, indices_to_keep):\n    entries = len(indices)\n\n    lis_count = np.full(entries, 0)\n    prev_index = np.full(entries, -1)\n\n    longest_lis_count = -1\n    longest_lis_index = -1\n\n    for i in range(entries):\n        predecessor_counts = np.where((bids <= bids[i]) & (asks <= asks[i]), lis_count, 0)\n        best_predecessor_index = len(predecessor_counts) - np.argmax(predecessor_counts[::-1]) - 1\n\n        if best_predecessor_index < i:\n            prev_index[i] = best_predecessor_index\n\n        new_count = predecessor_counts[best_predecessor_index] + 1\n        lis_count[i] = new_count\n\n        if new_count >= longest_lis_count:\n            longest_lis_count = new_count\n            longest_lis_index = i\n\n    while longest_lis_index != -1:\n        indices_to_keep[indices[longest_lis_index]] = True\n        longest_lis_index = prev_index[longest_lis_index]\n\n\n# necessary for lis algo, and groupby will preserve the order\ndf = df.sort_values(['Strike'], ascending=True)\n\n# necessary for rows that were dropped. need reindexing for lis algo\ndf = df.reset_index(drop=True)\n\ndf_groups = df.groupby(['DTE'])\n\nrow_indices_to_keep = np.full(len(df.index), False, dtype=bool)\nfor name, group in df_groups:\n    bids = group['Bid'].to_numpy()\n    asks = group['Ask'].to_numpy()\n    indices = group.index.to_numpy()\n    set_list_indices(bids, asks, indices, row_indices_to_keep)\n\ndf = df.iloc[row_indices_to_keep]\n```\n\n    ", "Answer": "\r\nWhat is the complexity of your algorithm of finding the longest increasing subsequence?\nThis article provides an algorithm with the complexity of O(n log n).\nUpd: doesn't work.\nYou don't even need to modify the code, because in python comparison works for tuples:  ```\nassert (1, 2) < (3, 4)```\n\n```\n>>> seq=[(10, 11), (16, 17), (17, 18), (11, 12), (12, 13), (13, 14)]\n>>> subsequence(seq)\n[(10, 11), (11, 12), (12, 13), (13, 14)]\n```\n\n\n\nSince each row must refer to the previous rows to have already computed the longest increasing subsequence at that point, it seems you cannot do this in parallel?\n\nYes, but you can calculate the sequence in parallel for every DTE. You could try something like pandarallel for parallel aggregation after the ```\n.groupby()```\n.\n```\nfrom pandarallel import pandarallel\npandarallel.initialize()\n\n# just an example of usage:\ndf.groupby(\"DTE\").parallel_apply(subsequence)\n```\n\nAlso try to get rid of pandas (it's pretty slow) and use raw numpy arrays and python structs. You can calculate LIS indexes using an O(n^2) algorithm and then just select required rows using ```\ndf.iloc```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "memoization for recursive Longest Increasing subsequence\r\n                \r\nI came up with simple following recursive solution for Longest increasing sub-sequence.\nBut, Can you help to include memoization into this recursive solution.\n\n```\npublic int findLIS(int a[], int maxSoFar, int item, int count) {\n\n        if(item == a.length) {\n            return count;\n        }\n        int length1 = findLIS(a,maxSoFar, item+1, count);\n        int length2 = 0;\n        if(a[item] > maxSoFar) {\n\n            length2 = findLIS(a, a[item], item+1, count + 1);\n        }\n        return Math.max(length1, length2);\n}\n```\n\n\nPS: This not a homework question, it is more of my interest.\n    ", "Answer": "\r\nUse a ```\nMap<Pair<Integer,Integer>,Integer>```\n, and at the beginning of the method add:\n\n```\nInteger cache = map.get(new Pair<Integer,Integer>(maxSoFar,item));\nif (cache != null) return cache;\n```\n\n\nEach time you ```\nreturn```\n anything - make sure to write ```\n(maxSoFar,item)=returnValue```\n to the map.\n\nThe idea is to map between the pair that represent where you are in the calculation - to the maximal value found for this state, to avoid recalculating it.\n\n\n\nIt seems java, so you can use apache commons Pair as your ```\nPair```\n interface.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "What is the most optimized algorithm to find ALL longest increasing subsequence?\r\n                \r\nI am trying to find ALL longest increasing subsequence of an array. I could manage to find one such LIS in ```\nO(n log n)```\n using binary search as suggested on Wikipedia.\n\nCan someone help me as how can I extend the same for finding ALL such LIS. I can't find better way of doing it in more than ```\nO(n²)```\n. Any suggestion to optimization would be really helpful.\n    ", "Answer": "\r\nConsider this list:\n\n```\n2,1, 4,3, 6,5, 8,7, 10,9, ..., 2m,2m-1\n```\n\n\nThe longest increasing sequence length of this list is ```\nm = n/2```\n. You can trivially construct such a sequence by picking one element from each \"pair\" of items. Since there are ```\nm```\n such pairs, and the choices are independent, there are ```\n2^m```\n longest increasing sequences.\n\nSo your algorithm can't be faster than ```\nΩ(2^(n/2))```\n, because there's at least that much output in some cases.\n\nTo get around this you need to tweak the problem, perhaps by doing an output-sensitive analysis or by counting the number of sequences instead of actually generating them. Another alternative is to output a compact way that can be used later to generate all the sequences, which is what linear time unification algorithms do.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "C++: (LIS)Longest Increasing Subsequence using Segment Tree\r\n                \r\nGiven an array of N elements, I need to find length of longest increasing subsequence for T different values of L and R. I tried segment trees, I'm getting Time Limit Exceeded.\n\n```\nusing namespace std;\n\n\n  int a[1000001],ans[1000001],out;\n  int T[1000001];\n  int query(int v,int tl,int tr,int l,int r){\n      if (l>r) return 0;\n      if (tl==l && tr==r){\n          return T[v];\n      };\n      int tm=(tl+tr)/2;\n      return max(query(2*v,tl,tm,l,min(tm,r)),query(2*v+1,tm+1,tr,max(tm+1,l),r));\n  };\n  void update(int v,int tl,int tr,int pos,int val)\n  {\n       if (tl==tr){\n          T[v]=val;\n          return;\n       };\n       ll tm=(tl+tr)/2;\n       if (tm>=pos) update(2*v,tl,tm,pos,val); else update(2*v+1,tm+1,tr,pos,val);\n       T[v]=max(T[2*v],T[2*v+1]);\n  };\nint main()\n{\n\n        int n,i,t;\n        cin>>n>>t;\n       for (i=1;i<=n;i++)\n          cin>>a[i];\n\n        for(int j=0;j<t;j++)\n        {\n            int l,r;\n           cin>>l>>r;\n            for (i=l;i<=r;i++)\n           { \n               ans[a[i]]=query(1,1,n,1,a[i]-1)+1;\n               update(1,1,n,a[i],ans[a[i]]);\n               out=max(out,ans[a[i]]);\n           }\n\n           cout<<out;\n           out=0;\n\n        }\n\n    }\n\n\n return 0;\n}\n```\n\n\nNow I need to find out LIS for every given pair of L, R. Can someone help improvising the time complexity for T queries ? \n\nIs there a way to calculate the answer of each query using separate for loop and remove the nested for loop and use inner for loop to calculate the LIS for the whole array at once ?\n\nUpdate : The previous error is sorted out so I updated the question.\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "When adding cache to my longest increasing subsequence solution, answer is not correct?\r\n                \r\nI am working on https://leetcode.com/problems/longest-increasing-subsequence\nFor test case\n```\ninput: [5, 4, 19, 5, 7, 12]; output: 4\n```\n\nWithout the cache, I am able to output 4 correctly.\n```\nvar lengthOfLIS = function (ns) {\n  if (ns.length === 1) return 1;\n\n  const prev_i = -1;\n  const curr_i = 0;\n  const res = 0;\n  return recur(ns, prev_i, curr_i, res);\n};\n\n// good\nvar recur = function (ns, prev_i, curr_i, res) {\n  //\n  if (curr_i >= ns.length) {\n    return res;\n  }\n\n  // take\n  let out_1 = 0;\n  if (prev_i === -1) {\n    out_1 = recur(ns, curr_i, curr_i + 1, res + 1);\n  } else if (ns[curr_i] > ns[prev_i]) {\n    out_1 = recur(ns, curr_i, curr_i + 1, res + 1);\n  } else if (ns[curr_i] <= ns[prev_i]) {\n    out_1 = res;\n  }\n\n  // !take\n  let out_2 = 0;\n  out_2 = recur(ns, prev_i, curr_i + 1, res);\n\n  const max = Math.max(out_1, out_2);\n  return max;\n};\n```\n\nWhen I adding cache to it, my output is 3.\n```\nvar recur = function (dp, ns, prev_i, curr_i, res) {\n  //\n  if (curr_i >= ns.length) {\n    return res;\n  }\n\n  if (prev_i !== -1 && dp[prev_i + 1][curr_i + 1] !== undefined) {\n    return dp[prev_i + 1][curr_i + 1];\n  }\n\n  // take\n  let out_1 = 0;\n  if (prev_i === -1) {\n    out_1 = recur(dp, ns, curr_i, curr_i + 1, res + 1);\n  } else if (ns[curr_i] > ns[prev_i]) {\n    out_1 = recur(dp, ns, curr_i, curr_i + 1, res + 1);\n  } else if (ns[curr_i] <= ns[prev_i]) {\n    out_1 = res;\n  }\n\n  // !take\n  let out_2 = 0;\n  out_2 = recur(dp, ns, prev_i, curr_i + 1, res);\n\n  const max = Math.max(out_1, out_2);\n  dp[prev_i + 1][curr_i + 1] = max;\n  return max;\n};\n\nvar lengthOfLIS = function (ns) {\n  if (ns.length === 1) return 1;\n\n  const dp = Array(ns.length + 1)\n    .fill(undefined)\n    .map((_, i) => {\n      return Array(ns.length + 1).fill(undefined);\n    });\n\n  const prev_i = -1;\n  const curr_i = 0;\n  const res = 0;\n  return recur(dp, ns, prev_i, curr_i, res);\n};\n```\n\nCould someone point out any mistake I made? I am trying to use debugger to see what is happening.\n    ", "Answer": "\r\nYou can debug this kind of problem by comparing the cached result with the uncached result and logging differences.\nThe problem is that the result of this function depends on the values of prev_i, curr_i, and res.  However, your cache only depends on values of prev_i and curr_i so does not have enough information to predict the correct output.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "DP: Longest Increasing Subsequence Thought Process & Solution\r\n                \r\nFor the Longest Increasing Subsequence problem I envisioned keeping a DP array that is always in order keeping the max value at the farthest end. Something that would look like this:\n```\n{1, 1, 2, 3, 3, 4, 5, 6, 6, 6}\n```\n\nThe thought process I followed to produce my first incorrect solution was, we want to look at the entire array starting with only the first element, calculate the LIS, then incrementally add on a value to the end of our array. While doing this, we incrementally calculate the LIS in our DP array to the LIS of the old subarray plus the new element we added on. This means at index ```\ni```\n of the ```\ndp```\n array exists the value of the LCS of the subarray of length ```\ni```\n.\nMore clearly put\n```\narray => {5, 6, 7, 1, 2, 3, 4}\ndp    => {1, 2, 3, 3, 3, 3, 4}\n```\n\nThis way the very last entry of the DP array will be the LIS of the current array. This would act as our invariant, so when we get the end, we can be assured that the last value is the only one we need. It then dawned on me that while we're traversing an array with a DP kinda feel, the next value does not depend on any of the previously tabulated values in the array, so this method is the same as maintaining a ```\nmaxLIS```\n variable, a pattern I've seen in many ```\nO(n)```\n solutions. So my closest-to-correct solution is as follows:\n1.) Save a copy of the input array/vector as ```\nold```\n\n2.) Sort the original input array\n3.) Traverse the sorted array, incrementing a variable ```\nlongest```\n by one every time the next value (which should be larger than the current`) appears before the current in the original array.\n4.) Return ```\nlongest```\n\nThe code would be ~this:\n```\nint lengthOfLIS(vector<int>& seq) {\n  if (!seq.size()) return 0;\n  vector<int> old = seq;\n\n  sort(seq.begin(), seq.end());\n\n  int longest = 1;\n\n  for (int i = 1; i < seq.size(); ++i) {\n    if (seq[i] > seq[i-1] && find(old.begin(), old.end(), seq[i]) - old.begin() > find(old.begin(), old.end(), seq[i-1]) - old.begin()) longest++;\n  }\n  return longest;\n}\n```\n\nWhere we have the ```\nfind```\n method (I'm assuming a linear operation) we could make a constant operation by just making a data structure to store the original index of the value along with the the value itself so we don't have to do any traversing to find the index of an element in the original array (```\nold```\n). I believe this would be an ```\nO(nlog(n))```\n solution however fails with this input array: ```\n[1,3,6,7,9,4,10,5,6]```\n. CHECK HERE\nFinally I did some research and I found that all solution guides I have read sneak in the fact that their solution keeps the values of their DP array not in order, but instead like this: A value in the DP array represents the length of an increasing subsequence with the last value of the subsequence being the value of ```\noriginalArray[index]```\n.\nMore clearly put,\n```\narray => {5, 6, 7, 1, 2, 3}\ndp    => {1, 2, 3, 1, 2, 3}\n```\n\nHere, where 5 is the last value of an increasing subsequence, no values come before it so it must be of length 1. If 6 is the last value of an increasing subsequence, we must look at all values before it to determine how long a subsequence ending with 6 can be. Only 5 can come before it, thus making the longest increasing subsequence thus far 2. This continues, and you return the maximum value in the DP array. Time complexity for this solution is ```\nO(n^2)```\n, standard naive solution.\nQuestions:\nI'm curious as to how I can think about this problem correctly. I want to fine-tune my thought process so that I can come up with an optimal solution from scratch (that's the goal at least) so I'd like to know\n1.) What property of this problem should've triggered to me to use a DP array differently than how I would've used it? In hindsight, my original way was simply equivalent to keeping a max variable but even then I struggle seeing a property of this problem that would trigger the thought `Hey, the value of an entry in my DP array at index i should be the length of the increasing subsequence ending with originalArray[i]. I'm struggling to see how I should've come up with that.\n2.) Is it possible to get my proposed ```\nO(nlog(n))```\n solution to work? I know an ```\nO(nlog(n))```\n solution exists, but since I can't get mine working I think I need a nudge in the right direction.\n    ", "Answer": "\r\nI admit, it is an interesting question and i do not have exact answer to it but i guess i can give you a nudge in right direction. So here it goes:\n\nWhile facing with such dilemma, I would usually turn to the basics. Like in your case go through definition of Dynamic Programming. It has two properties: \n\n\n  \n  Overlapping Subproblems \n  Optimal Substructure.\n  \n\n\nYou can easily find these property reflecting in standard solution but not yours. You can read about them in cormen or just google them in context of DP.\n\nIn my opinion your solution is not a DP, you just found some pattern and your are trying to solve based on this pattern. If you are not getting the solution, it means that either your pattern is wrong or your solution is overlooking something. In scenarios like this try to prove, mathematically, that the pattern you are observing is correct and prove that the solution should also work. \n\nGive me some more time, while i work through your solution but mean while you can also try to develop a proof for your solution.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence and tracing\r\n                \r\nGiven you a sequence of integers, find the longest and largest lexicographically ordered subsequence of the sequence given number\n|a[i]| <= 2.10^9\noutput :\n— print the length of the longest subsequence\n\nPrint the largest lexicographically ordered subsequence\n\nVD\ninput\n6\n1 2 4 3 5 6\noutput\n5\n1 2 4 5 6\nthis is my code but it's wrong\n```\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn int(3e6) + 5\n#define ii pair<ll, ll>\n#define iii pair<ll, ii>\n#define F first\n#define S second\n#define oo 1e16\n#define sz(x) x.size() * 1ll\n#define all(x) x.begin(), x.end()\n#define mem(x, k) memset(x, k, sizeof x)\n#define tb {clock_t start, en; double time_use; start = clock();}\n#define te {en = clock(); cout << '\\n'; time_use = (double)(en - start) / CLOCKS_PER_SEC; cout<<\"Thoi gian chay : \"<<time_use << '\\n';}\nusing namespace std;\nll n;\nll a[maxn];\nll num[maxn];\nll trace[maxn];\n\nstruct BIT{\n    vector<ll> bit;\n    BIT(int n){\n        bit.resize(n + 4, 0);\n    }\n\n    int gbit(int x){\n        return x & (- x);\n    }\n\n    void update(int x, ll val, int n){\n        for(;x <= n; x += gbit(x))\n            bit[x] = max(bit[x], val);\n    }\n\n    ll getbit(ll y, ll &tmp){\n        ll ans = 0;\n        for(; y > 0; y -= gbit(y)){\n            if(bit[y] > ans){\n                ans = bit[y];\n                tmp = 0;\n            }\n            if(ans == bit[y]){\n                tmp = max(tmp, y);\n            }\n        }\n        return ans;\n    }\n\n};\n\nint main() {\n//    ifstream cin(\"test.inp\");\n//    ofstream cout(\"test.out\");\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    {// number compression\n        vector<ll> s;\n        for(int i = 1; i <= n; i ++){\n            cin >> a[i];\n            a[i] += 2e9;\n            s.push_back(a[i]);\n        }\n        sort(all(s));\n        vector<ll> b;\n        b.push_back(s[0]);\n        for(int i = 1; i < sz(s); i ++)\n            if(s[i] != s[i - 1]) b.push_back(s[i]);\n\n        for(int i = 1; i <= n; i ++){\n            int x = a[i];\n            a[i] = lower_bound(all(b), a[i]) - b.begin() + 1;\n            num[a[i]] = x;\n        }\n    }\n\n    BIT b(maxn - 5);\n    ll tmp = 0;\n    ll ans = 0, en = 0;\n    for(int i = 1; i <= n; i ++){\n        tmp = 0;\n        int p = b.getbit(a[i] - 1, tmp);\n        if(p + 1 > ans){\n            ans = p + 1;\n            en = a[i];\n        }\n        b.update(a[i], p + 1, maxn - 5);\n        trace[a[i]] = tmp;\n        //printf(\"%lld %lld\\n\", a[i], tmp);\n    }\n    cout << ans << '\\n';\n    vector<ll> tp;\n    while(en > 0){\n        tp.push_back(en);\n        en = trace[en];\n    }\n    reverse(all(tp));\n    for(int x: tp)\n        cout << num[x] - 2e9 << '\\n';\n\n}\n```\n\nI use BIT to solve but the trace is wrong\nI can't think of a solution for it please help me !!\n    ", "Answer": "\r\nActual C++ code would look more like this, to give you an idea what I am talking about (not fully tested):\n```\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n\n// helper struct to make code more readable. \nstruct sub_range\n{\n    std::size_t length()\n    {\n        return end - begin;\n    }\n\n    std::size_t begin{ 0ul };\n    std::size_t end{ 1ul};      // inclusive end, unlike iterators which have end one beyond end.\n};\n\nstd::vector<std::int64_t> GetLongestSubRange(const std::vector<std::int64_t>& values)\n{\n    sub_range longest_range;\n    sub_range current_range;\n\n    // always test your input. \n    if (values.size() < 1) return values;\n\n    for (std::size_t prev_pos{ 0ul }, pos{ 1ul }; pos < values.size(); ++pos, ++prev_pos)\n    {\n        // still ordered so extend length of current range\n        if (values[prev_pos] <= values[pos])\n        {\n            current_range.end = pos;\n        }\n        else\n        {\n            // if current range is longer then previous longest range\n            // then updated longest_range\n            if (current_range.length() > longest_range.length())\n            {\n                longest_range = current_range;\n            }\n\n            // and start detecting a new range at current position\n            current_range.begin = pos;\n            current_range.end = pos;\n        }\n    }\n\n    // return a sub vector, the +1ul is because subrange is inclusive range and STL works with exclusive end.\n    return std::vector<std::int64_t>{ values.begin() + longest_range.begin, values.begin() + longest_range.end + 1ul};\n};\n\n\nint main()\n{\n    auto subrange = GetLongestSubRange({ 1, 2, 4, 3, 5, 6, 7, 8, 9, 2 });\n\n    // output the longest subrange\n    for (const auto& v : subrange) std::cout << v << \" \";\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Obtaining the longest increasing subsequence in Python\r\n                \r\nCan anyone tell me why this code doesn't produce each increasing subsequence?\nI used dynamic programming to solve this but I can't figure out why this code fails.\nThe parameter ```\nA```\n is a sequence of integers.\n\n```\ndef LIS(A):\n\n    # make a list of lists\n    L = list()\n    for i in range(0, len(A)):\n        L.append(list())\n\n    #the first increasing subsequence is the first element in A\n    L[0].append(A[0])\n\n    for i in range(1, len(A)):\n        for j in (0, i):\n\n            # a new larger increasing subsequence found\n            if (A[j] < A[i]) and ( len(L[i]) < len(L[j]) ):\n                L[i] = L[j]\n\n        L[i].append(A[i])\n\n        # print an increasing subsequence\n        print L[i]\n```\n\n\nExample output produced for A = [3, 5, 10, 0, 1, 100, 2, 4, 7] by this algorithm:\n\n```\n[3, 5]\n[3, 5, 10]\n[0]\n[1]\n[3, 5, 10, 100]\n[2]\n[3, 5, 10, 100, 4]\n[3, 5, 10, 100, 4, 7]\nNone\n```\n\n\nCorrect output:\n\n```\n[3] \n[3, 5] \n[3, 5, 10] \n[0] \n[0, 1] \n[3, 5, 10, 100] \n[0, 1, 2] \n[0, 1, 2, 4] \n[0, 1, 2, 4, 7] \n```\n\n    ", "Answer": "\r\nTwo mistakes that I found in your code \n\n1.You assumed list are immutable but they are not in python\n\n```\nL[i] = L[j] this is going to make L[i] point to the same list pointed by L[j]\n\n2.for j in (0, i):\n```\n\n\nThis does not iterate j form 0 to i-1 it iterates j form 0 to i.\n\nHere is fixed version of your code.\n\n```\ndef LIS(A):\n\n    # make a list of lists\n    L = list()\n    for i in range(0, len(A)):\n        L.append(list())\n\n    # the first increasing subsequence is the first element in A\n    L[0].append(A[0])\n\n    for i in range(1, len(A)):\n        for j in range(0, i):\n\n            # a new larger increasing subsequence found\n            if (A[j] < A[i]) and (len(L[i]) < len(L[j])):\n                'throw the previous list'\n                L[i] = []\n                'add all elements of L[j] to L[i]'\n                L[i].extend(L[j])\n        L[i].append(A[i])\n\n    for i in range(len(A)):\n    # print an increasing subsequence\n        print (L[i])\nA = [3, 5, 10, 0, 1, 100, 2, 4, 7]\nLIS(A)\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "R: Print ALL Longest Increasing Subsequences (LIS)\r\n                \r\nGiven a vector  \n\n```\nx <- c(4,5,6,7,8,9,10,11,12,13,15,14,13,12,11,10,9,8,6)\n```\n\n\nFind ALL the longest increasing subsequences (LIS)\n\nThe solution should look like \n\n```\n4,5,6,7,8,9,10,11,12,13,14\n\n4,5,6,7,8,9,10,11,12,13,15\n```\n\n\nI could even do with the index of the elements\n\nI've used the code given by JINJING XIE but it only returns one sequence\n\nAny help would be appreciated\n    ", "Answer": "\r\nHere is a (slow & not very efficient) function that will compute it (uses ```\nRcppAlgos```\n)\n\n```\nmax_sub_sequences <- function (x) {  \n  # x incresing, result is obviously x\n  if (all(diff(x) > 0)) return (x)\n  N <- length(x)\n  n <- N - 1L \n  break_condition <- TRUE\n  while (break_condition) {\n    # generate all combinations of indices\n    combinations <- RcppAlgos::comboGeneral(1:N,n)    \n    # get subsequences according to indices\n    sub_sequences <- matrix(x[combinations[1:nrow(combinations),]], nrow = nrow(combinations)) ; rm(combinations)\n    # check monotony \n    index_subsequence <- vapply(1:nrow(sub_sequences), function (k) any(diff(sub_sequences[k,]) < 1L), logical(1L))\n    # keep increasing sequences only\n    sub_sequences <- sub_sequences[!index_subsequence,] ; rm(index_subsequence)\n    break_condition <- nrow(sub_sequences) == 0L\n    n <- n - 1L\n  }\n  sub_sequences\n }\nmax_sub_sequences(c(4,5,6,7,8,9,10,11,12,13,15,14,13,12,11,10,9,8,6))    \n#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n# [1,]    4    5    6    7    8    9   10   11   12    13    15\n# [2,]    4    5    6    7    8    9   10   11   12    13    14  \n\n# timing\n# Unit: seconds\n#                 expr     min       lq     mean   median       uq      max neval\n# max_sub_sequences(x) 1.30611 1.462473 1.502727 1.484785 1.522796 1.821037   100\n```\n\n\nThere are for sure ways to make it more efficient, e.g. other logic or by writing it in ```\nc++```\n and using ```\nRcpp```\n for the whole task. \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Length of longest increasing subsequence, O(n) complexity\r\n                \r\nDoes this function return a maximal length of an increasing subsequence existing in array A[]?\n\n```\nint maxLength(int A[], int n) { // n - size of A[]\n\n   int subRes[n];\n\n   subRes[0] = 1;\n\n   for (int i = 1; i < n; i++) {\n\n       subRes[i] = (A[i] > A[i-1] ? subRes[i-1] + 1 : 1);\n   }\n\n   int maxL = 0;\n   for (int i = 0; i < n; i++) maxL = max(maxL, subRes[i]);\n\n   return maxL;\n}\n```\n\n    ", "Answer": "\r\nThe above solution is incorrect . The above code is for longest increasing sequence and not subsequence. For longest increasing subsequence check \nhttps://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Why is an ancestral array needed when recovering longest increasing subsequence?\r\n                \r\nI looked at the following website describing the longest increasing subsequnce algorithm: https://www.fyears.org/2016/12/LIS.html\nIn the section \"how to reconstruct the subsequence?\", it says that\n\"We should pay attention that the dp in the end is NOT the LIS.\"\nSomehow I don't see how dp is not LIS?\nWe know that dp is sorted and that it contains as many entries modified by the algorithm as the length of the LIS. An element at index i cannot be equal to an element at i-1, since for every index  dp[i] contains the smallest possible ending value in all increasing subsequences with length i + 1. So, if there is a subsequence of length i + 1, this implies that there is also a subsequence of length i, which consequently must end at a smaller value, right?\n    ", "Answer": "\r\nLIS is a subsequence (fixed order of elements), but DP array isn't saving elements order. Check on array [2, 3, 1]. DP will be [1, 3] after all iterations, but [1, 3] isn't the subsequence of the initial array.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Proof of Longest Increasing Subsequence using greedy patience sort\r\n                \r\nI came across the solution that uses Patience sort to obtain the length of the Longest Increasing Subsequence (LIS). http://www-stat.stanford.edu/~cgates/PERSI/papers/Longest.pdf, and here - http://en.wikipedia.org/wiki/Patience_sorting. \n\nThe proof that following the greedy strategy actually gives us the length correctly has 2 parts - \n\n\nproves that the number of piles is at least equal to the length of the LIS.\nproves that the number of piles using greedy strategy is at most equal to the LIS.\n\n\nThus by virtue of both 1) and 2), the solution gives the length of LIS correctly. \n\nI get the explanation for 1), but I just cannot intuitively realize part 2). Can someone may be use a different example to convince me that this is indeed true. Or, you could even use a different proof technique too. \n    ", "Answer": "\r\nI just read over the paper and I agree that the proof is a bit, um, terse. (I'd say that it's missing some pretty important steps!)\n\nIntuitively, the idea behind the proof is to show that if you play with the greedy strategy and at the end of the game pick any card in a pile numbered p, you can find an increasing subsequence in the original array whose length is p. If you can prove this fact, then you can conclude that the maximum number of piles produced by the greedy strategy is the length of the longest increasing subsequence.\n\nTo formally prove this, we're going to argue that the following two invariants hold at each step:\n\n\nThe top cards in each pile, when read from left to right, are in sorted order.\nAt any point in time, every card in every pile is part of an increasing subsequence whose length is given by the pile index.\n\n\nPart (1) is easy to see from the greedy strategy - every element is placed as far to the left as possible without violating the rule that smaller cards must always be placed on top of larger cards. This means that if a card is put into pile p, we are effectively taking a sorted sequence and reducing the value of the pth element to a value that's greater than whatever is in position p - 1 (if it exists).\n\nTo see part (2), we'll go inductively. The first placed card is put into pile 1, and it's also part of an increasing subsequence of length 1 (the card by itself). For the inductive step, assume that this property holds after placing n cards and consider the (n+1)st. Suppose that it ends up in pile p. If p = 1, then the claim still holds because this card forms an increasing subsequence of length 1 all by itself. Otherwise, p > 1. Now, look at the card on top of pile p - 1. We know that this card's value is less than the value of the card we just placed, since otherwise we would have placed the card on top of that pile. We also know that the card on top of that pile precedes the card we just placed in the original ordering, since we're playing the cards in order. By our existing invariant, we know that the card on top of pile p - 1 is part of an increasing subsequence of length p - 1, so that subsequence, with this new card added into it, forms an increasing subsequence of length p, as required.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Python Recursion to Find The Longest Increasing Subsequence with Specific Limitations\r\n                \r\nI'm working on a problem where I need to implement a recursive function in Python to find the length of the longest increasing subsequence from a list of numbers. The list can have any length and can contain any integers. I'm only allowed to use the ```\nlen()```\n function and recursion to solve this problem, no loops, max(), helper functions or any other built-in functions are allowed.\nHere's the problem description:\nGiven a list of numbers, find the length of the longest subsequence that creates a series of numbers that are strictly increasing. The order of the numbers in the list must not be changed to produce the increasing sequence, but numbers can be omitted.\nFor example, given the list [1, 5, 3, 4], the longest increasing subsequence is [1, 3, 4], therefore the resulting length is 3.\nHere is my current attempt:\n```\ndef longest_seq(lst, num=0):\n    if not lst:\n        return num\n    if len(lst) == 1:\n        return num + 1\n\n    if lst[0] < lst[1]:\n        return longest_seq(lst[1:], num + 1)\n    if lst[0] >= lst[1]:\n        if lst[0] < lst[2]:\n            return longest_seq([lst[0]] + lst[2:], num)\n        else:\n            return longest_seq(lst[1:], num)\n\n```\n\nThe function seems to work for some inputs, but I believe the logic is flawed. I've tried to address these issues, but I'm finding it challenging to come up with a solution that only uses recursion and len(), and doesn't modify the input list.\nI understand that when lst[0] >= lst[1], my function should consider two possibilities:\n\nDiscard the current number and start a new sequence from the next number, or\nDiscard the next number and try extending the current sequence with the number after the next.\n\nBut I'm struggling to implement this logic in my function. Can anyone suggest how I could improve my current implementation to handle these cases correctly?\nThank you in advance for your help.\n** Apologies for any confusion caused. I removed the part where I mentioned it was against the rules. I would like to clarify that I am a beginner, so I may make mistakes from time to time. Regarding the question, I attempted to solve it by restricting myself to using only the len() function and employing recursive calls.\n    ", "Answer": "\r\nPassing in a slice of the input list with the input removed is the correct idea. However, I'd suggest modifying your function so that it tracks the current largest element of the subsequence under consideration, as trying to achieve this by keeping ```\nlst[0]```\n as the largest element (which is what I think is you're doing) won't work in general. I've gone ahead and provided a skeleton as to how this might look but left some of the recursive calls/details blank.\n```\ndef longest_seq(lst, largest = None, num = 0):\n    if not lst:\n        return num\n\n    rest = lst[1:] # the callee operates on the sublist of the lst, with lst[0] excluded\n    if num == 0:\n        include = longest_seq(rest, lst[0], 1) # In the callee, operate on rest, using lst[0] as the largest element. subsequence length is also 1 in the callee.\n        exclude = None # TBD - how would the recursive call for i\n        return None # TBD - larger between include/exclude\n\n    # num > 0 => largest entry populated\n    exclude = None # figure out the recursive call of not including lst[0]\n    if lst[0] > largest: # can include current\n        include = None # figure out recursive call\n        return None # TBD - larger between include/exclude\n\n    return exclude # could not include lst[0] in the subsequence so only exclude can be returned\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "longest increasing subsequence(O(nlogn))\r\n                \r\nLIS:wikipedia\n\nThere is one thing that I can't understand:\n\nwhy is X[M[i]] a non-decreasing sequence?\n    ", "Answer": "\r\nLet's first look at the n^2 algorithm:\n\n```\ndp[0] = 1;\nfor( int i = 1; i < len; i++ ) {\n   dp[i] = 1;\n   for( int j = 0; j < i; j++ ) {\n      if( array[i] > array[j] ) {\n         if( dp[i] < dp[j]+1 ) {\n            dp[i] = dp[j]+1;\n         }\n      }\n   }\n}\n```\n\n\nNow the improvement happens at the second loop, basically, you can improve the speed by using binary search. Besides the array dp[], let's have another array c[], c is pretty special, c[i] means: the minimum value of the last element of the longest increasing sequence whose length is i.\n\n```\nsz = 1;\nc[1] = array[0]; /*at this point, the minimum value of the last element of the size 1 increasing sequence must be array[0]*/\ndp[0] = 1;\nfor( int i = 1; i < len; i++ ) {\n   if( array[i] < c[1] ) {\n      c[1] = array[i]; /*you have to update the minimum value right now*/\n      dp[i] = 1;\n   }\n   else if( array[i] > c[sz] ) {\n      c[sz+1] = array[i];\n      dp[i] = sz+1;\n      sz++;\n   }\n   else {\n      int k = binary_search( c, sz, array[i] ); /*you want to find k so that c[k-1]<array[i]<c[k]*/\n      c[k] = array[i];\n      dp[i] = k;\n   }\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find longest increasing sequence\r\n                \r\nYou are given a sequence of numbers and you need to find a longest increasing subsequence from the given input(not necessary continuous).\n\nI found the link to this(Longest increasing subsequence on Wikipedia) but need more explanation.\n\nIf anyone could help me understand the O(n log n) implementation, that will be really helpful. If you could explain the algo with an example, that will be really appreciated.\n\nI saw the other posts as well and what I did not understand is:\nL = 0\n for i = 1, 2, ... n:\n   binary search for the largest positive j ≤ L such that X[M[j]] < X[i] (or set j = 0 if no such value exists)\n above statement, from where to start binary search? how to initialize M[], X[]?\n    ", "Answer": "\r\nA simpler problem is to find the length of the longest increasing subsequence. You can focus on understanding that problem first. The only difference in the algorithm is that it doesn't use the P array.\n\nx is the input of a sequence, so it can be initialized as:\nx = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n\nm keeps track of the best subsequence of each length found so far. The best is the one with the smallest ending value (allowing a wider range of values to be added after it). The length and ending value is the only data needed to be stored for each subsequence.\n\nEach element of m represents a subsequence. For m[j],\n\n\nj is the length of the subsequence.\nm[j] is the index (in x) of the last element of the subsequence.\nso, x[m[j]] is the value of the last element of the subsequence.\n\n\nL is the length of the longest subsequence found so far. The first L values of m are valid, the rest are uninitialized. m can start with the first element being 0, the rest uninitialized. L increases as the algorithm runs, and so does the number of initialized values of m.\n\nHere's an example run. x[i], and m at the end of each iteration is given (but values of the sequence are used instead of indexes).\n\nThe search in each iteration is looking for where to place x[i]. It should be as far to the right as possible (to get the longest sequence), and be greater than the value to its left (so it's an increasing sequence).\n\n```\n 0:  m = [0, 0]        - ([0] is a subsequence of length 1.)\n 8:  m = [0, 0, 8]     - (8 can be added after [0] to get a sequence of length 2.)\n 4:  m = [0, 0, 4]     - (4 is better than 8. This can be added after [0] instead.)\n 12: m = [0, 0, 4, 12] - (12 can be added after [...4])\n 2:  m = [0, 0, 2, 12] - (2 can be added after [0] instead of 4.)\n 10: m = [0, 0, 2, 10]\n 6:  m = [0, 0, 2, 6]\n 14: m = [0, 0, 2, 6, 14]\n 1:  m = [0, 0, 1, 6, 14]\n 9:  m = [0, 0, 1, 6, 9]\n 5:  m = [0, 0, 1, 5, 9]\n 13: m = [0, 0, 1, 5, 9, 13]\n 3:  m = [0, 0, 1, 3, 9, 13]\n 11: m = [0, 0, 1, 3, 9, 11]\n 7:  m = [0, 0, 1, 3, 7, 11]\n 15: m = [0, 0, 1, 3, 7, 11, 15]\n```\n\n\nNow we know there is a subsequence of length 6, ending in 15. The actual values in the subsequence can be found by storing them in the P array during the loop.\n\nRetrieving the best sub-sequence:\n\nP stores the previous element in the longest subsequence (as an index of x), for each number, and is updated as the algorithm advances. For example, when we process 8, we know it comes after 0, so store the fact that 8 is after 0 in P. You can work backwards from the last number like a linked-list to get the whole sequence.\n\nSo for each number we know the number that came before it. To find the subsequence ending in 7, we look at P and see that:\n\n```\n7 is after 3\n3 is after 1\n1 is after 0\n```\n\n\nSo we have the subsequence [0, 1, 3, 7].\n\nThe subsequences ending in 7 or 15 share some numbers:\n\n```\n15 is after 11\n11 is after 9\n9 is after 6\n6 is after 2\n2 is after 0\n```\n\n\nSo we have the subsequences [0, 2, 6, 9, 11], and [0, 2, 6, 9, 11, 15] (the longest increasing subsequence)\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "longest increasing subsequence problem - n log n solution that returns the actual subsequence - explanation/clarification needed\r\n                \r\nI've tried to implement the n log n solution to the longest increasing subsequence problem (where you need to find a longest subsequence where each element is larger than the previous one of a given sequence), one which will find the actual subsequence that is longest (not just its length). I've worked off of this video - https://www.youtube.com/watch?v=S9oUiVYEq7E - but sadly I don't think the algorithm shown on the video is correct - it seems to at least work for the exact input that is shown on the video, but doesn't work for others, such as [1, 8, 6, 4, 9, 8, 3, 5, 2, 7, 1, 9, 5, 7].\n```\nfrom bisect import bisect_left, bisect_right\nfrom math import floor, ceil\n\n\nsequence = [3, 4, -1, 5, 8, 2, 3, 12, 7, 9, 10]\nindexes = [0]\nhelper = [-1] * len(sequence)\nfor i in range(1, len(sequence)):\n    if len(indexes) == 0 or sequence[i] > sequence[indexes[-1]]:\n        indexes.append(i)\n        helper[i] = indexes[-2]\n    else:\n        ceiltable = bisect_right([sequence[x] for x in indexes], sequence[i])\n        indexes[ceiltable] = i\n        if ceiltable > 0:\n            helper[i] = indexes[ceiltable - 1]\n\n\n\nsolution = [sequence[x] for x in indexes]\n\n\nprint(f\"longest increasing subsequence is {solution}, and has a lenght of  {len(solution)}\")\n```\n\nAnd my question(s) are - can anyone confirm/disconfirm whether the algorithm shown in that video is actually correct and what might be wrong with my implementation of it? Also, can I ask anyone to provide a simple explanation/pseudocode/mockup of the n log n solution of this problem? I tried searching of course, But I don't think there is anything that really explains how this solution works, or specifically how an implementation of it would work - and again, just to note, I also have to return the actual subsequence, not just the length.\n    ", "Answer": "\r\nThe video you refer to explains he algorithm correctly.\nThere are two issues in your implementation:\n\nYou should use ```\nbisect_left```\n instead of ```\nbisect_right```\n, as otherwise you will allow solutions that are in fact non-decreasing sequences (with potential duplicate values) instead of strictly increasing sequences. And ```\nbisect_right```\n may also result in an index that is equal to the length of the list, resulting in an invalid index access error. (Side note: If you really want to use ```\nbisect_right```\n and find non-decreasing sequences, then make the preceding ```\nif```\n condition ```\n>=```\n)\n\nThe code does not translate the gathered data correctly into a solution. You really need to use the ```\nhelper```\n list to trace back the solution. Here is the code you could use:\n```\nsolution = []\ni = indexes[-1]  # start with the index of the last value of the longest sequence\nwhile i >= 0:\n    solution.append(sequence[i])\n    i = helper[i]  # Look up what the optimal predecessor is of that index\nsolution.reverse()  # Reverse the solution since we populated it in reverse order\n```\n\n\n\nOther remark\nThe way you perform binary search is not efficient because you iterate the whole list with a list comprehension. That defeats the efficiency offered by binary search. You should have the values ready for binary search, so keep them in a separate list that you maintain throughout the algorithm, and don't do such a list comprehension any more at the time of the binary search.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Finding the longest increasing subsequence of an array in python\r\n                \r\nI am a beginner to python and have already gone through other solutions for this problem. I was wondering if I could take another approach (this might be much slower, but I want to be able to tackle problems with a similar approach):\nI noted that for a number n in our sequence with index (position in of the number in the sequence) i, if there exists another number in our sequence m with index y, such that, n > m and i > y, we can say with certainty that n is not the 1st entry of the longest increasing subsequence of our sequence.\nI hope to apply this condition to our sequence to get all possible candidates for the 1st entry of LIS. From there we only consider the sequence that comes after our candidates and apply our condition again so that we get all possible second entries of the LIS.\nWe keep doing this, assembling all possible subsequences as we go along and at the end we choose the largest subsequence.\n```\ndef LIS(sequence):\n    \n    candidates = []\n    \n    for i in range(0,len(sequence)):\n        candidates.append(i)\n    \n    for i in range(0,len(sequence)):\n        for y in range(0,len(sequence)):\n            if sequence[i] > sequence[y] and i > y:\n                candidates.remove(i)\n                \n                break\n      \n    \n    return(candidates)  \n```\n\nThis is what the condition looks like when I write it out in code. But I am not able to wrap my head around how I can apply this condition again and again  to get the LIS\n    ", "Answer": "\r\nYour logic is correct, that can be used to decide the potential candidates for the first number of our LIS. However, there is a way to simplify your ```\nn>m and i>y```\n logic. It effectively states that a number can't be a candidate if it has a smaller number to the left of it. So all you have to do is keep a track of the smallest number on the left, and iterate.\nFor each candidate, recursively continue the process, till no valid candidates are found, and then return the LIS sequence obtained.\n```\ndef candidates(lst, base_index, min_val):\n    if base_index>=len(lst):\n        return []\n    if lst[base_index]>min_val:\n        ans = [base_index]   #0th index will always be a candidate\n        min_left = lst[base_index]\n    else:\n        ans = []\n        min_left = int(1e8)\n    for i in range(base_index+1, len(lst)):\n        if lst[i]<min_left and lst[i]>min_val:\n            ans.append(i)\n            min_left = min(min_left, lst[i])\n    return ans   # list of indexes of potential candidates \n\ndef lis(lst, i):\n    # returns LIS starting at index i\n    seq = []\n    ans = [i]\n    candidate_list = candidates(lst, i+1, lst[i])\n    for candidate in candidate_list:\n        temp = lis(lst, candidate) #LIS starting at each candidate\n        if len(temp)>len(seq):\n            seq = temp\n    ans += seq\n    return ans\n\ndef lis_helper(lst):\n    ans = []\n    candidate_list = candidates(lst,0, -int(1e8))\n    for candidate in candidate_list:\n        temp = lis(lst, candidate)\n        if len(temp)>len(ans):\n            ans = temp\n    return ans  #list of indexes that make up the LIS\n\nlst  = [5,6,1,0,4,6,7]\nlst2 = [1,2,3,4,5,6]\nlst3 = [5,4,3,2,1]\n\nprint(lis_helper(lst))   # [2, 4, 5, 6]\nprint(lis_helper(lst2))  # [0, 1, 2, 3, 4, 5]\nprint(lis_helper(lst3))  # [0]\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "1D Memoization in Recursive solution of Longest Increasing Subsequence\r\n                \r\nCalculating LIS (Longest Increasing Subsequence) in an array is a very famous Dynamic Programming problem. However in every tutorial they first show the recursive solution without using the concepts of DP and then solve it by applying Bottom-Up DP (Iterative Solution).\n\nMy question is:\n\n\n  How will we use Memoization in  Recursive Solution itself.\n  Not just Memoization but memoization using 1D array. \n\n\nI did some research but could not find anything of relevance. Although there are 2 places where recursive memoization has been asked 1 &  2 but the solutions over there, are using 2D Map / Array for memoization. \n\nAnyway Memoizing the solution with 1D array, is giving wrong output. \nHere is what I did:\n\n```\nint lis(int idx, int prev)\n{\n    if(idx >= N)\n        return 0;\n\n    if(dp[idx])\n        return dp[idx];\n\n    int best_ans = lis(idx+1, prev);\n\n    int cur_ans = 0;\n    if(arr[idx] > prev)\n    {\n        cur_ans = 1 + lis(idx+1, arr[idx]);\n    }\n    int ans = max(best_ans, cur_ans);\n    dp[idx] = ans;\n    return ans;\n}\n\nint main()\n{\n    // Scan N \n    // Scan arr\n\n    ans = lis(0, -1));\n    print ans;\n}\n```\n\n\nAlthough I know the reason why this solution is giving Wrong output as:\n\n\n  There can be more than one solution for the giving index based on what was the previous value. \n\n\nBut I still want to know how it can be done using 1D array.\n\nI am curious to know the solution because I have read that every DP Top-Down solution can be reframed into Bottom-Up and vice-versa. \n\nIt would be highly helpful if someone could provide some insight for the same.\n\nThanks in advance. \n    ", "Answer": "\r\nThis can't be done because the problem fundamentally needs a 2D data structure to solve.\n\nThe bottom-up approach can cheat by producing one row at a time of the data structure.  Viewed over time, it produces a 2D data structure, but at any given time you only see one dimension of it.\n\nThe top-down approach has to build the entire 2D data structure.\n\nThis is a fundamental tradeoff in DP.  It is usually easier to write down the top-down approach.  But the bottom-up approach only has to have part of the overall data structure at any time, and therefore has significantly lower memory requirements.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "NIce Subsequence - A variant of Longest Increasing Subsequence\r\n                \r\nA subsequence X[1..k] is nice if X[i] > X[i - 2] for all i > 2. Compute a longest nice subsequence of an arbitrary array of integers A[1...n].\nI have some confusions regarding this problem statement as no examples were provided.\nI took an example array : A = { 1,2,3,4,2,-1,0,7,9}.\nI did the Comparison of elements in an iterative way : 3 > 1, include 3 in the output array.\n4 > 2, include 4, and so on.\nFrom my understanding of this problem, I figured out this Nice Subsequence: {3,4,7,9}.\nI am confused that if the subsequence consists of elements 1 and 2 in it, because I think {1,2,3,4,7,9} is also valid. I need to clear this confusion.\nAny help is much appreciated.\n Below there is my written Java code.\n```\npublic static int niceSub(int[] input) {\n        int n = input.length;\n        int i, j;\n        int[] X = new int[n];\n\n        for (i = 0; i < n; i++) {\n            X[i] = 0;\n        }\n        ArrayList<Integer> answer = new ArrayList<>();\n        int[] A = new int[n + 1];\n        A[0] = 0;\n        for (i = 1; i <= n; i++) {\n            A[i] = input[i - 1];\n        }\n        for (i = 3; i < A.length; i++) {\n            for (j = i - 2; j <= i - 2; j++) {\n                if (A[i] > A[j]) {\n                    answer.add(A[i]);\n                }\n            }\n        }\n        System.out.println(answer);\n        // System.out.println(Arrays.toString(X));\n        return answer.size();\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "What is the most efficient way of finding the longest increasing subsequence (sorted string) in a circular buffer?\r\n                \r\nSince the sequence is in a circular buffer, a sequence of 1 2 3 4 would be thought the same as 2 3 4 1, 3 4 1 2, or 4 1 2 3, depending on the starting index.\nIn this context, what I am trying to find is this:\nExample 1\nIn 3 4 1 2 5, the longest increasing subsequence would be 1 2 3 4, not 1 2 5. Of course, this would be easy to find if the sequence started at 1.\nExample 2\nIn 1 4 5 2 3, the longest increasing subsequence would be 2 3 4 5, not 1 2 3. This again would be easy to find if the sequence started at 2.\nExample 3\nThe sequence 3 4 5 1 2 would be considered sorted, and its LIS would be 1 2 3 4 5.\nI am trying to find an algorithm that does this, but all I could find is finding the longest increasing subsequence from a finite sequence, resulting in a shorter subsequence as in the examples. The optimal algorithm of finding LIS from a finite sequence seems to be of O(n log n) as illustrated in https://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms, but the naive way of applying this to my problem would grow to O(n^2 log n), starting over at every number (or letter). Is there a better way of doing this?\nI am sorry if I have used the wrong terminologies that might cause confusion.\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Length and sum of longest increasing subsequence\r\n                \r\nI wanted to count sum and length of the longest subsequence  in the given array ```\nt```\n.\n```\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class so {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        br.close();\n        int[] t = new int[s.length];\n        for (int i = 0; i < s.length; i++) {\n            t[i] = Integer.parseInt(s[i]);\n        }\n        int length = 1;\n        int sum = t[0];\n        int maxSum = 0;\n        int maxLength = 0;\n\n        for (int i = 1; i < t.length; i++) {\n            for (; i < t.length && t[i - 1] <= t[i]; i++) {\n                length++;\n                sum += t[i];\n                System.out.print(t[i] + \" \");\n            }\n\n            if (length > maxLength) {\n                maxLength = length;\n                maxSum = sum;\n                length = 1;\n                sum = 0;\n                i--;\n            }\n        }\n        System.out.println(\"sum is \" + maxSum + \" length is \" + maxLength);\n    }\n}\n```\n\nfor the numbers```\n1 1 7 3 2 0 0 4 5 5 6 2 1```\n I get output:\n```\nsum is 20 length is 6```\n\nbut for the same numbers in reverse order ```\n1 2 6 5 5 4 0 0 2 3 7 1 1```\n I get output:\n```\nsum is 17 length is 6```\n which is not true because I should get ```\nsum is 12 length is 5```\n.\nCould someone spot the my mistake?\n    ", "Answer": "\r\nYou are reseting the ```\nlength```\n and ```\nsum```\n only when you find the next longest sequence but you should reset them every time you finish testing a sequence:\n\nRight now, your code accumulates ```\nlength```\n and ```\nsum```\n until it surpasses ```\nmaxLength```\n but ```\nlength```\n and ```\nsum```\n are test variables that need to be reset when testing each possible subsequence. \n\nFurthermore, you ```\nsum```\n variable needs to reset to the current test value at ```\nt[i - 1]```\n and not to ```\n0```\n. The reason you are getting a correct result even though this bug is present is because the first item in the LIS for both of your inputs is ```\n0```\n.\n\nIf we input something like (replace two ```\n0```\ns in the first input with ```\n1```\ns):\n\n```\n1 1 7 3 2 1 1 4 5 5 6 2 1\n```\n\n\nOutput is: \n\n```\nsum is 21 length is 6\n```\n\n\nBut sum should be ```\n22```\n\n\nIn fact, a slightly cleaner way would be to perform initialization of your test variables at the beginning of the loop instead of initializing outside of the loop and then reseting inside:\n\n```\n// ...\nint length, sum, maxSum = Integer.MIN_VALUE, maxLength = Integer.MIN_VALUE;\n\nfor (int i = 1; i < t.length; i++) {\n   // initialize test variables\n   length = 1;\n   sum = t[i - 1];\n   for (; i < t.length && t[i - 1] <= t[i]; i++) {\n       length++;\n       sum += t[i];\n       System.out.print(t[i] + \" \");\n   }\n\n   if (length > maxLength) {\n       maxLength = length;\n       maxSum = sum;\n       i--;\n   }\n}\n// ...\n```\n\n\nNOTE: I added initialization for ```\nmaxLength```\n and ```\nmaxSum```\n to use the smallest possible integer to allow counting negative numbers as well.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "SQLITE Is it possible to calculate the length of the longest increasing subsequence also referred to as sortation percent?\r\n                \r\nWith the latest version of Sqlite, Is it possible to calculate the length of the longest increasing subsequence, also referred to as sortation percent, using a sqlite UDF, user defined function? \n\nOctober 15,2012 edit as requested by @Code-Guru.     \n\nFollowing the project gurus's example sequence of -- 1,2,3,4,3,5,6,7,8,10 -- the numeric sorted ascending subsequence is found to be 1,2,3,4,5,6,7,8,10 using an automatic variable containing the most recent monotically increasing sequence member value and traversing the array sequentially. As a result, the length of the sorted numeric ascending subsequence is 9. The length of the entire sequence is 10. So, the sortation percentage is (9/10) * 100% = 90%. Thank you.\n    ", "Answer": "\r\nSqlite does not have any functionality that implements longest increasing subsequence, so you will need a user defined function\n\nYou can sort by function results.  I don't believe UDFs are treated any differently in this respect.\n\nHere is an example of how you would use a function (user defined or not) to order your query results.\n\n```\nsqlite> create table foo(a);\nsqlite> create table foobar(a);\nsqlite> create table fubar(a);\nsqlite> select name, length(name) as len from sqlite_master;\nfoo|3\nfoobar|6\nfubar|5\nsqlite> select name, length(name) as len from sqlite_master order by len;\nfoo|3\nfubar|5\nfoobar|6\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Algorithm for determining the longest increasing subsequence?\r\n                \r\nThis problem can be solved by making a BST from the given array of integers. Insertion in BST takes O(logn). So n insertions will take O(nlogn). And then longest subsequence can be derived by traversing only the rightmost children starting from root. This can take atmost O9n). Thus overall time complexty will be O(nlogn). Is this a correct approach?\n    ", "Answer": "\r\nNo, the approach is not correct. Consider this tree:\n\n```\n    10\n  2    11\n 1 3\n    4\n```\n\n\nObviously the longest increasing subsequence here is ```\n2,3,4```\n but your algorithm would give ```\n10,11```\n which is shorter.\n\nAt the same time, there is no way of telling how my tree was built. Both these sequences would give the same tree:\n\n```\n10,2,1,3,4,11\n10,11,2,1,3,4\n```\n\n\nThese two have different longest increasing subsequences!\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Number of all longest increasing subsequences\r\n                \r\nI'm practicing algorithms and one of my tasks is to count the number of all longest increasing sub-sequences for given 0 < n <= 10^6 numbers. Solution O(n^2) is not an option. \n\nI have already implemented finding a LIS and its length (LIS Algorithm), but this algorithm switches numbers to the lowest possible. Therefore, it's impossible to determine if sub-sequences with a previous number (the bigger one) would be able to achieve the longest length, otherwise I could just count those switches, I guess. \n\nAny ideas how to get this in about O(nlogn)? I know that it should be solved using dynamic-programming.\n\nI implemented one solution and it works well, but it requires two nested loops (i in 1..n) x (j in 1..i-1).\n  So it's O(n^2) I think, nevertheless it's too slow.   \n\nI tried even to move those numbers from array to a binary tree (because in each i iteration I look for all smaller numbers then number[i] - going through elements i-1..1), but it was even slower.\n\nExample tests:  \n\n```\n1 3 2 2 4\nresult: 3 (1,3,4 | 1,2,4 | 1,2,4)\n\n3 2 1\nresult: 3 (1 | 2 | 3)\n\n16 5 8 6 1 10 5 2 15 3 2 4 1\nresult: 3 (5,8,10,15 | 5,6,10,15 | 1,2,3,4)\n```\n\n    ", "Answer": "\r\nFinding the number of all longest increasing subsequences\n\nFull Java code of improved LIS algorithm, which discovers not only the length of longest increasing subsequence, but number of subsequences of such length, is below. I prefer to use generics to allow not only integers, but any comparable types.\n\n```\n@Test\npublic void testLisNumberAndLength() {\n\n    List<Integer> input = Arrays.asList(16, 5, 8, 6, 1, 10, 5, 2, 15, 3, 2, 4, 1);\n    int[] result = lisNumberAndlength(input);\n    System.out.println(String.format(\n            \"This sequence has %s longest increasing subsequenses of length %s\", \n            result[0], result[1]\n            ));\n}\n\n\n/**\n * Body of improved LIS algorithm\n */\npublic <T extends Comparable<T>> int[] lisNumberAndLength(List<T> input) {\n\n    if (input.size() == 0) \n        return new int[] {0, 0};\n\n    List<List<Sub<T>>> subs = new ArrayList<>();\n    List<Sub<T>> tails = new ArrayList<>();\n\n    for (T e : input) {\n        int pos = search(tails, new Sub<>(e, 0), false);      // row for a new sub to be placed\n        int sum = 1;\n        if (pos > 0) {\n            List<Sub<T>> pRow = subs.get(pos - 1);            // previous row\n            int index = search(pRow, new Sub<T>(e, 0), true); // index of most left element that <= e\n            if (pRow.get(index).value.compareTo(e) < 0) {\n                index--;\n            } \n            sum = pRow.get(pRow.size() - 1).sum;              // sum of tail element in previous row\n            if (index >= 0) {\n                sum -= pRow.get(index).sum;\n            }\n        }\n\n        if (pos >= subs.size()) {                             // add a new row\n            List<Sub<T>> row = new ArrayList<>();\n            row.add(new Sub<>(e, sum));\n            subs.add(row);\n            tails.add(new Sub<>(e, 0));\n\n        } else {                                              // add sub to existing row\n            List<Sub<T>> row = subs.get(pos);\n            Sub<T> tail = row.get(row.size() - 1); \n            if (tail.value.equals(e)) {\n                tail.sum += sum;\n            } else {\n                row.add(new Sub<>(e, tail.sum + sum));\n                tails.set(pos, new Sub<>(e, 0));\n            }\n        }\n    }\n\n    List<Sub<T>> lastRow = subs.get(subs.size() - 1);\n    Sub<T> last = lastRow.get(lastRow.size() - 1);\n    return new int[]{last.sum, subs.size()};\n}\n\n\n\n/**\n * Implementation of binary search in a sorted list\n */\npublic <T> int search(List<? extends Comparable<T>> a, T v, boolean reversed) {\n\n    if (a.size() == 0)\n        return 0;\n\n    int sign = reversed ? -1 : 1;\n    int right = a.size() - 1;\n\n    Comparable<T> vRight = a.get(right);\n    if (vRight.compareTo(v) * sign < 0)\n        return right + 1;\n\n    int left = 0;\n    int pos = 0;\n    Comparable<T> vPos;\n    Comparable<T> vLeft = a.get(left);\n\n    for(;;) {\n        if (right - left <= 1) {\n            if (vRight.compareTo(v) * sign >= 0 && vLeft.compareTo(v) * sign < 0) \n                return right;\n            else \n                return left;\n        }\n        pos = (left + right) >>> 1;\n        vPos = a.get(pos);\n        if (vPos.equals(v)) {\n            return pos;\n        } else if (vPos.compareTo(v) * sign > 0) {\n            right = pos;\n            vRight = vPos;\n        } else {\n            left = pos;\n            vLeft = vPos;\n        }\n    } \n}\n\n\n\n/**\n * Class for 'sub' pairs\n */\npublic static class Sub<T extends Comparable<T>> implements Comparable<Sub<T>> {\n\n    T value;\n    int sum;\n\n    public Sub(T value, int sum) { \n        this.value = value; \n        this.sum = sum; \n    }\n\n    @Override public String toString() {\n        return String.format(\"(%s, %s)\", value, sum); \n    }\n\n    @Override public int compareTo(Sub<T> another) { \n        return this.value.compareTo(another.value); \n    }\n}\n```\n\n\nExplanation\n\nAs my explanation seems to be long, I will call initial sequence \"seq\" and any its subsequence \"sub\". So the task is to calculate count of longest increasing subs that can be obtained from the seq.\n\nAs I mentioned before, idea is to keep counts of all possible longest subs obtained on previous steps. So let's create a numbered list of rows, where number of each line equals the length of subs stored in this row. And let's store subs as pairs of numbers (v, c), where \"v\" is \"value\" of ending element, \"c\" is \"count\" of subs of given length that end by \"v\". For example:\n\n```\n1: (16, 1) // that means that so far we have 1 sub of length 1 which ends by 16.\n```\n\n\nWe will build such list step by step, taking elements from initial sequence by their order. On every step we will try to add this element to the longest sub that it can be added to and record changes.\n\nBuilding a list\n\nLet's build the list using sequence from your example, since it has all possible options:\n\n```\n 16 5 8 6 1 10 5 2 15 3 2 4 1\n```\n\n\nFirst, take element 16. Our list is empty so far, so we just put one pair in it:\n\n```\n1: (16, 1) <= one sub that ends by 16\n```\n\n\nNext is 5. It cannot be added to a sub that ends by 16, so it will create new sub with length of 1. We create a pair (5, 1) and put it into line 1:\n\n```\n1: (16, 1)(5, 1)\n```\n\n\nElement 8 is coming next. It cannot create the sub [16, 8] of length 2, but can create the sub [5, 8]. So, this is where algorithm is coming. First, we iterate the list rows upside down, looking at the \"values\" of last pair. If our element is greater than values of all last elements in all rows, then we can add it to existing sub(s), increasing its length by one. So value 8 will create new row of the list, because it is greater than values all last elements existing in the list so far (i. e. > 5):\n\n```\n1: (16, 1)(5, 1) \n2: (8, ?)   <=== need to resolve how many longest subs ending by 8 can be obtained\n```\n\n\nElement 8 can continue 5, but cannot continue 16. So we need to search through previous row, starting from its end, calculating the sum of \"counts\" in pairs which \"value\" is less than 8:\n\n```\n(16, 1)(5, 1)^  // sum = 0\n(16, 1)^(5, 1)  // sum = 1\n^(16, 1)(5, 1)  // value 16 >= 8: stop. count = sum = 1, so write 1 in pair next to 8\n\n1: (16, 1)(5, 1)\n2: (8, 1)  <=== so far we have 1 sub of length 2 which ends by 8.\n```\n\n\nWhy don't we store value 8 into subs of length 1 (first line)? Because we need subs of maximum possible length, and 8 can continue some previous subs. So every next number greater than 8 will also continue such sub and there is no need to keep 8 as sub of length less that it can be.\n\nNext. 6. Searching upside down by last \"values\" in rows:\n\n```\n1: (16, 1)(5, 1)  <=== 5 < 6, go next\n2: (8, 1)\n\n1: (16, 1)(5, 1)\n2: (8, 1 )  <=== 8 >= 6, so 6 should be put here\n```\n\n\nFound the room for 6, need to calculate a count:\n\n```\ntake previous line\n(16, 1)(5, 1)^  // sum = 0\n(16, 1)^(5, 1)  // 5 < 6: sum = 1\n^(16, 1)(5, 1)  // 16 >= 6: stop, write count = sum = 1\n\n1: (16, 1)(5, 1)\n2: (8, 1)(6, 1) \n```\n\n\nAfter processing 1:\n\n```\n1: (16, 1)(5, 1)(1, 1) <===\n2: (8, 1)(6, 1)\n```\n\n\nAfter processing 10:\n\n```\n1: (16, 1)(5, 1)(1, 1)\n2: (8, 1)(6, 1)\n3: (10, 2) <=== count is 2 because both \"values\" 8 and 6 from previous row are less than 10, so we summarized their \"counts\": 1 + 1\n```\n\n\nAfter processing 5:\n\n```\n1: (16, 1)(5, 1)(1, 1)\n2: (8, 1)(6, 1)(5, 1) <===\n3: (10, 2)\n```\n\n\nAfter processing 2:\n\n```\n1: (16, 1)(5, 1)(1, 1)\n2: (8, 1)(6, 1)(5, 1)(2, 1) <===\n3: (10, 2)\n```\n\n\nAfter processing 15:\n\n```\n1: (16, 1)(5, 1)(1, 1)\n2: (8, 1)(6, 1)(5, 1)(2, 1)\n3: (10, 2)\n4: (15, 2) <===\n```\n\n\nAfter processing 3:\n\n```\n1: (16, 1)(5, 1)(1, 1)\n2: (8, 1)(6, 1)(5, 1)(2, 1)\n3: (10, 2)(3, 1) <===\n4: (15, 2)  \n```\n\n\nAfter processing 2:\n\n```\n1: (16, 1)(5, 1)(1, 1)\n2: (8, 1)(6, 1)(5, 1)(2, 2) <===\n3: (10, 2)(3, 1) \n4: (15, 2)  \n```\n\n\nIf when searching rows by last element we find equal element, we calculate its \"count\" again based on previous row, and add to existing \"count\".\n\nAfter processing 4:\n\n```\n1: (16, 1)(5, 1)(1, 1)\n2: (8, 1)(6, 1)(5, 1)(2, 2)  \n3: (10, 2)(3, 1) \n4: (15, 2)(4, 1) <===\n```\n\n\nAfter processing 1:\n\n```\n1: (16, 1)(5, 1)(1, 2) <===\n2: (8, 1)(6, 1)(5, 1)(2, 2)  \n3: (10, 2)(3, 1) \n4: (15, 2)(4, 1)  \n```\n\n\nSo what do we have after processing all initial sequence? Looking at the last row, we see that we have 3 longest subs, each consist of 4 elements: 2 end by 15 and 1 ends by 4.\n\nWhat about complexity?\n\nOn every iteration, when taking next element from initial sequence, we make 2 loops: first when iterating rows to find room for next element, and second when summarizing counts in previous row. So for every element we make maximum to n iterations (worst cases: if initial seq consists of elements in increasing order, we will get a list of n rows with 1 pair in every row; if seq is sorted in descending order, we will obtain list of 1 row with n elements). By the way, O(n2) complexity is not what we want.\n\nFirst, this is obvious, that in every intermediate state rows are sorted by increasing order of their last \"value\". So instead of brute loop, binary searching can be performed, which complexity is O(log n).\n\nSecond, we don't need to summarize \"counts\" of subs by looping through row elements every time. We can summarize them in process, when new pair is added to the row, like:\n\n```\n1: (16, 1)(5, 2) <=== instead of 1, put 1 + \"count\" of previous element in the row\n```\n\n\nSo second number will show not count of longest subs that can be obtained with given value at the end, but summary count of all longest subs that end by any element that is greater or equal to \"value\" from the pair. \n\nThus, \"counts\" will be replaced by \"sums\". And instead of iterating elements in previous row, we just perform binary search (it is possible because pairs in any row are always ordered by their \"values\") and take \"sum\" for new pair as \"sum\" of last element in previous row minus \"sum\" from element left to found position in previous row plus \"sum\" of previous element in the current row.\n\nSo when processing 4:\n\n```\n1: (16, 1)(5, 2)(1, 3)\n2: (8, 1)(6, 2)(5, 3)(2, 5) \n3: (10, 2)(3, 3) \n4: (15, 2) <=== room for (4, ?)\n\nsearch in row 3 by \"values\" < 4:\n3: (10, 2)^(3, 3) \n```\n\n\n4 will be paired with (3-2+2): (\"sum\" from the last pair of previous row) - (\"sum\" from pair left to found position in previous row) + (\"sum\" from previous pair in current row):\n\n```\n4: (15, 2)(4, 3)\n```\n\n\nIn this case, final count of all longest subs is \"sum\" from the last pair of the last row of the list, i. e. 3, not 3 + 2.\n\nSo, performing binary search to both row search and sum search, we will come with O(n*log n) complexity.\n\nWhat about memory consumed, after processing all array we obtain maximum n pairs, so memory consumption in case of dynamic arrays will be O(n). Besides, when using dynamic arrays or collections, some additional time is needed to allocate and resize them, but most operations are made in O(1) time because we don't make any kind of sorting and rearrangement during process. So complexity estimation seems to be final.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find the longest increasing subsequence in a 2-D array\r\n                \r\nI have this problem as homework and I really just have no idea where to begin.  I have implemented the solution using a recursive algorithm (#1), but I just cannot figure out how to solve the problem using a stack... any assistance would be great.\n\nFind the longest increasing sequence of numbers in a 15 x 15 array.  For example, if the array, 4x4, contains\n\n```\n97  47  56  36\n35  57  41  13\n89  36  98  75\n25  45  26  17\n```\n\n\nthen the longest increasing sequence of numbers is the sequence of length eight consisting of 17, 26, 36, 41, 47, 56, 57, 97.  Note that there are no duplicates in the increasing sequence.\n\n\nDesign a recursive algorithm to solve this problem and implement it in Java.\nDesign a non-recursive algorithm to solve the same problem using a stack.\n\n    ", "Answer": "\r\nBecause this is homework, here is a hint:\nYou can convert your array of numbers to a directed acyclic graph. (It is acyclic because there are no duplicates allowed in the sequence.) After that you can use an algorithm to solve the longest path problem, to find a simple path of maximum length in your graph.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing unique subsequence\r\n                \r\nI have a list/array that looks something like this: \n\n```\n[ 0  1  2  3  4  5  6  7  3  9 10 11 13 13 14 15 16 17 18 19  4 16 22  5  3   \n  2 10 17 34  5 11 18 27 14 11 15 29  2 11 10 19 32  8 27  1 32  6  2  0]\n```\n\n\nThis list is supposed to be monotonic (strictly increasing). \nIt is not, but you can see that it is mostly increasing.\nThe values that does not fit into this pattern can be considered as noise,\nand I want them removed.\nSo I want to extract the largest possible subset of this list which will\nbe a strictly increasing sequence of numbers.\nThere are many possible monotonic sequences here, \nbut the point is to find the largest possible one.\n\nIt is important that I get the indices of the values to be removed,\nas I need to know the exact position of the remaining numbers\n(so instead of removing numbers we can replace them with\nf.ex. ```\nNone```\n, ```\nnan```\n, or ```\n-1```\n).\n\nI can not change the order of any number, \njust remove the ones that does not fit in.\n\nThe remaining list has to be strictly increasing, \nso if we have f.ex. ```\n[11 13 13 14]```\n, both of the 13s have to be removed.\n\nIf there are several possible solutions that are equally large,\nwe cannot use any of them and must choose a solution with 1 number less.\nF.ex. in ```\n[27 29 30 34 32]```\n we have to throw away both 34 and 32, \nbecause we cannot choose one over the other.\nIf we have ```\n[27 29 34 15 32]```\n there is no possible solution, \nbecause we cannot choose between ```\n[27 29]```\n, ```\n[27 34]```\n, ```\n[29 34]```\n, or ```\n[15 32]```\n.\n\nThe best possible solution to the list presented above would be this:\n\n```\n[ 0  1  2  3  4  5  6  7 -1  9 10 11 -1 -1 14 15 16 17 18 19 -1 -1 22 -1 -1   \n -1 -1 -1 -1 -1 -1 -1 27 -1 -1 -1 29 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]\n```\n\n\nCan anyone think of an algorithm that would do this specifc job?\nIf you can bring me a part on the way that would also be appreciated.\n\nMy only idea so far is a loop ```\nfor n in range(N, 0, -1):```\n\nwhere ```\nN```\n is the size of the list.\nThe loop would first try to find solutions of size ```\nn=N```\n, \nand then for ```\nn=N-1```\n, ```\nn=N-2```\n, etc.\nWhen it find exactly 1 solution for a specifc ```\nn```\n it stops and\nreturns that solution. I'm not sure what should be inside the loop yet.\n\nUPDATE:\n\nAnother SO question provides a Python algorithm for finding the longest\nsubsequence of a list. This is almost what I want to do, but not quite.\n\nI have copied that function (see below) and added a little extra code at the end which\nchanged the ouput ```\nif fullsize=True```\n.\nThen the original sequence with its original shape is rebuilt, \nbut the numbers which are not part of the increasing sequence are replaced\nby nans. And then I check if any number occurs more than once, \nand if so, replace all occurences of that number with nans.\n\nThe original algorithm must still be changed since it does not provide\nunique solutions.\n\nFor example:\n\n```\na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 32, \n    18, 19, 20, 16, 35, 35, 33, 32, 1, 35, 13, 5, 32, 8, 35, 29, 19, \n    35, 19, 28, 32, 18, 31, 13, 3, 32, 33, 35, 31, 0, 21]\nprint subsequence(a)\n```\n\n\ngives\n\n```\n[  0.   1.   2.   3.   4.   5.   6.   7.   8.   9.  10.  11.  12.  13.  14.\n  15.  16.  32.  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan\n  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan\n  nan  nan  nan  nan]\n```\n\n\nInstead of ending with ```\n.. 16 32 nan ..```\n it should have ended with\n```\n... 16 nan ... nan 31 nan nan 32 33 35 nan nan nan]```\n, \nas far as I can see.\n\nSimpler example:\n\n```\na = [0,1,2,3,4,1,2,3,4,5]\nprint subsequence(a)\n```\n\n\ngives\n\n```\n[  0.   1.   2.   3.  nan  nan  nan  nan  nan   5.]\n```\n\n\nbut it should only have given\n```\n[0 nan ... nan 5]```\n\nbecause ```\n1 2 3 4```\n appears two times and is not unique.\n\nHere comes the current semi-working version of the code\n(which was used for my example runs):\n\n```\nimport numpy as np\n\ndef subsequence(seq, fullsize=True):\n    \"\"\"\n    Credit:\n    http://stackoverflow.com/questions/3992697/longest-increasing-subsequence\n    \"\"\"\n\n    M = [None] * len(seq)    # offset by 1 (j -> j-1)\n    P = [None] * len(seq)\n\n    # Since we have at least one element in our list, we can start by\n    # knowing that the there's at least an increasing subsequence of length one:\n    # the first element.\n    L = 1\n    M[0] = 0\n\n    # Looping over the sequence starting from the second element\n    for i in range(1, len(seq)):\n        # Binary search: we want the largest j <= L\n        #  such that seq[M[j]] < seq[i] (default j = 0),\n        #  hence we want the lower bound at the end of the search process.\n        lower = 0\n        upper = L\n\n        # Since the binary search will not look at the upper bound value,\n        # we'll have to check that manually\n        if seq[M[upper-1]] < seq[i]:\n            j = upper\n\n        else:\n            # actual binary search loop\n            while upper - lower > 1:\n                mid = (upper + lower) // 2\n                if seq[M[mid-1]] < seq[i]:\n                    lower = mid\n                else:\n                    upper = mid\n\n            j = lower    # this will also set the default value to 0\n\n        P[i] = M[j-1]\n\n        if j == L or seq[i] < seq[M[j]]:\n            M[j] = i\n            L = max(L, j+1)\n\n    # Building the result: [seq[M[L-1]], seq[P[M[L-1]]], seq[P[P[M[L-1]]]], ...]\n    result = []\n    pos = M[L-1]\n    for _ in range(L):\n        result.append(seq[pos])\n        pos = P[pos]\n\n    result = np.array(result[::-1])    # reversing\n\n    if not fullsize:\n        return result  # Original return from other SO question.\n\n    # This was written by me, PaulMag:\n    # Rebuild original sequence\n    subseq = np.zeros(len(seq)) * np.nan\n    for a in result:\n        for i, b in enumerate(seq):\n            if a == b:\n                subseq[i] = a\n            elif b > a:\n                break\n        if np.sum(subseq[np.where(subseq == a)].size) > 1:  # Remove duplicates.\n            subseq[np.where(subseq == a)] = np.nan\n\n    return subseq  # Alternative return made by me, PaulMag.\n```\n\n    ", "Answer": "\r\nIt's a classical dynamic programming problem.\n\nYou store for every element the length of the largest sequence that ends at that element.\nFor the first element the value is 1 (just take that element). For the rest you take max(1, 1 + the value assigned to some other previous element that is <= then you current element). \n\nYou can implement with 2 loops (O(N^2)). There are probably some optimizations you can do if your data is really large. Or knowing your sequence is mostly good only check for the previous X elements.\n\nTo fix your data you start with one of the maximum values assigned (that the length of the longest monotonous sequence), you replace with -1 everything after that then go backward through the list looking for the previous element in the sequence (should be <= then the current one and the assigned value should be -1 what the current element is assigned), while you don't find a match, that element doesn't belong. When you find a match you take it as the current and continue backwards until you find an element you've assigned 1 to (that's the first one). \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence -- Linear Time Solution?\r\n                \r\nWe can use a stack to keep recording increasing subsequences while iterating the array. The run time is linear because each element enters and leaves the stack once. \n\nIf we want to output the actual sequence instead of its length, we can record the starting index, and then find all elements after it with greater values.\n\nDoes this linear time algorithm work?\n\n```\n    public int longestIncreasingSubsequence(int[] seq) {\n    int longest = 0;\n    int curSize = 0;\n\n    LinkedList<Integer> stack = new LinkedList<Integer>();\n\n    for (int i : seq) {\n        while (!stack.isEmpty() && i <= stack.get(0)) {\n            stack.removeFirst();\n            curSize--;\n        }\n        stack.addFirst(i);\n        curSize++;\n        if (curSize > longest) {\n            longest = curSize;\n        }\n    }\n\n    return longest;\n}\n```\n\n    ", "Answer": "\r\nNo. The algorithm you've written is not correct.\n\nConsider the test case: ```\n15,20,12,25```\n\n\n```\nAfter two pushes:\nstack: 20,15\ncurSize: 2\nlongest: 2\n\nIn comes 12. So two pops.\ncurSize: 0\n\n12 pushed:\nstack: 12\ncurSize: 1\nlongest: 2\n\n25 pushed:\nstack: 25,12\ncurSize: 2\nlongest: 2 //so gives answer 2\n```\n\n\nBut in reality the answer should be 3.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Algorithm for Longest Increasing Subsequence timing out [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How to determine the longest increasing subsequence using dynamic programming?\r\n                            \r\n                                (20 answers)\r\n                            \r\n                    \r\n                Closed 8 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am solving the Longest Subsequence problem at HackerRank. I am using Dynamic Programming algorithm to solve the Longest subsequence problem. The time complexity for my algorithm is O(n^2). Although my solution presents the correct result, its timimg out for most of the test cases. I am not able to improve my algorithm, so that it calculates the result faster. Let me know in case anybody can suggest anything. My function is as follows:\n\n```\nstatic ArrayList<Integer> calcSolution(int[] arr) throws Exception{\n        ArrayList<ArrayList<Integer>> prev = new ArrayList<ArrayList<Integer>>(); \n        ArrayList<Integer> lis = new ArrayList<Integer>();\n\n        lis.add(arr[0]);\n        prev.add(lis);\n        for(int i=1 ; i<arr.length ; i++){\n            prev.add(new ArrayList<Integer>());\n            for(int j=0 ; j<i ; j++){\n                if( (arr[i] > arr[j]) && (prev.get(i).size() < (prev.get(j).size()+1)) ){\n                    prev.get(i).addAll(prev.get(j));\n                }\n            }\n            prev.get(i).add(new Integer(arr[i]));\n        }\n\n        for(int i=0 ; i<prev.size() ; i++){\n            for(int j=0 ; j<prev.get(i).size(); j++){\n                System.out.print(prev.get(i).get(j));\n            }\n            System.out.println();\n        }\n\n        lis = prev.get(0);\n        for(int i=1 ; i<prev.size() ; i++){\n            if(prev.get(i).size() > lis.size()){\n                lis = prev.get(i);\n            }\n        }\n\n        return lis;\n    }\n```\n\n\nMy question is: - Is there anything that I can do to this algorithm that can make it faster. The algorithm suggested in the other post is a completely different algorithm.\n    ", "Answer": "\r\nYour implementation has time complexity O(n^3) and not O(n^2).\n\n```\nprev.get(i).addAll(prev.get(j)); \n```\n\n\nis unnecessary and expensive. \n\nFor every element, you need to remember the previous link and the length of the subsequence ending at it. You don't need to memorize the actual subsequence at each element.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to find the longest odd-even increasing subsequence in python? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed last year.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have this problem and I'm not sure about the solution:\nGiven an integer array A, calculate the length of its longest odd-even increasing subsequence (LOEIS), that is the length of the longest sequence S of elements in A such that all elements of S are odd or even.\nFor instance, given:  A=[3,9,4,8,6,13,10,26,16,18], because the longest even sequence is made of 5 elements:  [4,6,10,16,18] we have LOEIS(A)=5.\nHow to code such a function?\nThank you!\n    ", "Answer": "\r\nHere a solution from https://www.geeksforgeeks.org/python-program-for-longest-increasing-subsequence/ that I've adapted to you issue:\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# A naive Python implementation of LIS problem\n\n\"\"\" To make use of recursive calls, this function must return\n two things:\n 1) Length of LIS ending with element arr[n-1]. We use\n max_ending_here for this purpose\n 2) Overall maximum as the LIS may end with an element\n before arr[n-1] max_ref is used this purpose.\n The value of LIS of full array of size n is stored \n  in * max_ref which is our final result \"\"\"\n\n# global variable to store the maximum\nglobal maximum\n\n\ndef _lis(arr, n):\n    # to allow the access of global variable\n    global maximum\n\n    # Base Case\n    if n == 1:\n        return 1\n\n    # maxEndingHere is the length of LIS ending with arr[n-1]\n    maxEndingHere = 1\n\n    \"\"\"Recursively get all LIS ending with arr[0], arr[1]..arr[n-2]\n       IF arr[n-1] is smaller than arr[n-1], and max ending with\n       arr[n-1] needs to be updated, then update it\"\"\"\n    for i in range(1, n):\n        res = _lis(arr, i)\n        if arr[i - 1] < arr[n - 1] and res + 1 > maxEndingHere:\n            maxEndingHere = res + 1\n\n    # Compare maxEndingHere with overall maximum. And\n    # update the overall maximum if needed\n    maximum = max(maximum, maxEndingHere)\n\n    return maxEndingHere\n\n\ndef lis(arr):\n    # to allow the access of global variable\n    global maximum\n\n    # length of arr\n    n = len(arr)\n\n    # maximum variable holds the result\n    maximum = 1\n\n    # The function _lis() stores its result in maximum\n    _lis(arr, n)\n\n    return maximum\n\n\n\n\n\nA=np.array([3,9,4,8,6,13,10,26,16,18])\nEven = A[A%2==0]\nOdd = A[A%2==1]\nprint(Even,Odd)\n\nprint(\"Length of lis for Even is\", lis(Even))\nprint(\"Length of lis for Odd is\", lis(Odd))\n```\n\n\nLength of lis for Even is 5\n\n\nLength of lis for Odd is 3\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find the longest increasing subsequence from start to end\r\n                \r\nHow do I find the LIS,subsequence, with the constraint that I cant skip first and last element?\n\nEDIT:\nWhat I actually meant was that I have to start from the beginning and end at the end.Also I want to extend this for a zigzag subsequence like \nDynamic programming: Find longest subsequence that is zig zag\n    ", "Answer": "\r\nImplement the typical LIS algorithm, simply remove all elements smaller than the first element and bigger than the last one from the input. Only consider elements that are not the first or the last one for the solution and then append these two to the solution you find. Also in case the last element is no bigger than the first one say there is no increasing subsequence.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to find Longest non-decreasing Subsequence containing duplicates in O(n) or O(nlogn)?\r\n                \r\nWe know about an algorithm that will find the Longest Increasing subsequence in O(nlogn). I was wondering whether we can find the Longest non-decreasing subsequence with similar time complexity?\nFor example, consider an array : (4,10,4,8,9).\nThe longest increasing subsequence is (4,8,9).\nAnd a longest non-decreasing subsequence would be (4,4,8,9).\n    ", "Answer": "\r\nFirst, here’s a “black box” approach that will let you find the longest nondecreasing subsequence using an off-the-shelf solver for longest increasing subsequences. Let’s take your sample array:\n```\n4, 10, 4, 8, 9\n```\n\nNow, imagine we transformed this array as follows by adding a tiny fraction to each number:\n```\n4.0, 10.1, 4.2, 8.3, 9.4\n```\n\nChanging the numbers this way will not change the results of any comparisons between two different integers, since the integer components have a larger magnitude difference than the values after the decimal point. However, if you compare the two ```\n4```\ns now, the latter 4 compares bigger than the previous one. If you now find the longest nondecreasing subsequence, you get back ```\n[4.0, 4.2, 8.3, 9.4]```\n, which you can then map back to ```\n[4, 4, 8, 9]```\n.\nMore generally, if you’re working with an array of n integer values, you can add i / n to each of the numbers, where i is its index, and you’ll be left with a sequence of distinct numbers. From there running a regular LIS algorithm will do the trick.\nIf you can’t work with fractions this way, you could alternatively multiply each number by n and then add in i, which also works.\nOn the other hand, suppose you have the code for a solver for LIS and want to convert it to one that solves the longest nondecreasing subsequence problem. The reasoning above shows that if you treat later copies of numbers as being “larger” than earlier copies, then you can just use a regular LIS. Given that, just read over the code for LIS and find spots where comparisons are made. When a comparison is made between two equal values, break the tie by considering the later appearance to be bigger than the earlier one.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Applications of Longest Increasing Subsquence\r\n                \r\nHow useful is the LIS (Longest Increasing Subsequence) problem in tackling other CS problems?  There are a few algorithms, using patience sorting, dynamic programming or with decision trees.  How are these used in real life -- maybe to data streams or something?\n\nTo remind you, I put in bold the longest increasing sequence\n\n{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}.\n\nAs a bonus, is there any way to use the result that a sequence of length mn + 1 will have an increasing subsequence of length m or a decreasing subsequence of length n? E.g. Our list as length 16, so there should be an increasing sequence of length 5 or decreasing sequence of length 5.  In our case 0,2,6,9,11,15.\n\nAlso an increasing sequence of length 8 or a decreasing sequence of length 3: in our case 12,10,1.\n    ", "Answer": "\r\nAn interesting real-world application of LIS is Patience Diff, a diffing algorithm by Bram Cohen (the creator of BitTorrent) which is used in the Bazaar version control system.\n\nThe regular diff algorithm involves computing the LCS (Longest Common Subsequence) between two documents. While being efficient, this approach has a problem, which is -- the results often happen to be not quite human-friendly.\n\nA simple example of how a regular diff may fail:\n\n```\n void func1() {\n     x += 1\n+}\n+\n+void functhreehalves() {\n+    x += 1.5\n }\n\n void func2() {\n     x += 2\n }\n```\n\n\nThe advantage of the Patience Diff algorithm is that it allows to compute the differences more accurately, in a manner more closely corresponding to how a human would perform.\n\nIn the previous case Patience Diff spots the difference better:\n\n```\n void func1() {\n     x += 1\n }\n\n+void functhreehalves() {\n+    x += 1.5\n+}\n+\n void func2() {\n     x += 2\n }\n```\n\n\nIn a nutshell, the algorithm is:\n\n\nFind unique lines which are common to both documents.\nTake all such lines from the first document and order them according to their appearance in the second document.\nCompute the LIS of the resulting sequence (by doing a Patience Sort), getting the longest matching sequence of lines, a correspondence between the lines of two documents.\nRecurse the algorithm on each range of lines between already matched ones.\n\n\nTake a look at the code.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find the length of the longest increasing subsequence using only one auxiliary recursion function\r\n                \r\nI need to find the length of the longest monotonically increasing subsequence using only a single recursion function.\nFor example given an ```\narr={45 1 21 3 33 6 53 9 18}```\n it need to give back 5. I have started to write the code but i'm stuck, and i don't know how to find out which of the calls gives the maximum length.\n\nThe function ```\nlongestSet```\n is my auxiliary function i can use any variables i want but it have to be called from the function ```\nmax_set```\n.\n\n```\nvoid question3(int question)\n{\n    int *arr, size;\n    printf(\"enter the array size\\n\");\n    scanf(\"%d\", &size);\n    arr=(int*)malloc(size*sizeof(int));\n    fillArr(arr, size-1);\n    max_set(arr, size);\n    free(arr);\n}\n\nvoid max_set(int arr[], int size)\n{\n    int i=0, finelmax=0, count=0,longrising;\n    longrising=longestSet(arr,size,i,finelmax,count);\n    printf(\"the length of the longest risind set is: %d\", longrising);\n}\n\nint longestSet(int arr[], int size, int i, int finelmax, int count)\n{\n    if(i==size)\n        return count;\n\n    if(arr[i]>=finelmax)\n    {\n        finelmax=arr[i];\n        return longestSet(arr,size,i+1,finelmax,count+1);\n    }\n\n    return longestSet(arr,size,i+1,finelmax,count);\n}\n```\n\n    ", "Answer": "\r\nSomething like this:\n\n```\nint longestSet(int arr[], int size, int i, int finelmax, int count)\n{\n    if(i==size) return count;\n\n    int length1 = longestSet(arr, size, i + 1, finelmax, count);\n    if(arr[i] > finelmax)\n    {\n        int length2 = longestSet(arr, size, i + 1, arr[i], count + 1);\n        if(length2 > length1) length1 = length2;\n    }\n\n    return length1;\n}\n```\n\n\nWhat this basically does is at each point compare if it would be better to include the current number or skip it. Also will be pretty slow - you can for example add memoization to it to improve, but I'm guessing that's not part of the homework?\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "find the longest increasing subsequence (LIS)\r\n                \r\nGiven A= {1,4,2,9,7,5,8,2}, find the LIS. Show the filled dynamic programming table and how the solution is found.\n\nMy book doesnt cover LIS so im a bit lost on how to start. For the DP table, ive done something similar with Longest Common Subsequences. Any help on how to start this would be much appreciated.\n    ", "Answer": "\r\nAlready plenty of answers on this topic but here's my walkthrough, I view this site as a repository of answers for future posterity and this is just to provide additional insight when I worked through it myself.\n\nThe longest Increasing Subsequence (LIS) problem is to find the length of the longest subsequence of a given sequence such that all elements of the \nsubsequence are sorted in increasing order. For example, length of LIS for \n\n```\n{ 10, 22, 9, 33, 21, 50, 41, 60, 80 } is 6 and LIS is {10, 22, 33, 50, 60, 80}.\n```\n\n\nLet ```\nS[pos]```\n be defined as the smallest integer that ends an increasing sequence of length pos.\n\nNow iterate through every integer X of the input set and do the following:\n\nIf X > last element in S, then append X to the end of S. This essentialy means we have found a new largest LIS.\n\nOtherwise find the smallest element in S, which is >= than X, and change it to X. Because S is sorted at any time, the element can be found \nusing binary search in log(N).\n\nTotal runtime - N integers and a binary search for each of them - N * log(N) = O(N log N)\n\nNow let's do a real example:\n\nSet of integers: 2 6 3 4 1 2 9 5 8\n\nSteps:\n\n```\n0. S = {} - Initialize S to the empty set\n1. S = {2} - New largest LIS\n2. S = {2, 6} - 6 > 2 so append that to S\n3. S = {2, 3} - 6 is the smallest element > 3 so replace 6 with 3\n4. S = {2, 3, 4} - 4 > 3 so append that to s\n5. S = {1, 3, 4} - 2 is the smallest element > 1 so replace 2 with 1\n6. S = {1, 2, 4} - 3 is the smallest element > 2 so replace 3 with 2\n7. S = {1, 2, 4, 9} - 9 > 4 so append that to S\n8. S = {1, 2, 4, 5} - 9 is the smallest element > 5 replace 9 with 5\n9. S = {1, 2, 4, 5, 8} - 8 > 5 so append that to S\nSo the length of the LIS is 5 (the size of S).\n```\n\n\nLet's take some other sequences to see that this will cover all possible caveats, each presents its own issue\n\nsay we have ```\n1,2,3,4,9,2,3,4,5,6,7,8,10```\n\n\nbasically it builds out ```\n12349```\n first, then ```\n2```\n will replace ```\n3```\n, ```\n3```\n will replace ```\n4```\n, ```\n4```\n will replace ```\n9```\n, then append ```\n5,6,7,8,10```\n \nso will look like ```\n1,2,2,3,4,6,7,8,10```\n\n\ntake the other case we have ```\n1,2,3,4,5,9,2,10```\n\nthis will give us ```\n1,2,2,4,5,9,10```\n\n\nor take the case we have ```\n1,2,3,4,5,9,6,7,8,10```\n\nthis will give us ```\n1,2,3,4,5,7,8,10```\n\n\nso that kind of illuminates what goes on, in the first case the critical juncture being what happens when you hit the ```\n2```\n after the ```\n9```\n, \nhow do you deal with these. well the block of ```\n2,3,4```\n won't do anything really, when you hit ```\n5```\n you replace the ```\n9```\n because the ```\n5```\n and ```\n9```\n \nare virtually indifferentiable ```\n9```\n ends the block of the first ```\n5```\n increasing elements, you replace ```\n9```\n with ```\n5```\n because ```\n5```\n is smaller so there \nis greater potential to hit something > ```\n5```\n later on. but you only replace the smallest element > itself.  for ex. in the last case, \nif your ```\n6```\n doesn't replace ```\n9```\n but instead replaces ```\n1```\n and ```\n7```\n replaces ```\n2```\n and ```\n8```\n replaces ```\n3```\n, then we get a final array of 7 elements instead \nof 9. So just do a couple of these and figure out the pattern, this logic isn't the easiest to translate to paper. \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Maximum of Longest Increasing Sequences\r\n                \r\nI have a code that will find all the cycles of a list, e.g for [1,2,3] the cycles are [1,2,3], [2,3,1], [3,1,2]. I also have a code for finding the longest increasing subsequence. \n\nWhat I want to do is input a list, find the longest increasing subsequence of every cycle of that list, and then return the maximum length out of all of these. how do I go from these two functions to finding the LIS of every cycle and then return the maximum?\n\nHere is my code so far: \n\n```\ndef cycles(X):\n\n  n = len(X)\n\n  values = []\n\n  for i in range(0,n):\n    values.append(X[i:n] + X[0:i])\n\n  return values    \n\n\n\ndef longest_increasing_subsequence(d):\n\n    l = []\n\n    for i in range(len(d)):\n\n        l.append(max([l[j] for j in range(i) if l[j][-1] < d[i]] or  [[]], key=len)  + [d[i]])\n\n\n    return len(max(l, key=len))\n```\n\n\nI'd appreciate any help. thanks.\n    ", "Answer": "\r\nThis will do the job:\n\n```\nl=[1,2,3,4]\ns=cycles(l)\nlis=[longest_increasing_subsequence(d) for d in s]\nprint(lis) \nprint(max(lis))\n```\n\n\nThe result is \n\n```\n[4,3,2,3]\n```\n\n\nand\n\n```\n4\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Python Longest Increasing Subsequence of Indexes in a Array\r\n                \r\nThis algorithm (originally implemented in unl-aligner) calculates the longest list of increasing numbers with correspondingly increasing indices in the sequence, so given\n\n```\nseq = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n```\n\n\nit will return\n\n```\n[0, 2, 6, 9, 11, 15]\n```\n\n\nthe implementation looks like\n\n```\ndef subseq(seq, keyfn=lambda value: value):\n    if not seq: return seq\n    tail = []\n    prev = []\n    for i in range(len(seq)):\n        for k in range(len(tail)-1, -1, -1):\n            if keyfn(seq[tail[k]]) < keyfn(seq[i]):\n                if len(tail) == k+1:\n                    tail.append(i)\n                elif keyfn(seq[tail[k+1]]) > keyfn(seq[i]):\n                    tail[k+1] = i\n                prev.append(tail[k])                    \n                break\n        else:\n            tail.append(i)\n            prev.append(None)\n\n    i = tail[-1]\n    subseq = [seq[i]]\n    while prev[i] is not None:\n        i = prev[i]\n        subseq.append(seq[i])\n    subseq.reverse()\n    return subseq\n```\n\n\nThe algorithm performs a linear scan, while a bisect (binary) search should be preferred.\nWhich is the best approach to refactor it to perform a binary search?\n    ", "Answer": "\r\nWith this answer:\n\n```\nbisect = \"longest_subsequence([1,2,3,4,5,6,7,2,2,2,2,2,5,1,7,8])\"\n_subseq = \"subseq([1,2,3,4,5,6,7,2,2,2,2,2,5,1,7,8])\"\n\nfrom timeit import timeit\n\nprint(timeit(bisect, globals=globals(), number=10000))  # 0.2994734\nprint(timeit(_subseq, globals=globals(), number=10000))  # 0.32428109999999993\n```\n\n\nThis is the result on a totally random test, for your example they seem almost exact time-wise\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "UVa 10134: Is Bigger Smarter? (Dynamic programming and longest increasing subsequence)\r\n                \r\n```\nprivate void findLDS() {\n    Integer[] array = Arrays.copyOf(elephants.iq, elephants.iq.length);\n    Hashtable<Integer, Integer> eq = elephants.elephantiqs;\n\n    Integer[] lds = new Integer[array.length];\n    Integer[] prev= new Integer[array.length];\n    lds[0] = 0;\n    prev[0] = 0;\n\n    int maxlds = 1, ending=0;\n\n    for(int i = 0; i < array.length; ++i) {\n        lds[i] = 1;\n        prev[i] = -1;\n\n        for (int j = i; j >= 0; --j) {\n            if(lds[j] + 1 > lds[i] && array[j] > array[i] && eq.get(array[j]) < eq.get(array[i])) {\n                lds[i] = lds[j]+1;\n                prev[i] = j;\n            }\n        }\n        if(lds[i] > maxlds) {\n            ending = i;\n            maxlds = lds[i];\n        }\n    }\n    System.out.println(maxlds);\n    for(int i = ending; i >= 0; --i) {\n        if(prev[i] != -1) {\n            System.out.println(eq.get(array[prev[i]])); \n        }\n\n    }\n```\n\n\nI have based this algorithm on this SO question. This code is trying to find longest decreasing subsequence instead of increasing. array[] is sorted in descending order, and I also have a hashtable with the elephants IQ's as keys for their weights.\n\nI'm having a hard time properly understanding DP, and I need some help.\n\nMy algorithm seems to work fine besides tracking the chosen sequence in prev[], where it always misses one element. Does anyone know how to do this?\n    ", "Answer": "\r\nA few ways to approach this one:\n\n\nSort by weight in decreasing order, then find the longest increasing subsequence.\nSort by IQ in decreasing order, then find the longest increasing subsequence of weights.\nand 4. are just (1) and (2), switching the words \"increasing\" and \"decreasing\"\n\n\nIf you don't understand the DP for longest increasing subsequence O(N^2), it's basically this:\n\n\nSince the list has to be strictly increasing/decreasing anyway, you can just eliminate some elephants beforehand to make the set unique.\nCreate an array, which I will call ```\nllis```\n standing for \"Longest Increasing Subsequence\", of length N, the number of elephants there now are. Create another array called ```\nlast```\n with the same length. I will assume the sorted list of elephants is called ```\narray```\n as it is in your problem statement.\nAssuming that you've already sorted the elephants in decreasing order, you will want to find the longest increasing subsequence of IQs.\nTell yourself that the element in the array ```\nllis```\n at index n (this is a different \"n\") < N will be the length of the longest increasing subsequence for the sub-array of ```\narray```\n from index 0 to n, inclusive. Also say that the element in the ```\nnext```\n array at index n will be the next index in ```\narray```\n in the longest increasing subsequence.\nTherefore, finding the length of the longest increasing subsequence in the \"sub-array\" of 0 to N - 1 inclusive, which is also the whole array, would only require you to find the N - 1 th element in the array ```\nllis```\n after the DP calculations, and finding the actual subsequence would simplify to following the indices in the ```\nnext```\n array.\nNow that you know what you're looking for, you can proceed with the algorithm. At index n in the array, how do you know what the longest increasing subsequence is? Well, if you've calculated the length of the longest increasing subsequence and the last value in the subsequences for every k < n, you can try adding the elephant at index n to the longest increasing subsequence ending at k if the IQ of the elephant n is higher than the IQ of the elephant at k. In this case, the length of the longest increasing subsequence ending at elephant n would be ```\nllis[k] + 1```\n. (Also, remember to set ```\nnext[k]```\n to be n, since the next elephant in the increasing subsequence will be the one at n.)\nWe've found the DP relation that ```\nllis[n] = max(llis[n], llis[k] + 1)```\n, after going through all k s that come strictly before n. Just process the n s in the right order (linearly) and you should get the correct result.\nProcedure/warnings: 1) Process n in order from 0 to N - 1. 2) For every n, process k in order from n - 1 to 0 because you want to minimize the k that you choose. 3) After you're done processing, make sure to find the maximum number in the array ```\nllis```\n to get your final result.\nSince this is tagged as homework, I won't explicitly say how to modify this to find the longest decreasing subsequence, but I hope my explanation has helped with your understanding of DP. It should be easy to figure out the decreasing version on your own, if you choose to use it. (Note that this problem can be solved using the increasing version, as described in approaches 1 or 2.)\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing and Decreasing subsequence (Top-Down with memoization)\r\n                \r\nQuestion - Given an array of integers, A of length N, find the length of longest subsequence which is first increasing then decreasing.\nInput:[1, 11, 2, 10, 4, 5, 2, 1]\n\nOutput: 6\n\nExplanation:[1 2 10 4 2 1] is the longest subsequence.\n\nI wrote a top-down approach. I have five arguments - vector A(containing the sequence), start index(denoting the current index), previous value, large(denoting maximum value in current subsequence) and map(m) STL.\n\nFor the backtrack approach I have two cases -\n\n\nelement is excluded - In this case we move to next element(start+1). prev and large remains same.\nelement is included - having two cases \n\na. if current value(A[start]) is greater than prev and prev == large then this is the case\n  of increasing sequence. Then equation becomes 1 + LS(start+1, A[start], A[start]) i.e. \n  prev becomes current element(A[start]) and largest element also becomes A[start].\n\nb. if current value (A[start]) is lesser than prev and current (A[start]) < large then \n  this is the case of decreasing sequence. Then equation becomes 1 + LS(start+1, A[start], \n  large) i.e. prev becomes current element(A[start]) and largest element remains same i.e. \n  large.\n\n\nBase Cases -\n\n\nif current index is out of the array i.e. start == end then return 0.\nif sequence is decreasing and then increasing then return 0.\ni.e. if(current> previous and previous < maximum value) then return 0.\n\n\nThis is not an optimized approach approach as map.find() is itself a costly operation. Can someone suggest optimized top-down approach with memoization.\n\n```\nint LS(const vector<int> &A, int start, int end, int prev, int large, map<string, int>&m){\n\n    if(start == end){return 0;}\n    if(A[start] > prev && prev < large){\n        return 0;\n    }\n\n    string key = to_string(start) + '|' + to_string(prev) + '|' + to_string(large);\n\n    if(m.find(key) == m.end()){\n        int excl = LS(A, start+1, end, prev, large, m);\n        int incl = 0;\n        if(((A[start] > prev)&&(prev==large))){\n            incl = 1 + LS(A, start+1, end, A[start],A[start], m); \n        }else if(((A[start]<prev)&&(A[start]<large))){\n            incl = 1+ LS(A, start+1, end, A[start], large, m);\n        }  \n\n        m[key] = max(incl, excl);\n    }\n\n    return m[key];\n}\n\nint Solution::longestSubsequenceLength(const vector<int> &A) {\n        map<string, int>m;\n        return LS(A, 0, A.size(), INT_MIN, INT_MIN, m);\n}\n```\n\n    ", "Answer": "\r\nNot sure about top-down but it seems we could use the classic LIS algorithm to just approach each element from \"both sides\" as it were. Here's the example with each element as the rightmost and leftmost, respectively, as we iterate from both directions. We can see three instances of a valid sequence of length 6:\n\n```\n[1, 11, 2, 10, 4, 5, 2, 1]\n\n 1 11       11 10 4 2 1\n 1 2                2 1\n 1 2 10        10 4 2 1\n 1 2 4            4 2 1\n 1 2 4 5          5 2 1\n 1 2                2 1\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to find the longest alternating increasing subsequence by alternating between two arrays\r\n                \r\nGiven two arrays of numbers, how do I find the longest increasing subsequence by alternating between the elements of the two arrays?\nfor example\n```\nA = [4, 1, 10, 5, 9]\nB = [4, 5, 7, 14]\nso the output must be [1,4,5,7,9,14]\n```\n\nIt HAS to be in the format of element of a , element of b , element of a , element of b ... so on.\nI tried finding a solution but I couldn't think of anything, I tried the LIS approach but since that code requires one array only that didnt make sense to me either sorry\n(just in case , to make it more clear = [ 1(A), 4(B), 5(A), 7(B), 9(A), 14(B)] also, note how the order cannot be changed)\nThanks and sorry if I've not phrased it properly\n    ", "Answer": "\r\nThe simplest way would just be to do:\n```\n# lias: Longest Increasing Alternating Subsequence\ndef lias(curr, next, seq):\n    good, elem = False, None\n    while not good:\n        if not curr: return seq\n        elem = min(curr); curr.remove(elem)\n        good = False if elem in seq or elem < max(seq, default=0) else True\n    seq.append(elem)\n    return lias(next, curr, seq)\n\n\nif __name__ == '__main__':\n    A = [4, 1, 10, 5, 9]\n    B = [4, 5, 7, 14]\n    print(lias(A,B, []))\n    \n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Finding the longest increasing contiguous subsequence\r\n                \r\nI'm attempting to write a program that takes a sequence as an array, then prints the longest contiguous subsequence, as well as its length.  In the code I've written thus far (below), I've managed to accomplish this in the method longestForward.  However, in the assignment specification I've also been asked to write another method, longestBackwards, that accomplishes the exact same task ie. will print the exact same thing, but it must search the original array backward.  This is where I'm having difficulty. \n\nI've managed to write a method that prints only the last two members of the longest contiguous subsequence, and in reverse order (for example, for the array 4, 5, 6 it prints 6, 5).  However it does print the length correctly.\n\nIf anyone can help figure out what I've done wrong that would be much appreciated.\n\n```\nimport java.util.Scanner;\npublic class LongestSubsequence {\npublic static void main(String[] args) {\n\n    // Test array\n    int[] arr = {4, 5, 6};\n\n\n    longestForward(arr);\n    longestBackward(arr);\n\n  }\n\npublic static void longestForward(int[] arr)\n{\n    int subSeqLength = 1;\n    int longest = 1;\n    int indexStart = 0;\n    int indexEnd = 0;\n\n    for (int i = 0; i < arr.length - 1; i++)\n    {\n        if (arr[i] < arr[i + 1] )//We need to check if the current is equal to the next\n        {\n            subSeqLength++;//if it is we increment\n            if (subSeqLength > longest)//we assign the longest and new bounds\n            {\n                longest = subSeqLength;\n                indexStart = i + 2 - subSeqLength;\n                indexEnd = i + 2;\n            }\n\n        } \n        else\n            subSeqLength = 1;//else re-initiate the straight length\n    }\n\nSystem.out.println(longest);\n    for (int i = indexStart; i < indexEnd; i++)//print the sequence\n\n      System.out.print(arr[i] + \", \");  \n}\npublic static void longestBackward(int[] arr) {\n\n    int subSeqLength = 1;\n    int longest = 1;\n    int indexStart = 0;\n    int indexEnd = 0;\n    for (int i = arr.length - 1; i > 0; i--) {\n        if (arr[i] > arr[i - 1]) { \n            subSeqLength++;\n            if (subSeqLength > longest) {\n                longest = subSeqLength;\n                indexStart = i + (subSeqLength - 1); \n                indexEnd = i - 1;\n            }\n        } // Else re-initiate the length\n        else {\n            subSeqLength = 1;\n        }\n    }\nSystem.out.println(\"\");\n    // Print the sequence\nSystem.out.println(longest);\n    for (int i = indexStart-1; i > indexEnd; i--) {\n        System.out.print(arr[i] + \", \");\n    }\n}\n}\n```\n\n    ", "Answer": "\r\nJust to clarify.. Why can't you take the longest forward and reverse it? Wouldn't the longest forward be the reverse of the longest backward?\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Length of Longest increasing subsequence\r\n                \r\nI am not expecting for a solution here. But I have trouble finding out what could be a possible error. I feel that this is correct solution but however, the solution is not passing all the test case I have. e.g ```\n{2,2}```\n . Below is the code I have written in a brute force (worst case - ```\nn!```\n complexity) approach. Any help would be greatly appreciated. I am not expecting the solution but would like to know where I am going wrong and how to get it right.\n\n```\n package org.practice;\n    import java.util.Arrays;\n    import java.util.HashSet;\n    import java.util.LinkedList;\n    import java.util.List;\n\n    public class LengthofLIS {\n        int maxLength = 0;\n\n        public static void main(String[] args) {\n            // TODO Auto-generated method stub\n            LengthofLIS l = new LengthofLIS();\n            int[] nums = { 2,2 };\n            l.lengthOfLIS(nums);\n        }\n\n        public int lengthOfLIS(int[] nums) {\n            if (nums.length == 1)\n                return nums.length;\n            List<Integer> hs = new LinkedList<>();\n            dfs(nums, 0, 0, nums.length - 1, hs);\n            System.out.println(maxLength);\n            return maxLength;\n        }\n\n        public void dfs(int[] nums, int index, int length, int end, List<Integer> hs) {\n\n        if (index > end) {\n            return;\n        }\n\n        for (int i = index; i <= end; i++) {\n\n            if (hs.size() == 0) {\n                hs.add(nums[i]);\n                length++;\n            } else if (nums[i] > hs.get(hs.size() - 1)) {\n                hs.add(nums[i]);\n                length++;\n            }\n\n            else if (nums[i] <= hs.get(hs.size() - 1))\n                continue;\n\n            dfs(nums, i + 1, length, end, hs);\n            //System.out.println(\"Printing \" + Arrays.asList(hs));\n            maxLength = Math.max(maxLength, hs.size());\n\n            if (maxLength == nums.length)\n                break;\n\n            if (hs.size() != 0) {\n                hs.remove(hs.get(hs.size() - 1));\n                length--;\n            }\n        }\n    }\n    }\n```\n\n    ", "Answer": "\r\nSince you didn't ask for any solution, I won't provide you one, and on the other hand, you could simply find lots of answers by just a simple search.\n\nHere is what I understand from your code: \n\n```\npublic void dfs(int[] nums, int index, int length, int end, List<Integer> hs) {\n    if (index > end) {\n        return;\n    }\n    for (int i = index; i <= end; i++) {\n        if (hs.size() == 0) {\n            hs.add(nums[i]);\n            length++;\n        }\n        else if (nums[i] > hs.get(hs.size() - 1)) {\n            hs.add(nums[i]);\n            length++;\n        }\n        else if (i == end && nums[i] < hs.get(hs.size() - 1)) { //(1) \n            maxLength = Math.max(maxLength, hs.size());\n        }\n        else if (nums[i] < hs.get(hs.size() - 1))\n            continue;\n        dfs(nums, i + 1, length, end, hs);\n        if (hs.size() != 0) { //(2)\n            hs.remove(hs.get(hs.size() - 1));\n            length--;\n        }\n    }\n}\n```\n\n\n\nwhat do you want to accomplish with that? consider the situation when the last element is the biggest element, then you will always print ```\n0```\n because you'll never set ```\nmaxLength```\n.\nyour main problem is here. Because you remove ```\na[i]```\n , ```\na[i+1]```\n recursively from the list. suppose you have ```\n{2, 3, 100, 4, 5, 6, 1}```\n instead of considering ```\n[2, 3, 4, 5, 6]```\n longest list, your code will consider ```\n[2, 4, 5, 6]```\n the longest list.\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence variations dynamic programming\r\n                \r\nI have this question:\n\nGiven the following:\n\n```\nA = [9,6,9,3,8,9,2,0,4,12]```\n\n```\nC = [r,g,r,g,r,g,r,r,r,g]```\n\n\nWhere \n - ```\nr```\n = red \n - ```\ng```\n = green \n\nThis list represent the color of the number in the same index in array ```\nA```\n  i.e. ```\nA[0] = 9 = red, A[1] = 6 = green, ...```\n\n\nWe need to pick a number ```\nN```\n to start, if the number is ```\ngreen```\n we can only move right (by any numbers) to a number that are ```\n>=N```\n greater than the current one.\n\nIf the number ```\nN```\n is ```\nred```\n, we can only move left (by any numbers) to a number that are ```\n>=N```\n greater than the current one.\n\nObjective: find the longest sequence of moves possible, return the indices of the path. If there are multiple subsequences of the same length that are longest, return anyone:\n\nExample 1:\n\n```\n    A = [9,6,9,3,8,9,2,0,4,12]\n    C = [r,g,r,g,r,g,r,r,r,g]\n    output: [7,6,3,8,1,4,0]\n```\n\n\nExample 2:\n\n```\n    A = [1,2,3,4,5,6,7,10]\n    C =[r,r,r,r,r,r,r,r]\n    output:[7]\n```\n\n\nExample 3:\n\n```\n    A = [5,3,2,0,24,9,20]\n    C = [g,g,g,g,r,r,g]\n    output: [0,5,4]\n```\n\n\nCurrent idea of my algorithm:\n\nConsider possible moves for every element in ```\nA```\n, for the first example, ```\nA[0] = 9```\n = ```\nred```\n. \n\nAs there is no left elements, there is only ```\n1```\n move (choose ```\nA[0]```\n). \n\nSo, ```\nOPT[0] = 1```\n. For ```\nA[1] = 6```\n = ```\ngreen```\n. \nPossible move are: ```\nA[2]= 9```\n, ```\nA[4] = 8```\n, ```\nA[5] = 9```\n, ```\nA[9] =12```\n.\n\nRecursion is ```\nOPT[i] = max{1, 1+ OPT[j]}```\n  where ```\nj```\n is the next possible move. \n\nAm I on the right track using dynamic programming? The runtime is ```\nO(n²)```\n isn't it?\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Where am I going wrong in this implementation of the \"Longest Increasing Subsequence\" problem?\r\n                \r\nThe problem statement : Longest Increasing Subsequence\nMy attempt at a solution is outlined below:\n```\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] dp = new int[nums.length];\n        return lisHelper(nums,dp,nums.length-1,nums[nums.length-1]);\n    }\n    private int lisHelper(int[] nums, int[] dp, int currIdx, int prevVal){\n        if (currIdx==-1){return 0;}\n        if (currIdx==0){return 1;}\n        if(dp[currIdx]!=0){return dp[currIdx];}\n        if(prevVal<=nums[currIdx]){\n            dp[currIdx]=lisHelper(nums,dp,currIdx-1,prevVal);\n        }else{\n            dp[currIdx]=1+lisHelper(nums,dp,currIdx-1,nums[currIdx]);\n        }\n        return dp[currIdx];\n    }\n}\n```\n\nThe code above returns the correct answer for the following use cases:\n[10,9,2,5,3,7,101,18] : Correct answer is 4, code returns 4\n[7,7,7,7,7,7,7] : Correct answer is 1, code returns 1\n[0,1,0,3,2,3] : Correct answer is 4, code returns 3\nAll base cases (empty array and array of length 1) return correct result.\nHow can I change the above code, to handle the failed case here ? It appears to me to be a small change, however, I cannot seem to put my finger on it, for some reason.\nEDIT\nFirstly, I would like to thank everyone who went through my question and provided their thoughts (CaptainTrojan, user15793316 & potter1024)\nBased on your suggestions, I have been able to come up with the correct solution to the problem.\nHere it is:\n```\n    public int lengthOfLIS(int[] nums) {\n        int[][] dp = new int[nums.length+1][nums.length+1];\n        for (int[] row: dp) {\n            Arrays.fill(row,-1);\n        }  \n        return lisHelper(nums,dp,nums.length-1,nums.length);\n    }\n    \n    private static int lisHelper(int[] nums,int[][] dp, int currIdx, int prevIdx){\n        if (currIdx==-1){return 0;}\n\n        if(dp[currIdx][prevIdx]!=-1){return dp[currIdx][prevIdx];}\n\n        int include = 0;\n        if(prevIdx==nums.length || nums[prevIdx]>nums[currIdx]){\n            include= 1+lisHelper(nums,dp,currIdx-1,currIdx);\n        }\n        int exclude= lisHelper(nums,dp,currIdx-1,prevIdx);\n\n        dp[currIdx][prevIdx]=Math.max(exclude,include);\n\n        return dp[currIdx][prevIdx];\n    }\n```\n\nThis solution passes all test cases, however, it uses O(n^2) extra space to store results of subproblems.\nIs it possible to solve it using less space than this ?\n    ", "Answer": "\r\nYour solution is algorithmically wrong. To keep it simple, the time complexity of your algorithm is ```\nO(n)```\n whereas the typical dynamic programming approach solves it in ```\nO(n^2)```\n.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence using 2-3 tree\r\n                \r\nWhile preparing for my data structures final I came across this problem:\n\nA - a given array of integers of length n.\n\nPropose data structure with supports the following operations:\n\nInit(A) - initialisation of the structure given the array A. Worst case complexity: O(nlogn).\nLengthOfLongest() - returns the length of the longest monotonically increasing s of A (elements). Worst case complexity: O(1).\n\nI know that it is a well known problem, and I'm aware of the relevant wiki article. However the solution provided there is not intuitive to me.\n\nI was given a hint that this problem can be solved as well with 2-3 rank tree for instance.\n\nCan someone explain me the solution using 2-3 tree?\n\nExample:\nFor array A = {10,9,11,8,12,7,13}\nThe longest subarray is {10, 11, 12, 13} and its length is 4.\n    ", "Answer": "\r\nThis is a well-studied problem called longest increasing subsequence, which could be solved in O(n log n) time. See http://en.wikipedia.org/wiki/Longest_increasing_subsequence\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Number of Longest increasing subsequence [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Longest increasing subsequence\r\n                            \r\n                                (13 answers)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI need to return the number of ```\nLIS```\n of the array.\n\nPseudocode example:\n\n```\nif the arr is\n int []arr = {2,4,90,-3,-2,-1,-10,-9,-8};\nnum of LIS is: 3\n 2,4,90\n -3,-2,-1\n -10,-9,-8\n```\n\n\nexample 2:\n\n```\narr [] = {2,-3,4,90,-2,-1,-10,-9,-8};\nnum of LIS is: 4\n2,4,90\n-3,4,90\n-3,-2,-1\n-10,-9,-8\n```\n\n\nI have tried to do this:\n\n```\nint [] A = {2,4,90,-3,-2,-1,-10,-9,-8};\n    int[] dp = new int[A.length];\n\n    for (int i = 0; i < A.length; i++) {\n        dp[i] = 1;\n\n        for (int j = 0; j <= i - 1; j++) {\n            if (A[j] < A[i]) {\n                dp[i] = dp[i] + dp[j];\n            }\n        }\n        System.out.println(dp[dp.length - 1] ) ;\n    }\n```\n\n    ", "Answer": "\r\nIn your code you just keep on adding to the dp[i] for all lookups in the inner for loop. Ideally you should find the maximum size of the subsequence for all positions (j < i) and then add that maximum Value to d[i]. \nCorrect way is as follows : \n\n```\nint maxSizeOfSubseq = 0;\nfor (int i = 0; i < A.length; i++) {\n    dp[i] = 1;\n    maxSizeOfSubseq = 0;\n    for (int j = 0; j <= i - 1; j++) {\n        if (A[j] < A[i] && dp[j] > maxSizeOfSubseq ) {\n            maxSizeOfSubseq = dp[j];\n        }\n    }\n    dp[i] = dp[i] + maxSizeOfSubseq ;\n             System.out.println(dp[dp.length - 1] ) ;\n}\n\n\n// Now find the Max Size Of Subsequence amongst all computes subsequence lengths\nmaxSizeOfSubseq  = 0;\nfor(int count = 0 ; count < dp.length; ++count)\n{\n  if(dp[i] > maxSizeOfSubseq )\n  {\n  maxSizeOfSubseq  = dp[i]\n  }\n}\n\nreturn maxSizeOfSubseq ;\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Number of all increasing subsequences in given sequence?\r\n                \r\nYou may have heard about the well-known problem of finding the longest increasing subsequence. The optimal algorithm has ```\nO(n*log(n))```\ncomplexity.\n\nI was thinking about problem of finding all increasing subsequences in given sequence. I have found solution for a problem where we need to find a number of increasing subsequences of length k, which has ```\nO(n*k*log(n))```\n complexity (where n is a length of a sequence). \n\nOf course, this algorithm can be used for my problem, but then solution has ```\nO(n*k*log(n)*n) = O(n^2*k*log(n))```\n complexity, I suppose. I think, that there must be a better (I mean - faster) solution, but I don't know such yet.\n\nIf you know how to solve the problem of finding all increasing subsequences in given sequence in optimal time/complexity (in this case, optimal = better than ```\nO(n^2*k*log(n)))```\n, please let me know about that.\n\nIn the end: this problem is not a homework. There was mentioned on my lecture a problem of the longest increasing subsequence and I have started thinking about general idea of all  increasing subsequences in given sequence.\n    ", "Answer": "\r\nI don't know if this is optimal - probably not, but here's a DP solution in ```\nO(n^2)```\n.\n\nLet ```\ndp[i] = number of increasing subsequences with i as the last element```\n\n\n```\nfor i = 1 to n do\n    dp[i] = 1\n    for j = 1 to i - 1 do\n        if input[j] < input[i] then\n            dp[i] = dp[i] + dp[j] // we can just append input[i] to every subsequence ending with j\n```\n\n\nThen it's just a matter of summing all the entries in ```\ndp```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Constructing Longest Increasing Subsequence from stage 1 of the patience sort\r\n                \r\nI am trying to construct the longest subsequence from stage 1 of the patience sort.  This runs in O(n log n). However, when trying to construct the longest subsequence from the individual piles, I cannot seem to come up with anything faster than O(n^2).  The algorithm I am using (in C++) is the following. If further explanation is needed I can do further explanation, I can do so.\n\n```\n vector<int> composeLIS(const vector<vector<int>>& piles)\n {\n      vector<int> LIS;\n      int prev;\n      for (auto i = v.end()-1; i >= v.begin(); i--)\n      {\n          if (i == v.end() - 1)\n          {\n              auto j = i[i->size()-1][0];\n              LIS.push_back(j);\n              prev = j;\n          }\n          else\n          {\n              for (auto j = i->begin(); j < i->end(); j++)\n              {\n                  if (prev > *j)\n                  {\n                      LIS.insert(LIS.begin(),*j);\n                      prev = *j;\n                      break;\n                  }\n              }\n          }\n      }\n      return LIS;\n }\n```\n\n\nIs there any way to compose the subsequence in a complexity better than O(n^2)?\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Dynamic Programming Longest Increasing Subsequence\r\n                \r\nI need help understanding this. How are the elements in the parent list given - like which list of the previous element in the sequence is it referring to? I've tried testing for each list and I'm still getting a different parent list. Sorry in advance if this is a silly question.\n    ", "Answer": "\r\nLook at this Java code to understand the solution\n\n\r\n\r\n```\n/* A Naive Java Program for LIS Implementation */\r\nclass LIS \r\n{ \r\n   static int max_ref; // stores the LIS \r\n  \r\n   /* To make use of recursive calls, this function must return \r\n   two things: \r\n   1) Length of LIS ending with element arr[n-1]. We use \r\n      max_ending_here for this purpose \r\n   2) Overall maximum as the LIS may end with an element \r\n      before arr[n-1] max_ref is used this purpose. \r\n   The value of LIS of full array of size n is stored in \r\n   *max_ref which is our final result */\r\n   static int _lis(int arr[], int n) \r\n   { \r\n       // base case \r\n       if (n == 1) \r\n           return 1; \r\n  \r\n       // 'max_ending_here' is length of LIS ending with arr[n-1] \r\n       int res, max_ending_here = 1; \r\n  \r\n        /* Recursively get all LIS ending with arr[0], arr[1] ... \r\n           arr[n-2]. If   arr[i-1] is smaller than arr[n-1], and \r\n           max ending with arr[n-1] needs to be updated, then \r\n           update it */\r\n        for (int i = 1; i < n; i++) \r\n        { \r\n            res = _lis(arr, i); \r\n            if (arr[i-1] < arr[n-1] && res + 1 > max_ending_here) \r\n                max_ending_here = res + 1; \r\n        } \r\n  \r\n        // Compare max_ending_here with the overall max. And \r\n        // update the overall max if needed \r\n        if (max_ref < max_ending_here) \r\n           max_ref = max_ending_here; \r\n  \r\n        // Return length of LIS ending with arr[n-1] \r\n        return max_ending_here; \r\n   } \r\n  \r\n    // The wrapper function for _lis() \r\n    static int lis(int arr[], int n) \r\n    { \r\n        // The max variable holds the result \r\n         max_ref = 1; \r\n  \r\n        // The function _lis() stores its result in max \r\n        _lis( arr, n); \r\n  \r\n        // returns max \r\n        return max_ref; \r\n    } \r\n  \r\n    // driver program to test above functions \r\n    public static void main(String args[]) \r\n    { \r\n        int arr[] = { 10, 22, 9, 33, 21, 50, 41, 60 }; \r\n        int n = arr.length; \r\n        System.out.println(\"Length of lis is \"\r\n                           + lis(arr, n) + \"n\"); \r\n    } \r\n } ```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to print out longest increasing subsequence by recursion\r\n                \r\nGiven a sequence of n integer stored in an array, describe a recursive algorithm to print out a subsequence of non-decreasing elements with maximum length. A subsequence may contain non-consecutive elements but they should be ordered in the same way as the original sequence. \n\nPlease help me :(\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Largest Increasing SubSequence with O(n^2) using Recursions\r\n                \r\nLIS :The longest increasing subsequence problem is to find a subsequence of a given sequence in which the subsequence's elements are in sorted order, lowest to highest\n\nEg: \n\n\n  0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 \n  \n  A longest increasing subsequence is 0, 2, 6, 9, 13, 15.\n\n\nI can develop LIS using different ways like Dynamic programming and memorization techniques but, with a particular case where I like to implement LIS using recursion with time complexity of ```\nO(N^2)```\n.\n\nAs of I think using recursion we cannot implement algorithms with time complexity ```\nO(N^2)```\n.(Please correct me)\n\nHowever i got this algorithm from google\n\n```\nAlgorithm  LIS(A,n,x)\n1: if n = 0 then\n2:   return 0\n3: m   LIS(A; n -1; x)\n4: if A[n] < x then\n5:   m =max(m; 1 + LIS(A; n-1;A[n]))\n6: print(m)\n```\n\n\nIs this algorithm ```\nO(N^2)```\n?\n\nCan you please explain?  \n    ", "Answer": "\r\nThis Algorithm Prints Maximum in a array First Argument (A) is the array, Second Argument (n) is the index of item that now checks for max and third Argument (x) is maximum in that time.\nin worst case you have a sorted array and in every check (if A[n] < x then) you have to update third Argument with max that means at most you have to check all of array.\n\nthe algorithm take a max from index n to n-1 and check that with max from n to n-2 and check that with max in n to n-3 index and it continues to check with n to 1 to get max item.\n\nthat means it is O(n+(n-1)+(n-2)+...+2+1) = O(n^2)\n\n\n\nSorry about Pic Quality :)\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Finding the longest contiguous subsequence in an array\r\n                \r\nMy assignment is to write a program that finds the longest increasing contiguous subsequence in a given array and prints both the length of that subsequence, and the subsequence it self.\nSay the array is: \n\n```\nint[] arr = {3, 6, 5, 1, 9, 3, 2, 3, 4, 5, 1}\n```\n\n\nThe longest continuous increasing subsequence is 2, 3, 4, 5 with a length of 4. \nSo the output of this method would be\n\n```\n4\n2, 3, 4, 5\n```\n\n\nThis is my code so far:\n\n```\npublic class LongestSubsequence {\n  public static void main(String[] args) {\n\n    // Test arrays\n    int[] arrC = {9, 5, 2, 3, 4, 5};\n    int[] arrA = {1, 2, 3, 4, 5, 7};\n    int[] arrB = {7, 6, 5, 4, 1, 2};\n    int[] arr = {3, 6, 5, 1, 9, 3, 2, 3, 4, 5, 1};\n\n    longestForward(arr);\n\n  }\n\n  // input of the int array, returns nothing.\n  public static void longestForward(int[] arr) {\n    // variables for Length of longest subsequence found and for the length of the current sequence\n    int subSeqLength = 1;\n    int longest = 1;\n    boolean longestSub = false;\n    int indexStart = 0;\n    int indexEnd = 0;\n\n    for (int i = 0; i < arr.length-1; i++) {\n      //Increases subsequence length variable \n      if (arr[i] < arr[i+1]) {\n        subSeqLength++;\n      }\n      // Sets the current subsequence to the longest variable if it is the longest one found at the time.\n      else if (subSeqLength > longest) {\n        longest = subSeqLength;\n        longestSub = true;\n      }\n      // if the current sequence being analyzed is the longest one, keeps track of where it starts and ends\n      else if (longestSub = true) {\n        arr[i] = indexStart;\n        arr[i+1] = indexEnd;\n      }\n      // sets the subsequence length back to one if it is no longer increasing         \n      else subSeqLength = 1;\n    }\n\n    System.out.println(subSeqLength);\n    System.out.println(indexStart);\n    System.out.print(indexEnd);\n  }\n}\n```\n\n\nSo I've figured out how to get the program to identify the length of the longest subsequence. However, I'm stuck on how I can actually get it to print. Right now, I'm just trying to get the method to correctly print the place in the array where the longest subsequence starts and ends. This is not what needs to be in the program, but I thought I would need to figure this out before going on to printing it.\n\nI reasoned that to print the subsequence, I would need to keep track of when the longest sequence started and ended, and from there get the program to print on those elemennts. But my code doesn't seem to be running correctly. There are no errors given, it just runs but doesn't return anything. \n\nAny help is greatly appreciated. Thanks!\n    ", "Answer": "\r\nHere I fixed your algorithm with comments :\n\n```\npublic static void longestForward(int[] arr)\n{\n    int subSeqLength = 1;\n    int longest = 1;\n    int indexStart = 0;\n    int indexEnd = 0;\n\n    for (int i = 0; i < arr.length - 1; i++)\n    {\n        if (arr[i] == arr[i + 1] - 1)//We need to check if the current is equal to the next\n        {\n            subSeqLength++;//if it is we increment\n            if (subSeqLength > longest)//we assign the longest and new bounds\n            {\n                longest = subSeqLength;\n                indexStart = i + 2 - subSeqLength;//make sure the index start is correct\n                indexEnd = i + 2;\n            }\n\n        } \n        else\n            subSeqLength = 1;//else re-initiate the straight length\n    }\n\n\n    for (int i = indexStart; i < indexEnd; i++)//print the sequence\n        System.out.println(arr[i] + \", \");        \n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Maximum Weight Increasing Subsequence\r\n                \r\nIn the Longest Increasing Subsequence Problem if we change the length by weight i.e the length of each element Ai is 1 if we change it to Wi \nHow can we do it in O(NlogN).\n\nFor Example\nFor an array of 8 Elements\n\n```\nElements 1  2  3  4  1  2  3  4\nWeights  10 20 30 40 15 15 15 50 \n```\n\n\nThe maximum weight is 110.\n\nI found the LIS solution on wikipedia but I can't modify it to solve this problem.\n    ", "Answer": "\r\nStill, we use ```\nf[i]```\n denotes the max value we can get with a sequence end with ```\nE[i]```\n.  \n\nSo generally we have ```\nfor (int i = 1;i <= n;i++) f[i] = dp(i);```\n and initially ```\nf[0] = 0;```\n and ```\nE[0] = -INF;```\n  \n\nNow we shall calculate ```\nf[i]```\n in ```\ndp(i)```\n within ```\nO(log(N))```\n.  \n\nin ```\ndp(i)```\n, we shall find the max ```\nf[j]```\n with ```\nE[j] < E[i]```\n for all ```\n0 <= j < i```\n. Here we can maintain a ```\nSegment Tree```\n.  \n\nSo ```\ndp(i) = find_max(1,E[i]-1) + W[i]```\n(this takes ```\nO(log)```\n), and for every f[i] already calculated, ```\nupdate(E[i],f[i])```\n.  \n\nSo the whole algorithm takes ```\n(O(NlogN))```\n.\n\nTip: If ```\nE[i]```\n varies in a very big range, it can be ```\nDiscretization```\ned.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest convex subsequence in an array\r\n                \r\nSuppose we are given an input array of integers, how to find the longest convex subsequence that satisfies the following condition:\n\n```\nc[i] < (c[i-1] + c[i+1]) / 2\n```\n\n\n```\nc[i-1]```\n, ```\nc[i]```\n and ```\nc[i+1]```\n are three consecutive elements in the subsequence.\n\nFor example, if input array is ```\n{ 1, 2, -1, 0, 3, 8, 5 }```\n, the longest convex subsequence should be: ```\n{ 1, -1, 0, 3, 8 }```\n or ```\n{ 2, -1, 0, 3, 8 }```\n.\n\nI tried to solve this problem using the same dynamic programming idea in \"Longest Increasing Subsequence\" (LIS) problem. But because each element in the subsequence depends on the previous two elements, it seems that an O(n^2) solution is impossible. Thank you for your help.   \n    ", "Answer": "\r\nHere is O(N2 log N) algorithm (and since ```\nlog N```\n is here only because of sorting we could reduce this to O(N2 log log N) or even to O(N2) with different sorting algorithms or more advanced priority queues):\n\n\nCreate an array for each pair of input array elements: ```\nP[]```\n. Elements inside each pair are ordered by their index.\nSort these pairs according to value difference ```\nY2 - Y1```\n. In case of equal ```\nY2 - Y1```\n values they should be sorted by second index in decreasing order.\nZero-initialize array ```\nL[]```\n of subsequence lengths for subsequences ending at indexes 0 .. N-1.\nFor each pair from ```\nP[]```\n (in sorted order): ```\nL[X2] = max(L[X2], L[X1] + 1)```\n. Where ```\nX```\n is index of element in the input array.\nFind largest value in ```\nL[]```\n. This is length of the longest convex subsequence.\nTo be able to reconstruct subsequence itself, step #4 should also update chain of back-pointers. When ```\nL[X2]```\n is updated we'll create a node pointing to the node pointed by entry corresponding to ```\nX1```\n, then point entry corresponding to ```\nX2```\n to this new node: ```\nBP_Head[X2] = new Node(BP_Head[X1])```\n.\n\n\nConvex property ```\nc[i] < (c[i-1] + c[i+1]) / 2```\n may be transformed to equivalent inequality ```\nc[i] - c[i-1] < c[i+1] - c[i]```\n. Which means that while processing pairs in sorted order we do not need to check convex property anymore. So the only task of step #4 is to grow the substrings.\n\nThis simplified variant of the algorithm needs O(N2) space. Space complexity may be reduced if instead of a large array ```\nP[]```\n we use a pre-sorted copy of input array ```\nS[]```\n together with priority queue. Step #4 receives elements from top of this priority queue. To keep size of this priority queue equal to N we may push element ```\nS[i+1] - S[j]```\n to the queue only after ```\nS[i] - S[j]```\n is removed (so the queue keeps only one element for each ```\nj```\n). Huge space consumed by forest of back-pointers is not needed if we use a known DP trick to store only one back-pointer (for each index) pointing to \"middle\" of the original back-pointer chain (and then repeating this algorithm recursively for two sub-arrays preceding and following this \"middle\" back-pointer).\n\n\n\nAnd O(N3) algorithm:\n\n\nConstruct graph where each vertex corresponds to (ordered by index) pair of array elements.\nConnect vertexes with an edge if they have one common array element which is located between remaining two elements associated with these vertexes and all three elements satisfy convex property. This edge should be directed to the vertex with larger indexes.\nAdd source and destination nodes and connect them to every vertex.\nFind longest path in this graph.\n\n\nThis graph has O(N2) vertexes and O(N3) edges. It may be constructed in O(N3) time; and since it is a DAG, finding longest path also takes O(N3) time.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest subarray that has elements in increasing order?\r\n                \r\nGiven an array = {1 2 3 3 2 4 6 7}\n\nThe longest increasing subarray is 2 4 6 7.  Note that this isn't the same as the longest increasing subsequence, since the values have to be contiguous.\n\nIs there any O(n) solution for this problem?\n    ", "Answer": "\r\nYou can just use dynamic programming.\n\nPseudo code:\n\n```\ndef DP(a[]):\n    dp[1] = 1\n    for i = 2 to n:\n        if a[i] > a[i - 1]:\n            dp[i] = dp[i - 1] + 1\n        else:\n            dp[i] = 1\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "DrRacket - find the longest increasing subsequence\r\n                \r\nI want to create code for finding LIS. My code doesn't work very well. For example if the input is '(1 3 5 10 9 6 7), output should be '(1 3 5 6 7) but my program return '(1 3 5 10). What am I doing wrong? Have I code binary tree and then find the higher height? Or can I code this program in easiest way?\n```\n(define (return_sequence N lst)\n  (cond\n    [(empty? lst) '()]\n    [(< N (first lst)) (cons                           \n                           (first lst)\n                           (return_sequence (first lst) (rest lst))\n                           )]\n    [else (return_sequence N (rest lst))]\n  )\n)\n\n(define (find_longest lst1 lst2)\n  (cond\n    [(empty? lst1) lst2]\n    [(empty? lst2) lst1]\n    [(< (length lst1) (length lst2)) lst2]\n    [else lst1]\n  )\n)\n\n(define (LIS lst) \n  (cond\n    [(empty? lst) '()]\n    [else (find_longest\n           (cons\n            (first lst)\n            (return_sequence (first lst) (rest lst)))\n           (LIS (rest lst))\n          )]\n  )\n)\n```\n\n    ", "Answer": "\r\nBefore we begin, a question. Do you consider ```\n'(1 1)```\n to be an increasing sequence? For now, I will assume you do not.\nFirst, note that we can simplify ```\nfind-longest```\n as follows:\n```\n(define (find-longest lst1 lst2)\n  (if (<= (length lst1)\n          (length lst2))\n      lst1\n      lst2))\n```\n\nThis is terribly inefficient, but we won't worry about that for now. It at least looks cleaner than your code.\nI assume that you're trying to define ```\n(return_sequence N lst)```\n to be the longest increasing subsequence of ```\nlst```\n such that all elements of said subsequence are greater than ```\nN```\n. I suggest you take a look at exactly what happens when you try ```\n(return_sequence 1 '(4 2 3))```\n. We should expect the result to be ```\n'(2 3)```\n, but it is in fact ```\n'(4)```\n.\nYou need to think carefully about exactly how you want to handle the case where ```\n(< N (first lst))```\n and make sure you're not making a silly mistake (spoiler - you are making a silly mistake).\nEdit: suppose that ```\n(< N (first lst))```\n. The longest increasing subsequence of ```\nlst```\n where all elements are greater than ```\nN```\n either contains ```\n(first lst)```\n or doesn't. To find the longest subsequence that doesn't, we compute ```\n(return_sequence N (rest lst))```\n. To find the longest subsequence that does, we compute ```\n(cons (first lst) (return_sequence (first lst) (rest lst))```\n. The relevant ```\ncond```\n clause becomes\n```\n[(< N (first lst)) (find_longest \n                      (cons (first lst) \n                            (return_sequence (first lst) (rest lst)))\n                      (return_sequence N (rest lst)))]\n```\n\nand this solves your problem.\nOn another note, it's extremely helpful to add in the value of ```\nminus-infinity```\n, with the condition that this value is always less than any other value. In that case, we can just do\n```\n(define (LIS lst)\n   (return_sequence minus-infinity lst))\n```\n\nDoing this requires a little bit of cleverness, but it is possible.\nIn fact, one clever way to add ```\nminus_infinity```\n is to pass into ```\nreturn_sequence```\n not a number ```\nN```\n, but the function ```\n(lambda (x) (< N x))```\n. Then, instead of the line ```\n(< N (first list))```\n, you would instead write ```\n(less_than_N (first list))```\n. Then, you can ```\n(define (minus_infinity x) #t)```\n.\nIt's also possible to create a new symbol using ```\ngensym```\n and have that be ```\nminus_infinity```\n. You'd then want to do something rather cheeky like\n```\n(define minus_infinity (gensym))\n\n(define (return_sequence N lst)\n (let ((< (lambda (a b) (or (equal? a minus_infinity) (< a b)))))\n   cond ...)\n\n(define (LIS lst)\n  (return_sequence minus_infinity lst))\n```\n\nwith the cheeky bit being that we're not defining ```\n(<)```\n recursively - the ```\n<```\n that occurs in ```\n(lambda (a b) (or (equal? a minus_infinity) (< a b)))```\n is the original ```\n<```\n.\nFinally, the algorithm you're trying is really slow. It's possible to solve this problem in ```\nO(n log n)```\n where ```\nn = (length lst)```\n. Your solution will be an exponential time one, but improving it is highly nontrivial.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence with maximum sum plus constraint - allowed number of elements can be skipped\r\n                \r\nThe longest increasing sub-sequence with maximum sum (http://www.geeksforgeeks.org/dynamic-programming-set-14-maximum-sum-increasing-subsequence/) is a classic algorithm problem and there exist a lot of solutions on the web. However, I just encountered a variation of this problem and have no idea how to solve it.\n\nCompared with the original question, now you are also given a number m which indicates the number of elements you can skip at most from a continuous sub-range in order to find the LIS with maximum sum. For example, with the following array,\n\n[1, 200, 300, 3, 4, 5, 6]\n\nThe LIS is 1,3,4,5,6 and the maximum sum is 19. However, if m is 1, it means that at most one element can be skipped in a continuous sub-range in order to find the LIS. Hence the above solution is not right because between 1 and 3, two elements are skipped (200, 300 in this case).  The new solution should be 3,4,5,6 since no elements are skipped in a continuous sub-range. The question is to find the LIS with the maximum sum and return the sub-sequence (not the sum or the length of the sub-sequence) when the array and the number m is given. I have been stuck with this problem for several days so any help is appreciated. \n\nEdit: O(n^2) solution is good enough for now since I have complete no idea where to start.\n\nEdit: m is the cumulative steps can be skipped for the entire array, not the steps can be skipped between two separate increasing sub-sequence.\n    ", "Answer": "\r\nThis problem can be solved by using Dynamic programming technique.\n\nCall the input array ```\ndata```\n length ```\nn```\n.\n\nAssume we have an array ```\ndp[n][n + 1]```\n which entry ```\ndp[i][j]```\n store the nearest index, which from ```\ni```\n to ```\ndp[i][j]```\n, the length of increasing sub-sequence start at ```\ni```\n is ```\nj```\n. If we have this ```\ndp```\n, the result for your question is straight forwards.\n\nNow, how to calculate ```\ndp[i][j]```\n for a specific ```\nj```\n? moving ```\ni```\n backward from index ```\nn - 1```\n to ```\n0```\n, assume that, we maintain another array ```\nlist[n + 1]```\n, with ```\nlist[i]```\n storing all index ```\nk```\n, which has a increasing sub-sequence start at ```\nk```\n and length ```\ni```\n. We need to maintain the property of ```\nlist[j]```\n: ```\nlist[j]```\n is decreasing list, with element at index ```\nx```\n and ```\ny```\n in ```\nlist[j]```\n, then ```\ndata[x] > data[y]```\n if and only if ```\nx < y```\n. If we have ```\nlist[j]```\n for each length ```\nj```\n, for ```\ndp[i][j + 1]```\n, we only need to binary search inside ```\nlist[j]```\n to find the smallest element in list[j] which is greater than data[i].  \n\n```\nint[][]dp = new int[n][n + 1];\nfill(dp, -1);\nList<Integer>[]lists = new List[n + 1];\nfor(int i = n - 1; i >= 0; i--){\n    for(int j = 1; j <= n; j++){\n        if(j == 1){\n            dp[i][j] = i;\n\n        }else if(!list[j - 1].isEmpty()){\n            int index = binary search in list[j - 1] to get the nearest index that greater than data[i];\n            dp[i][j] = dp[index][j - 1];\n\n        }\n        if(dp[i][j] == -1)\n           continue;\n        while(data[list[j].peekLast()] <= data[i]){\n        //Remove all entries which is smaller than i in list, we can easily see that all entries which is smaller than i can only end at point at least as near as end point of i.\n           list[j].pollLast();\n        }\n        if(list[j].isEmpty() || dp[list[j].peekLast()][j] > dp[i][j]){\n        //Only add entry to list if result of new entry is nearer. \n           list[j].add(i);\n        }\n    }\n}\n```\n\n\nTime complexity O(n^2 logn).\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Can I get an explanation for how optimal substructure is used to find the longest increasing subsequence in this powerpoint slide?\r\n                \r\nI'm learning about finding optimal solutions in my algorithms class at the moment and one of the topics is about finding optimal substructures in problems.\n\nMy understanding of it so far is that we see if we can find an optimal solution for a problem of size n. If we can, then we increase the size of the problem by 1 so it's n+1. If the optimal solution for n+1 includes the entire optimal solution of n plus the new solution introduced by the +1, then we have optimal substructure.\n\nI was given an example of using optimal substructure to find the longest increasing subsequence given a set of numbers. This is shown on the powerpoint slide here:\n\n\n\nCan someone explain to me the notation on the bottom of the slide and give me a proof that this problem can be solved using optimal substructure?\n    ", "Answer": "\r\n\nLower(i) means a set of positions ```\nj```\n in ```\nS```\n to the left of the current index ```\ni```\n such that Sj is less than Si. In other words, elements Sj and Si are in increasing order, even though there may be other elements in between them.\nThe expression with the brace on the left explains how we construct the answer:\n\n\nFirst line says that if the set Lower(i) is empty (i.e. Si is the largest number in the sequence so far) then the answer is 1. This is the base case: a single number is treated as one-element sequence\nSecond line says that if Lower(i) is not empty, then we pick the max element from it, and add 1. In other words, we look to the left of the number Si for another number Sj that is smaller than Si, and ends the longest ascending subsequence among Lower(i).\n\n\n\nAll of this is incredibly long way of writing these six lines of pseudocode:\n\n```\nL[0] = 1\nfor i = 1..N\n    L[i] = 1\n    for j = i..0\n        if S[i] > S[j] // Member of Lower(i) ?\n            L[i] = MAX(L[i], L[j]+1)\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Increasing Subsequence Recursive Java\r\n                \r\nI have the following problem: A sequence of numbers is said to be monotonically increasing (or simply increasing) if every\nnumber in the sequence is greater than, or equals to, the number preceding it. write a boolean function ```\nincreasing(int[] x, int length)```\n that returns true if the given array contains an increasing subsequence of the given length, and false otherwise. The guidelines:\n\n\nNo loops at all, only recursion\nNo lists &  imports (so no map or so) & ```\n?```\n\nNo changing the signature of the function ```\nincreasing(int[] x, int length)```\n\nYou may add private functions but not ints/booleans ect.\n\n\nI thought about using an old problem, longest increasing subsequence, and then comparing the sizes, if the size given is larger then LIS, it would return false. However my code for LIS seems to be missing cases that skip a number and repeat a number, for example ```\n9,7,5,4,7,1,-3,8```\n return false for 3 instead of true, also for ```\n3,1,1,2```\n returns false.\n\n```\npublic static boolean increasing(int[] x, int length) {\n    int i = 0;\n    int ans = longestIncreasing(x, length, i);\n    return (ans >= length);\n}\n\nprivate static int longestIncreasing(int[] arr, int n, int i) {\n    if (n == 0) {\n        return 1;\n    }\n\n    int m = 1, temp;\n    if (arr[i++] < arr[n--]) {\n        temp = 1 + longestIncreasing(arr, n, i);\n        if (temp > m) {\n            m = temp;    //   m = max(m, 1 + _lis(arr, i));\n        }\n    }\n    else {\n        longestIncreasing(arr, n--, i++);\n    }\n    return m;\n}\n```\n\n    ", "Answer": "\r\nFinding the longest increasing sequence seems like it may be the harder problem to solve in this case. The problem of finding consecutive sequences of a certain length simply requires adding one to an index variable at each level down the recursive call stack, and comparing to your target length. So, in the simple case, your problem can be solved like this:\n\n```\npublic static boolean increasing(int[] x, int length) {\n    return increasing(x, length, 0);\n}\n\nprivate static boolean increasing(int[] x, int length, int depth) {\n    if (x.length < length) return false;\n    if (depth >= length) return true;\n    if (depth > 0 && x[depth - 1] > x[depth]) return false;\n\n    return increasing(x, length, depth + 1);\n}\n```\n\n\nIt becomes more complex when you have to account for sequences of non-consecutive items. In that case, rather than immediately returning ```\nfalse```\n when you encounter an element that's less than its predecessor, you simply move down the call stack without incrementing the depth, and keep track of how many elements to skip when comparing the last two terms of the sequence. (Note, this requires an extra check to prevent the recursion from exceeding the array size):\n\n```\npublic static boolean increasing(int[] x, int length) {\n    return increasing(x, length, 0, 0);\n}\n\nprivate static boolean increasing(int[] x, int length, int depth, int skip) {\n    if (x.length < length) return false;\n    if (depth >= length) return true;\n    if (depth + skip >= x.length) return false;\n\n    if (depth > 0 && x[depth - 1] > x[depth + skip]) {\n        return increasing(x, length, depth, skip + 1);\n    }\n\n    return increasing(x, length, depth + 1, 0);\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence (LIS) with two numbers\r\n                \r\nHow to find the length of LIS using two numbers.\nFor example, \n    [(1,2) (7,8) (3,4) (5,6)]\nIn the above array sequence, the length of LIS would be 3. i.e,\n    [(1,2) (3,4) (5,6)]\nAny idea?\n    ", "Answer": "\r\nI'm not sure what you are asking but I will assume what you mean is that a pair (a,b) is less than another pair (c,d) if and only if a < c and b < d.\n\nThis can be easily solved in O(N^2) time by adapting the standard dynamic programming technique, which is described in another SO thread.\n\nThe classic O(N log N) solution to the standard LIS problem can be extended to give a subquadratic solution to the LIS problem with pairs, with some difficulty. We cannot simply remember one minimum value for every possible length; we have to maintain \"staircase-like\" structures containing all minimal pairs for each length, that is, up to N copies of the data structure described here, implemented using an ordered dynamic set of pairs keyed on the first member. We can then query one copy of this structure in O(log N) time (to check whether it contains any pair less than the current pair), giving O(log^2 N) time for the binary search step, and O(N log^2 N) time in all. This is the fastest solution I know to the problem.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "The length of second-longest increasing subsequence\r\n                \r\nYou must solve it with O(n^2). (This is could be equal with the length of LIS, such as \"13245\")\n    ", "Answer": "\r\nThis problem can be reduces to:\n\nCheck if there exist two or more different LIS's (with the same maximum length of course).\nIf the answer is yes - the \"second\"-LIS is obviously the same length as the LIS.\nIf the answer is no - the second-LIS length is the length of the longest one minus 1.\n\nIn order to find the number of LIS's you can simply modify the ```\nO(n^2)```\n algorithm described here to keep track of not only the maximum length but also the number of those maximums.  \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence (Javascript) Facebook Algo\r\n                \r\nI was trying to solve this problem with backtracking instead of DP...and ran into a problem that doesn't make sense to me.  here is my code \n\n```\nfunction solve(A) {\n  let lp = 0;\n  const path = [];\n\n  const traverse = function (arr, i = 0) {\n    if (i >= arr.length) return;\n    for (j = i; j < arr.length; j++) {\n      if (path.length === 0 || arr[j] > path[path.length - 1]) {\n        path.push(arr[j]); \n\n// here is the problem I don't understand, I am calling the recursive function with( j + 1) \n// but somehow that reads it as j = j + 1; why is this happening? \n// I would understand if it was an Array where the j would pointing to memory but it shouldn't // happen to a regular number, right?  \n\n        traverse(arr, j + 1);\n\n// this causes the j variable in the for loop to increment by 1 so I can't get back track properly. \n\n        if (path.length > lp) lp = path.length;\n        path.pop();\n      } \n    }\n  }\n\n  traverse(A);\n  return lp;\n}\n\nconst A = [69, 54, 19, 51, 16, 54, 64, 89, 72, 40, 31, 43, 1, 11, 82, 65, 75, 67, 25, 98, 31, 77, 55, 88, 85, 76, 35, 101, 44, 74, 29, 94, 72, 39, 20, 24, 23, 66, 16, 95, 5, 17, 54, 89, 93, 10, 7, 88, 68, 10, 11, 22, 25, 50, 18, 59, 79, 87, 7, 49, 26, 96, 27, 19, 67, 35, 50, 10, 6, 48, 38, 28, 66, 94, 60, 27, 76, 4, 43, 66, 14, 8, 78, 72, 21, 56, 34, 90, 89]\nconst B = [1,3,4,2,5,3]\n\nconsole.log(solve(A))\nconsole.log(solve(B))\n\n```\n\n\nan explanation would be appreciated, thanks in advance!!!\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How can I get the longest increasing subsequence in a string?\r\n                \r\nI'm pretty rusty on my Java skills but I was trying to write a program that prompts the user to enter a string and displays a maximum length increasing ordered subsequence of characters. For example, if the user entered ```\nWelcome```\n the program would output ```\nWelo```\n. If the user entered ```\nWWWWelllcommmeee```\n, the program would still output ```\nWelo```\n. I've gotten this much done but it's not doing what it should be and I'm honestly at a loss as to why. \n\n```\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Stuff {\n\npublic static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n    System.out.println(\"Please enter a string. \");\n    String userString = input.next();\n    ArrayList charList = new ArrayList();\n    ArrayList finalList = new ArrayList();\n    int currentLength = 0;\n    int max = 0;\n\n    for(int i = 0; i < userString.length(); i++){\n        charList.add(userString.charAt(i));\n\n        for(int j = i; j < userString.length(); j++){\n            int k=j+1;\n            if(k < userString.length() && userString.charAt(k) > userString.charAt(j)){\n                charList.add(userString.charAt(j));\n                currentLength++;\n            }\n        }\n    }\n\n    if(max < currentLength){\n        max = currentLength;\n        finalList.addAll(charList);\n    }\n\n    for (int i = 0; i < finalList.size(); i++){\n        char item = (char) finalList.get(i);\n        System.out.print(item);\n    }\n\n    int size1 = charList.size();\n    int size2 = finalList.size();\n    System.out.println(\"\");\n    System.out.println(\"Size 1 is: \" + size1 + \" Size 2 is : \" + size2);    \n  }\n }\n```\n\n\nMy code, if I input ```\nWelcome```\n, outputs ```\nWWeceeclcccome```\n.\n\nDoes anyone have some tips on what I'm doing wrong?\n    ", "Answer": "\r\nIn these cases it tends to help to step away from the keyboard and think about the algorithm you're trying to implement. Try to explain it first in words.\n\nYou are constructing a list of individual characters by appending each of the characters in the input string followed by characters to its right that are in correct alphabetical with their successor. For the input \"Welcome\" this means the accumulated output will be, showing the outer loop in vertical and inner loop in horizontal:\n\n```\nW W e c\ne e c\nl c\nc c\no\nm\ne\n```\n\n\nIn total: WWeceeclccome\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing substring with gap\r\n                \r\nI've encountered a problem specified as follows:\n\nLet A be a sequence of positive integers.\nLet B be a substring of A.\nLet C be a sequence created by removing B from A.\nFor given A, find the length of the longest increasing (strictly) substring of C, where B can be chosen arbitrarily.\n\nFor example let A = [3 2 5 7 1 2 8 1]. If we set B = [1 2], then C = [3 2 5 7 8 1] and its longest increasing substring is [2 5 7 8], which length is 4. 4 is the answer since there exist no other B which would lead to a better solution.\n\nI can't find an algorithm to solve the problem (in polynomial time, of course :) ), but I belive it would be some variation of the longest increasing subsequence problem.\nPlease help me to find a good algorithm or give me some hints or references.\n    ", "Answer": "\r\nWhile doing a single iteration through the input array:\n\n\nSet up an array ```\nsmallest[n]```\n, where ```\nsmallest[i]```\n represents the smallest element which an increasing substring of length ```\ni```\n can end with (e.g. if ```\nsmallest[3] = 5```\n, that means there's a substring of length 3 ending with a ```\n5```\n, and there is no substring of length 3 ending with a ```\n4```\n, otherwise ```\nsmallest[3]```\n will be ```\n4```\n).\n\nWe can keep track of the longest substring ```\ni```\n so far, and simply replace ```\nsmallest[i]```\n if that element is bigger than the current element.\n\nAn important notes about this array: the elements in this array will be in strictly increasing order, that is to say, if a substring of length ```\ni```\n ending in element ```\nx```\n exists in the array, there is no longer substring containing an element equal to or less than ```\nx```\n (this is because the longer substring will contain an substring of length ```\ni```\n ending in an element less than ```\nx```\n, thus ```\nsmallest[i]```\n will be that element instead of ```\nx```\n).\nIn addition to this array, keep a binary search tree (BST) that maps elements to substring lengths (essentially the opposite of the array).\n\nWhen updating ```\nsmallest```\n, also remove the old element from the BST and insert the new one.\n\n(All of this so far were about substrings in the original array A, not the array post-removal C)\nUsing this, we can find the longest substring ```\nlongestSSAfterB```\n in C ending at any element (directly following some B) by looking up the biggest element smaller than that element in the BST and adding 1 to that length.\nThe longest substring in C ending at any given element will simply be the maximum of 1 + the longest substring ending in the previous element (if it's smaller, 0 otherwise) and ```\nlongestSSAfterB```\n.\n\nThe longest substring in C will simply be the longest substring we found above.\n\n\nAll of this will take ```\nO(n log n)```\n.\n\n\n\nExample:\n\n```\nA = [3 2 5 7 1 2 8 1]\n                   BST.floor(i)+1\n        currentSS  longestSSAfterB  longestSSinC  smallest BST\nA[0]=3  1          0+1=1            max(1,0+1)=1  [3]      [(3→1)]\nA[1]=2  1          0+1=1            max(1,0+1)=1  [2]      [(2→1)]\nA[2]=5  2          (2→1)->1+1=2     max(2,1+1)=2  [2,5]    [(2→1), (5→2)]\nA[3]=7  3          (5→2)->2+1=3     max(3,2+1)=2  [2,5,7]  [(2→1), (5→2), (7→3)]\nA[4]=1  1          0+1=1            max(1,0+1)=1  [1,5,7]  [(1→1), (5→2), (7→3)]\nA[5]=2  2          (1→1)->1+1=2     max(2,1+1)=2  [1,2,7]  [(1→1), (2→2), (7→3)]\nA[6]=8  3          (7→3)->3+1=4     max(4,2+1)=4  [1,2,7]  [(1→1), (2→2), (7→3)]\nA[7]=1  1          0+1=1            max(1,0+1)=1  [1,5,7]  [(1→1), (5→2), (7→3)]\n\nLongest substring = max(longestSSinC) = 4\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Largest sum of all increasing subsequences of length k\r\n                \r\nI am currently stuck with the classic longest increasing subsequence problem, but there is a slight twist to it. Instead of just finding the longest increasing subsequence, I need to find the largest sum of all increasing subsequences that are of length k.\nI have the following pseudo code implemented:\n```\ninput = [4,13,5,14] k = 2\nn = size of input\nopt = array of size n which stores the highest increasing subsequence sum up to this index\ncounts = array of size n which stores the amount of values in the subsequence up to this index\nhighestSum = -1\nFOR i in range(0, n)\n   high = new data object(value = 0, sum = 0, count = 0)\n   FOR j in range(i-1, 0, -1)\n     IF high.sum < opt[j] AND opt[j] < opt[i] AND counts[j] < k\n        high.value = input[j]\n        high.sum = opt[j]\n        high.count = counts[j]\n   opt[i] = high.sum + input[i]\n   counts[i] = high.count + 1\n   IF counts[i] == k\n     highestSum = higher value between (highestSum, opt[i])\nreturn highestSum\n\n```\n\nThis dynamic programming approach works in most cases, but for the list I outlined above it does not return the optimal subsequence sum. The optimal subsequence sum with length 2 should be 27 (13-14), but 18 is returned (4-14). This is due to the opt and counts array looking like this:\n```\nk = 2\ninput:   0 4 13 5 14\nopt:     0 4 17 9 18\ncounts:  0 1 2  2 2 \n```\n\nDue to 13 already having a subsequence of 4-13, and thus its count value (2) is no longer less than k, 14 is unable to accept 13 as a correct subsequence due to its count value.\nAre there any suggestions as to what I can change?\n    ", "Answer": "\r\nYou'll need ```\nk+1```\n sorted data structures, one for each possible length of subsequence currently found.\nEach structure contains, by the last entry in an optimal subsequence, the current sum.  That is, we only care about a subsequence that can lead to the best possible solution.  (Technical note.  Of those that can lead to the best solution, pick the one whose positions are lexicographically first.) Which will be sorted by increasing last entry, and decreasing sum.\nIn pseudocode it works like this.\n```\ninitialize optimal[0..k]\noptimal[0][min(sequence) - 1] = 0 # empty set.\n\nfor entry in sequence:\n    for i in k..1:\n        entry_prev = biggest < entry in optimal[i-1]\n        if entry_prev is not None:\n            this_sum = optimal[i-1][entry_prev] + entry\n            entry_smaller = biggest <= entry in optimal[i-1]\n            if entry_smaller is None or optimal[i][entry_smaller] < this_sum:\n                delete (e, v) from optimal[i] where entry <= e and ​v <= this_sum\n               ​ insert (entry, this_sum) into optimal[i]\nreturn optimal[k][largest entry in optimal[k]]\n```\n\nBut you need this kind of 2-d structure to keep track of what might happen from here.\nThe total memory needed is ```\nO(k n)```\n and running time will be ```\nO(k n log(n))```\n.\nIt is possible to also reconstruct the optimal subsequence, but that requires a more complex data structure.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "To find all longest increasing subsequences given an array of integers - Dynamic Programming\r\n                \r\nI'm studying dynamic programing & I came  across this question in which I have to print out all the longest subsequences. There could be more than one longest subsequence given an array. \nThe program that I tried would give me only one longest subsequence but not all the longest subsequence. How do I get all longest subsequences?\n\n```\n//Initially I create two arrays of the length of the given input array \n\npublic static void LIS(int[] input) {\n\n    String paths[] = new String[input.length];\n    int[] size = new int[input.length];\n\n    for(int i=0;i<input.length; i++) {\n       paths[i] = input[i];\n       size[i] = 1;\n    }\n\n    for(i=1; i<input.length ; i++) {\n\n        for(j=i; j< i ; j++) {\n            if(input[i] > input[j] && size[i] < size[j] + 1) {\n                size[i] =  size[j] +1;\n                paths[i] =  paths[j] + input[i] + \"\"\n\n                if (maxlength < size[i]) {\n                    maxlength = size[i];\n                }\n            }\n        }\n    }\n}\n```\n\n\nMy example input[] = 1,8,10,3,7,12,15\n\nwith the above algorithm I get the longest subsequence as 1,8,10,12,15 \n\nI should also get 1,3,7,12,15 \n\nHow can I modify the code to get this?\n    ", "Answer": "\r\nIf you want to modify this code you may store all possible predecessors for any element;\nfrom your code:\n\n```\nfor(i=1; i<input.length ; i++) {\n\n    for(j=i; j< i ; j++) {\n        //if(input[i] > input[j] && size[i] < size[j] + 1) {\n        if(input[i] > input[j] && size[i] <= size[j] + 1) {\n            size[i] =  size[j] +1;\n            //paths[i] =  paths[j] + input[i] + \"\"\n            if (size[i] < size[j] + 1 )\n               //empty p[i]\n            p[i].push(j);\n\n            if (maxlength < size[i]) {\n                maxlength = size[i];\n            }\n        }\n    }\n}\n```\n\n\nand then you will need to restore all possible subsequences\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence code in O(N)?\r\n                \r\nSomeone asked me a question \n\n```\nFind the longest alphabetically increasing or equal string \ncomposed of those letters. Note that you are allowed to drop \nunused characters.\n\nSo ghaaawxyzijbbbklccc returns aaabbbccc.\n\nIs an O(n) solution possible?\n```\n\n\nand I implemented it code [in python]\n\n```\ns = 'ghaaawxyzijbbbklccc'\nlst = [[] for i in range(26)]\n\nfor ch in s:\n    ml = 0\n    for i in range(0,ord(ch) + 1 - ord('a')):\n        if len(lst[i]) > len(lst[ml]):\n            ml= i\n    cpy = ''.join(lst[ml])\n    lst[ord(ch) - ord('a')] = cpy + ch\n\nml = 0\nfor i in range(26):\n    if len(lst[i]) > len(lst[ml]):\n        ml = i\nprint lst[ml]\n```\n\n\nand the answer is 'aaabbbccc'\n\nI have tried this some more examples and all works!\nand as far as I can think the complexity of this code is O(N) \nlet's take an example\nsuppose I have a string 'zzzz'\nso the main loop will run 4 times and internal loop will run 26 times for each iteration so we can say in worst case the code will run in\n\n```\nO(26*N + 26)\n---------^-\nthis is the last iteration\n```\n\n\nso O(N) is acceptable? \n\nNow questions are\n\n\nIs it works in O(N) my code at ideone\nIf it works in O(N) then why to use DP of O(N2) code of DP\nIs it better then this code Friends code\nLimitations of this code\n\n    ", "Answer": "\r\n\nIt's O(N)\n'why to use DP of O(N2)' : You don't need to for this problem.  Note, though, that you take advantage of the fact that your sequence tokens (letters) are finite - so you can set up a list to hold all the possible starting values (26) and you need only look for the longest member of that list - an O(1) operation.  A more generalised solution for sequences with an arbitrary number of ordered tokens can be done in O(NlogN).\nYour friend's code is basically the same, just mapping the letters to numbers and their list for the 26 starting places holds 26 numbers for letter counts - they don't need to do either of those.  Conceptually, though, it's the same thing - holding a list of lists.  \n\n\"Better\" is a matter of opinion.  Although it has the same asymptotic complexity, the constant terms may be different, so one may execute faster than the other.  Also, in terms of storage, one may use very slightly more memory than the other.  With such low ```\nn```\n - judging which is more readable may be more important than the absolute performance of either algorithm.  I'm not going to make a judgement.\n\nYou might notice a slight difference where the \"winning\" sequence is a tie.  For instance - on the test string ```\nedxeducation```\n that you have there - your implementation returns ```\nddin```\n whereas your friend's returns ```\nddio```\n.  Both seem valid to me - without a rule to break such ties.\nThe major limitation of this code is that it can only cope with sequences composed entirely of letters in one particular case.  You could extend it to cope with upper and lower case letters, either treating them the same, or using an ordering where all lower case letters were \"less than\" all upper case letters or something similar.  This is just extending the finite set of tokens that it can cope with.\n\nTo generalise this limitation - the code will only cope with finite sets of sequence tokens as noted in 2. above.  Also - there is no error handling, so if you put in a string with, say, digits or punctuation, it will fail.\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Subsequence using recursion and cache\r\n                \r\ni've been trying to implement a cache in my recursive LIS function so it doesn't calculate the same value twice. I would really aprecciate if someone can give me a hint of what im getting wrong.\nThis is the recursive function that returns the LIS array that works fine:\n```\nimport numpy as np\n\ndef lgs(l):\n    return lgsRecursive(np.NINF,l,0)\n    \ndef lgsRecursive(x,l,i):\n    print(x,i)\n    \n    if i >= len(l):\n        return[]\n        \n    else:\n        list1 = lgsRecursive(x,l,i+1)\n        if l[i] > x:\n            list2 = [l[i]] + lgsRecursive(l[i],l,i+1)\n            if len(list1) < len(list2):\n                list1 = list2\n                \n    return list1\n\nassert(lgs([1, 20, 3, 7, 40, 5, 2]) == [1,3,7,40])\n```\n\nThis is the same function but implementing a cache, it gives wrong answers with repetition(in the case of the previous assert it returns [1, 20, 40, 40, 40, 40, 40]):\n```\nimport numpy as np\ncache = {}\n\ndef lgs(l):\n    return lgsMemo(np.NINF,l,0)\n\ndef lgsMemo(x,l,i):\n    global cache\n    \n    key = (x,i)\n    \n    if key in cache:\n        return cache[(x,i)]\n    \n    if i >= len(l):\n        return []\n    \n    else:\n        list1 = lgsMemo(x,l,i+1)\n        if l[i] > x:\n            list2 = [l[i]] + lgsMemo(l[i],l,i+1)\n            if len(list1) < len(list2):\n                list1 = list2\n                cache[(l[i],i+1)] = list1\n            else:\n                cache[(x,i+1)] = list1                  \n    return list1\n```\n\nI think maybe the error is caching [l[i]] + lgsMemo(l[i],l,i+1) instead of lgsMemo(l[i],l,i+1).\n    ", "Answer": "\r\nWhy make it so hard on yourself? You can just have two functions. One you call if you need to actually calculate things and one where you check if you have it in memory and delegate to the other if necessary. Notice that I had to slightly edit your recursive function so it uses the cache if possible.\n```\nimport numpy as np\ncache = {}\n\ndef lgs(l):\n    return lgsMemo(np.NINF,l,0)\n    \ndef lgsRecursive(x,l,i):\n    print(x,i)\n    \n    if i >= len(l):\n        return[]\n        \n    else:\n        list1 = lgsMemo(x,l,i+1)\n        if l[i] > x:\n            list2 = [l[i]] + lgsMemo(l[i],l,i+1)\n            if len(list1) < len(list2):\n                list1 = list2\n                \n    return list1\n\n\ndef lgsMemo(x,l,i):\n    global cache\n    if (x,i) not in cache:\n        cache[(x,i)] = lgsRecursive(x,l,i)\n    return cache[(x,i)]\n\n\nassert(lgs([1, 20, 3, 7, 40, 5, 2]) == [1,3,7,40])\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "function to find the longest increasing subsequence without arrays\r\n                \r\nI need to make a program in C with those instructions:\nthe problem is its kinda easy to do with arrays but without them,I cant think anything else.\nwe need to write a function that takes int n and then takes the sequences of numbers, the function need to return us the sum of the biggest sequence.\nfor ```\nn = 8  and the sequence = 2,4,6,8,11,14,17,9' (there is 2 long sequences of 4, (when 8 starts the new sequence and closes the current sequence) ```\nhere we will get the print 50.`\nfor n = 2 and the sequence 7,19 the function will print 26.\nfor n = 8 and the sequence 8,6,4,2,11,14,15,16\nthe longest length is 4 so the function will print 20.\ncan't find any solution here without arrays\n```\n printf(\"please choose a n\");\n    scanf(\"%d\", &n);\n    y = n;\n    if (n == 1)\n  {\n        printf(\"Please enter the next number \");\n        scanf(\"%d\", &series);\n        return series;\n    }\n  else\n    if (n == 2)\n  {\n        while (i < 2) {\n    {\n        printf(\"Please enter the next number \");\n            scanf(\"%d\", &series);\n            sum += series;\n        }\n        return sum;\n    }\n   printf(\"Plase choose another number\");\nscanf(\"%d\", &last);\nsum += last;\nprintf(\"please choose another number\");\nscanf(\"%d\", &series);\nd = series - last;\nsum = series + last;\nbSum = sum;\nfor (i = 2; i < n; i++)\n    {\n    last = series;\n    printf(\"Please write another number; \");\n    scanf(\"%d\", &series);\n     if (series - last == d)\n      {\n          sum += series;\n          count++;\n      }\n      if (series - last != d)\n      {\n          if (count > length)\n          {\n              bSum = sum;\n              length = count;\n          }\n          else if (count == length && sum > bSum)\n          {\n              bSum = sum;\n          }\n        }\n    }\n```\n\n    ", "Answer": "\r\nI had coded this up, but needed clarification from OP (see my top comments).\nAs a result ...\nI added code to pick a sequence of equal length to the best but with a larger sum.\nBecause it was minimal changes to my code, I chose that the longest sequence wins:\n\nFor input of ```\n-2 -1 1 2```\n, this is a sequence of 4 with sum 0. It is not two sequences of 2 ```\n-2 -1```\n and ```\n1 2```\n with sum 3.\nFor input of ```\n1 1 1 1 1```\n, this is a sequence of 5 with sum 5 and not 5 sequences of 1 [each] with sum 1\n\n\nHere is the code. It is annotated:\n```\n#include <stdio.h>\n\nint\nmain(void)\n{\n\n    // get count of sequence numbers\n    int n;\n    scanf(\"%d\",&n);\n\n    // length of current sequence\n    int curlen = 0;\n\n    // sum of current sequence\n    int cursum = 0;\n\n    // value of current number\n    int curval;\n\n    // value of previous number\n    int oldval;\n\n    // get the first number\n    scanf(\"%d\",&oldval);\n\n    // add it to the current sequence\n    curlen += 1;\n    cursum += oldval;\n\n    // initialize the best sequence from the current one\n    int bestsum = cursum;\n    int bestlen = curlen;\n\n    // get all remaining numbers in the sequence\n    for (int i = 1;  i < n;  ++i, oldval = curval) {\n        // get new current number\n        if (scanf(\"%d\",&curval) != 1) {\n            fprintf(stderr,\"too short\\n\");\n            break;\n        }\n\n        // reset the current sequence if we're not increasing\n        if (curval < oldval) {\n            cursum = 0;\n            curlen = 0;\n        }\n\n        // add to the current sequence\n        cursum += curval;\n        curlen += 1;\n\n        // save off the longest sequence we've seen\n        if (curlen > bestlen) {\n            bestlen = curlen;\n            bestsum = cursum;\n            continue;\n        }\n\n        // save off a sequence that is the same length as the best but has a\n        // larger sum\n        if ((curlen == bestlen) && (cursum > bestsum)) {\n            bestsum = cursum;\n            continue;\n        }\n    }\n\n    // print the final/best sum\n    printf(\"%d\\n\",bestsum);\n\n    return 0;\n}\n```\n\n\nInput:\n```\n4\n-2 -1 1 2\n```\n\nOutput: 0\n\nInput:\n```\n5\n1 1 1 1 1\n```\n\nOutput: 5\n\nInput:\n```\n2\n7 19\n```\n\nOutput: 26\n\nInput:\n```\n8\n2 4 6 8 11 14 17 9\n```\n\nOutput: 62\n\nInput:\n```\n8\n8 6 4 2 11 14 15 16\n```\n\nOutput: 58\n\nInput:\n```\n12\n1 2 3 4\n2 3 4 5\n3 4 5 6\n```\n\nOutput: 18\n\nInput:\n```\n2\n2 1\n```\n\nOutput: 2\n\nHere is the ```\nperl```\n script that I used to generate the tests:\nEdit: Updated for example below.\n```\n#!/usr/bin/perl\n# runseq -- run sequence program\n#\n# options:\n#   \"-D\" -- cc -D options\n#   \"-S<sfile>\" -- source file (DEFAULT: seq.c)\n#   \"-clip\" -- send output to xclip program\n#   \"-d\" -- debug runseq script\n#\n# arguments:\n#   1-- [optional] comma separated list of sequence numbers (e.g. 3,7 2,1)\n\nmaster(@ARGV);\nexit(0);\n\n# master -- master control\nsub master\n{\n    my(@argv) = @_;\n\n    optdcd(\\@argv,\n        \"+opt_D\",\"opt_S\",\"opt_clip\");\n\n    # get source file\n    $sroot = $opt_S;\n    $sroot //= \"seq\";\n    $sroot =~ s/[.].+$//;\n\n    zprtx(\"compiling %s ...\\n\",$sroot);\n    $sfile = \"$sroot.c\";\n    sysfault(\"runseq: no source file\\n\")\n        unless (-e $sfile);\n\n    push(@cc,\"cc\");\n    push(@cc,\"-o$sroot\");\n    foreach $opt (@opt_D) {\n        push(@cc,\"-D$opt\");\n    }\n    push(@cc,$sfile);\n\n    $cmd = join(\" \",@cc);\n    zprtx(\"%s\\n\",$cmd);\n\n    $code = vxsystem(@cc);\n    exit(1) if ($code);\n\n    $tmpfile = \"inp.txt\";\n\n    # send to xclip program\n    if ($opt_clip) {\n        open($xfout,\"|xclip\");\n    }\n    else {\n        $xfout = \\*STDOUT;\n    }\n\n    {\n        # take tests from command line\n        if (@argv > 0) {\n            foreach $arg (@argv) {\n                $arg =~ s/,/ /g;\n                @body = ($arg);\n                dosum();\n            }\n            last;\n        }\n\n        # get test data from below\n        $xfdata = \\*seq::DATA;\n        while ($dat = <$xfdata>) {\n            chomp($dat);\n\n            # ignore comments\n            next if ($dat =~ /^\\s*#/);\n\n            # blank line separates tests\n            if ($dat =~ /^\\s*$/) {\n                dosum();\n                next;\n            }\n\n            push(@body,$dat);\n        }\n    }\n\n    # do final test\n    dosum()\n        if (@body > 0);\n\n    close($xfout)\n        if ($opt_clip);\n}\n\n# optdcd -- decode command line options\nsub optdcd\n{\n    my(@syms) = @_;\n    my($argv);\n    my($arg);\n    my($ary);\n    my($symlhs,$symrhs,$val,$match);\n\n    $argv = shift(@syms);\n\n    # get options\n    while (@$argv > 0) {\n        $arg = $argv->[0];\n        last unless ($arg =~ /^-/);\n\n        shift(@$argv);\n\n        $match = 0;\n        foreach $symrhs (@syms) {\n            $symlhs = $symrhs;\n            $ary = ($symlhs =~ s/^[+]//);\n\n            $opt = $symlhs;\n            $opt =~ s/^opt_/-/;\n\n            zprt(\"optdcd: TRYARG arg='%s' symrhs='%s' symlhs='%s' opt='%s' ary=%d\\n\",\n                $arg,$symrhs,$symlhs,$opt,$ary);\n\n            if ($arg =~ /^$opt(.*)$/) {\n                $val = $1;\n\n                $val =~ s/^=//;\n                $val = 1\n                    if ($val eq \"\");\n\n                if ($ary) {\n                    zprt(\"optdcd: PUSH val=%s\\n\",$val);\n                    push(@$symlhs,$val);\n                }\n                else {\n                    zprt(\"optdcd: SET val=%s\\n\",$val);\n                    $$symlhs = $val;\n                }\n\n                $match = 1;\n                last;\n            }\n        }\n\n        sysfault(\"optdcd: unknown option -- '%s'\\n\",$arg)\n            unless ($match);\n    }\n}\n\nsub dosum\n{\n    my($bf);\n    my(@rhs);\n    my(@n);\n\n    zprtx(\"\\n\")\n        if ($opt_clip);\n\n    $xfdst = xfopen(\">$tmpfile\",\"dosum\");\n\n    # get count of sequence values (i.e. \"n\")\n    foreach $bf (@body) {\n        @rhs = split(\" \",$bf);\n        push(@n,@rhs);\n    }\n    printf($xfdst \"%d\\n\",scalar(@n));\n\n    foreach $bf (@body) {\n        zprtx(\"dosum: %s\\n\",$bf)\n            if ($opt_clip);\n        print($xfdst $bf,\"\\n\");\n    }\n    $xfdst = xfclose($xfdst);\n\n    # run program\n    my($outval) = (`./$sroot < $tmpfile`);\n    chomp($outval);\n\n    # output test input data and program output\n    outf(\"\\n\");\n    outf(\"----------\\n\")\n        if ($opt_clip);\n    outf(\"Input:\\n\");\n    outf(\"```\\n\")\n        if ($opt_clip);\n    $xfsrc = xfopen(\"<$tmpfile\",\"dosum\");\n    while ($buf = <$xfsrc>) {\n        outf(\"%s\",$buf);\n    }\n    $xfsrc = xfclose($xfsrc);\n    outf(\"```\\n\")\n        if ($opt_clip);\n\n    outf(\"\\n\")\n        if ($opt_clip);\n    outf(\"Output: %d\\n\",$outval);\n\n    undef(@body);\n}\n\nsub outf\n{\n\n    printf($xfout @_);\n}\n\nsub zprt\n{\n\n    goto &zprtx\n        if ($opt_d);\n}\n\nsub zprtx\n{\n\n    printf(STDERR @_);\n}\n\nsub sysfault\n{\n\n    zprtx(@_);\n    exit(1);\n}\n\nsub xfopen\n{\n    my($file,$who) = @_;\n    my($xf);\n\n    open($xf,$file) or\n        sysfault(\"xfopen: unable to open '%s' -- $!\\n\",$file);\n\n    $xf;\n}\n\nsub xfclose\n{\n    my($xf) = @_;\n\n    close($xf);\n\n    undef($xf);\n\n    $xf;\n}\n\nsub vxsystem\n{\n    my($cmd);\n\n    $cmd = join(\" \",@_);\n\n    system($cmd);\n\n    $? >> 8;\n}\n\npackage seq;\n__DATA__\n-2 -1 1 2\n\n1 1 1 1 1\n\n7 19\n\n2 4 6 8 11 14 17 9\n\n8 6 4 2 11 14 15 16\n\n1 2 3 4\n2 3 4 5\n3 4 5 6\n\n2 1\n```\n\n\nUPDATE:\nHere is a version that adds some debug printing (-DDEBUG). And, selection of ```\n<=```\n vs ```\n<```\n (-DLE).\nI've updated the ```\nrunseq```\n script above to handle this version [it is backwards compatible].\n```\n#include <stdio.h>\n\n#if DEBUG\n#define dbgprt(_fmt...) \\\n    fprintf(stderr,_fmt)\n#else\n#define dbgprt(_fmt...) \\\n    do { } while (0)\n#endif\n\nint\nmain(void)\n{\n\n    // get count of sequence numbers\n    int n;\n\n    scanf(\"%d\", &n);\n\n    // length of current sequence\n    int curlen = 0;\n\n    // sum of current sequence\n    int cursum = 0;\n\n    // value of current number\n    int curval;\n\n    // value of previous number\n    int oldval = 0;\n\n    // get the first number\n    scanf(\"%d\", &curval);\n\n    // add it to the current sequence\n    curlen += 1;\n    cursum += curval;\n\n    dbgprt(\"OLD: oldval=%d curval=%d cursum=%d curlen=%d\\n\",\n        oldval,curval,cursum,curlen);\n\n    oldval = curval;\n\n    // initialize the best sequence from the current one\n    int bestsum = cursum;\n    int bestlen = curlen;\n\n    // get all remaining numbers in the sequence\n    for (int i = 1; i < n; ++i, oldval = curval) {\n        // get new current number\n        if (scanf(\"%d\", &curval) != 1) {\n            fprintf(stderr, \"too short\\n\");\n            break;\n        }\n\n        // reset the current sequence if we're not increasing\n#if LE\n        if (curval <= oldval) {\n            cursum = 0;\n            curlen = 0;\n            dbgprt(\"ZAPLE\\n\");\n        }\n#else\n        if (curval < oldval) {\n            cursum = 0;\n            curlen = 0;\n            dbgprt(\"ZAPLT\\n\");\n        }\n#endif\n\n        // add to the current sequence\n        cursum += curval;\n        curlen += 1;\n\n        dbgprt(\"CUR: oldval=%d curval=%d cursum=%d curlen=%d\\n\",\n            oldval,curval,cursum,curlen);\n\n        // save off the longest sequence we've seen\n        if (curlen > bestlen) {\n            dbgprt(\"NEWLEN\\n\");\n            bestlen = curlen;\n            bestsum = cursum;\n            continue;\n        }\n\n        // save off a sequence that is the same length as the best but has a\n        // larger sum\n        if ((curlen == bestlen) && (cursum > bestsum)) {\n            dbgprt(\"NEWSUM\\n\");\n            bestsum = cursum;\n            continue;\n        }\n    }\n\n    // print the final/best sum\n    printf(\"%d\\n\", bestsum);\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence in O(n) time?\r\n                \r\nI'm studying this algorithm for the first time.  CLRS (15-4.6) asks to write an algorithm to run in O(n lg n) time.  The algorithm I came up with seems to run in O(n).  I think I must be misunderstanding something, because even wikipedia says it should take O(n lg n) time.  (https://en.wikipedia.org/wiki/Longest_increasing_subsequence)\nCould somebody tell me why this algorithm (in Python) doesn't work in general or isn't O(n) or doesn't answer the question??\n\n```\n\"\"\"Attempts to find maximal ordered subsequence in linear time.\"\"\"\n\ndef subseq(n):\n    \"\"\"Assumes the elements of n are unique\"\"\"\n    if len(n) == 1:\n        return n[:]\n    first = [n[0]]\n    second = []\n    for i in range(1,len(n)):\n        if n[i] > first[-1]:\n            second = first[:]\n            first.append(n[i])\n        elif not second or n[i] > second[-1]:\n            first = second[:]\n            first.append(n[i])\n    return first\n\nprint subseq([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15])\n```\n\n    ", "Answer": "\r\nI'll leave some of the debugging to you, but the following does not produce the maximum length substring using your algorithm. I simply added a few numbers to the example you had, so it should have produced ```\n[0, 4, 6, 9, 11, 15]```\n again, but didn't:\n\n```\n>>> print(subseq([0, 12,12,15,14 ,8, 4, 12, 14, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]))\n[0, 12, 13, 15]\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Non increasing and Non Decreasing Subsequence\r\n                \r\nFinding non-decreasing subsequence is well known problem.\nBut this Question is a slight variant of the finding longest non-decreasing subsequence. In this problem we have to find the length of longest subsequence which comprises 2 disjoint sequences 1. non decreasing 2. non-increasing.\ne.g. in string \"aabcazcczba\" longest such sequence is aabczcczba. aabczcczba is made up of 2 disjoint subsequence aabcZccZBA. (capital letter shows non-increasing sequence)\n\nMy algorithm is\n\n```\nlength = 0\nFor i = 0 to length of given string S\n  let s' = find the longest non-decreasing subsequence starting at position i\n  let s\" = find the longest non-increasing subsequence from S-s'.\n  if (length of s' + length of s\") > length\n      length = (length of s' + length of s\")\nenter code here\n```\n\n\nBut I am not sure whether this would give correct answer or not. Can you find a bug in this algo and if there is bug also suggest correct algorithm. Also I need to optimize the solution. My algorithm would take roughly o(n^4) steps.\n    ", "Answer": "\r\nYour solution is definitely incorrect. Eg. addddbc. The longest non-decreasing sequence is adddd, but that would never give you a non-increasing sequence. The optimal solution is abc and dddd ( or ab ddddc, or ac ddddb).\n\nOne solution is to use dynamic programming. \n\nF(i, x, a, b) = 1, if there is a non-decreasing and non-increasing combo from first i letters of x ( x[:i]) such that last letter of non-decreasing part is a, and non-increasing part is b. Both of these letters equal to NULL if the corresponding sub-sequence is empty.\n\nOtherwise F(i, x, a, b) = 0.\n\n```\nF(i+1,x,x[i+1],b) = 1 if there exists a and b such that \n    a<=x[i+1] or a=NULL and F(i,x,a,b)=1. 0 otherwise.\n\nF(i+1,x,a,x[i+1]) = 1 if there exists a and b such that\n    b>=x[i+1] or b=NULL and F(i,x,a,b)=1. 0 otherwise. \n\nInitialize F(0,x,NULL,NULL)=1 and iterate from i=1..n\n```\n\n\nAs you can see, you can get F(i+1, x, a, b) from F(i, x, a, b). Complexity: Linear in length, polynomial in size of the alphabet.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Counting number of longest increasing subsequences by evolving recursive solution\r\n                \r\nHow can I count the number of longest increasing LIS by evolving my recursive solution for example ```\n[1,3,5,4,7]```\n returns ```\n2```\n where the LIS is ```\n1,3,5,7```\n and ```\n1,3,4,7```\nsimilarly for ```\n[3,3,3,3]```\n it will be ```\n4```\n where LIS is ```\n3```\n and there are ```\n4```\n of them \n\nI compute LIS recursively as follows: (I can optimize this using memoisation and go further to DP and then to a segmented tree as per various solutions but I would like to intuitively lead myself to them)\n\n```\nint numberOfLis(vector<int>& nums)\n{\n    //Set the size of count to the size of num, since there cannot be an LIS greater than the size of nums\n    vector<int> count(nums.size(), 0); \n\n    //Get the size of the maximum LIS and update the frequency of how many similar sizes have been encountered in the count array\n    int maxcount = LIS(nums, INT32_MIN, 0, count);\n\n    //Return the number of occurances by looking it up in our count.\n    return count[maxcount];\n}\n\nint LIS(vector<int>& nums, int prev, int index, vector<int>& count)\n{\n    if (index == nums.size()) return 0;\n\n    int with = 0;\n    //Increasing sequence, lets select it.\n    if (nums[index] > prev) with = 1 + helper(nums, nums[index], index + 1, count);\n\n    //See if we can do better without the current number\n    int without = helper(nums, prev, index + 1, count);\n\n    //Get the maximum seen so far and update the frequency in count array\n    int maxcount = max(with, without);\n    ++count[maxcount];\n\n    return maxcount;\n}\n```\n\n\nI used a ```\ncount```\n array ```\nvector<int>(nums.size(), 0)```\n to increment the max value as I encounter it as ```\n++count[max(with,without)]```\n where the ```\ncount```\n of the returned max value would be the answer. This lead the ```\ncount```\n array to have ```\n4```\n a count of ```\n1```\n not ```\n2```\n which is wrong. I am looking for a way to move forward from here.\n\nUpdated: Added code for the ```\ncount```\n array and added comments\n    ", "Answer": "\r\nThe count for a subsequence is more than an increment, as there can be multiple subsequences that end up with the same length.\n\nWorking with your example data, when ```\nindex```\n is 1, both ```\nwith```\n and ```\nwithout```\n are 3.  ```\ncount[3]```\n is only incremented once, though, even though there are two subsequences with this length, and 3 is returned as the maximum length.  When this is used by the previous call (when ```\nindex```\n is 0), ```\nwith```\n will be 4 and ```\nwithout```\n 3.  ```\ncount[4]```\n is only increased by 1, even though there are two subsequences of length 4.\n\nYou need to change ```\nhelper```\n to return not just the length of the longest subsequence, but the number of subsequences that have that length.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find the length of longest increasing subsequence C++\r\n                \r\nPlease help me solve this problem, when input ```\n10```\n and  ```\n1 2 3 1 2 3 3 4 5 6```\n\nOutput should be ```\n4```\n but it's ```\n6```\n.\nIn all other tests, the program is working well.\nFor Example:\n```\nInput: 1   -10\nOutput: 1\n\nInput: 2   123 123\nOutput: 1\n\nInput: 2   -1245 234\nOutput: 2\n\nInput: 5   1 2 3 -1 -20\nOutput: 3\n\nInput: 5   1 1 2 3 1\nOutput: 3\n\nInput: 5   0 0 0 1 10000\nOutput: 3\n```\n\nThanks in advance!\n```\n#include <iostream>\nusing namespace std;\n\nint subsequence(int arr[], int n) {\n\n int* length = new int[n];\n int max_length = 0;\n\n for (int i = 0; i < n; i++) {  \n    for (int j = 0; j < i; j++) { \n       if (arr[j] < arr[i] && length[j] > length[i])\n          length[i] = length[j];\n    }\n        length[i]++; \n }\n for (int i = 0; i < n; i++) { \n    max_length = max(max_length, length[i]);\n }\n delete [] length;\n\n      return max_length;\n}\nint main() {\n  int n;\n      cin >> n;\n  int* arr = new int[n];\n  for(int i = 0; i < n; ++i) {\n      cin >> arr[i];\n  }\n      cout << subsequence(arr, n);\n\n      return 0;\n}\n```\n\n    ", "Answer": "\r\nFirstly, the ```\nlength```\n array values are unitialized, this will invoke undefined behavior, in your case, by chance, it works, but you should expect that whatever garbage values are in the array will be used as a comparison, to avoid this you should fill it with ```\n0```\ns.\nThen, this piece of code:\n```\nfor (int i = 0; i < n; i++)\n{\n    max_length = max(max_length, length[i]);   \n    std::cout << max_length << \" \";    \n}\n```\n\nThis means, broadly speaking, that the ```\nmax_length```\n will increase as long as the next number is larger than the previous, there is no variable reset, both sequences are counted:\n```\n1 2 3 1 2 3 3 4 5 6  //input sequence\n\n1 2 3 3 3 3 3 4 5 6  //max_length value along the function\n^ ^ ^         ^ ^ ^\n+ + +         + + +\n```\n\nHence the ```\n6```\n output.\nThat said, you wouldn't need such a convoluted piece of code for such a simple task, if you just need to count the max sequence, something along the lines of:\n```\nint subsequence(int arr[], int n) {\n\n    int max_length = 1; //hold the max_length\n    int temp = 1;       //hold the temporary max_length\n\n    for (int i = 0; i < n - 1; i++) {\n        if(arr[i + 1] > arr[i]) { \n            temp++;     //if the next value is larger increase temp\n            max_length = std::max(max_length, temp); //assign largest temp to max_length\n        }\n        else{     \n            temp = 1;   //otherwise reset temp\n        }    \n    }\n    return max_length;  //return max_length\n}\n```\n\nSide note:\nSince you're using C++, you could upgrade your code to use C++ containers instead of C style arrays, ```\nstd::vector```\n in this case, given the variable size array.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to print Longest Increasing Subsequence(LIS) from a given array?\r\n                \r\nI can print the length of a LIS by a normal function and Recursive function. But I want to print that index of LIS subsequence in a given array in C++.\n\nHere is my function to find the length of LIS : \n\n```\nint lis( int *arr, int n )\n{\n   int *lis, i, j, max = 0;\n   lis = (int*) malloc ( sizeof( int ) * n );\n   for ( i = 0; i < n; i++ )\n      lis[i] = 1;\n   for ( i = 1; i < n; i++ )\n      for ( j = 0; j < i; j++ )\n         if ( arr[i] > arr[j] && lis[i] < lis[j] + 1)\n            lis[i] = lis[j] + 1;\n   for ( i = 0; i < n; i++ )\n      if ( max < lis[i] )\n         max = lis[i];\n   /* Free memory to avoid memory leak */\n   free( lis );\n   return max;\n}\n```\n\n\nhere ```\narray[10]={7 6 2 3 4 1 8 5 9 10}```\n\n\nhere ```\nLIS Length=6```\n\n\nI wanna print the index of numbers ```\n{2 3 4 6 8 9}```\n ( its not the sequence its the arrray index , what i wanna print ) index of sequence in the ```\narray[10]```\n\n    ", "Answer": "\r\nAfter calculating lis for each index, take a tmp value equal to max, go backwards on lis array, and every time you find an element equal to max, add that index to the answer and decrement tmp. Hereby you'll get the indexes array in reversed order.\n\nExample code:\n\n```\nint tmp = max;\nstd::vector<int> indexes;\nfor( i = n - 1; i >= 0; --i )\n   if( lis[ i ] == tmp )\n   {\n      indexes.push_back( i );\n      --tmp;\n   }\nstd::reverse( indexes.begin(), indexes.end());\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find increasing and decreasing subsequence in an array Python\r\n                \r\nI have a little complicated problem. \n\nI have this array [34,33,5,78,50,76,82,95,119,31,49,76] and I need to find all the longest increasing and decreasing subsequences.\nFor example, the longest decreasing subsequence you can find has a lenght of three. Then, I need to find all the subsequence with that lenght, e.g: [78,76,76] or  [78,50,31] or [34,33,31] etc..\n\nI've been trying to create an algorithm in python that, given an array in input, it returns all the longest decreasing and increasing subsequences, for a while but I couldn't succeed.\nI've written this so far, \n\n```\ndef find_decreasing(seq):\nfound=[]\nfor v in seq[:-1]:        \n    for iv in found[:]:\n        if v > iv[0]:\n            found.append([v+1]+iv)\n    found.append([v])\nreturn found\n```\n\n\nBut it doesn't work\nMay you help me?\n\nThanks for your attention.\n    ", "Answer": "\r\nWell i did something similar once, if i understood your question correctly.\n\nMy code works to find all possible decreasing numbers within a list of numbers.\n\nI am going to try to explain it (just for decreasing sequences):\n\nThe way i did was:\n\n```\ndef find_decreasing(seq):\n    found=[]\n    for v in seq[::-1]:        \n        for iv in found[:]:\n            if v >= iv[0]:\n                found.append([v]+iv)\n        found.append([v])\n    return found\n```\n\n\nIt is not easy to explain the logic now but it is not that hard to understanding reading the code. If you have any doubt, you can ask and I can post an explanation with more time later.\n\nBut with this function, ow it is easy to filter for the largest:\n\n```\ndecreasing = find_decreasing(seq) # Find all decreasing\nmax_len = max(map(len,decreasing)) # get the max length of that sequences\nfinal_list = list(filter(lambda a: len(a)==max_len, decreasing)) # filter the ones with the max length\n```\n\n\nFor your input, the answer i get is:\n\n```\nfinal_list = [[78, 76, 76],\n [78, 76, 49],\n [78, 76, 31],\n [78, 50, 49],\n [78, 50, 31],\n [34, 33, 31],\n [34, 33, 5]]\n```\n\n\nFor increasing sequences it is easy to change the code (just changing >= to <= should do it). \n\nHope I helped. \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Explain the algorithm to solve 'longest increasing subsequence' problem\r\n                \r\nI have been trying to understand this algorithm for past two hours, but can't seem to get it. Can someone please explain it in easy to understand manner?\n\n```\nfunction lis_length(a)\n    n := a.length\n    q := new Array(n)\n    for k from 0 to n:\n        max := 0;\n        for j from 0 to k, if a[k] > a[j]:\n            if q[j] > max, then set max = q[j].\n        q[k] := max + 1;\n    max := 0\n    for i from 0 to n:\n        if q[i] > max, then set max = q[i].\n    return max;\n```\n\n    ", "Answer": "\r\nAfter the first (double) loop terminates, ```\nq[i]```\n is the length of the longest increasing subsequence ending at position ```\ni```\n.\n\nTo see how the double loop works, suppose ```\nq[j]```\n already contained the length of the largest increasing subsequence ending at position ```\nj```\n, but only for ```\nj```\n between ```\n0```\n and ```\nk-1```\n.  Given this, how would you compute ```\nq[k]```\n?\n\nWell, you would find all of the ```\nj```\n with ```\nj < k```\n and ```\na[j] < a[k]```\n, see which of the corresponding ```\nq[j]```\n values was biggest, add one, and stash that value in ```\nq[k]```\n.  This is exactly what the inner loop does.\n\nSo at entry to the inner loop, ```\nq[j]```\n already has the correct values for j between ```\n0```\n and ```\nk-1```\n.  And at exit, it also has the correct value for ```\nk```\n.  So by the time the double loop exits, ```\nq[i]```\n has the correct value for all ```\ni```\n between ```\n0```\n and ```\nn```\n.\n\nThe final loop just selects the largest of those, which is the answer.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest increasing subsequence in Python (For vs While loop)\r\n                \r\nI was solving this leetcode problem link in which we are supposed to find the ```\nlongest increasing sub-sequence in a list or array```\n. I solved the problem using \ntwo methods. \n\n\nFirst using the ```\nwhile```\n loop \nUsing nested ```\nfor```\n loop \n\n\n\n  Even though the value of (i, j) or looping is exactly same, but for\n  the higher length inputs, the ```\nwhile loop```\n program is taking more time\n  than the ```\nfor```\n program. I am not sure why?\n\n\nFOR LOOP\n\n```\nimport time\nstart_time = time.time()\n\nclass Solution(object):\n# using dP\n    def lengthOfLIS1(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n\nprint Solution().lengthOfLIS1([1] * 1249 + [101] + [1] * 1250)\n\nprint(\"--- %s seconds ---\" % (time.time() - start_time))\n```\n\n\nOutput : \n\n```\n2\n--- 0.240112066269 seconds ---\n```\n\n\nWHILE LOOP\n\n```\n# This problem an be done in O(n*n)\nimport time\nstart_time = time.time()\n\nclass Solution(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return []\n        elif len(nums) == 1:\n            return nums\n\n        size = len(nums)\n        subsequence_array = [1] * size\n        i, j, max_value = 0, 1, 1\n        while j < size:\n            if nums[j] > nums[i]:\n                subsequence_array[j] = max(subsequence_array[j], subsequence_array[i] + 1)\n                if max_value < subsequence_array[j]:\n                    max_value = subsequence_array[j]\n                i += 1\n                if j == i:\n                    i = 0\n                    j += 1\n            else:\n                i += 1\n                if i == j:\n                    j += 1\n                    i = 0\n\n        return max_value\n\nprint Solution().lengthOfLIS([1] * 1249 + [101] + [1] * 1250)\n\nprint(\"--- %s seconds ---\" % (time.time() - start_time))\n```\n\n\nOUTPUT\n\n```\n2\n--- 0.331799030304 seconds ---\n```\n\n\nCan anyone explain why the ```\nwhile loop```\n is taking more time than the ```\nfor loop```\n even though the looping of ```\ni and j```\n is almost same? Will appreciate your answer.\n    ", "Answer": "\r\nLook at the bytecode\n\nThe ```\nwhile```\n loop has to do way more operations.\nPython is executing bytecode. Therefore, the number of and kind of bytecode instructions can give you hint what actually happens.\n\nThe function ```\ndis```\n in the module ```\ndis```\n:\n\n```\nimport dis\n```\n\n\ncan visualize the bytcode.\n\nFirst for the ```\nrange```\n solution:\n\n```\ndis.dis(SolutionRange)\nDisassembly of lengthOfLIS1:\n  8           0 LOAD_FAST                1 (nums)\n              3 POP_JUMP_IF_TRUE        10\n\n  9           6 LOAD_CONST               1 (0)\n              9 RETURN_VALUE\n\n 10     >>   10 LOAD_CONST               2 (1)\n             13 BUILD_LIST               1\n             16 LOAD_GLOBAL              0 (len)\n             19 LOAD_FAST                1 (nums)\n             22 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             25 BINARY_MULTIPLY\n             26 STORE_FAST               2 (dp)\n\n 11          29 SETUP_LOOP             103 (to 135)\n             32 LOAD_GLOBAL              1 (range)\n             35 LOAD_CONST               2 (1)\n             38 LOAD_GLOBAL              0 (len)\n             41 LOAD_FAST                1 (nums)\n             44 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             47 CALL_FUNCTION            2 (2 positional, 0 keyword pair)\n             50 GET_ITER\n        >>   51 FOR_ITER                80 (to 134)\n             54 STORE_FAST               3 (i)\n\n 12          57 SETUP_LOOP              71 (to 131)\n             60 LOAD_GLOBAL              1 (range)\n             63 LOAD_FAST                3 (i)\n             66 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             69 GET_ITER\n        >>   70 FOR_ITER                57 (to 130)\n             73 STORE_FAST               4 (j)\n\n 13          76 LOAD_FAST                1 (nums)\n             79 LOAD_FAST                3 (i)\n             82 BINARY_SUBSCR\n             83 LOAD_FAST                1 (nums)\n             86 LOAD_FAST                4 (j)\n             89 BINARY_SUBSCR\n             90 COMPARE_OP               4 (>)\n             93 POP_JUMP_IF_FALSE       70\n\n 14          96 LOAD_GLOBAL              2 (max)\n             99 LOAD_FAST                2 (dp)\n            102 LOAD_FAST                3 (i)\n            105 BINARY_SUBSCR\n            106 LOAD_FAST                2 (dp)\n            109 LOAD_FAST                4 (j)\n            112 BINARY_SUBSCR\n            113 LOAD_CONST               2 (1)\n            116 BINARY_ADD\n            117 CALL_FUNCTION            2 (2 positional, 0 keyword pair)\n            120 LOAD_FAST                2 (dp)\n            123 LOAD_FAST                3 (i)\n            126 STORE_SUBSCR\n            127 JUMP_ABSOLUTE           70\n        >>  130 POP_BLOCK\n        >>  131 JUMP_ABSOLUTE           51\n        >>  134 POP_BLOCK\n\n 15     >>  135 LOAD_GLOBAL              2 (max)\n            138 LOAD_FAST                2 (dp)\n            141 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n            144 RETURN_VALUE\n```\n\n\nand now for the ```\nwhile```\n solution:\n\n```\ndis.dis(SolutionWhile)\n\nDisassembly of lengthOfLIS:\n  7           0 LOAD_FAST                1 (nums)\n              3 POP_JUMP_IF_TRUE        10\n\n  8           6 BUILD_LIST               0\n              9 RETURN_VALUE\n\n  9     >>   10 LOAD_GLOBAL              0 (len)\n             13 LOAD_FAST                1 (nums)\n             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             19 LOAD_CONST               1 (1)\n             22 COMPARE_OP               2 (==)\n             25 POP_JUMP_IF_FALSE       32\n\n 10          28 LOAD_FAST                1 (nums)\n             31 RETURN_VALUE\n\n 12     >>   32 LOAD_GLOBAL              0 (len)\n             35 LOAD_FAST                1 (nums)\n             38 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             41 STORE_FAST               2 (size)\n\n 13          44 LOAD_CONST               1 (1)\n             47 BUILD_LIST               1\n             50 LOAD_FAST                2 (size)\n             53 BINARY_MULTIPLY\n             54 STORE_FAST               3 (subsequence_array)\n\n 14          57 LOAD_CONST               3 ((0, 1, 1))\n             60 UNPACK_SEQUENCE          3\n             63 STORE_FAST               4 (i)\n             66 STORE_FAST               5 (j)\n             69 STORE_FAST               6 (max_value)\n\n 15          72 SETUP_LOOP             172 (to 247)\n        >>   75 LOAD_FAST                5 (j)\n             78 LOAD_FAST                2 (size)\n             81 COMPARE_OP               0 (<)\n             84 POP_JUMP_IF_FALSE      246\n\n 16          87 LOAD_FAST                1 (nums)\n             90 LOAD_FAST                5 (j)\n             93 BINARY_SUBSCR\n             94 LOAD_FAST                1 (nums)\n             97 LOAD_FAST                4 (i)\n            100 BINARY_SUBSCR\n            101 COMPARE_OP               4 (>)\n            104 POP_JUMP_IF_FALSE      205\n\n 17         107 LOAD_GLOBAL              1 (max)\n            110 LOAD_FAST                3 (subsequence_array)\n            113 LOAD_FAST                5 (j)\n            116 BINARY_SUBSCR\n            117 LOAD_FAST                3 (subsequence_array)\n            120 LOAD_FAST                4 (i)\n            123 BINARY_SUBSCR\n            124 LOAD_CONST               1 (1)\n            127 BINARY_ADD\n            128 CALL_FUNCTION            2 (2 positional, 0 keyword pair)\n            131 LOAD_FAST                3 (subsequence_array)\n            134 LOAD_FAST                5 (j)\n            137 STORE_SUBSCR\n\n 18         138 LOAD_FAST                6 (max_value)\n            141 LOAD_FAST                3 (subsequence_array)\n            144 LOAD_FAST                5 (j)\n            147 BINARY_SUBSCR\n            148 COMPARE_OP               0 (<)\n            151 POP_JUMP_IF_FALSE      164\n\n 19         154 LOAD_FAST                3 (subsequence_array)\n            157 LOAD_FAST                5 (j)\n            160 BINARY_SUBSCR\n            161 STORE_FAST               6 (max_value)\n\n 20     >>  164 LOAD_FAST                4 (i)\n            167 LOAD_CONST               1 (1)\n            170 INPLACE_ADD\n            171 STORE_FAST               4 (i)\n\n 21         174 LOAD_FAST                5 (j)\n            177 LOAD_FAST                4 (i)\n            180 COMPARE_OP               2 (==)\n            183 POP_JUMP_IF_FALSE      243\n\n 22         186 LOAD_CONST               2 (0)\n            189 STORE_FAST               4 (i)\n\n 23         192 LOAD_FAST                5 (j)\n            195 LOAD_CONST               1 (1)\n            198 INPLACE_ADD\n            199 STORE_FAST               5 (j)\n            202 JUMP_ABSOLUTE           75\n\n 25     >>  205 LOAD_FAST                4 (i)\n            208 LOAD_CONST               1 (1)\n            211 INPLACE_ADD\n            212 STORE_FAST               4 (i)\n\n 26         215 LOAD_FAST                4 (i)\n            218 LOAD_FAST                5 (j)\n            221 COMPARE_OP               2 (==)\n            224 POP_JUMP_IF_FALSE       75\n\n 27         227 LOAD_FAST                5 (j)\n            230 LOAD_CONST               1 (1)\n            233 INPLACE_ADD\n            234 STORE_FAST               5 (j)\n\n 28         237 LOAD_CONST               2 (0)\n            240 STORE_FAST               4 (i)\n        >>  243 JUMP_ABSOLUTE           75\n        >>  246 POP_BLOCK\n\n 30     >>  247 LOAD_FAST                6 (max_value)\n            250 RETURN_VALUE\n```\n\n\nThere many more lines of bytecode in the ```\nwhile```\nsolution. This is an indication that is slower. Of course, not all bytecode instructions take the same time and need to analyze deeper for a more quantitative answer.\n\nEverything is an object\n\nIn Python everything is an object. Therefore, this:\n\n```\n>>> 1 + 1\n2\n```\n\n\nis actually doing this:\n\n```\n>>> 1 .__add__(1)\n2\n```\n\n\nSo the simple addition of two integers involves a call to the method ```\n__add__()```\n. Such calls are relatively slow.\n\nFor example, we have this list:\n\n```\nL = list(range(int(1e6)))\n```\n\n\nThe sum with th built-in function ```\nsum()```\n:\n\n```\n%%timeit\nsum(L)\n\n100 loops, best of 3: 15.9 ms per loop\n```\n\n\nis considerably faster than writing a loop:\n\n```\n%%timeit\nsum_ = 0\nfor x in L:\n    sum_ += x\n\n10 loops, best of 3: 95.7 ms per loop\n```\n\n\nThe built-in ```\nsum```\n uses optimizations that avoid some of the overhead cause by the everything-is-an-object concept.\n\nThe ```\nwhile```\n solution has many operations such as ```\nj += 1```\n. These alone add measurable execution time.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "find minium of increasing subseqeunces in permutation\r\n                \r\ni want to find one minimum of increasing subsequences ```\nList<int[]```\n in a permutation ```\n1-n```\n. So i just needn't a number but the concrete subsequences.\nCurrently I search the longest increasing subsequence, delete these elements and search again, until no element left. But this isn't optimal.\nExample:\n```\n1,4,3,2,5```\n -> 3 -> ```\n1,2,5```\n ```\n4```\n ```\n3```\n\n```\n1,4,5,2,3```\n -> 2 -> ```\n1,4,5```\n ```\n2,3```\n\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest subsequence that first increases then decreases\r\n                \r\nI am trying to solve the following question : \n\n\n\nA sequence in which the value of elements first decrease and then increase is called V- Sequence. In a valid V-Sequence there should be at least one element in the decreasing and at least one element in the increasing arm.\n\nFor example, \"5 3 1 9 17 23\" is a valid V-Sequence having two elements in the decreasing arm namely 5 and 3, and 3 elements in the increasing arm namely 9, 17 and 23 . But none of the sequence \"6 4 2\" or \"8 10 15\" are V-Sequence since \"6 4 2\" has no element in the increasing part while \"8 10 15\" has no element in the decreasing part.\n\nA sub-sequence of a sequence is obtained by deleting zero or more elements from the sequence. For example definition \"7\", \"2 10\", \"8 2 7 6\", \"8 2 7 10 6\" etc are valid sub-sequences of \"8 2 7 10 6\"\n\nGiven a sequence of N numbers find its longest sub-sequence which is a V-Sequence.\n\n\n\nI currently have an O( n^2 ) solution wherein I first initialize an array ( m[] ) such that each m[i] contains the longest increasing sequences STARTING at 'i' within the array.\n\nSimilarly, I initialize another array ( d[] ), such that each d[i] contains the longest decreasing sequence ENDING at that point.\n\nBoth of these operations take O( n^2 )\n\nI now go through these arrays and choose the maximum value of m[i] + d[i] -1 , such that required conditions are satisfied.\n\nWhat I want to know is - Is there an O( n lg n ) solution ?? Because my solution does not run within required time limits. Thank you :)\n\nCODE : \n\n```\n#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\n\n\nint m[ 200000 ];\nint d[200000 ];\nint n;\nint arr[200000 ];\n\nvoid LIS()\n{\n    m[ n-1 ] = 1;\n\n    int maxvPos = -1;\n    int maxv = -1;\n\n    for( int i=n-2; i>=0; i-- )\n    {\n        maxv = -1;\n        for( int j=i+1; j<n; j++ )\n        {\n            if( ( m[j]+1 > maxv ) && ( arr[i] < arr[j]) )\n            {\n                maxv = m[j]+1;\n                maxvPos = j;\n            }\n\n\n        }\n        if( maxv>0 )\n            {\n                m[i] = maxv;\n            }\n\n            else\n                m[i ] = 1;\n    }\n\n }\n\nvoid LDS()\n{\n      d[0] = 1;\n\n    int maxv = -1;\n    int maxvPos = -1;\n\n    for( int i=1; i<n; i++ )\n    {\n        maxv = -1;\n        for( int j=i-1; j>=0; j-- )\n        {\n            if( ( d[j]+1 > maxv) && arr[j]>arr[i] )\n            {\n                maxv = d[j]+1;\n                maxvPos = j;\n            }\n        }\n\n        if( maxv>0 )\n            d[i] = maxv;\n\n        else\n            d[i]=1;\n    }\n\n}\n\nint solve()\n{\n    LIS();\n    LDS();\n\n    int maxv = 0;\n    int curr = 0;\n\n    for( int i=0; i<n; i++ )\n    {\n        curr = d[i] + m[i] -1 ;\n\n        if( ( d[i]>0) && (m[i]>0 ))\n        {\n            if( curr != 1 )\n            maxv = max( curr, maxv );\n        }\n\n    }\n\n    return maxv;\n\n}\n\n/*    static void printArr( int[] a )\n{\n    for( int i : a )\n        System.out.print( i + \" \");\n\n    System.out.println();\n} */\n\n\nint main()\n{\n    scanf( \"%d\", &n );\n\n    for( int i=0; i<n; i++ )\n    {\n        scanf(\"%d\", &arr[i] );\n    }   \n\n    printf(\"%d\\n\", solve() );\n    return 0;\n\n}\n```\n\n    ", "Answer": "\r\nThere are ```\nO(NlgK)```\n algorithm for Longest Increasing Subsequence problem, where ```\nK```\n is the LIS length. You can check Wikipedia for a description of the algorithm. LightOJ also has a nice tutorial (this might require login).\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Subsequence in a sequence of numbers in scala\r\n                \r\nFor example i have:\n```\nList(1,3,2,5)```\n\n\nHow i get all these:\n```\nList(1), List(3), List(2), List(5), List(1,3), List(1,2), List(1,5), List(3,2), List(3,5), List(2,5), List(1,3,2), List(1,3,5), List(1,2,5), List(3,2,5), List(1,3,2,5))```\n\n\nI need this for Longest Increasing Subsequence -problem and this answer for example would be: (1,3,5)\n\nAnd I want use it for bigger Lists.\n    ", "Answer": "\r\nYou want all the ```\ncombinations()```\n from 1 to array length.\n\n```\nval arr = Array(4, 3, 1)\n\narr.indices.flatMap(x => arr.combinations(x + 1))\n//res0: Seq[Array[Int]] = Vector(Array(4), Array(3), Array(1), Array(4, 3), Array(4, 1), Array(3, 1), Array(4, 3, 1))\n```\n\n\n\n\nupdate\n\nThis will give you all possible combinations, retaining original order and duplicate elements.\n\n```\ndef subseqs[A](seq :Seq[A]) :List[Seq[A]] = seq match {\n  case hd +: tl =>\n    val res = subseqs(tl)\n    Seq(hd) :: res ++ res.map(hd +: _)\n  case Seq() => Nil\n}\n```\n\n\nThe result is a ```\nList```\n of n^2 - 1 possible sub-sequences. So for a collection of 8 elements you'll get 255 sub-sequences.\n\nThis, of course, is going to be way too tedious and inefficient for your purposes. Generating all possible sub-sequences in order to find the Longest Increasing is a little like washing all the clothes in your neighborhood so you'll have clean socks in the morning.\n\nMuch better to generate only the increasing sub-sequences and find the longest from that set (9 lines of code).\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Solve the Longest Array Subsequence program in C#\r\n                \r\nThe question is already asked in SO:\n\nLongest increasing subsequence\n\nbut the solution is in Python.\n\nHere is my C# version\n\n```\nprivate static int longestSeq(int[] input1)\n            {                \n                int counter = 0;\n                int i = 0;\n                int x = 0;\n                bool flag = true;\n\n                if (input1.Length == 0) return 0;\n                if (input1.Length == 1) return 1;\n\n                while (i != input1.Length-1)\n                {\n                     if (flag)x= input1[i];\n                    int y = input1[i + 1];\n                    if (x < y) { counter++; flag = true; }\n                    else { if (flag) { x = input1[i]; flag = !flag; } }\n                    i++;\n                }\n\n                return counter+1;\n            }\n```\n\n\nBut it is not working for \n\n```\nint[] input1 = new int[] { 0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15 };\n```\n\n\nThe expected output is 6 but I am getting 5.\n\n2 questions\n\na) What is that i am missing?\n\nb) How can I optimize my program\n    ", "Answer": "\r\nI've just invented a superfast ;-) algorithm for at least this case now (it still requires dynamic indexing optimization but it works):\n\nMy algorithm works with a ```\ntolerance/distance```\n that specifies how far a number can be from its sorted index. Based on the image that I drew:\n\n\n\nand it turned out that at least here, the distance of 2 gives us the correnct results (= the numbers that lie closest to their sorted positions). I have to invesitigate it more but it seems do the work.\n\nThere can be two cases (that I can think of) how we find the increasing sequence:\n\n\n1st case - the tolerance is positive. This gives us a result where we get: ```\n0, 2, 6, 9 , 11, 15```\n\n2nd case - the tolerance is negative. This would give us: ```\n0, 4, 6, 9 , 13, 15```\n\n\n\nI saw in the linked question another result like this: ```\n0, 2, 6, 9 , 13, 15```\n but I think it's wrong and inconsistent if you compare it with the two cases and the image because if we take the ```\n2```\n we cannot take the ```\n13```\n later. We had to take the ```\n11```\n like we took the ```\n2```\n at the beginning of the array. Compare ```\n4, 12, 2```\n and ```\n13, 3, 11```\n.\n\nHere's the code:\n\n```\nclass Program\n{\n    static void Main(string[] args)\n    {\n        //int[] seq = new int[] { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 };\n        //int[] seq = new int[] { 0, 8, 4, 2, 12, 10, 6, 14, 1, 9, 5, 7, 3, 11, 15, 13 };\n        //int[] seq = new int[] { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 16, 7, 15, 11 };\n        //int[] seq = new int[] { 3, 1, 2, 5, 4, 8, 6 };\n        int[] seq = new int[] { 6, 3, 4, 8, 10, 5, 7, 1, 9, 2 };\n        var result = longestSeq3(seq);\n    }\n\n    private static List<int> longestSeq3(int[] seq)\n    {\n        int maxDist = 2;\n        List<int> result = new List<int>();\n\n        for (int i = 0; i < seq.Length; i++)\n        {\n            int current = seq[i];\n            int dist = Math.Abs(i - current);\n            if (dist >= 0 && dist <= maxDist)\n            {\n                if (result.Count > 0 && current <= result.Last())\n                {\n                    continue;\n                }\n                result.Add(current);\n            }\n        }\n\n        return result;\n    }\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest subsequence with alternating increasing and decreasing values\r\n                \r\nGiven an array , we need to find the length of longest sub-sequence with alternating increasing and decreasing values.\n\nFor example , if the array is , \n```\n7 4 8 9 3 5 2 1```\n then the ```\nL = 6```\n for ```\n7,4,8,3,5,2```\n or ```\n7,4,9,3,5,1```\n , etc.\n\nIt could also be the case that first we have small then big element. \n\nWhat could be the most efficient solution for this ? I had a DP solution in mind. And if we were to do it using brute force how would we do it (O(n^3) ?) ?\n\nAnd it's not a homework problem.\n    ", "Answer": "\r\nYou indeed can use dynamic programming approach here. For sake of simplicity , assume we need to find only the maximal length of such sequence seq (it will be easy to tweak solution to find the sequence itself).\n\nFor each index we will store 2 values: \n\n\nmaximal length of alternating sequence ending at that element where last step was increasing (say, incr[i])\nmaximal length of alternating sequence ending at that element where last step was decreasing (say, decr[i])\n\n\nalso by definition we assume ```\nincr[0] = decr[0] = 1```\n\n\nthen each incr[i] can be found recursively:\n\n```\nincr[i] = max(decr[j])+1, where j < i and seq[j] < seq[i]\ndecr[i] = max(incr[j])+1, where j < i and seq[j] > seq[i]\n```\n\n\nRequired length of the sequence will be the maximum value in both arrays, complexity of this approach is O(N*N) and it requires 2N of extra memory (where N is the length of initial sequence)\n\nsimple example in c:\n\n```\nint seq[N]; // initial sequence\nint incr[N], decr[N];\n\n... // Init sequences, fill incr and decr with 1's as initial values\n\nfor (int i = 1; i < N; ++i){\n    for (int j = 0; j < i; ++j){\n         if (seq[j] < seq[i]) \n         {\n             // handle \"increasing\" step - need to check previous \"decreasing\" value\n             if (decr[j]+1 > incr[i])  incr[i] = decr[j] + 1;\n         }\n         if (seq[j] > seq[i]) \n         {\n             if (incr[j]+1 > decr[i])  decr[i] = incr[j] + 1;\n         }\n    }\n}\n\n... // Now all arrays are filled, iterate over them and find maximum value\n```\n\n\nHow algorithm will work:\n\nstep 0 (initial values):\n\n```\nseq  = 7   4 8 9 3 5 2 1\nincr = 1   1 1 1 1 1 1 1\ndecr = 1   1 1 1 1 1 1 1\n```\n\n\nstep 1 take value at index 1 ('4') and check previous values. 7 > 4 so we make \"decreasing step from index 0 to index 1, new sequence values:\n\n```\nincr = 1 1   1 1 1 1 1 1\ndecr = 1 2   1 1 1 1 1 1\n```\n\n\nstep 2. take value 8 and iterate over previous value:\n\n7 < 8, make increasing step: incr[2] = MAX(incr[2], decr[0]+1):\n\n```\nincr = 1 1 2   1 1 1 1 1\ndecr = 1 2 1   1 1 1 1 1\n```\n\n\n4 < 8, make increasing step: incr[2] = MAX(incr[2], decr[1]+1):\n\n```\nincr = 1 1 3   1 1 1 1 1\ndecr = 1 2 1   1 1 1 1 1\n```\n\n\netc...\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How do you check if one array is a subsequence of another?\r\n                \r\nI'm looking to explore different algorithms, both recursive and dynamic programming, that checks if one arrayA is a subsequence of arrayB. For example,\n\n```\narrayA = [1, 2, 3] \narrayB = [5, 6, 1, 7, 2, 9, 3]\n\nthus, arrayA is indeed a subsequence of arrayB. \n```\n\n\nI've tried a few different searches, but all I can seem to find is algorithms to compute the longest increasing subsequence. \n    ", "Answer": "\r\nSince you must match all elements of ```\narrayA```\n to some elements of ```\narrayB```\n, you never need to backtrack. In other words, if there are two candidates in ```\narrayB```\n to match an element of ```\narrayA```\n, you can pick the earliest one, and never retract the choice.\n\nTherefore, you do not need DP, because a straightforward linear greedy strategy will work:\n\n```\nbool isSubsequence(int[] arrayA, int[] arrayB) {\n    int startIndexB = 0;\n    foreach (int n in arrayA) {\n        int next = indexOf(arrayB, startIndexB , n);\n        if (next == NOT_FOUND) {\n            return false;\n        }\n        startIndexB = next+1;\n    }\n    return true;\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "what is the method equivalent to push_back (C++) in java?\r\n                \r\n\n  The problem : Longest Increasing Subsequence\n  \n  // input : int[] a = {3,2,6,4,5,1};\n\n\n```\nvector<vector<int>> l(a.size());\n\nl[0].push_back(a[0]);\n\nfor(int i = 1 ; i < a.size() ;i++){\n    for(int j = 0 ; j < i ;++){\n        if(a[i] > a[j] && l[i].size() < l[j].size()+1){\n             l[i] = l[j];\n        }\n    }   \n    l[i].push_back(a[i]); \n }\n```\n\n\n\n\n  i want print this output : \n\n\n```\n 3\n```\n\n\n\n```\n 2 6 \n```\n\n\n\n```\n 2 4  \n```\n\n\n\n```\n 2 4 5 \n```\n\n\n\n```\n 1\n```\n\n\n\n```\n //Thanks so much for Helping\n```\n\n\n\n    ", "Answer": "\r\nAnswering the question in the title line: If you use ```\njava.util.Vector<E>```\n, then it is ```\naddElement```\n.  Those would be the closest-match class and method in Java to the C++ template classes that you mentioned in your question.\n\nDocs are here: https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html#addElement-E-\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Returning list.append() throws \"TypeError: unsupported operand type(s)\" in recursive function\r\n                \r\nI try to write a recursive function to return the longest increasing subsequence, but error occur says \"```\nTypeError: unsupported operand type(s) for +: 'NoneType' and 'NoneType'```\n\"\n\n```\ndef helper(cur_seq, seq, cur_i, result):\n    if len(seq) == cur_i:\n        return result.append(cur_seq)\n    else:\n        next_i = cur_i + 1\n        if len(cur_seq) == 0 or seq[cur_i] > cur_seq[-1]:\n            temp = cur_seq.copy()\n            temp1 = cur_seq.copy()\n            temp.append(seq[cur_i])\n            return helper(temp, seq, next_i, result) + helper(temp1, seq, next_i, result)\n        else:\n            return helper(cur_seq.copy(), seq, next_i, result)\n\n\ndef longest_sub_sequence(seq):\n    cur_seq = []\n\n    result = helper(cur_seq, seq, 0, [])\n\n    max_length = 0\n    for i in result:\n        if len(i) > max_length:\n            max_length = len(i)\n\n\n    return max_length\n\n\nif __name__ == \"__main__\":\n\n    seq = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n    y = longest_sub_sequence(seq)\n    print(y)\n```\n\n    ", "Answer": "\r\n```\nlist.append```\n is an in-place operation. For example,\n\n```\nl = [1, 2, 3]\nresult = l.append(4)\n\nprint(result)\n# None\n\nprint(l)\n# [1, 2, 3, 4]\n```\n\n\n```\nappend```\n returns ```\nNone```\n, modifying ```\nl```\n in-place. This means that ```\nreturn result.append(cur_seq)```\n in your function will return ```\nNone```\n, and the two recursive calls result in ```\nNone + None```\n which gives you the ```\nTypeError```\n.\n\nThe fix would be to append first, return later.\n\n```\ndef helper(cur_seq, seq, cur_i, result):\n    if len(seq) == cur_i:\n        result.append(cur_seq)\n        return result\n    ...\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "LIS - Longest Increasing Subsequence Algorithm in PHP O(nlogn)\r\n                \r\nI can't find anywhere solutions for my problem :(.\nCan someone help me and find (or write) this algorithm with comments? \nI can't do it myself. I spent on it at least 3 hours and nothing.\n\nBIG Thank you!\n    ", "Answer": "\r\nKeeps a vector 'v[x] = y' where y is the smallest element of the original sequence that gives the longest increasing subsequence of length x. Originally you only have ```\nv[0] = -inf```\n.\n\nTraverse the sequence for an element ```\na```\n, look it up in the vector ```\nv```\n using binary search. You will not find ```\na```\n exactly, but the largest ```\nx```\n such that ```\nv[x] <= a```\n (< if it is strictly increasing). So the longest increasing subsequence that ends at a will be of length ```\nx+1```\n. Now update ```\nv[x+1]```\n to be a (it can't be smaller than a, otherwise your search should have return ```\nx+1```\n), you may need to extend the vector.\n\nThe length of the LIS is the size of the vector. Keep track of which positions you used if you need to reconstruct the solution.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to use LIS to solve 10635 uva\r\n                \r\nHow to do the reduction from Longest Common Subsequence to O(nlog n) Longest Increasing Subsequence for the problem 10635 uva. I need some help regarding the logic to be applied to solve the problem.\n    ", "Answer": "\r\nFor each step of the route of one of the two characters(let's say the princess), assign the number of this step in the sequence of the prince.\n\nFirst observation - all the steps not present in the prince's sequence are immediately removed - they can not be part of the common sequence of moves. \n\nNow we have a sequence of numbers representing the index in the sequence of moves of the prince. We should choose an increasing subsequence(increasing because we should visit the cells in the same order as the prince) of maximal length of that sequence. Ringing any bells?\n\nHope this helps.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Is this Longest Common Subsequence Correct?\r\n                \r\nI just wrote this implementation to find out the length of the longest increasing subsequence using dynamic programming. So for input as [10, 22, 9, 33, 21, 50, 41, 60, 80] the LIS is 6 and one of the set is [10, 22, 33, 50, 60, 80].\n\nWhen I run the below code I get the correct answer as 6 with O(n) complexity. Is it correct? \n\n```\ndef lis(a):\n    dp_lis     = []\n    curr_index = 0\n    prev_index = 0\n\n    for i in range(len(a)):\n        prev_index = curr_index\n        curr_index = i\n\n        print 'if: %d < %d and %d < %d' % (prev_index, curr_index, a[prev_index], a[curr_index])\n        if prev_index < curr_index and a[prev_index] < a[curr_index]:\n            print '\\tadd ELEMENT: ', a[curr_index]\n            new_lis = 1 + max(dp_lis)\n            dp_lis.append(new_lis)\n        else:\n            print '\\telse ELEMENT: ', a[curr_index]\n            dp_lis.append(1)\n\n    print \"DP LIST: \", dp_lis\n    return max(dp_lis)\n\nif __name__ == '__main__':\n    a = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n    print lis(a)\n```\n\n    ", "Answer": "\r\nUse this correct, proven but inefficient implementation of the algorithm to check against your results - it's the standard recursive solution, it doesn't use dynamic programming:\n\n```\ndef lis(nums):\n    def max_length(i):\n        if i == -1:\n            return 0\n        maxLen, curLen = 0, 0\n        for j in xrange(i-1, -1, -1):\n            if nums[j] < nums[i]:\n                curLen = max_length(j)\n                if curLen > maxLen:\n                    maxLen = curLen\n        return 1 + maxLen\n    if not nums:\n        return 0\n    return max(max_length(x) for x in xrange(len(nums)))\n```\n\n\nCheck to see if ```\nyour_lis(nums) == my_lis(nums)```\n for as many different-sized input lists with numbers as possible, they should be equal. At some point, for long lists my implementation will be far slower than yours.\n\nAs a further comparison point, here's my own optimized dynamic programming solution. It runs in ```\nO(n log k)```\n time and ```\nO(n)```\n space, returning the actual longest increasing subsequences it finds along the way:\n\n```\ndef an_lis(nums):\n    table, lis = lis_table(nums), []\n    for i in xrange(len(table)):\n        lis.append(nums[table[i]])\n    return lis\n\ndef lis_table(nums):\n    if not nums:\n        return []\n    table, preds = [0], [0] * len(nums)\n    for i in xrange(1, len(nums)):\n        if nums[table[-1]] < nums[i]:\n            preds[i] = table[-1]\n            table.append(i)\n            continue\n        minIdx, maxIdx = 0, len(table)-1\n        while minIdx < maxIdx:\n            mid = (minIdx + maxIdx) / 2\n            if nums[table[mid]] < nums[i]:\n                minIdx = mid + 1\n            else:\n                maxIdx = mid\n        if nums[i] < nums[table[minIdx]]:\n            if minIdx > 0:\n                preds[i] = table[minIdx-1]\n            table[minIdx] = i\n    current, i = table[-1], len(table)\n    while i:\n        i -= 1\n        table[i], current = current, preds[current]\n    return table\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "the system cannot find the file specified c++\r\n                \r\nEhab has an array a of length n. He has just enough free time to make a new array consisting of n copies of the old array, written back-to-back. What will be the length of the new array's longest increasing subsequence?\n\nA sequence a is a subsequence of an array b if a can be obtained from b by deletion of several (possibly, zero or all) elements. The longest increasing subsequence of an array is the longest subsequence such that its elements are ordered in strictly increasing order.\n\nheres my answer, I keep getting \"the system cannot find the file specified\" \nwhats wrong?\n\n\n\n```\n#include <algorithm>\n#include <iostream>\n    using namespace std;\n    int main(){\n        int t, n;\n        cin >> t;\n\n        while(t != 0){\n            cin >> n;\n            int* a = new int [n];\n            cin >> a[0];\n            int min = a[0];\n\n            for (int i = 1 ; i < n ; i++){\n                cin >> a [i];\n                if (min > a[i])\n                    min = a[i];\n            }\n\n            int* b = new int [n*n];\n            for (int i = 0 ; i < n*n ; i++)\n                copy(a[0], b[n-1], b[i*n]);\n\n            int num = 0;\n            for (int i = 0 ; i < n*n ; i++)\n                if (b[i] == min){\n                    for (int j = i+1 ; j < n*n ; j++){\n                        if (b[j] > b[i]){\n                            num++;\n                            j = i;\n                        }\n                    break;\n                    }\n                }\n            cout << num << endl;\n            t--;\n        }\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How does complexity get reduced to O(n^2) from O(2^n) in case of memoization?\r\n                \r\nI am currently learning dynamic programming via memoization and tabularization technique. With reference to following link,(Longest increasing sequence problem), I didn't understand how the complexity is reduced to O(n^2) from O(2^n) when we memoize?\n\nhttps://leetcode.com/problems/longest-increasing-subsequence/solution/\n    ", "Answer": "\r\nWhen memoizing a function, you make a note each time you call that function of a) the parameters and b) the result. Then next when you want to call the function again, you check in your notes whether you've called that function before with the parameters you want to use this time. If you have, you don't need to call the function again, because you already have the result. This way the function is called only as many times as you have distinct parameters: if you want to call it with parameters you've used already, you save having to call it.\n\nThis approach works well where a) the function is deterministic, i.e. returns the same value each time it is called with the same paramters, and b) the function is expensive compared to the cost of memoization.\n\nThe example you cite says this:\n\n\n  In the previous approach, many recursive calls had to made again and again with the same parameters. This redundancy can be eliminated by storing the results obtained for a particular call in a 2-d memorization array \n\n\nHere the function in question is called O(2n) times, but with only O(n2) different sets of parameters. Using memoization, the function is called once only for each different parameter set (O(n2)) rather than each time the algorithm needs the answer (O(2n)).\n\nHere is a reference which may help.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Finding continuous subsequence that minimizes the average of the rest of the array?\r\n                \r\nSuppose there's an integer array ```\narr[0..n-1]```\n. Find a subsequence ```\nsub[i..j]```\n (i > 0 and j < n - 1) such that the rest of the array has the smallest average. \n\nExample:\n\n```\narr[5] = {5,1,7,8,2};\n```\n\n\nRemove ```\n{7,8}```\n, the array becomes ```\n{5, 1, 2}```\n which has average 2.67 (smallest possible). \n\nI thought this is a modification of the Longest Increasing Subsequence but couldn't figure it out.\n\nThanks,\n    ", "Answer": "\r\nLet's find the average value using binary search.\n\nSuppose, that sum of all elements is S.\n\nFor given x let's check if exist i and j such that avg of all elements except from i to j less or equal to x.\n\nTo do that, let's subtract x from all elements in arr. We need to check if exists i and j such that sum of all elements except from i to j less or equal to zero. To do that, lets find sum of all elements in current array: S' = S - x * n. So we want to find i and j such that sum from i to j will be greater or equal than S'. To do that, let's find subarray with the larges sum. And this can be done using elegant Jay Kadane's algorithm: https://en.wikipedia.org/wiki/Maximum_subarray_problem\n\nWhen to terminate binary search? When the maximum subarray sum will be zero (or close enough).\n\nTime complexity: O(n log w), w - presicion of the binary search.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Divide and Conquer algorithm for Longest Increasing Consecutive sequence in an array\r\n                \r\nCan anyone help me out with this problem that I have been trying to solve for a while.\n\nLets say there is an array A[1,2...n] of numbers and we wish to find the longest increasing consecutive sub sequence with Divide an Conquer method. Specifically we wish to find indices i,j such that i<=j and A[i]<=A[i+1]<=.....A[j]. For Example if the array has 4,1,3,5,6,7,5,8,2 then it has to return [1,3,5,6,7]. \n\nI have searched a lot about this problem but all I can find is dynamic approach and Longest Increasing Subsequences without consecutive elements.    \n    ", "Answer": "\r\nHow about this:\n\n\nDivide array A to A1 and A2.\nFind the longest consecutive sub sequence of sub array A1 and A2, named as s1, s2 respectively. \nIf the longest consecutive sub sequence cross A1 and A2, the consecutive sub sequence must use the last of A1 and first of A2, named as s3.\nCompare s1, s2, s3, find the longest one.\nIn step 2, it needs divide sub arrays constantly. And step 3 and 4 are conquer process.\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find the LIS with the maximum sum\r\n                \r\nI have this code for finding the Longest Increasing Subsequence (LIS) but when i test my code I dont get maximum sum, for example:\n\nif I type 20 1 4 3 10 the answer is 1 3 10, but i need 1 4 10\nThis is my code in C:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\n#define INT_INF 1000\n\nint search_replace(int *lis, int left, int right, int key) {\n    int mid;\n\n    for (mid = (left+right)/2; left <= right; mid = (left+right)/2) {\n            if (lis[mid] > key) {\n                    right = mid - 1;\n            } else if (lis[mid] == key) {\n                    return mid;\n            } else if (mid+1 <= right && lis[mid+1] >= key) {\n                    lis[mid+1] = key;\n                    return mid+1;\n            } else {\n                    left = mid + 1;\n            }\n    }\n    if (mid == left) {\n            lis[mid] = key;\n            return mid;\n    }\n    lis[mid+1] = key;\n    return mid+1;\n}\n\nint main() {\n    int size, i;\n\n    scanf(\" %d\", &size);\n\n    int A[size];\n\n    for(i = 0; i < size; i++){\n        scanf(\" %d\", &A[i]);\n    }\n\n    int tmp, lis_length = -1;\n    int *answer;\n    int LIS[size];\n    int index[size];\n\n    LIS[0] = A[0];\n    for (i = 1; i < size; ++i) {\n            LIS[i] = INT_INF;\n    }\n\n    for (i = 1; i < size; ++i) {\n            index[i] = search_replace(LIS, 0, i, A[i]);\n            if (lis_length < index[i]) {\n                    lis_length = index[i];\n            }\n    }\n\n    answer = (int*) malloc((lis_length+1) * sizeof(int));\n    for (i = size-1, tmp = lis_length; i >= 0; --i) {\n            if (index[i] == tmp) {\n                    answer[tmp] = A[i];\n                    --tmp;\n            }\n    }\n\n    printf(\"LIS: \");\n    for (i = 0; i < lis_length+1; ++i) {\n            printf(\"%d \", answer[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n\n\nfirst input is for number of elements in array.\n\nI aleready tried with this post: Find the Longest Increasing Subsequence with the Maximum Sum , and few others but no success.\n    ", "Answer": "\r\nI have analyzed your code and found your problem: you don't have code for finding the lis with maximum sum, you have the simple lis searching only. I have added the missing part and now, the code is working as it should. Also, I wrote my own solution, with another lis searching algorithm and without the binary search.\nNote: the ```\n(left+right)/2```\n method for finding the middle value, have a problem - Nearly All Binary Searches and Mergesorts are Broken .\nYour code with my addition:\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define INT_INF 1000\n\nint search_replace(int *lis, int left, int right, int key) {\n    int mid;\n    for (mid = (left+right)/2; left <= right; mid = (left+right)/2) {\n        if (lis[mid] > key) {\n            right = mid - 1;\n        } else if (lis[mid] == key) {\n            return mid;\n        } else if (mid+1 <= right && lis[mid+1] >= key) {\n            lis[mid+1] = key;\n            return mid+1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    if (mid == left) {\n        lis[mid] = key;\n        return mid;\n    }\n    lis[mid+1] = key;\n    return mid+1;\n}\n\nint main() {\n    int size, i;\n\n    scanf(\" %d\", &size);\n\n    int A[size];\n\n    for(i = 0; i < size; i++){\n        scanf(\" %d\", &A[i]);\n    }\n\n    int tmp, lis_length = -1;\n    int LIS[size];\n    int index[size];\n\n    LIS[0] = A[0];\n    for (i = 1; i < size; ++i) {\n        LIS[i] = INT_INF;\n    }\n\n    for (i = 1; i < size; ++i) {\n        index[i] = search_replace(LIS, 0, i, A[i]);\n        if (lis_length < index[i]) {\n            lis_length = index[i];\n        }\n    }\n    \n    //////// my addition starts\n    int max, j;\n    // INT_MAX - the maximum number of the integer type.\n    // The \"limits.h\" header is needed for this.\n    int prev = INT_MAX;\n    int answer[lis_length + 1];\n    // Iterating through the \"index\" values.\n    // On the each iteration, the checking all sequences \n    // with the same length\n    // and determining the max value among them.\n    // Starts from the lis_length and goes to the zero.\n    for(i = lis_length; i >= 0; i--) {\n        max = INT_MIN;\n        for(j = 0; j < size; j++) {\n            if(    index[j] == i \n                && A[j] > max \n                && A[j] < prev) {\n                    \n                max = A[j];\n            }\n        }\n        answer[i] = max;\n        prev = max;\n    }\n    //////// my addition ends\n\n    printf(\"LIS: \");\n    for (i = 0; i < lis_length+1; ++i) {\n        printf(\"%d \", answer[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n\n\nThis is my solution with comments.\nI used this algorithm for the lis determination. Ask questions, if you need.\n```\n#include <stdio.h>\n#include <limits.h>\n\nint main() {\n    int size = 0;\n    int arr_nums[100];\n    // Initialize all array values to the one. This is the GCC feature.\n    int seq_lens[100] = {[0 ... 99] = 1};\n\n    // Gets input numbers.\n    while(scanf(\"%d\", arr_nums + size) == 1) {\n        size++;\n    }\n    // Fill the seq_lens array with sequences's lenghts.\n    int i, j;\n    int lis_num = 1;\n    for(i = 1; i < size; i++) {\n        for(j = 0; j <= i; j++) {\n            if(     arr_nums[i] > arr_nums[j] \n                && (seq_lens[j] + 1 > seq_lens[i])) {\n\n                    seq_lens[i] = seq_lens[j] + 1;\n            }\n        }\n        // Finding the LIS number (the maximum sequence length).\n        // If the previous LIS number is lesser then current, \n        // change it to the current.\n        if(lis_num < seq_lens[i])\n            lis_num = seq_lens[i];\n    }\n\n    // Finding the LIS with the maximum sum\n    int max;\n    // INT_MAX - the maximum number of the integer type.\n    // The \"limits.h\" header is needed for this.\n    int prev = INT_MAX;\n    int lis_arr[lis_num];\n    // Iterating through the seq_lens values.\n    // On the each iteration, the checking all sequences with the same length\n    // and determining the max value among them.\n    // Starts from the LIS (the longest sequence number) \n    // and goes to the one (the minimum possible sequence number).\n    for(i = lis_num; i > 0; i--) {\n        max = INT_MIN;\n        for(j = 0; j < size; j++) {\n            if(    seq_lens[j] == i \n                && arr_nums[j] > max \n                && arr_nums[j] < prev) {\n                    \n                max = arr_nums[j];\n            }\n        }\n        lis_arr[i - 1] = max;\n        prev = max;\n    }\n\n    printf(\"The longest increasing sequence number is:\\n%d\\n\", lis_num);\n\n    puts(\"\\nThe longest increasing sequence with the max sum is: \");\n    for(i = 0; i < lis_num; i++) {\n        printf(\"%d \", lis_arr[i]);\n    }\n    puts(\"\");\n\n    return 0;\n}\n```\n\nInput\n```\n0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15\n```\n\nOutput\n```\nThe longest increasing sequence number is:\n6\n\nThe longest increasing sequence with the max sum is: \n0 4 6 9 13 15 \n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Can dynamic programming problems always be represented as DAG\r\n                \r\nI am trying to draw a DAG for Longest Increasing Subsequence {3,2,6,4,5,1} but cannot break this into a DAG structure.\n\nIs it possible to represent this in a tree like structure? \n    ", "Answer": "\r\nAs far as I know, the answer to the actual question in the title is, \"No, not all DP programs can be reduced to DAGs.\"\n\nReducing a DP to a DAG is one of my favorite tricks, and when it works, it often gives me key insights into the problem, so I find it always worth trying.  But I have encountered some that seem to require at least hypergraphs, and this paper and related research seems to bear that out.  \n\nThis might be an appropriate question for the CS Stack Exchange, meaning the abstract question about graph reduction, not the specific question about longest increasing subsequence.  \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "c++ - Multiple conditions in for loop getting incorrect result\r\n                \r\nGiven an array ```\nA = [10,9,2,5,3,7,101,18]```\n I am populating another array ```\nB```\n of same length such that ```\nB[i]```\n is longest increasing sub sequence containing ```\nA[i]```\n of subarray ```\nA[0,i]```\n (Please refer Longest Increasing Subsequence : https://leetcode.com/problems/longest-increasing-subsequence/ )\nFor this I am using following loop\n```\nfor(int i = 1; i < A.size(); i++) { \n    int curr_lis = 1;\n    for (int j = 0; j < i; j++)\n        if (A[j] < A[i])\n            curr_lis = max(curr_lis, B[j] + 1); \n    \n    B[i] = curr_lis;\n}\n```\n\nThis logic correctly populates array B = [1 1 1 2 2 3 4 4 1]\nBut if I try to merge inner condition with the for-loop condition i.e. ```\n(j < i) && (a[j] < a[i])```\n as shown below\n```\nfor(int i = 1; i < A.size(); i++) { \n    int curr_lis = 1;\n    for(int j = 0; (j < i) && (A[j] < A[i]); j++)\n        curr_lis = max(curr_lis, B[j] + 1); \n    \n    B[i] = curr_lis;\n}\n```\n\nthen the array B gets incorrectly populated to ```\nB = [1 1 1 1 1 1 2 2 1]```\n\nI think I am doing something silly in merging the conditions in for-loop, can someone please help to understand the issue ?\n    ", "Answer": "\r\nOk, first example will work for each ```\nj```\n value and find the maximum value. Second will stop the first time you hit ```\nA[j] < A[i]```\n. So what if you have situation like ```\nA[i] = 5```\n and ```\nA[j] = 5```\n, but down the road ```\nA[j+1] = 6```\n, ```\nA[j+2] = 7```\n ... ```\nA[j+100]=1000```\n. Your second loop will say I found maximum its ```\n5```\n, go on and increment ```\ni```\n. No A[i] = 6, but ```\nj```\n will not go to ```\n6```\n because of the clause ```\nj < i```\n.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to implement lexicographical order string converter (Longest Increasing Subsequence)?\r\n                \r\nI was recently taking part in some kind of online test from java language.\n\nIn one of question, I was asked to implement a function, that given a string will return a minimal number of characters that must be removed from the string to get new lexicographical ordered string.\n\nThat mean, when we pass string \"banana\" to our method, it will return 3. \n\nFrom word \"banana\" we need to remove 1st letter (\"b\"), 3rd letter(\"n\") and 6th letter (\"a\"), to get string \"aan\". \n\nThere is no possibility to remove fewer letters.\n\nI was trying to figure the solution out for quite a long time but without any effect. \n\nOne thing that could work would be checking every possible sub-string from our original string, checking if it is ordered and comparing the number of removed digits but it would be terrible for longer strings.\n\nAny ideas for algorithm?\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Why can I not solve the Longest increasing subsequence by simply sorting the sequence?\r\n                \r\nhttp://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms says that the most efficient solution is in O(n log n), hence if I sort the sequence, it will be O(n log n) and then if I iterate through the sorted sequence, rejecting each item that is not increasing, it will be O(n), hence the algorithm would be in O(n log n + n) which is ~ O(n log n)...\n    ", "Answer": "\r\nSorting the sequence would change the order of items in the original sequence, and your approach would always return a shortest sequence of the same length as the original total sequence.  Se Mehrdad's comment.\n\nFrom your link:\n\nIn the binary Van der Corput sequence\n\n0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15, …\n\na longest increasing subsequence is\n\n0, 2, 6, 9, 13, 15.\n\nNow let's apply your algorithim:\n\nSorted the original sequence becomes:\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n\nThe longest increasing subsequnce here is:\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Need to understand answer of algorithm\r\n                \r\nI am trying to solve above Longest Monotonically Increasing Subsequence problem using javascript. In order to do that, I need to know about Longest Monotonically Subsequence. Current I am following wikipedia article. The thing I am not understanding this example is that the longest increasing subsequence is given as ```\n0, 2, 6, 9, 13, 15```\n from ```\n0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15, …```\n list. The question is Why the answer does not have 3 in between 2 and 6, and 8 between 6 and 9 etc? How does that answer come from that list?\n    ", "Answer": "\r\nIst of all , consider the name \"Longest Monotonically Increasing Subsequence\" . So , from the given array you need to figure out the largest sequence where the numbers should be appeared in a strictly increasing fashion. There can be many sequence, where the sub array can be strictly increasing but you need to find the largest sub-Array. \n\nSo. lets debug this array. a[] = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15} \n\nIn here the some monotonously increasing sub-arrays are :\n\n{0,8,12,14,15} Length = 5\n\n{0,4,12,14,15} Length = 5\n\n{0,1,9,13,15} Length = 5 and so on.\n\nBut if you calculate like this , you can find the largest sub-array will be :\n\n{0, 2, 6, 9, 13, 15} , Length = 6, so this is the answer.\n\nEvery single little time you pick any number , the next number should be large than the previous one and must be present in the array. say  {0, 2, 6, 9, 13, 15} this list, when you pick 9 , then the next number should be larger than 9. the immediate sequence shows 13>9, so you can pick 13. You can also pick 11. But that will create another branch of sub-array. Like :\n{0, 2, 6, 9, 11, 15} which is another solution.\n\nHope this explanation will help you to understand the LIS (Longest Increasing Subsequence).Thanks.  \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find out multiple nonintersecting increasing sequences in an array of maximal combined length\r\n                \r\nThere is a known problem \"Longest increasing subsequence\", which is: Given an array of integers, find out the longest increasing sequence in that array. I now face a similar but apparently more complicated problem: Given an array of integers and a given number N, find N sequences in that array so that each of them is increasing, they do not intersect by indexes and their combined sum of lengths is maximal.\n\nSo far I have tried \"greedy\" algorithms in the line of:\n\n\nUse the longest increasing subsequence algorithm, throw that sequence away from the array, repeat N times, provide found sequences as result. This works if N=1 by design, works in several odd cases but returns incorrect results for shuffled arrays such as an array constructed of N increasing subsequences.\nConstruct a number of sequences, adding each element to the now-longest possible subsequence. Obviously flawed, as it finds \"substrings\" more often than prolonged sequences.\nConstruct a number of sequences, adding each element to the sequence that has the largest last element. This works better, at least if an array is known to contain N increasing subsequences, this algorithm correctly returns full array as the result, but it does not work properly in general, as it does not consume N as is.\n\n\nAny other ideas?\n\nIf you want to play with sample data of decent size, here's an array:\n\n```\n103,202,234,260,301,324,356,379,405,412,421,284,137,439,315,150,322,454,185,335,481,208,495,223,358,258,522,267,365,526,\n536,374,399,566,580,424,302,602,335,365,618,441,380,455,397,483,510,410,419,622,529,534,633,442,544,568,653,668,474,502,\n689,583,607,694,699,530,618,648,654,555,705,723,563,738,672,595,746,697,766,720,624,740,794,798,818,845,859,653,752,758,\n783,674,793,805,876,831,892,918,929,689,865,950,874,966,997,716,738,899,759,1023,1032,917,1053,938,944,1080,771,797,\n960,1089,980,815,839,850,1110,1011,1115,861,878,1143,901,1025,931,1175,1192,1197,1050,1229,959,988,1058,1008,1038,1088,\n1116,1126,1135,1063,1256,1269,1082,1275,1088,1305,1122,1154,1157,1326,1184,1350,1184,1205,1236,1268,1293,1324,1373,1347,\n1365,1217,1400,1240,1261,1414,1381,1406,1413,1443,1282,1451,1456,1442,1476,1485,1475,1488,1499,1510,1508,1316,1325,1338,\n1540,1536,1353,1556,1558,1588,1363,1587,1617,1382,1625,1402,1609,1415,1633,1642,1655,1671,1689,1697,1439,1712,1458,1732,\n1481,1693,1510,1747,1715,1762,1730,1791,1820,1522,1539,1748,1759,1566,1577,1584,1611,1646,1834,1790,1653,1820,1659,1833,\n1693,1842,1704,1717,1846,1868,1729,1744,1773,1882,1796,1915,1937,1814,1861,1846,1941,1871,1905,1893,1931,1945,1917,\n1960,1979,1941,1960,1980,1933,1962,2014,2046,1975,1988,2008,1988,2040,1995,2062,2000,2009,2025,2083,2058,2067,2083,2103,\n2038,2114,2121,2134,2063,2166,2115,2124,2178,2202,2135,2090,2104\n```\n\n\nThis is an array constructed of 3 randomized increasing subsequences with overlapping ranges, each having a length of 100, so processing this array with a proper algorithm with N=3 should return full array, with N=1 the answer should be 123, and for N=2, no less than 222. (True value yet undetermined)\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "LLVM ERROR: out of memory ?? How to fix this error (if its fixable)\r\n                \r\nOkay I am Solving https://leetcode.com/problems/longest-increasing-subsequence/\nMy code is Correct and runs fine without memonization(TLE), but after memonized it gives error :\n```\nLLVM ERROR: out of memory\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace, preprocessed source, and associated run script.\n```\n\nMy code:\n```\nclass Solution {\npublic:\n    int dp[2555][25000005];\n    int fun(vector<int>& a, vector<int>& v, int i, int count) {\n        int n = a.size();\n        if(i == n) return count;\n        if(dp[i][count] != -1) return dp[i][count];\n        \n        if(v.back() < a[i]) {\n            v.push_back(a[i]);\n            int val1 = fun(a, v, i+1, count+1);\n            v.pop_back();\n            int val2 = fun(a,v,i+1,count);\n            return  max(val1, val2);\n        }\n        else\n            return fun(a,v,i+1,count);\n    }\n    int lengthOfLIS(vector<int>& a) {\n        vector<int> v;\n        v.push_back(INT_MIN);\n        memset(dp, -1, sizeof(dp));\n        return fun(a, v, 0, 0);\n    }\n};\n```\n\n    ", "Answer": "\r\nYour ```\nint dp[2555][25000005];```\n array is probably way too large for your stack as it is approximately ```\n2555*25000005*4=```\n255 GB (if an int is 4 bytes). If you have enough memory (physical and pageable) you can simply allocate all that memory on the heap by using ```\nmalloc()/free()```\n or an STL container like ```\nstd::vector```\n. Otherwise, you should probably try to make your program allocate less memory by changing your algorithm.\nFor further information on the stack/heap and memory and general you can look that this previous question What and where are the stack and heap?.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Extracting the subsequence of maximum length from a sequence [PYTHON] [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Longest increasing unique subsequence\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 6 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have a sequence of values [1,2,3,4,1,5,1,6,7], and I have to find the longest subsequence of increasing length. However, the function needs to stop counting once it reaches a number lower than the previous one. The answer in this sequence in that case is [1,2,3,4]. As it has 4 values before being reset. How would I write the Python code for this?\n\nNote: Finding the \"longest increasing subsequence\" seems to be a common challenge and so searching online I find a lot of solutions that would count for the entire length of the sequence, and return a subsequence of increasing values, ignoring any decrease, so in this case it would return [1,2,3,4,5,6,7]. That is not what I'm looking for. \n\nIt needs to count each subsequence, and reset the count upon reaching a number lower than the previous one. It then needs to compare all the subsequences counted, and return the longest one.\n\nThanks in advance.\n    ", "Answer": "\r\nConsider a function that generates all possible ascending subsequences, you would start with an empty list, add items until one element was less (or equal to?) the the previous at which point you save (```\nyield```\n) the subsequence and restart with a new subsequence.  \n\nOne implementation using a generator could be this:\n\n```\ndef all_ascending_subsequences(sequence):\n    #use an iterator so we can pull out the first element without slicing\n    seq = iter(sequence)\n\n    try: #NOTE 1\n        last = next(seq)  # grab the first element from the sequence\n    except StopIteration: # or if there are none just return\n        #yield [] #NOTE 2\n        return\n\n    sub = [last]\n    for value in seq:\n        if value > last: #or check if their difference is exactly 1 etc.\n            sub.append(value)\n        else: #end of the subsequence, yield it and reset sub\n            yield sub\n            sub = [value]\n        last = value\n\n    #after the loop we send the final subsequence\n    yield sub\n```\n\n\ntwo notes about the handling of empty sequences:\n\n\nTo finish a generator a ```\nStopIteration```\n needs to be\nraised so we could just let the one from ```\nnext(seq)```\n propegate out - however when ```\nfrom __future__ import generator_stop```\n is in\neffect it would cause a ```\nRuntimeError```\n so to be future compatible we\nneed to catch it and explicitly ```\nreturn```\n.\nAs I've written it passing an empty list to\n```\nall_ascending_subsequences```\n would generate no values, which may not\nbe the desired behaviour.  Feel free to uncomment the ```\nyield []```\n to\ngenerate an empty list when passed an empty list.\n\n\nThen you can just get the longest by calling ```\nmax```\n on the result with ```\nkey=len```\n\n\n```\nb =  [1,2,3,4,1,5,1,6,7]\n\nresult = max(all_ascending_subsequences(b),key=len)\nprint(\"longest is\", result)\n\n#print(*all_ascending_subsequences(b))\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest sequence that holds a property in Dafny\r\n                \r\nIn Dafny I am trying to make a ```\nMax```\n polymorphic and high-order function that, given a sequence and a predicate, returns the longest subsequence that holds it. For instance, the longest increasing subsequence, or the longest subsequence in which all the elements are zero.\nTo do so, I designed a slow algorithm (given the ```\nP```\n predicate and a ```\nS```\n sequence):\n```\n   1. Start an i pivot in the left and a j pivot in the same place.\n   2. Start the max_sequence = [] and the max_sequence_length = 0.\n   3. While i<S.length:\n        counter = 0 \n        j = i\n        While max_sequence[i..j] satisfies P and j<S.length:\n          If counter > max_sequence_length:\n             max_sequence_length = counter\n             max_sequence = max_sequence[i..j]\n          Increment j\n        Increment i\n   4. Return max_sequence\n```\n\nYou can see it implemented:\n```\nmethod maxPropertySequence<T>(P: seq<T> -> bool, sequ: seq<T>) returns (max_seq: seq<T>)\n\n  {\n    var i := 0;\n    var j := 0;\n    var longest := 0;\n    var the_sgmt := sequ;\n    var fresh_segmnt := sequ;\n    var counter := longest;\n    while i<(|sequ|) \n      decreases |sequ|-i\n    {\n      j := i;\n      counter := 0;\n      fresh_segmnt := [sequ[i]];\n      if P(fresh_segmnt) \n      {\n          j := j+1;\n          counter:=counter+1;\n          if counter>longest {\n            longest:=counter;\n            the_sgmt := fresh_segmnt;\n          }\n          while P(fresh_segmnt) && j<|sequ|\n            decreases |sequ|-j\n          {\n            fresh_segmnt := fresh_segmnt + [sequ[j]];\n            j := j+1;\n            counter:=counter+1;\n            if counter>longest {\n              longest:=counter;\n              the_sgmt := fresh_segmnt;\n            }\n          }\n      }\n      i := i+1;\n    }\n    return the_sgmt;\n      \n  }\n\n\n```\n\nMy question is: how can I verify that the ```\nMax```\n function behaves as I expect? More concretely: which are the ```\nensures```\n I have to add?\nI have thought something like: forall the subsequences of the original sequence, there is no subsequence that holds ```\nP```\n and is longer than ```\nthe_sgmt```\n. But I do not know how to express it efficiently.\nThanks!\n    ", "Answer": "\r\nI wrote code for finding the (leftmost) longest subsequence of zeros from a given integer array. Since you can map ```\nsequ```\n using the predicate, these two are almost identical problems.\n```\n// For a given integer array, let's find the longest subesquence of 0s.\n// sz: size, pos: position.   a[pos..(pos+sz)] will be all zeros\nmethod longestZero(a: array<int>) returns (sz:int, pos:int)   \n    requires 1 <= a.Length\n    ensures 0 <= sz <= a.Length\n    ensures 0 <= pos < a.Length\n    ensures pos + sz <= a.Length\n    ensures forall i:int  :: pos <= i < pos + sz ==> a[i] == 0\n    ensures forall i,j :: (0 <= i < j < a.Length && getSize(i, j) > sz) ==> exists k :: i <= k <= j && a[k] != 0\n{\n    var b := new int[a.Length];   // if b[i] == n, then a[i], a[i-1], ... a[i-n+1] will be all zeros and (i-n ==0 or a[i-n] !=0)\n    if a[0] == 0\n        {b[0] := 1;}\n    else\n        {b[0] := 0;}\n\n    var idx:int := 0;\n    while idx < a.Length - 1    // idx <- 0 to a.Length - 2\n        invariant 0 <= idx <= a.Length - 1\n        invariant forall i:int :: 0 <= i <= idx ==>  0 <= b[i] <= a.Length\n        invariant forall i:int :: 0 <= i <= idx ==> -1 <= i - b[i]\n        invariant forall i:int :: 0 <= i <= idx ==> (forall j:int :: i-b[i] < j <= i ==> a[j] == 0) \n        invariant forall i:int :: 0 <= i <= idx ==> ( 0 <= i - b[i] ==> a[i - b[i]] != 0 )\n    {\n        if a[idx + 1] == 0\n            { b[idx + 1] := b[idx] + 1; }\n        else\n            { b[idx + 1] := 0;}\n\n        idx := idx + 1;\n    }\n\n\n    idx := 1;\n    sz := b[0];\n    pos := 0;\n    // Let's find maximum of array b. That is the desired sz.\n    while idx < a.Length\n        invariant 1 <= idx <= b.Length\n\n        invariant 0 <= sz <= a.Length\n        invariant 0 <= pos < a.Length\n        invariant pos + sz <= a.Length\n\n        invariant forall i:int :: 0 <= i < idx  ==> b[i] <= sz\n        invariant forall i:int  :: pos <= i < pos + sz ==> a[i] == 0\n        invariant forall i, j:int  :: (0 <= i < j < idx && getSize(i,j) > sz) ==>  a[j-b[j]] != 0\n    {\n        // find max\n        if b[idx] > sz \n        { \n            sz := b[idx]; \n            pos := idx - b[idx] + 1;\n        }\n        idx := idx + 1;\n    }\n}\n\n\nfunction getSize(i: int, j:int) : int\n{\n    j - i + 1    \n}\n```\n\nSince I am new to dafny, any comments on style or anything are appreciated.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Incresing Subsequence to solve building bridge\r\n                \r\nI've something that bothers me. I'm trying to solve building bridge problem which have this information as a instruction.\n\n\n  Building Bridges\n  Consider a 2-D map with a horizontal river passing through its center. There are n cities on the southern bank with x-coordinates a(1) ... a(n) and n cities on the northern bank with x-coordinates b(1) ... b(n).\n  You want to connect as many north-south pairs of cities as possible with bridges such that no two bridges cross. When connecting cities, you can only connect city i on the northern bank to city i on the southern bank.\"\n\n\nI did research on Stack Overflow and found out some topic that really help me a lot such as:\nBuilding bridges problem - how to apply longest increasing subsequence? \nand\nHow to determine the longest increasing subsequence using dynamic programming?\n\nBut when I come up with LIS and trying to solve one sample list by hand. Let's say I have\n\n```\nNorthern Bank >> 7 4 3 6 2 1 5\nSouthern Bank >> 5 3 2 4 6 1 7\n```\n\n\nAfter sort southern bank \n\n```\nNorthern Bank >> 1 3 4 6 7 2 5 \nSouthern Bank >> 1 2 3 4 5 6 7\n```\n\n\nWhich LIS length suppose to be \"5\" but actually in the first list, Only 3 bridge are able to create (3,2,1). So did I misunderstand LIS or are there any exception on this that won't work on building bridge problem? \n    ", "Answer": "\r\nMy understanding is that you have correctly solved the problem using the longest increasing subsequence:\n\n\n\nYou can build all 5 black bridges (but not the 2 red ones).\n\nWhy do you think you can only make 3 bridges?\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest non-decreasing subsequence with minimal sum\r\n                \r\nI am trying to find topic algorithm and am stuck. Basically, I adopted the code given in zzz's answer here, which is Longest Increasing Subsequence algorithm, to get Longest Non-decreasing Subsequence. What I aim to find is LNDS that has a minimal sum (MSLNDS) and don't know do I have one. But as far as I can tell, original LIS algorithm as presented on wikipedia does locate minimal sum LIS. Docstring of its code says that LIS algorithm guarantees that if multiple increasing subsequences exist, the one that ends with the smallest value is preferred, and if multiple occurrences of that value can end the sequence, then the earliest occurrence is preferred. Don't know what earliest occurrence means, but would love not to be in the position to generate all LNDS to find my MSLNDS. It seems to me that clever transformation given by templatetypedef may be used to show that unique MSLIS transforms to MSLNDS, but dont have the proof. So,  \n\na) Will LIS algorithm as given on wikipedia always output minimal sum LIS?\n\nb) If LIS algorithm is adopted this way, will LNDS algorithm retain this property?\n\n```\ndef NDS(X):\n    n = len(X)\n    X = [0.0] + X\n    M = [None]*(n+1)\n    P = [None]*(n+1)\n    L = 0\n    for i in range(1,n+1):\n        #########################################\n        # for LIS algorithm, this line would be \n        # if L == 0 or X[M[1]] >= X[i]:\n        #########################################\n        if L == 0 or X[M[1]] > X[i]:\n            j = 0\n        else:\n            lo = 1\n            hi = L+1\n            while lo < hi - 1:\n                mid = (lo + hi)//2\n                #########################################\n                # for LIS algorithm, this line would be \n                # if X[M[mid]] < X[i]:\n                #########################################\n                if X[M[mid]] <= X[i]:\n                    lo = mid\n                else:\n                    hi = mid\n            j = lo\n\n        P[i] = M[j]\n        if j == L or X[i] < X[M[j+1]]:\n            M[j+1] = i\n            L = max(L,j+1)\n\n    output = []\n    pos = M[L]\n    while L > 0:\n        output.append(X[pos])\n        pos = P[pos]\n        L -= 1\n\n    output.reverse()\n    return output\n```\n\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Most efficient way to find longest incrementing subsequence in a list of lists\r\n                \r\nI am doing some signal analysis, a part of which is to find the longest subsequence \n\nI have dictionary like the following:\n\n```\nsequenceDict = {\n    0: [168, 360, 470],\n    1: [279, 361, 471, 633, 729, 817],\n    2: [32, 168, 170, 350, 634, 730, 818],\n    3: [33, 155, 171, 363, 635, 731, 765, 819],\n    4: [352, 364, 732, 766, 822],\n    5: [157, 173, 353, 577, 637, 733, 823, 969],\n    6: [158, 174, 578, 638, 706, 734, 824],\n    7: [159, 175, 579, 707, 735],\n    8: [160, 464, 640, 708, 826],\n    9: [173, 709, 757, 827],\n    10: [174, 540, 642, 666, 710],\n    11: [253, 667, 711],\n    12: [254, 304, 668],\n    13: [181, 255, 831],\n    14: [256, 340, 646, 832],\n    16: [184, 416], \n    17: [417], \n    18: [418], \n    19: [875], \n    20: [876], \n    23: [217], \n    24: [168, 218, 880], \n    25: [219, 765, 881], \n    26: [220, 766], \n    27: [221], \n    28: [768], \n    29: [3, 769], \n    30: [344, 476, 706]}\n```\n\n\nThese are essentially always sorted indices of another array, I would like to find the longest incrementing sequence ( just like a longest increasing subsequence), by picking only one number from each key sequentially ( key 2 comes right after key 1 and so on), for example, \nfrom keys 0 and 1, [360, 361] is one sequence, and [470, 471] is another.\nI am calling these incrementing sequence, as these numbers should strictly increase by 1.\n\nI have looked at things like patience sorting and so on, but since this problem is slightly different, and also has a tree of sequences, are there any known python implementations, or other efficient ways to do this except generating all possible sequences from this dict and then running patience sort?\n    ", "Answer": "\r\nI would just implement a \"brute-force\" solution...\n\n\nkeep a list of \"current sequences\", initially empty\nfor each key check if any of the current sequences can be extended by one step. When increasing a sequence update also a best-so-far solution.\nfor any number that was not used to extend a sequence start a new sequence of length 1\n\n\nPython provides ```\nset```\n that may be a reasonable choice... this is a sample implementation:\n\n```\nbest = None\ncurrent_sequences = set()\nlast_key = None\nfor key in sorted(sequenceDict.keys()):\n    data = set(sequenceDict[key])\n    new_sequences = set()\n    if last_key == key-1:\n        # no gap in key value, may be some sequence got extended\n        for val, count in current_sequences:\n            if val+1 in data:\n                # found a continuation, keep this sequence\n                new_sequences.add((val+1, count+1))\n                data.remove(val+1)\n                if best is None or count+1 > best[0]:\n                    # we've got a new champion\n                    best = count+1, val+1, key\n    # add new sequences starting here\n    for v in data:\n        new_sequences.add((v, 1))\n        if best is None:\n            best = 1, v, key\n    current_sequences = new_sequences\n    last_key = key\n```\n\n\nOne tricky part is that if there is a gap in the keys then you cannot extend a sequence, this is what ```\nlast_key```\n is used for.\n\nComplexity should be ```\nO(input_size × average_number_of_sequences)```\n. Mine is just a gut feeling, but my guess is that you cannot get lower than that. I was tempted by the idea of using ```\nvalue - key```\n to associate a constant value with each sequence... however this would not detect \"gaps\" (i.e. value 100 in key 1 and value 102 in key 3, but without 101 in key 2).\n\nWith the question input the solution is ```\n(7, 735, 7)```\n meaning a 7-elements sequence ending with value 735 at key 7.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Dynamic Programming: Can recursion with memoization work with any recursive solution or only solutions in specific formats?\r\n                \r\nI am reading about dynamic programming and was trying to solve the Longest Increasing subsequence problem.\nI tried to come up with a brute force recursion approach where I generated all possible increasing subsequences and checked which one is the longest.\n```\nprivate int lis(int[] arr, int k, List<Integer> curr){\n    int ans = 0;\n    for(int i=k;i<arr.length;i++){\n        if(!curr.isEmpty() && arr[i]<=curr.get(curr.size()-1)){\n            continue;\n        }\n        curr.add(arr[i]);\n        ans = Math.max(ans, curr.size());\n        ans = Math.max(ans,lis(arr,i+1,curr));\n        curr.remove(curr.size()-1);\n    }\n    return ans;\n}\n```\n\nHere ```\narr```\n is the input array, ```\nk```\n is 0 and ```\ncurr```\n is a list where I store the current increasing subsequence, ```\nans```\n is a global variable that keeps count of the longest increasing subsequence. I get TLE on this solution which is expected.\nI know that this isn't the most efficient approach since I am using a list to keep track of elements and the problem can be solved without it. But I was still trying to apply memoization to this code as an exercise.\nI'm trying to understand if memoization can be applied to any recursive brute force solution (or does it require the recursive solution to be in a specific format since there are several types of recursions like tail recursion etc)? If no what properties should it satisfy?\nCan memoization be applied to the above algorithm to make it work?\n    ", "Answer": "\r\nMemoization can be performed as long as you're able to create a lookup structure that will recognize whether the arguments are the same so that you know when to return the previous result.\nIn Python a ```\ntuple```\n is like a ```\nlist```\n except immutable and hashable so it can be used in a dictionary.  In other languages you usually have to do a lot more work to create a lookup based on elements.  What work that is depends on the language.  With the most common fallback being to create a string representation of your arguments.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Python loop through list and return \"out of sequence\" values\r\n                \r\nConsider this list:\n\n```\ndates = [\n    ('2015-02-03', 'name1'),\n    ('2015-02-04', 'nameg'),\n    ('2015-02-04', 'name5'),\n    ('2015-02-05', 'nameh'),\n    ('1929-03-12', 'name4'),\n    ('2023-07-01', 'name7'),\n    ('2015-02-07', 'name0'),\n    ('2015-02-08', 'nameh'),\n    ('2015-02-15', 'namex'),\n    ('2015-02-09', 'namew'),\n    ('1980-12-23', 'name2'),\n    ('2015-02-12', 'namen'),\n    ('2015-02-13', 'named'),\n]\n```\n\n\nHow can I identify those dates that are out of sequence. I don't care if they repeat, or skip, I just need the ones way out of line. Ie, I should get back:\n\n```\n('1929-03-12', 'name4'),\n('2023-07-01', 'name7'),\n('2015-02-15', 'namex'),\n('1980-12-23', 'name2'),\n```\n\n\nNamex is less obvious, but it's not in the general order of the list.\n\nMy simplistic start (which I have deleted to simplify the question) is obviously woefully incomplete.\n\n\n\nUpdate: Based on the comments, it seems an implementation of the Longest Increase Subsequence (LIS) will get me started, a python implementation found here: \n\n\nhttps://stackoverflow.com/a/9832414/1061836\nHow to determine the longest increasing subsequence using dynamic programming?\nhttps://rosettacode.org/wiki/Longest_increasing_subsequence#Python\nhttps://codereview.stackexchange.com/questions/10230/python-implementation-of-the-longest-increasing-subsequence\n\n\nSeems once I get the LIS, I can compare it to the original list and see where the gaps are... Fascinating. SO is the hive-mind of awesomeness.\n    ", "Answer": "\r\nShort answer, general solution\n\nUsing my answer to the \"Longest increasing subsequence\" question, this could be implemented simply as:\n\n```\ndef out_of_sequence(seq):\n  indices = set(longest_subsequence(seq, 'weak', key=lambda x: x[0], index=True))\n  return [e for i, e in enumerate(seq) if i not in indices]\n```\n\n\nLonger answer, specific solution\n\nBased on the question at Code Review and a question about non-decreasing sequences (since that's what you're after), here's a solution to your problem:\n\n```\nfrom bisect import bisect_right\nfrom operator import itemgetter\n\n\ndef out_of_sequence(seq, key = None):\n  if key is None: key = lambda x: x \n\n  lastoflength = [0] # end position of subsequence with given length\n  predecessor = [None] # penultimate element of l.i.s. ending at given position\n\n  for i in range(1, len(seq)):\n    # find length j of subsequence that seq[i] can extend\n    j = bisect_right([key(seq[k]) for k in lastoflength], key(seq[i]))\n    # update old subsequence or extend the longest\n    try: lastoflength[j] = i\n    except: lastoflength.append(i)\n    # record element preceding seq[i] in the subsequence for backtracking\n    predecessor.append(lastoflength[j-1] if j > 0 else None)\n\n  indices = set()\n  i = lastoflength[-1]\n  while i is not None:\n    indices.add(i)\n    i = predecessor[i]\n\n  return [e for i, e in enumerate(seq) if i not in indices]\n\n\nprint(*out_of_sequence(dates, itemgetter(0)), sep='\\n')\n```\n\n\nOutputs:\n\n```\n('1929-03-12', 'name4')\n('2023-07-01', 'name7')\n('2015-02-15', 'namex')\n('1980-12-23', 'name2')\n```\n\n\n\n\nThe ```\nkey```\n parameter (inspired by ```\nsorted```\n builtin) specifies a function of one argument that is used to extract a comparison key from each list element. The default value is ```\nNone```\n so the caller has a convenient way of saying \"I want to compare the elements directly\". If it is set to ```\nNone```\n we use ```\nlambda x: x```\n as an identity function, so the elements are not changed in any way before the comparison.\n\nIn your case, you want to use the dates as keys for comparison, so we use ```\nitemgetter(0)```\n as ```\nkey```\n. And ```\nitemgetter(1)```\n would use the names as ```\nkey```\n, see:\n\n```\n>>> print(*map(itemgetter(1), dates))\nname1 nameg name5 nameh name4 name7 name0 nameh namex namew name2 namen named\n```\n\n\nUsing ```\nitemgetter(k)```\n is equivalent to ```\nlambda x: x[k]```\n:\n\n```\n>>> print(*map(lambda x: x[1], dates))\nname1 nameg name5 nameh name4 name7 name0 nameh namex namew name2 namen named\n```\n\n\nUsing it with ```\nmap```\n is equivalent to a generator expression:\n\n```\n>>> print(*(x[1] for x in dates))\nname1 nameg name5 nameh name4 name7 name0 nameh namex namew name2 namen named\n```\n\n\nBut if we used a similar list comprehension to pass the sequence to ```\nout_of_sequence```\n we would get a different result from expected:\n\n```\n>>> print(*out_of_sequence([x[0] for x in dates]), sep='\\n')\n1929-03-12\n2023-07-01\n2015-02-15\n1980-12-23\n```\n\n\nLikewise, if we compare the date-name pairs directly we get wrong results (because ```\n'nameg'```\n compares greater to ```\n'name5'```\n):\n\n```\n>>> print(*out_of_sequence(dates), sep='\\n')\n('2015-02-04', 'nameg')\n('1929-03-12', 'name4')\n('2023-07-01', 'name7')\n('2015-02-15', 'namex')\n('1980-12-23', 'name2')\n```\n\n\nBecause we want to return dates and names, and we want to order by dates only, we need to pass a function that extracts dates using the ```\nkey```\n parameter.\n\nAn alternative would be to get rid of ```\nkey```\n and just write:\n\n```\nj = bisect_right([seq[k][0] for k in lastoflength], seq[i][0])\n```\n\n\nBut since this is stackoverflow, maybe one day another person will come by this answer and will need some other key extraction, therefore I decided to post the more general solution here.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Does a subsequence need to be continuous\r\n                \r\nI am new to Dynamic Programming and was reading on the Longest Increasing Subsequence(LIS) problem. \n\nThe solution stated that the sequence need not be continuous as in the original array. Elements can be skipped in between; but I was under another impression.\n\nCould you please help clarify this confusion.\n\nSay for example: \n```\na = {10,22,9,33,55,66,12,90}```\n\nthe LIS is ```\n{10,22,33,55,66,90} => 6```\n\n\nHowever, I thought it would be ```\n{33,55,66}```\n\n\nThanks\n    ", "Answer": "\r\nSubsequence doesn't need to be continous. A Subsequence is formed by deleting zero or more elements from an array. A subaaray on the other hand is always continous. Lets's take your example:\n\n```\na = {10,22,9,33,55,66,12,90}\n```\n\n\nHere,```\n{10,22,33,55,66,90}```\n is the longest increasing subsequence and ```\n{33,55,66}```\n is the longest increasing subarray.\n\nSo, what you are basically answering is a solution to the longest increasing subarray problem.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "IndexOutOfBoundsException issue\r\n                \r\nSo, I'm writing a code to find the longest increasing subsequence in a input numbers. \n\n```\n    int curr_len = 0, max_len = 0, start = 0;\n\n    for (int i = 1; i <= listN.size(); i++){\n        if (listN.get(i-1) < listN.get(i)){\n            curr_len++;\n            if (curr_len >= max_len){\n                max_len = curr_len;\n                start = i - max_len + 1;\n            }\n        } else {\n            curr_len = 1;\n        }\n    }\n\n    for (int i = 0; i < max_len; i++)\n        listAsc.add(start+i);\n```\n\n\nThe problem is that I got IndexOutOfBoundsException in that fragment of code\n\n```\n    if (listN.get(i-1) < listN.get(i))\n```\n\n\nAnyone can help how to do it properly?\n    ", "Answer": "\r\nUse\n\n```\nfor (int i = 1; i < listN.size(); i++){\n```\n\n\nas the index starts at 0. Using an index < 0 or >= listN.size() causes a ```\nIndexOutOfBoundsException```\n in get(i).\n\nSee: http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#get%28int%29\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "What is the purpose of the fourth line of code particularly \"l[j][-1]\" here? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How slicing in Python works\r\n                            \r\n                                (38 answers)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nThe ff is a code to find the longest increasing subsequence of an array/list in this case it is d. The 4th line confuses me like what does ```\nl[j][-1]```\n mean. Let's say i=1. What would ```\nl[j][-1]```\n be?\n\n```\nd = [10,300,40,43,2,69]\nl = []\nfor i in range(len(d)):\n    l.append(max([l[j] for j in range(i) if l[j][-1] < d[i]] or [[]], key=len) + [d[i]])\n```\n\n    ", "Answer": "\r\nWhen I hit something like this, I consider that either I'm facing a smart algorithm that's beyond my trivial understanding, or that I'm just seeing tight code written by somebody while their mind was well soaked with the problem at hand, and not thinking about the guy who'd try to read it later (that guy most often being the writer himself, six months later... unless he's an APL hacker...).\n\nSo I take the code and try deobfuscate it.  I copy/paste it into my text editor, and from there I rework it to split complex statements or expressions into smaller ones, and to assign intermediate values to variables with meaningful names. I do so iteratively, peeling off one layer of convolution at a time, until the result makes sense to me.\n\nI did just that for your code. I believe you'll understand it easily by yourself in this shape. And me not being all too familiar with Python, I commented a few things for my own understanding at least as much as for yours.\n\nThis resulting code could use a bit of reordering and simplification, but I left in the form that would map most easily to the original four-liner, being the direct result of its expansion. Here we go :\n\n```\ndata = [10,300,40,43,2,69]\nincreasingSubsequences = []\n\nfor i in range(len(data)):\n\n    # increasingSubsequences is a list of lists\n    # increasingSubsequences[j][-1] is the last element of increasingSubsequences[j]\n\n    candidatesForMoreIncrease = []\n    for j in range(i):\n        if data[i] > increasingSubsequences[j][-1]:\n            candidatesForMoreIncrease.append( increasingSubsequences[j] )\n\n    if len(candidatesForMoreIncrease) != 0:\n        nonEmpty = candidatesForMoreIncrease\n    else:\n        nonEmpty = [[]]\n\n    longestCandidate = max( nonEmpty, key=len )   # keep the LONGEST of the retained lists\n                                         # with the empty list included as a bottom element\n\n    # (stuff + [data[i]]) is like copying stuff and and then appending data[i] to the copy\n    increasingSubsequences.append( longestCandidate + [data[i]] )\n\n\n\nprint \"All increasingSubsequences : \", increasingSubsequences\nprint \"The result you expected : \", max(increasingSubsequences, key=len)\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Why doesn't my recursive longest increasing subsequence function work for large inputs?\r\n                \r\nI wrote it to work on a single test case at a time.\nIt either takes too long on online judges or returns wrong answers\n\nSource: The problem I used to test it on\n\nIt works perfectly for small cases:\n\n```\n#include <iostream>\n  #include <algorithm>\n  #include <vector>\n  int LIS[100000];\n  void LS (int *arr , int n)\n  {\n      if (n == 0)\n      {\n          LIS[0] = 1;\n          return;\n      }\n      if (LIS[n])\n      {\n          return;\n      }\n      int i = 0;\n      int max = 0;\n      while (i < n)\n      {\n          if (arr[i] < arr[n])\n          {\n              LS(arr,i);\n              if (LIS[i] + 1 > max)\n              {\n                  max = 1 + LIS[i];\n              }\n          }\n          ++i;\n      }\n      LIS[n] = max;\n\n  }\n  int main()\n  {\n      int n;\n      std::cin >> n;\n      int arr[n];\n      for(int i = 0 ; i < n ; ++i) std::cin >> arr[i];\n      LS(arr,n-1);\n      std::sort (LIS , LIS+n);\n      std::cout << \"\\n\" << LIS[n-1] << \"\\n\";\n  }\n```\n\n    ", "Answer": "\r\nYou said it works perfectly small cases.. than maybe it is stack overflow..\n\nA function call consume stack memory..\n\nIf recursive call depth is too deep, stack memory runs out, and crash..\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Finding the Longest Palindrome Subsequence with less memory\r\n                \r\nI am trying to solve a dynamic programming problem from Cormem's Introduction to Algorithms 3rd edition (pg 405) which asks the following:\n\n\n  A palindrome is a nonempty string over\n  some alphabet that reads the same\n  forward and backward. Examples of\n  palindromes are all strings of length\n  1, ```\ncivic```\n, ```\nracecar```\n, and ```\naibohphobia```\n\n  (fear of palindromes).\n  \n  Give an efficient algorithm to find\n  the longest palindrome that is a\n  subsequence of a given input string.\n  For example, given the input\n  ```\ncharacter```\n, your algorithm should\n  return ```\ncarac```\n.\n\n\nWell, I could solve it in two ways:\n\nFirst solution:\n\nThe Longest Palindrome Subsequence (LPS) of a string is simply the Longest Common Subsequence of itself and its reverse. (I've build this solution after solving another related question which asks for the Longest Increasing Subsequence of a sequence).\nSince it's simply a LCS variant, it also takes O(n²) time and O(n²) memory.\n\nSecond solution:\n\nThe second solution is a bit more elaborated, but also follows the general LCS template. It comes from the following recurrence:\n\n```\nlps(s[i..j]) = \n    s[i] + lps(s[i+1]..[j-1]) + s[j], if s[i] == s[j];\n    max(lps(s[i+1..j]), lps(s[i..j-1])) otherwise\n```\n\n\nThe pseudocode for calculating the length of the lps is the following:\n\n```\ncompute-lps(s, n):\n\n    // palindromes with length 1\n    for i = 1 to n:\n        c[i, i] = 1\n    // palindromes with length up to 2\n    for i = 1 to n-1:\n        c[i, i+1] = (s[i] == s[i+1]) ? 2 : 1\n\n    // palindromes with length up to j+1\n    for j = 2 to n-1:\n        for i = 1 to n-i:\n            if s[i] == s[i+j]:\n                c[i, i+j] = 2 + c[i+1, i+j-1]\n            else:\n                c[i, i+j] = max( c[i+1, i+j] , c[i, i+j-1] )\n```\n\n\nIt still takes O(n²) time and memory if I want to effectively construct the lps (because I 'll need all cells on the table). Analysing related problems, such as LIS, which can be solved with approaches other than LCS-like with less memory (LIS is solvable with O(n) memory), I was wondering if it's possible to solve it with O(n) memory, too.\n\nLIS achieves this bound by linking the candidate subsequences, but with palindromes it's harder because what matters here is not the previous element in the subsequence, but the first. Does anyone know if is possible to do it, or are the previous solutions memory optimal?\n    ", "Answer": "\r\nHere is a very memory efficient version.  But I haven't demonstrated that it is always ```\nO(n)```\n memory.  (With a preprocessing step it can better than ```\nO(n2)```\n CPU, though ```\nO(n2)```\n is the worst case.)\n\nStart from the left-most position.  For each position, keep track of a table of the farthest out points at which you can generate reflected subsequences of length 1, 2, 3, etc.  (Meaning that a subsequence to the left of our point is reflected to the right.)  For each reflected subsequence we store a pointer to the next part of the subsequence.\n\nAs we work our way right, we search from the RHS of the string to the position for any occurrences of the current element, and try to use those matches to improve the bounds we previously had.  When we finish, we look at the longest mirrored subsequence and we can easily construct the best palindrome.\n\nLet's consider this for ```\ncharacter```\n.\n\n\nWe start with our best palindrome being the letter 'c', and our mirrored subsequence being reached with the pair ```\n(0, 11)```\n which are off the ends of the string.\nNext consider the 'c' at position 1.  Our best mirrored subsequences in the form ```\n(length, end, start)```\n are now ```\n[(0, 11, 0), (1, 6, 1)]```\n.  (I'll leave out the linked list you need to generate to actually find the palindrome.\nNext consider the ```\nh```\n at position 2.  We do not improve the bounds ```\n[(0, 11, 0), (1, 6, 1)]```\n.\nNext consider the ```\na```\n at position 3.  We improve the bounds to ```\n[(0, 11, 0), (1, 6, 1), (2, 5, 3)]```\n.\nNext consider the ```\nr```\n at position 4.  We improve the bounds to ```\n[(0, 11, 0), (1, 10, 4), (2, 5, 3)]```\n.  (This is where the linked list would be useful.\n\n\nWorking through the rest of the list we do not improve that set of bounds.\n\nSo we wind up with the longest mirrored list is of length 2.  And we'd follow the linked list (that I didn't record in this description to find it is ```\nac```\n.  Since the ends of that list are at positions ```\n(5, 3)```\n we can flip the list, insert character ```\n4```\n, then append the list to get ```\ncarac```\n.\n\nIn general the maximum memory that it will require is to store all of the lengths of the maximal mirrored subsequences plus the memory to store the linked lists of said subsequences.  Typically this will be a very small amount of memory.\n\nAt a classic memory/CPU tradeoff you can preprocess the list once in time ```\nO(n)```\n to generate a ```\nO(n)```\n sized hash of arrays of where specific sequence elements appear.  This can let you scan for \"improve mirrored subsequence with this pairing\" without having to consider the whole string, which should generally be a major saving on CPU for longer strings.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "What is the complexity for std::upper_bound and std::lower_bound for Vector in C++?\r\n                \r\nWhat is the complexity of the ```\nstd::lower_bound```\n and ```\nstd::upper_bound```\n functions.\nI know in case of ```\nstd::set<int>```\n it is ```\nlog(n)```\n, but I have no idea for a ```\nstd::vector<int>```\n.\nI was going through an implementation of the Longest Increasing Subsequence using vectors and ```\nstd::lower_bound```\n.\nWhat is the complexity of this code?\n```\nint LIS2(vector<int> a) {\n    vector<int> v;\n    for (int i = 0; i < a.size(); i++) {\n        auto it = lower_bound(v.begin(), v.end(), a[i]);\n        if (it != v.end()) \n            *it = a[i];\n        else \n            v.push_back(a[i]);\n    }\n    return v.size();\n}\n```\n\n    ", "Answer": "\r\nFrom https://en.cppreference.com/w/cpp/algorithm/lower_bound:\n\n\n  Complexity\n  \n  The number of comparisons performed is logarithmic in the distance between first and last (At most log2(last - first) + O(1) comparisons). However, for non-LegacyRandomAccessIterators, the number of iterator increments is linear.\n\n\nFor random access iterators (e.g from ```\nstd::vector```\n) the bounds functions simply do a binary search.\n\nFor non-random access iterators (e.g. from ```\nstd::list```\n and ```\nstd::set```\n) the functions still perform a binary search but there is an additional cost as they have to increment the iterators one element at a time to move between elements.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Explain this line of code\r\n                \r\ncan someone explain when this line of code ends ? :\n\n```\nvoid constituteSubsequence(int i){\n    if( Pred[i] + 1) constituteSubsequence(Pred[i]);\n    cout << a[i] << \" \";\n}\n```\n\n\nIn this program that calculate the longest increasing subsequence :\n\n```\n#include <iostream>\nusing namespace std;\nint Pred[1000]; //Pred is previous.\nint a[1000], v[1000], n, imax;\nvoid read() {\n    cout << \" n = \";\n    cin >> n;\n    cout << \" Sequence: \";\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n}\nvoid constituteSubsequence(int i) {\n    if (Pred[i] + 1) constituteSubsequence(Pred[i]);\n    cout << a[i] << \" \";\n}\nvoid calculate() {\n    int i, j;\n    v[0] = 1;\n    imax = 0;\n    Pred[0] = -1;\n    for (int i = 1; i < n; i++) {\n        v[i] = 1;\n        Pred[i] = -1;\n        for (int j = 0; j < i; j++) {\n            if (a[j] < a[i] && v[j] + 1 > v[i]) {\n                v[i] = v[j] + 1;\n                Pred[i] = j;\n            }\n            if (v[i] > v[imax]) {\n                imax = i;\n            }\n        }\n    }\n}\nvoid write() {\n    cout << \" Longest Increasing Subsequence : \";\n    constituteSubsequence(imax);\n    cout << endl << \" Length: \" << v[imax];\n}\nint main() {\n    read();\n    calculate();\n    write();\n    return 0;\n}\n```\n\n\nIf I run this code,it compiles and works as expected,but how does that condition repeat itself after it found a 0 value (false) and it print cout << a[i] ? .And when does it stop ?\n    ", "Answer": "\r\nIn C++ an integer expression can be treated as a Boolean. For example, in the context of ```\nif```\n statement ```\nPred[i] + 1```\n means ```\n(Pred[i] + 1) != 0```\n\n\nThis provides the answer to your question: the chain of recursive invocations is going to end when ```\nPred[i]```\n is ```\n-1```\n. Of course, an easier to read way to express the same condition would be with the ```\n!=```\n operator:\n\n```\nif( Pred[i] != -1) {\n    constituteSubsequence(Pred[i]);\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "longest nondecreasing subsequence in O(nlgn)\r\n                \r\nI have the following algorithm which works well\n\nI tried explaining it here for myself http://nemo.la/?p=943 and it is explained here http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ as well and on stackoverflow as well\n\nI want to modify it to produce the longest non-monotonically increasing subsequence\n\nfor the sequence 30 20 20 10 10 10 10\n\nthe answer should be 4: \"10 10 10 10\"\n\nBut the with nlgn version of the algorithm it isn't working. Initializing s to contain the first element \"30\" and starting at the second element = 20. This is what happens:\n\n\nThe first step: 30 is not greater than or equal to 20. We find the smallest element greater than 20. The new s becomes \"20\"\nThe second step: 20 is greater than or equal to 20. We extend the sequence and s now contains \"20 20\"\nThe third step: 10 is not greater than or equal to 20. We find the smallest element greater than 10 which is \"20\". The new s becomes \"10 20\"\n\n\nand s will never grow after that and the algorithm will return 2 instead of 4\n\n```\nint height[100];\nint s[100];\n\nint binary_search(int first, int last, int x) {\n\n    int mid;\n\n    while (first < last) {\n\n        mid = (first + last) / 2;\n\n        if (height[s[mid]] == x)\n            return mid;\n\n        else if (height[s[mid]] >= x)\n            last =  mid;\n\n        else\n            first = mid + 1;\n    }\n    return first; /* or last */\n}\n\nint longest_increasing_subsequence_nlgn(int n) {\n\n    int i, k, index;\n\n    memset(s, 0, sizeof(s));\n\n    index = 1;\n    s[1] = 0; /* s[i] = 0 is the index of the element that ends an increasing sequence of length  i = 1 */\n\n    for (i = 1; i < n; i++) {\n\n        if (height[i] >= height[s[index]]) { /* larger element, extend the sequence */\n\n            index++; /* increase the length of my subsequence */\n            s[index] = i; /* the current doll ends my subsequence */\n\n        }\n        /* else find the smallest element in s >= a[i], basically insert a[i] in s such that s stays sorted */\n        else {\n            k = binary_search(1, index, height[i]);\n\n            if (height[s[k]] >= height[i]) { /* if truly >= greater */\n                s[k] = i;\n            }\n        }\n    }\n    return index;\n}\n```\n\n    ", "Answer": "\r\nTo find the longest non-strictly increasing subsequence, change these conditions:\n\n\n  \n  If ```\nA[i]```\n is smallest among all end candidates of active lists, we will start new active list of length ```\n1```\n.\n  If ```\nA[i]```\n is largest among all end candidates of active lists, we will clone the largest active list, and extend it by ```\nA[i]```\n.\n  If ```\nA[i]```\n is in between, we will find a list with largest end element that is smaller than ```\nA[i]```\n. Clone and extend this list by ```\nA[i]```\n. We will discard all other lists of same length as that of this modified list.\n  \n\n\nto:\n\n\n  \n  If ```\nA[i]```\n is smaller than the smallest of all end candidates of active lists, we will start new active list of length ```\n1```\n.\n  If ```\nA[i]```\n is largest among all end candidates of active lists, we will clone the largest active list, and extend it by ```\nA[i]```\n.\n  If ```\nA[i]```\n is in between, we will find a list with largest end element that is smaller than or equal to ```\nA[i]```\n. Clone and extend this list by ```\nA[i]```\n. We will discard all other lists of same length as that of this modified list.\n  \n\n\nThe fourth step for your example sequence should be: \n\n```\n10```\n is not less than ```\n10```\n (the smallest element). We find the largest element that is smaller than or equal to ```\n10```\n (that would be ```\ns[0]==10```\n). Clone and extend this list by ```\n10```\n. Discard the existing list of length 2. The new ```\ns```\n becomes ```\n{10 10}```\n.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Tips on optimizing DP solution further\r\n                \r\nI solved the Longest Increasing Subsequence question on LeetCode: https://leetcode.com/problems/longest-increasing-subsequence/\n\nGiven an unsorted array of integers, find the length of longest increasing subsequence.  For ```\n[10,9,2,5,3,7,101,18]```\n, the answer is ```\n4```\n (size of ```\n[2,3,7,101]```\n).\n\n```\nclass Solution {\npublic:\n    int helper(vector<int>& nums, unordered_map<int, vector<int>>& dp, int lastNum, int startIndex) {\n        if(startIndex>=nums.size()) return 0;\n        if(dp.find(lastNum)!=dp.end() && dp[lastNum].size()>=startIndex && dp[lastNum][startIndex]!=INT_MIN) {\n            return dp[lastNum][startIndex];\n        }\n        \n        int ans=0;\n        if(nums[startIndex]>lastNum) ans=1+helper(nums, dp, nums[startIndex], startIndex+1);\n        ans=max(ans, helper(nums, dp, lastNum, startIndex+1));\n        \n        return dp[lastNum][startIndex]=ans;\n    }\n    \n    int lengthOfLIS(vector<int>& nums) {\n        int ans=0;\n        unordered_map<int, vector<int>> dp;\n        dp[INT_MIN].resize(10001, INT_MIN);\n        for(int i=0; i<nums.size(); i++) dp[nums[i]].resize(10001, INT_MIN);\n        \n        return helper(nums, dp, INT_MIN, 0);\n    }\n};\n\n```\n\nNote that I am also memoizing it, using the ```\ndp```\n table above and using two states ```\nlastNum```\n (```\nnums[i]```\n value that we picked in the last recursion) and ```\nstartIndex```\n.  In the solution section they use two states ```\nprev```\n (index, unlike the value that I pass using ```\nlastNum```\n) and ```\ncurpos```\n (analogous to ```\nstartIndex```\n).\nI am confused because I still get a TLE.  Now I am aware that the time limits set by the online judges are arbitrary, but I am looking to see why using ```\nlastNum```\n instead of ```\nprev```\n as a state results in more execution time.  Similarly, are there any other optimizations that I can make?\nThanks!\nEdit: I changed it to ```\n10001```\n, based on Igor's suggestion in the comments, all the tests cases pass now, but it takes a lot of time:\n\n24 / 24 test cases passed, but took too long.\n\nEdit2: Said differently, I guess my question is, as an interviewer what advice would one provide to nudge the candidate in the right direction (of using ```\nprev```\n instead of ```\nlastNum```\n)?\n    ", "Answer": "\r\nNot sure about your solution, but I'm a bit puzzled here: ```\ndp[INT_MIN].resize(10000001, INT_MIN);```\n, maybe your solution is not O(N). This'd get accepted:\n```\n#include <vector>\n#include <algorithm>\n\nstruct Solution {\n    static const inline int lengthOfLIS(const std::vector<int> &nums) {\n        std::vector<int> longest;\n\n        for (unsigned int index = 0; index < nums.size(); index++) {\n            const auto iter = std::lower_bound(longest.begin(), longest.end(), nums[index]);\n\n            if (iter == longest.end()) {\n                longest.emplace_back(nums[index]);\n\n            } else {\n                *iter = nums[index];\n            }\n        }\n\n        return longest.size();\n    }\n};\n```\n\n\nReferences\n\nFor additional details, you can see the Discussion Board. There are plenty of accepted solutions with a variety of languages and explanations, efficient algorithms, as well as asymptotic time/space complexity analysis1, 2 in there.\n\nIf you are preparing for interviews:\n\nWe would want to write bug-free and clean codes based on standards and conventions (e.g., c1, 2, c++1, 2, java1, 2, c#1, 2, python1, javascript1, go1, rust1).\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Increasing Sub sequence in a range\r\n                \r\nI have come across a problem where we want to tell the maximum size of the longest increasing sub-sequence.\n\n```\nan array A consisting of N integers. \nM queries (Li, Ri)\nfor each query we wants to find the length of the longest increasing subsequence in \narray A[Li], A[Li + 1], ..., A[Ri].\n```\n\n\nI implemented finding the sub-sequence using dp approach\n\n```\n// mind the REPN, LLD, these are macros I use for programming\n// LLD = long long int\n// REPN(i, a, b) = for (int i = a; i < b; ++i)\nLLD a[n], dp[n];\nREPN(i, 0, n) \n{ \n  scanf(\"%lld\", &a[i]); \n  dp[i] = 1; \n}\nREPN(i, 1, n) \n{\n  REPN(j, 0, i) \n  {\n    if(a[i] > a[j]) \n      dp[i] = std::max(dp[j] + 1, dp[i]);\n  }\n}\n```\n\n\nFor example:\n\n```\nArray: 1 3 8 9 7 2 4 5 10 6\ndplis: 1 2 3 4 3 1 3 4 5  5\nmax: 5\n```\n\n\nBut if it was for range ```\nLi=2```\n & ```\nRi=9```\n\n\nThen:\n\n```\nArray: 3 8 9 7 2 4 5 10\ndplis: 1 2 3 2 1 2 3 4\nmax: 4\n```\n\n\nHow can i determine the maximum longest increasing sub-sequence in a sub array?\n\nPS: I don't want to recompute the whole dplis array, I want to use the original one because too much computation will kill the purpose of the question.\n\nOne of the approaches was to construct a complete 2D DP array that consists of sub-sequence from position i where range of i is from 0 to n, but it fails on many cases due to TLE(Time limit exceeded) \n\n```\nREPN(k,0,n) {\n    REPN(i,k+1,n) {\n        REPN(j,k,i) {\n            if(a[i]>a[j]) dp[k][i]=std::max(dp[k][j]+1, dp[k][i]);\n        }\n    }\n} \n\nREPN(i,0,q) {\n    read(l); read(r);\n\n    LLD max=-1;\n    REPN(i,0,r) {\n        if(max<dp[l-1][i]) max=dp[l-1][i];\n    }\n\n    printf(\"%lld\\n\", max);\n}\n```\n\n\nIf you have any new logic/implementation, I will gladly study it in-depth. Cheers.\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How does finding a Longest Increasing Subsequence that ends with a particular element leads to the solution of finding LIS\r\n                \r\nI have understood that to find the solution of LIS problem, we need to find a LIS for every subsequence starting from initial element of the array to the each element that ends with a particular element(the last element), but I am not able to understand how would that help in finally finding a LIS of a given unsorted array, I also understand that this leads to an optimal substructure property and then can be solved, but as mentioned, I dont see how finding LIS(j) that ends with arr[j] will help us.\n\nthanks.\n    ", "Answer": "\r\nConsider this sequence as an example:\n\n```\na[]   : 10 20  1  2  5 30  6  8 50  5  7\n```\n\n\nIt produces the following sequence of ```\nLIS[i]```\n:\n\n```\na[]   : 10 20  1  2  5 30  6  8 50  5  7\nLIS[] :  1  2  1  2  3  4  4  5  6  3  4\n```\n\n\nGiven this sequence, you can immediately find the length of the result, and its last element: the length is 6, and the last element is 50.\n\nNow you can unfold the rest of the sequence, starting from the back: looking for ```\nLIS```\n of ```\n5```\n (one less than that of element ```\n50```\n) such that the number is less than ```\n50```\n yields 8. Looking back further for ```\n4```\n gives you ```\n6```\n (there is no tie, because ```\n30```\n is above ```\n8```\n). Next comes ```\n5```\n with ```\nLIS```\n of ```\n3```\n, and then a ```\n2```\n with ```\nLIS```\n of ```\n2```\n. Note that there is no tie again, even though ```\n20```\n has the same ```\nLIS```\n. This is because ```\n20```\n is above ```\n5```\n. Finally, we find ```\n1```\n with ```\nLIS```\n of ```\n1```\n, completing the sequence:\n\n```\n50  8  6  5  2  1\n```\n\n\nReversing this produces the longest increasing subsequence:\n\n```\n1 2 5 6 8 50\n```\n\n\nThis is a common trick: given a table with the value of the function that you are maximizing (i.e. the length) you can produce the answer that yields this function (i.e. the sequence itself) by back-tracking the steps of the algorithm to the initial element.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Defining algorithm [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\ncan anyone give me an example of this algorithm? Can it be longest common increasing subsequence?\n\n\n    ", "Answer": "\r\nIt seems to be a minimum path length to reach v from s(starting point) where E is the set of edges from vertex u to vertex v.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "LIS for coordinate values in O(NlogN) or O(Nlog^2N)\r\n                \r\nThis is a standard Dynamic programming Question LIS PROBLEM\n\nI want a longest increasing subsequence for points in 2D coordinates\n\nthat is, 2 points A(x1,y1) at index i in array , B(x2,y2) at index j in array can be a part of increasing sequence if\n    (x1<=x2) && (y1 <=y2) && !(x1==x2 && y1==y2) && (j>i)\n\nmy code is as below  which is O(N^2) using standard DP :-\n\n```\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n\nusing namespace std;\n\n\nstruct Pair\n{\n    int x;\n    int y;\n};\n\n\n\nint main()\n{\n\n    int n;\n    cin>>n;\n\n    vector<Pair> arr;\n    int L[1000000];\n\n    Pair a;\n\n    int i;int Maxchain=0;\n    for(i=0;i<n;i++)\n    {\n\n        cin>>a.x>>a.y;\n        arr.push_back(a);\n\n        L[i]=0;\n        for (int j = i-1; j >=0; j--)\n        {\n\n            if ((L[j]>(Maxchain-1))&&(L[j]>=L[i])&&(arr[j].x <= arr[i].x) && (arr[j].y <= arr[i].y) && !(arr[j].x == arr[i].x && arr[j].y == arr[i].y))\n                L[i] = L[j]+1;\n\n\n        }\n\n                Maxchain = L[i]>Maxchain ?L[i]:Maxchain ;\n\n    }\n    cout<<Maxchain;\n\n    return 0;\n}\n```\n\n\nThis is an O(N^2) solution can it be further reduced or any alogrithm for this to solve in O(NlogN) or O(Nlog^2N) ?\n\nfor reference found something here:\n\nLongest Increasing Subsequence (LIS) with two numbers\n\nThe second answer is more appropriate for my case but how can we implement that?\n\nNeed a Better answer or algorithm.\n    ", "Answer": "\r\nI'll assume that both coordinates are in the ```\n[0..N-1]```\n range (if it's not the case, we can \"compress\" them without changing their ordering relation).\n\nLet's take a closer look at a standard dynamic programming solution. Let ```\nf[i]```\n be the length of the longest increasing subsequence that ends in the ```\ni```\n-th position. A simple (but slow) way to compute it is too iterate over all previous elements and choose the optimal one. What we want to find is the ```\nmax f[j]```\n for all such ```\nj```\n that ```\np[j].x <= p[i].x```\n and ```\np[j].y <= p[j].y```\n. It looks like some kind of a 2-D query in a rectangle (I know that there is another condition that ```\np[j] != p[i]```\n, but we can work around it by querying two rectangles ```\n(p[i].x - 1, p[i].y)```\n and ```\n(p[i].x, p[i].y - 1)```\n.).\n\nSo we need a data structure that supports two operations: adding a point with a specific value and getting the maximum value in a rectangle. A segment tree by x-coordinate that stores a balanced binary search tree by y-coordinate for all points in its range can do it in ```\nO(log^2 N)```\n per query. Every query range is decomposed into at most ```\nO(log N)```\n nodes in the tree. If it's an insertion query, we need to insert the current point ```\n(p[i].x, p[i].y)```\n with a value ```\nf[i]```\n into the binary search trees for each of these nodes. If it's a get maximum query, we need to get a maximum for some prefix of each of these trees. Either way, we perform an ```\nO(log N)```\n operation for ```\nO(log N)```\n binary search trees per query. Thus, the total time complexity is ```\n(N * log^2 N)```\n. The space complexity is ```\nO(N log N)```\n as there are ```\nO(log N)```\n levels in the tree and each point can occur somewhere at most once per level.\n\nThis solution already satisfies your requirements, but it looks pretty hard to code. We can slightly simplify it. We can do two \"runs\": during the first run, we just store the queries that go into each node of the segment tree (we don't store any extra information so far). Now we can keep a vector of all numbers that ever occur in the node and a binary index tree of the same length to keep track of a minimum for each prefix and get it efficiently (the big picture: we used the fact that we know all the queries beforehand so we can use a combination of a sorted vector and binary index tree instead of a binary search). The time and space complexity analysis is the same as above.\n\nA short recap: we used a data structure that supports a maximum query in a rectangle and insertions of new points efficiently to speed up finding the best ```\nj```\n for a fixed ```\ni```\n in an ```\nO(N^2)```\n dynamic programming solution to solve it in ```\nO(N log^2 N)```\n. \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to check whether each element is in any Longest Increasing Subsequence of an array or not?\r\n                \r\nWe have an array of integer numbers. We want to know for each element whether that element is contained at least in one LIS of many LISs of our array or not. We want to know this for all elements in the array in less than O(n2).\n\nFor example array [2, 4, 3, 2, 5] has two LISs. All elements in the array belong to at least one of these LISs, exept the 4th element which does not belong to any LIS.\n\nI know an easy solution which uses dfs, but its runtime is O(n2).\n    ", "Answer": "\r\nRun an algorithm such as https://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms which computes, at each point, the length of the longest increasing subsequence ending at that point.\n\nRun the same algorithm using the data in reversed order, to compute, for each point, the length of the longest increasing subsequence starting at that point.\n\nFor each point add the two computed lengths. The point is on a longest increasing subsequence if this sum is equal to the largest sum found.\n\nThe alogorithm quoted takes time O(n log n) for each pass and the sum is only O(log n) so the total is O(n log n)\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest non-decreasing sub-sequence in O(nlogn)\r\n                \r\nThis may be a very classical problem of finding longest non-decreasing subsequence in O(nlogn). Just to revise, length of longest non-decreasing subsequence in array A={2 4 2 3 3 5 1} is 5 {2 2 3 3 5}. \n\nHowever, After countless efforts I fail to understand where my implementation of the algorithm is failing. I've read and implementing the algorithm described Here and Here with only a little change of \"=\" sign to allow equal elements in O(nlogn) implementation of longest increasing subsequence. I'm attempting this problem where trivial O(n^2) approach (which is correct as the solution got accepted) and O(nlogn) approach are giving different solutions (which I inferred by assert statements) which proves that something is wrong for sure with my O(nlogn) implementation. \n\nMy O(nlogn) implementation is as follows:\n\n```\n/* Array LNDS will be used for finding\nlongest non-decreasing subsequence in array A of size n */\nint LNDS[n],len=1,x; // len will be storing the required length\nfill(LNDS,LNDS+n,0);\nLNDS[0]=A[0];\nfor(int i=1; i<n; i++)\n{\n    x=LNDS[len-1];\n    if(A[i]<LNDS[0])\n        LNDS[0]=A[i];\n    else if(A[i]>=x) // \"=\" sign to allow equal elements\n        LNDS[len++]=A[i];\n    else\n    {\n        l=0;\n        r=len-1;\n        while(r-l>1) // binary search for finding lower bound for A[i] in LNDS\n        {\n            m=(l+r)/2;\n            if(LNDS[m]>=A[i]) r=m;\n            else l=m;\n        }\n        LNDS[r]=A[i];\n    }\n}\nreturn len;\n```\n\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Non-tail recursion within a for loop\r\n                \r\n\nGiven an array of numbers, find the length of the longest increasing subsequence in the array. The subsequence does not necessarily have to be contiguous.\nFor example, given the array [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15], the longest increasing subsequence has length 6: it is 0, 2, 6, 9, 11, 15.\n\nOne of the solutions to the above problem uses non-tail recursion within a for loop, and I am having trouble making sense of it. I don't understand when the code after the recursive call in the for loop is executed, and I can't visualize the entire execution process of the whole solution.\n```\ndef longest_increasing_subsequence(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n\n    max_ending_here = 0\n    for i in range(len(arr)):\n        ending_at_i = longest_increasing_subsequence(arr[:i])\n        if arr[-1] > arr[i - 1] and ending_at_i + 1 > max_ending_here:\n            max_ending_here = ending_at_i + 1\n    return max_ending_here\n```\n\nThe description of the solution is as follows:\n\nAssume that we already have a function that gives us the length of the longest increasing subsequence. Then we’ll try to feed some part of our input array back to it and try to extend the result. Our base cases are: the empty list, returning 0, and an array with one element, returning 1.\nThen,\n\nFor every index ```\ni```\n up until the second to last element, calculate ```\nlongest_increasing_subsequence```\n up to there.\nWe can only extend the result with the last element if our last element is greater than ```\narr[i]```\n (since otherwise, it’s not increasing).\nKeep track of the largest result.\n\n\nSource: https://www.dailycodingproblem.com/blog/longest-increasing-subsequence/\n\n**EDITS**:\nWhat I mean by I don't understand when the code after the recursive call in the for loop is executed. Here is my understanding:\n\nSome code calls ```\nlis([0, 8, 4, 12, 2])```\n.\n```\narr = [0, 8, 4, 12, 2]```\n doesn't meet either of the two base cases.\nThe for loop makes the first call when ```\ni = 0```\n in the line ```\nending_at_i = lis([])```\n. This is the first base case, so it returns 0. I can't understand why control doesn't return to the for loop so that ```\nending_at_i```\n is set to 0, and the if condition is executed (because it surely isn't checked else ```\n[][-1]```\n would throw an error), after which we can move on to the for loop making the second call when ```\ni = 1```\n, third call when ```\ni = 2```\n which would branch into two calls, and so on.\n\n    ", "Answer": "\r\nHere's how this function works.  Fist, it handles the degenerate cases where the list length is 0 or 1.\nIt then looks for the solution when the list length is >= 2.  There are two possibilities for the longest sequence:  (1) It may contain the last number in the list, or (2) It may not contain the last number in the list.\nFor case (1), if the last number in the list is in the longest sequence, then the number before it in the longest sequence must be one of the earlier numbers.  Suppose the number before it in the sequence is at position x.  Then the longest sequence is the longest sequence taken from the numbers in the list up to and including x, plus the last number in the list.  So it recurses on all of the possible positions of x, which are 0 through the list length minus 2.  It iterates ```\ni```\n over ```\nrange(len(arr))```\n, which is 0 through ```\nlen(arr)-1)```\n.  But it then uses ```\ni```\n as the upper bound in the slice, so the last element in the slice corresponds to indices ```\n-1```\n through ```\nlen(arr)-2```\n.  In the case of ```\n-1```\n, this is an empty slice, which handles the case where all values in the list before the last are >= the last element.\nThis handles case (1).  For case (2), we just need to find the largest sequence from the sublist that excludes the last element.  However, this check is missing from the posted code, which is why the wrong answer is given for a list like ```\n[1, 2, 3, 0]```\n:\n```\n>>> longest_increasing_subsequence([1, 2, 3, 0])\n0\n>>> \n```\n\nObviously the correct answer in this case is ```\n3```\n, not ```\n0```\n.  This is fairly easy to fix, but somehow was left out of the posted version.\nAlso, as others have pointed out, creating a new slice each time it recurses is unnecessary and inefficient.  All that's needed is to pass the length of the sublist to achieve the same result.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Can we solve the longest increasing subsequence prob by designing the binary search tree and traverse its longest right?\r\n                \r\nI have solved two ques with the same approach and it is providing me right answer.\n\n    ", "Answer": "\r\nNo.\n\n'Subsequence' means the original order in the array should be preserved, but if you insert the items into a binary search tree, you lose the original order, since binary search trees insert items in BST order.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Can you break this pythonic list comprehension down\r\n                \r\nI encountered this List Comprehension when looking for interesting ways to solve longest increasing subsequence problems:\n\n```\ndef lis(a):\n    L = []\n    for (k,v) in enumerate(a):\n        L.append(max([L[i] for (i,n) in enumerate(a[:k]) if n<v] or [[]], key=len) + [v])\n    return max(L, key=len)\n```\n\n\nI've tried to understand it, but this is the best way I could understand it:\n\n```\ndef lis(a):\n    L = []\n    for (k,v) in enumerate(a):\n        for (i,n) in enumerate(a[:k]):\n            if n < v:\n                L.append(max(L[i]) + [v])\n            else:\n                L.append([[]])\n        #L.append(max([L[i] for (i,n) in enumerate(a[:k]) if n<v] or [[]], key=len) + [v])\n    return max(L, key=len)\n```\n\n\nBut this is incorrect... any help? Thank you.\n\nEdit:\n\nNew code:\n\n```\ndef lis(a):\n    L = []\n    for (k,v) in enumerate(a):\n        for (i,n) in enumerate(a[:k]):\n            if n < v:\n                L.append(max(L[i], key=len) + [v])\n            else:\n                L.append([[]] + [v])\n```\n\n\nWhen I run this on this list:\n\n```\na = [5, 2, 1, 5, 3, 2, 10, 2, 4, 2, 1, 0, 5]\n```\n\n\nI get this error:\n\n```\n  L.append(max(L[i], key=len) + [v])\nTypeError: object of type 'int' has no len()\n```\n\n    ", "Answer": "\r\nYou forgot ```\n+ [v]```\n in the else statement.\n\nEdit (think it's right):\n\n```\ndef lis(a):\n    L = []\n    for (k, v) in enumerate(a):\n        tmp = []\n        for (i, n) in enumerate(a[:k]):\n            if n < v:\n                tmp.append(L[i])\n        if len(tmp) == 0:\n            tmp = [[]]\n        L.append(max(tmp, key=len) + [v])\n    return max(L, key=len)\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "what is common practice of saving function definitions in asp.net-mvc\r\n                \r\nI've a question, not about code, but about a good practice. \nin my asp.net mvc app i need to write function which calculates longest increasing subsequence, so where should i save this function? \nmy opinion is to create different file in my project create class and add this function there.\n    ", "Answer": "\r\nYou can start by thinking about your project in terms of layers:\n\n\nYou have a presentation layer or the UI, consisting of the views and controllers that decide how actions are executed and how.\nYou have a data access layer, in charge of communicating with your database.\nYou have a business logic layer, where your business rules and domain models are defined.\n\n\n\n  In my asp.net mvc app i need to write function which calculates longest increasing subsequence, so where should i save this function?\n\n\nYou can answer this by determining which layer should be in charge of executing this logic. Does this belong to the presentation layer? Certainly not, as the UI does not care how you calculate the subsequence. So this function should not be placed in the controllers.\n\nMy suggestion is then to create a service that will be in charge of executing this calculation. Something like:\n\n```\npublic class CalculationsService : ICalculationService\n{\n    public int[] GetLongestIncreasingSubsequence(int [] seq)\n    {\n        // ...\n    }\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "finding the length of the longest subsequence\r\n                \r\nHere, in this piece of code, it prints the length of the largest subsequence of a sequence that's increasing then decreasing or vice versa. \n\nfor example:\n\nInput: 1, 11, 2, 10, 4, 5, 2, 1\n\nOutput: 6 (A Longest Subsequence of length 6 is 1, 2, 10, 4, 2, 1)\n\nbut how can I make it work with three monotonic (increasing or decreasing) regions? \n\nlike increasing-decreasing-increasing OR decreasing-increasing-decreasing\n\nexample:\n\ninput: 7 16 1 6 20 17 7 18 25 1 25 21 11 5 29 11 3 3 26 19\n\noutput: 12\n\n(largest subsequence: 7 1 6 17 18 25 25 21 11 5 3 3) as we see, \n\nit can be split into three regions:\n7,1 / 6,17,18,25,25 / 21,11,5,3,3\n\n```\narr = list(map(int, input().split()))\ndef lbs(arr): \n    n = len(arr) \n\n    lis = [1 for i in range(n+1)] \n\n    for i in range(1 , n): \n        for j in range(0 , i): \n            if ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)): \n                lis[i] = lis[j] + 1\n\n\n    lds = [1 for i in range(n+1)] \n\n    for i in reversed(range(n-1)):\n        for j in reversed(range(i-1 ,n)):  \n            if(arr[i] > arr[j] and lds[i] < lds[j] + 1): \n                lds[i] = lds[j] + 1 \n\n\n\n    maximum = lis[0] + lds[0] - 1\n    for i in range(1 , n): \n        maximum = max((lis[i] + lds[i]-1), maximum) \n\n    return maximum \n\nprint (\"Length of LBS is\",lbs(arr)) \n```\n\n    ", "Answer": "\r\nI've came up with a O(n^2 log n) idea.\n\nYou want to divide your whole segment into three parts: first one containing increasing subsequence, second one containing decreasing one and the last one containing again increasing one. \n\nFirst of all, let's choose a sequence's prefix - the first part (O(n) possibilities). To minimize the amount of checked intervals, you can pick only prefixes which last element is in their longest increasing subsequence. (In other words, when choosing range [1, x], a_x should be in it's longest increasing subsequence)\n\nNow you have similar problem to the one you've already solved - finding decreasing, then increasing subsequence (I'd use binary search instead of for loop you used, by the way). The only difference is that the decreasing subsequence must start from values smaller than the last element of chosen prefix (just ignore any larger or equal values) - you're able to do it in O(n log n).\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Remove one number from array of number to sort the array\r\n                \r\nWe have array of numbers, we need to find the total number of ways that we can remove one number in the array if removing that, will sort the array. \n\nFor example if we have [3,4,5,4] we should return 2 because if we remove 5 or the second 4 our array will be sorted. \n\nBut if we get something like [4,5,2,3,4] we should return 0 because removing any of them will not sort the array. \n\nI believe that this is something related to Longest increasing subsequence \n\nCorrect me if I'm wrong, but this should work like this : \n\nWe should find the longest increasing subsequence and delete everything not in that subsequence.\n\nWith that in mind, I used some function like this to find the LIS : \n\n```\nfunction findSubsequence(arr){\nvar allSubsequence = [],\n    longestSubsequence = null,\n    longestSubsequenceLength = -1;\n\nfor(var i=0;i<arr.length;i++){          //i=1\n    var subsequenceForCurrent = [arr[i]],\n        current = arr[i],\n        lastElementAdded = -1;\n    for(var j=i;j<arr.length;j++){\n        var subsequent = arr[j];\n        if((subsequent > current) && (lastElementAdded<subsequent)){\n            subsequenceForCurrent.push(subsequent);\n            lastElementAdded = subsequent;\n        }\n    }\n    allSubsequence.push(subsequenceForCurrent);\n}\nfor(var i in allSubsequence){\n    var subs = allSubsequence[i];\n    if(subs.length>longestSubsequenceLength){\n        longestSubsequenceLength = subs.length;\n        longestSubsequence = subs;\n    }\n}\nreturn longestSubsequence;\n}\n\n\n(function driver(){\n    var sample = [87,88,91, 10, 22, 9,92, 94, 33, 21, 50, 41, 60, 80];\n    console.log(findSubsequence(sample));\n})();\n```\n\n\nBut this give me the highest numbers, I'm not sure how should I remove one of them to keep the array sort and find all possible ways.\n\nAny Idea?\n    ", "Answer": "\r\nThat approach seems a bit complicated. I think it would be clearer and less resource-heavy to use a brute force approach: for every item in the array, try removing it, and then check to see if the array is sorted afterwards. But don't use ```\nsort```\n to check if it's sorted (that has ```\nO(N log N)```\n complexity), instead, just check to see that every item in the array is the same or greater than the previous one (```\nO(N)```\n):\n\n\r\n\r\n```\nconst checkSorted = arr => arr.every((num, i, arr) => i === 0 || num >= arr[i - 1]);\r\nconst checkRemovalCount = arr => arr.reduce((countSoFar, _, i, arr) => {\r\n  const removedArr = [...arr.slice(0, i), ...arr.slice(i + 1)];\r\n  return countSoFar + checkSorted(removedArr);\r\n}, 0);\r\nconsole.log(checkRemovalCount([3,4,5,4]));\r\nconsole.log(checkRemovalCount([4,5,2,3,4]));\r\nconsole.log(checkRemovalCount([87,88,91, 10, 22, 9,92, 94, 33, 21, 50, 41, 60, 80]));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest bitonic subsequence in O(n*logn) complexity\r\n                \r\n\n  A subsequence is bitonic if it monotonically increases and then monotonically de- creases, or if it can be circularly shifted to monotonically increase and then monotonically decrease.\n\n\nGiven a sequence, how can I determine the longest bitonic subsequence efficiently?\n\nedit: edited title to subsequence\n    ", "Answer": "\r\nhere included a complete compilable example of the algorithm:\n\n```\nimport java.util.Arrays;\n\npublic class LBS {\n\npublic static int binarySearchBetween(int[] arr, int end, int val) {\n    int low = 0, high = end;\n    if (val < arr[0]) {\n        return 0;\n    }\n    if (val > arr[end]) {\n        return end + 1;\n    }\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (low == high) {\n            return low;\n        } else {\n            if (arr[mid] == val) {\n                return mid;\n            }\n            if (val < arr[mid]) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\n/**\n * Returns an array of LIS results such that arr[i] holds the result of the \n * LIS calculation up to that index included.\n * @param arr The target array.\n * @return An array of LIS results.\n */\npublic static int[] lisArray(int[] arr) { // O(n*logn) \n    /* Regular LIS */\n    int size = arr.length;\n    int[] t = new int[size]; \n    t[0]=arr[0];\n    int end = 0;\n\n    /* LIS ARRAY */\n    int[] lis = new int[size]; // array for LIS answers.\n     // Start at 1 (longest sub array of a single element is 1)\n    lis[0]=1; \n\n    for (int i=1; i<size; i++) { // O(n) * O(logn) \n        int index = binarySearchBetween(t, end, arr[i]);\n        t[index] = arr[i];\n        if (index > end) {\n            end++;\n        }\n        lis[i]=end+1; // saves the current calculation in the relevant index\n    }\n    return lis;\n}\n\n/*\n* Input:  {1, 11, 2, 10, 4, 5, 2, 1}\n* Output: {1,  2, 2,  3, 3, 4, 4, 4}\n* Each index in output contains the LIS calculation UP TO and INCLUDING that \n* index in the original array.\n*/\n\npublic static int[] ldsArray(int[] arr) { // O(n*logn)\n    int size = arr.length;\n    int t[] = new int[size];\n    for (int i = 0; i < size; i++) {\n        t[i] = -arr[i];\n    }\n    int ans[] = lisArray(t);\n    return ans;\n}\n\npublic static int lbs(int[] arr) { // O(n*logn)\n    int size = arr.length;\n    int[] lis = lisArray(arr); // O(n*logn)\n    int[] lds = ldsArray(arr); // O(n*logn)\n    int max = lis[0]+lds[size-1]-1;\n    for (int i=1; i<size; i++) { // O(n)\n        max = Math.max(lis[i]+lds[size-i]-1, max);\n    }\n    return max;\n}\n\npublic static void main (String[] args)\n{\n        int arr[] = {1,11,2,10,4,5,2,1};\n        System.out.println(Arrays.toString(arr));\n        System.out.println(lbs(arr));\n}\n}\n```\n\n\nexplanation: \n\nfirst of all a binary search uses a complexity of O(logn), it is a given an i shall not explain this in this thread.\n\nThis method uses a dynamic programming version of LIS which uses a complexity of O(n*logn) (also a given that shall not be explained here)\na dynamic LIS algorithm returns the length of the longest sub-array. with slight modification we save into an array the size of n the longest sub-array length up to and including that index.\n\nso in each index we know \"the max length up to index\"\nnext we do the same for LDS.\nthis will give us the value of \"the max length from index\"\n\nafterwards we cross-combine the values, this gives us the value of \"the max length up to index + the max length from index\"\n\nnow since the element in index is calculated twice we remove one. thus resulting in the formula:\n\n```\nlbs[i] = lis[i]+lds[n-i]-1```\n for n>=1;\n\nas for complexity the following commands: \n\n```\nint[] lis = lisArray(arr); // O(n*logn)\nint[] lds = ldsArray(arr); // O(n*logn)\n```\n\n\neach work ```\nO(n*logn)```\n complexity\n\nand the for loop: \n\n```\nfor (int i=1; i<size; i++) { // O(n)\n        max = Math.max(lis[i]+lds[size-i]-1, max);\n    }\n```\n\n\nworks in ```\nO(n)```\n complexity\nso the total is ```\nO(n*logn)+O(n*logn)+O(n) = O(n*logn)```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Haskell - Values do not save after a ForM loop\r\n                \r\nI want to be able to create a program in haskell that can an find an increasing subsequence from a list of numbers (not yet completed, this part is to compute for each sublist what the longest increasing subsequence is within that sublist). This program essentially take take from an input such as\n\n```\n1\n5\n1 2 9 6 8\n```\n\n\nwhere the first line is the number of test cases and the second line being the number of numbers in the specific test case, and the third line being the test case itself. It is looking for the multiple increasing sequences within the test case. Here is what I have so far:    \n\n```\nmain = do   \n    inputCases <- getLine\n    let cases = (read inputCases :: Int)\n    forM [1..cases] $ \\num -> do\n        inputNumbers <- getLine\n        let numbers = (read inputNumbers :: Int)  \n        something <- getLine\n        let singlewords = words something\n            list = f singlewords\n        let hello = grid numbers numbers 0\n        let second  = hello\n        print list\n        forM [0..numbers] $ \\check -> do\n            forM [check..numbers] $ \\check2 -> do\n                let val = 1\n                let keeper = val\n                forM [check..check2] $ \\check3 -> do\n                    let val = getVal hello list keeper check check2 check3\n                    let keeper = val\n                    return()\n                print check\n                print check2\n                print val\n                let hello = updateMatrix second val (check, check2)\n                let second = hello\n\n\nf :: [String] -> [Int]\nf = map read\n\ngrid :: Int -> Int -> a -> [[a]]\ngrid x y = replicate y . replicate x\n\ngetVal :: [[Int]] -> [Int] -> Int -> Int -> Int -> Int -> Int\ngetVal m b second x y z = \n    if b!!z < b!!y && 1+m!!x!!z > second then 1+m!!x!!z\n    else second\n\nupdateMatrix :: [[a]] -> a -> (Int, Int) -> [[a]]\nupdateMatrix m x (r,c) =\n  take r m ++\n  [take c (m !! r) ++ [x] ++ drop (c + 1) (m !! r)] ++\n  drop (r + 1) m\n```\n\n\nHowever, my problem is that once the program exits the ForM loop, it does not save the variable \"hello\" or anything that was declared in the for loop. Is there a better way of doing this? Would recursion work in this case? I am not quite sure how that would be implemented\nlis[i][j] will hold the length of the longest increasing subsequence in {a[i], ..., a[j]}\n\nhere is the python code that I am trying to translate. Given this code, is there a better way of doing this besides the way I am currently trying to do it?\n\n```\nT = int(input())\nfor t in range(0, T):\n\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    lis = [[0 for j in range(0, n)] for i in range(0, n)]\n\n    for i in range(0, n):\n        for j in range(i, n):\n            val = 1\n            for k in range(i, j):\n                if(a[k] < a[j] and 1 + lis[i][k] > val):\n                    val = 1 + lis[i][k]\n            lis[i][j] = val\n```\n\n    ", "Answer": "\r\nIn my other answer, I discussed the answer to the question you asked about how to store information for retrieval later when in a ```\nforM```\n loop. In this answer, I will discuss the idiomatic translation of ```\nfor```\n loops from other languages; generally this is not to produce a ```\nforM```\n loop in Haskell.\n\nBecause this is an excellent programming exercise, I don't want to give away the answer -- there's a lot of joy and learning to be had from solving the problem yourself. But I do want to illustrate an alternative approach. To keep all the interesting bits of the translation I cooked up of your Python code, I will solve a slightly easier problem in a slightly stylized way: instead of ```\nlis[i][j]```\n giving the length of the longest increasing subsequence between indices ```\ni```\n and ```\nj```\n in the original list, we will have ```\nlis[i][j]```\n give the largest value between indices ```\ni```\n and ```\nj```\n in the original list.\n\nThe idea will go like this: instead of iterating over indices ```\ni```\n and ```\nj```\n, we'll iterate over suffixes starting at ```\ni```\n, then over prefixes of suffixes starting at ```\ni```\n and ending at ```\nj```\n. To begin with, we'll do the naive thing of just calling ```\nmaximum```\n on each infix expression. So:\n\n```\nimport Data.List\n\nmaxes0 a =\n    [ [ maximum inf\n      | inf <- tail (inits suff)\n      ]\n    | suff <- init (tails a)\n    ]\n```\n\n\nFor example, we can try it on your example list in ghci:\n\n```\n> maxes0 [1,2,9,6,8]\n[[1,2,9,9,9],[2,9,9,9],[9,9,9],[6,8],[8]]\n```\n\n\nNote right away that there's a difference in shape here: where in Python we produced a square result, here we produce a triangular one, omitting the useless entries that do not correspond to actual infix chunks of the original list. (It's easy to reintroduce dummy values if you actually need a square result for some reason.)\n\nThis is already pretty good, and quite idiomatic; however, there is one part of the Python code that it does not capture well yet: the Python code reuses previously computed values to do some dynamic programming. This can be done to the above code, as well, though it does require a bit of mental gymnastics the first few times you see it. We will use laziness and recursion to make available earlier results when computing later ones.\n\nThe idea here will be to keep a rolling max as we traverse the suffix, merging as we go the list of maximums of infixes with the new values we see in the suffix. So:\n\n```\nmaxes1 a =\n    [ let row = head suff : zipWith max row (tail suff)\n      in row\n    | suff <- init (tails a)\n    ]\n```\n\n\nWe can see in ghci that this works just the same:\n\n```\n> maxes1 [1,2,9,6,8]\n[[1,2,9,9,9],[2,9,9,9],[9,9,9],[6,8],[8]]\n```\n\n\nYou can combine these two ideas (making the already-computed bits available via laziness+recursion, and making the infix list available by nested list comprehensions) to produce an idiomatic translation of the Python code which is completely pure, does not mention list indices anywhere, and does not use ```\nforM```\n.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How do I memoize this LIS python2.7 algorithm properly?\r\n                \r\nI'm practicing Dynamic Programming and I am writing the Longest Increasing Subsequence problem.\n\nI have the DP solution:\n\n```\ndef longest_subsequence(lst, lis=[], mem={}):\n  if not lst:\n    return lis\n  if tuple(lst) not in mem.keys():\n    if not lis or lst[0] > lis[-1]:\n      mem[tuple(lst)] = max([longest_subsequence(lst[1:], lis+[lst[0]], mem), longest_subsequence(lst[1:], lis, mem)], key=len)\n    else:\n     mem[tuple(lst)] = longest_subsequence(lst[1:], lis, mem)\n  return mem[tuple(lst)]\n```\n\n\nAnd a non-memoized version\n\n```\ndef longest_subsequence(lst, lis=[]):\n  if not lst:\n    return lis\n  if not lis or lst[0] > lis[-1]:\n    result = max([longest_subsequence(lst[1:], lis+[lst[0]]), longest_subsequence(lst[1:], lis)], key=len)\n  else:\n    result = longest_subsequence(lst[1:], lis)\n  return result\n```\n\n\nHowever, the two functions have different behaviours. For example, the test case ```\nlongest_subsequence([10,9,2,5,3,7,101,18])```\n fails for the memoized version. \n\n```\n>>> longest_subsequence([10,9,2,5,3,7,101,18])\n[10, 101]\n```\n\n\nThe non-memoized version is fully correct however (although much slower). \n\n```\n>>> longest_subsequence([10,9,2,5,3,7,101,18])\n[2, 5, 7, 101]\n```\n\n\nwhat I am doing wrong?\n    ", "Answer": "\r\nYour state depends on both ```\nlst```\n and previous item you have picked. But you are only considering the ```\nlst```\n. That is why you are getting incorrect results. To fix it you just have to add previous item to your dynamic state.\n\n```\ndef longest_subsequence(lst, prev=None, mem={}):\n  if not lst:\n    return []\n  if (tuple(lst),prev) not in mem:\n    if not prev or lst[0] > prev:\n      mem[(tuple(lst),prev)] = max([[lst[0]]+longest_subsequence(lst[1:], lst[0]), longest_subsequence(lst[1:], prev)], key=len)\n    else:\n     mem[(tuple(lst),prev)] = longest_subsequence(lst[1:], prev)\n\n  return mem[(tuple(lst),prev)]\n\nprint longest_subsequence([3,5,6,2,5,4,19,5,6,7,12])\n```\n\n\nNote that using the ```\ntuple(list)```\n as your dynamic state is not a very good idea. You can simply use the index of the item in the ```\nlist```\n that you are checking instead of the whole list:\n\n```\ndef longest_subsequence(lst, index=0, prev=None, mem={}):\n  if index>=len(lst):\n    return []\n  if (index,prev) not in mem:\n    if not prev or lst[index] > prev:\n      mem[(index,prev)] = max([[lst[index]]+longest_subsequence(lst, index+1, lst[index]), longest_subsequence(lst, index+1, prev)], key=len)\n    else:\n      mem[(index,prev)] = longest_subsequence(lst,index+1, prev)\n\n  return mem[(index,prev)]\n\nprint longest_subsequence([3,5,6,2,5,4,19,5,6,7,12])\n```\n\n\nFor more efficient approaches you can check this question.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Segmentation fault (core dumped) error, in a C search function\r\n                \r\nI'm trying to write a C program to take an array of discrete positive integers and find the length of the longest increasing subsequence.\n\n'int* a' is the array of randomly generated integers, which is of length 'int b'\n\ncall:\n```\nlis_n = answer(seq, seq_size);```\n\n\nfunction:\n\n```\nint answer(int* a, int b) {\n    if (a == NULL) {return -1;}\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    //instantiate max and set it to 0\n    int max = 0;\n    //make an array storing all included numbers\n    int included[b];\n    memset(included, 0, b*sizeof(int));\n    //create a pointer to the index in included[] with the largest value\n    int indexMax = 0;\n    //create a pointer to the index in a[]\n    int indexArray = 0;\n    //index of a[] for max included\n    int maxToA = 0;\n    //set the first included number to the first element in a[]\n    included[indexMax] = a[indexArray];\n    //loop until break\n    while (1) {\n        if (a[indexArray] > included[indexMax]/*digit greater than last included*/) {\n            //include the digit\n            included[indexMax+1] = a[indexArray];\n            //increment current max pointer\n            indexMax++;\n        }\n        j = b - 1;\n        while (indexArray >= j/*pointer is at end\"*/) {\n            if (j == (b - 1)) {\n                if ((indexMax+1) > max/*total is greater than current max*/) {\n                    max = indexMax + 1;\n                }\n            }\n            if (a[b-1] == included[0]/*last element is in included[0], stop*/) {\n                return max;\n            } else {\n                //max included is set to zero\n                included[indexMax] = 0;\n                //max included pointer decreased\n                indexMax--;\n                //set array pointer to new max included\n                for (k=0;k<(b-1);k++) {\n                    if (a[k] == included[indexMax]) {\n                        indexArray = k;\n                    }\n                }\n                //increment array pointer\n                indexArray++;\n                j--;\n            }\n        }\n        indexArray++;\n\n        printf(\"(\");\n        for (i=0;i<b;i++) {\n            printf(\"%d,\",included[i]);\n        }\n        printf(\")\");\n    }\n}\n```\n\n\nI'm receiving 'Segmentation fault (core dumped)' in the terminal upon running.\n\nAny help would be awesome.\n    ", "Answer": "\r\nYou have declared\n\n```\nint indexMax = 0;\n```\n\n\nAnd here you use it as an array index\n\n```\nincuded[indexMax] = 0;\n```\n\n\nYou increment and decrement it\n\n```\nindexMax++;\n...\nindexMax--;\n```\n\n\nYou check its range but you don't limit it, you alter the value you compare it with\n\n```\nif ((indexMax+1) > max/*total is greater than current max*/) {\n                max = indexMax + 1;\n}\n```\n\n\nYou never check ```\nindexMax```\n against ```\nb```\n or with ```\n0```\n\n\n```\nint included[b];\n```\n\n\nSo you are almost guaranteed to exceed the bounds of ```\nincluded[]```\n.\n\nSome general points of advice. Make your function and variable names meaningful. Avoid making a premature exit from a function wherever possible. Avoid ```\nwhile(1)```\n wherever possible. And never make assumptions about array sizes (including C \"strings\"). It might seem hard work putting in the overhead, but there is a payoff. The payoff is not just about catching unexpected errors, it makes you think about the code you are writing as you do it.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Recursive call resulting in nonetype return\r\n                \r\n```\nimport sys\n\nmemo={}\nsize_memo={}\n\ndef DP(arr,n):\n\n    global memo\n    global size_memo\n\n    if(n==0):\n        memo[n]=0\n        size_memo[n]=1\n        return memo[n], size_memo[n] \n\n    if(n in memo.keys()):\n        return memo[n], size_memo[n]\n    else:\n\n        if(n-1 in memo.keys()):\n            last=memo[n-1]\n            last_size=size_memo[n-1]\n        else:\n            last, last_size= DP(arr, n-1)\n\n        if(arr[n]>arr[last]):\n            # we will obviously include n in the lis\n            new_size=last_size+1\n            memo[n]=n \n            size_memo[n]=new_size\n\n        else:\n\n            #forcefully including n and creating new longest_ss ending with n  and comparing with what last longest_seq\n            i=n\n            size_inc=1\n            while(arr[i]>arr[i-1]):\n                size_inc+=1\n                i-=1    \n\n            if(size_inc>size_exc):\n                size_memo[n]=size_inc\n                memo[n]=n\n\n                return memo[n], size_memo[n]\n            else:\n                size_memo=size_exc\n                memo[n]=last\n\n                return memo[n], size_memo[n]\n\narr=[10, 22, 9, 33, 21, 50, 41, 60, 80]\n\nl=len(arr)-1\n\nprint(DP(arr,l))\n\n```\n\n\nError at line : last, last_size= DP(arr, n-1)\n\nError message: cannot unpack non-iterable NoneType object\n\nI can not understand why the recursive call is giving this error. please can anyone help?\n\nI am trying to write a DP to calcualte longest increasing subsequence in an array, but the recursiion is giving this error.\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Why do I get list index out of range even though I've kept a condition to check so?\r\n                \r\nI'm getting list index out of range even though I've kept a condition so that it would not check such a state where the index is not inside the limit specified. Please go through the code below.\n\n```\nT=int(input())\nc=1;\nf=0;\nd=[]\nfor i in range(T):\n    a=int(input())\n    A=list(map(int, input().strip().split()))\n    b=int(input())\n    B=list(map(int, input().strip().split()))\n    for j in range(a-1):\n        for k in range(b):\n            if(A[j] == B[k]):\n                if(j+c < a, k+c< b):\n                    while(f==0):\n                            if(j+c < a, k+c < b):\n                                c += 1\n                                if(A[j+c]==B[k+c]):\n                                    f=1\n                if(f==0):            \n                    d.append(c)\n        f=0;\n        c=1;\n    d.sort;\n    d= []\n    print (d[-1])\n```\n\n\nThis is the error that I get:\n\n```\n    Runtime Error:\nRuntime ErrorTraceback (most recent call last):\n  File \"/home/a065c7cd2e000ec65fe6b148ca7dee08.py\", line 17, in <module>\n    if(A[j+c]==B[k+c]):\nIndexError: list index out of range\n```\n\n\nI was trying to solve the question of Longest Common Increasing Subsequence. It would be helpful if the correct for it would be provided otherwise. :)\n\nGiven two arrays, find length of the longest common increasing subsequence (LCIS).  For example length of LCIS for A[] = {3, 4, 9, 1} and B[] = {5, 3, 8, 9, 10, 2, 1}  is 2 ( The subsequence {3, 9} is the longest subsequence that is both common and increasing.   As another example LCIS for A[] = {1, 1, 4, 3} and B[] = {1, 1, 3, 4} is 2 (There are two subsequences {1, 4} and {1, 3}).\n    ", "Answer": "\r\nFirst, the statement ```\nif(a, b):```\n is not the same as ```\nif(a and b):```\n, as ```\nif(a, b):```\n is checking whether the tuple ```\n(a, b)```\n is empty or not, and since it is not empty, it returns true no matter what. Try\n\n```\nif(False, False):\n    print('What?!')\n```\n\n\nand see that the print does execute.\n\nFor your question, within your code you have this:\n\n```\nif(j+c < a and k+c < b):\n    c += 1\n    if(A[j+c]==B[k+c]):\n```\n\n\nso, suppose that ```\nj+c```\n is 1 and ```\na```\n is 2, we'd enter the block. Then, we add one to ```\nc```\n, so now ```\nj+c```\n is 2, and ```\na```\n is 2, and then we'd check ```\nA[2]```\n which is out of bounds.\n\nAnd as a side note, you can use the len function to get the length of a list. So your input could look like:\n\n```\nA=list(map(int, input('A:').strip().split()))\nB=list(map(int, input('B:').strip().split()))\na, b = len(A), len(B)\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest consecutive subsequence in dates array\r\n                \r\nHi I have an ```\nArraylist```\n containing dates in increasing order. Dates are of this format ```\nyyyy-MM-dd```\n. Now I want to find out longest consecutive subsequence in that ```\nArraylist```\n. I have checked for solutions online but they are related to int arrays and I want to find out for dates array.\nCode for int array:\n\n```\n// Returns length of the longest contiguous subarray\nint findLength(int arr[], int n)\n{\nint max_len = 1;  // Initialize result\nfor (int i=0; i<n-1; i++)\n{\n    // Initialize min and max for all subarrays starting with i\n    int mn = arr[i], mx = arr[i];\n\n    // Consider all subarrays starting with i and ending with j\n    for (int j=i+1; j<n; j++)\n    {\n        // Update min and max in this subarray if needed\n        mn = min(mn, arr[j]);\n        mx = max(mx, arr[j]);\n\n        // If current subarray has all contiguous elements\n        if ((mx - mn) == j-i)\n            max_len = max(max_len, mx-mn+1);\n    }\n}\nreturn max_len;  // Return result\n}\n\n// Utility functions to find minimum and maximum of\n// two elements\nint min(int x, int y) { return (x < y)? x : y; }\nint max(int x, int y) { return (x > y)? x : y; }\n```\n\n    ", "Answer": "\r\ntl;dr\n\n```\nChronoUnit.DAYS.between ( \n    LocalDate.parse( previousString ) , \n    LocalDate.parse( currentString )\n)\n```\n\n\nString != date\n\n\n  I have an Arraylist containing dates in increasing order. Dates are of this format yyyy-MM-dd.\n\n\nThat means you have a ```\nList```\n of String objects, not dates. The main challenge here is to get date objects so you can calculate days in between them. \n\njava.time\n\nThe modern way is with the java.time classes that supplant the troublesome old legacy classes (```\nDate```\n, ```\nCalendar```\n, etc.).\n\nYour input strings happen to comply with standard ISO 8601 formats. And the java.time classes happen to use ISO 8601 formats by default when parsing/generating strings. So no need to specify a formatting pattern.\n\n```\nList<String> inputs = new ArrayList<> ();\ninputs.add ( \"2016-01-23\" );\ninputs.add ( \"2016-01-25\" );\ninputs.add ( \"2016-02-22\" ); // End of longest period between dates.\ninputs.add ( \"2016-02-25\" );\ninputs.add ( \"2016-02-28\" );\n```\n\n\nThe ```\nLocalDate```\n class represents a date-only value without time-of-day and without time zone.\n\nThe strategy of this example code is to calculate the days between each ```\nLocalDate```\n (parsed from each incoming String) and the previous ```\nLocalDate```\n. If longer than the longest seen so far, forget the old longest and remember the current loop’s data. \n\n```\nLocalDate longestStart = null;\nLocalDate longestStop = null;\nLocalDate previousDate = null;\nlong longestInDays = 0;\n```\n\n\nThe ```\nChronoUnit```\n enum has handy methods such as calculating elapsed days.\n\n```\nfor ( String input : inputs ) {\n    LocalDate currentDate = LocalDate.parse ( input );\n    if ( null == previousDate ) {  // First loop.\n        previousDate = currentDate;\n        continue;  // Skip the rest of this first loop.\n    }\n    long currentDays = ChronoUnit.DAYS.between ( previousDate , currentDate );\n    if ( currentDays > longestInDays ) {\n        // If the current loop exceeds previous longest, remember this one as longest.\n        longestInDays = currentDays;\n        longestStart = previousDate;\n        longestStop = currentDate;\n    }\n    // Prepare for next loop.\n    previousDate = currentDate;\n}\n```\n\n\nDump results to console.\n\n```\nSystem.out.println ( \"Longest period has days: \" + longestInDays + \" = \" + longestStart + \"/\" + longestStop );\n```\n\n\n\n  Longest period has days: 28 = 2016-01-25/2016-02-22\n\n\nSee live code in IdeOne.com.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to prove correctness of the following algo\r\n                \r\nProblem is to find LIS(Longest Increasing Subsequence) of any given array.\nEx. a[]={10,9,7,8,9};\nlength=3;  {7,8,9}\n\nSo one way of doing in nlogn is\n\n\nSort the array\nTake LCS of the the two\nResulting is LIS.\n\n\nNow I understood how to do it. But how do I prove it is correct. How to apply MI here?\n    ", "Answer": "\r\nIn your case there is no need for induction, you have to show three things:\n\n\nresulting method captures increasing sequence - comes directly from the fact that it is a part of sorted array\nresulting subsequence exists in the input array - comes directly from the definition of LCS (common subsequence)\nthere is no longer increasing subsequence - you can easily show that the longest sequence has to be present in both input sequence (by definition) and in sorted array, so it would be also analyzed by LCS, thus it cannot be longer then the one returned by LCS.\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How can I use isSrderd and subsequences?\r\n                \r\nThe goal is to find the Longest Increasing Subsequence (LIS) of a list in Haskell.  I tried to run the following code, but the error of couldn't find modules appeared. I saw answers to  This question and I understand that the ordered package is old and not used anymore.\n```\nimport Data.Ord          ( comparing )\nimport Data.List         ( maximumBy, subsequences )\nimport Data.List.Ordered ( isSorted, nub )\nlis :: Ord a => [a] -> [a]\nlis = maximumBy (comparing length) . map nub  . filter isSorted . subsequences                 \n--    longest                    <-- unique <-- increasing    <-- all      \n\nmain = do\nprint $ lis [3,2,6,4,5,1]\nprint $ lis [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]\nprint $ lis [1,1,1,1]\n```\n\nTherefore, I tried to use only:\n```\nimport Data.List\n```\n\nbut I got the following error :\n```\nmain.hs:3:18: error:\n    Variable not in scope:\n       comparing :: (t0 a0 -> Int) -> [a] -> [a] -> Ordering\n  |\n3 | lis = maximumBy (comparing length) . map nub  . filter isSorted . subsequences                 \n  |                  ^^^^^^^^^\n\nmain.hs:3:56: error: Variable not in scope: isSorted :: [a] -> Bool\n  |\n3 | lis = maximumBy (comparing length) . map nub  . filter isSorted . subsequences                 \n  |                                                        ^^^^^^^^\nexit status 1\n```\n\n    ", "Answer": "\r\n```\nnub```\n is now in ```\nData.List```\n. If an ```\nisSorted```\n function is available in any normal library, Hoogle doesn't show it. You can easily write one yourself, though I haven't given much thought to whether the following suggestion is the most efficient implementation - and it probably doesn't work with infinite lists (I think that the answer to both questions is no):\n```\nisSorted :: Ord a => [a] -> Bool\nisSorted l = sort l == l\n```\n\n(Using sort from ```\nData.List```\n.)\nWith these imports:\n```\nimport Data.Ord (comparing)\nimport Data.List (maximumBy, subsequences, nub, sort)\n```\n\nthe ```\nlis```\n function now compiles.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Length of longest increasing subarray after rotating array left/right\r\n                \r\nI encountered this problem on a competitive programming platform:\n\nGiven an array of length N and Q queries, where a query is either left or right rotation of the array. Find the length of longest sub-array in array after every rotation.\n\nAlthough an O(N * Q) approach was an acceptable answer, I can't help but think there there must be a faster approach since every rotation would modify length of only 2 potential sub-sequences.\n\nI thought about duplicating the array and appending the duplicate array to get an array of length 2N:\n\n\n\nSo then if I take a window of size N:\n\n\nwith 0 rotations, answer would be longest increasing subarray in range [0, N - 1] where the window would start.\nwith 1 left rotation, answer would be longest subarray in range [1, N], i.e. move the window right by 1 unit.\nwith k left rotations, answer would be in range[k, N - 1 + k] which would be moving window right by k units from initial position. \n\n\nI was planning to save the answers for all possible queries by shifting the window right by 1 unit until I have checked for N-1 left rotations.\n\nFinding longest subarray for the range [0, N - 1] would be O(N) but I am not able to reduce time taken after every window shift. \n\nI had thought of using a priority queue, where I would store every index in the window and the length of longest subarray possible with the said index as start, and use the length of the subarray as priority. I am having troubles with updating the queue after a shift. I had initially thought that I would not have to make too many updates bringing down the algorithm's complexity down to O(N logN) but here I am not updating the subarray that were added before the window is shifted.\n\nI feel that if the priority queue is managed properly, the complexity could be brought down to O(N logN) from preprocessing and O(1) per query.\n\nEdit: The question was actually about longest increasing subarray, but I had used subsequence instead of using the word subarray which has been corrected after the edit.\n    ", "Answer": "\r\nConsider duplicated sequence (like you suggested). Try to group up elements such that if ai <= ai+1 then ai should be in the same group as ai+1. In that way you will divide the sequence into increasing continuous subsequences. Store those subsequences as pairs (begin, end). You can get a sorted list of them in O(N).\n\nNow let's calculate the results for all cyclic shifts. Let's start with the first N elements. Create a BST that will sort subsequences by their length. Insert all subsequences that end before N. If there is any subsequence that starts before N and ends after it (or later any subsequence that starts before our window and ends inside), we shall call it special. To get the result just take the maximum of length of subsequences in BST and a part of special ones that lies within the considered window. When you move to the next shift, the special one may fit entirely, so just insert it to the BST. You may also need to delete from BST an subsequence that starts before the window (it then becomes the special one). So you can get the maximum length from all the subsequences in the BST in O(log n) and from the special ones in O(1) (there are at most two of them at the same time).\n\nYou can even go for a O(n) complexity by changing BST into a queue (it is sometimes called min/max queue, or sliding window maximum/minimum, or whatever else, it enables to get minimum/maximum of elements, adding new one and deleting the first one added all in O(1))\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Improving the Longest Increasing Sequence Algorithm\r\n                \r\nFrom SPOJ, here is the problem statement. I started off with the normal DP solution, but that was going to take n^2 time and was bound to exceed the time limit. \n\nI came across the nlogn solution to the problem and here is the solution for that. \n\nThe solution works well if we just have to find the length of longest increasing subsequence, or if you have to find one of the sequences too. But If you have to find all the elements that are part of one sequence or the other, I did some storage and other stuff and I have reached this solution.\n\nNow this got expected by the SPOJ engine, but when I look at other accepted solutions, my program take .48 time where as others take as low as .04.\n\nI want to know, if possible, can someone tell me how can I improve my solution?\n\nWhat I am doing in my solution is that, in the output array, I am not only storing the current number, but the entire list, and in the parent, I am maintaining the parent of all, as each number becomes part of the output array.\n\nThe final array is nothing more than the final integer array, that stores boolean values, of whether that number belongs in the LIS or not.\n\nThanks\n\nPS It says that Links to ideone.com must be accompanied by code, hence pasting the code here itself.\n\n```\n#include<stdio.h>\n#include<stdlib.h>\n\nint count;\n\nstruct node{\n    int value;\n    struct node* next;\n};\n\nint constructFinal(int *final,struct node **parent,struct node **output,int value){\n    if(final[value - 1] == 1)\n        return 0;\n    final[value - 1] = 1;\n    count++;\n    struct node* temp;\n    temp = parent[value-1];\n    while(temp!= NULL){\n        constructFinal(final,parent,output,temp->value);\n        temp = temp->next;\n    }\n}\n\nint findIndex(int currentElement,struct node** output,int lower,int upper){\n    if(lower >= upper)\n        return lower;\n    int mid =lower + ( upper - lower )/2;\n    if(output[mid]->value < currentElement)\n        return findIndex(currentElement,output,mid+1,upper);\n    else if(output[mid]->value > currentElement)\n        return findIndex(currentElement,output,lower,mid);\n}   \n\nint main(){\n    int numOfInp,sizeOfInp,i,currentElement,sizeOfOut,indexBinary,indexAdded;\n    struct node *temp,*tempIter;\n    numOfInp=1;\n    while(numOfInp--){\n        scanf(\"%d\",&sizeOfInp);\n        struct node **output; // if I initialise normal initialisation, I may not get the data as 0 by default, hence callocing\n        struct node **parent;\n        int *input;\n        input = (int *)calloc(sizeOfInp,sizeof(int));\n        for(i=0 ; i< sizeOfInp ; i++)\n            scanf(\"%d\",&input[i]);\n\n        parent = (struct node**)calloc(sizeOfInp, sizeof(struct node*));\n\n        output = (struct node**)calloc(sizeOfInp, sizeof(struct node*));\n        sizeOfOut = 0;\n        for(i=0;i<sizeOfInp;i++){\n            indexBinary = -1;\n            currentElement = input[i];\n            if(sizeOfOut == 0){\n                output[sizeOfOut] = (struct node*)calloc(1,sizeof(struct node));\n                output[sizeOfOut]->value = currentElement;\n                indexAdded = sizeOfOut;\n                sizeOfOut++;\n            }\n            else{\n                if(currentElement > output[sizeOfOut-1]->value){\n                    output[sizeOfOut] = (struct node*)calloc(1,sizeof(struct node));\n                    output[sizeOfOut]->value = currentElement;\n                    indexAdded = sizeOfOut;\n                    sizeOfOut++;\n                }\n                else{\n                    indexBinary = findIndex(currentElement,output,0,sizeOfOut-1);\n                    temp = (struct node*)calloc(1,sizeof(struct node));\n                    temp->next = output[indexBinary];\n                    output[indexBinary] = temp;\n                    output[indexBinary]->value = currentElement;\n                    indexAdded = indexBinary;\n                }\n            }\n\n            //parent[currentElement-1] = (struct node*)calloc(sizeof(struct node));\n            if(indexAdded > 0){\n                tempIter = output[indexAdded-1];\n                while(tempIter != 0 && tempIter->value < currentElement){               //for all the elements in the previous bucket\n                    temp = (struct node*)calloc(1,sizeof(struct node)); //add the values to parent\n                    temp->next = parent[currentElement-1];\n                    parent[currentElement-1] = temp;\n                    parent[currentElement-1]->value = tempIter ->value;\n                    tempIter = tempIter->next;\n                }\n            }\n            else{\n                parent[currentElement-1] = NULL;    // these are the elements in the first bucket of output\n            }\n        }\n\n        int *final;\n        final = (int*)calloc(sizeOfInp,sizeof(int));\n        temp = output[sizeOfOut -1];\n        count=0;\n        while(temp != NULL){\n            constructFinal(final,parent,output,temp->value);\n            temp=temp->next;\n        }\n        printf(\"%d\\n\",count);\n        for(i=0;i<sizeOfInp;i++)\n            if(final[i]==1)\n                printf(\"%d \",i+1);\n        printf(\"\\n\");\n        free(output);\n        free(parent);\n\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nOne suggestion (that will probably only help a small amount) would be to avoid calling calloc so many times.\n\nYou can do this by preallocating a single array of the maximum size and keeping track of how many elements have been allocated inside it.\n\nIt may also help to change your recursive function calls into single iterative functions as this may avoid the overhead of calling the function.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Can someone explain this \"Longest Common Subsequence\" algorithm?\r\n                \r\nThe ```\nLongest Common Subsequence (LCS)```\n problem is: given two sequences ```\nA```\n and ```\nB```\n, find the longest subsequence that is found both in ```\nA```\n and in ```\nB```\n. For example, given ```\nA = \"peterparker\"```\n and ```\nB = \"spiderman\"```\n, the longest common subsequence is ```\n\"pera\"```\n.\nCan someone explain this ```\nLongest Common Subsequence```\n algorithm?\n```\ndef longestCommonSubsequence(A: List, B: List) -> int:\n    # n = len(A)\n    # m = len(B)\n    \n    indeces_A = collections.defaultdict(list)\n    \n    # O(n)\n    for i, a in enumerate(A):\n        indeces_A[a].append(i)\n    \n    # O(n)\n    for indeces_a in indeces_A.values():\n        indeces_a.reverse()\n    \n    # O(m)\n    indeces_A_filtered = []\n    for b in B:\n        indeces_A_filtered.extend(indeces_A[b])\n    \n    # The length of indeces_A_filtered is at most n*m, but in practice it's more like O(m) or O(n) as far as I can tell.\n    iAs = []\n    # O(m log m) in practice as far as I can tell.\n    for iA in indeces_A_filtered:\n        j = bisect.bisect_left(iAs, iA)\n        if j == len(iAs):\n            iAs.append(iA)\n        else:\n            iAs[j] = iA\n    return len(iAs)\n```\n\nThe algorithm as written finds the length of the ```\nlongest common subsequence```\n, but can be modified to find the ```\nlongest common subsequence```\n outright.\nI found this algorithm as I was looking at the fastest python solutions to an equivalent problem on leetcode link. This algorithm was the fastest python solution (40 ms) for the problem and it also seems to have ```\nO(m log m)```\n time complexity, which is much better than the ```\nO(m*n)```\n time complexity of most other solutions.\nI do not fully understand why it works and tried looking all over for known algorithms to the ```\nLongest Common Subsequence```\n problem to find other mentions of it, but couldn't find anything like it. The closest thing I could find was the ```\nHunt–Szymanski algorithm```\n link which is also said to have ```\nO(m log m)```\n in practice, but does not seem to be the same algorithm.\nWhat I kind of understand:\n\n```\nindeces_a```\n are reversed so that in the ```\niAs```\n for loop, the smaller index is kept (this is more apparent when doing the walkthrough below.)\nAs far as I can tell, the ```\niAs```\n for loop finds the ```\nlongest increasing subsequence```\n of ```\nindeces_A_filtered```\n.\n\nThanks!\n\nHere's a walkthrough of the algorithm for example ```\nA = \"peterparker\"```\n and ```\nB = \"spiderman\"```\n\n```\n     01234567890\nA = \"peterparker\"\nB = \"spiderman\"\n\nindeces_A = {'p':[0,5], 'e':[1,3,9], 't':[2], 'r':[4,7,10], 'a':[6], 'k':[8]}\n\n# after reverse\nindeces_A = {'p':[5,0], 'e':[9,3,1], 't':[2], 'r':[10,7,4], 'a':[6], 'k':[8]}\n\n#                     -p-  --e--  ---r--  a\nindeces_A_filtered = [5,0, 9,3,1, 10,7,4, 6]\n\n# the `iAs` loop\n\niA = 5\nj = 0\niAs = [5]\n\niA = 0\nj = 0\niAs = [0]\n\niA = 9\nj = 1\niAs = [0,9]\n\niA = 3\nj = 1\niAs = [0,3]\n\niA = 1\nj = 1\niAs = [0,1]\n\niA = 10\nj = 2\niAs = [0,1,10]\n\niA = 7\nj = 2\niAs = [0,1,7]\n\niA = 4\nj = 2\niAs = [0,1,4]\n\niA = 6\nj = 3\niAs = [0,1,4,6] # corresponds to indices of A that spell out \"pera\", the LCS\n\nreturn len(iAs) # 4, the length of the LCS\n```\n\n    ", "Answer": "\r\nThe missing bit here is \"patience sorting\", whose connection to longest increasing subsequence (LIS) is a bit subtle but well known. The final loop in the code is a bare bones implementation of patience sorting with \"the greedy strategy\". It does not, in general, compute a LIS directly, but rather the length of a LIS.\nAn easy-enough correctness proof, which includes a sketch of what's needed to reliably compute a LIS too (not just its length), can be found as Lemma 1 early in\n\n\"Longest Increasing Subsequences: From Patience Sorting to the Baik-Deift-Johansson Theorem\"\nDavid Aldous and Persi Diaconis\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Dictionary mutability issue while adding new key and value to the dictionary in python\r\n                \r\nI'm trying to find the longest increasing subsequence from the python list i'm passing. The final dictionary structure should look something like this:\n\n```\nExpected structure\nsubsequence_dict={ 0:[15], 1:[15,27], 2:[14],3:[15,27,38],4:[14,26],5:[15,27,38,55],6:[15,27,38,46],7:[15, 27, 38, 55, 65, 85]}\n\nOutput:\n{0: [15, 27, 38, 55, 65, 85], 1: [15, 27, 38, 55, 65, 85], 2: [14, 26, 46], 3: [15, 27, 38, 55, 65, 85], 4: [14, 26, 46], 5: [15, 27, 38, 55, 65, 85], 6: [14, 26, 46], 7: [15, 27, 38, 55, 65, 85], 8: [15, 27, 38, 55, 65, 85]}\n```\n\n\nAs looking at the key 0 in my output it looks there is some mutability issue.\n\nFor every value of i in the main function there should be a new key in the dict which has value as list coming from longest_subsequence function.\n\n```\nfrom copy import deepcopy\ndef longest_subsequence(dict_elent,subsequence_dict):\n    \"\"\"\n\n    :param dict_elent: Dictionary element to which the longest list last element to be compared\n    :param subsequence_dict: \n    :return:  List \n    \"\"\"\n    x=subsequence_dict.values()\n    sorted_list = sorted(x, reverse=True)\n    flag=False\n    for sublist in sorted_list:\n        if sublist[-1]<dict_elent:\n            sublist.append(dict_elent)\n            flag=True\n            break\n    if flag==True:\n        return  sublist\n    else:\n        return [dict_elent]\n\n\ndef main(d,subsequence_dict):\n    for i in range(len(d)):\n        if i==0 :\n            subsequence_dict[i]=[d[i]]\n        else:\n            subsequence_dict.update({i: longest_subsequence(d[i],subsequence_dict)})\n\nif __name__ == '__main__':\n    d=[15,27,14,38,26,55,46,65,85]\n    subsequence_dict={}\n    main(d,subsequence_dict)\n    print(subsequence_dict)\n```\n\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Using global variables in python function\r\n                \r\nI'm going through this solution for the Longest Increasing Subsequence problem and noticed that the global variable for the maximum value of the sub sequence length is being redefined both in the driver that runs the main function as well as in the actual function that computes the longest sub sequence:\n\n```\n# global variable to store the maximum\nglobal maximum\n\ndef _lis(arr , n ):\n\n    # to allow the access of global variable\n    global maximum\n\n    # Base Case\n    if n == 1 :\n        return 1\n\n    # maxEndingHere is the length of LIS ending with arr[n-1]\n    maxEndingHere = 1\n\n    \"\"\"Recursively get all LIS ending with arr[0], arr[1]..arr[n-2]\n       IF arr[n-1] is maller than arr[n-1], and max ending with\n        arr[n-1] needs to be updated, then update it\"\"\"\n\n    for i in xrange(1, n):\n        res = _lis(arr , i)\n        if arr[i-1] < arr[n-1] and res+1 > maxEndingHere:\n            maxEndingHere  = res +1\n\n    # Compare maxEndingHere with overall maximum.And update\n    # the overall maximum if needed\n    maximum = max(maximum , maxEndingHere)\n\n    return maxEndingHere\n\ndef lis(arr):\n\n    # to allow the access of global variable\n    global maximum\n\n    # lenght of arr\n    n = len(arr)\n\n    # maximum variable holds the result\n    maximum = 1\n\n    # The function _lis() stores its result in maximum\n    _lis(arr , n)\n\n    return maximum\n```\n\n\nIt would seem that each time a recursive call is made, the maximum value would be reset. What would be the purpose of redefining the global variables within the local scope of the functions? \n    ", "Answer": "\r\nYou have to use the ```\nglobal```\n keyword in a function to be able to change the variable globally; if you do not use the keyword, it will create a variable of local scope with the same name. The statement ```\nglobal maximum```\n does not “re-define” the variable, but it tells Python that if in this function ```\nmaximum```\n is set to some value, the global variable is meant to change.\n\n```\nIn [1]: a = 42\n\nIn [2]: def f():\n   ...:     a = 23\n   ...:\n\nIn [3]: f()\n\nIn [4]: a\nOut[4]: 42\n\nIn [5]: def g():\n   ...:     global a\n   ...:     a = 23\n   ...:\n\nIn [6]: g()\n\nIn [7]: a\nOut[7]: 23\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Finding total number of subsequences in an array with consecutive difference = k\r\n                \r\nIn the given array, I am trying to find the total number of  subsequences such that:\n\nthe difference between the consecutive terms is not greater than 3\nthe first element of the subsequence is the first element of the array\nthe last element of the subsequence is the last element of the array\n\nFor example, in an array: ```\n[10,13,7,8,14,200, 876, 11]```\n, it has 5 subsequences which follow the above condition.\nI am trying a bottom-up approach to this. I tried the following, but it does not give all the subsequences and outputs 4 instead of 5.\nHow can I approach this? I have an intuition that the approach could be similar to Longest Increasing Subsequence, but not sure how.\n    ", "Answer": "\r\nLet f(i) be the number of subsequences that fulfill the following conditions:\n\nStart by A[0]\nEnd by A[i]\nThe difference between the consecutive terms is not greater than 3\n\nThen the answer to your problem will be f(A.length()-1).\nHere is the code in C++ in a bottom-up approach:\n```\nint A[] = {10,13,7,8,14,11};\nint f[6];\nint n = 6;\n    \nfor (int i=0;i<n;i++) f[i] = 0;\nf[0]=1;\nfor (int i=1;i<n;i++){\n  for (int j=0;j<i;j++){\n     if (abss(A[i] - A[j]) <= 3)\n         f[i] += f[j];\n  }\n}\ncout<<f[n-1]<<endl;//printing the result\n```\n\nHere is the code written in C++ in top-down approach:\n```\nint A[] = {10,13,7,8,14,11};\nint n = 6;\n\nint memo[6];//initialized with -1s;\n\nint count(int currIndex){\n  if (currIndex == n-1) return 1;\n  if (memo[currIndex] != -1) return memo[currIndex];\n  \n  int res = 0;\n  for (int i=currIndex+1 ; i<n ; i++){\n      if (abss(A[currIndex] - A[i]) <= 3){\n            res += count(i);\n      }\n  }\n    \n  memo[currIndex] = res;\n  return res;\n}\n\n```\n\nAnd the result will be by calling count at first index like this:\n```\ncount(0);\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "How to print the actual bitonic subsequence?\r\n                \r\nGiven an array arr[0 … n-1] containing n positive integers, a subsequence of arr[] is called Bitonic if it is first increasing, then decreasing. Write a function that takes an array as argument and returns the length of the longest bitonic subsequence.\n\nInput arr[] = {1, 11, 2, 10, 4, 5, 2, 1};\nOutput: 6 (A Longest Bitonic Subsequence of length 6 is 1, 2, 10, 4, 2, 1)\n\nNow, for finding out the length, I calculated first the length of LIS (Longest Inc. Subsequence) and then the length of the LDS (Longest Dec. Subsequence) and then traversed over both the arrays, while doing ```\nmax(lis[i] + lds[i]-1)```\n where ```\ni varies from 0 to (n-1)```\n. \n\n```\nfor ( i = 0; i < n; i++ )   // Code for LIS\n{\n    for ( j = 0; j < i; j++ )\n    {\n        if (arr[i] > arr[j] && lis[i] < lis[j] + 1)\n            lis[i] = lis[j] + 1;\n    }\n}\n\nfor ( i = 0; i < n; i++ )   // Code for LDS\n{\n    for ( j = 0; j < i; j++ )\n    {\n        if (arr[i]  < arr[j] && lds[i] < lds[j] + 1)\n            lds[i] = lds[j] + 1;\n    }\n}\n```\n\n\nNow, if I am asked to print the actual bitonic subsequence, how can I do that? One way I thought of is to find out the index where maximum occurs. Now, I know the values of LIS and LDS at that index and then, I print the LIS and LDS from that index. But, I couldn't really formulate this idea properly.\n    ", "Answer": "\r\nYour idea is spot-on. When you compute the maximum length as ```\nmax(lis[i] + lds[i]-1)```\n, store ```\ni```\n of the actual maximum, where the sequence changes from increasing to decreasing. Let's call it ```\nmaxIndex```\n.\n\nNow you can produce the sequence as follows:\n\n\nStart at ```\nprev=maxIndex, i=maxIndex-1```\n, and go down in the order of decreasing indexes until you find ```\nlis[i]==lis[prev]-1 && arr[i] < arr[prev]```\n.\nStore ```\narr[i]```\n in the result list ```\nres```\n, set ```\nprev=i```\n, and continue searching down the array\nStop when you reach ```\nlis[i]==1```\n.\nInvert the ```\nres```\n list\nAdd ```\narr[maxIndex]```\n to ```\nres```\n\nStart at ```\nprev=maxIndex, i=maxIndex+1```\n, and go up the array until you find ```\nlds[i]==lis[prev]-1 && arr[i] < arr[prev]```\n\nStore ```\narr[i]```\n in the result list ```\nres```\n, set ```\nprev=i```\n, and continue searching down the array\nStop when you reach ```\nlds[i]==1```\n.\n\n\nThis approach uses ```\nlis```\n and ```\nlds```\n arrays to reconstruct both portions of the bitonic sequence. Since the first part of the sequence needs to be retrieved in reverse order, the portion of the list from 0 to ```\nmaxIndex```\n needs to be reversed.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Debug recursion problem; incorrect output\r\n                \r\nI am trying to write a program that'll find the length of the longest (adjacent) increasing subsequence in a vector with n elements.\nI have written my code with recursion for exercise on understanding the subject. When trying to compile the program earlier, instead of 4, my output was 12 on getting the longest increasing sequence. I'm trying to get the correct output. I'm under suspicion that my counters are not incrementing correctly. My \"largest element\" function works properly, but my issues lie within my sequence function. Help would be appreciated. I am still learning how recursion works.\nHere is my code (.hpp file just has my two prototypes):\n```\n#include <iostream>\n#include <vector>\n#include \"increasing_sequences_recursive.hpp\"\n\nint main() {\n    std::vector<int> numbers;\n    int input;\n    int startIdx = 0;\n\n    std::cout << \"Enter a set of numbers (0 to stop): \" << std::endl;\n\n    while (true) {\n        std::cin >> input;\n\n        if (input != 0) {\n            numbers.push_back(input);\n        }\n        else {\n            break;\n        }\n    } \n    \n    startIdx = numbers.size();\n    std::cout << \"Length of longest sequence: \" <<\n           increasing_sequences_recursive(numbers, startIdx);\n\n    return 0;\n}\n\n// Recursively find the largest sequence\nint increasing_sequences_recursive(std::vector<int> &numbers, int startIdx) {\n    int counter = 0;\n    int maxCounter = 0;\n\n    if (startIdx == 1) {\n        return 1;\n    }\n    int largeElmt = largestElement(numbers, startIdx);\n    counter += increasing_sequences_recursive(numbers, startIdx - 1);\n    if (numbers[startIdx - 1] <= largeElmt) {//numbers[startIdx]) {\n        counter++;\n        if (counter >= maxCounter) {\n            maxCounter = counter;\n        }\n    }\n    else {\n        if (counter >= maxCounter) {\n            maxCounter = counter;\n        }\n    }\n\n    return maxCounter;\n}\n\n// Recursively find the largest element.\nint largestElement(std::vector<int> &numbers, int n) {\n    // Assume n >= 1; Find largest element in the first\n    // n elements of n \"numbers\"\n    if (n == 1)\n        return numbers[n - 1];\n\n    int res = largestElement(numbers, n - 1);\n    if (res > numbers[n - 1])\n        return res;\n\n    return numbers[n - 1];\n}\n```\n\n    ", "Answer": "\r\nThis sounds like a homework assignment, thus I'm not going to find a bug in your code since it won't be useful for you in any sense. Instead, I'll give some hints that I hope will lead you in the right direction.\n\nFirst, there is nothing weird C++-specific in your code going on. Thus, it is essentially not a C++ question, but rather an algorithmic question.\n\nThe essence of recursion is to formulate a parametrized task ```\nF(N)```\n in terms of the task of lower values of the parameter, e.g. in terms of ```\nF(N-1)```\n, and to define a trivial case, e.g. ```\nF(0)```\n. In your case, ```\nF(N)```\n might stand for \"the length of the longest increasing subsequence withing the first N+1 elements of the whole sequence\" (I use \"N+1\" here to support zero-based indexing). How could we express ```\nF(N)```\n in terms of ```\nF(N-1)```\n?\n\nLet's call the sequence ```\nA```\n, and it's Nth element ```\nA[N]```\n (starting with zero). Then we can say that ```\nF(N)```\n is ```\nF(N-1)+1```\n in case ```\nA[N] >= A[N-1]```\n and ```\n1```\n otherwise. Check for yourself. And of course ```\nF(0)```\n is ```\n1```\n. Now your task is to translate this definition into C++. The code should look MUCH simpler than the one you came up with. But again, I'm not going to provide it here, since you should make it yourself.\n\nHTH\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Is this sequence an increasing or decreasing subsequence?\r\n                \r\nI have  a sequence of length 1. That is,\n\n```\n1\n```\n\n\nNow can I say that the ```\nlongest increasing subsequence```\n of length 1 in the above sequence is ```\n1```\n. And the ```\nlongest decreasing subsequence```\n of length 1 in the above sequence is ```\n1```\n ?\n    ", "Answer": "\r\nDegenerate sequence (i.e. a sequence of a single element) can be assigned whatever properties that you need: it is the longest increasing sequence, the longest decreasing sequence, and the longest sequence of equal elements.\n\nThis is important in situations when you define properties of sequences in terms of their sub-sequences: one-element sub-sequence gives you a base case; expanding it with another element gives you a two-element sequence.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Need help understanding why the following code does not work\r\n                \r\nI am trying to solve the Longest Increasing Subsequence problem on leetcode where I have to find the longest increasing subsequence in an array. I am attempting to solve it using Dynamic Programming (O(n^2) complexity).\n\nI have written 2 functions both of which attempt to solve the problem separately however only one function works. \n\nI tried to optimize the second function using the exact same logic of the first function however I am having trouble figuring out why it does not work.\n\nThe following function works: \n\n```\n// WORKS\nprivate int dp(int[] a) {\n    int[][] dp = new int[a.length+1][a.length+1];\n    for(int p = a.length-1; p >=0; p--) {\n        for(int i = a.length-1; i >=0; i--) {\n            if(i >= a.length)\n                dp[p][i] = 0;\n            else if(a[i] > a[p])\n                dp[p][i] = Math.max(dp[p][i+1], 1 + dp[i][i+1]);\n            else\n                dp[p][i] = dp[p][i+1];\n        }\n    }\n    return dp[0][0];\n}\n```\n\n\nIn the second function, I try to reduce the space needed by using 2 columns instead of a full matrix as we only need the values of column i+1 to fill a column i. However it does not work (col 1 is an array of 0s) and I cannot figure out why\n\n```\n// DOES NOT WORK\nprivate int dp_optimized(int[] a) {\n    int[] col1 = new int[a.length+1];\n    int[] col2 = new int[a.length+1];\n    for(int p = a.length-1; p >=0; p--) {\n        for(int i = a.length-1; i >=0; i--) {\n            if(i >= a.length)\n                col1[p] = 0;\n            else if(a[i] > a[p]) \n                col1[p] = Math.max(col2[p], 1+col2[i]);\n            else\n                col1[p] = col2[p];\n        }\n        for(int i=0; i< col1.length; i++)\n            col2[i] = col1[i];\n    }\n    return col1[0];\n}\n```\n\n\nIsnt this basically the same thing? Why does function 1 work and function 2 not work?\n\nAlso the main method calling these functions is as follows:\n\n```\npublic int lengthOfLIS(int[] nums) {\n\n    int[] a = new int[nums.length+1];\n    int[][] dp = new int[a.length+1][a.length+1];\n    for(int i = 1; i<nums.length+1; i++)\n        a[i] = nums[i-1];\n    a[0] = Integer.MIN_VALUE;\n    // return dp(a)\n    return dp_optimized(a);\n}\n```\n\n\n\nSample input: nums = [10,9,2,5,3,7,101,18]\nSample output: 4\n\n\nAny help would be appreciated. Thanks.\n    ", "Answer": "\r\nLet's start by making sure that we understand the recurrence correctly.\n\nDefinition: dp[p][i] stores the answer to the following question:\nWhat is the longest increasing subsequence of integers chosen from the elements with indices [i, a.length() - 1], with an additional constraint that the first element must be greater than a[p] (we will keep track of the last element taken by storing its index in the variable p)\n\nRecurrence: The answer of dp[p][i] is either:\n\n\ndp[p][i+1] : We ignored the i-th item and got the solution of the same problem but by considering only elements with indices [i + 1, a.length - 1]\n1 + dp[i][i+1] : We decided to take the i-th item as one of the integers in the optimal subsequence, so we counted the element taken, and now we're interested with elements with indices [i+1, a.length-1]. \nThis choice can only be considered if the i-th element is greater than the p-th element. The p in the sub-problem is changed to i, this to enforce that the next element to be chosen must be greater than the item we just took (the i-th one)\n\n\nLet's now discuss the code\n\nN^2 Memory Code:\n\nI made slight modifications to your correct code, let's take a look.\n\n```\nprivate int dp(int[] a) {\n    int[][] dp = new int[a.length+1][a.length+1];\n    for(int p = a.length-1; p >=0; p--) {\n        for(int i = a.length-1; i >p; i--) {\n            dp[p][i] = dp[p][i+1]; // Try to leave the i-th item\n            if(a[i] > a[p])        // Try to pick the i-th item\n                dp[p][i] = Math.max(dp[p][i], 1 + dp[i][i+1]);\n        }\n    }\n    return dp[0][1];\n}\n```\n\n\n1st Modification: I removed the following part ```\nif(i >= a.length) col1[p] = 0;```\n, the condition will not be ever satisfied.\n\n2nd Modification: The inner loop iterates between [p+1, a.length-1], since i must be always greater than p\n\n3rd Modification: Instead of returning ```\ndp[0][0]```\n, return ```\ndp[0][1]```\n, where the first item is an additional element that was not included in the original array and holds a value smaller than any other item. (dp[0][1] find the LIS of elements [1, a.length-1], given that there's no restriction on the first element to be picked)\n\nMemory Reduction:\n\nLet's think more about the dp table of the above code. The first dimension on the table is the previous index, the second dimension is the starting index in the array a (we're trying to find the LIS starting from i given previous p)\n\nTo reduce the memory for your dp solution you must ask yourself 2 questions:\n\n1- Which dimension can be reduced?\n\nTo answer this question you must go over each dimension separately and ask yourself if the current value of the dimension is x what other values of the current dimension do I depend on? The farthest value among these values gives us an idea of how much reduction can be done on this dimension.\n\nlet's apply the above technique to our problem.\n\n\nDimension p: if the value of p is x, then in the first subproblem ```\ndp[p][i+1]```\n we don't change x (this is great), however in the second subproblem ```\ndp[i][i+1]```\n x is changed to i, and i takes any value in the rage [i+1, a.length-1], hence, this dimension is irreducible!\nDimension i: if the value of i is x, then in the first subproblem ```\ndp[p][i+1]```\n we depend on the values stored in x+1, in the second subproblem ```\ndp[i][i+1]```\n we also depend on the values stored in x+1, this is great, It's clear that when the value of i is x we need only values in x+1 to be stored, we don't care at all about values stored in x+2 or x+3 ...\n\n\n2- What should be the order of our loops?\n\nWhen we're doing memory reduction, the order of the loops matter, the loop that iterates on the dimension to be reduced must be the outermost one! \n\nWhen our outer loop is the one that iterates over the second dimension i, the inner loops are responsible of calculating all values of dp[p][i] given that i is constant (in other words, calculates a full column in the dp table), after the calculation, we're ready to move to i-1 since all values in the i-th column are stored and ready to be used, after calculating all values in the (i-1)-th column we can move to i-2 and calculate all answers of i-2 using the answers stored only in the (i-1)-th column, and ignoring all values stored in the i-th column.\n\nSo let's reorder the loops of your code:\n\n```\nprivate int dp(int[] a) {\n    int[][] dp = new int[a.length+1][a.length+1];\n    for(int i = a.length-1; i>0; i--) {\n        for(int p = i-1; p>=0; p--) {\n            dp[p][i] = dp[p][i+1]; // Try to leave the i-th item\n            if(a[i] > a[p])        // Try to pick the i-th item\n                dp[p][i] = Math.max(dp[p][i], 1 + dp[i][i+1]);\n        }\n    }\n    return dp[0][1];\n}\n```\n\n\nNow let's reorder and modify the code you wrote in the dp-optimized function:\n\n```\nprivate int dp_optimized(int[] a) {\n    int[] col1 = new int[a.length+1];\n    int[] col2 = new int[a.length+1];\n    for(int i = a.length-1; i>0; i--) {\n        for(int p = i-1; p>=0; p--) {\n            col1[p] = col2[p];\n            if(a[i] > a[p]) \n                col1[p] = Math.max(col1[p], 1+col2[i]);\n        }\n        for(int p=0; p< col1.length; p++){\n            col2[p] = col1[p];\n        }\n    }\n    return col1[0];\n}\n```\n\n\nDone!\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Problem with getting Longest Convex Subsequence\r\n                \r\nA sequence X[1..m] of integers is said to be convex if X[i+1] - X[i] > X[i] - X[i-1] for every integer i between 2 and m-1. \n\n```\nfor (int i = 1; i < list.size(); i++) {\n            for (int j = 0; j < list.size(); j++) {\n                dp[i][j] = 2;\n                for (int k = 0; k < j; k++) {\n                    if (dp[j][k] + 1 > dp[i][j] && ((list.get(i) + list.get(k)) > (list.get(j) * 2))) {\n                        dp[i][j] = dp[j][k] + 1;\n                    }\n                    len = Math.max(len, dp[i][j]);\n                }\n            }\n        }\n```\n\n\nI have found there is a pattern that Given X[1..m], define Y[2..m] by letting Y[i] = X[i] - X[i-1]. Thus, Y is the sequence consisting of differences between successive terms of X. The sequence X is convex if and only if the sequence Y is increasing.\nI am wondering is there any way to get the subsequence like A = [0, 3, 7, 8, 13], then a longest convex subsequence is [0, 3, 7, 13]. \nThanks in advance.\n    ", "Answer": "\r\nYou are right in that this problem can be solved by dynamic programming. The general idea is to store the each possible valid convex subsequence that ends with each element of the original array with a specific max consecutive element difference, and then use all prior entries to construct the next subsequence.\n\nMore specifically, construct a 2D matrix that stores the longest convex sequence ending with at a specific ```\nindex```\n into the original array ```\nA```\n and largest difference between successive terms at most ```\ndiff```\n. So ```\ndp[3][11]```\n would give the longest convex substring which ends with the 3rd element of ```\nA```\n, and contains no successive differences larger than 11.\n\nUsing prior entries in this array, we can construct the row ```\nk```\n for the ```\nk```\nth element of your original array. Just iterate through each prior row ```\nj```\n, and concatenate ```\nA[k]```\n to each sequence at ```\ndp[j][diff]```\n, for ```\ndiff```\n in range ```\n[0, A[k]-A[j])```\n. Store this new sequence in ```\ndp[k][diff+1]```\n. Whenever there happens to be a collision at ```\ndp[k][diff+1]```\n for some ```\ndiff```\n, keep the longer of the two sequences. \n\nRinse and repeat this process until you have a row for element element in ```\nA```\n. Then just take the longest sequence out of the longest subsequence of each row. The longest subsequence will always be the last non-empty element in each row, so just iterate over each row backwards, and take the longest of the rows. This will be your longest convex subsequence.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "C++ reading a sequence of integers\r\n                \r\ngooday programers. I have to design a C++ program that reads a sequence of positive integer values that ends with zero and find the length of the longest increasing subsequence in the given sequence. For example,  for the following \nsequence of integer numbers:\n\n```\n1 2 3 4 5 2 3 4 1 2 5 6 8 9 1 2 3 0\n```\n\n\nthe program should return 6 \ni have written my code which seems correct but for some reason is always returning zero, could someone please help me with this problem. \n\nHere is my code: \n\n```\n#include <iostream> \nusing namespace std; \n\nint main() \n{ \n    int x = 1;          // note x is initialised as one so it can enter the while loop\n    int y = 0; \n    int n = 0;\n\n    while (x != 0)          // users can enter a zero at end of input to say they have entered all their numbers\n    { \n        cout << \"Enter sequence of numbers(0 to end): \";\n        cin >> x; \n        if (x == (y + 1))   // <<<<< i think for some reason this if statement if never happening \n        { \n            n = n + 1;\n            y = x;\n        } \n        else \n        {\n            n = 0;\n        }\n    } \n    cout << \"longest sequence is: \" << n << endl;\n    return 0; \n}\n```\n\n    ", "Answer": "\r\nIn your program, you have made some assumptions, you need to validate them first.\n\n\nThat the subsequence always starts at 1\nThat the subsequence always increments by 1\n\n\nIf those are correct assumptions, then here are some tweaks\n\n\nMove the ```\ncout```\n outside of the loop\nThe canonical way in C++ of testing whether an input operation from a stream has worked, is simply test the stream in operation, i.e. ```\nif (cin >> x) {...}```\n\nGiven the above, you can re-write your ```\nwhile```\n loop to read in ```\nx```\n and test that ```\nx != 0```\n\nIf both above conditions hold, enter the loop\nNow given the above assumptions, your first check is correct, however in the event the check fails, remember that the new subsequence starts at the current input number (value ```\nx```\n), so there is no sense is setting ```\nn```\n to ```\n0```\n. \nEither way, ```\ny```\n must always be current value of ```\nx```\n.\n\n\nIf you make the above logic changes to your code, it should work.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Java: Error Trying to Convert Comparable Array to Integer Array\r\n                \r\nI am currently implementing a generic version of the longest increasing subsequence problem in Java. The method works as intended, but when I try to use Comparable[] instead of Integer[] (or int[]), the program won't compile. The error given is \"Comparable cannot be cast to Integer\". I understand the error and what it means, but I don't know how to fix it. Any help would be greatly appreciated :)\n\nI have already tried making the method's return type a generic (>), but the problem is that Java does not allow generic array creation. I've tried just using Integer[] as my return type, and while that compiles and works properly, it's not what I want. \n\n```\npublic class LIS {\n  public static void main(String[] args) {\n    final Integer[] arr = {-1, 2, 4, 2, 33, 4, 7, 8, 10, 7, 5, 4, 5, 5, 1};\n    final Integer[] LIS = (Integer[]) lis(arr);\n    for (int i : LIS) {\n      System.out.print(i + \" \");\n    }\n  }\n\n  public static Comparable[] lis(Comparable[] arr) {\n    // We use Comparable[] so we can use interchangably with any Comparable type\n\n    final int N = arr.length;\n\n    // Java conveniently initializes array values to 0:\n    int[] lisEndingHere = new int[N];\n\n    for (int i = 0; i < N; i++) {\n      lisEndingHere[i] = 1;\n      int curMax = 0;\n      for (int j = 0; j <= i; j++) {\n        if (arr[i].compareTo(arr[j]) <= 0) continue;\n        if (lisEndingHere[j] > curMax) {\n          curMax = lisEndingHere[j];\n        }\n      }\n      lisEndingHere[i] += curMax;\n    }\n\n    // Find and return the longest increasing subsequence:\n    int max = 0;\n    for (int i = 0; i < N; i++) {\n      if (lisEndingHere[i] > max) max = lisEndingHere[i];\n    }\n\n    Comparable[] LIS = new Comparable[max];\n    for (int i = N-1; i >= 0 && max != 0; i--) {\n      if (lisEndingHere[i] == max) {\n        LIS[--max] = arr[i];\n      }\n    }\n\n    return LIS;\n  }\n}\n```\n\n    ", "Answer": "\r\nJust change the line\n\n```\nfinal Integer[] LIS = (Integer[]) lis(arr);\n```\n\n\nto\n\n```\nfinal Comparable[] LIS = lis(arr);\n```\n\n\nand also update the for loop.\n\nYour method returns a Comparable array, so you cant downcast to an Integer array, but since the implementation of your numbers are Integers, they are still treated as such during runtime.\n\nSetting the result to an Integer array is against the purpose of making a generic method anyways. For something to be passed to your method, it must have a compareTo method, and inherently has a toString method, and that satisfies everything you need the program to do.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest monotonically decreasing subsequence, with no consecutive elements included\r\n                \r\nfor example:\n\n```\ns = <6, 5, 4, 3, 2, 1>, s1 = <6, 4, 1>, s2 = <5, 2>, s3 = <5, 3, 2>\n```\n\n\nGiven ```\ns```\n as a sequence, ```\ns1```\n and ```\ns2```\n are the valid subsequences to be considered, but ```\ns3```\n is not because it contains a consecutive elements 3 and 2.\n\nHow do you find a longest such a subsequence so that it is monotonically decreasing in ```\nO(n^2)```\n\n\nI am aware of the version of the question that contains monotonic increase/ decrease. \n\nBut the additional condition here makes it difficult. \n\nA trivial solution would be to start at ```\ni = n'th```\n element as well as at ```\nj = (n-1)'th```\n element, solve as if solving for longest monotonically decreasing subsequence with consideration that next element is at ```\n(i-2)'th```\n and ```\n(j-2)'th```\n respectively and compare the length of two at the end. This will still give the ```\nO(n^2)```\n, but does seem way too trivial.\n\nIs there a better approach?\n    ", "Answer": "\r\n```\nD[i] = max { D[j] + 1 | a[i] < a[j], j < i + 1 } U {1} \n```\n\n\nExplanation: for each element ```\na[i]```\n, your Dynamic Programming (DP) checks for all numbers that are before it and with lower value, but not adjacent - if the new number can be used to extend the best sequence. In addition, you have the option to start a new sequence (that's when the {1} comes to play).\n\nExample:\nS = <6, 0, 5, 8, 4, 7, 6 >\n\n```\nD[1] = max { 1 } = 1  // sequence = <6>\nD[2] = max {1} = 1  // sequence = <0>\nD[3] = max {1, D[0] + 1 } = 2  // sequence = <6, 5>\nD[4] = max {1} = 1  // sequence = <8>\nD[5] = max{D[3] + 1, D[1] + 1, 1} = 3 // sequence = <6, 5, 4>\nD[6] = max{D[4] + 1, 1} = 2  // sequence = <8, 7>\nD[7] = max{D[4] + 1, 1} = 2  // sequence = <8, 6>\n```\n\n\nThe algorithm runs in ```\nO(n^2)```\n, since calculating ```\nD[i]```\n takes ```\nO(i)```\n time. From sum of arithmetic progression, this sums to ```\nO(n^2)```\n to calculate all.\n\nWhen you are done calculating all ```\nD[.]```\n,  you iterate through all of them, and find the maximal value. This is done in linear time.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest consecutive sequence where each element is less than 3\r\n                \r\nI've seen some longest consecutive sequence problems before such as find the increasing subsequence. I am now trying to further develop my skills. Given an array of integers, I want to find the longest consecutive sequence where the difference of all the elements in the respective subsequence is less than a given number, e.g. 3. An example is [10,11,12,15,13] where only the first three elements fulfill the condition. \nAlso, I want to return the indexes of the first and last element from the given array.\n\nI was thinking of making two functions; get_first_element(arr) and get_last_element(arr).\n\n```\ndef get_last_ele(arr):\n    longest_seq = 0\n    last_ele = 0\n\n    max_difference = 3\n\n    for i in range (0, len(arr)):\n\n        max_ele_seq = arr[i]\n        min_ele_seq = arr[i]\n        _count = 0\n        _last_ele = i\n        for j in range(i,len(arr)-i+1):\n            ele_j = arr[j]\n            if ele_j > max_ele_seq:\n                max_ele_seq = ele_j\n            if ele_j < min_ele_seq:\n                min_ele_seq = ele_j\n            if abs(max_ele_seq - min_ele_seq) > max_difference:\n                break\n\n            last_ele = j\n            _count += 1\n\n        if _count > longest_seq:\n            longest_seq = _count\n            last_ele = last_ele\n\n    return last_ele     \n```\n\n\nI feel like I can re-use this code to get the first element, but that will be redundant to have two similar functions. Is it possible to implement all of this in one function, and are there any better solutions with regards to time complexity?\n    ", "Answer": "\r\n```\ndef get_longest_sequence(arr):\n    \"\"\"\n    Prints out the longest sequence, its length, and the index of its first and last elements\n\n    arr: list of numbers\n\"\"\"\n\n    longest_seq_length = 0\n    last_ele_index_of_longest_seq = 0\n    max_difference = 3\n\n    for i in range(0, len(arr)): \n\n        max_ele_seq = arr[i]\n        min_ele_seq = arr[i]\n\n        count = 0\n\n        for j in range(i, len(arr)):\n\n            ele_j = arr[j]\n            if ele_j > max_ele_seq:\n                max_ele_seq = ele_j\n            elif ele_j < min_ele_seq:\n                min_ele_seq = ele_j\n\n            if max_ele_seq - min_ele_seq > max_difference: # no need for abs() since max always larger than min\n                break\n\n            last_ele_index = j\n            count += 1\n\n        if count > longest_seq_length:\n            longest_seq_length = count\n            last_ele_index_of_longest_seq = last_ele_index\n            # no need for last_ele = last_ele, it does nothing, merely reassigns itself\n\n    longest_seq = arr[(last_ele_index_of_longest_seq - longest_seq_length + 1):(last_ele_index_of_longest_seq + 1)]\n    print(f\"The longest sequence found: {longest_seq}\")\n    print(f\"Its length: {longest_seq_length}\")\n    print(f\"Index of first element (with regards to arr): {last_ele_index_of_longest_seq - longest_seq_length + 1}\")\n    print(f\"Index of last element: {last_ele_index_of_longest_seq}\")\n\narr = [10,11,12,15,13]\nget_longest_sequence(arr)\n\n```\n\n\nIf you wanted to improve your coding further, maybe try editing the program such that it will print out all the longest sequences (i.e. if there were 2 different sequences, of the longest length, to print out both of them, rather than just the first one).\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Patience Diff - what exactly is done in the last phase for non-unique lines?\r\n                \r\nI have an algorithm based on Longest Increasing Subsequence that works very well for solving the relevant business problem when the objects in each collection are unique, but tends to give odd results when there are many non-unique objects present in both collections.\n\nIt appears that an approach using the Patience Diff algorithm (which is also based on Longest Increasing Subsequence) would provide the results I want when non-unique objects exist.  However, before I can figure out if Patience Diff would be suitable, and in order to apply it to my problem if it's suitable, I need a better understanding of the algorithm.\n\nI understand what happens in steps 1 to 3, but I'm not clear on what happens in step 4.  After 1 to 3, now there remains blocks of unique lines that have no possible match, and non-unique lines.  So what happens next -- suppose there is no match with the remaining first/last lines of the documents, surely it doesn't terminate already (because there are no more unique lines)?  Or does it compare every non-unique block in one document with every non-unique block in the other document and pick the best match somehow?\n\nhttp://bramcohen.livejournal.com/73318.html\n\n\nMatch the first lines of both if they're identical, then match the second, third, etc. until a pair doesn't match.\nMatch the last lines of both if they're identical, then match the next to last, second to last, etc. until a pair doesn't match.\nFind all lines which occur exactly once on both sides, then do longest common subsequence on those lines, matching them up.\nDo steps 1-2 on each section between matched lines\n\n    ", "Answer": "\r\nOnce you've run out of unique lines you need to fall back to a different alignment algorithm.  Git uses the standard diff algorithm at that point (Eugene Myers' O(ND) algorithm).\n\ne.g., if the two files are:\n\n```\na 12121 e 1212 b ee c x d\na 21212 e 2121 b ye c d\n```\n\n\nFirst, the patience algorithm aligns any lines that are unique and exist in both files:\n\n```\na b c d\na b c d\n```\n\n\nEach subrange between those lines is then aligned recursively, first doing the patience algorithm again, then doing LCS algorithms if the patience algorithm doesn't match anything.\n\n```\n1212 e 121    |  ee  |    x\n2121 e 2      |  ye  |\n```\n\n\nIn the first subrange, ```\ne```\n is now unique on both so the second patience diff pass will align it, splitting that into two new subranges.  The new first subrange (12121 vs 21212) doesn't have any unique lines, so it will be aligned with the LCS algorithm.  The second new subrange (1212 vs 2121) is done with a second pass of the LCS algorithm.\n\nThe second grouping above (ee vs ye) doesn't have any unique lines, so they'll be aligned using the LCS algorithm as well.\n\nThe final grouping (x vs nothing) just outputs x as a delete, without doing either the patience or LCS algorithms.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "What is wrong with my solution - SPOJ - ALTSEQ?\r\n                \r\nWhat I need to do: I need to solve [ this ] problem on SPOJ. \n\nGiven an array a of N integers a1, a2, a3, ... aN I have to find the length of the longest alternating subsequence of the array.\nAn alternating sequence b1, b2 ... bk, k>=1 is a sequence that has the 2 following properties:  \n\n\n|b1|<|b2|<|b3|<.....<|bk|\nThe signs alternate between adjacent elements, i.e, if b1 > 0 then b2<0, b3 >0 and so on. Alternatively, if b1<0, then b2>0, b3<0 and so on.\n\n\nMy approach:\nThe problem is a variation of the Longest Increasing Subsequence (LIS) problem. And here is my memoization based recursive solution:  \n\n```\n#include <cstdio>\nusing namespace std;\n\nlong *a;\nint *dp;\n\nint solve(int);\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    a = new long[n];\n    dp = new int[n]{};\n    for (int i = 0; i < n; i++) scanf(\"%ld\", a+i);\n    printf(\"%d\", solve(n-1));\n}\n\nint solve(int n)\n{\n    if (dp[n]) return dp[n];\n    int &m = dp[n] = 1, k;\n    for(int j = 0; j < n; j++)\n        if (((a[n] < 0 && a[j] > 0 && -a[n] > a[j]) || (a[n] > 0 && a[j] < 0 && a[n] > -a[j])))\n            if ((k = 1 + solve(j)) > m) m = k;\n    return m;\n}\n```\n\n\nMy Question: This solution gives wrong answer on the judge system so there must be something wrong with it. I need help to figure out what is wrong with this solution since I can't on my own.\n    ", "Answer": "\r\nIt occurred to me later that solve(i) is calculating dp[i] which is the LIS ending with the ith element. The maximum of the whole dp array therefore, is the correct answer not dp[n-1] which I was printing before.  \n\nAlso, the recursive solution can be converted to bottom-up for efficiency. Furthermore, in bottom-up, the outer one of the two loops involved can be combined with the input reading loop and maximum dp[i] can be kept track of within the outer loop itself to avoid another pass to find maximum. This should result in a faster solution.  \n\n```\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n    int n, k, m = 0;\n    scanf(\"%d\", &n);\n    long *a = new long[n];\n    int *dp = new int[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%ld\", a+i);\n        dp[i] = 1;\n        for (int j = 0; j < i; j++)\n            if (((a[i] < 0 && a[j] > 0 && -a[i] > a[j]) || (a[i] > 0 && a[j] < 0 && a[i] > -a[j])) && (k = 1 + dp[j]) > dp[i]) dp[i] = k;\n        if (dp[i] > m) m = dp[i];\n    }\n    printf(\"%d\\n\", m);\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Consistent monotonic subsequence\r\n                \r\nI have problem with this algorithm. It should search for longest consistent and monotonic subsequence and sum of it. If there are few subsequense with the same length it should return the first one.\nIt should work as monotonic function - http://en.wikipedia.org/wiki/Monotonic_function\n\nFor input : ```\n1 1 7 3 2 0 0 4 5 5 6 2 1```\n \n\nthe result is : ```\n6 20```\n - so it works.\n\nBut for input :  ```\n23 34 11 5 23 90 11 10 15 12 28 49```\n \n\nthe result is : ```\n3 113```\n - but should be ```\n3 50```\n\n\nI feel that the problem is in switching between increasing and decreasing case. Any idea?\n\ncode : \n\n```\n#include <stdio.h>\n\n#define gc getchar\nvoid scan_integer(unsigned long long int* o)\n{\n    register unsigned long long int c = gc();\n    int x = 0;\n    for (; ((c<48 || c>57)); c = gc());\n\n    for (; c>47 && c<58; c = gc()) {\n        x = (x << 1) + (x << 3) + c - 48;\n    }\n    *o = x;\n}\n\n\nint main(){\n    unsigned long long int current_value, last_value, sum_increasing, sum_decreasing, length_increasing, length_decreasing, max_length, max_sum, is_increasing;\n    bool equal = false;\n    scan_integer(&current_value);\n    last_value = 0;\n    sum_increasing = current_value;\n    sum_decreasing = current_value;\n    length_increasing = 1;\n    length_decreasing = 1;\n    max_length = 1;\n    max_sum = current_value;\n    is_increasing = 0;\n\n    while (!feof(stdin))\n    {\n        last_value = current_value;\n        scan_integer(&current_value);\n\n        if (current_value == last_value){\n            sum_increasing += current_value;\n            sum_decreasing += current_value;\n            length_increasing += 1;\n            length_decreasing += 1;\n            equal = true;\n        }\n        else {\n            if (current_value > last_value){\n                sum_increasing += current_value;\n                length_increasing += 1;\n\n                if (equal == true){\n                    length_decreasing = 1;\n                    sum_decreasing = 0;\n                    equal = false;\n                }\n\n                if (is_increasing < 0){\n                    sum_increasing += last_value;\n                    if (length_decreasing > max_length){\n                        max_length = length_decreasing;\n                        max_sum = sum_decreasing;\n                    }\n                    sum_decreasing = 0;\n                    length_decreasing = 1;\n                }\n                is_increasing = 1;\n            }\n            else {\n                sum_decreasing += current_value;\n                length_decreasing += 1;\n                if (equal == true){\n                    length_increasing = 1;\n                    sum_increasing = 0;\n                    equal = false;\n                }\n                if (is_increasing == 1){\n                    sum_decreasing += last_value;\n                    if (length_increasing > max_length){\n                        max_length = length_increasing;\n                        max_sum = sum_increasing;\n                    }\n\n                sum_increasing = 0;\n                length_increasing = 1;\n            }\n            is_increasing = -1;\n        }\n    }\n}\n\nprintf(\"%llu %llu\", max_length, max_sum);\n\n\nreturn 0;\n\n}\n```\n\n    ", "Answer": "\r\nI see a problem in the code, in this part:\n\n```\n           is_increasing = 1;   // here\n           // Did you mean to write a continue here?\n        }\n        else {\n            sum_decreasing += current_value;\n            length_decreasing += 1;\n            if (equal == true){\n                length_increasing = 1;\n                sum_increasing = 0;\n                equal = false;\n            }\n            if (is_increasing == 1){\n                sum_decreasing += last_value;\n                if (length_increasing > max_length){\n                    max_length = length_increasing;\n                    max_sum = sum_increasing;\n                }\n\n            sum_increasing = 0;\n            length_increasing = 1;\n        }\n        is_increasing = -1;   // Or you might want to put this inside of the else above\n```\n\n\nIf I understand correctly, 'is_increasing = -1' at the bottom completely invalidates the setting of it in the true condition of the if statemen (at the top of the code above). That's why, In the \"else\" that handles decreasing sequences 'is_increasing' always has the value of '-1' and such sequences never get saved as good sequences.\n\nI put some codes in the code I copied and pasted. I think that handling the codition at which two numbers in sequence might need a little more care than those comments, but this should set you in the right direction.\n\nLet me know if this helps.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Discover long patterns\r\n                \r\nGiven a sorted list of numbers, I would like to find the longest subsequence where the differences between successive elements are geometrically increasing.  So if the list is \n\n```\n 1, 2, 3, 4, 7, 15, 27, 30, 31, 81\n```\n\n\nthen the subsequence is ```\n1, 3, 7, 15, 31```\n.  Alternatively consider ```\n1, 2, 5, 6, 11, 15, 23, 41, 47```\n which has subsequence ```\n5, 11, 23, 47```\n with a = 3 and k = 2. \n\nCan this be solved in O(n2) time? Where n is the length of the list.\n\nI am interested both in the general case where the progression of differences is ak, ak2, ak3, etc., where both a and k are integers, and in the special case where a = 1, so the progression of difference is k, k2, k3, etc.\n    ", "Answer": "\r\nUpdate\n\nI have made an improvement of the algorithm that it takes an average of O(M + N^2) and memory needs of O(M+N). Mainly is the same that the protocol described below, but to calculate the possible factors A,K for ech diference D, I preload a table. This table takes less than a second to be constructed for M=10^7.\n\nI have made a C implementation that takes less than 10minutes to solve N=10^5 diferent random integer elements.\n\nHere is the source code in C: To execute just do: gcc -O3 -o findgeo findgeo.c \n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <memory.h>\n#include <time.h>\n\nstruct Factor {\n    int a;\n    int k;\n    struct Factor *next;\n};\n\nstruct Factor *factors = 0;\nint factorsL=0;\n\nvoid ConstructFactors(int R) {\n    int a,k,C;\n    int R2;\n    struct Factor *f;\n    float seconds;\n    clock_t end;\n    clock_t start = clock();\n\n    if (factors) free(factors);\n    factors = malloc (sizeof(struct Factor) *((R>>1) + 1));\n    R2 = R>>1 ;\n    for (a=0;a<=R2;a++) {\n        factors[a].a= a;\n        factors[a].k=1;\n        factors[a].next=NULL;\n    }\n    factorsL=R2+1;\n    R2 = floor(sqrt(R));\n    for (k=2; k<=R2; k++) {\n        a=1;\n        C=a*k*(k+1);\n        while (C<R) {\n            C >>= 1;\n            f=malloc(sizeof(struct Factor));\n            *f=factors[C];\n            factors[C].a=a;\n            factors[C].k=k;\n            factors[C].next=f;\n            a++;\n            C=a*k*(k+1);\n        }\n    }\n\n    end = clock();\n    seconds = (float)(end - start) / CLOCKS_PER_SEC;\n    printf(\"Construct Table: %f\\n\",seconds);\n}\n\nvoid DestructFactors() {\n    int i;\n    struct Factor *f;\n    for (i=0;i<factorsL;i++) {\n        while (factors[i].next) {\n            f=factors[i].next->next;\n            free(factors[i].next);\n            factors[i].next=f;\n        }\n    }\n    free(factors);\n    factors=NULL;\n    factorsL=0;\n}\n\nint ipow(int base, int exp)\n{\n    int result = 1;\n    while (exp)\n    {\n        if (exp & 1)\n            result *= base;\n        exp >>= 1;\n        base *= base;\n    }\n\n    return result;\n}\n\nvoid findGeo(int **bestSolution, int *bestSolutionL,int *Arr, int L) {\n    int i,j,D;\n    int mustExistToBeBetter;\n    int R=Arr[L-1]-Arr[0];\n    int *possibleSolution;\n    int possibleSolutionL=0;\n    int exp;\n    int NextVal;\n    int idx;\n    int kMax,aMax;\n    float seconds;\n    clock_t end;\n    clock_t start = clock();\n\n\n    kMax = floor(sqrt(R));\n    aMax = floor(R/2);\n    ConstructFactors(R);\n    *bestSolutionL=2;\n    *bestSolution=malloc(0);\n\n    possibleSolution = malloc(sizeof(int)*(R+1));\n\n    struct Factor *f;\n    int *H=malloc(sizeof(int)*(R+1));\n    memset(H,0, sizeof(int)*(R+1));\n    for (i=0;i<L;i++) {\n        H[ Arr[i]-Arr[0] ]=1;\n    }\n    for (i=0; i<L-2;i++) {\n        for (j=i+2; j<L; j++) {\n            D=Arr[j]-Arr[i];\n            if (D & 1) continue;\n            f = factors + (D >>1);\n            while (f) {\n                idx=Arr[i] + f->a * f->k  - Arr[0];\n                if ((f->k <= kMax)&& (f->a<aMax)&&(idx<=R)&&H[idx]) {\n                    if (f->k ==1) {\n                        mustExistToBeBetter = Arr[i] + f->a * (*bestSolutionL);\n                    } else {\n                        mustExistToBeBetter = Arr[i] + f->a * f->k * (ipow(f->k,*bestSolutionL) - 1)/(f->k-1);\n                    }\n                    if (mustExistToBeBetter< Arr[L-1]+1) {\n                        idx=  floor(mustExistToBeBetter - Arr[0]);\n                    } else {\n                        idx = R+1;\n                    }\n                    if ((idx<=R)&&H[idx]) {\n                        possibleSolution[0]=Arr[i];\n                        possibleSolution[1]=Arr[i] + f->a*f->k;\n                        possibleSolution[2]=Arr[j];\n                        possibleSolutionL=3;\n                        exp = f->k * f->k * f->k;\n                        NextVal = Arr[j] + f->a * exp;\n                        idx=NextVal - Arr[0];\n                        while ( (idx<=R) && H[idx]) {\n                            possibleSolution[possibleSolutionL]=NextVal;\n                            possibleSolutionL++;\n                            exp = exp * f->k;\n                            NextVal = NextVal + f->a * exp;\n                            idx=NextVal - Arr[0];\n                        }\n\n                        if (possibleSolutionL > *bestSolutionL) {\n                            free(*bestSolution);\n                            *bestSolution = possibleSolution;\n                            possibleSolution = malloc(sizeof(int)*(R+1));\n                            *bestSolutionL=possibleSolutionL;\n                            kMax= floor( pow (R, 1/ (*bestSolutionL) ));\n                            aMax= floor(R /  (*bestSolutionL));\n                        }\n                    }\n                }\n                f=f->next;\n            }\n        }\n    }\n\n    if (*bestSolutionL == 2) {\n        free(*bestSolution);\n        possibleSolutionL=0;\n        for (i=0; (i<2)&&(i<L); i++ ) {\n            possibleSolution[possibleSolutionL]=Arr[i];\n            possibleSolutionL++;\n        }\n        *bestSolution = possibleSolution;\n        *bestSolutionL=possibleSolutionL;\n    } else {\n        free(possibleSolution);\n    }\n    DestructFactors();\n    free(H);\n\n    end = clock();\n    seconds = (float)(end - start) / CLOCKS_PER_SEC;\n    printf(\"findGeo: %f\\n\",seconds);\n}\n\nint compareInt (const void * a, const void * b)\n{\n    return *(int *)a - *(int *)b;\n}\n\nint main(void) {\n    int N=100000;\n    int R=10000000;\n    int *A = malloc(sizeof(int)*N);\n    int *Sol;\n    int SolL;\n    int i;\n\n\n    int *S=malloc(sizeof(int)*R);\n    for (i=0;i<R;i++) S[i]=i+1;\n\n    for (i=0;i<N;i++) {\n        int r = rand() % (R-i);\n        A[i]=S[r];\n        S[r]=S[R-i-1];\n    }\n\n    free(S);\n    qsort(A,N,sizeof(int),compareInt);\n\n/*\n    int step = floor(R/N);\n    A[0]=1;\n    for (i=1;i<N;i++) {\n        A[i]=A[i-1]+step;\n    }\n*/\n\n    findGeo(&Sol,&SolL,A,N);\n\n    printf(\"[\");\n    for (i=0;i<SolL;i++) {\n        if (i>0) printf(\",\");\n        printf(\"%d\",Sol[i]);\n    }\n    printf(\"]\\n\");\n    printf(\"Size: %d\\n\",SolL);\n\n    free(Sol);\n    free(A);\n    return EXIT_SUCCESS;\n}\n```\n\n\nDemostration\n\nI will try to demonstrate that the algorithm that I proposed is  in average for an equally distributed random sequence. I’m not a mathematician and I am not used to do this kind of demonstrations, so please fill free to correct me any error that you can see.\n\nThere are 4 indented loops, the two firsts are the N^2 factor.  The M is for the calculation of the possible factors table).\n\nThe third loop is executed only once in average for each pair. You can see this checking the size of the pre-calculated factors table. It’s size is M when N->inf. So the average steps for each pair is M/M=1.\n\nSo the proof happens to check that the forth loop. (The one that traverses the good made sequences is executed less that or equal O(N^2) for all the pairs.\n\nTo demonstrate that, I will consider two cases: one where M>>N and  other where M ~= N. Where M is the maximum difference of the initial array: M= S(n)-S(1).\n\nFor the first case, (M>>N) the probability to find a coincidence is p=N/M. To start a sequence, it must coincide the second and the b+1 element where b is the length of the best sequence until now. So the loop will enter  times. And the average length of this series (supposing an infinite series) is  . So the total number of times that the loop will be executed is . And this is close to 0 when M>>N.  The problem here is when M~=N.\n\nNow lets consider this case where M~=N. Lets consider that b is the best sequence length until now. For the case A=k=1, then the sequence must start before N-b, so the number of sequences will be N-b, and the times that will go for the loop will be a maximum of (N-b)*b. \n\nFor A>1 and k=1 we can extrapolate to  where d is M/N (the average distance between numbers).  If we add for all A’s from 1 to dN/b then we see a top limit of:\n\n\n\nFor the cases where k>=2, we see that the sequence must start before , So the loop will enter an average of  and adding for all As from 1 to dN/k^b, it gives a limit of \n\n \n\nHere,  the worst case is when b is minimum. Because we are considering minimum series, lets consider a very worst case of  b= 2 so the number of passes for the 4th loop for a given k will be less than \n\n . \n\nAnd if we add all k’s from 2 to infinite will be:\n\n \n\nSo adding  all the passes for k=1 and k>=2, we have a maximum of:\n\n\n\nNote that d=M/N=1/p.\n\nSo we have two limits, One that goes to infinite when d=1/p=M/N goes to 1 and other that goes to infinite when d goes to infinite. So our limit is the minimum of both, and the worst case is when both equetions cross. So if we solve the equation:\n\n \n\nwe see that the maximum is when d=1.353\n\nSo it is demonstrated that the forth loops will be processed less than 1.55N^2 times in total. \n\nOf course, this is for the average case. For the worst case I am not able to find a way to generate series whose forth loop are higher than O(N^2), and I strongly believe that they does not exist, but I am not a mathematician to prove it. \n\nOld Answer\n\nHere is a solution in average of O((n^2)*cube_root(M)) where M is the difference between the first and last element of the array. And memory requirements of O(M+N).\n\n1.- Construct an array H of length M so that M[i - S[0]]=true if i exists in the initial array and false if it does not exist.\n\n2.- For each pair in the array S[j], S[i] do:\n\n2.1 Check if it can be the first and third elements of a possible solution. To do so, calculate all possible A,K pairs that meet the equation S(i) = S(j) + AK + AK^2. Check this SO question to see how to solve this problem. And check that exist the second element: S[i]+ A*K\n\n2.2 Check also that exist the element one position further that the best solution that we have. For example, if the best solution that we have until now is 4 elements long then check that exist the element A[j] + AK + AK^2 + AK^3 + AK^4\n\n2.3 If 2.1 and 2.2 are true, then iterate how long is this series and set as the bestSolution until now is is longer that the last.\n\nHere is the code in javascript:\n\n```\nfunction getAKs(A) {\n    if (A / 2 != Math.floor(A / 2)) return [];\n    var solution = [];\n    var i;\n    var SR3 = Math.pow(A, 1 / 3);\n    for (i = 1; i <= SR3; i++) {\n        var B, C;\n        C = i;\n        B = A / (C * (C + 1));\n        if (B == Math.floor(B)) {\n            solution.push([B, C]);\n        }\n\n        B = i;\n        C = (-1 + Math.sqrt(1 + 4 * A / B)) / 2;\n        if (C == Math.floor(C)) {\n            solution.push([B, C]);\n        }\n    }\n\n    return solution;\n}\n\nfunction getBestGeometricSequence(S) {\n    var i, j, k;\n\n    var bestSolution = [];\n\n    var H = Array(S[S.length-1]-S[0]);\n    for (i = 0; i < S.length; i++) H[S[i] - S[0]] = true;\n\n    for (i = 0; i < S.length; i++) {\n        for (j = 0; j < i; j++) {\n            var PossibleAKs = getAKs(S[i] - S[j]);\n            for (k = 0; k < PossibleAKs.length; k++) {\n                var A = PossibleAKs[k][0];\n                var K = PossibleAKs[k][17];\n\n                var mustExistToBeBetter;\n                if (K==1) {\n                    mustExistToBeBetter = S[j] + A * bestSolution.length;\n                } else {\n                    mustExistToBeBetter = S[j] + A * K * (Math.pow(K,bestSolution.length) - 1)/(K-1);\n                }\n\n                if ((H[S[j] + A * K - S[0]]) && (H[mustExistToBeBetter - S[0]])) {\n                    var possibleSolution=[S[j],S[j] + A * K,S[i]];\n                    exp = K * K * K;\n                    var NextVal = S[i] + A * exp;\n                    while (H[NextVal - S[0]] === true) {\n                        possibleSolution.push(NextVal);\n                        exp = exp * K;\n                        NextVal = NextVal + A * exp;\n                    }\n\n                    if (possibleSolution.length > bestSolution.length) {\n                        bestSolution = possibleSolution;\n                    }\n                }\n            }\n        }\n    }\n    return bestSolution;\n}\n\n//var A= [ 1, 2, 3,5,7, 15, 27, 30,31, 81];\nvar A=[];\nfor (i=1;i<=3000;i++) {\n    A.push(i);\n}\nvar sol=getBestGeometricSequence(A);\n\n$(\"#result\").html(JSON.stringify(sol));\n```\n\n\nYou can check the code here: http://jsfiddle.net/6yHyR/1/\n\nI maintain the other solution because I believe that it is still better when M is very big compared to N.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Get list of values from a nested Python data-structure using a list comprehension?\r\n                \r\nin calculating a longest increasing subsequence using patience sorting I create a nested tuple of (value, backlink) pairs that I then need to crawl to get all the values in order.\nCurrently I use a small function to do this but was wondering if there was a way to use a list comprehensions to do the same thing.\n\nThe example uses a namedtuple as in my original program and should illustrate my issue:\n\n```\n>>> from collections import namedtuple\n>>> P = namedtuple('P', 'val, back')\n>>> q = P(val=15, back=P(val=11, back=P(val=9, back=P(val=6, back=P(val=2, back=P(val=0, back=None))))))\n>>> q\nP(val=15, back=P(val=11, back=P(val=9, back=P(val=6, back=P(val=2, back=P(val=0, back=None))))))\n>>> #Request something like:\n>>> [val for val, q in q]\nTraceback (most recent call last):\n  File \"<pyshell#68>\", line 1, in <module>\n    [val for val, q in q]\n  File \"<pyshell#68>\", line 1, in <listcomp>\n    [val for val, q in q]\nTypeError: 'int' object is not iterable\n>>> q\nP(val=15, back=P(val=11, back=P(val=9, back=P(val=6, back=P(val=2, back=P(val=0, back=None))))))\n>>> # Wanted: [15, 11, 9, 6, 2, 0]\n>>> \n>>> # Have to use:\n>>> def _unwind(q):\n    u = []\n    while q:\n        u.append(q.val)\n        q = q.back\n    return u\n\n>>> q\nP(val=15, back=P(val=11, back=P(val=9, back=P(val=6, back=P(val=2, back=P(val=0, back=None))))))\n>>> _unwind(q)\n[15, 11, 9, 6, 2, 0]\n>>> \n```\n\n\nI was looking for some way of setting P up so I could write something like:\n\n```\n[val for val, q in q]\n```\n\n\nMaybe by overriding P.__iter__ and P.__next__ in some way to elegantly redefine the iter protocol for P?\n    ", "Answer": "\r\nTry following:\n\n```\n>>> from collections import namedtuple\n>>>\n>>> class P(namedtuple('_P', 'val back')):\n...     def __iter__(self):\n...         while self:\n...             yield self.val, self.back\n...             self = self.back\n...\n>>> q = P(val=15, back=P(val=11, back=P(val=9, back=P(val=6, back=P(val=2, back=P(val=0, back=None))))))\n>>> [val for val, back in q]\n[15, 11, 9, 6, 2, 0]\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Dynamic Programming Algorithm Notation\r\n                \r\nFrom Chapter 6 of Algorithms, S. Dasgupta, C. Papadimitriou, U. Vazirani, 2006.\n\nI am trying to understand some of the psuedocode with the algorithms at the beginning of this chapter. The first one is the topological sort linearization I understand the dist and min routines. But I do not understand notation ```\nmin *subscript* (u, v)∈Edges {dist(u) + l(u, v)}```\n. Does anyone know how to describe each piece of that particular notation. Is this cycling through ever node ```\nu```\n connected to ```\nv```\n by a directed edge? \n\nMy second question is the notation in the Longest Increasing Subsequence algorithm. How do you interpret the ```\nmax{L(i):(i, j)∈Edges}```\n. What does the colon mean in this statement? And in the text I see ```\nL(.)```\n and what does that mean? \n    ", "Answer": "\r\nBoth minimum and maximum need a domain to operate on. I.e. from a specific set, those operators return the maximum or minimum element.\n\nBoth notations are variants to define this domain. The first one basically says: \"Considering all pairs ```\n(u, v)```\n in the ```\nEdges```\n set, find the minimum value of ```\ndist(u) + l(u, v)```\n.\n\nThe second variant defines the set of values: ```\n{L(i) : (i, j) ∈ Edges}```\n is the set of all values ```\nL(i)```\n that can be formed from the pairs ```\n(i, j)```\n in the ```\nEdges```\n set. Then, the maximum operator finds the maximum value from this set.\n\nSo the differences are marginal. The first one specifies a domain and an expression that maps every element of the domain to a value. The second one directly specifies the set to pick the maximum element from.\n\nActually, both variants can be used interchangeably. It is probably just some inconsistency between the authors that the book used both.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Zig-Zag sequence[Dynamic Programming] bugs\r\n                \r\nI currently learning DP and I was studying via the topsider tutorial, and was trying to solve the problem ZigZag sequence and understand and know that the solution would be very similar to computing the length go longest increasing subsequence. I programmed a simple c++ DP solution as follows:\n\n```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(void)\n{\n    int n = 50;\n    int numbers[] =         \n{ 374, 40, 854, 203, 203, 156, 362, 279, 812, 955, \n600, 947, 978, 46, 100, 953, 670, 862, 568, 188, \n67, 669, 810, 704, 52, 861, 49, 640, 370, 908, \n477, 245, 413, 109, 659, 401, 483, 308, 609, 120, \n249, 22, 176, 279, 23, 22, 617, 462, 459, 244 };\n    vector<int> length(n, 1);\n    for(int i = 1;i < n;i++)\n    {\n        for(int j = (i - 1);j >= 0;j--)\n        {\n            if(length[j] + 1 > length[i])\n            {\n                if(length[j] % 2 == 0)\n                {\n                    if(numbers[i] - numbers[j] < 0)\n                    {\n                        length[i] = length[j] + 1;\n                    }\n                }\n                else\n                {\n                    if(numbers[i] - numbers[j] > 0)\n                    {\n                        length[i] = length[j] + 1;\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", *(max_element(length.begin(), length.end())));\n}\n```\n\n\nBut the problem is that the code works fine for all other cases, except this one:\n\n```\n{ 374, 40, 854, 203, 203, 156, 362, 279, 812, 955, \n600, 947, 978, 46, 100, 953, 670, 862, 568, 188, \n67, 669, 810, 704, 52, 861, 49, 640, 370, 908, \n477, 245, 413, 109, 659, 401, 483, 308, 609, 120, \n249, 22, 176, 279, 23, 22, 617, 462, 459, 244 }\n```\n\n\nMy code prints the answer ```\n35```\n while topsider believes its ```\n36```\n. I know Im making some kind of silly mistake in the program, but have been trying to find it since quite some time now, can someone else help me figure out the bug ? \n    ", "Answer": "\r\nI suspect the problem is that the first difference can be either positive or negative, but your code only supports one of these cases.\n\nMaybe you should run this code twice, once with positive first, then the second time with negative first.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "add value to first list (of lists) matching predicate\r\n                \r\nI have a list of lists and a value. My goal is a new list of lists, where the value is conjed (new first item) to the first list matching a predicate (eg > to the first item of the list). If no list matches the predicate, I want my value to \"begin\" a new list at the end of lists.\n\n```\nif my list is: ['(2 3 4) '(4 5 6 7) '(5 6 7)]\nand my value: 3\nand my predicate: (comp (partial < my-value) first)\nthen my result should be: ['(2 3 4) '(3 4 5 6 7) '(5 6 7)]\n\nif my value was: 10\nmy result should be: ['(2 3 4) '(4 5 6 7) '(5 6 7) '(10)]\n```\n\n\nThis problem confuses me, because my imperative mind keeps telling me how easy it should be, but I cannot find an easy (ok, be honest: any) solution. this is my attempt so far:\n\n```\n(defn add-to-first-list-that-matches [func value]\n  (loop [result []\n         remaining-lists list-of-lists\n         value-to-add value]\n    (if (empty? remaining-lists)\n      result\n      (let [current-list (first remaining-lists)\n            value-matches? (func value-to-add current-list)\n            new-list (if value-matches? (conj value-to-add current-list) current-list)]\n        (recur (conj new-list result)\n               (rest remaining-lists)\n               (if-not value-matches? value-to-add nil))))))\n```\n\n\n(it crashes)\nplease enlighten me with some clojure expression magic :)\n\nbtw. I want to solve this as part of the longest-increasing-subsequence problem.\n    ", "Answer": "\r\nThis uses loop-recur.\n\n```\n(defn add-to-ll\n  [ll pred value]\n  (loop [[current & unprocessed] ll\n         processed []]\n    (cond\n     (pred current) (concat processed\n                            [(cons value current)]\n                            unprocessed)\n     (empty? unprocessed) (concat processed\n                                  [current]\n                                  [[value]])\n     :else (recur unprocessed\n                  (conj processed current)))))\n\n\n (def l-l1 [[2 3 4] [4 5 6 7] [5 6 7]])\n (add-to-ll l-l1 (comp (partial < 10) first) 10)\n => ([2 3 4] [4 5 6 7] [5 6 7] [10])\n\n (add-to-ll l-l1 (comp (partial < 3) first) 3)\n => ([2 3 4] (3 4 5 6 7) [5 6 7])\n```\n\n\nYou could also use split-with\n\n```\n(defn add-to-ll\n  [ll pred value]\n  (let [[first-lists [to-change & rest-lists]] (split-with (complement pred) ll)]\n    (if to-change\n      (concat first-lists [(cons value to-change)] rest-lists)\n      (concat ll [[value]]))))\n```\n\n\nPerformance wise the first solution should run a bit faster. \n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest Common Subsequence, required length on contiguous parts\r\n                \r\nI think I have enough grasp of the LCS algorithm from this page. Specifically this psedo-code implementation: (m and n are the lengths of A and B)\n\n```\nint lcs_length(char * A, char * B) {\n  allocate storage for array L;\n  for (i = m; i >= 0; i--)\n    for (j = n; j >= 0; j--) {\n      if (A[i] == '\\0' || B[j] == '\\0') L[i,j] = 0;\n      else if (A[i] == B[j]) L[i,j] = 1 + L[i+1, j+1];\n      else L[i,j] = max(L[i+1, j], L[i, j+1]);\n    }\n  return L[0,0];\n}\n```\n\n\nThe L array is later backtracked to find the specific subsequence like so:\n\n```\nsequence S = empty;\ni = 0;\nj = 0;\nwhile (i < m && j < n) {\n  if (A[i]==B[j]) {\n    add A[i] to end of S;\n    i++; j++;\n  }\n  else if (L[i+1,j] >= L[i,j+1]) i++;\n  else j++;\n}\n```\n\n\nI have yet to rewrite this into Javascript, but for now I know that the implementation at Rossetta Code works just fine. So to my questions:\n\n1. How do I modify the algorithm to only return the longest common subsequence where the parts of the sequence are of a given minimum length?\n\nFor example, \"thisisatest\" and \"thimplestesting\" returns \"thistest\", with the contiguous parts \"thi\", \"s\" and \"test\". Let's define 'limit' as a minimum requirement of contiguous characters for it to be added to the result. With a limit of 3 the result would be \"thitest\" and with a limit of 4 the result would be \"test\". For my uses I would like to not only get the length, but the actual sequence and its indices in the first string. It doesn't matter if that needs to be backtracked later or not.\n\n2. Would such a modification reduce the complexity or increase it?\n\nFrom what I understand, analysing the entire suffix tree might be a solution to find a subsequence that fits a limit? If correct, is that significantly more complex than the original algorithm?.\n\n3. Can you optimize the LCS algorithm, modified or not, with the knowledge that the same source string is compared to a huge amount of target strings?\n\nCurrently I'm just iterating through the target strings finding the LCS and selecting the string with the longest subsequence. Is there any significant preprocessing that could be done on the source string to reduce the time?\n\nAnswers to any of my questions are welcome, or just hints on where to research further.\nThank you for your time! :)\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "leetcode673:why did my solution run out of time?\r\n                \r\nLeetcode 673:\nGiven an integer array nums, return the number of longest increasing subsequences.\nNotice that the sequence has to be strictly increasing.\nAnd here is my code:\n```\nclass Solution {\n//recursively compute the max increasing subsequence length and number of them at a given start point\n//and a Min which means the next value must be at least Min.The result will be recorded on dp and values in\n//dp will be checked first\n    pair<int,int> length_and_count(int ptr,int Min,vector<int>& nums,vector<unordered_map<int,pair<int,int>>>& dp){\n        if(ptr==nums.size())\n        return make_pair(0,1);\n        if(dp[ptr].find(Min)!=dp[ptr].end()){\n            return dp[ptr][Min];\n        } \n        else{\n            if(nums[ptr]<Min)\n            return dp[ptr][Min]=length_and_count(ptr+1,Min,nums,dp);\n            else{\n                auto pair1=length_and_count(ptr+1,Min,nums,dp),pair2=length_and_count(ptr+1,nums[ptr]+1,nums,dp);\n                if(pair1.first>++pair2.first)\n                return dp[ptr][Min]=pair1;\n                else if(pair1.first<pair2.first)\n                return dp[ptr][Min]=pair2;\n                else return dp[ptr][Min]=make_pair(pair1.first,pair1.second+pair2.second);\n            }\n        }\n    } \npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        vector<unordered_map<int,pair<int,int>>> dp(nums.size());\n        return length_and_count(0,INT_MIN,nums,dp).second;\n    }\n};\n```\n\nI think my solution is of complexity O(n2), because my dp parameters are the start point of nums and the current max value, which is got from the vector,so the size of dp can not be bigger than the square of the input vector.Since the problem size is less than 2000,my solution should be of 10s of ms.So whats's wrong with my solution?\n    ", "Answer": "\r\nThanks for very interesting question! Was glad to implement my own solution for it, and to improve speed of yours.\nOn test of random input of 2000 elements I improved speed of your solution ```\n8x-9x```\n times. For that I did following things:\n\nInterchanged order of vector and unordered_map, by making ```\ndp```\n structure ```\nunordered_map<int, shared_ptr<vector<pair<int, int>>>>```\n. This way we can later reuse pointer to ```\nMin```\n entry of unordered map, by passing this entry downwards to recursive function.\n\nIn ```\ndp```\n wrapped vector into std::shared_ptr. This allows to be sure that vector will not change memory location even if unordered map grows.\n\nInstead of doing same unordered map search again with ```\ndp[ptr][Min]```\n I did search just once inside single call of function through ```\n.find(Min)```\n and reused this iterator later in all other places of a function.\n\nPassed ```\nMin_vec```\n pointer down to all recursive calls, so that other function calls don't search inside unordered map again for same ```\nMin```\n entry. Just single place was not reusing this pointer, where ```\nnums[ptr] + 1```\n was passed as Min.\n\nCreated special lambda function ```\nGetMinVec()```\n which finds and returns pointer to Min entry. In case if this entry didn't exist yet I initialize it by allocating shared_ptr and resizing vector to size of ```\nnums.size()```\n filled with ```\npair(-1, -1)```\n which signifies empty value.\n\n\nAll steps above boosted your solution by ```\n8x-9x```\n times. Your original solution is located in my code as ```\nSolutionOriginal```\n class. While my boosted variant is ```\nSolutionBoosted```\n.\nAlso I created my own solution that is ```\n100x```\n faster than your original and ```\n11x-12x```\n faster than boosted original. This new solution I called ```\nSolutionSqrt```\n. It works as follows:\n\nLets create ```\nK = sqrt(N)```\n buckets. Each of ```\nK```\n buckets will have around ```\nK```\n elements on average at the end.\n\nEach bucket will help us to narrow search of all elements that are smaller than current one. For each new number we will find the bucket index ```\nbuck_i```\n that says that all buckets with smaller index contain elements not bigger than current.\n\nInside current bucket ```\nbuck_i```\n we will do linear search to find all elements that are smaller than current.\n\nEach bucket contains a Heap array that grows by using std::push_heap. This Heap is sorted in such a way that its first element (head) contains largest element.\n\nBucket's Heap is sorted in such a way that first element has longest chain of numbers located in this heap.\n\nWe do ```\nSqrt(N) + Sqrt(N)```\n searches on average for each new number. And we search how can we extend current longest chain by adding this new element.\n\nIf longest chain is succeded to be prolonged then we remember new maximal length and new maximal count of current bucket ```\nbuck_i```\n. Also then new element becomes first Heap element as providing the longest chain.\n\nEach bucket has its own length of longest chain and count of such chains formed.\n\nOverall complexity of such algorithm is ```\nO(N * Sqrt(N))```\n. This complexity can be improved even further if instead of 2-level buckets we make 3-level buckets in this case we will achieve complexity ```\nO(N * N^(1/3))```\n. This ```\nO(N * Sqrt(N))```\n complexity is much less than original OP's code that is ```\nO(N^2)```\n.\n\n\nI did timings of all 3 variants of solutions on random test set of 2000 numbers. Timings can be seen after the code.\nTry it online!\n```\n#include <cstdint>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nclass SolutionSqrt {\npublic:\n    using u64 = uint64_t;\n    using NumT = int;\n    u64 findNumberOfLIS(std::vector<NumT> const & nums) {\n        size_t const\n            N = nums.size(),\n            nbucks = std::max<size_t>(1, std::llround(std::sqrt(N))),\n            buck_size = (N + nbucks - 1) / nbucks;\n        std::vector<size_t> si(N), rsi(N), ll(N);\n        std::vector<u64> lc(N);\n        for (size_t i = 0; i < si.size(); ++i)\n            si[i] = i;\n        std::sort(si.begin(), si.end(), [&](size_t a, size_t b){\n            return nums[a] < nums[b];\n        });\n        for (size_t i = 0; i < rsi.size(); ++i)\n            rsi[si[i]] = i;\n        struct Buck {\n            std::vector<size_t> sj;\n            size_t max_ll = 0;\n            u64 max_lc = 0;\n            NumT max_num = std::numeric_limits<NumT>::min(),\n                 min_num = std::numeric_limits<NumT>::max();\n        };\n        std::vector<Buck> bucks(nbucks);\n        for (size_t i = 0; i < N; ++i) {\n            auto const num = nums[i];\n            size_t const buck_i = rsi[i] / buck_size;\n            size_t max_ll = 0;\n            for (size_t j = 0; j <= buck_i; ++j) {\n                auto const & buckj = bucks[j];\n                if (buckj.sj.empty())\n                    continue;\n                if (j < buck_i && buckj.max_num < num)\n                    max_ll = std::max(max_ll, buckj.max_ll);\n                else {\n                    if (buckj.min_num == buckj.max_num && buckj.max_num == num)\n                        continue;\n                    for (size_t k = 0; k < buckj.sj.size(); ++k)\n                        if (nums[buckj.sj[k]] < num)\n                            max_ll = std::max(max_ll, ll[buckj.sj[k]]);\n                }\n            }\n            if (max_ll > 0) {\n                u64 clc = 0;\n                for (size_t j = 0; j <= buck_i; ++j) {\n                    auto const & buckj = bucks[j];\n                    if (buckj.sj.empty())\n                        continue;\n                    if (j < buck_i && buckj.max_num < num) {\n                        if (ll[buckj.sj[0]] == max_ll)\n                            clc += buckj.max_lc;\n                    } else {\n                        if (buckj.min_num == buckj.max_num && buckj.max_num == num)\n                            continue;\n                        for (size_t k = 0; k < buckj.sj.size(); ++k)\n                            if (nums[buckj.sj[k]] < num && ll[buckj.sj[k]] == max_ll)\n                                clc += lc[buckj.sj[k]];\n                    }\n                }\n                ll[i] = max_ll + 1;\n                lc[i] = clc;\n            } else {\n                ll[i] = 1;\n                lc[i] = 1;\n            }\n            auto & buck = bucks[buck_i];\n            bool const new_max = buck.sj.empty() || ll[i] > ll[buck.sj[0]];\n            buck.sj.push_back(i);\n            std::push_heap(buck.sj.begin(), buck.sj.end(), [&](size_t a, size_t b){\n                return ll[a] < ll[b];\n            });\n            if (ll[i] >= buck.max_ll)\n                buck.max_lc = lc[i] + (new_max ? u64(0) : buck.max_lc);\n            buck.max_ll = std::max(buck.max_ll, ll[i]);\n            buck.min_num = std::min(buck.min_num, num);\n            buck.max_num = std::max(buck.max_num, num);\n        }\n        size_t total_max_ll = 0;\n        for (size_t i = 0; i < bucks.size(); ++i)\n            if (!bucks[i].sj.empty())\n                total_max_ll = std::max(total_max_ll, bucks[i].max_ll);\n        u64 total_lc = 0;\n        for (size_t i = 0; i < bucks.size(); ++i)\n            if (!bucks[i].sj.empty() && ll[bucks[i].sj[0]] == total_max_ll)\n                total_lc += bucks[i].max_lc;\n\n        //std::cout << \"Length \" << total_max_ll << std::endl;\n        //std::cout << \"Count \" << total_lc << std::endl;\n\n        return total_lc;\n    }\n};\n\n#include <unordered_map>\n#include <climits>\n#include <memory>\n\nusing namespace std;\n\nclass SolutionOriginal {\n    // recursively compute the max increasing subsequence length and number of them at a given start point\n    // and a Min which means the next value must be at least Min.The result will be recorded on dp and values in\n    // dp will be checked first\n    pair<int, int> length_and_count(int ptr, int Min, vector<int> & nums,\n                                    vector<unordered_map<int, pair<int, int>>> & dp) {\n        if (ptr == nums.size())\n            return make_pair(0, 1);\n        if (dp[ptr].find(Min) != dp[ptr].end()) {\n            return dp[ptr][Min];\n        } else {\n            if (nums[ptr] < Min)\n                return dp[ptr][Min] = length_and_count(ptr + 1, Min, nums, dp);\n            else {\n                auto pair1 = length_and_count(ptr + 1, Min, nums, dp),\n                     pair2 = length_and_count(ptr + 1, nums[ptr] + 1, nums, dp);\n                if (pair1.first > ++pair2.first)\n                    return dp[ptr][Min] = pair1;\n                else if (pair1.first < pair2.first)\n                    return dp[ptr][Min] = pair2;\n                else\n                    return dp[ptr][Min] = make_pair(pair1.first, pair1.second + pair2.second);\n            }\n        }\n    }\n\n  public:\n    int findNumberOfLIS(vector<int> nums) {\n        vector<unordered_map<int, pair<int, int>>> dp(nums.size());\n        auto p = length_and_count(0, INT_MIN, nums, dp);\n        // std::cout << \"Length \" << p.first << std::endl;\n        // std::cout << \"Count \" << p.second << std::endl;\n        return p.second;\n    }\n};\n\nclass SolutionBoosted {\n    // recursively compute the max increasing subsequence length and number of them at a given start point\n    // and a Min which means the next value must be at least Min.The result will be recorded on dp and values in\n    // dp will be checked first\n    pair<int, int> length_and_count(int ptr, int Min, vector<int> & nums,\n            unordered_map<int, shared_ptr<vector<pair<int, int>>>> & dp,\n            vector<pair<int, int>> * Min_vec = nullptr) {\n        if (ptr == nums.size())\n            return make_pair(0, 1);\n        auto GetMinVec = [&]{\n            auto it0 = dp.find(Min);\n            if (it0 != dp.end())\n                return it0->second.get();\n\n            auto it1 = dp.insert(make_pair(Min, make_shared<\n                vector<pair<int, int>>>())).first;\n            it1->second->resize(nums.size(), make_pair(-1, -1));\n            return it1->second.get();\n        };\n        if (!Min_vec)\n            Min_vec = GetMinVec();\n        auto & e = (*Min_vec)[ptr];\n        if (e.first != -1)\n            return e;\n        else {\n            if (nums[ptr] < Min)\n                return e = length_and_count(ptr + 1, Min, nums, dp, Min_vec);\n            else {\n                auto pair1 = length_and_count(ptr + 1, Min, nums, dp, Min_vec),\n                     pair2 = length_and_count(ptr + 1, nums[ptr] + 1, nums, dp);\n                if (pair1.first > ++pair2.first)\n                    return e = pair1;\n                else if (pair1.first < pair2.first)\n                    return e = pair2;\n                else\n                    return e = make_pair(\n                        pair1.first, pair1.second + pair2.second);\n            }\n        }\n    }\n\n  public:\n    int findNumberOfLIS(vector<int> nums) {\n        unordered_map<int, shared_ptr<vector<pair<int, int>>>> dp;\n        auto p = length_and_count(0, INT_MIN, nums, dp);\n        // std::cout << \"Length \" << p.first << std::endl;\n        // std::cout << \"Count \" << p.second << std::endl;\n        return p.second;\n    }\n};\n\n#include <random>\n#include <chrono>\n\nint main() {\n    std::mt19937_64 rng(123);\n    std::uniform_int_distribution<int> distr(-100, 100);\n    std::vector<int> v;\n    for (size_t i = 0; i < (1 << 11); ++i)\n        v.push_back(distr(rng));\n    {\n        auto tb = std::chrono::system_clock::now();\n        std::cout << \"Sqrt \" << SolutionSqrt().findNumberOfLIS(v) << \"  \";\n        std::cout << \"Time \" << std::chrono::duration_cast<std::chrono::microseconds>(\n            std::chrono::system_clock::now() - tb).count() / 1000000.0 << \" sec\" << std::endl;\n    }\n    {\n        auto tb = std::chrono::system_clock::now();\n        std::cout << \"Original \"\n            << SolutionOriginal().findNumberOfLIS(v) << \"  \";\n        std::cout << \"Time \" << std::chrono::duration_cast<std::chrono::microseconds>(\n            std::chrono::system_clock::now() - tb).count() / 1000000.0 << \" sec\" << std::endl;\n    }\n    {\n        auto tb = std::chrono::system_clock::now();\n        std::cout << \"Original_Boosted \"\n            << SolutionBoosted().findNumberOfLIS(v) << \"  \";\n        std::cout << \"Time \" << std::chrono::duration_cast<std::chrono::microseconds>(\n            std::chrono::system_clock::now() - tb).count() / 1000000.0 << \" sec\" << std::endl;\n    }\n}\n```\n\nOutput:\n```\nSqrt 15240960  Time 0.000856 sec\nOriginal 15240960  Time 0.081954 sec\nOriginal_Boosted 15240960  Time 0.011343 sec\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "When to use a matrix vs. 1D array for dynamic programming problems?\r\n                \r\nI was looking at this question on the usage of matrices in top down dynamic programming. In an attempt to apply it I tried the Longest Increasing Subsequence problem.\nLooking at various implementations of the top down approach people seem to use a 1D array to memoize instead of a matrix. I thought the implementation would be a matrix where columns are the number of subproblems (which is the length of the array of numbers), and the number of rows would be the subset of remaining elements you can select from which at max would again be the length of the array of numbers - 1).\ne.g.\n```\n   dp = [[1] * len(nums) for i in range(len(nums))]\n```\n\nHow do you know when to use a matrix vs. 1D array in dynamic programming?\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Looking for an efficient array-like structure that supports \"replace-one-member\" and \"append\"\r\n                \r\nAs an exercise I wrote an implementation of the longest increasing subsequence algorithm, initially in Python but I would like to translate this to Haskell.  In a nutshell, the algorithm involves a fold over a list of integers, where the result of each iteration is an array of integers that is the result of either changing one element of or appending one element to the previous result.\n\nOf course in Python you can just change one element of the array.  In Haskell, you could rebuild the array while replacing one element at each iteration - but that seems wasteful (copying most of the array at each iteration).\n\nIn summary what I'm looking for is an efficient Haskell data structure that is an ordered collection of 'n' objects and supports the operations: ```\nlookup i```\n, ```\nreplace i foo```\n, and ```\nappend foo```\n (where ```\ni```\n is in [0..n-1]).  Suggestions?\n    ", "Answer": "\r\nPerhaps the standard ```\nSeq```\n type from ```\nData.Sequence```\n. It's not quite O(1), but it's pretty good:\n\n\n```\nindex```\n (your ```\nlookup```\n) and ```\nadjust```\n (your ```\nreplace```\n) are O(log(min(index, length - index)))\n```\n(><)```\n (your ```\nappend```\n) is O(log(min(length1, length2)))\n\n\nIt's based on a tree structure (specifically, a 2-3 finger tree), so it should have good sharing properties (meaning that it won't copy the entire sequence for incremental modifications, and will perform them faster too). Note that ```\nSeq```\ns are strict, unlike lists.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Finding Longest Weak Twin that occurs as a subsequence of a given sequence\r\n                \r\nSuppose ```\na[]```\n and ```\nb[]```\n are finite sequences of integers in which there are no pairs ```\na[i] = a[j]```\n or ```\nb[i] = b[j]```\n for (i != j). Then, ```\na[]```\n and ```\nb[]```\n are called weak twins if for all ```\ni```\n, ```\na[i] < a[i+1]```\n iff ```\nb[i] < b[i+1]```\n (which implies, ```\na[i] > a[i+1]```\n iff ```\nb[i] > b[i+1]```\n).\nSuppose ```\ns[]```\n is again some finite sequence of integers with pairwise distinct values. The twin-width of ```\ns[]```\n is the length of the maximum pair of disjoint subsequences ```\na[], b[]```\n of ```\ns[]```\n such that ```\na[]```\n and ```\nb[]```\n are weak twins.\nFor example, the twin-width of the sequence ```\n[1, 4, 6, 5, 3, 2]```\n is 3 because we can extract the two following subsequences from this sequences which are weak-twins: ```\n[1, 3, 2]```\n and ```\n[4, 6, 5]```\n.\nIt is clear that the twin-width of a sequence of length 2n is at most n, but in many cases, it can be much smaller.\nGiven a sequence ```\ns[]```\n, how can we find its twin-width?\n\nI have tried a simple dynamic programming approach where ```\ndp[i, j]```\n represents the length of the longest pair of weak twin subsequences which end in ```\ns[i]```\n and ```\ns[j]```\n respectively. To compute dp[i, j], I want to see whether all sequences ending at i', j' for i' < i and j' < j can be extended or not. Unfortunately, it appears that this approach does not seem to work since we do not know that the sequence we are extending already contains ```\ns[i]```\n or ```\ns[j]```\n.\nI am thinking of this as a slight generalization of the longest increasing sequence problem. So, maybe there is a better algorithm?\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "minimum number of actions needed to sort an array\r\n                \r\nI'm trying to practice solving a problem from Codeforces. It is to sort an array by moving the elements of the array either to the beginning or to the end of the array. At first thought i thought it is longest increasing subsequence but it's not working in some cases. For example if the input is 4,1,2,5,3 the LIS is 3 but the answer for the problem is moving 4 to the end of the array and then 5 to the end of the array which gives us 2. Also i was trying out on the example 1,6,4,5,9,8,7,3,2 in this LIS is 1,4,5,9 but the answer for the problem is 7 moves between 1 and 2. I got to know that i should use greedy approach but couldn't quite relate. Could someone help me in this ?\n    ", "Answer": "\r\nWe can see that, to sort the array, each element is only need to be moved at most one.\n\nSo, to minimize the number of movement, we need to find the maximum number of element that is not moved. And those element is the longest continuous sequence , which is the sequence ```\n(a0, a1, ... an)```\n with ```\na(i + 1) = ai + 1```\n.\n\nFor example, \n\n(4,1,2,5,3), longest continuous sequence is (1,2,3)\n\n(5,2,1,3,4), longest continuous sequence is (2,3,4)\n\nSo we have our code:\n\n```\nint[]longest = new int[n + 1];\nint result = 0;\nfor(int i = 0; i < n; i++){\n    longest[data[i]] = longest[data[i] - 1] + 1;\n    result = max (longest[data[i]] , result);\n}\n\nprint \"Minimum number of move is \" + (n - result)\n```\n\n\nExplanation:\n\nIn the code, I am using an array ```\nlongest```\n which index ```\nith```\n stores the longest continuous sequence, which ends at ```\nvalue i```\n.\n\nSo, we can see that ```\nlongest[i] = longest[i - 1] + 1```\n. \n\nAnd the result for the longest continuous sequence is the maximum value stored in ```\nlongest```\n array.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Algorithm for \"erase as few numbers as possible to make remaining in increasing order\" [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking us to recommend or find a book, tool, software library, tutorial or other off-site resource are off-topic for Stack Overflow as they tend to attract opinionated answers and spam. Instead, describe the problem and what has been done so far to solve it.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI’m reading \"Introduction to Algorithms: A Creative Approach\" and met this question in Chapter 1:\n\n\n  Problem 1.3: You have a list of numbers, erase as few numbers as possible to make remaining numbers in increasing order.\n\n\nFor example, given the array\n\n```\n9 44 32 12 7 42 34 92\n```\n\n\nTwo possible options are ```\n9 12 42 92```\n and ```\n32 42 92```\n, and the former has fewer numbers removed.\n\nI tried a recursive algorithm but not satisfied with its performance, because it still need to test too many combinations. I found a heuristic algorithm that can get good result fast, though I'm not sure if it can guarantee the best result. I searched online but didn't find any discussion on this question. I believe there should be a better algorithm.\n\nI wrote my 2 methods here in case you want to check.\n\nUPDATE: I was asking solutions to this question, @josilber and @templatetypedef gave the links and the right direction to look at. It turned out that this is a special case of a family of known problems with good solutions. There is no need to write detailed solution here, the wiki page of Longest increasing subsequence, Patience sorting provided detailed information.\n\nIt's worth noting that although the answers have some links, this question is not about asking for resources or links. The real answer is the knowledge of \"this question is a variation of some known solved problems\".\n    ", "Answer": "\r\nAs a hint, this is equivalent to finding the longest increasing subsequence of the array (do you see why?) Since that's a standard algorithm with known O(n log n) solutions, you should be able to solve the problem with a slight modification of LIS.\n\nHope this helps!\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Javascript dynamic programming table, can't index 2D array like in Python in some cases?\r\n                \r\nEdit: Actually the logic is wrong here.\nI solved it using Python3 with a dictionary that updates the last index at which a letter is seen.  In dynamic programming lingo, it is similar to L.I.S (longest increasing subsequence).\nIf anyone knows how to solve this without using a dictionary, please comment because I learned DP in school and those lessons only used arrays so it should be possible with just arrays.\nOriginal question:\nI am trying Leetcode, 3. Longest Substring Without Repeating Characters.\nI can solve this in Python making a 2D table for dynamic programming.\nBut in JavaScript which I am sort of new to, I am getting an error.\n```\nevalmachine.<anonymous>:41\n                var top = T[i-1][j]\n                                ^\n\nTypeError: Cannot read property '1' of undefined\n    at lengthOfLongestSubstring (evalmachine.<anonymous>:4\n```\n\nMy code:\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    //empty string\n    if (s.length <= 0){\n        return 0\n    }\n    //initialize dict\n    var dict = {};\n    //initialize 2D table T\n    var T = new Array(s.length)\n    for (var i = 0; i<s.length; i++){\n        T[i] = new Array(s.length);\n    }\n    \n    //base cases are diagonals\n    for (var i = 0; i < T.length; i++){\n        for (var j=0; j<T.length; j++){\n            if(i==j){\n                T[i][j] = 1;\n            }\n            else{\n                T[i][j] = 0;\n            }\n        }\n    }\n    //put base case in dict\n    //dict[s[0]]=1\n    for (var i=0; i < s.length; i++){\n        for (var j=i+1; j<s.length; j++){\n            var row_char = s.charAt(i);\n            var col_char = s.charAt(j);\n            if (row_char==col_char){\n                T[i][j] = 1;\n            }\n            else{\n                //console.log(\"j\",j,T)\n                var left = T[i][j-1]\n                console.log(left)\n                var top = T[i-1][j] \n                console.log(top)\n                var bigger = Math.max(left,top);\n                T[i][j] = bigger + 1\n            }\n        }\n    }\n    //iterate each row to get max\n    var high = Number.MIN_SAFE_INTEGER;\n    \n    for (var i = 0; i < s.length; i++){\n        if(T[i][s.length-1] > high){\n            high = T[i][s.length-1];\n        } \n    }\n    \n    return high;\n    \n};\n```\n\nIt is letting me fill the table with 0's and base case of 1 indexing like ```\nT[i][j]```\n but then complaining about indexing like that to get the value which I don't understand.\nI looked at this: How to get value at a specific index of array In JavaScript?\nBut it does not really say anything different.\n    ", "Answer": "\r\nOn the first iteration of the loop following the ```\n//put base case in dict```\n comment ```\ni```\n is ```\n0```\n.\nYou're then attempting to access ```\nT[i-1][j]```\n, which is the equivalent of ```\nT[-1][j]```\n.\nBecause ```\nT```\n doesn't have a ```\n-1```\n index, ```\nT[-1]```\n resolves to ```\nundefined```\n, upon which you attempt to access index ```\n[j]```\n and you get the error you're seeing.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Wrong Answer on SPOJ\r\n                \r\nI was trying a problem on SPOJ,in which we have to simply find the Length of Longest Increasing Sub-sequence of the given Array A.\n\nI had solved this problem using a dynamic programming O(n^2)algorithm and the solution got accepted..Here is the code,that got Accepted:\n\n```\nvoid LIS(int *A,int A_Length)\n{\n    int Seq[MAX];\n    for(int i=0;i<A_Length;++i)\n    {\n        int maxima=0;\n        for(int j=0;j<i;++j)\n        {\n            if(A[i]>A[j])\n            {\n                maxima=max(Seq[j],maxima);\n            }\n        }\n        Seq[i]=maxima+1;\n        //cout<<Seq[i]<<endl;\n    }\n    cout<<*max_element(Seq,Seq+A_Length)<<endl;\n}\n```\n\n\nBut When i tried to solve it using the Second Method (LINK),which is ::\n\n```\nA simple way of finding the longest increasing subsequence is\n to use the Longest Common Subsequence (Dynamic Programming) algorithm.\n[1]Make a sorted copy of the sequence A, denoted as B. O(nlog(n)) time.\n[2]Use Longest Common Subsequence on with A and B. O(n2) time.\n```\n\n\n,I got Wrong Answer .\n\nThis is my c++ code\n\n```\n//Global Variable\nint A[100],B[100];\nint DP[100][100];\n\n//This function Finds the Longest common subsequce of Array A[1,2,3...,N] and B[1,2,3...,N]\nvoid LIS(int N)\n{\n\n    sort((B+1),(B+1)+N);//STL SORT sort from index 1 to N of Array B.\n    int i,j;\n\n    //Base Cases\n    for(i=0;i<=N;++i)\n        DP[i][0]=0;\n\n    for(j=0;j<=N;++j)\n        DP[0][j]=0;\n\n    for(i=1;i<=N;++i)\n    {\n        for(j=1;j<=N;++j)\n        {\n            if(A[i]==B[j])\n                DP[i][j]=DP[i-1][j-1]+1;\n            else\n                DP[i][j]=max(DP[i-1][j],DP[i][j-1]);\n        }\n    }\n    printf(\"%d\\n\",DP[N][N]);\n}\nint main()\n{\n    int N,i;\n    scanf(\"%d\",&N);\n    for(i=1;i<=N;++i)\n    {\n        scanf(\"%d\",&A[i]);\n        B[i]=A[i];\n    }\n    LIS(N);\n\n    return 0;\n}\n```\n\n\nI don't know why i am getting the Wrong Answer.Can You please Help me in Finding the Bug. Or the LIS by LCS Algorithm given in the site is incorrect??\n    ", "Answer": "\r\nThe Second Method is correct, but can't be applied to this problem directly. That's because the numbers in the sequence are not guaranteed to be unique in this SPOJ problem, and the target is to find a strict increasing subsequence, while Your Second Method's output is non-decreasing subsequence here. Demonstrating on a simple test case ```\n[1,2,2,3]```\n will help you find the difference.\n\nThis solution is also simple: just remove the duplicated elements after sorting.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest consecutive downfall in financial series\r\n                \r\nI would like to ask you for help regarding an issue which seems really weird. Namely, I am trying to find the longest consecutive subsequence of negative returns in a financial time series (and when it occured), but I can manage to program only longest consecutive subsequence of returns with the same sign. I am dealing with the following type of financial data:\n\n```\n               LgReturn\n1991-08-13  0.005180647\n1991-08-14  0.008555806\n1991-08-15  0.004878436\n1991-08-16 -0.004723199\n```\n\n\nMy approach was the following: First use sign to get sequence of only 1s (positive return and -1s (negative return) and use rle\nto get the list of all lengths of appearances\n\n```\nz <- sign(NASDAQLgRetOpen[,1])\nrle(z)\n```\n\n\nThe command rle(z) produces the following output:\n\n```\nRun Length Encoding\nlengths: int [1:2731] 3 3 2 1 4 6 1 1 2 3 ...\nvalues : num [1:2731] 1 -1 1 -1 1 -1 1 -1 1 -\n```\n\n\nThen I used the following code to find the longest subsequence:\n\n```\npad <- rev(sort(rle(z)$lengths[rle(z)$values[rle(z)$lengths]==-1]))\n```\n\n\nand the following code to extract the  position at which it occurs in my time series\n\n```\nvsota <- sum(rle(z)$lengths[1:(which(unlist(rle(z)$lengths)==pad[1]))])\n```\n\n\nThis gave me the rows in my time series, so I used\n\n```\nserija <- NASDAQLgRetOpen[(vsota+1-pad[1]):vsota,1]\n\nplot(cumprod(1+serija), type=\"l\")\n```\n\n\nThe problem is that I get a plot, which clearly shows an increasing sequence, so I have found the longest positive subsequence. What is really odd is that I get the positive subsequence regardless whether I choose 1 or -1 in the line\n\n```\n pad <- rev(sort(rle(z)$lengths[rle(z)$values[rle(z)$lengths]==-1]))\n```\n\n\nWhat am I missing? Please guys, help me out, since this is really confusing. Thank you in advance for your suggestions.\n\n...found an easy way solve this: reverse the signs and apply log, so that negative returns become 0 and pozitive returns become NaN - then rle always returns longest sequences of negative seturns since Nan is interpreted as of length 1. The following code works; it is assumed that the data you want to analyze are in i-th column of a datatable:\n\n```\nfall <- function(data,i){\nsg <- log(-sign(data[,i]))\nzacetek <-  sum(rle(sg)$lengths[1:(which(rle(sg)$lengths==max(rle(sg)$lengths))-1)[1]])\npodatki <- data[(zacetek+1):(zacetek+max(rle(sg)$lengths)),1]\nplot(cumprod(1+podatki), type=\"l\")\n}\n```\n\n\nNow that this is settled I would ask what is even more important for my data analysis: I have collection of 27 financial data sets and in order to improve my coding skills I would like to start using lapply function instead of for loops or something similar. \nThe question is the following: how do I apply the upper function fall on all of my 27 elements in a list. I have used this code to make a list of all objects\n\n```\nsz <-c()\nfor (i in 1:length(files)){\nsz <- rbind(sz,gsub(\" \",\"\",  paste(unlist(strsplit(files[[i]],\n\".txt\")),\"LgRetOpen\",\"\")))           \n}\nsz <- list(sz)\n```\n\n\nto produce the (first lines) of the following result:\n\n```\n     [,1]                      \n[1,] \"AUDUSDLgRetOpen\"         \n[2,] \"BVSPUSDIBOVLgRetOpen\"    \n[3,] \"DAXLgRetOpen\"            \n[4,] \"DJIALgRetOpen\"        \n```\n\n\nThe data on which I want to apply function fall are stored as the names in the sz list, but without the hyphens, i.e. I want to apply fall on AUDUSDLgRetOpen[,1], or better said call function fall(AUDUSDLgRetOpen,1) and so on for each element os the list. How do I do this? I have tried something like\n\n```\npadci <- lapply(sz, function(x,i) fall(x,1))  \n```\n\n\nbut that of course does not work since I have to call data.frames AUDUSDLgRetOpen and so on and not characters \"AUDUSDLgRetOpen\". How to solve this?\n    ", "Answer": "\r\nI think you're on the right track with ```\nrle```\n but you need to be looking at the values of the run to make sure it's negative. (Of course you need to make sure your data is sorted by date for ```\nrle```\n to work.)\n\n```\nset.seed(17)\ndd<-data.frame(\n    date=seq(as.Date(\"1991-01-01\"), as.Date(\"1991-02-28\"), by=\"1 day\"),\n    lgreturn=rnorm(59, 0, 100)\n)\n\nrun<-rle(dd$lgreturn<0)\n\nmaxrun <- which.min(run$lengths * run$values*-1)\ndatestart <- sum(run$lengths[1:(maxrun-1)])+1\ndateend <- datestart+run$lengths[maxrun]-1\n```\n\n\nThen ```\ndatestart```\n and ```\ndateend```\n will have the index of the rows where your run begins and ends. And here's a plot of the result...\n\n```\nplot(lgreturn~date, dd)\nabline(h=0, lty=2, col=\"red\")\nabline(v=dd$date[c(datestart, dateend)], lty=2)\n```\n\n\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "what is the most appropriate data structure supporting binary search to solve LIS?\r\n                \r\nI would like to solve the Longest increasing subsequence problem in Haskell, with the patience sorting algorithm.\nI first did it with lists, and it worked in O(n^2) time.\nNow I would like to do create an algorithm that solve it in O(n log n) time. To do it I need to get the \"first fit\" when I insert each value ```\nv```\n, in other words finding the first pile whose last element is bigger than v in n log n time.\n```\ndata OrderedStruct = undefined -- ???\n\n-- I need a method to remove elements in   (n log n)  time\npopFirstBigger :: Ord a -> a -> OrderedStruct a -> (Maybe a, OrderedStruct a)\npopFirstBigger a t = undefined\n\n-- and one to insert them in  (n log n) or faster\ninsert :: Ord a -> a -> OrderedStruct a -> OrderedStruct a\ninsert a t = undefined\n```\n\nI could do it with a balanced binary search tree, but I would like to know if it exists a shortest way.\nFor example, any structure that I could use in a dichotomic search would be sufficient.\nDoes such a data structure exists in standard Haskell (```\nSeq```\n for example?)\nOtherwise which data structure could I use?\n    ", "Answer": "\r\n```\nData.Set```\n offers ```\ninsert```\n, ```\ndelete```\n, and ```\nlookupGT```\n, all in O(log n) time.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Runtime complexity & correctedness of LIS\r\n                \r\n```\nfunction LIS(str1){\n\nreturn LISUtil(str1, 0);\n\nfunction LISUtil(str1, index){\n    if(index == str1.length){\n        return 0;\n    }\n    var min = str1[index],\n        len = 1;\n\n    for(let i=index+1; i<str1.length; i++){\n\n        if(min < str1[i]){\n            len++;\n            min = str1[i];\n        }\n    }\n    return Math.max(len, LISUtil(str1, index+1));\n}\n```\n\n\n}\n\nThis is what I've come up with longest increasing subsequence  (yes it looks weird, but please ignore that for now!).\n\nI've read that LIS has a runtime Complexity of 2^n. With DP, you could make it to n^2.\n\nAs I think and try my LIS function, I'm sure that it runs in n^2. It goes through n, and each index is checked O(n) times -> n^2.\n\nI've run some test cases, and it does return correctly. But I haven't used DP...meaning it must be either of these 2.\n\n\nMy function is wrong. It does not get LIS.\nThe run time is 2^n, and I am just failing to calculate the run time properly.\n\n\nCould anyone help me straighten my thoughts?\nIs my function wrong, is the runtime 2^n, or is it possible to get LIS without DP?\n    ", "Answer": "\r\nIt does not get the LIS. For instance,\n\n```\nLIS([1, 6, 2, 3, 7, 4, 5])\n```\n\n\nreturns 3. Should be 4.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Javascript: Find out of sequence dates\r\n                \r\nConsider this nested array of dates and names: \n\n```\nvar fDates = [\n    ['2015-02-03', 'name1'],\n    ['2015-02-04', 'nameg'],\n    ['2015-02-04', 'name5'],\n    ['2015-02-05', 'nameh'],\n    ['1929-03-12', 'name4'],\n    ['2023-07-01', 'name7'],\n    ['2015-02-07', 'name0'],\n    ['2015-02-08', 'nameh'],\n    ['2015-02-15', 'namex'],\n    ['2015-02-09', 'namew'],\n    ['1980-12-23', 'name2'],\n    ['2015-02-12', 'namen'],\n    ['2015-02-13', 'named'],\n]\n```\n\n\nHow can I identify those dates that are out of sequence. I don't care if dates repeat, or skip, I just need the ones out of order. Ie, I should get back:\n\n```\nresults = [\n    ['1929-03-12', 'name4'],\n    ['2023-07-01', 'name7'],\n    ['2015-02-15', 'namex'],\n    ['1980-12-23', 'name2'],\n]\n```\n\n\n('Namex' is less obvious, but it's not in the general order of the list.)\n\nThis appears to be a variation on the Longest Increase Subsequence (LIS) problem, with the caveat that there may be repeated dates in the sequence but shouldn't ever step backward.\n\nUse case: I have sorted and dated records and need to find the ones where the dates are \"suspicious\" -- perhaps input error -- to flag for checking.\n\n\n\nNB1: I am using straight Javascript and NOT a framework. (I am in node, but am looking for a package-free solution so I can understand what's going on...)\n    ", "Answer": "\r\nHere's an adaptation of Rosetta Code LIS to take a custom ```\ngetElement```\n and ```\ncompare```\n functions. We can refine the comparison and element-get functions based on your specific needs.\n\n\r\n\r\n```\nfunction f(arr, getElement, compare){\r\n  function findIndex(input){\r\n    var len = input.length;\r\n    var maxSeqEndingHere = new Array(len).fill(1)\r\n    for(var i=0; i<len; i++)\r\n      for(var j=i-1;j>=0;j--)\r\n        if(compare(getElement(input, i), getElement(input, j)) && maxSeqEndingHere[j] >= maxSeqEndingHere[i])\r\n          maxSeqEndingHere[i] = maxSeqEndingHere[j]+1;\r\n    return maxSeqEndingHere;\r\n  }\r\n\r\n  function findSequence(input, result){\r\n    var maxValue = Math.max.apply(null, result);\r\n    var maxIndex = result.indexOf(Math.max.apply(Math, result));\r\n    var output = new Set();\r\n    output.add(maxIndex);\r\n    for(var i = maxIndex ; i >= 0; i--){\r\n      if(maxValue==0)break;\r\n      if(compare(getElement(input, maxIndex), getElement(input, i))  && result[i] == maxValue-1){\r\n        output.add(i);\r\n        maxValue--;\r\n      }\r\n    }\r\n\r\n    return output;\r\n  }\r\n\r\n  var result = findIndex(arr);\r\n  var final = findSequence(arr, result)\r\n  return arr.filter((e, i) => !final.has(i));\r\n}\r\n\r\nvar fDates = [\r\n    ['2015-02-03', 'name1'],\r\n    ['2015-02-04', 'nameg'],\r\n    ['2015-02-04', 'name5'],\r\n    ['2015-02-05', 'nameh'],\r\n    ['1929-03-12', 'name4'],\r\n    ['2023-07-01', 'name7'],\r\n    ['2015-02-07', 'name0'],\r\n    ['2015-02-08', 'nameh'],\r\n    ['2015-02-15', 'namex'],\r\n    ['2015-02-09', 'namew'],\r\n    ['1980-12-23', 'name2'],\r\n    ['2015-02-12', 'namen'],\r\n    ['2015-02-13', 'named'],\r\n];\r\n\r\nconsole.log(f(fDates, (arr, i) => arr[i][0], (a,b) => a >= b));```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Profit Maximization based on dynamix programming\r\n                \r\nI have been trying to solve this problem :\n\" You have to travel to different villages to make some profit.\nIn each village, you gain some profit. But the catch is, from a particular village i, you can only move to a village j if and only if and the profit gain from village j is a multiple of the profit gain from village i.\nYou have to tell the maximum profit you can gain while traveling.\"\nHere is the link to the full problem:\nhttps://www.hackerearth.com/practice/algorithms/dynamic-programming/introduction-to-dynamic-programming-1/practice-problems/algorithm/avatar-and-his-quest-d939b13f/description/\nI have been trying to solve this problem for quite a few hours. I know this is a variant of the longest increasing subsequence but the first thought that came to my mind was to solve it through recursion and then memoize it. Here is a part of the code to my approach. Please help me identify the mistake.\n```\n    static int[] dp;\n    static int index;\n    static int solve(int[] p) {\n        int n = p.length;\n        int max = 0;\n        for(int i = 0;i<n; i++)\n        {\n            dp = new int[i+1];\n            Arrays.fill(dp,-1);\n            index = i;\n            max = Math.max(max,profit(p,i));\n        }\n        return max;\n    }\n    static int profit(int[] p, int n)\n    {\n        if(dp[n] == -1)\n        {\n            if(n == 0)\n            {\n                if(p[index] % p[n] == 0)\n                    dp[n] = p[n];\n                else\n                    dp[n] = 0;\n            }\n            else\n            {\n                int v1 = profit(p,n-1);\n                int v2 = 0;\n                if(p[index] % p[n] == 0)\n                    v2 = p[n] + profit(p,n-1);\n                dp[n] = Math.max(v1,v2);\n            }\n        }\n        return dp[n];\n    }\n```\n\n    ", "Answer": "\r\nI have used extra array to get the solution, my code is written in Java.\n```\npublic static int getmaxprofit(int[] p, int n){\n       // p is the array that contains all the village profits \n       // n is the number of villages\n       // used one extra array msis, that would be just a copy of p initially\n       int i,j,max=0;\n       int msis[] = new int[n];\n\n       for(i=0;i<n;i++){\n           msis[i]=p[i];\n       }\n       // while iteraring through p, I will check in backward and find all the villages that can be added based on criteria such previous element must be smaller and current element is multiple of previous.\n\n       for(i=1;i<n;i++){\n           for(j=0;j<i;j++){\n               if(p[i]>p[j] && p[i]%p[j]==0 && msis[i] < msis[j]+p[i]){\n                   msis[i] = msis[j]+p[i];\n               }\n           }\n       }\n       for(i=0;i<n;i++){\n           if(max < msis[i]){\n               max = msis[i];\n           }\n       }\n       return max;\n    }\n\n \n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Construct chains of pairs of numbers with one common member\r\n                \r\nI need to construct a chain of pair of numbers where:\n\nIn each pair, the first one is smaller than the second\nIn order to form a chain between two consecutive nodes, they must have one number in common. In other words, the link ```\n(a,b) -- (c,d)```\n can be made if and only if either ```\na==c```\n, ```\nb==c```\n, ```\na==d```\n or ```\nb==d```\n\nA pair cannot be made of the same number. In other words, if ```\n(a,b)```\n exists, then ```\na!=b```\n\n\nThis may look like a Longest increasing subsequence but I actually want to chain consecutive pairs that have one equal member.\nExample:\n```\nInitial list (unordered):\n(0,1)\n(2,3)\n(1,6)\n(4,6)\n(8,9)\n(2,8)\nResult:\n----- chain #1\n(0,1)\n(1,6)\n(4,6)\n----- chain #2\n(2,3)\n(2,8)\n(8,9)\n```\n\nI could do an algorithm that will iterate over the entire list for each cell (O(n^2)), but I want to make it faster and I have the flexibility of ordering my initial array in any way I want (std::set, std::map, std::unordered_map, etc.). My list is made of tens of thousands of pairs so I need an efficient solution in terms of processing time.\n    ", "Answer": "\r\nYou can solve it in ```\nO(N * log(N))```\n when you manage two lists, one sorted with respect to first the other sorted with respect to second.\nThe code has some duplication that I didnt bother to clean up yet.\n```\n#include <iostream>\n#include <list>\n#include <algorithm>\n#include <tuple>\n#include <any>\n\nstruct pair_and_iter {\n    int first;\n    int second;\n    std::any other_iter;\n};\n\nstruct compare_first {\n    bool operator()(int x,pair_and_iter p){ return x < p.first; }\n    bool operator()(pair_and_iter p, int x){ return p.first < x; }\n};\nstruct compare_second {\n    bool operator()(int x,pair_and_iter p){ return x < p.second; }\n    bool operator()(pair_and_iter p, int x){ return p.second < x; }\n};\ntemplate <typename Iter,typename Comp>\nIter my_find(Iter first,Iter last,int x, Comp comp) {\n    auto it = std::lower_bound(first,last,x,comp);\n    if (it != last && (!comp(x,*it) && !comp(*it,x))){\n        return it;\n    } else {\n        return last;\n    }\n}\n\nint main() {\n    std::list<pair_and_iter> a {{0,1},{2,3},{1,6},{4,6},{8,9},{2,8}};\n    std::list<pair_and_iter> b;\n\n    for (auto it = a.begin(); it != a.end(); ++it){\n        b.push_back({it->first,it->second,it});\n        it->other_iter = std::prev(b.end());\n    }\n\n    a.sort([](const auto& x,const auto& y){ \n        return std::tie(x.first,x.second) < std::tie(y.first,y.second); });\n    b.sort([](const auto& x,const auto& y){ \n        return std::tie(x.second,x.first) < std::tie(y.second,y.first); });\n    \n    std::vector<std::vector<pair_and_iter>> result;\n    std::vector<pair_and_iter> current_result;\n    current_result.push_back(a.front());\n    auto current = current_result.begin();\n    b.erase(std::any_cast<std::list<pair_and_iter>::iterator>(current->other_iter));\n    a.erase(a.begin());        \n\n    while (a.size() && b.size()) {\n        // look for an element with same first\n        auto it = my_find(a.begin(),a.end(),current->first,compare_first{});\n        if (it == a.end()) {\n            // look for element where current->second == elem.first\n            it = my_find(a.begin(),a.end(),current->second,compare_first{});\n        }\n        if (it != a.end()){\n            current_result.push_back(*it);\n            current = std::prev(current_result.end());\n            b.erase(std::any_cast<std::list<pair_and_iter>::iterator>(it->other_iter));\n            a.erase(it);\n            continue;\n        }\n\n        // look for element with current->first == elem.second\n        it = my_find(b.begin(),b.end(),current->first,compare_second{});\n        if (it == b.end()) {\n            // look for element with same second\n            it = my_find(b.begin(),b.end(),current->second,compare_second{});\n        }\n        if (it != b.end()) {\n            current_result.push_back(*it);            \n            current = std::prev(current_result.end());\n            a.erase(std::any_cast<std::list<pair_and_iter>::iterator>(it->other_iter));\n            b.erase(it);\n            continue;\n        }        \n        // no matching element found\n        result.push_back(current_result);\n        current_result.clear();\n        current_result.push_back(a.front());\n        current = current_result.begin();\n        b.erase(std::any_cast<std::list<pair_and_iter>::iterator>(current->other_iter));\n        a.erase(a.begin());\n    }\n    result.push_back(current_result);\n    for (const auto& chain : result){\n        for (const auto& elem : chain){\n            std::cout << elem.first << \" \" << elem.second << \"\\n\";\n        }\n        std::cout << \"\\n\";\n    }\n}\n```\n\nOutput:\n```\n0 1\n1 6\n4 6\n\n2 3\n2 8\n8 9\n```\n\nI used ```\nstd::list```\n because it has stable iterators and constant time erase. ```\nstd::any```\n for type erasure because each list contains iterators to the other list. ```\na```\n is sorted with respect to ```\nfirst```\n and ```\nb```\n is sorted with respect to ```\nsecond```\n. Hence ```\nstd::lower_bound```\n can be used to to find a match in ```\nO(logN)```\n. A single linear search is traded against 2 binary searchs to find either ```\ncurrent->first```\n or ```\ncurrent->second```\n in a ```\nfirst```\n of ```\na```\n and 2 binary searchs to find either ```\ncurrent->first```\n or ```\ncurrent->second```\n in a ```\nsecond```\n of ```\nb```\n. In total it is ```\nO(N log(N))```\n for sorting plus ```\nO( log(N) + log(N-1) + log(N-2) + .... log(1))```\n which equals ```\nO(log( n! ))```\n if I am not mistaken.\nPS: You didn't mention that you are looking for a longest chain, and this algorithm is not finding the longest chain. It just picks the first element of the remaining ones and uses the next element it finds to continue the chain.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "What is the algorithm and underlying structure of this recursive DP algorithm about buying and selling stock?\r\n                \r\nI have spent about 3 hours trying to figure this out, but I fail to understand two lines of code:\n\n```\nb[j]     = _max(b[j],     s[j] - prices[i]);\ns[j + 1] = _max(s[j + 1], b[j] + prices[i]);\n```\n\n\nThe problem that the following code is a DP solution to is:\nBest Time to Buy and Sell Stock\n\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete at most k transactions.\n\nNote:\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n\nExample 1:\n\nInput: [2,4,1], k = 2\n\nOutput: 2\n\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\nExample 2:\n\nInput: [3,2,6,5,0,3], k = 2\n\nOutput: 7\n\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.\nThen buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\n```\nint _max(int a, int b) {\n    return a > b ? a : b;\n}\nint all_profits(int* prices, int pricesSize) {\n    int i, d, p;\n\n    p = 0;\n    for (i = 1; i < pricesSize; i ++) {\n        d = prices[i] - prices[i - 1];\n        p = d > 0 ? p + d : p;  // get it as long as it is a profit!\n    }\n\n    return p;\n}\nint maxProfit(int k, int* prices, int pricesSize) {\n    int *b, *s, *buff, i, j, p;\n\n    if (pricesSize < 2) return 0;\n\n    if (k >= pricesSize / 2) return all_profits(prices, pricesSize);\n\n    buff = malloc((2 * k + 1) * sizeof(int));\n    //assert(buff);\n    b = &buff[0];\n    s = &buff[k];\n\n    for (i = 0; i < k; i ++) {\n        b[i] = 0x80000000;  // min integer\n        s[i] = 0;\n    }\n    s[k] = 0;\n\n    for (i = 0; i < pricesSize; i ++) {\n        for (j = 0; j < k; j ++) {\n            // profit on buy is current buy or last sale minus today's price\n            b[j]     = _max(b[j],     s[j] - prices[i]);\n            // profit on sale is current sale or last buy plus today's price\n            s[j + 1] = _max(s[j + 1], b[j] + prices[i]);\n        }\n    }\n\n    p = s[k];\n\n    free(buff);\n\n    return p;\n}\n```\n\n\nI understand all of the code except for the two lines mentioned at the beginning:\n\n\nWhat is the purpose of the buff array? The buff array is divided into two parts, one with b and the other with s. From what I understand, s[n] is the max profit you can make on the nth day. I have no idea what b is doing.\nWhy are we doing MAX of ```\nb[j]     = _max(b[j],     s[j] - prices[i]);```\n, should the buying price not be the lowest? Why is b[j] the max of these two things? What is s[j] - prices[i]?\nThis probably also has to do with the algorithm but why this statement: ```\ns[j + 1] = _max(s[j + 1], b[j] + prices[i]);```\n What is b[j] + prices[i] doing in this expression and what does it mean? \nWhy are we going through each day k times: ```\nfor (j = 0; j < k; j ++) {```\n?\n\n\nI have spent a lot of time (3 hours) thinking about this solution and comparing it to other DP problems, but no luck. I compared it to longest increasing subsequence DP problem and how you're supposed to \"Let length(k) denote the length of the longest increasing subsequence that ends at position k\" and tried to apply that logic to arrays here, but no luck.\n\nThank you for any help.\n    ", "Answer": "\r\nConsider that we would like to consider each price (or day) as either a buying day or a selling day to arrive at the best choices. The ```\nb```\n list is considering each day as a ```\nbuy```\n day and the ```\ns```\n list as a ```\nsell```\n day. Now we just implement the logic. What might be slightly confusing is that because ```\ns```\n is updated at ```\nj + 1```\n, for the ```\ns```\n list, ```\nj```\n is the day before.\n\nThe best ```\nk```\nth buy day for the price at ```\ni```\n is either what we already have as the ```\nk```\nth buy day or we buy, which equals the ```\n(k-1)```\nth best sell day (that's the confusing ```\ns[j]```\n) subtracted by the buying price since we just bought!\n\n```\nb[j] = _max(b[j], s[j] - prices[i]);\n```\n\n\nThe best ```\nk```\nth sell day for the price at ```\ni```\n is either what we already have as the ```\nk```\nth sell day or the best ```\nk```\nth buy day (since a ```\nk```\nth transaction has both a buy and a sell) plus today's price since we just earned it selling a stock!\n\n```\ns[j + 1] = _max(s[j + 1], b[j] + prices[i]);\n```\n\n\nUpdate\n\nPer OP's request, here's an example: ```\n[5, 20, 15, 100, 35] k = 2```\n.\n\n```\nb represents the most profit at\nthe jth buy considering prices up to i:\nmax(b[j], s[j] - prices[i])\n\ns represents the most profit at\nthe jth sell (index j+1 in s) considering prices up to i:\nmax(s[j + 1], b[j] + prices[i])\n\nnote that when j = 0, s[j] (the sell before the first buy)\nis always 0\n\nprices[0]:\n  j:  0     1\n  b:  -5    -5 // max(-Inf, 0 - 5), max(-Inf, 0 - 5)\n  s:  0     0  // max(0, -5 + 5), max(0, -5 + 5)\n\nprices[1]:\n  j:  0     1\n  b:  -5    -5 // max(-5, 0 - 20), max(-5, 15 - 20)\n  s:  15    15 // max(0, -5 + 20), max(0, -5 + 20)\n\nprices[2]:\n  j:  0    1\n  b:  -5   0   // max(-5, 0 - 15), max(-5, 15 - 15)\n  s:  15   15  // max(15, -5 + 15), max(15, 0 + 15)    \n\nprices[3]:\n  j:  0    1\n  b:  -5   0   // max(-5, 0 - 100), max(0, 0 - 100) \n  s:  95   100 // max(15, -5 + 100), max(15, 0 + 100)\n\nprices[4]:\n  j:  0    1\n  b:  -5   60  // max(-5, 0 - 35), max(0, 95 - 35)\n  s:  95   100 // max(95, -5 + 35), max(100, 60 + 35)\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Algorithm of Minimum steps to transform a list to the desired array. (Using InsertAt and DeleteAt Only)\r\n                \r\nSituation\n\nTo begin with, you have an array/list A, then you want to transform it to an expected array/list B given. The only actions that you can apply on array are ```\nInsertAt```\n and ```\nDeleteAt```\n where they are able to insert and delete an element at certain index from list.\n\n\n  note: Array B is always sorted while Array A may not be.\n\n\nFor instance, you have an array A of ```\n[1, 4, 3, 6, 7]```\n\n\nand you want it to become ```\n[2, 3, 4, 5, 6, 6, 7, 8]```\n\n\nOne way of doing that is let A undergo following actions:\n\n```\n    deleteAt(0); // which will delete element 1, arrayA now [4, 3, 6, 7]\n    deleteAt(0); // delete element 4 which now at index 0\n                 // array A now [3, 6, 7]\n    insertAt(0, 2); // Insert value to at index 0 of array A\n                    // array A now [2, 3, 6, 7]\n    insertAt(2, 4); // array now [2, 3, 4, 6, 7]\n    insertAt(3, 5); // array Now [2, 3, 4, 5, 6, 7]\n    insertAt(5, 6); // array Now [2, 3, 4, 5, 6, 6, 7]\n    insertAt(7, 8); // array Now [2, 3, 4, 5, 6, 6, 7, 8]\n```\n\n\nOn the above example, 7 operations were done on array A to transform it to array we wanted.\n\nHence, how do we find the what are the steps to transform A to B, as well as the minimum steps? Thanks!\n\nbtw, solution of deleting all element at A then add everything from B to A is only applicable when A & B have nothing in common.\n\nMy thoughts\n\nWhat I have done so far:\n\n\nCompare the array A and array B, then save delete all the elements in Array A that can't be found in array B.\nFind the longest increasing subsequence from the common list of A and B. \ndelete All elements that are not in Longest increasing sub sequence. \ncompare what is left with B, then add elements accordingly. \n\n\nHowever, I'm struggling from implementing that.. \n\nChange log\n\n\nfixed a typo of missing out element ```\n7```\n, now least operation is 7.\nAdded ```\nMY THOUGHTS```\n section\nThere was a answer that elaborated on Levenshtein distance (AKA min edit distance), somehow it disappeared.. But I found that really useful after reading git/git levenshtein.c file, it seems to be a faster algorithm then what I already have. However, I'm not sure will that algorithm give me the detailed steps, or it is only capable of giving min num of steps.\n\n    ", "Answer": "\r\nI have a python program that seems to work, but it is not very short\n\n```\n__version__ = '0.2.0'\n\nclass Impossible(RuntimeError): pass\n\ndeleteAt = 'deleteAt'\ninsertAt = 'insertAt' \nincOffset = 'incOffset'\n\ndef remove_all(size):\n    return [(deleteAt, i, None) for i in range(size-1, -1, -1)]\n\ndef index_not(seq, val):\n    for i, x in enumerate(seq):\n        if x != val:\n            return i\n    return len(seq)\n\ndef cnt_checked(func):\n    \"\"\"Helper function to check some function's contract\"\"\"\n    from functools import wraps\n    @wraps(func)\n    def wrapper(src, dst, maxsteps):\n        nsteps, steps = func(src, dst, maxsteps)\n        if nsteps > maxsteps:\n            raise RuntimeError(('cnt_checked() failed', maxsteps, nsteps))\n        return nsteps, steps\n    return wrapper\n\n@cnt_checked\ndef strategy_1(src, dst, maxsteps):\n    # get dst's first value from src\n    val = dst[0]\n    try:\n        index = src.index(val)\n    except ValueError:\n        raise Impossible\n\n    # remove all items in src before val's first occurrence\n    left_steps = remove_all(index)\n    src = src[index:]\n    n = min(index_not(src, val), index_not(dst, val))\n    score = len(left_steps)\n    assert n > 0\n    left_steps.append([incOffset, n, None])\n    right_steps = [[incOffset, -n, None]]\n    nsteps, steps = rec_find_path(src[n:], dst[n:], maxsteps - score)\n    return (score + nsteps, (left_steps + steps + right_steps))\n\n@cnt_checked\ndef strategy_2(src, dst, maxsteps):\n    # do not get dst's first value from src\n    val = dst[0]\n    left_steps = []\n    src = list(src)\n    for i in range(len(src)-1, -1, -1):\n        if src[i] == val:\n            left_steps.append((deleteAt, i, None))\n            del src[i]\n    n = index_not(dst, val)\n    right_steps = [(insertAt, 0, val) for i in range(n)]\n    dst = dst[n:]\n    score = len(left_steps) + len(right_steps)\n    nsteps, steps = rec_find_path(src, dst, maxsteps - score)\n    return (score + nsteps, (left_steps + steps + right_steps))\n\n@cnt_checked\ndef rec_find_path(src, dst, maxsteps):\n\n    if maxsteps <= 0:\n        if (maxsteps == 0) and (src == dst):\n            return (0, [])\n        else:\n            raise Impossible\n\n    # if destination is empty, clear source\n    if not dst:\n        if len(src) > maxsteps:\n            raise Impossible\n        steps = remove_all(len(src))\n        return (len(steps), steps)\n\n    found = False\n    try:\n        nsteps_1, steps_1 = strategy_1(src, dst, maxsteps)\n    except Impossible:\n        pass\n    else:\n        found = True\n        maxsteps = nsteps_1 - 1\n    try:\n        nsteps_2, steps_2 = strategy_2(src, dst, maxsteps)\n    except Impossible:\n        if found:\n            return (nsteps_1, steps_1)\n        else:\n            raise\n    else:\n        return (nsteps_2, steps_2)\n\ndef find_path(A, B):\n    assert B == list(sorted(B))\n    maxsteps = len(A) + len(B)\n    nsteps, steps = rec_find_path(A, B, maxsteps)\n    result = []\n    offset = 0\n    for a, b, c in steps:\n        if a == incOffset:\n            offset += b\n        else:\n            result.append((a, b + offset, c))\n    return result\n\ndef check(start, target, ops):\n    \"\"\"Helper function to check correctness of solution\"\"\"\n    L = list(start)\n    for a, b, c in ops:\n        print(L)\n        if a == insertAt:\n            L.insert(b, c)\n        elif a == deleteAt:\n            del L[b]\n        else:\n            raise RuntimeError(('Unexpected op:', a))\n    print(L)\n    if L != target:\n        raise RuntimeError(('Result check failed, expected', target, 'got:', L))\n\nstart = [1, 4, 3, 6, 7]\ntarget = [2, 3, 4, 5, 6, 6, 7, 8]\n\nops = find_path(start, target)\nprint(ops)\n\ncheck(start, target, ops)\n```\n\n\nAfter some tests with this code, it is now obvious that the result is\na two phases operation. There is a first phase where items are deleted from\nthe initial list, all but a increasing sequence of items all belonging to the\ntarget list (with repetition). Missing items are then added to list until\nthe target list is built.\n\nThe temporary conclusion is that if we find an algorithm to determine the\nlongest subsequence of items from the target list initially present in the\nfirst list, in the same order but not necessarily contiguous, then it gives the shortest path. This is a new\nand potentially simpler problem. This is probably what you meant above, but it is much clearer from the program's output.\n\nIt seems almost obvious that this problem can be reduced to the problem of the longest increasing subsequence\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "longest substring without repeatition bruteforce algorithm error leetcode\r\n                \r\nI have tried a whole day still answer is not coming. I don't know how to find whether an element exists in the vector or not other than this ```\nstd::find(substr.begin(),substr.end(),s[j]) != substr.end()```\n technique.\nsee my code :\n```\nclass Solution {\n    public:\n        int lengthOfLongestSubstring(string s) {\n        int max_length = 0;\n        \n        for(int i=0;i<s.length();i++){\n            int temp = 0;\n            for(int j=i;j<s.length();j++){\n                \n                vector<char> substr;\n                \n                //char ele = s[j];\n                if(substr.empty()){\n                    substr.push_back(s[j]);\n                    temp++;\n                    \n                }\n                else if( std::find(substr.begin(),substr.end(),s[j]) != substr.end()){\n                    substr.push_back(s[j]);\n                    temp++;\n                    cout<<j<<\" iteration \"<<temp<<endl;\n                }else{\n                    break;\n                }\n            }\n            //cout<<temp<<endl;\n            max_length = max(temp,max_length);\n        }\n        \n    return max_length;\n    }\n};\n```\n\nquestion is  Longest Substring Without Repeating Characters\nGiven a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\nExample 4:\nInput: s = \"\"\nOutput: 0\nhere my temp is not increasing because of that else if condition ```\n(std::find(substr.begin(),substr.end(),s[j]) != substr.end())```\n is not working as expected.\npseudocode:\n\nfor each letter greater than i take vector store subsequent non repetitive letters into that vector and then increase temp\nif you found a letter which is present in vector then break out of the loop\ncompare if its greater than max if yes replace max if no continue with all other letters.\n\nps: I'm a noob in coding and this is my first question. Help me if I'm doing something wrong.\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Optimize Code for longest common sequence\r\n                \r\nI was trying to solve this practice problem, it is also quoted below.\n\n\n  The Chef is planning a buffet for the DirectiPlex inauguration party,\n  and everyone is invited. On their way in, each guest picks up a sheet\n  of paper containing a random number (this number may be repeated). The\n  guests then sit down on a round table with their friends.\n       The Chef now decides that he would like to play a game. He asks you to pick a random person from your table and have them read their\n  number out loud.  Then, moving clockwise around the table, each person\n  will read out their number.  The goal is to find that set of numbers\n  which forms an increasing subsequence.  All people owning these\n  numbers will be eligible for a lucky draw! One of the software\n  developers is very excited about this prospect, and wants to maximize\n  the number of people who are eligible for the lucky draw. So, he\n  decides to write a program that decides who should read their number\n  first so as to maximize the number of people that are eligible for the\n  lucky draw. Can you beat him to it?\n       Input    The first line contains t, the number of test cases (about 15). Then t test cases follow. Each test case consists of two\n  lines:\n  \n  The first line contains a number N, the number of guests invited to\n  the party.\n  \n  The second line contains N numbers a1, a2, ..., an separated by\n  spaces, which are the numbers written on the sheets of paper in\n  clockwise order.\n         Output     For each test case, print a line containing a single number which is the maximum number of guests that can be eligible for\n  participating the the lucky draw.\n\n\nHere's the solution that I have come up with\n\n```\n// http://www.codechef.com/problems/D2/\nimport java.io.*;\nimport java.util.*;\n\npublic class D2\n{\n  public static void main(String [] args)\n    throws IOException\n  {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    int numTestCases = Integer.parseInt(br.readLine());\n    for(int _t=0; _t<numTestCases; ++_t)\n    {\n      int N = Integer.parseInt(br.readLine());\n      StringTokenizer strtok = new StringTokenizer(br.readLine());\n      int [] originalArray = new int[N*2];\n      for(int i=0; i<N; ++i)\n      {\n        //this concatenates the array with itself at the time of reading the input itself\n        originalArray[i] = originalArray[N+i] = Integer.parseInt(strtok.nextToken());\n      }\n      //Now we calculate the length of the longest increasing sequence\n      int maxWinners = new LongestIncreasingSequence(originalArray).lengthOfLongestIncreasingSequence();\n      System.out.println(maxWinners);\n    }\n  }\n}\n\nclass LongestIncreasingSequence\n{\n  private int [] array;\n  private int [] longest;\n  private int subsequence_size;\n  public LongestIncreasingSequence(int [] A)\n  {\n    array = A;\n    longest = new int[array.length / 2];\n    longest[0] = array[0];\n    subsequence_size = 1;\n  }\n\n  public int lengthOfLongestIncreasingSequence()\n  {\n    for(int i=1; i<array.length; ++i)\n    {\n      if(array[i] < longest[0])\n      {\n        longest[0] = array[i];\n      }\n      else if(array[i] > longest[subsequence_size - 1])\n      {\n        longest[subsequence_size++] = array[i];\n      }\n      else\n      {\n        //Make the replacement with binary search\n        longest[getReplacementIndex(array[i])] = array[i];\n      }\n    }\n    return subsequence_size;\n  }\n\n  //Method to find the correct index using binary search\n  private int getReplacementIndex(int elem)\n  {\n    int left, right, mid;\n    left = 0; right = subsequence_size - 1;\n    while(right - left > 1)\n    {\n      mid = 1 + (right - left) / 2;\n      if(array[mid] >= elem)\n      {\n        if(mid != right) right = mid;\n        else --right;\n      }\n      else\n      {\n        left = mid;\n      }\n    }\n    return right;\n  }\n}\n```\n\n\nThe complexity is ```\nO(n(log(n))```\n I'm finding the Longest Increasing Sequence by concatenating the array with itself.\n\nThis however doesn't pass the time requirement, can someone help me speed up this implementation.\n    ", "Answer": "\r\nI would not do ```\nN```\n rotations, but instead determine the longest (cyclic) run in one go. It is certainly doable, you just have to take care warping around at the end of the array.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Longest substring computational complexity\r\n                \r\nI was wondering about my apparently code for an MIT online edx class practice problem vs the provided answer code. \n\nThe assignment in question from the class was as follows: \n\n\n  Write a program that prints the longest substring of s in which the\n  letters occur in alphabetical order. For example, if s =\n  'azcbobobegghakl', then your program should print\n  \n  Longest substring in alphabetical order is: beggh\n  \n  Our automating testing will provide a value of s for you\n\n\nMy successful code: \n\n```\ncurSlice='z'\nfor b in range(len(s)):\n    for e in range(b+1,len(s)):\n        if s[e-1]<=s[e]:\n            if len(s[b:e+1])>len(aas):\n                aas=s[b:e+1]\n        else:\n            break\nprint('Longest substring in alphabetical order is: '+str(aas))\n```\n\n\nThe logic is to increment a beginning string letter and test every subsequent letter for increasing value then store the slice if bigger than the current slice,  until the test fails and and the beginning letter increments one. At which point the process starts over.\n\nMIT's Code:\n\n```\ncurString = s[0]\nlongest = s[0]\nfor i in range(1, len(s)):\n    if s[i] >= curString[-1]:\n        curString += s[i]\n        if len(curString) > len(longest):\n            longest = curString\n    else:\n        curString = s[i]\nprint 'Longest substring in alphabetical order is:', longest\n```\n\n\nwhich code is more efficient? They both are about the same length, but mine has two loops. Does that make it not as optimized? Thanks\n    ", "Answer": "\r\nAs a rough rule, adding more loops slows things down. But that's just a rough rule. Things that don't look like loops can, in actual implementation, be loops and thus slow things down. For example, innocent looking code like ```\ncurString += s[i]```\n can actually be quite slow. That's because, assuming curString is a Python string, you can't just add one more letter to it; what Python ends up doing is creating a new string that's 1 character longer than the old one, then copying all the old characters into the new string, then appending the one new character, and then assigning this new string to ```\ncurString```\n. Neither implementation is terribly efficient as they both do things like this (using range instead of xrange, copying slices of strings, etc.). However, assuming the strings are relatively short this is also unlikely to matter.\n\nIn any event, both implementations, your and theirs, could be fixed to so that each operation they perform is efficient. In that case, it does come back to the loops and their implementation is indeed faster than yours. To see why, consider a string like \"wxyabcd\". When considering the first three characters (the \"w\", \"x\", and \"y\"), both algorithms do pretty much the same thing. But consider what happens next. In your code you'll encounter the \"a\", note that this isn't in alphabetical order, so you end you inner loop. Your outer loop will have b = 1, and you'll consider the all strings that start with \"x\". However, these won't ever give you a longer string that the one that started with \"w\", so this is wasted effort. Still you'll end up checking \"x\", \"xy\", and \"y\" before moving on to check the strings that start with \"a\", while the MIT code will jump right to the strings that start with \"a\". To be more concrete, here's the set of strings your code will consider:\n\n```\nw\nwx\nwxy\nx\nxy\ny\na\nab\nabc\nabcd\nb\nbc\nbcd\nc\ncd\nd\n```\n\n\nAnd here's what the MIT code will consider\n\n```\nw\nwx\nwxy\na\nab\nabc\nabcd\n```\n\n\nAs you can see, their code does a lot less work. One way to look at it is that they \"look at\" any given character in the string only once while you will look at some characters multiple times.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Sort array in the minimum number of moves\r\n                \r\nIt is theoretically possible to sort an array in ```\nlength(array) - length(longestIncreasingSubsequence(array))```\n moves by moving only elements that are not already in sorted order.\n\nIf the only operation allowed is an in place move, by removing an element from index A and reinserting it into index B, one element at a time, how would you generate the correct moves to end up with the sorted array?  Again, there should be ```\nlength(array) - length(longestIncreasingSubsequence(array))```\n moves required.\n\nFor example, here is an array:\n\n```\n[ 1, 8, 5, 2, 4, 6, 3, 9, 7, 10 ]\n```\n\n\nThe longest increasing subsequence is:\n\n```\n[ 1, 2, 4, 6, 7, 10 ]\n```\n\n\nThe indices of those elements are:\n\n```\n[ 0, 3, 4, 5, 8, 9 ]\n```\n\n\nSo, the indices we need to move are:\n\n```\n[ 1, 2, 6, 7]\n```\n\n\nsince those are the indices that are not already in sorted order.\n\nIn order to end up with a sorted array, the final indices of those 4 elements are:\n\n```\n[ 7, 4, 2, 8]\n```\n\n\nSo, we need to simultaneously move index 1 to index 7, index 2 to index 4, index 6 to index 2, and index 7 to index 8.  The problem is that when an element is moved, the other elements are shifted around making the later move operations invalid.  I've tried transforming these indices, but so far have not come up with the correct list of moves required.  Any ideas?\n\nHopefully I've explained the problem well enough. Please ask questions and I will clarify. Thanks!\n    ", "Answer": "\r\nYour problem is that the source positions are expressed in the prior order while the destination positions are in the final order.  When you do 1->7, you don't know yet where 7 is in the prior order.  You need to make adjustments for all the moves.\n\nThe original moves are:\n\n```\nfrom: [ 1, 2, 6, 7]\nto:   [ 7, 4, 2, 8]\n```\n\n\nStep 1\n\nLet's first tranform the positions as if we were removing all elements first, then inserting the elements at the new positions.  For the ```\nfrom```\n positions, proceed from the left: removing at 1 shifts positions (2,6,7) down to (1,5,6).  Removing at 1 again shifts (5,6) down to (4,5).  Removing at 5 shifts the 5 down to 4.  For every position in ```\nfrom```\n all subsequent positions with a larger or equal index must be decremented.  We get:\n\n```\nfrom: [ 1, 1, 4, 4]\n```\n\n\nFor the ```\nto```\n positions, proceed from the end: Position 8 is correct.  Position 2 is also correct, but it means the prior (7,4) were actually (6,3) at the time of insertion.  So we adjust them.  Similarily, inserting at 3 means the prior position 6 was at 5.\n\nSo, for the ```\nto```\n array, we proceed from the end, for every position we decrement all prior positions that have a larger index.  The ```\nto```\n array becomes:\n\n```\nto:   [ 5, 3, 2, 8]\n```\n\n\nStep 2\n\nWhat we have is the correct positions for 4 removals followed by 4 insertions.  Now we want to interleave the removals and the insertions.\n\nInsertion at 5 must be done before the removals at (1, 1, 4).  5 is larger than any of these, so it won't affect the positions (1, 1, 4), but the 5 is affected because the 3 removals are done left of the insertion point.  5 becomes 8.\n\nInsertion at 3 must come before removals at (4, 4).  Since 3 is smaller than the 4's, the position 3 is unaffected by the removals but the removals must be incremented, to positions (5, 5).\n\nInsertion at 2 comes before the last removal at 5 (was 4).  It is smaller, therefore the 5 is adjusted to 6.\n\nGeneral method for step 2:\n\n```\nfor i = 0 to size-1\n    for j = size-1 to i+1\n        if from[j] < to[i] then increment to[i]\n        else increment from[j]\n```\n\n\nWe should get the arrays:\n\n```\nfrom: [ 1, 1, 5, 6]\nto:   [ 8, 3, 2, 8]\n```\n\n\nThese are the final moves to execute with the correct positions at the time of the move.  The moves can be read from left to right: Remove at 1, insert at 8.  Remove at 1, insert at 3.  Remove at 5, insert at 2.  Remove at 6, insert at 8.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "how to get longest sub ascending array, which is not necessarily have to be contiguous\r\n                \r\nI want to get the longest subarray from a large list. For simplfy, I just show a slice of the array:\n```\na = [1263, 1270, 1265, 1267, 1266, 1269, 1271, 1272, 1268, 1264, 1288, 1289, 1261, 1262, 1284, 1277, 1278, 1281, 1273, 1279, 1280, 1296]\n```\n\nThe output should keep as many elements as possible in ascending order. The output does not necessarily have to be contiguous.\nI got the output manually, and found that it should have 11 elements:\n```\n[1263, 1265, 1266, 1269, 1271, 1272, 1277, 1278, 1279, 1280, 1296]\n```\n\nHowever, I can only get 7 elements array from my code:\n```\ndef get_ascending_sub_array(arr):\n    if not arr:\n        return arr\n    if len(arr) == 1:\n        return arr\n    else:\n        sub_arr = [ arr[0] ]\n        for i in range(1,len(arr)):\n            if arr[i] > sub_arr[-1]:\n                sub_arr.append(arr[i])\n        return sub_arr\n\n\n\ndef get_longest_sub_ascending_array(arr):\n    outarr = []\n    if not arr:\n        return arr\n    if len(arr) == 1:\n        return arr\n    max_len = 0\n    max_arr = []\n    for i in range(len(arr)):\n        if len(arr[i:]) > max_len:\n            arr_start_at_i = get_longest_sub_ascending_array(arr[i:])\n            if len(arr_start_at_i) > max_len:\n                max_len = max_len\n                max_arr = get_ascending_sub_array(arr[i:])\n    outarr = max_arr\n    return outarr\n\nprint get_ascending_sub_array(a)\n\n\n```\n\noutput:\n```\n[1263, 1270, 1271, 1272, 1288, 1289, 1296]\n```\n\nWhat's wrong with my code?\nThank you for any suggestions.\n\nFinally, I found this answer from here:\n```\n# Dynamic Programming solution to construct Longest \n# Increasing Subsequence \n\n# Utility function to print LIS \ndef printLIS(arr): \n    arr = list(arr)\n    for x in arr: \n        print x,\n    print \n    print len(arr)\n\n# Function to construct and print Longest Increasing \n# Subsequence \ndef constructPrintLIS(arr, n): \n    arr = list(arr)\n    n = int(n)\n\n    # L[i] - The longest increasing sub-sequence \n    # ends with arr[i] \n    l = [[] for i in range(n)] \n\n    # L[0] is equal to arr[0] \n    l[0].append(arr[0]) \n\n    # start from index 1 \n    for i in range(1, n): \n\n        # do for every j less than i \n        for j in range(i): \n\n            # L[i] = {Max(L[j])} + arr[i] \n            # where j < i and arr[j] < arr[i] \n            if arr[i] > arr[j] and (len(l[i]) < len(l[j]) + 1): \n                l[i] = list(l[j]) #.copy() \n\n        # L[i] ends with arr[i] \n        l[i].append(arr[i]) \n\n    # L[i] now stores increasing sub-sequence of \n    # arr[0..i] that ends with arr[i] \n    maxx = l[0] \n\n    # LIS will be max of all increasing sub- \n    # sequences of arr \n    for x in l: \n        if len(x) > len(maxx): \n            maxx = x \n\n    # max will contain LIS \n    printLIS(maxx) \n\n\n\n# This code is contributed by \n# sanjeev2552 \n\n\n\n\n\na = [1263, 1270, 1265, 1267, 1266, 1269, 1271, \n     1272, 1268, 1264, 1288, 1289, 1261, 1262, 1284, \n     1277, 1278, 1281, 1273, 1279, 1280, 1296]\n\nprint constructPrintLIS(a, len(a)) \n\n```\n\n    ", "Answer": "\r\nThe problem you describe is the longest increasing subsequence problem.\nThe algorithm is described in the Wikipedia link above. I suggest you use the algorithm they describe, which runs rather quickly (```\nO(n log n)```\n).\nIf you do not understand it well, you also can compute the longest common subsequence between ```\narr```\n and ```\nsorted(arr)```\n using a dynamic programming algorithm. It will run in ```\nO(n²)```\n, which is suboptimal but still adapted to relatively small inputs.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Getting two different answers on same input just by different methods of initialization of an array in C++\r\n                \r\nI was solving a DP problem, Longest Increasing Subsequence, wherein I initialized the dp array by two different methods and got different results for the same input.\n\nFirst method, where I got the wrong answer was: ```\nint dp[n] = {1};```\n\n\nSecond method, again a wrong answer: ```\nint dp[n];\n                                      memset(dp, 1, sizeof(dp));```\n\n\nFinally, when I initialized the array manually using a \"for loop\", I got the right answer.\n\nWhat is the difference between all the three methods of initialization ?\n\nInput: First Line (N i.e size of the array), next line : array elements\n\n83\n\n86 177 115 193 135 186 92 49 21 162 27 90 59 163 126 140 26 172 136 11 168 167 29 182 130 62 123 67 135 129 2 22 58 69 167 193 56 11 42 29 173 21 119 184 137 198 124 115 170 13 126 91 180 156 73 62 170 196 81 105 125 84 127 136 105 46 129 113 57 124 95 182 145 14 167 34 164 43 150 87 8 76 178\n\nCorrect output: 15\n\nMy answer with \"memset\" and direct initialization was 14. Got 15 after initializing using a for-loop.\n    ", "Answer": "\r\nWith\n\n```\nint dp[n] = {1};\n```\n\n\nyou initialize the first element to ```\n1```\n, and the rest to zero.\n\nWith\n\n```\nmemset(dp, 1, sizeof(dp));\n```\n\n\nyou set all bytes to ```\n1```\n, which means that each element in the array will be ```\n0x01010101```\n.\n\nThe \"correct\" way to set all elements of an array to a specific value is to use the algorithm function ```\nstd::fill```\n or ```\nstd::fill_n```\n. Or use a ```\nstd::vector```\n where you can pass a default value to the constructor for each element.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Helping to solve the algorithm by dynamic programming\r\n                \r\nI try to solve a Longest Anchored Comb Problem by dynamic programming but do not know how to achieve the algorithm. Codes except the algorithm have been written down below.\nCan someone tell me how to solve the algorithm part?\nHere are the definition of the problem.\nIn the list of numbers, any subsequence in this array of the form A[i1], A[i1 + 1], A[i2], A[i2 + 1], . . . , A[ik], A[ik + 1] of 2k elements of array A, for some integer k ≥ 1, and for some indices 1 ≤ i1 < i1 + 1 < i2 < i2 + 1 < · · · < ik < ik + 1 ≤ n such that A[i1] < A[i1 + 1] > A[i2] < A[i2 + 1] > A[i3] < · · · > A[ik] < A[ik + 1], is called a comb.\nWe call a given comb A[i1], A[i1 + 1], A[i2], A[i2 + 1], . . . , A[ik], A[ik + 1] anchored if A[i1] = A[ik] .\n3 examples:\n\nFor instance if A[1, 3, 10, 15, 21], n = 5, then because this sequence is increasing, the longest comb has length k = 1, and such longest comb is\nnot unique, e.g., 1, 3; 3, 10; 15, 21 – are examples of 3 longest and anchored combs, each of length 1, i.e., each having one tooth. The output in this instance is therefore 1. Another example of the input array A = [5, 3, 2, 1] with n = 4, where the sequence is decreasing means that there is no comb there, so the output to the Longest Anchored Comb Problem is 0.\n\nAnother input A[1, 3, 2, 11, 12, 10, 11, 2, 23] with n = 9. Here subsequence A[1], A[2], A[3], A[4], A[6], A[7], A[8], A[9], which is\n1, 3, 2, 11, 10, 11, 2, 23,is a comb of length k = 4 (with 4 teeth), but it is not anchored because the first elements of its first and last teeth are not equal: A[1] = 1 and A[8] = 2. However, subsequence A[3], A[4], A[6], A[7], A[8], A[9] which is 2, 11, 10, 11, 2, 23 is an anchored comb of length k = 3 (with 3 teeth), because the first elements of its first and last teeth are equal: A[3] = 2 and A[8] = 2. This is also the longest anchored comb in this instance, so the output to the Longest Anchored Comb problem is 3.\n\n\n3.Suppose, for instance, that n = 10 and that the input sequence is:\n1 3 2 4 3 5 4 6 1 3,\nthat is, A[1] = 1, A[2] = 3, A[3] = 2, A[4] = 4, A[5] = 3, A[6] = 5, A[7] =\n4, A[8] = 6, A[9] = 1, A[10] = 3. Then, for instance, A[2] = 3, A[4] =\n4, A[5] = 3, A[6] = 5 is an anchored comb of length 2, but the longest anchored comb is the whole array and has length 5.\n```\n import javax.xml.crypto.Data;\n import java.io.File;\n import java.io.InputStreamReader;\n import java.io.BufferedReader;\n import java.io.FileInputStream;\n import java.lang.reflect.Array;\n import java.util.ArrayList;\n import java.util.Scanner;\n\npublic class Main{\n\n    public static ArrayList<String> ReadData(String pathname) {\n      ArrayList<String> strlist = new ArrayList<String>();\n      try {\n\n        File filename = new File(pathname);\n        InputStreamReader reader = new InputStreamReader(\n                new FileInputStream(filename));\n        BufferedReader br = new BufferedReader(reader);\n        int j = 0;\n        String line = \"\";\n        while ((line = br.readLine()) != null) {\n            strlist.add(line);\n        }\n        return strlist;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return strlist;\n}\n\npublic static ArrayList<ArrayList<Integer> > DataWash(ArrayList<String> Datalist) {\n    ArrayList<ArrayList<Integer> > AIS = new ArrayList<ArrayList<Integer> >();\n    ArrayList<Integer> IS = new ArrayList<Integer>();\n    for (int i = 0; i < Datalist.size(); i++) {\n        String Tstr = Datalist.get(i);\n        if (Tstr.equals(\"A\") == false) {\n            IS.add(Integer.parseInt(Tstr));\n        }\n        if (Tstr.equals(\"A\")) {\n            ArrayList<Integer> elemAIS = new ArrayList<Integer>(IS);\n            AIS.add(elemAIS);\n            IS.clear();\n        }\n    }\n    return AIS;\n}\n\n\n  //%%%%%%%%%%%%%%%%%%%%%%% Procedure LongestComb() that contains code to write. \n    //These codes are to complete:\n    \npublic static int LongestComb(int[] A, int n){\n    /* Input is array of input sequence (a_1 <= a_2 <= ... <= a_n) as A[0,1,...,n-1], that is,\n    a_1 = A[0], a_2 = A[1], ..., a_n = A[n-1].\n    n = number of integers in sequence A\n    This procedure returns the value of the longest anchored comb (>= 1) or 0 if there is no anchored comb. It should not return the respective anchored comb.\n    */\n\n\n    /* \n                   Given an array T[1,...,n] \n                   then M = max_{k: some condition C(k) holds} [ T[k] ],\n                   M denotes the largest value T[k] over all indices k such that condition C(k) holds.\n    .....\n    .....\n    */\n\n    /* Here should be the statement and description of the running time\n    analysis: describe how the running time depends on\n    n (length of the input sequence), and give short argument.\n\n    .....\n    ..... \n    */\n\n    /* Here should be the code to solve the problem:\n  \n\n    .....\n    .....\n    return ...;\n    */\n\n} // end of procedure LongestComb()\n\n\npublic static int Computation(ArrayList<Integer> Instance, int opt){\n    // opt=1 here means option 1 as in -opt1, and opt=2 means option 2 as in -opt2\n    int NGounp = 0;\n    int size = 0;\n    int Correct = 0;\n    size = Instance.size();\n\n    int [] A = new int[size-opt];\n    // NGounp = Integer.parseInt((String)Instance.get(0));\n    NGounp = Instance.get(0); // NOTE: NGounp = 0 always, as it is NOT used for any purpose\n                                       // It is just the first \"0\" in the first line before instance starts.\n    for (int i = opt; i< size;i++ ){\n        A[i-opt] = Instance.get(i);\n    }\n    int Size =A.length;\n    if (NGounp >Size ){\n        return (-1);\n    }\n    else {\n        //Size\n        int R = LongestComb(A,Size);\n        return(R);\n    }\n}\n\npublic static String Test;\n\n\npublic static void main(String[] args) {\n    if (args.length == 0) {\n        String msg = \"Rerun with flag: \" +\n        \"\\n\\t -opt1 to get input from dataOne.txt \" + \n        \"\\n\\t -opt2 to check results in dataTwo.txt\";\n        System.out.println(msg);\n        return;\n    }\n    Test = args[0];\n    int opt = 2;\n    String pathname = \"dataTwo.txt\";\n    if (Test.equals(\"-opt1\")) {\n        opt = 1;\n        pathname = \"dataOne.txt\";\n    }\n\n\n    ArrayList<String> Datalist = new ArrayList<String>();\n    Datalist = ReadData(pathname);\n    ArrayList<ArrayList<Integer> > AIS = DataWash(Datalist);\n\n    int Nins = AIS.size();\n    int NGounp = 0;\n    int size = 0;\n    if (Test.equals(\"-opt1\")) {\n        for (int t = 0; t < Nins; t++) {\n            int Correct = 0;\n            int Result = 0;\n            ArrayList<Integer> Instance = AIS.get(t);\n            Result = Computation(Instance, opt);\n            System.out.println(Result);\n        }\n    }\n    else {\n        int wrong_no = 0;\n        int Correct = 0;\n        int Result = 0;\n        ArrayList<Integer> Wrong = new ArrayList<Integer>();\n        for (int t = 0; t < Nins; t++) {\n            ArrayList<Integer> Instance = AIS.get(t);\n            Result = Computation(Instance, opt);\n            System.out.println(Result);\n            Correct = Instance.get(1);\n            if (Correct != Result) {\n                Wrong.add(t+1);\n                wrong_no=wrong_no+1;\n            }\n        }\n        if (Wrong.size() > 0) {System.out.println(\"Index of wrong instance(s):\");}\n        for (int j = 0; j < Wrong.size(); j++) {\n            System.out.print(Wrong.get(j));\n            System.out.print(\",\");\n\n            /*ArrayList Instance = (ArrayList)Wrong.get(j);\n            for (int k = 0; k < Instance.size(); k++){\n                System.out.println(Instance.get(k));\n            }*/\n        }\n        System.out.println(\"\");\n        System.out.println(\"Percentage of correct answers:\");\n        System.out.println(((double)(Nins-wrong_no) / (double)Nins)*100);\n\n    }\n\n }\n```\n\n}\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Maintain the same sorted order using different comparisons\r\n                \r\nSuppose we have an object that can be sorted using two or more comparison functions. For instance a ```\nBox```\n that has a ```\nlength```\n, a ```\nwidth```\n, and a ```\nheight```\n. We can sort an array of boxes according to any of these fields.\n\nNow consider two arrays of ```\nBox```\n objects that contain identical boxes. In the first array the boxes are sorted in order of increasing size by their ```\nlength```\n. In the second array the boxes are sorted in order of increasing size by their ```\nheight```\n. Most likely these two sorted arrays will list the boxes in a different order. \n\nWe want to find a third array that has a subset of the boxes and has the property that if we sort them by either their ```\nlength```\n or their ```\nheight```\n, we will have the same sorted order.\n\nIs this simply a matter of finding the longest common subsequence of boxes between the two sorted arrays? Is there a better way to do this or a nice implementation in C++ without having to implement the algorithm for LCS if that is the most practical way to go? Are there any data structures that maintain this property on their own that are practical?\n    ", "Answer": "\r\nWhat you've just described is an instance of the longest common subsequence problem, which is NP-hard.\n\nIntuitively, you can view this as a matryoshka nesting problem. The only elements that satisfy the relation must perfectly fit inside one another, but using the square of their longest edge instead of rote topology.\n\nHere's two related questions, plus a canned implementation in C++.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Maximize sum of weights with constraints given on left and right indices in array\r\n                \r\nI recently came through an interesting coding problem, which is as follows: \n\nThere are n boxes, let us assume this is an array of n boxes.\n\nFor each index i of this array, three values are given -\n\n1.) Weight(i)\n\n2.) Left(i)\n\n3.) Right(i)\n\n```\nleft(i)```\n means - if ```\nweight[i]```\n is chosen, we are not allowed to choose ```\nleft[i]```\n elements from the left of this ```\nith element```\n.\n\nSimilarly, ```\nright[i]```\n means if ```\narr[i]```\n is chosen, we are not allowed to choose ```\nright[i]```\n elements from the right of it.\n\nExample :\n\nWeight[2] = 5\n\nLeft[2] = 1\n\nRight[2] = 3\n\nThen, if I pick element at position 2, I get weight of 5 units. But, I cannot pick elements at position {1} (due to left constraint). And cannot pick elements at position {3,4,5} (due to right constraint).\n\nObjective - We need to calculate the maximum sum of the weights we can pick.\n\nSample Test Case :-\n\n**Input: **\n\n5\n\n2 0 3\n\n4 0 0\n\n3 2 0\n\n7 2 1\n\n9 2 0\n\n**Output: **\n\n13\n\nNote - First column is weights, Second column is left constraints, Third column is right constraints\n\nI used Dynamic Programming approach(similar to Longest Increasing Subsequence) to reach a ```\nO(n^2)```\n solution. But, not able to think of a ```\nO(n*logn)```\n solution. ```\n(n can be up to 10^5.)```\n \n\nI also tried to use priority queue, in which elements with lower value of ```\n(right[i] + i)```\n are given higher priority(assigned higher priority to element with lower value of \"i\", in case primary key value is equal). But, it is also giving timeout error. \n\nAny other approach for this? or any optimization in priority queue method? I can post both of my codes if needed.\nThanks.\n    ", "Answer": "\r\nOne approach is to use a binary indexed tree to create a data structure that makes it easy to do two operations in O(logn) time each:\n\n\nInsert number into an array\nFind maximum in a given range\n\n\nWe will use this data structure to hold the maximum weight that can be achieved by selecting box i along with an optimal selection of boxes to the left.\n\nThe key is that we will only insert values into this data structure when we reach a point where the right constraint has been met.\n\nTo find the best value for box i, we need to find the maximum value in the data structure for all points up to location i-left[i], which can be done in O(logn).\n\nThe final algorithm is to loop over i=0..n-1 and for each i:\n\n\nCompute result for box i by finding maximum in range 0..(i-left[i])\nSchedule the result to be added when we reach location i+right[i]\nAdd any previously scheduled results into our data structure\n\n\nThe final result is the maximum value in the whole data structure.\n\nOverall, the complexity is o(nlogn) because each value of i results in one lookup and one update operation.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Why is my algorithm timing out?\r\n                \r\nHere's the problem (from Leetcode):\n\n```\nGiven an unsorted array of integers, find the length of longest increasing subsequence.\n\nExample:\n\nInput: [10,9,2,5,3,7,101,18]\nOutput: 4 \nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \nNote:\n\nThere may be more than one LIS combination, it is only necessary for you to return the length.\nYour algorithm should run in O(n2) complexity.\n```\n\n\nHere's my solution:\n\n```\nmemo = {} \ndef lis_calc(lower_bound, offset):\n    if memo.get((lower_bound, offset), None):\n        return memo[(lower_bound, offset)]\n    if offset >= len(nums):\n        return 0\n    if nums[offset] > lower_bound:\n        res = max(1 + lis_calc(nums[offset], offset + 1), lis_calc(lower_bound, offset + 1))\n    else:\n        res = lis_calc(lower_bound, offset + 1)\n\n    memo[(lower_bound, offset)] = res \n    return memo[(lower_bound, offset)]\n```\n\n\nIn the worst case (list is already sorted ascending order), we'll have NxN unique function calls, (N values for each arg in pair). However, my algorithm is timing out for very large inputs, which suggests that my algorithm does not have a worst case time cost of O(NxN). Am I doing something incorrectly here? Seems like a straightforward implementation of DP + memoization. The test input that it's timing out on is ```\nlist(range(1,2501))```\n\n\nI invoke the function via ```\nlis_calc(float('-inf'), 0)```\n\n    ", "Answer": "\r\nYour algorithm may not be quadratic, but exponential.\n\nLook at this code:\n\n```\nif nums[offset] > lower_bound:\n    res = max(1 + lis_calc(nums[offset], offset + 1), lis_calc(lower_bound, offset + 1))\n```\n\n\nAt each step, in the worst case, you make two calls. And each of those two calls, worst-case, makes two calls. And each of those four call makes two calls, and so on.\n\nYour algorithm could still be polynomial if one of two things were true:\n\n\nIf at least half of those new calls were memo-cached, or\nIf it were guaranteed that a worst case would reduce to the lower-bound case (which becomes linear) in at worst ```\nlog N```\n steps.\n\n\nBut as far as I can tell, neither of those is true. So, worst case, your algorithm takes ```\nO(2**N)```\n steps. Which is why it's too slow.\n\n\n\nOr… maybe that's not true, maybe it's just taking quadratic time with an extra constant factor, and 2500 is right near the edge of where they expected your code to work comfortably, and you just didn't quite pass?\n\nEach time you double the calls, you aren't going to cache half of them—but you should be caching half of ```\nN-1```\n of them. So your total steps should work out to ```\nN * (N+1) + 1```\n if everything is going right, but if you got it slightly wrong that could be enough to be off by a factor of 4… Although really, I don't think it would be a great test if a constant factor of 4 at even the very largest number they test is enough to make a difference.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Find maximal subset of all non connected elements if Elements swapped in bubble sort are connected\r\n                \r\nPROBLEM STATEMENT\n\nIn Bubble sort,whenever I swap two elements in the array (while sorting),I tie a rope between the element which are swapped.I need to find the size of the maximal set in the array in which none of the elements are connected with any other element after the bubble sort is done .\n\neg : { 1 , 3 ,2 }\n\n1st iteration of bubble sort :\n\n2 and 3 swapped so tie 2 with 3 \n\n{1 ,2,3}\n\n2nd iteration \n\n{1,2,3}\nno swaps in this iteration so dont tie any element with any other element \n\n3rd iteration \n\n{1,2,3}\nno swaps in this iteration so dont tie any element with any other element  \n\nafter the end of bubble sort only 2 and 3 are tied together \n\nAnswer for this example is 2 because the size of  the maximal set  in which none of the elements is not tied with any other element.\n\nthe possible maximal sets are {1,2} (since 1 and 2 are not tied with a rope) and {1,3}  { since 1 and 3 are not tied with the rope }\n\nPossible subsets for this array are {1} , {2}, {3} ,{1,2} ,{1,3} ,{3,2} {1,3,2},{ }\n\nout of these valid subsets are {1},{2},{3},{1,2},{1,3} In this valid subsets {1,2} and {1,3} are larger subsets .The size of both the subsets are 2 .so the answer is 2.\n\nInput :\n\nFirst line of input contains T  - No of test cases \n\nfirst line of each test case contains n ( 1 <= n <= 100000 )- number of elements in the array \n\nsecond line  of each test case contains n elements of the array \n\nexample:\n\ninput : (from the example explained above )\n\n1\n\n3\n\n1 3 2 \n\noutput :\n\n2\n\nMY APPROACH\n\nI think the maximal subset length will be the length of longest increasing subsequence and here's my code getting WRONG ANSWERS. Please help!\n\n```\n#include <iostream>\nusing namespace std;\n\nint bs(int a[],int x,int lo,int hi)\n{\nwhile(hi-lo>1)\n{\n    int mid=(hi+lo)/2;\n    if(a[mid]>=x)\n    hi=mid;\n    else\n    lo=mid;\n}\nreturn hi;\n}\n\nint main() {\nint t;\ncin>>t;\nwhile(t--)\n{\n    int n,m=1;\n    cin>>n;\n    int a[n+1];\n    for(int i=0;i<n;i++)\n    cin>>a[i];\n    int dp[n+1];\n    for(int i=0;i<n;i++)\n    dp[i]=0;\n    dp[0]=a[0];\n    for(int i=1;i<n;i++)\n    {\n        if(dp[0]>a[i])\n        dp[0]=a[i];\n        else if(a[i]>dp[m-1])\n        dp[m++]=a[i];\n        else\n        {\n            int x=bs(a,a[i],-1,m-1);\n            dp[x]=a[i];\n        }\n    }\n    cout<<m<<endl;\n}\nreturn 0;\n}\n```\n\n    ", "Answer": "\r\nObserve first by induction that each connected component is an interval.\n\nObserve next that, given a partition of the input into two parts, there is no edge spanning the parts if and only if every element in the first part is less than or equal to every element in the second part.\n\nThe connected components can be identified using a linear-time algorithm.\n\n```\ndef count(lst):\n    compmaxes = []  # holds the maximum of each connected component\n    for x in lst:\n        if not compmaxes or compmaxes[-1] <= x:\n            compmaxes.append(x)\n        else:\n            while len(compmaxes) > 1 and compmaxes[-2] > x:\n                del compmaxes[-2]\n    return len(compmaxes)\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Is the computational complexity of counting runs in cribbage O(N*log(N)) in the worst case?\r\n                \r\nIn the card game cribbage, counting the runs for a hand during the show (one of the stages of a turn in the game) is reporting the longest increasing subsequence which consists of only values that increase by 1. If duplicate values exist are apart of this subsequence than a double run (or triple, quadruple, et cetera) is reported.\nSome examples:\n(\"A\",\"2\",\"3\",\"4\",\"5\") => (1,5) Single run for 5\n(\"A\",\"2\",\"3\",\"4\",\"4\") => (2,4) Double run for 4\n(\"A\",\"2\",\"3\",\"3\",\"3\") => (3,3) Triple run for 3\n(\"A\",\"2\",\"3\",\"4\",\"6\") => (1,4) Single run for 4\n(\"A\",\"2\",\"3\",\"5\",\"6\") => (1,3) Single run for 3\n(\"A\",\"2\",\"4\",\"5\",\"7\") => (0,0) No runs\nTo address cases that arise with hands larger than the cribbage hand size of 5. A run will be selected if it has the maximum product of the number duplicates of a subsequence and that subsequences length.\nSome relevant examples:\n(\"A\",\"2\",\"2\",\"3\",\"5\",\"6\",\"7\",\"8\",\"9\",\"T\",\"J\") => (1,7) Single run for 7\n(\"A\",\"2\",\"2\",\"3\",\"5\",\"6\",\"7\",\"8\") => (2,3) Double run for 3\nMy method for finding the maximum scoring run is as follows:\n\nCreate a list of ranks and sort it. O(N*log(N))\nCreate a list to store the length of the maximum run length and how many duplicates of it exist. Initialize it to [1 duplicate, 1 long].\nCreate an identical list as above to store the current run.\nCreate a flag that indicates whether the duplicate you've encountered is not the initial duplicate of this value. Initialize it to False.\nCreate a variable to store the increase in duplicate subsequences if additional duplicates values are found after the initial duplicate. Initialize it to 1.\nIterate over the differences between adjacent elements. O(N)\nIf the difference is greater than one, the run has ended. Check if the product of the elements of the max run is less than the current run and the current run has length 3 or greater. If this is true, the current run becomes the maximum run and the current run list is reset to [1,1]. The flag is reset to False. The increment for duplicate subsequences is reset to 1. Iterate to next value.\nIf the difference is 1, increment the length of the current run by 1 and set the flag to False. Iterate to next value.\nIf the difference is 0 and the flag is False, set the increment for duplicate subsequences equal to the current number of duplicates for the run. Then, double the number of duplicates for the run and set the flag to True. Iterate to the next value\nIf the difference is 0 and the flag is True, increase the number of the runs by the increment for duplicate subsequences value.\nAfter the iteration, check the current run list as in step 7 against the max run and set max run accordingly.\n\nI believe this has O(N*(1+log(N)). I believe this is the best time complexity, but I am not sure how to prove this or what a better algorithm would look like. Is there a way to do this without sorting the list first that achieves a better time complexity? If not, how does one go about proving this is the best time complexity?\niterate over the differences between\n    ", "Answer": "\r\nTime complexity of an algorithm is a well-traveled path.  Proving the complexity of an algorithm varies slightly among mathematician clusters; rather, the complexity community usually works with modular pseudo-code and standard reductions.  For instance, a ```\nfor```\n loop based on the input length is O(N) (surprise); sorting a list is known to be O(log N) at best (in the general case).  For an good treatment, see Big O, how do you calculate/approximate it?.\nNote: O(N x (1+log(N)) is slightly sloppy notation.  Only the greatest complexity factor -- the one that dominates as ```\nN```\n approaches infinity -- is used.  Drop the ```\n1+```\n: it's simply O(N log N).\nAs I suggested in a comment, you can simply count elements.  Keep a list of counts, indexed by your card values.  For discussing the algorithm, don't use the \"dirty\" data of character representations: \"A23456789TJQK\"; simply use their values, either 0-12 or 1-13.\n```\nfor rank in hand:\n    count[rank] += 1\n```\n\nThis is a linear pass through the data, O(N).\nNow, traverse your array of counts, finding the longest sequence of non-zero values.  This is a fixed-length list of 13 elements, touching each element only once: O(1).  If you accumulate a list of multiples (card counts, then you'll also have your combinatoric factors at the end.\nThe resulting algorithm and code are, therefore, O(N).\n\nFor instance, let's shorten this to 7 card values, 0-6.  Given the input integers\n```\n1 2 1 3 6 1 3 5 0\n```\n\nYou make the first pass to count items:\n```\n[1 3 1 2 0 1 1]\n```\n\nA second pass gives you a max run length of 4, with counts [1 3 1 2].\nYou report a run of 4, a triple and a double, or the point count\n```\n4 * (1 * 3 * 1 * 2)\n```\n\nYou can also count the pair values:\n```\n2 * 3! + 2 * 2!\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Nested Boxes Algorithm - based on Nested Dolls but fundamentally different?\r\n                \r\nI've tried to solve a problem related to the SPOJ Nested Dolls problem, where boxes with a two-dimensional bottom are used instead of dolls that differ in a single scale parameter. I have an algorithm but I'm very muddy about the actual theory behind the problem and whether better approaches exist. Can anyone help me understand the problem better and perhaps find a better algorithm?\n\nAs a refresher, the Nested Dolls problem as follows:\n\nGiven N Matryoshka dolls of a various sizes, find the smallest number of nested dolls that remain after optimally nesting the dolls inside one another. For each nested doll, if the outermost doll has size S then it either contains no dolls, or it contains one nested doll whose size is strictly smaller than S.\n\nI don't know the full specifics of this problem, but from reading about it I believe the Nested Dolls problem can be solved by sorting the dolls by increasing size and repeatedly extracting the Longest Increasing Subsequence (LIS) from the size sequences, where ties are broken by choosing the subsequence that utilizes the biggest dolls. The number of nested dolls would be the number of subsequences extracted. I think this greedy algorithm works because:\n\na) Reducing the length of one of these subsequences introduces new dolls that cannot reduce the number of nested dolls found in future steps (\"fewer is better\")\n\nb) Replacing a doll in the subsequence necessarily replaces a smaller doll in the set of remaining dolls with a larger doll, which cannot reduce the number of nested dolls found in future steps (\"smaller is better\")\n\nThis means the problem can be solved in O(N log N) with a good LIS algorithm.\n\nBut the boxes problem is different:\nGiven N open boxes with various bottom dimensions, find the smallest number of box-stacks that remain after optimally nesting the boxes inside one another. For each box-stack, if the outermost box has dimension WxH then it either contains no boxes, or it contains one box-stack whose width and height are strictly smaller than W and H respectively.\n\nThis means there is no total ordering of the boxes - if box A doesn't fit in box B, it does not imply box B has the same size as A or that it will fit in box A, unlike Matryoshka dolls.\n\nI have no idea if I'm right but I think it's no longer true that the optimal solution can be found  by repeatedly extracting the LIS (or rather, the longest sequence of boxes fitting in each other), mainly because there's no good way to break ties. A box with larger area can still end up more useful for future steps if, say, we're comparing between a 1x17 box and a 5x4 box. Trying out all the tied LIS's sounds like exponential runtime. Am I right, or is there really a greedy way to do this?\n\nI've only found one other post about this (Stacking boxes into fewest number of stacks efficiently?) which suggests using a graph theory approach to solve the problem. I have very little experience with graph theory so I have no idea how the approach works. I basically blindly took their word to make a bipartite graph of boxes, asserting that the number of box stacks = (number of boxes - size of the maximum matching). I then implemented the Fork Fulkerson algorithm in Java based on pseudocode without fully understanding how it actually solves the problem. I've tried my best to annotate the code with my thought process, but it irks me how this approach is so different from the Nested Dolls solution, and that it takes 150+ lines when I was challenged to do this in 1 hour. Is it true that there's no easier way to solve the problem?\n\nCode:\n\n```\nimport java.util.*;\n\npublic class NestedBoxes {\n    private static final int SOURCE_INDEX = -1;\n    private static final int SINK_INDEX = -2;\n\n    private NestedBoxes() {\n        // Unused\n    }\n\n    public static void main(String args[] ) throws Exception {\n        // Get box dimensions from user input\n        Scanner sc = new Scanner(System.in);\n        int numBoxes = sc.nextInt();\n        List<Rectangle> boxes = new ArrayList<>();\n        for (int i = 0; i < numBoxes; i++) {\n            Rectangle box = new Rectangle(sc.nextInt(), sc.nextInt());\n            boxes.add(box);\n        }\n\n        // Sort boxes by bottom area as a useful heuristic\n        Collections.sort(boxes, (b1, b2) -> Integer.compare(b1.width * b1.height, b2.width * b2.height));\n\n        // Make a bipartite graph based on which boxes fit into each other, and\n        //  add a source linking to all boxes and a sink linked by all boxes.\n        // Forward edges go from the left (lower index) nodes to the right (higher index) nodes.\n        // Each forward edge has a corresponding backward edge in the bipartite section.\n        // Only one of the two edges are active at any point in time.\n        Map<Integer, Map<Integer, BooleanVal>> graphEdges = new HashMap<>();\n        Map<Integer, BooleanVal> sourceMap = new HashMap<>();\n        graphEdges.put(SOURCE_INDEX, sourceMap);\n        graphEdges.put(SINK_INDEX, new HashMap<>()); // Empty adjacency list for the sink\n        for (int i = 0; i < numBoxes; i++) {\n            // TreeMaps make the later DFS step prefer reaching the sink over other nodes, and prefer\n            //  putting boxes into the smallest fitting box first, speeding up the search a bit since\n            //  log(N) is not that bad compared to a large constant factor.\n            graphEdges.put(i, new TreeMap<>());\n            // Each node representing a box is duplicated in a bipartite graph, where node[i]\n            //  matches with node[numBoxes + i] and represent the same box\n            graphEdges.put(numBoxes + i, new TreeMap<>());\n        }\n        for (int i = 0; i < boxes.size(); i++) {\n            // Boolean pointers are used so that backward edges (\"flow\") and\n            //  forward edges (\"capacity\") are updated in tandem, maintaining that\n            //  only one is active at any time.\n            sourceMap.put(i, new BooleanPtr(true)); // Source -> Node\n            graphEdges.get(numBoxes + i).put(SINK_INDEX, new BooleanPtr(true)); // Node -> Sink\n            for (int j = i + 1; j < boxes.size(); j++) {\n                if (fitsIn(boxes.get(i), boxes.get(j))) {\n                    BooleanVal opening = new BooleanPtr(true);\n                    graphEdges.get(i).put(numBoxes + j, opening); // Small box -> Big box\n                    graphEdges.get(numBoxes + j).put(i, new Negation(opening)); // Small box <- Big box\n                }\n            }\n        }\n        Deque<Integer> path; // Paths are represented as stacks where the top is the first node in the path\n        Set<Integer> visited = new HashSet<>(); // Giving the GC a break\n        // Each DFS pass takes out the capacity of one edge from the source\n        //  and adds a single edge to the bipartite matching generated.\n        // The algorithm automatically backtracks if a suboptimal maximal matching is found because\n        //  the path would take away edges and add new ones in if necessary.\n        // This happens when the path zigzags using N backward edges and (N + 1) forward edges -\n        //  removing a backward edge corresponds to removing a connection from the matching, and using extra\n        //  forward edges will add new connections to the matching.\n        // So if no more DFS passes are possible, then no amount of readjustment will increase the size\n        //  of the matching, so the number of passes equals the size of the maximum matching of the bipartite graph.\n        int numPasses = 0;\n        while ((path = depthFirstSearch(graphEdges, SOURCE_INDEX, SINK_INDEX, visited)) != null) {\n            visited.clear();\n            Integer current = SOURCE_INDEX;\n            path.pop();\n            for (Integer node : path) {\n                // Take out the edges visited.\n                //  Taking away any backward edges automatically adds back the corresponding forward edge,\n                //  and similarly removing a forward edge adds back the backward edge.\n                graphEdges.get(current).get(node).setBoolValue(false);\n                current = node;\n            }\n            numPasses++;\n        }\n\n        // Print out the stacks made from the boxes. Here, deleted forward edges / available backward edges\n        //  represent opportunities to nest boxes that have actually been used in the solution.\n        System.out.println(\"Box stacks:\");\n        visited.clear();\n        for (int i = 0; i < numBoxes; i++) {\n            Integer current = i;\n            if (visited.contains(current)) {\n                continue;\n            }\n            visited.add(current);\n            boolean halt = false;\n            while (!halt) {\n                halt = true;\n                System.out.print(boxes.get(current));\n                for (Map.Entry<Integer, BooleanVal> entry : graphEdges.get(current).entrySet()) {\n                    int neighbor = entry.getKey() - numBoxes;\n                    if (!visited.contains(neighbor) && !entry.getValue().getBoolValue()) {\n                        System.out.print(\"->\");\n                        visited.add(neighbor);\n                        current = neighbor;\n                        halt = false;\n                        break;\n                    }\n                }\n            }\n            System.out.println();\n        }\n        System.out.println();\n\n        // Let a box-stack be a set of any positive number boxes nested into one another, including 1.\n        // Beginning with each box-stack being a single box, we can nest them to reduce the box-stack count.\n        // Each DFS pass, or edge in the maximal matching, represents a single nesting opportunity that has\n        //  been used. Each used opportunity removes one from the number of box-stacks. so the total number\n        //  of box-stacks will be the number of boxes minus the number of passes.\n        System.out.println(\"Number of box-stacks: \" + (numBoxes - numPasses));\n    }\n\n    private static Deque<Integer> depthFirstSearch(Map<Integer, Map<Integer, BooleanVal>> graphEdges,\n                                           int source, int sink, Set<Integer> visited) {\n        if (source == sink) {\n            // Base case where the path visits only one node\n            Deque<Integer> result = new ArrayDeque<>();\n            result.push(sink);\n            return result;\n        }\n\n        // Get all the neighbors of the source node\n        Map<Integer, BooleanVal> neighbors = graphEdges.get(source);\n        for (Map.Entry<Integer, BooleanVal> entry : neighbors.entrySet()) {\n            Integer neighbor = entry.getKey();\n            if (!visited.contains(neighbor) && entry.getValue().getBoolValue()) {\n                // The neighbor hasn't been visited before, and the edge is active so the\n                //  DFS attempts to include this edge into the path.\n                visited.add(neighbor);\n                // Trying to find a path from the neighbor to the sink\n                Deque<Integer> path = depthFirstSearch(graphEdges, neighbor, sink, visited);\n                if (path != null) {\n                    // Adds the source onto the path found\n                    path.push(source);\n                    return path;\n                } else {\n                    // Pretend we never visited the neighbor and move on\n                    visited.remove(neighbor);\n                }\n            }\n        }\n        // No paths were found\n        return null;\n    }\n\n    // Interface for a mutable boolean value\n    private interface BooleanVal {\n        boolean getBoolValue();\n        void setBoolValue(boolean val);\n    }\n\n    // A boolean pointer\n    private static class BooleanPtr implements BooleanVal {\n        private boolean value;\n\n        public BooleanPtr(boolean value) {\n            this.value = value;\n        }\n\n        @Override\n        public boolean getBoolValue() {\n            return value;\n        }\n\n        @Override\n        public void setBoolValue(boolean value) {\n            this.value = value;\n        }\n\n        @Override\n        public String toString() {\n            return \"\" + value;\n        }\n    }\n\n    // The negation of a boolean value\n    private static class Negation implements BooleanVal {\n        private BooleanVal ptr;\n\n        public Negation(BooleanVal ptr) {\n            this.ptr = ptr;\n        }\n\n        @Override\n        public boolean getBoolValue() {\n            return !ptr.getBoolValue();\n        }\n\n        @Override\n        public void setBoolValue(boolean val) {\n            ptr.setBoolValue(!val);\n        }\n\n        @Override\n        public String toString() {\n            return \"\" + getBoolValue();\n        }\n    }\n\n    // Method to find if a rectangle strictly fits inside another\n    private static boolean fitsIn(Rectangle rec1, Rectangle rec2) {\n        return rec1.height < rec2.height && rec1.width < rec2.width;\n    }\n\n    // A helper class representing a rectangle, or the bottom of a box\n    private static class Rectangle {\n        public int width, height;\n\n        public Rectangle(int width, int height) {\n            this.width = width;\n            this.height = height;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", width, height);\n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nYes, there is a simpler (and a more efficient) solution.\n\nLet's sort the boxes by their width (and in reverse order of their height if the width of two boxes is the same). It is clear that we can nest a box only into a box that goes after it. Thus, we want to split it into multiple increasing subsequences (considering only heights now). There is a theorem that says that the minimum number of increasing subsequences the sequence can be split into is equal to the the length of the longest non-increasing (that is, not strictly decreasning subsequence). \n\nTo sum up, the solution goes like this:\n\n\nSort the boxes by their width. If the width is the same, compare them by their height in reverse order.\nThrow away the widths and just compute the length of the longest non-increasing subsequence of heights (in the order we've got after sorting). It's the answer to the problem. That's it.\n\n\nIt is clear that this solution can work in ```\nO(N log N)```\n time if implemented properly.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Pyspark Dataframe Efficient ways for O(n^2) Complexity Looping\r\n                \r\nI have a pyspark datafram as the following. I need to check the longest common subsequence between the text field (3rd column) and return a new dataframe that crosses a certain threshold in similarity value. So, the complexity in the simple array would be O(n^2). I was wondering how to get this effect for a distributed system using pyspark. I got one idea by using join on the data frame, however, it is very costly in terms of computation when the dataframe size increases. It would be great if you please provide some information about some efficient or 'right' way to do this.\n\n```\n--------------------------\npath | startline | text\n--------------------------\n p1  |      15   | hello\n--------------------------\n p2  |      8    | world\n--------------------------\n p3  |      5    | AAA\n--------------------------\n```\n\n\nMy current code structure is as follows:\n\n```\n#convert the pandas dataframe to pyspark dataframe\n#df was in csv format in pandas dataframe\nspark_dataframe = sqlContext.createDataFrame(df)\n\ndef lcs(row):\n    #need to run Longest common subsequence on texts from two rows\n    return (row.path, row.startline, row.text, lcs_sim)\n\ntransformed_spark_df = spark_df.rdd.map(lcs)\n```\n\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "Converted c++ code into javascript but return incorrect result\r\n                \r\nConverted c++ code to javascript, however it returns incorrect result. The c++ code is here. Below is my code\n\n```\n    function CeilIndex(A, l, r, key) {\n        var m;\n\n        while( r - l > 1 ) {\n            m = l + (r - l)/2;\n\n            if (A[m] >= key) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n\n        return r;\n    }\n\n\n    function LongestIncreasingSubsequenceLength(A, size) {\n        var tailTable = new Array(size);\n        var len;\n\n        tailTable[0] = A[0];\n\n        len = 1;\n\n        for (var i = 1; i < size; i++) {\n            if( A[i] < tailTable[0] ) {\n                tailTable[0] = A[i];\n            } else if( A[i] > tailTable[len-1] ) {\n                tailTable[len++] = A[i];\n            } else {\n                tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i];\n            }\n        }\n\n        return tailTable;\n    }\n\n    var A = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    var n = A.length;\n    console.log(\"Length of Longest Increasing Subsequence is: \",  LongestIncreasingSubsequenceLength(A, n));\n```\n\n\nWhen I execute above code it returns ```\nLength of Longest Increasing Subsequence is:  [0, 4, 2, 6, 1, 5, 3, 7, 15]```\n whereas its answer is ```\n[0, 2, 6, 9, 11, 15]```\n\n\nHow can I resolve this issue?\n    ", "Answer": "\r\n```\nm```\n becomes double in your code. All numbers are represented as doubles internally in JS. Should be truncated to int, I guess?\nThe following code seems to work.\n\n```\nfunction CeilIndex(A, l, r, key) {\n    var m;\n\n    while( r - l > 1 ) {\n        m = Math.floor(l + (r - l)/2);\n\n        if (A[m] >= key) {\n            r = m;\n        } else {\n            l = m;\n        }\n    }\n\n    return r;\n}\n```\n\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "\"Javascript heap out of memory\" using Lodash memoize\r\n                \r\nI'm trying to solve LeetCode's longest palindromic subsequence problem using Javascript by applying memoization to a recursive solution. Here is the recursive solution, ```\nlongestPalindromicSubsequence.js```\n:\n\n```\nfunction longestPalindromicSubsequence(string, start = 0, end = string.length) {\n  if (end < start) { return 0; }\n  if (start === end) { return 1; }\n  if (string[start] === string[end]) {\n    return 2 + longestPalindromicSubsequence(string, start + 1, end - 1);\n  }\n  return Math.max(\n    longestPalindromicSubsequence(string, start + 1, end),\n    longestPalindromicSubsequence(string, start, end - 1),\n  );\n}\n\nmodule.exports = longestPalindromicSubsequence;\n```\n\n\nHere are some Jest test cases for it, ```\nlongestPalindromicSubsequence.test.js```\n:\n\n```\nconst longestPalindromicSubsequence = require('./longestPalindromicSubsequence');\n\ndescribe('longest palindromic subsequence', () => {\n  test('works for aab', () => {\n    expect(longestPalindromicSubsequence('aab')).toBe(2);\n  });\n\n  test('works for long string', () => {\n    expect(longestPalindromicSubsequence(`${'a'.repeat(50)}bcdef`)).toBe(50);\n  });\n});\n```\n\n\nThis works, but is rather slow due to the exponential increase in the number of recursive calls. For example, for a string of length ~50 it takes 9 seconds:\n\n```\n$ jest longestPalindromicSubsequence.test.js\n PASS  ./longestPalindromicSubsequence.test.js (9.6s)\n  longest palindromic subsequence\n    ✓ works for aab (3ms)\n    ✓ works for long string (9315ms)\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        10.039s\nRan all test suites matching /longestPalindromicSubsequence.test.js/i.\n```\n\n\nTo improve this performance, I tried using ```\n_.memoize```\n in an updated module ```\nlongestPalindromicSubsequence2.js```\n:\n\n```\nconst _ = require('lodash');\n\nconst longestPalindromicSubsequence = _.memoize(\n  (string, start = 0, end = string.length) => {\n    if (end < start) { return 0; }\n    if (start === end) { return 1; }\n    if (string[start] === string[end]) {\n      return 2 + longestPalindromicSubsequence(string, start + 1, end - 1);\n    }\n    return Math.max(\n      longestPalindromicSubsequence(string, start + 1, end),\n      longestPalindromicSubsequence(string, start, end - 1),\n    );\n  },\n  (string, start, end) => [string, start, end], // resolver function\n);\n\nmodule.exports = longestPalindromicSubsequence;\n```\n\n\nHowever, when I try to run the tests with this module, I get a \"Javascript heap out of memory\" error:\n\n```\n$ jest longestPalindromicSubsequence.test.js\n\n RUNS  ./longestPalindromicSubsequence.test.js\n\n<--- Last few GCs --->\nat[89308:0x104801e00]    15800 ms: Mark-sweep 1379.2 (1401.3) -> 1379.2 (1401.3) MB, 1720.4 / 0.0 ms  (+ 0.0 ms in 5 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 1735 ms) (average mu = 0.128, current mu = 0.057) allocat[89308:0x104801e00]    17606 ms: Mark-sweep 1390.0 (1412.3) -> 1390.0 (1412.3) MB, 1711.7 / 0.0 ms  (+ 0.0 ms in 4 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 1764 ms) (average mu = 0.091, current mu = 0.052) allocat\n\n<--- JS stacktrace --->\n\n==== JS stack trace =========================================\n\n    0: ExitFrame [pc: 0x20b000bdc01d]\nSecurity context: 0x1c189571e549 <JSObject>\n    1: /* anonymous */ [0x1c18f7682201] [/Users/kurtpeek/GoogleDrive/LeetCode/longestPalindromicSubsequence2.js:~14] [pc=0x20b0015cd091](this=0x1c18d38893a1 <JSGlobal Object>,string=0x1c18f7682271 <String[55]: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcdef>,start=45,end=45)\n    2: memoized [0x1c18f7682309] [/Users/kurtpeek/GoogleDrive/LeetCode/node_...\n\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\n 1: 0x100037733 node::Abort() [/usr/local/bin/node]\n 2: 0x1000378d6 node::FatalTryCatch::~FatalTryCatch() [/usr/local/bin/node]\n 3: 0x10018e57b v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [/usr/local/bin/node]\n 4: 0x10018e51c v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [/usr/local/bin/node]\n 5: 0x1004682ee v8::internal::Heap::UpdateSurvivalStatistics(int) [/usr/local/bin/node]\n 6: 0x100469ed7 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [/usr/local/bin/node]\n 7: 0x1004675cb v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [/usr/local/bin/node]\n 8: 0x1004663e6 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [/usr/local/bin/node]\n 9: 0x10046eafc v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [/usr/local/bin/node]\n10: 0x10046eb48 v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [/usr/local/bin/node]\n11: 0x10044eb7a v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [/usr/local/bin/node]\n12: 0x100634916 v8::internal::Runtime_AllocateInTargetSpace(int, v8::internal::Object**, v8::internal::Isolate*) [/usr/local/bin/node]\n13: 0x20b000bdc01d \nAbort trap: 6\n```\n\n\nAs I understand from Node.js heap out of memory, the standard memory usage for Node is 1.7GB, which I reckon should be sufficient. Any ideas why the memoized version is not working, and on how to fix it?\n    ", "Answer": "\r\nI managed to fix the problem by changing the resolver function from ```\n(string, start, end) => [string, start, end]```\n to ```\n(string, start, end) => string + start + end```\n:\n\n```\nconst _ = require('lodash');\n\nconst longestPalindromicSubsequence = _.memoize(\n  (string, start = 0, end = string.length) => {\n    if (end < start) { return 0; }\n    if (start === end) { return 1; }\n    if (string[start] === string[end]) {\n      return 2 + longestPalindromicSubsequence(string, start + 1, end - 1);\n    }\n    return Math.max(\n      longestPalindromicSubsequence(string, start + 1, end),\n      longestPalindromicSubsequence(string, start, end - 1),\n    );\n  },\n  (string, start, end) => string + start + end, // resolver function\n);\n\nmodule.exports = longestPalindromicSubsequence;\n```\n\n\nNow the 'long string' test takes only 3ms:\n\n```\n$ jest longestPalindromicSubsequence.test.js\n PASS  ./longestPalindromicSubsequence.test.js\n  longest palindromic subsequence\n    ✓ works for aab (3ms)\n    ✓ works for long string (3ms)\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        1.004s, estimated 10s\nRan all test suites matching /longestPalindromicSubsequence.test.js/i.\n```\n\n\nIt would appear that using a string as a key into the cache is much more memory-efficient than using an array - perhaps because strings are immutable in Javascript? Any explanations of this improvement would be welcome.\n    ", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
{"Question": "What are the differences in time and space complexity between these 2 algorithms that solve leetcode 873?\r\n                \r\nI have just solved https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/. The objective is to find the longest Fibonacci sub-sequence in an array of strictly increasing integers.\n\nI need some help figuring out the difference in time and space complexity between my solution and the \"optimal\" one that I got off the solutions section of leetcode.\n\n1- My algorithm:\n\n```\nclass Solution:\n    def lenLongestFibSubseq(self, A):\n        dp = [collections.defaultdict(int) for i in range(len(A))]\n        res = 2\n        for j in range(len(A)):\n            for i in range(j):\n                prev = dp[i].get(A[j], 0)\n                prev = 2 if not prev else prev+1\n                dp[j][A[j]+A[i]] = prev\n                res = max(res, prev)\n        return res if res > 2 else 0\n```\n\n\n2- \"Optimal\" algorithm:\n\n```\nclass Solution:\n    def lenLongestFibSubseq(self, A):\n        dp = collections.defaultdict(int)\n        s = set(A)\n        for j in range(len(A)):\n            for i in range(j):\n                if A[j] - A[i] < A[i] and A[j] - A[i] in s:\n                    dp[A[i], A[j]] = dp.get((A[j] - A[i], A[i]), 2) + 1\n        return max(dp.values() or [0])\n```\n\n\nTime complexity is easy --> they are both ```\nO(n^2)```\n\n\nFor space complexity I think both are ```\nO(n^2)```\n at least mine is for sure, since for each index I maintain a dict whose size is equal to ```\nindex-1```\n. \n\nHowever the \"optimal\" algorithm seems like it is ```\nO(n^2)```\n space too since he is caching one value for all pairs ```\n[A[i], A[j]]```\n. \n\nI am here because the online judge rates my solution as 4 times slower ```\n2000ms```\n vs ```\n500ms```\n and 3 times as space consuming ```\n45Mb```\n vs ```\n15Mb```\n. I might be missing something big, any help is welcome.\n    ", "Answer": "", "Knowledge_point": "Longest Increasing Subsequence", "Tag": "算法分析"}
